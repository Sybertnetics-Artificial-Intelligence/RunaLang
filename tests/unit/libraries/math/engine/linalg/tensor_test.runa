Note:
tests/unit/libraries/math/engine/linalg/tensor_test.runa
Comprehensive Unit Tests for Tensor Operations Module

This test suite provides complete coverage for the math/engine/linalg/tensor module,
testing all 67 functions across tensor creation, manipulation, decompositions,
sparse operations, tensor networks, and advanced mathematical operations.

Test Categories:
- Tensor Creation Operations (5 tests)
- Tensor Basic Operations (5 tests)
- Tensor Shape Manipulation (6 tests)
- Tensor Indexing and Slicing (4 tests)
- Tensor Contraction Operations (4 tests)
- Tensor Decomposition Operations (6 tests)
- Sparse Tensor Operations (5 tests)
- Tensor Reduction Operations (5 tests)
- Tensor Network Operations (4 tests)
- Tensor Calculus Operations (5 tests)
- Broadcasting Operations (7 tests)
- Tensor Comparison Operations (4 tests)
- Tensor Utility Operations (5 tests)
- Helper Function Operations (8 tests)

Total: 73 comprehensive test functions covering all tensor functionality
:End Note

Import "dev/test" as UnitTest
Import "math/engine/linalg/tensor" as Tensor
Import "math/core/operations" as Operations
Import "collections" as Collections
Import "datetime" as DateTime

Note: =====================================================================
Note: TEST DATA HELPERS
Note: =====================================================================

Process called "create_test_tensor_2x3" returns List[List[String]]:
    Note: Create 2x3 test tensor data
    Let tensor_data be List[List[String]]
    Let row1 be List[String]().append("1.0").append("2.0").append("3.0")
    Let row2 be List[String]().append("4.0").append("5.0").append("6.0")
    Let tensor_data be tensor_data.append(row1).append(row2)
    Return tensor_data

Process called "create_test_tensor_3x2x2" returns List[List[List[String]]]:
    Note: Create 3x2x2 test tensor data (3D)
    Let tensor_data be List[List[List[String]]]
    
    Note: First 2x2 matrix
    Let matrix1 be List[List[String]]
    Let matrix1 be matrix1.append(List[String]().append("1.0").append("2.0"))
    Let matrix1 be matrix1.append(List[String]().append("3.0").append("4.0"))
    
    Note: Second 2x2 matrix
    Let matrix2 be List[List[String]]
    Let matrix2 be matrix2.append(List[String]().append("5.0").append("6.0"))
    Let matrix2 be matrix2.append(List[String]().append("7.0").append("8.0"))
    
    Note: Third 2x2 matrix
    Let matrix3 be List[List[String]]
    Let matrix3 be matrix3.append(List[String]().append("9.0").append("10.0"))
    Let matrix3 be matrix3.append(List[String]().append("11.0").append("12.0"))
    
    Let tensor_data be tensor_data.append(matrix1).append(matrix2).append(matrix3)
    Return tensor_data

Process called "create_test_tensor_shape" returns List[Integer]:
    Note: Create test tensor shape [2, 3]
    Let shape be List[Integer]
    Let shape be shape.append(2).append(3)
    Return shape

Process called "create_test_tensor_shape_3d" returns List[Integer]:
    Note: Create test 3D tensor shape [3, 2, 2]
    Let shape be List[Integer]
    Let shape be shape.append(3).append(2).append(2)
    Return shape

Process called "create_sparse_tensor_indices" returns List[List[Integer]]:
    Note: Create sparse tensor indices for 3x3 tensor
    Let indices be List[List[Integer]]
    Let indices be indices.append(List[Integer]().append(0).append(0))
    Let indices be indices.append(List[Integer]().append(1).append(1))
    Let indices be indices.append(List[Integer]().append(2).append(2))
    Return indices

Process called "create_sparse_tensor_values" returns List[String]:
    Note: Create sparse tensor values
    Let values be List[String]
    Let values be values.append("1.0").append("5.0").append("9.0")
    Return values

Process called "create_tensor_network_data" returns Dictionary[String, List[Dictionary[String, String]]]:
    Note: Create tensor network connection data
    Let network_data be Dictionary[String, List[Dictionary[String, String]]]
    Let connections be List[Dictionary[String, String]]
    
    Let conn1 be Dictionary[String, String]
    Let conn1 be conn1.set("tensor1", "0").set("axis1", "1").set("tensor2", "1").set("axis2", "0")
    Let connections be connections.append(conn1)
    
    Let network_data be network_data.set("connections", connections)
    Return network_data

Note: =====================================================================
Note: ASSERTION HELPERS
Note: =====================================================================

Process called "assert_numerical_close" that takes actual as String, expected as String, tolerance as Float, message as String:
    Note: Assert two numerical values are close within tolerance
    Let actual_val be Operations.convert_to_float(actual)
    Let expected_val be Operations.convert_to_float(expected)
    Let diff be Operations.absolute_value(Operations.subtract(actual, expected, 15).result)
    Let diff_val be Operations.convert_to_float(diff)
    UnitTest.assert_true(diff_val < tolerance, message ++ " - expected: " ++ expected ++ ", actual: " ++ actual)

Process called "assert_tensor_valid" that takes tensor as Tensor.Tensor, expected_shape as List[Integer]:
    Note: Assert tensor is valid and has expected shape
    UnitTest.assert_not_null(tensor, "Tensor should not be null")
    UnitTest.assert_not_null(tensor.shape, "Tensor shape should not be null")
    UnitTest.assert_equal(tensor.shape.dimensions.size(), expected_shape.size(), "Tensor rank should match expected")
    
    For i in range(0, expected_shape.size()):
        UnitTest.assert_equal(tensor.shape.dimensions[i], expected_shape[i], 
                            "Dimension " ++ i.to_string() ++ " should match")

Process called "assert_tensor_data_close" that takes actual_tensor as Tensor.Tensor, expected_data as List[String], tolerance as Float:
    Note: Assert tensor data values are numerically close
    Let flattened_data be Tensor.flatten_tensor(actual_tensor, 0, -1)
    UnitTest.assert_equal(flattened_data.data.size(), expected_data.size(), "Data size should match")
    
    For i in range(0, expected_data.size()):
        assert_numerical_close(flattened_data.data[i], expected_data[i], tolerance, 
                             "Element " ++ i.to_string())

Process called "assert_decomposition_valid" that takes decomposition as Tensor.TensorDecomposition, original_tensor as Tensor.Tensor:
    Note: Assert tensor decomposition is valid
    UnitTest.assert_not_null(decomposition, "Decomposition should not be null")
    UnitTest.assert_not_null(decomposition.factors, "Decomposition factors should not be null")
    UnitTest.assert_true(decomposition.reconstruction_error >= 0.0, "Reconstruction error should be non-negative")

Process called "assert_sparse_tensor_valid" that takes sparse_tensor as Tensor.SparseTensor, expected_nnz as Integer:
    Note: Assert sparse tensor is valid
    UnitTest.assert_not_null(sparse_tensor, "Sparse tensor should not be null")
    UnitTest.assert_not_null(sparse_tensor.indices, "Indices should not be null")
    UnitTest.assert_not_null(sparse_tensor.values, "Values should not be null")
    UnitTest.assert_equal(sparse_tensor.values.size(), expected_nnz, "Should have expected number of non-zeros")

Process called "assert_tensor_network_valid" that takes network as Tensor.TensorNetwork:
    Note: Assert tensor network is valid
    UnitTest.assert_not_null(network, "Tensor network should not be null")
    UnitTest.assert_not_null(network.nodes, "Network nodes should not be null")
    UnitTest.assert_not_null(network.edges, "Network edges should not be null")
    UnitTest.assert_true(network.nodes.size() > 0, "Should have at least one node")

Note: =====================================================================
Note: TENSOR CREATION TESTS
Note: =====================================================================

Process called "test_create_tensor":
    Note: Test tensor creation from data array
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let data_type be "Float32"
    
    Let tensor be Tensor.create_tensor(data, shape, data_type, "dense")
    
    assert_tensor_valid(tensor, shape)
    UnitTest.assert_equal(tensor.data_type, data_type, "Data type should match")
    UnitTest.assert_equal(tensor.storage_format, "dense", "Storage format should be dense")

Process called "test_zeros_tensor":
    Note: Test creation of tensor filled with zeros
    Let shape be create_test_tensor_shape()
    Let data_type be "Float32"
    
    Let zeros_tensor be Tensor.zeros_tensor(shape, data_type)
    
    assert_tensor_valid(zeros_tensor, shape)
    Note: Check that all elements are zero
    Let flattened be Tensor.flatten_tensor(zeros_tensor, 0, -1)
    For i in range(0, flattened.data.size()):
        assert_numerical_close(flattened.data[i], "0.0", 1e-12, "Element should be zero")

Process called "test_ones_tensor":
    Note: Test creation of tensor filled with ones
    Let shape be create_test_tensor_shape()
    Let data_type be "Float32"
    
    Let ones_tensor be Tensor.ones_tensor(shape, data_type)
    
    assert_tensor_valid(ones_tensor, shape)
    Note: Check that all elements are one
    Let flattened be Tensor.flatten_tensor(ones_tensor, 0, -1)
    For i in range(0, flattened.data.size()):
        assert_numerical_close(flattened.data[i], "1.0", 1e-12, "Element should be one")

Process called "test_random_tensor":
    Note: Test creation of tensor with random values
    Let shape be create_test_tensor_shape()
    Let distribution be "uniform"
    Let min_val be 0.0
    Let max_val be 1.0
    
    Let random_tensor be Tensor.random_tensor(shape, distribution, min_val, max_val, "Float32")
    
    assert_tensor_valid(random_tensor, shape)
    Note: Check that values are in expected range
    Let flattened be Tensor.flatten_tensor(random_tensor, 0, -1)
    For i in range(0, flattened.data.size()):
        Let val be Operations.convert_to_float(flattened.data[i])
        UnitTest.assert_true(val >= min_val and val <= max_val, "Random value should be in range")

Process called "test_identity_tensor":
    Note: Test creation of identity tensor
    Let size be 3
    Let data_type be "Float32"
    
    Let identity_tensor be Tensor.identity_tensor(size, data_type)
    
    Let expected_shape be List[Integer]().append(size).append(size)
    assert_tensor_valid(identity_tensor, expected_shape)
    
    Note: Check diagonal elements are 1 and off-diagonal are 0
    Let dense_data be Tensor.sparse_to_dense(identity_tensor)
    For i in range(0, size):
        For j in range(0, size):
            If i == j:
                assert_numerical_close(dense_data.data[i * size + j], "1.0", 1e-12, "Diagonal should be 1")
            Otherwise:
                assert_numerical_close(dense_data.data[i * size + j], "0.0", 1e-12, "Off-diagonal should be 0")

Note: =====================================================================
Note: TENSOR BASIC OPERATIONS TESTS
Note: =====================================================================

Process called "test_tensor_add":
    Note: Test element-wise tensor addition
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor_a be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let tensor_b be Tensor.create_tensor(data, shape, "Float32", "dense")
    
    Let result be Tensor.tensor_add(tensor_a, tensor_b)
    
    assert_tensor_valid(result, shape)
    Note: Check that result is 2 * original
    Let expected_data be List[String]
    Let expected_data be expected_data.append("2.0").append("4.0").append("6.0").append("8.0").append("10.0").append("12.0")
    assert_tensor_data_close(result, expected_data, 1e-12)

Process called "test_tensor_multiply":
    Note: Test element-wise tensor multiplication
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor_a be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let tensor_b be Tensor.create_tensor(data, shape, "Float32", "dense")
    
    Let result be Tensor.tensor_multiply(tensor_a, tensor_b)
    
    assert_tensor_valid(result, shape)
    Note: Check that result is element-wise square
    Let expected_data be List[String]
    Let expected_data be expected_data.append("1.0").append("4.0").append("9.0").append("16.0").append("25.0").append("36.0")
    assert_tensor_data_close(result, expected_data, 1e-12)

Process called "test_tensor_subtract":
    Note: Test element-wise tensor subtraction
    Let data1 be create_test_tensor_2x3()
    Let data2 be List[List[String]]
    Let data2 be data2.append(List[String]().append("1.0").append("1.0").append("1.0"))
    Let data2 be data2.append(List[String]().append("1.0").append("1.0").append("1.0"))
    Let shape be create_test_tensor_shape()
    
    Let tensor_a be Tensor.create_tensor(data1, shape, "Float32", "dense")
    Let tensor_b be Tensor.create_tensor(data2, shape, "Float32", "dense")
    
    Let result be Tensor.tensor_subtract(tensor_a, tensor_b)
    
    assert_tensor_valid(result, shape)
    Let expected_data be List[String]
    Let expected_data be expected_data.append("0.0").append("1.0").append("2.0").append("3.0").append("4.0").append("5.0")
    assert_tensor_data_close(result, expected_data, 1e-12)

Process called "test_tensor_divide":
    Note: Test element-wise tensor division
    Let data1 be create_test_tensor_2x3()
    Let data2 be List[List[String]]
    Let data2 be data2.append(List[String]().append("2.0").append("2.0").append("2.0"))
    Let data2 be data2.append(List[String]().append("2.0").append("2.0").append("2.0"))
    Let shape be create_test_tensor_shape()
    
    Let tensor_a be Tensor.create_tensor(data1, shape, "Float32", "dense")
    Let tensor_b be Tensor.create_tensor(data2, shape, "Float32", "dense")
    
    Let result be Tensor.tensor_divide(tensor_a, tensor_b)
    
    assert_tensor_valid(result, shape)
    Let expected_data be List[String]
    Let expected_data be expected_data.append("0.5").append("1.0").append("1.5").append("2.0").append("2.5").append("3.0")
    assert_tensor_data_close(result, expected_data, 1e-12)

Process called "test_scalar_multiply":
    Note: Test scalar multiplication of tensor
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let scalar be "2.5"
    
    Let result be Tensor.scalar_multiply(tensor, scalar)
    
    assert_tensor_valid(result, shape)
    Let expected_data be List[String]
    Let expected_data be expected_data.append("2.5").append("5.0").append("7.5").append("10.0").append("12.5").append("15.0")
    assert_tensor_data_close(result, expected_data, 1e-12)

Note: =====================================================================
Note: TENSOR SHAPE MANIPULATION TESTS
Note: =====================================================================

Process called "test_reshape_tensor":
    Note: Test tensor reshaping to new dimensions
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let new_shape be List[Integer]().append(3).append(2)
    
    Let reshaped be Tensor.reshape_tensor(tensor, new_shape)
    
    assert_tensor_valid(reshaped, new_shape)
    Note: Data should be preserved but arranged differently
    UnitTest.assert_equal(Tensor.flatten_tensor(reshaped, 0, -1).data.size(), 6, "Should preserve element count")

Process called "test_transpose_tensor":
    Note: Test tensor transpose along specified axes
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let axes be List[Integer]().append(1).append(0)
    
    Let transposed be Tensor.transpose_tensor(tensor, axes)
    
    Let expected_shape be List[Integer]().append(3).append(2)
    assert_tensor_valid(transposed, expected_shape)

Process called "test_squeeze_tensor":
    Note: Test removal of single-dimensional entries
    Let shape_with_singleton be List[Integer]().append(1).append(2).append(3).append(1)
    Let data be List[List[List[List[String]]]]
    Note: Create 4D tensor with singleton dimensions
    Let tensor be Tensor.zeros_tensor(shape_with_singleton, "Float32")
    
    Let squeezed be Tensor.squeeze_tensor(tensor, List[Integer]())
    
    Let expected_shape be List[Integer]().append(2).append(3)
    assert_tensor_valid(squeezed, expected_shape)

Process called "test_expand_dims":
    Note: Test adding dimensions to tensor
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let axis be 0
    
    Let expanded be Tensor.expand_dims(tensor, axis)
    
    Let expected_shape be List[Integer]().append(1).append(2).append(3)
    assert_tensor_valid(expanded, expected_shape)

Process called "test_flatten_tensor":
    Note: Test tensor flattening between specified axes
    Let data be create_test_tensor_3x2x2()
    Let shape be create_test_tensor_shape_3d()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let start_axis be 1
    Let end_axis be 2
    
    Let flattened be Tensor.flatten_tensor(tensor, start_axis, end_axis)
    
    Let expected_shape be List[Integer]().append(3).append(4)  Note: 2*2=4
    assert_tensor_valid(flattened, expected_shape)

Process called "test_slice_tensor":
    Note: Test tensor slicing
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let start_indices be List[Integer]().append(0).append(1)
    Let end_indices be List[Integer]().append(2).append(3)
    
    Let sliced be Tensor.slice_tensor(tensor, start_indices, end_indices)
    
    Let expected_shape be List[Integer]().append(2).append(2)
    assert_tensor_valid(sliced.result_tensor, expected_shape)

Note: =====================================================================
Note: TENSOR INDEXING AND SLICING TESTS
Note: =====================================================================

Process called "test_index_tensor":
    Note: Test tensor indexing with specific indices
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let indices be List[Integer]().append(1).append(2)
    
    Let indexed_value be Tensor.index_tensor(tensor, indices)
    
    UnitTest.assert_not_null(indexed_value, "Indexed value should not be null")
    assert_numerical_close(indexed_value, "6.0", 1e-12, "Should get value at [1,2]")

Process called "test_mask_tensor":
    Note: Test applying boolean mask to tensor
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let mask_data be List[List[String]]
    Let mask_data be mask_data.append(List[String]().append("1").append("0").append("1"))
    Let mask_data be mask_data.append(List[String]().append("0").append("1").append("0"))
    Let mask be Tensor.create_tensor(mask_data, shape, "Boolean", "dense")
    
    Let masked be Tensor.mask_tensor(tensor, mask)
    
    UnitTest.assert_not_null(masked, "Masked tensor should not be null")

Process called "test_gather_tensor":
    Note: Test gathering elements along axis using indices
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let axis be 1
    Let indices be List[Integer]().append(0).append(2)
    
    Let gathered be Tensor.gather_tensor(tensor, indices, axis)
    
    Let expected_shape be List[Integer]().append(2).append(2)
    assert_tensor_valid(gathered, expected_shape)

Process called "test_scatter_tensor":
    Note: Test scattering updates to tensor using indices
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let indices be List[List[Integer]]
    Let indices be indices.append(List[Integer]().append(0).append(0))
    Let updates be List[String]().append("10.0")
    
    Let scattered be Tensor.scatter_tensor(tensor, indices, updates, 0)
    
    assert_tensor_valid(scattered, shape)
    Let indexed_value be Tensor.index_tensor(scattered, List[Integer]().append(0).append(0))
    assert_numerical_close(indexed_value, "10.0", 1e-12, "Should update value at [0,0]")

Note: =====================================================================
Note: TENSOR CONTRACTION TESTS
Note: =====================================================================

Process called "test_tensor_dot":
    Note: Test tensor dot product with specified axes
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor_a be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let data_b be List[List[String]]
    Let data_b be data_b.append(List[String]().append("1.0").append("2.0"))
    Let data_b be data_b.append(List[String]().append("3.0").append("4.0"))
    Let data_b be data_b.append(List[String]().append("5.0").append("6.0"))
    Let shape_b be List[Integer]().append(3).append(2)
    Let tensor_b be Tensor.create_tensor(data_b, shape_b, "Float32", "dense")
    Let axes_a be List[Integer]().append(1)
    Let axes_b be List[Integer]().append(0)
    
    Let dot_product be Tensor.tensor_dot(tensor_a, tensor_b, axes_a, axes_b)
    
    Let expected_shape be List[Integer]().append(2).append(2)
    assert_tensor_valid(dot_product, expected_shape)

Process called "test_einstein_sum":
    Note: Test Einstein summation notation operations
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor_a be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let tensor_b be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let tensors be List[Tensor.Tensor]().append(tensor_a).append(tensor_b)
    Let subscripts be "ij,ij->ij"
    
    Let result be Tensor.einstein_sum(tensors, subscripts)
    
    assert_tensor_valid(result, shape)

Process called "test_outer_product":
    Note: Test outer product of two tensors
    Let vector_a be Tensor.ones_tensor(List[Integer]().append(3), "Float32")
    Let vector_b be Tensor.ones_tensor(List[Integer]().append(2), "Float32")
    
    Let outer_prod be Tensor.outer_product(vector_a, vector_b)
    
    Let expected_shape be List[Integer]().append(3).append(2)
    assert_tensor_valid(outer_prod, expected_shape)

Process called "test_kronecker_product":
    Note: Test Kronecker product of tensors
    Let data_a be List[List[String]]
    Let data_a be data_a.append(List[String]().append("1.0").append("2.0"))
    Let data_a be data_a.append(List[String]().append("3.0").append("4.0"))
    Let tensor_a be Tensor.create_tensor(data_a, List[Integer]().append(2).append(2), "Float32", "dense")
    Let tensor_b be Tensor.create_tensor(data_a, List[Integer]().append(2).append(2), "Float32", "dense")
    
    Let kronecker_prod be Tensor.kronecker_product(tensor_a, tensor_b)
    
    Let expected_shape be List[Integer]().append(4).append(4)
    assert_tensor_valid(kronecker_prod, expected_shape)

Note: =====================================================================
Note: TENSOR DECOMPOSITION TESTS
Note: =====================================================================

Process called "test_tensor_trace":
    Note: Test tensor trace computation
    Let data = List[List[String]]
    Let data be data.append(List[String]().append("1.0").append("2.0"))
    Let data be data.append(List[String]().append("3.0").append("4.0"))
    Let tensor be Tensor.create_tensor(data, List[Integer]().append(2).append(2), "Float32", "dense")
    Let axes be List[Integer]().append(0).append(1)
    
    Let trace be Tensor.tensor_trace(tensor, axes)
    
    assert_numerical_close(trace, "5.0", 1e-12, "Trace should be 1.0 + 4.0 = 5.0")

Process called "test_tensor_svd":
    Note: Test singular value decomposition
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    
    Let svd_result be Tensor.tensor_svd(tensor, false)
    
    UnitTest.assert_not_null(svd_result, "SVD result should not be null")
    UnitTest.assert_true(Collections.contains_key(svd_result, "U"), "Should contain U matrix")
    UnitTest.assert_true(Collections.contains_key(svd_result, "S"), "Should contain singular values")
    UnitTest.assert_true(Collections.contains_key(svd_result, "V"), "Should contain V matrix")

Process called "test_cp_decomposition":
    Note: Test CANDECOMP/PARAFAC decomposition
    Let data be create_test_tensor_3x2x2()
    Let shape be create_test_tensor_shape_3d()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let rank be 2
    Let max_iterations be 100
    Let tolerance be 1e-6
    
    Let cp_decomp be Tensor.cp_decomposition(tensor, rank, max_iterations, tolerance)
    
    assert_decomposition_valid(cp_decomp, tensor)
    UnitTest.assert_equal(cp_decomp.factors.size(), 3, "Should have 3 factor matrices for 3D tensor")

Process called "test_tucker_decomposition":
    Note: Test Tucker decomposition
    Let data be create_test_tensor_3x2x2()
    Let shape be create_test_tensor_shape_3d()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let core_shape be List[Integer]().append(2).append(2).append(2)
    
    Let tucker_decomp be Tensor.tucker_decomposition(tensor, core_shape)
    
    assert_decomposition_valid(tucker_decomp, tensor)
    UnitTest.assert_not_null(tucker_decomp.core_tensor, "Should contain core tensor")

Process called "test_hosvd":
    Note: Test Higher-Order Singular Value Decomposition
    Let data be create_test_tensor_3x2x2()
    Let shape be create_test_tensor_shape_3d()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let truncation_ranks be List[Integer]().append(2).append(2).append(2)
    
    Let hosvd_result be Tensor.hosvd(tensor, truncation_ranks)
    
    assert_decomposition_valid(hosvd_result, tensor)
    UnitTest.assert_not_null(hosvd_result.core_tensor, "Should contain core tensor")

Process called "test_tensor_train_decomposition":
    Note: Test Tensor Train decomposition
    Let data be create_test_tensor_3x2x2()
    Let shape be create_test_tensor_shape_3d()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let max_ranks be List[Integer]().append(2).append(2)
    
    Let tt_decomp be Tensor.tensor_train_decomposition(tensor, max_ranks, 1e-6)
    
    assert_decomposition_valid(tt_decomp, tensor)
    UnitTest.assert_true(tt_decomp.factors.size() > 0, "Should have TT cores")

Note: =====================================================================
Note: SPARSE TENSOR TESTS
Note: =====================================================================

Process called "test_create_sparse_tensor":
    Note: Test sparse tensor creation from indices and values
    Let indices be create_sparse_tensor_indices()
    Let values be create_sparse_tensor_values()
    Let shape be List[Integer]().append(3).append(3)
    
    Let sparse_tensor be Tensor.create_sparse_tensor(indices, values, shape)
    
    assert_sparse_tensor_valid(sparse_tensor, 3)
    UnitTest.assert_equal(sparse_tensor.shape.dimensions, shape, "Shape should match")

Process called "test_sparse_tensor_add":
    Note: Test addition of two sparse tensors
    Let indices be create_sparse_tensor_indices()
    Let values be create_sparse_tensor_values()
    Let shape be List[Integer]().append(3).append(3)
    Let sparse_a be Tensor.create_sparse_tensor(indices, values, shape)
    Let sparse_b be Tensor.create_sparse_tensor(indices, values, shape)
    
    Let result be Tensor.sparse_tensor_add(sparse_a, sparse_b)
    
    assert_sparse_tensor_valid(result, 3)
    Note: Values should be doubled
    For i in range(0, result.values.size()):
        Let expected_val be Operations.multiply(values[i], "2.0", 15).result
        assert_numerical_close(result.values[i], expected_val, 1e-12, "Added values should be doubled")

Process called "test_sparse_tensor_multiply":
    Note: Test multiplication of two sparse tensors
    Let indices be create_sparse_tensor_indices()
    Let values be create_sparse_tensor_values()
    Let shape be List[Integer]().append(3).append(3)
    Let sparse_a be Tensor.create_sparse_tensor(indices, values, shape)
    Let sparse_b be Tensor.create_sparse_tensor(indices, values, shape)
    
    Let result be Tensor.sparse_tensor_multiply(sparse_a, sparse_b)
    
    assert_sparse_tensor_valid(result, 3)

Process called "test_sparse_to_dense":
    Note: Test conversion of sparse tensor to dense
    Let indices be create_sparse_tensor_indices()
    Let values be create_sparse_tensor_values()
    Let shape be List[Integer]().append(3).append(3)
    Let sparse_tensor be Tensor.create_sparse_tensor(indices, values, shape)
    
    Let dense_tensor be Tensor.sparse_to_dense(sparse_tensor)
    
    assert_tensor_valid(dense_tensor, shape)
    Note: Check diagonal values
    Let indexed_val_00 be Tensor.index_tensor(dense_tensor, List[Integer]().append(0).append(0))
    assert_numerical_close(indexed_val_00, "1.0", 1e-12, "Should have value 1.0 at [0,0]")

Process called "test_dense_to_sparse":
    Note: Test conversion of dense tensor to sparse
    Let data be List[List[String]]
    Let data be data.append(List[String]().append("1.0").append("0.0").append("0.0"))
    Let data be data.append(List[String]().append("0.0").append("5.0").append("0.0"))
    Let data be data.append(List[String]().append("0.0").append("0.0").append("9.0"))
    Let dense_tensor be Tensor.create_tensor(data, List[Integer]().append(3).append(3), "Float32", "dense")
    Let threshold be 1e-12
    
    Let sparse_tensor be Tensor.dense_to_sparse(dense_tensor, threshold)
    
    assert_sparse_tensor_valid(sparse_tensor, 3)
    UnitTest.assert_true(sparse_tensor.density < 1.0, "Should have low density")

Note: =====================================================================
Note: TENSOR REDUCTION TESTS
Note: =====================================================================

Process called "test_reduce_sum":
    Note: Test sum reduction along axes
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let axes be List[Integer]().append(1)
    
    Let sum_result be Tensor.reduce_sum(tensor, axes, false)
    
    Let expected_shape be List[Integer]().append(2)
    assert_tensor_valid(sum_result, expected_shape)
    Note: Row sums should be [6.0, 15.0]
    Let indexed_val_0 be Tensor.index_tensor(sum_result, List[Integer]().append(0))
    assert_numerical_close(indexed_val_0, "6.0", 1e-12, "First row sum should be 6.0")

Process called "test_reduce_mean":
    Note: Test mean reduction along axes
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let axes be List[Integer]().append(0)
    
    Let mean_result be Tensor.reduce_mean(tensor, axes, false)
    
    Let expected_shape be List[Integer]().append(3)
    assert_tensor_valid(mean_result, expected_shape)

Process called "test_reduce_max":
    Note: Test maximum reduction along axes
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let axes be List[Integer]().append(1)
    
    Let max_result be Tensor.reduce_max(tensor, axes, false)
    
    Let expected_shape be List[Integer]().append(2)
    assert_tensor_valid(max_result, expected_shape)

Process called "test_reduce_min":
    Note: Test minimum reduction along axes
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let axes be List[Integer]().append(1)
    
    Let min_result be Tensor.reduce_min(tensor, axes, false)
    
    Let expected_shape be List[Integer]().append(2)
    assert_tensor_valid(min_result, expected_shape)

Process called "test_reduce_prod":
    Note: Test product reduction along axes
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let axes be List[Integer]().append(1)
    
    Let prod_result be Tensor.reduce_prod(tensor, axes, false)
    
    Let expected_shape be List[Integer]().append(2)
    assert_tensor_valid(prod_result, expected_shape)

Note: =====================================================================
Note: TENSOR NETWORK TESTS
Note: =====================================================================

Process called "test_create_tensor_network":
    Note: Test tensor network creation
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor_a be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let tensor_b be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let tensors be List[Tensor.Tensor]().append(tensor_a).append(tensor_b)
    Let network_data be create_tensor_network_data()
    
    Let network be Tensor.create_tensor_network(tensors, network_data)
    
    assert_tensor_network_valid(network)

Process called "test_contract_tensor_network":
    Note: Test tensor network contraction
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor_a be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let tensor_b be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let tensors be List[Tensor.Tensor]().append(tensor_a).append(tensor_b)
    Let network_data be create_tensor_network_data()
    Let network be Tensor.create_tensor_network(tensors, network_data)
    Let contraction_order be List[Integer]().append(0).append(1)
    
    Let contracted be Tensor.contract_tensor_network(network, contraction_order)
    
    UnitTest.assert_not_null(contracted, "Contracted result should not be null")

Process called "test_optimize_contraction_order":
    Note: Test contraction order optimization
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor_a be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let tensor_b be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let tensors be List[Tensor.Tensor]().append(tensor_a).append(tensor_b)
    Let network_data be create_tensor_network_data()
    Let network be Tensor.create_tensor_network(tensors, network_data)
    
    Let optimal_order be Tensor.optimize_contraction_order(network, "greedy")
    
    UnitTest.assert_not_null(optimal_order, "Optimal order should not be null")
    UnitTest.assert_true(optimal_order.size() > 0, "Should have contraction steps")

Process called "test_tensor_network_svd":
    Note: Test SVD decomposition of tensor network bond
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor_a be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let tensor_b be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let tensors be List[Tensor.Tensor]().append(tensor_a).append(tensor_b)
    Let network_data be create_tensor_network_data()
    Let network be Tensor.create_tensor_network(tensors, network_data)
    Let bond_index be 0
    Let max_bond_dim be 10
    
    Let svd_network be Tensor.tensor_network_svd(network, bond_index, max_bond_dim)
    
    assert_tensor_network_valid(svd_network)

Note: =====================================================================
Note: TENSOR CALCULUS TESTS
Note: =====================================================================

Process called "test_tensor_gradient":
    Note: Test tensor gradient computation
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let variable_indices be List[List[Integer]]
    Let variable_indices be variable_indices.append(List[Integer]().append(0).append(0))
    
    Let gradient be Tensor.tensor_gradient(tensor, variable_indices)
    
    UnitTest.assert_not_null(gradient, "Gradient should not be null")

Process called "test_tensor_jacobian":
    Note: Test Jacobian matrix computation
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let input_variables be List[String]().append("x").append("y")
    
    Let jacobian be Tensor.tensor_jacobian(tensor, input_variables)
    
    UnitTest.assert_not_null(jacobian, "Jacobian should not be null")

Process called "test_tensor_hessian":
    Note: Test Hessian matrix computation
    Let data be List[String]().append("1.0").append("2.0").append("3.0")
    Let scalar_tensor be Tensor.create_tensor(data, List[Integer]().append(3), "Float32", "dense")
    Let input_variables be List[String]().append("x").append("y")
    
    Let hessian be Tensor.tensor_hessian(scalar_tensor, input_variables)
    
    UnitTest.assert_not_null(hessian, "Hessian should not be null")

Process called "test_tensor_divergence":
    Note: Test divergence computation of vector field
    Let vector_field_data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let vector_field be Tensor.create_tensor(vector_field_data, shape, "Float32", "dense")
    
    Let divergence be Tensor.tensor_divergence(vector_field, List[Integer]().append(0))
    
    UnitTest.assert_not_null(divergence, "Divergence should not be null")

Process called "test_tensor_curl":
    Note: Test curl computation of vector field
    Let vector_field_data be create_test_tensor_3x2x2()
    Let shape be create_test_tensor_shape_3d()
    Let vector_field be Tensor.create_tensor(vector_field_data, shape, "Float32", "dense")
    
    Let curl be Tensor.tensor_curl(vector_field, List[Integer]().append(1).append(2))
    
    UnitTest.assert_not_null(curl, "Curl should not be null")

Note: =====================================================================
Note: BROADCASTING TESTS
Note: =====================================================================

Process called "test_broadcast_tensors":
    Note: Test broadcasting multiple tensors to common shape
    Let tensor_a be Tensor.ones_tensor(List[Integer]().append(2).append(1), "Float32")
    Let tensor_b be Tensor.ones_tensor(List[Integer]().append(1).append(3), "Float32")
    Let tensors be List[Tensor.Tensor]().append(tensor_a).append(tensor_b)
    
    Let broadcast_result be Tensor.broadcast_tensors(tensors)
    
    UnitTest.assert_equal(broadcast_result.size(), 2, "Should return 2 tensors")
    Let expected_shape be List[Integer]().append(2).append(3)
    assert_tensor_valid(broadcast_result[0], expected_shape)
    assert_tensor_valid(broadcast_result[1], expected_shape)

Process called "test_broadcast_single_tensor":
    Note: Test broadcasting single tensor to target shape
    Let tensor be Tensor.ones_tensor(List[Integer]().append(1).append(3), "Float32")
    Let target_shape be List[Integer]().append(2).append(3)
    
    Let broadcasted be Tensor.broadcast_single_tensor(tensor, target_shape)
    
    assert_tensor_valid(broadcasted, target_shape)

Process called "test_compute_broadcast_shape":
    Note: Test computing broadcast shape from multiple shapes
    Let shape_a be List[Integer]().append(2).append(1)
    Let shape_b be List[Integer]().append(1).append(3)
    Let shapes be List[List[Integer]]().append(shape_a).append(shape_b)
    
    Let broadcast_shape be Tensor.compute_broadcast_shape(shapes)
    
    Let expected_shape be List[Integer]().append(2).append(3)
    UnitTest.assert_equal(broadcast_shape, expected_shape, "Broadcast shape should be [2,3]")

Process called "test_check_broadcast_compatibility":
    Note: Test checking if shapes are broadcast compatible
    Let shape_a be List[Integer]().append(2).append(1)
    Let shape_b be List[Integer]().append(1).append(3)
    
    Let compatible be Tensor.check_broadcast_compatibility(shape_a, shape_b)
    
    UnitTest.assert_true(compatible, "Shapes should be broadcast compatible")

Process called "test_expand_to_shape":
    Note: Test expanding tensor to target shape
    Let tensor be Tensor.ones_tensor(List[Integer]().append(1).append(3), "Float32")
    Let target_shape be List[Integer]().append(4).append(3)
    
    Let expanded be Tensor.expand_to_shape(tensor, target_shape)
    
    assert_tensor_valid(expanded, target_shape)

Process called "test_compute_broadcast_shape_multiple":
    Note: Test computing broadcast shape for multiple tensors
    Let tensor_a be Tensor.ones_tensor(List[Integer]().append(2).append(1), "Float32")
    Let tensor_b be Tensor.ones_tensor(List[Integer]().append(1).append(3), "Float32")
    Let tensor_c be Tensor.ones_tensor(List[Integer]().append(2).append(3), "Float32")
    Let tensors be List[Tensor.Tensor]().append(tensor_a).append(tensor_b).append(tensor_c)
    
    Let broadcast_shape be Tensor.compute_broadcast_shape_multiple(tensors)
    
    Let expected_shape be List[Integer]().append(2).append(3)
    UnitTest.assert_equal(broadcast_shape, expected_shape, "Broadcast shape should be [2,3]")

Process called "test_map_broadcast_coordinates":
    Note: Test mapping coordinates during broadcasting
    Let source_shape be List[Integer]().append(1).append(3)
    Let target_shape be List[Integer]().append(2).append(3)
    Let target_coords be List[Integer]().append(1).append(2)
    
    Let source_coords be Tensor.map_broadcast_coordinates(target_coords, source_shape, target_shape)
    
    UnitTest.assert_not_null(source_coords, "Mapped coordinates should not be null")
    UnitTest.assert_equal(source_coords.size(), 2, "Should have 2 coordinates")

Note: =====================================================================
Note: TENSOR COMPARISON TESTS
Note: =====================================================================

Process called "test_tensor_equal":
    Note: Test element-wise equality comparison
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor_a be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let tensor_b be Tensor.create_tensor(data, shape, "Float32", "dense")
    
    Let equal_result be Tensor.tensor_equal(tensor_a, tensor_b)
    
    assert_tensor_valid(equal_result, shape)
    Note: All elements should be equal (true)
    Let flattened be Tensor.flatten_tensor(equal_result, 0, -1)
    For i in range(0, flattened.data.size()):
        UnitTest.assert_equal(flattened.data[i], "1", "All elements should be equal")

Process called "test_tensor_greater":
    Note: Test element-wise greater than comparison
    Let data_a be create_test_tensor_2x3()
    Let data_b be List[List[String]]
    Let data_b be data_b.append(List[String]().append("0.5").append("1.5").append("2.5"))
    Let data_b be data_b.append(List[String]().append("3.5").append("4.5").append("5.5"))
    Let shape be create_test_tensor_shape()
    Let tensor_a be Tensor.create_tensor(data_a, shape, "Float32", "dense")
    Let tensor_b be Tensor.create_tensor(data_b, shape, "Float32", "dense")
    
    Let greater_result be Tensor.tensor_greater(tensor_a, tensor_b)
    
    assert_tensor_valid(greater_result, shape)

Process called "test_tensor_less":
    Note: Test element-wise less than comparison
    Let data_a be create_test_tensor_2x3()
    Let data_b be List[List[String]]
    Let data_b be data_b.append(List[String]().append("2.0").append("3.0").append("4.0"))
    Let data_b be data_b.append(List[String]().append("5.0").append("6.0").append("7.0"))
    Let shape be create_test_tensor_shape()
    Let tensor_a be Tensor.create_tensor(data_a, shape, "Float32", "dense")
    Let tensor_b be Tensor.create_tensor(data_b, shape, "Float32", "dense")
    
    Let less_result be Tensor.tensor_less(tensor_a, tensor_b)
    
    assert_tensor_valid(less_result, shape)

Process called "test_all_close":
    Note: Test checking if tensors are approximately equal
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor_a be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let tensor_b be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let tolerance be 1e-6
    
    Let all_close_result be Tensor.all_close(tensor_a, tensor_b, tolerance, tolerance)
    
    UnitTest.assert_true(all_close_result, "Identical tensors should be all close")

Note: =====================================================================
Note: TENSOR UTILITY TESTS
Note: =====================================================================

Process called "test_tensor_info":
    Note: Test getting tensor information dictionary
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    
    Let info be Tensor.tensor_info(tensor)
    
    UnitTest.assert_not_null(info, "Info should not be null")
    UnitTest.assert_true(Collections.contains_key(info, "shape"), "Should contain shape info")
    UnitTest.assert_true(Collections.contains_key(info, "dtype"), "Should contain data type info")
    UnitTest.assert_true(Collections.contains_key(info, "size"), "Should contain size info")

Process called "test_memory_usage":
    Note: Test calculating tensor memory usage
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    
    Let memory_bytes be Tensor.memory_usage(tensor)
    
    UnitTest.assert_true(memory_bytes > 0, "Memory usage should be positive")

Process called "test_clone_tensor":
    Note: Test creating copy of tensor
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    
    Let cloned be Tensor.clone_tensor(tensor)
    
    assert_tensor_valid(cloned, shape)
    UnitTest.assert_true(Tensor.all_close(tensor, cloned, 1e-12, 1e-12), "Cloned tensor should be identical")

Process called "test_move_to_device":
    Note: Test moving tensor to different device
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let target_device be "cpu"
    
    Let moved_tensor be Tensor.move_to_device(tensor, target_device)
    
    assert_tensor_valid(moved_tensor, shape)
    UnitTest.assert_equal(moved_tensor.device, target_device, "Tensor should be on target device")

Process called "test_change_dtype":
    Note: Test changing tensor data type
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let new_dtype be "Float64"
    
    Let converted_tensor be Tensor.change_dtype(tensor, new_dtype)
    
    assert_tensor_valid(converted_tensor, shape)
    UnitTest.assert_equal(converted_tensor.data_type, new_dtype, "Data type should be changed")

Note: =====================================================================
Note: HELPER FUNCTION TESTS  
Note: =====================================================================

Process called "test_construct_khatri_rao_product":
    Note: Test Khatri-Rao product construction
    Let data_a be List[List[String]]
    Let data_a be data_a.append(List[String]().append("1.0").append("2.0"))
    Let data_a be data_a.append(List[String]().append("3.0").append("4.0"))
    Let matrix_a be Tensor.create_tensor(data_a, List[Integer]().append(2).append(2), "Float32", "dense")
    
    Let data_b be List[List[String]]
    Let data_b be data_b.append(List[String]().append("5.0").append("6.0"))
    Let data_b be data_b.append(List[String]().append("7.0").append("8.0"))
    Let matrix_b be Tensor.create_tensor(data_b, List[Integer]().append(2).append(2), "Float32", "dense")
    
    Let matrices be List[Tensor.Tensor]().append(matrix_a).append(matrix_b)
    
    Let khatri_rao be Tensor.construct_khatri_rao_product(matrices)
    
    Let expected_shape be List[Integer]().append(4).append(2)
    assert_tensor_valid(khatri_rao, expected_shape)

Process called "test_matricize_tensor_along_mode":
    Note: Test tensor matricization along specified mode
    Let data be create_test_tensor_3x2x2()
    Let shape be create_test_tensor_shape_3d()
    Let tensor be Tensor.create_tensor(data, shape, "Float32", "dense")
    Let mode be 1
    
    Let matricized be Tensor.matricize_tensor_along_mode(tensor, mode)
    
    Let expected_rows be 2  Note: Size of mode 1
    Let expected_cols be 6  Note: Product of other modes (3*2)
    Let expected_shape be List[Integer]().append(expected_rows).append(expected_cols)
    assert_tensor_valid(matricized, expected_shape)

Process called "test_normalize_factor_columns":
    Note: Test normalizing factor matrix columns
    Let data be List[List[String]]
    Let data be data.append(List[String]().append("3.0").append("4.0"))
    Let data be data.append(List[String]().append("0.0").append("0.0"))
    Let matrix be Tensor.create_tensor(data, List[Integer]().append(2).append(2), "Float32", "dense")
    
    Let normalized_result be Tensor.normalize_factor_columns(matrix)
    
    UnitTest.assert_not_null(normalized_result, "Normalized result should not be null")
    UnitTest.assert_true(Collections.contains_key(normalized_result, "normalized_matrix"), "Should contain normalized matrix")
    UnitTest.assert_true(Collections.contains_key(normalized_result, "norms"), "Should contain column norms")

Process called "test_compute_tensor_reconstruction_error":
    Note: Test computing tensor reconstruction error
    Let original_data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let original = Tensor.create_tensor(original_data, shape, "Float32", "dense")
    Let reconstructed = Tensor.create_tensor(original_data, shape, "Float32", "dense")
    
    Let error be Tensor.compute_tensor_reconstruction_error(original, reconstructed)
    
    UnitTest.assert_true(error >= 0.0, "Reconstruction error should be non-negative")
    assert_numerical_close(error.to_string(), "0.0", 1e-12, "Identical tensors should have zero error")

Process called "test_transpose_matrix":
    Note: Test matrix transpose helper function
    Let data be create_test_tensor_2x3()
    Let shape be create_test_tensor_shape()
    Let matrix be Tensor.create_tensor(data, shape, "Float32", "dense")
    
    Let transposed be Tensor.transpose_matrix(matrix)
    
    Let expected_shape be List[Integer]().append(3).append(2)
    assert_tensor_valid(transposed, expected_shape)

Process called "test_contract_tensor_with_matrix":
    Note: Test contracting tensor with matrix
    Let tensor_data be create_test_tensor_3x2x2()
    Let tensor_shape be create_test_tensor_shape_3d()
    Let tensor be Tensor.create_tensor(tensor_data, tensor_shape, "Float32", "dense")
    
    Let matrix_data be List[List[String]]
    Let matrix_data be matrix_data.append(List[String]().append("1.0").append("2.0"))
    Let matrix_data be matrix_data.append(List[String]().append("3.0").append("4.0"))
    Let matrix be Tensor.create_tensor(matrix_data, List[Integer]().append(2).append(2), "Float32", "dense")
    
    Let mode be 1
    
    Let contracted be Tensor.contract_tensor_with_matrix(tensor, matrix, mode)
    
    UnitTest.assert_not_null(contracted, "Contracted tensor should not be null")

Process called "test_compute_tensor_frobenius_difference":
    Note: Test computing Frobenius norm difference
    Let data1 be create_test_tensor_2x3()
    Let data2 be List[List[String]]
    Let data2 be data2.append(List[String]().append("2.0").append("3.0").append("4.0"))
    Let data2 = data2.append(List[String]().append("5.0").append("6.0").append("7.0"))
    Let shape be create_test_tensor_shape()
    
    Let tensor_a be Tensor.create_tensor(data1, shape, "Float32", "dense")
    Let tensor_b be Tensor.create_tensor(data2, shape, "Float32", "dense")
    
    Let frobenius_diff be Tensor.compute_tensor_frobenius_difference(tensor_a, tensor_b)
    
    UnitTest.assert_true(frobenius_diff >= 0.0, "Frobenius difference should be non-negative")

Process called "test_multiply_diagonal_matrix_vector":
    Note: Test multiplying diagonal matrix with vector
    Let diagonal_values be List[String]().append("2.0").append("3.0").append("4.0")
    Let vector_data be List[String]().append("1.0").append("2.0").append("3.0")
    
    Let result be Tensor.multiply_diagonal_matrix_vector(diagonal_values, vector_data)
    
    UnitTest.assert_equal(result.size(), 3, "Result should have 3 elements")
    Let expected_data be List[String]().append("2.0").append("6.0").append("12.0")
    For i in range(0, 3):
        assert_numerical_close(result[i], expected_data[i], 1e-12, "Element " ++ i.to_string())

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_tensor_creation_tests":
    Note: Run all tensor creation tests
    UnitTest.run_test("test_create_tensor")
    UnitTest.run_test("test_zeros_tensor")
    UnitTest.run_test("test_ones_tensor")
    UnitTest.run_test("test_random_tensor")
    UnitTest.run_test("test_identity_tensor")

Process called "run_basic_operations_tests":
    Note: Run all basic tensor operation tests
    UnitTest.run_test("test_tensor_add")
    UnitTest.run_test("test_tensor_multiply")
    UnitTest.run_test("test_tensor_subtract")
    UnitTest.run_test("test_tensor_divide")
    UnitTest.run_test("test_scalar_multiply")

Process called "run_shape_manipulation_tests":
    Note: Run all shape manipulation tests
    UnitTest.run_test("test_reshape_tensor")
    UnitTest.run_test("test_transpose_tensor")
    UnitTest.run_test("test_squeeze_tensor")
    UnitTest.run_test("test_expand_dims")
    UnitTest.run_test("test_flatten_tensor")
    UnitTest.run_test("test_slice_tensor")

Process called "run_decomposition_tests":
    Note: Run all tensor decomposition tests
    UnitTest.run_test("test_tensor_trace")
    UnitTest.run_test("test_tensor_svd")
    UnitTest.run_test("test_cp_decomposition")
    UnitTest.run_test("test_tucker_decomposition")
    UnitTest.run_test("test_hosvd")
    UnitTest.run_test("test_tensor_train_decomposition")

Process called "run_sparse_tensor_tests":
    Note: Run all sparse tensor tests
    UnitTest.run_test("test_create_sparse_tensor")
    UnitTest.run_test("test_sparse_tensor_add")
    UnitTest.run_test("test_sparse_tensor_multiply")
    UnitTest.run_test("test_sparse_to_dense")
    UnitTest.run_test("test_dense_to_sparse")

Process called "run_all_tensor_tests":
    Note: Run comprehensive test suite for all tensor functionality
    Let start_time be DateTime.get_current_timestamp()
    
    UnitTest.start_test_suite("Tensor Operations Tests")
    
    UnitTest.start_test_group("Tensor Creation Operations")
    run_tensor_creation_tests()
    
    UnitTest.start_test_group("Tensor Basic Operations")
    run_basic_operations_tests()
    
    UnitTest.start_test_group("Tensor Shape Manipulation")
    run_shape_manipulation_tests()
    
    UnitTest.start_test_group("Tensor Indexing and Slicing")
    UnitTest.run_test("test_index_tensor")
    UnitTest.run_test("test_mask_tensor")
    UnitTest.run_test("test_gather_tensor")
    UnitTest.run_test("test_scatter_tensor")
    
    UnitTest.start_test_group("Tensor Contraction Operations")
    UnitTest.run_test("test_tensor_dot")
    UnitTest.run_test("test_einstein_sum")
    UnitTest.run_test("test_outer_product")
    UnitTest.run_test("test_kronecker_product")
    
    UnitTest.start_test_group("Tensor Decomposition Operations")
    run_decomposition_tests()
    
    UnitTest.start_test_group("Sparse Tensor Operations")
    run_sparse_tensor_tests()
    
    UnitTest.start_test_group("Tensor Reduction Operations")
    UnitTest.run_test("test_reduce_sum")
    UnitTest.run_test("test_reduce_mean")
    UnitTest.run_test("test_reduce_max")
    UnitTest.run_test("test_reduce_min")
    UnitTest.run_test("test_reduce_prod")
    
    UnitTest.start_test_group("Tensor Network Operations")
    UnitTest.run_test("test_create_tensor_network")
    UnitTest.run_test("test_contract_tensor_network")
    UnitTest.run_test("test_optimize_contraction_order")
    UnitTest.run_test("test_tensor_network_svd")
    
    UnitTest.start_test_group("Tensor Calculus Operations")
    UnitTest.run_test("test_tensor_gradient")
    UnitTest.run_test("test_tensor_jacobian")
    UnitTest.run_test("test_tensor_hessian")
    UnitTest.run_test("test_tensor_divergence")
    UnitTest.run_test("test_tensor_curl")
    
    UnitTest.start_test_group("Broadcasting Operations")
    UnitTest.run_test("test_broadcast_tensors")
    UnitTest.run_test("test_broadcast_single_tensor")
    UnitTest.run_test("test_compute_broadcast_shape")
    UnitTest.run_test("test_check_broadcast_compatibility")
    UnitTest.run_test("test_expand_to_shape")
    UnitTest.run_test("test_compute_broadcast_shape_multiple")
    UnitTest.run_test("test_map_broadcast_coordinates")
    
    UnitTest.start_test_group("Tensor Comparison Operations")
    UnitTest.run_test("test_tensor_equal")
    UnitTest.run_test("test_tensor_greater")
    UnitTest.run_test("test_tensor_less")
    UnitTest.run_test("test_all_close")
    
    UnitTest.start_test_group("Tensor Utility Operations")
    UnitTest.run_test("test_tensor_info")
    UnitTest.run_test("test_memory_usage")
    UnitTest.run_test("test_clone_tensor")
    UnitTest.run_test("test_move_to_device")
    UnitTest.run_test("test_change_dtype")
    
    UnitTest.start_test_group("Helper Function Operations")
    UnitTest.run_test("test_construct_khatri_rao_product")
    UnitTest.run_test("test_matricize_tensor_along_mode")
    UnitTest.run_test("test_normalize_factor_columns")
    UnitTest.run_test("test_compute_tensor_reconstruction_error")
    UnitTest.run_test("test_transpose_matrix")
    UnitTest.run_test("test_contract_tensor_with_matrix")
    UnitTest.run_test("test_compute_tensor_frobenius_difference")
    UnitTest.run_test("test_multiply_diagonal_matrix_vector")
    
    Let end_time be DateTime.get_current_timestamp()
    Let duration be DateTime.calculate_duration(start_time, end_time)
    
    UnitTest.end_test_suite("Tensor Operations Tests completed in " ++ duration.to_string() ++ " seconds")

Process called "run_quick_tensor_tests":
    Note: Run essential tensor tests for continuous integration
    UnitTest.start_test_suite("Quick Tensor Tests")
    
    Note: Test core functionality
    UnitTest.run_test("test_create_tensor")
    UnitTest.run_test("test_tensor_add")
    UnitTest.run_test("test_reshape_tensor")
    UnitTest.run_test("test_tensor_dot")
    UnitTest.run_test("test_cp_decomposition")
    UnitTest.run_test("test_create_sparse_tensor")
    UnitTest.run_test("test_broadcast_tensors")
    UnitTest.run_test("test_tensor_equal")
    
    UnitTest.end_test_suite("Quick Tensor Tests")

Process called "get_tensor_test_count" returns Integer:
    Note: Return total number of tensor tests
    Return 73