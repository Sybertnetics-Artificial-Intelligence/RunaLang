Note:
tests/unit/libraries/math/engine/linalg/sparse_test.runa
Comprehensive Unit Tests for Sparse Matrix Module

This test suite provides complete coverage for the math/engine/linalg/sparse module,
testing all 48 functions across sparse matrix creation, storage formats, operations,
solvers, eigenvalue computations, and performance optimization.

Test Categories:
- Matrix Creation and Conversion (4 tests)
- Basic Matrix Operations (5 tests)
- Direct Solvers and Factorizations (4 tests) 
- Iterative Solvers (5 tests)
- Eigenvalue and SVD Computations (3 tests)
- Matrix Ordering and Analysis (8 tests)
- Block Sparse Operations (4 tests)
- Preconditioning Operations (4 tests)
- Performance Optimization (4 tests)
- Analysis and Validation (3 tests)
- Helper Function Operations (3 tests)

Total: 47 comprehensive test functions covering all sparse matrix functionality
:End Note

Import "dev/test" as UnitTest
Import "math/engine/linalg/sparse" as Sparse
Import "math/engine/linalg/core" as LinalgCore
Import "math/core/operations" as Operations
Import "collections" as Collections
Import "datetime" as DateTime

Note: =====================================================================
Note: TEST DATA HELPERS
Note: =====================================================================

Process called "create_test_sparse_triplets" returns List[Dictionary[String, String]]:
    Note: Create triplet entries for sparse matrix testing
    Let triplets be List[Dictionary[String, String]]
    
    Note: Create 3x3 sparse matrix with pattern:
    Note: [4.0  0   2.0]
    Note: [0   5.0  3.0] 
    Note: [1.0  0   6.0]
    
    Let entry1 be Dictionary[String, String]
    Let entry1 be entry1.set("row", "0").set("col", "0").set("value", "4.0")
    Let triplets be triplets.append(entry1)
    
    Let entry2 be Dictionary[String, String]
    Let entry2 be entry2.set("row", "0").set("col", "2").set("value", "2.0")
    Let triplets be triplets.append(entry2)
    
    Let entry3 be Dictionary[String, String]
    Let entry3 be entry3.set("row", "1").set("col", "1").set("value", "5.0")
    Let triplets be triplets.append(entry3)
    
    Let entry4 be Dictionary[String, String]
    Let entry4 be entry4.set("row", "1").set("col", "2").set("value", "3.0")
    Let triplets be triplets.append(entry4)
    
    Let entry5 be Dictionary[String, String]
    Let entry5 be entry5.set("row", "2").set("col", "0").set("value", "1.0")
    Let triplets be triplets.append(entry5)
    
    Let entry6 be Dictionary[String, String]
    Let entry6 be entry6.set("row", "2").set("col", "2").set("value", "6.0")
    Let triplets be triplets.append(entry6)
    
    Return triplets

Process called "create_symmetric_sparse_triplets" returns List[Dictionary[String, String]]:
    Note: Create symmetric sparse matrix for specialized algorithms
    Let triplets be List[Dictionary[String, String]]
    
    Note: Create 3x3 symmetric matrix:
    Note: [4.0  1.0  2.0]
    Note: [1.0  5.0  3.0] 
    Note: [2.0  3.0  6.0]
    
    Let entries be List[List[String]]
    Let entries be entries.append(List[String]().append("0").append("0").append("4.0"))
    Let entries be entries.append(List[String]().append("0").append("1").append("1.0"))
    Let entries be entries.append(List[String]().append("0").append("2").append("2.0"))
    Let entries be entries.append(List[String]().append("1").append("0").append("1.0"))
    Let entries be entries.append(List[String]().append("1").append("1").append("5.0"))
    Let entries be entries.append(List[String]().append("1").append("2").append("3.0"))
    Let entries be entries.append(List[String]().append("2").append("0").append("2.0"))
    Let entries be entries.append(List[String]().append("2").append("1").append("3.0"))
    Let entries be entries.append(List[String]().append("2").append("2").append("6.0"))
    
    For i in range(0, entries.size()):
        Let entry be Dictionary[String, String]
        Let entry be entry.set("row", entries[i][0])
        Let entry be entry.set("col", entries[i][1])
        Let entry be entry.set("value", entries[i][2])
        Let triplets be triplets.append(entry)
    
    Return triplets

Process called "create_test_sparse_vector" returns List[String]:
    Note: Create test vector for sparse matrix-vector operations
    Let vector be List[String]
    Let vector be vector.append("1.0").append("2.0").append("3.0")
    Return vector

Process called "create_larger_sparse_matrix" returns List[Dictionary[String, String]]:
    Note: Create larger sparse matrix for ordering and eigenvalue testing
    Let triplets be List[Dictionary[String, String]]
    
    Note: Create 5x5 tridiagonal matrix with some fill-in
    For i in range(0, 5):
        Note: Main diagonal
        Let entry be Dictionary[String, String]
        Let entry be entry.set("row", i.to_string())
        Let entry be entry.set("col", i.to_string())
        Let entry be entry.set("value", "4.0")
        Let triplets be triplets.append(entry)
        
        Note: Super and sub diagonals
        If i < 4:
            Let super_entry be Dictionary[String, String]
            Let super_entry be super_entry.set("row", i.to_string())
            Let super_entry be super_entry.set("col", Operations.add(i.to_string(), "1", 0).result)
            Let super_entry be super_entry.set("value", "1.0")
            Let triplets be triplets.append(super_entry)
            
            Let sub_entry be Dictionary[String, String]
            Let sub_entry be sub_entry.set("row", Operations.add(i.to_string(), "1", 0).result)
            Let sub_entry be sub_entry.set("col", i.to_string())
            Let sub_entry be sub_entry.set("value", "1.0")
            Let triplets be triplets.append(sub_entry)
    
    Return triplets

Process called "create_block_structure_data" returns Dictionary[String, List[Integer]]:
    Note: Create block structure information for block sparse tests
    Let block_info be Dictionary[String, List[Integer]]
    Let row_blocks be List[Integer]
    Let row_blocks be row_blocks.append(2).append(1)
    Let col_blocks be List[Integer]
    Let col_blocks be col_blocks.append(2).append(1)
    
    Let block_info be block_info.set("row_blocks", row_blocks)
    Let block_info be block_info.set("col_blocks", col_blocks)
    
    Return block_info

Note: =====================================================================
Note: ASSERTION HELPERS
Note: =====================================================================

Process called "assert_numerical_close" that takes actual as String, expected as String, tolerance as Float, message as String:
    Note: Assert two numerical values are close within tolerance
    Let actual_val be Operations.convert_to_float(actual)
    Let expected_val be Operations.convert_to_float(expected)
    Let diff be Operations.absolute_value(Operations.subtract(actual, expected, 15).result)
    Let diff_val be Operations.convert_to_float(diff)
    UnitTest.assert_true(diff_val < tolerance, message ++ " - expected: " ++ expected ++ ", actual: " ++ actual)

Process called "assert_sparse_matrix_valid" that takes matrix as Sparse.SparseMatrix, expected_nnz as Integer, expected_rows as Integer, expected_cols as Integer:
    Note: Assert sparse matrix is valid and has expected dimensions
    UnitTest.assert_equal(matrix.rows, expected_rows, "Matrix should have expected number of rows")
    UnitTest.assert_equal(matrix.columns, expected_cols, "Matrix should have expected number of columns")
    UnitTest.assert_equal(matrix.nnz, expected_nnz, "Matrix should have expected number of non-zeros")
    UnitTest.assert_not_null(matrix.format, "Matrix format should be specified")

Process called "assert_vector_close" that takes actual as List[String], expected as List[String], tolerance as Float, message as String:
    Note: Assert two vectors are numerically close
    UnitTest.assert_equal(actual.size(), expected.size(), message ++ " - vector sizes should match")
    
    For i in range(0, actual.size()):
        assert_numerical_close(actual[i], expected[i], tolerance, 
                             message ++ " - component " ++ i.to_string())

Process called "assert_eigenvalues_valid" that takes eigenvalues as List[String], matrix_size as Integer:
    Note: Assert eigenvalue results are reasonable
    UnitTest.assert_true(eigenvalues.size() > 0, "Should compute some eigenvalues")
    UnitTest.assert_true(eigenvalues.size() <= matrix_size, "Should not exceed matrix size")
    
    Note: Check that eigenvalues are real numbers
    For i in range(0, eigenvalues.size()):
        Let val be Operations.convert_to_float(eigenvalues[i])
        UnitTest.assert_false(Operations.is_nan(val), "Eigenvalue should be valid number")

Process called "assert_factorization_valid" that takes factorization as Dictionary[String, String], original_matrix as Sparse.SparseMatrix:
    Note: Assert factorization result is valid
    UnitTest.assert_true(Collections.contains_key(factorization, "success"), "Should indicate success status")
    UnitTest.assert_true(Collections.contains_key(factorization, "nnz"), "Should report non-zero count")
    
    Let success be Collections.get_from_dictionary(factorization, "success")
    UnitTest.assert_equal(success, "true", "Factorization should succeed for well-conditioned matrix")

Note: =====================================================================
Note: MATRIX CREATION AND CONVERSION TESTS
Note: =====================================================================

Process called "test_create_sparse_matrix":
    Note: Test sparse matrix creation from triplet format
    Let triplets be create_test_sparse_triplets()
    Let rows be 3
    Let cols be 3
    
    Let sparse_matrix be Sparse.create_sparse_matrix(triplets, rows, cols, "CSR")
    
    assert_sparse_matrix_valid(sparse_matrix, 6, 3, 3)
    UnitTest.assert_equal(sparse_matrix.format, "CSR", "Matrix format should be CSR")

Process called "test_convert_sparse_format":
    Note: Test conversion between sparse storage formats
    Let triplets be create_test_sparse_triplets()
    Let csr_matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    
    Let csc_matrix be Sparse.convert_sparse_format(csr_matrix, "CSC")
    
    assert_sparse_matrix_valid(csc_matrix, 6, 3, 3)
    UnitTest.assert_equal(csc_matrix.format, "CSC", "Converted matrix should be CSC")

Process called "test_dense_to_sparse":
    Note: Test conversion from dense to sparse with threshold
    Let dense_matrix be List[List[String]]
    Let dense_matrix be dense_matrix.append(List[String]().append("4.0").append("0.0").append("2.0"))
    Let dense_matrix be dense_matrix.append(List[String]().append("0.0").append("5.0").append("3.0"))
    Let dense_matrix be dense_matrix.append(List[String]().append("1.0").append("0.0").append("6.0"))
    Let threshold be 1e-12
    
    Let sparse_matrix be Sparse.dense_to_sparse(dense_matrix, threshold, "COO")
    
    assert_sparse_matrix_valid(sparse_matrix, 6, 3, 3)
    UnitTest.assert_equal(sparse_matrix.format, "COO", "Matrix format should be COO")

Process called "test_sparse_to_dense":
    Note: Test conversion from sparse to dense format
    Let triplets be create_test_sparse_triplets()
    Let sparse_matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    
    Let dense_matrix be Sparse.sparse_to_dense(sparse_matrix)
    
    UnitTest.assert_equal(dense_matrix.size(), 3, "Should have 3 rows")
    UnitTest.assert_equal(dense_matrix[0].size(), 3, "Should have 3 columns")
    assert_numerical_close(dense_matrix[0][0], "4.0", 1e-12, "Matrix element [0,0]")
    assert_numerical_close(dense_matrix[0][1], "0.0", 1e-12, "Matrix element [0,1]")
    assert_numerical_close(dense_matrix[0][2], "2.0", 1e-12, "Matrix element [0,2]")

Note: =====================================================================
Note: BASIC MATRIX OPERATIONS TESTS
Note: =====================================================================

Process called "test_sparse_matrix_multiply":
    Note: Test sparse matrix-matrix multiplication
    Let triplets be create_test_sparse_triplets()
    Let matrix_a be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    Let matrix_b be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    
    Let result be Sparse.sparse_matrix_multiply(matrix_a, matrix_b)
    
    assert_sparse_matrix_valid(result, -1, 3, 3)  Note: -1 for unknown nnz
    UnitTest.assert_not_null(result.data, "Result should contain data")

Process called "test_sparse_matrix_vector_multiply":
    Note: Test sparse matrix-vector multiplication
    Let triplets be create_test_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    Let vector be create_test_sparse_vector()
    
    Let result be Sparse.sparse_matrix_vector_multiply(matrix, vector)
    
    UnitTest.assert_equal(result.size(), 3, "Result vector should have 3 elements")
    Note: Expected: [4*1 + 0*2 + 2*3, 0*1 + 5*2 + 3*3, 1*1 + 0*2 + 6*3] = [10, 19, 19]
    assert_numerical_close(result[0], "10.0", 1e-12, "First component")
    assert_numerical_close(result[1], "19.0", 1e-12, "Second component")
    assert_numerical_close(result[2], "19.0", 1e-12, "Third component")

Process called "test_sparse_matrix_transpose":
    Note: Test sparse matrix transpose
    Let triplets be create_test_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    
    Let transpose_matrix be Sparse.sparse_matrix_transpose(matrix)
    
    assert_sparse_matrix_valid(transpose_matrix, 6, 3, 3)
    UnitTest.assert_not_null(transpose_matrix.data, "Transpose should contain data")

Process called "test_sparse_matrix_add":
    Note: Test sparse matrix addition with scaling
    Let triplets be create_test_sparse_triplets()
    Let matrix_a be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    Let matrix_b be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    Let alpha be "2.0"
    Let beta be "1.0"
    
    Let result be Sparse.sparse_matrix_add(matrix_a, matrix_b, alpha, beta)
    
    assert_sparse_matrix_valid(result, -1, 3, 3)  Note: Result might have different nnz due to cancellation
    UnitTest.assert_not_null(result.data, "Addition result should contain data")

Process called "test_sparse_matrix_scale":
    Note: Test sparse matrix scaling
    Let triplets be create_test_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    Let scale_factor be "2.5"
    
    Let scaled_matrix be Sparse.sparse_matrix_scale(matrix, scale_factor)
    
    assert_sparse_matrix_valid(scaled_matrix, 6, 3, 3)
    UnitTest.assert_not_null(scaled_matrix.data, "Scaled matrix should contain data")

Note: =====================================================================
Note: DIRECT SOLVERS AND FACTORIZATIONS TESTS
Note: =====================================================================

Process called "test_sparse_lu_factorization":
    Note: Test LU factorization for sparse matrices
    Let triplets be create_test_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    
    Let lu_factorization be Sparse.sparse_lu_factorization(matrix, "partial")
    
    assert_factorization_valid(lu_factorization, matrix)
    UnitTest.assert_true(Collections.contains_key(lu_factorization, "L_matrix"), "Should contain L matrix")
    UnitTest.assert_true(Collections.contains_key(lu_factorization, "U_matrix"), "Should contain U matrix")

Process called "test_sparse_cholesky_factorization":
    Note: Test Cholesky factorization for SPD sparse matrices
    Let triplets be create_symmetric_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    
    Let chol_factorization be Sparse.sparse_cholesky_factorization(matrix)
    
    assert_factorization_valid(chol_factorization, matrix)
    UnitTest.assert_true(Collections.contains_key(chol_factorization, "L_matrix"), "Should contain L matrix")

Process called "test_sparse_qr_factorization":
    Note: Test QR factorization using Givens rotations
    Let triplets be create_test_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    
    Let qr_factorization be Sparse.sparse_qr_factorization(matrix, "givens")
    
    assert_factorization_valid(qr_factorization, matrix)
    UnitTest.assert_true(Collections.contains_key(qr_factorization, "Q_matrix"), "Should contain Q matrix")
    UnitTest.assert_true(Collections.contains_key(qr_factorization, "R_matrix"), "Should contain R matrix")

Process called "test_solve_sparse_system":
    Note: Test general sparse system solver interface
    Let triplets be create_symmetric_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    Let rhs be create_test_sparse_vector()
    
    Let solution be Sparse.solve_sparse_system(matrix, rhs, "cholesky")
    
    UnitTest.assert_equal(solution.size(), 3, "Solution should have 3 elements")
    UnitTest.assert_not_null(solution[0], "Solution elements should not be null")

Note: =====================================================================
Note: ITERATIVE SOLVERS TESTS
Note: =====================================================================

Process called "test_conjugate_gradient_sparse":
    Note: Test CG solver for symmetric positive definite systems
    Let triplets be create_symmetric_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    Let rhs be create_test_sparse_vector()
    Let tolerance be 1e-10
    Let max_iterations be 100
    
    Let cg_result be Sparse.conjugate_gradient_sparse(matrix, rhs, tolerance, max_iterations)
    
    UnitTest.assert_true(Collections.contains_key(cg_result, "solution"), "Should contain solution")
    UnitTest.assert_true(Collections.contains_key(cg_result, "converged"), "Should contain convergence status")
    UnitTest.assert_true(Collections.contains_key(cg_result, "iterations"), "Should contain iteration count")

Process called "test_gmres_sparse":
    Note: Test GMRES solver with restart
    Let triplets be create_test_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    Let rhs be create_test_sparse_vector()
    Let tolerance be 1e-10
    Let max_iterations be 100
    Let restart be 10
    
    Let gmres_result be Sparse.gmres_sparse(matrix, rhs, tolerance, max_iterations, restart)
    
    UnitTest.assert_true(Collections.contains_key(gmres_result, "solution"), "Should contain solution")
    UnitTest.assert_true(Collections.contains_key(gmres_result, "converged"), "Should contain convergence status")

Process called "test_bicgstab_sparse":
    Note: Test BiCGSTAB solver for general systems
    Let triplets be create_test_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    Let rhs be create_test_sparse_vector()
    Let tolerance be 1e-10
    Let max_iterations be 100
    
    Let bicgstab_result be Sparse.bicgstab_sparse(matrix, rhs, tolerance, max_iterations)
    
    UnitTest.assert_true(Collections.contains_key(bicgstab_result, "solution"), "Should contain solution")
    UnitTest.assert_true(Collections.contains_key(bicgstab_result, "converged"), "Should contain convergence status")

Process called "test_minres_sparse":
    Note: Test MINRES solver for symmetric indefinite systems
    Let triplets be create_symmetric_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    Let rhs be create_test_sparse_vector()
    Let tolerance be 1e-10
    Let max_iterations be 100
    
    Let minres_result be Sparse.minres_sparse(matrix, rhs, tolerance, max_iterations)
    
    UnitTest.assert_true(Collections.contains_key(minres_result, "solution"), "Should contain solution")
    UnitTest.assert_true(Collections.contains_key(minres_result, "converged"), "Should contain convergence status")

Process called "test_sparse_generalized_eigenvalues":
    Note: Test generalized eigenvalue problems
    Let triplets = create_symmetric_sparse_triplets()
    Let matrix_a be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    Let matrix_b be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    Let num_eigenvalues be 2
    
    Let eigen_result be Sparse.sparse_generalized_eigenvalues(matrix_a, matrix_b, num_eigenvalues, "smallest")
    
    UnitTest.assert_true(Collections.contains_key(eigen_result, "eigenvalues"), "Should contain eigenvalues")
    UnitTest.assert_true(Collections.contains_key(eigen_result, "eigenvectors"), "Should contain eigenvectors")

Note: =====================================================================
Note: EIGENVALUE AND SINGULAR VALUE TESTS
Note: =====================================================================

Process called "test_sparse_eigenvalues_arnoldi":
    Note: Test Arnoldi method for eigenvalue computation
    Let triplets be create_test_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    Let num_eigenvalues be 2
    Let max_iterations be 50
    
    Let eigenvalues be Sparse.sparse_eigenvalues_arnoldi(matrix, num_eigenvalues, max_iterations, "largest")
    
    assert_eigenvalues_valid(eigenvalues, 3)
    UnitTest.assert_equal(eigenvalues.size(), 2, "Should compute requested number of eigenvalues")

Process called "test_sparse_eigenvalues_lanczos":
    Note: Test Lanczos method for symmetric matrices
    Let triplets be create_symmetric_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    Let num_eigenvalues be 2
    Let max_iterations be 50
    
    Let eigenvalues be Sparse.sparse_eigenvalues_lanczos(matrix, num_eigenvalues, max_iterations)
    
    assert_eigenvalues_valid(eigenvalues, 3)
    UnitTest.assert_equal(eigenvalues.size(), 2, "Should compute requested number of eigenvalues")

Process called "test_sparse_singular_values":
    Note: Test singular value decomposition for sparse matrices
    Let triplets be create_test_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    Let num_values be 2
    
    Let svd_result be Sparse.sparse_singular_values(matrix, num_values, "largest")
    
    UnitTest.assert_true(Collections.contains_key(svd_result, "singular_values"), "Should contain singular values")
    UnitTest.assert_true(Collections.contains_key(svd_result, "left_vectors"), "Should contain left singular vectors")
    UnitTest.assert_true(Collections.contains_key(svd_result, "right_vectors"), "Should contain right singular vectors")

Note: =====================================================================
Note: MATRIX ORDERING AND ANALYSIS TESTS
Note: =====================================================================

Process called "test_compute_amd_ordering":
    Note: Test approximate minimum degree ordering
    Let triplets be create_larger_sparse_matrix()
    Let matrix be Sparse.create_sparse_matrix(triplets, 5, 5, "CSR")
    
    Let amd_ordering be Sparse.compute_amd_ordering(matrix)
    
    UnitTest.assert_equal(amd_ordering.size(), 5, "Ordering should have 5 elements")
    Note: Check that it's a valid permutation
    For i in range(0, 5):
        UnitTest.assert_true(amd_ordering.contains(i.to_string()), "Should contain index " ++ i.to_string())

Process called "test_compute_nested_dissection":
    Note: Test nested dissection ordering
    Let triplets be create_larger_sparse_matrix()
    Let matrix be Sparse.create_sparse_matrix(triplets, 5, 5, "CSR")
    
    Let nd_ordering be Sparse.compute_nested_dissection(matrix)
    
    UnitTest.assert_equal(nd_ordering.size(), 5, "Ordering should have 5 elements")

Process called "test_compute_rcm_ordering":
    Note: Test Reverse Cuthill-McKee ordering
    Let triplets be create_larger_sparse_matrix()
    Let matrix be Sparse.create_sparse_matrix(triplets, 5, 5, "CSR")
    
    Let rcm_ordering be Sparse.compute_rcm_ordering(matrix)
    
    UnitTest.assert_equal(rcm_ordering.size(), 5, "RCM ordering should have 5 elements")

Process called "test_analyze_fill_pattern":
    Note: Test fill-in pattern analysis during factorization
    Let triplets be create_test_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    
    Let fill_analysis be Sparse.analyze_fill_pattern(matrix, "lu")
    
    UnitTest.assert_true(Collections.contains_key(fill_analysis, "fill_factor"), "Should contain fill factor")
    UnitTest.assert_true(Collections.contains_key(fill_analysis, "memory_estimate"), "Should contain memory estimate")

Process called "test_analyze_sparsity_pattern":
    Note: Test general sparsity pattern analysis
    Let triplets be create_test_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    
    Let pattern_analysis be Sparse.analyze_sparsity_pattern(matrix)
    
    UnitTest.assert_true(Collections.contains_key(pattern_analysis, "density"), "Should contain matrix density")
    UnitTest.assert_true(Collections.contains_key(pattern_analysis, "symmetry"), "Should contain symmetry information")

Process called "test_find_connected_components":
    Note: Test connected components detection
    Let triplets be create_larger_sparse_matrix()
    Let matrix be Sparse.create_sparse_matrix(triplets, 5, 5, "CSR")
    
    Let components be Sparse.find_connected_components(matrix)
    
    UnitTest.assert_true(components.size() > 0, "Should find at least one component")
    UnitTest.assert_true(Collections.contains_key(components[0], "size"), "Component should have size information")

Process called "test_compute_bandwidth":
    Note: Test matrix bandwidth computation
    Let triplets be create_larger_sparse_matrix()
    Let matrix be Sparse.create_sparse_matrix(triplets, 5, 5, "CSR")
    
    Let bandwidth be Sparse.compute_bandwidth(matrix)
    
    UnitTest.assert_true(Operations.convert_to_integer(bandwidth) >= 0, "Bandwidth should be non-negative")
    UnitTest.assert_true(Operations.convert_to_integer(bandwidth) < 5, "Bandwidth should be less than matrix size")

Process called "test_compute_profile":
    Note: Test matrix profile computation
    Let triplets be create_larger_sparse_matrix()
    Let matrix be Sparse.create_sparse_matrix(triplets, 5, 5, "CSR")
    
    Let profile be Sparse.compute_profile(matrix)
    
    UnitTest.assert_true(Operations.convert_to_integer(profile) >= 0, "Profile should be non-negative")

Note: =====================================================================
Note: BLOCK SPARSE OPERATIONS TESTS
Note: =====================================================================

Process called "test_create_block_sparse_matrix":
    Note: Test block sparse matrix creation
    Let block_data be create_block_structure_data()
    Let triplets be create_test_sparse_triplets()
    
    Let block_matrix be Sparse.create_block_sparse_matrix(triplets, block_data)
    
    UnitTest.assert_not_null(block_matrix, "Block matrix should be created")
    UnitTest.assert_not_null(block_matrix.block_structure, "Should contain block structure")

Process called "test_block_sparse_multiply":
    Note: Test block sparse matrix multiplication
    Let block_data be create_block_structure_data()
    Let triplets be create_test_sparse_triplets()
    Let block_a be Sparse.create_block_sparse_matrix(triplets, block_data)
    Let block_b be Sparse.create_block_sparse_matrix(triplets, block_data)
    
    Let result be Sparse.block_sparse_multiply(block_a, block_b)
    
    UnitTest.assert_not_null(result, "Block multiplication result should not be null")

Process called "test_block_sparse_factorization":
    Note: Test block sparse factorizations
    Let block_data be create_block_structure_data()
    Let triplets be create_symmetric_sparse_triplets()
    Let block_matrix be Sparse.create_block_sparse_matrix(triplets, block_data)
    
    Let factorization be Sparse.block_sparse_factorization(block_matrix, "cholesky")
    
    UnitTest.assert_true(Collections.contains_key(factorization, "success"), "Factorization should indicate success")

Process called "test_extract_block":
    Note: Test extraction of individual blocks
    Let block_data be create_block_structure_data()
    Let triplets be create_test_sparse_triplets()
    Let block_matrix be Sparse.create_block_sparse_matrix(triplets, block_data)
    Let block_row be 0
    Let block_col be 0
    
    Let extracted_block be Sparse.extract_block(block_matrix, block_row, block_col)
    
    UnitTest.assert_not_null(extracted_block, "Extracted block should not be null")

Note: =====================================================================
Note: PRECONDITIONING TESTS
Note: =====================================================================

Process called "test_create_jacobi_preconditioner":
    Note: Test Jacobi preconditioner creation
    Let triplets be create_test_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    
    Let jacobi_precond be Sparse.create_jacobi_preconditioner(matrix)
    
    UnitTest.assert_not_null(jacobi_precond, "Jacobi preconditioner should be created")
    UnitTest.assert_equal(jacobi_precond.type, "jacobi", "Preconditioner type should be jacobi")

Process called "test_create_ilu_preconditioner":
    Note: Test ILU preconditioner creation
    Let triplets be create_test_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    Let fill_level be 0
    Let drop_tolerance be 1e-6
    
    Let ilu_precond be Sparse.create_ilu_preconditioner(matrix, fill_level, drop_tolerance)
    
    UnitTest.assert_not_null(ilu_precond, "ILU preconditioner should be created")
    UnitTest.assert_equal(ilu_precond.type, "ilu", "Preconditioner type should be ilu")

Process called "test_create_ic_preconditioner":
    Note: Test incomplete Cholesky preconditioner
    Let triplets be create_symmetric_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    Let fill_level be 0
    
    Let ic_precond be Sparse.create_ic_preconditioner(matrix, fill_level)
    
    UnitTest.assert_not_null(ic_precond, "IC preconditioner should be created")
    UnitTest.assert_equal(ic_precond.type, "incomplete_cholesky", "Preconditioner type should be IC")

Process called "test_apply_preconditioner":
    Note: Test preconditioner application to vector
    Let triplets be create_test_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    Let jacobi_precond be Sparse.create_jacobi_preconditioner(matrix)
    Let vector be create_test_sparse_vector()
    
    Let preconditioned_vector be Sparse.apply_preconditioner(jacobi_precond, vector)
    
    UnitTest.assert_equal(preconditioned_vector.size(), 3, "Preconditioned vector should have 3 elements")
    UnitTest.assert_not_null(preconditioned_vector[0], "Elements should not be null")

Note: =====================================================================
Note: PERFORMANCE OPTIMIZATION TESTS
Note: =====================================================================

Process called "test_optimize_sparse_storage":
    Note: Test storage format optimization
    Let triplets be create_test_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "COO")
    Let operation_type be "matvec"
    
    Let optimized_matrix be Sparse.optimize_sparse_storage(matrix, operation_type)
    
    UnitTest.assert_not_null(optimized_matrix, "Optimized matrix should not be null")
    UnitTest.assert_not_equal(optimized_matrix.format, matrix.format, "Format should be optimized")

Process called "test_compress_sparse_indices":
    Note: Test index array compression
    Let triplets be create_larger_sparse_matrix()
    Let matrix be Sparse.create_sparse_matrix(triplets, 5, 5, "CSR")
    
    Let compressed_matrix be Sparse.compress_sparse_indices(matrix)
    
    UnitTest.assert_not_null(compressed_matrix, "Compressed matrix should not be null")
    UnitTest.assert_equal(compressed_matrix.rows, matrix.rows, "Dimensions should be preserved")

Process called "test_reorder_for_cache_efficiency":
    Note: Test reordering for better cache performance
    Let triplets be create_larger_sparse_matrix()
    Let matrix be Sparse.create_sparse_matrix(triplets, 5, 5, "CSR")
    
    Let reordered_matrix be Sparse.reorder_for_cache_efficiency(matrix)
    
    UnitTest.assert_not_null(reordered_matrix, "Reordered matrix should not be null")
    UnitTest.assert_equal(reordered_matrix.rows, matrix.rows, "Dimensions should be preserved")

Process called "test_parallelize_sparse_operations":
    Note: Test parallel operation setup
    Let triplets be create_test_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    Let num_threads be 2
    
    Let parallel_config be Sparse.parallelize_sparse_operations(matrix, num_threads)
    
    UnitTest.assert_not_null(parallel_config, "Parallel configuration should not be null")
    UnitTest.assert_true(Collections.contains_key(parallel_config, "thread_count"), "Should contain thread count")

Note: =====================================================================
Note: ANALYSIS AND VALIDATION TESTS
Note: =====================================================================

Process called "test_sparse_matrix_statistics":
    Note: Test matrix statistics computation
    Let triplets be create_test_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    
    Let stats be Sparse.sparse_matrix_statistics(matrix)
    
    UnitTest.assert_true(Collections.contains_key(stats, "density"), "Should contain density")
    UnitTest.assert_true(Collections.contains_key(stats, "nnz"), "Should contain non-zero count")
    UnitTest.assert_true(Collections.contains_key(stats, "condition_estimate"), "Should contain condition estimate")

Process called "test_validate_sparse_format":
    Note: Test sparse format correctness validation
    Let triplets be create_test_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    
    Let validation_result be Sparse.validate_sparse_format(matrix)
    
    UnitTest.assert_true(Collections.get_from_dictionary(validation_result, "valid"), "Matrix should be valid")
    UnitTest.assert_true(Collections.contains_key(validation_result, "errors"), "Should contain error information")

Process called "test_visualize_sparsity_pattern":
    Note: Test ASCII visualization of sparsity pattern
    Let triplets be create_test_sparse_triplets()
    Let matrix be Sparse.create_sparse_matrix(triplets, 3, 3, "CSR")
    
    Let visualization be Sparse.visualize_sparsity_pattern(matrix, "ascii")
    
    UnitTest.assert_not_null(visualization, "Visualization should not be null")
    UnitTest.assert_true(visualization.length > 0, "Visualization should contain content")

Note: =====================================================================
Note: HELPER FUNCTION TESTS
Note: =====================================================================

Process called "test_sort_triplets_by_row":
    Note: Test triplet sorting by row index
    Let unsorted_triplets be List[Dictionary[String, String]]
    
    Note: Create unsorted triplet list
    Let entry1 be Dictionary[String, String]
    Let entry1 be entry1.set("row", "2").set("col", "1").set("value", "3.0")
    Let unsorted_triplets be unsorted_triplets.append(entry1)
    
    Let entry2 be Dictionary[String, String]
    Let entry2 be entry2.set("row", "0").set("col", "0").set("value", "1.0")
    Let unsorted_triplets be unsorted_triplets.append(entry2)
    
    Let entry3 be Dictionary[String, String]
    Let entry3 be entry3.set("row", "1").set("col", "2").set("value", "2.0")
    Let unsorted_triplets be unsorted_triplets.append(entry3)
    
    Let sorted_triplets be Sparse.sort_triplets_by_row(unsorted_triplets)
    
    UnitTest.assert_equal(sorted_triplets.size(), 3, "Should preserve all triplets")
    UnitTest.assert_equal(Collections.get_from_dictionary(sorted_triplets[0], "row"), "0", "First triplet should have row 0")
    UnitTest.assert_equal(Collections.get_from_dictionary(sorted_triplets[1], "row"), "1", "Second triplet should have row 1")
    UnitTest.assert_equal(Collections.get_from_dictionary(sorted_triplets[2], "row"), "2", "Third triplet should have row 2")

Process called "test_triplet_merge_sort":
    Note: Test merge sort implementation for triplets
    Let triplets be create_test_sparse_triplets()
    
    Let sorted_triplets be Sparse.triplet_merge_sort(triplets, "col")
    
    UnitTest.assert_equal(sorted_triplets.size(), triplets.size(), "Should preserve all triplets")
    Note: Check that result is sorted by column
    For i in range(1, sorted_triplets.size()):
        Let prev_col be Operations.convert_to_integer(Collections.get_from_dictionary(sorted_triplets[i-1], "col"))
        Let curr_col be Operations.convert_to_integer(Collections.get_from_dictionary(sorted_triplets[i], "col"))
        UnitTest.assert_true(prev_col <= curr_col, "Should be sorted by column")

Process called "test_triplet_merge":
    Note: Test merge operation for sorted triplet arrays
    Let left_triplets be List[Dictionary[String, String]]
    Let entry1 be Dictionary[String, String]
    Let entry1 be entry1.set("row", "0").set("col", "0").set("value", "1.0")
    Let left_triplets be left_triplets.append(entry1)
    
    Let right_triplets be List[Dictionary[String, String]]
    Let entry2 be Dictionary[String, String]
    Let entry2 be entry2.set("row", "1").set("col", "1").set("value", "2.0")
    Let right_triplets be right_triplets.append(entry2)
    
    Let merged_triplets be Sparse.triplet_merge(left_triplets, right_triplets, "row")
    
    UnitTest.assert_equal(merged_triplets.size(), 2, "Should contain all elements")
    UnitTest.assert_equal(Collections.get_from_dictionary(merged_triplets[0], "row"), "0", "First should have row 0")
    UnitTest.assert_equal(Collections.get_from_dictionary(merged_triplets[1], "row"), "1", "Second should have row 1")

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_matrix_creation_tests":
    Note: Run all matrix creation and conversion tests
    UnitTest.run_test("test_create_sparse_matrix")
    UnitTest.run_test("test_convert_sparse_format")
    UnitTest.run_test("test_dense_to_sparse")
    UnitTest.run_test("test_sparse_to_dense")

Process called "run_basic_operations_tests":
    Note: Run all basic matrix operation tests
    UnitTest.run_test("test_sparse_matrix_multiply")
    UnitTest.run_test("test_sparse_matrix_vector_multiply")
    UnitTest.run_test("test_sparse_matrix_transpose")
    UnitTest.run_test("test_sparse_matrix_add")
    UnitTest.run_test("test_sparse_matrix_scale")

Process called "run_solver_tests":
    Note: Run all solver tests (direct and iterative)
    UnitTest.run_test("test_sparse_lu_factorization")
    UnitTest.run_test("test_sparse_cholesky_factorization")
    UnitTest.run_test("test_sparse_qr_factorization")
    UnitTest.run_test("test_solve_sparse_system")
    UnitTest.run_test("test_conjugate_gradient_sparse")
    UnitTest.run_test("test_gmres_sparse")
    UnitTest.run_test("test_bicgstab_sparse")
    UnitTest.run_test("test_minres_sparse")
    UnitTest.run_test("test_sparse_generalized_eigenvalues")

Process called "run_eigenvalue_tests":
    Note: Run all eigenvalue and SVD tests
    UnitTest.run_test("test_sparse_eigenvalues_arnoldi")
    UnitTest.run_test("test_sparse_eigenvalues_lanczos")
    UnitTest.run_test("test_sparse_singular_values")

Process called "run_ordering_analysis_tests":
    Note: Run all matrix ordering and analysis tests
    UnitTest.run_test("test_compute_amd_ordering")
    UnitTest.run_test("test_compute_nested_dissection")
    UnitTest.run_test("test_compute_rcm_ordering")
    UnitTest.run_test("test_analyze_fill_pattern")
    UnitTest.run_test("test_analyze_sparsity_pattern")
    UnitTest.run_test("test_find_connected_components")
    UnitTest.run_test("test_compute_bandwidth")
    UnitTest.run_test("test_compute_profile")

Process called "run_all_sparse_tests":
    Note: Run comprehensive test suite for all sparse matrix functionality
    Let start_time be DateTime.get_current_timestamp()
    
    UnitTest.start_test_suite("Sparse Matrix Tests")
    
    UnitTest.start_test_group("Matrix Creation and Conversion")
    run_matrix_creation_tests()
    
    UnitTest.start_test_group("Basic Matrix Operations")
    run_basic_operations_tests()
    
    UnitTest.start_test_group("Direct Solvers and Factorizations")
    UnitTest.run_test("test_sparse_lu_factorization")
    UnitTest.run_test("test_sparse_cholesky_factorization")
    UnitTest.run_test("test_sparse_qr_factorization")
    UnitTest.run_test("test_solve_sparse_system")
    
    UnitTest.start_test_group("Iterative Solvers")
    UnitTest.run_test("test_conjugate_gradient_sparse")
    UnitTest.run_test("test_gmres_sparse")
    UnitTest.run_test("test_bicgstab_sparse")
    UnitTest.run_test("test_minres_sparse")
    UnitTest.run_test("test_sparse_generalized_eigenvalues")
    
    UnitTest.start_test_group("Eigenvalue and SVD Computations")
    run_eigenvalue_tests()
    
    UnitTest.start_test_group("Matrix Ordering and Analysis")
    run_ordering_analysis_tests()
    
    UnitTest.start_test_group("Block Sparse Operations")
    UnitTest.run_test("test_create_block_sparse_matrix")
    UnitTest.run_test("test_block_sparse_multiply")
    UnitTest.run_test("test_block_sparse_factorization")
    UnitTest.run_test("test_extract_block")
    
    UnitTest.start_test_group("Preconditioning Operations")
    UnitTest.run_test("test_create_jacobi_preconditioner")
    UnitTest.run_test("test_create_ilu_preconditioner")
    UnitTest.run_test("test_create_ic_preconditioner")
    UnitTest.run_test("test_apply_preconditioner")
    
    UnitTest.start_test_group("Performance Optimization")
    UnitTest.run_test("test_optimize_sparse_storage")
    UnitTest.run_test("test_compress_sparse_indices")
    UnitTest.run_test("test_reorder_for_cache_efficiency")
    UnitTest.run_test("test_parallelize_sparse_operations")
    
    UnitTest.start_test_group("Analysis and Validation")
    UnitTest.run_test("test_sparse_matrix_statistics")
    UnitTest.run_test("test_validate_sparse_format")
    UnitTest.run_test("test_visualize_sparsity_pattern")
    
    UnitTest.start_test_group("Helper Function Operations")
    UnitTest.run_test("test_sort_triplets_by_row")
    UnitTest.run_test("test_triplet_merge_sort")
    UnitTest.run_test("test_triplet_merge")
    
    Let end_time be DateTime.get_current_timestamp()
    Let duration be DateTime.calculate_duration(start_time, end_time)
    
    UnitTest.end_test_suite("Sparse Matrix Tests completed in " ++ duration.to_string() ++ " seconds")

Process called "run_quick_sparse_tests":
    Note: Run essential sparse matrix tests for continuous integration
    UnitTest.start_test_suite("Quick Sparse Tests")
    
    Note: Test core functionality
    UnitTest.run_test("test_create_sparse_matrix")
    UnitTest.run_test("test_sparse_matrix_vector_multiply")
    UnitTest.run_test("test_sparse_lu_factorization")
    UnitTest.run_test("test_conjugate_gradient_sparse")
    UnitTest.run_test("test_sparse_eigenvalues_arnoldi")
    UnitTest.run_test("test_create_jacobi_preconditioner")
    
    UnitTest.end_test_suite("Quick Sparse Tests")

Process called "get_sparse_test_count" returns Integer:
    Note: Return total number of sparse matrix tests
    Return 47