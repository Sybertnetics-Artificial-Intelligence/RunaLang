Note: Comprehensive unit tests for the math/engine/linalg/decomposition module
Note: Tests LU, QR, SVD, eigenvalue decompositions, Cholesky, Schur, and advanced matrix factorizations

Import "dev/test" as UnitTest
Import "stdlib/math/engine/linalg/decomposition" as Decomposition
Import "stdlib/math/engine/linalg/core" as LinalgCore
Import "collections" as Collections

Note: Test helper functions for decomposition testing

Process called "create_test_square_matrix" returns Dictionary[String, Any]:
    Let entries be Collections.create_list([
        Collections.create_list([4.0, 2.0, 1.0]),
        Collections.create_list([2.0, 5.0, 3.0]),
        Collections.create_list([1.0, 3.0, 6.0])
    ])
    Return Collections.create_dictionary([
        ("entries", entries),
        ("rows", 3),
        ("columns", 3),
        ("is_positive_definite", true),
        ("is_symmetric", true)
    ])

Process called "create_test_rectangular_matrix" returns Dictionary[String, Any]:
    Let entries be Collections.create_list([
        Collections.create_list([1.0, 2.0, 3.0]),
        Collections.create_list([4.0, 5.0, 6.0]),
        Collections.create_list([7.0, 8.0, 9.0]),
        Collections.create_list([10.0, 11.0, 12.0])
    ])
    Return Collections.create_dictionary([
        ("entries", entries),
        ("rows", 4),
        ("columns", 3)
    ])

Process called "create_symmetric_matrix" returns Dictionary[String, Any]:
    Let entries be Collections.create_list([
        Collections.create_list([3.0, 1.0, 2.0]),
        Collections.create_list([1.0, 4.0, 0.0]),
        Collections.create_list([2.0, 0.0, 5.0])
    ])
    Return Collections.create_dictionary([
        ("entries", entries),
        ("is_symmetric", true),
        ("has_real_eigenvalues", true)
    ])

Process called "assert_decomposition_accuracy" that takes original as Dictionary[String, Any], reconstructed as Dictionary[String, Any], tolerance as Float, message as String:
    Let max_diff be 0.0
    Let rows be LinalgCore.matrix_rows(original)
    Let cols be LinalgCore.matrix_columns(original)
    
    For i = 0 to rows - 1:
        For j = 0 to cols - 1:
            Let orig_entry be LinalgCore.get_matrix_entry(original, i, j)
            Let recon_entry be LinalgCore.get_matrix_entry(reconstructed, i, j)
            Let diff be LinalgCore.abs(orig_entry - recon_entry)
            If diff > max_diff:
                max_diff = diff
    
    UnitTest.assert_true(max_diff < tolerance, message + " - Max difference: " + UnitTest.to_string(max_diff))

Process called "assert_orthogonal_matrix" that takes matrix as Dictionary[String, Any], tolerance as Float, message as String:
    Let transpose be LinalgCore.matrix_transpose(matrix)
    Let product be LinalgCore.multiply_matrices(matrix, transpose)
    Let identity be LinalgCore.create_identity_matrix(LinalgCore.matrix_rows(matrix))
    
    assert_decomposition_accuracy(product, identity, tolerance, message + " - Should be orthogonal")

Process called "assert_upper_triangular" that takes matrix as Dictionary[String, Any], tolerance as Float, message as String:
    Let rows be LinalgCore.matrix_rows(matrix)
    Let cols be LinalgCore.matrix_columns(matrix)
    
    For i = 0 to rows - 1:
        For j = 0 to i - 1:
            If j < cols:
                Let entry be LinalgCore.get_matrix_entry(matrix, i, j)
                UnitTest.assert_true(LinalgCore.abs(entry) < tolerance, message + " - Should be upper triangular")

Note: LU Decomposition Tests

Process called "test_lu_decomposition":
    Let data be create_test_square_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let lu_result be Decomposition.lu_decomposition(matrix)
    
    UnitTest.assert_true(lu_result.decomposition_successful, "LU decomposition should succeed")
    UnitTest.assert_true(Collections.has_key(lu_result, "L"), "Should contain L matrix")
    UnitTest.assert_true(Collections.has_key(lu_result, "U"), "Should contain U matrix")
    
    Let reconstructed be LinalgCore.multiply_matrices(lu_result.L, lu_result.U)
    assert_decomposition_accuracy(matrix, reconstructed, 1e-12, "LU reconstruction")

Process called "test_lu_with_partial_pivoting":
    Let data be create_test_square_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let plu_result be Decomposition.lu_with_partial_pivoting(matrix)
    
    UnitTest.assert_true(plu_result.decomposition_successful, "PLU decomposition should succeed")
    UnitTest.assert_true(Collections.has_key(plu_result, "P"), "Should contain P matrix")
    UnitTest.assert_true(Collections.has_key(plu_result, "L"), "Should contain L matrix")
    UnitTest.assert_true(Collections.has_key(plu_result, "U"), "Should contain U matrix")
    
    Let PA be LinalgCore.multiply_matrices(plu_result.P, matrix)
    Let LU be LinalgCore.multiply_matrices(plu_result.L, plu_result.U)
    assert_decomposition_accuracy(PA, LU, 1e-12, "PLU reconstruction")

Process called "test_lu_with_complete_pivoting":
    Let data be create_test_square_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let result be Decomposition.lu_with_complete_pivoting(matrix)
    
    UnitTest.assert_true(result.decomposition_successful, "Complete pivoting LU should succeed")
    UnitTest.assert_true(Collections.has_key(result, "P"), "Should contain row permutation matrix")
    UnitTest.assert_true(Collections.has_key(result, "Q"), "Should contain column permutation matrix")

Process called "test_block_lu_decomposition":
    Let large_matrix_entries be Collections.create_list()
    For i = 0 to 5:
        Let row be Collections.create_list()
        For j = 0 to 5:
            Collections.add_to_list(row, (i + j + 1) * 1.0)
        Collections.add_to_list(large_matrix_entries, row)
    
    Let large_matrix be LinalgCore.create_matrix(large_matrix_entries)
    Let block_size be 2
    Let result be Decomposition.block_lu_decomposition(large_matrix, block_size)
    
    UnitTest.assert_true(result.decomposition_successful, "Block LU decomposition should succeed")

Process called "test_solve_with_lu":
    Let data be create_test_square_matrix()
    Let A be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let b be LinalgCore.create_vector(Collections.create_list([1.0, 2.0, 3.0]))
    Let lu_result be Decomposition.lu_decomposition(A)
    Let solution be Decomposition.solve_with_lu(lu_result, b)
    
    UnitTest.assert_true(LinalgCore.is_valid_vector(solution), "LU solution should be valid")
    Let verification be LinalgCore.multiply_matrix_vector(A, solution)
    assert_decomposition_accuracy(LinalgCore.vector_to_matrix(b), LinalgCore.vector_to_matrix(verification), 1e-10, "LU solve verification")

Note: QR Decomposition Tests

Process called "test_qr_decomposition":
    Let data be create_test_rectangular_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let qr_result be Decomposition.qr_decomposition(matrix)
    
    UnitTest.assert_true(qr_result.decomposition_successful, "QR decomposition should succeed")
    UnitTest.assert_true(Collections.has_key(qr_result, "Q"), "Should contain Q matrix")
    UnitTest.assert_true(Collections.has_key(qr_result, "R"), "Should contain R matrix")
    
    assert_orthogonal_matrix(qr_result.Q, 1e-12, "Q matrix should be orthogonal")
    assert_upper_triangular(qr_result.R, 1e-12, "R matrix should be upper triangular")
    
    Let reconstructed be LinalgCore.multiply_matrices(qr_result.Q, qr_result.R)
    assert_decomposition_accuracy(matrix, reconstructed, 1e-12, "QR reconstruction")

Process called "test_householder_qr":
    Let data be create_test_square_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let result be Decomposition.householder_qr(matrix)
    
    UnitTest.assert_true(result.decomposition_successful, "Householder QR should succeed")
    UnitTest.assert_equals(result.algorithm_used, "householder", "Should use Householder reflections")

Process called "test_givens_qr":
    Let data be create_test_square_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let result be Decomposition.givens_qr(matrix)
    
    UnitTest.assert_true(result.decomposition_successful, "Givens QR should succeed")
    UnitTest.assert_equals(result.algorithm_used, "givens", "Should use Givens rotations")

Process called "test_modified_gram_schmidt_qr":
    Let data be create_test_rectangular_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let result be Decomposition.modified_gram_schmidt_qr(matrix)
    
    UnitTest.assert_true(result.decomposition_successful, "Modified Gram-Schmidt QR should succeed")
    UnitTest.assert_equals(result.algorithm_used, "modified_gram_schmidt", "Should use MGS algorithm")

Process called "test_column_pivoting_qr":
    Let data be create_test_rectangular_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let result be Decomposition.column_pivoting_qr(matrix)
    
    UnitTest.assert_true(result.decomposition_successful, "Column pivoting QR should succeed")
    UnitTest.assert_true(Collections.has_key(result, "P"), "Should contain permutation matrix")

Process called "test_solve_with_qr":
    Let data be create_test_square_matrix()
    Let A be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let b be LinalgCore.create_vector(Collections.create_list([1.0, 2.0, 3.0]))
    Let qr_result be Decomposition.qr_decomposition(A)
    Let solution be Decomposition.solve_with_qr(qr_result, b)
    
    UnitTest.assert_true(LinalgCore.is_valid_vector(solution), "QR solution should be valid")

Note: SVD Tests

Process called "test_singular_value_decomposition":
    Let data be create_test_rectangular_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let svd_result be Decomposition.singular_value_decomposition(matrix)
    
    UnitTest.assert_true(svd_result.decomposition_successful, "SVD should succeed")
    UnitTest.assert_true(Collections.has_key(svd_result, "U"), "Should contain U matrix")
    UnitTest.assert_true(Collections.has_key(svd_result, "S"), "Should contain S matrix")
    UnitTest.assert_true(Collections.has_key(svd_result, "V"), "Should contain V matrix")
    
    assert_orthogonal_matrix(svd_result.U, 1e-12, "U matrix should be orthogonal")
    assert_orthogonal_matrix(svd_result.V, 1e-12, "V matrix should be orthogonal")
    
    UnitTest.assert_true(Collections.size(svd_result.singular_values) > 0, "Should have singular values")

Process called "test_jacobi_svd":
    Let data be create_test_square_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let result be Decomposition.jacobi_svd(matrix)
    
    UnitTest.assert_true(result.decomposition_successful, "Jacobi SVD should succeed")
    UnitTest.assert_equals(result.algorithm_used, "jacobi", "Should use Jacobi algorithm")

Process called "test_bidiagonal_svd":
    Let data be create_test_square_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let result be Decomposition.bidiagonal_svd(matrix)
    
    UnitTest.assert_true(result.decomposition_successful, "Bidiagonal SVD should succeed")
    UnitTest.assert_true(result.convergence_achieved, "Should achieve convergence")

Process called "test_divide_and_conquer_svd":
    Let data be create_test_rectangular_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let result be Decomposition.divide_and_conquer_svd(matrix)
    
    UnitTest.assert_true(result.decomposition_successful, "Divide and conquer SVD should succeed")
    UnitTest.assert_equals(result.algorithm_used, "divide_and_conquer", "Should use D&C algorithm")

Process called "test_randomized_svd":
    Let data be create_test_rectangular_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let rank_approximation be 2
    Let result be Decomposition.randomized_svd(matrix, rank_approximation)
    
    UnitTest.assert_true(result.decomposition_successful, "Randomized SVD should succeed")
    UnitTest.assert_true(result.rank <= rank_approximation, "Should respect rank approximation")

Process called "test_truncated_svd":
    Let data be create_test_rectangular_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let k be 2
    Let result be Decomposition.truncated_svd(matrix, k)
    
    UnitTest.assert_true(result.decomposition_successful, "Truncated SVD should succeed")
    UnitTest.assert_equals(Collections.size(result.singular_values), k, "Should have k singular values")

Note: Eigenvalue Decomposition Tests

Process called "test_eigenvalue_decomposition":
    Let data be create_symmetric_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let eigen_result be Decomposition.eigenvalue_decomposition(matrix)
    
    UnitTest.assert_true(eigen_result.decomposition_successful, "Eigenvalue decomposition should succeed")
    UnitTest.assert_true(Collections.has_key(eigen_result, "eigenvalues"), "Should contain eigenvalues")
    UnitTest.assert_true(Collections.has_key(eigen_result, "eigenvectors"), "Should contain eigenvectors")
    UnitTest.assert_true(Collections.size(eigen_result.eigenvalues) > 0, "Should have eigenvalues")

Process called "test_symmetric_eigendecomposition":
    Let data be create_symmetric_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let result be Decomposition.symmetric_eigendecomposition(matrix)
    
    UnitTest.assert_true(result.decomposition_successful, "Symmetric eigendecomposition should succeed")
    UnitTest.assert_true(result.all_eigenvalues_real, "Symmetric matrix should have real eigenvalues")

Process called "test_power_iteration_eigenvalues":
    Let data be create_symmetric_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let result be Decomposition.power_iteration_eigenvalues(matrix)
    
    UnitTest.assert_true(result.iteration_converged, "Power iteration should converge")
    UnitTest.assert_true(result.dominant_eigenvalue_found, "Should find dominant eigenvalue")

Process called "test_qr_algorithm_eigenvalues":
    Let data be create_symmetric_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let result be Decomposition.qr_algorithm_eigenvalues(matrix)
    
    UnitTest.assert_true(result.algorithm_converged, "QR algorithm should converge")
    UnitTest.assert_equals(result.algorithm_used, "qr_iteration", "Should use QR iteration")

Process called "test_jacobi_eigenvalue_algorithm":
    Let data be create_symmetric_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let result be Decomposition.jacobi_eigenvalue_algorithm(matrix)
    
    UnitTest.assert_true(result.decomposition_successful, "Jacobi eigenvalue algorithm should succeed")
    UnitTest.assert_equals(result.algorithm_used, "jacobi", "Should use Jacobi method")

Process called "test_lanczos_eigenvalues":
    Let data be create_symmetric_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let num_eigenvalues be 2
    Let result be Decomposition.lanczos_eigenvalues(matrix, num_eigenvalues)
    
    UnitTest.assert_true(result.algorithm_converged, "Lanczos algorithm should converge")
    UnitTest.assert_true(Collections.size(result.eigenvalues) <= num_eigenvalues, "Should find requested eigenvalues")

Note: Cholesky Decomposition Tests

Process called "test_cholesky_decomposition":
    Let pd_entries be Collections.create_list([
        Collections.create_list([4.0, 2.0, 1.0]),
        Collections.create_list([2.0, 5.0, 3.0]),
        Collections.create_list([1.0, 3.0, 6.0])
    ])
    Let pd_matrix be LinalgCore.create_matrix(pd_entries)
    Let chol_result be Decomposition.cholesky_decomposition(pd_matrix)
    
    UnitTest.assert_true(chol_result.decomposition_successful, "Cholesky decomposition should succeed")
    UnitTest.assert_true(Collections.has_key(chol_result, "L"), "Should contain L matrix")
    
    Let L_transpose be LinalgCore.matrix_transpose(chol_result.L)
    Let reconstructed be LinalgCore.multiply_matrices(chol_result.L, L_transpose)
    assert_decomposition_accuracy(pd_matrix, reconstructed, 1e-12, "Cholesky reconstruction")

Process called "test_ldlt_decomposition":
    Let symmetric_entries be Collections.create_list([
        Collections.create_list([4.0, 2.0, 1.0]),
        Collections.create_list([2.0, 5.0, 3.0]),
        Collections.create_list([1.0, 3.0, 6.0])
    ])
    Let symmetric_matrix be LinalgCore.create_matrix(symmetric_entries)
    Let result be Decomposition.ldlt_decomposition(symmetric_matrix)
    
    UnitTest.assert_true(result.decomposition_successful, "LDLT decomposition should succeed")
    UnitTest.assert_true(Collections.has_key(result, "L"), "Should contain L matrix")
    UnitTest.assert_true(Collections.has_key(result, "D"), "Should contain D matrix")

Note: Schur Decomposition Tests

Process called "test_schur_decomposition":
    Let data be create_test_square_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let schur_result be Decomposition.schur_decomposition(matrix)
    
    UnitTest.assert_true(schur_result.decomposition_successful, "Schur decomposition should succeed")
    UnitTest.assert_true(Collections.has_key(schur_result, "Q"), "Should contain Q matrix")
    UnitTest.assert_true(Collections.has_key(schur_result, "T"), "Should contain T matrix")
    
    assert_orthogonal_matrix(schur_result.Q, 1e-12, "Q matrix should be orthogonal")
    assert_upper_triangular(schur_result.T, 1e-12, "T matrix should be upper triangular")

Process called "test_real_schur_decomposition":
    Let data be create_symmetric_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let result be Decomposition.real_schur_decomposition(matrix)
    
    UnitTest.assert_true(result.decomposition_successful, "Real Schur decomposition should succeed")
    UnitTest.assert_true(result.is_real_schur_form, "Should be in real Schur form")

Note: Advanced Decomposition Tests

Process called "test_polar_decomposition":
    Let data be create_test_square_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let result be Decomposition.polar_decomposition(matrix)
    
    UnitTest.assert_true(result.decomposition_successful, "Polar decomposition should succeed")
    UnitTest.assert_true(Collections.has_key(result, "U"), "Should contain unitary matrix U")
    UnitTest.assert_true(Collections.has_key(result, "P"), "Should contain positive semidefinite matrix P")

Process called "test_matrix_exponential":
    Let data be create_test_square_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let result be Decomposition.matrix_exponential(matrix)
    
    UnitTest.assert_true(result.computation_successful, "Matrix exponential should succeed")
    UnitTest.assert_true(LinalgCore.is_valid_matrix(result.exponential), "Should be valid matrix")

Process called "test_matrix_logarithm":
    Let pd_entries be Collections.create_list([
        Collections.create_list([2.0, 1.0]),
        Collections.create_list([1.0, 2.0])
    ])
    Let pd_matrix be LinalgCore.create_matrix(pd_entries)
    Let result be Decomposition.matrix_logarithm(pd_matrix)
    
    UnitTest.assert_true(result.computation_successful, "Matrix logarithm should succeed")
    UnitTest.assert_true(LinalgCore.is_valid_matrix(result.logarithm), "Should be valid matrix")

Process called "test_matrix_square_root":
    Let pd_entries be Collections.create_list([
        Collections.create_list([4.0, 2.0]),
        Collections.create_list([2.0, 5.0])
    ])
    Let pd_matrix be LinalgCore.create_matrix(pd_entries)
    Let result be Decomposition.matrix_square_root(pd_matrix)
    
    UnitTest.assert_true(result.computation_successful, "Matrix square root should succeed")
    Let verification be LinalgCore.multiply_matrices(result.square_root, result.square_root)
    assert_decomposition_accuracy(pd_matrix, verification, 1e-10, "Square root verification")

Process called "test_generalized_eigenvalue_problem":
    Let A_entries be Collections.create_list([
        Collections.create_list([2.0, 1.0]),
        Collections.create_list([1.0, 2.0])
    ])
    Let B_entries be Collections.create_list([
        Collections.create_list([1.0, 0.0]),
        Collections.create_list([0.0, 1.0])
    ])
    Let A be LinalgCore.create_matrix(A_entries)
    Let B be LinalgCore.create_matrix(B_entries)
    Let result be Decomposition.generalized_eigenvalue_problem(A, B)
    
    UnitTest.assert_true(result.problem_solved, "Generalized eigenvalue problem should be solved")
    UnitTest.assert_true(Collections.size(result.eigenvalues) > 0, "Should have eigenvalues")

Note: Performance and Stability Tests

Process called "test_iterative_refinement":
    Let data be create_test_square_matrix()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let b be LinalgCore.create_vector(Collections.create_list([1.0, 2.0, 3.0]))
    Let result be Decomposition.solve_with_iterative_refinement(matrix, b)
    
    UnitTest.assert_true(result.refinement_converged, "Iterative refinement should converge")
    UnitTest.assert_true(result.accuracy_improved, "Should improve solution accuracy")

Process called "test_stability_analysis":
    Let hilbert_matrix be LinalgCore.create_hilbert_matrix(5)
    Let analysis = Decomposition.analyze_decomposition_stability(hilbert_matrix)
    
    UnitTest.assert_true(analysis.analysis_completed, "Stability analysis should complete")
    UnitTest.assert_true(Collections.has_key(analysis, "condition_number"), "Should compute condition number")
    UnitTest.assert_true(Collections.has_key(analysis, "backward_error"), "Should compute backward error")

Process called "test_parallel_decomposition":
    Let large_matrix_entries be Collections.create_list()
    For i = 0 to 49:
        Let row be Collections.create_list()
        For j = 0 to 49:
            Collections.add_to_list(row, LinalgCore.random_float(0.0, 1.0))
        Collections.add_to_list(large_matrix_entries, row)
    
    Let large_matrix be LinalgCore.create_matrix(large_matrix_entries)
    Let result be Decomposition.parallel_lu_decomposition(large_matrix)
    
    UnitTest.assert_true(result.decomposition_successful, "Parallel decomposition should succeed")
    UnitTest.assert_true(result.parallelization_effective, "Should use parallelization effectively")

Process called "test_block_decomposition":
    Let large_matrix_entries be Collections.create_list()
    For i = 0 to 7:
        Let row be Collections.create_list()
        For j = 0 to 7:
            Collections.add_to_list(row, (i + j + 1) * 1.0)
        Collections.add_to_list(large_matrix_entries, row)
    
    Let large_matrix be LinalgCore.create_matrix(large_matrix_entries)
    Let block_size be 2
    Let result be Decomposition.block_qr_decomposition(large_matrix, block_size)
    
    UnitTest.assert_true(result.decomposition_successful, "Block decomposition should succeed")

Note: Test suite coordination

Process called "run_all_decomposition_tests":
    UnitTest.start_test_suite("Math Engine Linalg Decomposition Module Tests")
    
    Note: LU decomposition tests
    UnitTest.run_test("LU Decomposition", test_lu_decomposition)
    UnitTest.run_test("LU with Partial Pivoting", test_lu_with_partial_pivoting)
    UnitTest.run_test("LU with Complete Pivoting", test_lu_with_complete_pivoting)
    UnitTest.run_test("Block LU Decomposition", test_block_lu_decomposition)
    UnitTest.run_test("Solve with LU", test_solve_with_lu)
    
    Note: QR decomposition tests
    UnitTest.run_test("QR Decomposition", test_qr_decomposition)
    UnitTest.run_test("Householder QR", test_householder_qr)
    UnitTest.run_test("Givens QR", test_givens_qr)
    UnitTest.run_test("Modified Gram-Schmidt QR", test_modified_gram_schmidt_qr)
    UnitTest.run_test("Column Pivoting QR", test_column_pivoting_qr)
    UnitTest.run_test("Solve with QR", test_solve_with_qr)
    
    Note: SVD tests
    UnitTest.run_test("Singular Value Decomposition", test_singular_value_decomposition)
    UnitTest.run_test("Jacobi SVD", test_jacobi_svd)
    UnitTest.run_test("Bidiagonal SVD", test_bidiagonal_svd)
    UnitTest.run_test("Divide and Conquer SVD", test_divide_and_conquer_svd)
    UnitTest.run_test("Randomized SVD", test_randomized_svd)
    UnitTest.run_test("Truncated SVD", test_truncated_svd)
    
    Note: Eigenvalue decomposition tests
    UnitTest.run_test("Eigenvalue Decomposition", test_eigenvalue_decomposition)
    UnitTest.run_test("Symmetric Eigendecomposition", test_symmetric_eigendecomposition)
    UnitTest.run_test("Power Iteration Eigenvalues", test_power_iteration_eigenvalues)
    UnitTest.run_test("QR Algorithm Eigenvalues", test_qr_algorithm_eigenvalues)
    UnitTest.run_test("Jacobi Eigenvalue Algorithm", test_jacobi_eigenvalue_algorithm)
    UnitTest.run_test("Lanczos Eigenvalues", test_lanczos_eigenvalues)
    
    Note: Cholesky decomposition tests
    UnitTest.run_test("Cholesky Decomposition", test_cholesky_decomposition)
    UnitTest.run_test("LDLT Decomposition", test_ldlt_decomposition)
    
    Note: Schur decomposition tests
    UnitTest.run_test("Schur Decomposition", test_schur_decomposition)
    UnitTest.run_test("Real Schur Decomposition", test_real_schur_decomposition)
    
    Note: Advanced decomposition tests
    UnitTest.run_test("Polar Decomposition", test_polar_decomposition)
    UnitTest.run_test("Matrix Exponential", test_matrix_exponential)
    UnitTest.run_test("Matrix Logarithm", test_matrix_logarithm)
    UnitTest.run_test("Matrix Square Root", test_matrix_square_root)
    UnitTest.run_test("Generalized Eigenvalue Problem", test_generalized_eigenvalue_problem)
    
    Note: Performance and stability tests
    UnitTest.run_test("Iterative Refinement", test_iterative_refinement)
    UnitTest.run_test("Stability Analysis", test_stability_analysis)
    UnitTest.run_test("Parallel Decomposition", test_parallel_decomposition)
    UnitTest.run_test("Block Decomposition", test_block_decomposition)
    
    Let results be UnitTest.end_test_suite()
    Return results

Process called "get_decomposition_test_count" returns Integer:
    Return 34

Process called "get_decomposition_test_categories" returns List[String]:
    Return Collections.create_list([
        "LU Decomposition",
        "QR Decomposition",
        "SVD",
        "Eigenvalue Decomposition",
        "Cholesky Decomposition",
        "Schur Decomposition",
        "Advanced Decompositions",
        "Performance and Stability"
    ])