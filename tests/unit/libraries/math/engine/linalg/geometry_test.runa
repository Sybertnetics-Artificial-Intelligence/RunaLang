Note: Comprehensive unit tests for the math/engine/linalg/geometry module
Note: Tests computational geometry operations, spatial transformations, convex hulls, and geometric algorithms

Import "dev/test" as UnitTest
Import "stdlib/math/engine/linalg/geometry" as Geometry
Import "stdlib/math/engine/linalg/core" as LinalgCore
Import "collections" as Collections

Note: Test helper functions for geometry testing

Process called "create_test_points_2d" returns List[Dictionary[String, Any]]:
    Return Collections.create_list([
        Collections.create_dictionary([("x", 0.0), ("y", 0.0)]),
        Collections.create_dictionary([("x", 1.0), ("y", 0.0)]),
        Collections.create_dictionary([("x", 1.0), ("y", 1.0)]),
        Collections.create_dictionary([("x", 0.0), ("y", 1.0)]),
        Collections.create_dictionary([("x", 0.5), ("y", 0.5)])
    ])

Process called "create_test_points_3d" returns List[Dictionary[String, Any]]:
    Return Collections.create_list([
        Collections.create_dictionary([("x", 0.0), ("y", 0.0), ("z", 0.0)]),
        Collections.create_dictionary([("x", 1.0), ("y", 0.0), ("z", 0.0)]),
        Collections.create_dictionary([("x", 0.0), ("y", 1.0), ("z", 0.0)]),
        Collections.create_dictionary([("x", 0.0), ("y", 0.0), ("z", 1.0)]),
        Collections.create_dictionary([("x", 0.5), ("y", 0.5), ("z", 0.5)])
    ])

Process called "create_test_line_3d" returns Dictionary[String, Any]:
    Return Collections.create_dictionary([
        ("point", Collections.create_dictionary([("x", 1.0), ("y", 2.0), ("z", 3.0)])),
        ("direction", Collections.create_dictionary([("x", 1.0), ("y", 0.0), ("z", 0.0)]))
    ])

Process called "create_test_plane" returns Dictionary[String, Any]:
    Return Collections.create_dictionary([
        ("point", Collections.create_dictionary([("x", 0.0), ("y", 0.0), ("z", 1.0)])),
        ("normal", Collections.create_dictionary([("x", 0.0), ("y", 0.0), ("z", 1.0)]))
    ])

Process called "assert_point_equality" that takes point1 as Dictionary[String, Any], point2 as Dictionary[String, Any], tolerance as Float, message as String:
    If Collections.has_key(point1, "z") and Collections.has_key(point2, "z"):
        Note: 3D points
        UnitTest.assert_true(LinalgCore.abs(Collections.get_from_dictionary(point1, "x") - Collections.get_from_dictionary(point2, "x")) < tolerance, message + " - X coordinate")
        UnitTest.assert_true(LinalgCore.abs(Collections.get_from_dictionary(point1, "y") - Collections.get_from_dictionary(point2, "y")) < tolerance, message + " - Y coordinate")
        UnitTest.assert_true(LinalgCore.abs(Collections.get_from_dictionary(point1, "z") - Collections.get_from_dictionary(point2, "z")) < tolerance, message + " - Z coordinate")
    Otherwise:
        Note: 2D points
        UnitTest.assert_true(LinalgCore.abs(Collections.get_from_dictionary(point1, "x") - Collections.get_from_dictionary(point2, "x")) < tolerance, message + " - X coordinate")
        UnitTest.assert_true(LinalgCore.abs(Collections.get_from_dictionary(point1, "y") - Collections.get_from_dictionary(point2, "y")) < tolerance, message + " - Y coordinate")

Process called "assert_vector_equality" that takes vector1 as Dictionary[String, Any], vector2 as Dictionary[String, Any], tolerance as Float, message as String:
    assert_point_equality(vector1, vector2, tolerance, message)

Process called "assert_numerical_close" that takes actual as Float, expected as Float, tolerance as Float, message as String:
    UnitTest.assert_true(LinalgCore.abs(actual - expected) < tolerance, message + " - Expected: " + UnitTest.to_string(expected) + ", Actual: " + UnitTest.to_string(actual))

Note: Basic Geometric Operations Tests

Process called "test_distance_between_points":
    Let point1 be Collections.create_dictionary([("x", 0.0), ("y", 0.0)])
    Let point2 be Collections.create_dictionary([("x", 3.0), ("y", 4.0)])
    Let distance be Geometry.distance_between_points(point1, point2)
    
    assert_numerical_close(distance, 5.0, 1e-10, "Distance should be 5 (3-4-5 triangle)")

Process called "test_distance_between_points_3d":
    Let point1 be Collections.create_dictionary([("x", 0.0), ("y", 0.0), ("z", 0.0)])
    Let point2 be Collections.create_dictionary([("x", 1.0), ("y", 2.0), ("z", 2.0)])
    Let distance be Geometry.distance_between_points(point1, point2)
    
    assert_numerical_close(distance, 3.0, 1e-10, "Distance should be 3")

Process called "test_dot_product_vectors":
    Let vector1 be Collections.create_dictionary([("x", 1.0), ("y", 2.0), ("z", 3.0)])
    Let vector2 be Collections.create_dictionary([("x", 4.0), ("y", 5.0), ("z", 6.0)])
    Let dot_product be Geometry.dot_product(vector1, vector2)
    
    assert_numerical_close(dot_product, 32.0, 1e-10, "Dot product should be 1*4 + 2*5 + 3*6 = 32")

Process called "test_cross_product_vectors":
    Let vector1 be Collections.create_dictionary([("x", 1.0), ("y", 0.0), ("z", 0.0)])
    Let vector2 be Collections.create_dictionary([("x", 0.0), ("y", 1.0), ("z", 0.0)])
    Let cross_product be Geometry.cross_product(vector1, vector2)
    
    assert_vector_equality(cross_product, Collections.create_dictionary([("x", 0.0), ("y", 0.0), ("z", 1.0)]), 1e-10, "Cross product of i and j should be k")

Process called "test_vector_magnitude":
    Let vector be Collections.create_dictionary([("x", 3.0), ("y", 4.0), ("z", 0.0)])
    Let magnitude be Geometry.vector_magnitude(vector)
    
    assert_numerical_close(magnitude, 5.0, 1e-10, "Magnitude should be 5")

Process called "test_normalize_vector":
    Let vector be Collections.create_dictionary([("x", 3.0), ("y", 4.0), ("z", 0.0)])
    Let normalized be Geometry.normalize_vector(vector)
    
    assert_numerical_close(Collections.get_from_dictionary(normalized, "x"), 0.6, 1e-10, "Normalized x component")
    assert_numerical_close(Collections.get_from_dictionary(normalized, "y"), 0.8, 1e-10, "Normalized y component")
    assert_numerical_close(Collections.get_from_dictionary(normalized, "z"), 0.0, 1e-10, "Normalized z component")
    assert_numerical_close(Geometry.vector_magnitude(normalized), 1.0, 1e-10, "Normalized vector should have unit length")

Note: Linear Transformation Tests

Process called "test_apply_transformation":
    Let transformation_matrix be LinalgCore.create_matrix(Collections.create_list([
        Collections.create_list([2.0, 0.0, 0.0]),
        Collections.create_list([0.0, 2.0, 0.0]),
        Collections.create_list([0.0, 0.0, 2.0])
    ]))
    Let point be Collections.create_dictionary([("x", 1.0), ("y", 2.0), ("z", 3.0)])
    Let transformed = Geometry.apply_transformation(transformation_matrix, point)
    
    assert_point_equality(transformed, Collections.create_dictionary([("x", 2.0), ("y", 4.0), ("z", 6.0)]), 1e-10, "Scaling transformation")

Process called "test_compose_transformations":
    Let scale_matrix be LinalgCore.create_matrix(Collections.create_list([
        Collections.create_list([2.0, 0.0, 0.0]),
        Collections.create_list([0.0, 2.0, 0.0]),
        Collections.create_list([0.0, 0.0, 2.0])
    ]))
    Let rotation_matrix be LinalgCore.create_matrix(Collections.create_list([
        Collections.create_list([1.0, 0.0, 0.0]),
        Collections.create_list([0.0, 0.0, -1.0]),
        Collections.create_list([0.0, 1.0, 0.0])
    ]))
    Let composed be Geometry.compose_transformations(scale_matrix, rotation_matrix)
    
    UnitTest.assert_equals(LinalgCore.matrix_rows(composed), 3, "Composed transformation should be 3x3")
    UnitTest.assert_equals(LinalgCore.matrix_columns(composed), 3, "Composed transformation should be 3x3")

Process called "test_invert_transformation":
    Let scale_matrix be LinalgCore.create_matrix(Collections.create_list([
        Collections.create_list([2.0, 0.0, 0.0]),
        Collections.create_list([0.0, 3.0, 0.0]),
        Collections.create_list([0.0, 0.0, 4.0])
    ]))
    Let inverse be Geometry.invert_transformation(scale_matrix)
    Let identity_check be LinalgCore.multiply_matrices(scale_matrix, inverse)
    
    UnitTest.assert_true(LinalgCore.is_identity_matrix(identity_check), "T * T^(-1) should be identity")

Process called "test_create_rotation_matrix":
    Let angle be 3.14159/2.0  Note: 90 degrees
    Let axis be Collections.create_dictionary([("x", 0.0), ("y", 0.0), ("z", 1.0)])
    Let rotation_matrix be Geometry.create_rotation_matrix(angle, axis)
    
    UnitTest.assert_true(LinalgCore.is_orthogonal(rotation_matrix), "Rotation matrix should be orthogonal")
    assert_numerical_close(LinalgCore.matrix_determinant(rotation_matrix), 1.0, 1e-10, "Rotation matrix determinant should be 1")

Process called "test_create_scaling_matrix":
    Let scale_factors be Collections.create_dictionary([("x", 2.0), ("y", 3.0), ("z", 4.0)])
    Let scaling_matrix be Geometry.create_scaling_matrix(scale_factors)
    
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(scaling_matrix, 0, 0), 2.0, "X scaling factor")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(scaling_matrix, 1, 1), 3.0, "Y scaling factor")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(scaling_matrix, 2, 2), 4.0, "Z scaling factor")

Note: Affine Transformation Tests

Process called "test_apply_affine_transformation":
    Let linear_part be LinalgCore.create_identity_matrix(3)
    Let translation be Collections.create_dictionary([("x", 1.0), ("y", 2.0), ("z", 3.0)])
    Let affine_transform be Geometry.create_affine_transformation(linear_part, translation)
    
    Let point be Collections.create_dictionary([("x", 5.0), ("y", 6.0), ("z", 7.0)])
    Let transformed be Geometry.apply_affine_transformation(affine_transform, point)
    
    assert_point_equality(transformed, Collections.create_dictionary([("x", 6.0), ("y", 8.0), ("z", 10.0)]), 1e-10, "Affine transformation with translation")

Process called "test_create_translation":
    Let translation_vector be Collections.create_dictionary([("x", 3.0), ("y", 4.0), ("z", 5.0)])
    Let translation_matrix be Geometry.create_translation(translation_vector)
    
    UnitTest.assert_equals(LinalgCore.matrix_rows(translation_matrix), 4, "Translation matrix should be 4x4")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(translation_matrix, 0, 3), 3.0, "X translation component")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(translation_matrix, 1, 3), 4.0, "Y translation component")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(translation_matrix, 2, 3), 5.0, "Z translation component")

Process called "test_create_affine_from_points":
    Let source_points be Collections.create_list([
        Collections.create_dictionary([("x", 0.0), ("y", 0.0)]),
        Collections.create_dictionary([("x", 1.0), ("y", 0.0)]),
        Collections.create_dictionary([("x", 0.0), ("y", 1.0)])
    ])
    Let target_points be Collections.create_list([
        Collections.create_dictionary([("x", 1.0), ("y", 1.0)]),
        Collections.create_dictionary([("x", 2.0), ("y", 1.0)]),
        Collections.create_dictionary([("x", 1.0), ("y", 2.0)])
    ])
    Let affine_transform be Geometry.create_affine_from_points(source_points, target_points)
    
    UnitTest.assert_true(affine_transform.transformation_computed, "Affine transformation should be computed")

Note: Intersection Algorithm Tests

Process called "test_line_line_intersection":
    Let line1 be Collections.create_dictionary([
        ("point", Collections.create_dictionary([("x", 0.0), ("y", 0.0)])),
        ("direction", Collections.create_dictionary([("x", 1.0), ("y", 0.0)]))
    ])
    Let line2 be Collections.create_dictionary([
        ("point", Collections.create_dictionary([("x", 0.0), ("y", 0.0)])),
        ("direction", Collections.create_dictionary([("x", 0.0), ("y", 1.0)]))
    ])
    Let intersection be Geometry.line_line_intersection(line1, line2)
    
    UnitTest.assert_true(intersection.intersection_exists, "Lines should intersect")
    assert_point_equality(intersection.intersection_point, Collections.create_dictionary([("x", 0.0), ("y", 0.0)]), 1e-10, "Intersection at origin")

Process called "test_line_plane_intersection":
    Let line be create_test_line_3d()
    Let plane be create_test_plane()
    Let intersection be Geometry.line_plane_intersection(line, plane)
    
    UnitTest.assert_true(intersection.intersection_exists, "Line should intersect plane")
    UnitTest.assert_true(Collections.has_key(intersection, "intersection_point"), "Should have intersection point")

Process called "test_plane_plane_intersection":
    Let plane1 be Collections.create_dictionary([
        ("point", Collections.create_dictionary([("x", 0.0), ("y", 0.0), ("z", 0.0)])),
        ("normal", Collections.create_dictionary([("x", 1.0), ("y", 0.0), ("z", 0.0)]))
    ])
    Let plane2 be Collections.create_dictionary([
        ("point", Collections.create_dictionary([("x", 0.0), ("y", 0.0), ("z", 0.0)])),
        ("normal", Collections.create_dictionary([("x", 0.0), ("y", 1.0), ("z", 0.0)]))
    ])
    Let intersection be Geometry.plane_plane_intersection(plane1, plane2)
    
    UnitTest.assert_true(intersection.intersection_exists, "Planes should intersect")
    UnitTest.assert_equals(intersection.intersection_type, "line", "Should intersect in a line")

Process called "test_polytope_intersection":
    Let polytope1_constraints be Collections.create_list([
        Collections.create_dictionary([("normal", Collections.create_dictionary([("x", 1.0), ("y", 0.0)])), ("offset", 0.0)]),
        Collections.create_dictionary([("normal", Collections.create_dictionary([("x", -1.0), ("y", 0.0)])), ("offset", 1.0)])
    ])
    Let polytope2_constraints be Collections.create_list([
        Collections.create_dictionary([("normal", Collections.create_dictionary([("x", 0.0), ("y", 1.0)])), ("offset", 0.0)]),
        Collections.create_dictionary([("normal", Collections.create_dictionary([("x", 0.0), ("y", -1.0)])), ("offset", 1.0)])
    ])
    Let polytope1 be Geometry.create_polytope(polytope1_constraints)
    Let polytope2 be Geometry.create_polytope(polytope2_constraints)
    
    Let intersection be Geometry.polytope_intersection(polytope1, polytope2)
    
    UnitTest.assert_true(intersection.intersection_computed, "Polytope intersection should be computed")

Note: Convex Hull Algorithm Tests

Process called "test_compute_convex_hull_2d":
    Let points = create_test_points_2d()
    Let convex_hull be Geometry.compute_convex_hull_2d(points)
    
    UnitTest.assert_true(convex_hull.hull_computed, "2D convex hull should be computed")
    UnitTest.assert_true(Collections.size(convex_hull.hull_vertices) >= 3, "Should have at least 3 vertices")
    UnitTest.assert_true(Collections.size(convex_hull.hull_vertices) <= Collections.size(points), "Hull vertices should not exceed input points")

Process called "test_compute_convex_hull_3d":
    Let points = create_test_points_3d()
    Let convex_hull be Geometry.compute_convex_hull_3d(points)
    
    UnitTest.assert_true(convex_hull.hull_computed, "3D convex hull should be computed")
    UnitTest.assert_true(Collections.size(convex_hull.hull_vertices) >= 4, "Should have at least 4 vertices")
    UnitTest.assert_true(Collections.has_key(convex_hull, "faces"), "Should have face information")

Process called "test_compute_convex_hull_nd":
    Let points_4d be Collections.create_list([
        Collections.create_list([0.0, 0.0, 0.0, 0.0]),
        Collections.create_list([1.0, 0.0, 0.0, 0.0]),
        Collections.create_list([0.0, 1.0, 0.0, 0.0]),
        Collections.create_list([0.0, 0.0, 1.0, 0.0]),
        Collections.create_list([0.0, 0.0, 0.0, 1.0]),
        Collections.create_list([0.5, 0.5, 0.5, 0.5])
    ])
    Let convex_hull be Geometry.compute_convex_hull_nd(points_4d)
    
    UnitTest.assert_true(convex_hull.hull_computed, "N-D convex hull should be computed")
    UnitTest.assert_equals(convex_hull.dimension, 4, "Should be 4-dimensional")

Process called "test_point_in_convex_hull":
    Let points = create_test_points_2d()
    Let convex_hull be Geometry.compute_convex_hull_2d(points)
    
    Let interior_point be Collections.create_dictionary([("x", 0.3), ("y", 0.3)])
    Let exterior_point be Collections.create_dictionary([("x", 2.0), ("y", 2.0)])
    
    Let interior_test be Geometry.point_in_convex_hull(interior_point, convex_hull)
    Let exterior_test be Geometry.point_in_convex_hull(exterior_point, convex_hull)
    
    UnitTest.assert_true(interior_test.point_inside, "Interior point should be inside hull")
    UnitTest.assert_false(exterior_test.point_inside, "Exterior point should be outside hull")

Process called "test_convex_hull_volume":
    Let points = create_test_points_3d()
    Let convex_hull be Geometry.compute_convex_hull_3d(points)
    Let volume be Geometry.convex_hull_volume(convex_hull)
    
    UnitTest.assert_true(volume.volume_computed, "Volume should be computed")
    UnitTest.assert_true(volume.volume >= 0.0, "Volume should be non-negative")

Note: Spatial Data Structure Tests

Process called "test_create_kd_tree":
    Let points = create_test_points_3d()
    Let kd_tree be Geometry.create_kd_tree(points)
    
    UnitTest.assert_true(kd_tree.tree_constructed, "KD-tree should be constructed")
    UnitTest.assert_true(Collections.has_key(kd_tree, "root_node"), "Should have root node")
    UnitTest.assert_equals(kd_tree.dimension, 3, "Should be 3-dimensional")

Process called "test_nearest_neighbor_query":
    Let points = create_test_points_3d()
    Let kd_tree be Geometry.create_kd_tree(points)
    
    Let query_point be Collections.create_dictionary([("x", 0.1), ("y", 0.1), ("z", 0.1)])
    Let nn_result be Geometry.nearest_neighbor_query(kd_tree, query_point)
    
    UnitTest.assert_true(nn_result.neighbor_found, "Nearest neighbor should be found")
    UnitTest.assert_true(Collections.has_key(nn_result, "nearest_point"), "Should have nearest point")
    UnitTest.assert_true(Collections.has_key(nn_result, "distance"), "Should have distance")

Process called "test_range_query":
    Let points = create_test_points_3d()
    Let kd_tree be Geometry.create_kd_tree(points)
    
    Let query_center be Collections.create_dictionary([("x", 0.5), ("y", 0.5), ("z", 0.5)])
    Let query_radius be 1.0
    Let range_result be Geometry.range_query(kd_tree, query_center, query_radius)
    
    UnitTest.assert_true(range_result.query_completed, "Range query should complete")
    UnitTest.assert_true(Collections.size(range_result.points_in_range) >= 0, "Should have valid result")

Process called "test_create_quadtree":
    Let points_2d = create_test_points_2d()
    Let bounding_box be Collections.create_dictionary([
        ("min_x", -1.0), ("max_x", 2.0),
        ("min_y", -1.0), ("max_y", 2.0)
    ])
    Let quadtree be Geometry.create_quadtree(points_2d, bounding_box)
    
    UnitTest.assert_true(quadtree.tree_constructed, "Quadtree should be constructed")
    UnitTest.assert_true(Collections.has_key(quadtree, "root_node"), "Should have root node")

Process called "test_create_octree":
    Let points = create_test_points_3d()
    Let bounding_box be Collections.create_dictionary([
        ("min_x", -1.0), ("max_x", 2.0),
        ("min_y", -1.0), ("max_y", 2.0),
        ("min_z", -1.0), ("max_z", 2.0)
    ])
    Let octree be Geometry.create_octree(points, bounding_box)
    
    UnitTest.assert_true(octree.tree_constructed, "Octree should be constructed")
    UnitTest.assert_true(Collections.has_key(octree, "root_node"), "Should have root node")

Note: Coordinate System Tests

Process called "test_cartesian_to_polar":
    Let cartesian_point be Collections.create_dictionary([("x", 3.0), ("y", 4.0)])
    Let polar_point be Geometry.cartesian_to_polar(cartesian_point)
    
    assert_numerical_close(Collections.get_from_dictionary(polar_point, "r"), 5.0, 1e-10, "Radius should be 5")
    UnitTest.assert_true(Collections.has_key(polar_point, "theta"), "Should have angle theta")

Process called "test_polar_to_cartesian":
    Let polar_point be Collections.create_dictionary([("r", 5.0), ("theta", LinalgCore.atan2(4.0, 3.0))])
    Let cartesian_point be Geometry.polar_to_cartesian(polar_point)
    
    assert_numerical_close(Collections.get_from_dictionary(cartesian_point, "x"), 3.0, 1e-10, "X coordinate should be 3")
    assert_numerical_close(Collections.get_from_dictionary(cartesian_point, "y"), 4.0, 1e-10, "Y coordinate should be 4")

Process called "test_cartesian_to_spherical":
    Let cartesian_point be Collections.create_dictionary([("x", 0.0), ("y", 0.0), ("z", 1.0)])
    Let spherical_point be Geometry.cartesian_to_spherical(cartesian_point)
    
    assert_numerical_close(Collections.get_from_dictionary(spherical_point, "r"), 1.0, 1e-10, "Radius should be 1")
    assert_numerical_close(Collections.get_from_dictionary(spherical_point, "theta"), 0.0, 1e-10, "Theta should be 0")
    assert_numerical_close(Collections.get_from_dictionary(spherical_point, "phi"), 0.0, 1e-10, "Phi should be 0")

Process called "test_spherical_to_cartesian":
    Let spherical_point be Collections.create_dictionary([("r", 1.0), ("theta", 0.0), ("phi", 0.0)])
    Let cartesian_point be Geometry.spherical_to_cartesian(spherical_point)
    
    assert_numerical_close(Collections.get_from_dictionary(cartesian_point, "x"), 0.0, 1e-10, "X coordinate should be 0")
    assert_numerical_close(Collections.get_from_dictionary(cartesian_point, "y"), 0.0, 1e-10, "Y coordinate should be 0")
    assert_numerical_close(Collections.get_from_dictionary(cartesian_point, "z"), 1.0, 1e-10, "Z coordinate should be 1")

Note: Quaternion Tests

Process called "test_quaternion_multiplication":
    Let q1 be Collections.create_dictionary([("w", 1.0), ("x", 0.0), ("y", 0.0), ("z", 0.0)])
    Let q2 be Collections.create_dictionary([("w", 0.0), ("x", 1.0), ("y", 0.0), ("z", 0.0)])
    Let product be Geometry.quaternion_multiply(q1, q2)
    
    assert_numerical_close(Collections.get_from_dictionary(product, "w"), 0.0, 1e-10, "W component")
    assert_numerical_close(Collections.get_from_dictionary(product, "x"), 1.0, 1e-10, "X component")
    assert_numerical_close(Collections.get_from_dictionary(product, "y"), 0.0, 1e-10, "Y component")
    assert_numerical_close(Collections.get_from_dictionary(product, "z"), 0.0, 1e-10, "Z component")

Process called "test_quaternion_normalize":
    Let q be Collections.create_dictionary([("w", 2.0), ("x", 0.0), ("y", 0.0), ("z", 0.0)])
    Let normalized be Geometry.quaternion_normalize(q)
    
    assert_numerical_close(Collections.get_from_dictionary(normalized, "w"), 1.0, 1e-10, "W component should be 1")
    Let magnitude_squared = Collections.get_from_dictionary(normalized, "w") * Collections.get_from_dictionary(normalized, "w") +
                           Collections.get_from_dictionary(normalized, "x") * Collections.get_from_dictionary(normalized, "x") +
                           Collections.get_from_dictionary(normalized, "y") * Collections.get_from_dictionary(normalized, "y") +
                           Collections.get_from_dictionary(normalized, "z") * Collections.get_from_dictionary(normalized, "z")
    assert_numerical_close(magnitude_squared, 1.0, 1e-10, "Quaternion should be unit length")

Process called "test_quaternion_slerp":
    Let q1 be Collections.create_dictionary([("w", 1.0), ("x", 0.0), ("y", 0.0), ("z", 0.0)])
    Let q2 be Collections.create_dictionary([("w", 0.0), ("x", 1.0), ("y", 0.0), ("z", 0.0)])
    Let t be 0.5
    Let interpolated be Geometry.quaternion_slerp(q1, q2, t)
    
    UnitTest.assert_true(Collections.has_key(interpolated, "w"), "Should have W component")
    UnitTest.assert_true(Collections.has_key(interpolated, "x"), "Should have X component")

Note: Curve Fitting Tests

Process called "test_fit_line_2d":
    Let points be Collections.create_list([
        Collections.create_dictionary([("x", 0.0), ("y", 1.0)]),
        Collections.create_dictionary([("x", 1.0), ("y", 3.0)]),
        Collections.create_dictionary([("x", 2.0), ("y", 5.0)])
    ])
    Let line_fit be Geometry.fit_line_2d(points)
    
    UnitTest.assert_true(line_fit.fitting_successful, "Line fitting should succeed")
    assert_numerical_close(line_fit.slope, 2.0, 1e-10, "Slope should be 2")
    assert_numerical_close(line_fit.intercept, 1.0, 1e-10, "Intercept should be 1")

Process called "test_fit_plane_3d":
    Let points be Collections.create_list([
        Collections.create_dictionary([("x", 0.0), ("y", 0.0), ("z", 0.0)]),
        Collections.create_dictionary([("x", 1.0), ("y", 0.0), ("z", 0.0)]),
        Collections.create_dictionary([("x", 0.0), ("y", 1.0), ("z", 0.0)]),
        Collections.create_dictionary([("x", 1.0), ("y", 1.0), ("z", 0.0)])
    ])
    Let plane_fit be Geometry.fit_plane_3d(points)
    
    UnitTest.assert_true(plane_fit.fitting_successful, "Plane fitting should succeed")
    assert_vector_equality(plane_fit.normal, Collections.create_dictionary([("x", 0.0), ("y", 0.0), ("z", 1.0)]), 1e-10, "Normal should be (0,0,1)")

Process called "test_fit_circle_2d":
    Let points be Collections.create_list([
        Collections.create_dictionary([("x", 1.0), ("y", 0.0)]),
        Collections.create_dictionary([("x", 0.0), ("y", 1.0)]),
        Collections.create_dictionary([("x", -1.0), ("y", 0.0)]),
        Collections.create_dictionary([("x", 0.0), ("y", -1.0)])
    ])
    Let circle_fit be Geometry.fit_circle_2d(points)
    
    UnitTest.assert_true(circle_fit.fitting_successful, "Circle fitting should succeed")
    assert_point_equality(circle_fit.center, Collections.create_dictionary([("x", 0.0), ("y", 0.0)]), 1e-10, "Center should be origin")
    assert_numerical_close(circle_fit.radius, 1.0, 1e-10, "Radius should be 1")

Process called "test_fit_sphere_3d":
    Let points be Collections.create_list([
        Collections.create_dictionary([("x", 1.0), ("y", 0.0), ("z", 0.0)]),
        Collections.create_dictionary([("x", 0.0), ("y", 1.0), ("z", 0.0)]),
        Collections.create_dictionary([("x", 0.0), ("y", 0.0), ("z", 1.0)]),
        Collections.create_dictionary([("x", -1.0), ("y", 0.0), ("z", 0.0)]),
        Collections.create_dictionary([("x", 0.0), ("y", -1.0), ("z", 0.0)]),
        Collections.create_dictionary([("x", 0.0), ("y", 0.0), ("z", -1.0)])
    ])
    Let sphere_fit be Geometry.fit_sphere_3d(points)
    
    UnitTest.assert_true(sphere_fit.fitting_successful, "Sphere fitting should succeed")
    assert_point_equality(sphere_fit.center, Collections.create_dictionary([("x", 0.0), ("y", 0.0), ("z", 0.0)]), 1e-8, "Center should be origin")
    assert_numerical_close(sphere_fit.radius, 1.0, 1e-8, "Radius should be 1")

Note: Principal Component Analysis Tests

Process called "test_principal_component_analysis":
    Let data_points be Collections.create_list([
        Collections.create_list([1.0, 2.0]),
        Collections.create_list([2.0, 4.0]),
        Collections.create_list([3.0, 6.0]),
        Collections.create_list([4.0, 8.0])
    ])
    Let pca_result be Geometry.principal_component_analysis(data_points)
    
    UnitTest.assert_true(pca_result.analysis_completed, "PCA should complete")
    UnitTest.assert_equals(Collections.size(pca_result.principal_components), 2, "Should have 2 principal components")
    UnitTest.assert_true(Collections.has_key(pca_result, "explained_variance"), "Should have explained variance")

Process called "test_compute_centroid":
    Let points = create_test_points_3d()
    Let centroid be Geometry.compute_centroid(points)
    
    UnitTest.assert_true(Collections.has_key(centroid, "x"), "Centroid should have X coordinate")
    UnitTest.assert_true(Collections.has_key(centroid, "y"), "Centroid should have Y coordinate")
    UnitTest.assert_true(Collections.has_key(centroid, "z"), "Centroid should have Z coordinate")

Note: Test suite coordination

Process called "run_all_geometry_tests":
    UnitTest.start_test_suite("Math Engine Linalg Geometry Module Tests")
    
    Note: Basic geometric operations tests
    UnitTest.run_test("Distance Between Points", test_distance_between_points)
    UnitTest.run_test("Distance Between Points 3D", test_distance_between_points_3d)
    UnitTest.run_test("Dot Product Vectors", test_dot_product_vectors)
    UnitTest.run_test("Cross Product Vectors", test_cross_product_vectors)
    UnitTest.run_test("Vector Magnitude", test_vector_magnitude)
    UnitTest.run_test("Normalize Vector", test_normalize_vector)
    
    Note: Linear transformation tests
    UnitTest.run_test("Apply Transformation", test_apply_transformation)
    UnitTest.run_test("Compose Transformations", test_compose_transformations)
    UnitTest.run_test("Invert Transformation", test_invert_transformation)
    UnitTest.run_test("Create Rotation Matrix", test_create_rotation_matrix)
    UnitTest.run_test("Create Scaling Matrix", test_create_scaling_matrix)
    
    Note: Affine transformation tests
    UnitTest.run_test("Apply Affine Transformation", test_apply_affine_transformation)
    UnitTest.run_test("Create Translation", test_create_translation)
    UnitTest.run_test("Create Affine from Points", test_create_affine_from_points)
    
    Note: Intersection algorithm tests
    UnitTest.run_test("Line-Line Intersection", test_line_line_intersection)
    UnitTest.run_test("Line-Plane Intersection", test_line_plane_intersection)
    UnitTest.run_test("Plane-Plane Intersection", test_plane_plane_intersection)
    UnitTest.run_test("Polytope Intersection", test_polytope_intersection)
    
    Note: Convex hull algorithm tests
    UnitTest.run_test("Compute Convex Hull 2D", test_compute_convex_hull_2d)
    UnitTest.run_test("Compute Convex Hull 3D", test_compute_convex_hull_3d)
    UnitTest.run_test("Compute Convex Hull N-D", test_compute_convex_hull_nd)
    UnitTest.run_test("Point in Convex Hull", test_point_in_convex_hull)
    UnitTest.run_test("Convex Hull Volume", test_convex_hull_volume)
    
    Note: Spatial data structure tests
    UnitTest.run_test("Create KD-Tree", test_create_kd_tree)
    UnitTest.run_test("Nearest Neighbor Query", test_nearest_neighbor_query)
    UnitTest.run_test("Range Query", test_range_query)
    UnitTest.run_test("Create Quadtree", test_create_quadtree)
    UnitTest.run_test("Create Octree", test_create_octree)
    
    Note: Coordinate system tests
    UnitTest.run_test("Cartesian to Polar", test_cartesian_to_polar)
    UnitTest.run_test("Polar to Cartesian", test_polar_to_cartesian)
    UnitTest.run_test("Cartesian to Spherical", test_cartesian_to_spherical)
    UnitTest.run_test("Spherical to Cartesian", test_spherical_to_cartesian)
    
    Note: Quaternion tests
    UnitTest.run_test("Quaternion Multiplication", test_quaternion_multiplication)
    UnitTest.run_test("Quaternion Normalize", test_quaternion_normalize)
    UnitTest.run_test("Quaternion SLERP", test_quaternion_slerp)
    
    Note: Curve fitting tests
    UnitTest.run_test("Fit Line 2D", test_fit_line_2d)
    UnitTest.run_test("Fit Plane 3D", test_fit_plane_3d)
    UnitTest.run_test("Fit Circle 2D", test_fit_circle_2d)
    UnitTest.run_test("Fit Sphere 3D", test_fit_sphere_3d)
    
    Note: Principal component analysis tests
    UnitTest.run_test("Principal Component Analysis", test_principal_component_analysis)
    UnitTest.run_test("Compute Centroid", test_compute_centroid)
    
    Let results be UnitTest.end_test_suite()
    Return results

Process called "get_geometry_test_count" returns Integer:
    Return 37

Process called "get_geometry_test_categories" returns List[String]:
    Return Collections.create_list([
        "Basic Geometric Operations",
        "Linear Transformations",
        "Affine Transformations", 
        "Intersection Algorithms",
        "Convex Hull Algorithms",
        "Spatial Data Structures",
        "Coordinate Systems",
        "Quaternions",
        "Curve Fitting",
        "Principal Component Analysis"
    ])