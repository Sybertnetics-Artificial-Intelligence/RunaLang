Note: Comprehensive unit tests for the math/engine/linalg/core module
Note: Tests matrix creation, vector operations, matrix analysis, linear system solvers, and performance optimization

Import "dev/test" as UnitTest
Import "stdlib/math/engine/linalg/core" as LinalgCore
Import "collections" as Collections

Note: Test helper functions for linear algebra core testing

Process called "create_test_matrix_2x2" returns Dictionary[String, Any]:
    Let entries be Collections.create_list([
        Collections.create_list([1.0, 2.0]),
        Collections.create_list([3.0, 4.0])
    ])
    Return Collections.create_dictionary([
        ("entries", entries),
        ("rows", 2),
        ("columns", 2),
        ("determinant", -2.0),
        ("trace", 5.0),
        ("rank", 2)
    ])

Process called "create_test_matrix_3x3" returns Dictionary[String, Any]:
    Let entries be Collections.create_list([
        Collections.create_list([2.0, -1.0, 0.0]),
        Collections.create_list([1.0, 2.0, -1.0]),
        Collections.create_list([0.0, 1.0, 2.0])
    ])
    Return Collections.create_dictionary([
        ("entries", entries),
        ("rows", 3),
        ("columns", 3),
        ("is_tridiagonal", true),
        ("is_symmetric", false)
    ])

Process called "create_test_vector_3d" returns Dictionary[String, Any]:
    Let components be Collections.create_list([1.0, 2.0, 3.0])
    Return Collections.create_dictionary([
        ("components", components),
        ("dimension", 3),
        ("magnitude", 3.7416573868),
        ("unit_vector", Collections.create_list([0.2672612419, 0.5345224838, 0.8017837257]))
    ])

Process called "assert_matrix_properties" that takes matrix as Dictionary[String, Any], expected as Dictionary[String, Any], message as String:
    UnitTest.assert_equals(LinalgCore.matrix_rows(matrix), Collections.get_from_dictionary(expected, "rows"), message + " - Rows should match")
    UnitTest.assert_equals(LinalgCore.matrix_columns(matrix), Collections.get_from_dictionary(expected, "columns"), message + " - Columns should match")
    UnitTest.assert_true(LinalgCore.is_valid_matrix(matrix), message + " - Should be valid matrix")

Process called "assert_vector_properties" that takes vector as Dictionary[String, Any], expected as Dictionary[String, Any], message as String:
    UnitTest.assert_equals(LinalgCore.vector_dimension(vector), Collections.get_from_dictionary(expected, "dimension"), message + " - Dimension should match")
    UnitTest.assert_true(LinalgCore.is_valid_vector(vector), message + " - Should be valid vector")

Process called "assert_numerical_close" that takes actual as Float, expected as Float, tolerance as Float, message as String:
    Let diff be LinalgCore.abs(actual - expected)
    UnitTest.assert_true(diff < tolerance, message + " - Values should be within tolerance")

Note: Matrix Creation Tests

Process called "test_create_matrix":
    Let data be create_test_matrix_2x2()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    
    assert_matrix_properties(matrix, data, "Matrix creation")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(matrix, 0, 0), 1.0, "Entry (0,0) should be correct")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(matrix, 1, 1), 4.0, "Entry (1,1) should be correct")

Process called "test_create_zero_matrix":
    Let zero_matrix be LinalgCore.create_zero_matrix(3, 3)
    
    UnitTest.assert_equals(LinalgCore.matrix_rows(zero_matrix), 3, "Should have 3 rows")
    UnitTest.assert_equals(LinalgCore.matrix_columns(zero_matrix), 3, "Should have 3 columns")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(zero_matrix, 1, 1), 0.0, "All entries should be zero")

Process called "test_create_identity_matrix":
    Let identity be LinalgCore.create_identity_matrix(4)
    
    UnitTest.assert_equals(LinalgCore.matrix_rows(identity), 4, "Should have 4 rows")
    UnitTest.assert_equals(LinalgCore.matrix_columns(identity), 4, "Should have 4 columns")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(identity, 0, 0), 1.0, "Diagonal should be 1")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(identity, 0, 1), 0.0, "Off-diagonal should be 0")
    UnitTest.assert_true(LinalgCore.is_identity_matrix(identity), "Should be identity matrix")

Process called "test_create_diagonal_matrix":
    Let diagonal_values be Collections.create_list([2.0, 3.0, 5.0])
    Let diag_matrix be LinalgCore.create_diagonal_matrix(diagonal_values)
    
    UnitTest.assert_equals(LinalgCore.matrix_rows(diag_matrix), 3, "Should have 3 rows")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(diag_matrix, 0, 0), 2.0, "First diagonal element")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(diag_matrix, 1, 1), 3.0, "Second diagonal element")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(diag_matrix, 2, 2), 5.0, "Third diagonal element")
    UnitTest.assert_true(LinalgCore.is_diagonal_matrix(diag_matrix), "Should be diagonal matrix")

Process called "test_create_random_matrix":
    Let random_matrix be LinalgCore.create_random_matrix(2, 3, 0.0, 1.0)
    
    UnitTest.assert_equals(LinalgCore.matrix_rows(random_matrix), 2, "Should have 2 rows")
    UnitTest.assert_equals(LinalgCore.matrix_columns(random_matrix), 3, "Should have 3 columns")
    UnitTest.assert_true(LinalgCore.is_valid_matrix(random_matrix), "Should be valid matrix")

Process called "test_create_hilbert_matrix":
    Let hilbert be LinalgCore.create_hilbert_matrix(3)
    
    UnitTest.assert_equals(LinalgCore.matrix_rows(hilbert), 3, "Should have 3 rows")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(hilbert, 0, 0), 1.0, "H(0,0) = 1")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(hilbert, 0, 1), 0.5, "H(0,1) = 1/2")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(hilbert, 1, 1), 1.0/3.0, "H(1,1) = 1/3")

Note: Matrix Operations Tests

Process called "test_add_matrices":
    Let data be create_test_matrix_2x2()
    Let matrix1 be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let matrix2 be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let result be LinalgCore.add_matrices(matrix1, matrix2)
    
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(result, 0, 0), 2.0, "Addition should double entries")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(result, 1, 1), 8.0, "Entry (1,1) should be 8")

Process called "test_subtract_matrices":
    Let data be create_test_matrix_2x2()
    Let matrix1 be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let matrix2 be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let result be LinalgCore.subtract_matrices(matrix1, matrix2)
    
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(result, 0, 0), 0.0, "Subtraction should give zero")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(result, 1, 1), 0.0, "Entry (1,1) should be 0")
    UnitTest.assert_true(LinalgCore.is_zero_matrix(result), "Result should be zero matrix")

Process called "test_multiply_matrices":
    Let data be create_test_matrix_2x2()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let identity be LinalgCore.create_identity_matrix(2)
    Let result be LinalgCore.multiply_matrices(matrix, identity)
    
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(result, 0, 0), 1.0, "Matrix * I should give original")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(result, 1, 1), 4.0, "Entry (1,1) should be preserved")

Process called "test_scalar_multiply_matrix":
    Let data be create_test_matrix_2x2()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let result be LinalgCore.scalar_multiply_matrix(matrix, 2.0)
    
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(result, 0, 0), 2.0, "Scalar multiplication")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(result, 1, 1), 8.0, "Entry (1,1) should be doubled")

Process called "test_power_matrix":
    Let identity be LinalgCore.create_identity_matrix(2)
    Let result be LinalgCore.power_matrix(identity, 5)
    
    UnitTest.assert_true(LinalgCore.is_identity_matrix(result), "Identity^n should be identity")

Process called "test_hadamard_product":
    Let data be create_test_matrix_2x2()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let result be LinalgCore.hadamard_product(matrix, matrix)
    
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(result, 0, 0), 1.0, "1*1 = 1")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(result, 0, 1), 4.0, "2*2 = 4")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(result, 1, 0), 9.0, "3*3 = 9")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(result, 1, 1), 16.0, "4*4 = 16")

Note: Vector Operations Tests

Process called "test_create_vector":
    Let data be create_test_vector_3d()
    Let vector be LinalgCore.create_vector(Collections.get_from_dictionary(data, "components"))
    
    assert_vector_properties(vector, data, "Vector creation")
    UnitTest.assert_equals(LinalgCore.get_vector_component(vector, 0), 1.0, "First component")
    UnitTest.assert_equals(LinalgCore.get_vector_component(vector, 2), 3.0, "Third component")

Process called "test_create_zero_vector":
    Let zero_vector be LinalgCore.create_zero_vector(4)
    
    UnitTest.assert_equals(LinalgCore.vector_dimension(zero_vector), 4, "Should have 4 dimensions")
    UnitTest.assert_equals(LinalgCore.get_vector_component(zero_vector, 1), 0.0, "All components should be zero")
    UnitTest.assert_true(LinalgCore.is_zero_vector(zero_vector), "Should be zero vector")

Process called "test_create_unit_vector":
    Let unit_vector be LinalgCore.create_unit_vector(3, 1)
    
    UnitTest.assert_equals(LinalgCore.vector_dimension(unit_vector), 3, "Should have 3 dimensions")
    UnitTest.assert_equals(LinalgCore.get_vector_component(unit_vector, 0), 0.0, "Non-unit component should be 0")
    UnitTest.assert_equals(LinalgCore.get_vector_component(unit_vector, 1), 1.0, "Unit component should be 1")
    UnitTest.assert_equals(LinalgCore.get_vector_component(unit_vector, 2), 0.0, "Non-unit component should be 0")

Process called "test_create_random_vector":
    Let random_vector be LinalgCore.create_random_vector(5, -1.0, 1.0)
    
    UnitTest.assert_equals(LinalgCore.vector_dimension(random_vector), 5, "Should have 5 dimensions")
    UnitTest.assert_true(LinalgCore.is_valid_vector(random_vector), "Should be valid vector")

Process called "test_add_vectors":
    Let data be create_test_vector_3d()
    Let vector1 be LinalgCore.create_vector(Collections.get_from_dictionary(data, "components"))
    Let vector2 be LinalgCore.create_vector(Collections.get_from_dictionary(data, "components"))
    Let result be LinalgCore.add_vectors(vector1, vector2)
    
    UnitTest.assert_equals(LinalgCore.get_vector_component(result, 0), 2.0, "Addition should double components")
    UnitTest.assert_equals(LinalgCore.get_vector_component(result, 1), 4.0, "Second component should be 4")
    UnitTest.assert_equals(LinalgCore.get_vector_component(result, 2), 6.0, "Third component should be 6")

Process called "test_subtract_vectors":
    Let data be create_test_vector_3d()
    Let vector1 be LinalgCore.create_vector(Collections.get_from_dictionary(data, "components"))
    Let vector2 be LinalgCore.create_vector(Collections.get_from_dictionary(data, "components"))
    Let result be LinalgCore.subtract_vectors(vector1, vector2)
    
    UnitTest.assert_true(LinalgCore.is_zero_vector(result), "v - v should be zero vector")

Process called "test_scalar_multiply_vector":
    Let data be create_test_vector_3d()
    Let vector be LinalgCore.create_vector(Collections.get_from_dictionary(data, "components"))
    Let result be LinalgCore.scalar_multiply_vector(vector, 3.0)
    
    UnitTest.assert_equals(LinalgCore.get_vector_component(result, 0), 3.0, "Scalar multiplication")
    UnitTest.assert_equals(LinalgCore.get_vector_component(result, 1), 6.0, "Second component should be 6")
    UnitTest.assert_equals(LinalgCore.get_vector_component(result, 2), 9.0, "Third component should be 9")

Process called "test_dot_product":
    Let data = create_test_vector_3d()
    Let vector1 be LinalgCore.create_vector(Collections.get_from_dictionary(data, "components"))
    Let vector2 be LinalgCore.create_vector(Collections.get_from_dictionary(data, "components"))
    Let result be LinalgCore.dot_product(vector1, vector2)
    
    UnitTest.assert_equals(result, 14.0, "Dot product should be 1*1 + 2*2 + 3*3 = 14")

Process called "test_cross_product":
    Let vector1 be LinalgCore.create_vector(Collections.create_list([1.0, 0.0, 0.0]))
    Let vector2 be LinalgCore.create_vector(Collections.create_list([0.0, 1.0, 0.0]))
    Let result be LinalgCore.cross_product(vector1, vector2)
    
    UnitTest.assert_equals(LinalgCore.get_vector_component(result, 0), 0.0, "Cross product x component")
    UnitTest.assert_equals(LinalgCore.get_vector_component(result, 1), 0.0, "Cross product y component")
    UnitTest.assert_equals(LinalgCore.get_vector_component(result, 2), 1.0, "Cross product z component")

Process called "test_outer_product":
    Let vector1 be LinalgCore.create_vector(Collections.create_list([1.0, 2.0]))
    Let vector2 be LinalgCore.create_vector(Collections.create_list([3.0, 4.0]))
    Let result be LinalgCore.outer_product(vector1, vector2)
    
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(result, 0, 0), 3.0, "Outer product (0,0)")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(result, 0, 1), 4.0, "Outer product (0,1)")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(result, 1, 0), 6.0, "Outer product (1,0)")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(result, 1, 1), 8.0, "Outer product (1,1)")

Note: Matrix Analysis Tests

Process called "test_matrix_transpose":
    Let data be create_test_matrix_2x2()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let transpose be LinalgCore.matrix_transpose(matrix)
    
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(transpose, 0, 1), 3.0, "Transpose swaps entries")
    UnitTest.assert_equals(LinalgCore.get_matrix_entry(transpose, 1, 0), 2.0, "Transpose swaps entries")

Process called "test_matrix_trace":
    Let data be create_test_matrix_2x2()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let trace be LinalgCore.matrix_trace(matrix)
    
    assert_numerical_close(trace, Collections.get_from_dictionary(data, "trace"), 1e-10, "Trace calculation")

Process called "test_matrix_determinant":
    Let data be create_test_matrix_2x2()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let det be LinalgCore.matrix_determinant(matrix)
    
    assert_numerical_close(det, Collections.get_from_dictionary(data, "determinant"), 1e-10, "Determinant calculation")

Process called "test_matrix_rank":
    Let data be create_test_matrix_2x2()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let rank be LinalgCore.matrix_rank(matrix)
    
    UnitTest.assert_equals(rank, Collections.get_from_dictionary(data, "rank"), "Rank calculation")

Process called "test_matrix_condition_number":
    Let identity be LinalgCore.create_identity_matrix(3)
    Let condition_number be LinalgCore.matrix_condition_number(identity)
    
    assert_numerical_close(condition_number, 1.0, 1e-10, "Identity matrix condition number should be 1")

Process called "test_matrix_norm":
    Let data be create_test_matrix_2x2()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let frobenius_norm be LinalgCore.matrix_norm(matrix, "frobenius")
    Let spectral_norm be LinalgCore.matrix_norm(matrix, "spectral")
    
    UnitTest.assert_true(frobenius_norm > 0, "Frobenius norm should be positive")
    UnitTest.assert_true(spectral_norm > 0, "Spectral norm should be positive")

Process called "test_is_symmetric":
    Let symmetric_entries be Collections.create_list([
        Collections.create_list([1.0, 2.0, 3.0]),
        Collections.create_list([2.0, 4.0, 5.0]),
        Collections.create_list([3.0, 5.0, 6.0])
    ])
    Let symmetric_matrix be LinalgCore.create_matrix(symmetric_entries)
    Let data be create_test_matrix_2x2()
    Let non_symmetric be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    
    UnitTest.assert_true(LinalgCore.is_symmetric(symmetric_matrix), "Should detect symmetric matrix")
    UnitTest.assert_false(LinalgCore.is_symmetric(non_symmetric), "Should detect non-symmetric matrix")

Process called "test_is_positive_definite":
    Let positive_definite_entries be Collections.create_list([
        Collections.create_list([2.0, 1.0]),
        Collections.create_list([1.0, 2.0])
    ])
    Let pd_matrix be LinalgCore.create_matrix(positive_definite_entries)
    
    UnitTest.assert_true(LinalgCore.is_positive_definite(pd_matrix), "Should detect positive definite matrix")

Process called "test_is_orthogonal":
    Let rotation_angle be 3.14159/4.0  Note: 45 degrees
    Let cos_theta be LinalgCore.cos(rotation_angle)
    Let sin_theta be LinalgCore.sin(rotation_angle)
    Let rotation_entries be Collections.create_list([
        Collections.create_list([cos_theta, -sin_theta]),
        Collections.create_list([sin_theta, cos_theta])
    ])
    Let rotation_matrix be LinalgCore.create_matrix(rotation_entries)
    
    UnitTest.assert_true(LinalgCore.is_orthogonal(rotation_matrix), "Rotation matrix should be orthogonal")

Process called "test_is_singular":
    Let singular_entries be Collections.create_list([
        Collections.create_list([1.0, 2.0]),
        Collections.create_list([2.0, 4.0])
    ])
    Let singular_matrix be LinalgCore.create_matrix(singular_entries)
    Let data be create_test_matrix_2x2()
    Let non_singular be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    
    UnitTest.assert_true(LinalgCore.is_singular(singular_matrix), "Should detect singular matrix")
    UnitTest.assert_false(LinalgCore.is_singular(non_singular), "Should detect non-singular matrix")

Note: Linear System Solver Tests

Process called "test_solve_linear_system":
    Let A_entries be Collections.create_list([
        Collections.create_list([2.0, 1.0]),
        Collections.create_list([1.0, 3.0])
    ])
    Let A be LinalgCore.create_matrix(A_entries)
    Let b be LinalgCore.create_vector(Collections.create_list([5.0, 7.0]))
    Let solution be LinalgCore.solve_linear_system(A, b)
    
    UnitTest.assert_true(LinalgCore.is_valid_vector(solution), "Solution should be valid vector")
    Let expected_x = 8.0/5.0
    Let expected_y = 9.0/5.0
    assert_numerical_close(LinalgCore.get_vector_component(solution, 0), expected_x, 1e-10, "First solution component")
    assert_numerical_close(LinalgCore.get_vector_component(solution, 1), expected_y, 1e-10, "Second solution component")

Process called "test_gaussian_elimination":
    Let A_entries be Collections.create_list([
        Collections.create_list([1.0, 2.0, 3.0]),
        Collections.create_list([2.0, 5.0, 8.0]),
        Collections.create_list([3.0, 8.0, 14.0])
    ])
    Let A be LinalgCore.create_matrix(A_entries)
    Let b be LinalgCore.create_vector(Collections.create_list([6.0, 15.0, 25.0]))
    Let result be LinalgCore.gaussian_elimination(A, b)
    
    UnitTest.assert_true(result.elimination_successful, "Gaussian elimination should succeed")
    UnitTest.assert_true(LinalgCore.is_valid_vector(result.solution), "Solution should be valid")

Process called "test_lu_solve":
    Let data be create_test_matrix_3x3()
    Let A be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let b be LinalgCore.create_vector(Collections.create_list([1.0, 2.0, 3.0]))
    Let solution be LinalgCore.lu_solve(A, b)
    
    UnitTest.assert_true(LinalgCore.is_valid_vector(solution), "LU solution should be valid vector")

Process called "test_cholesky_solve":
    Let positive_definite_entries be Collections.create_list([
        Collections.create_list([4.0, 2.0]),
        Collections.create_list([2.0, 2.0])
    ])
    Let A be LinalgCore.create_matrix(positive_definite_entries)
    Let b be LinalgCore.create_vector(Collections.create_list([8.0, 6.0]))
    Let solution be LinalgCore.cholesky_solve(A, b)
    
    UnitTest.assert_true(LinalgCore.is_valid_vector(solution), "Cholesky solution should be valid vector")

Process called "test_matrix_inverse":
    Let data be create_test_matrix_2x2()
    Let matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let inverse be LinalgCore.matrix_inverse(matrix)
    Let product be LinalgCore.multiply_matrices(matrix, inverse)
    
    UnitTest.assert_true(LinalgCore.is_identity_matrix(product), "A * A^(-1) should be identity")

Process called "test_pseudoinverse":
    Let tall_matrix_entries be Collections.create_list([
        Collections.create_list([1.0, 2.0]),
        Collections.create_list([3.0, 4.0]),
        Collections.create_list([5.0, 6.0])
    ])
    Let tall_matrix be LinalgCore.create_matrix(tall_matrix_entries)
    Let pinv be LinalgCore.pseudoinverse(tall_matrix)
    
    UnitTest.assert_equals(LinalgCore.matrix_rows(pinv), 2, "Pseudoinverse should have 2 rows")
    UnitTest.assert_equals(LinalgCore.matrix_columns(pinv), 3, "Pseudoinverse should have 3 columns")

Note: Advanced Operations Tests

Process called "test_gram_schmidt_orthogonalization":
    Let vectors be Collections.create_list([
        LinalgCore.create_vector(Collections.create_list([1.0, 1.0, 0.0])),
        LinalgCore.create_vector(Collections.create_list([1.0, 0.0, 1.0])),
        LinalgCore.create_vector(Collections.create_list([0.0, 1.0, 1.0]))
    ])
    Let result be LinalgCore.gram_schmidt_orthogonalization(vectors)
    
    UnitTest.assert_equals(Collections.size(result.orthogonal_vectors), 3, "Should have 3 orthogonal vectors")
    UnitTest.assert_true(result.orthogonalization_successful, "Orthogonalization should succeed")

Process called "test_eigenvalue_computation":
    Let symmetric_entries be Collections.create_list([
        Collections.create_list([3.0, 1.0]),
        Collections.create_list([1.0, 3.0])
    ])
    Let symmetric_matrix be LinalgCore.create_matrix(symmetric_entries)
    Let result be LinalgCore.compute_eigenvalues(symmetric_matrix)
    
    UnitTest.assert_equals(Collections.size(result.eigenvalues), 2, "Should have 2 eigenvalues")
    UnitTest.assert_true(result.computation_converged, "Eigenvalue computation should converge")

Process called "test_matrix_validation":
    Let data be create_test_matrix_2x2()
    Let valid_matrix be LinalgCore.create_matrix(Collections.get_from_dictionary(data, "entries"))
    Let invalid_entries be Collections.create_list([
        Collections.create_list([1.0, 2.0]),
        Collections.create_list([3.0])  Note: Inconsistent row size
    ])
    
    UnitTest.assert_true(LinalgCore.is_valid_matrix(valid_matrix), "Should validate correct matrix")
    Let validation_result be LinalgCore.validate_matrix_structure(invalid_entries)
    UnitTest.assert_false(validation_result.is_valid, "Should detect invalid matrix structure")

Process called "test_performance_benchmarking":
    Let benchmark_size be 50
    Let large_matrix be LinalgCore.create_random_matrix(benchmark_size, benchmark_size, 0.0, 1.0)
    Let benchmark_result be LinalgCore.benchmark_matrix_operations(large_matrix)
    
    UnitTest.assert_true(benchmark_result.benchmark_completed, "Benchmark should complete")
    UnitTest.assert_true(benchmark_result.multiplication_time > 0, "Should measure multiplication time")
    UnitTest.assert_true(benchmark_result.inversion_time > 0, "Should measure inversion time")

Process called "test_memory_management":
    Let memory_info_before be LinalgCore.get_memory_usage()
    Let large_matrices be Collections.create_list()
    
    For i = 0 to 10:
        Let matrix be LinalgCore.create_random_matrix(100, 100, 0.0, 1.0)
        Collections.add_to_list(large_matrices, matrix)
    
    Let memory_info_after be LinalgCore.get_memory_usage()
    LinalgCore.cleanup_matrices(large_matrices)
    Let memory_info_cleanup be LinalgCore.get_memory_usage()
    
    UnitTest.assert_true(memory_info_after.allocated_bytes > memory_info_before.allocated_bytes, "Memory usage should increase")
    UnitTest.assert_true(memory_info_cleanup.allocated_bytes <= memory_info_after.allocated_bytes, "Cleanup should reduce memory")

Note: Test suite coordination

Process called "run_all_core_tests":
    UnitTest.start_test_suite("Math Engine Linalg Core Module Tests")
    
    Note: Matrix creation tests
    UnitTest.run_test("Create Matrix", test_create_matrix)
    UnitTest.run_test("Create Zero Matrix", test_create_zero_matrix)
    UnitTest.run_test("Create Identity Matrix", test_create_identity_matrix)
    UnitTest.run_test("Create Diagonal Matrix", test_create_diagonal_matrix)
    UnitTest.run_test("Create Random Matrix", test_create_random_matrix)
    UnitTest.run_test("Create Hilbert Matrix", test_create_hilbert_matrix)
    
    Note: Matrix operations tests
    UnitTest.run_test("Add Matrices", test_add_matrices)
    UnitTest.run_test("Subtract Matrices", test_subtract_matrices)
    UnitTest.run_test("Multiply Matrices", test_multiply_matrices)
    UnitTest.run_test("Scalar Multiply Matrix", test_scalar_multiply_matrix)
    UnitTest.run_test("Power Matrix", test_power_matrix)
    UnitTest.run_test("Hadamard Product", test_hadamard_product)
    
    Note: Vector operations tests
    UnitTest.run_test("Create Vector", test_create_vector)
    UnitTest.run_test("Create Zero Vector", test_create_zero_vector)
    UnitTest.run_test("Create Unit Vector", test_create_unit_vector)
    UnitTest.run_test("Create Random Vector", test_create_random_vector)
    UnitTest.run_test("Add Vectors", test_add_vectors)
    UnitTest.run_test("Subtract Vectors", test_subtract_vectors)
    UnitTest.run_test("Scalar Multiply Vector", test_scalar_multiply_vector)
    UnitTest.run_test("Dot Product", test_dot_product)
    UnitTest.run_test("Cross Product", test_cross_product)
    UnitTest.run_test("Outer Product", test_outer_product)
    
    Note: Matrix analysis tests
    UnitTest.run_test("Matrix Transpose", test_matrix_transpose)
    UnitTest.run_test("Matrix Trace", test_matrix_trace)
    UnitTest.run_test("Matrix Determinant", test_matrix_determinant)
    UnitTest.run_test("Matrix Rank", test_matrix_rank)
    UnitTest.run_test("Matrix Condition Number", test_matrix_condition_number)
    UnitTest.run_test("Matrix Norm", test_matrix_norm)
    UnitTest.run_test("Is Symmetric", test_is_symmetric)
    UnitTest.run_test("Is Positive Definite", test_is_positive_definite)
    UnitTest.run_test("Is Orthogonal", test_is_orthogonal)
    UnitTest.run_test("Is Singular", test_is_singular)
    
    Note: Linear system solver tests
    UnitTest.run_test("Solve Linear System", test_solve_linear_system)
    UnitTest.run_test("Gaussian Elimination", test_gaussian_elimination)
    UnitTest.run_test("LU Solve", test_lu_solve)
    UnitTest.run_test("Cholesky Solve", test_cholesky_solve)
    UnitTest.run_test("Matrix Inverse", test_matrix_inverse)
    UnitTest.run_test("Pseudoinverse", test_pseudoinverse)
    
    Note: Advanced operations tests
    UnitTest.run_test("Gram-Schmidt Orthogonalization", test_gram_schmidt_orthogonalization)
    UnitTest.run_test("Eigenvalue Computation", test_eigenvalue_computation)
    UnitTest.run_test("Matrix Validation", test_matrix_validation)
    UnitTest.run_test("Performance Benchmarking", test_performance_benchmarking)
    UnitTest.run_test("Memory Management", test_memory_management)
    
    Let results be UnitTest.end_test_suite()
    Return results

Process called "get_core_test_count" returns Integer:
    Return 41

Process called "get_core_test_categories" returns List[String]:
    Return Collections.create_list([
        "Matrix Creation",
        "Matrix Operations", 
        "Vector Operations",
        "Matrix Analysis",
        "Linear System Solvers",
        "Advanced Operations"
    ])