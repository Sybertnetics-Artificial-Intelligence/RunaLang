Note:
tests/unit/libraries/math/engine/parallel/vectorization_test.runa
Comprehensive Unit Tests for Vectorization Parallel Module

Testing suite for SIMD operations and vector instructions.
Tests SIMD capability detection, vectorized arithmetic, transcendental functions, and memory operations.

Key Test Areas:
- SIMD capability detection and optimization
- Vectorized basic arithmetic operations (add, multiply, divide)
- Vectorized transcendental functions (sin, cos, exp, log)
- Vectorized linear algebra operations (dot product, matrix operations)
- Vectorized reduction and comparison operations
- Memory alignment and data layout optimization
- Auto-vectorization and code generation

Dependencies:
- Collections (List, Dictionary)
- Math.Engine.Parallel.Vectorization (vectorization operations)
- Math.Probability.Sampling (test data generation)
- Testing framework utilities
:End Note

Import "collections" as Collections
Import "math.engine.parallel.vectorization" as Vectorization
Import "math.probability.sampling" as Sampling
Import "math.core.operations" as MathCore
Import "errors" as Errors

Note: ========================================================================
Note: TEST DATA GENERATION AND HELPER FUNCTIONS
Note: ========================================================================

Process called "create_test_vector_float" that takes size as Integer, simd_width as Integer returns Vectorization.VectorFloat:
    Note: Create test VectorFloat with specified size and SIMD width
    Let vector be Vectorization.VectorFloat
    Set vector.data to Collections.List.new()
    Set vector.length to size
    Set vector.alignment to 32
    Set vector.simd_width to simd_width
    
    Let i be 0
    While i < size:
        Let value be (i + 1).to_float()  Note: Sequential values for easy testing
        Collections.List.add(vector.data, value)
        Set i to i + 1
    End While
    
    Return vector

Process called "create_test_vector_int" that takes size as Integer, simd_width as Integer returns Vectorization.VectorInt:
    Note: Create test VectorInt with specified size and SIMD width
    Let vector be Vectorization.VectorInt
    Set vector.data to Collections.List.new()
    Set vector.length to size
    Set vector.alignment to 32
    Set vector.simd_width to simd_width
    
    Let i be 0
    While i < size:
        Collections.List.add(vector.data, i + 1)
        Set i to i + 1
    End While
    
    Return vector

Process called "create_simd_capabilities_test" that takes has_avx2 as Boolean, has_sse4 as Boolean, has_neon as Boolean returns Vectorization.SIMDCapabilities:
    Note: Create test SIMD capabilities structure
    Let capabilities be Vectorization.SIMDCapabilities
    Set capabilities.has_sse to true
    Set capabilities.has_sse2 to true
    Set capabilities.has_sse3 to true
    Set capabilities.has_sse4 to has_sse4
    Set capabilities.has_avx to has_avx2
    Set capabilities.has_avx2 to has_avx2
    Set capabilities.has_avx512 to false
    Set capabilities.has_neon to has_neon
    
    If has_avx2 then:
        Set capabilities.preferred_width to 8
    Otherwise if has_sse4 then:
        Set capabilities.preferred_width to 4
    Otherwise if has_neon then:
        Set capabilities.preferred_width to 4
    Otherwise:
        Set capabilities.preferred_width to 1
    End If
    
    Return capabilities

Process called "assert_float_equal" that takes actual as Float, expected as Float, tolerance as Float returns Boolean:
    Note: Assert two floats are equal within tolerance
    Let diff be MathCore.abs(actual - expected)
    Return diff <= tolerance

Process called "assert_vectors_equal" that takes actual as List[Float], expected as List[Float], tolerance as Float returns Boolean:
    Note: Assert two vectors are equal within tolerance
    Let actual_size be Collections.List.size(actual)
    Let expected_size be Collections.List.size(expected)
    
    If actual_size != expected_size then:
        Return false
    End If
    
    Let i be 0
    While i < actual_size:
        Let actual_val be Collections.List.get(actual, i)
        Let expected_val be Collections.List.get(expected, i)
        
        If not assert_float_equal(actual_val, expected_val, tolerance) then:
            Return false
        End If
        
        Set i to i + 1
    End While
    
    Return true

Process called "assert_vector_float_equal" that takes actual as Vectorization.VectorFloat, expected as Vectorization.VectorFloat, tolerance as Float returns Boolean:
    Note: Assert two VectorFloat objects are equal within tolerance
    If actual.length != expected.length then:
        Return false
    End If
    
    Return assert_vectors_equal(actual.data, expected.data, tolerance)

Note: ========================================================================
Note: SIMD CAPABILITY DETECTION TESTS
Note: ========================================================================

Process called "test_detect_simd_capabilities" that returns Boolean:
    Note: Test SIMD capability detection
    Try:
        Let capabilities be Vectorization.detect_simd_capabilities()
        
        Note: Should have at least basic capabilities set
        If capabilities.preferred_width <= 0 then:
            Return false
        End If
        
        Note: Preferred width should be reasonable (1, 4, 8, or 16)
        If capabilities.preferred_width != 1 and 
           capabilities.preferred_width != 4 and 
           capabilities.preferred_width != 8 and 
           capabilities.preferred_width != 16 then:
            Return false
        End If
        
        Return true
    Catch error:
        Return false
    End Try

Process called "test_get_optimal_vector_width" that returns Boolean:
    Note: Test optimal vector width calculation for different data types
    Let float_width be Vectorization.get_optimal_vector_width("Float")
    Let double_width be Vectorization.get_optimal_vector_width("Double")
    Let int_width be Vectorization.get_optimal_vector_width("Integer")
    
    Note: Should return positive widths
    If float_width <= 0 or double_width <= 0 or int_width <= 0 then:
        Return false
    End If
    
    Note: Float and int should have same width (32-bit each)
    If float_width != int_width then:
        Return false
    End If
    
    Note: Double width should be half of float width (64-bit vs 32-bit)
    If double_width * 2 != float_width then:
        Return false
    End If
    
    Return true

Process called "test_get_optimal_vector_width_unknown_type" that returns Boolean:
    Note: Test optimal vector width with unknown data type
    Let unknown_width be Vectorization.get_optimal_vector_width("UnknownType")
    
    Note: Should default to scalar (width 1) for unknown types
    Return unknown_width == 1

Process called "test_check_memory_alignment" that returns Boolean:
    Note: Test memory alignment checking
    Let aligned_data be Collections.List.new()
    Let unaligned_data be Collections.List.new()
    
    Note: Create aligned data (size multiple of 4)
    Let i be 0
    While i < 16:  Note: 16 elements, divisible by 4
        Collections.List.add(aligned_data, i.to_float())
        Set i to i + 1
    End While
    
    Note: Create unaligned data (size not multiple of 4)
    Set i to 0
    While i < 15:  Note: 15 elements, not divisible by 4
        Collections.List.add(unaligned_data, i.to_float())
        Set i to i + 1
    End While
    
    Let is_aligned be Vectorization.check_memory_alignment(aligned_data, 4)
    Let is_unaligned be Vectorization.check_memory_alignment(unaligned_data, 4)
    
    If not is_aligned then:
        Return false
    End If
    
    If is_unaligned then:
        Return false
    End If
    
    Return true

Process called "test_align_memory" that returns Boolean:
    Note: Test memory alignment padding
    Let unaligned_data be Collections.List.new()
    
    Note: Create data with size not multiple of alignment
    Let i be 0
    While i < 13:  Note: 13 elements
        Collections.List.add(unaligned_data, i.to_float())
        Set i to i + 1
    End While
    
    Let aligned_data be Vectorization.align_memory(unaligned_data, 4)
    
    Note: Should now be aligned (size multiple of 4)
    If Collections.List.size(aligned_data) % 4 != 0 then:
        Return false
    End If
    
    Note: Should be 16 elements (next multiple of 4 after 13)
    If Collections.List.size(aligned_data) != 16 then:
        Return false
    End If
    
    Note: Original data should be preserved
    Set i to 0
    While i < 13:
        Let original_val be Collections.List.get(unaligned_data, i)
        Let aligned_val be Collections.List.get(aligned_data, i)
        
        If not assert_float_equal(original_val, aligned_val, 1e-10) then:
            Return false
        End If
        
        Set i to i + 1
    End While
    
    Note: Padding should be zeros
    Set i to 13
    While i < 16:
        Let padding_val be Collections.List.get(aligned_data, i)
        If not assert_float_equal(padding_val, 0.0, 1e-10) then:
            Return false
        End If
        Set i to i + 1
    End While
    
    Return true

Note: ========================================================================
Note: BASIC VECTORIZED ARITHMETIC TESTS
Note: ========================================================================

Process called "test_vector_add" that returns Boolean:
    Note: Test vectorized addition
    Let a be create_test_vector_float(8, 4)
    Let b be create_test_vector_float(8, 4)
    
    Note: Modify b values to be different from a
    Let i be 0
    While i < 8:
        Collections.List.set(b.data, i, (i + 10).to_float())
        Set i to i + 1
    End While
    
    Let result be Vectorization.vector_add(a, b)
    
    Note: Check results
    If result.length != 8 then:
        Return false
    End If
    
    Set i to 0
    While i < 8:
        Let expected be (i + 1).to_float() + (i + 10).to_float()  Note: a[i] + b[i]
        Let actual be Collections.List.get(result.data, i)
        
        If not assert_float_equal(actual, expected, 1e-10) then:
            Return false
        End If
        
        Set i to i + 1
    End While
    
    Return true

Process called "test_vector_add_mismatched_length" that returns Boolean:
    Note: Test vectorized addition with mismatched vector lengths
    Let a be create_test_vector_float(8, 4)
    Let b be create_test_vector_float(6, 4)
    
    Try:
        Vectorization.vector_add(a, b)
        Return false  Note: Should have thrown error
    Catch error:
        Return true   Note: Expected behavior
    End Try

Process called "test_vector_subtract" that returns Boolean:
    Note: Test vectorized subtraction
    Let a be create_test_vector_float(6, 4)
    Let b be create_test_vector_float(6, 4)
    
    Note: Set specific values for testing
    Collections.List.set(a.data, 0, 10.0)
    Collections.List.set(b.data, 0, 3.0)
    Collections.List.set(a.data, 1, 20.0)
    Collections.List.set(b.data, 1, 5.0)
    
    Let result be Vectorization.vector_subtract(a, b)
    
    Note: Check first two results
    Let result0 be Collections.List.get(result.data, 0)
    Let result1 be Collections.List.get(result.data, 1)
    
    If not assert_float_equal(result0, 7.0, 1e-10) then:  Note: 10 - 3
        Return false
    End If
    
    If not assert_float_equal(result1, 15.0, 1e-10) then:  Note: 20 - 5
        Return false
    End If
    
    Return true

Process called "test_vector_multiply" that returns Boolean:
    Note: Test vectorized element-wise multiplication
    Let a be create_test_vector_float(4, 4)
    Let b be create_test_vector_float(4, 4)
    
    Note: Set test values
    Collections.List.set(a.data, 0, 2.0)
    Collections.List.set(b.data, 0, 3.0)
    Collections.List.set(a.data, 1, 4.0)
    Collections.List.set(b.data, 1, 5.0)
    
    Let result be Vectorization.vector_multiply(a, b)
    
    Let result0 be Collections.List.get(result.data, 0)
    Let result1 be Collections.List.get(result.data, 1)
    
    If not assert_float_equal(result0, 6.0, 1e-10) then:  Note: 2 * 3
        Return false
    End If
    
    If not assert_float_equal(result1, 20.0, 1e-10) then:  Note: 4 * 5
        Return false
    End If
    
    Return true

Process called "test_vector_divide" that returns Boolean:
    Note: Test vectorized element-wise division
    Let a be create_test_vector_float(4, 4)
    Let b be create_test_vector_float(4, 4)
    
    Note: Set test values
    Collections.List.set(a.data, 0, 10.0)
    Collections.List.set(b.data, 0, 2.0)
    Collections.List.set(a.data, 1, 21.0)
    Collections.List.set(b.data, 1, 3.0)
    
    Let result be Vectorization.vector_divide(a, b)
    
    Let result0 be Collections.List.get(result.data, 0)
    Let result1 be Collections.List.get(result.data, 1)
    
    If not assert_float_equal(result0, 5.0, 1e-10) then:  Note: 10 / 2
        Return false
    End If
    
    If not assert_float_equal(result1, 7.0, 1e-10) then:  Note: 21 / 3
        Return false
    End If
    
    Return true

Process called "test_vector_divide_by_zero" that returns Boolean:
    Note: Test vectorized division by zero error handling
    Let a be create_test_vector_float(2, 4)
    Let b be create_test_vector_float(2, 4)
    
    Collections.List.set(a.data, 0, 10.0)
    Collections.List.set(b.data, 0, 0.0)  Note: Division by zero
    
    Try:
        Vectorization.vector_divide(a, b)
        Return false  Note: Should have thrown error
    Catch error:
        Return true   Note: Expected behavior
    End Try

Process called "test_vector_multiply_add" that returns Boolean:
    Note: Test vectorized fused multiply-add operation
    Let a be create_test_vector_float(3, 4)
    Let b be create_test_vector_float(3, 4)
    Let c be create_test_vector_float(3, 4)
    
    Note: Set test values: result = a * b + c
    Collections.List.set(a.data, 0, 2.0)
    Collections.List.set(b.data, 0, 3.0)
    Collections.List.set(c.data, 0, 1.0)
    
    Let result be Vectorization.vector_multiply_add(a, b, c)
    Let result0 be Collections.List.get(result.data, 0)
    
    If not assert_float_equal(result0, 7.0, 1e-10) then:  Note: 2 * 3 + 1 = 7
        Return false
    End If
    
    Return true

Process called "test_vector_scalar_multiply" that returns Boolean:
    Note: Test vectorized scalar multiplication
    Let vector be create_test_vector_float(4, 4)
    Let scalar be 3.5
    
    Collections.List.set(vector.data, 0, 2.0)
    Collections.List.set(vector.data, 1, 4.0)
    
    Let result be Vectorization.vector_scalar_multiply(vector, scalar)
    
    Let result0 be Collections.List.get(result.data, 0)
    Let result1 be Collections.List.get(result.data, 1)
    
    If not assert_float_equal(result0, 7.0, 1e-10) then:  Note: 2.0 * 3.5
        Return false
    End If
    
    If not assert_float_equal(result1, 14.0, 1e-10) then:  Note: 4.0 * 3.5
        Return false
    End If
    
    Return true

Note: ========================================================================
Note: VECTORIZED TRANSCENDENTAL FUNCTIONS TESTS
Note: ========================================================================

Process called "test_vector_sin" that returns Boolean:
    Note: Test vectorized sine function
    Let vector be create_test_vector_float(4, 4)
    
    Note: Set test values including 0 and π/2
    Collections.List.set(vector.data, 0, 0.0)
    Collections.List.set(vector.data, 1, 1.5707963)  Note: π/2
    Collections.List.set(vector.data, 2, 3.1415926)  Note: π
    
    Let result be Vectorization.vector_sin(vector)
    
    Let sin0 be Collections.List.get(result.data, 0)
    Let sin_pi_2 be Collections.List.get(result.data, 1)
    Let sin_pi be Collections.List.get(result.data, 2)
    
    Note: sin(0) = 0, sin(π/2) ≈ 1, sin(π) ≈ 0
    If not assert_float_equal(sin0, 0.0, 1e-6) then:
        Return false
    End If
    
    If not assert_float_equal(sin_pi_2, 1.0, 1e-6) then:
        Return false
    End If
    
    If not assert_float_equal(sin_pi, 0.0, 1e-6) then:
        Return false
    End If
    
    Return true

Process called "test_vector_cos" that returns Boolean:
    Note: Test vectorized cosine function
    Let vector be create_test_vector_float(3, 4)
    
    Collections.List.set(vector.data, 0, 0.0)
    Collections.List.set(vector.data, 1, 1.5707963)  Note: π/2
    Collections.List.set(vector.data, 2, 3.1415926)  Note: π
    
    Let result be Vectorization.vector_cos(vector)
    
    Let cos0 be Collections.List.get(result.data, 0)
    Let cos_pi_2 be Collections.List.get(result.data, 1)
    Let cos_pi be Collections.List.get(result.data, 2)
    
    Note: cos(0) = 1, cos(π/2) ≈ 0, cos(π) ≈ -1
    If not assert_float_equal(cos0, 1.0, 1e-6) then:
        Return false
    End If
    
    If not assert_float_equal(cos_pi_2, 0.0, 1e-6) then:
        Return false
    End If
    
    If not assert_float_equal(cos_pi, -1.0, 1e-6) then:
        Return false
    End If
    
    Return true

Process called "test_vector_exp" that returns Boolean:
    Note: Test vectorized exponential function
    Let vector be create_test_vector_float(3, 4)
    
    Collections.List.set(vector.data, 0, 0.0)
    Collections.List.set(vector.data, 1, 1.0)
    Collections.List.set(vector.data, 2, 2.0)
    
    Let result be Vectorization.vector_exp(vector)
    
    Let exp0 be Collections.List.get(result.data, 0)
    Let exp1 be Collections.List.get(result.data, 1)
    Let exp2 be Collections.List.get(result.data, 2)
    
    Note: exp(0) = 1, exp(1) ≈ 2.718, exp(2) ≈ 7.389
    If not assert_float_equal(exp0, 1.0, 1e-6) then:
        Return false
    End If
    
    If not assert_float_equal(exp1, 2.718281, 1e-5) then:
        Return false
    End If
    
    If not assert_float_equal(exp2, 7.389056, 1e-5) then:
        Return false
    End If
    
    Return true

Process called "test_vector_log" that returns Boolean:
    Note: Test vectorized natural logarithm
    Let vector be create_test_vector_float(3, 4)
    
    Collections.List.set(vector.data, 0, 1.0)
    Collections.List.set(vector.data, 1, 2.718281)  Note: e
    Collections.List.set(vector.data, 2, 7.389056)  Note: e²
    
    Let result be Vectorization.vector_log(vector)
    
    Let log1 be Collections.List.get(result.data, 0)
    Let log_e be Collections.List.get(result.data, 1)
    Let log_e2 be Collections.List.get(result.data, 2)
    
    Note: ln(1) = 0, ln(e) = 1, ln(e²) = 2
    If not assert_float_equal(log1, 0.0, 1e-6) then:
        Return false
    End If
    
    If not assert_float_equal(log_e, 1.0, 1e-5) then:
        Return false
    End If
    
    If not assert_float_equal(log_e2, 2.0, 1e-5) then:
        Return false
    End If
    
    Return true

Process called "test_vector_log_negative" that returns Boolean:
    Note: Test vectorized log with negative input throws error
    Let vector be create_test_vector_float(2, 4)
    Collections.List.set(vector.data, 0, -1.0)  Note: Negative input
    
    Try:
        Vectorization.vector_log(vector)
        Return false  Note: Should have thrown error
    Catch error:
        Return true   Note: Expected behavior
    End Try

Process called "test_vector_sqrt" that returns Boolean:
    Note: Test vectorized square root
    Let vector be create_test_vector_float(4, 4)
    
    Collections.List.set(vector.data, 0, 0.0)
    Collections.List.set(vector.data, 1, 1.0)
    Collections.List.set(vector.data, 2, 4.0)
    Collections.List.set(vector.data, 3, 9.0)
    
    Let result be Vectorization.vector_sqrt(vector)
    
    Let sqrt0 be Collections.List.get(result.data, 0)
    Let sqrt1 be Collections.List.get(result.data, 1)
    Let sqrt4 be Collections.List.get(result.data, 2)
    Let sqrt9 be Collections.List.get(result.data, 3)
    
    If not assert_float_equal(sqrt0, 0.0, 1e-10) then:
        Return false
    End If
    
    If not assert_float_equal(sqrt1, 1.0, 1e-10) then:
        Return false
    End If
    
    If not assert_float_equal(sqrt4, 2.0, 1e-10) then:
        Return false
    End If
    
    If not assert_float_equal(sqrt9, 3.0, 1e-10) then:
        Return false
    End If
    
    Return true

Note: ========================================================================
Note: VECTORIZED LINEAR ALGEBRA TESTS
Note: ========================================================================

Process called "test_vector_dot_product" that returns Boolean:
    Note: Test vectorized dot product
    Let a be create_test_vector_float(4, 4)
    Let b be create_test_vector_float(4, 4)
    
    Note: Set test values: a = [1, 2, 3, 4], b = [2, 3, 4, 5]
    Collections.List.set(a.data, 0, 1.0)
    Collections.List.set(a.data, 1, 2.0)
    Collections.List.set(a.data, 2, 3.0)
    Collections.List.set(a.data, 3, 4.0)
    
    Collections.List.set(b.data, 0, 2.0)
    Collections.List.set(b.data, 1, 3.0)
    Collections.List.set(b.data, 2, 4.0)
    Collections.List.set(b.data, 3, 5.0)
    
    Let result be Vectorization.vector_dot_product(a, b)
    Let expected be 1.0*2.0 + 2.0*3.0 + 3.0*4.0 + 4.0*5.0  Note: 2 + 6 + 12 + 20 = 40
    
    Return assert_float_equal(result, expected, 1e-10)

Process called "test_vector_cross_product" that returns Boolean:
    Note: Test vectorized 3D cross product
    Let a be create_test_vector_float(3, 4)
    Let b be create_test_vector_float(3, 4)
    
    Note: Set test values: a = [1, 0, 0], b = [0, 1, 0]
    Collections.List.set(a.data, 0, 1.0)
    Collections.List.set(a.data, 1, 0.0)
    Collections.List.set(a.data, 2, 0.0)
    
    Collections.List.set(b.data, 0, 0.0)
    Collections.List.set(b.data, 1, 1.0)
    Collections.List.set(b.data, 2, 0.0)
    
    Let result be Vectorization.vector_cross_product(a, b)
    
    Note: a × b = [0, 0, 1] for unit vectors along x and y axes
    Let result_x be Collections.List.get(result.data, 0)
    Let result_y be Collections.List.get(result.data, 1)
    Let result_z be Collections.List.get(result.data, 2)
    
    If not assert_float_equal(result_x, 0.0, 1e-10) then:
        Return false
    End If
    
    If not assert_float_equal(result_y, 0.0, 1e-10) then:
        Return false
    End If
    
    If not assert_float_equal(result_z, 1.0, 1e-10) then:
        Return false
    End If
    
    Return true

Process called "test_vector_cross_product_wrong_size" that returns Boolean:
    Note: Test cross product with non-3D vectors throws error
    Let a be create_test_vector_float(4, 4)  Note: Wrong size
    Let b be create_test_vector_float(3, 4)
    
    Try:
        Vectorization.vector_cross_product(a, b)
        Return false  Note: Should have thrown error
    Catch error:
        Return true   Note: Expected behavior
    End Try

Process called "test_vector_norm" that returns Boolean:
    Note: Test vectorized p-norm computation
    Let vector be create_test_vector_float(3, 4)
    
    Note: Set test values: [3, 4, 0] for easy L2 norm calculation
    Collections.List.set(vector.data, 0, 3.0)
    Collections.List.set(vector.data, 1, 4.0)
    Collections.List.set(vector.data, 2, 0.0)
    
    Note: Test L2 norm (should be 5.0)
    Let l2_norm be Vectorization.vector_norm(vector, 2.0)
    If not assert_float_equal(l2_norm, 5.0, 1e-10) then:
        Return false
    End If
    
    Note: Test L1 norm (should be 7.0)
    Let l1_norm be Vectorization.vector_norm(vector, 1.0)
    If not assert_float_equal(l1_norm, 7.0, 1e-10) then:
        Return false
    End If
    
    Return true

Process called "test_vector_normalize" that returns Boolean:
    Note: Test vectorized vector normalization
    Let vector be create_test_vector_float(2, 4)
    
    Note: Set test values: [3, 4] (L2 norm = 5)
    Collections.List.set(vector.data, 0, 3.0)
    Collections.List.set(vector.data, 1, 4.0)
    
    Let result be Vectorization.vector_normalize(vector)
    
    Let norm_x be Collections.List.get(result.data, 0)
    Let norm_y be Collections.List.get(result.data, 1)
    
    Note: Normalized vector should be [0.6, 0.8]
    If not assert_float_equal(norm_x, 0.6, 1e-6) then:
        Return false
    End If
    
    If not assert_float_equal(norm_y, 0.8, 1e-6) then:
        Return false
    End If
    
    Note: Verify that result is unit vector
    Let result_norm be Vectorization.vector_norm(result, 2.0)
    Return assert_float_equal(result_norm, 1.0, 1e-6)

Process called "test_matrix_vector_multiply" that returns Boolean:
    Note: Test vectorized matrix-vector multiplication
    Let matrix be Collections.List.new()
    Let vector be create_test_vector_float(2, 4)
    
    Note: Create 2x2 matrix [[2, 3], [4, 5]]
    Let row1 be Collections.List.new()
    Collections.List.add(row1, 2.0)
    Collections.List.add(row1, 3.0)
    Collections.List.add(matrix, row1)
    
    Let row2 be Collections.List.new()
    Collections.List.add(row2, 4.0)
    Collections.List.add(row2, 5.0)
    Collections.List.add(matrix, row2)
    
    Note: Set vector [1, 2]
    Collections.List.set(vector.data, 0, 1.0)
    Collections.List.set(vector.data, 1, 2.0)
    
    Let result be Vectorization.matrix_vector_multiply(matrix, vector)
    
    Note: Result should be [2*1 + 3*2, 4*1 + 5*2] = [8, 14]
    Let result0 be Collections.List.get(result.data, 0)
    Let result1 be Collections.List.get(result.data, 1)
    
    If not assert_float_equal(result0, 8.0, 1e-10) then:
        Return false
    End If
    
    If not assert_float_equal(result1, 14.0, 1e-10) then:
        Return false
    End If
    
    Return true

Note: ========================================================================
Note: VECTORIZED REDUCTION OPERATIONS TESTS
Note: ========================================================================

Process called "test_vector_sum" that returns Boolean:
    Note: Test vectorized sum reduction
    Let vector be create_test_vector_float(5, 4)
    
    Note: Set values [1, 2, 3, 4, 5]
    Collections.List.set(vector.data, 0, 1.0)
    Collections.List.set(vector.data, 1, 2.0)
    Collections.List.set(vector.data, 2, 3.0)
    Collections.List.set(vector.data, 3, 4.0)
    Collections.List.set(vector.data, 4, 5.0)
    
    Let result be Vectorization.vector_sum(vector)
    
    Return assert_float_equal(result, 15.0, 1e-10)  Note: 1+2+3+4+5

Process called "test_vector_product" that returns Boolean:
    Note: Test vectorized product reduction
    Let vector be create_test_vector_float(4, 4)
    
    Note: Set values [2, 3, 4, 5]
    Collections.List.set(vector.data, 0, 2.0)
    Collections.List.set(vector.data, 1, 3.0)
    Collections.List.set(vector.data, 2, 4.0)
    Collections.List.set(vector.data, 3, 5.0)
    
    Let result be Vectorization.vector_product(vector)
    
    Return assert_float_equal(result, 120.0, 1e-10)  Note: 2*3*4*5

Process called "test_vector_min" that returns Boolean:
    Note: Test vectorized minimum reduction
    Let vector be create_test_vector_float(5, 4)
    
    Collections.List.set(vector.data, 0, 5.0)
    Collections.List.set(vector.data, 1, 2.0)
    Collections.List.set(vector.data, 2, 8.0)
    Collections.List.set(vector.data, 3, 1.0)  Note: Minimum
    Collections.List.set(vector.data, 4, 9.0)
    
    Let result be Vectorization.vector_min(vector)
    
    Return assert_float_equal(result, 1.0, 1e-10)

Process called "test_vector_max" that returns Boolean:
    Note: Test vectorized maximum reduction
    Let vector be create_test_vector_float(5, 4)
    
    Collections.List.set(vector.data, 0, 5.0)
    Collections.List.set(vector.data, 1, 2.0)
    Collections.List.set(vector.data, 2, 8.0)
    Collections.List.set(vector.data, 3, 1.0)
    Collections.List.set(vector.data, 4, 9.0)  Note: Maximum
    
    Let result be Vectorization.vector_max(vector)
    
    Return assert_float_equal(result, 9.0, 1e-10)

Process called "test_vector_argmin" that returns Boolean:
    Note: Test vectorized argument of minimum
    Let vector be create_test_vector_float(5, 4)
    
    Collections.List.set(vector.data, 0, 5.0)
    Collections.List.set(vector.data, 1, 2.0)
    Collections.List.set(vector.data, 2, 8.0)
    Collections.List.set(vector.data, 3, 1.0)  Note: Minimum at index 3
    Collections.List.set(vector.data, 4, 9.0)
    
    Let result be Vectorization.vector_argmin(vector)
    
    Return result == 3

Process called "test_vector_argmax" that returns Boolean:
    Note: Test vectorized argument of maximum
    Let vector be create_test_vector_float(5, 4)
    
    Collections.List.set(vector.data, 0, 5.0)
    Collections.List.set(vector.data, 1, 2.0)
    Collections.List.set(vector.data, 2, 8.0)
    Collections.List.set(vector.data, 3, 1.0)
    Collections.List.set(vector.data, 4, 9.0)  Note: Maximum at index 4
    
    Let result be Vectorization.vector_argmax(vector)
    
    Return result == 4

Note: ========================================================================
Note: VECTORIZED COMPARISON OPERATIONS TESTS
Note: ========================================================================

Process called "test_vector_equal" that returns Boolean:
    Note: Test vectorized equality comparison
    Let a be create_test_vector_float(4, 4)
    Let b be create_test_vector_float(4, 4)
    
    Note: Set some equal and some different values
    Collections.List.set(a.data, 0, 1.0)
    Collections.List.set(b.data, 0, 1.0)  Note: Equal
    Collections.List.set(a.data, 1, 2.0)
    Collections.List.set(b.data, 1, 3.0)  Note: Different
    
    Let result be Vectorization.vector_equal(a, b)
    
    Let equal0 be Collections.List.get(result, 0)
    Let equal1 be Collections.List.get(result, 1)
    
    If not equal0 then:
        Return false
    End If
    
    If equal1 then:
        Return false
    End If
    
    Return true

Process called "test_vector_greater_than" that returns Boolean:
    Note: Test vectorized greater than comparison
    Let a be create_test_vector_float(3, 4)
    Let b be create_test_vector_float(3, 4)
    
    Collections.List.set(a.data, 0, 5.0)
    Collections.List.set(b.data, 0, 3.0)  Note: a[0] > b[0]
    Collections.List.set(a.data, 1, 2.0)
    Collections.List.set(b.data, 1, 4.0)  Note: a[1] < b[1]
    
    Let result be Vectorization.vector_greater_than(a, b)
    
    Let gt0 be Collections.List.get(result, 0)
    Let gt1 be Collections.List.get(result, 1)
    
    If not gt0 then:  Note: 5 > 3
        Return false
    End If
    
    If gt1 then:  Note: 2 < 4
        Return false
    End If
    
    Return true

Process called "test_vector_select" that returns Boolean:
    Note: Test vectorized conditional selection
    Let condition be Collections.List.new()
    Let true_values be create_test_vector_float(3, 4)
    Let false_values be create_test_vector_float(3, 4)
    
    Collections.List.add(condition, true)
    Collections.List.add(condition, false)
    Collections.List.add(condition, true)
    
    Collections.List.set(true_values.data, 0, 10.0)
    Collections.List.set(false_values.data, 0, 20.0)
    Collections.List.set(true_values.data, 1, 30.0)
    Collections.List.set(false_values.data, 1, 40.0)
    
    Let result be Vectorization.vector_select(condition, true_values, false_values)
    
    Let result0 be Collections.List.get(result.data, 0)  Note: Should be 10 (true)
    Let result1 be Collections.List.get(result.data, 1)  Note: Should be 40 (false)
    
    If not assert_float_equal(result0, 10.0, 1e-10) then:
        Return false
    End If
    
    If not assert_float_equal(result1, 40.0, 1e-10) then:
        Return false
    End If
    
    Return true

Note: ========================================================================
Note: AUTO-VECTORIZATION AND OPTIMIZATION TESTS
Note: ========================================================================

Process called "test_auto_vectorize_loop" that returns Boolean:
    Note: Test automatic loop vectorization
    Let data be Collections.List.new()
    Collections.List.add(data, 2.0)
    Collections.List.add(data, 3.0)
    Collections.List.add(data, 4.0)
    
    Let hints be Vectorization.VectorizationHints
    Set hints.force_vectorization to true
    Set hints.target_architecture to "AVX2"
    Set hints.alignment_requirement to 32
    Set hints.loop_unroll_factor to 4
    Set hints.prefetch_distance to 64
    
    Note: Test square operation
    Let result be Vectorization.auto_vectorize_loop("square", data, hints)
    
    Note: Should return squared values [4, 9, 16]
    If Collections.List.size(result) != 3 then:
        Return false
    End If
    
    Let result0 be Collections.List.get(result, 0)
    If not assert_float_equal(result0, 4.0, 1e-10) then:
        Return false
    End If
    
    Return true

Process called "test_vectorization_analysis" that returns Boolean:
    Note: Test vectorization opportunity analysis
    Let code_block be "for i in range(n): result[i] = a[i] + b[i] * c[i]"
    
    Let analysis be Vectorization.vectorization_analysis(code_block)
    
    Note: Should detect vectorizable loop
    Let vectorizable_loops be Collections.Dictionary.get(analysis, "vectorizable_loops").to_integer()
    If vectorizable_loops <= 0 then:
        Return false
    End If
    
    Note: Should detect SIMD-friendly operations
    Let simd_ops be Collections.Dictionary.get(analysis, "simd_friendly_operations").to_integer()
    If simd_ops <= 0 then:
        Return false
    End If
    
    Return true

Process called "test_generate_vectorized_code" that returns Boolean:
    Note: Test vectorized code generation
    Let scalar_function be "add"
    Let target_arch be "AVX2"
    
    Let vectorized_code be Vectorization.generate_vectorized_code(scalar_function, target_arch)
    
    Note: Should contain vectorized instructions
    If vectorized_code == "" then:
        Return false
    End If
    
    Note: Should reference the target architecture width
    If not vectorized_code contains "8" then:  Note: AVX2 = 8 floats
        Return false
    End If
    
    Return true

Process called "test_optimization_hints" that returns Boolean:
    Note: Test optimization hints generation
    Let hints be Vectorization.optimization_hints("dense_arithmetic")
    
    If not hints.force_vectorization then:
        Return false
    End If
    
    If hints.target_architecture != "AVX2" then:
        Return false
    End If
    
    If hints.alignment_requirement != 32 then:
        Return false
    End If
    
    Return true

Note: ========================================================================
Note: UTILITY FUNCTIONS TESTS
Note: ========================================================================

Process called "test_create_aligned_vector" that returns Boolean:
    Note: Test aligned vector creation
    Let size be 10
    Let alignment be 32
    
    Let vector be Vectorization.create_aligned_vector(size, alignment)
    
    If vector.length != size then:
        Return false
    End If
    
    If vector.alignment != alignment then:
        Return false
    End If
    
    If Collections.List.size(vector.data) != size then:
        Return false
    End If
    
    Note: All elements should be initialized to zero
    Let i be 0
    While i < size:
        Let value be Collections.List.get(vector.data, i)
        If not assert_float_equal(value, 0.0, 1e-10) then:
            Return false
        End If
        Set i to i + 1
    End While
    
    Return true

Process called "test_vector_to_list" that returns Boolean:
    Note: Test vector to list conversion
    Let vector be create_test_vector_float(4, 4)
    Let list be Vectorization.vector_to_list(vector)
    
    If Collections.List.size(list) != 4 then:
        Return false
    End If
    
    Return assert_vectors_equal(list, vector.data, 1e-10)

Process called "test_list_to_vector" that returns Boolean:
    Note: Test list to vector conversion
    Let list be Collections.List.new()
    Collections.List.add(list, 1.5)
    Collections.List.add(list, 2.5)
    Collections.List.add(list, 3.5)
    
    Let vector be Vectorization.list_to_vector(list, 16)
    
    If vector.length != 3 then:
        Return false
    End If
    
    If vector.alignment != 16 then:
        Return false
    End If
    
    Return assert_vectors_equal(vector.data, list, 1e-10)

Process called "test_calculate_aligned_length" that returns Boolean:
    Note: Test aligned length calculation
    Let length be 13
    Let alignment be 4
    
    Let aligned_length be Vectorization.calculate_aligned_length(length, alignment)
    
    Note: Should round up to next multiple of 4
    If aligned_length != 16 then:
        Return false
    End If
    
    Note: Test already aligned length
    Let already_aligned be Vectorization.calculate_aligned_length(16, 4)
    If already_aligned != 16 then:
        Return false
    End If
    
    Return true

Note: ========================================================================
Note: COMPREHENSIVE TEST SUITE RUNNER
Note: ========================================================================

Process called "run_all_vectorization_tests" that returns Dictionary[String, Boolean]:
    Note: Run all vectorization module tests and return results
    Let test_results be Collections.Dictionary.new()
    
    Note: SIMD capability detection tests
    Collections.Dictionary.set(test_results, "test_detect_simd_capabilities", test_detect_simd_capabilities())
    Collections.Dictionary.set(test_results, "test_get_optimal_vector_width", test_get_optimal_vector_width())
    Collections.Dictionary.set(test_results, "test_get_optimal_vector_width_unknown_type", test_get_optimal_vector_width_unknown_type())
    Collections.Dictionary.set(test_results, "test_check_memory_alignment", test_check_memory_alignment())
    Collections.Dictionary.set(test_results, "test_align_memory", test_align_memory())
    
    Note: Basic vectorized arithmetic tests
    Collections.Dictionary.set(test_results, "test_vector_add", test_vector_add())
    Collections.Dictionary.set(test_results, "test_vector_add_mismatched_length", test_vector_add_mismatched_length())
    Collections.Dictionary.set(test_results, "test_vector_subtract", test_vector_subtract())
    Collections.Dictionary.set(test_results, "test_vector_multiply", test_vector_multiply())
    Collections.Dictionary.set(test_results, "test_vector_divide", test_vector_divide())
    Collections.Dictionary.set(test_results, "test_vector_divide_by_zero", test_vector_divide_by_zero())
    Collections.Dictionary.set(test_results, "test_vector_multiply_add", test_vector_multiply_add())
    Collections.Dictionary.set(test_results, "test_vector_scalar_multiply", test_vector_scalar_multiply())
    
    Note: Vectorized transcendental functions tests
    Collections.Dictionary.set(test_results, "test_vector_sin", test_vector_sin())
    Collections.Dictionary.set(test_results, "test_vector_cos", test_vector_cos())
    Collections.Dictionary.set(test_results, "test_vector_exp", test_vector_exp())
    Collections.Dictionary.set(test_results, "test_vector_log", test_vector_log())
    Collections.Dictionary.set(test_results, "test_vector_log_negative", test_vector_log_negative())
    Collections.Dictionary.set(test_results, "test_vector_sqrt", test_vector_sqrt())
    
    Note: Vectorized linear algebra tests
    Collections.Dictionary.set(test_results, "test_vector_dot_product", test_vector_dot_product())
    Collections.Dictionary.set(test_results, "test_vector_cross_product", test_vector_cross_product())
    Collections.Dictionary.set(test_results, "test_vector_cross_product_wrong_size", test_vector_cross_product_wrong_size())
    Collections.Dictionary.set(test_results, "test_vector_norm", test_vector_norm())
    Collections.Dictionary.set(test_results, "test_vector_normalize", test_vector_normalize())
    Collections.Dictionary.set(test_results, "test_matrix_vector_multiply", test_matrix_vector_multiply())
    
    Note: Vectorized reduction operations tests
    Collections.Dictionary.set(test_results, "test_vector_sum", test_vector_sum())
    Collections.Dictionary.set(test_results, "test_vector_product", test_vector_product())
    Collections.Dictionary.set(test_results, "test_vector_min", test_vector_min())
    Collections.Dictionary.set(test_results, "test_vector_max", test_vector_max())
    Collections.Dictionary.set(test_results, "test_vector_argmin", test_vector_argmin())
    Collections.Dictionary.set(test_results, "test_vector_argmax", test_vector_argmax())
    
    Note: Vectorized comparison operations tests
    Collections.Dictionary.set(test_results, "test_vector_equal", test_vector_equal())
    Collections.Dictionary.set(test_results, "test_vector_greater_than", test_vector_greater_than())
    Collections.Dictionary.set(test_results, "test_vector_select", test_vector_select())
    
    Note: Auto-vectorization and optimization tests
    Collections.Dictionary.set(test_results, "test_auto_vectorize_loop", test_auto_vectorize_loop())
    Collections.Dictionary.set(test_results, "test_vectorization_analysis", test_vectorization_analysis())
    Collections.Dictionary.set(test_results, "test_generate_vectorized_code", test_generate_vectorized_code())
    Collections.Dictionary.set(test_results, "test_optimization_hints", test_optimization_hints())
    
    Note: Utility functions tests
    Collections.Dictionary.set(test_results, "test_create_aligned_vector", test_create_aligned_vector())
    Collections.Dictionary.set(test_results, "test_vector_to_list", test_vector_to_list())
    Collections.Dictionary.set(test_results, "test_list_to_vector", test_list_to_vector())
    Collections.Dictionary.set(test_results, "test_calculate_aligned_length", test_calculate_aligned_length())
    
    Return test_results

Process called "count_test_results" that takes results as Dictionary[String, Boolean] returns Dictionary[String, Integer]:
    Note: Count passed and failed tests
    Let summary be Collections.Dictionary.new()
    Let passed be 0
    Let failed be 0
    Let total be 0
    
    Let test_names be Collections.Dictionary.keys(results)
    Let i be 0
    Let num_tests be Collections.List.size(test_names)
    
    While i < num_tests:
        Let test_name be Collections.List.get(test_names, i)
        Let test_result be Collections.Dictionary.get(results, test_name)
        
        If test_result then:
            Set passed to passed + 1
        Else:
            Set failed to failed + 1
        End If
        
        Set total to total + 1
        Set i to i + 1
    End While
    
    Collections.Dictionary.set(summary, "passed", passed)
    Collections.Dictionary.set(summary, "failed", failed)
    Collections.Dictionary.set(summary, "total", total)
    
    Return summary

Process called "print_test_summary" that takes results as Dictionary[String, Boolean] returns Nothing:
    Note: Print test execution summary
    Let summary be count_test_results(results)
    Let passed be Collections.Dictionary.get(summary, "passed")
    Let failed be Collections.Dictionary.get(summary, "failed")
    Let total be Collections.Dictionary.get(summary, "total")
    
    Note: Print summary statistics
    Print "Vectorization Module Test Results:"
    Print "=================================="
    Print "Total tests: " + total.to_string()
    Print "Passed: " + passed.to_string()
    Print "Failed: " + failed.to_string()
    
    If failed > 0 then:
        Print ""
        Print "Failed tests:"
        Let test_names be Collections.Dictionary.keys(results)
        Let i be 0
        Let num_tests be Collections.List.size(test_names)
        
        While i < num_tests:
            Let test_name be Collections.List.get(test_names, i)
            Let test_result be Collections.Dictionary.get(results, test_name)
            
            If not test_result then:
                Print "- " + test_name
            End If
            
            Set i to i + 1
        End While
    End If
    
    Print ""
    If failed == 0 then:
        Print "All tests passed! ✓"
    Else:
        Print "Some tests failed. Please review the implementation."
    End If