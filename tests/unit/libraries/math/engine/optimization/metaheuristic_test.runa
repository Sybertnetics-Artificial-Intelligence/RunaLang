Note:
tests/unit/libraries/math/engine/optimization/metaheuristic_test.runa
Unit Tests for Math Engine Optimization Metaheuristic Module

This test suite provides comprehensive testing for the math engine optimization metaheuristic module including:
- Simulated Annealing with various cooling schedules
- Tabu Search with different memory structures and aspiration criteria
- Ant Colony Optimization for continuous and discrete problems
- Bee Colony Algorithm variants (ABC, Artificial Bee Colony)
- Firefly Algorithm with light intensity and movement patterns
- Cuckoo Search with L√©vy flight random walks
- Gravitational Search Algorithm and mass calculations
- Chemical Reaction Optimization and reaction operators
- Cultural Evolution Algorithm with belief spaces
- Hybrid metaheuristic combinations and adaptive strategies
- Multi-objective metaheuristic algorithms
- Dynamic and adaptive parameter control
:End Note

Import "stdlib/math/engine/optimization/metaheuristic" as MetaOpt
Import "dev/debug/test_framework/assertions" as Assert
Import "dev/debug/test_framework/test_runner" as TestRunner
Import "dev/debug/test_framework/data_generators" as DataGen
Import "math.core" as MathCore
Import "collections" as Collections

Note: =====================================================================
Note: HELPER FUNCTIONS AND TEST UTILITIES
Note: =====================================================================

Process called "create_test_objective_function" that takes function_type as String returns MetaheuristicObjective:
    Note: Create test objective function for metaheuristic algorithms
    If function_type == "sphere":
        Return MetaOpt.MetaheuristicObjective{
            function: "lambda x: sum(xi*xi for xi in x)",
            dimension: 2,
            bounds_lower: ["-5.0", "-5.0"],
            bounds_upper: ["5.0", "5.0"],
            global_optimum: "0.0",
            is_minimization: True,
            landscape_type: "unimodal"
        }
    Otherwise if function_type == "rastrigin":
        Return MetaOpt.MetaheuristicObjective{
            function: "lambda x: 10*len(x) + sum(xi*xi - 10*cos(2*pi*xi) for xi in x)",
            dimension: 2,
            bounds_lower: ["-5.12", "-5.12"],
            bounds_upper: ["5.12", "5.12"],
            global_optimum: "0.0",
            is_minimization: True,
            landscape_type: "highly_multimodal"
        }
    Otherwise if function_type == "ackley":
        Return MetaOpt.MetaheuristicObjective{
            function: "lambda x: -20*exp(-0.2*sqrt(sum(xi*xi for xi in x)/len(x))) - exp(sum(cos(2*pi*xi) for xi in x)/len(x)) + 20 + e",
            dimension: 2,
            bounds_lower: ["-32.768", "-32.768"],
            bounds_upper: ["32.768", "32.768"],
            global_optimum: "0.0",
            is_minimization: True,
            landscape_type: "multimodal"
        }
    Otherwise:
        Return MetaOpt.MetaheuristicObjective{
            function: "lambda x: x[0]*x[0] + x[1]*x[1]",
            dimension: 2,
            bounds_lower: ["-10.0", "-10.0"],
            bounds_upper: ["10.0", "10.0"],
            global_optimum: "0.0",
            is_minimization: True,
            landscape_type: "simple"
        }

Process called "create_discrete_optimization_problem" returns DiscreteOptimizationProblem:
    Note: Create discrete optimization problem (TSP-like)
    Return MetaOpt.DiscreteOptimizationProblem{
        problem_type: "tsp",
        num_cities: 10,
        distance_matrix: MetaOpt.generate_random_distance_matrix(10, 42),
        optimal_tour_length: "known",
        solution_representation: "permutation"
    }

Process called "assert_metaheuristic_result_valid" that takes result as MetaheuristicResult returns Boolean:
    Note: Assert that metaheuristic optimization result is valid
    Assert.IsNotNull(result)
    Assert.IsTrue(result.converged == "true" or result.converged == "false")
    Assert.IsTrue(result.iterations >= 0)
    Assert.IsTrue(result.function_evaluations >= 0)
    Assert.IsNotEmpty(result.best_solution)
    Assert.IsNotEmpty(result.best_fitness)
    Assert.IsNotNull(result.convergence_history)
    Return True

Process called "create_cooling_schedule" that takes schedule_type as String returns TemperatureSchedule:
    Note: Create cooling schedule for simulated annealing
    If schedule_type == "linear":
        Return MetaOpt.TemperatureSchedule{
            type: "linear",
            initial_temperature: "100.0",
            final_temperature: "0.01",
            cooling_rate: "0.95"
        }
    Otherwise if schedule_type == "exponential":
        Return MetaOpt.TemperatureSchedule{
            type: "exponential",
            initial_temperature: "100.0",
            final_temperature: "0.01",
            cooling_rate: "0.95"
        }
    Otherwise if schedule_type == "logarithmic":
        Return MetaOpt.TemperatureSchedule{
            type: "logarithmic", 
            initial_temperature: "100.0",
            final_temperature: "0.01",
            cooling_constant: "10.0"
        }
    Otherwise:
        Return MetaOpt.TemperatureSchedule{
            type: "geometric",
            initial_temperature: "100.0",
            final_temperature: "0.01",
            cooling_rate: "0.9"
        }

Note: =====================================================================
Note: SIMULATED ANNEALING TESTS
Note: =====================================================================

Process called "test_simulated_annealing_basic" that takes no parameters returns Boolean:
    Note: Test basic simulated annealing functionality
    Let objective be create_test_objective_function("sphere")
    Let schedule be create_cooling_schedule("exponential")
    
    Let config be MetaOpt.SimulatedAnnealingConfig{
        temperature_schedule: schedule,
        max_iterations: 1000,
        initial_solution_method: "random",
        neighborhood_method: "gaussian",
        neighborhood_radius: "0.5"
    }
    
    Let result be MetaOpt.simulated_annealing(objective, config)
    
    Assert.IsTrue(assert_metaheuristic_result_valid(result))
    Assert.IsTrue(result.iterations > 0)
    
    Note: Should find reasonable solution for sphere function
    Let best_fitness be MathCore.parse_float(result.best_fitness)
    Assert.IsTrue(best_fitness < 1.0)
    Return True

Process called "test_simulated_annealing_cooling_schedules" that takes no parameters returns Boolean:
    Note: Test different cooling schedules
    Let objective be create_test_objective_function("ackley")
    
    Let schedule_types be ["linear", "exponential", "logarithmic", "geometric"]
    
    For schedule_type in schedule_types:
        Let schedule be create_cooling_schedule(schedule_type)
        Let config be MetaOpt.SimulatedAnnealingConfig{
            temperature_schedule: schedule,
            max_iterations: 500,
            initial_solution_method: "center"
        }
        
        Let result be MetaOpt.simulated_annealing(objective, config)
        Assert.IsTrue(assert_metaheuristic_result_valid(result))
    
    Return True

Process called "test_simulated_annealing_neighborhood_methods" that takes no parameters returns Boolean:
    Note: Test different neighborhood generation methods
    Let objective be create_test_objective_function("rastrigin")
    Let schedule be create_cooling_schedule("exponential")
    
    Let neighborhood_methods be ["gaussian", "uniform", "cauchy", "levy"]
    
    For method in neighborhood_methods:
        Let config be MetaOpt.SimulatedAnnealingConfig{
            temperature_schedule: schedule,
            max_iterations: 300,
            neighborhood_method: method,
            neighborhood_radius: "1.0"
        }
        
        Let result be MetaOpt.simulated_annealing(objective, config)
        Assert.IsTrue(assert_metaheuristic_result_valid(result))
    
    Return True

Process called "test_adaptive_simulated_annealing" that takes no parameters returns Boolean:
    Note: Test adaptive simulated annealing
    Let objective be create_test_objective_function("ackley")
    
    Let config be MetaOpt.AdaptiveSimulatedAnnealingConfig{
        initial_temperature: "50.0",
        adaptive_cooling: True,
        acceptance_ratio_target: "0.4",
        temperature_adjustment_factor: "1.1",
        max_iterations: 800
    }
    
    Let result be MetaOpt.adaptive_simulated_annealing(objective, config)
    
    Assert.IsTrue(assert_metaheuristic_result_valid(result))
    Assert.IsNotNull(result.temperature_adaptation_history)
    Return True

Note: =====================================================================
Note: TABU SEARCH TESTS
Note: =====================================================================

Process called "test_tabu_search_basic" that takes no parameters returns Boolean:
    Note: Test basic tabu search algorithm
    Let objective be create_test_objective_function("sphere")
    
    Let tabu_memory be MetaOpt.TabuMemory{
        memory_type: "recency_based",
        memory_size: 10,
        tenure: 5
    }
    
    Let config be MetaOpt.TabuSearchConfig{
        tabu_memory: tabu_memory,
        max_iterations: 200,
        neighborhood_size: 20,
        intensification_threshold: 50,
        diversification_threshold: 100
    }
    
    Let result be MetaOpt.tabu_search(objective, config)
    
    Assert.IsTrue(assert_metaheuristic_result_valid(result))
    Assert.IsNotNull(result.tabu_statistics)
    Return True

Process called "test_tabu_search_memory_structures" that takes no parameters returns Boolean:
    Note: Test different tabu memory structures
    Let objective be create_test_objective_function("rastrigin")
    
    Let memory_types be [
        ["recency_based", 10],
        ["frequency_based", 20],
        ["quality_based", 15]
    ]
    
    For memory_info in memory_types:
        Let tabu_memory be MetaOpt.TabuMemory{
            memory_type: memory_info[0],
            memory_size: memory_info[1],
            tenure: 7
        }
        
        Let config be MetaOpt.TabuSearchConfig{
            tabu_memory: tabu_memory,
            max_iterations: 150
        }
        
        Let result be MetaOpt.tabu_search(objective, config)
        Assert.IsTrue(assert_metaheuristic_result_valid(result))
    
    Return True

Process called "test_tabu_search_aspiration_criteria" that takes no parameters returns Boolean:
    Note: Test tabu search with aspiration criteria
    Let objective be create_test_objective_function("ackley")
    
    Let config be MetaOpt.TabuSearchConfig{
        tabu_memory: MetaOpt.TabuMemory{memory_type: "recency_based", memory_size: 12, tenure: 6},
        aspiration_criterion: "best_solution",
        aspiration_threshold: "0.1",
        max_iterations: 250
    }
    
    Let result be MetaOpt.tabu_search(objective, config)
    
    Assert.IsTrue(assert_metaheuristic_result_valid(result))
    Assert.IsTrue(result.aspiration_activations >= 0)
    Return True

Process called "test_reactive_tabu_search" that takes no parameters returns Boolean:
    Note: Test reactive tabu search with adaptive memory
    Let objective be create_test_objective_function("rastrigin")
    
    Let config be MetaOpt.ReactiveTabuSearchConfig{
        initial_tenure: 5,
        tenure_adaptation_factor: "1.2",
        cycle_detection: True,
        diversification_strategy: "random_restart",
        max_iterations: 300
    }
    
    Let result be MetaOpt.reactive_tabu_search(objective, config)
    
    Assert.IsTrue(assert_metaheuristic_result_valid(result))
    Assert.IsNotNull(result.tenure_adaptation_history)
    Return True

Note: =====================================================================
Note: ANT COLONY OPTIMIZATION TESTS
Note: =====================================================================

Process called "test_ant_colony_optimization_continuous" that takes no parameters returns Boolean:
    Note: Test ACO for continuous optimization
    Let objective be create_test_objective_function("sphere")
    
    Let config be MetaOpt.AntColonyConfig{
        num_ants: 20,
        max_iterations: 100,
        alpha: "1.0",
        beta: "2.0",
        rho: "0.1",
        q0: "0.9",
        archive_size: 10,
        gaussian_kernel_xi: "0.85"
    }
    
    Let result be MetaOpt.ant_colony_optimization_continuous(objective, config)
    
    Assert.IsTrue(assert_metaheuristic_result_valid(result))
    Assert.IsNotNull(result.pheromone_statistics)
    Return True

Process called "test_ant_colony_optimization_discrete" that takes no parameters returns Boolean:
    Note: Test ACO for discrete optimization problems (TSP)
    Let problem be create_discrete_optimization_problem()
    
    Let config be MetaOpt.AntColonyConfig{
        num_ants: 15,
        max_iterations: 150,
        alpha: "1.0",
        beta: "5.0",
        rho: "0.5",
        q0: "0.0",
        local_search: True
    }
    
    Let result be MetaOpt.ant_colony_optimization_tsp(problem, config)
    
    Assert.IsTrue(assert_metaheuristic_result_valid(result))
    Assert.IsNotNull(result.best_tour)
    
    Note: Check tour validity (all cities visited once)
    Let tour_length be result.best_tour.length
    Assert.IsTrue(tour_length == problem.num_cities)
    Return True

Process called "test_max_min_ant_system" that takes no parameters returns Boolean:
    Note: Test MAX-MIN Ant System variant
    Let objective be create_test_objective_function("ackley")
    
    Let config be MetaOpt.MaxMinAntSystemConfig{
        num_ants: 25,
        max_iterations: 120,
        tau_max: "1.0",
        tau_min: "0.01",
        pheromone_update_rule: "best_so_far",
        local_search_probability: "0.1"
    }
    
    Let result be MetaOpt.max_min_ant_system(objective, config)
    
    Assert.IsTrue(assert_metaheuristic_result_valid(result))
    
    Note: Check pheromone bounds maintenance
    Assert.IsNotNull(result.pheromone_bounds_history)
    Return True

Note: =====================================================================
Note: BEE COLONY ALGORITHM TESTS
Note: =====================================================================

Process called "test_artificial_bee_colony_basic" that takes no parameters returns Boolean:
    Note: Test basic Artificial Bee Colony algorithm
    Let objective be create_test_objective_function("sphere")
    
    Let config be MetaOpt.BeeColonyConfig{
        colony_size: 30,
        employed_bees: 15,
        onlooker_bees: 15,
        scout_bees: 0,
        max_iterations: 150,
        limit: 10,
        modification_rate: "1.0"
    }
    
    Let result be MetaOpt.artificial_bee_colony(objective, config)
    
    Assert.IsTrue(assert_metaheuristic_result_valid(result))
    
    Note: ABC should perform well on sphere function
    Let best_fitness be MathCore.parse_float(result.best_fitness)
    Assert.IsTrue(best_fitness < 0.1)
    Return True

Process called "test_bee_colony_with_scouts" that takes no parameters returns Boolean:
    Note: Test bee colony with scout bee behavior
    Let objective be create_test_objective_function("rastrigin")
    
    Let config be MetaOpt.BeeColonyConfig{
        colony_size: 40,
        employed_bees: 15,
        onlooker_bees: 15,
        scout_bees: 10,
        max_iterations: 200,
        limit: 5,
        scout_activation_threshold: 20
    }
    
    Let result be MetaOpt.artificial_bee_colony(objective, config)
    
    Assert.IsTrue(assert_metaheuristic_result_valid(result))
    Assert.IsNotNull(result.scout_activations)
    Assert.IsTrue(result.scout_activations > 0)
    Return True

Process called "test_bee_colony_selection_methods" that takes no parameters returns Boolean:
    Note: Test different selection methods for onlooker bees
    Let objective be create_test_objective_function("ackley")
    
    Let selection_methods be ["roulette_wheel", "tournament", "rank_based"]
    
    For method in selection_methods:
        Let config be MetaOpt.BeeColonyConfig{
            colony_size: 24,
            employed_bees: 12,
            onlooker_bees: 12,
            onlooker_selection_method: method,
            max_iterations: 100
        }
        
        Let result be MetaOpt.artificial_bee_colony(objective, config)
        Assert.IsTrue(assert_metaheuristic_result_valid(result))
    
    Return True

Note: =====================================================================
Note: FIREFLY ALGORITHM TESTS
Note: =====================================================================

Process called "test_firefly_algorithm_basic" that takes no parameters returns Boolean:
    Note: Test basic Firefly Algorithm
    Let objective be create_test_objective_function("sphere")
    
    Let config be MetaOpt.FireflyConfig{
        num_fireflies: 25,
        max_iterations: 100,
        alpha: "0.5",
        beta0: "1.0",
        gamma: "1.0",
        randomization_method: "gaussian"
    }
    
    Let result be MetaOpt.firefly_algorithm(objective, config)
    
    Assert.IsTrue(assert_metaheuristic_result_valid(result))
    
    Note: Firefly should converge well on sphere
    Let best_fitness be MathCore.parse_float(result.best_fitness)
    Assert.IsTrue(best_fitness < 0.5)
    Return True

Process called "test_firefly_light_intensity_models" that takes no parameters returns Boolean:
    Note: Test different light intensity models
    Let objective be create_test_objective_function("rastrigin")
    
    Let intensity_models be ["inverse_square", "exponential", "gaussian"]
    
    For model in intensity_models:
        Let config be MetaOpt.FireflyConfig{
            num_fireflies: 20,
            max_iterations: 80,
            light_intensity_model: model,
            alpha: "0.2",
            beta0: "1.0",
            gamma: "0.01"
        }
        
        Let result be MetaOpt.firefly_algorithm(objective, config)
        Assert.IsTrue(assert_metaheuristic_result_valid(result))
    
    Return True

Process called "test_firefly_movement_strategies" that takes no parameters returns Boolean:
    Note: Test different firefly movement strategies
    Let objective be create_test_objective_function("ackley")
    
    Let movement_strategies be ["attraction_based", "levy_flight", "random_walk"]
    
    For strategy in movement_strategies:
        Let config be MetaOpt.FireflyConfig{
            num_fireflies: 30,
            max_iterations: 120,
            movement_strategy: strategy,
            alpha: "0.3",
            levy_beta: "1.5"
        }
        
        Let result be MetaOpt.firefly_algorithm(objective, config)
        Assert.IsTrue(assert_metaheuristic_result_valid(result))
    
    Return True

Note: =====================================================================
Note: CUCKOO SEARCH TESTS
Note: =====================================================================

Process called "test_cuckoo_search_basic" that takes no parameters returns Boolean:
    Note: Test basic Cuckoo Search algorithm
    Let objective be create_test_objective_function("sphere")
    
    Let config be MetaOpt.CuckooSearchConfig{
        nest_population: 25,
        max_iterations: 150,
        pa: "0.25",
        levy_beta: "1.5",
        step_size_scaling: "0.01"
    }
    
    Let result be MetaOpt.cuckoo_search(objective, config)
    
    Assert.IsTrue(assert_metaheuristic_result_valid(result))
    
    Note: Cuckoo search should find good solution
    Let best_fitness be MathCore.parse_float(result.best_fitness)
    Assert.IsTrue(best_fitness < 1.0)
    Return True

Process called "test_cuckoo_search_levy_flights" that takes no parameters returns Boolean:
    Note: Test Cuckoo Search with different L√©vy flight parameters
    Let objective be create_test_objective_function("rastrigin")
    
    Let levy_betas be ["1.0", "1.5", "2.0", "3.0"]
    
    For beta in levy_betas:
        Let config be MetaOpt.CuckooSearchConfig{
            nest_population: 20,
            max_iterations: 100,
            pa: "0.25",
            levy_beta: beta,
            step_size_scaling: "0.02"
        }
        
        Let result be MetaOpt.cuckoo_search(objective, config)
        Assert.IsTrue(assert_metaheuristic_result_valid(result))
    
    Return True

Process called "test_improved_cuckoo_search" that takes no parameters returns Boolean:
    Note: Test improved Cuckoo Search with local search
    Let objective be create_test_objective_function("ackley")
    
    Let config be MetaOpt.ImprovedCuckooSearchConfig{
        nest_population: 30,
        max_iterations: 200,
        pa: "0.2",
        levy_beta: "1.5",
        local_search_probability: "0.3",
        local_search_method: "random_walk"
    }
    
    Let result be MetaOpt.improved_cuckoo_search(objective, config)
    
    Assert.IsTrue(assert_metaheuristic_result_valid(result))
    Assert.IsNotNull(result.local_search_statistics)
    Return True

Note: =====================================================================
Note: GRAVITATIONAL SEARCH ALGORITHM TESTS
Note: =====================================================================

Process called "test_gravitational_search_basic" that takes no parameters returns Boolean:
    Note: Test basic Gravitational Search Algorithm
    Let objective be create_test_objective_function("sphere")
    
    Let config be MetaOpt.GravitationalConfig{
        num_agents: 30,
        max_iterations: 150,
        g0: "100.0",
        alpha: "20.0",
        epsilon: "1e-10",
        kbest_percentage: "0.1"
    }
    
    Let result be MetaOpt.gravitational_search_algorithm(objective, config)
    
    Assert.IsTrue(assert_metaheuristic_result_valid(result))
    
    Note: GSA should perform well on sphere function
    Let best_fitness be MathCore.parse_float(result.best_fitness)
    Assert.IsTrue(best_fitness < 0.1)
    Return True

Process called "test_gravitational_search_mass_calculation" that takes no parameters returns Boolean:
    Note: Test different mass calculation methods in GSA
    Let objective be create_test_objective_function("rastrigin")
    
    Let mass_methods be ["fitness_based", "rank_based", "exponential"]
    
    For method in mass_methods:
        Let config be MetaOpt.GravitationalConfig{
            num_agents: 25,
            max_iterations: 100,
            mass_calculation_method: method,
            g0: "50.0",
            alpha: "15.0"
        }
        
        Let result be MetaOpt.gravitational_search_algorithm(objective, config)
        Assert.IsTrue(assert_metaheuristic_result_valid(result))
    
    Return True

Process called "test_gravitational_search_kbest_strategy" that takes no parameters returns Boolean:
    Note: Test K-best strategy in gravitational search
    Let objective be create_test_objective_function("ackley")
    
    Let kbest_percentages be ["0.05", "0.1", "0.2", "0.5"]
    
    For percentage in kbest_percentages:
        Let config be MetaOpt.GravitationalConfig{
            num_agents: 40,
            max_iterations: 120,
            kbest_percentage: percentage,
            g0: "80.0",
            alpha: "25.0"
        }
        
        Let result be MetaOpt.gravitational_search_algorithm(objective, config)
        Assert.IsTrue(assert_metaheuristic_result_valid(result))
    
    Return True

Note: =====================================================================
Note: CHEMICAL REACTION OPTIMIZATION TESTS
Note: =====================================================================

Process called "test_chemical_reaction_optimization_basic" that takes no parameters returns Boolean:
    Note: Test basic Chemical Reaction Optimization
    Let objective be create_test_objective_function("sphere")
    
    Let config be MetaOpt.ChemicalReactionConfig{
        population_size: 30,
        max_iterations: 200,
        kinetic_energy_loss_rate: "0.1",
        initial_kinetic_energy: "1000.0",
        molecular_collision_rate: "0.2",
        synthesis_rate: "0.2",
        decomposition_threshold: "100.0"
    }
    
    Let result be MetaOpt.chemical_reaction_optimization(objective, config)
    
    Assert.IsTrue(assert_metaheuristic_result_valid(result))
    
    Note: CRO should find good solutions
    Let best_fitness be MathCore.parse_float(result.best_fitness)
    Assert.IsTrue(best_fitness < 1.0)
    Return True

Process called "test_chemical_reaction_operators" that takes no parameters returns Boolean:
    Note: Test different chemical reaction operators
    Let objective be create_test_objective_function("rastrigin")
    
    Let config be MetaOpt.ChemicalReactionConfig{
        population_size: 25,
        max_iterations: 150,
        on_wall_ineffective_collision_rate: "0.3",
        decomposition_rate: "0.15",
        inter_molecular_collision_rate: "0.4",
        synthesis_rate: "0.15"
    }
    
    Let result be MetaOpt.chemical_reaction_optimization_with_tracking(objective, config)
    
    Assert.IsTrue(assert_metaheuristic_result_valid(result))
    Assert.IsNotNull(result.reaction_statistics)
    
    Note: Check that different reactions occurred
    Assert.IsTrue(result.reaction_statistics.on_wall_collisions > 0)
    Assert.IsTrue(result.reaction_statistics.inter_molecular_collisions > 0)
    Return True

Note: =====================================================================
Note: HYBRID AND ADAPTIVE METAHEURISTICS TESTS
Note: =====================================================================

Process called "test_hybrid_metaheuristic_sa_tabu" that takes no parameters returns Boolean:
    Note: Test hybrid SA-Tabu Search algorithm
    Let objective be create_test_objective_function("ackley")
    
    Let config be MetaOpt.HybridConfig{
        primary_algorithm: "simulated_annealing",
        secondary_algorithm: "tabu_search",
        switching_criterion: "iteration_based",
        switch_point: 100,
        max_iterations: 200
    }
    
    Let result be MetaOpt.hybrid_sa_tabu(objective, config)
    
    Assert.IsTrue(assert_metaheuristic_result_valid(result))
    Assert.IsNotNull(result.algorithm_switches)
    Assert.IsTrue(result.algorithm_switches.length > 0)
    Return True

Process called "test_adaptive_metaheuristic_parameters" that takes no parameters returns Boolean:
    Note: Test adaptive parameter control in metaheuristics
    Let objective be create_test_objective_function("rastrigin")
    
    Let config be MetaOpt.AdaptationConfig{
        base_algorithm: "firefly",
        parameter_adaptation_method: "feedback_based",
        adaptation_frequency: 20,
        performance_metric: "improvement_rate",
        parameter_ranges: [
            ["alpha", "0.1", "1.0"],
            ["beta0", "0.5", "2.0"],
            ["gamma", "0.01", "1.0"]
        ]
    }
    
    Let result be MetaOpt.adaptive_metaheuristic(objective, config)
    
    Assert.IsTrue(assert_metaheuristic_result_valid(result))
    Assert.IsNotNull(result.parameter_adaptation_history)
    Return True

Process called "test_multi_swarm_metaheuristic" that takes no parameters returns Boolean:
    Note: Test multi-swarm metaheuristic approach
    Let objective be create_test_objective_function("rastrigin")
    
    Let config be MetaOpt.MultiSwarmConfig{
        num_swarms: 3,
        swarm_size: 15,
        base_algorithm: "firefly",
        migration_interval: 30,
        migration_rate: "0.1",
        diversity_maintenance: True
    }
    
    Let result be MetaOpt.multi_swarm_metaheuristic(objective, config)
    
    Assert.IsTrue(assert_metaheuristic_result_valid(result))
    Assert.IsTrue(result.swarms.length == 3)
    Assert.IsNotNull(result.migration_statistics)
    Return True

Note: =====================================================================
Note: MULTI-OBJECTIVE METAHEURISTICS TESTS
Note: =====================================================================

Process called "test_multi_objective_simulated_annealing" that takes no parameters returns Boolean:
    Note: Test multi-objective simulated annealing (MOSA)
    Let objectives be MetaOpt.MultiObjectiveFunction{
        objectives: [
            "lambda x: x[0]*x[0] + x[1]*x[1]",
            "lambda x: (x[0] - 1)*(x[0] - 1) + x[1]*x[1]"
        ],
        dimension: 2,
        bounds_lower: ["-2.0", "-2.0"],
        bounds_upper: ["2.0", "2.0"]
    }
    
    Let config be MetaOpt.MOSAConfig{
        temperature_schedule: create_cooling_schedule("exponential"),
        archive_size: 50,
        max_iterations: 300
    }
    
    Let result be MetaOpt.multi_objective_simulated_annealing(objectives, config)
    
    Assert.IsNotNull(result)
    Assert.IsTrue(result.pareto_front.length > 0)
    Assert.IsTrue(result.iterations > 0)
    Return True

Process called "test_multi_objective_tabu_search" that takes no parameters returns Boolean:
    Note: Test multi-objective tabu search (MOTS)
    Let objectives be MetaOpt.MultiObjectiveFunction{
        objectives: [
            "lambda x: sum(xi*xi for xi in x)",
            "lambda x: sum((xi - 1)*(xi - 1) for xi in x)"
        ],
        dimension: 2,
        bounds_lower: ["-3.0", "-3.0"],
        bounds_upper: ["3.0", "3.0"]
    }
    
    Let config be MetaOpt.MOTSConfig{
        tabu_memory: MetaOpt.TabuMemory{memory_type: "recency_based", memory_size: 15, tenure: 8},
        archive_size: 40,
        max_iterations: 250
    }
    
    Let result be MetaOpt.multi_objective_tabu_search(objectives, config)
    
    Assert.IsNotNull(result)
    Assert.IsTrue(result.pareto_front.length > 0)
    Assert.IsNotNull(result.tabu_statistics)
    Return True

Note: =====================================================================
Note: COMPREHENSIVE TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_simulated_annealing_tests" that takes no parameters returns Boolean:
    Note: Run all simulated annealing tests
    Let tests be [
        "test_simulated_annealing_basic",
        "test_simulated_annealing_cooling_schedules",
        "test_simulated_annealing_neighborhood_methods",
        "test_adaptive_simulated_annealing"
    ]
    
    Let all_passed be True
    For test_name in tests:
        Try:
            Print "Running " + test_name + "..."
            Let result be Call(test_name)
            If result:
                Print "  ‚úì " + test_name + " PASSED"
            Else:
                Print "  ‚úó " + test_name + " FAILED"
                Set all_passed to False
        Catch error:
            Print "  ‚úó " + test_name + " ERROR: " + ToString(error)
            Set all_passed to False
    
    Return all_passed

Process called "run_tabu_search_tests" that takes no parameters returns Boolean:
    Note: Run all tabu search tests
    Let tests be [
        "test_tabu_search_basic",
        "test_tabu_search_memory_structures",
        "test_tabu_search_aspiration_criteria",
        "test_reactive_tabu_search"
    ]
    
    Let all_passed be True
    For test_name in tests:
        Try:
            Print "Running " + test_name + "..."
            Let result be Call(test_name)
            If result:
                Print "  ‚úì " + test_name + " PASSED"
            Else:
                Print "  ‚úó " + test_name + " FAILED"
                Set all_passed to False
        Catch error:
            Print "  ‚úó " + test_name + " ERROR: " + ToString(error)
            Set all_passed to False
    
    Return all_passed

Process called "run_ant_colony_tests" that takes no parameters returns Boolean:
    Note: Run all ant colony optimization tests
    Let tests be [
        "test_ant_colony_optimization_continuous",
        "test_ant_colony_optimization_discrete",
        "test_max_min_ant_system"
    ]
    
    Let all_passed be True
    For test_name in tests:
        Try:
            Print "Running " + test_name + "..."
            Let result be Call(test_name)
            If result:
                Print "  ‚úì " + test_name + " PASSED"
            Else:
                Print "  ‚úó " + test_name + " FAILED"
                Set all_passed to False
        Catch error:
            Print "  ‚úó " + test_name + " ERROR: " + ToString(error)
            Set all_passed to False
    
    Return all_passed

Process called "run_bee_colony_tests" that takes no parameters returns Boolean:
    Note: Run all bee colony algorithm tests
    Let tests be [
        "test_artificial_bee_colony_basic",
        "test_bee_colony_with_scouts",
        "test_bee_colony_selection_methods"
    ]
    
    Let all_passed be True
    For test_name in tests:
        Try:
            Print "Running " + test_name + "..."
            Let result be Call(test_name)
            If result:
                Print "  ‚úì " + test_name + " PASSED"
            Else:
                Print "  ‚úó " + test_name + " FAILED"
                Set all_passed to False
        Catch error:
            Print "  ‚úó " + test_name + " ERROR: " + ToString(error)
            Set all_passed to False
    
    Return all_passed

Process called "run_firefly_algorithm_tests" that takes no parameters returns Boolean:
    Note: Run all firefly algorithm tests
    Let tests be [
        "test_firefly_algorithm_basic",
        "test_firefly_light_intensity_models",
        "test_firefly_movement_strategies"
    ]
    
    Let all_passed be True
    For test_name in tests:
        Try:
            Print "Running " + test_name + "..."
            Let result be Call(test_name)
            If result:
                Print "  ‚úì " + test_name + " PASSED"
            Else:
                Print "  ‚úó " + test_name + " FAILED"
                Set all_passed to False
        Catch error:
            Print "  ‚úó " + test_name + " ERROR: " + ToString(error)
            Set all_passed to False
    
    Return all_passed

Process called "run_cuckoo_search_tests" that takes no parameters returns Boolean:
    Note: Run all cuckoo search tests
    Let tests be [
        "test_cuckoo_search_basic",
        "test_cuckoo_search_levy_flights",
        "test_improved_cuckoo_search"
    ]
    
    Let all_passed be True
    For test_name in tests:
        Try:
            Print "Running " + test_name + "..."
            Let result be Call(test_name)
            If result:
                Print "  ‚úì " + test_name + " PASSED"
            Else:
                Print "  ‚úó " + test_name + " FAILED"
                Set all_passed to False
        Catch error:
            Print "  ‚úó " + test_name + " ERROR: " + ToString(error)
            Set all_passed to False
    
    Return all_passed

Process called "run_gravitational_search_tests" that takes no parameters returns Boolean:
    Note: Run all gravitational search algorithm tests
    Let tests be [
        "test_gravitational_search_basic",
        "test_gravitational_search_mass_calculation",
        "test_gravitational_search_kbest_strategy"
    ]
    
    Let all_passed be True
    For test_name in tests:
        Try:
            Print "Running " + test_name + "..."
            Let result be Call(test_name)
            If result:
                Print "  ‚úì " + test_name + " PASSED"
            Else:
                Print "  ‚úó " + test_name + " FAILED"
                Set all_passed to False
        Catch error:
            Print "  ‚úó " + test_name + " ERROR: " + ToString(error)
            Set all_passed to False
    
    Return all_passed

Process called "run_chemical_reaction_tests" that takes no parameters returns Boolean:
    Note: Run all chemical reaction optimization tests
    Let tests be [
        "test_chemical_reaction_optimization_basic",
        "test_chemical_reaction_operators"
    ]
    
    Let all_passed be True
    For test_name in tests:
        Try:
            Print "Running " + test_name + "..."
            Let result be Call(test_name)
            If result:
                Print "  ‚úì " + test_name + " PASSED"
            Else:
                Print "  ‚úó " + test_name + " FAILED"
                Set all_passed to False
        Catch error:
            Print "  ‚úó " + test_name + " ERROR: " + ToString(error)
            Set all_passed to False
    
    Return all_passed

Process called "run_hybrid_adaptive_tests" that takes no parameters returns Boolean:
    Note: Run all hybrid and adaptive metaheuristic tests
    Let tests be [
        "test_hybrid_metaheuristic_sa_tabu",
        "test_adaptive_metaheuristic_parameters",
        "test_multi_swarm_metaheuristic"
    ]
    
    Let all_passed be True
    For test_name in tests:
        Try:
            Print "Running " + test_name + "..."
            Let result be Call(test_name)
            If result:
                Print "  ‚úì " + test_name + " PASSED"
            Else:
                Print "  ‚úó " + test_name + " FAILED"
                Set all_passed to False
        Catch error:
            Print "  ‚úó " + test_name + " ERROR: " + ToString(error)
            Set all_passed to False
    
    Return all_passed

Process called "run_multi_objective_metaheuristic_tests" that takes no parameters returns Boolean:
    Note: Run all multi-objective metaheuristic tests
    Let tests be [
        "test_multi_objective_simulated_annealing",
        "test_multi_objective_tabu_search"
    ]
    
    Let all_passed be True
    For test_name in tests:
        Try:
            Print "Running " + test_name + "..."
            Let result be Call(test_name)
            If result:
                Print "  ‚úì " + test_name + " PASSED"
            Else:
                Print "  ‚úó " + test_name + " FAILED"
                Set all_passed to False
        Catch error:
            Print "  ‚úó " + test_name + " ERROR: " + ToString(error)
            Set all_passed to False
    
    Return all_passed

Process called "run_all_tests" that takes no parameters returns Boolean:
    Note: Run all metaheuristic optimization module tests
    Print "=" * 80
    Print "METAHEURISTIC OPTIMIZATION MODULE COMPREHENSIVE TEST SUITE"
    Print "=" * 80
    Print ""
    
    Let test_categories be [
        ["Simulated Annealing", "run_simulated_annealing_tests"],
        ["Tabu Search", "run_tabu_search_tests"],
        ["Ant Colony Optimization", "run_ant_colony_tests"],
        ["Bee Colony Algorithms", "run_bee_colony_tests"],
        ["Firefly Algorithm", "run_firefly_algorithm_tests"],
        ["Cuckoo Search", "run_cuckoo_search_tests"],
        ["Gravitational Search", "run_gravitational_search_tests"],
        ["Chemical Reaction Optimization", "run_chemical_reaction_tests"],
        ["Hybrid and Adaptive Methods", "run_hybrid_adaptive_tests"],
        ["Multi-Objective Metaheuristics", "run_multi_objective_metaheuristic_tests"]
    ]
    
    Let overall_success be True
    Let passed_categories be 0
    Let total_categories be test_categories.length
    
    For category_info in test_categories:
        Let category_name be category_info[0]
        Let test_runner be category_info[1]
        
        Print "Testing " + category_name + "..."
        Print "-" * (9 + Length(category_name))
        
        Let category_result be Call(test_runner)
        If category_result:
            Print "‚úì " + category_name + ": ALL TESTS PASSED"
            Set passed_categories to passed_categories + 1
        Else:
            Print "‚úó " + category_name + ": SOME TESTS FAILED"
            Set overall_success to False
        Print ""
    
    Print "=" * 80
    Print "METAHEURISTIC OPTIMIZATION TEST SUMMARY"
    Print "=" * 80
    Print "Categories tested: " + ToString(total_categories)
    Print "Categories passed: " + ToString(passed_categories)
    Print "Categories failed: " + ToString(total_categories - passed_categories)
    
    Let success_rate be (passed_categories * 100.0) / total_categories
    Print "Success rate: " + ToString(success_rate) + "%"
    
    If overall_success:
        Print "\nüéâ ALL METAHEURISTIC OPTIMIZATION TESTS PASSED! üéâ"
        Print "The metaheuristic optimization module is ready for production use."
    Else:
        Print "\n‚ùå SOME METAHEURISTIC OPTIMIZATION TESTS FAILED ‚ùå"
        Print "Please review and fix failing tests before deployment."
    
    Print "=" * 80
    
    Return overall_success