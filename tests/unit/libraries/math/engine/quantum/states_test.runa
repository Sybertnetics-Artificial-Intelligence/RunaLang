Note:
tests/unit/libraries/math/engine/quantum/states_test.runa
Comprehensive tests for Quantum State Manipulation and Operations

This test suite provides comprehensive testing for quantum state manipulation including
state vector and density matrix representations, state preparation and initialization,
quantum state operations, entanglement measures, state tomography and reconstruction,
and decoherence and noise modeling for quantum computing applications.
:End Note

Import "math/engine/quantum/states" as QuantumStates
Import "math/core/operations" as MathOps
Import "collections" as Collections

Note: =====================================================================
Note: TEST HELPER FUNCTIONS
Note: =====================================================================

Process called "assert_float_equals" that takes actual as Float, expected as Float, tolerance as Float returns Boolean:
    Let difference be MathOps.abs(MathOps.subtract(actual.to_string(), expected.to_string(), 50).result_value).result_value
    Let diff_float be MathOps.string_to_float(difference, 50).result_value
    If diff_float <= tolerance:
        Return true
    Otherwise:
        Print("Expected: " + expected.to_string() + ", Actual: " + actual.to_string() + ", Difference: " + diff_float.to_string())
        Return false

Process called "assert_complex_equals" that takes actual as Complex, expected as Complex, tolerance as Float returns Boolean:
    Let real_diff_result be MathOps.subtract(actual.real_part, expected.real_part, 50)
    Let imag_diff_result be MathOps.subtract(actual.imaginary_part, expected.imaginary_part, 50)
    Let real_diff be MathOps.abs(real_diff_result.result_value).result_value
    Let imag_diff be MathOps.abs(imag_diff_result.result_value).result_value
    Let real_diff_float be MathOps.string_to_float(real_diff, 50).result_value
    Let imag_diff_float be MathOps.string_to_float(imag_diff, 50).result_value
    
    If real_diff_float <= tolerance && imag_diff_float <= tolerance:
        Return true
    Otherwise:
        Print("Expected: " + expected.real_part + " + " + expected.imaginary_part + "i")
        Print("Actual: " + actual.real_part + " + " + actual.imaginary_part + "i")
        Return false

Process called "assert_state_normalized" that takes state as QuantumState, tolerance as Float returns Boolean:
    Note: Check if quantum state is properly normalized (amplitude squares sum to 1)
    
    Let total_probability be "0.0"
    Let i be 0
    While i < state.state_vector.length:
        Let amplitude be state.state_vector.get(i)
        Let real_squared be MathOps.multiply(amplitude.real_part, amplitude.real_part, 50)
        Let imag_squared be MathOps.multiply(amplitude.imaginary_part, amplitude.imaginary_part, 50)
        Let magnitude_squared be MathOps.add(real_squared.result_value, imag_squared.result_value, 50)
        Set total_probability to MathOps.add(total_probability, magnitude_squared.result_value, 50).result_value
        Set i to i + 1
    
    Let total_prob_float be MathOps.string_to_float(total_probability, 50).result_value
    Return assert_float_equals(total_prob_float, 1.0, tolerance)

Note: =====================================================================
Note: STATE CREATION AND INITIALIZATION TESTS
Note: =====================================================================

Process called "test_state_creation_and_initialization" that returns [Integer, Integer]:
    Print("Testing Quantum State Creation and Initialization...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test zero state creation
    Set total to total + 1
    Let zero_state_1q be QuantumStates.zero_state(1)
    
    Note: Should create |0⟩ state
    If zero_state_1q.num_qubits == 1 &&
       zero_state_1q.state_vector.length == 2 &&
       zero_state_1q.state_vector.get(0).real_part == "1.0" &&
       zero_state_1q.state_vector.get(0).imaginary_part == "0.0" &&
       zero_state_1q.state_vector.get(1).real_part == "0.0" &&
       zero_state_1q.state_vector.get(1).imaginary_part == "0.0":
        Set passed to passed + 1
        Print("✓ Zero state creation test passed")
    Otherwise:
        Print("✗ Zero state creation test failed")
    
    Note: Test one state creation
    Set total to total + 1
    Let one_state_1q be QuantumStates.one_state(1)
    
    Note: Should create |1⟩ state
    If one_state_1q.num_qubits == 1 &&
       one_state_1q.state_vector.length == 2 &&
       one_state_1q.state_vector.get(0).real_part == "0.0" &&
       one_state_1q.state_vector.get(0).imaginary_part == "0.0" &&
       one_state_1q.state_vector.get(1).real_part == "1.0" &&
       one_state_1q.state_vector.get(1).imaginary_part == "0.0":
        Set passed to passed + 1
        Print("✓ One state creation test passed")
    Otherwise:
        Print("✗ One state creation test failed")
    
    Note: Test plus state creation
    Set total to total + 1
    Let plus_state_1q be QuantumStates.plus_state(1)
    
    If assert_state_normalized(plus_state_1q, 1e-10):
        Set passed to passed + 1
        Print("✓ Plus state normalization test passed")
    Otherwise:
        Print("✗ Plus state normalization test failed")
    
    Note: Test computational basis state creation
    Set total to total + 1
    Let basis_state be QuantumStates.computational_basis_state(2, 3)
    
    If basis_state.num_qubits == 3 &&
       basis_state.state_vector.length == 8:
        Set passed to passed + 1
        Print("✓ Computational basis state creation test passed")
    Otherwise:
        Print("✗ Computational basis state creation test failed")
    
    Note: Test random state creation
    Set total to total + 1
    Let random_state be QuantumStates.random_state(2, 12345)
    
    If assert_state_normalized(random_state, 1e-10):
        Set passed to passed + 1
        Print("✓ Random state normalization test passed")
    Otherwise:
        Print("✗ Random state normalization test failed")
    
    Print("State Creation Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Process called "test_special_quantum_states" that returns [Integer, Integer]:
    Print("Testing Special Quantum States...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test Bell state creation
    Set total to total + 1
    Let bell_phi_plus be QuantumStates.bell_state(0)
    
    If bell_phi_plus.num_qubits == 2 &&
       assert_state_normalized(bell_phi_plus, 1e-10):
        Set passed to passed + 1
        Print("✓ Bell state |Φ+⟩ test passed")
    Otherwise:
        Print("✗ Bell state |Φ+⟩ test failed")
    
    Note: Test GHZ state creation
    Set total to total + 1
    Let ghz_3q be QuantumStates.ghz_state(3)
    
    If ghz_3q.num_qubits == 3 &&
       assert_state_normalized(ghz_3q, 1e-10):
        Set passed to passed + 1
        Print("✓ GHZ state test passed")
    Otherwise:
        Print("✗ GHZ state test failed")
    
    Note: Test W state creation
    Set total to total + 1
    Let w_3q be QuantumStates.w_state(3)
    
    If w_3q.num_qubits == 3 &&
       assert_state_normalized(w_3q, 1e-10):
        Set passed to passed + 1
        Print("✓ W state test passed")
    Otherwise:
        Print("✗ W state test failed")
    
    Note: Test spin coherent state
    Set total to total + 1
    Let spin_coherent be QuantumStates.spin_coherent_state(1.0, 0.5, 2)
    
    If spin_coherent.num_qubits == 2:
        Set passed to passed + 1
        Print("✓ Spin coherent state test passed")
    Otherwise:
        Print("✗ Spin coherent state test failed")
    
    Note: Test cat state creation
    Set total to total + 1
    Let alpha be MathOps.ComplexNumber
    Set alpha.real_part to "1.0"
    Set alpha.imaginary_part to "0.0"
    Let cat_state be QuantumStates.cat_state(alpha, 0.0)
    
    If cat_state.num_qubits == 1:
        Set passed to passed + 1
        Print("✓ Cat state test passed")
    Otherwise:
        Print("✗ Cat state test failed")
    
    Print("Special States Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Process called "test_state_operations" that returns [Integer, Integer]:
    Print("Testing Quantum State Operations...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test state normalization
    Set total to total + 1
    Let unnormalized_state be QuantumStates.zero_state(1)
    Set unnormalized_state.state_vector.get(0).real_part to "2.0"
    Set unnormalized_state.is_normalized to false
    
    Let normalized_result be QuantumStates.normalize_state(unnormalized_state)
    
    If assert_state_normalized(normalized_result, 1e-10):
        Set passed to passed + 1
        Print("✓ State normalization test passed")
    Otherwise:
        Print("✗ State normalization test failed")
    
    Note: Test tensor product
    Set total to total + 1
    Let state1 be QuantumStates.zero_state(1)
    Let state2 be QuantumStates.one_state(1)
    Let tensor_result be QuantumStates.tensor_product(state1, state2)
    
    If tensor_result.num_qubits == 2 &&
       tensor_result.state_vector.length == 4:
        Set passed to passed + 1
        Print("✓ Tensor product test passed")
    Otherwise:
        Print("✗ Tensor product test failed")
    
    Note: Test state fidelity
    Set total to total + 1
    Let identical_state1 be QuantumStates.zero_state(2)
    Let identical_state2 be QuantumStates.zero_state(2)
    Let fidelity be QuantumStates.state_fidelity(identical_state1, identical_state2)
    
    If assert_float_equals(fidelity, 1.0, 1e-10):
        Set passed to passed + 1
        Print("✓ State fidelity test passed")
    Otherwise:
        Print("✗ State fidelity test failed")
    
    Print("State Operations Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Process called "test_density_matrix_operations" that returns [Integer, Integer]:
    Print("Testing Density Matrix Operations...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test state to density matrix conversion
    Set total to total + 1
    Let pure_state be QuantumStates.zero_state(2)
    Let density_matrix be QuantumStates.state_to_density_matrix(pure_state)
    
    If density_matrix.num_qubits == 2 &&
       density_matrix.matrix.length == 4:
        Set passed to passed + 1
        Print("✓ State to density matrix conversion test passed")
    Otherwise:
        Print("✗ State to density matrix conversion test failed")
    
    Note: Test maximally mixed state
    Set total to total + 1
    Let mixed_state be QuantumStates.maximally_mixed_state(2)
    
    If mixed_state.num_qubits == 2:
        Set passed to passed + 1
        Print("✓ Maximally mixed state test passed")
    Otherwise:
        Print("✗ Maximally mixed state test failed")
    
    Note: Test purity calculation
    Set total to total + 1
    Let pure_density be QuantumStates.state_to_density_matrix(QuantumStates.zero_state(1))
    Let purity_value be QuantumStates.purity(pure_density)
    
    If assert_float_equals(purity_value, 1.0, 1e-10):
        Set passed to passed + 1
        Print("✓ Purity calculation test passed")
    Otherwise:
        Print("✗ Purity calculation test failed")
    
    Note: Test von Neumann entropy
    Set total to total + 1
    Let entropy_value be QuantumStates.von_neumann_entropy(pure_density)
    
    If assert_float_equals(entropy_value, 0.0, 1e-10):
        Set passed to passed + 1
        Print("✓ von Neumann entropy test passed")
    Otherwise:
        Print("✗ von Neumann entropy test failed")
    
    Print("Density Matrix Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Process called "test_measurement_operations" that returns [Integer, Integer]:
    Print("Testing Measurement Operations...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test computational measurement
    Set total to total + 1
    Let measured_state be QuantumStates.zero_state(2)
    Let qubit_indices be Collections.List[Integer]()
    qubit_indices.add(0)
    Let measurement_result be QuantumStates.computational_measurement(measured_state, qubit_indices)
    
    If measurement_result.outcome == 0 &&
       measurement_result.probability >= 0.0 &&
       measurement_result.probability <= 1.0:
        Set passed to passed + 1
        Print("✓ Computational measurement test passed")
    Otherwise:
        Print("✗ Computational measurement test failed")
    
    Note: Test Pauli measurement
    Set total to total + 1
    Let pauli_result be QuantumStates.pauli_measurement(measured_state, "Z")
    
    If pauli_result.outcome >= -1 &&
       pauli_result.outcome <= 1:
        Set passed to passed + 1
        Print("✓ Pauli measurement test passed")
    Otherwise:
        Print("✗ Pauli measurement test failed")
    
    Print("Measurement Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Process called "test_entanglement_measures" that returns [Integer, Integer]:
    Print("Testing Entanglement Measures...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test entanglement entropy
    Set total to total + 1
    Let bell_state be QuantumStates.bell_state(0)
    Let partition be Collections.List[Integer]()
    partition.add(0)
    Let entropy be QuantumStates.entanglement_entropy(bell_state, partition)
    
    If entropy > 0.0:
        Set passed to passed + 1
        Print("✓ Entanglement entropy test passed")
    Otherwise:
        Print("✗ Entanglement entropy test failed")
    
    Note: Test concurrence calculation
    Set total to total + 1
    Let concurrence_value be QuantumStates.concurrence(bell_state)
    
    If concurrence_value >= 0.0 &&
       concurrence_value <= 1.0:
        Set passed to passed + 1
        Print("✓ Concurrence calculation test passed")
    Otherwise:
        Print("✗ Concurrence calculation test failed")
    
    Note: Test Schmidt decomposition
    Set total to total + 1
    Let schmidt_result be QuantumStates.schmidt_decomposition(bell_state, partition)
    
    If schmidt_result != Null:
        Set passed to passed + 1
        Print("✓ Schmidt decomposition test passed")
    Otherwise:
        Print("✗ Schmidt decomposition test failed")
    
    Print("Entanglement Measures Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Process called "test_noise_and_decoherence" that returns [Integer, Integer]:
    Print("Testing Noise and Decoherence Models...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test depolarizing noise
    Set total to total + 1
    Let clean_state be QuantumStates.state_to_density_matrix(QuantumStates.zero_state(1))
    Let noisy_state be QuantumStates.apply_depolarizing_noise(clean_state, 0.1)
    
    If noisy_state.num_qubits == 1:
        Set passed to passed + 1
        Print("✓ Depolarizing noise test passed")
    Otherwise:
        Print("✗ Depolarizing noise test failed")
    
    Note: Test amplitude damping
    Set total to total + 1
    Let damped_state be QuantumStates.apply_amplitude_damping(clean_state, 0.1)
    
    If damped_state.num_qubits == 1:
        Set passed to passed + 1
        Print("✓ Amplitude damping test passed")
    Otherwise:
        Print("✗ Amplitude damping test failed")
    
    Note: Test phase damping
    Set total to total + 1
    Let phase_damped_state be QuantumStates.apply_phase_damping(clean_state, 0.1)
    
    If phase_damped_state.num_qubits == 1:
        Set passed to passed + 1
        Print("✓ Phase damping test passed")
    Otherwise:
        Print("✗ Phase damping test failed")
    
    Print("Noise and Decoherence Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Process called "test_continuous_variable_states" that returns [Integer, Integer]:
    Print("Testing Continuous Variable States...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test coherent state
    Set total to total + 1
    Let alpha be MathOps.ComplexNumber
    Set alpha.real_part to "1.0"
    Set alpha.imaginary_part to "0.0"
    Let coherent_state be QuantumStates.coherent_state(alpha, 1)
    
    If coherent_state.state_vector.length > 0:
        Set passed to passed + 1
        Print("✓ Coherent state test passed")
    Otherwise:
        Print("✗ Coherent state test failed")
    
    Note: Test squeezed state
    Set total to total + 1
    Let squeezed_state be QuantumStates.squeezed_state(0.5, 0.0)
    
    If squeezed_state.state_vector.length > 0:
        Set passed to passed + 1
        Print("✓ Squeezed state test passed")
    Otherwise:
        Print("✗ Squeezed state test failed")
    
    Note: Test thermal state
    Set total to total + 1
    Let hamiltonian be Collections.List[List[Complex]]()
    Let row1 be Collections.List[Complex]()
    Let elem1 be MathOps.ComplexNumber
    Set elem1.real_part to "1.0"
    Set elem1.imaginary_part to "0.0"
    row1.add(elem1)
    Let elem2 be MathOps.ComplexNumber
    Set elem2.real_part to "0.0"
    Set elem2.imaginary_part to "0.0"
    row1.add(elem2)
    hamiltonian.add(row1)
    
    Let row2 be Collections.List[Complex]()
    Let elem3 be MathOps.ComplexNumber
    Set elem3.real_part to "0.0"
    Set elem3.imaginary_part to "0.0"
    row2.add(elem3)
    Let elem4 be MathOps.ComplexNumber
    Set elem4.real_part to "-1.0"
    Set elem4.imaginary_part to "0.0"
    row2.add(elem4)
    hamiltonian.add(row2)
    
    Let thermal_state be QuantumStates.thermal_state(hamiltonian, 1.0)
    
    If thermal_state.matrix.length > 0:
        Set passed to passed + 1
        Print("✓ Thermal state test passed")
    Otherwise:
        Print("✗ Thermal state test failed")
    
    Print("Continuous Variable Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Process called "test_quantum_information_theory" that returns [Integer, Integer]:
    Print("Testing Quantum Information Theory Functions...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test state overlap
    Set total to total + 1
    Let state1 be QuantumStates.zero_state(1)
    Let state2 be QuantumStates.zero_state(1)
    Let overlap be QuantumStates.state_overlap(state1, state2)
    
    If overlap.real_part == "1.0" &&
       overlap.imaginary_part == "0.0":
        Set passed to passed + 1
        Print("✓ State overlap test passed")
    Otherwise:
        Print("✗ State overlap test failed")
    
    Note: Test expectation value
    Set total to total + 1
    Let pauli_z be Collections.List[List[Complex]]()
    Let z_row1 be Collections.List[Complex]()
    Let z11 be MathOps.ComplexNumber
    Set z11.real_part to "1.0"
    Set z11.imaginary_part to "0.0"
    z_row1.add(z11)
    Let z12 be MathOps.ComplexNumber
    Set z12.real_part to "0.0"
    Set z12.imaginary_part to "0.0"
    z_row1.add(z12)
    pauli_z.add(z_row1)
    
    Let z_row2 be Collections.List[Complex]()
    Let z21 be MathOps.ComplexNumber
    Set z21.real_part to "0.0"
    Set z21.imaginary_part to "0.0"
    z_row2.add(z21)
    Let z22 be MathOps.ComplexNumber
    Set z22.real_part to "-1.0"
    Set z22.imaginary_part to "0.0"
    z_row2.add(z22)
    pauli_z.add(z_row2)
    
    Let expectation be QuantumStates.expectation_value(QuantumStates.zero_state(1), pauli_z)
    
    If expectation.real_part == "1.0":
        Set passed to passed + 1
        Print("✓ Expectation value test passed")
    Otherwise:
        Print("✗ Expectation value test failed")
    
    Note: Test variance calculation
    Set total to total + 1
    Let variance_value be QuantumStates.variance(QuantumStates.zero_state(1), pauli_z)
    
    If variance_value >= 0.0:
        Set passed to passed + 1
        Print("✓ Variance calculation test passed")
    Otherwise:
        Print("✗ Variance calculation test failed")
    
    Print("Quantum Information Theory Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Process called "test_bloch_sphere_representation" that returns [Integer, Integer]:
    Print("Testing Bloch Sphere Representation...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test state to Bloch vector conversion
    Set total to total + 1
    Let zero_state be QuantumStates.zero_state(1)
    Let bloch_vector be QuantumStates.state_to_bloch_vector(zero_state)
    
    If bloch_vector.length == 3:
        Set passed to passed + 1
        Print("✓ State to Bloch vector test passed")
    Otherwise:
        Print("✗ State to Bloch vector test failed")
    
    Note: Test Bloch vector to state conversion
    Set total to total + 1
    Let test_bloch be Collections.List[Float]()
    test_bloch.add(0.0)
    test_bloch.add(0.0)
    test_bloch.add(1.0)
    Let reconstructed_state be QuantumStates.bloch_vector_to_state(test_bloch)
    
    If reconstructed_state.state_vector.length == 2:
        Set passed to passed + 1
        Print("✓ Bloch vector to state test passed")
    Otherwise:
        Print("✗ Bloch vector to state test failed")
    
    Print("Bloch Sphere Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: MAIN TEST RUNNER
Note: =====================================================================

Process called "run_all_quantum_states_tests" that returns [Integer, Integer]:
    Print("=".repeat(70))
    Print("QUANTUM STATES COMPREHENSIVE TEST SUITE")
    Print("=".repeat(70))
    
    Let total_passed be 0
    Let total_tests be 0
    
    Note: Run all test suites
    Let [p1, t1] be test_state_creation_and_initialization()
    Set total_passed to total_passed + p1
    Set total_tests to total_tests + t1
    
    Let [p2, t2] be test_special_quantum_states()
    Set total_passed to total_passed + p2
    Set total_tests to total_tests + t2
    
    Let [p3, t3] be test_state_operations()
    Set total_passed to total_passed + p3
    Set total_tests to total_tests + t3
    
    Let [p4, t4] be test_density_matrix_operations()
    Set total_passed to total_passed + p4
    Set total_tests to total_tests + t4
    
    Let [p5, t5] be test_measurement_operations()
    Set total_passed to total_passed + p5
    Set total_tests to total_tests + t5
    
    Let [p6, t6] be test_entanglement_measures()
    Set total_passed to total_passed + p6
    Set total_tests to total_tests + t6
    
    Let [p7, t7] be test_noise_and_decoherence()
    Set total_passed to total_passed + p7
    Set total_tests to total_tests + t7
    
    Let [p8, t8] be test_continuous_variable_states()
    Set total_passed to total_passed + p8
    Set total_tests to total_tests + t8
    
    Let [p9, t9] be test_quantum_information_theory()
    Set total_passed to total_passed + p9
    Set total_tests to total_tests + t9
    
    Let [p10, t10] be test_bloch_sphere_representation()
    Set total_passed to total_passed + p10
    Set total_tests to total_tests + t10
    
    Print("=".repeat(70))
    Print("QUANTUM STATES TEST SUMMARY")
    Print("Total Tests: " + total_tests.to_string())
    Print("Passed: " + total_passed.to_string())
    Print("Failed: " + (total_tests - total_passed).to_string())
    
    If total_passed == total_tests:
        Print("🎉 ALL TESTS PASSED! 🎉")
    Otherwise:
        Print("❌ Some tests failed. Please review output above.")
    
    Print("=".repeat(70))
    
    Return [total_passed, total_tests]