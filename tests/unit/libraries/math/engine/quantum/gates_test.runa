Note:
tests/unit/libraries/math/engine/quantum/gates_test.runa
Comprehensive tests for Quantum Gate Operations and Quantum Logic

This test suite provides comprehensive testing for quantum gate operations including
single-qubit gates, two-qubit gates, multi-qubit gates, parameterized gates,
gate composition and decomposition, and quantum gate optimization and synthesis
for quantum computing simulations and quantum logic applications.
:End Note

Import "math/engine/quantum/gates" as QuantumGates
Import "math/core/operations" as MathOps

Note: =====================================================================
Note: TEST HELPER FUNCTIONS
Note: =====================================================================

Process called "assert_float_equals" that takes actual as Float and expected as Float and tolerance as Float returns Boolean:
    Let difference be MathOps.absolute_value(actual - expected)
    If difference <= tolerance:
        Return true
    Otherwise:
        Print("Expected: " + expected.to_string() + ", Actual: " + actual.to_string() + ", Difference: " + difference.to_string())
        Return false

Process called "assert_complex_equals" that takes actual as QuantumGates.Complex and expected as QuantumGates.Complex and tolerance as Float returns Boolean:
    Let real_diff be MathOps.absolute_value(actual.real - expected.real)
    Let imag_diff be MathOps.absolute_value(actual.imag - expected.imag)
    
    If real_diff <= tolerance and imag_diff <= tolerance:
        Return true
    Otherwise:
        Print("Expected: " + expected.real.to_string() + " + " + expected.imag.to_string() + "i")
        Print("Actual: " + actual.real.to_string() + " + " + actual.imag.to_string() + "i")
        Return false

Process called "assert_matrix_unitary" that takes matrix as List[List[QuantumGates.Complex]] and tolerance as Float returns Boolean:
    Note: Check if matrix is unitary (U† U = I)
    
    Let size be matrix.size()
    If size == 0:
        Return false
    
    Note: Compute U† U
    Let product be List[List[QuantumGates.Complex]]()
    For i from 0 to size - 1:
        Let row be List[QuantumGates.Complex]()
        For j from 0 to size - 1:
            Let sum_real be 0.0
            Let sum_imag be 0.0
            
            For k from 0 to size - 1:
                Note: U†[i,k] * U[k,j] = conj(U[k,i]) * U[k,j]
                Let u_conj_real be matrix[k][i].real
                Let u_conj_imag be -matrix[k][i].imag
                Let u_real be matrix[k][j].real
                Let u_imag be matrix[k][j].imag
                
                sum_real = sum_real + u_conj_real * u_real - u_conj_imag * u_imag
                sum_imag = sum_imag + u_conj_real * u_imag + u_conj_imag * u_real
            
            Let element be QuantumGates.Complex
            element.real = sum_real
            element.imag = sum_imag
            row.add(element)
        product.add(row)
    
    Note: Check if result is identity matrix
    For i from 0 to size - 1:
        For j from 0 to size - 1:
            If i == j:
                Note: Diagonal element should be 1
                If not assert_complex_equals(product[i][j], QuantumGates.Complex(1.0, 0.0), tolerance):
                    Return false
            Otherwise:
                Note: Off-diagonal element should be 0
                If not assert_complex_equals(product[i][j], QuantumGates.Complex(0.0, 0.0), tolerance):
                    Return false
    
    Return true

Process called "create_test_state_vector" that returns List[QuantumGates.Complex]:
    Note: Create test state vector |0⟩
    
    Let state_vector be List[QuantumGates.Complex]()
    
    Let amp_0 be QuantumGates.Complex
    amp_0.real = 1.0
    amp_0.imag = 0.0
    state_vector.add(amp_0)
    
    Let amp_1 be QuantumGates.Complex
    amp_1.real = 0.0
    amp_1.imag = 0.0
    state_vector.add(amp_1)
    
    Return state_vector

Note: =====================================================================
Note: SINGLE-QUBIT GATE TESTS
Note: =====================================================================

Process called "test_single_qubit_gates" that returns [Integer, Integer]:
    Print("Testing Single-Qubit Gates...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test identity gate
    total = total + 1
    Let identity_gate be QuantumGates.identity_gate()
    
    Note: Identity matrix should be [[1,0],[0,1]]
    If identity_gate.matrix.size() == 2 and identity_gate.matrix[0].size() == 2:
        If assert_complex_equals(identity_gate.matrix[0][0], QuantumGates.Complex(1.0, 0.0), 0.0001) and
           assert_complex_equals(identity_gate.matrix[0][1], QuantumGates.Complex(0.0, 0.0), 0.0001) and
           assert_complex_equals(identity_gate.matrix[1][0], QuantumGates.Complex(0.0, 0.0), 0.0001) and
           assert_complex_equals(identity_gate.matrix[1][1], QuantumGates.Complex(1.0, 0.0), 0.0001):
            passed = passed + 1
    
    Note: Test Pauli-X gate
    total = total + 1
    Let pauli_x_gate be QuantumGates.pauli_x_gate()
    
    Note: Pauli-X matrix should be [[0,1],[1,0]]
    If assert_complex_equals(pauli_x_gate.matrix[0][0], QuantumGates.Complex(0.0, 0.0), 0.0001) and
       assert_complex_equals(pauli_x_gate.matrix[0][1], QuantumGates.Complex(1.0, 0.0), 0.0001) and
       assert_complex_equals(pauli_x_gate.matrix[1][0], QuantumGates.Complex(1.0, 0.0), 0.0001) and
       assert_complex_equals(pauli_x_gate.matrix[1][1], QuantumGates.Complex(0.0, 0.0), 0.0001):
        passed = passed + 1
    
    Note: Test Pauli-Y gate
    total = total + 1
    Let pauli_y_gate be QuantumGates.pauli_y_gate()
    
    Note: Pauli-Y matrix should be [[0,-i],[i,0]]
    If assert_complex_equals(pauli_y_gate.matrix[0][0], QuantumGates.Complex(0.0, 0.0), 0.0001) and
       assert_complex_equals(pauli_y_gate.matrix[0][1], QuantumGates.Complex(0.0, -1.0), 0.0001) and
       assert_complex_equals(pauli_y_gate.matrix[1][0], QuantumGates.Complex(0.0, 1.0), 0.0001) and
       assert_complex_equals(pauli_y_gate.matrix[1][1], QuantumGates.Complex(0.0, 0.0), 0.0001):
        passed = passed + 1
    
    Note: Test Pauli-Z gate
    total = total + 1
    Let pauli_z_gate be QuantumGates.pauli_z_gate()
    
    Note: Pauli-Z matrix should be [[1,0],[0,-1]]
    If assert_complex_equals(pauli_z_gate.matrix[0][0], QuantumGates.Complex(1.0, 0.0), 0.0001) and
       assert_complex_equals(pauli_z_gate.matrix[0][1], QuantumGates.Complex(0.0, 0.0), 0.0001) and
       assert_complex_equals(pauli_z_gate.matrix[1][0], QuantumGates.Complex(0.0, 0.0), 0.0001) and
       assert_complex_equals(pauli_z_gate.matrix[1][1], QuantumGates.Complex(-1.0, 0.0), 0.0001):
        passed = passed + 1
    
    Note: Test Hadamard gate
    total = total + 1
    Let hadamard_gate be QuantumGates.hadamard_gate()
    
    Note: Hadamard matrix should be [[1,1],[1,-1]]/√2
    Let inv_sqrt2 be 1.0 / MathOps.square_root(2.0)
    If assert_complex_equals(hadamard_gate.matrix[0][0], QuantumGates.Complex(inv_sqrt2, 0.0), 0.0001) and
       assert_complex_equals(hadamard_gate.matrix[0][1], QuantumGates.Complex(inv_sqrt2, 0.0), 0.0001) and
       assert_complex_equals(hadamard_gate.matrix[1][0], QuantumGates.Complex(inv_sqrt2, 0.0), 0.0001) and
       assert_complex_equals(hadamard_gate.matrix[1][1], QuantumGates.Complex(-inv_sqrt2, 0.0), 0.0001):
        passed = passed + 1
    
    Note: Test gate unitarity
    total = total + 1
    If assert_matrix_unitary(pauli_x_gate.matrix, 0.0001) and
       assert_matrix_unitary(hadamard_gate.matrix, 0.0001):
        passed = passed + 1
    
    Print("Single-Qubit Gates Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: ROTATION GATE TESTS
Note: =====================================================================

Process called "test_rotation_gates" that returns [Integer, Integer]:
    Print("Testing Rotation Gates...")
    
    Let passed be 0
    Let total = 0
    
    Note: Test rotation-X gate
    total = total + 1
    Let angle be MathOps.pi / 4.0  Note: 45 degrees
    Let rx_gate be QuantumGates.rotation_x_gate(angle)
    
    Note: Rx(θ) = [[cos(θ/2), -i*sin(θ/2)], [-i*sin(θ/2), cos(θ/2)]]
    Let half_angle be angle / 2.0
    Let cos_half be MathOps.cosine(half_angle)
    Let sin_half be MathOps.sine(half_angle)
    
    If assert_complex_equals(rx_gate.matrix[0][0], QuantumGates.Complex(cos_half, 0.0), 0.0001) and
       assert_complex_equals(rx_gate.matrix[0][1], QuantumGates.Complex(0.0, -sin_half), 0.0001) and
       assert_complex_equals(rx_gate.matrix[1][0], QuantumGates.Complex(0.0, -sin_half), 0.0001) and
       assert_complex_equals(rx_gate.matrix[1][1], QuantumGates.Complex(cos_half, 0.0), 0.0001):
        passed = passed + 1
    
    Note: Test rotation-Y gate
    total = total + 1
    Let ry_gate be QuantumGates.rotation_y_gate(angle)
    
    Note: Ry(θ) = [[cos(θ/2), -sin(θ/2)], [sin(θ/2), cos(θ/2)]]
    If assert_complex_equals(ry_gate.matrix[0][0], QuantumGates.Complex(cos_half, 0.0), 0.0001) and
       assert_complex_equals(ry_gate.matrix[0][1], QuantumGates.Complex(-sin_half, 0.0), 0.0001) and
       assert_complex_equals(ry_gate.matrix[1][0], QuantumGates.Complex(sin_half, 0.0), 0.0001) and
       assert_complex_equals(ry_gate.matrix[1][1], QuantumGates.Complex(cos_half, 0.0), 0.0001):
        passed = passed + 1
    
    Note: Test rotation-Z gate
    total = total + 1
    Let rz_gate be QuantumGates.rotation_z_gate(angle)
    
    Note: Rz(θ) = [[e^(-iθ/2), 0], [0, e^(iθ/2)]]
    Let exp_neg_half_real be MathOps.cosine(-half_angle)
    Let exp_neg_half_imag be MathOps.sine(-half_angle)
    Let exp_pos_half_real be MathOps.cosine(half_angle)
    Let exp_pos_half_imag be MathOps.sine(half_angle)
    
    If assert_complex_equals(rz_gate.matrix[0][0], QuantumGates.Complex(exp_neg_half_real, exp_neg_half_imag), 0.0001) and
       assert_complex_equals(rz_gate.matrix[0][1], QuantumGates.Complex(0.0, 0.0), 0.0001) and
       assert_complex_equals(rz_gate.matrix[1][0], QuantumGates.Complex(0.0, 0.0), 0.0001) and
       assert_complex_equals(rz_gate.matrix[1][1], QuantumGates.Complex(exp_pos_half_real, exp_pos_half_imag), 0.0001):
        passed = passed + 1
    
    Note: Test phase gate (special case of Rz)
    total = total + 1
    Let phase_gate be QuantumGates.phase_gate(MathOps.pi / 2.0)  Note: S gate
    
    Note: Phase gate should be [[1, 0], [0, i]]
    If assert_complex_equals(phase_gate.matrix[0][0], QuantumGates.Complex(1.0, 0.0), 0.0001) and
       assert_complex_equals(phase_gate.matrix[0][1], QuantumGates.Complex(0.0, 0.0), 0.0001) and
       assert_complex_equals(phase_gate.matrix[1][0], QuantumGates.Complex(0.0, 0.0), 0.0001) and
       assert_complex_equals(phase_gate.matrix[1][1], QuantumGates.Complex(0.0, 1.0), 0.0001):
        passed = passed + 1
    
    Note: Test T gate (π/4 phase)
    total = total + 1
    Let t_gate be QuantumGates.t_gate()
    
    Note: T gate should be [[1, 0], [0, e^(iπ/4)]]
    Let exp_pi4_real be MathOps.cosine(MathOps.pi / 4.0)
    Let exp_pi4_imag be MathOps.sine(MathOps.pi / 4.0)
    
    If assert_complex_equals(t_gate.matrix[0][0], QuantumGates.Complex(1.0, 0.0), 0.0001) and
       assert_complex_equals(t_gate.matrix[1][1], QuantumGates.Complex(exp_pi4_real, exp_pi4_imag), 0.0001):
        passed = passed + 1
    
    Note: Test rotation gate unitarity
    total = total + 1
    If assert_matrix_unitary(rx_gate.matrix, 0.0001) and
       assert_matrix_unitary(ry_gate.matrix, 0.0001) and
       assert_matrix_unitary(rz_gate.matrix, 0.0001):
        passed = passed + 1
    
    Print("Rotation Gates Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: TWO-QUBIT GATE TESTS
Note: =====================================================================

Process called "test_two_qubit_gates" that returns [Integer, Integer]:
    Print("Testing Two-Qubit Gates...")
    
    Let passed be 0
    Let total = 0
    
    Note: Test CNOT gate
    total = total + 1
    Let cnot_gate be QuantumGates.cnot_gate()
    
    Note: CNOT matrix should be 4x4: [[1,0,0,0],[0,1,0,0],[0,0,0,1],[0,0,1,0]]
    If cnot_gate.matrix.size() == 4 and cnot_gate.matrix[0].size() == 4:
        Let cnot_correct be true
        
        Note: Check diagonal elements
        If not assert_complex_equals(cnot_gate.matrix[0][0], QuantumGates.Complex(1.0, 0.0), 0.0001) or
           not assert_complex_equals(cnot_gate.matrix[1][1], QuantumGates.Complex(1.0, 0.0), 0.0001) or
           not assert_complex_equals(cnot_gate.matrix[2][3], QuantumGates.Complex(1.0, 0.0), 0.0001) or
           not assert_complex_equals(cnot_gate.matrix[3][2], QuantumGates.Complex(1.0, 0.0), 0.0001):
            cnot_correct = false
        
        Note: Check specific zero elements
        If not assert_complex_equals(cnot_gate.matrix[0][1], QuantumGates.Complex(0.0, 0.0), 0.0001) or
           not assert_complex_equals(cnot_gate.matrix[2][2], QuantumGates.Complex(0.0, 0.0), 0.0001):
            cnot_correct = false
        
        If cnot_correct:
            passed = passed + 1
    
    Note: Test CZ gate (controlled-Z)
    total = total + 1
    Let cz_gate be QuantumGates.cz_gate()
    
    Note: CZ matrix should be diag([1,1,1,-1])
    If assert_complex_equals(cz_gate.matrix[0][0], QuantumGates.Complex(1.0, 0.0), 0.0001) and
       assert_complex_equals(cz_gate.matrix[1][1], QuantumGates.Complex(1.0, 0.0), 0.0001) and
       assert_complex_equals(cz_gate.matrix[2][2], QuantumGates.Complex(1.0, 0.0), 0.0001) and
       assert_complex_equals(cz_gate.matrix[3][3], QuantumGates.Complex(-1.0, 0.0), 0.0001):
        passed = passed + 1
    
    Note: Test SWAP gate
    total = total + 1
    Let swap_gate be QuantumGates.swap_gate()
    
    Note: SWAP matrix should be [[1,0,0,0],[0,0,1,0],[0,1,0,0],[0,0,0,1]]
    If assert_complex_equals(swap_gate.matrix[0][0], QuantumGates.Complex(1.0, 0.0), 0.0001) and
       assert_complex_equals(swap_gate.matrix[1][2], QuantumGates.Complex(1.0, 0.0), 0.0001) and
       assert_complex_equals(swap_gate.matrix[2][1], QuantumGates.Complex(1.0, 0.0), 0.0001) and
       assert_complex_equals(swap_gate.matrix[3][3], QuantumGates.Complex(1.0, 0.0), 0.0001):
        passed = passed + 1
    
    Note: Test iSWAP gate
    total = total + 1
    Let iswap_gate be QuantumGates.iswap_gate()
    
    Note: iSWAP matrix should have i factors in swap elements
    If assert_complex_equals(iswap_gate.matrix[0][0], QuantumGates.Complex(1.0, 0.0), 0.0001) and
       assert_complex_equals(iswap_gate.matrix[1][2], QuantumGates.Complex(0.0, 1.0), 0.0001) and
       assert_complex_equals(iswap_gate.matrix[2][1], QuantumGates.Complex(0.0, 1.0), 0.0001) and
       assert_complex_equals(iswap_gate.matrix[3][3], QuantumGates.Complex(1.0, 0.0), 0.0001):
        passed = passed + 1
    
    Note: Test controlled rotation gates
    total = total + 1
    Let crx_gate be QuantumGates.controlled_rotation_x(MathOps.pi / 2.0)
    
    Note: Controlled-Rx should be block diagonal with I and Rx
    If crx_gate.matrix.size() == 4:
        passed = passed + 1
    
    Note: Test two-qubit gate unitarity
    total = total + 1
    If assert_matrix_unitary(cnot_gate.matrix, 0.0001) and
       assert_matrix_unitary(cz_gate.matrix, 0.0001) and
       assert_matrix_unitary(swap_gate.matrix, 0.0001):
        passed = passed + 1
    
    Print("Two-Qubit Gates Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: MULTI-QUBIT GATE TESTS
Note: =====================================================================

Process called "test_multi_qubit_gates" that returns [Integer, Integer]:
    Print("Testing Multi-Qubit Gates...")
    
    Let passed be 0
    Let total = 0
    
    Note: Test Toffoli gate (CCX)
    total = total + 1
    Let toffoli_gate be QuantumGates.toffoli_gate()
    
    Note: Toffoli gate should be 8x8 matrix
    If toffoli_gate.matrix.size() == 8 and toffoli_gate.matrix[0].size() == 8:
        Note: Check that it flips last bit only when first two bits are 1
        If assert_complex_equals(toffoli_gate.matrix[6][7], QuantumGates.Complex(1.0, 0.0), 0.0001) and
           assert_complex_equals(toffoli_gate.matrix[7][6], QuantumGates.Complex(1.0, 0.0), 0.0001):
            passed = passed + 1
    
    Note: Test Fredkin gate (CSWAP)
    total = total + 1
    Let fredkin_gate be QuantumGates.fredkin_gate()
    
    Note: Fredkin gate should be 8x8 matrix
    If fredkin_gate.matrix.size() == 8 and fredkin_gate.matrix[0].size() == 8:
        Note: Check controlled swap functionality
        If assert_complex_equals(fredkin_gate.matrix[0][0], QuantumGates.Complex(1.0, 0.0), 0.0001):
            passed = passed + 1
    
    Note: Test multi-controlled X gate
    total = total + 1
    Let control_qubits be List[Integer]([0, 1])
    Let mcx_gate be QuantumGates.multi_controlled_x(control_qubits, 2)
    
    Note: Multi-controlled X should be same as Toffoli for 2 controls
    If mcx_gate.matrix.size() == 8:
        passed = passed + 1
    
    Note: Test multi-controlled Z gate
    total = total + 1
    Let mcz_gate be QuantumGates.multi_controlled_z(control_qubits, 2)
    
    Note: Multi-controlled Z should apply phase only when all controls are 1
    If mcz_gate.matrix.size() == 8:
        passed = passed + 1
    
    Note: Test quantum Fourier transform gate
    total = total + 1
    Let qft_gate be QuantumGates.quantum_fourier_transform(3)  Note: 3-qubit QFT
    
    Note: QFT gate should be 8x8 unitary matrix
    If qft_gate.matrix.size() == 8 and assert_matrix_unitary(qft_gate.matrix, 0.001):
        passed = passed + 1
    
    Note: Test custom controlled gate
    total = total + 1
    Let base_gate be QuantumGates.pauli_y_gate()
    Let controlled_y = QuantumGates.controlled_gate(base_gate)
    
    Note: Controlled-Y should be 4x4 matrix
    If controlled_y.matrix.size() == 4:
        passed = passed + 1
    
    Print("Multi-Qubit Gates Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: GATE COMPOSITION TESTS
Note: =====================================================================

Process called "test_gate_composition" that returns [Integer, Integer]:
    Print("Testing Gate Composition...")
    
    Let passed be 0
    Let total = 0
    
    Note: Test gate multiplication/composition
    total = total + 1
    Let gate1 be QuantumGates.pauli_x_gate()
    Let gate2 be QuantumGates.pauli_x_gate()
    Let composed_gate be QuantumGates.compose_gates(gate1, gate2)
    
    Note: X * X = I
    Let identity_expected be QuantumGates.identity_gate()
    If assert_complex_equals(composed_gate.matrix[0][0], identity_expected.matrix[0][0], 0.0001) and
       assert_complex_equals(composed_gate.matrix[1][1], identity_expected.matrix[1][1], 0.0001):
        passed = passed + 1
    
    Note: Test gate sequence composition
    total = total + 1
    Let gate_sequence be QuantumGates.GateSequence
    gate_sequence.gates = List[QuantumGates.QuantumGate]()
    gate_sequence.gates.add(QuantumGates.hadamard_gate())
    gate_sequence.gates.add(QuantumGates.pauli_z_gate())
    gate_sequence.gates.add(QuantumGates.hadamard_gate())
    
    Let sequence_result be QuantumGates.compose_gate_sequence(gate_sequence)
    
    Note: HZH = X (up to global phase)
    If sequence_result.matrix.size() == 2:
        passed = passed + 1
    
    Note: Test gate tensor product
    total = total + 1
    Let gate_a be QuantumGates.pauli_x_gate()
    Let gate_b be QuantumGates.pauli_z_gate()
    Let tensor_product be QuantumGates.tensor_product_gates(gate_a, gate_b)
    
    Note: X ⊗ Z should be 4x4 matrix
    If tensor_product.matrix.size() == 4 and tensor_product.matrix[0].size() == 4:
        passed = passed + 1
    
    Note: Test gate power operations
    total = total + 1
    Let rotation_gate be QuantumGates.rotation_z_gate(MathOps.pi / 4.0)
    Let squared_gate be QuantumGates.gate_power(rotation_gate, 2)
    
    Note: (Rz(π/4))^2 = Rz(π/2) = Z
    If squared_gate.matrix.size() == 2:
        passed = passed + 1
    
    Note: Test gate inverse
    total = total + 1
    Let hadamard be QuantumGates.hadamard_gate()
    Let hadamard_inverse be QuantumGates.gate_inverse(hadamard)
    Let should_be_identity be QuantumGates.compose_gates(hadamard, hadamard_inverse)
    
    Note: H * H† = I (Hadamard is self-inverse)
    If assert_complex_equals(should_be_identity.matrix[0][0], QuantumGates.Complex(1.0, 0.0), 0.001):
        passed = passed + 1
    
    Note: Test commutator calculation
    total = total + 1
    Let gate_x be QuantumGates.pauli_x_gate()
    Let gate_z be QuantumGates.pauli_z_gate()
    Let commutator be QuantumGates.calculate_commutator(gate_x, gate_z)
    
    Note: [X, Z] = 2iY
    If commutator.matrix.size() == 2:
        passed = passed + 1
    
    Print("Gate Composition Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: GATE DECOMPOSITION TESTS
Note: =====================================================================

Process called "test_gate_decomposition" that returns [Integer, Integer]:
    Print("Testing Gate Decomposition...")
    
    Let passed be 0
    Let total = 0
    
    Note: Test single-qubit gate decomposition to Euler angles
    total = total + 1
    Let arbitrary_gate be QuantumGates.rotation_y_gate(MathOps.pi / 3.0)
    Let euler_decomposition be QuantumGates.decompose_single_qubit_to_euler(arbitrary_gate)
    
    Note: Should return three rotation angles
    If euler_decomposition.angles.size() == 3:
        passed = passed + 1
    
    Note: Test two-qubit gate decomposition to CNOTs and single-qubit gates
    total = total + 1
    Let arbitrary_two_qubit be QuantumGates.cz_gate()
    Let cnot_decomposition be QuantumGates.decompose_two_qubit_to_cnot(arbitrary_two_qubit)
    
    Note: Should provide decomposition with at most 3 CNOTs
    If cnot_decomposition.cnot_count <= 3:
        passed = passed + 1
    
    Note: Test controlled gate decomposition
    total = total + 1
    Let controlled_rotation be QuantumGates.controlled_rotation_y(MathOps.pi / 6.0)
    Let controlled_decomposition be QuantumGates.decompose_controlled_gate(controlled_rotation)
    
    Note: Should decompose into single-qubit gates and CNOTs
    If controlled_decomposition.single_qubit_gates.size() > 0:
        passed = passed + 1
    
    Note: Test Toffoli gate decomposition
    total = total + 1
    Let toffoli be QuantumGates.toffoli_gate()
    Let toffoli_decomposition be QuantumGates.decompose_toffoli_to_cnot(toffoli)
    
    Note: Toffoli can be decomposed into 6 CNOTs and single-qubit gates
    If toffoli_decomposition.cnot_count <= 8:  Note: Allow some overhead
        passed = passed + 1
    
    Note: Test universality check
    total = total + 1
    Let gate_set be List[QuantumGates.QuantumGate]()
    gate_set.add(QuantumGates.hadamard_gate())
    gate_set.add(QuantumGates.t_gate())
    gate_set.add(QuantumGates.cnot_gate())
    
    Let is_universal be QuantumGates.check_gate_set_universality(gate_set)
    
    Note: {H, T, CNOT} is known universal set
    If is_universal:
        passed = passed + 1
    
    Note: Test Clifford group check
    total = total + 1
    Let clifford_gate be QuantumGates.pauli_x_gate()
    Let is_clifford be QuantumGates.is_clifford_gate(clifford_gate)
    
    Note: Pauli-X is in Clifford group
    If is_clifford:
        passed = passed + 1
    
    Print("Gate Decomposition Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: GATE OPTIMIZATION TESTS
Note: =====================================================================

Process called "test_gate_optimization" that returns [Integer, Integer]:
    Print("Testing Gate Optimization...")
    
    Let passed be 0
    Let total = 0
    
    Note: Test gate cancellation detection
    total = total + 1
    Let gate1 be QuantumGates.pauli_x_gate()
    Let gate2 be QuantumGates.pauli_x_gate()
    
    Let can_cancel be QuantumGates.can_cancel_gates(gate1, gate2)
    
    Note: X and X should cancel
    If can_cancel:
        passed = passed + 1
    
    Note: Test gate commutation detection
    total = total + 1
    Let gate_z be QuantumGates.pauli_z_gate()
    Let gate_i be QuantumGates.identity_gate()
    
    Let can_commute be QuantumGates.can_commute_gates(gate_z, gate_i, [0], [0])
    
    Note: Z and I commute on same qubit
    If can_commute:
        passed = passed + 1
    
    Note: Test rotation gate merging
    total = total + 1
    Let rx1 be QuantumGates.rotation_x_gate(MathOps.pi / 4.0)
    Let rx2 be QuantumGates.rotation_x_gate(MathOps.pi / 4.0)
    Let merged_rotation be QuantumGates.merge_rotation_gates(rx1, rx2)
    
    Note: Rx(π/4) + Rx(π/4) = Rx(π/2)
    If assert_float_equals(merged_rotation.parameters[0], MathOps.pi / 2.0, 0.0001):
        passed = passed + 1
    
    Note: Test gate synthesis for arbitrary unitary
    total = total + 1
    Let target_unitary be QuantumGates.pauli_y_gate().matrix
    Let synthesized_sequence be QuantumGates.synthesize_unitary(target_unitary)
    
    Note: Should find gate sequence that approximates target
    If synthesized_sequence.gates.size() > 0:
        passed = passed + 1
    
    Note: Test circuit depth optimization
    total = total + 1
    Let initial_sequence be QuantumGates.GateSequence
    initial_sequence.gates = List[QuantumGates.QuantumGate]()
    initial_sequence.gates.add(QuantumGates.hadamard_gate())
    initial_sequence.gates.add(QuantumGates.pauli_z_gate())
    initial_sequence.gates.add(QuantumGates.hadamard_gate())
    initial_sequence.depth = 3
    
    Let optimized_sequence be QuantumGates.optimize_gate_sequence(initial_sequence)
    
    Note: HZH = X, so should reduce to single gate
    If optimized_sequence.depth <= initial_sequence.depth:
        passed = passed + 1
    
    Note: Test T-count optimization
    total = total + 1
    Let t_gate be QuantumGates.t_gate()
    Let t_sequence be QuantumGates.GateSequence
    t_sequence.gates = List[QuantumGates.QuantumGate]()
    For i from 0 to 7:  Note: 8 T gates = Identity
        t_sequence.gates.add(t_gate)
    
    Let t_optimized be QuantumGates.optimize_t_count(t_sequence)
    
    Note: 8 T gates should optimize to identity (0 T gates)
    If t_optimized.t_count == 0:
        passed = passed + 1
    
    Print("Gate Optimization Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: PERFORMANCE BENCHMARKING TESTS
Note: =====================================================================

Process called "test_quantum_gates_performance" that returns [Integer, Integer]:
    Print("Testing Quantum Gates Performance...")
    
    Let passed be 0
    Let total = 0
    
    Note: Test single-qubit gate creation performance
    total = total + 1
    Let start_time be QuantumGates.get_current_time()
    
    For i from 0 to 999:  Note: Create 1000 gates
        Let temp_gate be QuantumGates.hadamard_gate()
    
    Let gate_creation_time be QuantumGates.get_current_time() - start_time
    
    Note: Gate creation should be fast
    If gate_creation_time < 1.0:  Note: Less than 1 second
        passed = passed + 1
    
    Note: Test gate composition performance
    total = total + 1
    Let composition_start be QuantumGates.get_current_time()
    
    Let accumulated_gate be QuantumGates.identity_gate()
    For i from 0 to 99:  Note: Compose 100 gates
        accumulated_gate = QuantumGates.compose_gates(accumulated_gate, QuantumGates.rotation_z_gate(0.01))
    
    Let composition_time be QuantumGates.get_current_time() - composition_start
    
    Note: Gate composition should be reasonably fast
    If composition_time < 2.0:  Note: Less than 2 seconds
        passed = passed + 1
    
    Note: Test multi-qubit gate performance
    total = total + 1
    Let multi_qubit_start be QuantumGates.get_current_time()
    Let large_qft_gate be QuantumGates.quantum_fourier_transform(5)  Note: 5-qubit QFT
    Let multi_qubit_time be QuantumGates.get_current_time() - multi_qubit_start
    
    Note: Multi-qubit gate creation should complete in reasonable time
    If multi_qubit_time < 5.0:  Note: Less than 5 seconds
        passed = passed + 1
    
    Note: Test memory efficiency
    total = total + 1
    Let memory_before be QuantumGates.get_memory_usage()
    Let temp_gates be List[QuantumGates.QuantumGate]()
    For i from 0 to 199:  Note: 200 gates
        temp_gates.add(QuantumGates.rotation_x_gate(MathOps.random() * MathOps.pi))
    Let memory_after be QuantumGates.get_memory_usage()
    
    Note: Memory usage should be reasonable
    Let memory_increase be memory_after - memory_before
    If memory_increase < 5.0:  Note: Less than 5MB
        passed = passed + 1
    
    Print("Quantum Gates Performance Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: MAIN TEST RUNNER
Note: =====================================================================

Process called "run_all_quantum_gates_tests" that returns [Integer, Integer]:
    Print("=== Running All Quantum Gates Tests ===")
    
    Let total_passed be 0
    Let total_tests be 0
    
    Note: Run single-qubit gate tests
    Let [single_passed, single_total] be test_single_qubit_gates()
    total_passed = total_passed + single_passed
    total_tests = total_tests + single_total
    Print("")
    
    Note: Run rotation gate tests
    Let [rotation_passed, rotation_total] be test_rotation_gates()
    total_passed = total_passed + rotation_passed
    total_tests = total_tests + rotation_total
    Print("")
    
    Note: Run two-qubit gate tests
    Let [two_qubit_passed, two_qubit_total] be test_two_qubit_gates()
    total_passed = total_passed + two_qubit_passed
    total_tests = total_tests + two_qubit_total
    Print("")
    
    Note: Run multi-qubit gate tests
    Let [multi_passed, multi_total] be test_multi_qubit_gates()
    total_passed = total_passed + multi_passed
    total_tests = total_tests + multi_total
    Print("")
    
    Note: Run gate composition tests
    Let [composition_passed, composition_total] be test_gate_composition()
    total_passed = total_passed + composition_passed
    total_tests = total_tests + composition_total
    Print("")
    
    Note: Run gate decomposition tests
    Let [decomposition_passed, decomposition_total] be test_gate_decomposition()
    total_passed = total_passed + decomposition_passed
    total_tests = total_tests + decomposition_total
    Print("")
    
    Note: Run gate optimization tests
    Let [optimization_passed, optimization_total] be test_gate_optimization()
    total_passed = total_passed + optimization_passed
    total_tests = total_tests + optimization_total
    Print("")
    
    Note: Run performance tests
    Let [performance_passed, performance_total] be test_quantum_gates_performance()
    total_passed = total_passed + performance_passed
    total_tests = total_tests + performance_total
    Print("")
    
    Note: Print final results
    Print("=== Quantum Gates Test Results ===")
    Print("Total Tests Passed: " + total_passed.to_string() + "/" + total_tests.to_string())
    Let success_rate be (total_passed.to_float() / total_tests.to_float()) * 100.0
    Print("Success Rate: " + success_rate.to_string() + "%")
    
    If total_passed == total_tests:
        Print("✅ All quantum gates tests passed!")
    Otherwise:
        Print("❌ Some quantum gates tests failed.")
    
    Return [total_passed, total_tests]