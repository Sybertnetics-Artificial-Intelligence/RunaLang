Note: Comprehensive unit tests for math/engine/fourier/windowing module
Note: Tests window functions and spectral windowing techniques

Import "collections" as Collections
Import "math.core" as MathCore
Import "math.engine.fourier.windowing" as Windowing
Import "test.assertions" as Assert

Note: ========================================================================
Note: CLASSICAL WINDOW FUNCTION TESTS
Note: ========================================================================

Process called "test_rectangular_window" that takes no parameters returns Boolean:
    Note: Test rectangular (boxcar) window function
    Let length be 8
    Let window be Windowing.rectangular_window(length)
    
    Assert.AreEqual(window.length(), length)
    
    Note: All values should be 1.0 for rectangular window
    For i from 0 to length - 1:
        Assert.AreEqual(window[i], 1.0)
    
    Return true

Process called "test_triangular_window" that takes no parameters returns Boolean:
    Note: Test triangular (Bartlett) window function
    Let length be 9
    Let window be Windowing.triangular_window(length)
    
    Assert.AreEqual(window.length(), length)
    
    Note: Check symmetry around center
    Let center be length / 2
    For i from 0 to center - 1:
        Let symmetric_index be length - 1 - i
        Let error be MathCore.abs(window[i] - window[symmetric_index])
        Assert.IsTrue(error < 1e-14)
    
    Note: Center should be maximum value (1.0)
    Assert.AreEqual(window[center], 1.0)
    
    Note: Endpoints should be 0.0
    Assert.AreEqual(window[0], 0.0)
    Assert.AreEqual(window[length - 1], 0.0)
    
    Return true

Process called "test_hanning_window_periodic" that takes no parameters returns Boolean:
    Note: Test periodic Hanning window
    Let length be 8
    Let periodic be true
    Let window be Windowing.hanning_window(length, periodic)
    
    Assert.AreEqual(window.length(), length)
    
    Note: Verify Hanning formula: w[n] = 0.5 - 0.5 * cos(2*π*n/N)
    For i from 0 to length - 1:
        Let angle be 2.0 * MathCore.pi() * i / length
        Let expected be 0.5 - 0.5 * MathCore.cos(angle)
        Let error be MathCore.abs(window[i] - expected)
        Assert.IsTrue(error < 1e-14)
    
    Note: Periodic Hanning should not have zeros at endpoints
    Assert.IsTrue(window[0] > 0.0)
    Assert.IsTrue(window[length - 1] > 0.0)
    
    Return true

Process called "test_hanning_window_symmetric" that takes no parameters returns Boolean:
    Note: Test symmetric Hanning window
    Let length be 8
    Let periodic be false
    Let window be Windowing.hanning_window(length, periodic)
    
    Assert.AreEqual(window.length(), length)
    
    Note: Symmetric Hanning should have zeros at endpoints
    Assert.AreEqual(window[0], 0.0)
    Assert.AreEqual(window[length - 1], 0.0)
    
    Note: Check symmetry
    For i from 0 to length / 2 - 1:
        Let symmetric_index be length - 1 - i
        Let error be MathCore.abs(window[i] - window[symmetric_index])
        Assert.IsTrue(error < 1e-14)
    
    Return true

Process called "test_hamming_window" that takes no parameters returns Boolean:
    Note: Test Hamming window function
    Let length be 10
    Let window be Windowing.hamming_window(length)
    
    Assert.AreEqual(window.length(), length)
    
    Note: Verify Hamming formula: w[n] = 0.54 - 0.46 * cos(2*π*n/(N-1))
    For i from 0 to length - 1:
        Let angle be 2.0 * MathCore.pi() * i / (length - 1)
        Let expected be 0.54 - 0.46 * MathCore.cos(angle)
        Let error be MathCore.abs(window[i] - expected)
        Assert.IsTrue(error < 1e-14)
    
    Note: Hamming window should have non-zero endpoints (unlike Hanning)
    Assert.IsTrue(window[0] > 0.0)
    Assert.IsTrue(window[length - 1] > 0.0)
    
    Return true

Process called "test_blackman_window" that takes no parameters returns Boolean:
    Note: Test Blackman window function
    Let length be 12
    Let window be Windowing.blackman_window(length)
    
    Assert.AreEqual(window.length(), length)
    
    Note: Verify Blackman coefficients: a0=0.42, a1=0.5, a2=0.08
    Note: w[n] = a0 - a1*cos(2*π*n/(N-1)) + a2*cos(4*π*n/(N-1))
    For i from 0 to length - 1:
        Let angle1 be 2.0 * MathCore.pi() * i / (length - 1)
        Let angle2 be 4.0 * MathCore.pi() * i / (length - 1)
        Let expected be 0.42 - 0.5 * MathCore.cos(angle1) + 0.08 * MathCore.cos(angle2)
        Let error be MathCore.abs(window[i] - expected)
        Assert.IsTrue(error < 1e-14)
    
    Note: Blackman window has very small values at endpoints
    Assert.IsTrue(window[0] < 1e-10)
    Assert.IsTrue(window[length - 1] < 1e-10)
    
    Return true

Process called "test_blackman_harris_window" that takes no parameters returns Boolean:
    Note: Test Blackman-Harris window function
    Let length be 16
    Let window be Windowing.blackman_harris_window(length)
    
    Assert.AreEqual(window.length(), length)
    
    Note: Check symmetry
    For i from 0 to length / 2 - 1:
        Let symmetric_index be length - 1 - i
        Let error be MathCore.abs(window[i] - window[symmetric_index])
        Assert.IsTrue(error < 1e-14)
    
    Note: Maximum should be at center
    Let center be length / 2
    Let max_value be window[center]
    For i from 0 to length - 1:
        Assert.IsTrue(window[i] <= max_value)
    
    Return true

Note: ========================================================================
Note: MODERN WINDOW FUNCTION TESTS
Note: ========================================================================

Process called "test_kaiser_window" that takes no parameters returns Boolean:
    Note: Test Kaiser window with beta parameter
    Let length be 15
    Let beta be 5.0
    Let window be Windowing.kaiser_window(length, beta)
    
    Assert.AreEqual(window.length(), length)
    
    Note: Kaiser window should be symmetric
    For i from 0 to length / 2 - 1:
        Let symmetric_index be length - 1 - i
        Let error be MathCore.abs(window[i] - window[symmetric_index])
        Assert.IsTrue(error < 1e-12)
    
    Note: Maximum at center should approach 1.0
    Let center be length / 2
    Assert.IsTrue(window[center] > 0.9)
    
    Note: Test different beta values produce different shapes
    Let beta_small be 2.0
    Let beta_large be 10.0
    Let window_small be Windowing.kaiser_window(length, beta_small)
    Let window_large be Windowing.kaiser_window(length, beta_large)
    
    Note: Larger beta should produce more concentrated window
    Assert.IsTrue(window_small[1] > window_large[1])  Note: Second element
    
    Return true

Process called "test_gaussian_window" that takes no parameters returns Boolean:
    Note: Test Gaussian window function
    Let length be 20
    Let sigma be 2.5
    Let window be Windowing.gaussian_window(length, sigma)
    
    Assert.AreEqual(window.length(), length)
    
    Note: Gaussian should be symmetric around center
    Let center be (length - 1) / 2.0
    For i from 0 to length / 2 - 1:
        Let symmetric_index be length - 1 - i
        Let error be MathCore.abs(window[i] - window[symmetric_index])
        Assert.IsTrue(error < 1e-12)
    
    Note: Maximum should be at center
    Let center_index be length / 2
    For i from 0 to length - 1:
        Assert.IsTrue(window[i] <= window[center_index])
    
    Note: Test Gaussian formula: w[n] = exp(-0.5 * ((n - center)/sigma)^2)
    For i from 0 to length - 1:
        Let distance be (i - center) / sigma
        Let expected be MathCore.exp(-0.5 * distance * distance)
        Let error be MathCore.abs(window[i] - expected)
        Assert.IsTrue(error < 1e-12)
    
    Return true

Process called "test_tukey_window" that takes no parameters returns Boolean:
    Note: Test Tukey (tapered cosine) window
    Let length be 24
    Let alpha be 0.5  Note: Fraction of window that is tapered
    Let window be Windowing.tukey_window(length, alpha)
    
    Assert.AreEqual(window.length(), length)
    
    Note: Middle section should be approximately constant (like rectangular)
    Let taper_length be Integer(alpha * (length - 1) / 2)
    Let constant_start be taper_length
    Let constant_end be length - 1 - taper_length
    
    If constant_start < constant_end:
        For i from constant_start + 1 to constant_end - 1:
            Let error be MathCore.abs(window[i] - 1.0)
            Assert.IsTrue(error < 1e-12)
    
    Note: Check symmetry
    For i from 0 to length / 2 - 1:
        Let symmetric_index be length - 1 - i
        Let error be MathCore.abs(window[i] - window[symmetric_index])
        Assert.IsTrue(error < 1e-12)
    
    Return true

Process called "test_chebyshev_window" that takes no parameters returns Boolean:
    Note: Test Chebyshev window with specified side-lobe level
    Let length be 16
    Let side_lobe_db be -60.0
    Let window be Windowing.chebyshev_window(length, side_lobe_db)
    
    Assert.AreEqual(window.length(), length)
    
    Note: Chebyshev window should be symmetric
    For i from 0 to length / 2 - 1:
        Let symmetric_index be length - 1 - i
        Let error be MathCore.abs(window[i] - window[symmetric_index])
        Assert.IsTrue(error < 1e-10)
    
    Note: Verify ripple characteristics through DFT
    Let spectrum be Windowing.compute_window_spectrum(window, 512)
    Let max_magnitude be Windowing.find_spectrum_peak(spectrum)
    
    Note: Check that side-lobes are below specified level
    Let side_lobe_threshold be max_magnitude * MathCore.pow(10.0, side_lobe_db / 20.0)
    Let main_lobe_region be Windowing.identify_main_lobe(spectrum)
    
    Note: Test that side-lobes meet specification (simplified check)
    Assert.IsTrue(spectrum.length() > 0)
    Assert.IsTrue(max_magnitude > 0.0)
    
    Return true

Note: ========================================================================
Note: WINDOW PROPERTIES AND ANALYSIS TESTS
Note: ========================================================================

Process called "test_window_properties_computation" that takes no parameters returns Boolean:
    Note: Test computation of window function properties
    Let length be 32
    Let hanning_window be Windowing.hanning_window(length, false)
    Let properties be Windowing.analyze_window_properties(hanning_window)
    
    Note: Verify basic properties structure
    Assert.IsTrue(properties.coherent_gain > 0.0)
    Assert.IsTrue(properties.processing_gain > 0.0)
    Assert.IsTrue(properties.equivalent_noise_bandwidth > 0.0)
    Assert.IsTrue(properties.main_lobe_width > 0.0)
    Assert.IsTrue(properties.side_lobe_level < 0.0)  Note: Should be negative dB
    
    Note: Coherent gain should be less than 1.0 for Hanning
    Assert.IsTrue(properties.coherent_gain < 1.0)
    
    Note: Processing gain should account for window energy loss
    Let window_energy be 0.0
    For i from 0 to length - 1:
        Set window_energy to window_energy + hanning_window[i] * hanning_window[i]
    
    Let expected_processing_gain be length / window_energy
    Let gain_error be MathCore.abs(properties.processing_gain - expected_processing_gain)
    Assert.IsTrue(gain_error < 1e-10)
    
    Return true

Process called "test_window_comparison" that takes no parameters returns Boolean:
    Note: Test comparative analysis of different window functions
    Let length be 64
    
    Let rectangular be Windowing.rectangular_window(length)
    Let hanning be Windowing.hanning_window(length, false)
    Let blackman be Windowing.blackman_window(length)
    
    Let rect_props be Windowing.analyze_window_properties(rectangular)
    Let hann_props be Windowing.analyze_window_properties(hanning)
    Let black_props be Windowing.analyze_window_properties(blackman)
    
    Note: Rectangular should have best main lobe width (narrowest)
    Assert.IsTrue(rect_props.main_lobe_width < hann_props.main_lobe_width)
    Assert.IsTrue(hann_props.main_lobe_width < black_props.main_lobe_width)
    
    Note: Blackman should have best side lobe suppression (most negative)
    Assert.IsTrue(black_props.side_lobe_level < hann_props.side_lobe_level)
    Assert.IsTrue(hann_props.side_lobe_level < rect_props.side_lobe_level)
    
    Note: Rectangular should have highest coherent gain
    Assert.IsTrue(rect_props.coherent_gain > hann_props.coherent_gain)
    Assert.IsTrue(hann_props.coherent_gain > black_props.coherent_gain)
    
    Return true

Process called "test_spectral_leakage_analysis" that takes no parameters returns Boolean:
    Note: Test window functions' effect on spectral leakage
    Let length be 32
    Let sampling_rate be 1000.0
    
    Note: Create test signal with frequency between bins
    Let test_signal be Collections.CreateList[Float]()
    Let frequency be 15.625  Note: Between FFT bins
    For i from 0 to length - 1:
        Let t be i / sampling_rate
        Let amplitude be MathCore.cos(2.0 * MathCore.pi() * frequency * t)
        Call test_signal.append(amplitude)
    
    Note: Test without windowing (rectangular)
    Let rect_window be Windowing.rectangular_window(length)
    Let rect_result be Windowing.apply_window_and_analyze(test_signal, rect_window, sampling_rate)
    
    Note: Test with Hanning window
    Let hann_window be Windowing.hanning_window(length, false)
    Let hann_result be Windowing.apply_window_and_analyze(test_signal, hann_window, sampling_rate)
    
    Note: Hanning should reduce spectral leakage
    Let rect_leakage be Windowing.compute_spectral_leakage(rect_result)
    Let hann_leakage be Windowing.compute_spectral_leakage(hann_result)
    
    Assert.IsTrue(hann_leakage < rect_leakage)
    
    Return true

Process called "test_scalloping_loss_measurement" that takes no parameters returns Boolean:
    Note: Test measurement of scalloping loss for window functions
    Let length be 64
    Let hanning_window be Windowing.hanning_window(length, false)
    
    Note: Measure response at bin center vs. bin edge
    Let bin_center_response be Windowing.measure_frequency_response(hanning_window, 0.0)
    Let bin_edge_response be Windowing.measure_frequency_response(hanning_window, 0.5 / length)
    
    Let scalloping_loss be 20.0 * MathCore.log10(bin_edge_response / bin_center_response)
    
    Note: Hanning window should have approximately 1.42 dB scalloping loss
    Let expected_loss be -1.42
    Let error be MathCore.abs(scalloping_loss - expected_loss)
    Assert.IsTrue(error < 0.1)  Note: Allow some tolerance
    
    Return true

Note: ========================================================================
Note: MULTIDIMENSIONAL WINDOWING TESTS
Note: ========================================================================

Process called "test_2d_window_separable" that takes no parameters returns Boolean:
    Note: Test 2D separable window function
    Let rows be 8
    Let cols be 10
    Let window_1d_row be Windowing.hanning_window(rows, false)
    Let window_1d_col be Windowing.hamming_window(cols)
    
    Let window_2d be Windowing.separable_2d_window(window_1d_row, window_1d_col)
    
    Assert.AreEqual(window_2d.length(), rows)
    Assert.AreEqual(window_2d[0].length(), cols)
    
    Note: Verify separability: w_2d[i,j] = w_row[i] * w_col[j]
    For i from 0 to rows - 1:
        For j from 0 to cols - 1:
            Let expected be window_1d_row[i] * window_1d_col[j]
            Let error be MathCore.abs(window_2d[i][j] - expected)
            Assert.IsTrue(error < 1e-14)
    
    Return true

Process called "test_2d_window_circular" that takes no parameters returns Boolean:
    Note: Test 2D circular window function
    Let size be 16
    Let radius be 6.0
    Let window_2d be Windowing.circular_window(size, size, radius)
    
    Assert.AreEqual(window_2d.length(), size)
    Assert.AreEqual(window_2d[0].length(), size)
    
    Note: Check circular symmetry
    Let center_x be (size - 1) / 2.0
    Let center_y be (size - 1) / 2.0
    
    For i from 0 to size - 1:
        For j from 0 to size - 1:
            Let distance be MathCore.sqrt((i - center_x) * (i - center_x) + (j - center_y) * (j - center_y))
            
            If distance <= radius:
                Assert.IsTrue(window_2d[i][j] > 0.0)
            Otherwise:
                Assert.AreEqual(window_2d[i][j], 0.0)
    
    Return true

Process called "test_window_design_optimization" that takes no parameters returns Boolean:
    Note: Test optimal window design for specific requirements
    Let design_spec be Windowing.WindowDesign with:
        name = "custom_optimized"
        parameters = Collections.CreateDictionary[String, Float]()
        length = 32
        properties = Windowing.WindowProperties with:
            coherent_gain = 0.0
            processing_gain = 0.0
            equivalent_noise_bandwidth = 0.0
            main_lobe_width = 4.0  Note: Target main lobe width
            side_lobe_level = -50.0  Note: Target side lobe level
            side_lobe_fall_off_rate = 0.0
            scalloping_loss = 0.0
        symmetric = true
        periodic = false
    
    Call design_spec.parameters.set("target_sll", -50.0)
    Call design_spec.parameters.set("transition_width", 2.0)
    
    Let optimized_window be Windowing.design_optimal_window(design_spec)
    
    Assert.AreEqual(optimized_window.length(), 32)
    
    Note: Verify the designed window meets basic requirements
    Let actual_properties be Windowing.analyze_window_properties(optimized_window)
    Assert.IsTrue(actual_properties.side_lobe_level < -45.0)  Note: Close to target
    
    Return true

Note: ========================================================================
Note: WINDOW APPLICATION AND UTILITY TESTS
Note: ========================================================================

Process called "test_window_application_to_signal" that takes no parameters returns Boolean:
    Note: Test applying window function to signal
    Let signal be Collections.CreateList[Float]()
    Let length be 16
    
    Note: Create test signal
    For i from 0 to length - 1:
        Call signal.append(MathCore.sin(2.0 * MathCore.pi() * i / length))
    
    Let window be Windowing.hanning_window(length, false)
    Let windowed_signal be Windowing.apply_window(signal, window)
    
    Assert.AreEqual(windowed_signal.length(), length)
    
    Note: Verify windowing operation: windowed[i] = signal[i] * window[i]
    For i from 0 to length - 1:
        Let expected be signal[i] * window[i]
        Let error be MathCore.abs(windowed_signal[i] - expected)
        Assert.IsTrue(error < 1e-14)
    
    Return true

Process called "test_window_overlap_analysis" that takes no parameters returns Boolean:
    Note: Test window overlap analysis for STFT applications
    Let window_length be 32
    Let overlap_percent be 50.0
    Let hanning_window be Windowing.hanning_window(window_length, false)
    
    Let overlap_analysis be Windowing.analyze_window_overlap(hanning_window, overlap_percent)
    
    Note: Check overlap-add reconstruction property
    Assert.IsTrue(overlap_analysis.perfect_reconstruction)
    Assert.IsTrue(overlap_analysis.constant_overlap_add > 0.0)
    
    Note: Test different overlap percentages
    Let overlap_25 be Windowing.analyze_window_overlap(hanning_window, 25.0)
    Let overlap_75 be Windowing.analyze_window_overlap(hanning_window, 75.0)
    
    Note: Higher overlap should provide better reconstruction
    Assert.IsTrue(overlap_75.reconstruction_quality > overlap_25.reconstruction_quality)
    
    Return true

Process called "test_window_normalization" that takes no parameters returns Boolean:
    Note: Test window function normalization methods
    Let length be 20
    Let blackman_window be Windowing.blackman_window(length)
    
    Note: Test coherent gain normalization
    Let coherent_normalized be Windowing.normalize_window(blackman_window, "coherent")
    Let coherent_gain be 0.0
    For i from 0 to length - 1:
        Set coherent_gain to coherent_gain + coherent_normalized[i]
    Set coherent_gain to coherent_gain / length
    Assert.IsTrue(MathCore.abs(coherent_gain - 1.0) < 1e-10)
    
    Note: Test energy normalization
    Let energy_normalized be Windowing.normalize_window(blackman_window, "energy")
    Let energy be 0.0
    For i from 0 to length - 1:
        Set energy to energy + energy_normalized[i] * energy_normalized[i]
    Assert.IsTrue(MathCore.abs(energy - 1.0) < 1e-10)
    
    Return true

Note: ========================================================================
Note: ERROR HANDLING AND EDGE CASES TESTS
Note: ========================================================================

Process called "test_window_invalid_parameters" that takes no parameters returns Boolean:
    Note: Test window functions with invalid parameters
    
    Note: Test zero length
    Try:
        Let invalid_window be Windowing.hanning_window(0, false)
        Assert.Fail("Expected exception for zero length")
    Catch error:
        Assert.IsTrue(true)
    
    Note: Test negative length
    Try:
        Let invalid_window be Windowing.gaussian_window(-5, 1.0)
        Assert.Fail("Expected exception for negative length")
    Catch error:
        Assert.IsTrue(true)
    
    Note: Test invalid Kaiser beta
    Try:
        Let invalid_window be Windowing.kaiser_window(10, -1.0)
        Assert.Fail("Expected exception for negative beta")
    Catch error:
        Assert.IsTrue(true)
    
    Return true

Process called "test_window_extreme_parameters" that takes no parameters returns Boolean:
    Note: Test window functions with extreme but valid parameters
    
    Note: Very large window
    Let large_window be Windowing.hanning_window(1024, false)
    Assert.AreEqual(large_window.length(), 1024)
    
    Note: Single-element window
    Let single_window be Windowing.rectangular_window(1)
    Assert.AreEqual(single_window.length(), 1)
    Assert.AreEqual(single_window[0], 1.0)
    
    Note: Very high Kaiser beta
    Let sharp_kaiser be Windowing.kaiser_window(20, 50.0)
    Assert.AreEqual(sharp_kaiser.length(), 20)
    
    Note: Should be very concentrated around center
    Let center be 10
    Assert.IsTrue(sharp_kaiser[center] > 0.9)
    Assert.IsTrue(sharp_kaiser[0] < 1e-10)
    Assert.IsTrue(sharp_kaiser[19] < 1e-10)
    
    Return true

Process called "test_window_numerical_precision" that takes no parameters returns Boolean:
    Note: Test window functions maintain numerical precision
    Let length be 64
    
    Note: Test multiple window types for precision
    Let windows be Collections.CreateList[String]()
    Call windows.append("hanning")
    Call windows.append("hamming")
    Call windows.append("blackman")
    
    For window_index from 0 to 2:
        Let window_type be windows[window_index]
        Let window be if window_type == "hanning" then Windowing.hanning_window(length, false)
                       else if window_type == "hamming" then Windowing.hamming_window(length)
                       else Windowing.blackman_window(length)
        
        Note: Check that all values are finite and reasonable
        For i from 0 to length - 1:
            Assert.IsTrue(MathCore.is_finite(window[i]))
            Assert.IsTrue(window[i] >= 0.0)
            Assert.IsTrue(window[i] <= 1.001)  Note: Allow small numerical tolerance
        
        Note: Check symmetry is preserved within precision limits
        For i from 0 to length / 2 - 1:
            Let symmetric_index be length - 1 - i
            Let symmetry_error be MathCore.abs(window[i] - window[symmetric_index])
            Assert.IsTrue(symmetry_error < 1e-14)
    
    Return true