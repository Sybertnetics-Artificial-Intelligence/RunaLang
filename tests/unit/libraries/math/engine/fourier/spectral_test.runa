Note: Comprehensive unit tests for math/engine/fourier/spectral module
Note: Tests spectral analysis and frequency domain methods

Import "collections" as Collections
Import "math.core" as MathCore
Import "math.engine.fourier.spectral" as Spectral
Import "math.engine.fourier.dft" as DFT
Import "test.assertions" as Assert

Note: ========================================================================
Note: PERIODOGRAM SPECTRAL ESTIMATION TESTS
Note: ========================================================================

Process called "test_periodogram_basic_estimation" that takes no parameters returns Boolean:
    Note: Test basic periodogram computation
    Let signal be Collections.CreateList[Float]()
    
    Note: Create sinusoidal signal at known frequency
    Let frequency be 5.0  Note: Hz
    Let sampling_rate be 50.0  Note: Hz
    For i from 0 to 49:
        Let t be i / sampling_rate
        Let amplitude be MathCore.cos(2.0 * MathCore.pi() * frequency * t)
        Call signal.append(amplitude)
    
    Let estimate be Spectral.periodogram(signal, "rectangular", sampling_rate)
    
    Assert.AreEqual(estimate.frequencies.length(), 25)  Note: N/2 + 1 for real signal
    Assert.AreEqual(estimate.power_spectral_density.length(), 25)
    Assert.AreEqual(estimate.sampling_rate, sampling_rate)
    Assert.IsTrue(estimate.frequency_resolution > 0.0)
    Assert.AreEqual(estimate.method, "periodogram")
    
    Note: Find peak frequency
    Let max_power be 0.0
    Let peak_index be 0
    For i from 0 to 24:
        If estimate.power_spectral_density[i] > max_power:
            Set max_power to estimate.power_spectral_density[i]
            Set peak_index to i
    
    Let detected_frequency be estimate.frequencies[peak_index]
    Let frequency_error be MathCore.abs(detected_frequency - frequency)
    Assert.IsTrue(frequency_error < 2.0)  Note: Within one frequency bin
    
    Return true

Process called "test_periodogram_window_functions" that takes no parameters returns Boolean:
    Note: Test periodogram with different window functions
    Let signal be Collections.CreateList[Float]()
    
    Note: Create test signal with spectral leakage
    For i from 0 to 63:
        Let t be i / 64.0
        Let freq be 7.3  Note: Non-integer frequency bin
        Let amplitude be MathCore.sin(2.0 * MathCore.pi() * freq * t)
        Call signal.append(amplitude)
    
    Let sampling_rate be 64.0
    
    Note: Compare different windowing
    Let rect_estimate be Spectral.periodogram(signal, "rectangular", sampling_rate)
    Let hanning_estimate be Spectral.periodogram(signal, "hanning", sampling_rate)
    Let hamming_estimate be Spectral.periodogram(signal, "hamming", sampling_rate)
    
    Assert.AreEqual(rect_estimate.frequencies.length(), hanning_estimate.frequencies.length())
    Assert.AreEqual(hanning_estimate.frequencies.length(), hamming_estimate.frequencies.length())
    
    Note: Windowed estimates should reduce spectral leakage
    Let rect_leakage be Spectral.compute_spectral_leakage(rect_estimate)
    Let hann_leakage be Spectral.compute_spectral_leakage(hanning_estimate)
    
    Assert.IsTrue(hann_leakage < rect_leakage)
    
    Return true

Process called "test_periodogram_parseval_theorem" that takes no parameters returns Boolean:
    Note: Test energy conservation in periodogram (Parseval's theorem)
    Let signal be Collections.CreateList[Float]()
    
    For i from 0 to 31:
        Let value be MathCore.cos(2.0 * MathCore.pi() * i / 32.0) + 0.5 * MathCore.sin(4.0 * MathCore.pi() * i / 32.0)
        Call signal.append(value)
    
    Note: Compute time domain energy
    Let time_energy be 0.0
    For i from 0 to 31:
        Set time_energy to time_energy + signal[i] * signal[i]
    
    Note: Compute frequency domain energy from periodogram
    Let estimate be Spectral.periodogram(signal, "rectangular", 32.0)
    Let freq_energy be 0.0
    For i from 0 to estimate.power_spectral_density.length() - 1:
        Set freq_energy to freq_energy + estimate.power_spectral_density[i]
    
    Note: Account for scaling factors in periodogram
    Set freq_energy to freq_energy * estimate.frequency_resolution
    
    Note: Energy should be conserved (within numerical precision)
    Let energy_error be MathCore.abs(time_energy - freq_energy) / time_energy
    Assert.IsTrue(energy_error < 0.01)  Note: Allow some numerical tolerance
    
    Return true

Note: ========================================================================
Note: WELCH'S METHOD TESTS
Note: ========================================================================

Process called "test_welch_method_basic" that takes no parameters returns Boolean:
    Note: Test Welch's method for spectral estimation
    Let signal be Collections.CreateList[Float]()
    
    Note: Create longer signal for segmentation
    For i from 0 to 511:
        Let t be i / 512.0
        Let f1 be MathCore.cos(2.0 * MathCore.pi() * 10.0 * t)
        Let f2 be 0.5 * MathCore.sin(2.0 * MathCore.pi() * 25.0 * t)
        Let noise be 0.1 * (MathCore.random() - 0.5)
        Call signal.append(f1 + f2 + noise)
    
    Let sampling_rate be 512.0
    Let segment_length be 128
    Let overlap_percent be 50.0
    
    Let welch_estimate be Spectral.welch_method(signal, segment_length, overlap_percent, "hanning", sampling_rate)
    
    Assert.AreEqual(welch_estimate.method, "welch")
    Assert.IsTrue(welch_estimate.frequencies.length() > 0)
    Assert.IsTrue(welch_estimate.power_spectral_density.length() > 0)
    Assert.AreEqual(welch_estimate.sampling_rate, sampling_rate)
    
    Note: Should have better noise reduction than single periodogram
    Let single_periodogram be Spectral.periodogram(signal, "hanning", sampling_rate)
    
    Note: Welch method should have smoother spectrum (less variance)
    Let welch_variance be Spectral.compute_spectral_variance(welch_estimate)
    Let periodogram_variance be Spectral.compute_spectral_variance(single_periodogram)
    
    Assert.IsTrue(welch_variance < periodogram_variance)
    
    Return true

Process called "test_welch_method_overlap_effects" that takes no parameters returns Boolean:
    Note: Test effects of different overlap percentages in Welch's method
    Let signal be Collections.CreateList[Float]()
    
    For i from 0 to 255:
        Let t be i / 256.0
        Call signal.append(MathCore.sin(2.0 * MathCore.pi() * 8.0 * t) + 0.2 * MathCore.random())
    
    Let sampling_rate be 256.0
    Let segment_length be 64
    
    Let overlap_0 be Spectral.welch_method(signal, segment_length, 0.0, "hanning", sampling_rate)
    Let overlap_50 be Spectral.welch_method(signal, segment_length, 50.0, "hanning", sampling_rate)
    Let overlap_75 be Spectral.welch_method(signal, segment_length, 75.0, "hanning", sampling_rate)
    
    Note: Higher overlap should provide better statistics (more averaging)
    Let variance_0 be Spectral.compute_spectral_variance(overlap_0)
    Let variance_50 be Spectral.compute_spectral_variance(overlap_50)
    Let variance_75 be Spectral.compute_spectral_variance(overlap_75)
    
    Assert.IsTrue(variance_75 < variance_50)
    Assert.IsTrue(variance_50 < variance_0)
    
    Return true

Note: ========================================================================
Note: MULTITAPER METHOD TESTS
Note: ========================================================================

Process called "test_multitaper_method_basic" that takes no parameters returns Boolean:
    Note: Test multitaper spectral estimation
    Let signal be Collections.CreateList[Float]()
    
    For i from 0 to 127:
        Let t be i / 128.0
        Let signal_value be MathCore.cos(2.0 * MathCore.pi() * 12.0 * t) + 0.3 * MathCore.random()
        Call signal.append(signal_value)
    
    Let sampling_rate be 128.0
    Let time_bandwidth_product be 4.0
    Let num_tapers be 7
    
    Let mt_estimate be Spectral.multitaper_method(signal, time_bandwidth_product, num_tapers, sampling_rate)
    
    Assert.AreEqual(mt_estimate.method, "multitaper")
    Assert.IsTrue(mt_estimate.frequencies.length() > 0)
    Assert.IsTrue(mt_estimate.confidence_intervals.length() > 0)
    Assert.AreEqual(mt_estimate.sampling_rate, sampling_rate)
    
    Note: Should provide confidence intervals
    For i from 0 to mt_estimate.confidence_intervals.length() - 1:
        Let lower_bound be mt_estimate.confidence_intervals[i][0]
        Let upper_bound be mt_estimate.confidence_intervals[i][1]
        Let psd_value be mt_estimate.power_spectral_density[i]
        
        Assert.IsTrue(lower_bound <= psd_value)
        Assert.IsTrue(psd_value <= upper_bound)
    
    Return true

Process called "test_multitaper_eigenspectra" that takes no parameters returns Boolean:
    Note: Test multitaper eigenspectra computation
    Let signal be Collections.CreateList[Float]()
    
    For i from 0 to 63:
        Call signal.append(MathCore.sin(2.0 * MathCore.pi() * i / 64.0))
    
    Let time_bandwidth_product be 3.0
    Let num_tapers be 5
    
    Let eigenspectra be Spectral.compute_multitaper_eigenspectra(signal, time_bandwidth_product, num_tapers)
    
    Assert.AreEqual(eigenspectra.length(), num_tapers)
    
    Note: Each eigenspectrum should have same frequency resolution
    For taper_index from 0 to num_tapers - 1:
        Assert.AreEqual(eigenspectra[taper_index].length(), 32)  Note: N/2 for real signal
    
    Note: Eigenspectra should be different due to different tapers
    Let first_spectrum_sum be 0.0
    Let second_spectrum_sum be 0.0
    For i from 0 to 31:
        Set first_spectrum_sum to first_spectrum_sum + eigenspectra[0][i]
        Set second_spectrum_sum to second_spectrum_sum + eigenspectra[1][i]
    
    Assert.IsTrue(MathCore.abs(first_spectrum_sum - second_spectrum_sum) > 1e-10)
    
    Return true

Note: ========================================================================
Note: CROSS-SPECTRAL ANALYSIS TESTS
Note: ========================================================================

Process called "test_cross_spectrum_computation" that takes no parameters returns Boolean:
    Note: Test cross-spectral density computation
    Let signal1 be Collections.CreateList[Float]()
    Let signal2 be Collections.CreateList[Float]()
    
    Note: Create correlated signals with phase shift
    Let phase_shift be MathCore.pi() / 4.0  Note: 45 degrees
    For i from 0 to 63:
        Let t be i / 64.0
        Let freq be 8.0
        Let s1 be MathCore.cos(2.0 * MathCore.pi() * freq * t)
        Let s2 be MathCore.cos(2.0 * MathCore.pi() * freq * t + phase_shift)
        Call signal1.append(s1)
        Call signal2.append(s2)
    
    Let sampling_rate be 64.0
    Let cross_result be Spectral.cross_spectrum(signal1, signal2, "hanning", sampling_rate)
    
    Assert.AreEqual(cross_result.cross_power_spectrum.length(), 32)
    Assert.AreEqual(cross_result.coherence.length(), 32)
    Assert.AreEqual(cross_result.phase.length(), 32)
    Assert.AreEqual(cross_result.frequencies.length(), 32)
    
    Note: Find the peak frequency bin
    Let max_coherence be 0.0
    Let peak_index be 0
    For i from 0 to 31:
        If cross_result.coherence[i] > max_coherence:
            Set max_coherence to cross_result.coherence[i]
            Set peak_index to i
    
    Note: Coherence should be high at the signal frequency
    Assert.IsTrue(max_coherence > 0.8)
    
    Note: Phase should be close to the expected phase shift
    Let measured_phase be cross_result.phase[peak_index]
    Let phase_error be MathCore.abs(measured_phase - phase_shift)
    Assert.IsTrue(phase_error < 0.2)  Note: Within reasonable tolerance
    
    Return true

Process called "test_coherence_function" that takes no parameters returns Boolean:
    Note: Test coherence function properties
    Let signal1 be Collections.CreateList[Float]()
    Let signal2 be Collections.CreateList[Float]()
    Let signal3 be Collections.CreateList[Float]()
    
    Note: Create identical signals (perfect coherence)
    For i from 0 to 31:
        Let value be MathCore.sin(2.0 * MathCore.pi() * i / 32.0)
        Call signal1.append(value)
        Call signal2.append(value)  Note: Identical to signal1
        Call signal3.append(MathCore.random())  Note: Random (no coherence)
    
    Let sampling_rate be 32.0
    
    Note: Perfect coherence case
    Let coherent_result be Spectral.cross_spectrum(signal1, signal2, "rectangular", sampling_rate)
    
    Note: No coherence case
    Let incoherent_result be Spectral.cross_spectrum(signal1, signal3, "rectangular", sampling_rate)
    
    Note: Check coherence values
    For i from 1 to 15:  Note: Skip DC and Nyquist
        Assert.IsTrue(coherent_result.coherence[i] > 0.99)    Note: Nearly perfect coherence
        Assert.IsTrue(incoherent_result.coherence[i] < 0.2)  Note: Low coherence
    
    Return true

Process called "test_cross_correlation_spectrum" that takes no parameters returns Boolean:
    Note: Test relationship between cross-correlation and cross-spectrum
    Let signal1 be Collections.CreateList[Float]()
    Let signal2 be Collections.CreateList[Float]()
    
    For i from 0 to 31:
        Let t be i / 32.0
        Call signal1.append(MathCore.cos(2.0 * MathCore.pi() * 4.0 * t))
        Call signal2.append(MathCore.sin(2.0 * MathCore.pi() * 4.0 * t))  Note: 90 degree phase shift
    
    Let sampling_rate be 32.0
    
    Note: Compute cross-spectrum
    Let cross_spec be Spectral.cross_spectrum(signal1, signal2, "rectangular", sampling_rate)
    
    Note: Compute cross-correlation via inverse FFT of cross-spectrum
    Let cross_correlation be Spectral.cross_spectrum_to_correlation(cross_spec)
    
    Assert.AreEqual(cross_correlation.length(), 32)
    
    Note: For 90-degree phase shift, correlation should have specific pattern
    Let max_correlation be 0.0
    Let max_index be 0
    For i from 0 to 31:
        If MathCore.abs(cross_correlation[i]) > MathCore.abs(max_correlation):
            Set max_correlation to cross_correlation[i]
            Set max_index to i
    
    Assert.IsTrue(MathCore.abs(max_correlation) > 0.5)
    
    Return true

Note: ========================================================================
Note: SPECTROGRAM ANALYSIS TESTS
Note: ========================================================================

Process called "test_spectrogram_computation" that takes no parameters returns Boolean:
    Note: Test Short-Time Fourier Transform spectrogram
    Let signal be Collections.CreateList[Float]()
    
    Note: Create chirp signal (frequency changes with time)
    For i from 0 to 255:
        Let t be i / 256.0
        Let freq be 5.0 + 15.0 * t  Note: Frequency sweep from 5 to 20 Hz
        Call signal.append(MathCore.cos(2.0 * MathCore.pi() * freq * t))
    
    Let sampling_rate be 256.0
    Let window_length be 64
    Let overlap_percent be 75.0
    
    Let spectrogram be Spectral.compute_spectrogram(signal, window_length, overlap_percent, "hanning", sampling_rate)
    
    Assert.IsTrue(spectrogram.time_bins.length() > 0)
    Assert.IsTrue(spectrogram.frequency_bins.length() > 0)
    Assert.IsTrue(spectrogram.spectrogram.length() > 0)
    Assert.AreEqual(spectrogram.window_function, "hanning")
    Assert.AreEqual(spectrogram.overlap_percent, overlap_percent)
    
    Note: Spectrogram should show time-varying frequency content
    Let num_time_bins be spectrogram.time_bins.length()
    Let num_freq_bins be spectrogram.frequency_bins.length()
    
    Assert.AreEqual(spectrogram.spectrogram.length(), num_time_bins)
    Assert.AreEqual(spectrogram.spectrogram[0].length(), num_freq_bins)
    
    Return true

Process called "test_spectrogram_time_frequency_resolution" that takes no parameters returns Boolean:
    Note: Test time-frequency resolution trade-off in spectrograms
    Let signal be Collections.CreateList[Float]()
    
    Note: Create signal with brief tone burst
    For i from 0 to 127:
        Let t be i / 128.0
        Let tone be if (t >= 0.3 and t <= 0.4) then MathCore.sin(2.0 * MathCore.pi() * 20.0 * t) else 0.0
        Call signal.append(tone)
    
    Let sampling_rate be 128.0
    
    Note: Short window (good time resolution)
    Let short_window_spec be Spectral.compute_spectrogram(signal, 16, 50.0, "hanning", sampling_rate)
    
    Note: Long window (good frequency resolution)
    Let long_window_spec be Spectral.compute_spectrogram(signal, 64, 50.0, "hanning", sampling_rate)
    
    Note: Short window should have better time resolution
    Assert.IsTrue(short_window_spec.time_bins.length() > long_window_spec.time_bins.length())
    
    Note: Long window should have better frequency resolution
    Assert.IsTrue(long_window_spec.frequency_bins.length() > short_window_spec.frequency_bins.length())
    
    Return true

Process called "test_spectrogram_peak_tracking" that takes no parameters returns Boolean:
    Note: Test spectral peak tracking in spectrograms
    Let signal be Collections.CreateList[Float]()
    
    Note: Create signal with two crossing frequency trajectories
    For i from 0 to 255:
        Let t be i / 256.0
        Let f1 be 10.0 + 10.0 * t     Note: Increasing frequency
        Let f2 be 20.0 - 5.0 * t      Note: Decreasing frequency
        Call signal.append(MathCore.sin(2.0 * MathCore.pi() * f1 * t) + MathCore.sin(2.0 * MathCore.pi() * f2 * t))
    
    Let sampling_rate be 256.0
    Let spectrogram be Spectral.compute_spectrogram(signal, 32, 75.0, "hanning", sampling_rate)
    
    Note: Track spectral peaks across time
    Let peak_tracks be Spectral.track_spectral_peaks(spectrogram, 0.3)  Note: Threshold
    
    Assert.IsTrue(peak_tracks.length() >= 2)  Note: Should find at least 2 trajectories
    
    Note: Verify peak tracking results
    For track_index from 0 to peak_tracks.length() - 1:
        Let track be peak_tracks[track_index]
        Assert.IsTrue(track.frequency_trajectory.length() > 0)
        Assert.IsTrue(track.time_points.length() > 0)
        Assert.AreEqual(track.frequency_trajectory.length(), track.time_points.length())
    
    Return true

Note: ========================================================================
Note: HIGHER-ORDER SPECTRAL ANALYSIS TESTS
Note: ========================================================================

Process called "test_bispectrum_computation" that takes no parameters returns Boolean:
    Note: Test bispectrum (third-order spectrum) computation
    Let signal be Collections.CreateList[Float]()
    
    Note: Create signal with quadratic phase coupling
    For i from 0 to 63:
        Let t be i / 64.0
        Let f1 be MathCore.cos(2.0 * MathCore.pi() * 5.0 * t)
        Let f2 be MathCore.cos(2.0 * MathCore.pi() * 10.0 * t)
        Let coupling be MathCore.cos(2.0 * MathCore.pi() * 15.0 * t)  Note: f1 + f2 = 15 Hz
        Call signal.append(f1 + f2 + 0.5 * coupling)
    
    Let sampling_rate be 64.0
    Let bispectrum be Spectral.compute_bispectrum(signal, sampling_rate)
    
    Assert.IsTrue(bispectrum.frequency_pairs.length() > 0)
    Assert.IsTrue(bispectrum.bispectral_values.length() > 0)
    Assert.IsTrue(bispectrum.bicoherence.length() > 0)
    
    Note: Should detect quadratic phase coupling at (5, 10) Hz
    Let coupling_detected be false
    For i from 0 to bispectrum.frequency_pairs.length() - 1:
        Let f1 be bispectrum.frequency_pairs[i][0]
        Let f2 be bispectrum.frequency_pairs[i][1]
        If MathCore.abs(f1 - 5.0) < 1.0 and MathCore.abs(f2 - 10.0) < 1.0:
            If bispectrum.bicoherence[i] > 0.3:  Note: Significant coupling
                Set coupling_detected to true
    
    Assert.IsTrue(coupling_detected)
    
    Return true

Process called "test_trispectrum_computation" that takes no parameters returns Boolean:
    Note: Test trispectrum (fourth-order spectrum) computation
    Let signal be Collections.CreateList[Float]()
    
    Note: Create signal with cubic phase coupling
    For i from 0 to 63:
        Let t be i / 64.0
        Let f1 be MathCore.cos(2.0 * MathCore.pi() * 3.0 * t)
        Let f2 be MathCore.cos(2.0 * MathCore.pi() * 5.0 * t)
        Let f3 be MathCore.cos(2.0 * MathCore.pi() * 7.0 * t)
        Let coupling be MathCore.cos(2.0 * MathCore.pi() * 15.0 * t)  Note: f1 + f2 + f3 = 15 Hz
        Call signal.append(f1 + f2 + f3 + 0.3 * coupling)
    
    Let sampling_rate be 64.0
    Let trispectrum be Spectral.compute_trispectrum(signal, sampling_rate)
    
    Assert.IsTrue(trispectrum.frequency_triplets.length() > 0)
    Assert.IsTrue(trispectrum.trispectral_values.length() > 0)
    Assert.IsTrue(trispectral.tricoherence.length() > 0)
    
    Note: Basic structure verification
    For i from 0 to trispectrum.frequency_triplets.length() - 1:
        Assert.AreEqual(trispectrum.frequency_triplets[i].length(), 3)  Note: Three frequencies
        Assert.IsTrue(trispectral.tricoherence[i] >= 0.0)
        Assert.IsTrue(trispectral.tricoherence[i] <= 1.0)
    
    Return true

Note: ========================================================================
Note: PARAMETRIC SPECTRAL ESTIMATION TESTS
Note: ========================================================================

Process called "test_autoregressive_spectral_estimation" that takes no parameters returns Boolean:
    Note: Test AR (autoregressive) spectral estimation
    Let signal be Collections.CreateList[Float]()
    
    Note: Create AR(2) process: x[n] = 0.5*x[n-1] + 0.3*x[n-2] + noise
    Let x_prev be 0.0
    Let x_prev2 be 0.0
    For i from 0 to 99:
        Let noise be 0.1 * (MathCore.random() - 0.5)
        Let x_current be 0.5 * x_prev + 0.3 * x_prev2 + noise
        Call signal.append(x_current)
        Set x_prev2 to x_prev
        Set x_prev to x_current
    
    Let model_order be 4  Note: Overestimate to test robustness
    Let sampling_rate be 100.0
    
    Let ar_estimate be Spectral.autoregressive_psd(signal, model_order, sampling_rate)
    
    Assert.AreEqual(ar_estimate.method, "autoregressive")
    Assert.IsTrue(ar_estimate.frequencies.length() > 0)
    Assert.IsTrue(ar_estimate.power_spectral_density.length() > 0)
    Assert.IsTrue(ar_estimate.parameters.contains_key("model_order"))
    Assert.IsTrue(ar_estimate.parameters.contains_key("prediction_error_variance"))
    
    Note: AR spectrum should be smoother than periodogram
    Let periodogram_estimate be Spectral.periodogram(signal, "rectangular", sampling_rate)
    
    Let ar_smoothness be Spectral.compute_spectral_smoothness(ar_estimate)
    Let periodogram_smoothness be Spectral.compute_spectral_smoothness(periodogram_estimate)
    
    Assert.IsTrue(ar_smoothness > periodogram_smoothness)
    
    Return true

Process called "test_model_order_selection" that takes no parameters returns Boolean:
    Note: Test automatic model order selection for parametric methods
    Let signal be Collections.CreateList[Float]()
    
    Note: Create signal from known AR(3) model
    Let x1 be 0.0
    Let x2 be 0.0
    Let x3 be 0.0
    For i from 0 to 199:
        Let noise be 0.05 * (MathCore.random() - 0.5)
        Let x_new be 0.6 * x1 - 0.4 * x2 + 0.2 * x3 + noise
        Call signal.append(x_new)
        Set x3 to x2
        Set x2 to x1
        Set x1 to x_new
    
    Let max_order be 10
    Let sampling_rate be 200.0
    
    Note: Test different order selection criteria
    Let aic_order be Spectral.select_ar_order_aic(signal, max_order)
    Let bic_order be Spectral.select_ar_order_bic(signal, max_order)
    Let mdl_order be Spectral.select_ar_order_mdl(signal, max_order)
    
    Note: Should select order close to true order (3)
    Assert.IsTrue(aic_order >= 2 and aic_order <= 5)
    Assert.IsTrue(bic_order >= 2 and bic_order <= 5)
    Assert.IsTrue(mdl_order >= 2 and mdl_order <= 5)
    
    Note: BIC typically selects lower order than AIC
    Assert.IsTrue(bic_order <= aic_order)
    
    Return true

Process called "test_music_algorithm" that takes no parameters returns Boolean:
    Note: Test MUSIC algorithm for high-resolution spectral estimation
    Let signal be Collections.CreateList[Float]()
    
    Note: Create signal with closely spaced sinusoids
    For i from 0 to 127:
        Let t be i / 128.0
        Let f1 be MathCore.cos(2.0 * MathCore.pi() * 20.0 * t)
        Let f2 be MathCore.cos(2.0 * MathCore.pi() * 21.0 * t)  Note: Only 1 Hz apart
        Let noise be 0.1 * (MathCore.random() - 0.5)
        Call signal.append(f1 + f2 + noise)
    
    Let num_sources be 2
    Let subspace_dimension be 8
    Let sampling_rate be 128.0
    
    Let music_estimate be Spectral.music_algorithm(signal, num_sources, subspace_dimension, sampling_rate)
    
    Assert.AreEqual(music_estimate.method, "MUSIC")
    Assert.IsTrue(music_estimate.frequencies.length() > 0)
    Assert.IsTrue(music_estimate.power_spectral_density.length() > 0)
    
    Note: MUSIC should provide much sharper peaks than periodogram
    Let music_sharpness be Spectral.compute_spectral_sharpness(music_estimate)
    Let periodogram_estimate be Spectral.periodogram(signal, "hanning", sampling_rate)
    Let periodogram_sharpness be Spectral.compute_spectral_sharpness(periodogram_estimate)
    
    Assert.IsTrue(music_sharpness > periodogram_sharpness)
    
    Return true

Note: ========================================================================
Note: ERROR HANDLING AND EDGE CASES TESTS
Note: ========================================================================

Process called "test_spectral_estimation_edge_cases" that takes no parameters returns Boolean:
    Note: Test spectral estimation with edge case inputs
    
    Note: Test with very short signals
    Let short_signal be Collections.CreateList[Float]()
    Call short_signal.append(1.0)
    Call short_signal.append(-1.0)
    
    Try:
        Let estimate be Spectral.periodogram(short_signal, "hanning", 2.0)
        Assert.IsTrue(estimate.frequencies.length() >= 1)
    Catch error:
        Note: Some methods may require minimum signal length
        Assert.IsTrue(true)
    
    Note: Test with constant (DC) signal
    Let dc_signal be Collections.CreateList[Float]()
    For i from 0 to 31:
        Call dc_signal.append(5.0)
    
    Let dc_estimate be Spectral.periodogram(dc_signal, "rectangular", 32.0)
    
    Note: All energy should be at DC (first bin)
    Assert.IsTrue(dc_estimate.power_spectral_density[0] > 0.0)
    For i from 1 to dc_estimate.power_spectral_density.length() - 1:
        Assert.IsTrue(dc_estimate.power_spectral_density[i] < 0.01)
    
    Return true

Process called "test_spectral_invalid_parameters" that takes no parameters returns Boolean:
    Note: Test spectral analysis functions with invalid parameters
    Let valid_signal be Collections.CreateList[Float]()
    For i from 0 to 15:
        Call valid_signal.append(MathCore.sin(2.0 * MathCore.pi() * i / 16.0))
    
    Note: Test with zero sampling rate
    Try:
        Let estimate be Spectral.periodogram(valid_signal, "hanning", 0.0)
        Assert.Fail("Expected exception for zero sampling rate")
    Catch error:
        Assert.IsTrue(true)
    
    Note: Test with invalid window function name
    Try:
        Let estimate be Spectral.periodogram(valid_signal, "invalid_window", 16.0)
        Assert.Fail("Expected exception for invalid window function")
    Catch error:
        Assert.IsTrue(true)
    
    Note: Test Welch method with segment length larger than signal
    Try:
        Let estimate be Spectral.welch_method(valid_signal, 32, 50.0, "hanning", 16.0)
        Assert.Fail("Expected exception for oversized segment length")
    Catch error:
        Assert.IsTrue(true)
    
    Return true

Process called "test_spectral_numerical_precision" that takes no parameters returns Boolean:
    Note: Test numerical precision of spectral analysis methods
    Let signal be Collections.CreateList[Float]()
    
    Note: Create signal with very small amplitude
    For i from 0 to 31:
        Let tiny_signal be 1e-12 * MathCore.cos(2.0 * MathCore.pi() * i / 32.0)
        Call signal.append(tiny_signal)
    
    Let estimate be Spectral.periodogram(signal, "rectangular", 32.0)
    
    Note: Should maintain precision for small signals
    Assert.IsTrue(estimate.power_spectral_density[1] > 0.0)  Note: Peak at bin 1
    
    Note: Test with very large amplitude
    Let large_signal be Collections.CreateList[Float]()
    For i from 0 to 31:
        Let big_signal be 1e12 * MathCore.sin(2.0 * MathCore.pi() * i / 32.0)
        Call large_signal.append(big_signal)
    
    Let large_estimate be Spectral.periodogram(large_signal, "rectangular", 32.0)
    
    Note: Should handle large signals without overflow
    Assert.IsTrue(MathCore.is_finite(large_estimate.power_spectral_density[1]))
    
    Return true