Note: Comprehensive unit tests for math/engine/fourier/fft module
Note: Tests Fast Fourier Transform algorithms and optimizations

Import "collections" as Collections
Import "math.core" as MathCore
Import "math.engine.fourier.fft" as FFT
Import "math.engine.fourier.dft" as DFT
Import "test.assertions" as Assert

Note: ========================================================================
Note: BASIC FFT ALGORITHM TESTS
Note: ========================================================================

Process called "test_fft_radix2_power_of_two" that takes no parameters returns Boolean:
    Note: Test radix-2 FFT with power-of-two input size
    Let input be Collections.CreateList[Complex]()
    
    Note: Create test signal: cos(2Ï€t) for 8 samples
    For i from 0 to 7:
        Let angle be 2.0 * MathCore.pi() * i / 8.0
        Call input.append(Complex with:
            real = MathCore.cos(angle)
            imag = 0.0)
    
    Let fft_result be FFT.fft_radix2(input, false)
    
    Note: Compare with direct DFT for verification
    Let dft_result be DFT.dft_direct(input)
    
    Assert.AreEqual(fft_result.length(), 8)
    
    Note: Verify FFT matches DFT within numerical precision
    For i from 0 to 7:
        Let error_real be MathCore.abs(fft_result[i].real - dft_result[i].real)
        Let error_imag be MathCore.abs(fft_result[i].imag - dft_result[i].imag)
        Assert.IsTrue(error_real < 1e-10)
        Assert.IsTrue(error_imag < 1e-10)
    
    Return true

Process called "test_fft_radix2_inverse" that takes no parameters returns Boolean:
    Note: Test radix-2 IFFT reconstruction accuracy
    Let original be Collections.CreateList[Complex]()
    
    Note: Create complex test signal
    For i from 0 to 7:
        Let real_part be MathCore.cos(2.0 * MathCore.pi() * i / 8.0)
        Let imag_part be MathCore.sin(2.0 * MathCore.pi() * i / 8.0) * 0.5
        Call original.append(Complex with:
            real = real_part
            imag = imag_part)
    
    Note: Forward FFT
    Let spectrum be FFT.fft_radix2(original, false)
    
    Note: Inverse FFT
    Let reconstructed be FFT.fft_radix2(spectrum, true)
    
    Note: Verify perfect reconstruction
    For i from 0 to 7:
        Let error_real be MathCore.abs(original[i].real - reconstructed[i].real)
        Let error_imag be MathCore.abs(original[i].imag - reconstructed[i].imag)
        Assert.IsTrue(error_real < 1e-10)
        Assert.IsTrue(error_imag < 1e-10)
    
    Return true

Process called "test_fft_radix2_non_power_of_two" that takes no parameters returns Boolean:
    Note: Test radix-2 FFT error handling for non-power-of-two sizes
    Let input be Collections.CreateList[Complex]()
    
    Note: Create input with size 6 (not power of 2)
    For i from 0 to 5:
        Call input.append(Complex with:
            real = i
            imag = 0.0)
    
    Try:
        Let result be FFT.fft_radix2(input, false)
        Assert.Fail("Expected exception for non-power-of-two input")
    Catch error:
        Assert.IsTrue(true)  Note: Expected to throw exception
    
    Return true

Process called "test_fft_radix4_algorithm" that takes no parameters returns Boolean:
    Note: Test radix-4 FFT algorithm implementation
    Let input be Collections.CreateList[Complex]()
    
    Note: Create test signal for size 16 (power of 4)
    For i from 0 to 15:
        Let real_part be MathCore.cos(2.0 * MathCore.pi() * 3.0 * i / 16.0)
        Call input.append(Complex with:
            real = real_part
            imag = 0.0)
    
    Let fft4_result be FFT.fft_radix4(input, false)
    Let fft2_result be FFT.fft_radix2(input, false)
    
    Note: Radix-4 should match radix-2 results
    Assert.AreEqual(fft4_result.length(), 16)
    
    For i from 0 to 15:
        Let error_real be MathCore.abs(fft4_result[i].real - fft2_result[i].real)
        Let error_imag be MathCore.abs(fft4_result[i].imag - fft2_result[i].imag)
        Assert.IsTrue(error_real < 1e-10)
        Assert.IsTrue(error_imag < 1e-10)
    
    Return true

Process called "test_fft_radix4_fallback" that takes no parameters returns Boolean:
    Note: Test radix-4 FFT fallback to radix-2 for non-multiple-of-4 sizes
    Let input be Collections.CreateList[Complex]()
    
    Note: Create input with size 8 (power of 2 but not 4)
    For i from 0 to 7:
        Call input.append(Complex with:
            real = i
            imag = i * 0.5)
    
    Let radix4_result be FFT.fft_radix4(input, false)
    Let radix2_result be FFT.fft_radix2(input, false)
    
    Note: Should produce identical results via fallback
    For i from 0 to 7:
        Let error_real be MathCore.abs(radix4_result[i].real - radix2_result[i].real)
        Let error_imag be MathCore.abs(radix4_result[i].imag - radix2_result[i].imag)
        Assert.IsTrue(error_real < 1e-10)
        Assert.IsTrue(error_imag < 1e-10)
    
    Return true

Note: ========================================================================
Note: FFT CONFIGURATION AND PLANNING TESTS
Note: ========================================================================

Process called "test_fft_config_creation" that takes no parameters returns Boolean:
    Note: Test FFT configuration structure
    Let config be FFT.FFTConfig with:
        algorithm_type = "radix2"
        use_simd = true
        use_parallel = false
        num_threads = 1
        memory_layout = "row_major"
        precision = "double"
    
    Assert.AreEqual(config.algorithm_type, "radix2")
    Assert.IsTrue(config.use_simd)
    Assert.IsFalse(config.use_parallel)
    Assert.AreEqual(config.num_threads, 1)
    Assert.AreEqual(config.memory_layout, "row_major")
    Assert.AreEqual(config.precision, "double")
    
    Return true

Process called "test_fft_plan_creation" that takes no parameters returns Boolean:
    Note: Test FFT plan initialization and setup
    Let size be 32
    Let config be FFT.FFTConfig with:
        algorithm_type = "radix2"
        use_simd = false
        use_parallel = false
        num_threads = 1
        memory_layout = "row_major"
        precision = "double"
    
    Let plan be FFT.create_fft_plan(size, config)
    
    Assert.AreEqual(plan.size, size)
    Assert.IsFalse(plan.is_initialized)
    
    Note: Initialize the plan
    Call FFT.initialize_fft_plan(plan)
    
    Assert.IsTrue(plan.is_initialized)
    Assert.IsTrue(plan.twiddle_factors.length() > 0)
    Assert.IsTrue(plan.bit_reversal_indices.length() > 0)
    
    Return true

Process called "test_fft_twiddle_factor_generation" that takes no parameters returns Boolean:
    Note: Test twiddle factor computation for FFT
    Let N be 8
    Let twiddle_factors be FFT.generate_twiddle_factors(N, false)
    
    Assert.AreEqual(twiddle_factors.length(), N)
    
    Note: Verify twiddle factor formula: W_N^k = exp(-j*2*pi*k/N)
    For k from 0 to N - 1:
        Let angle be -2.0 * MathCore.pi() * k / N
        Let expected_real be MathCore.cos(angle)
        Let expected_imag be MathCore.sin(angle)
        
        Let error_real be MathCore.abs(twiddle_factors[k].real - expected_real)
        Let error_imag be MathCore.abs(twiddle_factors[k].imag - expected_imag)
        
        Assert.IsTrue(error_real < 1e-14)
        Assert.IsTrue(error_imag < 1e-14)
    
    Return true

Process called "test_fft_bit_reversal_permutation" that takes no parameters returns Boolean:
    Note: Test bit-reversal permutation for FFT
    Let input be Collections.CreateList[Complex]()
    
    Note: Create sequential input for testing
    For i from 0 to 7:
        Call input.append(Complex with:
            real = i
            imag = 0.0)
    
    Let bit_reversed be FFT.bit_reverse_permutation(input)
    
    Note: Verify bit-reversal pattern for 8 elements
    Note: 0->0, 1->4, 2->2, 3->6, 4->1, 5->5, 6->3, 7->7
    Assert.AreEqual(bit_reversed[0].real, 0.0)  Note: 000 -> 000
    Assert.AreEqual(bit_reversed[1].real, 4.0)  Note: 001 -> 100
    Assert.AreEqual(bit_reversed[2].real, 2.0)  Note: 010 -> 010
    Assert.AreEqual(bit_reversed[3].real, 6.0)  Note: 011 -> 110
    Assert.AreEqual(bit_reversed[4].real, 1.0)  Note: 100 -> 001
    Assert.AreEqual(bit_reversed[5].real, 5.0)  Note: 101 -> 101
    Assert.AreEqual(bit_reversed[6].real, 3.0)  Note: 110 -> 011
    Assert.AreEqual(bit_reversed[7].real, 7.0)  Note: 111 -> 111
    
    Return true

Note: ========================================================================
Note: ADVANCED FFT FEATURES TESTS
Note: ========================================================================

Process called "test_fft_mixed_radix" that takes no parameters returns Boolean:
    Note: Test mixed-radix FFT for composite sizes
    Let input be Collections.CreateList[Complex]()
    
    Note: Create test signal for size 12 (2^2 * 3)
    For i from 0 to 11:
        Let angle be 2.0 * MathCore.pi() * i / 12.0
        Call input.append(Complex with:
            real = MathCore.cos(angle)
            imag = 0.0)
    
    Let mixed_radix_result be FFT.fft_mixed_radix(input, false)
    Let dft_result be DFT.dft_direct(input)
    
    Assert.AreEqual(mixed_radix_result.length(), 12)
    
    Note: Compare with DFT reference
    For i from 0 to 11:
        Let error_real be MathCore.abs(mixed_radix_result[i].real - dft_result[i].real)
        Let error_imag be MathCore.abs(mixed_radix_result[i].imag - dft_result[i].imag)
        Assert.IsTrue(error_real < 1e-10)
        Assert.IsTrue(error_imag < 1e-10)
    
    Return true

Process called "test_fft_prime_factor" that takes no parameters returns Boolean:
    Note: Test prime factor algorithm for specific sizes
    Let input be Collections.CreateList[Complex]()
    
    Note: Create test signal for size 15 (3 * 5)
    For i from 0 to 14:
        Let real_part be MathCore.sin(2.0 * MathCore.pi() * 2.0 * i / 15.0)
        Call input.append(Complex with:
            real = real_part
            imag = 0.0)
    
    Let pfa_result be FFT.fft_prime_factor(input, false)
    Let dft_result be DFT.dft_direct(input)
    
    Assert.AreEqual(pfa_result.length(), 15)
    
    Note: Verify accuracy against DFT
    For i from 0 to 14:
        Let error_real be MathCore.abs(pfa_result[i].real - dft_result[i].real)
        Let error_imag be MathCore.abs(pfa_result[i].imag - dft_result[i].imag)
        Assert.IsTrue(error_real < 1e-10)
        Assert.IsTrue(error_imag < 1e-10)
    
    Return true

Process called "test_fft_real_to_complex" that takes no parameters returns Boolean:
    Note: Test real-to-complex FFT optimization
    Let real_input be Collections.CreateList[Float]()
    
    Note: Create real-valued test signal
    For i from 0 to 15:
        Let value be MathCore.cos(2.0 * MathCore.pi() * i / 16.0) + 0.5 * MathCore.cos(4.0 * MathCore.pi() * i / 16.0)
        Call real_input.append(value)
    
    Let real_fft_result be FFT.rfft(real_input)
    
    Note: Real FFT should return N/2+1 complex values due to Hermitian symmetry
    Assert.AreEqual(real_fft_result.length(), 9)  Note: 16/2 + 1 = 9
    
    Note: Convert to complex input for comparison
    Let complex_input be Collections.CreateList[Complex]()
    For i from 0 to 15:
        Call complex_input.append(Complex with:
            real = real_input[i]
            imag = 0.0)
    
    Let complex_fft_result be FFT.fft_radix2(complex_input, false)
    
    Note: First N/2+1 elements should match
    For i from 0 to 8:
        Let error_real be MathCore.abs(real_fft_result[i].real - complex_fft_result[i].real)
        Let error_imag be MathCore.abs(real_fft_result[i].imag - complex_fft_result[i].imag)
        Assert.IsTrue(error_real < 1e-10)
        Assert.IsTrue(error_imag < 1e-10)
    
    Return true

Process called "test_fft_multidimensional_2d" that takes no parameters returns Boolean:
    Note: Test 2D FFT implementation
    Let rows be 4
    Let cols be 4
    Let input_2d be Collections.CreateList[List[Complex]]()
    
    Note: Create 2D test pattern
    For i from 0 to rows - 1:
        Let row be Collections.CreateList[Complex]()
        For j from 0 to cols - 1:
            Let value be MathCore.cos(2.0 * MathCore.pi() * i / rows) * MathCore.sin(2.0 * MathCore.pi() * j / cols)
            Call row.append(Complex with:
                real = value
                imag = 0.0)
        Call input_2d.append(row)
    
    Let fft_2d_result be FFT.fft_2d(input_2d, false)
    
    Note: Verify dimensions preserved
    Assert.AreEqual(fft_2d_result.length(), rows)
    Assert.AreEqual(fft_2d_result[0].length(), cols)
    
    Note: Verify separability: 2D FFT = FFT of rows, then FFT of columns
    Let row_wise_fft be Collections.CreateList[List[Complex]]()
    For i from 0 to rows - 1:
        Let row_fft be FFT.fft_radix2(input_2d[i], false)
        Call row_wise_fft.append(row_fft)
    
    Note: Basic verification that 2D FFT produces reasonable results
    Let total_energy_input be 0.0
    Let total_energy_output be 0.0
    
    For i from 0 to rows - 1:
        For j from 0 to cols - 1:
            Set total_energy_input to total_energy_input + input_2d[i][j].real * input_2d[i][j].real
            Set total_energy_output to total_energy_output + fft_2d_result[i][j].real * fft_2d_result[i][j].real + fft_2d_result[i][j].imag * fft_2d_result[i][j].imag
    
    Note: Energy should be preserved (Parseval's theorem)
    Let energy_ratio be total_energy_output / (total_energy_input * rows * cols)
    Assert.IsTrue(MathCore.abs(energy_ratio - 1.0) < 1e-10)
    
    Return true

Note: ========================================================================
Note: FFT OPTIMIZATION AND PERFORMANCE TESTS
Note: ========================================================================

Process called "test_fft_in_place_algorithm" that takes no parameters returns Boolean:
    Note: Test in-place FFT to verify memory efficiency
    Let input be Collections.CreateList[Complex]()
    Let original_copy be Collections.CreateList[Complex]()
    
    Note: Create test data and backup
    For i from 0 to 7:
        Let value be Complex with:
            real = MathCore.cos(2.0 * MathCore.pi() * i / 8.0)
            imag = MathCore.sin(2.0 * MathCore.pi() * i / 8.0)
        Call input.append(value)
        Call original_copy.append(value)
    
    Note: Perform in-place FFT
    Call FFT.fft_radix2_in_place(input, false)
    
    Note: Compare with out-of-place result
    Let out_of_place_result be FFT.fft_radix2(original_copy, false)
    
    For i from 0 to 7:
        Let error_real be MathCore.abs(input[i].real - out_of_place_result[i].real)
        Let error_imag be MathCore.abs(input[i].imag - out_of_place_result[i].imag)
        Assert.IsTrue(error_real < 1e-10)
        Assert.IsTrue(error_imag < 1e-10)
    
    Return true

Process called "test_fft_simd_acceleration" that takes no parameters returns Boolean:
    Note: Test SIMD-accelerated FFT implementation
    Let input be Collections.CreateList[Complex]()
    
    Note: Create larger dataset suitable for SIMD testing
    For i from 0 to 31:
        Let real_part be MathCore.cos(2.0 * MathCore.pi() * i / 32.0)
        Let imag_part be MathCore.sin(2.0 * MathCore.pi() * i / 32.0)
        Call input.append(Complex with:
            real = real_part
            imag = imag_part)
    
    Note: Test with SIMD enabled
    Let config_simd be FFT.FFTConfig with:
        algorithm_type = "radix2"
        use_simd = true
        use_parallel = false
        num_threads = 1
        memory_layout = "interleaved"
        precision = "double"
    
    Let simd_result be FFT.fft_with_config(input, false, config_simd)
    
    Note: Test with SIMD disabled for comparison
    Let config_no_simd be FFT.FFTConfig with:
        algorithm_type = "radix2"
        use_simd = false
        use_parallel = false
        num_threads = 1
        memory_layout = "row_major"
        precision = "double"
    
    Let no_simd_result be FFT.fft_with_config(input, false, config_no_simd)
    
    Note: Results should be identical regardless of SIMD usage
    For i from 0 to 31:
        Let error_real be MathCore.abs(simd_result[i].real - no_simd_result[i].real)
        Let error_imag be MathCore.abs(simd_result[i].imag - no_simd_result[i].imag)
        Assert.IsTrue(error_real < 1e-10)
        Assert.IsTrue(error_imag < 1e-10)
    
    Return true

Process called "test_fft_parallel_execution" that takes no parameters returns Boolean:
    Note: Test parallel FFT implementation
    Let input be Collections.CreateList[Complex]()
    
    Note: Create dataset large enough to benefit from parallelization
    For i from 0 to 127:
        Let angle1 be 2.0 * MathCore.pi() * 3.0 * i / 128.0
        Let angle2 be 2.0 * MathCore.pi() * 7.0 * i / 128.0
        Call input.append(Complex with:
            real = MathCore.cos(angle1) + 0.5 * MathCore.cos(angle2)
            imag = MathCore.sin(angle1) + 0.5 * MathCore.sin(angle2))
    
    Note: Test with parallel execution
    Let config_parallel be FFT.FFTConfig with:
        algorithm_type = "radix2"
        use_simd = false
        use_parallel = true
        num_threads = 4
        memory_layout = "row_major"
        precision = "double"
    
    Let parallel_result be FFT.fft_with_config(input, false, config_parallel)
    
    Note: Test with serial execution
    Let config_serial be FFT.FFTConfig with:
        algorithm_type = "radix2"
        use_simd = false
        use_parallel = false
        num_threads = 1
        memory_layout = "row_major"
        precision = "double"
    
    Let serial_result be FFT.fft_with_config(input, false, config_serial)
    
    Note: Results should be identical
    Assert.AreEqual(parallel_result.length(), 128)
    Assert.AreEqual(serial_result.length(), 128)
    
    For i from 0 to 127:
        Let error_real be MathCore.abs(parallel_result[i].real - serial_result[i].real)
        Let error_imag be MathCore.abs(parallel_result[i].imag - serial_result[i].imag)
        Assert.IsTrue(error_real < 1e-10)
        Assert.IsTrue(error_imag < 1e-10)
    
    Return true

Note: ========================================================================
Note: FFT RESULT ANALYSIS AND VALIDATION TESTS
Note: ========================================================================

Process called "test_fft_result_structure" that takes no parameters returns Boolean:
    Note: Test FFT result metadata and timing
    Let input be Collections.CreateList[Complex]()
    
    For i from 0 to 15:
        Call input.append(Complex with:
            real = MathCore.random()
            imag = MathCore.random())
    
    Let config be FFT.FFTConfig with:
        algorithm_type = "radix2"
        use_simd = false
        use_parallel = false
        num_threads = 1
        memory_layout = "row_major"
        precision = "double"
    
    Let result be FFT.fft_with_result_info(input, false, config)
    
    Assert.AreEqual(result.output.length(), 16)
    Assert.IsTrue(result.computation_time >= 0.0)
    Assert.IsTrue(result.memory_usage > 0)
    Assert.AreEqual(result.algorithm_used, "radix2")
    Assert.IsTrue(result.optimization_flags.length() >= 0)
    
    Return true

Process called "test_fft_algorithm_selection" that takes no parameters returns Boolean:
    Note: Test automatic algorithm selection based on input size
    Let sizes be Collections.CreateList[Integer]()
    Call sizes.append(8)   Note: Power of 2 - should use radix-2
    Call sizes.append(16)  Note: Power of 4 - could use radix-4
    Call sizes.append(12)  Note: Composite - should use mixed radix
    Call sizes.append(17)  Note: Prime - should use bluestein or DFT
    
    For size_index from 0 to 3:
        Let size be sizes[size_index]
        Let input be Collections.CreateList[Complex]()
        
        For i from 0 to size - 1:
            Call input.append(Complex with:
                real = MathCore.cos(2.0 * MathCore.pi() * i / size)
                imag = 0.0)
        
        Let auto_result be FFT.fft_auto_algorithm(input, false)
        Let dft_result be DFT.dft_direct(input)
        
        Note: Auto-selected algorithm should produce accurate results
        For i from 0 to size - 1:
            Let error_real be MathCore.abs(auto_result[i].real - dft_result[i].real)
            Let error_imag be MathCore.abs(auto_result[i].imag - dft_result[i].imag)
            Assert.IsTrue(error_real < 1e-9)
            Assert.IsTrue(error_imag < 1e-9)
    
    Return true

Process called "test_fft_numerical_stability" that takes no parameters returns Boolean:
    Note: Test FFT numerical stability with challenging signals
    Let input be Collections.CreateList[Complex]()
    
    Note: Create signal with wide dynamic range
    For i from 0 to 15:
        Let large_component be 1e6 * MathCore.cos(2.0 * MathCore.pi() * i / 16.0)
        Let small_component be 1e-6 * MathCore.sin(2.0 * MathCore.pi() * 3.0 * i / 16.0)
        Call input.append(Complex with:
            real = large_component + small_component
            imag = 0.0)
    
    Let fft_result be FFT.fft_radix2(input, false)
    
    Note: Check that FFT doesn't lose small components due to numerical issues
    Let has_significant_components be false
    For i from 0 to 15:
        Let magnitude be MathCore.sqrt(fft_result[i].real * fft_result[i].real + fft_result[i].imag * fft_result[i].imag)
        If magnitude > 1e-3:
            Set has_significant_components to true
    
    Assert.IsTrue(has_significant_components)
    
    Note: Verify inverse reconstruction maintains precision
    Let reconstructed be FFT.fft_radix2(fft_result, true)
    
    For i from 0 to 15:
        Let relative_error be MathCore.abs(input[i].real - reconstructed[i].real) / MathCore.abs(input[i].real)
        Assert.IsTrue(relative_error < 1e-12 or MathCore.abs(input[i].real - reconstructed[i].real) < 1e-12)
    
    Return true

Note: ========================================================================
Note: ERROR HANDLING AND EDGE CASES TESTS
Note: ========================================================================

Process called "test_fft_empty_input" that takes no parameters returns Boolean:
    Note: Test FFT behavior with empty input
    Let empty_input be Collections.CreateList[Complex]()
    
    Try:
        Let result be FFT.fft_radix2(empty_input, false)
        Assert.Fail("Expected exception for empty input")
    Catch error:
        Assert.IsTrue(true)  Note: Expected to throw exception
    
    Return true

Process called "test_fft_single_element" that takes no parameters returns Boolean:
    Note: Test FFT with single element
    Let input be Collections.CreateList[Complex]()
    Call input.append(Complex with:
        real = 3.14
        imag = 2.71)
    
    Let result be FFT.fft_radix2(input, false)
    
    Assert.AreEqual(result.length(), 1)
    Assert.AreEqual(result[0].real, 3.14)
    Assert.AreEqual(result[0].imag, 2.71)
    
    Return true

Process called "test_fft_very_large_input" that takes no parameters returns Boolean:
    Note: Test FFT with large input size for memory and performance
    Let size be 1024
    Let input be Collections.CreateList[Complex]()
    
    Note: Create large test signal
    For i from 0 to size - 1:
        Let angle be 2.0 * MathCore.pi() * 7.0 * i / size
        Call input.append(Complex with:
            real = MathCore.cos(angle)
            imag = MathCore.sin(angle))
    
    Let large_result be FFT.fft_radix2(input, false)
    
    Assert.AreEqual(large_result.length(), size)
    
    Note: Verify energy conservation (Parseval's theorem)
    Let input_energy be 0.0
    Let output_energy be 0.0
    
    For i from 0 to size - 1:
        Set input_energy to input_energy + input[i].real * input[i].real + input[i].imag * input[i].imag
        Set output_energy to output_energy + large_result[i].real * large_result[i].real + large_result[i].imag * large_result[i].imag
    
    Set output_energy to output_energy / size  Note: Normalize for FFT scaling
    Let energy_error be MathCore.abs(input_energy - output_energy) / input_energy
    Assert.IsTrue(energy_error < 1e-10)
    
    Return true

Process called "test_fft_plan_reuse" that takes no parameters returns Boolean:
    Note: Test FFT plan reuse for multiple transforms
    Let size be 16
    Let config be FFT.FFTConfig with:
        algorithm_type = "radix2"
        use_simd = false
        use_parallel = false
        num_threads = 1
        memory_layout = "row_major"
        precision = "double"
    
    Let plan be FFT.create_fft_plan(size, config)
    Call FFT.initialize_fft_plan(plan)
    
    Note: Perform multiple transforms with same plan
    For test_run from 0 to 4:
        Let input be Collections.CreateList[Complex]()
        
        For i from 0 to size - 1:
            Let phase_shift be 2.0 * MathCore.pi() * test_run / 5.0
            Let angle be 2.0 * MathCore.pi() * i / size + phase_shift
            Call input.append(Complex with:
                real = MathCore.cos(angle)
                imag = 0.0)
        
        Let result be FFT.fft_with_plan(input, false, plan)
        Assert.AreEqual(result.length(), size)
        
        Note: Verify plan state remains valid
        Assert.IsTrue(plan.is_initialized)
        Assert.AreEqual(plan.size, size)
    
    Note: Clean up plan
    Call FFT.destroy_fft_plan(plan)
    
    Return true