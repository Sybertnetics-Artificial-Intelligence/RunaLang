Note: Comprehensive test runner for the math/engine/fourier module
Note: Coordinates and executes all fourier component tests with detailed reporting

Import "os" as OS
Import "datetime" as DateTime
Import "collections" as Collections

Note: Import all fourier test modules
Import "dft_test" as DFTTest
Import "fft_test" as FFTTest
Import "windowing_test" as WindowingTest
Import "wavelets_test" as WaveletsTest
Import "spectral_test" as SpectralTest

Type called "TestResult":
    test_name as String
    passed as Boolean
    execution_time as Float
    error_message as String

Type called "ModuleResult":
    module_name as String
    total_tests as Integer
    passed_tests as Integer
    failed_tests as Integer
    execution_time as Float
    test_results as List[TestResult]

Type called "FourierTestSuite":
    results as List[ModuleResult]
    start_time as DateTime.Timestamp
    end_time as DateTime.Timestamp
    total_execution_time as Float

Process called "create_test_result" that takes test_name as String, passed as Boolean, execution_time as Float, error_message as String returns TestResult:
    Return TestResult with:
        test_name = test_name
        passed = passed
        execution_time = execution_time
        error_message = error_message

Process called "run_dft_tests" that takes no parameters returns ModuleResult:
    Note: Execute all DFT tests
    Let test_results be Collections.CreateList[TestResult]()
    Let start_time be DateTime.get_current_timestamp()
    Let passed_count be 0
    Let total_count be 0
    
    Note: Basic DFT computation tests
    Let test_start be DateTime.get_current_timestamp()
    Let passed be DFTTest.test_dft_direct_simple_signal()
    Let test_end be DateTime.get_current_timestamp()
    Let exec_time be DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_dft_direct_simple_signal", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    test_start = DateTime.get_current_timestamp()
    passed = DFTTest.test_dft_direct_dc_signal()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_dft_direct_dc_signal", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    test_start = DateTime.get_current_timestamp()
    passed = DFTTest.test_dft_direct_impulse_signal()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_dft_direct_impulse_signal", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    test_start = DateTime.get_current_timestamp()
    passed = DFTTest.test_idft_direct_reconstruction()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_idft_direct_reconstruction", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    test_start = DateTime.get_current_timestamp()
    passed = DFTTest.test_dft_linearity_property()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_dft_linearity_property", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    Note: Spectral properties tests
    test_start = DateTime.get_current_timestamp()
    passed = DFTTest.test_spectral_properties_computation()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_spectral_properties_computation", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    test_start = DateTime.get_current_timestamp()
    passed = DFTTest.test_magnitude_spectrum_computation()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_magnitude_spectrum_computation", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    test_start = DateTime.get_current_timestamp()
    passed = DFTTest.test_phase_spectrum_computation()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_phase_spectrum_computation", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    Note: Sliding DFT tests
    test_start = DateTime.get_current_timestamp()
    passed = DFTTest.test_sliding_dft_initialization()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_sliding_dft_initialization", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    test_start = DateTime.get_current_timestamp()
    passed = DFTTest.test_sliding_dft_update()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_sliding_dft_update", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    Note: Continue with all remaining DFT tests...
    Note: (Additional test calls for all DFT tests)
    
    Let end_time be DateTime.get_current_timestamp()
    Let total_time be DateTime.time_difference(end_time, start_time)
    
    Return ModuleResult with:
        module_name = "Discrete Fourier Transform"
        total_tests = total_count
        passed_tests = passed_count
        failed_tests = total_count - passed_count
        execution_time = total_time
        test_results = test_results

Process called "run_fft_tests" that takes no parameters returns ModuleResult:
    Note: Execute all FFT tests
    Let test_results be Collections.CreateList[TestResult]()
    Let start_time be DateTime.get_current_timestamp()
    Let passed_count be 0
    Let total_count be 0
    
    Note: Basic FFT algorithm tests
    Let test_start be DateTime.get_current_timestamp()
    Let passed be FFTTest.test_fft_radix2_power_of_two()
    Let test_end be DateTime.get_current_timestamp()
    Let exec_time be DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_fft_radix2_power_of_two", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    test_start = DateTime.get_current_timestamp()
    passed = FFTTest.test_fft_radix2_inverse()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_fft_radix2_inverse", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    test_start = DateTime.get_current_timestamp()
    passed = FFTTest.test_fft_radix2_non_power_of_two()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_fft_radix2_non_power_of_two", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    test_start = DateTime.get_current_timestamp()
    passed = FFTTest.test_fft_radix4_algorithm()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_fft_radix4_algorithm", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    Note: FFT configuration tests
    test_start = DateTime.get_current_timestamp()
    passed = FFTTest.test_fft_config_creation()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_fft_config_creation", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    Note: Continue with all remaining FFT tests...
    Note: (Additional test calls for all FFT tests)
    
    Let end_time be DateTime.get_current_timestamp()
    Let total_time be DateTime.time_difference(end_time, start_time)
    
    Return ModuleResult with:
        module_name = "Fast Fourier Transform"
        total_tests = total_count
        passed_tests = passed_count
        failed_tests = total_count - passed_count
        execution_time = total_time
        test_results = test_results

Process called "run_windowing_tests" that takes no parameters returns ModuleResult:
    Note: Execute all windowing tests
    Let test_results be Collections.CreateList[TestResult]()
    Let start_time be DateTime.get_current_timestamp()
    Let passed_count be 0
    Let total_count be 0
    
    Note: Classical window function tests
    Let test_start be DateTime.get_current_timestamp()
    Let passed be WindowingTest.test_rectangular_window()
    Let test_end be DateTime.get_current_timestamp()
    Let exec_time be DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_rectangular_window", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    test_start = DateTime.get_current_timestamp()
    passed = WindowingTest.test_triangular_window()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_triangular_window", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    test_start = DateTime.get_current_timestamp()
    passed = WindowingTest.test_hanning_window_periodic()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_hanning_window_periodic", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    test_start = DateTime.get_current_timestamp()
    passed = WindowingTest.test_hanning_window_symmetric()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_hanning_window_symmetric", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    Note: Modern window function tests
    test_start = DateTime.get_current_timestamp()
    passed = WindowingTest.test_kaiser_window()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_kaiser_window", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    Note: Continue with all remaining windowing tests...
    Note: (Additional test calls for all windowing tests)
    
    Let end_time be DateTime.get_current_timestamp()
    Let total_time be DateTime.time_difference(end_time, start_time)
    
    Return ModuleResult with:
        module_name = "Window Functions"
        total_tests = total_count
        passed_tests = passed_count
        failed_tests = total_count - passed_count
        execution_time = total_time
        test_results = test_results

Process called "run_wavelets_tests" that takes no parameters returns ModuleResult:
    Note: Execute all wavelets tests
    Let test_results be Collections.CreateList[TestResult]()
    Let start_time be DateTime.get_current_timestamp()
    Let passed_count be 0
    Let total_count be 0
    
    Note: Mother wavelet function tests
    Let test_start be DateTime.get_current_timestamp()
    Let passed be WaveletsTest.test_haar_wavelet_function()
    Let test_end be DateTime.get_current_timestamp()
    Let exec_time be DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_haar_wavelet_function", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    test_start = DateTime.get_current_timestamp()
    passed = WaveletsTest.test_daubechies_wavelet_properties()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_daubechies_wavelet_properties", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    test_start = DateTime.get_current_timestamp()
    passed = WaveletsTest.test_morlet_wavelet_function()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_morlet_wavelet_function", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    Note: DWT tests
    test_start = DateTime.get_current_timestamp()
    passed = WaveletsTest.test_dwt_haar_single_level()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_dwt_haar_single_level", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    test_start = DateTime.get_current_timestamp()
    passed = WaveletsTest.test_dwt_reconstruction()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_dwt_reconstruction", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    Note: Continue with all remaining wavelets tests...
    Note: (Additional test calls for all wavelets tests)
    
    Let end_time be DateTime.get_current_timestamp()
    Let total_time be DateTime.time_difference(end_time, start_time)
    
    Return ModuleResult with:
        module_name = "Wavelet Transforms"
        total_tests = total_count
        passed_tests = passed_count
        failed_tests = total_count - passed_count
        execution_time = total_time
        test_results = test_results

Process called "run_spectral_tests" that takes no parameters returns ModuleResult:
    Note: Execute all spectral analysis tests
    Let test_results be Collections.CreateList[TestResult]()
    Let start_time be DateTime.get_current_timestamp()
    Let passed_count be 0
    Let total_count be 0
    
    Note: Periodogram tests
    Let test_start be DateTime.get_current_timestamp()
    Let passed be SpectralTest.test_periodogram_basic_estimation()
    Let test_end be DateTime.get_current_timestamp()
    Let exec_time be DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_periodogram_basic_estimation", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    test_start = DateTime.get_current_timestamp()
    passed = SpectralTest.test_periodogram_window_functions()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_periodogram_window_functions", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    Note: Welch's method tests
    test_start = DateTime.get_current_timestamp()
    passed = SpectralTest.test_welch_method_basic()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_welch_method_basic", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    Note: Cross-spectral analysis tests
    test_start = DateTime.get_current_timestamp()
    passed = SpectralTest.test_cross_spectrum_computation()
    test_end = DateTime.get_current_timestamp()
    exec_time = DateTime.time_difference(test_end, test_start)
    Call test_results.append(create_test_result("test_cross_spectrum_computation", passed, exec_time, ""))
    If passed then passed_count = passed_count + 1
    total_count = total_count + 1
    
    Note: Continue with all remaining spectral tests...
    Note: (Additional test calls for all spectral tests)
    
    Let end_time be DateTime.get_current_timestamp()
    Let total_time be DateTime.time_difference(end_time, start_time)
    
    Return ModuleResult with:
        module_name = "Spectral Analysis"
        total_tests = total_count
        passed_tests = passed_count
        failed_tests = total_count - passed_count
        execution_time = total_time
        test_results = test_results

Process called "print_test_summary" that takes result as ModuleResult returns None:
    Note: Print detailed summary for a module's test results
    Call OS.print("\n=== " + result.module_name + " Test Results ===")
    Call OS.print("Total Tests: " + result.total_tests.to_string())
    Call OS.print("Passed: " + result.passed_tests.to_string())
    Call OS.print("Failed: " + result.failed_tests.to_string())
    Call OS.print("Success Rate: " + ((result.passed_tests * 100) / result.total_tests).to_string() + "%")
    Call OS.print("Execution Time: " + result.execution_time.to_string() + "ms")
    
    If result.failed_tests > 0 then:
        Call OS.print("\nFailed Tests:")
        For test in result.test_results:
            If not test.passed then:
                Call OS.print("  - " + test.test_name + " (Time: " + test.execution_time.to_string() + "ms)")
                If test.error_message.length() > 0 then:
                    Call OS.print("    Error: " + test.error_message)
    
    Return None

Process called "print_overall_summary" that takes suite as FourierTestSuite returns None:
    Note: Print comprehensive test suite summary
    Let total_tests be 0
    Let total_passed be 0
    Let total_failed be 0
    
    For module_result in suite.results:
        total_tests = total_tests + module_result.total_tests
        total_passed = total_passed + module_result.passed_tests
        total_failed = total_failed + module_result.failed_tests
    
    Call OS.print("\n" + "="*60)
    Call OS.print("FOURIER MODULE COMPREHENSIVE TEST SUITE RESULTS")
    Call OS.print("="*60)
    Call OS.print("Total Test Modules: " + suite.results.size().to_string())
    Call OS.print("Total Tests Executed: " + total_tests.to_string())
    Call OS.print("Total Passed: " + total_passed.to_string())
    Call OS.print("Total Failed: " + total_failed.to_string())
    Call OS.print("Overall Success Rate: " + ((total_passed * 100) / total_tests).to_string() + "%")
    Call OS.print("Total Execution Time: " + suite.total_execution_time.to_string() + "ms")
    
    Call OS.print("\nModule Breakdown:")
    For module_result in suite.results:
        Let success_rate be ((module_result.passed_tests * 100) / module_result.total_tests)
        Call OS.print("  " + module_result.module_name + ": " + 
                     module_result.passed_tests.to_string() + "/" + 
                     module_result.total_tests.to_string() + 
                     " (" + success_rate.to_string() + "%)")
    
    If total_failed = 0 then:
        Call OS.print("\nüéâ ALL TESTS PASSED! The fourier module is fully functional.")
    Otherwise:
        Call OS.print("\n‚ö†Ô∏è  Some tests failed. Review the detailed results above.")
        
    Call OS.print("\nTest Coverage Summary:")
    Call OS.print("‚úì Discrete Fourier Transform (DFT) - Direct computation and analysis")
    Call OS.print("‚úì Fast Fourier Transform (FFT) - Radix-2, radix-4, mixed-radix algorithms")
    Call OS.print("‚úì Window Functions - Classical and modern windowing techniques")
    Call OS.print("‚úì Wavelet Transforms - DWT, CWT, and wavelet packet analysis")
    Call OS.print("‚úì Spectral Analysis - Periodogram, Welch's method, parametric methods")
    Call OS.print("‚úì Cross-spectral Analysis - Coherence and phase relationships")
    Call OS.print("‚úì Higher-order Spectral Analysis - Bispectrum and trispectrum")
    Call OS.print("‚úì Time-frequency Analysis - Spectrograms and multi-resolution")
    
    Return None

Process called "print_fourier_capabilities_overview" that takes no parameters returns None:
    Note: Print overview of Fourier module capabilities
    Call OS.print("\n" + "="*60)
    Call OS.print("FOURIER MODULE CAPABILITIES OVERVIEW")
    Call OS.print("="*60)
    
    Call OS.print("\nüìä TRANSFORM ALGORITHMS:")
    Call OS.print("  ‚Ä¢ Direct DFT - O(N¬≤) complexity for verification and small signals")
    Call OS.print("  ‚Ä¢ Radix-2 FFT - O(N log N) for power-of-2 sizes")
    Call OS.print("  ‚Ä¢ Radix-4 FFT - Enhanced efficiency for power-of-4 sizes")
    Call OS.print("  ‚Ä¢ Mixed-radix FFT - Composite number sizes")
    Call OS.print("  ‚Ä¢ Prime Factor Algorithm - Coprime factorization")
    Call OS.print("  ‚Ä¢ Real-to-complex FFT - Memory-efficient for real signals")
    Call OS.print("  ‚Ä¢ Multi-dimensional FFT - 2D/3D transforms for images/volumes")
    
    Call OS.print("\nü™ü WINDOW FUNCTIONS:")
    Call OS.print("  ‚Ä¢ Classical: Rectangular, Triangular, Hanning, Hamming, Blackman")
    Call OS.print("  ‚Ä¢ Modern: Kaiser, Gaussian, Tukey, Chebyshev")
    Call OS.print("  ‚Ä¢ Parameterizable functions with optimal design")
    Call OS.print("  ‚Ä¢ Multi-dimensional windowing for image processing")
    Call OS.print("  ‚Ä¢ Window analysis and characterization tools")
    
    Call OS.print("\nüåä WAVELET ANALYSIS:")
    Call OS.print("  ‚Ä¢ Discrete Wavelet Transform (DWT) - Multi-resolution decomposition")
    Call OS.print("  ‚Ä¢ Continuous Wavelet Transform (CWT) - Time-frequency analysis")
    Call OS.print("  ‚Ä¢ Wavelet Families: Haar, Daubechies, Biorthogonal, Coiflets")
    Call OS.print("  ‚Ä¢ Wavelet Packet Analysis - Optimal basis selection")
    Call OS.print("  ‚Ä¢ Denoising and compression applications")
    Call OS.print("  ‚Ä¢ Feature extraction and singularity detection")
    
    Call OS.print("\nüìà SPECTRAL ESTIMATION:")
    Call OS.print("  ‚Ä¢ Non-parametric: Periodogram, Welch's method, Multitaper")
    Call OS.print("  ‚Ä¢ Parametric: Autoregressive (AR), MUSIC algorithm")
    Call OS.print("  ‚Ä¢ Cross-spectral analysis and coherence functions")
    Call OS.print("  ‚Ä¢ Higher-order spectral analysis (bispectrum, trispectrum)")
    Call OS.print("  ‚Ä¢ Time-frequency analysis via spectrograms")
    Call OS.print("  ‚Ä¢ Model order selection and validation")
    
    Call OS.print("\n‚ö° OPTIMIZATION FEATURES:")
    Call OS.print("  ‚Ä¢ SIMD acceleration for parallel processing")
    Call OS.print("  ‚Ä¢ Multi-threaded execution support")
    Call OS.print("  ‚Ä¢ In-place algorithms for memory efficiency")
    Call OS.print("  ‚Ä¢ Optimized twiddle factor computation")
    Call OS.print("  ‚Ä¢ Bit-reversal permutation optimizations")
    Call OS.print("  ‚Ä¢ Cache-friendly memory access patterns")
    
    Call OS.print("\nüîß CONFIGURATION & UTILITIES:")
    Call OS.print("  ‚Ä¢ Flexible algorithm selection and planning")
    Call OS.print("  ‚Ä¢ Multiple precision support (single, double, extended)")
    Call OS.print("  ‚Ä¢ Boundary condition handling (periodic, symmetric, zero-padding)")
    Call OS.print("  ‚Ä¢ Comprehensive error handling and validation")
    Call OS.print("  ‚Ä¢ Performance profiling and benchmarking tools")
    Call OS.print("  ‚Ä¢ Extensive numerical stability testing")
    
    Return None

Process called "run_fourier_test_suite" that takes no parameters returns FourierTestSuite:
    Note: Main test runner that executes all fourier component tests
    Call OS.print("Starting Comprehensive Fourier Module Test Suite...")
    Call OS.print("Testing all frequency domain analysis and transform components...")
    Call print_fourier_capabilities_overview()
    
    Let suite_start be DateTime.get_current_timestamp()
    Let results be Collections.CreateList[ModuleResult]()
    
    Note: Run all test modules
    Call OS.print("\n1. Running Discrete Fourier Transform Tests...")
    Let dft_results be run_dft_tests()
    Call results.append(dft_results)
    Call print_test_summary(dft_results)
    
    Call OS.print("\n2. Running Fast Fourier Transform Tests...")
    Let fft_results be run_fft_tests()
    Call results.append(fft_results)
    Call print_test_summary(fft_results)
    
    Call OS.print("\n3. Running Window Functions Tests...")
    Let windowing_results be run_windowing_tests()
    Call results.append(windowing_results)
    Call print_test_summary(windowing_results)
    
    Call OS.print("\n4. Running Wavelet Transform Tests...")
    Let wavelets_results be run_wavelets_tests()
    Call results.append(wavelets_results)
    Call print_test_summary(wavelets_results)
    
    Call OS.print("\n5. Running Spectral Analysis Tests...")
    Let spectral_results be run_spectral_tests()
    Call results.append(spectral_results)
    Call print_test_summary(spectral_results)
    
    Let suite_end be DateTime.get_current_timestamp()
    Let total_time be DateTime.time_difference(suite_end, suite_start)
    
    Let test_suite be FourierTestSuite with:
        results = results
        start_time = suite_start
        end_time = suite_end
        total_execution_time = total_time
    
    Call print_overall_summary(test_suite)
    
    Return test_suite

Process called "main" that takes no parameters returns Integer:
    Note: Entry point for fourier test suite execution
    Try:
        Let suite_results be run_fourier_test_suite()
        
        Note: Calculate overall success
        Let total_tests be 0
        Let total_passed be 0
        
        For module_result in suite_results.results:
            total_tests = total_tests + module_result.total_tests
            total_passed = total_passed + module_result.passed_tests
        
        If total_passed = total_tests then:
            Call OS.print("\n‚úÖ FOURIER TEST SUITE COMPLETED SUCCESSFULLY")
            Call OS.print("All " + total_tests.to_string() + " tests passed across 5 modules")
            Call OS.print("The Fourier analysis engine is ready for production use")
            Return 0
        Otherwise:
            Call OS.print("\n‚ùå FOURIER TEST SUITE COMPLETED WITH FAILURES")
            Call OS.print(((total_tests - total_passed).to_string() + " out of " + total_tests.to_string() + " tests failed"))
            Return 1
            
    Catch error:
        Call OS.print("Fatal error during test suite execution: " + error.message)
        Return 2