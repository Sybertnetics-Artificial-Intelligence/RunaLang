Note: Comprehensive unit tests for math/engine/fourier/dft module
Note: Tests direct Discrete Fourier Transform implementations and analysis

Import "collections" as Collections
Import "math.core" as MathCore
Import "math.engine.fourier.dft" as DFT
Import "test.assertions" as Assert

Note: ========================================================================
Note: BASIC DFT COMPUTATION TESTS
Note: ========================================================================

Process called "test_dft_direct_simple_signal" that takes no parameters returns Boolean:
    Note: Test direct DFT on simple sinusoidal signal
    Let input be Collections.CreateList[Complex]()
    
    Note: Create a simple cosine wave at frequency 1 Hz, 8 samples
    For i from 0 to 7:
        Let angle be 2.0 * MathCore.pi() * i / 8.0
        Let real_part be MathCore.cos(angle)
        Call input.append(Complex with:
            real = real_part
            imag = 0.0)
    
    Let result be DFT.dft_direct(input)
    
    Note: Verify output length
    Assert.AreEqual(result.length(), 8)
    
    Note: For cosine wave at frequency 1, expect peaks at k=1 and k=7 (N-1)
    Assert.IsTrue(MathCore.abs(result[1].real) > 3.5)  Note: Should be ~4.0
    Assert.IsTrue(MathCore.abs(result[7].real) > 3.5)  Note: Should be ~4.0
    Assert.IsTrue(MathCore.abs(result[0].real) < 0.1)  Note: DC component should be small
    
    Return true

Process called "test_dft_direct_dc_signal" that takes no parameters returns Boolean:
    Note: Test DFT on DC (constant) signal
    Let input be Collections.CreateList[Complex]()
    
    Note: Create constant signal with amplitude 2.0
    For i from 0 to 7:
        Call input.append(Complex with:
            real = 2.0
            imag = 0.0)
    
    Let result be DFT.dft_direct(input)
    
    Note: All energy should be at DC (k=0)
    Assert.AreEqual(result[0].real, 16.0)  Note: 8 samples * 2.0 amplitude
    Assert.AreEqual(result[0].imag, 0.0)
    
    Note: All other frequencies should be zero
    For k from 1 to 7:
        Assert.IsTrue(MathCore.abs(result[k].real) < 0.001)
        Assert.IsTrue(MathCore.abs(result[k].imag) < 0.001)
    
    Return true

Process called "test_dft_direct_impulse_signal" that takes no parameters returns Boolean:
    Note: Test DFT on impulse signal (delta function)
    Let input be Collections.CreateList[Complex]()
    
    Note: Create impulse at n=0
    For i from 0 to 7:
        Let amplitude be if i == 0 then 1.0 else 0.0
        Call input.append(Complex with:
            real = amplitude
            imag = 0.0)
    
    Let result be DFT.dft_direct(input)
    
    Note: Impulse should have flat spectrum (all frequencies equal)
    For k from 0 to 7:
        Assert.AreEqual(result[k].real, 1.0)
        Assert.AreEqual(result[k].imag, 0.0)
    
    Return true

Process called "test_idft_direct_reconstruction" that takes no parameters returns Boolean:
    Note: Test inverse DFT reconstructs original signal
    Let original be Collections.CreateList[Complex]()
    
    Note: Create test signal with multiple frequency components
    For i from 0 to 7:
        Let t be i / 8.0
        Let signal_value be MathCore.cos(2.0 * MathCore.pi() * t) + 0.5 * MathCore.sin(4.0 * MathCore.pi() * t)
        Call original.append(Complex with:
            real = signal_value
            imag = 0.0)
    
    Note: Forward transform
    Let spectrum be DFT.dft_direct(original)
    
    Note: Inverse transform
    Let reconstructed be DFT.idft_direct(spectrum)
    
    Note: Check reconstruction accuracy
    For i from 0 to 7:
        Let error_real be MathCore.abs(original[i].real - reconstructed[i].real)
        Let error_imag be MathCore.abs(original[i].imag - reconstructed[i].imag)
        Assert.IsTrue(error_real < 1e-10)
        Assert.IsTrue(error_imag < 1e-10)
    
    Return true

Process called "test_dft_linearity_property" that takes no parameters returns Boolean:
    Note: Test DFT linearity: DFT(ax + by) = a*DFT(x) + b*DFT(y)
    Let signal1 be Collections.CreateList[Complex]()
    Let signal2 be Collections.CreateList[Complex]()
    
    Note: Create two different signals
    For i from 0 to 3:
        Let t be i / 4.0
        Call signal1.append(Complex with:
            real = MathCore.cos(2.0 * MathCore.pi() * t)
            imag = 0.0)
        Call signal2.append(Complex with:
            real = MathCore.sin(2.0 * MathCore.pi() * t)
            imag = 0.0)
    
    Let a be 2.0
    Let b be 3.0
    
    Note: Compute DFT(ax + by)
    Let combined_signal be Collections.CreateList[Complex]()
    For i from 0 to 3:
        Call combined_signal.append(Complex with:
            real = a * signal1[i].real + b * signal2[i].real
            imag = a * signal1[i].imag + b * signal2[i].imag)
    Let dft_combined be DFT.dft_direct(combined_signal)
    
    Note: Compute a*DFT(x) + b*DFT(y)
    Let dft1 be DFT.dft_direct(signal1)
    Let dft2 be DFT.dft_direct(signal2)
    
    Note: Verify linearity
    For k from 0 to 3:
        Let expected_real be a * dft1[k].real + b * dft2[k].real
        Let expected_imag be a * dft1[k].imag + b * dft2[k].imag
        Let error_real be MathCore.abs(dft_combined[k].real - expected_real)
        Let error_imag be MathCore.abs(dft_combined[k].imag - expected_imag)
        Assert.IsTrue(error_real < 1e-10)
        Assert.IsTrue(error_imag < 1e-10)
    
    Return true

Note: ========================================================================
Note: SPECTRAL PROPERTIES TESTS
Note: ========================================================================

Process called "test_spectral_properties_computation" that takes no parameters returns Boolean:
    Note: Test computation of spectral properties from DFT
    Let input be Collections.CreateList[Float]()
    
    Note: Create signal with known spectral properties
    For i from 0 to 127:
        Let t be i / 128.0
        Let amplitude1 be 2.0 * MathCore.cos(2.0 * MathCore.pi() * 10.0 * t)
        Let amplitude2 be 1.0 * MathCore.cos(2.0 * MathCore.pi() * 25.0 * t)
        Call input.append(amplitude1 + amplitude2)
    
    Let sampling_rate be 128.0
    Let properties be DFT.compute_spectral_properties(input, sampling_rate)
    
    Note: Verify basic properties exist
    Assert.IsTrue(properties.peak_frequency > 0.0)
    Assert.IsTrue(properties.peak_magnitude > 0.0)
    Assert.IsTrue(properties.spectral_centroid > 0.0)
    Assert.IsTrue(properties.spectral_bandwidth > 0.0)
    
    Return true

Process called "test_magnitude_spectrum_computation" that takes no parameters returns Boolean:
    Note: Test magnitude spectrum computation
    Let input be Collections.CreateList[Complex]()
    
    Note: Create complex signal with known magnitude
    For i from 0 to 7:
        Call input.append(Complex with:
            real = 3.0
            imag = 4.0)
    
    Let spectrum be DFT.dft_direct(input)
    Let magnitudes be DFT.compute_magnitude_spectrum(spectrum)
    
    Assert.AreEqual(magnitudes.length(), 8)
    
    Note: Verify magnitude computation: |a + bi| = sqrt(a^2 + b^2)
    For i from 0 to 7:
        Let expected_magnitude be MathCore.sqrt(spectrum[i].real * spectrum[i].real + spectrum[i].imag * spectrum[i].imag)
        Let error be MathCore.abs(magnitudes[i] - expected_magnitude)
        Assert.IsTrue(error < 1e-10)
    
    Return true

Process called "test_phase_spectrum_computation" that takes no parameters returns Boolean:
    Note: Test phase spectrum computation
    Let input be Collections.CreateList[Complex]()
    
    Note: Create signal with known phase relationships
    For i from 0 to 7:
        Let angle be MathCore.pi() / 4.0  Note: 45 degrees
        Call input.append(Complex with:
            real = MathCore.cos(angle)
            imag = MathCore.sin(angle))
    
    Let spectrum be DFT.dft_direct(input)
    Let phases be DFT.compute_phase_spectrum(spectrum)
    
    Assert.AreEqual(phases.length(), 8)
    
    Note: Verify phase computation: phase = atan2(imag, real)
    For i from 0 to 7:
        Let expected_phase be MathCore.atan2(spectrum[i].imag, spectrum[i].real)
        Let error be MathCore.abs(phases[i] - expected_phase)
        Assert.IsTrue(error < 1e-10)
    
    Return true

Note: ========================================================================
Note: SLIDING DFT TESTS
Note: ========================================================================

Process called "test_sliding_dft_initialization" that takes no parameters returns Boolean:
    Note: Test sliding DFT state initialization
    Let window_size be 8
    Let sliding_dft be DFT.create_sliding_dft(window_size)
    
    Assert.AreEqual(sliding_dft.window_size, window_size)
    Assert.AreEqual(sliding_dft.buffer.length(), window_size)
    Assert.AreEqual(sliding_dft.spectrum.length(), window_size)
    Assert.IsFalse(sliding_dft.is_initialized)
    
    Return true

Process called "test_sliding_dft_update" that takes no parameters returns Boolean:
    Note: Test sliding DFT sample update mechanism
    Let window_size be 4
    Let sliding_dft be DFT.create_sliding_dft(window_size)
    
    Note: Add initial samples
    For i from 0 to 3:
        Call DFT.sliding_dft_update(sliding_dft, i)
    
    Assert.IsTrue(sliding_dft.is_initialized)
    
    Note: Verify buffer contents
    For i from 0 to 3:
        Assert.AreEqual(sliding_dft.buffer[i], i)
    
    Note: Add one more sample (should shift buffer)
    Call DFT.sliding_dft_update(sliding_dft, 4)
    
    Note: Verify sliding behavior
    Assert.AreEqual(sliding_dft.buffer[0], 1)
    Assert.AreEqual(sliding_dft.buffer[1], 2)
    Assert.AreEqual(sliding_dft.buffer[2], 3)
    Assert.AreEqual(sliding_dft.buffer[3], 4)
    
    Return true

Process called "test_sliding_dft_spectrum_accuracy" that takes no parameters returns Boolean:
    Note: Test sliding DFT spectrum computation accuracy
    Let window_size be 8
    Let sliding_dft be DFT.create_sliding_dft(window_size)
    
    Note: Fill with test data
    Let test_data be Collections.CreateList[Float]()
    For i from 0 to 7:
        Let value be MathCore.cos(2.0 * MathCore.pi() * i / 8.0)
        Call test_data.append(value)
        Call DFT.sliding_dft_update(sliding_dft, value)
    
    Note: Compute reference DFT
    Let input be Collections.CreateList[Complex]()
    For i from 0 to 7:
        Call input.append(Complex with:
            real = test_data[i]
            imag = 0.0)
    Let reference_spectrum be DFT.dft_direct(input)
    
    Note: Compare with sliding DFT result
    Let sliding_spectrum be DFT.get_sliding_dft_spectrum(sliding_dft)
    
    For k from 0 to 7:
        Let error_real be MathCore.abs(sliding_spectrum[k].real - reference_spectrum[k].real)
        Let error_imag be MathCore.abs(sliding_spectrum[k].imag - reference_spectrum[k].imag)
        Assert.IsTrue(error_real < 1e-10)
        Assert.IsTrue(error_imag < 1e-10)
    
    Return true

Note: ========================================================================
Note: DFT CONFIGURATION AND OPTIMIZATION TESTS
Note: ========================================================================

Process called "test_dft_config_creation" that takes no parameters returns Boolean:
    Note: Test DFT configuration structure
    Let config be DFT.DFTConfig with:
        zero_padding = true
        normalize = false
        window_function = "hanning"
        frequency_range = Collections.CreateList[Float]()
        dc_component = true
    
    Assert.IsTrue(config.zero_padding)
    Assert.IsFalse(config.normalize)
    Assert.AreEqual(config.window_function, "hanning")
    Assert.IsTrue(config.dc_component)
    
    Return true

Process called "test_dft_with_zero_padding" that takes no parameters returns Boolean:
    Note: Test DFT with zero padding for improved frequency resolution
    Let input be Collections.CreateList[Complex]()
    
    Note: Create short signal
    For i from 0 to 3:
        Call input.append(Complex with:
            real = MathCore.cos(2.0 * MathCore.pi() * i / 4.0)
            imag = 0.0)
    
    Note: Apply zero padding (double the length)
    Let padded_input be DFT.apply_zero_padding(input, 8)
    
    Assert.AreEqual(padded_input.length(), 8)
    
    Note: Verify original samples preserved
    For i from 0 to 3:
        Assert.AreEqual(padded_input[i].real, input[i].real)
        Assert.AreEqual(padded_input[i].imag, input[i].imag)
    
    Note: Verify zero padding
    For i from 4 to 7:
        Assert.AreEqual(padded_input[i].real, 0.0)
        Assert.AreEqual(padded_input[i].imag, 0.0)
    
    Return true

Process called "test_dft_normalization" that takes no parameters returns Boolean:
    Note: Test DFT output normalization
    Let input be Collections.CreateList[Complex]()
    
    Note: Create unity amplitude signal
    For i from 0 to 7:
        Call input.append(Complex with:
            real = 1.0
            imag = 0.0)
    
    Let unnormalized_result be DFT.dft_direct(input)
    Let normalized_result be DFT.dft_direct_normalized(input)
    
    Note: Unnormalized DC should be N (8)
    Assert.AreEqual(unnormalized_result[0].real, 8.0)
    
    Note: Normalized DC should be 1
    Assert.AreEqual(normalized_result[0].real, 1.0)
    
    Return true

Note: ========================================================================
Note: FREQUENCY DOMAIN ANALYSIS TESTS
Note: ========================================================================

Process called "test_frequency_bin_calculation" that takes no parameters returns Boolean:
    Note: Test frequency bin calculation from DFT parameters
    Let N be 16
    Let sampling_rate be 1000.0
    
    Let frequencies be DFT.compute_frequency_bins(N, sampling_rate)
    
    Assert.AreEqual(frequencies.length(), N)
    
    Note: Check frequency spacing
    Let expected_spacing be sampling_rate / N
    For i from 1 to N - 1:
        Let spacing be frequencies[i] - frequencies[i-1]
        Let error be MathCore.abs(spacing - expected_spacing)
        Assert.IsTrue(error < 1e-10)
    
    Note: Check Nyquist frequency (at N/2)
    Let nyquist_freq be sampling_rate / 2.0
    Assert.AreEqual(frequencies[N/2], nyquist_freq)
    
    Return true

Process called "test_dft_result_structure" that takes no parameters returns Boolean:
    Note: Test DFT result data structure completeness
    Let input be Collections.CreateList[Float]()
    For i from 0 to 15:
        Call input.append(MathCore.cos(2.0 * MathCore.pi() * i / 16.0))
    
    Let sampling_rate be 16.0
    Let result be DFT.compute_dft_analysis(input, sampling_rate)
    
    Assert.AreEqual(result.frequencies.length(), 16)
    Assert.AreEqual(result.magnitudes.length(), 16)
    Assert.AreEqual(result.phases.length(), 16)
    Assert.AreEqual(result.complex_spectrum.length(), 16)
    Assert.AreEqual(result.sampling_rate, sampling_rate)
    Assert.IsTrue(result.frequency_resolution > 0.0)
    
    Return true

Process called "test_windowing_effects_analysis" that takes no parameters returns Boolean:
    Note: Test analysis of windowing effects on DFT
    Let input be Collections.CreateList[Float]()
    
    Note: Create signal with spectral leakage potential
    For i from 0 to 31:
        Let t be i / 32.0
        Let frequency be 3.5  Note: Non-integer multiple of bin frequency
        Call input.append(MathCore.cos(2.0 * MathCore.pi() * frequency * t))
    
    Let rectangular_result be DFT.analyze_with_window(input, "rectangular")
    Let hanning_result be DFT.analyze_with_window(input, "hanning")
    
    Note: Hanning window should reduce spectral leakage
    Let rect_leakage be DFT.compute_spectral_leakage(rectangular_result)
    Let hann_leakage be DFT.compute_spectral_leakage(hanning_result)
    
    Assert.IsTrue(hann_leakage < rect_leakage)
    
    Return true

Note: ========================================================================
Note: ERROR HANDLING AND EDGE CASES TESTS
Note: ========================================================================

Process called "test_dft_empty_input" that takes no parameters returns Boolean:
    Note: Test DFT behavior with empty input
    Let empty_input be Collections.CreateList[Complex]()
    
    Try:
        Let result be DFT.dft_direct(empty_input)
        Assert.Fail("Expected exception for empty input")
    Catch error:
        Assert.IsTrue(true)  Note: Expected to throw exception
    
    Return true

Process called "test_dft_single_sample" that takes no parameters returns Boolean:
    Note: Test DFT with single sample input
    Let input be Collections.CreateList[Complex]()
    Call input.append(Complex with:
        real = 5.0
        imag = 0.0)
    
    Let result be DFT.dft_direct(input)
    
    Assert.AreEqual(result.length(), 1)
    Assert.AreEqual(result[0].real, 5.0)
    Assert.AreEqual(result[0].imag, 0.0)
    
    Return true

Process called "test_dft_numerical_precision" that takes no parameters returns Boolean:
    Note: Test DFT numerical precision with known signals
    Let input be Collections.CreateList[Complex]()
    
    Note: Create signal designed to test precision limits
    For i from 0 to 15:
        Let real_part be 1e-12 * MathCore.cos(2.0 * MathCore.pi() * i / 16.0)
        Let imag_part be 1e-12 * MathCore.sin(2.0 * MathCore.pi() * i / 16.0)
        Call input.append(Complex with:
            real = real_part
            imag = imag_part)
    
    Let result be DFT.dft_direct(input)
    
    Note: Verify result is not corrupted by numerical errors
    Assert.AreEqual(result.length(), 16)
    
    Note: Check that non-zero components are preserved with reasonable precision
    Let total_energy be 0.0
    For i from 0 to 15:
        Set total_energy to total_energy + result[i].real * result[i].real + result[i].imag * result[i].imag
    
    Assert.IsTrue(total_energy > 0.0)  Note: Energy should be preserved
    
    Return true

Process called "test_sliding_dft_memory_management" that takes no parameters returns Boolean:
    Note: Test sliding DFT memory usage and cleanup
    Let window_size be 1024
    Let sliding_dft be DFT.create_sliding_dft(window_size)
    
    Note: Process many samples to test memory stability
    For i from 0 to 9999:
        Let sample be MathCore.sin(2.0 * MathCore.pi() * i / 100.0)
        Call DFT.sliding_dft_update(sliding_dft, sample)
    
    Note: Verify state remains consistent
    Assert.AreEqual(sliding_dft.buffer.length(), window_size)
    Assert.IsTrue(sliding_dft.is_initialized)
    
    Note: Cleanup
    Call DFT.destroy_sliding_dft(sliding_dft)
    
    Return true

Note: ========================================================================
Note: PERFORMANCE AND OPTIMIZATION TESTS
Note: ========================================================================

Process called "test_dft_computational_complexity" that takes no parameters returns Boolean:
    Note: Test DFT computational performance characteristics
    Let small_size be 8
    Let large_size be 32
    
    Note: Create test signals
    Let small_input be Collections.CreateList[Complex]()
    Let large_input be Collections.CreateList[Complex]()
    
    For i from 0 to small_size - 1:
        Call small_input.append(Complex with:
            real = MathCore.random()
            imag = 0.0)
    
    For i from 0 to large_size - 1:
        Call large_input.append(Complex with:
            real = MathCore.random()
            imag = 0.0)
    
    Note: Time both computations (conceptual - actual timing would need timing utilities)
    Let small_result be DFT.dft_direct(small_input)
    Let large_result be DFT.dft_direct(large_input)
    
    Note: Verify results have correct sizes
    Assert.AreEqual(small_result.length(), small_size)
    Assert.AreEqual(large_result.length(), large_size)
    
    Return true

Process called "test_dft_cache_efficiency" that takes no parameters returns Boolean:
    Note: Test DFT implementation for cache-friendly access patterns
    Let input be Collections.CreateList[Complex]()
    
    Note: Create larger signal for cache testing
    For i from 0 to 127:
        Call input.append(Complex with:
            real = MathCore.cos(2.0 * MathCore.pi() * i / 128.0)
            imag = MathCore.sin(2.0 * MathCore.pi() * i / 128.0))
    
    Note: Multiple DFT computations to test cache behavior
    For iteration from 0 to 9:
        Let result be DFT.dft_direct(input)
        Assert.AreEqual(result.length(), 128)
    
    Return true