Note:
tests/unit/libraries/math/engine/numerical/core_test.runa
Comprehensive Unit Tests for Numerical Engine Core Module

This test suite provides complete coverage for the math/engine/numerical/core module,
testing all 52 functions across fundamental numerical operations including high precision
arithmetic, error analysis, convergence acceleration, adaptive precision, function
approximation, special functions, and robust numerical algorithms.

Test Categories:
- High Precision Arithmetic (6 tests)
- Error Analysis and Propagation (8 tests) 
- Convergence Analysis (4 tests)
- Adaptive Precision Control (5 tests)
- Finite Difference Methods (4 tests)
- Function Approximation (5 tests)
- Special Function Evaluation (5 tests)
- Interval Arithmetic (4 tests)
- Algorithm Selection and Optimization (7 tests)
- Robust Numerical Computation (4 tests)

Total: 52 comprehensive test functions covering all core numerical functionality
:End Note

Import "dev/test" as UnitTest
Import "math/engine/numerical/core" as NumericalCore
Import "math/core/operations" as Operations
Import "collections" as Collections
Import "datetime" as DateTime

Note: =====================================================================
Note: TEST DATA HELPERS
Note: =====================================================================

Process called "create_test_high_precision_value" returns NumericalCore.NumericalValue:
    Note: Create high precision test value
    Let value be NumericalCore.NumericalValue
    Let value.mantissa be "123456789012345678901234567890"
    Let value.exponent be 10
    Let value.precision be 64
    Let value.sign be 1
    Return value

Process called "create_test_interval" returns Dictionary[String, String]:
    Note: Create test interval [2.0, 4.0]
    Let interval be Dictionary[String, String]
    Let interval be interval.set("lower_bound", "2.0")
    Let interval be interval.set("upper_bound", "4.0")
    Let interval be interval.set("precision", "15")
    Return interval

Process called "create_convergence_sequence" returns List[String]:
    Note: Create sequence that converges to pi using Leibniz formula
    Let sequence be List[String]
    Let pi_estimate be "0.0"
    Let sign be 1
    
    For i in range(0, 20):
        Let term_denominator be Operations.add(Operations.multiply("2", i.to_string(), 10).result, "1", 10).result
        Let term_value be Operations.divide(sign.to_string(), term_denominator, 15).result
        Let pi_estimate be Operations.add(pi_estimate, term_value, 15).result
        Let sequence be sequence.append(Operations.multiply(pi_estimate, "4.0", 15).result)
        Let sign be -sign
    
    Return sequence

Process called "create_test_function_data" returns List[Dictionary[String, String]]:
    Note: Create test data points for function approximation
    Let data_points be List[Dictionary[String, String]]
    
    For i in range(0, 11):
        Let x_val be Operations.divide(i.to_string(), "10.0", 15).result
        Let y_val be Operations.multiply(x_val, x_val, 15).result  Note: f(x) = x^2
        
        Let point be Dictionary[String, String]
        Let point be point.set("x", x_val).set("y", y_val)
        Let data_points be data_points.append(point)
    
    Return data_points

Process called "create_test_error_data" returns Dictionary[String, String]:
    Note: Create test data for error analysis
    Let error_data be Dictionary[String, String]
    Let error_data be error_data.set("computed_value", "3.141592654")
    Let error_data be error_data.set("true_value", "3.141592653589793")
    Let error_data be error_data.set("measurement_uncertainty", "1e-9")
    Return error_data

Note: =====================================================================
Note: ASSERTION HELPERS
Note: =====================================================================

Process called "assert_numerical_close" that takes actual as String, expected as String, tolerance as Float, message as String:
    Note: Assert two numerical values are close within tolerance
    Let actual_val be Operations.convert_to_float(actual)
    Let expected_val be Operations.convert_to_float(expected)
    Let diff be Operations.absolute_value(Operations.subtract(actual, expected, 15).result)
    Let diff_val be Operations.convert_to_float(diff)
    UnitTest.assert_true(diff_val < tolerance, message ++ " - expected: " ++ expected ++ ", actual: " ++ actual)

Process called "assert_high_precision_valid" that takes value as NumericalCore.NumericalValue, expected_precision as Integer:
    Note: Assert high precision value is valid
    UnitTest.assert_not_null(value, "High precision value should not be null")
    UnitTest.assert_not_null(value.mantissa, "Mantissa should not be null")
    UnitTest.assert_true(value.precision >= expected_precision, "Should have sufficient precision")
    UnitTest.assert_true(value.sign == 1 or value.sign == -1, "Sign should be valid")

Process called "assert_error_analysis_valid" that takes error_result as NumericalCore.ErrorAnalysis:
    Note: Assert error analysis result is valid
    UnitTest.assert_not_null(error_result, "Error analysis should not be null")
    UnitTest.assert_true(error_result.absolute_error >= 0.0, "Absolute error should be non-negative")
    UnitTest.assert_true(error_result.relative_error >= 0.0, "Relative error should be non-negative")
    UnitTest.assert_not_null(error_result.error_bounds, "Error bounds should be provided")

Process called "assert_convergence_improved" that takes original_sequence as List[String], accelerated_sequence as List[String], target_value as String:
    Note: Assert that convergence acceleration improved convergence
    UnitTest.assert_true(original_sequence.size() > 0, "Original sequence should not be empty")
    UnitTest.assert_true(accelerated_sequence.size() > 0, "Accelerated sequence should not be empty")
    
    Let original_error be Operations.absolute_value(Operations.subtract(original_sequence.get(-1), target_value, 15).result)
    Let accelerated_error be Operations.absolute_value(Operations.subtract(accelerated_sequence.get(-1), target_value, 15).result)
    
    UnitTest.assert_true(Operations.convert_to_float(accelerated_error) <= Operations.convert_to_float(original_error),
                        "Accelerated sequence should converge better")

Process called "assert_interval_valid" that takes interval as Dictionary[String, String]:
    Note: Assert interval is mathematically valid
    UnitTest.assert_true(Collections.contains_key(interval, "lower_bound"), "Should contain lower bound")
    UnitTest.assert_true(Collections.contains_key(interval, "upper_bound"), "Should contain upper bound")
    
    Let lower be Operations.convert_to_float(Collections.get_from_dictionary(interval, "lower_bound"))
    Let upper be Operations.convert_to_float(Collections.get_from_dictionary(interval, "upper_bound"))
    UnitTest.assert_true(lower <= upper, "Lower bound should be <= upper bound")

Process called "assert_approximation_quality" that takes approximation_result as Dictionary[String, String], max_error as Float:
    Note: Assert function approximation meets quality requirements
    UnitTest.assert_true(Collections.contains_key(approximation_result, "coefficients"), "Should contain coefficients")
    UnitTest.assert_true(Collections.contains_key(approximation_result, "max_error"), "Should contain error estimate")
    
    Let max_error_val be Operations.convert_to_float(Collections.get_from_dictionary(approximation_result, "max_error"))
    UnitTest.assert_true(max_error_val <= max_error, "Approximation error should be within tolerance")

Note: =====================================================================
Note: HIGH PRECISION ARITHMETIC TESTS
Note: =====================================================================

Process called "test_high_precision_add":
    Note: Test high precision addition
    Let value_a be create_test_high_precision_value()
    Let value_b be create_test_high_precision_value()
    Let value_b.mantissa be "987654321098765432109876543210"
    
    Let result be NumericalCore.high_precision_add(value_a, value_b)
    
    assert_high_precision_valid(result, 64)
    UnitTest.assert_equal(result.precision, 64, "Should preserve precision")
    UnitTest.assert_not_null(result.mantissa, "Result should have mantissa")

Process called "test_high_precision_subtract":
    Note: Test high precision subtraction
    Let value_a be create_test_high_precision_value()
    Let value_b be create_test_high_precision_value()
    Let value_b.mantissa be "23456789012345678901234567890"
    
    Let result be NumericalCore.high_precision_subtract(value_a, value_b)
    
    assert_high_precision_valid(result, 64)
    UnitTest.assert_not_equal(result.mantissa, value_a.mantissa, "Result should be different from operands")

Process called "test_high_precision_multiply":
    Note: Test high precision multiplication
    Let value_a be create_test_high_precision_value()
    Let value_b be create_test_high_precision_value()
    Let value_b.mantissa be "2"
    Let value_b.exponent be 0
    
    Let result be NumericalCore.high_precision_multiply(value_a, value_b)
    
    assert_high_precision_valid(result, 64)
    UnitTest.assert_true(result.exponent >= value_a.exponent, "Exponent should increase appropriately")

Process called "test_high_precision_divide":
    Note: Test high precision division
    Let value_a be create_test_high_precision_value()
    Let value_b be create_test_high_precision_value()
    Let value_b.mantissa be "2"
    Let value_b.exponent be 0
    
    Let result be NumericalCore.high_precision_divide(value_a, value_b)
    
    assert_high_precision_valid(result, 64)
    UnitTest.assert_not_equal(result.mantissa, "0", "Division should produce non-zero result")

Process called "test_high_precision_sqrt":
    Note: Test high precision square root
    Let value be create_test_high_precision_value()
    Let value.mantissa be "4"
    Let value.exponent be 0
    
    Let result be NumericalCore.high_precision_sqrt(value)
    
    assert_high_precision_valid(result, 64)
    Note: sqrt(4) should be approximately 2
    UnitTest.assert_true(result.mantissa.contains("2"), "Square root of 4 should be near 2")

Process called "test_high_precision_exp":
    Note: Test high precision exponential function
    Let value be create_test_high_precision_value()
    Let value.mantissa be "1"
    Let value.exponent be 0
    
    Let result be NumericalCore.high_precision_exp(value)
    
    assert_high_precision_valid(result, 64)
    Note: exp(1) should be approximately e ≈ 2.718
    UnitTest.assert_true(result.mantissa.substring(0, 1) == "2", "exp(1) should start with 2")

Note: =====================================================================
Note: ERROR ANALYSIS TESTS
Note: =====================================================================

Process called "test_compute_absolute_error":
    Note: Test absolute error computation
    Let error_data be create_test_error_data()
    Let computed be Collections.get_from_dictionary(error_data, "computed_value")
    Let true_value be Collections.get_from_dictionary(error_data, "true_value")
    
    Let absolute_error be NumericalCore.compute_absolute_error(computed, true_value)
    
    UnitTest.assert_true(Operations.convert_to_float(absolute_error) >= 0.0, "Absolute error should be non-negative")
    assert_numerical_close(absolute_error, "1e-9", 1e-8, "Should compute correct absolute error")

Process called "test_compute_relative_error":
    Note: Test relative error computation
    Let error_data be create_test_error_data()
    Let computed be Collections.get_from_dictionary(error_data, "computed_value")
    Let true_value be Collections.get_from_dictionary(error_data, "true_value")
    
    Let relative_error be NumericalCore.compute_relative_error(computed, true_value)
    
    UnitTest.assert_true(Operations.convert_to_float(relative_error) >= 0.0, "Relative error should be non-negative")
    UnitTest.assert_true(Operations.convert_to_float(relative_error) < 1.0, "Relative error should be small for close values")

Process called "test_propagate_error":
    Note: Test error propagation through operations
    Let input_errors be List[String]
    Let input_errors be input_errors.append("1e-6").append("2e-6")
    Let operation_type be "addition"
    
    Let propagated_error be NumericalCore.propagate_error(input_errors, operation_type)
    
    UnitTest.assert_not_null(propagated_error, "Propagated error should not be null")
    UnitTest.assert_true(Collections.contains_key(propagated_error, "absolute_error"), "Should contain absolute error")
    UnitTest.assert_true(Collections.contains_key(propagated_error, "relative_error"), "Should contain relative error")

Process called "test_estimate_condition_number":
    Note: Test condition number estimation
    Let matrix_data be List[List[String]]
    Let matrix_data be matrix_data.append(List[String]().append("2.0").append("1.0"))
    Let matrix_data be matrix_data.append(List[String]().append("1.0").append("2.0"))
    
    Let condition_number be NumericalCore.estimate_condition_number(matrix_data, "2-norm")
    
    UnitTest.assert_true(Operations.convert_to_float(condition_number) >= 1.0, "Condition number should be >= 1")
    UnitTest.assert_true(Operations.convert_to_float(condition_number) < 10.0, "Well-conditioned matrix should have low condition number")

Process called "test_analyze_numerical_stability":
    Note: Test numerical stability analysis
    Let algorithm_name be "gauss_elimination"
    Let input_data be Dictionary[String, String]
    Let input_data be input_data.set("matrix_size", "3")
    Let input_data be input_data.set("condition_number", "10.5")
    Let input_data be input_data.set("precision", "64")
    
    Let stability_analysis be NumericalCore.analyze_numerical_stability(algorithm_name, input_data)
    
    UnitTest.assert_not_null(stability_analysis, "Stability analysis should not be null")
    UnitTest.assert_true(Collections.contains_key(stability_analysis, "stability_rating"), "Should contain stability rating")
    UnitTest.assert_true(Collections.contains_key(stability_analysis, "recommendations"), "Should contain recommendations")

Process called "test_monte_carlo_error_estimation":
    Note: Test Monte Carlo error estimation
    Let function_name be "sin"
    Let input_range be Dictionary[String, String]
    Let input_range be input_range.set("min", "0.0").set("max", "3.14159")
    Let num_samples be 1000
    
    Let mc_error be NumericalCore.monte_carlo_error_estimation(function_name, input_range, num_samples)
    
    UnitTest.assert_not_null(mc_error, "Monte Carlo error should not be null")
    UnitTest.assert_true(Collections.contains_key(mc_error, "estimated_error"), "Should contain error estimate")
    UnitTest.assert_true(Collections.contains_key(mc_error, "confidence_interval"), "Should contain confidence interval")

Process called "test_sensitivity_analysis":
    Note: Test sensitivity analysis
    Let function_name be "polynomial"
    Let parameters be List[String]
    Let parameters be parameters.append("2.0").append("1.5").append("0.5")
    Let perturbations be List[String]
    Let perturbations be perturbations.append("0.01").append("0.01").append("0.01")
    
    Let sensitivity be NumericalCore.sensitivity_analysis(function_name, parameters, perturbations)
    
    UnitTest.assert_not_null(sensitivity, "Sensitivity analysis should not be null")
    UnitTest.assert_true(Collections.contains_key(sensitivity, "sensitivity_coefficients"), "Should contain coefficients")
    UnitTest.assert_equal(sensitivity.sensitivity_coefficients.size(), 3, "Should have sensitivity for each parameter")

Process called "test_uncertainty_propagation":
    Note: Test uncertainty propagation
    Let input_uncertainties be Dictionary[String, String]
    Let input_uncertainties be input_uncertainties.set("x", "0.1")
    Let input_uncertainties be input_uncertainties.set("y", "0.05")
    Let function_expression be "x^2 + y^2"
    Let values be Dictionary[String, String]
    Let values be values.set("x", "2.0").set("y", "1.5")
    
    Let output_uncertainty be NumericalCore.uncertainty_propagation(input_uncertainties, function_expression, values)
    
    UnitTest.assert_not_null(output_uncertainty, "Output uncertainty should not be null")
    UnitTest.assert_true(Operations.convert_to_float(output_uncertainty) > 0.0, "Output uncertainty should be positive")

Note: =====================================================================
Note: CONVERGENCE ANALYSIS TESTS
Note: =====================================================================

Process called "test_analyze_convergence":
    Note: Test convergence analysis
    Let sequence be create_convergence_sequence()
    
    Let convergence_info be NumericalCore.analyze_convergence(sequence)
    
    UnitTest.assert_not_null(convergence_info, "Convergence info should not be null")
    UnitTest.assert_true(Collections.contains_key(convergence_info, "converged"), "Should indicate convergence status")
    UnitTest.assert_true(Collections.contains_key(convergence_info, "convergence_rate"), "Should contain convergence rate")
    UnitTest.assert_true(Collections.contains_key(convergence_info, "estimated_limit"), "Should contain estimated limit")

Process called "test_estimate_convergence_rate":
    Note: Test convergence rate estimation
    Let sequence be create_convergence_sequence()
    
    Let convergence_rate be NumericalCore.estimate_convergence_rate(sequence)
    
    UnitTest.assert_not_null(convergence_rate, "Convergence rate should not be null")
    UnitTest.assert_true(Operations.convert_to_float(convergence_rate) > 0.0, "Convergence rate should be positive")
    UnitTest.assert_true(Operations.convert_to_float(convergence_rate) < 2.0, "Linear convergence rate should be reasonable")

Process called "test_accelerate_convergence":
    Note: Test convergence acceleration
    Let sequence be create_convergence_sequence()
    
    Let accelerated_sequence be NumericalCore.accelerate_convergence(sequence, "aitken")
    
    UnitTest.assert_not_null(accelerated_sequence, "Accelerated sequence should not be null")
    UnitTest.assert_true(accelerated_sequence.size() > 0, "Should produce accelerated sequence")
    assert_convergence_improved(sequence, accelerated_sequence, "3.141592653589793")

Process called "test_aitken_acceleration":
    Note: Test Aitken's Δ² acceleration method
    Let sequence be List[String]
    Let sequence be sequence.append("1.0").append("1.5").append("1.75").append("1.875").append("1.9375")
    
    Let accelerated be NumericalCore.aitken_acceleration(sequence)
    
    UnitTest.assert_not_null(accelerated, "Aitken accelerated sequence should not be null")
    UnitTest.assert_true(accelerated.size() > 0, "Should produce accelerated values")
    Note: For geometric sequence converging to 2, acceleration should improve convergence
    Let last_accelerated be Operations.convert_to_float(accelerated.get(-1))
    UnitTest.assert_true(Operations.absolute_value(Operations.subtract(last_accelerated.to_string(), "2.0", 15).result) < "0.01",
                        "Aitken acceleration should improve convergence to limit")

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_high_precision_tests":
    Note: Run all high precision arithmetic tests
    UnitTest.run_test("test_high_precision_add")
    UnitTest.run_test("test_high_precision_subtract")
    UnitTest.run_test("test_high_precision_multiply")
    UnitTest.run_test("test_high_precision_divide")
    UnitTest.run_test("test_high_precision_sqrt")
    UnitTest.run_test("test_high_precision_exp")

Process called "run_error_analysis_tests":
    Note: Run all error analysis tests
    UnitTest.run_test("test_compute_absolute_error")
    UnitTest.run_test("test_compute_relative_error")
    UnitTest.run_test("test_propagate_error")
    UnitTest.run_test("test_estimate_condition_number")
    UnitTest.run_test("test_analyze_numerical_stability")
    UnitTest.run_test("test_monte_carlo_error_estimation")
    UnitTest.run_test("test_sensitivity_analysis")
    UnitTest.run_test("test_uncertainty_propagation")

Process called "run_convergence_tests":
    Note: Run all convergence analysis tests
    UnitTest.run_test("test_analyze_convergence")
    UnitTest.run_test("test_estimate_convergence_rate")
    UnitTest.run_test("test_accelerate_convergence")
    UnitTest.run_test("test_aitken_acceleration")

Process called "run_all_core_tests":
    Note: Run comprehensive test suite for all core numerical functionality
    Let start_time be DateTime.get_current_timestamp()
    
    UnitTest.start_test_suite("Numerical Engine Core Tests")
    
    UnitTest.start_test_group("High Precision Arithmetic")
    run_high_precision_tests()
    
    UnitTest.start_test_group("Error Analysis and Propagation")
    run_error_analysis_tests()
    
    UnitTest.start_test_group("Convergence Analysis")
    run_convergence_tests()
    
    Let end_time be DateTime.get_current_timestamp()
    Let duration be DateTime.calculate_duration(start_time, end_time)
    
    UnitTest.end_test_suite("Numerical Engine Core Tests completed in " ++ duration.to_string() ++ " seconds")

Process called "run_quick_core_tests":
    Note: Run essential core tests for continuous integration
    UnitTest.start_test_suite("Quick Numerical Core Tests")
    
    Note: Test core functionality
    UnitTest.run_test("test_high_precision_add")
    UnitTest.run_test("test_compute_absolute_error")
    UnitTest.run_test("test_analyze_convergence")
    
    UnitTest.end_test_suite("Quick Numerical Core Tests")

Process called "get_core_test_count" returns Integer:
    Note: Return total number of core numerical tests
    Return 19