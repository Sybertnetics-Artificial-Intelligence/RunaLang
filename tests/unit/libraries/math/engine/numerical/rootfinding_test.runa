Note:
tests/unit/libraries/math/engine/numerical/rootfinding_test.runa
Comprehensive Unit Tests for Numerical Root Finding Engine

This module provides comprehensive unit tests for root finding algorithms including:
- Bracketing methods (bisection, false position, Brent's method)
- Open methods (Newton-Raphson, secant, fixed-point iteration)
- Polynomial root finding (Durand-Kerner, Jenkins-Traub)
- Multidimensional root finding (Newton's method, quasi-Newton)
- Robustness and convergence analysis
- Performance benchmarking and edge case testing
:End Note

Import "dev/test/core" as Test
Import "math/engine/numerical/rootfinding" as RootFinding
Import "math/precision/bigdecimal" as BigDecimal
Import "math/core/constants" as Constants

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "assert_root_accuracy" that takes expected as String, actual as String, tolerance as String, message as String returns nothing:
    Note: Assert root is within expected tolerance
    Let difference be BigDecimal.abs(BigDecimal.subtract(actual, expected, 15))
    
    If BigDecimal.compare(difference, tolerance) > 0:
        Test.assert_fail(message + " Expected: " + expected + ", Got: " + actual + ", Error: " + difference + ", Tolerance: " + tolerance)

Process called "create_test_polynomials" that takes nothing returns Dictionary[String, List[String]]:
    Note: Create test polynomial coefficients for various scenarios
    Return {
        "linear": ["2.0", "-6.0"],  Note: 2x - 6 = 0, root at x = 3
        "quadratic": ["1.0", "-5.0", "6.0"],  Note: x^2 - 5x + 6 = (x-2)(x-3)
        "cubic": ["1.0", "-6.0", "11.0", "-6.0"],  Note: (x-1)(x-2)(x-3)
        "quartic": ["1.0", "0.0", "-5.0", "0.0", "4.0"],  Note: x^4 - 5x^2 + 4
        "high_degree": ["1.0", "-10.0", "35.0", "-50.0", "24.0"]  Note: Degree 4 with multiple roots
    }

Process called "verify_function_zero" that takes function_expr as String, root as String, tolerance as String returns Boolean:
    Note: Verify that f(root) is approximately zero
    Let function_value be RootFinding.evaluate_function(function_expr, root)
    Return BigDecimal.compare(BigDecimal.abs(function_value), tolerance) <= 0

Process called "analyze_convergence_rate" that takes iterations as List[String] returns Dictionary:
    Note: Analyze convergence rate from iteration sequence
    If iterations.length() < 3:
        Return { rate: "1.0", type: "insufficient_data" }
    
    Let convergence_ratios be []
    
    For i in range(2, iterations.length()):
        Let e_current be BigDecimal.abs(iterations[i])
        Let e_previous be BigDecimal.abs(iterations[i-1])
        Let e_prev_prev be BigDecimal.abs(iterations[i-2])
        
        If BigDecimal.compare(e_previous, "1e-15") > 0 and BigDecimal.compare(e_prev_prev, "1e-15") > 0:
            Let ratio be BigDecimal.divide(
                BigDecimal.log(e_current), 
                BigDecimal.log(e_previous), 
                10
            )
            List.append(convergence_ratios, ratio)
    
    If convergence_ratios.length() == 0:
        Return { rate: "1.0", type: "linear" }
    
    Note: Average the ratios to estimate convergence order
    Let sum_ratios be "0.0"
    For ratio in convergence_ratios:
        Set sum_ratios to BigDecimal.add(sum_ratios, ratio, 10)
    
    Let avg_rate be BigDecimal.divide(sum_ratios, Integer.to_string(convergence_ratios.length()), 10)
    
    Return {
        rate: avg_rate,
        type: BigDecimal.compare(avg_rate, "1.5") > 0 ? "superlinear" : "linear"
    }

Note: =====================================================================
Note: BRACKETING METHODS TESTS
Note: =====================================================================

Process called "test_bisection_method" that takes nothing returns Test.Result:
    Note: Test bisection method for various functions with guaranteed roots
    
    Let test_cases be [
        {
            function_expr: "x^3 - 2*x - 5",
            left_bound: "2.0",
            right_bound: "3.0",
            tolerance: "1e-8",
            expected_root: "2.094551481542",
            test_name: "Cubic polynomial"
        },
        {
            function_expr: "sin(x) - 0.5",
            left_bound: "0.0",
            right_bound: "1.0",
            tolerance: "1e-10",
            expected_root: "0.523598775598",
            test_name: "Transcendental equation"
        },
        {
            function_expr: "exp(x) - 3",
            left_bound: "0.5",
            right_bound: "1.5",
            tolerance: "1e-12", 
            expected_root: "1.098612288668",
            test_name: "Exponential equation"
        }
    ]
    
    For test_case in test_cases:
        Let result be RootFinding.bisection_method(
            test_case.function_expr,
            test_case.left_bound,
            test_case.right_bound,
            test_case.tolerance,
            1000
        )
        
        Note: Verify convergence
        Test.assert_equal(result.status, "converged", "Bisection should converge for " + test_case.test_name)
        
        Note: Check accuracy
        assert_root_accuracy(test_case.expected_root, result.root, test_case.tolerance, "Bisection accuracy for " + test_case.test_name)
        
        Note: Verify reasonable iteration count (bisection has predictable convergence)
        Let interval_size be BigDecimal.subtract(test_case.right_bound, test_case.left_bound, 10)
        Let max_expected_iterations be BigDecimal.log2(BigDecimal.divide(interval_size, test_case.tolerance, 15))
        
        Test.assert_less(result.iterations, BigDecimal.to_integer(max_expected_iterations) + 10, "Reasonable iterations for " + test_case.test_name)
        
        Note: Verify root is actually within bracket
        Test.assert_greater_equal(BigDecimal.to_float(result.root), BigDecimal.to_float(test_case.left_bound), "Root within left bound")
        Test.assert_less_equal(BigDecimal.to_float(result.root), BigDecimal.to_float(test_case.right_bound), "Root within right bound")
        
        Note: Verify function value at root is near zero
        Test.assert_true(verify_function_zero(test_case.function_expr, result.root, test_case.tolerance), "Function value at root for " + test_case.test_name)
    
    Return Test.success("All bisection method tests passed")

Process called "test_false_position_method" that takes nothing returns Test.Result:
    Note: Test false position (regula falsi) method
    
    Let test_cases be [
        {
            function_expr: "x^2 - 4",
            left_bound: "1.0",
            right_bound: "3.0", 
            tolerance: "1e-8",
            expected_root: "2.0",
            test_name: "Simple quadratic"
        },
        {
            function_expr: "x*exp(x) - 1",
            left_bound: "0.1",
            right_bound: "1.0",
            tolerance: "1e-10",
            expected_root: "0.567143290409",
            test_name: "Transcendental with product"
        },
        {
            function_expr: "cos(x) - x",
            left_bound: "0.0",
            right_bound: "1.0",
            tolerance: "1e-12",
            expected_root: "0.739085133215",
            test_name: "Trigonometric equation"
        }
    ]
    
    For test_case in test_cases:
        Let result be RootFinding.false_position_method(
            test_case.function_expr,
            test_case.left_bound,
            test_case.right_bound,
            test_case.tolerance,
            500
        )
        
        Test.assert_equal(result.status, "converged", "False position should converge for " + test_case.test_name)
        
        assert_root_accuracy(test_case.expected_root, result.root, test_case.tolerance, "False position accuracy for " + test_case.test_name)
        
        Note: False position should often converge faster than bisection for smooth functions
        Test.assert_greater_equal(result.convergence_rate, 1.0, "False position convergence rate for " + test_case.test_name)
        
        Note: Verify root satisfies equation
        Test.assert_true(verify_function_zero(test_case.function_expr, result.root, test_case.tolerance), "Function zero for " + test_case.test_name)
    
    Return Test.success("All false position tests passed")

Process called "test_brent_method" that takes nothing returns Test.Result:
    Note: Test Brent's method (combines bisection, secant, and inverse quadratic interpolation)
    
    Let challenging_cases be [
        {
            function_expr: "x^5 - 3*x^4 + 2*x^3 - x + 1",
            left_bound: "-2.0",
            right_bound: "0.0",
            tolerance: "1e-12",
            test_name: "High-degree polynomial"
        },
        {
            function_expr: "cos(x) - x*sin(x)",
            left_bound: "0.5",
            right_bound: "2.0",
            tolerance: "1e-14",
            test_name: "Trigonometric equation"
        },
        {
            function_expr: "x^3 - 2*x - 5",
            left_bound: "2.0",
            right_bound: "3.0",
            tolerance: "1e-15",
            test_name: "High precision cubic"
        }
    ]
    
    For test_case in challenging_cases:
        Let result be RootFinding.brent_method(
            test_case.function_expr,
            test_case.left_bound, 
            test_case.right_bound,
            test_case.tolerance,
            100
        )
        
        Test.assert_equal(result.status, "converged", "Brent's method should converge for " + test_case.test_name)
        
        Note: Verify final tolerance achieved
        Test.assert_less_equal(BigDecimal.to_float(result.final_tolerance), BigDecimal.to_float(test_case.tolerance), "Final tolerance for " + test_case.test_name)
        
        Note: Brent's method should show superlinear convergence
        Test.assert_greater_equal(result.convergence_rate, 1.3, "Brent's convergence rate for " + test_case.test_name)
        
        Note: Should require fewer iterations than bisection
        Test.assert_less(result.iterations, 50, "Brent's iteration count for " + test_case.test_name)
        
        Note: Verify function value at root
        Test.assert_true(verify_function_zero(test_case.function_expr, result.root, test_case.tolerance), "Function zero for " + test_case.test_name)
    
    Return Test.success("All Brent's method tests passed")

Process called "test_ridders_method" that takes nothing returns Test.Result:
    Note: Test Ridders' method for root finding
    
    Let ridders_cases be [
        {
            function_expr: "x^2 - 2",
            left_bound: "1.0",
            right_bound: "2.0",
            tolerance: "1e-10",
            expected_root: "1.414213562373",
            test_name: "Square root of 2"
        },
        {
            function_expr: "exp(x) - x - 2",
            left_bound: "0.0",
            right_bound: "2.0",
            tolerance: "1e-12",
            test_name: "Exponential equation"
        }
    ]
    
    For test_case in ridders_cases:
        Let result be RootFinding.ridders_method(
            test_case.function_expr,
            test_case.left_bound,
            test_case.right_bound,
            test_case.tolerance,
            100
        )
        
        Test.assert_equal(result.status, "converged", "Ridders' method should converge for " + test_case.test_name)
        
        If test_case.expected_root != "":
            assert_root_accuracy(test_case.expected_root, result.root, test_case.tolerance, "Ridders' accuracy for " + test_case.test_name)
        
        Note: Ridders' method should show quadratic convergence
        Test.assert_greater_equal(result.convergence_rate, 1.8, "Ridders' convergence rate for " + test_case.test_name)
    
    Return Test.success("All Ridders' method tests passed")

Note: =====================================================================
Note: OPEN METHODS TESTS
Note: =====================================================================

Process called "test_newton_raphson_method" that takes nothing returns Test.Result:
    Note: Test Newton-Raphson method with analytical derivatives
    
    Let test_cases be [
        {
            function_expr: "x^3 - x - 1",
            derivative_expr: "3*x^2 - 1", 
            initial_guess: "1.5",
            tolerance: "1e-12",
            expected_root: "1.324717957244",
            test_name: "Cubic with known derivative"
        },
        {
            function_expr: "exp(x) - 2*x - 1",
            derivative_expr: "exp(x) - 2",
            initial_guess: "0.0",
            tolerance: "1e-10",
            expected_root: "1.278464542127",
            test_name: "Exponential equation"
        },
        {
            function_expr: "sin(x) - x/2",
            derivative_expr: "cos(x) - 0.5",
            initial_guess: "2.0",
            tolerance: "1e-14",
            expected_root: "1.895494267034",
            test_name: "Trigonometric equation"
        }
    ]
    
    For test_case in test_cases:
        Let result be RootFinding.newton_raphson_method(
            test_case.function_expr,
            test_case.derivative_expr,
            test_case.initial_guess,
            test_case.tolerance,
            50
        )
        
        Test.assert_equal(result.status, "converged", "Newton-Raphson should converge for " + test_case.test_name)
        
        assert_root_accuracy(test_case.expected_root, result.root, test_case.tolerance, "Newton-Raphson accuracy for " + test_case.test_name)
        
        Note: Newton-Raphson should show quadratic convergence
        Test.assert_greater_equal(result.convergence_rate, 1.8, "Newton-Raphson convergence rate for " + test_case.test_name)
        
        Note: Should converge quickly with good initial guess
        Test.assert_less(result.iterations, 20, "Newton-Raphson iteration count for " + test_case.test_name)
        
        Note: Verify function value at root
        Test.assert_true(verify_function_zero(test_case.function_expr, result.root, test_case.tolerance), "Function zero for " + test_case.test_name)
    
    Return Test.success("All Newton-Raphson tests passed")

Process called "test_secant_method" that takes nothing returns Test.Result:
    Note: Test secant method (Newton-Raphson with numerical derivatives)
    
    Let test_cases be [
        {
            function_expr: "x^4 - 10*x^2 + 5",
            initial_guess_1: "0.5",
            initial_guess_2: "1.0", 
            tolerance: "1e-10",
            test_name: "Quartic polynomial"
        },
        {
            function_expr: "sin(x) - x/2",
            initial_guess_1: "1.5",
            initial_guess_2: "2.0",
            tolerance: "1e-8",
            test_name: "Transcendental equation"
        },
        {
            function_expr: "x^3 - 2*x - 5",
            initial_guess_1: "2.0",
            initial_guess_2: "2.5",
            tolerance: "1e-12",
            expected_root: "2.094551481542",
            test_name: "Cubic polynomial"
        }
    ]
    
    For test_case in test_cases:
        Let result be RootFinding.secant_method(
            test_case.function_expr,
            test_case.initial_guess_1,
            test_case.initial_guess_2,
            test_case.tolerance,
            100
        )
        
        Test.assert_equal(result.status, "converged", "Secant method should converge for " + test_case.test_name)
        
        If test_case.expected_root != "":
            assert_root_accuracy(test_case.expected_root, result.root, test_case.tolerance, "Secant accuracy for " + test_case.test_name)
        
        Note: Verify root satisfies function equation
        Test.assert_true(verify_function_zero(test_case.function_expr, result.root, test_case.tolerance), "Function zero for " + test_case.test_name)
        
        Note: Secant method should show superlinear convergence (golden ratio ≈ 1.618)
        Test.assert_greater_equal(result.convergence_rate, 1.4, "Secant convergence rate for " + test_case.test_name)
    
    Return Test.success("All secant method tests passed")

Process called "test_fixed_point_iteration" that takes nothing returns Test.Result:
    Note: Test fixed-point iteration method
    
    Let fixed_point_cases be [
        {
            function_expr: "(x + 2/x)/2",  Note: Fixed point iteration for sqrt(2)
            initial_guess: "1.5",
            tolerance: "1e-10",
            expected_root: "1.414213562373",
            test_name: "Square root iteration"
        },
        {
            function_expr: "cos(x)",  Note: Fixed point of cosine
            initial_guess: "0.5",
            tolerance: "1e-8",
            expected_root: "0.739085133215",
            test_name: "Cosine fixed point"
        }
    ]
    
    For test_case in fixed_point_cases:
        Let result be RootFinding.fixed_point_iteration(
            test_case.function_expr,
            test_case.initial_guess,
            test_case.tolerance,
            200
        )
        
        Test.assert_equal(result.status, "converged", "Fixed point should converge for " + test_case.test_name)
        
        assert_root_accuracy(test_case.expected_root, result.root, test_case.tolerance, "Fixed point accuracy for " + test_case.test_name)
        
        Note: Verify fixed point property: g(x) = x
        Let function_value be RootFinding.evaluate_function(test_case.function_expr, result.root)
        assert_root_accuracy(result.root, function_value, test_case.tolerance, "Fixed point property for " + test_case.test_name)
    
    Return Test.success("All fixed-point iteration tests passed")

Note: =====================================================================
Note: POLYNOMIAL ROOT FINDING TESTS
Note: =====================================================================

Process called "test_polynomial_root_finding" that takes nothing returns Test.Result:
    Note: Test specialized polynomial root finding algorithms
    
    Let polynomials be create_test_polynomials()
    
    Note: Test quadratic formula
    Let quadratic_coeffs be polynomials["quadratic"]
    Let quadratic_roots be RootFinding.solve_quadratic(quadratic_coeffs)
    
    Test.assert_equal(quadratic_roots.status, "success", "Quadratic solver should succeed")
    Test.assert_equal(quadratic_roots.roots.length(), 2, "Quadratic should have 2 roots")
    
    Note: Check roots are approximately 2.0 and 3.0
    Let found_roots be Set[String]()
    For root in quadratic_roots.roots:
        If BigDecimal.compare(BigDecimal.abs(BigDecimal.subtract(root, "2.0", 10)), "0.001") < 0:
            Set.add(found_roots, "2.0")
        Otherwise If BigDecimal.compare(BigDecimal.abs(BigDecimal.subtract(root, "3.0", 10)), "0.001") < 0:
            Set.add(found_roots, "3.0")
    
    Test.assert_equal(Set.size(found_roots), 2, "Should find both expected roots")
    
    Note: Test cubic polynomial solver
    Let cubic_coeffs be polynomials["cubic"]
    Let cubic_roots be RootFinding.solve_cubic(cubic_coeffs)
    
    Test.assert_equal(cubic_roots.status, "success", "Cubic solver should succeed")
    Test.assert_equal(cubic_roots.real_roots.length(), 3, "Cubic should have 3 real roots")
    
    Note: Test general polynomial root finder for higher degrees
    Let quartic_coeffs be polynomials["quartic"]
    Let quartic_roots be RootFinding.polynomial_roots(quartic_coeffs, "durand_kerner")
    
    Test.assert_equal(quartic_roots.status, "success", "Quartic polynomial solver should succeed")
    Test.assert_equal(quartic_roots.roots.length(), 4, "Quartic should have 4 roots")
    
    Note: Test Jenkins-Traub algorithm
    Let jenkins_traub_result be RootFinding.polynomial_roots(quartic_coeffs, "jenkins_traub")
    
    Test.assert_equal(jenkins_traub_result.status, "success", "Jenkins-Traub should succeed")
    Test.assert_equal(jenkins_traub_result.roots.length(), 4, "Jenkins-Traub should find all roots")
    
    Note: Compare accuracy between methods
    For i in range(0, quartic_roots.roots.length()):
        Let dk_root be quartic_roots.roots[i]
        Let jt_root be jenkins_traub_result.roots[i]
        
        Note: Both methods should find similar roots (within tolerance)
        Let root_difference be BigDecimal.abs(BigDecimal.subtract(dk_root, jt_root, 12))
        Test.assert_less(BigDecimal.to_float(root_difference), 1e-8, "Methods should agree on root " + Integer.to_string(i))
    
    Return Test.success("All polynomial root finding tests passed")

Process called "test_companion_matrix_method" that takes nothing returns Test.Result:
    Note: Test companion matrix method for polynomial roots
    
    Let test_polynomial be ["1.0", "-10.0", "35.0", "-50.0", "24.0"]  Note: (x-1)(x-2)(x-3)(x-4)
    
    Let companion_result be RootFinding.companion_matrix_roots(test_polynomial)
    
    Test.assert_equal(companion_result.status, "success", "Companion matrix method should succeed")
    Test.assert_equal(companion_result.eigenvalues.length(), 4, "Should find 4 eigenvalues")
    
    Note: Verify that eigenvalues are indeed roots
    For eigenvalue in companion_result.eigenvalues:
        Let polynomial_value be RootFinding.evaluate_polynomial(test_polynomial, eigenvalue)
        Test.assert_less(BigDecimal.to_float(BigDecimal.abs(polynomial_value)), 1e-10, "Eigenvalue should be root")
    
    Note: Check condition number of companion matrix
    Test.assert_less(companion_result.condition_number, 1e12, "Companion matrix should be reasonably conditioned")
    
    Return Test.success("Companion matrix method test passed")

Note: =====================================================================
Note: MULTIDIMENSIONAL ROOT FINDING TESTS
Note: =====================================================================

Process called "test_multidimensional_newton" that takes nothing returns Test.Result:
    Note: Test multidimensional Newton's method for systems of equations
    
    Note: Test 2D system: x^2 + y^2 = 5, x*y = 2
    Let system_functions be [
        "x^2 + y^2 - 5",
        "x*y - 2"
    ]
    
    Let jacobian_matrix be [
        ["2*x", "2*y"],
        ["y", "x"]
    ]
    
    Let initial_guess be ["1.5", "1.5"]
    
    Let result_2d be RootFinding.multidimensional_newton(
        system_functions,
        jacobian_matrix,
        initial_guess,
        "1e-10",
        50
    )
    
    Test.assert_equal(result_2d.status, "converged", "2D Newton's method should converge")
    Test.assert_equal(result_2d.solution.length(), 2, "2D solution should have 2 components")
    
    Note: Verify solution satisfies both equations
    Let x_val be result_2d.solution[0]
    Let y_val be result_2d.solution[1]
    
    Let eq1_residual be RootFinding.evaluate_function_2d("x^2 + y^2 - 5", x_val, y_val)
    Let eq2_residual be RootFinding.evaluate_function_2d("x*y - 2", x_val, y_val)
    
    Test.assert_less(BigDecimal.to_float(BigDecimal.abs(eq1_residual)), 1e-8, "Solution should satisfy equation 1")
    Test.assert_less(BigDecimal.to_float(BigDecimal.abs(eq2_residual)), 1e-8, "Solution should satisfy equation 2")
    
    Note: Test 3D system
    Let system_3d be [
        "x^2 + y^2 + z^2 - 14",
        "x + y + z - 6", 
        "x*y*z - 8"
    ]
    
    Let initial_3d be ["2.0", "2.0", "2.0"]
    
    Let result_3d be RootFinding.multidimensional_newton(
        system_3d,
        "numerical_jacobian",
        initial_3d,
        "1e-8",
        100
    )
    
    Test.assert_equal(result_3d.status, "converged", "3D Newton's method should converge")
    Test.assert_equal(result_3d.solution.length(), 3, "3D solution should have 3 components")
    
    Note: Verify convergence rate for multidimensional case
    Test.assert_greater_equal(result_2d.convergence_rate, 1.5, "2D Newton should show superlinear convergence")
    
    Return Test.success("All multidimensional Newton tests passed")

Process called "test_quasi_newton_methods" that takes nothing returns Test.Result:
    Note: Test quasi-Newton methods (Broyden, BFGS)
    
    Note: Test Broyden's method
    Let broyden_system be [
        "x^2 + y^2 - 4",
        "x + y - 2"
    ]
    
    Let broyden_initial be ["1.0", "1.0"]
    
    Let broyden_result be RootFinding.broyden_method(
        broyden_system,
        broyden_initial,
        "1e-10",
        100
    )
    
    Test.assert_equal(broyden_result.status, "converged", "Broyden's method should converge")
    
    Note: Test BFGS method
    Let bfgs_result be RootFinding.bfgs_root_finding(
        broyden_system,
        broyden_initial,
        "1e-10",
        100
    )
    
    Test.assert_equal(bfgs_result.status, "converged", "BFGS method should converge")
    
    Note: Compare solutions from different methods
    Let solution_diff_x be BigDecimal.abs(BigDecimal.subtract(broyden_result.solution[0], bfgs_result.solution[0], 10))
    Let solution_diff_y be BigDecimal.abs(BigDecimal.subtract(broyden_result.solution[1], bfgs_result.solution[1], 10))
    
    Test.assert_less(BigDecimal.to_float(solution_diff_x), 1e-6, "Methods should agree on x-coordinate")
    Test.assert_less(BigDecimal.to_float(solution_diff_y), 1e-6, "Methods should agree on y-coordinate")
    
    Return Test.success("All quasi-Newton method tests passed")

Note: =====================================================================
Note: ROBUSTNESS AND CONVERGENCE TESTS
Note: =====================================================================

Process called "test_convergence_analysis" that takes nothing returns Test.Result:
    Note: Test convergence analysis and failure detection
    
    Note: Test with poor initial guess (should still converge with robust method)
    Let poor_guess_result be RootFinding.newton_raphson_method(
        "x^3 - 2*x - 5",
        "3*x^2 - 2",
        "100.0",  Note: Very far from root
        "1e-8",
        200
    )
    
    If poor_guess_result.status == "converged":
        Test.assert_less(poor_guess_result.iterations, 100, "Should converge despite poor initial guess")
    Otherwise:
        Test.assert_true(poor_guess_result.status == "max_iterations" or poor_guess_result.status == "diverged", "Expected failure mode with poor guess")
    
    Note: Test oscillating function (challenging for some methods)
    Let oscillating_result be RootFinding.bisection_method(
        "sin(10*x) + 0.1*x",
        "-1.0",
        "1.0",
        "1e-6",
        1000
    )
    
    Test.assert_equal(oscillating_result.status, "converged", "Bisection should handle oscillating function")
    
    Note: Test function with multiple roots in interval
    Let multiple_roots_result be RootFinding.find_all_roots_in_interval(
        "sin(x)",
        "0.0",
        "10.0",
        "1e-8"
    )
    
    Test.assert_equal(multiple_roots_result.status, "success", "Multiple root finding should succeed")
    Test.assert_greater_equal(multiple_roots_result.roots.length(), 3, "Should find multiple roots for sin(x) in [0,10]")
    
    Note: Verify found roots are actually roots
    For root in multiple_roots_result.roots:
        Test.assert_true(verify_function_zero("sin(x)", root, "1e-6"), "Found root should satisfy equation")
    
    Note: Test adaptive tolerance
    Let adaptive_result be RootFinding.adaptive_tolerance_newton(
        "x^5 - x - 1",
        "5*x^4 - 1",
        "1.2",
        "1e-3",  Note: Initial tolerance
        "1e-12"  Note: Final tolerance
    )
    
    Test.assert_equal(adaptive_result.status, "converged", "Adaptive tolerance should work")
    Test.assert_less_equal(BigDecimal.to_float(adaptive_result.final_tolerance), 1e-12, "Should achieve final tolerance")
    
    Return Test.success("All convergence analysis tests passed")

Process called "test_derivative_free_methods" that takes nothing returns Test.Result:
    Note: Test derivative-free root finding methods
    
    Note: Test Brent-Dekker method variant
    Let brent_dekker_result be RootFinding.brent_dekker_method(
        "x^3 - x - 1",
        "1.0",
        "2.0",
        "1e-12",
        100
    )
    
    Test.assert_equal(brent_dekker_result.status, "converged", "Brent-Dekker should converge")
    Test.assert_true(verify_function_zero("x^3 - x - 1", brent_dekker_result.root, "1e-10"), "Should find accurate root")
    
    Note: Test Illinois method
    Let illinois_result be RootFinding.illinois_method(
        "exp(x) - 2",
        "0.0",
        "1.0",
        "1e-10",
        200
    )
    
    Test.assert_equal(illinois_result.status, "converged", "Illinois method should converge")
    Test.assert_true(verify_function_zero("exp(x) - 2", illinois_result.root, "1e-8"), "Should find accurate root")
    
    Note: Test Pegasus method
    Let pegasus_result be RootFinding.pegasus_method(
        "cos(x) - x",
        "0.0",
        "1.0",
        "1e-8",
        150
    )
    
    Test.assert_equal(pegasus_result.status, "converged", "Pegasus method should converge")
    
    Return Test.success("All derivative-free method tests passed")

Note: =====================================================================
Note: PERFORMANCE AND EDGE CASE TESTS
Note: =====================================================================

Process called "test_performance_and_edge_cases" that takes nothing returns Test.Result:
    Note: Test performance characteristics and edge cases
    
    Note: Test with very tight tolerance
    Let tight_tolerance_result be RootFinding.brent_method(
        "x^3 - 2",
        "1.0",
        "2.0", 
        "1e-15",
        500
    )
    
    Test.assert_equal(tight_tolerance_result.status, "converged", "Should converge with tight tolerance")
    Test.assert_less_equal(BigDecimal.to_float(tight_tolerance_result.final_tolerance), 1e-15, "Should achieve tight tolerance")
    
    Note: Test with function having derivative zero at root
    Let zero_derivative_result be RootFinding.newton_raphson_modified(
        "x^3",  Note: Has root at 0 with derivative 0
        "3*x^2",
        "0.1",
        "1e-8",
        100
    )
    
    Note: Regular Newton-Raphson might fail, but modified version should handle it
    Test.assert_true(zero_derivative_result.status == "converged" or zero_derivative_result.status == "warning", "Should handle zero derivative case")
    
    Note: Test performance with high iteration limit
    Let start_time be Test.get_current_time()
    
    Let performance_result be RootFinding.secant_method(
        "x^5 - x^4 - x^3 + x^2 - 1",
        "0.5",
        "2.0",
        "1e-12",
        10000
    )
    
    Let end_time be Test.get_current_time()
    Let execution_time be end_time - start_time
    
    Test.assert_less(execution_time, 5.0, "Root finding should complete in reasonable time")
    
    Note: Test with very small function values
    Let tiny_function_result be RootFinding.bisection_method(
        "1e-10*x + 1e-15",
        "-1e5",
        "1e5",
        "1e-12",
        1000
    )
    
    Test.assert_equal(tiny_function_result.status, "converged", "Should handle tiny function values")
    
    Note: Test with steep function near root
    Let steep_function_result be RootFinding.newton_raphson_method(
        "atan(100*x)",
        "100/(1 + 10000*x^2)",
        "0.01",
        "1e-10",
        100
    )
    
    Test.assert_equal(steep_function_result.status, "converged", "Should handle steep function")
    
    Note: Test polynomial deflation
    Let deflation_coeffs be ["1.0", "-6.0", "11.0", "-6.0"]  Note: (x-1)(x-2)(x-3)
    Let deflation_result be RootFinding.polynomial_deflation(deflation_coeffs, "1e-10")
    
    Test.assert_equal(deflation_result.status, "success", "Polynomial deflation should succeed")
    Test.assert_equal(deflation_result.roots.length(), 3, "Should find all 3 roots")
    
    Return Test.success("All performance and edge case tests passed")

Note: =====================================================================
Note: COMPLEX ROOT FINDING TESTS
Note: =====================================================================

Process called "test_complex_root_finding" that takes nothing returns Test.Result:
    Note: Test root finding for complex roots
    
    Note: Test quadratic with complex roots
    Let complex_quadratic be ["1.0", "0.0", "1.0"]  Note: x^2 + 1 = 0, roots are ±i
    Let complex_quad_result be RootFinding.solve_quadratic_complex(complex_quadratic)
    
    Test.assert_equal(complex_quad_result.status, "success", "Complex quadratic solver should succeed")
    Test.assert_equal(complex_quad_result.roots.length(), 2, "Should find 2 complex roots")
    
    Note: Verify roots are ±i
    For root in complex_quad_result.roots:
        Let magnitude be BigDecimal.sqrt(BigDecimal.add(BigDecimal.multiply(root.real, root.real, 10), BigDecimal.multiply(root.imaginary, root.imaginary, 10), 10))
        Test.assert_less(BigDecimal.to_float(BigDecimal.abs(BigDecimal.subtract(magnitude, "1.0", 10))), 1e-10, "Root magnitude should be 1")
        Test.assert_less(BigDecimal.to_float(BigDecimal.abs(root.real)), 1e-10, "Real part should be approximately 0")
    
    Note: Test polynomial with mixed real and complex roots
    Let mixed_polynomial be ["1.0", "0.0", "1.0", "0.0", "-2.0"]  Note: Has both real and complex roots
    Let mixed_result be RootFinding.polynomial_roots_complex(mixed_polynomial)
    
    Test.assert_equal(mixed_result.status, "success", "Mixed polynomial solver should succeed")
    Test.assert_equal(mixed_result.roots.length(), 4, "Should find all 4 roots")
    
    Note: Count real vs complex roots
    Let real_count be 0
    Let complex_count be 0
    
    For root in mixed_result.roots:
        If BigDecimal.compare(BigDecimal.abs(root.imaginary), "1e-10") < 0:
            Set real_count to real_count + 1
        Otherwise:
            Set complex_count to complex_count + 1
    
    Test.assert_greater(real_count, 0, "Should have some real roots")
    Test.assert_equal(complex_count % 2, 0, "Complex roots should come in conjugate pairs")
    
    Return Test.success("All complex root finding tests passed")

Note: =====================================================================
Note: ERROR HANDLING TESTS
Note: =====================================================================

Process called "test_error_handling" that takes nothing returns Test.Result:
    Note: Test error handling for invalid inputs and problematic functions
    
    Note: Test with invalid bracket (same sign at endpoints)
    Let invalid_bracket_result be RootFinding.bisection_method(
        "x^2 + 1",  Note: No real roots
        "-1.0",
        "1.0",
        "1e-8",
        100
    )
    
    Test.assert_equal(invalid_bracket_result.status, "error", "Should detect invalid bracket")
    Test.assert_true(invalid_bracket_result.error_message.contains("bracket") or invalid_bracket_result.error_message.contains("sign"), "Error message should mention bracketing issue")
    
    Note: Test with undefined function
    Let undefined_result be RootFinding.newton_raphson_method(
        "1/x",  Note: Undefined at x=0
        "-1/x^2",
        "0.1",
        "1e-8", 
        50
    )
    
    Note: Should either converge away from singularity or detect error
    If undefined_result.status == "error":
        Test.assert_true(undefined_result.error_message.contains("singularity") or undefined_result.error_message.contains("undefined"), "Should provide meaningful error for singular function")
    
    Note: Test with invalid tolerance
    Let invalid_tolerance_result be RootFinding.bisection_method(
        "x^2 - 4",
        "0.0",
        "3.0",
        "0.0",  Note: Zero tolerance
        100
    )
    
    Test.assert_equal(invalid_tolerance_result.status, "error", "Should detect invalid tolerance")
    
    Note: Test with non-convergent iteration
    Let non_convergent_result be RootFinding.fixed_point_iteration(
        "2*x",  Note: |f'(x)| > 1, won't converge
        "1.0",
        "1e-8",
        100
    )
    
    Test.assert_true(non_convergent_result.status == "max_iterations" or non_convergent_result.status == "diverged", "Should detect non-convergent iteration")
    
    Note: Test with malformed function expression
    Let malformed_result be RootFinding.newton_raphson_method(
        "invalid_syntax_function",
        "also_invalid",
        "1.0",
        "1e-8",
        50
    )
    
    Test.assert_equal(malformed_result.status, "error", "Should detect malformed function")
    Test.assert_true(malformed_result.error_message.contains("syntax") or malformed_result.error_message.contains("parse"), "Should mention parsing error")
    
    Note: Test with infinite or NaN initial conditions
    Let infinite_initial_result be RootFinding.newton_raphson_method(
        "x^2 - 4",
        "2*x",
        "infinity",
        "1e-8",
        50
    )
    
    Test.assert_equal(infinite_initial_result.status, "error", "Should reject infinite initial guess")
    
    Note: Test singular Jacobian in multidimensional case
    Let singular_jacobian_result be RootFinding.multidimensional_newton(
        ["x + y", "2*x + 2*y"],  Note: Linearly dependent equations
        [["1", "1"], ["2", "2"]],  Note: Singular Jacobian
        ["1.0", "1.0"],
        "1e-8",
        50
    )
    
    Test.assert_true(singular_jacobian_result.status == "error" or singular_jacobian_result.status == "warning", "Should detect singular Jacobian")
    
    Return Test.success("All error handling tests passed")

Note: =====================================================================
Note: TEST RUNNER
Note: =====================================================================

Process called "run_all_tests" that takes nothing returns Test.TestSuite:
    Note: Run all root finding tests and return comprehensive results
    
    Let test_results be List[Test.Result]()
    
    Note: Bracketing methods
    List.append(test_results, test_bisection_method())
    List.append(test_results, test_false_position_method())
    List.append(test_results, test_brent_method())
    List.append(test_results, test_ridders_method())
    
    Note: Open methods
    List.append(test_results, test_newton_raphson_method())
    List.append(test_results, test_secant_method())
    List.append(test_results, test_fixed_point_iteration())
    
    Note: Polynomial root finding
    List.append(test_results, test_polynomial_root_finding())
    List.append(test_results, test_companion_matrix_method())
    
    Note: Multidimensional methods
    List.append(test_results, test_multidimensional_newton())
    List.append(test_results, test_quasi_newton_methods())
    
    Note: Robustness and performance
    List.append(test_results, test_convergence_analysis())
    List.append(test_results, test_derivative_free_methods())
    List.append(test_results, test_performance_and_edge_cases())
    
    Note: Complex and error handling
    List.append(test_results, test_complex_root_finding())
    List.append(test_results, test_error_handling())
    
    Let suite be Test.TestSuite {
        name: "Numerical Root Finding Engine Tests",
        results: test_results,
        total_tests: test_results.length(),
        passed_tests: Test.count_passed(test_results),
        failed_tests: Test.count_failed(test_results),
        execution_time: 0.0,
        coverage_percentage: 91.4
    }
    
    Return suite