Note:
tests/unit/libraries/math/engine/numerical/ode_test.runa
Comprehensive Unit Tests for Ordinary Differential Equations Engine

This module provides comprehensive unit tests for ODE solving including:
- Explicit methods (Euler, Runge-Kutta families)
- Implicit methods (backward Euler, BDF methods)
- Adaptive step-size control (Dormand-Prince, Cash-Karp)
- Stiff equation solvers (Rosenbrock, RADAU)
- Boundary value problems (shooting, finite difference)
- System of ODEs and higher-order equations
- Stability analysis and error estimation
:End Note

Import "dev/test/core" as Test
Import "math/engine/numerical/ode" as ODE
Import "math/precision/bigdecimal" as BigDecimal
Import "math/core/constants" as Constants

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "assert_solution_accuracy" that takes expected as String, actual as String, tolerance as String, message as String returns nothing:
    Note: Assert ODE solution is within expected tolerance
    Let difference be BigDecimal.abs(BigDecimal.subtract(actual, expected, 15))
    
    If BigDecimal.compare(difference, tolerance) > 0:
        Test.assert_fail(message + " Expected: " + expected + ", Got: " + actual + ", Error: " + difference + ", Tolerance: " + tolerance)

Process called "create_analytical_solutions" that takes nothing returns Dictionary[String, Dictionary]:
    Note: Create analytical solutions for test ODEs
    Return {
        "exponential": {
            "equation": "dy/dx = y",
            "initial_condition": { x: "0.0", y: "1.0" },
            "solution": "exp(x)",
            "description": "Simple exponential growth"
        },
        "linear": {
            "equation": "dy/dx = -2*x",
            "initial_condition": { x: "0.0", y: "1.0" },
            "solution": "1 - x^2",
            "description": "Linear ODE with quadratic solution"
        },
        "oscillatory": {
            "equation": "d^2y/dx^2 + y = 0",
            "initial_conditions": { x: "0.0", y: "1.0", dy: "0.0" },
            "solution": "cos(x)",
            "description": "Simple harmonic oscillator"
        },
        "logistic": {
            "equation": "dy/dx = y*(1-y)",
            "initial_condition": { x: "0.0", y: "0.1" },
            "solution": "1/(1 + 9*exp(-x))",
            "description": "Logistic growth equation"
        }
    }

Process called "evaluate_analytical_solution" that takes solution_type as String, x_value as String returns String:
    Note: Evaluate analytical solution at given x
    Let solutions be create_analytical_solutions()
    Let solution_info be solutions[solution_type]
    
    If solution_type == "exponential":
        Return BigDecimal.exp(x_value)
    Otherwise If solution_type == "linear":
        Return BigDecimal.subtract("1.0", BigDecimal.multiply(x_value, x_value, 10), 10)
    Otherwise If solution_type == "oscillatory":
        Return BigDecimal.cos(x_value)
    Otherwise If solution_type == "logistic":
        Let exp_neg_x be BigDecimal.exp(BigDecimal.multiply("-1.0", x_value, 10))
        Return BigDecimal.divide("1.0", BigDecimal.add("1.0", BigDecimal.multiply("9.0", exp_neg_x, 10), 10), 10)
    
    Return "0.0"

Process called "create_test_ode_system" that takes system_type as String returns Dictionary:
    Note: Create test ODE systems
    
    If system_type == "predator_prey":
        Return {
            "equations": ["dx/dt = a*x - b*x*y", "dy/dt = -c*y + d*x*y"],
            "parameters": { a: "1.0", b: "0.1", c: "1.5", d: "0.075" },
            "initial_conditions": { x: "10.0", y: "5.0" },
            "description": "Lotka-Volterra predator-prey model"
        }
    
    If system_type == "van_der_pol":
        Return {
            "equations": ["dx/dt = y", "dy/dt = mu*(1-x^2)*y - x"],
            "parameters": { mu: "1.0" },
            "initial_conditions": { x: "2.0", y: "0.0" },
            "description": "Van der Pol oscillator (nonlinear)"
        }
    
    If system_type == "lorenz":
        Return {
            "equations": ["dx/dt = sigma*(y-x)", "dy/dt = x*(rho-z) - y", "dz/dt = x*y - beta*z"],
            "parameters": { sigma: "10.0", rho: "28.0", beta: "8/3" },
            "initial_conditions": { x: "1.0", y: "1.0", z: "1.0" },
            "description": "Lorenz system (chaotic)"
        }
    
    Return {}

Process called "verify_ode_solver_properties" that takes solver_result as Dictionary, expected_properties as Dictionary returns List[String]:
    Note: Verify ODE solver maintains expected mathematical properties
    Let violations be []
    
    Note: Check energy conservation for Hamiltonian systems
    If expected_properties.conserves_energy:
        Let energy_drift be BigDecimal.abs(BigDecimal.subtract(solver_result.final_energy, solver_result.initial_energy, 10))
        If BigDecimal.compare(energy_drift, expected_properties.energy_tolerance) > 0:
            List.append(violations, "Energy conservation violated: drift = " + energy_drift)
    
    Note: Check monotonicity for appropriate equations
    If expected_properties.monotonic:
        For i in range(1, solver_result.solution_points.length()):
            Let current be solver_result.solution_points[i].y
            Let previous be solver_result.solution_points[i-1].y
            If expected_properties.increasing and BigDecimal.compare(current, previous) < 0:
                List.append(violations, "Monotonicity violated at step " + Integer.to_string(i))
    
    Note: Check stability properties
    If expected_properties.check_stability:
        Let final_value be solver_result.solution_points[solver_result.solution_points.length()-1].y
        If BigDecimal.compare(BigDecimal.abs(final_value), expected_properties.stability_bound) > 0:
            List.append(violations, "Solution became unstable: |y| = " + BigDecimal.abs(final_value))
    
    Return violations

Note: =====================================================================
Note: EXPLICIT METHODS TESTS
Note: =====================================================================

Process called "test_euler_method" that takes nothing returns Test.Result:
    Note: Test Euler's method with known analytical solutions
    
    Let analytical_solutions be create_analytical_solutions()
    
    For solution_name in ["exponential", "linear"]:
        Let solution_info be analytical_solutions[solution_name]
        
        Let result be ODE.euler_method(
            solution_info.equation,
            solution_info.initial_condition.x,
            solution_info.initial_condition.y,
            "1.0",  Note: Final x
            "0.01"  Note: Step size
        )
        
        Test.assert_equal(result.status, "success", "Euler method should succeed for " + solution_name)
        Test.assert_greater(result.solution_points.length(), 90, "Should generate sufficient points")
        
        Note: Check accuracy at final point
        Let final_point be result.solution_points[result.solution_points.length()-1]
        Let analytical_value be evaluate_analytical_solution(solution_name, final_point.x)
        
        Let tolerance be solution_name == "exponential" ? "0.1" : "0.01"  Note: Euler is first-order
        assert_solution_accuracy(analytical_value, final_point.y, tolerance, "Euler accuracy for " + solution_name)
        
        Note: Verify step size consistency
        Test.assert_less(BigDecimal.to_float(BigDecimal.abs(BigDecimal.subtract(final_point.x, "1.0", 10))), 0.02, "Should reach target x-value")
    
    Return Test.success("All Euler method tests passed")

Process called "test_runge_kutta_methods" that takes nothing returns Test.Result:
    Note: Test various Runge-Kutta methods
    
    Let test_equation be "dy/dx = -2*x*y"  Note: Solution: y = exp(-x^2)
    Let initial_x be "0.0"
    Let initial_y be "1.0"
    Let final_x be "1.0"
    Let step_size be "0.1"
    
    Note: Test RK2 (Heun's method)
    Let rk2_result be ODE.runge_kutta_2(test_equation, initial_x, initial_y, final_x, step_size)
    
    Test.assert_equal(rk2_result.status, "success", "RK2 method should succeed")
    
    Let rk2_final be rk2_result.solution_points[rk2_result.solution_points.length()-1]
    Let analytical_final be BigDecimal.exp(BigDecimal.multiply("-1.0", BigDecimal.multiply(final_x, final_x, 10), 10))
    
    assert_solution_accuracy(analytical_final, rk2_final.y, "0.01", "RK2 accuracy")
    
    Note: Test RK4 (classical fourth-order)
    Let rk4_result be ODE.runge_kutta_4(test_equation, initial_x, initial_y, final_x, step_size)
    
    Test.assert_equal(rk4_result.status, "success", "RK4 method should succeed")
    
    Let rk4_final be rk4_result.solution_points[rk4_result.solution_points.length()-1]
    
    assert_solution_accuracy(analytical_final, rk4_final.y, "0.001", "RK4 should be more accurate than RK2")
    
    Note: Verify RK4 is more accurate than RK2
    Let rk2_error be BigDecimal.abs(BigDecimal.subtract(rk2_final.y, analytical_final, 15))
    Let rk4_error be BigDecimal.abs(BigDecimal.subtract(rk4_final.y, analytical_final, 15))
    
    Test.assert_less(BigDecimal.to_float(rk4_error), BigDecimal.to_float(rk2_error), "RK4 should be more accurate than RK2")
    
    Note: Test RK45 (Fehlberg method with error estimation)
    Let rk45_result be ODE.runge_kutta_45(test_equation, initial_x, initial_y, final_x, "0.01", "1e-6")
    
    Test.assert_equal(rk45_result.status, "success", "RK45 method should succeed")
    Test.assert_greater(rk45_result.error_estimates.length(), 0, "RK45 should provide error estimates")
    
    Note: Check adaptive behavior
    Test.assert_greater(rk45_result.step_size_changes, 0, "Should adapt step size")
    Test.assert_less(rk45_result.max_error_estimate, 1e-5, "Should maintain error tolerance")
    
    Return Test.success("All Runge-Kutta method tests passed")

Process called "test_adaptive_methods" that takes nothing returns Test.Result:
    Note: Test adaptive step-size methods
    
    Note: Test Dormand-Prince method
    Let dp_result be ODE.dormand_prince(
        "dy/dx = y",
        "0.0",
        "1.0",
        "2.0",
        "0.1",  Note: Initial step size
        "1e-8"  Note: Error tolerance
    )
    
    Test.assert_equal(dp_result.status, "success", "Dormand-Prince should succeed")
    Test.assert_greater(dp_result.step_acceptances, 10, "Should accept multiple steps")
    Test.assert_greater(dp_result.step_rejections, 0, "Should reject some steps for accuracy")
    
    Note: Verify final accuracy
    Let dp_final be dp_result.solution_points[dp_result.solution_points.length()-1]
    Let expected_final be BigDecimal.exp("2.0")
    
    assert_solution_accuracy(expected_final, dp_final.y, "1e-6", "Dormand-Prince should be highly accurate")
    
    Note: Test Cash-Karp method
    Let ck_result be ODE.cash_karp(
        "dy/dx = sin(x)",
        "0.0",
        "0.0",
        Constants.get_pi(),
        "0.1",
        "1e-6"
    )
    
    Test.assert_equal(ck_result.status, "success", "Cash-Karp should succeed")
    
    Let ck_final be ck_result.solution_points[ck_result.solution_points.length()-1]
    Let expected_integral be "2.0"  Note: +€^À sin(x) dx = 2
    
    assert_solution_accuracy(expected_integral, ck_final.y, "1e-5", "Cash-Karp accuracy")
    
    Note: Test Bogacki-Shampine method
    Let bs_result be ODE.bogacki_shampine(
        "dy/dx = -y + x",
        "0.0",
        "1.0",
        "1.0",
        "0.1",
        "1e-7"
    )
    
    Test.assert_equal(bs_result.status, "success", "Bogacki-Shampine should succeed")
    
    Note: Check error control effectiveness
    Test.assert_less(bs_result.max_error_estimate, 1e-6, "Should maintain tight error control")
    Test.assert_greater(bs_result.efficiency_index, 0.5, "Should be computationally efficient")
    
    Return Test.success("All adaptive method tests passed")

Note: =====================================================================
Note: IMPLICIT METHODS TESTS
Note: =====================================================================

Process called "test_implicit_methods" that takes nothing returns Test.Result:
    Note: Test implicit methods for stiff equations
    
    Note: Test backward Euler method
    Let stiff_equation be "dy/dx = -1000*y + 1000*sin(x)"  Note: Stiff equation
    
    Let backward_euler_result be ODE.backward_euler(
        stiff_equation,
        "0.0",
        "0.0",
        "1.0",
        "0.01"
    )
    
    Test.assert_equal(backward_euler_result.status, "success", "Backward Euler should handle stiff equation")
    Test.assert_less(backward_euler_result.newton_iterations_total, 1000, "Should converge efficiently")
    
    Note: Test trapezoidal method
    Let trapezoidal_result be ODE.trapezoidal_method(
        "dy/dx = -y^2",
        "0.0",
        "1.0",
        "2.0",
        "0.1"
    )
    
    Test.assert_equal(trapezoidal_result.status, "success", "Trapezoidal method should succeed")
    
    Note: Verify A-stability for linear test equation
    Let linear_stiff_result be ODE.trapezoidal_method(
        "dy/dx = -100*y",
        "0.0",
        "1.0",
        "1.0",
        "0.1"  Note: Large step size that would be unstable for explicit methods
    )
    
    Test.assert_equal(linear_stiff_result.status, "success", "Trapezoidal should be A-stable")
    
    Let final_value be linear_stiff_result.solution_points[linear_stiff_result.solution_points.length()-1].y
    Test.assert_less(BigDecimal.to_float(BigDecimal.abs(final_value)), 0.1, "Should remain stable with large steps")
    
    Note: Test BDF methods
    Let bdf2_result be ODE.bdf_method(
        stiff_equation,
        "0.0",
        "0.0",
        "0.5",
        "0.01",
        2  Note: Second-order BDF
    )
    
    Test.assert_equal(bdf2_result.status, "success", "BDF2 should handle stiff equation")
    Test.assert_greater_equal(bdf2_result.accuracy_order, 2, "BDF2 should be second-order accurate")
    
    Return Test.success("All implicit method tests passed")

Process called "test_stiff_solvers" that takes nothing returns Test.Result:
    Note: Test specialized stiff equation solvers
    
    Note: Test Rosenbrock method
    Let rosenbrock_result be ODE.rosenbrock_method(
        ["dy1/dx = -1001*y1 + 1000*y2", "dy2/dx = y1 - y2"],
        ["y1", "y2"],
        "0.0",
        ["1.0", "0.0"],
        "1.0",
        "0.01",
        "1e-6"
    )
    
    Test.assert_equal(rosenbrock_result.status, "success", "Rosenbrock should handle stiff system")
    Test.assert_greater(rosenbrock_result.jacobian_evaluations, 0, "Should evaluate Jacobian")
    Test.assert_less(rosenbrock_result.step_rejections, rosenbrock_result.step_acceptances, "Should have good step acceptance rate")
    
    Note: Test RADAU5 method
    Let radau_result be ODE.radau5_method(
        "dy/dx = -1000*(y - cos(x)) - sin(x)",
        "0.0",
        "1.0",
        "1.0",
        "0.1",
        "1e-8"
    )
    
    Test.assert_equal(radau_result.status, "success", "RADAU5 should succeed")
    Test.assert_equal(radau_result.accuracy_order, 5, "RADAU5 should be fifth-order accurate")
    
    Let radau_final be radau_result.solution_points[radau_result.solution_points.length()-1]
    Let expected_radau be BigDecimal.cos("1.0")  Note: Analytical solution
    
    assert_solution_accuracy(expected_radau, radau_final.y, "1e-6", "RADAU5 should be highly accurate")
    
    Note: Test DASSL method for differential-algebraic equations
    Let dassl_result be ODE.dassl_method(
        ["dy1/dx = y2", "0 = y1^2 + y2^2 - 1"],  Note: Constrained motion on unit circle
        ["y1", "y2"],
        "0.0",
        ["1.0", "0.0"],
        "1.0",
        "0.01"
    )
    
    Test.assert_equal(dassl_result.status, "success", "DASSL should handle DAE")
    
    Note: Verify constraint satisfaction
    For point in dassl_result.solution_points:
        Let constraint_violation be BigDecimal.abs(BigDecimal.subtract(
            BigDecimal.add(BigDecimal.multiply(point.y1, point.y1, 10), BigDecimal.multiply(point.y2, point.y2, 10), 10),
            "1.0",
            10
        ))
        Test.assert_less(BigDecimal.to_float(constraint_violation), 1e-6, "Should satisfy constraint y1² + y2² = 1")
    
    Return Test.success("All stiff solver tests passed")

Note: =====================================================================
Note: SYSTEM OF ODES TESTS
Note: =====================================================================

Process called "test_ode_systems" that takes nothing returns Test.Result:
    Note: Test systems of ordinary differential equations
    
    Note: Test predator-prey system
    Let predator_prey be create_test_ode_system("predator_prey")
    
    Let pp_result be ODE.solve_system(
        predator_prey.equations,
        "0.0",
        [predator_prey.initial_conditions.x, predator_prey.initial_conditions.y],
        "10.0",
        "0.01",
        "runge_kutta_4"
    )
    
    Test.assert_equal(pp_result.status, "success", "Predator-prey system should solve")
    Test.assert_equal(pp_result.variables.length(), 2, "Should track both populations")
    
    Note: Verify oscillatory behavior
    Let x_values be []
    Let y_values be []
    
    For point in pp_result.solution_points:
        List.append(x_values, point.variables[0])
        List.append(y_values, point.variables[1])
    
    Note: Check that populations oscillate (have multiple local maxima/minima)
    Let x_extrema be ODE.find_extrema(x_values)
    Let y_extrema be ODE.find_extrema(y_values)
    
    Test.assert_greater_equal(x_extrema.maxima.length(), 2, "Predator population should oscillate")
    Test.assert_greater_equal(y_extrema.maxima.length(), 2, "Prey population should oscillate")
    
    Note: Test Van der Pol oscillator
    Let van_der_pol be create_test_ode_system("van_der_pol")
    
    Let vdp_result be ODE.solve_system(
        van_der_pol.equations,
        "0.0",
        [van_der_pol.initial_conditions.x, van_der_pol.initial_conditions.y],
        "20.0",
        "0.01",
        "dormand_prince"
    )
    
    Test.assert_equal(vdp_result.status, "success", "Van der Pol system should solve")
    
    Note: Verify limit cycle behavior (should approach periodic solution)
    Let final_portion be vdp_result.solution_points.slice(vdp_result.solution_points.length() - 100, vdp_result.solution_points.length())
    Let period_estimate be ODE.estimate_period(final_portion)
    
    Test.assert_greater(period_estimate, 5.0, "Van der Pol should have reasonable period")
    Test.assert_less(period_estimate, 8.0, "Period should be within expected range")
    
    Note: Test Lorenz system (chaotic)
    Let lorenz be create_test_ode_system("lorenz")
    
    Let lorenz_result be ODE.solve_system(
        lorenz.equations,
        "0.0",
        [lorenz.initial_conditions.x, lorenz.initial_conditions.y, lorenz.initial_conditions.z],
        "30.0",
        "0.001",
        "runge_kutta_45"
    )
    
    Test.assert_equal(lorenz_result.status, "success", "Lorenz system should solve")
    Test.assert_equal(lorenz_result.variables.length(), 3, "Should track all three variables")
    
    Note: Verify chaotic behavior (sensitive dependence on initial conditions)
    Let perturbed_result be ODE.solve_system(
        lorenz.equations,
        "0.0",
        ["1.000001", "1.0", "1.0"],  Note: Tiny perturbation
        "30.0",
        "0.001",
        "runge_kutta_45"
    )
    
    Let final_original be lorenz_result.solution_points[lorenz_result.solution_points.length()-1]
    Let final_perturbed be perturbed_result.solution_points[perturbed_result.solution_points.length()-1]
    
    Let divergence be BigDecimal.sqrt(
        BigDecimal.add(
            BigDecimal.add(
                BigDecimal.multiply(BigDecimal.subtract(final_original.variables[0], final_perturbed.variables[0], 10), BigDecimal.subtract(final_original.variables[0], final_perturbed.variables[0], 10), 10),
                BigDecimal.multiply(BigDecimal.subtract(final_original.variables[1], final_perturbed.variables[1], 10), BigDecimal.subtract(final_original.variables[1], final_perturbed.variables[1], 10), 10),
                10
            ),
            BigDecimal.multiply(BigDecimal.subtract(final_original.variables[2], final_perturbed.variables[2], 10), BigDecimal.subtract(final_original.variables[2], final_perturbed.variables[2], 10), 10),
            10
        )
    )
    
    Test.assert_greater(BigDecimal.to_float(divergence), 1.0, "Lorenz system should show chaotic divergence")
    
    Return Test.success("All ODE system tests passed")

Note: =====================================================================
Note: HIGHER-ORDER EQUATIONS TESTS
Note: =====================================================================

Process called "test_higher_order_odes" that takes nothing returns Test.Result:
    Note: Test higher-order ordinary differential equations
    
    Note: Test second-order harmonic oscillator: y'' + É²y = 0
    Let omega be "2.0"
    Let oscillator_result be ODE.solve_second_order(
        "d^2y/dx^2 + " + BigDecimal.multiply(omega, omega, 10) + "*y",
        "0.0",           Note: Initial x
        "1.0",           Note: Initial y
        "0.0",           Note: Initial dy/dx
        Constants.get_pi(),  Note: Final x (half period)
        "0.01"
    )
    
    Test.assert_equal(oscillator_result.status, "success", "Second-order oscillator should solve")
    
    Let final_point be oscillator_result.solution_points[oscillator_result.solution_points.length()-1]
    Let expected_y be BigDecimal.cos(BigDecimal.multiply(omega, Constants.get_pi(), 10))
    Let expected_dy be BigDecimal.multiply("-1.0", BigDecimal.multiply(omega, BigDecimal.sin(BigDecimal.multiply(omega, Constants.get_pi(), 10)), 10), 10)
    
    assert_solution_accuracy(expected_y, final_point.y, "0.01", "Oscillator position accuracy")
    assert_solution_accuracy(expected_dy, final_point.dy_dx, "0.1", "Oscillator velocity accuracy")
    
    Note: Test damped harmonic oscillator: y'' + 2³y' + É²y = 0
    Let gamma be "0.1"
    Let damped_result be ODE.solve_second_order(
        "d^2y/dx^2 + " + BigDecimal.multiply("2.0", gamma, 10) + "*dy/dx + " + BigDecimal.multiply(omega, omega, 10) + "*y",
        "0.0",
        "1.0",
        "0.0",
        "10.0",
        "0.01"
    )
    
    Test.assert_equal(damped_result.status, "success", "Damped oscillator should solve")
    
    Note: Verify energy dissipation
    Let initial_energy be ODE.calculate_mechanical_energy(damped_result.solution_points[0], omega)
    Let final_energy be ODE.calculate_mechanical_energy(damped_result.solution_points[damped_result.solution_points.length()-1], omega)
    
    Test.assert_less(BigDecimal.to_float(final_energy), BigDecimal.to_float(initial_energy), "Damped oscillator should lose energy")
    
    Note: Test forced harmonic oscillator: y'' + É²y = A*cos(©t)
    Let forcing_amplitude be "0.5"
    Let forcing_frequency be "1.5"
    
    Let forced_result be ODE.solve_second_order(
        "d^2y/dx^2 + " + BigDecimal.multiply(omega, omega, 10) + "*y = " + forcing_amplitude + "*cos(" + forcing_frequency + "*x)",
        "0.0",
        "0.0",
        "0.0",
        "20.0",
        "0.01"
    )
    
    Test.assert_equal(forced_result.status, "success", "Forced oscillator should solve")
    
    Note: Verify steady-state amplitude
    Let steady_state_points be forced_result.solution_points.slice(forced_result.solution_points.length() - 100, forced_result.solution_points.length())
    Let amplitude_estimate be ODE.estimate_amplitude(steady_state_points)
    
    Let theoretical_amplitude be BigDecimal.divide(
        forcing_amplitude,
        BigDecimal.abs(BigDecimal.subtract(BigDecimal.multiply(omega, omega, 10), BigDecimal.multiply(forcing_frequency, forcing_frequency, 10), 10)),
        10
    )
    
    assert_solution_accuracy(theoretical_amplitude, amplitude_estimate, "0.1", "Forced oscillator amplitude")
    
    Note: Test third-order equation
    Let third_order_result be ODE.solve_nth_order(
        "d^3y/dx^3 - 6*d^2y/dx^2 + 11*dy/dx - 6*y = 0",
        3,  Note: Order
        "0.0",
        ["1.0", "0.0", "0.0"],  Note: Initial conditions: y, y', y''
        "2.0",
        "0.01"
    )
    
    Test.assert_equal(third_order_result.status, "success", "Third-order equation should solve")
    Test.assert_equal(third_order_result.derivatives.length(), 3, "Should track all derivatives")
    
    Return Test.success("All higher-order ODE tests passed")

Note: =====================================================================
Note: BOUNDARY VALUE PROBLEMS TESTS
Note: =====================================================================

Process called "test_boundary_value_problems" that takes nothing returns Test.Result:
    Note: Test boundary value problems
    
    Note: Test shooting method for y'' + y = 0, y(0) = 0, y(À) = 0
    Let shooting_result be ODE.shooting_method(
        "d^2y/dx^2 + y",
        "0.0",           Note: Left boundary
        Constants.get_pi(),  Note: Right boundary
        "0.0",           Note: y(0) = 0
        "0.0",           Note: y(À) = 0
        "1.0"            Note: Initial guess for y'(0)
    )
    
    Test.assert_equal(shooting_result.status, "success", "Shooting method should succeed")
    
    Note: Verify boundary conditions are satisfied
    Let left_boundary_error be BigDecimal.abs(shooting_result.solution_points[0].y)
    Let right_boundary_error be BigDecimal.abs(shooting_result.solution_points[shooting_result.solution_points.length()-1].y)
    
    Test.assert_less(BigDecimal.to_float(left_boundary_error), 1e-10, "Left boundary condition should be satisfied")
    Test.assert_less(BigDecimal.to_float(right_boundary_error), 1e-8, "Right boundary condition should be satisfied")
    
    Note: Test finite difference method
    Let fd_result be ODE.finite_difference_bvp(
        "d^2y/dx^2 - y = -x",
        "0.0",
        "2.0",
        "0.0",  Note: y(0) = 0
        "0.0",  Note: y(2) = 0
        100     Note: Number of interior points
    )
    
    Test.assert_equal(fd_result.status, "success", "Finite difference BVP should succeed")
    Test.assert_equal(fd_result.grid_points.length(), 102, "Should have correct number of grid points")
    
    Note: Verify boundary conditions
    Test.assert_less(BigDecimal.to_float(BigDecimal.abs(fd_result.solution_values[0])), 1e-12, "FD left boundary")
    Test.assert_less(BigDecimal.to_float(BigDecimal.abs(fd_result.solution_values[fd_result.solution_values.length()-1])), 1e-12, "FD right boundary")
    
    Note: Test collocation method
    Let collocation_result be ODE.collocation_method(
        "d^2y/dx^2 + y = sin(x)",
        "0.0",
        Constants.get_pi(),
        "0.0",  Note: y(0) = 0
        "0.0",  Note: y(À) = 0
        "chebyshev",  Note: Collocation points
        8       Note: Number of collocation points
    )
    
    Test.assert_equal(collocation_result.status, "success", "Collocation method should succeed")
    Test.assert_less(collocation_result.residual_norm, 1e-8, "Should minimize equation residual")
    
    Note: Test eigenvalue problem: y'' + »y = 0, y(0) = y(À) = 0
    Let eigenvalue_result be ODE.sturm_liouville_eigenvalues(
        "d^2y/dx^2 + lambda*y",
        "0.0",
        Constants.get_pi(),
        "dirichlet_zero",  Note: Both boundaries zero
        10  Note: Find first 10 eigenvalues
    )
    
    Test.assert_equal(eigenvalue_result.status, "success", "Eigenvalue problem should succeed")
    Test.assert_equal(eigenvalue_result.eigenvalues.length(), 10, "Should find requested eigenvalues")
    
    Note: Verify eigenvalues are n² (for this specific problem)
    For i in range(0, 10):
        Let expected_eigenvalue be BigDecimal.multiply(Integer.to_string(i+1), Integer.to_string(i+1), 10)
        assert_solution_accuracy(expected_eigenvalue, eigenvalue_result.eigenvalues[i], "0.01", "Eigenvalue " + Integer.to_string(i+1))
    
    Return Test.success("All boundary value problem tests passed")

Note: =====================================================================
Note: STABILITY AND ERROR ANALYSIS TESTS
Note: =====================================================================

Process called "test_stability_analysis" that takes nothing returns Test.Result:
    Note: Test stability analysis of ODE methods
    
    Note: Test A-stability of implicit methods
    Let test_lambda be "-100.0"  Note: Stiff decay
    Let test_equation be "dy/dx = " + test_lambda + "*y"
    
    Note: Test explicit Euler (should be unstable for large steps)
    Let explicit_unstable be ODE.euler_method(test_equation, "0.0", "1.0", "1.0", "0.1")
    
    Let explicit_final be explicit_unstable.solution_points[explicit_unstable.solution_points.length()-1].y
    Test.assert_greater(BigDecimal.to_float(BigDecimal.abs(explicit_final)), 10.0, "Explicit Euler should be unstable with large step")
    
    Note: Test implicit Euler (should be stable)
    Let implicit_stable be ODE.backward_euler(test_equation, "0.0", "1.0", "1.0", "0.1")
    
    Let implicit_final be implicit_stable.solution_points[implicit_stable.solution_points.length()-1].y
    Test.assert_less(BigDecimal.to_float(BigDecimal.abs(implicit_final)), 1.0, "Implicit Euler should be stable")
    
    Note: Test stability region analysis
    Let stability_analysis be ODE.analyze_stability_region("runge_kutta_4")
    
    Test.assert_equal(stability_analysis.status, "success", "Stability analysis should succeed")
    Test.assert_greater(stability_analysis.stability_boundary.length(), 0, "Should define stability boundary")
    Test.assert_less(BigDecimal.to_float(stability_analysis.stability_interval_real), 0.0, "RK4 should have negative real stability limit")
    
    Note: Test order of convergence
    Let convergence_study be ODE.convergence_order_study(
        "dy/dx = -y",
        "0.0",
        "1.0",
        "1.0",
        "euler_method",
        [0.1, 0.05, 0.025, 0.0125]  Note: Sequence of step sizes
    )
    
    Test.assert_equal(convergence_study.status, "success", "Convergence study should succeed")
    Test.assert_greater(convergence_study.observed_order, 0.8, "Euler should show first-order convergence")
    Test.assert_less(convergence_study.observed_order, 1.2, "Order should be close to theoretical value")
    
    Note: Test error estimation accuracy
    Let error_test be ODE.dormand_prince(
        "dy/dx = sin(x)",
        "0.0",
        "0.0",
        Constants.get_pi(),
        "0.1",
        "1e-8"
    )
    
    Note: Compare estimated vs actual error
    For i in range(0, error_test.solution_points.length()):
        Let point be error_test.solution_points[i]
        Let analytical be BigDecimal.subtract("1.0", BigDecimal.cos(point.x), 10)
        Let actual_error be BigDecimal.abs(BigDecimal.subtract(point.y, analytical, 15))
        Let estimated_error be error_test.error_estimates[i]
        
        Note: Error estimate should be within an order of magnitude of actual error
        Let error_ratio be BigDecimal.divide(actual_error, estimated_error, 10)
        Test.assert_less(BigDecimal.to_float(error_ratio), 10.0, "Error estimate should be reasonable")
        Test.assert_greater(BigDecimal.to_float(error_ratio), 0.1, "Error estimate should not be too conservative")
    
    Return Test.success("All stability analysis tests passed")

Note: =====================================================================
Note: PERFORMANCE AND EDGE CASE TESTS
Note: =====================================================================

Process called "test_performance_and_edge_cases" that takes nothing returns Test.Result:
    Note: Test performance and edge cases
    
    Note: Test very small time scales
    Let microscale_result be ODE.runge_kutta_4(
        "dy/dx = -1e6*y",
        "0.0",
        "1.0",
        "1e-3",
        "1e-9"
    )
    
    Test.assert_equal(microscale_result.status, "success", "Should handle microscale problems")
    Test.assert_greater(microscale_result.solution_points.length(), 100, "Should generate sufficient points")
    
    Note: Test very large time scales
    Let macroscale_result be ODE.adaptive_rk45(
        "dy/dx = -1e-6*y",
        "0.0",
        "1.0",
        "1e6",
        "1e-6"
    )
    
    Test.assert_equal(macroscale_result.status, "success", "Should handle macroscale problems")
    Test.assert_less(macroscale_result.total_function_evaluations, 100000, "Should be efficient for smooth solutions")
    
    Note: Test nearly singular problems
    Let singular_result be ODE.solve_with_regularization(
        "dy/dx = y/(x + 1e-15)",  Note: Nearly singular at x=0
        "1e-10",  Note: Start slightly away from singularity
        "1.0",
        "1.0",
        "0.001"
    )
    
    Test.assert_equal(singular_result.status, "success", "Should handle near-singular problems")
    Test.assert_greater(singular_result.regularization_parameter, 0.0, "Should apply regularization")
    
    Note: Test oscillatory solutions with many periods
    Let oscillatory_result be ODE.runge_kutta_45(
        "dy/dx = cos(100*x)",  Note: High frequency oscillation
        "0.0",
        "0.0",
        "10.0",  Note: Many periods
        "1e-8"
    )
    
    Test.assert_equal(oscillatory_result.status, "success", "Should handle oscillatory solutions")
    Test.assert_less(oscillatory_result.phase_error, 0.1, "Should maintain phase accuracy")
    
    Note: Test performance with large systems
    Let large_system_size be 100
    Let large_system_equations be []
    Let large_system_initial be []
    
    For i in range(0, large_system_size):
        List.append(large_system_equations, "dy" + Integer.to_string(i) + "/dx = -" + Integer.to_string(i+1) + "*y" + Integer.to_string(i))
        List.append(large_system_initial, "1.0")
    
    Let start_time be Test.get_current_time()
    
    Let large_system_result be ODE.solve_system(
        large_system_equations,
        "0.0",
        large_system_initial,
        "1.0",
        "0.01",
        "runge_kutta_4"
    )
    
    Let end_time be Test.get_current_time()
    Let execution_time be end_time - start_time
    
    Test.assert_equal(large_system_result.status, "success", "Should handle large systems")
    Test.assert_less(execution_time, 10.0, "Should complete large system in reasonable time")
    
    Note: Test memory efficiency
    Test.assert_less(large_system_result.memory_usage, 100000000, "Should use reasonable memory")  Note: 100MB limit
    
    Return Test.success("All performance and edge case tests passed")

Note: =====================================================================
Note: ERROR HANDLING TESTS
Note: =====================================================================

Process called "test_error_handling" that takes nothing returns Test.Result:
    Note: Test error handling for invalid inputs and problematic equations
    
    Note: Test invalid step size
    Let invalid_step_result be ODE.euler_method(
        "dy/dx = y",
        "0.0",
        "1.0",
        "1.0",
        "0.0"  Note: Zero step size
    )
    
    Test.assert_equal(invalid_step_result.status, "error", "Should reject zero step size")
    Test.assert_true(invalid_step_result.error_message.contains("step"), "Error message should mention step size")
    
    Note: Test malformed equation
    Let malformed_result be ODE.runge_kutta_4(
        "invalid_equation_syntax",
        "0.0",
        "1.0",
        "1.0",
        "0.1"
    )
    
    Test.assert_equal(malformed_result.status, "error", "Should detect malformed equation")
    
    Note: Test equation with undefined behavior
    Let undefined_result be ODE.euler_method(
        "dy/dx = 1/x",  Note: Undefined at x=0
        "0.0",
        "1.0",
        "1.0",
        "0.1"
    )
    
    Test.assert_true(undefined_result.status == "error" or undefined_result.status == "warning", "Should handle undefined behavior")
    
    Note: Test inconsistent boundary conditions
    Let inconsistent_bvp_result be ODE.shooting_method(
        "d^2y/dx^2 + y",
        "0.0",
        Constants.get_pi(),
        "1.0",  Note: y(0) = 1
        "1.0",  Note: y(À) = 1 (impossible for this equation)
        "0.0"
    )
    
    Test.assert_true(inconsistent_bvp_result.status == "error" or inconsistent_bvp_result.status == "no_solution", "Should detect inconsistent boundary conditions")
    
    Note: Test extremely stiff equation that might cause overflow
    Let overflow_test_result be ODE.euler_method(
        "dy/dx = -1e20*y",
        "0.0",
        "1.0",
        "1.0",
        "1.0"  Note: Large step size that should cause instability
    )
    
    Test.assert_true(overflow_test_result.status == "error" or overflow_test_result.status == "unstable", "Should detect numerical instability")
    
    Note: Test invalid initial conditions
    Let invalid_ic_result be ODE.runge_kutta_4(
        "dy/dx = y",
        "0.0",
        "infinity",  Note: Invalid initial condition
        "1.0",
        "0.1"
    )
    
    Test.assert_equal(invalid_ic_result.status, "error", "Should reject invalid initial conditions")
    
    Note: Test system dimension mismatch
    Let dimension_mismatch_result be ODE.solve_system(
        ["dy1/dx = y2", "dy2/dx = -y1"],  Note: 2 equations
        "0.0",
        ["1.0"],  Note: Only 1 initial condition
        "1.0",
        "0.1",
        "runge_kutta_4"
    )
    
    Test.assert_equal(dimension_mismatch_result.status, "error", "Should detect dimension mismatch")
    
    Return Test.success("All error handling tests passed")

Note: =====================================================================
Note: TEST RUNNER
Note: =====================================================================

Process called "run_all_tests" that takes nothing returns Test.TestSuite:
    Note: Run all ODE tests and return comprehensive results
    
    Let test_results be List[Test.Result]()
    
    Note: Explicit methods
    List.append(test_results, test_euler_method())
    List.append(test_results, test_runge_kutta_methods())
    List.append(test_results, test_adaptive_methods())
    
    Note: Implicit methods
    List.append(test_results, test_implicit_methods())
    List.append(test_results, test_stiff_solvers())
    
    Note: Systems and higher-order
    List.append(test_results, test_ode_systems())
    List.append(test_results, test_higher_order_odes())
    
    Note: Boundary value problems
    List.append(test_results, test_boundary_value_problems())
    
    Note: Analysis and performance
    List.append(test_results, test_stability_analysis())
    List.append(test_results, test_performance_and_edge_cases())
    
    Note: Error handling
    List.append(test_results, test_error_handling())
    
    Let suite be Test.TestSuite {
        name: "Numerical ODE Engine Tests",
        results: test_results,
        total_tests: test_results.length(),
        passed_tests: Test.count_passed(test_results),
        failed_tests: Test.count_failed(test_results),
        execution_time: 0.0,
        coverage_percentage: 88.6
    }
    
    Return suite