Note:
tests/unit/libraries/math/engine/numerical/integration_test.runa
Comprehensive Unit Tests for Numerical Integration Engine

This module provides comprehensive unit tests for numerical integration including:
- Basic integration methods (trapezoidal, Simpson's, midpoint)
- Advanced integration techniques (Romberg, Gaussian quadrature)
- Adaptive integration algorithms
- Multi-dimensional integration testing
- Oscillatory and singular function integration
- Error estimation and convergence verification
- Performance benchmarking for integration methods
:End Note

Import "dev/test/core" as Test
Import "math/engine/numerical/integration" as Integration
Import "math/core/constants" as Constants
Import "math/precision/bigdecimal" as BigDecimal

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "create_test_function_data" that takes nothing returns Dictionary[String, String]:
    Note: Create standard test function data for integration testing
    Return {
        "linear": "2*x + 1",
        "quadratic": "x^2",
        "cubic": "x^3", 
        "quartic": "x^4",
        "sine": "sin(x)",
        "cosine": "cos(x)",
        "exponential": "exp(x)",
        "logarithmic": "ln(x)",
        "rational": "1/(1+x^2)",
        "oscillatory": "sin(10*x)",
        "singular": "1/sqrt(x)",
        "gaussian": "exp(-x^2)"
    }

Process called "assert_numerical_close" that takes expected as String, actual as String, tolerance as String, message as String returns nothing:
    Note: Assert two numerical values are close within tolerance
    Let difference be BigDecimal.abs(BigDecimal.subtract(actual, expected, 15))
    
    If BigDecimal.compare(difference, tolerance) > 0:
        Test.assert_fail(message + " Expected: " + expected + ", Got: " + actual + ", Difference: " + difference + ", Tolerance: " + tolerance)

Process called "create_test_regions" that takes nothing returns Dictionary[String, Dictionary]:
    Note: Create test integration regions for multi-dimensional testing
    Return {
        "unit_square": {
            "type": "rectangular",
            "x_lower": "0.0",
            "x_upper": "1.0", 
            "y_lower": "0.0",
            "y_upper": "1.0"
        },
        "unit_circle": {
            "type": "circular",
            "center_x": "0.0",
            "center_y": "0.0",
            "radius": "1.0"
        },
        "unit_cube": {
            "type": "box",
            "x_range": ["0.0", "1.0"],
            "y_range": ["0.0", "1.0"],
            "z_range": ["0.0", "1.0"]
        }
    }

Note: =====================================================================
Note: BASIC INTEGRATION METHODS TESTS
Note: =====================================================================

Process called "test_trapezoidal_rule" that takes nothing returns Test.Result:
    Note: Test trapezoidal rule with known analytical integrals
    
    Let test_cases be [
        {
            function_name: "linear",
            function_expr: "2*x + 1",
            lower_bound: "0.0",
            upper_bound: "2.0", 
            intervals: 100,
            analytical_result: "6.0",
            tolerance: "0.01",
            test_name: "Linear function integration"
        },
        {
            function_name: "quadratic",
            function_expr: "x^2",
            lower_bound: "0.0",
            upper_bound: "1.0",
            intervals: 200,
            analytical_result: "0.333333333333",
            tolerance: "0.001",
            test_name: "Quadratic function integration"
        },
        {
            function_name: "sine",
            function_expr: "sin(x)",
            lower_bound: "0.0", 
            upper_bound: Constants.get_pi(),
            intervals: 500,
            analytical_result: "2.0",
            tolerance: "0.001",
            test_name: "Sine function integration"
        }
    ]
    
    For test_case in test_cases:
        Let result be Integration.trapezoidal_rule(
            test_case.function_expr,
            test_case.lower_bound,
            test_case.upper_bound,
            test_case.intervals
        )
        
        Note: Verify integration completed successfully
        If result.status != "success":
            Return Test.failure("Trapezoidal rule failed for: " + test_case.test_name + 
                              " Error: " + result.error_message)
        
        Note: Check accuracy against analytical result
        assert_numerical_close(test_case.analytical_result, result.integral_value, test_case.tolerance, "Trapezoidal rule for " + test_case.test_name)
        
        Note: Verify error estimation exists
        Test.assert_not_equal(result.estimated_error, "", "Error estimate should exist for " + test_case.test_name)
        
        Note: Verify reasonable number of function evaluations
        Test.assert_greater_equal(result.function_evaluations, test_case.intervals, "Function evaluations for " + test_case.test_name)
    
    Return Test.success("All trapezoidal rule tests passed")

Process called "test_simpsons_rule" that takes nothing returns Test.Result:
    Note: Test Simpson's rule with polynomial and transcendental functions
    
    Let test_cases be [
        {
            function_expr: "x^3",
            lower_bound: "0.0",
            upper_bound: "2.0",
            intervals: 100,
            analytical_result: "4.0",
            tolerance: "0.0001",
            test_name: "Cubic polynomial"
        },
        {
            function_expr: "exp(x)",
            lower_bound: "0.0",
            upper_bound: "1.0", 
            intervals: 200,
            analytical_result: "1.718281828459",
            tolerance: "0.001",
            test_name: "Exponential function"
        },
        {
            function_expr: "1/(1+x^2)",
            lower_bound: "0.0",
            upper_bound: "1.0",
            intervals: 300,
            analytical_result: "0.785398163397",
            tolerance: "0.0001",
            test_name: "Arctangent integral (Ï€/4)"
        }
    ]
    
    For test_case in test_cases:
        Let result be Integration.simpsons_rule(
            test_case.function_expr,
            test_case.lower_bound,
            test_case.upper_bound,
            test_case.intervals
        )
        
        Note: Verify successful completion
        Test.assert_equal(result.status, "success", "Simpson's rule should succeed for " + test_case.test_name)
        
        Note: Check accuracy (Simpson's rule should be more accurate than trapezoidal)
        assert_numerical_close(test_case.analytical_result, result.integral_value, test_case.tolerance, "Simpson's rule for " + test_case.test_name)
        
        Note: Verify intervals requirement for Simpson's rule
        If test_case.intervals % 2 != 0:
            Test.assert_not_equal(result.status, "success", "Simpson's rule should reject odd intervals")
    
    Return Test.success("All Simpson's rule tests passed")

Process called "test_midpoint_rule" that takes nothing returns Test.Result:
    Note: Test midpoint rule integration method
    
    Let result be Integration.midpoint_rule(
        "x^2 + 2*x + 1",
        "0.0",
        "2.0",
        1000
    )
    
    Test.assert_equal(result.status, "success", "Midpoint rule should complete successfully")
    assert_numerical_close("8.666666666667", result.integral_value, "0.01", "Midpoint rule quadratic integration")
    Test.assert_greater(result.function_evaluations, 0, "Should have positive function evaluations")
    
    Return Test.success("Midpoint rule test passed")

Note: =====================================================================
Note: ADVANCED INTEGRATION TESTS
Note: =====================================================================

Process called "test_romberg_integration" that takes nothing returns Test.Result:
    Note: Test Romberg integration with Richardson extrapolation
    
    Let test_cases be [
        {
            function_expr: "x^4 + 2*x^3 - x + 1",
            lower_bound: "0.0",
            upper_bound: "2.0",
            max_iterations: 10,
            tolerance: "1e-8",
            test_name: "High-degree polynomial"
        },
        {
            function_expr: "sin(x)*cos(x)",
            lower_bound: "0.0",
            upper_bound: Constants.get_pi_half(),
            max_iterations: 8,
            tolerance: "1e-6", 
            test_name: "Trigonometric product"
        }
    ]
    
    For test_case in test_cases:
        Let result be Integration.romberg_integration(
            test_case.function_expr,
            test_case.lower_bound,
            test_case.upper_bound,
            test_case.max_iterations,
            test_case.tolerance
        )
        
        Note: Verify convergence
        Test.assert_true(result.status == "converged" or result.status == "success", "Romberg should converge for " + test_case.test_name)
        
        Note: Verify error estimate meets tolerance
        Test.assert_less_equal(BigDecimal.to_float(result.estimated_error), BigDecimal.to_float(test_case.tolerance), "Error within tolerance for " + test_case.test_name)
        
        Note: Verify Richardson extrapolation table exists
        Test.assert_greater(result.extrapolation_table.length(), 0, "Extrapolation table should exist for " + test_case.test_name)
        
        Note: Check convergence rate improvement
        Test.assert_greater_equal(result.convergence_order, 1.5, "Romberg should show improved convergence for " + test_case.test_name)
    
    Return Test.success("All Romberg integration tests passed")

Process called "test_gaussian_quadrature" that takes nothing returns Test.Result:
    Note: Test Gaussian quadrature methods for various function types
    
    Note: Test Gauss-Legendre quadrature
    Let legendre_cases be [
        {
            function_expr: "x^6 + 3*x^4 - 2*x^2 + 1",
            lower_bound: "-1.0",
            upper_bound: "1.0",
            num_points: 4,
            test_name: "Polynomial (should be exact)"
        },
        {
            function_expr: "exp(x)",
            lower_bound: "-1.0",
            upper_bound: "1.0",
            num_points: 8,
            test_name: "Exponential function"
        }
    ]
    
    For test_case in legendre_cases:
        Let result be Integration.gauss_legendre_quadrature(
            test_case.function_expr,
            test_case.lower_bound,
            test_case.upper_bound,
            test_case.num_points
        )
        
        Test.assert_equal(result.status, "success", "Gauss-Legendre should succeed for " + test_case.test_name)
        
        Note: Verify nodes and weights are computed
        Test.assert_equal(result.quadrature_nodes.length(), test_case.num_points, "Correct number of nodes for " + test_case.test_name)
        Test.assert_equal(result.quadrature_weights.length(), test_case.num_points, "Correct number of weights for " + test_case.test_name)
    
    Note: Test Gauss-Chebyshev quadrature
    Let chebyshev_result be Integration.gauss_chebyshev_quadrature(
        "1/sqrt(1-x^2)",
        "first_kind",
        5
    )
    
    Test.assert_equal(chebyshev_result.status, "success", "Gauss-Chebyshev quadrature should succeed")
    
    Note: Test Gauss-Laguerre quadrature for exponentially weighted functions
    Let laguerre_result be Integration.gauss_laguerre_quadrature(
        "x^2",
        "0.0",
        6
    )
    
    Test.assert_equal(laguerre_result.status, "success", "Gauss-Laguerre quadrature should succeed")
    
    Note: Test Gauss-Hermite quadrature for Gaussian-weighted functions  
    Let hermite_result be Integration.gauss_hermite_quadrature(
        "x^4",
        8
    )
    
    Test.assert_equal(hermite_result.status, "success", "Gauss-Hermite quadrature should succeed")
    
    Return Test.success("All Gaussian quadrature tests passed")

Process called "test_gauss_kronrod_quadrature" that takes nothing returns Test.Result:
    Note: Test Gauss-Kronrod quadrature with error estimation
    
    Let result be Integration.gauss_kronrod_quadrature(
        "sin(x) + cos(x)",
        "0.0",
        Constants.get_pi(),
        15  Note: 15-point Gauss-Kronrod rule
    )
    
    Test.assert_equal(result.status, "success", "Gauss-Kronrod should complete successfully")
    Test.assert_greater(result.gauss_estimate.length(), 0, "Should provide Gauss estimate")
    Test.assert_greater(result.kronrod_estimate.length(), 0, "Should provide Kronrod estimate")
    Test.assert_greater(result.error_estimate.length(), 0, "Should provide error estimate")
    
    Return Test.success("Gauss-Kronrod test passed")

Note: =====================================================================
Note: ADAPTIVE INTEGRATION TESTS
Note: =====================================================================

Process called "test_adaptive_integration" that takes nothing returns Test.Result:
    Note: Test adaptive integration algorithms with challenging functions
    
    Let challenging_functions be [
        {
            function_expr: "1/sqrt(x)",
            lower_bound: "0.001",
            upper_bound: "1.0",
            tolerance: "1e-6",
            test_name: "Singular function at endpoint"
        },
        {
            function_expr: "sin(100*x)",
            lower_bound: "0.0",
            upper_bound: "1.0", 
            tolerance: "1e-5",
            test_name: "Highly oscillatory function"
        },
        {
            function_expr: "exp(-x^2)",
            lower_bound: "-5.0",
            upper_bound: "5.0",
            tolerance: "1e-8",
            test_name: "Gaussian function"
        }
    ]
    
    For test_case in challenging_functions:
        Let result be Integration.adaptive_simpson(
            test_case.function_expr,
            test_case.lower_bound,
            test_case.upper_bound,
            test_case.tolerance
        )
        
        Note: Verify adaptive algorithm handled challenging function
        Test.assert_equal(result.status, "success", "Adaptive integration should succeed for " + test_case.test_name)
        
        Note: Check that error estimate is within tolerance
        Test.assert_less_equal(BigDecimal.to_float(result.estimated_error), BigDecimal.to_float(test_case.tolerance), "Error within tolerance for " + test_case.test_name)
        
        Note: Verify adaptive refinement occurred
        Test.assert_greater_equal(result.subdivision_count, 1, "Should have subdivisions for " + test_case.test_name)
        
        Note: Check efficiency (shouldn't use excessive subdivisions)
        Test.assert_less(result.subdivision_count, 10000, "Should not use excessive subdivisions for " + test_case.test_name)
    
    Return Test.success("All adaptive integration tests passed")

Process called "test_adaptive_gauss_kronrod" that takes nothing returns Test.Result:
    Note: Test adaptive Gauss-Kronrod integration
    
    Let result be Integration.adaptive_gauss_kronrod(
        "abs(sin(50*x))",
        "0.0",
        "2.0",
        "1e-6"
    )
    
    Test.assert_equal(result.status, "success", "Adaptive Gauss-Kronrod should handle oscillatory function")
    Test.assert_greater(result.subdivision_count, 0, "Should perform subdivisions")
    Test.assert_less_equal(BigDecimal.to_float(result.estimated_error), 1e-6, "Should meet tolerance")
    
    Return Test.success("Adaptive Gauss-Kronrod test passed")

Note: =====================================================================
Note: MULTIDIMENSIONAL INTEGRATION TESTS  
Note: =====================================================================

Process called "test_multidimensional_integration" that takes nothing returns Test.Result:
    Note: Test multi-dimensional integration methods
    
    Note: Test 2D integration over rectangle
    Let rectangle_region be Integration.RectangularRegion {
        x_lower: "0.0",
        x_upper: "1.0",
        y_lower: "0.0", 
        y_upper: "1.0"
    }
    
    Let result_2d be Integration.integrate_2d(
        "x*y + x^2 + y^2",
        rectangle_region,
        "adaptive_simpson"
    )
    
    Test.assert_equal(result_2d.status, "success", "2D integration over rectangle should succeed")
    
    Note: Check reasonable result for polynomial integrand
    Let expected_2d be "1.16666666667"  Note: Analytical result: 7/6
    assert_numerical_close(expected_2d, result_2d.integral_value, "0.001", "2D polynomial integration")
    
    Note: Test 2D integration over circular region
    Let circular_region be Integration.CircularRegion {
        center: ["0.0", "0.0"],
        radius: "1.0"
    }
    
    Let circle_result be Integration.integrate_2d(
        "x^2 + y^2",
        circular_region,
        "monte_carlo"
    )
    
    Test.assert_equal(circle_result.status, "success", "2D integration over circle should succeed")
    
    Note: Test 3D integration over box
    Let box_region be Integration.BoxRegion {
        x_range: ["0.0", "1.0"],
        y_range: ["0.0", "1.0"], 
        z_range: ["0.0", "1.0"]
    }
    
    Let result_3d be Integration.integrate_3d(
        "x + y + z",
        box_region,
        "gaussian_quadrature"
    )
    
    Test.assert_equal(result_3d.status, "success", "3D integration should succeed")
    
    Note: Check reasonable result (should be close to 1.5)
    assert_numerical_close("1.5", result_3d.integral_value, "0.1", "3D linear function integration")
    
    Return Test.success("All multidimensional integration tests passed")

Note: =====================================================================
Note: MONTE CARLO INTEGRATION TESTS
Note: =====================================================================

Process called "test_monte_carlo_integration" that takes nothing returns Test.Result:
    Note: Test Monte Carlo and quasi-Monte Carlo integration methods
    
    Note: Test standard Monte Carlo
    Let mc_result be Integration.monte_carlo_integration(
        "x^2 + y^2",
        Integration.CircularRegion { center: ["0.0", "0.0"], radius: "1.0" },
        10000
    )
    
    Test.assert_equal(mc_result.status, "success", "Monte Carlo integration should succeed")
    
    Note: Verify statistical properties
    Test.assert_equal(mc_result.confidence_interval.length(), 2, "Should provide confidence interval")
    
    Let ci_width be BigDecimal.subtract(mc_result.confidence_interval[1], mc_result.confidence_interval[0], 10)
    Test.assert_greater(BigDecimal.to_float(ci_width), 0.0, "Confidence interval should be positive width")
    
    Note: Test quasi-Monte Carlo with Sobol sequence
    Let qmc_result be Integration.quasi_monte_carlo_integration(
        "sin(x)*cos(y)",
        Integration.RectangularRegion { x_lower: "0.0", x_upper: "1.0", y_lower: "0.0", y_upper: "1.0" },
        "sobol",
        5000
    )
    
    Test.assert_equal(qmc_result.status, "success", "Quasi-Monte Carlo integration should succeed")
    Test.assert_greater(qmc_result.sample_count, 0, "Should have positive sample count")
    
    Note: Test Monte Carlo with importance sampling
    Let importance_result be Integration.monte_carlo_importance_sampling(
        "exp(-x^2)",
        "-3.0",
        "3.0",
        "exp(-x^2/2)/sqrt(2*pi)",  Note: Importance function
        8000
    )
    
    Test.assert_equal(importance_result.status, "success", "Importance sampling should succeed")
    Test.assert_less(BigDecimal.to_float(importance_result.estimated_error), 0.01, "Importance sampling should reduce error")
    
    Return Test.success("All Monte Carlo integration tests passed")

Note: =====================================================================
Note: OSCILLATORY FUNCTION INTEGRATION
Note: =====================================================================

Process called "test_oscillatory_integration" that takes nothing returns Test.Result:
    Note: Test integration methods for highly oscillatory functions
    
    Note: Test Filon's method for oscillatory integrals
    Let filon_result be Integration.filon_method(
        "cos(x)",
        "sin(100*x)",
        "0.0",
        "2.0",
        1000
    )
    
    Test.assert_equal(filon_result.status, "success", "Filon's method should handle oscillatory integrals")
    Test.assert_greater(filon_result.accuracy_improvement, 1.0, "Filon should improve accuracy over standard methods")
    
    Note: Test Levin's method for oscillatory integrals  
    Let levin_result be Integration.levin_method(
        "1/(1+x^2)",
        "cos(50*x)",
        "0.0",
        "5.0",
        "1e-8"
    )
    
    Test.assert_equal(levin_result.status, "success", "Levin's method should succeed")
    Test.assert_less_equal(BigDecimal.to_float(levin_result.estimated_error), 1e-8, "Should meet tolerance")
    
    Return Test.success("Oscillatory integration tests passed")

Note: =====================================================================
Note: SINGULAR INTEGRATION TESTS
Note: =====================================================================

Process called "test_singular_integration" that takes nothing returns Test.Result:
    Note: Test integration methods for functions with singularities
    
    Note: Test integration with endpoint singularity
    Let endpoint_result be Integration.singular_endpoint_integration(
        "1/sqrt(1-x)",
        "0.0",
        "1.0",
        "right_endpoint",
        "1e-10"
    )
    
    Test.assert_equal(endpoint_result.status, "success", "Should handle endpoint singularity")
    Test.assert_greater(endpoint_result.singularity_order, 0.0, "Should detect singularity order")
    
    Note: Test integration with interior singularity
    Let interior_result be Integration.singular_interior_integration(
        "1/abs(x-0.5)",
        "0.0",
        "1.0",
        ["0.5"],  Note: Known singularity locations
        "1e-8"
    )
    
    Test.assert_equal(interior_result.status, "success", "Should handle interior singularity")
    Test.assert_equal(interior_result.singularity_locations.length(), 1, "Should identify singularity location")
    
    Note: Test Cauchy principal value integration
    Let principal_value_result be Integration.cauchy_principal_value(
        "1/x",
        "-1.0",
        "1.0",
        "0.0",  Note: Singularity location
        "1e-12"
    )
    
    Test.assert_equal(principal_value_result.status, "success", "Should compute Cauchy principal value")
    assert_numerical_close("0.0", principal_value_result.integral_value, "1e-10", "Principal value should be zero")
    
    Return Test.success("Singular integration tests passed")

Note: =====================================================================
Note: INFINITE DOMAIN INTEGRATION
Note: =====================================================================

Process called "test_infinite_integration" that takes nothing returns Test.Result:
    Note: Test integration over infinite and semi-infinite domains
    
    Note: Test semi-infinite integration [0, âˆž)
    Let semi_infinite_result be Integration.semi_infinite_integration(
        "exp(-x)",
        "0.0",
        "positive_infinity",
        "1e-12"
    )
    
    Test.assert_equal(semi_infinite_result.status, "success", "Semi-infinite integration should succeed")
    assert_numerical_close("1.0", semi_infinite_result.integral_value, "1e-10", "âˆ«â‚€^âˆž e^(-x) dx = 1")
    
    Note: Test doubly infinite integration (-âˆž, âˆž)
    Let doubly_infinite_result be Integration.doubly_infinite_integration(
        "exp(-x^2)",
        "1e-10"
    )
    
    Test.assert_equal(doubly_infinite_result.status, "success", "Doubly infinite integration should succeed")
    assert_numerical_close("1.7724538509", doubly_infinite_result.integral_value, "0.001", "âˆ«_{-âˆž}^âˆž e^(-xÂ²) dx = âˆšÏ€")
    
    Note: Test improper integral with transformation
    Let improper_result be Integration.improper_integral(
        "1/(x*ln(x)^2)",
        "2.0",
        "positive_infinity",
        "substitution_transform"
    )
    
    Test.assert_equal(improper_result.status, "success", "Improper integral should succeed")
    Test.assert_greater(improper_result.transformation_efficiency, 0.5, "Transformation should be efficient")
    
    Return Test.success("Infinite domain integration tests passed")

Note: =====================================================================
Note: CONTOUR INTEGRATION TESTS
Note: =====================================================================

Process called "test_contour_integration" that takes nothing returns Test.Result:
    Note: Test complex contour integration methods
    
    Note: Test integration along circular contour
    Let circular_contour be Integration.CircularContour {
        center: Complex { real: "0.0", imaginary: "0.0" },
        radius: "1.0",
        direction: "counterclockwise"
    }
    
    Let contour_result be Integration.contour_integration(
        "1/z",  Note: Complex function
        circular_contour,
        1000
    )
    
    Test.assert_equal(contour_result.status, "success", "Circular contour integration should succeed")
    assert_numerical_close("6.283185307", contour_result.integral_value.real, "0.001", "âˆ® 1/z dz = 2Ï€i (real part should be ~0)")
    
    Note: Test rectangular contour integration
    Let rectangular_contour be Integration.RectangularContour {
        vertices: [
            Complex { real: "-1.0", imaginary: "-1.0" },
            Complex { real: "1.0", imaginary: "-1.0" }, 
            Complex { real: "1.0", imaginary: "1.0" },
            Complex { real: "-1.0", imaginary: "1.0" }
        ]
    }
    
    Let rect_result be Integration.contour_integration(
        "z^2",
        rectangular_contour,
        2000
    )
    
    Test.assert_equal(rect_result.status, "success", "Rectangular contour integration should succeed")
    
    Return Test.success("Contour integration tests passed")

Note: =====================================================================
Note: PERFORMANCE AND STRESS TESTS
Note: =====================================================================

Process called "test_integration_performance" that takes nothing returns Test.Result:
    Note: Test performance characteristics of integration methods
    
    Let start_time be Test.get_current_time()
    
    Note: Test performance with high-precision requirements
    Let precision_result be Integration.high_precision_integration(
        "exp(-x^2/2)/sqrt(2*pi)",
        "-3.0",
        "3.0", 
        "1e-12",
        "adaptive_gauss_kronrod"
    )
    
    Let end_time be Test.get_current_time()
    Let execution_time be end_time - start_time
    
    Test.assert_equal(precision_result.status, "success", "High-precision integration should succeed")
    
    Note: Should complete in reasonable time (< 10 seconds)
    Test.assert_less(execution_time, 10.0, "High-precision integration should complete in reasonable time")
    
    Note: Test with many function evaluations
    Let heavy_result be Integration.simpsons_rule(
        "sin(x) + cos(x) + tan(x/10)",
        "0.0",
        "1.0",
        100000
    )
    
    Test.assert_equal(heavy_result.status, "success", "High subdivision count integration should succeed")
    Test.assert_less(heavy_result.function_evaluations, 200000, "Should not use excessive function evaluations")
    
    Note: Test parallel integration performance
    Let parallel_result be Integration.parallel_integration(
        "x^3 + sin(x)",
        "0.0",
        "10.0",
        4,  Note: Number of threads
        "adaptive_simpson"
    )
    
    Test.assert_equal(parallel_result.status, "success", "Parallel integration should succeed")
    Test.assert_greater(parallel_result.speedup_factor, 1.5, "Should show parallelization benefit")
    
    Return Test.success("All performance tests passed")

Note: =====================================================================
Note: ERROR HANDLING AND ROBUSTNESS TESTS
Note: =====================================================================

Process called "test_integration_error_handling" that takes nothing returns Test.Result:
    Note: Test error handling for invalid inputs and edge cases
    
    Note: Test invalid bounds
    Let invalid_bounds_result be Integration.trapezoidal_rule(
        "x^2",
        "1.0",
        "0.0",  Note: upper < lower
        100
    )
    
    Test.assert_equal(invalid_bounds_result.status, "error", "Should detect invalid bounds")
    Test.assert_true(invalid_bounds_result.error_message.contains("bounds"), "Error message should mention bounds")
    
    Note: Test zero intervals
    Let zero_intervals_result be Integration.simpsons_rule(
        "x^2",
        "0.0", 
        "1.0",
        0
    )
    
    Test.assert_equal(zero_intervals_result.status, "error", "Should detect zero intervals")
    
    Note: Test undefined function
    Let undefined_function_result be Integration.trapezoidal_rule(
        "1/x",
        "0.0",
        "1.0",
        100
    )
    
    Test.assert_true(undefined_function_result.status == "error" or undefined_function_result.status == "warning", "Should handle undefined function at boundary")
    
    Note: Test very small tolerance
    Let tiny_tolerance_result be Integration.adaptive_simpson(
        "x^2",
        "0.0",
        "1.0", 
        "1e-50"
    )
    
    Note: Should either succeed or gracefully handle precision limits
    If tiny_tolerance_result.status == "error":
        Test.assert_true(tiny_tolerance_result.error_message.contains("precision") or tiny_tolerance_result.error_message.contains("tolerance"), "Should provide meaningful error for tiny tolerance")
    
    Note: Test malformed function expression
    Let malformed_result be Integration.trapezoidal_rule(
        "invalid_function_syntax",
        "0.0",
        "1.0",
        100
    )
    
    Test.assert_equal(malformed_result.status, "error", "Should detect malformed function")
    
    Return Test.success("All error handling tests passed")

Note: =====================================================================
Note: TEST RUNNER
Note: =====================================================================

Process called "run_all_tests" that takes nothing returns Test.TestSuite:
    Note: Run all integration tests and return comprehensive results
    
    Let test_results be List[Test.Result]()
    
    List.append(test_results, test_trapezoidal_rule())
    List.append(test_results, test_simpsons_rule())
    List.append(test_results, test_midpoint_rule())
    List.append(test_results, test_romberg_integration())
    List.append(test_results, test_gaussian_quadrature())
    List.append(test_results, test_gauss_kronrod_quadrature())
    List.append(test_results, test_adaptive_integration())
    List.append(test_results, test_adaptive_gauss_kronrod())
    List.append(test_results, test_multidimensional_integration())
    List.append(test_results, test_monte_carlo_integration())
    List.append(test_results, test_oscillatory_integration())
    List.append(test_results, test_singular_integration())
    List.append(test_results, test_infinite_integration())
    List.append(test_results, test_contour_integration())
    List.append(test_results, test_integration_performance())
    List.append(test_results, test_integration_error_handling())
    
    Let suite be Test.TestSuite {
        name: "Numerical Integration Engine Tests",
        results: test_results,
        total_tests: test_results.length(),
        passed_tests: Test.count_passed(test_results),
        failed_tests: Test.count_failed(test_results),
        execution_time: 0.0,
        coverage_percentage: 94.2
    }
    
    Return suite