Note:
tests/unit/libraries/math/engine/numerical/differentiation_test.runa
Comprehensive Unit Tests for Numerical Differentiation Module

This test suite provides complete coverage for the math/engine/numerical/differentiation module,
testing all 70 functions across derivative computation methods including finite differences,
automatic differentiation, complex step methods, partial derivatives, Jacobian/Hessian
computation, and specialized derivative algorithms.

Test Categories:
- Finite Difference Methods (8 tests)
- Advanced Difference Methods (4 tests) 
- Automatic Differentiation (5 tests)
- Partial Derivatives (4 tests)
- Jacobian Computation (6 tests)
- Hessian Computation (5 tests)
- Richardson Extrapolation (4 tests)
- Robust Methods (4 tests)
- Specialized Derivatives (4 tests)
- Error Analysis (4 tests)
- High Performance Methods (6 tests)
- Utility Functions (12 tests)

Total: 66 comprehensive test functions covering all differentiation functionality
:End Note

Import "dev/test" as UnitTest
Import "math/engine/numerical/differentiation" as Differentiation
Import "math/core/operations" as Operations
Import "collections" as Collections
Import "datetime" as DateTime

Note: =====================================================================
Note: TEST DATA HELPERS
Note: =====================================================================

Process called "create_test_function_values" returns List[String]:
    Note: Create function values for f(x) = x^2 at x = 0, 1, 2, 3, 4
    Let values be List[String]
    Let values be values.append("0.0").append("1.0").append("4.0").append("9.0").append("16.0")
    Return values

Process called "create_test_function_sin" returns List[String]:
    Note: Create sin(x) values at x = 0, π/4, π/2, 3π/4, π
    Let values be List[String]
    Let values be values.append("0.0").append("0.7071067812").append("1.0").append("0.7071067812").append("0.0")
    Return values

Process called "create_multivariate_function_data" returns Dictionary[String, List[String]]:
    Note: Create data for multivariate function f(x,y) = x^2 + xy + y^2
    Let data be Dictionary[String, List[String]]
    Let x_values be List[String]
    Let x_values be x_values.append("1.0").append("2.0").append("1.0")
    Let y_values be List[String]
    Let y_values be y_values.append("1.0").append("1.0").append("2.0")
    Let function_values be List[String]
    Let function_values be function_values.append("3.0").append("7.0").append("7.0")  Note: f(1,1)=3, f(2,1)=7, f(1,2)=7
    
    Let data be data.set("x_values", x_values)
    Let data be data.set("y_values", y_values)
    Let data be data.set("function_values", function_values)
    Return data

Process called "create_matrix_data_2x2" returns List[List[String]]:
    Note: Create 2x2 test matrix
    Let matrix be List[List[String]]
    Let matrix be matrix.append(List[String]().append("2.0").append("3.0"))
    Let matrix be matrix.append(List[String]().append("1.0").append("4.0"))
    Return matrix

Process called "create_test_vector" returns List[String]:
    Note: Create test vector [1.0, 2.0]
    Let vector be List[String]
    Let vector be vector.append("1.0").append("2.0")
    Return vector

Process called "create_derivative_config" returns Differentiation.DerivativeConfig:
    Note: Create derivative computation configuration
    Let config be Differentiation.DerivativeConfig
    Let config.step_size be 1e-8
    Let config.method be "central_difference"
    Let config.order be 1
    Let config.precision be 64
    Let config.adaptive be false
    Return config

Note: =====================================================================
Note: ASSERTION HELPERS
Note: =====================================================================

Process called "assert_numerical_close" that takes actual as String, expected as String, tolerance as Float, message as String:
    Note: Assert two numerical values are close within tolerance
    Let actual_val be Operations.convert_to_float(actual)
    Let expected_val be Operations.convert_to_float(expected)
    Let diff be Operations.absolute_value(Operations.subtract(actual, expected, 15).result)
    Let diff_val be Operations.convert_to_float(diff)
    UnitTest.assert_true(diff_val < tolerance, message ++ " - expected: " ++ expected ++ ", actual: " ++ actual)

Process called "assert_derivative_valid" that takes derivative_result as String, expected_range_min as Float, expected_range_max as Float:
    Note: Assert derivative is within expected range
    Let derivative_val be Operations.convert_to_float(derivative_result)
    UnitTest.assert_true(derivative_val >= expected_range_min, "Derivative should be >= minimum expected value")
    UnitTest.assert_true(derivative_val <= expected_range_max, "Derivative should be <= maximum expected value")

Process called "assert_jacobian_valid" that takes jacobian as Differentiation.JacobianMatrix, expected_rows as Integer, expected_cols as Integer:
    Note: Assert Jacobian matrix is valid
    UnitTest.assert_not_null(jacobian, "Jacobian matrix should not be null")
    UnitTest.assert_equal(jacobian.rows, expected_rows, "Jacobian should have expected rows")
    UnitTest.assert_equal(jacobian.columns, expected_cols, "Jacobian should have expected columns")
    UnitTest.assert_not_null(jacobian.entries, "Jacobian entries should not be null")

Process called "assert_hessian_valid" that takes hessian as Differentiation.HessianMatrix, expected_size as Integer:
    Note: Assert Hessian matrix is valid
    UnitTest.assert_not_null(hessian, "Hessian matrix should not be null")
    UnitTest.assert_equal(hessian.size, expected_size, "Hessian should have expected size")
    UnitTest.assert_not_null(hessian.entries, "Hessian entries should not be null")
    
    Note: Check symmetry property
    For i in range(0, expected_size):
        For j in range(0, expected_size):
            assert_numerical_close(hessian.entries[i][j], hessian.entries[j][i], 1e-10, 
                                 "Hessian should be symmetric at [" ++ i.to_string() ++ "," ++ j.to_string() ++ "]")

Process called "assert_gradient_valid" that takes gradient as List[String], expected_size as Integer:
    Note: Assert gradient vector is valid
    UnitTest.assert_not_null(gradient, "Gradient should not be null")
    UnitTest.assert_equal(gradient.size(), expected_size, "Gradient should have expected size")
    
    For i in range(0, gradient.size()):
        UnitTest.assert_not_null(gradient[i], "Gradient component should not be null")

Process called "assert_complex_number_valid" that takes complex_num as Differentiation.ComplexNumber:
    Note: Assert complex number is valid
    UnitTest.assert_not_null(complex_num, "Complex number should not be null")
    UnitTest.assert_not_null(complex_num.real, "Real part should not be null")
    UnitTest.assert_not_null(complex_num.imaginary, "Imaginary part should not be null")

Note: =====================================================================
Note: FINITE DIFFERENCE METHODS TESTS
Note: =====================================================================

Process called "test_forward_difference_derivative":
    Note: Test forward difference derivative computation
    Let function_values be create_test_function_values()
    Let step_size be 1.0
    Let evaluation_index be 1  Note: Evaluate derivative at x=1
    
    Let derivative be Differentiation.forward_difference_derivative(function_values, step_size, evaluation_index)
    
    UnitTest.assert_not_null(derivative, "Forward difference derivative should not be null")
    Note: For f(x) = x^2, f'(1) = 2, forward difference gives f'(1) ≈ (f(2)-f(1))/h = (4-1)/1 = 3
    assert_derivative_valid(derivative, 2.5, 3.5)

Process called "test_backward_difference_derivative":
    Note: Test backward difference derivative computation
    Let function_values be create_test_function_values()
    Let step_size be 1.0
    Let evaluation_index be 2  Note: Evaluate derivative at x=2
    
    Let derivative be Differentiation.backward_difference_derivative(function_values, step_size, evaluation_index)
    
    UnitTest.assert_not_null(derivative, "Backward difference derivative should not be null")
    Note: For f(x) = x^2, f'(2) = 4, backward difference gives f'(2) ≈ (f(2)-f(1))/h = (4-1)/1 = 3
    assert_derivative_valid(derivative, 2.5, 3.5)

Process called "test_central_difference_derivative":
    Note: Test central difference derivative computation
    Let function_values be create_test_function_values()
    Let step_size be 1.0
    Let evaluation_index be 2  Note: Evaluate derivative at x=2
    
    Let derivative be Differentiation.central_difference_derivative(function_values, step_size, evaluation_index)
    
    UnitTest.assert_not_null(derivative, "Central difference derivative should not be null")
    Note: For f(x) = x^2, f'(2) = 4, central difference gives f'(2) ≈ (f(3)-f(1))/(2h) = (9-1)/2 = 4
    assert_numerical_close(derivative, "4.0", 1e-12, "Central difference should be exact for quadratic")

Process called "test_higher_order_finite_difference":
    Note: Test higher order finite difference schemes
    Let function_values be create_test_function_values()
    Let step_size be 1.0
    Let evaluation_index be 2
    Let order be 2  Note: Second derivative
    
    Let derivative be Differentiation.higher_order_finite_difference(function_values, step_size, evaluation_index, order)
    
    UnitTest.assert_not_null(derivative, "Higher order derivative should not be null")
    Note: For f(x) = x^2, f''(x) = 2 (constant)
    assert_numerical_close(derivative, "2.0", 1e-10, "Second derivative of x^2 should be 2")

Process called "test_adaptive_step_size_derivative":
    Note: Test adaptive step size derivative computation
    Let function_name be "x_squared"
    Let evaluation_point be "2.0"
    Let target_accuracy be 1e-6
    
    Let derivative be Differentiation.adaptive_step_size_derivative(function_name, evaluation_point, target_accuracy)
    
    UnitTest.assert_not_null(derivative, "Adaptive derivative should not be null")
    UnitTest.assert_true(Collections.contains_key(derivative, "derivative_value"), "Should contain derivative value")
    UnitTest.assert_true(Collections.contains_key(derivative, "step_size_used"), "Should contain step size used")
    UnitTest.assert_true(Collections.contains_key(derivative, "accuracy_achieved"), "Should contain achieved accuracy")

Process called "test_finite_difference_from_values":
    Note: Test finite difference computation from given function values
    Let x_values be List[String]
    Let x_values be x_values.append("0.0").append("1.0").append("2.0").append("3.0")
    Let y_values be List[String]
    Let y_values be y_values.append("0.0").append("1.0").append("4.0").append("9.0")
    Let evaluation_point be "2.0"
    
    Let derivative be Differentiation.finite_difference_from_values(x_values, y_values, evaluation_point, "central")
    
    UnitTest.assert_not_null(derivative, "Finite difference from values should not be null")
    Note: For f(x) = x^2 at x=2, f'(2) = 4
    assert_numerical_close(derivative, "4.0", 1e-10, "Derivative at x=2 should be 4")

Process called "test_finite_difference_weights_derivative":
    Note: Test finite difference weights computation
    Let grid_points be List[String]
    Let grid_points be grid_points.append("-1.0").append("0.0").append("1.0")
    Let derivative_order be 1
    Let evaluation_point be "0.0"
    
    Let weights be Differentiation.finite_difference_weights_derivative(grid_points, derivative_order, evaluation_point)
    
    UnitTest.assert_not_null(weights, "Finite difference weights should not be null")
    UnitTest.assert_equal(weights.size(), 3, "Should have weights for 3 points")
    Note: For central difference, weights should be [-0.5, 0, 0.5]
    assert_numerical_close(weights[0], "-0.5", 1e-12, "First weight should be -0.5")
    assert_numerical_close(weights[1], "0.0", 1e-12, "Second weight should be 0")
    assert_numerical_close(weights[2], "0.5", 1e-12, "Third weight should be 0.5")

Note: =====================================================================
Note: ADVANCED DIFFERENCE METHODS TESTS
Note: =====================================================================

Process called "test_complex_step_derivative":
    Note: Test complex step differentiation method
    Let function_name be "exp"
    Let evaluation_point be "1.0"
    Let step_size be 1e-15
    
    Let derivative be Differentiation.complex_step_derivative(function_name, evaluation_point, step_size)
    
    UnitTest.assert_not_null(derivative, "Complex step derivative should not be null")
    Note: For f(x) = exp(x), f'(1) = exp(1) ≈ 2.718
    assert_derivative_valid(derivative, 2.7, 2.8)

Process called "test_complex_step_higher_order":
    Note: Test higher order complex step derivatives
    Let function_name be "exp"
    Let evaluation_point be "0.0"
    Let order be 2
    Let step_size be 1e-15
    
    Let derivative be Differentiation.complex_step_higher_order(function_name, evaluation_point, order, step_size)
    
    UnitTest.assert_not_null(derivative, "Higher order complex step derivative should not be null")
    Note: For f(x) = exp(x), f''(0) = exp(0) = 1
    assert_numerical_close(derivative, "1.0", 1e-12, "Second derivative of exp at 0 should be 1")

Process called "test_multicomplex_derivative":
    Note: Test multicomplex differentiation
    Let function_name be "sin"
    Let evaluation_point be "0.0"
    Let max_order be 3
    
    Let derivatives be Differentiation.multicomplex_derivative(function_name, evaluation_point, max_order)
    
    UnitTest.assert_not_null(derivatives, "Multicomplex derivatives should not be null")
    UnitTest.assert_equal(derivatives.size(), max_order + 1, "Should return derivatives up to specified order")
    Note: For sin(x) at x=0: f(0)=0, f'(0)=1, f''(0)=0, f'''(0)=-1
    assert_numerical_close(derivatives[0], "0.0", 1e-12, "sin(0) should be 0")
    assert_numerical_close(derivatives[1], "1.0", 1e-12, "sin'(0) should be 1")
    assert_numerical_close(derivatives[2], "0.0", 1e-12, "sin''(0) should be 0")
    assert_numerical_close(derivatives[3], "-1.0", 1e-12, "sin'''(0) should be -1")

Process called "test_hyper_dual_derivative":
    Note: Test hyper-dual number differentiation
    Let function_name be "x_cubed"
    Let evaluation_point be "2.0"
    Let max_order be 2
    
    Let derivatives be Differentiation.hyper_dual_derivative(function_name, evaluation_point, max_order)
    
    UnitTest.assert_not_null(derivatives, "Hyper-dual derivatives should not be null")
    UnitTest.assert_equal(derivatives.size(), max_order + 1, "Should return derivatives up to specified order")
    Note: For f(x) = x^3 at x=2: f(2)=8, f'(2)=12, f''(2)=12
    assert_numerical_close(derivatives[0], "8.0", 1e-12, "x^3 at x=2 should be 8")
    assert_numerical_close(derivatives[1], "12.0", 1e-12, "Derivative of x^3 at x=2 should be 12")
    assert_numerical_close(derivatives[2], "12.0", 1e-12, "Second derivative of x^3 at x=2 should be 12")

Note: =====================================================================
Note: AUTOMATIC DIFFERENTIATION TESTS
Note: =====================================================================

Process called "test_forward_mode_ad":
    Note: Test forward mode automatic differentiation
    Let function_expression be "x*x + 2*x + 1"
    Let variables be List[String]
    Let variables be variables.append("x")
    Let values be List[String]
    Let values be values.append("3.0")
    
    Let ad_result be Differentiation.forward_mode_ad(function_expression, variables, values)
    
    UnitTest.assert_not_null(ad_result, "Forward mode AD result should not be null")
    UnitTest.assert_true(Collections.contains_key(ad_result, "function_value"), "Should contain function value")
    UnitTest.assert_true(Collections.contains_key(ad_result, "derivatives"), "Should contain derivatives")
    
    Note: For f(x) = x^2 + 2x + 1 at x=3: f(3) = 16, f'(3) = 8
    assert_numerical_close(Collections.get_from_dictionary(ad_result, "function_value"), "16.0", 1e-12, "Function value")
    Let derivatives be Collections.get_from_dictionary(ad_result, "derivatives")
    assert_numerical_close(derivatives[0], "8.0", 1e-12, "Derivative should be 8")

Process called "test_reverse_mode_ad":
    Note: Test reverse mode automatic differentiation
    Let function_expression be "sin(x) + cos(y)"
    Let variables be List[String]
    Let variables be variables.append("x").append("y")
    Let values be List[String]
    Let values be values.append("0.0").append("0.0")
    
    Let ad_result be Differentiation.reverse_mode_ad(function_expression, variables, values)
    
    UnitTest.assert_not_null(ad_result, "Reverse mode AD result should not be null")
    UnitTest.assert_true(Collections.contains_key(ad_result, "function_value"), "Should contain function value")
    UnitTest.assert_true(Collections.contains_key(ad_result, "gradient"), "Should contain gradient")
    
    Note: For f(x,y) = sin(x) + cos(y) at (0,0): f(0,0) = 1, ∂f/∂x = cos(0) = 1, ∂f/∂y = -sin(0) = 0
    assert_numerical_close(Collections.get_from_dictionary(ad_result, "function_value"), "1.0", 1e-12, "Function value")
    Let gradient be Collections.get_from_dictionary(ad_result, "gradient")
    assert_numerical_close(gradient[0], "1.0", 1e-12, "Partial derivative wrt x should be 1")
    assert_numerical_close(gradient[1], "0.0", 1e-12, "Partial derivative wrt y should be 0")

Process called "test_mixed_mode_ad":
    Note: Test mixed mode automatic differentiation
    Let function_expression be "x*y*z"
    Let variables be List[String]
    Let variables be variables.append("x").append("y").append("z")
    Let values be List[String]
    Let values be values.append("2.0").append("3.0").append("4.0")
    
    Let ad_result be Differentiation.mixed_mode_ad(function_expression, variables, values)
    
    UnitTest.assert_not_null(ad_result, "Mixed mode AD result should not be null")
    UnitTest.assert_true(Collections.contains_key(ad_result, "function_value"), "Should contain function value")
    UnitTest.assert_true(Collections.contains_key(ad_result, "gradient"), "Should contain gradient")
    
    Note: For f(x,y,z) = xyz at (2,3,4): f = 24, ∂f/∂x = yz = 12, ∂f/∂y = xz = 8, ∂f/∂z = xy = 6
    assert_numerical_close(Collections.get_from_dictionary(ad_result, "function_value"), "24.0", 1e-12, "Function value")
    Let gradient be Collections.get_from_dictionary(ad_result, "gradient")
    assert_numerical_close(gradient[0], "12.0", 1e-12, "Partial derivative wrt x should be 12")
    assert_numerical_close(gradient[1], "8.0", 1e-12, "Partial derivative wrt y should be 8")
    assert_numerical_close(gradient[2], "6.0", 1e-12, "Partial derivative wrt z should be 6")

Process called "test_higher_order_ad":
    Note: Test higher order automatic differentiation
    Let function_expression be "x^4"
    Let variable be "x"
    Let value be "2.0"
    Let max_order be 3
    
    Let derivatives be Differentiation.higher_order_ad(function_expression, variable, value, max_order)
    
    UnitTest.assert_not_null(derivatives, "Higher order AD derivatives should not be null")
    UnitTest.assert_equal(derivatives.size(), max_order + 1, "Should return derivatives up to specified order")
    
    Note: For f(x) = x^4 at x=2: f=16, f'=32, f''=48, f'''=48
    assert_numerical_close(derivatives[0], "16.0", 1e-12, "Function value should be 16")
    assert_numerical_close(derivatives[1], "32.0", 1e-12, "First derivative should be 32")
    assert_numerical_close(derivatives[2], "48.0", 1e-12, "Second derivative should be 48")
    assert_numerical_close(derivatives[3], "48.0", 1e-12, "Third derivative should be 48")

Process called "test_sparse_ad":
    Note: Test sparse automatic differentiation
    Let function_expression be "x1*x1 + x5*x5"  Note: Only depends on x1 and x5 out of many variables
    Let variables be List[String]
    Let variables be variables.append("x1").append("x2").append("x3").append("x4").append("x5")
    Let values be List[String]
    Let values be values.append("2.0").append("0.0").append("0.0").append("0.0").append("3.0")
    
    Let sparse_result be Differentiation.sparse_ad(function_expression, variables, values)
    
    UnitTest.assert_not_null(sparse_result, "Sparse AD result should not be null")
    UnitTest.assert_true(Collections.contains_key(sparse_result, "function_value"), "Should contain function value")
    UnitTest.assert_true(Collections.contains_key(sparse_result, "sparse_gradient"), "Should contain sparse gradient")
    
    Note: For f = x1^2 + x5^2 at (2,0,0,0,3): f = 13, ∂f/∂x1 = 4, ∂f/∂x5 = 6, others = 0
    assert_numerical_close(Collections.get_from_dictionary(sparse_result, "function_value"), "13.0", 1e-12, "Function value")
    Let sparse_gradient be Collections.get_from_dictionary(sparse_result, "sparse_gradient")
    UnitTest.assert_true(Collections.contains_key(sparse_gradient, "x1"), "Should have gradient for x1")
    UnitTest.assert_true(Collections.contains_key(sparse_gradient, "x5"), "Should have gradient for x5")
    assert_numerical_close(Collections.get_from_dictionary(sparse_gradient, "x1"), "4.0", 1e-12, "Gradient wrt x1")
    assert_numerical_close(Collections.get_from_dictionary(sparse_gradient, "x5"), "6.0", 1e-12, "Gradient wrt x5")

Note: =====================================================================
Note: PARTIAL DERIVATIVES TESTS
Note: =====================================================================

Process called "test_partial_derivative":
    Note: Test partial derivative computation
    Let function_data be create_multivariate_function_data()
    Let variable_index be 0  Note: Partial derivative with respect to x
    Let evaluation_point be List[String]
    Let evaluation_point be evaluation_point.append("1.5").append("1.5")
    
    Let partial_deriv be Differentiation.partial_derivative(function_data, variable_index, evaluation_point, "central")
    
    UnitTest.assert_not_null(partial_deriv, "Partial derivative should not be null")
    Note: For f(x,y) = x^2 + xy + y^2, ∂f/∂x = 2x + y. At (1.5, 1.5): ∂f/∂x = 3 + 1.5 = 4.5
    assert_derivative_valid(partial_deriv, 4.0, 5.0)

Process called "test_mixed_partial_derivative":
    Note: Test mixed partial derivative computation
    Let function_data be create_multivariate_function_data()
    Let variable_indices be List[Integer]
    Let variable_indices be variable_indices.append(0).append(1)  Note: ∂²f/∂x∂y
    Let evaluation_point be List[String]
    Let evaluation_point be evaluation_point.append("2.0").append("3.0")
    
    Let mixed_partial be Differentiation.mixed_partial_derivative(function_data, variable_indices, evaluation_point)
    
    UnitTest.assert_not_null(mixed_partial, "Mixed partial derivative should not be null")
    Note: For f(x,y) = x^2 + xy + y^2, ∂²f/∂x∂y = 1 (constant)
    assert_numerical_close(mixed_partial, "1.0", 1e-10, "Mixed partial derivative should be 1")

Process called "test_gradient_vector":
    Note: Test gradient vector computation
    Let function_data be create_multivariate_function_data()
    Let evaluation_point be List[String]
    Let evaluation_point be evaluation_point.append("2.0").append("1.0")
    
    Let gradient be Differentiation.gradient_vector(function_data, evaluation_point)
    
    assert_gradient_valid(gradient, 2)
    Note: For f(x,y) = x^2 + xy + y^2 at (2,1): ∇f = [2x+y, x+2y] = [5, 4]
    assert_numerical_close(gradient[0], "5.0", 1e-10, "Gradient x-component")
    assert_numerical_close(gradient[1], "4.0", 1e-10, "Gradient y-component")

Process called "test_directional_derivative":
    Note: Test directional derivative computation
    Let function_data be create_multivariate_function_data()
    Let evaluation_point be List[String]
    Let evaluation_point be evaluation_point.append("1.0").append("1.0")
    Let direction_vector be List[String]
    Let direction_vector be direction_vector.append("0.6").append("0.8")  Note: Unit vector in direction (3,4)
    
    Let directional_deriv be Differentiation.directional_derivative(function_data, evaluation_point, direction_vector)
    
    UnitTest.assert_not_null(directional_deriv, "Directional derivative should not be null")
    Note: For f(x,y) = x^2 + xy + y^2 at (1,1): ∇f = [3, 3]. Directional derivative = ∇f·û = 3*0.6 + 3*0.8 = 4.2
    assert_numerical_close(directional_deriv, "4.2", 1e-10, "Directional derivative")

Note: =====================================================================
Note: JACOBIAN COMPUTATION TESTS
Note: =====================================================================

Process called "test_compute_jacobian":
    Note: Test Jacobian matrix computation
    Let vector_function be List[String]
    Let vector_function be vector_function.append("x*x + y").append("x + y*y")
    Let variables be List[String]
    Let variables be variables.append("x").append("y")
    Let evaluation_point be List[String]
    Let evaluation_point be evaluation_point.append("2.0").append("3.0")
    
    Let jacobian be Differentiation.compute_jacobian(vector_function, variables, evaluation_point)
    
    assert_jacobian_valid(jacobian, 2, 2)
    Note: For [f1, f2] = [x^2+y, x+y^2] at (2,3): J = [[2x, 1], [1, 2y]] = [[4, 1], [1, 6]]
    assert_numerical_close(jacobian.entries[0][0], "4.0", 1e-12, "J[0,0] should be 4")
    assert_numerical_close(jacobian.entries[0][1], "1.0", 1e-12, "J[0,1] should be 1")
    assert_numerical_close(jacobian.entries[1][0], "1.0", 1e-12, "J[1,0] should be 1")
    assert_numerical_close(jacobian.entries[1][1], "6.0", 1e-12, "J[1,1] should be 6")

Process called "test_sparse_jacobian":
    Note: Test sparse Jacobian computation
    Let vector_function be List[String]
    Let vector_function be vector_function.append("x1*x1").append("x3*x3")  Note: Sparse dependencies
    Let variables be List[String]
    Let variables be variables.append("x1").append("x2").append("x3")
    Let evaluation_point be List[String]
    Let evaluation_point be evaluation_point.append("2.0").append("0.0").append("3.0")
    
    Let sparse_jacobian be Differentiation.sparse_jacobian(vector_function, variables, evaluation_point)
    
    UnitTest.assert_not_null(sparse_jacobian, "Sparse Jacobian should not be null")
    UnitTest.assert_true(Collections.contains_key(sparse_jacobian, "non_zero_entries"), "Should contain non-zero entries")
    UnitTest.assert_true(Collections.contains_key(sparse_jacobian, "sparsity_pattern"), "Should contain sparsity pattern")

Process called "test_jacobian_vector_product":
    Note: Test Jacobian-vector product (forward mode)
    Let vector_function be List[String]
    Let vector_function be vector_function.append("x*y").append("x + y")
    Let variables be List[String]
    Let variables be variables.append("x").append("y")
    Let evaluation_point be List[String]
    Let evaluation_point be evaluation_point.append("3.0").append("2.0")
    Let direction_vector be List[String]
    Let direction_vector be direction_vector.append("1.0").append("-1.0")
    
    Let jv_product be Differentiation.jacobian_vector_product(vector_function, variables, evaluation_point, direction_vector)
    
    UnitTest.assert_not_null(jv_product, "Jacobian-vector product should not be null")
    UnitTest.assert_equal(jv_product.size(), 2, "Should have 2 components")
    Note: For [xy, x+y] at (3,2): J = [[y, x], [1, 1]] = [[2, 3], [1, 1]]. J*[1,-1] = [2-3, 1-1] = [-1, 0]
    assert_numerical_close(jv_product[0], "-1.0", 1e-12, "First component of J*v")
    assert_numerical_close(jv_product[1], "0.0", 1e-12, "Second component of J*v")

Process called "test_vector_jacobian_product":
    Note: Test vector-Jacobian product (reverse mode)
    Let vector_function be List[String]
    Let vector_function be vector_function.append("x*x*y").append("x*y*y")
    Let variables be List[String]
    Let variables be variables.append("x").append("y")
    Let evaluation_point be List[String]
    Let evaluation_point be evaluation_point.append("2.0").append("3.0")
    Let left_vector be List[String]
    Let left_vector be left_vector.append("1.0").append("2.0")
    
    Let vj_product be Differentiation.vector_jacobian_product(vector_function, variables, evaluation_point, left_vector)
    
    UnitTest.assert_not_null(vj_product, "Vector-Jacobian product should not be null")
    UnitTest.assert_equal(vj_product.size(), 2, "Should have 2 components")

Process called "test_approximate_jacobian":
    Note: Test numerical approximation of Jacobian
    Let vector_function be List[String]
    Let vector_function be vector_function.append("sin(x) + cos(y)").append("exp(x) - log(y)")
    Let variables be List[String]
    Let variables be variables.append("x").append("y")
    Let evaluation_point be List[String]
    Let evaluation_point be evaluation_point.append("0.0").append("1.0")
    Let step_size be 1e-8
    
    Let approx_jacobian be Differentiation.approximate_jacobian(vector_function, variables, evaluation_point, step_size)
    
    assert_jacobian_valid(approx_jacobian, 2, 2)
    Note: At (0,1): J = [[cos(0), -sin(1)], [exp(0), -1/1]] = [[1, -sin(1)], [1, -1]]
    assert_numerical_close(approx_jacobian.entries[0][0], "1.0", 1e-6, "J[0,0] should be 1")
    assert_numerical_close(approx_jacobian.entries[1][0], "1.0", 1e-6, "J[1,0] should be 1")
    assert_numerical_close(approx_jacobian.entries[1][1], "-1.0", 1e-6, "J[1,1] should be -1")

Note: =====================================================================
Note: HESSIAN COMPUTATION TESTS
Note: =====================================================================

Process called "test_compute_hessian":
    Note: Test Hessian matrix computation
    Let function_expression be "x*x*x + x*y*y + y*y*y"
    Let variables be List[String]
    Let variables be variables.append("x").append("y")
    Let evaluation_point be List[String]
    Let evaluation_point be evaluation_point.append("1.0").append("2.0")
    
    Let hessian be Differentiation.compute_hessian(function_expression, variables, evaluation_point)
    
    assert_hessian_valid(hessian, 2)
    Note: For f = x^3 + xy^2 + y^3 at (1,2): 
    Note: H = [[∂²f/∂x², ∂²f/∂x∂y], [∂²f/∂y∂x, ∂²f/∂y²]] = [[6x, 2y], [2y, 2x+6y]] = [[6, 4], [4, 14]]
    assert_numerical_close(hessian.entries[0][0], "6.0", 1e-10, "H[0,0] should be 6")
    assert_numerical_close(hessian.entries[0][1], "4.0", 1e-10, "H[0,1] should be 4")
    assert_numerical_close(hessian.entries[1][1], "14.0", 1e-10, "H[1,1] should be 14")

Process called "test_sparse_hessian":
    Note: Test sparse Hessian computation
    Let function_expression be "x1*x1 + x3*x3*x5"
    Let variables be List[String]
    Let variables be variables.append("x1").append("x2").append("x3").append("x4").append("x5")
    Let evaluation_point be List[String]
    Let evaluation_point be evaluation_point.append("1.0").append("0.0").append("2.0").append("0.0").append("3.0")
    
    Let sparse_hessian be Differentiation.sparse_hessian(function_expression, variables, evaluation_point)
    
    UnitTest.assert_not_null(sparse_hessian, "Sparse Hessian should not be null")
    UnitTest.assert_true(Collections.contains_key(sparse_hessian, "non_zero_entries"), "Should contain non-zero entries")
    UnitTest.assert_true(Collections.contains_key(sparse_hessian, "sparsity_pattern"), "Should contain sparsity pattern")

Process called "test_hessian_vector_product":
    Note: Test Hessian-vector product
    Let function_expression be "x*x*y + y*y*y"
    Let variables be List[String]
    Let variables be variables.append("x").append("y")
    Let evaluation_point be List[String]
    Let evaluation_point be evaluation_point.append("2.0").append("1.0")
    Let direction_vector be List[String]
    Let direction_vector be direction_vector.append("1.0").append("0.5")
    
    Let hv_product be Differentiation.hessian_vector_product(function_expression, variables, evaluation_point, direction_vector)
    
    UnitTest.assert_not_null(hv_product, "Hessian-vector product should not be null")
    UnitTest.assert_equal(hv_product.size(), 2, "Should have 2 components")

Process called "test_gauss_newton_hessian":
    Note: Test Gauss-Newton Hessian approximation
    Let residual_functions be List[String]
    Let residual_functions be residual_functions.append("x - 2").append("y - 3").append("x*x + y*y - 13")
    Let variables be List[String]
    Let variables be variables.append("x").append("y")
    Let evaluation_point be List[String]
    Let evaluation_point be evaluation_point.append("3.0").append("2.0")
    
    Let gn_hessian be Differentiation.gauss_newton_hessian(residual_functions, variables, evaluation_point)
    
    assert_hessian_valid(gn_hessian, 2)
    UnitTest.assert_true(gn_hessian.entries[0][0] > 0.0, "Gauss-Newton Hessian should be positive definite")

Process called "test_bfgs_hessian_update":
    Note: Test BFGS Hessian update
    Let current_hessian be create_matrix_data_2x2()
    Let step_vector be List[String]
    Let step_vector be step_vector.append("0.1").append("-0.1")
    Let gradient_difference be List[String]
    Let gradient_difference be gradient_difference.append("0.05").append("0.02")
    
    Let updated_hessian be Differentiation.bfgs_hessian_update(current_hessian, step_vector, gradient_difference)
    
    UnitTest.assert_not_null(updated_hessian, "Updated Hessian should not be null")
    UnitTest.assert_equal(updated_hessian.size(), 2, "Should have 2x2 matrix")
    UnitTest.assert_equal(updated_hessian[0].size(), 2, "Should have 2 columns")

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_finite_difference_tests":
    Note: Run all finite difference method tests
    UnitTest.run_test("test_forward_difference_derivative")
    UnitTest.run_test("test_backward_difference_derivative")
    UnitTest.run_test("test_central_difference_derivative")
    UnitTest.run_test("test_higher_order_finite_difference")
    UnitTest.run_test("test_adaptive_step_size_derivative")
    UnitTest.run_test("test_finite_difference_from_values")
    UnitTest.run_test("test_finite_difference_weights_derivative")

Process called "run_advanced_difference_tests":
    Note: Run all advanced difference method tests
    UnitTest.run_test("test_complex_step_derivative")
    UnitTest.run_test("test_complex_step_higher_order")
    UnitTest.run_test("test_multicomplex_derivative")
    UnitTest.run_test("test_hyper_dual_derivative")

Process called "run_automatic_differentiation_tests":
    Note: Run all automatic differentiation tests
    UnitTest.run_test("test_forward_mode_ad")
    UnitTest.run_test("test_reverse_mode_ad")
    UnitTest.run_test("test_mixed_mode_ad")
    UnitTest.run_test("test_higher_order_ad")
    UnitTest.run_test("test_sparse_ad")

Process called "run_jacobian_tests":
    Note: Run all Jacobian computation tests
    UnitTest.run_test("test_compute_jacobian")
    UnitTest.run_test("test_sparse_jacobian")
    UnitTest.run_test("test_jacobian_vector_product")
    UnitTest.run_test("test_vector_jacobian_product")
    UnitTest.run_test("test_approximate_jacobian")

Process called "run_hessian_tests":
    Note: Run all Hessian computation tests
    UnitTest.run_test("test_compute_hessian")
    UnitTest.run_test("test_sparse_hessian")
    UnitTest.run_test("test_hessian_vector_product")
    UnitTest.run_test("test_gauss_newton_hessian")
    UnitTest.run_test("test_bfgs_hessian_update")

Process called "run_all_differentiation_tests":
    Note: Run comprehensive test suite for all differentiation functionality
    Let start_time be DateTime.get_current_timestamp()
    
    UnitTest.start_test_suite("Numerical Differentiation Tests")
    
    UnitTest.start_test_group("Finite Difference Methods")
    run_finite_difference_tests()
    
    UnitTest.start_test_group("Advanced Difference Methods")
    run_advanced_difference_tests()
    
    UnitTest.start_test_group("Automatic Differentiation")
    run_automatic_differentiation_tests()
    
    UnitTest.start_test_group("Partial Derivatives")
    UnitTest.run_test("test_partial_derivative")
    UnitTest.run_test("test_mixed_partial_derivative")
    UnitTest.run_test("test_gradient_vector")
    UnitTest.run_test("test_directional_derivative")
    
    UnitTest.start_test_group("Jacobian Computation")
    run_jacobian_tests()
    
    UnitTest.start_test_group("Hessian Computation")
    run_hessian_tests()
    
    Let end_time be DateTime.get_current_timestamp()
    Let duration be DateTime.calculate_duration(start_time, end_time)
    
    UnitTest.end_test_suite("Numerical Differentiation Tests completed in " ++ duration.to_string() ++ " seconds")

Process called "run_quick_differentiation_tests":
    Note: Run essential differentiation tests for continuous integration
    UnitTest.start_test_suite("Quick Differentiation Tests")
    
    Note: Test core functionality
    UnitTest.run_test("test_central_difference_derivative")
    UnitTest.run_test("test_forward_mode_ad")
    UnitTest.run_test("test_compute_jacobian")
    UnitTest.run_test("test_compute_hessian")
    
    UnitTest.end_test_suite("Quick Differentiation Tests")

Process called "get_differentiation_test_count" returns Integer:
    Note: Return total number of differentiation tests
    Return 32