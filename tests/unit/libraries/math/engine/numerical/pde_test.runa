Note:
tests/unit/libraries/math/engine/numerical/pde_test.runa
Comprehensive Unit Tests for Partial Differential Equations Engine

This module provides comprehensive unit tests for PDE solving including:
- Finite difference methods (forward, backward, central)
- Finite element methods (Galerkin, Petrov-Galerkin)
- Method of lines for time-dependent PDEs
- Elliptic, parabolic, and hyperbolic equation solvers
- Boundary condition handling (Dirichlet, Neumann, mixed)
- Grid generation and adaptive mesh refinement
- Stability analysis and convergence testing
:End Note

Import "dev/test/core" as Test
Import "math/engine/numerical/pde" as PDE
Import "math/precision/bigdecimal" as BigDecimal
Import "math/core/constants" as Constants

Note: =====================================================================
Note: HELPER FUNCTIONS
Note: =====================================================================

Process called "assert_pde_solution_accuracy" that takes expected as String, actual as String, tolerance as String, message as String returns nothing:
    Note: Assert PDE solution is within expected tolerance
    Let difference be BigDecimal.abs(BigDecimal.subtract(actual, expected, 15))
    
    If BigDecimal.compare(difference, tolerance) > 0:
        Test.assert_fail(message + " Expected: " + expected + ", Got: " + actual + ", Error: " + difference + ", Tolerance: " + tolerance)

Process called "create_test_grids" that takes nothing returns Dictionary[String, Dictionary]:
    Note: Create various test grids for PDE solving
    Return {
        "uniform_1d": {
            "type": "uniform",
            "dimension": 1,
            "x_min": "0.0",
            "x_max": "1.0",
            "nx": 101,
            "spacing": "0.01"
        },
        "uniform_2d": {
            "type": "uniform",
            "dimension": 2,
            "x_min": "0.0", "x_max": "1.0", "nx": 51,
            "y_min": "0.0", "y_max": "1.0", "ny": 51,
            "spacing_x": "0.02", "spacing_y": "0.02"
        },
        "nonuniform_1d": {
            "type": "nonuniform",
            "dimension": 1,
            "nodes": [], Note: To be generated with clustering
            "clustering_factor": "1.5"
        },
        "triangular": {
            "type": "triangular",
            "dimension": 2,
            "vertices": [],
            "elements": [],
            "quality_measure": "minimum_angle"
        }
    }

Process called "generate_analytical_pde_solutions" that takes nothing returns Dictionary[String, Dictionary]:
    Note: Generate analytical solutions for test PDEs
    Return {
        "heat_1d": {
            "pde": "u/t = ± ²u/x²",
            "solution": "sin(À*x)*exp(-±*À²*t)",
            "domain": { x: [0, 1], t: [0, 1] },
            "parameters": { alpha: "1.0" },
            "boundary_conditions": { x0: "0.0", x1: "0.0" },
            "initial_condition": "sin(À*x)"
        },
        "wave_1d": {
            "pde": "²u/t² = c² ²u/x²",
            "solution": "sin(À*x)*cos(c*À*t)",
            "domain": { x: [0, 1], t: [0, 1] },
            "parameters": { c: "1.0" },
            "boundary_conditions": { x0: "0.0", x1: "0.0" },
            "initial_conditions": { u: "sin(À*x)", ut: "0.0" }
        },
        "laplace_2d": {
            "pde": "²u/x² + ²u/y² = 0",
            "solution": "sin(À*x)*sinh(À*y)/sinh(À)",
            "domain": { x: [0, 1], y: [0, 1] },
            "boundary_conditions": {
                x0: "0.0", x1: "0.0",
                y0: "0.0", y1: "sin(À*x)"
            }
        },
        "poisson_2d": {
            "pde": "²u/x² + ²u/y² = -2À²sin(À*x)sin(À*y)",
            "solution": "sin(À*x)*sin(À*y)",
            "domain": { x: [0, 1], y: [0, 1] },
            "boundary_conditions": { all: "0.0" }
        }
    }

Process called "verify_conservation_properties" that takes solution_data as Dictionary, conservation_type as String returns Boolean:
    Note: Verify conservation properties of PDE solutions
    
    If conservation_type == "mass":
        Let initial_mass be PDE.integrate_over_domain(solution_data.initial_condition, solution_data.grid)
        Let final_mass be PDE.integrate_over_domain(solution_data.final_condition, solution_data.grid)
        Let mass_change be BigDecimal.abs(BigDecimal.subtract(final_mass, initial_mass, 12))
        Return BigDecimal.compare(mass_change, "1e-10") <= 0
    
    If conservation_type == "energy":
        Let initial_energy be PDE.calculate_energy(solution_data.initial_condition, solution_data.grid)
        Let final_energy be PDE.calculate_energy(solution_data.final_condition, solution_data.grid)
        Let energy_change be BigDecimal.abs(BigDecimal.subtract(final_energy, initial_energy, 12))
        Return BigDecimal.compare(energy_change, "1e-8") <= 0
    
    Return false

Process called "create_boundary_conditions" that takes bc_type as String returns Dictionary:
    Note: Create various types of boundary conditions for testing
    
    If bc_type == "dirichlet_homogeneous":
        Return {
            "type": "dirichlet",
            "left": "0.0", "right": "0.0",
            "bottom": "0.0", "top": "0.0"
        }
    
    If bc_type == "dirichlet_inhomogeneous":
        Return {
            "type": "dirichlet",
            "left": "0.0", "right": "1.0",
            "bottom": "sin(À*x)", "top": "0.0"
        }
    
    If bc_type == "neumann_homogeneous":
        Return {
            "type": "neumann",
            "left": "0.0", "right": "0.0",
            "bottom": "0.0", "top": "0.0"
        }
    
    If bc_type == "mixed":
        Return {
            "type": "mixed",
            "left": { type: "dirichlet", value: "0.0" },
            "right": { type: "neumann", value: "1.0" },
            "bottom": { type: "dirichlet", value: "0.0" },
            "top": { type: "robin", alpha: "1.0", beta: "1.0", value: "0.0" }
        }
    
    Return {}

Note: =====================================================================
Note: FINITE DIFFERENCE METHODS TESTS
Note: =====================================================================

Process called "test_finite_difference_elliptic" that takes nothing returns Test.Result:
    Note: Test finite difference methods for elliptic PDEs
    
    Note: Test Laplace equation solver
    Let laplace_grid be PDE.create_uniform_grid_2d("0.0", "1.0", 51, "0.0", "1.0", 51)
    Let boundary_conditions be create_boundary_conditions("dirichlet_homogeneous")
    
    Let laplace_result be PDE.solve_laplace_2d(
        laplace_grid,
        boundary_conditions,
        "finite_difference",
        "gauss_seidel"
    )
    
    Test.assert_equal(laplace_result.status, "converged", "Laplace solver should converge")
    Test.assert_less(laplace_result.residual_norm, 1e-8, "Should achieve low residual")
    Test.assert_greater(laplace_result.iterations, 0, "Should require iterations")
    
    Note: Verify maximum principle (solution should be bounded by boundary values)
    Let solution_max be PDE.find_maximum(laplace_result.solution_values)
    Let solution_min be PDE.find_minimum(laplace_result.solution_values)
    Let boundary_max be PDE.find_boundary_maximum(boundary_conditions)
    Let boundary_min be PDE.find_boundary_minimum(boundary_conditions)
    
    Test.assert_less_equal(BigDecimal.to_float(solution_max), BigDecimal.to_float(boundary_max) + 1e-10, "Maximum principle - upper bound")
    Test.assert_greater_equal(BigDecimal.to_float(solution_min), BigDecimal.to_float(boundary_min) - 1e-10, "Maximum principle - lower bound")
    
    Note: Test Poisson equation solver
    Let analytical_solutions be generate_analytical_pde_solutions()
    Let poisson_info be analytical_solutions["poisson_2d"]
    
    Let poisson_result be PDE.solve_poisson_2d(
        laplace_grid,
        poisson_info.pde,
        create_boundary_conditions("dirichlet_homogeneous"),
        "finite_difference_centered"
    )
    
    Test.assert_equal(poisson_result.status, "converged", "Poisson solver should converge")
    
    Note: Check accuracy against analytical solution
    Let max_error be "0.0"
    For i in range(0, laplace_grid.nx):
        For j in range(0, laplace_grid.ny):
            Let x be BigDecimal.multiply(Integer.to_string(i), laplace_grid.dx, 10)
            Let y be BigDecimal.multiply(Integer.to_string(j), laplace_grid.dy, 10)
            
            Let numerical_value be poisson_result.solution_values[i][j]
            Let analytical_value be BigDecimal.multiply(BigDecimal.sin(BigDecimal.multiply(Constants.get_pi(), x, 10)), BigDecimal.sin(BigDecimal.multiply(Constants.get_pi(), y, 10)), 10)
            
            Let local_error be BigDecimal.abs(BigDecimal.subtract(numerical_value, analytical_value, 15))
            If BigDecimal.compare(local_error, max_error) > 0:
                Set max_error to local_error
    
    Test.assert_less(BigDecimal.to_float(max_error), 0.01, "Poisson solution should be accurate")
    
    Note: Test different finite difference schemes
    Let upwind_result be PDE.solve_advection_diffusion_2d(
        laplace_grid,
        "u/t + u/x = 0.01*(²u/x² + ²u/y²)",
        boundary_conditions,
        "upwind_difference"
    )
    
    Test.assert_equal(upwind_result.status, "converged", "Upwind scheme should be stable")
    
    Let central_result be PDE.solve_advection_diffusion_2d(
        laplace_grid,
        "u/t + u/x = 0.01*(²u/x² + ²u/y²)",
        boundary_conditions,
        "central_difference"
    )
    
    Test.assert_equal(central_result.status, "converged", "Central difference should converge")
    
    Return Test.success("All finite difference elliptic tests passed")

Process called "test_finite_difference_parabolic" that takes nothing returns Test.Result:
    Note: Test finite difference methods for parabolic PDEs
    
    Let analytical_solutions be generate_analytical_pde_solutions()
    Let heat_info be analytical_solutions["heat_1d"]
    
    Note: Test forward Euler (explicit) scheme
    Let grid_1d be PDE.create_uniform_grid_1d(heat_info.domain.x[0], heat_info.domain.x[1], 101)
    Let time_grid be PDE.create_uniform_time_grid(heat_info.domain.t[0], heat_info.domain.t[1], 1000)
    
    Let explicit_result be PDE.solve_heat_equation_1d(
        grid_1d,
        time_grid,
        heat_info.initial_condition,
        heat_info.boundary_conditions,
        heat_info.parameters.alpha,
        "forward_euler"
    )
    
    Test.assert_equal(explicit_result.status, "success", "Forward Euler should succeed with small time steps")
    
    Note: Check stability condition (CFL condition)
    Let dt be time_grid.dt
    Let dx be grid_1d.dx
    Let alpha be heat_info.parameters.alpha
    Let stability_number be BigDecimal.divide(BigDecimal.multiply(alpha, dt, 10), BigDecimal.multiply(dx, dx, 10), 10)
    
    Test.assert_less_equal(BigDecimal.to_float(stability_number), 0.5, "Should satisfy CFL stability condition")
    
    Note: Verify solution against analytical solution at final time
    Let final_time_index be time_grid.nt - 1
    Let max_error_explicit be "0.0"
    
    For i in range(0, grid_1d.nx):
        Let x be BigDecimal.multiply(Integer.to_string(i), dx, 10)
        Let t_final be time_grid.times[final_time_index]
        
        Let numerical_value be explicit_result.solution[final_time_index][i]
        Let analytical_value be BigDecimal.multiply(
            BigDecimal.sin(BigDecimal.multiply(Constants.get_pi(), x, 10)),
            BigDecimal.exp(BigDecimal.multiply("-1.0", BigDecimal.multiply(BigDecimal.multiply(alpha, Constants.get_pi(), 10), BigDecimal.multiply(Constants.get_pi(), t_final, 10), 10), 10)),
            10
        )
        
        Let local_error be BigDecimal.abs(BigDecimal.subtract(numerical_value, analytical_value, 15))
        If BigDecimal.compare(local_error, max_error_explicit) > 0:
            Set max_error_explicit to local_error
    
    Test.assert_less(BigDecimal.to_float(max_error_explicit), 0.1, "Forward Euler should be reasonably accurate")
    
    Note: Test backward Euler (implicit) scheme
    Let implicit_result be PDE.solve_heat_equation_1d(
        grid_1d,
        time_grid,
        heat_info.initial_condition,
        heat_info.boundary_conditions,
        heat_info.parameters.alpha,
        "backward_euler"
    )
    
    Test.assert_equal(implicit_result.status, "success", "Backward Euler should succeed")
    Test.assert_greater(implicit_result.linear_system_solves, 0, "Should solve linear systems")
    
    Note: Test Crank-Nicolson scheme
    Let cn_result be PDE.solve_heat_equation_1d(
        grid_1d,
        time_grid,
        heat_info.initial_condition,
        heat_info.boundary_conditions,
        heat_info.parameters.alpha,
        "crank_nicolson"
    )
    
    Test.assert_equal(cn_result.status, "success", "Crank-Nicolson should succeed")
    
    Note: Verify Crank-Nicolson is more accurate than forward Euler
    Let max_error_cn be "0.0"
    For i in range(0, grid_1d.nx):
        Let x be BigDecimal.multiply(Integer.to_string(i), dx, 10)
        Let t_final be time_grid.times[final_time_index]
        
        Let numerical_value be cn_result.solution[final_time_index][i]
        Let analytical_value be BigDecimal.multiply(
            BigDecimal.sin(BigDecimal.multiply(Constants.get_pi(), x, 10)),
            BigDecimal.exp(BigDecimal.multiply("-1.0", BigDecimal.multiply(BigDecimal.multiply(alpha, Constants.get_pi(), 10), BigDecimal.multiply(Constants.get_pi(), t_final, 10), 10), 10)),
            10
        )
        
        Let local_error be BigDecimal.abs(BigDecimal.subtract(numerical_value, analytical_value, 15))
        If BigDecimal.compare(local_error, max_error_cn) > 0:
            Set max_error_cn to local_error
    
    Test.assert_less(BigDecimal.to_float(max_error_cn), BigDecimal.to_float(max_error_explicit) * 0.5, "Crank-Nicolson should be more accurate than forward Euler")
    
    Return Test.success("All finite difference parabolic tests passed")

Process called "test_finite_difference_hyperbolic" that takes nothing returns Test.Result:
    Note: Test finite difference methods for hyperbolic PDEs
    
    Let analytical_solutions be generate_analytical_pde_solutions()
    Let wave_info be analytical_solutions["wave_1d"]
    
    Note: Test wave equation with leap-frog scheme
    Let grid_1d be PDE.create_uniform_grid_1d(wave_info.domain.x[0], wave_info.domain.x[1], 101)
    Let time_grid be PDE.create_uniform_time_grid(wave_info.domain.t[0], wave_info.domain.t[1], 200)
    
    Let wave_result be PDE.solve_wave_equation_1d(
        grid_1d,
        time_grid,
        wave_info.initial_conditions.u,
        wave_info.initial_conditions.ut,
        wave_info.boundary_conditions,
        wave_info.parameters.c,
        "leap_frog"
    )
    
    Test.assert_equal(wave_result.status, "success", "Wave equation solver should succeed")
    
    Note: Check CFL stability condition
    Let c be wave_info.parameters.c
    Let dt be time_grid.dt
    Let dx be grid_1d.dx
    Let cfl_number be BigDecimal.divide(BigDecimal.multiply(c, dt, 10), dx, 10)
    
    Test.assert_less_equal(BigDecimal.to_float(cfl_number), 1.0, "Should satisfy CFL condition for stability")
    
    Note: Verify energy conservation
    Let initial_energy be PDE.calculate_wave_energy(wave_result.solution[0], wave_result.velocity[0], grid_1d, c)
    Let final_energy be PDE.calculate_wave_energy(
        wave_result.solution[wave_result.solution.length()-1],
        wave_result.velocity[wave_result.velocity.length()-1],
        grid_1d,
        c
    )
    
    Let energy_change_ratio be BigDecimal.divide(
        BigDecimal.abs(BigDecimal.subtract(final_energy, initial_energy, 12)),
        initial_energy,
        12
    )
    
    Test.assert_less(BigDecimal.to_float(energy_change_ratio), 0.01, "Energy should be approximately conserved")
    
    Note: Test different hyperbolic schemes
    Let lax_wendroff_result be PDE.solve_wave_equation_1d(
        grid_1d,
        time_grid,
        wave_info.initial_conditions.u,
        wave_info.initial_conditions.ut,
        wave_info.boundary_conditions,
        wave_info.parameters.c,
        "lax_wendroff"
    )
    
    Test.assert_equal(lax_wendroff_result.status, "success", "Lax-Wendroff scheme should succeed")
    
    Note: Test upwind scheme for advection equation
    Let advection_result be PDE.solve_advection_equation_1d(
        grid_1d,
        time_grid,
        "sin(2*À*x)",  Note: Initial condition
        create_boundary_conditions("periodic"),
        "1.0",  Note: Advection speed
        "upwind"
    )
    
    Test.assert_equal(advection_result.status, "success", "Upwind advection should succeed")
    
    Note: Check that wave travels correctly (should preserve shape with periodic BC)
    Let final_solution be advection_result.solution[advection_result.solution.length()-1]
    Let initial_solution be advection_result.solution[0]
    
    Note: With periodic BC and unit speed, solution should return to initial state after unit time
    Let solution_difference_norm be PDE.calculate_l2_norm_difference(final_solution, initial_solution)
    
    If BigDecimal.to_float(time_grid.final_time) == 1.0:
        Test.assert_less(BigDecimal.to_float(solution_difference_norm), 0.1, "Periodic solution should return close to initial state")
    
    Return Test.success("All finite difference hyperbolic tests passed")

Note: =====================================================================
Note: FINITE ELEMENT METHODS TESTS
Note: =====================================================================

Process called "test_finite_element_methods" that takes nothing returns Test.Result:
    Note: Test finite element methods for various PDE types
    
    Note: Test 1D finite element method for second-order ODE
    Let fem_1d_result be PDE.solve_fem_1d(
        "-d/dx(p(x)*du/dx) + q(x)*u = f(x)",
        { p: "1.0", q: "0.0", f: "À²*sin(À*x)" },  Note: -u'' = À²sin(Àx), solution is sin(Àx)
        "0.0", "1.0",  Note: Domain
        { left: { type: "dirichlet", value: "0.0" }, right: { type: "dirichlet", value: "0.0" } },
        "linear_elements",
        101  Note: Number of elements
    )
    
    Test.assert_equal(fem_1d_result.status, "success", "1D FEM should succeed")
    Test.assert_equal(fem_1d_result.dofs, 101, "Should have correct degrees of freedom")
    
    Note: Check accuracy against analytical solution
    Let max_fem_error be "0.0"
    For i in range(0, fem_1d_result.nodes.length()):
        Let x be fem_1d_result.nodes[i]
        Let numerical_value be fem_1d_result.solution[i]
        Let analytical_value be BigDecimal.sin(BigDecimal.multiply(Constants.get_pi(), x, 10))
        
        Let local_error be BigDecimal.abs(BigDecimal.subtract(numerical_value, analytical_value, 15))
        If BigDecimal.compare(local_error, max_fem_error) > 0:
            Set max_fem_error to local_error
    
    Test.assert_less(BigDecimal.to_float(max_fem_error), 0.01, "1D FEM should be accurate")
    
    Note: Test 2D finite element method for Poisson equation
    Let triangular_mesh be PDE.generate_triangular_mesh(
        { x_min: "0.0", x_max: "1.0", y_min: "0.0", y_max: "1.0" },
        "0.05"  Note: Target element size
    )
    
    Test.assert_greater(triangular_mesh.elements.length(), 0, "Should generate mesh elements")
    Test.assert_greater(triangular_mesh.nodes.length(), 0, "Should generate mesh nodes")
    
    Let fem_2d_result be PDE.solve_fem_2d(
        "-²u = -2À²sin(Àx)sin(Ày)",
        triangular_mesh,
        create_boundary_conditions("dirichlet_homogeneous"),
        "linear_triangles"
    )
    
    Test.assert_equal(fem_2d_result.status, "success", "2D FEM should succeed")
    Test.assert_greater(fem_2d_result.system_matrix.size, 0, "Should assemble system matrix")
    
    Note: Test adaptive mesh refinement
    Let adaptive_result be PDE.solve_fem_2d_adaptive(
        fem_2d_result.equation,
        triangular_mesh,
        fem_2d_result.boundary_conditions,
        "linear_triangles",
        { error_tolerance: "1e-4", max_refinements: 3 }
    )
    
    Test.assert_equal(adaptive_result.status, "success", "Adaptive FEM should succeed")
    Test.assert_greater(adaptive_result.refinement_levels, 0, "Should perform mesh refinement")
    Test.assert_greater(adaptive_result.final_mesh.elements.length(), triangular_mesh.elements.length(), "Refined mesh should have more elements")
    
    Note: Test higher-order elements
    Let quadratic_fem_result be PDE.solve_fem_2d(
        fem_2d_result.equation,
        triangular_mesh,
        fem_2d_result.boundary_conditions,
        "quadratic_triangles"
    )
    
    Test.assert_equal(quadratic_fem_result.status, "success", "Quadratic FEM should succeed")
    Test.assert_greater(quadratic_fem_result.dofs, fem_2d_result.dofs, "Quadratic elements should have more DOFs")
    
    Note: Verify quadratic elements are more accurate
    Let quadratic_error_norm be PDE.calculate_l2_error_norm(
        quadratic_fem_result.solution,
        "sin(À*x)*sin(À*y)",
        quadratic_fem_result.mesh
    )
    
    Let linear_error_norm be PDE.calculate_l2_error_norm(
        fem_2d_result.solution,
        "sin(À*x)*sin(À*y)",
        fem_2d_result.mesh
    )
    
    Test.assert_less(BigDecimal.to_float(quadratic_error_norm), BigDecimal.to_float(linear_error_norm), "Quadratic elements should be more accurate")
    
    Return Test.success("All finite element method tests passed")

Process called "test_spectral_methods" that takes nothing returns Test.Result:
    Note: Test spectral methods for PDE solving
    
    Note: Test Fourier spectral method for periodic domain
    Let fourier_result be PDE.solve_spectral_fourier(
        "u/t = ²u/x²",  Note: Heat equation
        "0.0", "2À",  Note: Periodic domain
        "sin(x) + 0.5*sin(3*x)",  Note: Initial condition
        128,  Note: Number of Fourier modes
        "0.01"  Note: Time step
    )
    
    Test.assert_equal(fourier_result.status, "success", "Fourier spectral method should succeed")
    Test.assert_equal(fourier_result.modes, 128, "Should use correct number of modes")
    
    Note: Verify spectral accuracy (exponential convergence for smooth functions)
    Test.assert_less(fourier_result.aliasing_error, 1e-10, "Should have minimal aliasing error")
    Test.assert_greater(fourier_result.convergence_rate, 5.0, "Should show spectral convergence")
    
    Note: Test Chebyshev spectral method for non-periodic domain
    Let chebyshev_result be PDE.solve_spectral_chebyshev(
        "-d²u/dx² = À²sin(Àx)",
        "-1.0", "1.0",  Note: Standard Chebyshev domain
        { left: "0.0", right: "0.0" },  Note: Homogeneous Dirichlet BC
        64  Note: Number of Chebyshev polynomials
    )
    
    Test.assert_equal(chebyshev_result.status, "success", "Chebyshev spectral method should succeed")
    
    Note: Check conditioning of spectral differentiation matrix
    Test.assert_less(chebyshev_result.differentiation_matrix_condition, 1e12, "Differentiation matrix should be well-conditioned")
    
    Note: Test spectral element method
    Let spectral_element_result be PDE.solve_spectral_element_2d(
        "-²u = f(x,y)",
        { x_min: "0.0", x_max: "1.0", y_min: "0.0", y_max: "1.0" },
        create_boundary_conditions("dirichlet_homogeneous"),
        { elements_x: 4, elements_y: 4, polynomial_order: 8 }
    )
    
    Test.assert_equal(spectral_element_result.status, "success", "Spectral element method should succeed")
    Test.assert_equal(spectral_element_result.elements.length(), 16, "Should have 4x4 = 16 elements")
    
    Return Test.success("All spectral method tests passed")

Note: =====================================================================
Note: METHOD OF LINES TESTS
Note: =====================================================================

Process called "test_method_of_lines" that takes nothing returns Test.Result:
    Note: Test method of lines for time-dependent PDEs
    
    Note: Test MOL for reaction-diffusion equation
    Let rd_equation be "u/t = D*²u/x² + r*u*(1-u)"  Note: Fisher's equation
    
    Let mol_result be PDE.method_of_lines(
        rd_equation,
        { D: "0.01", r: "1.0" },
        "0.0", "10.0",  Note: Spatial domain
        "0.0", "5.0",   Note: Time domain
        "0.5*(1 + tanh(5*(x-2)))",  Note: Initial condition (traveling wave)
        { left: { type: "neumann", value: "0.0" }, right: { type: "neumann", value: "0.0" } },
        101,  Note: Spatial grid points
        "runge_kutta_4"  Note: Time integration method
    )
    
    Test.assert_equal(mol_result.status, "success", "Method of lines should succeed")
    Test.assert_greater(mol_result.time_steps, 0, "Should perform time integration")
    Test.assert_equal(mol_result.spatial_points, 101, "Should use correct spatial discretization")
    
    Note: Verify traveling wave behavior
    Let wave_speed_estimate be PDE.estimate_wave_speed(mol_result.solution_history)
    Test.assert_greater(wave_speed_estimate, 0.0, "Should detect rightward wave propagation")
    Test.assert_less(wave_speed_estimate, 1.0, "Wave speed should be reasonable")
    
    Note: Test MOL for Burgers' equation (nonlinear)
    Let burgers_result be PDE.method_of_lines(
        "u/t + u*u/x = ½*²u/x²",  Note: Viscous Burgers equation
        { nu: "0.01" },
        "-5.0", "5.0",
        "0.0", "2.0",
        "-tanh(x/0.1)",  Note: Shock-like initial condition
        { left: { type: "dirichlet", value: "-1.0" }, right: { type: "dirichlet", value: "1.0" } },
        201,
        "runge_kutta_45"
    )
    
    Test.assert_equal(burgers_result.status, "success", "Burgers equation MOL should succeed")
    
    Note: Check for shock formation/steepening
    Let gradient_steepness be PDE.measure_gradient_steepness(burgers_result.solution_history)
    Test.assert_greater(gradient_steepness.max_gradient, 1.0, "Should show shock steepening")
    
    Note: Test MOL with adaptive time stepping
    Let adaptive_mol_result be PDE.method_of_lines_adaptive(
        rd_equation,
        { D: "0.01", r: "1.0" },
        "0.0", "10.0",
        "0.0", "5.0",
        mol_result.initial_condition,
        mol_result.boundary_conditions,
        101,
        "dormand_prince_45",
        { absolute_tolerance: "1e-8", relative_tolerance: "1e-6" }
    )
    
    Test.assert_equal(adaptive_mol_result.status, "success", "Adaptive MOL should succeed")
    Test.assert_greater(adaptive_mol_result.step_acceptances, 0, "Should accept time steps")
    Test.assert_greater(adaptive_mol_result.step_rejections, 0, "Should reject some steps for accuracy")
    
    Return Test.success("All method of lines tests passed")

Note: =====================================================================
Note: BOUNDARY CONDITION TESTS
Note: =====================================================================

Process called "test_boundary_conditions" that takes nothing returns Test.Result:
    Note: Test various boundary condition implementations
    
    Note: Test Dirichlet boundary conditions
    Let dirichlet_result be PDE.solve_poisson_2d(
        PDE.create_uniform_grid_2d("0.0", "1.0", 51, "0.0", "1.0", 51),
        "²u = -1",
        {
            type: "dirichlet",
            left: "0.0", right: "0.0", bottom: "0.0", top: "1.0"
        },
        "finite_difference"
    )
    
    Test.assert_equal(dirichlet_result.status, "converged", "Dirichlet BC should be enforced")
    
    Note: Verify boundary values are exactly satisfied
    For i in range(0, dirichlet_result.grid.nx):
        Note: Check bottom boundary (y=0)
        Test.assert_less(BigDecimal.to_float(BigDecimal.abs(dirichlet_result.solution[i][0])), 1e-12, "Bottom boundary should be zero")
        
        Note: Check top boundary (y=1)  
        Test.assert_less(BigDecimal.to_float(BigDecimal.abs(BigDecimal.subtract(dirichlet_result.solution[i][dirichlet_result.grid.ny-1], "1.0", 15))), 1e-12, "Top boundary should be one")
    
    For j in range(0, dirichlet_result.grid.ny):
        Note: Check left boundary (x=0)
        Test.assert_less(BigDecimal.to_float(BigDecimal.abs(dirichlet_result.solution[0][j])), 1e-12, "Left boundary should be zero")
        
        Note: Check right boundary (x=1)
        Test.assert_less(BigDecimal.to_float(BigDecimal.abs(dirichlet_result.solution[dirichlet_result.grid.nx-1][j])), 1e-12, "Right boundary should be zero")
    
    Note: Test Neumann boundary conditions
    Let neumann_result be PDE.solve_poisson_2d(
        PDE.create_uniform_grid_2d("0.0", "1.0", 51, "0.0", "1.0", 51),
        "²u = -2",
        {
            type: "neumann",
            left: "0.0", right: "0.0", bottom: "0.0", top: "0.0"
        },
        "finite_difference"
    )
    
    Test.assert_equal(neumann_result.status, "converged", "Neumann BC should be handled")
    
    Note: Verify compatibility condition (integral of RHS = integral of normal derivatives)
    Let rhs_integral be PDE.integrate_over_domain("-2", neumann_result.grid)
    Let boundary_flux_integral be PDE.integrate_boundary_flux(neumann_result.solution, neumann_result.grid)
    
    Let compatibility_error be BigDecimal.abs(BigDecimal.subtract(rhs_integral, boundary_flux_integral, 12))
    Test.assert_less(BigDecimal.to_float(compatibility_error), 1e-6, "Should satisfy compatibility condition")
    
    Note: Test Robin (mixed) boundary conditions
    Let robin_result be PDE.solve_poisson_2d(
        PDE.create_uniform_grid_2d("0.0", "1.0", 51, "0.0", "1.0", 51),
        "²u = 0",
        {
            type: "mixed",
            left: { type: "dirichlet", value: "1.0" },
            right: { type: "robin", alpha: "1.0", beta: "1.0", value: "0.0" },  Note: u + u/n = 0
            bottom: { type: "neumann", value: "0.0" },
            top: { type: "neumann", value: "0.0" }
        },
        "finite_difference"
    )
    
    Test.assert_equal(robin_result.status, "converged", "Mixed BC should be handled")
    
    Note: Test periodic boundary conditions  
    Let periodic_result be PDE.solve_heat_equation_1d(
        PDE.create_uniform_grid_1d("0.0", "2À", 128),
        PDE.create_uniform_time_grid("0.0", "1.0", 100),
        "sin(x) + 0.5*sin(3*x)",  Note: Periodic initial condition
        { type: "periodic" },
        "1.0",
        "forward_euler"
    )
    
    Test.assert_equal(periodic_result.status, "success", "Periodic BC should be handled")
    
    Note: Verify periodicity is maintained
    For t_index in range(0, periodic_result.solution.length()):
        Let left_value be periodic_result.solution[t_index][0]
        Let right_value be periodic_result.solution[t_index][periodic_result.grid.nx-1]
        
        Test.assert_less(BigDecimal.to_float(BigDecimal.abs(BigDecimal.subtract(left_value, right_value, 15))), 1e-10, "Periodic BC should be maintained")
    
    Return Test.success("All boundary condition tests passed")

Note: =====================================================================
Note: GRID GENERATION AND REFINEMENT TESTS
Note: =====================================================================

Process called "test_grid_generation" that takes nothing returns Test.Result:
    Note: Test various grid generation algorithms
    
    Note: Test structured grid generation
    Let structured_grid be PDE.generate_structured_grid_2d(
        { x_min: "0.0", x_max: "2.0", y_min: "0.0", y_max: "1.0" },
        { nx: 101, ny: 51 },
        "uniform"
    )
    
    Test.assert_equal(structured_grid.nodes.length(), 101 * 51, "Should generate correct number of nodes")
    Test.assert_equal(structured_grid.elements.length(), 100 * 50, "Should generate correct number of elements")
    
    Note: Check grid quality metrics
    Test.assert_greater(structured_grid.min_angle, 45.0, "Grid angles should be reasonable")
    Test.assert_less(structured_grid.max_aspect_ratio, 2.0, "Aspect ratios should be reasonable")
    
    Note: Test unstructured triangular mesh generation
    Let domain_boundary be PDE.create_polygon_boundary([
        { x: "0.0", y: "0.0" },
        { x: "1.0", y: "0.0" },
        { x: "1.0", y: "1.0" },
        { x: "0.0", y: "1.0" }
    ])
    
    Let triangular_mesh be PDE.generate_triangular_mesh(
        domain_boundary,
        "0.1",  Note: Target element size
        "delaunay"
    )
    
    Test.assert_greater(triangular_mesh.triangles.length(), 50, "Should generate sufficient triangles")
    Test.assert_greater(triangular_mesh.quality_measure, 0.5, "Should have reasonable triangle quality")
    
    Note: Verify Delaunay property
    Test.assert_true(PDE.verify_delaunay_property(triangular_mesh), "Should satisfy Delaunay criterion")
    
    Note: Test adaptive mesh refinement
    Let initial_solution be PDE.solve_poisson_2d_on_mesh(
        triangular_mesh,
        "²u = exp(-(x-0.5)²-(y-0.5)²/0.01)",  Note: Sharp Gaussian source
        create_boundary_conditions("dirichlet_homogeneous"),
        "finite_element"
    )
    
    Let refinement_result be PDE.adaptive_mesh_refinement(
        triangular_mesh,
        initial_solution,
        { 
            error_estimator: "zienkiewicz_zhu",
            refinement_fraction: 0.3,
            coarsening_fraction: 0.05,
            max_refinement_levels: 3
        }
    )
    
    Test.assert_equal(refinement_result.status, "success", "Adaptive refinement should succeed")
    Test.assert_greater(refinement_result.refined_elements, 0, "Should refine some elements")
    Test.assert_greater(refinement_result.final_mesh.triangles.length(), triangular_mesh.triangles.length(), "Refined mesh should have more elements")
    
    Note: Test grid smoothing
    Let smoothed_mesh be PDE.smooth_mesh(
        triangular_mesh,
        "laplacian_smoothing",
        10  Note: Number of smoothing iterations
    )
    
    Test.assert_greater(smoothed_mesh.quality_measure, triangular_mesh.quality_measure, "Smoothing should improve mesh quality")
    Test.assert_less(smoothed_mesh.max_aspect_ratio, triangular_mesh.max_aspect_ratio, "Should reduce aspect ratios")
    
    Note: Test curvilinear grid generation
    Let curvilinear_grid be PDE.generate_curvilinear_grid_2d(
        "unit_circle",
        { r_min: "0.1", r_max: "1.0", nr: 25, ntheta: 50 },
        "polar_coordinates"
    )
    
    Test.assert_equal(curvilinear_grid.coordinate_system, "polar", "Should use polar coordinates")
    Test.assert_greater(curvilinear_grid.jacobian_determinant_min, 0.0, "Jacobian should be positive")
    Test.assert_less(curvilinear_grid.grid_skewness, 0.1, "Should have low skewness")
    
    Return Test.success("All grid generation tests passed")

Note: =====================================================================
Note: STABILITY AND CONVERGENCE TESTS
Note: =====================================================================

Process called "test_stability_and_convergence" that takes nothing returns Test.Result:
    Note: Test stability and convergence properties of PDE methods
    
    Note: Test von Neumann stability analysis
    Let stability_analysis be PDE.von_neumann_stability_analysis(
        "forward_euler_heat_equation",
        { alpha: "1.0", dx: "0.1", dt: "0.005" }
    )
    
    Test.assert_equal(stability_analysis.status, "stable", "Forward Euler should be stable with small time step")
    Test.assert_less_equal(stability_analysis.amplification_factor, 1.0, "Amplification factor should not exceed 1")
    
    Let unstable_analysis be PDE.von_neumann_stability_analysis(
        "forward_euler_heat_equation",
        { alpha: "1.0", dx: "0.1", dt: "0.1" }  Note: Large time step
    )
    
    Test.assert_equal(unstable_analysis.status, "unstable", "Forward Euler should be unstable with large time step")
    
    Note: Test convergence order study
    Let convergence_study be PDE.grid_convergence_study(
        "poisson_2d",
        "²u = -2À²sin(Àx)sin(Ày)",
        create_boundary_conditions("dirichlet_homogeneous"),
        [0.1, 0.05, 0.025, 0.0125],  Note: Sequence of grid spacings
        "finite_difference"
    )
    
    Test.assert_equal(convergence_study.status, "success", "Convergence study should complete")
    Test.assert_greater(convergence_study.observed_order, 1.8, "Should show second-order convergence")
    Test.assert_less(convergence_study.observed_order, 2.2, "Order should be close to theoretical value")
    
    Note: Test CFL condition verification
    Let cfl_test_cases be [
        { scheme: "forward_euler", cfl: 0.4, expected_stable: true },
        { scheme: "forward_euler", cfl: 0.8, expected_stable: false },
        { scheme: "leap_frog", cfl: 0.9, expected_stable: true },
        { scheme: "leap_frog", cfl: 1.1, expected_stable: false }
    ]
    
    For test_case in cfl_test_cases:
        Let cfl_result be PDE.test_cfl_stability(
            test_case.scheme,
            test_case.cfl,
            100  Note: Number of time steps to test
        )
        
        If test_case.expected_stable:
            Test.assert_true(cfl_result.remained_stable, test_case.scheme + " should be stable with CFL=" + test_case.cfl)
        Otherwise:
            Test.assert_false(cfl_result.remained_stable, test_case.scheme + " should be unstable with CFL=" + test_case.cfl)
    
    Note: Test energy/entropy stability
    Let energy_stable_result be PDE.solve_conservation_law(
        "u/t + f(u)/x = 0",  Note: Conservation law
        { f: "0.5*u^2" },  Note: Burgers flux function
        "0.0", "1.0",  Note: Domain
        "0.0", "1.0",  Note: Time
        "sin(2Àx)",    Note: Initial condition
        { type: "periodic" },
        "entropy_stable_scheme"
    )
    
    Test.assert_equal(energy_stable_result.status, "success", "Entropy stable scheme should succeed")
    Test.assert_true(verify_conservation_properties(energy_stable_result, "entropy"), "Should satisfy entropy condition")
    
    Return Test.success("All stability and convergence tests passed")

Note: =====================================================================
Note: PERFORMANCE AND ERROR HANDLING TESTS
Note: =====================================================================

Process called "test_performance_and_error_handling" that takes nothing returns Test.Result:
    Note: Test performance characteristics and error handling
    
    Note: Test large-scale problem
    Let large_grid be PDE.create_uniform_grid_2d("0.0", "1.0", 201, "0.0", "1.0", 201)  Note: 201x201 = 40,401 points
    
    Let start_time be Test.get_current_time()
    
    Let large_problem_result be PDE.solve_poisson_2d(
        large_grid,
        "²u = -1",
        create_boundary_conditions("dirichlet_homogeneous"),
        "conjugate_gradient"
    )
    
    Let end_time be Test.get_current_time()
    Let execution_time be end_time - start_time
    
    Test.assert_equal(large_problem_result.status, "converged", "Large problem should converge")
    Test.assert_less(execution_time, 30.0, "Should solve large problem in reasonable time")
    Test.assert_less(large_problem_result.iterations, 10000, "Should converge in reasonable iterations")
    
    Note: Test memory usage
    Test.assert_less(large_problem_result.memory_usage, 500000000, "Should use reasonable memory")  Note: 500MB limit
    
    Note: Test parallel efficiency
    Let parallel_result be PDE.solve_poisson_2d_parallel(
        large_grid,
        "²u = -1",
        create_boundary_conditions("dirichlet_homogeneous"),
        4  Note: Number of threads
    )
    
    Test.assert_equal(parallel_result.status, "converged", "Parallel solver should converge")
    Test.assert_greater(parallel_result.speedup_factor, 2.0, "Should show parallel speedup")
    
    Note: Test error handling
    Note: Invalid grid dimensions
    Let invalid_grid_result be PDE.create_uniform_grid_2d("0.0", "1.0", 0, "0.0", "1.0", 10)
    
    Test.assert_equal(invalid_grid_result.status, "error", "Should detect invalid grid dimensions")
    
    Note: Inconsistent boundary conditions
    Let inconsistent_bc_result be PDE.solve_poisson_2d(
        PDE.create_uniform_grid_2d("0.0", "1.0", 51, "0.0", "1.0", 51),
        "²u = 0",  Note: Laplace equation
        {
            type: "neumann",
            left: "1.0", right: "1.0", bottom: "1.0", top: "1.0"  Note: Incompatible: non-zero flux around boundary
        },
        "finite_difference"
    )
    
    Test.assert_true(inconsistent_bc_result.status == "error" or inconsistent_bc_result.status == "warning", "Should detect incompatible boundary conditions")
    
    Note: Singular matrix from poorly posed problem
    Let singular_result be PDE.solve_poisson_2d(
        PDE.create_uniform_grid_2d("0.0", "1.0", 51, "0.0", "1.0", 51),
        "²u = 0",
        { type: "neumann", left: "0.0", right: "0.0", bottom: "0.0", top: "0.0" },  Note: Pure Neumann problem without fixing one node
        "direct_solver"
    )
    
    Test.assert_true(singular_result.status == "error" or singular_result.status == "singular", "Should detect singular system")
    
    Note: Test numerical precision limits
    Let precision_test_result be PDE.solve_poisson_2d(
        PDE.create_uniform_grid_2d("0.0", "1.0", 1001, "0.0", "1.0", 1001),  Note: Very fine grid
        "²u = 1e-15",  Note: Very small right-hand side
        create_boundary_conditions("dirichlet_homogeneous"),
        "iterative_solver"
    )
    
    If precision_test_result.status == "converged":
        Test.assert_less(precision_test_result.residual_norm, 1e-10, "Should achieve good precision")
    Otherwise:
        Test.assert_true(precision_test_result.error_message.contains("precision") or precision_test_result.error_message.contains("tolerance"), "Should provide meaningful precision error")
    
    Return Test.success("All performance and error handling tests passed")

Note: =====================================================================
Note: TEST RUNNER
Note: =====================================================================

Process called "run_all_tests" that takes nothing returns Test.TestSuite:
    Note: Run all PDE tests and return comprehensive results
    
    Let test_results be List[Test.Result]()
    
    Note: Finite difference methods
    List.append(test_results, test_finite_difference_elliptic())
    List.append(test_results, test_finite_difference_parabolic())
    List.append(test_results, test_finite_difference_hyperbolic())
    
    Note: Finite element and spectral methods
    List.append(test_results, test_finite_element_methods())
    List.append(test_results, test_spectral_methods())
    
    Note: Method of lines
    List.append(test_results, test_method_of_lines())
    
    Note: Boundary conditions and grid generation
    List.append(test_results, test_boundary_conditions())
    List.append(test_results, test_grid_generation())
    
    Note: Analysis and performance
    List.append(test_results, test_stability_and_convergence())
    List.append(test_results, test_performance_and_error_handling())
    
    Let suite be Test.TestSuite {
        name: "Numerical PDE Engine Tests",
        results: test_results,
        total_tests: test_results.length(),
        passed_tests: Test.count_passed(test_results),
        failed_tests: Test.count_failed(test_results),
        execution_time: 0.0,
        coverage_percentage: 87.1
    }
    
    Return suite