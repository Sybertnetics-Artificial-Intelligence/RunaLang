Note:
Unit tests for computation graph construction and management.
Tests graph node and edge creation, graph traversal algorithms, topological sorting,
graph optimization, and dynamic/static graph management.
:End Note

Import "math/engine/autodiff/graph" as Graph
Import "dev/debug/testing/assertion_engine" as Assert
Import "collections" as Collections

Note: =====================================================================
Note: GRAPH NODE CONSTRUCTION TESTS
Note: =====================================================================

Process called "test_graph_node_construction" that takes no parameters returns Boolean:
    Note: Test basic graph node construction and properties
    Let parents be Collections.CreateList[String]()
    Let children be Collections.CreateList[String]()
    Let metadata be Dictionary[String, Any]
    Call metadata.set("operation_type", "arithmetic")
    Call metadata.set("created_at", "timestamp_1")
    
    Let graph_node be Graph.GraphNode with:
        id = "node_1"
        operation = "add"
        value = 5.0
        gradient = 0.0
        parents = parents
        children = children
        metadata = metadata
        requires_grad = true
    
    Assert.AreEqual(graph_node.id, "node_1")
    Assert.AreEqual(graph_node.operation, "add")
    Assert.AreEqual(graph_node.value, 5.0)
    Assert.AreEqual(graph_node.gradient, 0.0)
    Assert.IsTrue(graph_node.requires_grad)
    Assert.AreEqual(graph_node.parents.length, 0)
    Assert.AreEqual(graph_node.children.length, 0)
    Assert.AreEqual(graph_node.metadata.get("operation_type"), "arithmetic")
    
    Return true

Process called "test_graph_edge_construction" that takes no parameters returns Boolean:
    Note: Test graph edge construction and properties
    Let edge_metadata be Dictionary[String, Any]
    Call edge_metadata.set("gradient_flow", "forward")
    Call edge_metadata.set("weight_type", "parameter")
    
    Let graph_edge be Graph.GraphEdge with:
        source_node = "node_a"
        target_node = "node_b"
        weight = 2.5
        edge_type = "data_flow"
        metadata = edge_metadata
    
    Assert.AreEqual(graph_edge.source_node, "node_a")
    Assert.AreEqual(graph_edge.target_node, "node_b")
    Assert.AreEqual(graph_edge.weight, 2.5)
    Assert.AreEqual(graph_edge.edge_type, "data_flow")
    Assert.AreEqual(graph_edge.metadata.get("gradient_flow"), "forward")
    
    Return true

Process called "test_computation_graph_construction" that takes no parameters returns Boolean:
    Note: Test computation graph construction and initialization
    Let nodes be Dictionary[String, Graph.GraphNode]
    Let edges be Collections.CreateList[Graph.GraphEdge]()
    Let input_nodes be Collections.CreateList[String]()
    Let output_nodes be Collections.CreateList[String]()
    Let execution_order be Collections.CreateList[String]()
    
    Call input_nodes.append("input_1")
    Call input_nodes.append("input_2")
    Call output_nodes.append("output_1")
    
    Let comp_graph be Graph.ComputationGraph with:
        nodes = nodes
        edges = edges
        input_nodes = input_nodes
        output_nodes = output_nodes
        execution_order = execution_order
        is_static = true
    
    Assert.AreEqual(comp_graph.input_nodes.length, 2)
    Assert.AreEqual(comp_graph.output_nodes.length, 1)
    Assert.IsTrue(comp_graph.is_static)
    Assert.AreEqual(comp_graph.nodes.size, 0)
    Assert.AreEqual(comp_graph.edges.length, 0)
    
    Return true

Note: =====================================================================
Note: GRAPH CONSTRUCTION OPERATIONS TESTS
Note: =====================================================================

Process called "test_create_empty_graph" that takes no parameters returns Boolean:
    Note: Test creation of empty computation graph
    Let empty_graph be Graph.create_empty_graph()
    
    Assert.AreEqual(empty_graph.nodes.size, 0)
    Assert.AreEqual(empty_graph.edges.length, 0)
    Assert.AreEqual(empty_graph.input_nodes.length, 0)
    Assert.AreEqual(empty_graph.output_nodes.length, 0)
    Assert.AreEqual(empty_graph.execution_order.length, 0)
    Assert.IsTrue(empty_graph.is_static)
    
    Return true

Process called "test_add_node_to_graph" that takes no parameters returns Boolean:
    Note: Test adding nodes to computation graph
    Let graph be Graph.create_empty_graph()
    
    Let node_id be Graph.add_node(graph, "multiply", 12.0, true)
    
    Assert.IsTrue(node_id.contains("node_"))
    Assert.AreEqual(graph.nodes.size, 1)
    Assert.IsTrue(graph.nodes.has_key(node_id))
    
    Let added_node be graph.nodes.get(node_id)
    Assert.AreEqual(added_node.operation, "multiply")
    Assert.AreEqual(added_node.value, 12.0)
    Assert.IsTrue(added_node.requires_grad)
    
    Return true

Process called "test_add_multiple_nodes" that takes no parameters returns Boolean:
    Note: Test adding multiple nodes with unique IDs
    Let graph be Graph.create_empty_graph()
    
    Let node_id_1 be Graph.add_node(graph, "add", 5.0, true)
    Let node_id_2 be Graph.add_node(graph, "multiply", 10.0, false)
    Let node_id_3 be Graph.add_node(graph, "exp", 2.718, true)
    
    Assert.AreEqual(graph.nodes.size, 3)
    Assert.AreNotEqual(node_id_1, node_id_2)
    Assert.AreNotEqual(node_id_2, node_id_3)
    Assert.AreNotEqual(node_id_1, node_id_3)
    
    Assert.AreEqual(graph.nodes.get(node_id_1).operation, "add")
    Assert.AreEqual(graph.nodes.get(node_id_2).operation, "multiply")
    Assert.AreEqual(graph.nodes.get(node_id_3).operation, "exp")
    
    Return true

Process called "test_add_edge_to_graph" that takes no parameters returns Boolean:
    Note: Test adding edges between nodes in computation graph
    Let graph be Graph.create_empty_graph()
    
    Let source_id be Graph.add_node(graph, "input", 3.0, true)
    Let target_id be Graph.add_node(graph, "square", 9.0, true)
    
    Let edge_added be Graph.add_edge(graph, source_id, target_id, 1.0, "data_flow")
    
    Assert.IsTrue(edge_added)
    Assert.AreEqual(graph.edges.length, 1)
    
    Let edge be graph.edges.get(0)
    Assert.AreEqual(edge.source_node, source_id)
    Assert.AreEqual(edge.target_node, target_id)
    Assert.AreEqual(edge.weight, 1.0)
    Assert.AreEqual(edge.edge_type, "data_flow")
    
    Return true

Process called "test_connect_nodes_with_dependencies" that takes no parameters returns Boolean:
    Note: Test connecting nodes with parent-child relationships
    Let graph be Graph.create_empty_graph()
    
    Let input_id be Graph.add_node(graph, "input", 2.0, true)
    Let square_id be Graph.add_node(graph, "square", 4.0, true)
    Let add_id be Graph.add_node(graph, "add", 6.0, true)
    
    Let connection_success_1 be Graph.connect_nodes(graph, input_id, square_id)
    Let connection_success_2 be Graph.connect_nodes(graph, square_id, add_id)
    
    Assert.IsTrue(connection_success_1)
    Assert.IsTrue(connection_success_2)
    
    Let square_node be graph.nodes.get(square_id)
    Let add_node be graph.nodes.get(add_id)
    
    Assert.IsTrue(square_node.parents.contains(input_id))
    Assert.IsTrue(add_node.parents.contains(square_id))
    
    Let input_node be graph.nodes.get(input_id)
    Assert.IsTrue(input_node.children.contains(square_id))
    
    Return true

Note: =====================================================================
Note: GRAPH TRAVERSAL TESTS
Note: =====================================================================

Process called "test_depth_first_traversal" that takes no parameters returns Boolean:
    Note: Test depth-first traversal of computation graph
    Let graph be Graph.create_empty_graph()
    
    Let a_id be Graph.add_node(graph, "a", 1.0, true)
    Let b_id be Graph.add_node(graph, "b", 2.0, true)
    Let c_id be Graph.add_node(graph, "c", 3.0, true)
    Let d_id be Graph.add_node(graph, "d", 4.0, true)
    
    Call Graph.connect_nodes(graph, a_id, b_id)
    Call Graph.connect_nodes(graph, a_id, c_id)
    Call Graph.connect_nodes(graph, b_id, d_id)
    Call Graph.connect_nodes(graph, c_id, d_id)
    
    Let traversal_order be Graph.depth_first_traversal(graph, a_id)
    
    Assert.AreEqual(traversal_order.get(0), a_id)
    Assert.IsTrue(traversal_order.contains(b_id))
    Assert.IsTrue(traversal_order.contains(c_id))
    Assert.IsTrue(traversal_order.contains(d_id))
    Assert.AreEqual(traversal_order.length, 4)
    
    Return true

Process called "test_breadth_first_traversal" that takes no parameters returns Boolean:
    Note: Test breadth-first traversal of computation graph
    Let graph be Graph.create_empty_graph()
    
    Let root_id be Graph.add_node(graph, "root", 0.0, true)
    Let left_id be Graph.add_node(graph, "left", 1.0, true)
    Let right_id be Graph.add_node(graph, "right", 2.0, true)
    Let leaf_id be Graph.add_node(graph, "leaf", 3.0, true)
    
    Call Graph.connect_nodes(graph, root_id, left_id)
    Call Graph.connect_nodes(graph, root_id, right_id)
    Call Graph.connect_nodes(graph, left_id, leaf_id)
    Call Graph.connect_nodes(graph, right_id, leaf_id)
    
    Let bfs_order be Graph.breadth_first_traversal(graph, root_id)
    
    Assert.AreEqual(bfs_order.get(0), root_id)
    Assert.IsTrue(bfs_order.get(1) == left_id or bfs_order.get(1) == right_id)
    Assert.IsTrue(bfs_order.get(2) == left_id or bfs_order.get(2) == right_id)
    Assert.AreEqual(bfs_order.get(3), leaf_id)
    
    Return true

Process called "test_topological_sort" that takes no parameters returns Boolean:
    Note: Test topological sorting of computation graph
    Let graph be Graph.create_empty_graph()
    
    Let x_id be Graph.add_node(graph, "x", 2.0, true)
    Let y_id be Graph.add_node(graph, "y", 3.0, true)
    Let mul_id be Graph.add_node(graph, "multiply", 6.0, true)
    Let add_id be Graph.add_node(graph, "add", 8.0, true)
    
    Call Graph.connect_nodes(graph, x_id, mul_id)
    Call Graph.connect_nodes(graph, y_id, mul_id)
    Call Graph.connect_nodes(graph, mul_id, add_id)
    
    Let topo_order be Graph.topological_sort(graph)
    
    Let x_index be topo_order.index_of(x_id)
    Let y_index be topo_order.index_of(y_id)
    Let mul_index be topo_order.index_of(mul_id)
    Let add_index be topo_order.index_of(add_id)
    
    Assert.IsTrue(x_index < mul_index)
    Assert.IsTrue(y_index < mul_index)
    Assert.IsTrue(mul_index < add_index)
    
    Return true

Process called "test_find_cycles_in_graph" that takes no parameters returns Boolean:
    Note: Test cycle detection in computation graph
    Let graph be Graph.create_empty_graph()
    
    Let a_id be Graph.add_node(graph, "a", 1.0, true)
    Let b_id be Graph.add_node(graph, "b", 2.0, true)
    Let c_id be Graph.add_node(graph, "c", 3.0, true)
    
    Note: Create acyclic graph first
    Call Graph.connect_nodes(graph, a_id, b_id)
    Call Graph.connect_nodes(graph, b_id, c_id)
    
    Let has_cycles_acyclic be Graph.detect_cycles(graph)
    Assert.IsFalse(has_cycles_acyclic)
    
    Note: Add cycle
    Call Graph.connect_nodes(graph, c_id, a_id)
    
    Let has_cycles_cyclic be Graph.detect_cycles(graph)
    Assert.IsTrue(has_cycles_cyclic)
    
    Return true

Note: =====================================================================
Note: GRAPH BUILDER TESTS
Note: =====================================================================

Process called "test_graph_builder_construction" that takes no parameters returns Boolean:
    Note: Test graph builder construction and initialization
    Let context_stack be Collections.CreateList[String]()
    Let variable_registry be Dictionary[String, String]
    
    Let graph_builder be Graph.GraphBuilder with:
        current_graph = Graph.create_empty_graph()
        node_counter = 0
        context_stack = context_stack
        variable_registry = variable_registry
    
    Assert.AreEqual(graph_builder.node_counter, 0)
    Assert.AreEqual(graph_builder.context_stack.length, 0)
    Assert.AreEqual(graph_builder.variable_registry.size, 0)
    Assert.AreEqual(graph_builder.current_graph.nodes.size, 0)
    
    Return true

Process called "test_graph_builder_add_operation" that takes no parameters returns Boolean:
    Note: Test adding operations through graph builder
    Let builder be Graph.GraphBuilder with:
        current_graph = Graph.create_empty_graph()
        node_counter = 0
        context_stack = Collections.CreateList[String]()
        variable_registry = Dictionary[String, String]
    
    Let inputs be Collections.CreateList[String]()
    Call inputs.append("x")
    Call inputs.append("y")
    
    Let operation_id be Graph.add_operation(builder, "add", inputs, 5.0)
    
    Assert.IsTrue(operation_id.contains("node_"))
    Assert.AreEqual(builder.node_counter, 1)
    Assert.IsTrue(builder.current_graph.nodes.has_key(operation_id))
    
    Let operation_node be builder.current_graph.nodes.get(operation_id)
    Assert.AreEqual(operation_node.operation, "add")
    Assert.AreEqual(operation_node.value, 5.0)
    
    Return true

Process called "test_graph_builder_variable_registration" that takes no parameters returns Boolean:
    Note: Test variable registration in graph builder
    Let builder be Graph.GraphBuilder with:
        current_graph = Graph.create_empty_graph()
        node_counter = 0
        context_stack = Collections.CreateList[String]()
        variable_registry = Dictionary[String, String]
    
    Let variable_name be "weight_1"
    Let variable_value be 0.5
    
    Let variable_id be Graph.register_variable(builder, variable_name, variable_value)
    
    Assert.IsTrue(builder.variable_registry.has_key(variable_name))
    Assert.AreEqual(builder.variable_registry.get(variable_name), variable_id)
    Assert.IsTrue(builder.current_graph.nodes.has_key(variable_id))
    
    Let variable_node be builder.current_graph.nodes.get(variable_id)
    Assert.AreEqual(variable_node.value, variable_value)
    
    Return true

Process called "test_graph_builder_context_management" that takes no parameters returns Boolean:
    Note: Test context stack management in graph builder
    Let builder be Graph.GraphBuilder with:
        current_graph = Graph.create_empty_graph()
        node_counter = 0
        context_stack = Collections.CreateList[String]()
        variable_registry = Dictionary[String, String]
    
    Let context_1 be "function_body"
    Let context_2 be "loop_iteration"
    
    Call Graph.push_context(builder, context_1)
    Assert.AreEqual(builder.context_stack.length, 1)
    Assert.AreEqual(builder.context_stack.get(0), context_1)
    
    Call Graph.push_context(builder, context_2)
    Assert.AreEqual(builder.context_stack.length, 2)
    Assert.AreEqual(builder.context_stack.get(1), context_2)
    
    Let popped_context be Graph.pop_context(builder)
    Assert.AreEqual(popped_context, context_2)
    Assert.AreEqual(builder.context_stack.length, 1)
    
    Return true

Note: =====================================================================
Note: GRAPH OPTIMIZATION TESTS
Note: =====================================================================

Process called "test_constant_folding_optimization" that takes no parameters returns Boolean:
    Note: Test constant folding optimization on computation graph
    Let graph be Graph.create_empty_graph()
    
    Let const1_id be Graph.add_node(graph, "constant", 3.0, false)
    Let const2_id be Graph.add_node(graph, "constant", 4.0, false)
    Let add_id be Graph.add_node(graph, "add", 0.0, false)
    
    Call Graph.connect_nodes(graph, const1_id, add_id)
    Call Graph.connect_nodes(graph, const2_id, add_id)
    
    Let optimized_graph be Graph.constant_folding_optimization(graph)
    
    Note: The add operation should be folded into a single constant node
    Assert.IsTrue(optimized_graph.nodes.size <= graph.nodes.size)
    
    Return true

Process called "test_dead_code_elimination" that takes no parameters returns Boolean:
    Note: Test dead code elimination optimization
    Let graph be Graph.create_empty_graph()
    
    Let input_id be Graph.add_node(graph, "input", 5.0, true)
    Let used_id be Graph.add_node(graph, "square", 25.0, true)
    Let unused_id be Graph.add_node(graph, "cube", 125.0, false)
    Let output_id be Graph.add_node(graph, "output", 25.0, true)
    
    Call Graph.connect_nodes(graph, input_id, used_id)
    Call Graph.connect_nodes(graph, used_id, output_id)
    Note: unused_id is not connected to the output
    
    Call graph.input_nodes.append(input_id)
    Call graph.output_nodes.append(output_id)
    
    Let optimized_graph be Graph.dead_code_elimination(graph)
    
    Assert.IsTrue(optimized_graph.nodes.has_key(input_id))
    Assert.IsTrue(optimized_graph.nodes.has_key(used_id))
    Assert.IsTrue(optimized_graph.nodes.has_key(output_id))
    Assert.IsFalse(optimized_graph.nodes.has_key(unused_id))
    
    Return true

Process called "test_common_subexpression_elimination" that takes no parameters returns Boolean:
    Note: Test common subexpression elimination optimization
    Let graph be Graph.create_empty_graph()
    
    Let x_id be Graph.add_node(graph, "input", 3.0, true)
    Let square1_id be Graph.add_node(graph, "square", 9.0, true)
    Let square2_id be Graph.add_node(graph, "square", 9.0, true)  Note: duplicate computation
    Let sum_id be Graph.add_node(graph, "add", 18.0, true)
    
    Call Graph.connect_nodes(graph, x_id, square1_id)
    Call Graph.connect_nodes(graph, x_id, square2_id)
    Call Graph.connect_nodes(graph, square1_id, sum_id)
    Call Graph.connect_nodes(graph, square2_id, sum_id)
    
    Let optimized_graph be Graph.common_subexpression_elimination(graph)
    
    Note: One of the square operations should be eliminated
    Assert.IsTrue(optimized_graph.nodes.size < graph.nodes.size)
    
    Return true

Note: =====================================================================
Note: DYNAMIC GRAPH TESTS
Note: =====================================================================

Process called "test_dynamic_graph_construction" that takes no parameters returns Boolean:
    Note: Test dynamic graph construction and modification
    Let dynamic_graph be Graph.create_dynamic_graph()
    
    Assert.IsFalse(dynamic_graph.is_static)
    Assert.AreEqual(dynamic_graph.nodes.size, 0)
    
    Let node_id be Graph.add_node_dynamic(dynamic_graph, "add", 0.0, true)
    
    Assert.AreEqual(dynamic_graph.nodes.size, 1)
    Assert.IsTrue(dynamic_graph.nodes.has_key(node_id))
    
    Return true

Process called "test_dynamic_graph_modification" that takes no parameters returns Boolean:
    Note: Test runtime modification of dynamic graphs
    Let dynamic_graph be Graph.create_dynamic_graph()
    
    Let node_id be Graph.add_node_dynamic(dynamic_graph, "multiply", 6.0, true)
    
    Note: Modify node value at runtime
    Let modification_success be Graph.modify_node_value(dynamic_graph, node_id, 12.0)
    Assert.IsTrue(modification_success)
    
    Let modified_node be dynamic_graph.nodes.get(node_id)
    Assert.AreEqual(modified_node.value, 12.0)
    
    Note: Modify node operation at runtime
    Let operation_change_success be Graph.modify_node_operation(dynamic_graph, node_id, "divide")
    Assert.IsTrue(operation_change_success)
    
    Let updated_node be dynamic_graph.nodes.get(node_id)
    Assert.AreEqual(updated_node.operation, "divide")
    
    Return true

Process called "test_dynamic_graph_edge_modification" that takes no parameters returns Boolean:
    Note: Test runtime modification of edges in dynamic graphs
    Let dynamic_graph be Graph.create_dynamic_graph()
    
    Let source_id be Graph.add_node_dynamic(dynamic_graph, "input", 5.0, true)
    Let target_id be Graph.add_node_dynamic(dynamic_graph, "output", 10.0, true)
    
    Call Graph.add_edge(dynamic_graph, source_id, target_id, 1.0, "data_flow")
    Assert.AreEqual(dynamic_graph.edges.length, 1)
    
    Note: Remove edge dynamically
    Let removal_success be Graph.remove_edge_dynamic(dynamic_graph, source_id, target_id)
    Assert.IsTrue(removal_success)
    Assert.AreEqual(dynamic_graph.edges.length, 0)
    
    Note: Add edge with different weight
    Call Graph.add_edge(dynamic_graph, source_id, target_id, 2.5, "control_flow")
    Assert.AreEqual(dynamic_graph.edges.length, 1)
    
    Let new_edge be dynamic_graph.edges.get(0)
    Assert.AreEqual(new_edge.weight, 2.5)
    Assert.AreEqual(new_edge.edge_type, "control_flow")
    
    Return true

Note: =====================================================================
Note: GRAPH ANALYSIS TESTS
Note: =====================================================================

Process called "test_graph_complexity_analysis" that takes no parameters returns Boolean:
    Note: Test computation graph complexity analysis
    Let graph be Graph.create_empty_graph()
    
    Note: Create a moderately complex graph
    Let i be 0
    While i < 10:
        Call Graph.add_node(graph, "operation_" + String(i), Float(i), true)
        Set i to i + 1
    
    Note: Add some edges to create dependencies
    Let j be 0
    While j < 5:
        Call Graph.add_edge(graph, "node_" + String(j), "node_" + String(j + 5), 1.0, "data_flow")
        Set j to j + 1
    
    Let complexity_metrics be Graph.analyze_graph_complexity(graph)
    
    Assert.IsTrue(complexity_metrics.has_key("node_count"))
    Assert.IsTrue(complexity_metrics.has_key("edge_count"))
    Assert.IsTrue(complexity_metrics.has_key("depth"))
    Assert.IsTrue(complexity_metrics.has_key("branching_factor"))
    
    Assert.AreEqual(complexity_metrics.get("node_count"), 10)
    
    Return true

Process called "test_graph_memory_usage_estimation" that takes no parameters returns Boolean:
    Note: Test memory usage estimation for computation graphs
    Let graph be Graph.create_empty_graph()
    
    Let large_node_id be Graph.add_node(graph, "large_tensor", 1000.0, true)
    Let small_node_id be Graph.add_node(graph, "scalar", 5.0, true)
    
    Let large_node be graph.nodes.get(large_node_id)
    Call large_node.metadata.set("tensor_size", 1000000)  Note: 1M elements
    
    Let small_node be graph.nodes.get(small_node_id)
    Call small_node.metadata.set("tensor_size", 1)  Note: scalar
    
    Let memory_estimate be Graph.estimate_memory_usage(graph)
    
    Assert.IsTrue(memory_estimate > 1000000)  Note: Should account for large tensor
    
    Return true

Process called "test_graph_execution_path_analysis" that takes no parameters returns Boolean:
    Note: Test execution path analysis for computation graphs
    Let graph be Graph.create_empty_graph()
    
    Let input_id be Graph.add_node(graph, "input", 1.0, true)
    Let branch1_id be Graph.add_node(graph, "branch1", 2.0, true)
    Let branch2_id be Graph.add_node(graph, "branch2", 3.0, true)
    Let merge_id be Graph.add_node(graph, "merge", 5.0, true)
    
    Call Graph.connect_nodes(graph, input_id, branch1_id)
    Call Graph.connect_nodes(graph, input_id, branch2_id)
    Call Graph.connect_nodes(graph, branch1_id, merge_id)
    Call Graph.connect_nodes(graph, branch2_id, merge_id)
    
    Call graph.input_nodes.append(input_id)
    Call graph.output_nodes.append(merge_id)
    
    Let execution_paths be Graph.analyze_execution_paths(graph)
    
    Assert.IsTrue(execution_paths.has_key("total_paths"))
    Assert.IsTrue(execution_paths.has_key("critical_path_length"))
    Assert.IsTrue(execution_paths.has_key("parallel_opportunities"))
    
    Return true

Note: =====================================================================
Note: ERROR HANDLING AND VALIDATION TESTS
Note: =====================================================================

Process called "test_graph_validation" that takes no parameters returns Boolean:
    Note: Test computation graph validation for structural correctness
    Let graph be Graph.create_empty_graph()
    
    Let valid_node_id be Graph.add_node(graph, "valid_op", 5.0, true)
    Call graph.input_nodes.append(valid_node_id)
    Call graph.output_nodes.append(valid_node_id)
    
    Let validation_result be Graph.validate_graph(graph)
    
    Assert.IsTrue(validation_result.has_key("is_valid"))
    Assert.IsTrue(validation_result.has_key("validation_errors"))
    Assert.IsTrue(validation_result.has_key("warnings"))
    
    Assert.IsTrue(validation_result.get("is_valid"))
    Assert.AreEqual(validation_result.get("validation_errors").length, 0)
    
    Return true

Process called "test_invalid_graph_detection" that takes no parameters returns Boolean:
    Note: Test detection of invalid graph structures
    Let invalid_graph be Graph.create_empty_graph()
    
    Note: Create graph with missing input nodes
    Let orphan_node_id be Graph.add_node(invalid_graph, "orphan", 10.0, true)
    Call invalid_graph.output_nodes.append(orphan_node_id)
    Note: No input nodes specified
    
    Let validation_result be Graph.validate_graph(invalid_graph)
    
    Assert.IsFalse(validation_result.get("is_valid"))
    Assert.IsTrue(validation_result.get("validation_errors").length > 0)
    
    Return true

Process called "test_graph_node_reference_validation" that takes no parameters returns Boolean:
    Note: Test validation of node references in edges
    Let graph be Graph.create_empty_graph()
    
    Let valid_node_id be Graph.add_node(graph, "valid", 1.0, true)
    
    Note: Try to create edge with non-existent target
    Let invalid_edge_added be Graph.add_edge(graph, valid_node_id, "non_existent_node", 1.0, "data_flow")
    
    Assert.IsFalse(invalid_edge_added)
    Assert.AreEqual(graph.edges.length, 0)
    
    Return true

Note: =====================================================================
Note: PERFORMANCE TESTS
Note: =====================================================================

Process called "test_large_graph_construction_performance" that takes no parameters returns Boolean:
    Note: Test performance of constructing large computation graphs
    Let large_graph be Graph.create_empty_graph()
    
    Let start_time be DateTime.GetCurrentTimestamp()
    
    Note: Create a large graph with many nodes
    Let node_ids be Collections.CreateList[String]()
    Let i be 0
    While i < 1000:
        Let node_id be Graph.add_node(large_graph, "op_" + String(i), Float(i), true)
        Call node_ids.append(node_id)
        Set i to i + 1
    
    Note: Add edges to create a chain
    Let j be 0
    While j < 999:
        Call Graph.add_edge(large_graph, node_ids.get(j), node_ids.get(j + 1), 1.0, "data_flow")
        Set j to j + 1
    
    Let end_time be DateTime.GetCurrentTimestamp()
    Let construction_time be end_time - start_time
    
    Assert.AreEqual(large_graph.nodes.size, 1000)
    Assert.AreEqual(large_graph.edges.length, 999)
    Assert.IsTrue(construction_time >= 0.0)  Note: Should complete in reasonable time
    
    Return true

Process called "test_graph_traversal_performance" that takes no parameters returns Boolean:
    Note: Test performance of graph traversal algorithms
    Let graph be Graph.create_empty_graph()
    
    Note: Create a moderately sized graph for traversal testing
    Let root_id be Graph.add_node(graph, "root", 0.0, true)
    Let node_ids be Collections.CreateList[String]()
    Call node_ids.append(root_id)
    
    Let level be 1
    While level <= 5:  Note: Create 5 levels
        Let nodes_in_level be 2  Note: Binary tree structure
        Let i be 0
        While i < nodes_in_level:
            Let node_id be Graph.add_node(graph, "level_" + String(level) + "_node_" + String(i), Float(level), true)
            Call node_ids.append(node_id)
            Set i to i + 1
        Set level to level + 1
    
    Let traversal_start be DateTime.GetCurrentTimestamp()
    Let dfs_result be Graph.depth_first_traversal(graph, root_id)
    Let traversal_end be DateTime.GetCurrentTimestamp()
    
    Let traversal_time be traversal_end - traversal_start
    
    Assert.IsTrue(dfs_result.length > 0)
    Assert.IsTrue(traversal_time >= 0.0)
    
    Return true

Note: =====================================================================
Note: TEST RUNNER PROCESS
Note: =====================================================================

Process called "run_graph_tests" that takes no parameters returns Boolean:
    Note: Run all computation graph tests
    Let test_results be Collections.CreateList[Boolean]()
    Let test_names be Collections.CreateList[String]()
    
    Note: Graph node and edge construction tests
    Call test_names.append("Graph Node Construction")
    Call test_results.append(test_graph_node_construction())
    
    Call test_names.append("Graph Edge Construction")
    Call test_results.append(test_graph_edge_construction())
    
    Call test_names.append("Computation Graph Construction")
    Call test_results.append(test_computation_graph_construction())
    
    Note: Graph construction operations
    Call test_names.append("Create Empty Graph")
    Call test_results.append(test_create_empty_graph())
    
    Call test_names.append("Add Node to Graph")
    Call test_results.append(test_add_node_to_graph())
    
    Call test_names.append("Add Multiple Nodes")
    Call test_results.append(test_add_multiple_nodes())
    
    Call test_names.append("Add Edge to Graph")
    Call test_results.append(test_add_edge_to_graph())
    
    Call test_names.append("Connect Nodes with Dependencies")
    Call test_results.append(test_connect_nodes_with_dependencies())
    
    Note: Graph traversal tests
    Call test_names.append("Depth First Traversal")
    Call test_results.append(test_depth_first_traversal())
    
    Call test_names.append("Breadth First Traversal")
    Call test_results.append(test_breadth_first_traversal())
    
    Call test_names.append("Topological Sort")
    Call test_results.append(test_topological_sort())
    
    Call test_names.append("Find Cycles in Graph")
    Call test_results.append(test_find_cycles_in_graph())
    
    Note: Graph builder tests
    Call test_names.append("Graph Builder Construction")
    Call test_results.append(test_graph_builder_construction())
    
    Call test_names.append("Graph Builder Add Operation")
    Call test_results.append(test_graph_builder_add_operation())
    
    Call test_names.append("Graph Builder Variable Registration")
    Call test_results.append(test_graph_builder_variable_registration())
    
    Call test_names.append("Graph Builder Context Management")
    Call test_results.append(test_graph_builder_context_management())
    
    Note: Graph optimization tests
    Call test_names.append("Constant Folding Optimization")
    Call test_results.append(test_constant_folding_optimization())
    
    Call test_names.append("Dead Code Elimination")
    Call test_results.append(test_dead_code_elimination())
    
    Call test_names.append("Common Subexpression Elimination")
    Call test_results.append(test_common_subexpression_elimination())
    
    Note: Dynamic graph tests
    Call test_names.append("Dynamic Graph Construction")
    Call test_results.append(test_dynamic_graph_construction())
    
    Call test_names.append("Dynamic Graph Modification")
    Call test_results.append(test_dynamic_graph_modification())
    
    Call test_names.append("Dynamic Graph Edge Modification")
    Call test_results.append(test_dynamic_graph_edge_modification())
    
    Note: Graph analysis tests
    Call test_names.append("Graph Complexity Analysis")
    Call test_results.append(test_graph_complexity_analysis())
    
    Call test_names.append("Graph Memory Usage Estimation")
    Call test_results.append(test_graph_memory_usage_estimation())
    
    Call test_names.append("Graph Execution Path Analysis")
    Call test_results.append(test_graph_execution_path_analysis())
    
    Note: Error handling tests
    Call test_names.append("Graph Validation")
    Call test_results.append(test_graph_validation())
    
    Call test_names.append("Invalid Graph Detection")
    Call test_results.append(test_invalid_graph_detection())
    
    Call test_names.append("Graph Node Reference Validation")
    Call test_results.append(test_graph_node_reference_validation())
    
    Note: Performance tests
    Call test_names.append("Large Graph Construction Performance")
    Call test_results.append(test_large_graph_construction_performance())
    
    Call test_names.append("Graph Traversal Performance")
    Call test_results.append(test_graph_traversal_performance())
    
    Note: Report test results
    Let total_tests be test_results.length
    Let passed_tests be 0
    Let failed_tests be 0
    
    Let i be 0
    While i < total_tests:
        If test_results.get(i):
            Set passed_tests to passed_tests + 1
        Otherwise:
            Set failed_tests to failed_tests + 1
            Assert.LogMessage("FAILED: " + test_names.get(i))
        Set i to i + 1
    
    Assert.LogMessage("Graph Test Results:")
    Assert.LogMessage("Total Tests: " + String(total_tests))
    Assert.LogMessage("Passed: " + String(passed_tests))
    Assert.LogMessage("Failed: " + String(failed_tests))
    
    If failed_tests == 0:
        Assert.LogMessage("All computation graph tests PASSED!")
        Return true
    Otherwise:
        Assert.LogMessage("Some computation graph tests FAILED!")
        Return false