Note:
Unit tests for higher-order derivatives and Hessian computation.
Tests Hessian matrix computation, higher-order tensor derivatives, mixed partials,
Hessian-vector products, and Taylor series methods.
:End Note

Import "math/engine/autodiff/higher_order" as HigherOrder
Import "dev/debug/testing/assertion_engine" as Assert
Import "collections" as Collections

Note: =====================================================================
Note: HESSIAN RESULT STRUCTURE TESTS
Note: =====================================================================

Process called "test_hessian_result_construction" that takes no parameters returns Boolean:
    Note: Test Hessian result structure construction and properties
    Let hessian_matrix be Collections.CreateList[Collections.CreateList[Float]]()
    Let row1 be Collections.CreateList[Float]()
    Call row1.append(2.0)
    Call row1.append(1.0)
    Call hessian_matrix.append(row1)
    
    Let row2 be Collections.CreateList[Float]()
    Call row2.append(1.0)
    Call row2.append(4.0)
    Call hessian_matrix.append(row2)
    
    Let eigenvalues be Collections.CreateList[Float]()
    Call eigenvalues.append(1.5)
    Call eigenvalues.append(4.5)
    
    Let sparsity_pattern be Collections.CreateList[Collections.CreateList[Boolean]]()
    Let sparse_row1 be Collections.CreateList[Boolean]()
    Call sparse_row1.append(true)
    Call sparse_row1.append(false)
    Call sparsity_pattern.append(sparse_row1)
    
    Let sparse_row2 be Collections.CreateList[Boolean]()
    Call sparse_row2.append(false)
    Call sparse_row2.append(true)
    Call sparsity_pattern.append(sparse_row2)
    
    Let hessian_result be HigherOrder.HessianResult with:
        hessian_matrix = hessian_matrix
        eigenvalues = eigenvalues
        condition_number = 3.0
        is_positive_definite = true
        sparsity_pattern = sparsity_pattern
        computation_method = "forward_over_reverse"
    
    Assert.AreEqual(hessian_result.hessian_matrix.length, 2)
    Assert.AreEqual(hessian_result.hessian_matrix.get(0).get(0), 2.0)
    Assert.AreEqual(hessian_result.hessian_matrix.get(1).get(1), 4.0)
    Assert.AreEqual(hessian_result.eigenvalues.length, 2)
    Assert.AreEqual(hessian_result.condition_number, 3.0)
    Assert.IsTrue(hessian_result.is_positive_definite)
    Assert.AreEqual(hessian_result.computation_method, "forward_over_reverse")
    
    Return true

Process called "test_jet_number_construction" that takes no parameters returns Boolean:
    Note: Test jet number construction for Taylor series coefficients
    Let coefficients be Collections.CreateList[Float]()
    Call coefficients.append(1.0)    Note: 0th order coefficient
    Call coefficients.append(2.0)    Note: 1st order coefficient  
    Call coefficients.append(1.5)    Note: 2nd order coefficient
    Call coefficients.append(0.25)   Note: 3rd order coefficient
    
    Let jet_number be HigherOrder.JetNumber with:
        coefficients = coefficients
        order = 3
        variable_index = 0
    
    Assert.AreEqual(jet_number.coefficients.length, 4)
    Assert.AreEqual(jet_number.coefficients.get(0), 1.0)
    Assert.AreEqual(jet_number.coefficients.get(3), 0.25)
    Assert.AreEqual(jet_number.order, 3)
    Assert.AreEqual(jet_number.variable_index, 0)
    
    Return true

Process called "test_hyperdual_number_construction" that takes no parameters returns Boolean:
    Note: Test hyperdual number construction for second derivatives
    Let hyperdual be HigherOrder.HyperDualNumber with:
        f = 12.0
        f_x = 6.0
        f_y = 4.0
        f_xx = 2.0
        f_yy = 0.0
        f_xy = 1.0
    
    Assert.AreEqual(hyperdual.f, 12.0)
    Assert.AreEqual(hyperdual.f_x, 6.0)
    Assert.AreEqual(hyperdual.f_y, 4.0)
    Assert.AreEqual(hyperdual.f_xx, 2.0)
    Assert.AreEqual(hyperdual.f_yy, 0.0)
    Assert.AreEqual(hyperdual.f_xy, 1.0)
    
    Return true

Process called "test_tensor_derivative_construction" that takes no parameters returns Boolean:
    Note: Test tensor derivative structure for higher-order derivatives
    Let derivative_values be Collections.CreateList[Float]()
    Call derivative_values.append(1.0)
    Call derivative_values.append(2.0)
    Call derivative_values.append(3.0)
    Call derivative_values.append(4.0)
    
    Let tensor_shape be Collections.CreateList[Integer]()
    Call tensor_shape.append(2)
    Call tensor_shape.append(2)
    
    Let derivative_orders be Collections.CreateList[Integer]()
    Call derivative_orders.append(1)  Note: First derivative wrt first variable
    Call derivative_orders.append(1)  Note: First derivative wrt second variable
    
    Let symmetries be Collections.CreateList[Collections.CreateList[Integer]]()
    Let symmetry_group be Collections.CreateList[Integer]()
    Call symmetry_group.append(0)
    Call symmetry_group.append(1)
    Call symmetries.append(symmetry_group)
    
    Let tensor_derivative be HigherOrder.TensorDerivative with:
        values = derivative_values
        shape = tensor_shape
        order = derivative_orders
        symmetries = symmetries
    
    Assert.AreEqual(tensor_derivative.values.length, 4)
    Assert.AreEqual(tensor_derivative.shape.get(0), 2)
    Assert.AreEqual(tensor_derivative.shape.get(1), 2)
    Assert.AreEqual(tensor_derivative.order.length, 2)
    Assert.AreEqual(tensor_derivative.symmetries.length, 1)
    
    Return true

Note: =====================================================================
Note: HESSIAN COMPUTATION TESTS
Note: =====================================================================

Process called "test_forward_over_reverse_hessian" that takes no parameters returns Boolean:
    Note: Test forward-over-reverse Hessian computation
    Let function be "x^2 + x*y + y^2"
    
    Let variables be Collections.CreateList[String]()
    Call variables.append("x")
    Call variables.append("y")
    
    Let point be Collections.CreateList[Float]()
    Call point.append(1.0)
    Call point.append(2.0)
    
    Let hessian_result be HigherOrder.forward_over_reverse_hessian(function, variables, point)
    
    Assert.AreEqual(hessian_result.computation_method, "forward_over_reverse")
    Assert.AreEqual(hessian_result.hessian_matrix.length, 2)
    Assert.AreEqual(hessian_result.hessian_matrix.get(0).length, 2)
    
    Note: For f(x,y) = x² + xy + y², Hessian should be [[2, 1], [1, 2]]
    Assert.AreEqual(hessian_result.hessian_matrix.get(0).get(0), 2.0)
    Assert.AreEqual(hessian_result.hessian_matrix.get(0).get(1), 1.0)
    Assert.AreEqual(hessian_result.hessian_matrix.get(1).get(0), 1.0)
    Assert.AreEqual(hessian_result.hessian_matrix.get(1).get(1), 2.0)
    
    Assert.IsTrue(hessian_result.is_positive_definite)
    Assert.IsTrue(hessian_result.condition_number > 1.0)
    
    Return true

Process called "test_reverse_over_forward_hessian" that takes no parameters returns Boolean:
    Note: Test reverse-over-forward Hessian computation
    Let function be "x^3 + y^3 + x*y"
    
    Let variables be Collections.CreateList[String]()
    Call variables.append("x")
    Call variables.append("y")
    
    Let point be Collections.CreateList[Float]()
    Call point.append(1.0)
    Call point.append(1.0)
    
    Let hessian_result be HigherOrder.reverse_over_forward_hessian(function, variables, point)
    
    Assert.AreEqual(hessian_result.computation_method, "reverse_over_forward")
    Assert.AreEqual(hessian_result.hessian_matrix.length, 2)
    
    Note: For f(x,y) = x³ + y³ + xy, Hessian at (1,1) should be [[6, 1], [1, 6]]
    Assert.AreEqual(hessian_result.hessian_matrix.get(0).get(0), 6.0)
    Assert.AreEqual(hessian_result.hessian_matrix.get(0).get(1), 1.0)
    Assert.AreEqual(hessian_result.hessian_matrix.get(1).get(0), 1.0)
    Assert.AreEqual(hessian_result.hessian_matrix.get(1).get(1), 6.0)
    
    Return true

Process called "test_sparse_hessian_computation" that takes no parameters returns Boolean:
    Note: Test sparse Hessian computation for functions with sparse second derivatives
    Let function be "x1^2 + x3^2"  Note: No coupling between variables
    
    Let variables be Collections.CreateList[String]()
    Call variables.append("x1")
    Call variables.append("x2")
    Call variables.append("x3")
    
    Let point be Collections.CreateList[Float]()
    Call point.append(1.0)
    Call point.append(0.0)
    Call point.append(2.0)
    
    Let sparse_hessian be HigherOrder.compute_sparse_hessian(function, variables, point)
    
    Assert.AreEqual(sparse_hessian.hessian_matrix.length, 3)
    Assert.AreEqual(sparse_hessian.hessian_matrix.get(0).get(0), 2.0)  Note: d²f/dx1²
    Assert.AreEqual(sparse_hessian.hessian_matrix.get(1).get(1), 0.0)  Note: x2 doesn't appear
    Assert.AreEqual(sparse_hessian.hessian_matrix.get(2).get(2), 2.0)  Note: d²f/dx3²
    Assert.AreEqual(sparse_hessian.hessian_matrix.get(0).get(1), 0.0)  Note: no coupling
    
    Note: Check sparsity pattern
    Assert.IsTrue(sparse_hessian.sparsity_pattern.get(0).get(0))  Note: (0,0) is non-zero
    Assert.IsFalse(sparse_hessian.sparsity_pattern.get(0).get(1))  Note: (0,1) is zero
    Assert.IsFalse(sparse_hessian.sparsity_pattern.get(1).get(2))  Note: (1,2) is zero
    Assert.IsTrue(sparse_hessian.sparsity_pattern.get(2).get(2))  Note: (2,2) is non-zero
    
    Return true

Process called "test_hessian_eigenvalue_analysis" that takes no parameters returns Boolean:
    Note: Test Hessian eigenvalue computation and analysis
    Let hessian_matrix be Collections.CreateList[Collections.CreateList[Float]]()
    Let row1 be Collections.CreateList[Float]()
    Call row1.append(3.0)
    Call row1.append(1.0)
    Call hessian_matrix.append(row1)
    
    Let row2 be Collections.CreateList[Float]()
    Call row2.append(1.0)
    Call row2.append(3.0)
    Call hessian_matrix.append(row2)
    
    Let eigenvalue_analysis be HigherOrder.analyze_hessian_eigenvalues(hessian_matrix)
    
    Assert.IsTrue(eigenvalue_analysis.has_key("eigenvalues"))
    Assert.IsTrue(eigenvalue_analysis.has_key("condition_number"))
    Assert.IsTrue(eigenvalue_analysis.has_key("is_positive_definite"))
    Assert.IsTrue(eigenvalue_analysis.has_key("determinant"))
    Assert.IsTrue(eigenvalue_analysis.has_key("trace"))
    
    Let eigenvalues be eigenvalue_analysis.get("eigenvalues")
    Assert.AreEqual(eigenvalues.length, 2)
    
    Note: For [[3,1],[1,3]], eigenvalues should be 2 and 4
    Assert.IsTrue(eigenvalues.contains(2.0) or MathCore.abs(eigenvalues.get(0) - 2.0) < 0.001)
    Assert.IsTrue(eigenvalues.contains(4.0) or MathCore.abs(eigenvalues.get(1) - 4.0) < 0.001)
    
    Assert.IsTrue(eigenvalue_analysis.get("is_positive_definite"))
    Assert.AreEqual(eigenvalue_analysis.get("trace"), 6.0)
    Assert.AreEqual(eigenvalue_analysis.get("determinant"), 8.0)
    
    Return true

Note: =====================================================================
Note: HESSIAN-VECTOR PRODUCT TESTS
Note: =====================================================================

Process called "test_hessian_vector_product" that takes no parameters returns Boolean:
    Note: Test efficient Hessian-vector product computation
    Let function be "x^2 + 2*x*y + y^2"
    
    Let variables be Collections.CreateList[String]()
    Call variables.append("x")
    Call variables.append("y")
    
    Let point be Collections.CreateList[Float]()
    Call point.append(1.0)
    Call point.append(1.0)
    
    Let vector be Collections.CreateList[Float]()
    Call vector.append(1.0)
    Call vector.append(-1.0)
    
    Let hvp_result be HigherOrder.compute_hessian_vector_product(function, variables, point, vector)
    
    Assert.AreEqual(hvp_result.length, 2)
    
    Note: For f(x,y) = x² + 2xy + y², Hessian is [[2, 2], [2, 2]]
    Note: Hv = [[2, 2], [2, 2]] * [1, -1] = [0, 0]
    Assert.AreEqual(hvp_result.get(0), 0.0)
    Assert.AreEqual(hvp_result.get(1), 0.0)
    
    Return true

Process called "test_vector_hessian_vector_product" that takes no parameters returns Boolean:
    Note: Test vector-Hessian-vector product (quadratic form)
    Let function be "x^2 + y^2"
    
    Let variables be Collections.CreateList[String]()
    Call variables.append("x")
    Call variables.append("y")
    
    Let point be Collections.CreateList[Float]()
    Call point.append(2.0)
    Call point.append(3.0)
    
    Let vector be Collections.CreateList[Float]()
    Call vector.append(1.0)
    Call vector.append(1.0)
    
    Let vhv_result be HigherOrder.compute_vector_hessian_vector_product(function, variables, point, vector)
    
    Note: For f(x,y) = x² + y², Hessian is [[2, 0], [0, 2]]
    Note: v^T H v = [1, 1] * [[2, 0], [0, 2]] * [1, 1] = [1, 1] * [2, 2] = 4
    Assert.AreEqual(vhv_result, 4.0)
    
    Return true

Process called "test_multiple_hessian_vector_products" that takes no parameters returns Boolean:
    Note: Test computation of multiple Hessian-vector products efficiently
    Let function be "x^3 + x*y + y^3"
    
    Let variables be Collections.CreateList[String]()
    Call variables.append("x")
    Call variables.append("y")
    
    Let point be Collections.CreateList[Float]()
    Call point.append(1.0)
    Call point.append(1.0)
    
    Let vectors be Collections.CreateList[Collections.CreateList[Float]]()
    
    Let vector1 be Collections.CreateList[Float]()
    Call vector1.append(1.0)
    Call vector1.append(0.0)
    Call vectors.append(vector1)
    
    Let vector2 be Collections.CreateList[Float]()
    Call vector2.append(0.0)
    Call vector2.append(1.0)
    Call vectors.append(vector2)
    
    Let vector3 be Collections.CreateList[Float]()
    Call vector3.append(1.0)
    Call vector3.append(1.0)
    Call vectors.append(vector3)
    
    Let multiple_hvp_results be HigherOrder.compute_multiple_hessian_vector_products(function, variables, point, vectors)
    
    Assert.AreEqual(multiple_hvp_results.length, 3)
    
    Note: For f(x,y) = x³ + xy + y³, Hessian at (1,1) is [[6, 1], [1, 6]]
    Note: H * [1, 0] = [6, 1]
    Assert.AreEqual(multiple_hvp_results.get(0).get(0), 6.0)
    Assert.AreEqual(multiple_hvp_results.get(0).get(1), 1.0)
    
    Note: H * [0, 1] = [1, 6]
    Assert.AreEqual(multiple_hvp_results.get(1).get(0), 1.0)
    Assert.AreEqual(multiple_hvp_results.get(1).get(1), 6.0)
    
    Note: H * [1, 1] = [7, 7]
    Assert.AreEqual(multiple_hvp_results.get(2).get(0), 7.0)
    Assert.AreEqual(multiple_hvp_results.get(2).get(1), 7.0)
    
    Return true

Note: =====================================================================
Note: JET TRANSPORT AND TAYLOR SERIES TESTS
Note: =====================================================================

Process called "test_jet_transport_computation" that takes no parameters returns Boolean:
    Note: Test jet transport method for higher-order derivatives
    Let function be "sin(x) + cos(y)"
    
    Let variables be Collections.CreateList[String]()
    Call variables.append("x")
    Call variables.append("y")
    
    Let center_point be Collections.CreateList[Float]()
    Call center_point.append(0.0)
    Call center_point.append(0.0)
    
    Let expansion_order be 3
    
    Let jet_result be HigherOrder.compute_jet_transport(function, variables, center_point, expansion_order)
    
    Assert.IsTrue(jet_result.has_key("taylor_coefficients"))
    Assert.IsTrue(jet_result.has_key("expansion_order"))
    Assert.IsTrue(jet_result.has_key("convergence_radius"))
    
    Let coefficients be jet_result.get("taylor_coefficients")
    
    Note: For sin(x) + cos(y) at (0,0):
    Note: f(0,0) = sin(0) + cos(0) = 0 + 1 = 1
    Assert.IsTrue(coefficients.has_key("constant_term"))
    Assert.AreEqual(coefficients.get("constant_term"), 1.0)
    
    Note: df/dx at (0,0) = cos(0) = 1, df/dy at (0,0) = -sin(0) = 0
    Assert.IsTrue(coefficients.has_key("first_order_x"))
    Assert.AreEqual(coefficients.get("first_order_x"), 1.0)
    Assert.AreEqual(coefficients.get("first_order_y"), 0.0)
    
    Return true

Process called "test_taylor_series_evaluation" that takes no parameters returns Boolean:
    Note: Test evaluation of Taylor series at specific points
    Let coefficients be Dictionary[String, Float]
    Call coefficients.set("constant", 1.0)
    Call coefficients.set("linear_x", 2.0)
    Call coefficients.set("linear_y", 1.0)
    Call coefficients.set("quadratic_xx", 0.5)
    Call coefficients.set("quadratic_yy", 0.5)
    Call coefficients.set("quadratic_xy", 1.0)
    
    Let evaluation_point be Collections.CreateList[Float]()
    Call evaluation_point.append(0.1)
    Call evaluation_point.append(0.2)
    
    Let taylor_value be HigherOrder.evaluate_taylor_series(coefficients, evaluation_point)
    
    Note: f(0.1, 0.2) = 1 + 2*0.1 + 1*0.2 + 0.5*0.1² + 0.5*0.2² + 1*0.1*0.2
    Note: = 1 + 0.2 + 0.2 + 0.005 + 0.02 + 0.02 = 1.445
    Assert.IsTrue(MathCore.abs(taylor_value - 1.445) < 0.001)
    
    Return true

Process called "test_taylor_series_composition" that takes no parameters returns Boolean:
    Note: Test composition of Taylor series
    Let series_f_coeffs be Dictionary[String, Float]
    Call series_f_coeffs.set("constant", 0.0)
    Call series_f_coeffs.set("linear", 1.0)
    Call series_f_coeffs.set("quadratic", 0.5)
    
    Let series_g_coeffs be Dictionary[String, Float]
    Call series_g_coeffs.set("constant", 1.0)
    Call series_g_coeffs.set("linear", 2.0)
    
    Let composed_series be HigherOrder.compose_taylor_series(series_f_coeffs, series_g_coeffs, 2)
    
    Assert.IsTrue(composed_series.has_key("constant"))
    Assert.IsTrue(composed_series.has_key("linear"))
    Assert.IsTrue(composed_series.has_key("quadratic"))
    
    Note: If f(x) = x + 0.5x² and g(x) = 1 + 2x, then f(g(x)) should be computed
    Assert.IsTrue(composed_series.get("constant") >= 0.0)
    
    Return true

Note: =====================================================================
Note: MIXED PARTIAL DERIVATIVE TESTS
Note: =====================================================================

Process called "test_mixed_partial_derivatives" that takes no parameters returns Boolean:
    Note: Test computation of mixed partial derivatives
    Let function be "x^2 * y^3 + x * y"
    
    Let variables be Collections.CreateList[String]()
    Call variables.append("x")
    Call variables.append("y")
    
    Let point be Collections.CreateList[Float]()
    Call point.append(2.0)
    Call point.append(3.0)
    
    Let derivative_orders be Collections.CreateList[Integer]()
    Call derivative_orders.append(1)  Note: First derivative wrt x
    Call derivative_orders.append(2)  Note: Second derivative wrt y
    
    Let mixed_partial be HigherOrder.compute_mixed_partial_derivative(function, variables, point, derivative_orders)
    
    Note: f(x,y) = x²y³ + xy
    Note: d³f/dx dy² = d/dy²(d/dx(x²y³ + xy)) = d/dy²(2xy³ + y) = d/dy(6xy²) = 12xy
    Note: At (2,3): 12 * 2 * 3 = 72
    Assert.AreEqual(mixed_partial, 72.0)
    
    Return true

Process called "test_symmetric_mixed_partials" that takes no parameters returns Boolean:
    Note: Test symmetry of mixed partial derivatives (Clairaut's theorem)
    Let function be "x^3 * y^2 + 2*x*y"
    
    Let variables be Collections.CreateList[String]()
    Call variables.append("x")
    Call variables.append("y")
    
    Let point be Collections.CreateList[Float]()
    Call point.append(1.0)
    Call point.append(2.0)
    
    Note: Compute d²f/dxdy
    Let orders_xy be Collections.CreateList[Integer]()
    Call orders_xy.append(1)
    Call orders_xy.append(1)
    Let partial_xy be HigherOrder.compute_mixed_partial_derivative(function, variables, point, orders_xy)
    
    Note: Compute d²f/dydx (should be equal by Clairaut's theorem)
    Let orders_yx be Collections.CreateList[Integer]()
    Call orders_yx.append(1)
    Call orders_yx.append(1)
    Let partial_yx be HigherOrder.compute_mixed_partial_derivative(function, variables, point, orders_yx)
    
    Assert.AreEqual(partial_xy, partial_yx)
    
    Note: For f(x,y) = x³y² + 2xy, d²f/dxdy = 6x²y + 2
    Note: At (1,2): 6*1*2 + 2 = 14
    Assert.AreEqual(partial_xy, 14.0)
    
    Return true

Note: =====================================================================
Note: HIGHER-ORDER TENSOR DERIVATIVES TESTS
Note: =====================================================================

Process called "test_third_order_derivatives" that takes no parameters returns Boolean:
    Note: Test third-order derivative computation
    Let function be "x^4 + y^4 + x*y^2"
    
    Let variables be Collections.CreateList[String]()
    Call variables.append("x")
    Call variables.append("y")
    
    Let point be Collections.CreateList[Float]()
    Call point.append(1.0)
    Call point.append(1.0)
    
    Let third_order_tensor be HigherOrder.compute_third_order_derivatives(function, variables, point)
    
    Assert.IsTrue(third_order_tensor.has_key("shape"))
    Assert.IsTrue(third_order_tensor.has_key("values"))
    Assert.IsTrue(third_order_tensor.has_key("symmetries"))
    
    Let shape be third_order_tensor.get("shape")
    Assert.AreEqual(shape.get(0), 2)  Note: 2 variables
    Assert.AreEqual(shape.get(1), 2)
    Assert.AreEqual(shape.get(2), 2)
    
    Note: For f(x,y) = x⁴ + y⁴ + xy², d³f/dx³ at (1,1) = 24
    Let values be third_order_tensor.get("values")
    Assert.AreEqual(values.get(0), 24.0)  Note: d³f/dx³
    
    Return true

Process called "test_fourth_order_derivatives" that takes no parameters returns Boolean:
    Note: Test fourth-order derivative computation
    Let function be "x^5 + y^5"
    
    Let variables be Collections.CreateList[String]()
    Call variables.append("x")
    Call variables.append("y")
    
    Let point be Collections.CreateList[Float]()
    Call point.append(1.0)
    Call point.append(1.0)
    
    Let fourth_order_tensor be HigherOrder.compute_fourth_order_derivatives(function, variables, point)
    
    Assert.IsTrue(fourth_order_tensor.has_key("shape"))
    Assert.IsTrue(fourth_order_tensor.has_key("values"))
    
    Let shape be fourth_order_tensor.get("shape")
    Assert.AreEqual(shape.length, 4)  Note: Fourth-order tensor
    For i from 0 to 3:
        Assert.AreEqual(shape.get(i), 2)
    
    Note: For f(x,y) = x⁵ + y⁵, d⁴f/dx⁴ at (1,1) = 120, d⁴f/dy⁴ at (1,1) = 120
    Let values be fourth_order_tensor.get("values")
    Assert.AreEqual(values.get(0), 120.0)  Note: d⁴f/dx⁴
    Assert.AreEqual(values.get(15), 120.0)  Note: d⁴f/dy⁴ (last element)
    
    Return true

Note: =====================================================================
Note: PERFORMANCE OPTIMIZATION TESTS
Note: =====================================================================

Process called "test_hessian_computation_performance" that takes no parameters returns Boolean:
    Note: Test performance of different Hessian computation methods
    Let function be "x^2 + 2*x*y + 3*y^2 + x^3 + y^3"
    
    Let variables be Collections.CreateList[String]()
    Call variables.append("x")
    Call variables.append("y")
    
    Let point be Collections.CreateList[Float]()
    Call point.append(1.0)
    Call point.append(1.0)
    
    Let start_time be DateTime.GetCurrentTimestamp()
    
    Let hessian_for be HigherOrder.forward_over_reverse_hessian(function, variables, point)
    
    Let mid_time be DateTime.GetCurrentTimestamp()
    
    Let hessian_rev be HigherOrder.reverse_over_forward_hessian(function, variables, point)
    
    Let end_time be DateTime.GetCurrentTimestamp()
    
    Let forward_time be mid_time - start_time
    Let reverse_time be end_time - mid_time
    
    Assert.IsTrue(forward_time >= 0.0)
    Assert.IsTrue(reverse_time >= 0.0)
    
    Note: Both methods should produce the same result
    Assert.AreEqual(hessian_for.hessian_matrix.get(0).get(0), hessian_rev.hessian_matrix.get(0).get(0))
    Assert.AreEqual(hessian_for.hessian_matrix.get(1).get(1), hessian_rev.hessian_matrix.get(1).get(1))
    
    Return true

Process called "test_sparse_hessian_optimization" that takes no parameters returns Boolean:
    Note: Test sparse Hessian computation optimization
    Let function be "x1^2 + x5^2 + x10^2"  Note: Sparse function
    
    Let variables be Collections.CreateList[String]()
    Let i be 1
    While i <= 10:
        Call variables.append("x" + String(i))
        Set i to i + 1
    
    Let point be Collections.CreateList[Float]()
    Let j be 1
    While j <= 10:
        Call point.append(1.0)
        Set j to j + 1
    
    Let sparse_start_time be DateTime.GetCurrentTimestamp()
    Let sparse_hessian be HigherOrder.compute_sparse_hessian(function, variables, point)
    Let sparse_end_time be DateTime.GetCurrentTimestamp()
    
    Let dense_start_time be DateTime.GetCurrentTimestamp()
    Let dense_hessian be HigherOrder.forward_over_reverse_hessian(function, variables, point)
    Let dense_end_time be DateTime.GetCurrentTimestamp()
    
    Let sparse_time be sparse_end_time - sparse_start_time
    Let dense_time = dense_end_time - dense_start_time
    
    Assert.IsTrue(sparse_time >= 0.0)
    Assert.IsTrue(dense_time >= 0.0)
    
    Note: Sparse computation should detect the sparsity pattern
    Let non_zero_count be 0
    For row in sparse_hessian.sparsity_pattern:
        For is_non_zero in row:
            If is_non_zero:
                Set non_zero_count to non_zero_count + 1
    
    Assert.IsTrue(non_zero_count <= 9)  Note: Should have few non-zero elements
    
    Return true

Note: =====================================================================
Note: ERROR HANDLING AND EDGE CASES
Note: =====================================================================

Process called "test_singular_hessian_handling" that takes no parameters returns Boolean:
    Note: Test handling of singular Hessian matrices
    Let function be "x^2"  Note: Function of one variable, extended to 2D
    
    Let variables be Collections.CreateList[String]()
    Call variables.append("x")
    Call variables.append("y")
    
    Let point be Collections.CreateList[Float]()
    Call point.append(1.0)
    Call point.append(1.0)
    
    Let singular_hessian be HigherOrder.forward_over_reverse_hessian(function, variables, point)
    
    Assert.IsFalse(singular_hessian.is_positive_definite)  Note: Singular matrix
    Assert.IsTrue(singular_hessian.condition_number >= 1e10)  Note: Very large condition number
    
    Note: Should have zero determinant (or very close to zero)
    Let determinant be HigherOrder.compute_determinant(singular_hessian.hessian_matrix)
    Assert.IsTrue(MathCore.abs(determinant) < 1e-6)
    
    Return true

Process called "test_hessian_with_zero_derivatives" that takes no parameters returns Boolean:
    Note: Test Hessian computation for functions with zero second derivatives
    Let function = "x + y"  Note: Linear function has zero Hessian
    
    Let variables be Collections.CreateList[String]()
    Call variables.append("x")
    Call variables.append("y")
    
    Let point be Collections.CreateList[Float]()
    Call point.append(2.0)
    Call point.append(3.0)
    
    Let zero_hessian be HigherOrder.forward_over_reverse_hessian(function, variables, point)
    
    Assert.AreEqual(zero_hessian.hessian_matrix.get(0).get(0), 0.0)
    Assert.AreEqual(zero_hessian.hessian_matrix.get(0).get(1), 0.0)
    Assert.AreEqual(zero_hessian.hessian_matrix.get(1).get(0), 0.0)
    Assert.AreEqual(zero_hessian.hessian_matrix.get(1).get(1), 0.0)
    
    Assert.IsFalse(zero_hessian.is_positive_definite)  Note: Zero matrix is not positive definite
    
    Return true

Process called "test_hessian_numerical_stability" that takes no parameters returns Boolean:
    Note: Test numerical stability of Hessian computation
    Let function be "exp(x^2 + y^2)"  Note: Function with rapidly growing derivatives
    
    Let variables be Collections.CreateList[String]()
    Call variables.append("x")
    Call variables.append("y")
    
    Note: Test at a point where function is well-behaved
    Let stable_point be Collections.CreateList[Float]()
    Call stable_point.append(0.1)
    Call stable_point.append(0.1)
    
    Let stable_hessian be HigherOrder.forward_over_reverse_hessian(function, variables, stable_point)
    
    Assert.IsTrue(stable_hessian.condition_number < 1e6)  Note: Should be well-conditioned
    
    Note: All elements should be finite
    For row in stable_hessian.hessian_matrix:
        For element in row:
            Assert.IsFalse(Float.IsInfinite(element))
            Assert.IsFalse(Float.IsNaN(element))
    
    Return true

Note: =====================================================================
Note: TEST RUNNER PROCESS
Note: =====================================================================

Process called "run_higher_order_tests" that takes no parameters returns Boolean:
    Note: Run all higher-order derivatives tests
    Let test_results be Collections.CreateList[Boolean]()
    Let test_names be Collections.CreateList[String]()
    
    Note: Structure construction tests
    Call test_names.append("Hessian Result Construction")
    Call test_results.append(test_hessian_result_construction())
    
    Call test_names.append("Jet Number Construction")
    Call test_results.append(test_jet_number_construction())
    
    Call test_names.append("Hyperdual Number Construction")
    Call test_results.append(test_hyperdual_number_construction())
    
    Call test_names.append("Tensor Derivative Construction")
    Call test_results.append(test_tensor_derivative_construction())
    
    Note: Hessian computation tests
    Call test_names.append("Forward Over Reverse Hessian")
    Call test_results.append(test_forward_over_reverse_hessian())
    
    Call test_names.append("Reverse Over Forward Hessian")
    Call test_results.append(test_reverse_over_forward_hessian())
    
    Call test_names.append("Sparse Hessian Computation")
    Call test_results.append(test_sparse_hessian_computation())
    
    Call test_names.append("Hessian Eigenvalue Analysis")
    Call test_results.append(test_hessian_eigenvalue_analysis())
    
    Note: Hessian-vector product tests
    Call test_names.append("Hessian Vector Product")
    Call test_results.append(test_hessian_vector_product())
    
    Call test_names.append("Vector Hessian Vector Product")
    Call test_results.append(test_vector_hessian_vector_product())
    
    Call test_names.append("Multiple Hessian Vector Products")
    Call test_results.append(test_multiple_hessian_vector_products())
    
    Note: Jet transport and Taylor series tests
    Call test_names.append("Jet Transport Computation")
    Call test_results.append(test_jet_transport_computation())
    
    Call test_names.append("Taylor Series Evaluation")
    Call test_results.append(test_taylor_series_evaluation())
    
    Call test_names.append("Taylor Series Composition")
    Call test_results.append(test_taylor_series_composition())
    
    Note: Mixed partial derivative tests
    Call test_names.append("Mixed Partial Derivatives")
    Call test_results.append(test_mixed_partial_derivatives())
    
    Call test_names.append("Symmetric Mixed Partials")
    Call test_results.append(test_symmetric_mixed_partials())
    
    Note: Higher-order tensor tests
    Call test_names.append("Third Order Derivatives")
    Call test_results.append(test_third_order_derivatives())
    
    Call test_names.append("Fourth Order Derivatives")
    Call test_results.append(test_fourth_order_derivatives())
    
    Note: Performance tests
    Call test_names.append("Hessian Computation Performance")
    Call test_results.append(test_hessian_computation_performance())
    
    Call test_names.append("Sparse Hessian Optimization")
    Call test_results.append(test_sparse_hessian_optimization())
    
    Note: Error handling tests
    Call test_names.append("Singular Hessian Handling")
    Call test_results.append(test_singular_hessian_handling())
    
    Call test_names.append("Hessian with Zero Derivatives")
    Call test_results.append(test_hessian_with_zero_derivatives())
    
    Call test_names.append("Hessian Numerical Stability")
    Call test_results.append(test_hessian_numerical_stability())
    
    Note: Report test results
    Let total_tests be test_results.length
    Let passed_tests be 0
    Let failed_tests be 0
    
    Let i be 0
    While i < total_tests:
        If test_results.get(i):
            Set passed_tests to passed_tests + 1
        Otherwise:
            Set failed_tests to failed_tests + 1
            Assert.LogMessage("FAILED: " + test_names.get(i))
        Set i to i + 1
    
    Assert.LogMessage("Higher-Order Derivatives Test Results:")
    Assert.LogMessage("Total Tests: " + String(total_tests))
    Assert.LogMessage("Passed: " + String(passed_tests))
    Assert.LogMessage("Failed: " + String(failed_tests))
    
    If failed_tests == 0:
        Assert.LogMessage("All higher-order derivatives tests PASSED!")
        Return true
    Otherwise:
        Assert.LogMessage("Some higher-order derivatives tests FAILED!")
        Return false