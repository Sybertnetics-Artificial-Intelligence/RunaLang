Note:
Unit tests for forward-mode automatic differentiation implementation.
Tests dual number arithmetic, forward mode differentiation, multivariate functions,
higher-order derivatives, and Taylor series computations.
:End Note

Import "math/engine/autodiff/forward" as Forward
Import "dev/debug/testing/assertion_engine" as Assert
Import "collections" as Collections

Note: =====================================================================
Note: DUAL NUMBER ARITHMETIC TESTS
Note: =====================================================================

Process called "test_dual_number_construction" that takes no parameters returns Boolean:
    Note: Test basic dual number construction and properties
    Let dual_a be Forward.DualNumber with:
        real = 5.0
        dual = 1.0
    
    Let dual_b be Forward.DualNumber with:
        real = -2.5
        dual = 0.0
    
    Assert.AreEqual(dual_a.real, 5.0)
    Assert.AreEqual(dual_a.dual, 1.0)
    Assert.AreEqual(dual_b.real, -2.5)
    Assert.AreEqual(dual_b.dual, 0.0)
    
    Return true

Process called "test_dual_addition" that takes no parameters returns Boolean:
    Note: Test dual number addition: (a + a'ε) + (b + b'ε) = (a + b) + (a' + b')ε
    Let a be Forward.DualNumber with:
        real = 3.0
        dual = 1.0
    
    Let b be Forward.DualNumber with:
        real = 2.0
        dual = 0.5
    
    Let result be Forward.dual_add(a, b)
    
    Assert.AreEqual(result.real, 5.0)
    Assert.AreEqual(result.dual, 1.5)
    
    Return true

Process called "test_dual_subtraction" that takes no parameters returns Boolean:
    Note: Test dual number subtraction: (a + a'ε) - (b + b'ε) = (a - b) + (a' - b')ε
    Let a be Forward.DualNumber with:
        real = 7.0
        dual = 2.0
    
    Let b be Forward.DualNumber with:
        real = 3.0
        dual = 1.0
    
    Let result be Forward.dual_subtract(a, b)
    
    Assert.AreEqual(result.real, 4.0)
    Assert.AreEqual(result.dual, 1.0)
    
    Return true

Process called "test_dual_multiplication" that takes no parameters returns Boolean:
    Note: Test dual number multiplication: (a + a'ε) × (b + b'ε) = (ab) + (a'b + ab')ε
    Let a be Forward.DualNumber with:
        real = 4.0
        dual = 1.0
    
    Let b be Forward.DualNumber with:
        real = 3.0
        dual = 0.5
    
    Let result be Forward.dual_multiply(a, b)
    
    Assert.AreEqual(result.real, 12.0)
    Assert.AreEqual(result.dual, 5.0)  Note: 1.0 * 3.0 + 4.0 * 0.5 = 5.0
    
    Return true

Process called "test_dual_division" that takes no parameters returns Boolean:
    Note: Test dual number division: (a + a'ε) ÷ (b + b'ε) = (a/b) + ((a'b - ab')/b²)ε
    Let a be Forward.DualNumber with:
        real = 6.0
        dual = 1.0
    
    Let b be Forward.DualNumber with:
        real = 2.0
        dual = 0.0
    
    Let result be Forward.dual_divide(a, b)
    
    Assert.AreEqual(result.real, 3.0)
    Assert.AreEqual(result.dual, 0.5)  Note: (1.0 * 2.0 - 6.0 * 0.0) / (2.0 * 2.0) = 0.5
    
    Return true

Process called "test_dual_division_by_zero_error" that takes no parameters returns Boolean:
    Note: Test that division by zero throws appropriate error
    Let a be Forward.DualNumber with:
        real = 5.0
        dual = 1.0
    
    Let b be Forward.DualNumber with:
        real = 0.0
        dual = 1.0
    
    Let error_caught be false
    Try:
        Let invalid_result be Forward.dual_divide(a, b)
    Catch error:
        Set error_caught to true
        Assert.IsTrue(error.message.contains("Cannot divide dual number by zero"))
    
    Assert.IsTrue(error_caught)
    
    Return true

Process called "test_dual_power_operation" that takes no parameters returns Boolean:
    Note: Test dual number power operation with proper derivative computation
    Let base be Forward.DualNumber with:
        real = 2.0
        dual = 1.0
    
    Let exponent be Forward.DualNumber with:
        real = 3.0
        dual = 0.0
    
    Let result be Forward.dual_power(base, exponent)
    
    Assert.AreEqual(result.real, 8.0)  Note: 2^3 = 8
    Assert.AreEqual(result.dual, 12.0)  Note: 3 * 2^2 * 1.0 = 12.0
    
    Return true

Process called "test_dual_power_invalid_base" that takes no parameters returns Boolean:
    Note: Test that negative base for power operation throws error
    Let negative_base be Forward.DualNumber with:
        real = -2.0
        dual = 1.0
    
    Let exponent be Forward.DualNumber with:
        real = 2.5
        dual = 0.0
    
    Let error_caught be false
    Try:
        Let invalid_result be Forward.dual_power(negative_base, exponent)
    Catch error:
        Set error_caught to true
        Assert.IsTrue(error.message.contains("Base must be positive"))
    
    Assert.IsTrue(error_caught)
    
    Return true

Process called "test_dual_negation" that takes no parameters returns Boolean:
    Note: Test dual number negation operation
    Let a be Forward.DualNumber with:
        real = 5.0
        dual = -2.0
    
    Let result be Forward.dual_negate(a)
    
    Assert.AreEqual(result.real, -5.0)
    Assert.AreEqual(result.dual, 2.0)
    
    Return true

Note: =====================================================================
Note: MULTIVARIATE DUAL NUMBER TESTS
Note: =====================================================================

Process called "test_multi_dual_construction" that takes no parameters returns Boolean:
    Note: Test construction of multivariate dual numbers
    Let derivatives be Collections.CreateList[Float]()
    Call derivatives.append(1.0)  Note: df/dx
    Call derivatives.append(0.0)  Note: df/dy
    Call derivatives.append(2.0)  Note: df/dz
    
    Let multi_dual be Forward.MultiDual with:
        value = 10.0
        derivatives = derivatives
        num_variables = 3
    
    Assert.AreEqual(multi_dual.value, 10.0)
    Assert.AreEqual(multi_dual.num_variables, 3)
    Assert.AreEqual(multi_dual.derivatives.get(0), 1.0)
    Assert.AreEqual(multi_dual.derivatives.get(1), 0.0)
    Assert.AreEqual(multi_dual.derivatives.get(2), 2.0)
    
    Return true

Process called "test_multi_dual_addition" that takes no parameters returns Boolean:
    Note: Test addition of multivariate dual numbers
    Let derivatives_a be Collections.CreateList[Float]()
    Call derivatives_a.append(1.0)
    Call derivatives_a.append(2.0)
    
    Let derivatives_b be Collections.CreateList[Float]()
    Call derivatives_b.append(0.5)
    Call derivatives_b.append(1.5)
    
    Let a be Forward.MultiDual with:
        value = 3.0
        derivatives = derivatives_a
        num_variables = 2
    
    Let b be Forward.MultiDual with:
        value = 2.0
        derivatives = derivatives_b
        num_variables = 2
    
    Let result be Forward.multi_dual_add(a, b)
    
    Assert.AreEqual(result.value, 5.0)
    Assert.AreEqual(result.derivatives.get(0), 1.5)
    Assert.AreEqual(result.derivatives.get(1), 3.5)
    
    Return true

Process called "test_multi_dual_multiplication" that takes no parameters returns Boolean:
    Note: Test multiplication of multivariate dual numbers
    Let derivatives_a be Collections.CreateList[Float]()
    Call derivatives_a.append(1.0)  Note: da/dx
    Call derivatives_a.append(0.0)  Note: da/dy
    
    Let derivatives_b be Collections.CreateList[Float]()
    Call derivatives_b.append(0.0)  Note: db/dx
    Call derivatives_b.append(1.0)  Note: db/dy
    
    Let a be Forward.MultiDual with:
        value = 4.0
        derivatives = derivatives_a
        num_variables = 2
    
    Let b be Forward.MultiDual with:
        value = 3.0
        derivatives = derivatives_b
        num_variables = 2
    
    Let result be Forward.multi_dual_multiply(a, b)
    
    Assert.AreEqual(result.value, 12.0)  Note: 4 * 3 = 12
    Assert.AreEqual(result.derivatives.get(0), 3.0)  Note: 1.0 * 3.0 + 4.0 * 0.0 = 3.0
    Assert.AreEqual(result.derivatives.get(1), 4.0)  Note: 0.0 * 3.0 + 4.0 * 1.0 = 4.0
    
    Return true

Note: =====================================================================
Note: HYPERDUAL NUMBER TESTS
Note: =====================================================================

Process called "test_hyperdual_construction" that takes no parameters returns Boolean:
    Note: Test construction of hyperdual numbers for second derivatives
    Let hyperdual be Forward.HyperDual with:
        f = 10.0
        f_x = 5.0
        f_y = 3.0
        f_xy = 1.5
    
    Assert.AreEqual(hyperdual.f, 10.0)
    Assert.AreEqual(hyperdual.f_x, 5.0)
    Assert.AreEqual(hyperdual.f_y, 3.0)
    Assert.AreEqual(hyperdual.f_xy, 1.5)
    
    Return true

Process called "test_hyperdual_addition" that takes no parameters returns Boolean:
    Note: Test addition of hyperdual numbers
    Let a be Forward.HyperDual with:
        f = 6.0
        f_x = 2.0
        f_y = 1.0
        f_xy = 0.5
    
    Let b be Forward.HyperDual with:
        f = 4.0
        f_x = 1.5
        f_y = 2.5
        f_xy = 1.0
    
    Let result be Forward.hyperdual_add(a, b)
    
    Assert.AreEqual(result.f, 10.0)
    Assert.AreEqual(result.f_x, 3.5)
    Assert.AreEqual(result.f_y, 3.5)
    Assert.AreEqual(result.f_xy, 1.5)
    
    Return true

Process called "test_hyperdual_multiplication" that takes no parameters returns Boolean:
    Note: Test multiplication of hyperdual numbers with mixed derivatives
    Let a be Forward.HyperDual with:
        f = 3.0
        f_x = 1.0
        f_y = 0.0
        f_xy = 0.0
    
    Let b be Forward.HyperDual with:
        f = 2.0
        f_x = 0.0
        f_y = 1.0
        f_xy = 0.0
    
    Let result be Forward.hyperdual_multiply(a, b)
    
    Assert.AreEqual(result.f, 6.0)  Note: 3 * 2 = 6
    Assert.AreEqual(result.f_x, 2.0)  Note: 1 * 2 + 3 * 0 = 2
    Assert.AreEqual(result.f_y, 3.0)  Note: 0 * 2 + 3 * 1 = 3
    Assert.AreEqual(result.f_xy, 1.0)  Note: Mixed second derivative
    
    Return true

Note: =====================================================================
Note: TAYLOR SERIES TESTS
Note: =====================================================================

Process called "test_taylor_series_construction" that takes no parameters returns Boolean:
    Note: Test Taylor series construction with coefficients
    Let coefficients be Collections.CreateList[Float]()
    Call coefficients.append(1.0)    Note: 0th order (constant)
    Call coefficients.append(2.0)    Note: 1st order (linear)
    Call coefficients.append(1.5)    Note: 2nd order (quadratic)
    Call coefficients.append(0.25)   Note: 3rd order (cubic)
    
    Let taylor_series be Forward.TaylorSeries with:
        coefficients = coefficients
        order = 3
        variable_name = "x"
    
    Assert.AreEqual(taylor_series.order, 3)
    Assert.AreEqual(taylor_series.variable_name, "x")
    Assert.AreEqual(taylor_series.coefficients.get(0), 1.0)
    Assert.AreEqual(taylor_series.coefficients.get(1), 2.0)
    Assert.AreEqual(taylor_series.coefficients.get(2), 1.5)
    Assert.AreEqual(taylor_series.coefficients.get(3), 0.25)
    
    Return true

Process called "test_taylor_series_addition" that takes no parameters returns Boolean:
    Note: Test addition of Taylor series
    Let coeffs_a be Collections.CreateList[Float]()
    Call coeffs_a.append(1.0)
    Call coeffs_a.append(2.0)
    Call coeffs_a.append(3.0)
    
    Let coeffs_b be Collections.CreateList[Float]()
    Call coeffs_b.append(0.5)
    Call coeffs_b.append(1.5)
    Call coeffs_b.append(2.5)
    
    Let taylor_a be Forward.TaylorSeries with:
        coefficients = coeffs_a
        order = 2
        variable_name = "x"
    
    Let taylor_b be Forward.TaylorSeries with:
        coefficients = coeffs_b
        order = 2
        variable_name = "x"
    
    Let result be Forward.taylor_add(taylor_a, taylor_b)
    
    Assert.AreEqual(result.coefficients.get(0), 1.5)
    Assert.AreEqual(result.coefficients.get(1), 3.5)
    Assert.AreEqual(result.coefficients.get(2), 5.5)
    Assert.AreEqual(result.order, 2)
    
    Return true

Process called "test_taylor_series_evaluation" that takes no parameters returns Boolean:
    Note: Test Taylor series evaluation at a point
    Let coefficients be Collections.CreateList[Float]()
    Call coefficients.append(1.0)    Note: constant term
    Call coefficients.append(2.0)    Note: x term
    Call coefficients.append(0.5)    Note: x² term
    
    Let taylor_series be Forward.TaylorSeries with:
        coefficients = coefficients
        order = 2
        variable_name = "x"
    
    Let point be 2.0
    Let result be Forward.evaluate_taylor_series(taylor_series, point)
    
    Note: f(x) = 1 + 2x + 0.5x², f(2) = 1 + 2*2 + 0.5*4 = 1 + 4 + 2 = 7
    Assert.AreEqual(result, 7.0)
    
    Return true

Note: =====================================================================
Note: FORWARD MODE DIFFERENTIATION TESTS
Note: =====================================================================

Process called "test_forward_mode_simple_function" that takes no parameters returns Boolean:
    Note: Test forward mode differentiation of f(x) = x²
    Let x_value be 3.0
    Let x_dual be Forward.DualNumber with:
        real = x_value
        dual = 1.0  Note: seed for df/dx
    
    Let result be Forward.square_function(x_dual)
    
    Assert.AreEqual(result.real, 9.0)  Note: 3² = 9
    Assert.AreEqual(result.dual, 6.0)  Note: d/dx(x²) = 2x, at x=3: 2*3 = 6
    
    Return true

Process called "test_forward_mode_polynomial" that takes no parameters returns Boolean:
    Note: Test forward mode for polynomial f(x) = 2x³ + 3x² - x + 1
    Let x_value be 2.0
    Let x_dual be Forward.DualNumber with:
        real = x_value
        dual = 1.0
    
    Let result be Forward.polynomial_function(x_dual)
    
    Note: f(2) = 2*8 + 3*4 - 2 + 1 = 16 + 12 - 2 + 1 = 27
    Assert.AreEqual(result.real, 27.0)
    
    Note: f'(x) = 6x² + 6x - 1, f'(2) = 6*4 + 6*2 - 1 = 24 + 12 - 1 = 35
    Assert.AreEqual(result.dual, 35.0)
    
    Return true

Process called "test_forward_mode_multivariate" that takes no parameters returns Boolean:
    Note: Test forward mode for multivariate function f(x,y) = x*y + x²
    Let variables be Collections.CreateList[Forward.DualNumber]()
    
    Note: Compute df/dx by setting x seed to 1, y seed to 0
    Let x_for_dx be Forward.DualNumber with:
        real = 3.0
        dual = 1.0
    
    Let y_for_dx be Forward.DualNumber with:
        real = 2.0
        dual = 0.0
    
    Call variables.append(x_for_dx)
    Call variables.append(y_for_dx)
    
    Let result_dx be Forward.multivariate_function(variables)
    
    Note: f(3,2) = 3*2 + 3² = 6 + 9 = 15
    Assert.AreEqual(result_dx.real, 15.0)
    
    Note: df/dx = y + 2x, at (3,2): 2 + 2*3 = 8
    Assert.AreEqual(result_dx.dual, 8.0)
    
    Return true

Process called "test_forward_mode_chain_rule" that takes no parameters returns Boolean:
    Note: Test forward mode with chain rule for f(g(x)) where g(x) = x² and f(u) = sin(u)
    Let x_value be 1.0
    Let x_dual be Forward.DualNumber with:
        real = x_value
        dual = 1.0
    
    Let result be Forward.composite_function(x_dual)
    
    Note: f(g(1)) = sin(1²) = sin(1) ≈ 0.8414
    Assert.IsTrue(MathCore.abs(result.real - 0.8414) < 0.001)
    
    Note: d/dx[sin(x²)] = cos(x²) * 2x, at x=1: cos(1) * 2 ≈ 1.0806
    Assert.IsTrue(MathCore.abs(result.dual - 1.0806) < 0.001)
    
    Return true

Note: =====================================================================
Note: TRANSCENDENTAL FUNCTION TESTS
Note: =====================================================================

Process called "test_dual_exponential" that takes no parameters returns Boolean:
    Note: Test dual number exponential function
    Let x be Forward.DualNumber with:
        real = 1.0
        dual = 1.0
    
    Let result be Forward.dual_exp(x)
    
    Note: exp(1) ≈ 2.718
    Assert.IsTrue(MathCore.abs(result.real - 2.718) < 0.001)
    
    Note: d/dx[exp(x)] = exp(x), so at x=1: exp(1) ≈ 2.718
    Assert.IsTrue(MathCore.abs(result.dual - 2.718) < 0.001)
    
    Return true

Process called "test_dual_logarithm" that takes no parameters returns Boolean:
    Note: Test dual number natural logarithm
    Let x be Forward.DualNumber with:
        real = 2.718
        dual = 1.0
    
    Let result be Forward.dual_log(x)
    
    Note: ln(e) ≈ 1.0
    Assert.IsTrue(MathCore.abs(result.real - 1.0) < 0.001)
    
    Note: d/dx[ln(x)] = 1/x, so at x=e: 1/e ≈ 0.368
    Assert.IsTrue(MathCore.abs(result.dual - 0.368) < 0.001)
    
    Return true

Process called "test_dual_sine" that takes no parameters returns Boolean:
    Note: Test dual number sine function
    Let x be Forward.DualNumber with:
        real = 0.0
        dual = 1.0
    
    Let result be Forward.dual_sin(x)
    
    Note: sin(0) = 0
    Assert.AreEqual(result.real, 0.0)
    
    Note: d/dx[sin(x)] = cos(x), cos(0) = 1
    Assert.AreEqual(result.dual, 1.0)
    
    Return true

Process called "test_dual_cosine" that takes no parameters returns Boolean:
    Note: Test dual number cosine function
    Let x be Forward.DualNumber with:
        real = 0.0
        dual = 1.0
    
    Let result be Forward.dual_cos(x)
    
    Note: cos(0) = 1
    Assert.AreEqual(result.real, 1.0)
    
    Note: d/dx[cos(x)] = -sin(x), -sin(0) = 0
    Assert.AreEqual(result.dual, 0.0)
    
    Return true

Note: =====================================================================
Note: HIGHER-ORDER FORWARD MODE TESTS
Note: =====================================================================

Process called "test_second_order_forward_mode" that takes no parameters returns Boolean:
    Note: Test second-order derivatives using nested dual numbers
    Let x be Forward.DualNumber with:
        real = 2.0
        dual = 1.0
    
    Let nested_dual be Forward.DualNumber with:
        real = x.real
        dual = x.dual
    
    Let second_order_result be Forward.compute_second_derivative(nested_dual)
    
    Note: For f(x) = x³, f''(2) = 6x = 6*2 = 12
    Assert.AreEqual(second_order_result.dual, 12.0)
    
    Return true

Process called "test_mixed_partial_derivatives" that takes no parameters returns Boolean:
    Note: Test mixed partial derivatives using hyperdual numbers
    Let hyperdual be Forward.HyperDual with:
        f = 0.0      Note: will be computed
        f_x = 0.0    Note: will be computed
        f_y = 0.0    Note: will be computed
        f_xy = 0.0   Note: will be computed
    
    Let x_value be 2.0
    Let y_value be 3.0
    
    Let result be Forward.compute_mixed_partial(hyperdual, x_value, y_value)
    
    Note: For f(x,y) = x²y, d²f/dxdy = 2y, at (2,3): 2*3 = 6
    Assert.AreEqual(result.f_xy, 6.0)
    
    Return true

Note: =====================================================================
Note: PERFORMANCE AND EDGE CASE TESTS
Note: =====================================================================

Process called "test_dual_number_precision" that takes no parameters returns Boolean:
    Note: Test precision of dual number computations
    Let x be Forward.DualNumber with:
        real = 1.000000001
        dual = 1.0
    
    Let result be Forward.dual_exp(x)
    
    Note: Should maintain precision in both real and dual parts
    Assert.IsTrue(result.real > 2.718)
    Assert.IsTrue(result.dual > 2.718)
    
    Return true

Process called "test_large_taylor_series" that takes no parameters returns Boolean:
    Note: Test Taylor series with many terms
    Let coefficients be Collections.CreateList[Float]()
    Let i be 0
    While i < 50:
        Call coefficients.append(1.0 / Float(i + 1))
        Set i to i + 1
    
    Let large_taylor be Forward.TaylorSeries with:
        coefficients = coefficients
        order = 49
        variable_name = "x"
    
    Let evaluation_result be Forward.evaluate_taylor_series(large_taylor, 0.5)
    
    Assert.IsTrue(evaluation_result > 0.0)
    Assert.IsTrue(evaluation_result < 10.0)  Note: Should converge to reasonable value
    
    Return true

Process called "test_forward_mode_zero_derivatives" that takes no parameters returns Boolean:
    Note: Test forward mode with constant functions (zero derivatives)
    Let x be Forward.DualNumber with:
        real = 5.0
        dual = 1.0
    
    Let constant_value be 42.0
    Let result be Forward.constant_function(x, constant_value)
    
    Assert.AreEqual(result.real, constant_value)
    Assert.AreEqual(result.dual, 0.0)  Note: derivative of constant is zero
    
    Return true

Note: =====================================================================
Note: INTEGRATION TESTS
Note: =====================================================================

Process called "test_forward_mode_integration_with_operators" that takes no parameters returns Boolean:
    Note: Test integration between forward mode and operator library
    Let x be Forward.DualNumber with:
        real = 3.0
        dual = 1.0
    
    Let y be Forward.DualNumber with:
        real = 4.0
        dual = 0.0
    
    Note: Test complex expression: (x² + y²) * exp(x)
    Let x_squared be Forward.dual_multiply(x, x)
    Let y_squared be Forward.dual_multiply(y, y)
    Let sum_squares be Forward.dual_add(x_squared, y_squared)
    Let exp_x be Forward.dual_exp(x)
    Let result be Forward.dual_multiply(sum_squares, exp_x)
    
    Note: Function value: (9 + 16) * e³ = 25 * e³
    Let expected_value be 25.0 * MathCore.exp(3.0)
    Assert.IsTrue(MathCore.abs(result.real - expected_value) < 0.001)
    
    Note: Derivative should be computed correctly
    Assert.IsTrue(result.dual > 0.0)  Note: Should have positive derivative
    
    Return true

Note: =====================================================================
Note: TEST RUNNER PROCESS
Note: =====================================================================

Process called "run_forward_tests" that takes no parameters returns Boolean:
    Note: Run all forward-mode automatic differentiation tests
    Let test_results be Collections.CreateList[Boolean]()
    Let test_names be Collections.CreateList[String]()
    
    Note: Dual number arithmetic tests
    Call test_names.append("Dual Number Construction")
    Call test_results.append(test_dual_number_construction())
    
    Call test_names.append("Dual Addition")
    Call test_results.append(test_dual_addition())
    
    Call test_names.append("Dual Subtraction")
    Call test_results.append(test_dual_subtraction())
    
    Call test_names.append("Dual Multiplication")
    Call test_results.append(test_dual_multiplication())
    
    Call test_names.append("Dual Division")
    Call test_results.append(test_dual_division())
    
    Call test_names.append("Dual Division by Zero Error")
    Call test_results.append(test_dual_division_by_zero_error())
    
    Call test_names.append("Dual Power Operation")
    Call test_results.append(test_dual_power_operation())
    
    Call test_names.append("Dual Power Invalid Base")
    Call test_results.append(test_dual_power_invalid_base())
    
    Call test_names.append("Dual Negation")
    Call test_results.append(test_dual_negation())
    
    Note: Multivariate dual number tests
    Call test_names.append("Multi Dual Construction")
    Call test_results.append(test_multi_dual_construction())
    
    Call test_names.append("Multi Dual Addition")
    Call test_results.append(test_multi_dual_addition())
    
    Call test_names.append("Multi Dual Multiplication")
    Call test_results.append(test_multi_dual_multiplication())
    
    Note: Hyperdual number tests
    Call test_names.append("Hyperdual Construction")
    Call test_results.append(test_hyperdual_construction())
    
    Call test_names.append("Hyperdual Addition")
    Call test_results.append(test_hyperdual_addition())
    
    Call test_names.append("Hyperdual Multiplication")
    Call test_results.append(test_hyperdual_multiplication())
    
    Note: Taylor series tests
    Call test_names.append("Taylor Series Construction")
    Call test_results.append(test_taylor_series_construction())
    
    Call test_names.append("Taylor Series Addition")
    Call test_results.append(test_taylor_series_addition())
    
    Call test_names.append("Taylor Series Evaluation")
    Call test_results.append(test_taylor_series_evaluation())
    
    Note: Forward mode differentiation tests
    Call test_names.append("Forward Mode Simple Function")
    Call test_results.append(test_forward_mode_simple_function())
    
    Call test_names.append("Forward Mode Polynomial")
    Call test_results.append(test_forward_mode_polynomial())
    
    Call test_names.append("Forward Mode Multivariate")
    Call test_results.append(test_forward_mode_multivariate())
    
    Call test_names.append("Forward Mode Chain Rule")
    Call test_results.append(test_forward_mode_chain_rule())
    
    Note: Transcendental function tests
    Call test_names.append("Dual Exponential")
    Call test_results.append(test_dual_exponential())
    
    Call test_names.append("Dual Logarithm")
    Call test_results.append(test_dual_logarithm())
    
    Call test_names.append("Dual Sine")
    Call test_results.append(test_dual_sine())
    
    Call test_names.append("Dual Cosine")
    Call test_results.append(test_dual_cosine())
    
    Note: Higher-order tests
    Call test_names.append("Second Order Forward Mode")
    Call test_results.append(test_second_order_forward_mode())
    
    Call test_names.append("Mixed Partial Derivatives")
    Call test_results.append(test_mixed_partial_derivatives())
    
    Note: Performance and edge case tests
    Call test_names.append("Dual Number Precision")
    Call test_results.append(test_dual_number_precision())
    
    Call test_names.append("Large Taylor Series")
    Call test_results.append(test_large_taylor_series())
    
    Call test_names.append("Forward Mode Zero Derivatives")
    Call test_results.append(test_forward_mode_zero_derivatives())
    
    Note: Integration tests
    Call test_names.append("Forward Mode Integration with Operators")
    Call test_results.append(test_forward_mode_integration_with_operators())
    
    Note: Report test results
    Let total_tests be test_results.length
    Let passed_tests be 0
    Let failed_tests be 0
    
    Let i be 0
    While i < total_tests:
        If test_results.get(i):
            Set passed_tests to passed_tests + 1
        Otherwise:
            Set failed_tests to failed_tests + 1
            Assert.LogMessage("FAILED: " + test_names.get(i))
        Set i to i + 1
    
    Assert.LogMessage("Forward Mode AD Test Results:")
    Assert.LogMessage("Total Tests: " + String(total_tests))
    Assert.LogMessage("Passed: " + String(passed_tests))
    Assert.LogMessage("Failed: " + String(failed_tests))
    
    If failed_tests == 0:
        Assert.LogMessage("All forward-mode AD tests PASSED!")
        Return true
    Otherwise:
        Assert.LogMessage("Some forward-mode AD tests FAILED!")
        Return false