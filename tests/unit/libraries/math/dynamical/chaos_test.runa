Note: Comprehensive Unit Tests for Chaos Theory Module

This module provides comprehensive testing for chaos theory analysis functionality,
including Lyapunov exponents, strange attractors, chaotic systems, fractal dimensions,
entropy measures, and nonlinear time series analysis.

Test Coverage:
- Lyapunov exponent computation and analysis
- Strange attractor detection and characterization
- Fractal dimension calculations
- Entropy and complexity measures  
- Chaotic system identification
- Time series analysis for chaos
- Poincar√© recurrence statistics
- Correlation dimension analysis
- Power spectrum analysis
- Performance benchmarking

Mathematical Foundations Tested:
- Chaotic dynamics and sensitive dependence
- Attractor reconstruction from time series
- Embedding theory and delay coordinates
- Information theory measures
- Fractal geometry and self-similarity
- Ergodic theory and mixing properties

:End Note

Import "math/dynamical/chaos" as Chaos
Import "math/dynamical/systems" as DynamicalSystems
Import "math/core/operations" as MathOps
Import "math/algebra/linear" as LinearAlgebra
Import "math/engine/numerical/integration" as Integration
Import "math/statistics/descriptive" as Statistics
Import "os/system/time" as SystemTime

Note: ===== Test Helper Functions =====

Process called "assert_equal" that takes actual as Float64, expected as Float64, tolerance as Float64 returns Boolean:
    Let difference be MathOps.absolute_value(actual - expected)
    Return difference <= tolerance

Process called "assert_vector_equal" that takes actual as List[Float64], expected as List[Float64], tolerance as Float64 returns Boolean:
    If actual.size != expected.size:
        Return false
    
    For i from 0 to actual.size - 1:
        If not assert_equal(actual[i], expected[i], tolerance):
            Return false
    
    Return true

Process called "assert_positive" that takes value as Float64 returns Boolean:
    Return value > 0.0

Process called "assert_in_range" that takes value as Float64, min_val as Float64, max_val as Float64 returns Boolean:
    Return value >= min_val and value <= max_val

Process called "generate_lorenz_time_series" that takes sigma as Float64, rho as Float64, beta as Float64, duration as Float64, dt as Float64 returns List[Float64]:
    Let system_function be (state: List[Float64]) => [
        sigma * (state[1] - state[0]),
        state[0] * (rho - state[2]) - state[1],
        state[0] * state[1] - beta * state[2]
    ]
    
    Let initial_state be [1.0, 1.0, 1.0]
    Let time_span be [0.0, duration]
    Let trajectory be DynamicalSystems.integrate_trajectory(system_function, initial_state, time_span, dt)
    
    Let x_series be MathOps.create_empty_list(trajectory.state_history.size)
    For i from 0 to trajectory.state_history.size - 1:
        x_series[i] = trajectory.state_history[i][0]
    
    Return x_series

Process called "generate_henon_time_series" that takes a as Float64, b as Float64, iterations as Integer returns List[Float64]:
    Let henon_map be (state: List[Float64]) => [
        1.0 - a * state[0] * state[0] + state[1],
        b * state[0]
    ]
    
    Let current_state be [0.1, 0.1]
    Let time_series be MathOps.create_empty_list(iterations)
    
    For i from 0 to iterations - 1:
        current_state = henon_map(current_state)
        time_series[i] = current_state[0]
    
    Return time_series

Process called "generate_logistic_time_series" that takes r as Float64, iterations as Integer returns List[Float64]:
    Let logistic_map be (x: Float64) => r * x * (1.0 - x)
    
    Let current_value be 0.5
    Let time_series be MathOps.create_empty_list(iterations)
    
    For i from 0 to iterations - 1:
        current_value = logistic_map(current_value)
        time_series[i] = current_value
    
    Return time_series

Note: ===== Lyapunov Exponent Tests =====

Process called "test_lyapunov_exponent_computation" that takes returns Boolean:
    Note: Tests computation of Lyapunov exponents for chaotic systems
    Let lorenz_system be (state: List[Float64]) => [
        10.0 * (state[1] - state[0]),
        state[0] * (28.0 - state[2]) - state[1],
        state[0] * state[1] - (8.0/3.0) * state[2]
    ]
    
    Let initial_state be [1.0, 1.0, 1.0]
    Let integration_time be 100.0
    
    Let lyapunov_exponents be Chaos.compute_lyapunov_exponents(lorenz_system, initial_state, integration_time)
    
    If lyapunov_exponents.size != 3:
        Return false
    
    Let lambda1 be lyapunov_exponents[0]
    Let lambda2 be lyapunov_exponents[1]
    Let lambda3 be lyapunov_exponents[2]
    
    If not assert_positive(lambda1):
        Return false
    
    If not assert_in_range(lambda1, 0.5, 1.5):
        Return false
    
    If not assert_in_range(lambda2, -0.5, 0.5):
        Return false
    
    If lambda3 >= 0.0:
        Return false
    
    Let sum_exponents be lambda1 + lambda2 + lambda3
    If not assert_in_range(sum_exponents, -15.0, -10.0):
        Return false
    
    Return true

Process called "test_largest_lyapunov_exponent" that takes returns Boolean:
    Note: Tests efficient computation of largest Lyapunov exponent
    Let time_series be generate_logistic_time_series(4.0, 1000)
    
    Let largest_exponent be Chaos.compute_largest_lyapunov_exponent(time_series)
    
    If not assert_positive(largest_exponent):
        Return false
    
    If not assert_in_range(largest_exponent, 0.4, 0.8):
        Return false
    
    Return true

Process called "test_lyapunov_dimension" that takes returns Boolean:
    Note: Tests Kaplan-Yorke dimension calculation from Lyapunov spectrum
    Let exponents be [0.906, 0.0, -14.572]
    
    Let lyapunov_dimension be Chaos.compute_kaplan_yorke_dimension(exponents)
    
    If not assert_in_range(lyapunov_dimension, 2.0, 2.1):
        Return false
    
    Let periodic_exponents be [-0.5, -1.0, -2.0]
    Let periodic_dimension be Chaos.compute_kaplan_yorke_dimension(periodic_exponents)
    
    If periodic_dimension >= 0.1:
        Return false
    
    Return true

Note: ===== Strange Attractor Tests =====

Process called "test_attractor_reconstruction" that takes returns Boolean:
    Note: Tests attractor reconstruction from time series using delay embedding
    Let time_series be generate_lorenz_time_series(10.0, 28.0, 8.0/3.0, 50.0, 0.01)
    Let embedding_dimension be 3
    Let delay be 10
    
    Let reconstructed_attractor be Chaos.reconstruct_attractor(time_series, embedding_dimension, delay)
    
    If reconstructed_attractor.embedding_vectors.size == 0:
        Return false
    
    If reconstructed_attractor.embedding_dimension != embedding_dimension:
        Return false
    
    If reconstructed_attractor.delay != delay:
        Return false
    
    Let expected_vectors be time_series.size - (embedding_dimension - 1) * delay
    If reconstructed_attractor.embedding_vectors.size != expected_vectors:
        Return false
    
    Return true

Process called "test_correlation_dimension" that takes returns Boolean:
    Note: Tests correlation dimension calculation using Grassberger-Procaccia algorithm
    Let henon_series be generate_henon_time_series(1.4, 0.3, 1000)
    Let embedding_dimension be 2
    Let delay be 1
    
    Let attractor be Chaos.reconstruct_attractor(henon_series, embedding_dimension, delay)
    Let correlation_dimension be Chaos.compute_correlation_dimension(attractor)
    
    If not assert_in_range(correlation_dimension, 1.2, 1.3):
        Return false
    
    Return true

Process called "test_attractor_characterization" that takes returns Boolean:
    Note: Tests comprehensive characterization of strange attractors
    Let lorenz_series be generate_lorenz_time_series(10.0, 28.0, 8.0/3.0, 100.0, 0.01)
    Let attractor be Chaos.reconstruct_attractor(lorenz_series, 3, 10)
    
    Let characteristics be Chaos.characterize_strange_attractor(attractor)
    
    If characteristics.correlation_dimension < 2.0:
        Return false
    
    If characteristics.information_dimension < characteristics.correlation_dimension:
        Return false
    
    If not assert_positive(characteristics.lyapunov_exponent):
        Return false
    
    If characteristics.is_chaotic != true:
        Return false
    
    Return true

Note: ===== Fractal Dimension Tests =====

Process called "test_box_counting_dimension" that takes returns Boolean:
    Note: Tests box-counting fractal dimension calculation
    Let cantor_set_points be generate_cantor_set_approximation(5)
    
    Let box_dimension be Chaos.compute_box_counting_dimension(cantor_set_points)
    
    Let theoretical_dimension be MathOps.natural_log(2.0) / MathOps.natural_log(3.0)
    If not assert_equal(box_dimension, theoretical_dimension, 0.1):
        Return false
    
    Return true

Process called "test_hausdorff_dimension" that takes returns Boolean:
    Note: Tests Hausdorff dimension estimation for fractal sets
    Let koch_curve_points be generate_koch_curve_approximation(4)
    
    Let hausdorff_dimension be Chaos.estimate_hausdorff_dimension(koch_curve_points)
    
    Let theoretical_dimension be MathOps.natural_log(4.0) / MathOps.natural_log(3.0)
    If not assert_equal(hausdorff_dimension, theoretical_dimension, 0.2):
        Return false
    
    Return true

Process called "test_capacity_dimension" that takes returns Boolean:
    Note: Tests capacity dimension for geometric objects
    Let circle_points be generate_circle_points(1000, 1.0)
    
    Let capacity_dimension be Chaos.compute_capacity_dimension(circle_points)
    
    If not assert_equal(capacity_dimension, 1.0, 0.1):
        Return false
    
    Let sphere_points be generate_sphere_points(1000, 1.0)
    Let sphere_dimension be Chaos.compute_capacity_dimension(sphere_points)
    
    If not assert_equal(sphere_dimension, 2.0, 0.2):
        Return false
    
    Return true

Note: ===== Entropy and Complexity Tests =====

Process called "test_kolmogorov_sinai_entropy" that takes returns Boolean:
    Note: Tests Kolmogorov-Sinai entropy calculation for chaotic systems
    Let chaotic_series be generate_logistic_time_series(4.0, 2000)
    
    Let ks_entropy be Chaos.compute_kolmogorov_sinai_entropy(chaotic_series)
    
    If not assert_positive(ks_entropy):
        Return false
    
    If not assert_in_range(ks_entropy, 0.4, 0.8):
        Return false
    
    Let periodic_series be generate_logistic_time_series(3.2, 2000)
    Let periodic_entropy be Chaos.compute_kolmogorov_sinai_entropy(periodic_series)
    
    If periodic_entropy >= 0.1:
        Return false
    
    Return true

Process called "test_approximate_entropy" that takes returns Boolean:
    Note: Tests approximate entropy (ApEn) for time series regularity
    Let random_series be generate_random_time_series(1000, 42)
    Let pattern_length be 2
    Let tolerance be 0.2
    
    Let apen be Chaos.compute_approximate_entropy(random_series, pattern_length, tolerance)
    
    If not assert_positive(apen):
        Return false
    
    If not assert_in_range(apen, 0.8, 2.0):
        Return false
    
    Let sine_series be generate_sine_series(1000, 1.0, 0.1)
    Let sine_apen be Chaos.compute_approximate_entropy(sine_series, pattern_length, tolerance)
    
    If sine_apen >= apen:
        Return false
    
    Return true

Process called "test_sample_entropy" that takes returns Boolean:
    Note: Tests sample entropy for improved regularity measurement
    Let chaotic_series be generate_henon_time_series(1.4, 0.3, 1000)
    Let pattern_length be 2
    Let tolerance be 0.15
    
    Let sample_entropy be Chaos.compute_sample_entropy(chaotic_series, pattern_length, tolerance)
    
    If not assert_positive(sample_entropy):
        Return false
    
    Let regular_series be generate_sine_series(1000, 1.0, 0.0)
    Let regular_entropy be Chaos.compute_sample_entropy(regular_series, pattern_length, tolerance)
    
    If regular_entropy >= sample_entropy:
        Return false
    
    Return true

Note: ===== Time Series Analysis Tests =====

Process called "test_recurrence_plot" that takes returns Boolean:
    Note: Tests recurrence plot generation and analysis
    Let lorenz_series be generate_lorenz_time_series(10.0, 28.0, 8.0/3.0, 20.0, 0.01)
    Let embedding_dimension be 3
    Let delay be 5
    Let threshold be 0.1
    
    Let recurrence_plot be Chaos.generate_recurrence_plot(lorenz_series, embedding_dimension, delay, threshold)
    
    If recurrence_plot.recurrence_matrix.size == 0:
        Return false
    
    If recurrence_plot.recurrence_rate <= 0.0:
        Return false
    
    If recurrence_plot.determinism <= 0.0:
        Return false
    
    If not assert_in_range(recurrence_plot.recurrence_rate, 0.01, 0.3):
        Return false
    
    Return true

Process called "test_poincare_return_map" that takes returns Boolean:
    Note: Tests Poincar√© return map construction and analysis
    Let time_series be generate_lorenz_time_series(10.0, 28.0, 8.0/3.0, 100.0, 0.01)
    
    Let return_map be Chaos.construct_poincare_return_map(time_series)
    
    If return_map.return_times.size == 0:
        Return false
    
    If return_map.return_values.size != return_map.return_times.size:
        Return false
    
    Let mean_return_time be Statistics.calculate_arithmetic_mean(return_map.return_times)
    If not assert_positive(mean_return_time):
        Return false
    
    Return true

Process called "test_power_spectrum_analysis" that takes returns Boolean:
    Note: Tests power spectral analysis for chaotic time series
    Let mixed_series be generate_mixed_frequency_series(1024, [1.0, 3.0, 7.0], [1.0, 0.5, 0.3])
    
    Let power_spectrum be Chaos.compute_power_spectrum(mixed_series)
    
    If power_spectrum.frequencies.size != power_spectrum.power_values.size:
        Return false
    
    If power_spectrum.frequencies.size < 512:
        Return false
    
    Let peak_frequencies be Chaos.find_spectral_peaks(power_spectrum)
    If peak_frequencies.size < 3:
        Return false
    
    Return true

Note: ===== Chaotic System Identification =====

Process called "test_chaos_detection" that takes returns Boolean:
    Note: Tests automatic detection of chaotic behavior in time series
    Let chaotic_series be generate_logistic_time_series(3.99, 1000)
    Let periodic_series be generate_logistic_time_series(3.2, 1000)
    Let random_series be generate_random_time_series(1000, 123)
    
    Let chaotic_result be Chaos.detect_chaos(chaotic_series)
    Let periodic_result be Chaos.detect_chaos(periodic_series)
    Let random_result be Chaos.detect_chaos(random_series)
    
    If not chaotic_result.is_chaotic:
        Return false
    
    If chaotic_result.largest_lyapunov_exponent <= 0.0:
        Return false
    
    If periodic_result.is_chaotic:
        Return false
    
    If random_result.is_chaotic:
        Return false
    
    If not assert_in_range(chaotic_result.predictability_horizon, 5.0, 20.0):
        Return false
    
    Return true

Process called "test_attractor_classification" that takes returns Boolean:
    Note: Tests classification of different attractor types
    Let fixed_point_series be generate_damped_oscillator_series(1000)
    Let limit_cycle_series be generate_van_der_pol_series(1000)
    Let strange_attractor_series be generate_lorenz_time_series(10.0, 28.0, 8.0/3.0, 50.0, 0.01)
    
    Let fixed_point_class be Chaos.classify_attractor(fixed_point_series)
    Let limit_cycle_class be Chaos.classify_attractor(limit_cycle_series)
    Let strange_attractor_class be Chaos.classify_attractor(strange_attractor_series)
    
    If fixed_point_class.attractor_type != "fixed_point":
        Return false
    
    If limit_cycle_class.attractor_type != "limit_cycle":
        Return false
    
    If strange_attractor_class.attractor_type != "strange_attractor":
        Return false
    
    If not assert_positive(strange_attractor_class.fractal_dimension):
        Return false
    
    Return true

Note: ===== Nonlinear Dynamics Tests =====

Process called "test_phase_space_reconstruction" that takes returns Boolean:
    Note: Tests optimal phase space reconstruction parameters
    Let time_series be generate_lorenz_time_series(10.0, 28.0, 8.0/3.0, 50.0, 0.01)
    
    Let optimal_delay be Chaos.compute_optimal_delay(time_series)
    Let optimal_dimension be Chaos.compute_optimal_embedding_dimension(time_series, optimal_delay)
    
    If not assert_in_range(optimal_delay, 5.0, 15.0):
        Return false
    
    If not assert_in_range(MathOps.integer_to_float(optimal_dimension), 2.0, 4.0):
        Return false
    
    Let reconstructed_attractor be Chaos.reconstruct_attractor(time_series, optimal_dimension, optimal_delay)
    
    If reconstructed_attractor.embedding_vectors.size == 0:
        Return false
    
    Return true

Process called "test_mutual_information" that takes returns Boolean:
    Note: Tests mutual information calculation for delay selection
    Let time_series be generate_henon_time_series(1.4, 0.3, 1000)
    Let max_delay be 20
    
    Let mutual_info be Chaos.compute_mutual_information(time_series, max_delay)
    
    If mutual_info.size != max_delay:
        Return false
    
    If mutual_info[0] < mutual_info[1]:
        Return false
    
    Let first_minimum be Chaos.find_first_minimum(mutual_info)
    If not assert_in_range(MathOps.integer_to_float(first_minimum), 1.0, 10.0):
        Return false
    
    Return true

Process called "test_false_nearest_neighbors" that takes returns Boolean:
    Note: Tests false nearest neighbors method for embedding dimension
    Let time_series be generate_lorenz_time_series(10.0, 28.0, 8.0/3.0, 30.0, 0.01)
    Let delay be 8
    Let max_dimension be 10
    
    Let fnn_results be Chaos.compute_false_nearest_neighbors(time_series, delay, max_dimension)
    
    If fnn_results.size != max_dimension:
        Return false
    
    Let first_zero_fnn be -1
    For i from 0 to fnn_results.size - 1:
        If fnn_results[i] < 0.01:
            first_zero_fnn = i
            Break
    
    If first_zero_fnn < 2 or first_zero_fnn > 6:
        Return false
    
    Return true

Note: ===== Advanced Chaos Analysis =====

Process called "test_generalized_dimensions" that takes returns Boolean:
    Note: Tests computation of generalized (R√©nyi) dimensions
    Let attractor_points be generate_sierpinski_triangle(1000)
    Let q_values be [-2.0, 0.0, 1.0, 2.0, 5.0]
    
    Let generalized_dims be Chaos.compute_generalized_dimensions(attractor_points, q_values)
    
    If generalized_dims.size != q_values.size:
        Return false
    
    For i from 0 to generalized_dims.size - 2:
        If generalized_dims[i] < generalized_dims[i + 1]:
            Return false
    
    Let d0 be generalized_dims[2]
    If not assert_in_range(d0, 1.5, 1.7):
        Return false
    
    Return true

Process called "test_multifractal_analysis" that takes returns Boolean:
    Note: Tests multifractal spectrum analysis
    Let multifractal_series be generate_multifractal_cascade(512, 0.7, 0.3)
    
    Let multifractal_spectrum be Chaos.compute_multifractal_spectrum(multifractal_series)
    
    If multifractal_spectrum.alpha_values.size == 0:
        Return false
    
    If multifractal_spectrum.f_alpha_values.size != multifractal_spectrum.alpha_values.size:
        Return false
    
    Let max_f_alpha be Statistics.calculate_maximum(multifractal_spectrum.f_alpha_values)
    If not assert_in_range(max_f_alpha, 0.8, 1.2):
        Return false
    
    Return true

Note: ===== Performance Tests =====

Process called "test_computation_performance" that takes returns Boolean:
    Note: Tests performance of chaos analysis computations
    Let large_series be generate_lorenz_time_series(10.0, 28.0, 8.0/3.0, 100.0, 0.001)
    
    Let start_time be SystemTime.current_timestamp_microseconds()
    
    Let largest_lyapunov be Chaos.compute_largest_lyapunov_exponent(large_series)
    
    Let end_time be SystemTime.current_timestamp_microseconds()
    Let computation_time_ms be MathOps.integer_to_float(end_time - start_time) / 1000.0
    
    If computation_time_ms > 500.0:
        Return false
    
    If not assert_positive(largest_lyapunov):
        Return false
    
    Let start_correlation_time be SystemTime.current_timestamp_microseconds()
    
    Let attractor be Chaos.reconstruct_attractor(large_series, 3, 10)
    Let correlation_dim be Chaos.compute_correlation_dimension(attractor)
    
    Let end_correlation_time be SystemTime.current_timestamp_microseconds()
    Let correlation_time_ms be MathOps.integer_to_float(end_correlation_time - start_correlation_time) / 1000.0
    
    If correlation_time_ms > 1000.0:
        Return false
    
    If not assert_positive(correlation_dim):
        Return false
    
    Return true

Note: ===== Helper Functions for Test Data Generation =====

Process called "generate_cantor_set_approximation" that takes iterations as Integer returns List[Float64]:
    Let points be [0.0, 1.0]
    
    For iteration from 0 to iterations - 1:
        Let new_points be MathOps.create_empty_list(points.size * 2)
        Let point_index be 0
        
        For i from 0 to points.size - 1 step 2:
            Let left be points[i]
            Let right be points[i + 1]
            Let third be (right - left) / 3.0
            
            new_points[point_index] = left
            new_points[point_index + 1] = left + third
            new_points[point_index + 2] = right - third
            new_points[point_index + 3] = right
            point_index = point_index + 4
        
        points = new_points
    
    Return points

Process called "generate_random_time_series" that takes length as Integer, seed as Integer returns List[Float64]:
    Let series be MathOps.create_empty_list(length)
    Let current_seed be seed
    
    For i from 0 to length - 1:
        current_seed = (current_seed * 1103515245 + 12345) % 2147483648
        Let random_value be MathOps.integer_to_float(current_seed) / 2147483647.0
        series[i] = random_value
    
    Return series

Process called "generate_sine_series" that takes length as Integer, frequency as Float64, noise_amplitude as Float64 returns List[Float64]:
    Let series be MathOps.create_empty_list(length)
    Let dt be 0.01
    
    For i from 0 to length - 1:
        Let t be MathOps.integer_to_float(i) * dt
        Let sine_value be MathOps.sine(2.0 * MathOps.pi() * frequency * t)
        Let noise be noise_amplitude * (MathOps.random_float() - 0.5)
        series[i] = sine_value + noise
    
    Return series

Note: ===== Main Test Runner =====

Process called "run_all_chaos_tests" that takes returns Tuple[Integer, Integer]:
    Note: Runs all chaos theory tests and returns [passed, total] counts
    
    Let test_results be MathOps.create_empty_list(20)
    Let test_names be [
        "Lyapunov Exponent Computation",
        "Largest Lyapunov Exponent",
        "Lyapunov Dimension",
        "Attractor Reconstruction",
        "Correlation Dimension",
        "Attractor Characterization",
        "Box-counting Dimension",
        "Hausdorff Dimension",
        "Capacity Dimension",
        "Kolmogorov-Sinai Entropy",
        "Approximate Entropy",
        "Sample Entropy",
        "Recurrence Plot",
        "Poincar√© Return Map",
        "Power Spectrum Analysis",
        "Chaos Detection",
        "Attractor Classification",
        "Phase Space Reconstruction",
        "Mutual Information",
        "False Nearest Neighbors",
        "Generalized Dimensions",
        "Multifractal Analysis",
        "Computation Performance"
    ]
    
    test_results[0] = test_lyapunov_exponent_computation()
    test_results[1] = test_largest_lyapunov_exponent()
    test_results[2] = test_lyapunov_dimension()
    test_results[3] = test_attractor_reconstruction()
    test_results[4] = test_correlation_dimension()
    test_results[5] = test_attractor_characterization()
    test_results[6] = test_box_counting_dimension()
    test_results[7] = test_hausdorff_dimension()
    test_results[8] = test_capacity_dimension()
    test_results[9] = test_kolmogorov_sinai_entropy()
    test_results[10] = test_approximate_entropy()
    test_results[11] = test_sample_entropy()
    test_results[12] = test_recurrence_plot()
    test_results[13] = test_poincare_return_map()
    test_results[14] = test_power_spectrum_analysis()
    test_results[15] = test_chaos_detection()
    test_results[16] = test_attractor_classification()
    test_results[17] = test_phase_space_reconstruction()
    test_results[18] = test_mutual_information()
    test_results[19] = test_false_nearest_neighbors()
    test_results[20] = test_generalized_dimensions()
    test_results[21] = test_multifractal_analysis()
    test_results[22] = test_computation_performance()
    
    Let passed_count be 0
    Let total_count be test_results.size
    
    For i from 0 to total_count - 1:
        If test_results[i]:
            passed_count = passed_count + 1
            Let test_status be "PASSED"
            MathOps.print_string(test_names[i] + ": " + test_status)
        Otherwise:
            Let test_status be "FAILED"
            MathOps.print_string(test_names[i] + ": " + test_status)
    
    MathOps.print_string("Chaos Theory Tests: " + MathOps.integer_to_string(passed_count) + " / " + MathOps.integer_to_string(total_count) + " passed")
    
    Return [passed_count, total_count]