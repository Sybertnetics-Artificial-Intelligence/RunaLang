Note: Comprehensive Unit Tests for Dynamical Systems Module

This module provides comprehensive testing for the dynamical systems analysis
functionality, including continuous and discrete systems, phase portraits, 
stability analysis, eigenvalue computation, linearization, and flow analysis.

Test Coverage:
- System creation and initialization
- Phase portrait generation and analysis
- Stability analysis and classification
- Eigenvalue computation and analysis
- System linearization around equilibria
- Flow analysis and trajectory computation
- Poincaré maps and discrete dynamics
- Lyapunov stability analysis
- Numerical integration accuracy
- Performance benchmarking

Mathematical Foundations Tested:
- Linear stability theory
- Phase space analysis
- Autonomous and non-autonomous systems
- Hamiltonian and dissipative dynamics
- Attracting and repelling sets
- Invariant manifolds and foliations

:End Note

Import "math/dynamical/systems" as DynamicalSystems
Import "math/core/operations" as MathOps
Import "math/algebra/linear" as LinearAlgebra
Import "math/engine/linalg/decomposition" as Decomposition
Import "math/engine/numerical/integration" as Integration
Import "os/system/time" as SystemTime

Note: ===== Test Helper Functions =====

Process called "assert_equal" that takes actual as Float64, expected as Float64, tolerance as Float64 returns Boolean:
    Let difference be MathOps.absolute_value(actual - expected)
    Return difference <= tolerance

Process called "assert_vector_equal" that takes actual as List[Float64], expected as List[Float64], tolerance as Float64 returns Boolean:
    If actual.size != expected.size:
        Return false
    
    For i from 0 to actual.size - 1:
        If not assert_equal(actual[i], expected[i], tolerance):
            Return false
    
    Return true

Process called "assert_matrix_equal" that takes actual as List[List[Float64]], expected as List[List[Float64]], tolerance as Float64 returns Boolean:
    If actual.size != expected.size:
        Return false
    
    For i from 0 to actual.size - 1:
        If not assert_vector_equal(actual[i], expected[i], tolerance):
            Return false
    
    Return true

Process called "assert_complex_equal" that takes actual as Complex64, expected as Complex64, tolerance as Float64 returns Boolean:
    Let real_equal be assert_equal(actual.real, expected.real, tolerance)
    Let imag_equal be assert_equal(actual.imaginary, expected.imaginary, tolerance)
    Return real_equal and imag_equal

Process called "create_test_linear_system" that takes returns Function:
    Return (state: List[Float64]) => [state[1], -state[0]]

Process called "create_test_nonlinear_system" that takes returns Function:
    Return (state: List[Float64]) => [state[0] * (1.0 - state[0] - state[1]), state[1] * (0.5 - state[1] - 0.75 * state[0])]

Process called "create_test_hamiltonian_system" that takes returns Function:
    Return (state: List[Float64]) => [state[1], -MathOps.sine(state[0])]

Process called "create_test_lorenz_system" that takes sigma as Float64, rho as Float64, beta as Float64 returns Function:
    Return (state: List[Float64]) => [
        sigma * (state[1] - state[0]),
        state[0] * (rho - state[2]) - state[1],
        state[0] * state[1] - beta * state[2]
    ]

Note: ===== Dynamical System Creation Tests =====

Process called "test_continuous_system_creation" that takes returns Boolean:
    Note: Tests creation and initialization of continuous dynamical systems
    Let system_function be create_test_linear_system()
    Let initial_state be [1.0, 0.0]
    Let time_span be [0.0, 10.0]
    
    Let system be DynamicalSystems.create_continuous_system(system_function, initial_state, time_span)
    
    If not assert_vector_equal(system.initial_conditions, initial_state, 1e-12):
        Return false
    
    If not assert_equal(system.time_span.0, 0.0, 1e-12):
        Return false
    
    If not assert_equal(system.time_span.1, 10.0, 1e-12):
        Return false
    
    If system.system_type != "continuous":
        Return false
    
    Return true

Process called "test_discrete_system_creation" that takes returns Boolean:
    Note: Tests creation of discrete dynamical systems and iterative maps
    Let map_function be (state: List[Float64]) => [3.8 * state[0] * (1.0 - state[0])]
    Let initial_state be [0.5]
    Let iterations be 100
    
    Let system be DynamicalSystems.create_discrete_system(map_function, initial_state, iterations)
    
    If not assert_vector_equal(system.initial_conditions, initial_state, 1e-12):
        Return false
    
    If system.max_iterations != iterations:
        Return false
    
    If system.system_type != "discrete":
        Return false
    
    Return true

Process called "test_hamiltonian_system_creation" that takes returns Boolean:
    Note: Tests creation of Hamiltonian systems with energy conservation
    Let pendulum_system be create_test_hamiltonian_system()
    Let initial_state be [0.5, 0.0]
    Let time_span be [0.0, 6.28]
    
    Let system be DynamicalSystems.create_hamiltonian_system(pendulum_system, initial_state, time_span)
    
    If not system.is_conservative:
        Return false
    
    If system.hamiltonian_function == null:
        Return false
    
    Let energy_initial be DynamicalSystems.compute_hamiltonian_energy(system, initial_state)
    If not assert_equal(energy_initial, 0.125, 1e-6):
        Return false
    
    Return true

Note: ===== Phase Portrait Analysis Tests =====

Process called "test_phase_portrait_generation" that takes returns Boolean:
    Note: Tests phase portrait generation and vector field visualization
    Let system_function be create_test_nonlinear_system()
    Let x_range be [-0.5, 2.0]
    Let y_range be [-0.5, 1.5]
    Let grid_resolution be 20
    
    Let phase_portrait be DynamicalSystems.generate_phase_portrait(system_function, x_range, y_range, grid_resolution)
    
    If phase_portrait.vector_field.size != grid_resolution * grid_resolution:
        Return false
    
    If phase_portrait.grid_points.size != grid_resolution * grid_resolution:
        Return false
    
    If not assert_equal(phase_portrait.x_range.0, -0.5, 1e-12):
        Return false
    
    If not assert_equal(phase_portrait.y_range.1, 1.5, 1e-12):
        Return false
    
    Return true

Process called "test_equilibrium_point_detection" that takes returns Boolean:
    Note: Tests detection and classification of equilibrium points
    Let system_function be create_test_nonlinear_system()
    Let search_region be [[-1.0, 3.0], [-1.0, 2.0]]
    
    Let equilibria be DynamicalSystems.find_equilibrium_points(system_function, search_region)
    
    If equilibria.size < 1:
        Return false
    
    Let origin_equilibrium be [0.0, 0.0]
    Let coexistence_equilibrium be [0.25, 0.25]
    
    Let origin_found be false
    Let coexistence_found be false
    
    For equilibrium in equilibria:
        If assert_vector_equal(equilibrium.position, origin_equilibrium, 1e-6):
            origin_found = true
            If equilibrium.stability_type != "unstable":
                Return false
        
        If assert_vector_equal(equilibrium.position, coexistence_equilibrium, 1e-6):
            coexistence_found = true
            If equilibrium.stability_type != "stable":
                Return false
    
    Return origin_found and coexistence_found

Process called "test_nullcline_computation" that takes returns Boolean:
    Note: Tests computation of nullclines and their intersections
    Let system_function be create_test_nonlinear_system()
    Let domain be [[-0.5, 2.0], [-0.5, 1.5]]
    
    Let nullclines be DynamicalSystems.compute_nullclines(system_function, domain)
    
    If nullclines.x_nullclines.size == 0:
        Return false
    
    If nullclines.y_nullclines.size == 0:
        Return false
    
    Let intersection_points be DynamicalSystems.find_nullcline_intersections(nullclines)
    
    If intersection_points.size < 2:
        Return false
    
    Return true

Note: ===== Stability Analysis Tests =====

Process called "test_linear_stability_analysis" that takes returns Boolean:
    Note: Tests linear stability analysis around equilibrium points
    Let system_function be create_test_nonlinear_system()
    Let equilibrium be [0.0, 0.0]
    
    Let stability_result be DynamicalSystems.analyze_linear_stability(system_function, equilibrium)
    
    If not assert_equal(stability_result.jacobian[0][0], 1.0, 1e-12):
        Return false
    
    If not assert_equal(stability_result.jacobian[1][1], 0.5, 1e-12):
        Return false
    
    If stability_result.stability_classification != "unstable_node":
        Return false
    
    Let eigenvalues be stability_result.eigenvalues
    If eigenvalues.size != 2:
        Return false
    
    For eigenvalue in eigenvalues:
        If eigenvalue.real <= 0.0:
            Return false
    
    Return true

Process called "test_lyapunov_stability" that takes returns Boolean:
    Note: Tests Lyapunov stability analysis and energy methods
    Let system_function be create_test_hamiltonian_system()
    Let equilibrium be [0.0, 0.0]
    
    Let lyapunov_result be DynamicalSystems.analyze_lyapunov_stability(system_function, equilibrium)
    
    If lyapunov_result.lyapunov_function == null:
        Return false
    
    If lyapunov_result.stability_type != "neutrally_stable":
        Return false
    
    Let lyapunov_derivative be lyapunov_result.derivative_along_trajectories
    If not assert_equal(lyapunov_derivative, 0.0, 1e-12):
        Return false
    
    Return true

Process called "test_basin_of_attraction" that takes returns Boolean:
    Note: Tests computation of basins of attraction for stable equilibria
    Let system_function be create_test_nonlinear_system()
    Let stable_equilibrium be [0.25, 0.25]
    Let test_region be [[0.0, 1.0], [0.0, 1.0]]
    
    Let basin be DynamicalSystems.compute_basin_of_attraction(system_function, stable_equilibrium, test_region)
    
    If basin.boundary_points.size == 0:
        Return false
    
    If basin.interior_points.size == 0:
        Return false
    
    Let test_point be [0.3, 0.3]
    If not DynamicalSystems.point_in_basin(basin, test_point):
        Return false
    
    Return true

Note: ===== Flow Analysis Tests =====

Process called "test_trajectory_integration" that takes returns Boolean:
    Note: Tests numerical integration of system trajectories
    Let system_function be create_test_linear_system()
    Let initial_state be [1.0, 0.0]
    Let time_span be [0.0, 6.28]
    Let time_step be 0.01
    
    Let trajectory be DynamicalSystems.integrate_trajectory(system_function, initial_state, time_span, time_step)
    
    If trajectory.time_points.size < 600:
        Return false
    
    If trajectory.state_history.size != trajectory.time_points.size:
        Return false
    
    Let final_state be trajectory.state_history[trajectory.state_history.size - 1]
    If not assert_vector_equal(final_state, [1.0, 0.0], 1e-3):
        Return false
    
    Return true

Process called "test_poincare_map" that takes returns Boolean:
    Note: Tests Poincaré map computation for periodic orbit analysis
    Let system_function be create_test_lorenz_system(10.0, 28.0, 8.0/3.0)
    Let poincare_section be DynamicalSystems.PlaneSection{normal: [0.0, 0.0, 1.0], point: [0.0, 0.0, 27.0]}
    Let initial_conditions be [[1.0, 1.0, 25.0], [-1.0, -1.0, 29.0]]
    
    Let poincare_map be DynamicalSystems.compute_poincare_map(system_function, poincare_section, initial_conditions)
    
    If poincare_map.intersections.size == 0:
        Return false
    
    If poincare_map.return_map == null:
        Return false
    
    For intersection in poincare_map.intersections:
        If not assert_equal(intersection.position[2], 27.0, 1e-6):
            Return false
    
    Return true

Process called "test_limit_cycle_detection" that takes returns Boolean:
    Note: Tests detection and analysis of limit cycles
    Let system_function be (state: List[Float64]) => [
        state[1] + state[0] * (1.0 - state[0] * state[0] - state[1] * state[1]),
        -state[0] + state[1] * (1.0 - state[0] * state[0] - state[1] * state[1])
    ]
    Let initial_states be [[0.1, 0.0], [2.0, 0.0], [0.5, 0.5]]
    
    Let limit_cycles be DynamicalSystems.detect_limit_cycles(system_function, initial_states)
    
    If limit_cycles.size != 1:
        Return false
    
    Let cycle be limit_cycles[0]
    If cycle.period < 6.0 or cycle.period > 7.0:
        Return false
    
    If cycle.stability != "stable":
        Return false
    
    Let radius_estimate be MathOps.square_root(cycle.representative_point[0] * cycle.representative_point[0] + cycle.representative_point[1] * cycle.representative_point[1])
    If not assert_equal(radius_estimate, 1.0, 1e-1):
        Return false
    
    Return true

Note: ===== Discrete System Tests =====

Process called "test_discrete_orbit_analysis" that takes returns Boolean:
    Note: Tests analysis of discrete system orbits and periodic points
    Let logistic_map be (state: List[Float64]) => [3.5 * state[0] * (1.0 - state[0])]
    Let initial_states be [0.1, 0.2, 0.7, 0.9]
    
    Let orbit_analysis be DynamicalSystems.analyze_discrete_orbits(logistic_map, initial_states, 100)
    
    If orbit_analysis.periodic_orbits.size == 0:
        Return false
    
    Let period_4_found be false
    For orbit in orbit_analysis.periodic_orbits:
        If orbit.period == 4:
            period_4_found = true
            If orbit.stability_multiplier.magnitude >= 1.0:
                Return false
    
    Return period_4_found

Process called "test_fixed_point_iteration" that takes returns Boolean:
    Note: Tests fixed point finding for discrete maps
    Let map_function be (state: List[Float64]) => [0.5 * (state[0] + 2.0 / state[0])]
    Let initial_guess be [1.5]
    
    Let fixed_point be DynamicalSystems.find_fixed_points_discrete(map_function, initial_guess)
    
    If fixed_point.size != 1:
        Return false
    
    Let sqrt2_approx be fixed_point[0].position[0]
    If not assert_equal(sqrt2_approx, MathOps.square_root(2.0), 1e-10):
        Return false
    
    If fixed_point[0].stability_type != "stable":
        Return false
    
    Return true

Process called "test_cobweb_diagram" that takes returns Boolean:
    Note: Tests cobweb diagram generation for discrete map visualization
    Let map_function be (state: List[Float64]) => [2.8 * state[0] * (1.0 - state[0])]
    Let initial_state be [0.3]
    Let iterations be 20
    
    Let cobweb be DynamicalSystems.generate_cobweb_diagram(map_function, initial_state, iterations)
    
    If cobweb.orbit_points.size != iterations + 1:
        Return false
    
    If cobweb.cobweb_segments.size != 2 * iterations:
        Return false
    
    Let final_value be cobweb.orbit_points[iterations][0]
    Let fixed_point be 0.642857
    If not assert_equal(final_value, fixed_point, 1e-3):
        Return false
    
    Return true

Note: ===== Advanced Analysis Tests =====

Process called "test_manifold_computation" that takes returns Boolean:
    Note: Tests computation of stable and unstable manifolds
    Let system_function be (state: List[Float64]) => [state[0] + state[1], -0.5 * state[0] + 1.5 * state[1]]
    Let saddle_point be [0.0, 0.0]
    
    Let manifolds be DynamicalSystems.compute_invariant_manifolds(system_function, saddle_point)
    
    If manifolds.stable_manifold.curves.size == 0:
        Return false
    
    If manifolds.unstable_manifold.curves.size == 0:
        Return false
    
    Let stable_direction be manifolds.stable_manifold.eigenvector
    Let unstable_direction be manifolds.unstable_manifold.eigenvector
    
    If not assert_equal(LinearAlgebra.dot_product(stable_direction, unstable_direction), 0.0, 1e-6):
        Return false
    
    Return true

Process called "test_center_manifold" that takes returns Boolean:
    Note: Tests center manifold computation for critical cases
    Let system_function be (state: List[Float64]) => [state[1], -state[0] + state[0] * state[0] * state[0]]
    Let equilibrium be [0.0, 0.0]
    
    Let center_manifold be DynamicalSystems.compute_center_manifold(system_function, equilibrium)
    
    If center_manifold.dimension != 2:
        Return false
    
    If center_manifold.local_coordinates.size == 0:
        Return false
    
    Let reduced_flow be center_manifold.reduced_dynamics
    If reduced_flow == null:
        Return false
    
    Return true

Process called "test_sensitivity_analysis" that takes returns Boolean:
    Note: Tests sensitivity analysis to initial conditions and parameters
    Let system_function be create_test_lorenz_system(10.0, 28.0, 8.0/3.0)
    Let reference_initial be [1.0, 1.0, 1.0]
    Let perturbed_initial be [1.0001, 1.0, 1.0]
    Let time_span be [0.0, 20.0]
    
    Let sensitivity be DynamicalSystems.analyze_sensitivity(system_function, reference_initial, perturbed_initial, time_span)
    
    If sensitivity.lyapunov_exponents.size != 3:
        Return false
    
    Let positive_exponent_found be false
    For exponent in sensitivity.lyapunov_exponents:
        If exponent > 0.0:
            positive_exponent_found = true
    
    If not positive_exponent_found:
        Return false
    
    If sensitivity.separation_growth_rate <= 0.0:
        Return false
    
    Return true

Note: ===== Performance and Accuracy Tests =====

Process called "test_integration_accuracy" that takes returns Boolean:
    Note: Tests accuracy of different numerical integration methods
    Let system_function be create_test_hamiltonian_system()
    Let initial_state be [0.1, 0.0]
    Let time_span be [0.0, 10.0]
    
    Let rk4_trajectory be DynamicalSystems.integrate_rk4(system_function, initial_state, time_span, 0.01)
    Let adaptive_trajectory be DynamicalSystems.integrate_adaptive(system_function, initial_state, time_span, 1e-8)
    
    Let energy_initial be 0.5 * initial_state[1] * initial_state[1] + 1.0 - MathOps.cosine(initial_state[0])
    
    Let final_state_rk4 be rk4_trajectory.state_history[rk4_trajectory.state_history.size - 1]
    Let energy_final_rk4 be 0.5 * final_state_rk4[1] * final_state_rk4[1] + 1.0 - MathOps.cosine(final_state_rk4[0])
    
    If not assert_equal(energy_initial, energy_final_rk4, 1e-3):
        Return false
    
    Let final_state_adaptive be adaptive_trajectory.state_history[adaptive_trajectory.state_history.size - 1]
    Let energy_final_adaptive be 0.5 * final_state_adaptive[1] * final_state_adaptive[1] + 1.0 - MathOps.cosine(final_state_adaptive[0])
    
    If not assert_equal(energy_initial, energy_final_adaptive, 1e-6):
        Return false
    
    Return true

Process called "test_performance_benchmarks" that takes returns Boolean:
    Note: Tests performance of core dynamical systems operations
    Let system_function be create_test_lorenz_system(10.0, 28.0, 8.0/3.0)
    Let initial_state be [1.0, 1.0, 1.0]
    Let time_span be [0.0, 5.0]
    
    Let start_time be SystemTime.current_timestamp_microseconds()
    
    Let trajectory be DynamicalSystems.integrate_trajectory(system_function, initial_state, time_span, 0.01)
    
    Let end_time be SystemTime.current_timestamp_microseconds()
    Let integration_time_ms be MathOps.integer_to_float(end_time - start_time) / 1000.0
    
    If integration_time_ms > 100.0:
        Return false
    
    Let start_stability_time be SystemTime.current_timestamp_microseconds()
    
    Let equilibrium be [0.0, 0.0, 0.0]
    Let stability_result be DynamicalSystems.analyze_linear_stability(system_function, equilibrium)
    
    Let end_stability_time be SystemTime.current_timestamp_microseconds()
    Let stability_time_ms be MathOps.integer_to_float(end_stability_time - start_stability_time) / 1000.0
    
    If stability_time_ms > 10.0:
        Return false
    
    Return true

Note: ===== Main Test Runner =====

Process called "run_all_systems_tests" that takes returns Tuple[Integer, Integer]:
    Note: Runs all dynamical systems tests and returns [passed, total] counts
    
    Let test_results be MathOps.create_empty_list(20)
    Let test_names be [
        "Continuous System Creation",
        "Discrete System Creation", 
        "Hamiltonian System Creation",
        "Phase Portrait Generation",
        "Equilibrium Point Detection",
        "Nullcline Computation",
        "Linear Stability Analysis",
        "Lyapunov Stability",
        "Basin of Attraction",
        "Trajectory Integration",
        "Poincaré Map",
        "Limit Cycle Detection",
        "Discrete Orbit Analysis",
        "Fixed Point Iteration",
        "Cobweb Diagram",
        "Manifold Computation",
        "Center Manifold",
        "Sensitivity Analysis",
        "Integration Accuracy",
        "Performance Benchmarks"
    ]
    
    test_results[0] = test_continuous_system_creation()
    test_results[1] = test_discrete_system_creation()
    test_results[2] = test_hamiltonian_system_creation()
    test_results[3] = test_phase_portrait_generation()
    test_results[4] = test_equilibrium_point_detection()
    test_results[5] = test_nullcline_computation()
    test_results[6] = test_linear_stability_analysis()
    test_results[7] = test_lyapunov_stability()
    test_results[8] = test_basin_of_attraction()
    test_results[9] = test_trajectory_integration()
    test_results[10] = test_poincare_map()
    test_results[11] = test_limit_cycle_detection()
    test_results[12] = test_discrete_orbit_analysis()
    test_results[13] = test_fixed_point_iteration()
    test_results[14] = test_cobweb_diagram()
    test_results[15] = test_manifold_computation()
    test_results[16] = test_center_manifold()
    test_results[17] = test_sensitivity_analysis()
    test_results[18] = test_integration_accuracy()
    test_results[19] = test_performance_benchmarks()
    
    Let passed_count be 0
    Let total_count be test_results.size
    
    For i from 0 to total_count - 1:
        If test_results[i]:
            passed_count = passed_count + 1
            Let test_status be "PASSED"
            MathOps.print_string(test_names[i] + ": " + test_status)
        Otherwise:
            Let test_status be "FAILED"
            MathOps.print_string(test_names[i] + ": " + test_status)
    
    MathOps.print_string("Dynamical Systems Tests: " + MathOps.integer_to_string(passed_count) + " / " + MathOps.integer_to_string(total_count) + " passed")
    
    Return [passed_count, total_count]