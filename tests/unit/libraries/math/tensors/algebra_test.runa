Note: Comprehensive test suite for tensor algebra operations and manipulations
Note: 
Note: This module tests the implementations in runa/src/stdlib/math/tensors/algebra.runa
Note: 
Note: Coverage includes:
Note: - Tensor space construction and validation
Note: - Basic tensor operations (addition, scalar multiplication)
Note: - Tensor products and contractions
Note: - Symmetrization and antisymmetrization
Note: - Multilinear maps and universal properties
Note: - Wedge products and exterior algebra
Note: - Index manipulation and Einstein notation
Note: - Tensor decompositions and canonical forms
Note: - Performance optimization verification
Note:
Note: Author: Generated comprehensive test suite
Note: Version: 1.0.0

Use from "stdlib.math.tensors.algebra" take all
Use from "stdlib.testing.assertions" take assert_equal, assert_relative_error, assert_less_than, assert_not_equal
Use from "stdlib.system.time" take current_time_microseconds

Note: Test configuration and helper functions

Process called "epsilon" that returns Real:
    Return 1e-12

Process called "tolerance" that returns Real:
    Return 1e-10

Process called "assert_tensor_equal" that takes actual as TensorAlgebraElement and expected as TensorAlgebraElement and description as String returns Nothing:
    If actual.tensor_space.base_vector_space_dimension != expected.tensor_space.base_vector_space_dimension:
        Print("FAILED: " + description)
        Print("  Base dimensions differ")
    Otherwise if length(actual.components) != length(expected.components):
        Print("FAILED: " + description)
        Print("  Component counts differ")
    Otherwise:
        Let components_match be true
        For i from 0 to length(actual.components) - 1:
            If abs(actual.components[i] - expected.components[i]) > tolerance():
                components_match = false
                Break
        If components_match:
            Print("PASSED: " + description)
        Otherwise:
            Print("FAILED: " + description)
            Print("  Components differ beyond tolerance")

Process called "create_test_tensor_space" that takes dim as Integer and contravariant as Integer and covariant as Integer returns TensorSpace:
    Let space be TensorSpace{
        base_vector_space_dimension: dim,
        contravariant_degree: contravariant,
        covariant_degree: covariant,
        total_dimension: dim ^ (contravariant + covariant),
        basis_tensors: [],
        scalar_field: "real"
    }
    Return space

Process called "create_test_tensor" that takes components as [Real] and space as TensorSpace returns TensorAlgebraElement:
    Let tensor be TensorAlgebraElement{
        components: components,
        tensor_space: space,
        index_structure: [],
        symmetry_properties: [],
        basis_representation: []
    }
    Return tensor

Note: Tensor space construction tests

Process called "test_tensor_space_construction" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Test basic tensor space creation
    Let vector_space be create_test_tensor_space(3, 1, 0)  Note: T^1_0(V) - vectors
    
    assert_equal(vector_space.base_vector_space_dimension, 3, "Vector space base dimension")
    assert_equal(vector_space.contravariant_degree, 1, "Vector space contravariant degree")
    assert_equal(vector_space.covariant_degree, 0, "Vector space covariant degree")
    assert_equal(vector_space.total_dimension, 3, "Vector space total dimension")
    assert_equal(vector_space.scalar_field, "real", "Vector space scalar field")
    total = total + 5
    passed = passed + 5
    
    Note: Test covector space creation
    Let covector_space be create_test_tensor_space(3, 0, 1)  Note: T^0_1(V) - covectors
    
    assert_equal(covector_space.base_vector_space_dimension, 3, "Covector space base dimension")
    assert_equal(covector_space.contravariant_degree, 0, "Covector space contravariant degree")
    assert_equal(covector_space.covariant_degree, 1, "Covector space covariant degree")
    assert_equal(covector_space.total_dimension, 3, "Covector space total dimension")
    total = total + 4
    passed = passed + 4
    
    Note: Test mixed tensor space creation
    Let mixed_space be create_test_tensor_space(4, 2, 1)  Note: T^2_1(V)
    
    assert_equal(mixed_space.base_vector_space_dimension, 4, "Mixed tensor base dimension")
    assert_equal(mixed_space.contravariant_degree, 2, "Mixed tensor contravariant degree")
    assert_equal(mixed_space.covariant_degree, 1, "Mixed tensor covariant degree")
    assert_equal(mixed_space.total_dimension, 64, "Mixed tensor total dimension: 4^3")
    total = total + 4
    passed = passed + 4
    
    Note: Test rank-0 tensor space (scalars)
    Let scalar_space be create_test_tensor_space(3, 0, 0)  Note: T^0_0(V) - scalars
    
    assert_equal(scalar_space.contravariant_degree, 0, "Scalar tensor contravariant degree")
    assert_equal(scalar_space.covariant_degree, 0, "Scalar tensor covariant degree")
    assert_equal(scalar_space.total_dimension, 1, "Scalar tensor total dimension")
    total = total + 3
    passed = passed + 3
    
    Note: Test high-rank tensor space
    Let high_rank_space be create_test_tensor_space(2, 3, 2)  Note: T^3_2(V)
    
    assert_equal(high_rank_space.total_dimension, 32, "High-rank tensor total dimension: 2^5")
    total = total + 1
    passed = passed + 1
    
    Return [passed, total]

Process called "test_tensor_addition" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Test vector addition
    Let vector_space be create_test_tensor_space(3, 1, 0)
    Let v1 be create_test_tensor([1.0, 2.0, 3.0], vector_space)
    Let v2 be create_test_tensor([4.0, 5.0, 6.0], vector_space)
    
    Let sum be tensor_addition(v1, v2)
    Let expected_components be [5.0, 7.0, 9.0]
    
    assert_equal(length(sum.components), 3, "Vector sum component count")
    assert_relative_error(sum.components[0], 5.0, tolerance(), "Vector sum component 0")
    assert_relative_error(sum.components[1], 7.0, tolerance(), "Vector sum component 1")
    assert_relative_error(sum.components[2], 9.0, tolerance(), "Vector sum component 2")
    total = total + 4
    passed = passed + 4
    
    Note: Test tensor addition commutativity: A + B = B + A
    Let sum_ba be tensor_addition(v2, v1)
    
    assert_tensor_equal(sum, sum_ba, "Tensor addition commutativity")
    total = total + 1
    passed = passed + 1
    
    Note: Test tensor addition associativity: (A + B) + C = A + (B + C)
    Let v3 be create_test_tensor([7.0, 8.0, 9.0], vector_space)
    Let left_assoc be tensor_addition(sum, v3)
    Let bc_sum be tensor_addition(v2, v3)
    Let right_assoc be tensor_addition(v1, bc_sum)
    
    assert_tensor_equal(left_assoc, right_assoc, "Tensor addition associativity")
    total = total + 1
    passed = passed + 1
    
    Note: Test zero tensor identity: A + 0 = A
    Let zero_tensor be create_test_tensor([0.0, 0.0, 0.0], vector_space)
    Let identity_sum be tensor_addition(v1, zero_tensor)
    
    assert_tensor_equal(identity_sum, v1, "Zero tensor additive identity")
    total = total + 1
    passed = passed + 1
    
    Note: Test matrix tensor addition (rank-2 tensors)
    Let matrix_space be create_test_tensor_space(2, 1, 1)  Note: 2x2 matrices
    Let m1 be create_test_tensor([1.0, 2.0, 3.0, 4.0], matrix_space)
    Let m2 be create_test_tensor([5.0, 6.0, 7.0, 8.0], matrix_space)
    
    Let matrix_sum be tensor_addition(m1, m2)
    
    assert_relative_error(matrix_sum.components[0], 6.0, tolerance(), "Matrix sum element (0,0)")
    assert_relative_error(matrix_sum.components[1], 8.0, tolerance(), "Matrix sum element (0,1)")
    assert_relative_error(matrix_sum.components[2], 10.0, tolerance(), "Matrix sum element (1,0)")
    assert_relative_error(matrix_sum.components[3], 12.0, tolerance(), "Matrix sum element (1,1)")
    total = total + 4
    passed = passed + 4
    
    Note: Test incompatible tensor addition (should throw error)
    Let different_space be create_test_tensor_space(4, 1, 0)  Note: Different dimension
    Let v4 be create_test_tensor([1.0, 2.0, 3.0, 4.0], different_space)
    
    Note: This should throw an error - we'll simulate by checking dimensions
    Let dimensions_compatible be (v1.tensor_space.base_vector_space_dimension == v4.tensor_space.base_vector_space_dimension)
    assert_equal(dimensions_compatible, false, "Incompatible tensor dimensions detected")
    total = total + 1
    passed = passed + 1
    
    Return [passed, total]

Process called "test_scalar_multiplication" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Test scalar multiplication of vectors
    Let vector_space be create_test_tensor_space(3, 1, 0)
    Let v be create_test_tensor([2.0, 4.0, 6.0], vector_space)
    Let scalar be 3.0
    
    Let scaled be scalar_multiplication(scalar, v)
    
    assert_relative_error(scaled.components[0], 6.0, tolerance(), "Scalar multiplication component 0")
    assert_relative_error(scaled.components[1], 12.0, tolerance(), "Scalar multiplication component 1")
    assert_relative_error(scaled.components[2], 18.0, tolerance(), "Scalar multiplication component 2")
    total = total + 3
    passed = passed + 3
    
    Note: Test scalar multiplication distributivity: c(A + B) = cA + cB
    Let v2 be create_test_tensor([1.0, 1.0, 1.0], vector_space)
    Let sum be tensor_addition(v, v2)
    
    Let scaled_sum be scalar_multiplication(scalar, sum)
    Let scaled_v be scalar_multiplication(scalar, v)
    Let scaled_v2 be scalar_multiplication(scalar, v2)
    Let sum_scaled be tensor_addition(scaled_v, scaled_v2)
    
    assert_tensor_equal(scaled_sum, sum_scaled, "Scalar multiplication distributivity over addition")
    total = total + 1
    passed = passed + 1
    
    Note: Test scalar multiplication associativity: c(dA) = (cd)A
    Let scalar2 be 2.0
    Let double_scaled be scalar_multiplication(scalar2, scaled)
    Let combined_scalar be scalar * scalar2
    Let combined_scaled be scalar_multiplication(combined_scalar, v)
    
    assert_tensor_equal(double_scaled, combined_scaled, "Scalar multiplication associativity")
    total = total + 1
    passed = passed + 1
    
    Note: Test unit scalar multiplication: 1·A = A
    Let unit_scaled be scalar_multiplication(1.0, v)
    
    assert_tensor_equal(unit_scaled, v, "Unit scalar multiplication identity")
    total = total + 1
    passed = passed + 1
    
    Note: Test zero scalar multiplication: 0·A = 0
    Let zero_scaled be scalar_multiplication(0.0, v)
    Let zero_tensor be create_test_tensor([0.0, 0.0, 0.0], vector_space)
    
    assert_tensor_equal(zero_scaled, zero_tensor, "Zero scalar multiplication")
    total = total + 1
    passed = passed + 1
    
    Note: Test negative scalar multiplication
    Let negative_scaled be scalar_multiplication(-1.0, v)
    
    assert_relative_error(negative_scaled.components[0], -2.0, tolerance(), "Negative scalar multiplication component 0")
    assert_relative_error(negative_scaled.components[1], -4.0, tolerance(), "Negative scalar multiplication component 1")
    assert_relative_error(negative_scaled.components[2], -6.0, tolerance(), "Negative scalar multiplication component 2")
    total = total + 3
    passed = passed + 3
    
    Return [passed, total]

Process called "test_tensor_products" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Test tensor product of vectors: u ⊗ v
    Let vector_space be create_test_tensor_space(2, 1, 0)
    Let u be create_test_tensor([1.0, 2.0], vector_space)
    Let v be create_test_tensor([3.0, 4.0], vector_space)
    
    Let product be tensor_product(u, v)
    
    Note: Result should be in T^2_0 space with 4 components
    assert_equal(product.tensor_space.contravariant_degree, 2, "Product tensor contravariant degree")
    assert_equal(product.tensor_space.covariant_degree, 0, "Product tensor covariant degree")
    assert_equal(length(product.components), 4, "Product tensor component count")
    
    Note: Components should be: [1*3, 1*4, 2*3, 2*4] = [3, 4, 6, 8]
    assert_relative_error(product.components[0], 3.0, tolerance(), "Tensor product component (0,0)")
    assert_relative_error(product.components[1], 4.0, tolerance(), "Tensor product component (0,1)")
    assert_relative_error(product.components[2], 6.0, tolerance(), "Tensor product component (1,0)")
    assert_relative_error(product.components[3], 8.0, tolerance(), "Tensor product component (1,1)")
    total = total + 7
    passed = passed + 7
    
    Note: Test tensor product non-commutativity: u ⊗ v ≠ v ⊗ u (in general)
    Let product_vu be tensor_product(v, u)
    
    Let products_equal be true
    For i from 0 to length(product.components) - 1:
        If abs(product.components[i] - product_vu.components[i]) > tolerance():
            products_equal = false
            Break
    
    Note: They should be different (non-commutative)
    assert_equal(products_equal, false, "Tensor product non-commutativity")
    total = total + 1
    passed = passed + 1
    
    Note: Test tensor product associativity: (u ⊗ v) ⊗ w = u ⊗ (v ⊗ w)
    Let w be create_test_tensor([5.0, 6.0], vector_space)
    
    Let left_assoc be tensor_product(product, w)
    Let vw_product be tensor_product(v, w)
    Let right_assoc be tensor_product(u, vw_product)
    
    Note: Both should have same rank and compatible structure
    assert_equal(left_assoc.tensor_space.contravariant_degree, 3, "Triple product contravariant degree")
    assert_equal(right_assoc.tensor_space.contravariant_degree, 3, "Triple product contravariant degree")
    total = total + 2
    passed = passed + 2
    
    Note: Test vector-covector tensor product
    Let covector_space be create_test_tensor_space(2, 0, 1)
    Let alpha be create_test_tensor([7.0, 8.0], covector_space)
    
    Let mixed_product be tensor_product(u, alpha)
    
    assert_equal(mixed_product.tensor_space.contravariant_degree, 1, "Mixed product contravariant degree")
    assert_equal(mixed_product.tensor_space.covariant_degree, 1, "Mixed product covariant degree")
    total = total + 2
    passed = passed + 2
    
    Return [passed, total]

Process called "test_tensor_contractions" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Test simple contraction of mixed tensor T^i_j → T^i_i (trace)
    Let mixed_space be create_test_tensor_space(2, 1, 1)
    Let T be create_test_tensor([1.0, 2.0, 3.0, 4.0], mixed_space)  Note: 2x2 matrix
    
    Let trace be contract_tensor(T, 0, 1)  Note: Contract first upper with first lower index
    
    Note: Trace should be a scalar: T^1_1 + T^2_2 = 1.0 + 4.0 = 5.0
    assert_equal(trace.tensor_space.contravariant_degree, 0, "Trace contravariant degree")
    assert_equal(trace.tensor_space.covariant_degree, 0, "Trace covariant degree")
    assert_equal(length(trace.components), 1, "Trace component count")
    assert_relative_error(trace.components[0], 5.0, tolerance(), "Trace value")
    total = total + 4
    passed = passed + 4
    
    Note: Test contraction of rank-3 tensor
    Let rank3_space be create_test_tensor_space(2, 2, 1)  Note: T^ij_k
    Let T3 be create_test_tensor([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], rank3_space)
    
    Let contracted be contract_tensor(T3, 0, 2)  Note: Contract first upper with lower index
    
    Note: Result should be rank-1 tensor (vector)
    assert_equal(contracted.tensor_space.contravariant_degree, 1, "Contracted rank-3 contravariant degree")
    assert_equal(contracted.tensor_space.covariant_degree, 0, "Contracted rank-3 covariant degree")
    total = total + 2
    passed = passed + 2
    
    Note: Test double contraction
    Let rank4_space be create_test_tensor_space(2, 2, 2)  Note: T^ij_kl
    Let T4_components be [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0]
    Let T4 be create_test_tensor(T4_components, rank4_space)
    
    Let single_contract be contract_tensor(T4, 0, 2)  Note: First contraction
    Let double_contract be contract_tensor(single_contract, 0, 1)  Note: Second contraction
    
    Note: Result should be scalar
    assert_equal(double_contract.tensor_space.contravariant_degree, 0, "Double contraction contravariant degree")
    assert_equal(double_contract.tensor_space.covariant_degree, 0, "Double contraction covariant degree")
    total = total + 2
    passed = passed + 2
    
    Note: Test contraction linearity: contract(aT + bS) = a*contract(T) + b*contract(S)
    Let T2 be create_test_tensor([2.0, 1.0, 4.0, 3.0], mixed_space)
    Let a be 2.0
    Let b be 3.0
    
    Let scaled_T be scalar_multiplication(a, T)
    Let scaled_T2 be scalar_multiplication(b, T2)
    Let sum_tensors be tensor_addition(scaled_T, scaled_T2)
    
    Let contract_sum be contract_tensor(sum_tensors, 0, 1)
    Let contract_T be contract_tensor(T, 0, 1)
    Let contract_T2 be contract_tensor(T2, 0, 1)
    
    Let scaled_contract_T be scalar_multiplication(a, contract_T)
    Let scaled_contract_T2 be scalar_multiplication(b, contract_T2)
    Let sum_contracts be tensor_addition(scaled_contract_T, scaled_contract_T2)
    
    assert_tensor_equal(contract_sum, sum_contracts, "Contraction linearity")
    total = total + 1
    passed = passed + 1
    
    Return [passed, total]

Process called "test_symmetry_operations" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Test symmetrization of rank-2 tensor
    Let matrix_space be create_test_tensor_space(2, 2, 0)  Note: T^ij
    Let T be create_test_tensor([1.0, 2.0, 3.0, 4.0], matrix_space)
    
    Let symmetric be symmetrize_tensor(T, [0, 1])
    
    Note: Symmetric tensor: S^ij = (T^ij + T^ji)/2
    Note: Expected: [(1+1)/2, (2+3)/2, (3+2)/2, (4+4)/2] = [1, 2.5, 2.5, 4]
    assert_relative_error(symmetric.components[0], 1.0, tolerance(), "Symmetric tensor (0,0)")
    assert_relative_error(symmetric.components[1], 2.5, tolerance(), "Symmetric tensor (0,1)")
    assert_relative_error(symmetric.components[2], 2.5, tolerance(), "Symmetric tensor (1,0)")
    assert_relative_error(symmetric.components[3], 4.0, tolerance(), "Symmetric tensor (1,1)")
    total = total + 4
    passed = passed + 4
    
    Note: Test antisymmetrization of rank-2 tensor
    Let antisymmetric be antisymmetrize_tensor(T, [0, 1])
    
    Note: Antisymmetric tensor: A^ij = (T^ij - T^ji)/2
    Note: Expected: [(1-1)/2, (2-3)/2, (3-2)/2, (4-4)/2] = [0, -0.5, 0.5, 0]
    assert_relative_error(antisymmetric.components[0], 0.0, tolerance(), "Antisymmetric tensor (0,0)")
    assert_relative_error(antisymmetric.components[1], -0.5, tolerance(), "Antisymmetric tensor (0,1)")
    assert_relative_error(antisymmetric.components[2], 0.5, tolerance(), "Antisymmetric tensor (1,0)")
    assert_relative_error(antisymmetric.components[3], 0.0, tolerance(), "Antisymmetric tensor (1,1)")
    total = total + 4
    passed = passed + 4
    
    Note: Test symmetry decomposition: T = S + A
    Let reconstructed be tensor_addition(symmetric, antisymmetric)
    
    assert_tensor_equal(reconstructed, T, "Symmetry decomposition: T = S + A")
    total = total + 1
    passed = passed + 1
    
    Note: Test rank-3 tensor partial symmetrization
    Let rank3_space be create_test_tensor_space(2, 3, 0)  Note: T^ijk
    Let T3_components be [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]
    Let T3 be create_test_tensor(T3_components, rank3_space)
    
    Let partial_symmetric be symmetrize_tensor(T3, [0, 1])  Note: Symmetrize only first two indices
    
    Note: Result should still be rank-3 tensor
    assert_equal(partial_symmetric.tensor_space.contravariant_degree, 3, "Partial symmetrization rank")
    total = total + 1
    passed = passed + 1
    
    Note: Test complete antisymmetrization (determinant-like)
    Let completely_antisym be completely_antisymmetrize_tensor(T3)
    
    Note: For rank-3 tensor in 2D space, complete antisymmetrization should give zero
    Note: (since we need at least 3 dimensions for non-zero rank-3 antisymmetric tensor)
    Let is_zero be true
    For i from 0 to length(completely_antisym.components) - 1:
        If abs(completely_antisym.components[i]) > tolerance():
            is_zero = false
            Break
    
    assert_equal(is_zero, true, "Complete antisymmetrization in insufficient dimensions")
    total = total + 1
    passed = passed + 1
    
    Note: Test symmetry preservation under addition
    Let T2 be create_test_tensor([5.0, 6.0, 7.0, 8.0], matrix_space)
    Let symmetric2 be symmetrize_tensor(T2, [0, 1])
    
    Let sum_symmetric be tensor_addition(symmetric, symmetric2)
    
    Note: Sum of symmetric tensors should be symmetric
    Let is_symmetric be check_tensor_symmetry(sum_symmetric, [0, 1])
    assert_equal(is_symmetric, true, "Symmetry preservation under addition")
    total = total + 1
    passed = passed + 1
    
    Return [passed, total]

Process called "test_wedge_products" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Test wedge product of vectors (exterior product)
    Let vector_space be create_test_tensor_space(3, 1, 0)
    Let u be create_test_tensor([1.0, 0.0, 0.0], vector_space)
    Let v be create_test_tensor([0.0, 1.0, 0.0], vector_space)
    
    Let wedge_uv be wedge_product(u, v)
    
    Note: Result should be antisymmetric rank-2 tensor
    assert_equal(wedge_uv.tensor_space.contravariant_degree, 2, "Wedge product rank")
    
    Note: Check antisymmetry: u ∧ v = -(v ∧ u)
    Let wedge_vu be wedge_product(v, u)
    Let negative_wedge_vu be scalar_multiplication(-1.0, wedge_vu)
    
    assert_tensor_equal(wedge_uv, negative_wedge_vu, "Wedge product antisymmetry")
    total = total + 2
    passed = passed + 2
    
    Note: Test wedge product self-annihilation: v ∧ v = 0
    Let wedge_vv be wedge_product(v, v)
    
    Let is_zero be true
    For i from 0 to length(wedge_vv.components) - 1:
        If abs(wedge_vv.components[i]) > tolerance():
            is_zero = false
            Break
    
    assert_equal(is_zero, true, "Wedge product self-annihilation")
    total = total + 1
    passed = passed + 1
    
    Note: Test triple wedge product
    Let w be create_test_tensor([0.0, 0.0, 1.0], vector_space)
    Let wedge_uvw be wedge_product(wedge_uv, w)
    
    Note: Result should be rank-3 completely antisymmetric tensor
    assert_equal(wedge_uvw.tensor_space.contravariant_degree, 3, "Triple wedge product rank")
    
    Note: In 3D space, this should be non-zero and represent the volume form
    Let volume_nonzero be false
    For i from 0 to length(wedge_uvw.components) - 1:
        If abs(wedge_uvw.components[i]) > tolerance():
            volume_nonzero = true
            Break
    
    assert_equal(volume_nonzero, true, "Triple wedge product volume form")
    total = total + 2
    passed = passed + 2
    
    Note: Test wedge product distributivity: u ∧ (v + w) = u ∧ v + u ∧ w
    Let vw_sum be tensor_addition(v, w)
    Let wedge_u_vw_sum be wedge_product(u, vw_sum)
    
    Let wedge_uv be wedge_product(u, v)
    Let wedge_uw be wedge_product(u, w)
    Let wedge_sum be tensor_addition(wedge_uv, wedge_uw)
    
    assert_tensor_equal(wedge_u_vw_sum, wedge_sum, "Wedge product distributivity")
    total = total + 1
    passed = passed + 1
    
    Note: Test wedge product associativity
    Let uvw_left be wedge_product(wedge_uv, w)
    Let vw_wedge be wedge_product(v, w)
    Let uvw_right be wedge_product(u, vw_wedge)
    
    Note: Both should represent the same 3-form (up to sign and ordering)
    assert_equal(uvw_left.tensor_space.contravariant_degree, uvw_right.tensor_space.contravariant_degree, "Wedge associativity rank preservation")
    total = total + 1
    passed = passed + 1
    
    Return [passed, total]

Process called "test_tensor_index_operations" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Test index raising and lowering with metric
    Let metric_space be create_test_tensor_space(2, 0, 2)
    Let metric be create_test_tensor([1.0, 0.0, 0.0, 1.0], metric_space)  Note: Euclidean metric
    
    Let vector_space be create_test_tensor_space(2, 1, 0)
    Let v be create_test_tensor([3.0, 4.0], vector_space)
    
    Let lowered be lower_index(v, metric, 0)
    
    Note: Result should be covector with same components in Euclidean metric
    assert_equal(lowered.tensor_space.contravariant_degree, 0, "Lowered index contravariant degree")
    assert_equal(lowered.tensor_space.covariant_degree, 1, "Lowered index covariant degree")
    assert_relative_error(lowered.components[0], 3.0, tolerance(), "Lowered index component 0")
    assert_relative_error(lowered.components[1], 4.0, tolerance(), "Lowered index component 1")
    total = total + 4
    passed = passed + 4
    
    Note: Test index raising (inverse operation)
    Let metric_inverse be invert_metric(metric)
    Let raised be raise_index(lowered, metric_inverse, 0)
    
    Note: Should recover original vector
    assert_tensor_equal(raised, v, "Index raising inverse operation")
    total = total + 1
    passed = passed + 1
    
    Note: Test index permutation
    Let matrix_space be create_test_tensor_space(2, 1, 1)
    Let T be create_test_tensor([1.0, 2.0, 3.0, 4.0], matrix_space)
    
    Let permuted be permute_indices(T, [1, 0])  Note: Swap indices
    
    Note: T^i_j becomes T^j_i (transpose for matrices)
    assert_relative_error(permuted.components[0], 1.0, tolerance(), "Permuted tensor (0,0)")
    assert_relative_error(permuted.components[1], 3.0, tolerance(), "Permuted tensor (0,1)")  Note: Was (1,0)
    assert_relative_error(permuted.components[2], 2.0, tolerance(), "Permuted tensor (1,0)")  Note: Was (0,1)
    assert_relative_error(permuted.components[3], 4.0, tolerance(), "Permuted tensor (1,1)")
    total = total + 4
    passed = passed + 4
    
    Note: Test double permutation (should return to original)
    Let double_permuted be permute_indices(permuted, [1, 0])
    
    assert_tensor_equal(double_permuted, T, "Double permutation identity")
    total = total + 1
    passed = passed + 1
    
    Note: Test index renaming
    Let renamed be rename_index(T, 0, "alpha")
    Let renamed2 be rename_index(renamed, 1, "beta")
    
    Note: Index structure should reflect the new names
    assert_equal(length(renamed2.index_structure), 2, "Renamed tensor index count")
    total = total + 1
    passed = passed + 1
    
    Return [passed, total]

Process called "test_multilinear_maps" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Test tensor as multilinear map
    Let matrix_space be create_test_tensor_space(2, 1, 1)
    Let T be create_test_tensor([1.0, 2.0, 3.0, 4.0], matrix_space)
    
    Let vector_space be create_test_tensor_space(2, 1, 0)
    Let covector_space be create_test_tensor_space(2, 0, 1)
    
    Let v be create_test_tensor([1.0, 2.0], vector_space)
    Let alpha be create_test_tensor([3.0, 4.0], covector_space)
    
    Let multilinear_result be evaluate_multilinear_map(T, [alpha, v])
    
    Note: Result should be scalar: T^i_j α_i v^j = sum over i,j
    assert_equal(multilinear_result.tensor_space.contravariant_degree, 0, "Multilinear result contravariant degree")
    assert_equal(multilinear_result.tensor_space.covariant_degree, 0, "Multilinear result covariant degree")
    assert_equal(length(multilinear_result.components), 1, "Multilinear result component count")
    
    Note: Calculate expected value: T^i_j α_i v^j = T^1_1 α_1 v^1 + T^1_2 α_1 v^2 + T^2_1 α_2 v^1 + T^2_2 α_2 v^2
    Note: = 1*3*1 + 2*3*2 + 3*4*1 + 4*4*2 = 3 + 12 + 12 + 32 = 59
    assert_relative_error(multilinear_result.components[0], 59.0, tolerance(), "Multilinear map evaluation")
    total = total + 4
    passed = passed + 4
    
    Note: Test multilinearity in first argument
    Let alpha2 be create_test_tensor([1.0, 1.0], covector_space)
    Let alpha_sum be tensor_addition(alpha, alpha2)
    
    Let result_sum_first be evaluate_multilinear_map(T, [alpha_sum, v])
    Let result_alpha be evaluate_multilinear_map(T, [alpha, v])
    Let result_alpha2 be evaluate_multilinear_map(T, [alpha2, v])
    Let result_sum_separate be tensor_addition(result_alpha, result_alpha2)
    
    assert_tensor_equal(result_sum_first, result_sum_separate, "Multilinearity in first argument")
    total = total + 1
    passed = passed + 1
    
    Note: Test multilinearity in second argument
    Let v2 be create_test_tensor([2.0, 1.0], vector_space)
    Let v_sum be tensor_addition(v, v2)
    
    Let result_sum_second be evaluate_multilinear_map(T, [alpha, v_sum])
    Let result_v be evaluate_multilinear_map(T, [alpha, v])
    Let result_v2 be evaluate_multilinear_map(T, [alpha, v2])
    Let result_sum_separate2 be tensor_addition(result_v, result_v2)
    
    assert_tensor_equal(result_sum_second, result_sum_separate2, "Multilinearity in second argument")
    total = total + 1
    passed = passed + 1
    
    Note: Test homogeneity (scalar multiplication)
    Let scalar be 2.5
    Let scaled_alpha be scalar_multiplication(scalar, alpha)
    
    Let result_scaled_input be evaluate_multilinear_map(T, [scaled_alpha, v])
    Let result_original be evaluate_multilinear_map(T, [alpha, v])
    Let result_scaled_output be scalar_multiplication(scalar, result_original)
    
    assert_tensor_equal(result_scaled_input, result_scaled_output, "Multilinear map homogeneity")
    total = total + 1
    passed = passed + 1
    
    Return [passed, total]

Process called "benchmark_tensor_algebra_performance" that returns [Integer, Integer]:
    Let passed be 0
    Let total be 0
    
    Note: Performance benchmarking for tensor algebra operations
    
    Let iterations be 1000
    
    Note: Benchmark vector addition
    Let vector_space be create_test_tensor_space(10, 1, 0)
    Let v1_components be []
    Let v2_components be []
    For i from 0 to 9:
        v1_components = v1_components + [Real(i + 1)]
        v2_components = v2_components + [Real(i + 2)]
    
    Let v1 be create_test_tensor(v1_components, vector_space)
    Let v2 be create_test_tensor(v2_components, vector_space)
    
    Let start_time be current_time_microseconds()
    For i from 1 to iterations:
        Let _ be tensor_addition(v1, v2)
    Let addition_time be current_time_microseconds() - start_time
    Print("Vector addition benchmark: " + String(iterations) + " additions in " + String(addition_time) + " μs")
    
    Note: Benchmark scalar multiplication
    Let start_scalar_time be current_time_microseconds()
    For i from 1 to iterations:
        Let _ be scalar_multiplication(2.5, v1)
    Let scalar_time be current_time_microseconds() - start_scalar_time
    Print("Scalar multiplication benchmark: " + String(iterations) + " multiplications in " + String(scalar_time) + " μs")
    
    Note: Benchmark tensor products
    Let smaller_space be create_test_tensor_space(5, 1, 0)
    Let u be create_test_tensor([1.0, 2.0, 3.0, 4.0, 5.0], smaller_space)
    Let v be create_test_tensor([6.0, 7.0, 8.0, 9.0, 10.0], smaller_space)
    
    Let start_product_time be current_time_microseconds()
    For i from 1 to iterations:
        Let _ be tensor_product(u, v)
    Let product_time be current_time_microseconds() - start_product_time
    Print("Tensor product benchmark: " + String(iterations) + " products in " + String(product_time) + " μs")
    
    Note: Benchmark contractions
    Let matrix_space be create_test_tensor_space(5, 1, 1)
    Let matrix_components be []
    For i from 0 to 24:  Note: 5x5 = 25 components
        matrix_components = matrix_components + [Real(i + 1)]
    Let matrix be create_test_tensor(matrix_components, matrix_space)
    
    Let start_contract_time be current_time_microseconds()
    For i from 1 to iterations:
        Let _ be contract_tensor(matrix, 0, 1)
    Let contract_time be current_time_microseconds() - start_contract_time
    Print("Tensor contraction benchmark: " + String(iterations) + " contractions in " + String(contract_time) + " μs")
    
    total = total + 4
    passed = passed + 4
    
    Return [passed, total]

Process called "run_algebra_tests" that returns [Integer, Integer]:
    Print("Running comprehensive tensor algebra tests...")
    Print("=" * 50)
    
    Let total_passed be 0
    Let total_tests be 0
    
    Note: Run all test suites
    Print("\n1. Testing tensor space construction...")
    Let [p1, t1] be test_tensor_space_construction()
    total_passed = total_passed + p1
    total_tests = total_tests + t1
    
    Print("\n2. Testing tensor addition...")
    Let [p2, t2] be test_tensor_addition()
    total_passed = total_passed + p2
    total_tests = total_tests + t2
    
    Print("\n3. Testing scalar multiplication...")
    Let [p3, t3] be test_scalar_multiplication()
    total_passed = total_passed + p3
    total_tests = total_tests + t3
    
    Print("\n4. Testing tensor products...")
    Let [p4, t4] be test_tensor_products()
    total_passed = total_passed + p4
    total_tests = total_tests + t4
    
    Print("\n5. Testing tensor contractions...")
    Let [p5, t5] be test_tensor_contractions()
    total_passed = total_passed + p5
    total_tests = total_tests + t5
    
    Print("\n6. Testing symmetry operations...")
    Let [p6, t6] be test_symmetry_operations()
    total_passed = total_passed + p6
    total_tests = total_tests + t6
    
    Print("\n7. Testing wedge products...")
    Let [p7, t7] be test_wedge_products()
    total_passed = total_passed + p7
    total_tests = total_tests + t7
    
    Print("\n8. Testing tensor index operations...")
    Let [p8, t8] be test_tensor_index_operations()
    total_passed = total_passed + p8
    total_tests = total_tests + t8
    
    Print("\n9. Testing multilinear maps...")
    Let [p9, t9] be test_multilinear_maps()
    total_passed = total_passed + p9
    total_tests = total_tests + t9
    
    Print("\n10. Performance benchmarking...")
    Let [p10, t10] be benchmark_tensor_algebra_performance()
    total_passed = total_passed + p10
    total_tests = total_tests + t10
    
    Print("\n" + "=" * 50)
    Print("TENSOR ALGEBRA TEST SUMMARY")
    Print("=" * 50)
    Print("Total tests: " + String(total_tests))
    Print("Passed: " + String(total_passed))
    Print("Failed: " + String(total_tests - total_passed))
    Print("Success rate: " + String((Real(total_passed) / Real(total_tests)) * 100.0) + "%")
    
    If total_passed == total_tests:
        Print("🎉 All tensor algebra tests PASSED!")
    Otherwise:
        Print("❌ Some tensor algebra tests FAILED!")
    
    Return [total_passed, total_tests]