Note:
tests/unit/libraries/math/applied/physics_test.runa
Comprehensive tests for Mathematical Physics Module

This test suite provides comprehensive testing for mathematical physics capabilities
including field equations, wave mechanics, quantum operators, thermodynamics,
fluid dynamics, electromagnetic calculations, and relativistic transformations
for physics simulations and theoretical physics research applications.
:End Note

Import "math/applied/physics" as Physics
Import "math/core/operations" as MathOps

Note: =====================================================================
Note: TEST HELPER FUNCTIONS
Note: =====================================================================

Process called "assert_float_equals" that takes actual as Float and expected as Float and tolerance as Float returns Boolean:
    Let difference be MathOps.absolute_value(actual - expected)
    If difference <= tolerance:
        Return true
    Otherwise:
        Print("Expected: " + expected.to_string() + ", Actual: " + actual.to_string() + ", Difference: " + difference.to_string())
        Return false

Process called "assert_list_equals" that takes actual as List[Float] and expected as List[Float] and tolerance as Float returns Boolean:
    If actual.size() != expected.size():
        Print("List sizes differ: Expected " + expected.size().to_string() + ", Actual " + actual.size().to_string())
        Return false
    
    For i from 0 to actual.size() - 1:
        If not assert_float_equals(actual[i], expected[i], tolerance):
            Print("Lists differ at index " + i.to_string())
            Return false
    
    Return true

Process called "create_sample_vector_field" that returns Physics.VectorField:
    Note: Create a standard test vector field for consistent testing
    
    Let field be Physics.VectorField
    field.dimension = 3
    field.coordinate_system = "Cartesian"
    field.boundary_conditions = Dictionary[String, Any]()
    field.boundary_conditions.add("type", "Dirichlet")
    field.boundary_conditions.add("value", 0.0)
    
    Return field

Process called "create_sample_scalar_field" that returns Physics.ScalarField:
    Note: Create a standard test scalar field for consistent testing
    
    Let field be Physics.ScalarField
    field.domain = Physics.Domain
    field.domain.dimensions = 3
    field.domain.bounds = List[List[Float]]()
    
    Return field

Note: =====================================================================
Note: FIELD THEORY TESTS
Note: =====================================================================

Process called "test_vector_field_operations" that returns [Integer, Integer]:
    Print("Testing Vector Field Operations...")
    
    Let passed be 0
    Let total be 0
    
    Let vector_field be create_sample_vector_field()
    
    Note: Test divergence calculation
    total = total + 1
    Let divergence be Physics.calculate_divergence(vector_field)
    
    Note: Divergence should be a scalar field
    If divergence.domain.dimensions == vector_field.dimension:
        passed = passed + 1
    
    Note: Test curl calculation
    total = total + 1
    Let curl be Physics.calculate_curl(vector_field)
    
    Note: Curl should be a vector field of same dimension
    If curl.dimension == vector_field.dimension:
        passed = passed + 1
    
    Note: Test gradient of scalar field
    total = total + 1
    Let scalar_field be create_sample_scalar_field()
    Let gradient be Physics.calculate_gradient(scalar_field)
    
    Note: Gradient should be a vector field
    If gradient.dimension == scalar_field.domain.dimensions:
        passed = passed + 1
    
    Note: Test Laplacian operator
    total = total + 1
    Let laplacian be Physics.calculate_laplacian(scalar_field)
    
    Note: Laplacian should be a scalar field
    If laplacian.domain.dimensions == scalar_field.domain.dimensions:
        passed = passed + 1
    
    Note: Test vector field line integral
    total = total + 1
    Let path_points be List[List[Float]]()
    path_points.add(List[Float]([0.0, 0.0, 0.0]))
    path_points.add(List[Float]([1.0, 1.0, 1.0]))
    
    Let line_integral be Physics.calculate_line_integral(vector_field, path_points)
    
    Note: Line integral should be a finite number
    If not MathOps.is_infinite(line_integral) and not MathOps.is_nan(line_integral):
        passed = passed + 1
    
    Print("Vector Field Operations Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Process called "test_wave_equations" that returns [Integer, Integer]:
    Print("Testing Wave Equation Solutions...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test classical wave equation
    total = total + 1
    Let wave_equation be Physics.WaveEquation
    wave_equation.wave_speed = 343.0  Note: Speed of sound in air
    
    Let initial_condition be Physics.InitialCondition
    initial_condition.condition_type = "displacement"
    initial_condition.function_data = "sin(pi*x)"
    
    wave_equation.initial_conditions = List[Physics.InitialCondition]()
    wave_equation.initial_conditions.add(initial_condition)
    
    Let solution be Physics.solve_wave_equation(wave_equation, 1.0, 0.01)  Note: 1 second, 0.01s timestep
    
    Note: Solution should be stable and finite
    If solution.stability_check and solution.max_amplitude < 1000.0:
        passed = passed + 1
    
    Note: Test electromagnetic wave propagation
    total = total + 1
    Let em_wave be Physics.solve_maxwell_equations_plane_wave(1.0, 1.0, 3.0e8)  Note: E0, B0, c
    
    Note: Should satisfy wave equation with c = 1/sqrt(mu*epsilon)
    If assert_float_equals(em_wave.phase_velocity, 3.0e8, 1.0e6):
        passed = passed + 1
    
    Note: Test standing wave formation
    total = total + 1
    Let boundary_condition be Physics.BoundaryCondition
    boundary_condition.condition_type = "fixed"
    boundary_condition.location = "both_ends"
    
    wave_equation.boundary_conditions = List[Physics.BoundaryCondition]()
    wave_equation.boundary_conditions.add(boundary_condition)
    
    Let standing_wave be Physics.solve_standing_wave(wave_equation, 1.0)  Note: Length = 1m
    
    Note: Standing wave should have nodes at boundaries
    If assert_float_equals(standing_wave.amplitude_at_position(0.0), 0.0, 0.001) and 
       assert_float_equals(standing_wave.amplitude_at_position(1.0), 0.0, 0.001):
        passed = passed + 1
    
    Note: Test wave dispersion
    total = total + 1
    Let dispersion_relation be Physics.calculate_dispersion_relation("deep_water_waves", 9.81)
    
    Note: Deep water waves: omega^2 = g*k
    Let test_k be 1.0
    Let expected_omega be MathOps.square_root(9.81 * test_k)
    Let actual_omega be dispersion_relation.omega_at_k(test_k)
    
    If assert_float_equals(actual_omega, expected_omega, 0.01):
        passed = passed + 1
    
    Note: Test wave interference
    total = total + 1
    Let wave1 be Physics.create_plane_wave(1.0, 1.0, 0.0)    Note: A=1, k=1, phi=0
    Let wave2 be Physics.create_plane_wave(1.0, 1.0, MathOps.pi)  Note: A=1, k=1, phi=pi
    
    Let interference_pattern be Physics.superpose_waves([wave1, wave2])
    
    Note: Destructive interference should result in zero amplitude
    If assert_float_equals(interference_pattern.amplitude, 0.0, 0.001):
        passed = passed + 1
    
    Print("Wave Equation Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: QUANTUM MECHANICS TESTS
Note: =====================================================================

Process called "test_quantum_mechanics" that returns [Integer, Integer]:
    Print("Testing Quantum Mechanics...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test Schrödinger equation for harmonic oscillator
    total = total + 1
    Let harmonic_potential be Physics.create_harmonic_potential(1.0, 1.0)  Note: mass=1, omega=1
    Let schrodinger_eq be Physics.SchrodingerEquation
    schrodinger_eq.hamiltonian = Physics.create_hamiltonian(harmonic_potential)
    
    Let eigenvalues be Physics.solve_time_independent_schrodinger(schrodinger_eq, 5)  Note: First 5 levels
    
    Note: Harmonic oscillator energy levels: E_n = hbar*omega*(n + 1/2)
    Let expected_ground_state be 0.5  Note: hbar=omega=1
    If assert_float_equals(eigenvalues[0], expected_ground_state, 0.01):
        passed = passed + 1
    
    Note: Test quantum tunneling
    total = total + 1
    Let barrier_potential be Physics.create_rectangular_barrier(1.0, 1.0, 2.0)  Note: height=1, width=1, E=2
    Let transmission_coefficient be Physics.calculate_tunneling_probability(barrier_potential, 0.5)  Note: E=0.5 < V
    
    Note: Transmission should be non-zero due to quantum tunneling
    If transmission_coefficient > 0.0 and transmission_coefficient < 1.0:
        passed = passed + 1
    
    Note: Test commutation relations
    total = total + 1
    Let position_operator be Physics.create_position_operator()
    Let momentum_operator be Physics.create_momentum_operator()
    
    Let commutator be Physics.calculate_commutator(position_operator, momentum_operator)
    
    Note: [x,p] = i*hbar (with hbar=1)
    If assert_float_equals(commutator.imaginary_part, 1.0, 0.001):
        passed = passed + 1
    
    Note: Test wave function normalization
    total = total + 1
    Let wave_function be Physics.create_gaussian_wave_packet(0.0, 1.0, 1.0)  Note: x0=0, p0=1, sigma=1
    Let normalization be Physics.calculate_normalization(wave_function)
    
    Note: Normalized wave function should have integral = 1
    If assert_float_equals(normalization, 1.0, 0.001):
        passed = passed + 1
    
    Note: Test uncertainty principle
    total = total + 1
    Let position_uncertainty be Physics.calculate_position_uncertainty(wave_function)
    Let momentum_uncertainty be Physics.calculate_momentum_uncertainty(wave_function)
    Let uncertainty_product be position_uncertainty * momentum_uncertainty
    
    Note: Delta_x * Delta_p >= hbar/2 (with hbar=1)
    If uncertainty_product >= 0.5 - 0.001:
        passed = passed + 1
    
    Print("Quantum Mechanics Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: THERMODYNAMICS TESTS
Note: =====================================================================

Process called "test_thermodynamics" that returns [Integer, Integer]:
    Print("Testing Thermodynamics...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test ideal gas law
    total = total + 1
    Let thermodynamic_system be Physics.ThermodynamicSystem
    thermodynamic_system.temperature = 300.0  Note: K
    thermodynamic_system.pressure = 101325.0  Note: Pa
    thermodynamic_system.volume = Physics.calculate_ideal_gas_volume(1.0, thermodynamic_system.pressure, thermodynamic_system.temperature)  Note: 1 mol
    
    Note: PV = nRT, so V = nRT/P
    Let gas_constant be 8.314  Note: J/(mol*K)
    Let expected_volume be 1.0 * gas_constant * thermodynamic_system.temperature / thermodynamic_system.pressure
    
    If assert_float_equals(thermodynamic_system.volume, expected_volume, 0.001):
        passed = passed + 1
    
    Note: Test first law of thermodynamics
    total = total + 1
    Let internal_energy_change be 1000.0  Note: J
    Let heat_added be 1500.0  Note: J
    Let work_done_by_system be Physics.calculate_work_first_law(internal_energy_change, heat_added)
    
    Note: Q = ΔU + W, so W = Q - ΔU
    Let expected_work be heat_added - internal_energy_change
    If assert_float_equals(work_done_by_system, expected_work, 0.001):
        passed = passed + 1
    
    Note: Test entropy calculation
    total = total + 1
    Let entropy_change be Physics.calculate_entropy_change(thermodynamic_system, heat_added)
    
    Note: For reversible process: ΔS = Q/T
    Let expected_entropy_change be heat_added / thermodynamic_system.temperature
    If assert_float_equals(entropy_change, expected_entropy_change, 0.001):
        passed = passed + 1
    
    Note: Test Carnot efficiency
    total = total + 1
    Let hot_temperature be 600.0   Note: K
    Let cold_temperature be 300.0  Note: K
    Let carnot_efficiency be Physics.calculate_carnot_efficiency(hot_temperature, cold_temperature)
    
    Note: η = 1 - T_cold/T_hot
    Let expected_efficiency be 1.0 - (cold_temperature / hot_temperature)
    If assert_float_equals(carnot_efficiency, expected_efficiency, 0.001):
        passed = passed + 1
    
    Note: Test Maxwell-Boltzmann distribution
    total = total + 1
    Let mass be 4.65e-26  Note: kg (nitrogen molecule)
    Let temperature be 300.0  Note: K
    Let velocity be 500.0     Note: m/s
    
    Let probability_density be Physics.calculate_maxwell_boltzmann_distribution(velocity, mass, temperature)
    
    Note: Should be positive and finite
    If probability_density > 0.0 and not MathOps.is_infinite(probability_density):
        passed = passed + 1
    
    Note: Test phase transitions
    total = total + 1
    Let phase_transition be Physics.calculate_phase_transition("water", "liquid", "vapor", 373.15)  Note: Boiling point
    
    Note: Latent heat should be positive
    If phase_transition.latent_heat > 0.0:
        passed = passed + 1
    
    Print("Thermodynamics Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: FLUID DYNAMICS TESTS
Note: =====================================================================

Process called "test_fluid_dynamics" that returns [Integer, Integer]:
    Print("Testing Fluid Dynamics...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test Navier-Stokes equations
    total = total + 1
    Let fluid_properties be Physics.FluidProperties
    fluid_properties.density = 1000.0      Note: kg/m³ (water)
    fluid_properties.viscosity = 0.001     Note: Pa·s
    fluid_properties.compressibility = false
    
    Let velocity_field be create_sample_vector_field()
    Let pressure_field be create_sample_scalar_field()
    
    Let navier_stokes_result be Physics.solve_navier_stokes(velocity_field, pressure_field, fluid_properties, 0.01, 10)
    
    Note: Solution should converge and be stable
    If navier_stokes_result.converged and navier_stokes_result.max_velocity < 1000.0:
        passed = passed + 1
    
    Note: Test Bernoulli's equation
    total = total + 1
    Let velocity1 be 10.0   Note: m/s
    Let pressure1 be 101325.0  Note: Pa
    Let height1 be 0.0      Note: m
    Let velocity2 be 15.0   Note: m/s
    Let height2 be 5.0      Note: m
    
    Let pressure2 be Physics.calculate_bernoulli_pressure(velocity1, pressure1, height1, velocity2, height2, fluid_properties.density)
    
    Note: Pressure should decrease due to increased velocity and height
    If pressure2 < pressure1:
        passed = passed + 1
    
    Note: Test Reynolds number
    total = total + 1
    Let characteristic_length be 0.1  Note: m
    Let flow_velocity be 2.0         Note: m/s
    Let reynolds_number be Physics.calculate_reynolds_number(flow_velocity, characteristic_length, fluid_properties.density, fluid_properties.viscosity)
    
    Note: Re = ρvL/μ
    Let expected_reynolds be fluid_properties.density * flow_velocity * characteristic_length / fluid_properties.viscosity
    If assert_float_equals(reynolds_number, expected_reynolds, 1.0):
        passed = passed + 1
    
    Note: Test boundary layer theory
    total = total + 1
    Let boundary_layer be Physics.calculate_boundary_layer_thickness(flow_velocity, characteristic_length, fluid_properties)
    
    Note: Boundary layer thickness should be positive and reasonable
    If boundary_layer.thickness > 0.0 and boundary_layer.thickness < characteristic_length:
        passed = passed + 1
    
    Note: Test vorticity calculation
    total = total + 1
    Let vorticity be Physics.calculate_vorticity(velocity_field)
    
    Note: Vorticity should be a vector field
    If vorticity.dimension == velocity_field.dimension:
        passed = passed + 1
    
    Note: Test turbulence modeling
    total = total + 1
    Let turbulence_model be Physics.create_k_epsilon_model(fluid_properties)
    Let turbulent_flow be Physics.solve_turbulent_flow(velocity_field, pressure_field, turbulence_model, 0.01, 10)
    
    Note: Turbulence model should provide additional dissipation
    If turbulent_flow.turbulent_kinetic_energy > 0.0:
        passed = passed + 1
    
    Print("Fluid Dynamics Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: ELECTROMAGNETIC THEORY TESTS
Note: =====================================================================

Process called "test_electromagnetic_theory" that returns [Integer, Integer]:
    Print("Testing Electromagnetic Theory...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test Maxwell's equations
    total = total + 1
    Let electric_field be create_sample_vector_field()
    Let magnetic_field be create_sample_vector_field()
    Let charge_density be create_sample_scalar_field()
    Let current_density be create_sample_vector_field()
    
    Let maxwell_equations be Physics.MaxwellEquations
    maxwell_equations.electric_field = electric_field
    maxwell_equations.magnetic_field = magnetic_field
    maxwell_equations.charge_density = charge_density
    maxwell_equations.current_density = current_density
    
    Let gauss_law_check be Physics.verify_gauss_law(maxwell_equations)
    
    Note: Gauss's law should be satisfied within tolerance
    If gauss_law_check.error < 0.01:
        passed = passed + 1
    
    Note: Test Faraday's law
    total = total + 1
    Let magnetic_flux_change be -0.5  Note: Wb/s
    Let induced_emf be Physics.calculate_induced_emf(magnetic_flux_change)
    
    Note: EMF = -dΦ/dt
    If assert_float_equals(induced_emf, -magnetic_flux_change, 0.001):
        passed = passed + 1
    
    Note: Test electromagnetic wave propagation
    total = total + 1
    Let wave_solution be Physics.solve_em_wave_equation(maxwell_equations)
    
    Note: Wave should propagate at speed of light
    Let speed_of_light be 2.998e8  Note: m/s
    If assert_float_equals(wave_solution.phase_velocity, speed_of_light, 1.0e6):
        passed = passed + 1
    
    Note: Test Lorentz force
    total = total + 1
    Let charge = 1.6e-19      Note: C (electron charge)
    Let velocity = List[Float]([1.0e6, 0.0, 0.0])  Note: m/s
    Let e_field = List[Float]([0.0, 1000.0, 0.0])  Note: V/m
    Let b_field = List[Float]([0.0, 0.0, 0.1])     Note: T
    
    Let lorentz_force be Physics.calculate_lorentz_force(charge, velocity, e_field, b_field)
    
    Note: F = q(E + v × B)
    Let expected_force_y be charge * 1000.0  Note: qE
    Let expected_force_z be charge * 1.0e6 * 0.1  Note: qvB
    
    If assert_float_equals(lorentz_force[1], expected_force_y, 1.0e-22) and
       assert_float_equals(lorentz_force[2], expected_force_z, 1.0e-22):
        passed = passed + 1
    
    Note: Test electromagnetic energy density
    total = total + 1
    Let e_field_magnitude be 1000.0  Note: V/m
    Let b_field_magnitude be 0.1     Note: T
    
    Let energy_density be Physics.calculate_em_energy_density(e_field_magnitude, b_field_magnitude)
    
    Note: u = (ε₀E² + B²/μ₀)/2
    Let epsilon_0 be 8.854e-12  Note: F/m
    Let mu_0 be 4.0 * MathOps.pi * 1.0e-7  Note: H/m
    Let expected_energy be 0.5 * (epsilon_0 * e_field_magnitude * e_field_magnitude + 
                                  b_field_magnitude * b_field_magnitude / mu_0)
    
    If assert_float_equals(energy_density, expected_energy, 1.0e-6):
        passed = passed + 1
    
    Print("Electromagnetic Theory Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: PERFORMANCE BENCHMARKING TESTS
Note: =====================================================================

Process called "test_physics_performance" that returns [Integer, Integer]:
    Print("Testing Mathematical Physics Performance...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test field calculations performance
    total = total + 1
    Let large_field be create_sample_vector_field()
    large_field.dimension = 1000  Note: Large field for performance testing
    
    Let start_time be Physics.get_current_time()
    Let divergence_result be Physics.calculate_divergence(large_field)
    Let field_calculation_time be Physics.get_current_time() - start_time
    
    Note: Field calculation should complete within reasonable time
    If field_calculation_time < 5.0:  Note: 5 seconds
        passed = passed + 1
    
    Note: Test wave equation solver performance
    total = total + 1
    Let large_wave_system be Physics.WaveEquation
    large_wave_system.wave_speed = 343.0
    
    Let wave_start_time be Physics.get_current_time()
    Let wave_solution be Physics.solve_wave_equation(large_wave_system, 1.0, 0.001)  Note: Small timestep
    Let wave_solve_time be Physics.get_current_time() - wave_start_time
    
    Note: Wave equation solving should be reasonably fast
    If wave_solve_time < 10.0:  Note: 10 seconds
        passed = passed + 1
    
    Note: Test parallel processing capability
    total = total + 1
    Let parallel_fields be List[Physics.VectorField]()
    For i from 0 to 9:  Note: 10 fields
        parallel_fields.add(create_sample_vector_field())
    
    Let parallel_start be Physics.get_current_time()
    Let parallel_results be Physics.calculate_divergence_parallel(parallel_fields, 4)  Note: 4 threads
    Let parallel_time be Physics.get_current_time() - parallel_start
    
    Note: Parallel processing should show efficiency gains
    If parallel_results.size() == 10 and parallel_time < 3.0:
        passed = passed + 1
    
    Note: Test memory efficiency
    total = total + 1
    Let memory_before be Physics.get_memory_usage()
    Let temp_fields be List[Physics.VectorField]()
    For i from 0 to 99:  Note: 100 fields
        temp_fields.add(create_sample_vector_field())
    Let memory_after be Physics.get_memory_usage()
    
    Note: Memory usage should be reasonable
    Let memory_increase be memory_after - memory_before
    If memory_increase < 100.0:  Note: Less than 100MB
        passed = passed + 1
    
    Print("Mathematical Physics Performance Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: MAIN TEST RUNNER
Note: =====================================================================

Process called "run_all_physics_tests" that returns [Integer, Integer]:
    Print("=== Running All Mathematical Physics Tests ===")
    
    Let total_passed be 0
    Let total_tests be 0
    
    Note: Run field theory tests
    Let [field_passed, field_total] be test_vector_field_operations()
    total_passed = total_passed + field_passed
    total_tests = total_tests + field_total
    Print("")
    
    Note: Run wave equation tests
    Let [wave_passed, wave_total] be test_wave_equations()
    total_passed = total_passed + wave_passed
    total_tests = total_tests + wave_total
    Print("")
    
    Note: Run quantum mechanics tests
    Let [quantum_passed, quantum_total] be test_quantum_mechanics()
    total_passed = total_passed + quantum_passed
    total_tests = total_tests + quantum_total
    Print("")
    
    Note: Run thermodynamics tests
    Let [thermo_passed, thermo_total] be test_thermodynamics()
    total_passed = total_passed + thermo_passed
    total_tests = total_tests + thermo_total
    Print("")
    
    Note: Run fluid dynamics tests
    Let [fluid_passed, fluid_total] be test_fluid_dynamics()
    total_passed = total_passed + fluid_passed
    total_tests = total_tests + fluid_total
    Print("")
    
    Note: Run electromagnetic theory tests
    Let [em_passed, em_total] be test_electromagnetic_theory()
    total_passed = total_passed + em_passed
    total_tests = total_tests + em_total
    Print("")
    
    Note: Run performance tests
    Let [performance_passed, performance_total] be test_physics_performance()
    total_passed = total_passed + performance_passed
    total_tests = total_tests + performance_total
    Print("")
    
    Note: Print final results
    Print("=== Mathematical Physics Test Results ===")
    Print("Total Tests Passed: " + total_passed.to_string() + "/" + total_tests.to_string())
    Let success_rate be (total_passed.to_float() / total_tests.to_float()) * 100.0
    Print("Success Rate: " + success_rate.to_string() + "%")
    
    If total_passed == total_tests:
        Print("✅ All mathematical physics tests passed!")
    Otherwise:
        Print("❌ Some mathematical physics tests failed.")
    
    Return [total_passed, total_tests]