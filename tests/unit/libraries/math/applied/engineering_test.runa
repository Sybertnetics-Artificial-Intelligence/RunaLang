Note:
tests/unit/libraries/math/applied/engineering_test.runa
Comprehensive tests for Mathematical Engineering Module

This test suite provides comprehensive testing for engineering mathematics including
control theory, signal processing, Fourier transforms, Laplace transforms, transfer
functions, system analysis, stability analysis, feedback control, and optimization
for engineering design, automation, robotics, and industrial control systems.
:End Note

Import "math/applied/engineering" as Engineering
Import "math/core/operations" as MathOps

Note: =====================================================================
Note: TEST HELPER FUNCTIONS
Note: =====================================================================

Process called "assert_float_equals" that takes actual as Float and expected as Float and tolerance as Float returns Boolean:
    Let difference be MathOps.absolute_value(actual - expected)
    If difference <= tolerance:
        Return true
    Otherwise:
        Print("Expected: " + expected.to_string() + ", Actual: " + actual.to_string() + ", Difference: " + difference.to_string())
        Return false

Process called "assert_complex_equals" that takes actual as Engineering.ComplexNumber and expected as Engineering.ComplexNumber and tolerance as Float returns Boolean:
    Let real_diff be MathOps.absolute_value(actual.real - expected.real)
    Let imag_diff be MathOps.absolute_value(actual.imaginary - expected.imaginary)
    
    If real_diff <= tolerance and imag_diff <= tolerance:
        Return true
    Otherwise:
        Print("Expected: " + expected.real.to_string() + " + " + expected.imaginary.to_string() + "i")
        Print("Actual: " + actual.real.to_string() + " + " + actual.imaginary.to_string() + "i")
        Return false

Process called "create_sample_transfer_function" that returns Engineering.TransferFunction:
    Note: Create a standard test transfer function G(s) = 10/(s^2 + 3s + 2)
    
    Let tf be Engineering.TransferFunction
    
    Note: Numerator: 10
    tf.numerator = Engineering.create_polynomial(List[Float]([10.0]))
    
    Note: Denominator: s^2 + 3s + 2
    tf.denominator = Engineering.create_polynomial(List[Float]([1.0, 3.0, 2.0]))
    
    tf.gain = 10.0
    
    Note: Poles at s = -1, -2
    tf.poles = List[Engineering.ComplexNumber]()
    tf.poles.add(Engineering.ComplexNumber(-1.0, 0.0))
    tf.poles.add(Engineering.ComplexNumber(-2.0, 0.0))
    
    Note: Zero at origin (none for this example)
    tf.zeros = List[Engineering.ComplexNumber]()
    
    Return tf

Process called "create_sample_state_space" that returns Engineering.StateSpaceSystem:
    Note: Create a standard test state-space system
    
    Let ss be Engineering.StateSpaceSystem
    
    Note: A matrix: [-3 1; 0 -2]
    ss.state_matrix = Engineering.Matrix
    ss.state_matrix.entries = List[List[String]]()
    ss.state_matrix.entries.add(List[String](["-3.0", "1.0"]))
    ss.state_matrix.entries.add(List[String](["0.0", "-2.0"]))
    ss.state_matrix.rows = 2
    ss.state_matrix.columns = 2
    
    Note: B matrix: [1; 1]
    ss.input_matrix = Engineering.Matrix
    ss.input_matrix.entries = List[List[String]]()
    ss.input_matrix.entries.add(List[String](["1.0"]))
    ss.input_matrix.entries.add(List[String](["1.0"]))
    ss.input_matrix.rows = 2
    ss.input_matrix.columns = 1
    
    Note: C matrix: [1 0]
    ss.output_matrix = Engineering.Matrix
    ss.output_matrix.entries = List[List[String]]()
    ss.output_matrix.entries.add(List[String](["1.0", "0.0"]))
    ss.output_matrix.rows = 1
    ss.output_matrix.columns = 2
    
    Note: D matrix: [0]
    ss.feedthrough_matrix = Engineering.Matrix
    ss.feedthrough_matrix.entries = List[List[String]]()
    ss.feedthrough_matrix.entries.add(List[String](["0.0"]))
    ss.feedthrough_matrix.rows = 1
    ss.feedthrough_matrix.columns = 1
    
    Note: Initial state: [0; 0]
    ss.initial_state = Engineering.Vector
    ss.initial_state.components = List[String](["0.0", "0.0"])
    ss.initial_state.dimension = 2
    
    Return ss

Note: =====================================================================
Note: CONTROL THEORY TESTS
Note: =====================================================================

Process called "test_control_theory" that returns [Integer, Integer]:
    Print("Testing Control Theory...")
    
    Let passed be 0
    Let total = 0
    
    Let test_tf be create_sample_transfer_function()
    
    Note: Test transfer function evaluation
    total = total + 1
    Let s_value be Engineering.ComplexNumber(0.0, 1.0)  Note: s = j (j*omega at omega = 1)
    Let tf_response be Engineering.evaluate_transfer_function(test_tf, s_value)
    
    Note: Should compute G(j) = 10/(j^2 + 3j + 2) = 10/(1 + 3j)
    Let expected_denominator be Engineering.ComplexNumber(1.0, 3.0)
    If tf_response.magnitude > 0.0:
        passed = passed + 1
    
    Note: Test pole-zero cancellation
    total = total + 1
    Let tf_with_zero be create_sample_transfer_function()
    tf_with_zero.zeros.add(Engineering.ComplexNumber(-1.0, 0.0))  Note: Add zero at s = -1
    
    Let cancelled_tf be Engineering.cancel_pole_zero_pairs(tf_with_zero)
    
    Note: Should cancel pole at -1 with zero at -1
    If cancelled_tf.poles.size() < tf_with_zero.poles.size():
        passed = passed + 1
    
    Note: Test state-space to transfer function conversion
    total = total + 1
    Let test_ss be create_sample_state_space()
    Let ss_to_tf be Engineering.convert_state_space_to_transfer_function(test_ss)
    
    Note: Should produce equivalent transfer function
    If ss_to_tf.numerator.degree >= 0 and ss_to_tf.denominator.degree >= 0:
        passed = passed + 1
    
    Note: Test stability analysis using Routh-Hurwitz criterion
    total = total + 1
    Let characteristic_poly be Engineering.create_polynomial(List[Float]([1.0, 3.0, 3.0, 1.0]))  Note: s^3 + 3s^2 + 3s + 1
    Let routh_table be Engineering.construct_routh_table(characteristic_poly)
    
    Note: Should determine stability from first column signs
    If routh_table.is_stable:
        passed = passed + 1
    
    Note: Test root locus analysis
    total = total + 1
    Let open_loop_tf be create_sample_transfer_function()
    Let root_locus_data be Engineering.compute_root_locus(open_loop_tf)
    
    Note: Should trace poles as gain varies
    If root_locus_data.breakaway_points.size() >= 0:  Note: Can be zero breakaway points
        passed = passed + 1
    
    Note: Test PID controller design
    total = total + 1
    Let plant_tf be create_sample_transfer_function()
    Let performance_specs be Engineering.PerformanceSpecs
    performance_specs.settling_time_max = 2.0
    performance_specs.overshoot_max = 10.0
    performance_specs.steady_state_error_max = 0.02
    
    Let pid_controller be Engineering.design_pid_controller(plant_tf, performance_specs)
    
    Note: Should provide PID gains
    If pid_controller.parameters.contains_key("kp") and 
       pid_controller.parameters.contains_key("ki") and
       pid_controller.parameters.contains_key("kd"):
        passed = passed + 1
    
    Print("Control Theory Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: SIGNAL PROCESSING TESTS
Note: =====================================================================

Process called "test_signal_processing" that returns [Integer, Integer]:
    Print("Testing Signal Processing...")
    
    Let passed be 0
    Let total = 0
    
    Note: Test Fourier Transform
    total = total + 1
    Let time_signal be List[Float]([1.0, 0.0, -1.0, 0.0, 1.0, 0.0, -1.0, 0.0])  Note: Square wave samples
    Let fourier_transform be Engineering.compute_fft(time_signal)
    
    Note: Should produce frequency domain representation
    If fourier_transform.frequency_domain.size() == time_signal.size():
        passed = passed + 1
    
    Note: Test inverse Fourier Transform
    total = total + 1
    Let reconstructed_signal be Engineering.compute_ifft(fourier_transform.frequency_domain)
    
    Note: Should reconstruct original signal (within numerical precision)
    Let reconstruction_error be 0.0
    For i from 0 to time_signal.size() - 1:
        reconstruction_error = reconstruction_error + MathOps.absolute_value(reconstructed_signal[i] - time_signal[i])
    
    If reconstruction_error < 0.1:
        passed = passed + 1
    
    Note: Test digital filter design (Butterworth lowpass)
    total = total + 1
    Let filter_order be 3
    Let cutoff_frequency be 0.3  Note: Normalized frequency (0 to 1)
    
    Let butterworth_filter be Engineering.design_butterworth_filter("lowpass", filter_order, cutoff_frequency)
    
    Note: Should have correct number of poles
    If butterworth_filter.poles.size() == filter_order:
        passed = passed + 1
    
    Note: Test filter frequency response
    total = total + 1
    Let test_frequencies be List[Float]([0.1, 0.2, 0.3, 0.4, 0.5])
    Let frequency_response be Engineering.calculate_filter_frequency_response(butterworth_filter, test_frequencies)
    
    Note: Lowpass filter should attenuate high frequencies
    If frequency_response.magnitude[0] > frequency_response.magnitude[4]:  Note: 0.1 Hz > 0.5 Hz magnitude
        passed = passed + 1
    
    Note: Test windowing functions
    total = total + 1
    Let window_length be 64
    Let hanning_window be Engineering.generate_hanning_window(window_length)
    
    Note: Hanning window should have correct properties
    If hanning_window.size() == window_length and 
       hanning_window[0] < 0.1 and hanning_window[window_length / 2] > 0.9:  Note: Low at edges, high at center
        passed = passed + 1
    
    Note: Test convolution
    total = total + 1
    Let signal1 be List[Float]([1.0, 2.0, 3.0, 2.0, 1.0])
    Let signal2 be List[Float]([0.5, 1.0, 0.5])
    
    Let convolution_result be Engineering.convolve_signals(signal1, signal2)
    
    Note: Convolution should produce signal of length N1 + N2 - 1
    If convolution_result.size() == signal1.size() + signal2.size() - 1:
        passed = passed + 1
    
    Note: Test correlation
    total = total + 1
    Let correlation_result be Engineering.correlate_signals(signal1, signal2)
    
    Note: Should find correlation between signals
    If correlation_result.max_correlation_value > 0.0:
        passed = passed + 1
    
    Print("Signal Processing Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: SYSTEM ANALYSIS TESTS
Note: =====================================================================

Process called "test_system_analysis" that returns [Integer, Integer]:
    Print("Testing System Analysis...")
    
    Let passed be 0
    Let total = 0
    
    Let test_system be create_sample_transfer_function()
    
    Note: Test step response analysis
    total = total + 1
    Let step_response be Engineering.compute_step_response(test_system, 10.0, 0.01)  Note: 10 sec, 0.01 sec sampling
    
    Note: Should compute system response to unit step
    If step_response.time_vector.size() > 0 and step_response.response_vector.size() > 0:
        passed = passed + 1
    
    Note: Test impulse response analysis
    total = total + 1
    Let impulse_response be Engineering.compute_impulse_response(test_system, 10.0, 0.01)
    
    Note: Should compute system response to unit impulse
    If impulse_response.time_vector.size() > 0 and impulse_response.response_vector.size() > 0:
        passed = passed + 1
    
    Note: Test frequency response (Bode plot)
    total = total + 1
    Let frequency_range be Engineering.generate_logarithmic_frequency_range(0.1, 100.0, 100)
    Let bode_data be Engineering.compute_bode_plot(test_system, frequency_range)
    
    Note: Should compute magnitude and phase response
    If bode_data.magnitude.size() == frequency_range.size() and 
       bode_data.phase.size() == frequency_range.size():
        passed = passed + 1
    
    Note: Test Nyquist plot
    total = total + 1
    Let nyquist_data be Engineering.compute_nyquist_plot(test_system, frequency_range)
    
    Note: Should compute complex frequency response
    If nyquist_data.real_part.size() == frequency_range.size() and
       nyquist_data.imaginary_part.size() == frequency_range.size():
        passed = passed + 1
    
    Note: Test performance metrics calculation
    total = total + 1
    Let performance_metrics be Engineering.calculate_performance_metrics(step_response)
    
    Note: Should calculate rise time, settling time, overshoot
    If performance_metrics.rise_time > 0.0 and performance_metrics.settling_time > 0.0:
        passed = passed + 1
    
    Note: Test bandwidth calculation
    total = total + 1
    Let bandwidth be Engineering.calculate_system_bandwidth(bode_data, -3.0)  Note: -3dB bandwidth
    
    Note: Should find frequency where magnitude drops by 3dB
    If bandwidth > 0.0:
        passed = passed + 1
    
    Note: Test gain and phase margins
    total = total + 1
    Let open_loop_system be test_system
    Let stability_margins be Engineering.calculate_stability_margins(open_loop_system)
    
    Note: Should compute gain and phase margins
    If stability_margins.gain_margin > 0.0 and stability_margins.phase_margin != 0.0:
        passed = passed + 1
    
    Print("System Analysis Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: FEEDBACK CONTROL TESTS
Note: =====================================================================

Process called "test_feedback_control" that returns [Integer, Integer]:
    Print("Testing Feedback Control...")
    
    Let passed be 0
    Let total = 0
    
    Let plant_tf be create_sample_transfer_function()
    
    Note: Test closed-loop system formation
    total = total + 1
    Let controller_tf be Engineering.create_proportional_controller(2.0)  Note: Proportional gain = 2
    Let feedback_tf be Engineering.create_unity_feedback()
    
    Let closed_loop_system be Engineering.form_closed_loop_system(plant_tf, controller_tf, feedback_tf)
    
    Note: Should form proper closed-loop transfer function
    If closed_loop_system.numerator.degree >= 0 and closed_loop_system.denominator.degree >= 0:
        passed = passed + 1
    
    Note: Test sensitivity analysis
    total = total + 1
    Let sensitivity_tf be Engineering.calculate_sensitivity_function(plant_tf, controller_tf)
    
    Note: Sensitivity S(s) = 1 / (1 + L(s)) where L(s) = G(s)C(s)
    If sensitivity_tf.numerator.degree >= 0:
        passed = passed + 1
    
    Note: Test complementary sensitivity
    total = total + 1
    Let complementary_sensitivity_tf be Engineering.calculate_complementary_sensitivity_function(plant_tf, controller_tf)
    
    Note: T(s) = L(s) / (1 + L(s))
    If complementary_sensitivity_tf.numerator.degree >= 0:
        passed = passed + 1
    
    Note: Test disturbance rejection analysis
    total = total + 1
    Let disturbance_tf be Engineering.create_step_disturbance(1.0)  Note: Unit step disturbance
    Let disturbance_response be Engineering.compute_disturbance_response(closed_loop_system, disturbance_tf, 10.0)
    
    Note: Should compute response to disturbance input
    If disturbance_response.steady_state_value != Float.POSITIVE_INFINITY:
        passed = passed + 1
    
    Note: Test reference tracking performance
    total = total + 1
    Let reference_tf be Engineering.create_step_reference(2.0)  Note: Step reference of magnitude 2
    Let tracking_response be Engineering.compute_reference_tracking_response(closed_loop_system, reference_tf, 10.0)
    
    Note: Should track reference with acceptable error
    Let tracking_error be MathOps.absolute_value(tracking_response.steady_state_value - 2.0)
    If tracking_error < 0.1:  Note: Less than 10% steady-state error
        passed = passed + 1
    
    Note: Test robust stability analysis
    total = total + 1
    Let plant_uncertainty be Engineering.create_multiplicative_uncertainty(0.2)  Note: 20% uncertainty
    Let robust_stability_margin be Engineering.analyze_robust_stability(plant_tf, controller_tf, plant_uncertainty)
    
    Note: Should provide stability robustness measure
    If robust_stability_margin >= 0.0:
        passed = passed + 1
    
    Note: Test adaptive control design
    total = total + 1
    Let adaptive_controller be Engineering.design_adaptive_controller(plant_tf, "model_reference")
    
    Note: Should design adaptive control law
    If adaptive_controller.adaptation_law != "":
        passed = passed + 1
    
    Print("Feedback Control Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: OPTIMIZATION TESTS
Note: =====================================================================

Process called "test_engineering_optimization" that returns [Integer, Integer]:
    Print("Testing Engineering Optimization...")
    
    Let passed be 0
    Let total = 0
    
    Note: Test controller parameter optimization
    total = total + 1
    Let plant be create_sample_transfer_function()
    Let design_objectives be Dictionary[String, Float]()
    design_objectives.add("settling_time", 2.0)
    design_objectives.add("overshoot", 5.0)
    design_objectives.add("steady_state_error", 0.01)
    
    Let optimal_controller be Engineering.optimize_controller_parameters(plant, "PID", design_objectives)
    
    Note: Should find optimal PID parameters
    If optimal_controller.parameters.contains_key("kp") and optimal_controller.cost_function_value > 0.0:
        passed = passed + 1
    
    Note: Test structural optimization using genetic algorithm
    total = total + 1
    Let beam_parameters be Engineering.BeamDesignProblem
    beam_parameters.length = 5.0  Note: 5 meter beam
    beam_parameters.load = 10000.0  Note: 10 kN load
    beam_parameters.material_properties = Engineering.SteelProperties
    
    Let ga_optimizer be Engineering.GeneticAlgorithm
    ga_optimizer.population_size = 50
    ga_optimizer.generations = 100
    ga_optimizer.mutation_rate = 0.01
    ga_optimizer.crossover_rate = 0.8
    
    Let optimal_beam_design be Engineering.optimize_beam_design(beam_parameters, ga_optimizer)
    
    Note: Should find beam dimensions that minimize weight while meeting constraints
    If optimal_beam_design.objective_value > 0.0 and optimal_beam_design.constraint_satisfaction:
        passed = passed + 1
    
    Note: Test multi-objective optimization (Pareto front)
    total = total + 1
    Let objectives be List[String](["minimize_cost", "maximize_performance"])
    Let pareto_solutions be Engineering.compute_pareto_front(plant, objectives, 20)  Note: 20 solutions
    
    Note: Should generate non-dominated solutions
    If pareto_solutions.size() > 0:
        passed = passed + 1
    
    Note: Test constrained optimization using sequential quadratic programming
    total = total + 1
    Let optimization_problem be Engineering.OptimizationProblem
    optimization_problem.objective_function = Engineering.create_quadratic_objective()
    optimization_problem.constraints = List[Engineering.Constraint]()
    optimization_problem.constraints.add(Engineering.create_inequality_constraint("x1 + x2 <= 10"))
    optimization_problem.constraints.add(Engineering.create_equality_constraint("2*x1 - x2 = 0"))
    
    Let sqp_solution be Engineering.solve_sqp_optimization(optimization_problem)
    
    Note: Should find optimal solution satisfying constraints
    If sqp_solution.converged and sqp_solution.constraint_violations < 0.001:
        passed = passed + 1
    
    Note: Test topology optimization
    total = total + 1
    Let design_domain be Engineering.create_rectangular_domain(10.0, 5.0)  Note: 10x5 design domain
    Let boundary_conditions be Engineering.create_cantilever_boundary_conditions()
    Let volume_fraction be 0.3  Note: 30% material usage
    
    Let topology_result be Engineering.optimize_topology(design_domain, boundary_conditions, volume_fraction)
    
    Note: Should generate optimal material distribution
    If topology_result.compliance > 0.0 and topology_result.volume_constraint_satisfied:
        passed = passed + 1
    
    Note: Test robust design optimization
    total = total + 1
    Let design_variables be List[String](["length", "width", "height"])
    Let uncertainty_ranges be Dictionary[String, Float]()
    uncertainty_ranges.add("material_strength", 0.1)  Note: 10% uncertainty
    uncertainty_ranges.add("load_magnitude", 0.15)    Note: 15% uncertainty
    
    Let robust_design be Engineering.optimize_robust_design(beam_parameters, design_variables, uncertainty_ranges)
    
    Note: Should find design robust to uncertainties
    If robust_design.robustness_measure > 0.0:
        passed = passed + 1
    
    Print("Engineering Optimization Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: PERFORMANCE BENCHMARKING TESTS
Note: =====================================================================

Process called "test_engineering_performance" that returns [Integer, Integer]:
    Print("Testing Mathematical Engineering Performance...")
    
    Let passed be 0
    Let total = 0
    
    Note: Test large system analysis performance
    total = total + 1
    Let high_order_system be Engineering.create_high_order_system(50)  Note: 50th order system
    
    Let start_time be Engineering.get_current_time()
    Let high_order_response be Engineering.compute_step_response(high_order_system, 10.0, 0.01)
    Let analysis_time be Engineering.get_current_time() - start_time
    
    Note: High-order system analysis should complete within reasonable time
    If analysis_time < 5.0:  Note: 5 seconds
        passed = passed + 1
    
    Note: Test FFT performance on large signals
    total = total + 1
    Let large_signal be List[Float]()
    For i from 0 to 8191:  Note: 8192 samples
        large_signal.add(MathOps.sine(2.0 * MathOps.pi * i.to_float() / 1024.0))
    
    Let fft_start_time be Engineering.get_current_time()
    Let large_fft_result be Engineering.compute_fft(large_signal)
    Let fft_time be Engineering.get_current_time() - fft_start_time
    
    Note: Large FFT should be reasonably fast
    If fft_time < 2.0:  Note: 2 seconds
        passed = passed + 1
    
    Note: Test parallel control system design
    total = total + 1
    Let control_problems be List[Engineering.ControlDesignProblem]()
    For i from 0 to 19:  Note: 20 design problems
        Let problem be Engineering.ControlDesignProblem
        problem.plant = create_sample_transfer_function()
        problem.specifications = design_objectives
        control_problems.add(problem)
    
    Let parallel_start be Engineering.get_current_time()
    Let parallel_designs be Engineering.design_controllers_parallel(control_problems, 4)  Note: 4 threads
    Let parallel_time = Engineering.get_current_time() - parallel_start
    
    Note: Parallel design should show efficiency
    If parallel_designs.size() == 20 and parallel_time < 3.0:
        passed = passed + 1
    
    Note: Test memory efficiency
    total = total + 1
    Let memory_before be Engineering.get_memory_usage()
    Let temp_systems be List[Engineering.TransferFunction]()
    For i from 0 to 99:  Note: 100 transfer functions
        temp_systems.add(create_sample_transfer_function())
    Let memory_after be Engineering.get_memory_usage()
    
    Note: Memory usage should be reasonable
    Let memory_increase be memory_after - memory_before
    If memory_increase < 20.0:  Note: Less than 20MB
        passed = passed + 1
    
    Print("Mathematical Engineering Performance Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: MAIN TEST RUNNER
Note: =====================================================================

Process called "run_all_engineering_tests" that returns [Integer, Integer]:
    Print("=== Running All Mathematical Engineering Tests ===")
    
    Let total_passed be 0
    Let total_tests be 0
    
    Note: Run control theory tests
    Let [control_passed, control_total] be test_control_theory()
    total_passed = total_passed + control_passed
    total_tests = total_tests + control_total
    Print("")
    
    Note: Run signal processing tests
    Let [signal_passed, signal_total] be test_signal_processing()
    total_passed = total_passed + signal_passed
    total_tests = total_tests + signal_total
    Print("")
    
    Note: Run system analysis tests
    Let [system_passed, system_total] be test_system_analysis()
    total_passed = total_passed + system_passed
    total_tests = total_tests + system_total
    Print("")
    
    Note: Run feedback control tests
    Let [feedback_passed, feedback_total] be test_feedback_control()
    total_passed = total_passed + feedback_passed
    total_tests = total_tests + feedback_total
    Print("")
    
    Note: Run optimization tests
    Let [optimization_passed, optimization_total] be test_engineering_optimization()
    total_passed = total_passed + optimization_passed
    total_tests = total_tests + optimization_total
    Print("")
    
    Note: Run performance tests
    Let [performance_passed, performance_total] be test_engineering_performance()
    total_passed = total_passed + performance_passed
    total_tests = total_tests + performance_total
    Print("")
    
    Note: Print final results
    Print("=== Mathematical Engineering Test Results ===")
    Print("Total Tests Passed: " + total_passed.to_string() + "/" + total_tests.to_string())
    Let success_rate be (total_passed.to_float() / total_tests.to_float()) * 100.0
    Print("Success Rate: " + success_rate.to_string() + "%")
    
    If total_passed == total_tests:
        Print("✅ All mathematical engineering tests passed!")
    Otherwise:
        Print("❌ Some mathematical engineering tests failed.")
    
    Return [total_passed, total_tests]