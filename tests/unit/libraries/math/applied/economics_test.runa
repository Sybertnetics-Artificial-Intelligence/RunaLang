Note:
tests/unit/libraries/math/applied/economics_test.runa
Comprehensive tests for Mathematical Economics Module

This test suite provides comprehensive testing for mathematical economics capabilities
including game theory, Nash equilibrium, auction theory, market dynamics, portfolio
theory, option pricing models, economic forecasting, utility functions, optimization,
and econometric modeling for financial analysis and economic research applications.
:End Note

Import "math/applied/economics" as Economics
Import "math/core/operations" as MathOps

Note: =====================================================================
Note: TEST HELPER FUNCTIONS
Note: =====================================================================

Process called "assert_float_equals" that takes actual as Float and expected as Float and tolerance as Float returns Boolean:
    Let difference be MathOps.absolute_value(actual - expected)
    If difference <= tolerance:
        Return true
    Otherwise:
        Print("Expected: " + expected.to_string() + ", Actual: " + actual.to_string() + ", Difference: " + difference.to_string())
        Return false

Process called "assert_list_equals" that takes actual as List[Float] and expected as List[Float] and tolerance as Float returns Boolean:
    If actual.size() != expected.size():
        Print("List sizes differ: Expected " + expected.size().to_string() + ", Actual " + actual.size().to_string())
        Return false
    
    For i from 0 to actual.size() - 1:
        If not assert_float_equals(actual[i], expected[i], tolerance):
            Print("Lists differ at index " + i.to_string())
            Return false
    
    Return true

Process called "create_sample_game" that returns Economics.GameTheoryModel:
    Note: Create a standard test game for consistent testing
    
    Let game be Economics.GameTheoryModel
    game.game_type = "simultaneous"
    game.information_structure = "complete"
    
    Note: Create 2x2 prisoner's dilemma payoff matrix
    game.payoff_matrix = List[List[Float]]()
    Let row1 be List[Float]([3.0, 0.0])  Note: Cooperate vs Cooperate, Defect
    Let row2 be List[Float]([5.0, 1.0])  Note: Defect vs Cooperate, Defect
    game.payoff_matrix.add(row1)
    game.payoff_matrix.add(row2)
    
    Return game

Process called "create_sample_market" that returns Economics.MarketModel:
    Note: Create a standard test market for consistent testing
    
    Let market be Economics.MarketModel
    market.market_structure = "perfect_competition"
    market.equilibrium_price = 10.0
    market.equilibrium_quantity = 100.0
    
    Return market

Note: =====================================================================
Note: GAME THEORY TESTS
Note: =====================================================================

Process called "test_game_theory" that returns [Integer, Integer]:
    Print("Testing Game Theory...")
    
    Let passed be 0
    Let total be 0
    
    Let test_game be create_sample_game()
    
    Note: Test Nash equilibrium calculation
    total = total + 1
    Let nash_equilibria be Economics.find_nash_equilibria(test_game)
    
    Note: Prisoner's dilemma should have one Nash equilibrium (Defect, Defect)
    If nash_equilibria.size() >= 1:
        passed = passed + 1
    
    Note: Test dominant strategy analysis
    total = total + 1
    Let dominant_strategies be Economics.find_dominant_strategies(test_game)
    
    Note: Should identify defection as dominant strategy
    If dominant_strategies.contains("defect"):
        passed = passed + 1
    
    Note: Test mixed strategy equilibrium
    total = total + 1
    Let mixed_game be Economics.GameTheoryModel
    mixed_game.payoff_matrix = List[List[Float]]()
    mixed_game.payoff_matrix.add(List[Float]([1.0, -1.0]))  Note: Matching pennies
    mixed_game.payoff_matrix.add(List[Float]([-1.0, 1.0]))
    
    Let mixed_equilibrium be Economics.find_mixed_strategy_equilibrium(mixed_game)
    
    Note: Matching pennies should have mixed strategy equilibrium at (0.5, 0.5)
    If assert_float_equals(mixed_equilibrium.probabilities[0], 0.5, 0.01):
        passed = passed + 1
    
    Note: Test cooperative game theory
    total = total + 1
    Let cooperative_game be Economics.CooperativeGame
    cooperative_game.players = List[Economics.Player]()
    cooperative_game.players.add(Economics.Player("A"))
    cooperative_game.players.add(Economics.Player("B"))
    cooperative_game.players.add(Economics.Player("C"))
    
    cooperative_game.coalition_values = Dictionary[List[Economics.Player], Float]()
    cooperative_game.coalition_values.add([Economics.Player("A")], 10.0)
    cooperative_game.coalition_values.add([Economics.Player("B")], 20.0)
    cooperative_game.coalition_values.add([Economics.Player("C")], 30.0)
    cooperative_game.coalition_values.add([Economics.Player("A"), Economics.Player("B")], 40.0)
    cooperative_game.coalition_values.add([Economics.Player("A"), Economics.Player("C")], 50.0)
    cooperative_game.coalition_values.add([Economics.Player("B"), Economics.Player("C")], 60.0)
    cooperative_game.coalition_values.add([Economics.Player("A"), Economics.Player("B"), Economics.Player("C")], 90.0)
    
    Let shapley_values be Economics.calculate_shapley_values(cooperative_game)
    
    Note: Shapley values should sum to grand coalition value
    Let shapley_sum be 0.0
    For value in shapley_values:
        shapley_sum = shapley_sum + value
    
    If assert_float_equals(shapley_sum, 90.0, 0.1):
        passed = passed + 1
    
    Note: Test auction theory
    total = total + 1
    Let auction be Economics.AuctionMechanism
    auction.auction_type = "first_price_sealed_bid"
    auction.reserve_price = 5.0
    
    Let bidder_values be List[Float]([10.0, 8.0, 12.0, 6.0])
    Let optimal_bids be Economics.calculate_optimal_bids(auction, bidder_values)
    
    Note: Optimal bids should be below true values
    If optimal_bids[0] < bidder_values[0]:
        passed = passed + 1
    
    Note: Test mechanism design
    total = total + 1
    Let mechanism be Economics.design_optimal_mechanism(bidder_values, "revenue_maximizing")
    
    Note: Should design mechanism with positive expected revenue
    If mechanism.expected_revenue > 0.0:
        passed = passed + 1
    
    Print("Game Theory Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: MARKET DYNAMICS TESTS
Note: =====================================================================

Process called "test_market_dynamics" that returns [Integer, Integer]:
    Print("Testing Market Dynamics...")
    
    Let passed be 0
    Let total be 0
    
    Let test_market be create_sample_market()
    
    Note: Test supply and demand equilibrium
    total = total + 1
    Let supply_function be Economics.create_linear_supply_function(1.0, 2.0)  Note: slope=1, intercept=2
    Let demand_function be Economics.create_linear_demand_function(-0.5, 15.0)  Note: slope=-0.5, intercept=15
    
    Let equilibrium be Economics.find_market_equilibrium(supply_function, demand_function)
    
    Note: At equilibrium, supply equals demand
    Let supply_at_eq be Economics.evaluate_function(supply_function, equilibrium.price)
    Let demand_at_eq be Economics.evaluate_function(demand_function, equilibrium.price)
    
    If assert_float_equals(supply_at_eq, demand_at_eq, 0.1):
        passed = passed + 1
    
    Note: Test price elasticity of demand
    total = total + 1
    Let price1 be 10.0
    Let quantity1 be 100.0
    Let price2 be 11.0
    Let quantity2 be 95.0
    
    Let elasticity be Economics.calculate_price_elasticity(price1, quantity1, price2, quantity2)
    
    Note: Elasticity should be negative for normal demand
    If elasticity < 0.0:
        passed = passed + 1
    
    Note: Test consumer surplus
    total = total + 1
    Let consumer_surplus be Economics.calculate_consumer_surplus(demand_function, equilibrium.price, equilibrium.quantity)
    
    Note: Consumer surplus should be positive
    If consumer_surplus > 0.0:
        passed = passed + 1
    
    Note: Test producer surplus
    total = total + 1
    Let producer_surplus be Economics.calculate_producer_surplus(supply_function, equilibrium.price, equilibrium.quantity)
    
    Note: Producer surplus should be positive
    If producer_surplus > 0.0:
        passed = passed + 1
    
    Note: Test market efficiency (deadweight loss)
    total = total + 1
    Let tax_per_unit be 2.0
    Let tax_equilibrium be Economics.find_equilibrium_with_tax(supply_function, demand_function, tax_per_unit)
    Let deadweight_loss be Economics.calculate_deadweight_loss(equilibrium, tax_equilibrium)
    
    Note: Tax should create deadweight loss
    If deadweight_loss > 0.0:
        passed = passed + 1
    
    Note: Test market concentration (Herfindahl-Hirschman Index)
    total = total + 1
    Let market_shares be List[Float]([0.4, 0.3, 0.2, 0.1])
    Let hhi be Economics.calculate_herfindahl_index(market_shares)
    
    Note: HHI = sum of squared market shares
    Let expected_hhi be 0.4*0.4 + 0.3*0.3 + 0.2*0.2 + 0.1*0.1
    If assert_float_equals(hhi, expected_hhi, 0.001):
        passed = passed + 1
    
    Print("Market Dynamics Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: PORTFOLIO THEORY TESTS
Note: =====================================================================

Process called "test_portfolio_theory" that returns [Integer, Integer]:
    Print("Testing Portfolio Theory...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test mean-variance optimization
    total = total + 1
    Let expected_returns be List[Float]([0.1, 0.12, 0.08])
    Let covariance_matrix be List[List[Float]]()
    covariance_matrix.add(List[Float]([0.04, 0.01, 0.02]))
    covariance_matrix.add(List[Float]([0.01, 0.06, 0.015]))
    covariance_matrix.add(List[Float]([0.02, 0.015, 0.05]))
    
    Let risk_tolerance be 0.5
    Let optimal_weights be Economics.optimize_mean_variance_portfolio(expected_returns, covariance_matrix, risk_tolerance)
    
    Note: Weights should sum to 1
    Let weight_sum be 0.0
    For weight in optimal_weights:
        weight_sum = weight_sum + weight
    
    If assert_float_equals(weight_sum, 1.0, 0.001):
        passed = passed + 1
    
    Note: Test Capital Asset Pricing Model (CAPM)
    total = total + 1
    Let risk_free_rate be 0.03
    Let market_return be 0.1
    Let beta be 1.2
    
    Let expected_return_capm be Economics.calculate_capm_expected_return(risk_free_rate, market_return, beta)
    
    Note: E(R) = Rf + β(E(Rm) - Rf)
    Let expected_capm be risk_free_rate + beta * (market_return - risk_free_rate)
    If assert_float_equals(expected_return_capm, expected_capm, 0.001):
        passed = passed + 1
    
    Note: Test portfolio risk calculation
    total = total + 1
    Let portfolio_weights be List[Float]([0.4, 0.3, 0.3])
    Let portfolio_variance be Economics.calculate_portfolio_variance(portfolio_weights, covariance_matrix)
    
    Note: Portfolio variance should be positive
    If portfolio_variance > 0.0:
        passed = passed + 1
    
    Note: Test Sharpe ratio
    total = total + 1
    Let portfolio_return be 0.15
    Let portfolio_std_dev be MathOps.square_root(portfolio_variance)
    Let sharpe_ratio be Economics.calculate_sharpe_ratio(portfolio_return, risk_free_rate, portfolio_std_dev)
    
    Note: Sharpe ratio = (Rp - Rf) / σp
    Let expected_sharpe be (portfolio_return - risk_free_rate) / portfolio_std_dev
    If assert_float_equals(sharpe_ratio, expected_sharpe, 0.001):
        passed = passed + 1
    
    Note: Test efficient frontier
    total = total + 1
    Let efficient_frontier be Economics.calculate_efficient_frontier(expected_returns, covariance_matrix, 20)
    
    Note: Should generate points along efficient frontier
    If efficient_frontier.size() == 20:
        passed = passed + 1
    
    Note: Test Value at Risk (VaR)
    total = total + 1
    Let confidence_level be 0.95
    Let portfolio_value be 1000000.0
    Let holding_period be 1  Note: 1 day
    
    Let var be Economics.calculate_portfolio_var(portfolio_weights, expected_returns, covariance_matrix, 
                                                confidence_level, portfolio_value, holding_period)
    
    Note: VaR should be positive (represents potential loss)
    If var > 0.0:
        passed = passed + 1
    
    Print("Portfolio Theory Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: BEHAVIORAL ECONOMICS TESTS
Note: =====================================================================

Process called "test_behavioral_economics" that returns [Integer, Integer]:
    Print("Testing Behavioral Economics...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test utility functions
    total = total + 1
    Let wealth be 100.0
    Let risk_aversion_coefficient be 0.5
    
    Let crra_utility be Economics.calculate_crra_utility(wealth, risk_aversion_coefficient)
    
    Note: CRRA utility: U(W) = W^(1-γ)/(1-γ) for γ ≠ 1
    Let expected_crra be MathOps.power(wealth, 1.0 - risk_aversion_coefficient) / (1.0 - risk_aversion_coefficient)
    If assert_float_equals(crra_utility, expected_crra, 0.01):
        passed = passed + 1
    
    Note: Test prospect theory value function
    total = total + 1
    Let gain be 50.0
    Let loss be -30.0
    Let loss_aversion_parameter be 2.0
    
    Let prospect_value be Economics.calculate_prospect_theory_value(gain, loss, loss_aversion_parameter)
    
    Note: Should incorporate loss aversion
    If prospect_value != gain + loss:  Note: Should be different from linear utility
        passed = passed + 1
    
    Note: Test probability weighting function
    total = total + 1
    Let objective_probability be 0.1
    Let weighting_parameter be 0.69
    
    Let weighted_probability be Economics.calculate_probability_weighting(objective_probability, weighting_parameter)
    
    Note: Probability weighting should transform objective probabilities
    If weighted_probability != objective_probability:
        passed = passed + 1
    
    Note: Test hyperbolic discounting
    total = total + 1
    Let future_value be 100.0
    Let time_delay be 1.0  Note: 1 year
    Let discount_rate be 0.05
    Let hyperbolic_parameter be 1.0
    
    Let present_value_hyperbolic be Economics.calculate_hyperbolic_discounting(future_value, time_delay, discount_rate, hyperbolic_parameter)
    
    Note: Hyperbolic discounting should be different from exponential
    Let present_value_exponential be future_value / MathOps.power(1.0 + discount_rate, time_delay)
    If MathOps.absolute_value(present_value_hyperbolic - present_value_exponential) > 0.01:
        passed = passed + 1
    
    Note: Test anchoring bias model
    total = total + 1
    Let anchor_value be 50.0
    Let true_value be 75.0
    Let anchoring_weight be 0.3
    
    Let biased_estimate be Economics.model_anchoring_bias(anchor_value, true_value, anchoring_weight)
    
    Note: Biased estimate should be between anchor and true value
    If biased_estimate > anchor_value and biased_estimate < true_value:
        passed = passed + 1
    
    Note: Test herding behavior model
    total = total + 1
    Let individual_signal be 0.8
    Let social_signal be 0.3
    Let herding_strength be 0.4
    
    Let final_decision be Economics.model_herding_behavior(individual_signal, social_signal, herding_strength)
    
    Note: Final decision should be influenced by both signals
    If final_decision != individual_signal:
        passed = passed + 1
    
    Print("Behavioral Economics Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: ECONOMETRIC MODELING TESTS
Note: =====================================================================

Process called "test_econometric_modeling" that returns [Integer, Integer]:
    Print("Testing Econometric Modeling...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test linear regression
    total = total + 1
    Let x_values be List[Float]([1.0, 2.0, 3.0, 4.0, 5.0])
    Let y_values be List[Float]([2.1, 4.2, 5.9, 8.1, 10.2])
    
    Let regression_result be Economics.estimate_linear_regression(x_values, y_values)
    
    Note: Should estimate slope and intercept
    If regression_result.contains_key("slope") and regression_result.contains_key("intercept"):
        passed = passed + 1
    
    Note: Test R-squared calculation
    total = total + 1
    Let r_squared be Economics.calculate_r_squared(x_values, y_values, regression_result)
    
    Note: R-squared should be between 0 and 1
    If r_squared >= 0.0 and r_squared <= 1.0:
        passed = passed + 1
    
    Note: Test multiple regression
    total = total + 1
    Let x_matrix be List[List[Float]]()
    x_matrix.add(List[Float]([1.0, 2.0]))
    x_matrix.add(List[Float]([2.0, 3.0]))
    x_matrix.add(List[Float]([3.0, 4.0]))
    x_matrix.add(List[Float]([4.0, 5.0]))
    x_matrix.add(List[Float]([5.0, 6.0]))
    
    Let multiple_regression_result be Economics.estimate_multiple_regression(x_matrix, y_values)
    
    Note: Should estimate coefficients for each variable
    If multiple_regression_result.coefficients.size() == 2:
        passed = passed + 1
    
    Note: Test instrumental variables estimation
    total = total + 1
    Let instruments be List[Float]([0.5, 1.5, 2.5, 3.5, 4.5])
    Let iv_result be Economics.estimate_instrumental_variables(x_values, y_values, instruments)
    
    Note: IV estimation should provide different results from OLS
    If MathOps.absolute_value(iv_result.slope - regression_result.get("slope")) > 0.01:
        passed = passed + 1
    
    Note: Test time series analysis
    total = total + 1
    Let time_series_data be List[Float]([10.0, 12.0, 11.0, 13.0, 15.0, 14.0, 16.0, 18.0])
    Let arima_model be Economics.estimate_arima_model(time_series_data, 1, 1, 1)
    
    Note: ARIMA model should provide parameters and forecasts
    If arima_model.contains_key("ar_coefficients") and arima_model.contains_key("ma_coefficients"):
        passed = passed + 1
    
    Note: Test cointegration analysis
    total = total + 1
    Let series1 be List[Float]([100.0, 102.0, 105.0, 103.0, 107.0])
    Let series2 be List[Float]([50.0, 51.0, 52.5, 51.5, 53.5])
    
    Let cointegration_test be Economics.test_cointegration(series1, series2)
    
    Note: Should test for long-run relationship
    If cointegration_test.contains_key("test_statistic") and cointegration_test.contains_key("p_value"):
        passed = passed + 1
    
    Print("Econometric Modeling Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: PERFORMANCE BENCHMARKING TESTS
Note: =====================================================================

Process called "test_economics_performance" that returns [Integer, Integer]:
    Print("Testing Mathematical Economics Performance...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test large game solving performance
    total = total + 1
    Let large_game be Economics.GameTheoryModel
    large_game.payoff_matrix = List[List[Float]]()
    For i from 0 to 9:  Note: 10x10 game matrix
        Let row be List[Float]()
        For j from 0 to 9:
            row.add(MathOps.random() * 10.0)
        large_game.payoff_matrix.add(row)
    
    Let start_time be Economics.get_current_time()
    Let large_nash_equilibria be Economics.find_nash_equilibria(large_game)
    Let game_solve_time be Economics.get_current_time() - start_time
    
    Note: Large game solving should complete within reasonable time
    If game_solve_time < 5.0:  Note: 5 seconds
        passed = passed + 1
    
    Note: Test portfolio optimization performance
    total = total + 1
    Let large_returns be List[Float]()
    For i from 0 to 99:  Note: 100 assets
        large_returns.add(0.05 + MathOps.random() * 0.1)
    
    Let large_covariance be List[List[Float]]()
    For i from 0 to 99:
        Let row be List[Float]()
        For j from 0 to 99:
            If i == j:
                row.add(0.04 + MathOps.random() * 0.02)
            Otherwise:
                row.add(MathOps.random() * 0.01)
        large_covariance.add(row)
    
    Let portfolio_start_time be Economics.get_current_time()
    Let large_portfolio_weights be Economics.optimize_mean_variance_portfolio(large_returns, large_covariance, 0.5)
    Let portfolio_optimization_time be Economics.get_current_time() - portfolio_start_time
    
    Note: Portfolio optimization should be reasonably fast
    If portfolio_optimization_time < 3.0:  Note: 3 seconds
        passed = passed + 1
    
    Note: Test parallel market simulation
    total = total + 1
    Let market_scenarios be List[Economics.MarketModel]()
    For i from 0 to 19:  Note: 20 market scenarios
        market_scenarios.add(create_sample_market())
    
    Let parallel_start be Economics.get_current_time()
    Let parallel_results be Economics.simulate_markets_parallel(market_scenarios, 100, 4)  Note: 4 threads
    Let parallel_time be Economics.get_current_time() - parallel_start
    
    Note: Parallel simulation should show efficiency
    If parallel_results.size() == 20 and parallel_time < 2.0:
        passed = passed + 1
    
    Note: Test memory efficiency
    total = total + 1
    Let memory_before be Economics.get_memory_usage()
    Let temp_games be List[Economics.GameTheoryModel]()
    For i from 0 to 99:  Note: 100 games
        temp_games.add(create_sample_game())
    Let memory_after be Economics.get_memory_usage()
    
    Note: Memory usage should be reasonable
    Let memory_increase be memory_after - memory_before
    If memory_increase < 30.0:  Note: Less than 30MB
        passed = passed + 1
    
    Print("Mathematical Economics Performance Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: MAIN TEST RUNNER
Note: =====================================================================

Process called "run_all_economics_tests" that returns [Integer, Integer]:
    Print("=== Running All Mathematical Economics Tests ===")
    
    Let total_passed be 0
    Let total_tests be 0
    
    Note: Run game theory tests
    Let [game_passed, game_total] be test_game_theory()
    total_passed = total_passed + game_passed
    total_tests = total_tests + game_total
    Print("")
    
    Note: Run market dynamics tests
    Let [market_passed, market_total] be test_market_dynamics()
    total_passed = total_passed + market_passed
    total_tests = total_tests + market_total
    Print("")
    
    Note: Run portfolio theory tests
    Let [portfolio_passed, portfolio_total] be test_portfolio_theory()
    total_passed = total_passed + portfolio_passed
    total_tests = total_tests + portfolio_total
    Print("")
    
    Note: Run behavioral economics tests
    Let [behavioral_passed, behavioral_total] be test_behavioral_economics()
    total_passed = total_passed + behavioral_passed
    total_tests = total_tests + behavioral_total
    Print("")
    
    Note: Run econometric modeling tests
    Let [econometric_passed, econometric_total] be test_econometric_modeling()
    total_passed = total_passed + econometric_passed
    total_tests = total_tests + econometric_total
    Print("")
    
    Note: Run performance tests
    Let [performance_passed, performance_total] be test_economics_performance()
    total_passed = total_passed + performance_passed
    total_tests = total_tests + performance_total
    Print("")
    
    Note: Print final results
    Print("=== Mathematical Economics Test Results ===")
    Print("Total Tests Passed: " + total_passed.to_string() + "/" + total_tests.to_string())
    Let success_rate be (total_passed.to_float() / total_tests.to_float()) * 100.0
    Print("Success Rate: " + success_rate.to_string() + "%")
    
    If total_passed == total_tests:
        Print("✅ All mathematical economics tests passed!")
    Otherwise:
        Print("❌ Some mathematical economics tests failed.")
    
    Return [total_passed, total_tests]