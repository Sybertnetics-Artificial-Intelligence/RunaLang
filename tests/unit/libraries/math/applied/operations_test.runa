Note:
tests/unit/libraries/math/applied/operations_test.runa
Comprehensive tests for Operations Research Module

This test suite provides comprehensive testing for operations research capabilities
including linear programming, integer programming, network flow, transportation
problems, assignment problems, scheduling optimization, inventory management,
queuing theory, and decision analysis for optimization and management science.
:End Note

Import "math/applied/operations" as Operations
Import "math/core/operations" as MathOps

Note: =====================================================================
Note: TEST HELPER FUNCTIONS
Note: =====================================================================

Process called "assert_float_equals" that takes actual as Float and expected as Float and tolerance as Float returns Boolean:
    Let difference be MathOps.absolute_value(actual - expected)
    If difference <= tolerance:
        Return true
    Otherwise:
        Print("Expected: " + expected.to_string() + ", Actual: " + actual.to_string() + ", Difference: " + difference.to_string())
        Return false

Process called "assert_list_equals" that takes actual as List[Float] and expected as List[Float] and tolerance as Float returns Boolean:
    If actual.size() != expected.size():
        Print("List sizes differ: Expected " + expected.size().to_string() + ", Actual " + actual.size().to_string())
        Return false
    
    For i from 0 to actual.size() - 1:
        If not assert_float_equals(actual[i], expected[i], tolerance):
            Print("Lists differ at index " + i.to_string())
            Return false
    
    Return true

Process called "create_sample_linear_program" that returns Operations.LinearProgram:
    Note: Create a standard test linear program for consistent testing
    
    Let lp be Operations.LinearProgram
    lp.optimization_sense = "maximize"
    
    Note: Maximize 3x1 + 2x2
    lp.objective_coefficients = List[Float]([3.0, 2.0])
    
    Note: Subject to: x1 + x2 <= 4, 2x1 + x2 <= 6, x1,x2 >= 0
    lp.constraint_matrix = Operations.Matrix
    lp.constraint_matrix.entries = List[List[String]]()
    lp.constraint_matrix.entries.add(List[String](["1.0", "1.0"]))
    lp.constraint_matrix.entries.add(List[String](["2.0", "1.0"]))
    lp.constraint_matrix.rows = 2
    lp.constraint_matrix.columns = 2
    
    lp.constraint_bounds = List[Float]([4.0, 6.0])
    
    lp.variable_bounds = List[Operations.Bound]()
    Let bound1 be Operations.Bound
    bound1.lower = 0.0
    bound1.upper = Float.POSITIVE_INFINITY
    Let bound2 be Operations.Bound
    bound2.lower = 0.0
    bound2.upper = Float.POSITIVE_INFINITY
    lp.variable_bounds.add(bound1)
    lp.variable_bounds.add(bound2)
    
    Return lp

Process called "create_sample_network" that returns Operations.NetworkFlow:
    Note: Create a standard test network for consistent testing
    
    Let network be Operations.NetworkFlow
    
    network.nodes = List[Operations.Node]()
    network.nodes.add(Operations.Node("S"))  Note: Source
    network.nodes.add(Operations.Node("A"))
    network.nodes.add(Operations.Node("B"))
    network.nodes.add(Operations.Node("T"))  Note: Sink
    
    network.edges = List[Operations.Edge]()
    network.edges.add(Operations.Edge("S", "A"))
    network.edges.add(Operations.Edge("S", "B"))
    network.edges.add(Operations.Edge("A", "T"))
    network.edges.add(Operations.Edge("B", "T"))
    
    network.capacities = List[Float]([10.0, 8.0, 12.0, 6.0])
    network.costs = List[Float]([1.0, 2.0, 3.0, 1.5])
    network.demands = List[Float]([10.0, 0.0, 0.0, -10.0])  Note: Supply at S, demand at T
    
    Return network

Note: =====================================================================
Note: LINEAR PROGRAMMING TESTS
Note: =====================================================================

Process called "test_linear_programming" that returns [Integer, Integer]:
    Print("Testing Linear Programming...")
    
    Let passed be 0
    Let total be 0
    
    Let test_lp be create_sample_linear_program()
    
    Note: Test simplex method solution
    total = total + 1
    Let simplex_solution be Operations.solve_linear_program_simplex(test_lp)
    
    Note: Should find optimal solution
    If simplex_solution.status == "optimal":
        passed = passed + 1
    
    Note: Test dual problem construction
    total = total + 1
    Let dual_problem be Operations.construct_dual_problem(test_lp)
    
    Note: Dual should have correct dimensions
    If dual_problem.constraint_matrix.rows == test_lp.objective_coefficients.size() and
       dual_problem.objective_coefficients.size() == test_lp.constraint_bounds.size():
        passed = passed + 1
    
    Note: Test strong duality theorem
    total = total + 1
    Let dual_solution be Operations.solve_linear_program_simplex(dual_problem.primal_problem)
    
    Note: Primal and dual objective values should be equal at optimum
    If assert_float_equals(simplex_solution.objective_value, dual_solution.objective_value, 0.01):
        passed = passed + 1
    
    Note: Test sensitivity analysis
    total = total + 1
    Let sensitivity_analysis be Operations.perform_sensitivity_analysis(test_lp, simplex_solution)
    
    Note: Should provide shadow prices and reduced costs
    If sensitivity_analysis.shadow_prices.size() == test_lp.constraint_bounds.size():
        passed = passed + 1
    
    Note: Test parametric programming
    total = total + 1
    Let parameter_ranges be Operations.analyze_parameter_ranges(test_lp, "objective_coefficients")
    
    Note: Should identify valid parameter ranges
    If parameter_ranges.size() > 0:
        passed = passed + 1
    
    Note: Test degeneracy handling
    total = total + 1
    Let degenerate_lp be create_sample_linear_program()
    Note: Add a redundant constraint to create degeneracy
    degenerate_lp.constraint_matrix.entries.add(List[String](["0.5", "0.5"]))
    degenerate_lp.constraint_bounds.add(2.0)
    
    Let degenerate_solution be Operations.solve_linear_program_simplex(degenerate_lp)
    
    Note: Should handle degeneracy and find optimal solution
    If degenerate_solution.status == "optimal":
        passed = passed + 1
    
    Print("Linear Programming Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: INTEGER PROGRAMMING TESTS
Note: =====================================================================

Process called "test_integer_programming" that returns [Integer, Integer]:
    Print("Testing Integer Programming...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test integer program setup
    total = total + 1
    Let integer_program be Operations.IntegerProgram
    integer_program.linear_relaxation = create_sample_linear_program()
    integer_program.integer_variables = List[Integer]([0, 1])  Note: Both variables are integer
    integer_program.binary_variables = List[Integer]()
    integer_program.branching_strategy = "most_fractional"
    
    Note: Should create proper integer program structure
    If integer_program.integer_variables.size() == 2:
        passed = passed + 1
    
    Note: Test branch and bound algorithm
    total = total + 1
    Let bb_solution be Operations.solve_integer_program_branch_and_bound(integer_program)
    
    Note: Should find integer solution
    If bb_solution.status == "optimal" and 
       MathOps.absolute_value(bb_solution.solution[0] - MathOps.round(bb_solution.solution[0])) < 0.001:
        passed = passed + 1
    
    Note: Test cutting plane method
    total = total + 1
    Let cutting_planes be Operations.generate_gomory_cuts(integer_program)
    
    Note: Should generate valid cutting planes
    If cutting_planes.size() > 0:
        passed = passed + 1
    
    Note: Test knapsack problem (0-1 integer programming)
    total = total + 1
    Let knapsack_values be List[Float]([60.0, 100.0, 120.0])
    Let knapsack_weights be List[Float]([10.0, 20.0, 30.0])
    Let knapsack_capacity be 50.0
    
    Let knapsack_solution be Operations.solve_knapsack_problem(knapsack_values, knapsack_weights, knapsack_capacity)
    
    Note: Should select optimal items within capacity constraint
    Let total_weight be 0.0
    For i from 0 to knapsack_solution.selected_items.size() - 1:
        If knapsack_solution.selected_items[i]:
            total_weight = total_weight + knapsack_weights[i]
    
    If total_weight <= knapsack_capacity:
        passed = passed + 1
    
    Note: Test set covering problem
    total = total + 1
    Let universe be List[Integer]([1, 2, 3, 4, 5])
    Let subsets be List[List[Integer]]()
    subsets.add(List[Integer]([1, 2, 3]))
    subsets.add(List[Integer]([2, 4]))
    subsets.add(List[Integer]([3, 4, 5]))
    subsets.add(List[Integer]([1, 5]))
    
    Let subset_costs be List[Float]([3.0, 2.0, 4.0, 2.5])
    Let set_cover_solution be Operations.solve_set_covering_problem(universe, subsets, subset_costs)
    
    Note: Should cover all elements with minimum cost
    If set_cover_solution.total_cost > 0.0 and set_cover_solution.selected_subsets.size() > 0:
        passed = passed + 1
    
    Note: Test traveling salesman problem (TSP)
    total = total + 1
    Let distance_matrix be List[List[Float]]()
    distance_matrix.add(List[Float]([0.0, 10.0, 15.0, 20.0]))
    distance_matrix.add(List[Float]([10.0, 0.0, 35.0, 25.0]))
    distance_matrix.add(List[Float]([15.0, 35.0, 0.0, 30.0]))
    distance_matrix.add(List[Float]([20.0, 25.0, 30.0, 0.0]))
    
    Let tsp_solution be Operations.solve_tsp_branch_and_bound(distance_matrix)
    
    Note: Should find valid tour visiting all cities
    If tsp_solution.tour.size() == 4 and tsp_solution.total_distance > 0.0:
        passed = passed + 1
    
    Print("Integer Programming Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: NETWORK OPTIMIZATION TESTS
Note: =====================================================================

Process called "test_network_optimization" that returns [Integer, Integer]:
    Print("Testing Network Optimization...")
    
    Let passed be 0
    Let total be 0
    
    Let test_network be create_sample_network()
    
    Note: Test maximum flow problem
    total = total + 1
    Let max_flow_problem be Operations.MaximumFlowProblem
    max_flow_problem.source = 0  Note: Node S
    max_flow_problem.sink = 3    Note: Node T
    
    Let max_flow_solution be Operations.solve_maximum_flow_ford_fulkerson(test_network, max_flow_problem)
    
    Note: Flow should be positive and respect capacity constraints
    If max_flow_solution.max_flow_value > 0.0 and max_flow_solution.max_flow_value <= 10.0:
        passed = passed + 1
    
    Note: Test minimum cost flow problem
    total = total + 1
    Let min_cost_flow be Operations.solve_minimum_cost_flow(test_network)
    
    Note: Should find feasible flow with minimum cost
    If min_cost_flow.status == "optimal":
        passed = passed + 1
    
    Note: Test shortest path problem (Dijkstra's algorithm)
    total = total + 1
    Let shortest_path_problem be Operations.ShortestPathProblem
    shortest_path_problem.source_node = 0
    shortest_path_problem.destination_node = 3
    
    Let shortest_path_solution be Operations.solve_shortest_path_dijkstra(test_network, shortest_path_problem)
    
    Note: Should find shortest path from source to destination
    If shortest_path_solution.shortest_paths.size() > 0:
        passed = passed + 1
    
    Note: Test all-pairs shortest paths (Floyd-Warshall)
    total = total + 1
    Let all_pairs_distances be Operations.solve_all_pairs_shortest_paths_floyd_warshall(test_network)
    
    Note: Should compute distances between all pairs of nodes
    If all_pairs_distances.rows == test_network.nodes.size() and
       all_pairs_distances.columns == test_network.nodes.size():
        passed = passed + 1
    
    Note: Test minimum spanning tree (Kruskal's algorithm)
    total = total + 1
    Let mst_solution be Operations.find_minimum_spanning_tree_kruskal(test_network)
    
    Note: MST should have n-1 edges for n nodes
    If mst_solution.edges.size() == test_network.nodes.size() - 1:
        passed = passed + 1
    
    Note: Test network reliability analysis
    total = total + 1
    Let edge_reliabilities be List[Float]([0.9, 0.85, 0.95, 0.8])
    Let network_reliability be Operations.calculate_network_reliability(test_network, edge_reliabilities)
    
    Note: Network reliability should be between 0 and 1
    If network_reliability >= 0.0 and network_reliability <= 1.0:
        passed = passed + 1
    
    Print("Network Optimization Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: SCHEDULING OPTIMIZATION TESTS
Note: =====================================================================

Process called "test_scheduling_optimization" that returns [Integer, Integer]:
    Print("Testing Scheduling Optimization...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test job shop scheduling
    total = total + 1
    Let jobs be List[Operations.Job]()
    
    Let job1 be Operations.Job
    job1.job_id = "J1"
    job1.processing_times = List[Float]([3.0, 2.0, 1.0])
    job1.machine_sequence = List[Integer]([1, 2, 3])
    job1.due_date = 10.0
    job1.priority = 1
    
    Let job2 be Operations.Job
    job2.job_id = "J2"
    job2.processing_times = List[Float]([2.0, 1.0, 3.0])
    job2.machine_sequence = List[Integer]([2, 1, 3])
    job2.due_date = 8.0
    job2.priority = 2
    
    jobs.add(job1)
    jobs.add(job2)
    
    Let scheduling_problem be Operations.SchedulingProblem
    scheduling_problem.jobs = jobs
    scheduling_problem.machines = List[Operations.Machine]()
    scheduling_problem.machines.add(Operations.Machine("M1"))
    scheduling_problem.machines.add(Operations.Machine("M2"))
    scheduling_problem.machines.add(Operations.Machine("M3"))
    
    Let job_shop_solution be Operations.solve_job_shop_scheduling(scheduling_problem)
    
    Note: Should provide feasible schedule
    If job_shop_solution.makespan > 0.0:
        passed = passed + 1
    
    Note: Test single machine scheduling with due dates
    total = total + 1
    Let single_machine_jobs be List[Operations.Job]()
    single_machine_jobs.add(job1)
    single_machine_jobs.add(job2)
    
    Let earliest_due_date_solution be Operations.schedule_earliest_due_date(single_machine_jobs)
    
    Note: Should minimize maximum lateness
    If earliest_due_date_solution.total_lateness >= 0.0:
        passed = passed + 1
    
    Note: Test flow shop scheduling
    total = total + 1
    Let flow_shop_solution be Operations.solve_flow_shop_johnson_algorithm(jobs)
    
    Note: Johnson's algorithm should minimize makespan for 2-machine flow shop
    If flow_shop_solution.makespan > 0.0:
        passed = passed + 1
    
    Note: Test resource-constrained project scheduling
    total = total + 1
    Let activities be List[Operations.Activity]()
    
    Let activity1 be Operations.Activity
    activity1.activity_id = "A1"
    activity1.duration = 3.0
    activity1.resource_requirements = List[Float]([2.0, 1.0])
    activity1.predecessors = List[String]()
    
    Let activity2 be Operations.Activity
    activity2.activity_id = "A2"
    activity2.duration = 2.0
    activity2.resource_requirements = List[Float]([1.0, 2.0])
    activity2.predecessors = List[String](["A1"])
    
    activities.add(activity1)
    activities.add(activity2)
    
    Let resource_capacities be List[Float]([3.0, 3.0])
    Let rcpsp_solution be Operations.solve_resource_constrained_project_scheduling(activities, resource_capacities)
    
    Note: Should respect resource constraints and precedence
    If rcpsp_solution.project_duration > 0.0:
        passed = passed + 1
    
    Note: Test crew scheduling problem
    total = total + 1
    Let shifts be List[Operations.Shift]()
    shifts.add(Operations.Shift("Morning", 8, 16))
    shifts.add(Operations.Shift("Evening", 16, 24))
    shifts.add(Operations.Shift("Night", 0, 8))
    
    Let crew_requirements be List[Integer]([5, 3, 2])  Note: Workers needed per shift
    
    Let crew_schedule be Operations.solve_crew_scheduling_problem(shifts, crew_requirements, 20)  Note: 20 available workers
    
    Note: Should assign sufficient workers to each shift
    If crew_schedule.total_assignments >= crew_requirements[0] + crew_requirements[1] + crew_requirements[2]:
        passed = passed + 1
    
    Note: Test nurse scheduling with constraints
    total = total + 1
    Let nurses be List[Operations.Nurse]()
    nurses.add(Operations.Nurse("Nurse1", ["Morning", "Evening"], 40))  Note: Available shifts, max hours
    nurses.add(Operations.Nurse("Nurse2", ["Evening", "Night"], 35))
    
    Let nurse_schedule be Operations.solve_nurse_scheduling_problem(nurses, shifts, crew_requirements)
    
    Note: Should respect individual constraints and coverage requirements
    If nurse_schedule.feasible:
        passed = passed + 1
    
    Print("Scheduling Optimization Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: QUEUING THEORY TESTS
Note: =====================================================================

Process called "test_queuing_theory" that returns [Integer, Integer]:
    Print("Testing Queuing Theory...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test M/M/1 queue (Poisson arrivals, exponential service, 1 server)
    total = total + 1
    Let arrival_rate be 8.0      Note: customers/hour
    Let service_rate be 10.0     Note: customers/hour
    
    Let mm1_metrics be Operations.analyze_mm1_queue(arrival_rate, service_rate)
    
    Note: Utilization should be λ/μ
    Let expected_utilization be arrival_rate / service_rate
    If assert_float_equals(mm1_metrics.utilization, expected_utilization, 0.001):
        passed = passed + 1
    
    Note: Test M/M/c queue (multiple servers)
    total = total + 1
    Let num_servers be 3
    Let mmc_metrics be Operations.analyze_mmc_queue(arrival_rate, service_rate, num_servers)
    
    Note: Should have lower average waiting time than M/M/1
    If mmc_metrics.average_waiting_time < mm1_metrics.average_waiting_time:
        passed = passed + 1
    
    Note: Test M/G/1 queue (general service time distribution)
    total = total + 1
    Let service_variance be 0.25  Note: Variance of service time
    Let mg1_metrics be Operations.analyze_mg1_queue(arrival_rate, service_rate, service_variance)
    
    Note: Should use Pollaczek-Khinchine formula for waiting time
    If mg1_metrics.average_waiting_time > 0.0:
        passed = passed + 1
    
    Note: Test finite capacity queue M/M/1/N
    total = total + 1
    Let system_capacity be 5
    Let mm1n_metrics be Operations.analyze_mm1_finite_queue(arrival_rate, service_rate, system_capacity)
    
    Note: Should have blocking probability > 0 when λ > μ
    If mm1n_metrics.blocking_probability >= 0.0:
        passed = passed + 1
    
    Note: Test queue network (Jackson network)
    total = total + 1
    Let network_nodes be List[Operations.QueueNode]()
    
    Let node1 be Operations.QueueNode
    node1.node_id = "N1"
    node1.service_rate = 12.0
    node1.external_arrival_rate = 5.0
    
    Let node2 be Operations.QueueNode
    node2.node_id = "N2"
    node2.service_rate = 8.0
    node2.external_arrival_rate = 3.0
    
    network_nodes.add(node1)
    network_nodes.add(node2)
    
    Let routing_matrix be List[List[Float]]()
    routing_matrix.add(List[Float]([0.0, 0.6]))  Note: 60% from N1 to N2
    routing_matrix.add(List[Float]([0.3, 0.0]))  Note: 30% from N2 to N1
    
    Let jackson_network_metrics be Operations.analyze_jackson_network(network_nodes, routing_matrix)
    
    Note: Should compute performance metrics for network
    If jackson_network_metrics.total_customers > 0.0:
        passed = passed + 1
    
    Note: Test priority queue
    total = total + 1
    Let priority_classes be List[Operations.PriorityClass]()
    priority_classes.add(Operations.PriorityClass(1, 3.0, 12.0))  Note: Priority 1, arrival rate 3, service rate 12
    priority_classes.add(Operations.PriorityClass(2, 5.0, 12.0))  Note: Priority 2, arrival rate 5, service rate 12
    
    Let priority_queue_metrics be Operations.analyze_priority_queue(priority_classes, "preemptive")
    
    Note: Higher priority class should have lower waiting time
    If priority_queue_metrics[0].average_waiting_time <= priority_queue_metrics[1].average_waiting_time:
        passed = passed + 1
    
    Print("Queuing Theory Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: INVENTORY MANAGEMENT TESTS
Note: =====================================================================

Process called "test_inventory_management" that returns [Integer, Integer]:
    Print("Testing Inventory Management...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test Economic Order Quantity (EOQ) model
    total = total + 1
    Let annual_demand be 1000.0
    Let ordering_cost be 50.0
    Let holding_cost_per_unit be 2.0
    
    Let eoq_model be Operations.calculate_eoq_model(annual_demand, ordering_cost, holding_cost_per_unit)
    
    Note: EOQ = sqrt(2*D*S/H)
    Let expected_eoq be MathOps.square_root(2.0 * annual_demand * ordering_cost / holding_cost_per_unit)
    If assert_float_equals(eoq_model.optimal_order_quantity, expected_eoq, 1.0):
        passed = passed + 1
    
    Note: Test EOQ with quantity discounts
    total = total + 1
    Let price_breaks be List[Operations.PriceBreak]()
    price_breaks.add(Operations.PriceBreak(0, 999, 10.0))    Note: Quantity range 0-999, price $10
    price_breaks.add(Operations.PriceBreak(1000, 4999, 9.5)) Note: Quantity range 1000-4999, price $9.5
    price_breaks.add(Operations.PriceBreak(5000, Integer.MAX_VALUE, 9.0)) Note: Quantity 5000+, price $9
    
    Let discount_eoq be Operations.calculate_eoq_with_discounts(annual_demand, ordering_cost, holding_cost_per_unit, price_breaks)
    
    Note: Should consider total cost including purchase cost
    If discount_eoq.total_annual_cost > 0.0:
        passed = passed + 1
    
    Note: Test reorder point model
    total = total + 1
    Let lead_time be 0.5  Note: 0.5 months
    Let demand_during_lead_time be annual_demand / 12.0 * lead_time  Note: Monthly demand * lead time
    Let safety_stock be 50.0
    
    Let reorder_point be Operations.calculate_reorder_point(demand_during_lead_time, safety_stock)
    
    Note: Reorder point = demand during lead time + safety stock
    Let expected_reorder_point be demand_during_lead_time + safety_stock
    If assert_float_equals(reorder_point, expected_reorder_point, 0.1):
        passed = passed + 1
    
    Note: Test (s,S) policy
    total = total + 1
    Let reorder_level be 200.0
    Let order_up_to_level be 500.0
    Let current_inventory be 150.0
    
    Let ss_policy_decision be Operations.evaluate_ss_policy(current_inventory, reorder_level, order_up_to_level)
    
    Note: Should order when inventory falls below s
    If ss_policy_decision.should_order and ss_policy_decision.order_quantity > 0.0:
        passed = passed + 1
    
    Note: Test newsvendor problem
    total = total + 1
    Let unit_cost be 5.0
    Let selling_price be 12.0
    Let salvage_value be 2.0
    Let demand_mean be 100.0
    Let demand_std_dev be 20.0
    
    Let newsvendor_solution be Operations.solve_newsvendor_problem(unit_cost, selling_price, salvage_value, demand_mean, demand_std_dev)
    
    Note: Optimal quantity should balance overstocking and understocking costs
    If newsvendor_solution.optimal_quantity > 0.0:
        passed = passed + 1
    
    Note: Test multi-period inventory model
    total = total + 1
    Let periods be 12
    Let period_demands be List[Float]()
    For i from 0 to periods - 1:
        period_demands.add(annual_demand / 12.0 + MathOps.random() * 20.0 - 10.0)  Note: Monthly demand with variation
    
    Let multi_period_policy be Operations.optimize_multi_period_inventory(period_demands, ordering_cost, holding_cost_per_unit, 0.95)  Note: 95% service level
    
    Note: Should provide ordering policy for each period
    If multi_period_policy.period_orders.size() == periods:
        passed = passed + 1
    
    Print("Inventory Management Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: PERFORMANCE BENCHMARKING TESTS
Note: =====================================================================

Process called "test_operations_research_performance" that returns [Integer, Integer]:
    Print("Testing Operations Research Performance...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test large linear program solving performance
    total = total + 1
    Let large_lp be Operations.LinearProgram
    large_lp.optimization_sense = "maximize"
    
    Note: Create LP with 50 variables and 25 constraints
    large_lp.objective_coefficients = List[Float]()
    For i from 0 to 49:
        large_lp.objective_coefficients.add(MathOps.random() * 10.0)
    
    large_lp.constraint_matrix = Operations.Matrix
    large_lp.constraint_matrix.entries = List[List[String]]()
    For i from 0 to 24:  Note: 25 constraints
        Let row be List[String]()
        For j from 0 to 49:  Note: 50 variables
            row.add((MathOps.random() * 5.0).to_string())
        large_lp.constraint_matrix.entries.add(row)
    
    Let start_time be Operations.get_current_time()
    Let large_lp_solution be Operations.solve_linear_program_simplex(large_lp)
    Let lp_solve_time be Operations.get_current_time() - start_time
    
    Note: Large LP should solve within reasonable time
    If lp_solve_time < 5.0:  Note: 5 seconds
        passed = passed + 1
    
    Note: Test network optimization performance
    total = total + 1
    Let large_network be Operations.NetworkFlow
    large_network.nodes = List[Operations.Node]()
    For i from 0 to 99:  Note: 100 nodes
        large_network.nodes.add(Operations.Node("N" + i.to_string()))
    
    large_network.edges = List[Operations.Edge]()
    For i from 0 to 98:  Note: Create path edges
        large_network.edges.add(Operations.Edge("N" + i.to_string(), "N" + (i + 1).to_string()))
    
    Let network_start_time be Operations.get_current_time()
    Let shortest_path be Operations.solve_shortest_path_dijkstra(large_network, 
        Operations.ShortestPathProblem("0", "99"))
    Let network_solve_time be Operations.get_current_time() - network_start_time
    
    Note: Network optimization should be reasonably fast
    If network_solve_time < 2.0:  Note: 2 seconds
        passed = passed + 1
    
    Note: Test parallel optimization
    total = total + 1
    Let optimization_problems be List[Operations.LinearProgram]()
    For i from 0 to 19:  Note: 20 problems
        optimization_problems.add(create_sample_linear_program())
    
    Let parallel_start be Operations.get_current_time()
    Let parallel_solutions be Operations.solve_linear_programs_parallel(optimization_problems, 4)  Note: 4 threads
    Let parallel_time be Operations.get_current_time() - parallel_start
    
    Note: Parallel solving should show efficiency gains
    If parallel_solutions.size() == 20 and parallel_time < 3.0:
        passed = passed + 1
    
    Note: Test memory efficiency
    total = total + 1
    Let memory_before be Operations.get_memory_usage()
    Let temp_networks be List[Operations.NetworkFlow]()
    For i from 0 to 49:  Note: 50 networks
        temp_networks.add(create_sample_network())
    Let memory_after be Operations.get_memory_usage()
    
    Note: Memory usage should be reasonable
    Let memory_increase be memory_after - memory_before
    If memory_increase < 25.0:  Note: Less than 25MB
        passed = passed + 1
    
    Print("Operations Research Performance Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: MAIN TEST RUNNER
Note: =====================================================================

Process called "run_all_operations_tests" that returns [Integer, Integer]:
    Print("=== Running All Operations Research Tests ===")
    
    Let total_passed be 0
    Let total_tests be 0
    
    Note: Run linear programming tests
    Let [lp_passed, lp_total] be test_linear_programming()
    total_passed = total_passed + lp_passed
    total_tests = total_tests + lp_total
    Print("")
    
    Note: Run integer programming tests
    Let [ip_passed, ip_total] be test_integer_programming()
    total_passed = total_passed + ip_passed
    total_tests = total_tests + ip_total
    Print("")
    
    Note: Run network optimization tests
    Let [network_passed, network_total] be test_network_optimization()
    total_passed = total_passed + network_passed
    total_tests = total_tests + network_total
    Print("")
    
    Note: Run scheduling optimization tests
    Let [scheduling_passed, scheduling_total] be test_scheduling_optimization()
    total_passed = total_passed + scheduling_passed
    total_tests = total_tests + scheduling_total
    Print("")
    
    Note: Run queuing theory tests
    Let [queuing_passed, queuing_total] be test_queuing_theory()
    total_passed = total_passed + queuing_passed
    total_tests = total_tests + queuing_total
    Print("")
    
    Note: Run inventory management tests
    Let [inventory_passed, inventory_total] be test_inventory_management()
    total_passed = total_passed + inventory_passed
    total_tests = total_tests + inventory_total
    Print("")
    
    Note: Run performance tests
    Let [performance_passed, performance_total] be test_operations_research_performance()
    total_passed = total_passed + performance_passed
    total_tests = total_tests + performance_total
    Print("")
    
    Note: Print final results
    Print("=== Operations Research Test Results ===")
    Print("Total Tests Passed: " + total_passed.to_string() + "/" + total_tests.to_string())
    Let success_rate be (total_passed.to_float() / total_tests.to_float()) * 100.0
    Print("Success Rate: " + success_rate.to_string() + "%")
    
    If total_passed == total_tests:
        Print("✅ All operations research tests passed!")
    Otherwise:
        Print("❌ Some operations research tests failed.")
    
    Return [total_passed, total_tests]