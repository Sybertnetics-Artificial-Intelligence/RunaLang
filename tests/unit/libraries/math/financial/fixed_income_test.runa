Note:
tests/unit/libraries/math/financial/fixed_income_test.runa
Comprehensive tests for Fixed Income Securities and Bond Analysis

This test suite provides comprehensive testing for fixed income analysis including 
bond pricing, yield calculations, duration and convexity analysis, yield curve 
construction, term structure models, credit risk assessment, and bond portfolio 
management for quantitative fixed income investment and risk management.
:End Note

Import "math/financial/fixed_income" as FixedIncome
Import "math/core/operations" as MathOps

Note: =====================================================================
Note: TEST HELPER FUNCTIONS
Note: =====================================================================

Process called "assert_float_equals" that takes actual as Float and expected as Float and tolerance as Float returns Boolean:
    Let difference be MathOps.absolute_value(actual - expected)
    If difference <= tolerance:
        Return true
    Otherwise:
        Print("Expected: " + expected.to_string() + ", Actual: " + actual.to_string() + ", Difference: " + difference.to_string())
        Return false

Process called "assert_list_equals" that takes actual as List[Float] and expected as List[Float] and tolerance as Float returns Boolean:
    If actual.size() != expected.size():
        Print("List sizes differ: Expected " + expected.size().to_string() + ", Actual " + actual.size().to_string())
        Return false
    
    For i from 0 to actual.size() - 1:
        If not assert_float_equals(actual[i], expected[i], tolerance):
            Print("Lists differ at index " + i.to_string())
            Return false
    
    Return true

Process called "create_sample_bond" that returns FixedIncome.BondContract:
    Note: Create a standard test bond for consistent testing
    
    Let call_schedule be FixedIncome.CallSchedule
    call_schedule.call_date = 1735689600  Note: 2025-01-01
    call_schedule.call_price = 102.0
    call_schedule.call_type = "American"
    
    Let put_schedule be FixedIncome.PutSchedule 
    put_schedule.put_date = 1767225600  Note: 2026-01-01
    put_schedule.put_price = 99.0
    put_schedule.put_type = "European"
    
    Let bond be FixedIncome.BondContract
    bond.bond_id = "TEST001"
    bond.issuer = "Test Corporation"
    bond.coupon_rate = 0.05  Note: 5% annual coupon
    bond.face_value = 1000.0
    bond.maturity_date = 1830297600  Note: 2028-01-01
    bond.issue_date = 1672531200  Note: 2023-01-01
    bond.bond_type = "Corporate"
    bond.payment_frequency = 2  Note: Semi-annual
    bond.credit_rating = "AA"
    bond.callable = true
    bond.putable = true
    bond.call_schedules = List[FixedIncome.CallSchedule]()
    bond.call_schedules.add(call_schedule)
    bond.put_schedules = List[FixedIncome.PutSchedule]()
    bond.put_schedules.add(put_schedule)
    
    Return bond

Process called "create_test_yield_curve" that returns FixedIncome.YieldCurve:
    Note: Create a test yield curve for bond pricing
    
    Let curve be FixedIncome.YieldCurve
    curve.curve_id = "TEST_CURVE"
    curve.curve_date = 1704067200  Note: 2024-01-01
    curve.maturities = List[Float]()
    curve.yields = List[Float]()
    
    Note: Add typical yield curve points (3m, 6m, 1y, 2y, 5y, 10y, 30y)
    curve.maturities.add(0.25)
    curve.maturities.add(0.5)
    curve.maturities.add(1.0)
    curve.maturities.add(2.0)
    curve.maturities.add(5.0)
    curve.maturities.add(10.0)
    curve.maturities.add(30.0)
    
    curve.yields.add(0.02)  Note: 2% for 3m
    curve.yields.add(0.025) Note: 2.5% for 6m
    curve.yields.add(0.03)  Note: 3% for 1y
    curve.yields.add(0.035) Note: 3.5% for 2y
    curve.yields.add(0.04)  Note: 4% for 5y
    curve.yields.add(0.045) Note: 4.5% for 10y
    curve.yields.add(0.05)  Note: 5% for 30y
    
    curve.curve_type = "Government"
    curve.currency = "USD"
    curve.interpolation_method = "CubicSpline"
    curve.smoothing_parameters = Dictionary[String, Float]()
    
    Return curve

Note: =====================================================================
Note: BOND PRICING TESTS
Note: =====================================================================

Process called "test_bond_pricing" that returns [Integer, Integer]:
    Print("Testing Bond Pricing...")
    
    Let passed be 0
    Let total be 0
    
    Let test_bond be create_sample_bond()
    Let yield_curve be create_test_yield_curve()
    Let settlement_date be 1704067200  Note: 2024-01-01
    
    Note: Test basic bond pricing
    total = total + 1
    Let bond_price be FixedIncome.price_bond(test_bond, 0.04, settlement_date)
    
    Note: Bond price should be positive and reasonable
    If bond_price.clean_price > 0.0 and bond_price.clean_price < test_bond.face_value * 2.0:
        passed = passed + 1
    
    Note: Test dirty price calculation
    total = total + 1
    If bond_price.dirty_price > bond_price.clean_price:
        passed = passed + 1
    
    Note: Test yield-to-maturity calculation
    total = total + 1
    Let ytm be FixedIncome.calculate_yield_to_maturity(test_bond, bond_price.clean_price, settlement_date)
    
    Note: YTM should be approximately equal to the discount rate used (4%)
    If assert_float_equals(ytm, 0.04, 0.001):
        passed = passed + 1
    
    Note: Test price-yield relationship (bond prices move inverse to yields)
    total = total + 1
    Let higher_yield_price be FixedIncome.price_bond(test_bond, 0.06, settlement_date)
    If higher_yield_price.clean_price < bond_price.clean_price:
        passed = passed + 1
    
    Note: Test zero-coupon bond pricing
    total = total + 1
    Let zero_bond be create_sample_bond()
    zero_bond.coupon_rate = 0.0
    Let zero_price be FixedIncome.price_bond(zero_bond, 0.04, settlement_date)
    
    Note: Zero-coupon bond should trade at discount
    If zero_price.clean_price < zero_bond.face_value:
        passed = passed + 1
    
    Print("Bond Pricing Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Process called "test_cash_flow_generation" that returns [Integer, Integer]:
    Print("Testing Cash Flow Generation...")
    
    Let passed be 0
    Let total be 0
    
    Let test_bond be create_sample_bond()
    Let settlement_date be 1704067200  Note: 2024-01-01
    
    Note: Test cash flow schedule generation
    total = total + 1
    Let cash_flows be FixedIncome.generate_bond_cash_flows(test_bond, settlement_date)
    
    Note: Should generate appropriate number of cash flows (semi-annual from 2024 to 2028)
    Let expected_payments be 8  Note: 4 years * 2 payments per year
    If cash_flows.payment_dates.size() == expected_payments:
        passed = passed + 1
    
    Note: Test coupon payment calculation
    total = total + 1
    Let expected_coupon be test_bond.face_value * (test_bond.coupon_rate / 2.0)  Note: Semi-annual
    If assert_float_equals(cash_flows.coupon_payments[0], expected_coupon, 0.01):
        passed = passed + 1
    
    Note: Test final principal payment
    total = total + 1
    Let final_payment_index be cash_flows.total_cash_flows.size() - 1
    Let final_total_payment be cash_flows.total_cash_flows[final_payment_index]
    Let expected_final be expected_coupon + test_bond.face_value
    
    If assert_float_equals(final_total_payment, expected_final, 0.01):
        passed = passed + 1
    
    Note: Test present value calculations
    total = total + 1
    Let total_pv be 0.0
    For pv in cash_flows.present_values:
        total_pv = total_pv + pv
    
    Note: Total PV should approximate bond price
    If total_pv > 0.0:
        passed = passed + 1
    
    Note: Test accrued interest calculation
    total = total + 1
    Let days_from_last_coupon be 30  Note: 30 days
    Let accrued be FixedIncome.calculate_accrued_interest(test_bond, settlement_date, days_from_last_coupon)
    
    Note: Accrued interest should be positive and less than full coupon
    If accrued > 0.0 and accrued < expected_coupon:
        passed = passed + 1
    
    Print("Cash Flow Generation Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: DURATION AND CONVEXITY TESTS
Note: =====================================================================

Process called "test_duration_convexity" that returns [Integer, Integer]:
    Print("Testing Duration and Convexity Analysis...")
    
    Let passed be 0
    Let total be 0
    
    Let test_bond be create_sample_bond()
    Let settlement_date be 1704067200
    Let yield_rate be 0.04
    
    Note: Test modified duration calculation
    total = total + 1
    Let duration_convexity be FixedIncome.calculate_duration_convexity(test_bond, yield_rate, settlement_date)
    
    Note: Modified duration should be positive and reasonable for 4-year bond
    If duration_convexity.modified_duration > 0.0 and duration_convexity.modified_duration < 4.0:
        passed = passed + 1
    
    Note: Test Macaulay duration relationship
    total = total + 1
    Let expected_modified be duration_convexity.macaulay_duration / (1.0 + yield_rate / 2.0)
    If assert_float_equals(duration_convexity.modified_duration, expected_modified, 0.01):
        passed = passed + 1
    
    Note: Test convexity calculation
    total = total + 1
    If duration_convexity.convexity > 0.0:
        passed = passed + 1
    
    Note: Test price sensitivity using duration
    total = total + 1
    Let base_price be FixedIncome.price_bond(test_bond, yield_rate, settlement_date)
    Let yield_change be 0.001  Note: 10 basis points
    Let new_price be FixedIncome.price_bond(test_bond, yield_rate + yield_change, settlement_date)
    
    Note: Estimate price change using duration
    Let estimated_change be -duration_convexity.modified_duration * yield_change * base_price.clean_price
    Let actual_change be new_price.clean_price - base_price.clean_price
    
    Note: Duration estimate should be close to actual price change
    If assert_float_equals(estimated_change, actual_change, base_price.clean_price * 0.01):
        passed = passed + 1
    
    Note: Test convexity adjustment
    total = total + 1
    Let larger_yield_change be 0.01  Note: 100 basis points
    Let large_change_price be FixedIncome.price_bond(test_bond, yield_rate + larger_yield_change, settlement_date)
    
    Let duration_estimate be -duration_convexity.modified_duration * larger_yield_change * base_price.clean_price
    Let convexity_adjustment be 0.5 * duration_convexity.convexity * (larger_yield_change * larger_yield_change) * base_price.clean_price
    Let total_estimate be duration_estimate + convexity_adjustment
    Let large_actual_change be large_change_price.clean_price - base_price.clean_price
    
    Note: Duration + convexity should be more accurate than duration alone
    Let duration_error be MathOps.absolute_value(duration_estimate - large_actual_change)
    Let combined_error be MathOps.absolute_value(total_estimate - large_actual_change)
    
    If combined_error < duration_error:
        passed = passed + 1
    
    Print("Duration and Convexity Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: YIELD CURVE TESTS
Note: =====================================================================

Process called "test_yield_curve_operations" that returns [Integer, Integer]:
    Print("Testing Yield Curve Operations...")
    
    Let passed be 0
    Let total be 0
    
    Let yield_curve be create_test_yield_curve()
    
    Note: Test yield curve interpolation
    total = total + 1
    Let interpolated_yield be FixedIncome.interpolate_yield(yield_curve, 3.0)  Note: 3-year yield
    
    Note: Interpolated yield should be between 2-year and 5-year yields
    If interpolated_yield > 0.035 and interpolated_yield < 0.04:
        passed = passed + 1
    
    Note: Test forward rate calculation
    total = total + 1
    Let forward_rate be FixedIncome.calculate_forward_rate(yield_curve, 1.0, 2.0)
    
    Note: Forward rate should be positive
    If forward_rate > 0.0:
        passed = passed + 1
    
    Note: Test spot rate extraction
    total = total + 1
    Let spot_rates be FixedIncome.bootstrap_spot_rates(yield_curve)
    
    Note: Should generate same number of spot rates as yield points
    If spot_rates.size() == yield_curve.yields.size():
        passed = passed + 1
    
    Note: Test yield curve shifting
    total = total + 1
    Let shift_amount be 0.001  Note: 10 basis points
    Let shifted_curve be FixedIncome.shift_yield_curve(yield_curve, shift_amount)
    
    Note: All yields should be shifted by the same amount
    Let first_shift be shifted_curve.yields[0] - yield_curve.yields[0]
    If assert_float_equals(first_shift, shift_amount, 0.0001):
        passed = passed + 1
    
    Note: Test yield curve steepening
    total = total + 1
    Let steepening_factor be 0.5
    Let steepened_curve be FixedIncome.steepen_yield_curve(yield_curve, steepening_factor)
    
    Note: Long-term rates should increase more than short-term rates
    Let short_change be steepened_curve.yields[0] - yield_curve.yields[0]
    Let long_change be steepened_curve.yields[6] - yield_curve.yields[6]
    
    If long_change > short_change:
        passed = passed + 1
    
    Note: Test yield curve fitting
    total = total + 1
    Let market_prices be List[Float]()
    market_prices.add(1020.0)
    market_prices.add(1015.0)
    market_prices.add(1010.0)
    
    Let fitted_curve be FixedIncome.fit_yield_curve_to_prices(market_prices, yield_curve)
    
    Note: Fitted curve should have same structure
    If fitted_curve.maturities.size() == yield_curve.maturities.size():
        passed = passed + 1
    
    Print("Yield Curve Operations Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: CALLABLE AND PUTABLE BOND TESTS
Note: =====================================================================

Process called "test_embedded_options" that returns [Integer, Integer]:
    Print("Testing Embedded Options Pricing...")
    
    Let passed be 0
    Let total be 0
    
    Let callable_bond be create_sample_bond()
    Let yield_curve be create_test_yield_curve()
    Let settlement_date be 1704067200
    
    Note: Test callable bond pricing
    total = total + 1
    Let callable_price be FixedIncome.price_callable_bond(callable_bond, yield_curve, settlement_date)
    
    Note: Callable bond should trade below equivalent straight bond
    Let straight_bond be create_sample_bond()
    straight_bond.callable = false
    Let straight_price be FixedIncome.price_bond(straight_bond, 0.04, settlement_date)
    
    If callable_price.clean_price < straight_price.clean_price:
        passed = passed + 1
    
    Note: Test option-adjusted spread calculation
    total = total + 1
    Let oas be FixedIncome.calculate_option_adjusted_spread(callable_bond, callable_price.clean_price, yield_curve, settlement_date)
    
    Note: OAS should be positive for callable bond (compensation for call risk)
    If oas > 0.0:
        passed = passed + 1
    
    Note: Test effective duration for callable bond
    total = total + 1
    Let effective_duration be FixedIncome.calculate_effective_duration(callable_bond, yield_curve, settlement_date)
    
    Note: Effective duration should be positive but may be less than modified duration
    If effective_duration > 0.0:
        passed = passed + 1
    
    Note: Test putable bond pricing
    total = total + 1
    Let putable_bond be create_sample_bond()
    putable_bond.callable = false  Note: Only putable
    Let putable_price be FixedIncome.price_putable_bond(putable_bond, yield_curve, settlement_date)
    
    Note: Putable bond should trade above equivalent straight bond
    If putable_price.clean_price > straight_price.clean_price:
        passed = passed + 1
    
    Note: Test binomial tree pricing for embedded options
    total = total + 1
    Let tree_steps be 50
    Let binomial_price be FixedIncome.price_bond_binomial_tree(callable_bond, yield_curve, tree_steps, settlement_date)
    
    Note: Binomial price should be reasonable
    If binomial_price > 0.0 and binomial_price < callable_bond.face_value * 1.5:
        passed = passed + 1
    
    Print("Embedded Options Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: CREDIT RISK TESTS
Note: =====================================================================

Process called "test_credit_risk_analysis" that returns [Integer, Integer]:
    Print("Testing Credit Risk Analysis...")
    
    Let passed be 0
    Let total be 0
    
    Let corporate_bond be create_sample_bond()
    Let treasury_curve be create_test_yield_curve()
    
    Note: Test credit spread calculation
    total = total + 1
    Let credit_spread be FixedIncome.calculate_credit_spread(corporate_bond, treasury_curve, 1704067200)
    
    Note: Credit spread should be positive for corporate bond
    If credit_spread > 0.0:
        passed = passed + 1
    
    Note: Test default probability estimation
    total = total + 1
    Let default_prob be FixedIncome.estimate_default_probability(corporate_bond, credit_spread, 1.0)  Note: 1 year
    
    Note: Default probability should be between 0 and 1
    If default_prob >= 0.0 and default_prob <= 1.0:
        passed = passed + 1
    
    Note: Test loss given default calculation
    total = total + 1
    Let recovery_rate be 0.4  Note: 40% recovery
    Let lgd be FixedIncome.calculate_loss_given_default(corporate_bond, recovery_rate)
    
    Note: LGD should be 60% (1 - recovery rate)
    If assert_float_equals(lgd, 0.6, 0.01):
        passed = passed + 1
    
    Note: Test expected loss calculation
    total = total + 1
    Let expected_loss be FixedIncome.calculate_expected_loss(default_prob, lgd, corporate_bond.face_value)
    
    Note: Expected loss should be positive and less than face value
    If expected_loss > 0.0 and expected_loss < corporate_bond.face_value:
        passed = passed + 1
    
    Note: Test credit rating transition
    total = total + 1
    Let transition_matrix be FixedIncome.get_rating_transition_matrix("AA")
    
    Note: Transition matrix should be properly formed (probabilities sum to 1)
    Let row_sum be 0.0
    For prob in transition_matrix[0]:  Note: First row for AA rating
        row_sum = row_sum + prob
    
    If assert_float_equals(row_sum, 1.0, 0.001):
        passed = passed + 1
    
    Note: Test credit value adjustment
    total = total + 1
    Let cva be FixedIncome.calculate_credit_value_adjustment(corporate_bond, default_prob, lgd, 1704067200)
    
    Note: CVA should reduce bond value
    If cva < 0.0:
        passed = passed + 1
    
    Print("Credit Risk Analysis Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: BOND PORTFOLIO TESTS
Note: =====================================================================

Process called "test_bond_portfolio_management" that returns [Integer, Integer]:
    Print("Testing Bond Portfolio Management...")
    
    Let passed be 0
    Let total be 0
    
    Note: Create test portfolio
    Let bonds be List[FixedIncome.BondContract]()
    bonds.add(create_sample_bond())
    
    Let second_bond be create_sample_bond()
    second_bond.bond_id = "TEST002"
    second_bond.coupon_rate = 0.06
    second_bond.maturity_date = 1893456000  Note: 2030-01-01
    bonds.add(second_bond)
    
    Let weights be List[Float]()
    weights.add(0.6)
    weights.add(0.4)
    
    Note: Test portfolio duration calculation
    total = total + 1
    Let portfolio_duration be FixedIncome.calculate_portfolio_duration(bonds, weights, 0.04, 1704067200)
    
    Note: Portfolio duration should be weighted average
    If portfolio_duration > 0.0:
        passed = passed + 1
    
    Note: Test portfolio convexity
    total = total + 1
    Let portfolio_convexity be FixedIncome.calculate_portfolio_convexity(bonds, weights, 0.04, 1704067200)
    
    Note: Portfolio convexity should be positive
    If portfolio_convexity > 0.0:
        passed = passed + 1
    
    Note: Test immunization strategy
    total = total + 1
    Let liability_duration be 3.5
    Let immunized_weights be FixedIncome.immunize_portfolio(bonds, liability_duration, 0.04, 1704067200)
    
    Note: Weights should sum to 1
    Let weight_sum be 0.0
    For weight in immunized_weights:
        weight_sum = weight_sum + weight
    
    If assert_float_equals(weight_sum, 1.0, 0.001):
        passed = passed + 1
    
    Note: Test barbell vs bullet strategy
    total = total + 1
    Let barbell_performance be FixedIncome.analyze_barbell_strategy(bonds, weights)
    Let bullet_performance be FixedIncome.analyze_bullet_strategy(bonds, weights)
    
    Note: Should provide performance metrics for both strategies
    If barbell_performance.contains_key("duration") and bullet_performance.contains_key("duration"):
        passed = passed + 1
    
    Note: Test ladder strategy
    total = total + 1
    Let ladder_bonds be FixedIncome.construct_bond_ladder(1000000.0, 5, 0.04)  Note: $1M over 5 years
    
    Note: Should create bonds with staggered maturities
    If ladder_bonds.size() == 5:
        passed = passed + 1
    
    Print("Bond Portfolio Management Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: PERFORMANCE BENCHMARKING TESTS
Note: =====================================================================

Process called "test_fixed_income_performance" that returns [Integer, Integer]:
    Print("Testing Fixed Income Performance...")
    
    Let passed be 0
    Let total be 0
    
    Note: Test pricing performance with large portfolios
    total = total + 1
    Let large_portfolio be List[FixedIncome.BondContract]()
    For i from 0 to 99:  Note: 100 bonds
        Let bond be create_sample_bond()
        bond.bond_id = "PERF" + i.to_string()
        large_portfolio.add(bond)
    
    Let start_time be FixedIncome.get_current_time()
    Let portfolio_values be FixedIncome.price_bond_portfolio(large_portfolio, 0.04, 1704067200)
    Let pricing_time be FixedIncome.get_current_time() - start_time
    
    Note: Should price 100 bonds within 2 seconds
    If pricing_time < 2.0 and portfolio_values.size() == 100:
        passed = passed + 1
    
    Note: Test yield curve construction performance
    total = total + 1
    Let market_data be List[Float]()
    For i from 0 to 49:  Note: 50 market instruments
        market_data.add(0.03 + (i.to_float() * 0.0004))
    
    Let curve_start_time be FixedIncome.get_current_time()
    Let constructed_curve be FixedIncome.bootstrap_yield_curve(market_data)
    Let curve_construction_time be FixedIncome.get_current_time() - curve_start_time
    
    Note: Curve construction should complete within 1 second
    If curve_construction_time < 1.0:
        passed = passed + 1
    
    Note: Test option-adjusted spread calculation performance
    total = total + 1
    Let callable_bonds be List[FixedIncome.BondContract]()
    For i from 0 to 9:  Note: 10 callable bonds
        Let bond be create_sample_bond()
        bond.bond_id = "CALL" + i.to_string()
        callable_bonds.add(bond)
    
    Let oas_start_time be FixedIncome.get_current_time()
    Let oas_values be FixedIncome.calculate_portfolio_oas(callable_bonds, constructed_curve, 1704067200)
    Let oas_calculation_time be FixedIncome.get_current_time() - oas_start_time
    
    Note: OAS calculation should complete within 3 seconds
    If oas_calculation_time < 3.0:
        passed = passed + 1
    
    Note: Test memory efficiency
    total = total + 1
    Let memory_before be FixedIncome.get_memory_usage()
    Let temp_bonds be List[FixedIncome.BondContract]()
    For i from 0 to 499:  Note: 500 bonds
        temp_bonds.add(create_sample_bond())
    Let memory_after be FixedIncome.get_memory_usage()
    
    Note: Memory increase should be reasonable (less than 50MB)
    Let memory_increase be memory_after - memory_before
    If memory_increase < 50.0:
        passed = passed + 1
    
    Print("Fixed Income Performance Tests: " + passed.to_string() + "/" + total.to_string() + " passed")
    Return [passed, total]

Note: =====================================================================
Note: MAIN TEST RUNNER
Note: =====================================================================

Process called "run_all_fixed_income_tests" that returns [Integer, Integer]:
    Print("=== Running All Fixed Income Tests ===")
    
    Let total_passed be 0
    Let total_tests be 0
    
    Note: Run bond pricing tests
    Let [pricing_passed, pricing_total] be test_bond_pricing()
    total_passed = total_passed + pricing_passed
    total_tests = total_tests + pricing_total
    Print("")
    
    Note: Run cash flow tests
    Let [cashflow_passed, cashflow_total] be test_cash_flow_generation()
    total_passed = total_passed + cashflow_passed
    total_tests = total_tests + cashflow_total
    Print("")
    
    Note: Run duration convexity tests
    Let [duration_passed, duration_total] be test_duration_convexity()
    total_passed = total_passed + duration_passed
    total_tests = total_tests + duration_total
    Print("")
    
    Note: Run yield curve tests
    Let [curve_passed, curve_total] be test_yield_curve_operations()
    total_passed = total_passed + curve_passed
    total_tests = total_tests + curve_total
    Print("")
    
    Note: Run embedded options tests
    Let [options_passed, options_total] be test_embedded_options()
    total_passed = total_passed + options_passed
    total_tests = total_tests + options_total
    Print("")
    
    Note: Run credit risk tests
    Let [credit_passed, credit_total] be test_credit_risk_analysis()
    total_passed = total_passed + credit_passed
    total_tests = total_tests + credit_total
    Print("")
    
    Note: Run portfolio tests
    Let [portfolio_passed, portfolio_total] be test_bond_portfolio_management()
    total_passed = total_passed + portfolio_passed
    total_tests = total_tests + portfolio_total
    Print("")
    
    Note: Run performance tests
    Let [performance_passed, performance_total] be test_fixed_income_performance()
    total_passed = total_passed + performance_passed
    total_tests = total_tests + performance_total
    Print("")
    
    Note: Print final results
    Print("=== Fixed Income Test Results ===")
    Print("Total Tests Passed: " + total_passed.to_string() + "/" + total_tests.to_string())
    Let success_rate be (total_passed.to_float() / total_tests.to_float()) * 100.0
    Print("Success Rate: " + success_rate.to_string() + "%")
    
    If total_passed == total_tests:
        Print("✅ All fixed income tests passed!")
    Otherwise:
        Print("❌ Some fixed income tests failed.")
    
    Return [total_passed, total_tests]