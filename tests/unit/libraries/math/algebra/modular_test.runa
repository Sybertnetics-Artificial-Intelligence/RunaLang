Note: Comprehensive unit tests for math/algebra/modular.runa module
Note: Tests cover modular arithmetic, Chinese Remainder Theorem, quadratic residues, and cryptographic operations

Import "../../../../../../src/stdlib/math/algebra/modular" as ModularArithmetic
Import "../../../../../../src/stdlib/testing/framework" as Test

Note: Helper functions for creating test data

Process called "create_test_modular_integer" that takes value as Integer, modulus as Integer:
    Note: Creates a ModularInteger for testing
    Return ModularArithmetic.create_modular_integer(value, modulus)

Process called "create_test_coprime_moduli":
    Note: Creates list of coprime moduli for CRT testing
    Return [3, 5, 7]

Process called "create_test_non_coprime_moduli":
    Note: Creates list of non-coprime moduli for generalized CRT
    Return [6, 10, 15]

Process called "create_test_prime_modulus":
    Note: Returns a test prime for quadratic residue testing
    Return 17

Process called "assert_modular_integer_valid" that takes mod_int as ModularInteger, expected_value as Integer, expected_modulus as Integer:
    Note: Assert basic modular integer properties
    Test.assert_not_null(mod_int, "Modular integer should be created successfully")
    Test.assert_equal(mod_int.value, expected_value, "Should have expected value")
    Test.assert_equal(mod_int.modulus, expected_modulus, "Should have expected modulus")
    Test.assert_true(mod_int.is_reduced, "Value should be reduced modulo modulus")

Process called "assert_congruent" that takes a as Integer, b as Integer, modulus as Integer, message as String:
    Note: Assert that a ≡ b (mod modulus)
    Let remainder_a be a % modulus
    Let remainder_b be b % modulus
    Test.assert_equal(remainder_a, remainder_b, message)

Note: Basic Modular Arithmetic Tests

Process called "test_modular_add":
    Note: Test modular addition
    Let a be 15
    Let b be 23
    Let modulus be 17
    
    Let result be ModularArithmetic.modular_add(a, b, modulus)
    
    assert_congruent(result, 4, modulus, "15 + 23 ≡ 4 (mod 17)")

Process called "test_modular_multiply":
    Note: Test modular multiplication
    Let a be 12
    Let b be 15
    Let modulus be 17
    
    Let result be ModularArithmetic.modular_multiply(a, b, modulus)
    
    assert_congruent(result, 10, modulus, "12 × 15 ≡ 10 (mod 17)")

Process called "test_modular_exponentiation":
    Note: Test modular exponentiation
    Let base be 3
    Let exponent be 5
    Let modulus be 17
    
    Let result be ModularArithmetic.modular_exponentiation(base, exponent, modulus)
    
    assert_congruent(result, 5, modulus, "3^5 ≡ 5 (mod 17)")

Process called "test_modular_inverse":
    Note: Test modular inverse computation
    Let a be 3
    Let modulus be 17
    
    Let inverse be ModularArithmetic.modular_inverse(a, modulus)
    
    Test.assert_not_null(inverse, "Inverse should exist for coprime numbers")
    
    Let product be ModularArithmetic.modular_multiply(a, inverse, modulus)
    assert_congruent(product, 1, modulus, "a × a^(-1) ≡ 1 (mod m)")

Process called "test_fast_modular_reduction":
    Note: Test fast modular reduction
    Let large_value be 123456789
    Let modulus be 17
    
    Let result be ModularArithmetic.fast_modular_reduction(large_value, modulus)
    
    Test.assert_less(result, modulus, "Result should be less than modulus")
    assert_congruent(result, large_value, modulus, "Should be congruent to original value")

Process called "test_modular_sqrt":
    Note: Test modular square root
    Let quadratic_residue be 4  Note: 2^2 = 4
    Let modulus be 17
    
    Let square_roots be ModularArithmetic.modular_sqrt(quadratic_residue, modulus)
    
    Test.assert_not_empty(square_roots, "Should find square roots")
    
    For root in square_roots:
        Let square be ModularArithmetic.modular_multiply(root, root, modulus)
        assert_congruent(square, quadratic_residue, modulus, "Root squared should equal original value")

Note: Chinese Remainder Theorem Tests

Process called "test_chinese_remainder_theorem":
    Note: Test basic CRT with coprime moduli
    Let remainders be [2, 3, 2]  Note: x ≡ 2 (mod 3), x ≡ 3 (mod 5), x ≡ 2 (mod 7)
    Let moduli be create_test_coprime_moduli()
    
    Let crt_solution be ModularArithmetic.chinese_remainder_theorem(remainders, moduli)
    
    Test.assert_not_null(crt_solution, "CRT solution should exist")
    Test.assert_true(crt_solution.is_consistent, "System should be consistent")
    
    Note: Verify solution satisfies all congruences
    Let solution be crt_solution.solution
    For i in 0 to remainders.length - 1:
        assert_congruent(solution, remainders[i], moduli[i], "Solution should satisfy congruence " + i)

Process called "test_generalized_crt":
    Note: Test generalized CRT with non-coprime moduli
    Let remainders be [0, 4, 9]  Note: x ≡ 0 (mod 6), x ≡ 4 (mod 10), x ≡ 9 (mod 15)
    Let moduli be create_test_non_coprime_moduli()
    
    Let gcrt_solution be ModularArithmetic.generalized_crt(remainders, moduli)
    
    Test.assert_not_null(gcrt_solution, "Generalized CRT should handle non-coprime moduli")
    
    Note: Check if system is consistent
    If gcrt_solution.is_consistent:
        Let solution be gcrt_solution.solution
        For i in 0 to remainders.length - 1:
            assert_congruent(solution, remainders[i], moduli[i], "Solution should satisfy congruence " + i)

Process called "test_crt_interpolation":
    Note: Test CRT interpolation
    Let values be [1, 2, 3]
    Let points be [0, 1, 2]
    Let modulus be 7
    
    Let interpolated_poly be ModularArithmetic.crt_interpolation(values, points, modulus)
    
    Test.assert_not_null(interpolated_poly, "Should interpolate polynomial")
    Test.assert_not_empty(interpolated_poly, "Polynomial should have coefficients")

Process called "test_mixed_radix_representation":
    Note: Test mixed radix representation
    Let value be 23
    Let moduli be [3, 5, 7]
    
    Let mixed_radix be ModularArithmetic.mixed_radix_representation(value, moduli)
    
    Test.assert_not_null(mixed_radix, "Should compute mixed radix representation")
    Test.assert_equal(mixed_radix.length, moduli.length, "Should have same length as moduli")

Note: Quadratic Residue Tests

Process called "test_legendre_symbol":
    Note: Test Legendre symbol computation
    Let a be 2
    Let p be create_test_prime_modulus()  Note: p = 17
    
    Let legendre be ModularArithmetic.legendre_symbol(a, p)
    
    Test.assert_true(legendre == 1 Or legendre == -1, "Legendre symbol should be ±1 for prime modulus")

Process called "test_jacobi_symbol":
    Note: Test Jacobi symbol computation
    Let a be 2
    Let n be 15  Note: Composite number
    
    Let jacobi be ModularArithmetic.jacobi_symbol(a, n)
    
    Test.assert_true(jacobi == 1 Or jacobi == -1 Or jacobi == 0, "Jacobi symbol should be in {-1, 0, 1}")

Process called "test_is_quadratic_residue":
    Note: Test quadratic residue detection
    Let quadratic_residue be 4  Note: 2^2 = 4
    Let non_quadratic_residue be 3
    Let modulus be create_test_prime_modulus()
    
    Let is_qr be ModularArithmetic.is_quadratic_residue(quadratic_residue, modulus)
    Let is_not_qr be ModularArithmetic.is_quadratic_residue(non_quadratic_residue, modulus)
    
    Test.assert_true(is_qr, "4 should be a quadratic residue mod 17")

Process called "test_quadratic_residues_mod_n":
    Note: Test enumeration of all quadratic residues
    Let modulus be create_test_prime_modulus()
    Let qr_list be ModularArithmetic.quadratic_residues_mod_n(modulus)
    
    Test.assert_not_empty(qr_list, "Should find quadratic residues")
    Test.assert_less_equal(qr_list.length, modulus / 2, "Number of QRs should be at most (p-1)/2")

Process called "test_tonelli_shanks_algorithm":
    Note: Test Tonelli-Shanks square root algorithm
    Let n be 2  Note: Find square root of 2 mod p
    Let p be create_test_prime_modulus()
    
    Let square_roots be ModularArithmetic.tonelli_shanks_algorithm(n, p)
    
    If ModularArithmetic.is_quadratic_residue(n, p):
        Test.assert_not_empty(square_roots, "Should find square roots if n is QR")
        
        For root in square_roots:
            Let square be ModularArithmetic.modular_multiply(root, root, p)
            assert_congruent(square, n, p, "Tonelli-Shanks root should be correct")

Process called "test_cipolla_algorithm":
    Note: Test Cipolla's square root algorithm
    Let n be 4  Note: Find square root of 4
    Let p be create_test_prime_modulus()
    
    Let square_roots be ModularArithmetic.cipolla_algorithm(n, p)
    
    Test.assert_not_empty(square_roots, "Cipolla should find square roots")
    
    For root in square_roots:
        Let square be ModularArithmetic.modular_multiply(root, root, p)
        assert_congruent(square, n, p, "Cipolla root should be correct")

Note: Primitive Root and Discrete Logarithm Tests

Process called "test_find_primitive_root":
    Note: Test primitive root finding
    Let modulus be create_test_prime_modulus()
    Let primitive_root_info be ModularArithmetic.find_primitive_root(modulus)
    
    Test.assert_not_null(primitive_root_info, "Should find primitive root")
    Test.assert_greater(primitive_root_info.root, 0, "Primitive root should be positive")
    Test.assert_less(primitive_root_info.root, modulus, "Primitive root should be less than modulus")

Process called "test_test_primitive_root":
    Note: Test primitive root verification
    Let root be 3  Note: Test if 3 is primitive root mod 17
    Let modulus be create_test_prime_modulus()
    
    Let is_primitive be ModularArithmetic.test_primitive_root(root, modulus)
    
    Test.assert_type(is_primitive, Boolean, "Should return boolean")

Process called "test_multiplicative_order":
    Note: Test multiplicative order computation
    Let a be 2
    Let modulus be create_test_prime_modulus()
    
    Let order be ModularArithmetic.multiplicative_order(a, modulus)
    
    Test.assert_greater(order, 0, "Order should be positive")
    Test.assert_less_equal(order, modulus - 1, "Order should be at most p-1")
    
    Note: Verify that a^order ≡ 1 (mod p)
    Let power be ModularArithmetic.modular_exponentiation(a, order, modulus)
    assert_congruent(power, 1, modulus, "a^order should be 1")

Process called "test_discrete_logarithm":
    Note: Test discrete logarithm computation
    Let base be 3
    Let target be 9  Note: 3^2 = 9
    Let modulus be create_test_prime_modulus()
    
    Let log_result be ModularArithmetic.discrete_logarithm(base, target, modulus)
    
    Test.assert_not_null(log_result, "Should compute discrete logarithm")
    
    Note: Verify that base^log_result ≡ target (mod modulus)
    Let verification be ModularArithmetic.modular_exponentiation(base, log_result, modulus)
    assert_congruent(verification, target, modulus, "base^log should equal target")

Process called "test_baby_step_giant_step":
    Note: Test baby-step giant-step algorithm
    Let base be 5
    Let target be 25  Note: 5^2 = 25
    Let modulus be create_test_prime_modulus()
    
    Let log_result be ModularArithmetic.baby_step_giant_step(base, target, modulus)
    
    Test.assert_not_null(log_result, "Baby-step giant-step should find logarithm")
    
    Let verification be ModularArithmetic.modular_exponentiation(base, log_result, modulus)
    assert_congruent(verification, target, modulus, "BSGS result should be correct")

Process called "test_pollard_rho_log":
    Note: Test Pollard's rho algorithm for discrete logs
    Let base be 2
    Let target be 8  Note: 2^3 = 8
    Let modulus be create_test_prime_modulus()
    
    Let log_result be ModularArithmetic.pollard_rho_log(base, target, modulus)
    
    Test.assert_not_null(log_result, "Pollard rho should find logarithm")
    
    Let verification be ModularArithmetic.modular_exponentiation(base, log_result, modulus)
    assert_congruent(verification, target, modulus, "Pollard rho result should be correct")

Note: Congruence System Tests

Process called "test_solve_linear_congruence":
    Note: Test linear congruence solving
    Let a be 3
    Let b be 6
    Let modulus be 15  Note: 3x ≡ 6 (mod 15)
    
    Let solutions be ModularArithmetic.solve_linear_congruence(a, b, modulus)
    
    Test.assert_not_empty(solutions, "Should find solutions to linear congruence")
    
    For solution in solutions:
        Let product be ModularArithmetic.modular_multiply(a, solution, modulus)
        assert_congruent(product, b, modulus, "Solution should satisfy congruence")

Process called "test_solve_quadratic_congruence":
    Note: Test quadratic congruence solving
    Let a be 1
    Let b be 0
    Let c be -4  Note: x^2 - 4 ≡ 0 (mod p), so x ≡ ±2 (mod p)
    Let modulus be create_test_prime_modulus()
    
    Let solutions be ModularArithmetic.solve_quadratic_congruence(a, b, c, modulus)
    
    Test.assert_not_empty(solutions, "Should find solutions to quadratic congruence")
    
    For solution in solutions:
        Let ax2 be ModularArithmetic.modular_multiply(a, ModularArithmetic.modular_multiply(solution, solution, modulus), modulus)
        Let bx be ModularArithmetic.modular_multiply(b, solution, modulus)
        Let result be ModularArithmetic.modular_add(ModularArithmetic.modular_add(ax2, bx, modulus), c, modulus)
        assert_congruent(result, 0, modulus, "Solution should satisfy quadratic congruence")

Process called "test_solve_modular_linear_system":
    Note: Test modular linear system solving
    Let matrix be [[2, 3], [1, 4]]
    Let vector be [7, 5]
    Let modulus be create_test_prime_modulus()
    
    Let solutions be ModularArithmetic.solve_modular_linear_system(matrix, vector, modulus)
    
    If solutions.length > 0:
        Note: Verify solution if it exists
        Let solution be solutions[0]
        Test.assert_equal(solution.length, 2, "Solution should have 2 components")

Process called "test_hensel_lifting":
    Note: Test Hensel's lifting algorithm
    Let polynomial be [1, 0, -2]  Note: x^2 - 2
    Let initial_root be 3  Note: Root modulo small prime
    Let prime be 7
    Let power be 2  Note: Lift to mod p^2
    
    Let lifted_root be ModularArithmetic.hensel_lifting(polynomial, initial_root, prime, power)
    
    Test.assert_not_null(lifted_root, "Hensel lifting should produce result")

Note: Arithmetic Function Tests

Process called "test_euler_totient":
    Note: Test Euler's totient function
    Let n be 12
    Let totient be ModularArithmetic.euler_totient(n)
    
    Test.assert_equal(totient, 4, "φ(12) should be 4")

Process called "test_carmichael_function":
    Note: Test Carmichael function
    Let n be 12
    Let carmichael be ModularArithmetic.carmichael_function(n)
    
    Test.assert_greater(carmichael, 0, "Carmichael function should be positive")
    Test.assert_less_equal(carmichael, ModularArithmetic.euler_totient(n), "λ(n) ≤ φ(n)")

Process called "test_mobius_function":
    Note: Test Möbius function
    Let square_free be 30  Note: 2 × 3 × 5
    Let square_full be 12   Note: 2^2 × 3
    
    Let mu_square_free be ModularArithmetic.mobius_function(square_free)
    Let mu_square_full be ModularArithmetic.mobius_function(square_full)
    
    Test.assert_equal(mu_square_full, 0, "μ(n) = 0 for non-square-free n")
    Test.assert_true(mu_square_free == 1 Or mu_square_free == -1, "μ(n) = ±1 for square-free n")

Process called "test_liouville_function":
    Note: Test Liouville function
    Let n be 8  Note: 2^3
    Let liouville be ModularArithmetic.liouville_function(n)
    
    Test.assert_true(liouville == 1 Or liouville == -1, "λ(n) should be ±1")

Process called "test_jacobsthal_function":
    Note: Test Jacobsthal function
    Let n be 15
    Let jacobsthal be ModularArithmetic.jacobsthal_function(n)
    
    Test.assert_greater_equal(jacobsthal, 1, "Jacobsthal function should be at least 1")

Note: Advanced Operations Tests

Process called "test_modular_matrix_multiply":
    Note: Test modular matrix multiplication
    Let matrix_a be [[1, 2], [3, 4]]
    Let matrix_b be [[5, 6], [7, 8]]
    Let modulus be create_test_prime_modulus()
    
    Let product be ModularArithmetic.modular_matrix_multiply(matrix_a, matrix_b, modulus)
    
    Test.assert_not_null(product, "Matrix multiplication should succeed")
    Test.assert_equal(product.length, 2, "Result should be 2x2 matrix")
    Test.assert_equal(product[0].length, 2, "Result should be 2x2 matrix")

Process called "test_modular_matrix_power":
    Note: Test modular matrix exponentiation
    Let matrix be [[1, 1], [1, 0]]  Note: Fibonacci matrix
    Let exponent be 5
    Let modulus be create_test_prime_modulus()
    
    Let power be ModularArithmetic.modular_matrix_power(matrix, exponent, modulus)
    
    Test.assert_not_null(power, "Matrix power should be computed")
    Test.assert_equal(power.length, 2, "Result should maintain dimensions")

Process called "test_modular_polynomial_arithmetic":
    Note: Test polynomial operations modulo prime
    Let poly1 be [1, 2, 1]  Note: x^2 + 2x + 1
    Let poly2 be [1, 1]     Note: x + 1
    Let prime be 7
    
    Let sum be ModularArithmetic.modular_polynomial_add(poly1, poly2, prime)
    Let product be ModularArithmetic.modular_polynomial_multiply(poly1, poly2, prime)
    
    Test.assert_not_null(sum, "Polynomial addition should succeed")
    Test.assert_not_null(product, "Polynomial multiplication should succeed")

Process called "test_berlekamp_factorization":
    Note: Test Berlekamp factorization algorithm
    Let polynomial be [1, 0, -1]  Note: x^2 - 1 = (x-1)(x+1)
    Let prime be 7
    
    Let factors be ModularArithmetic.berlekamp_factorization(polynomial, prime)
    
    Test.assert_not_empty(factors, "Should find factors")
    Test.assert_greater_equal(factors.length, 2, "Should factor into at least 2 parts")

Note: Main test execution process

Process called "run_modular_arithmetic_tests":
    Note: Execute all modular arithmetic tests
    Test.describe("Modular Arithmetic Module Tests")
    
    Note: Basic Modular Arithmetic Tests
    Test.describe("Basic Modular Arithmetic")
    test_modular_add()
    test_modular_multiply()
    test_modular_exponentiation()
    test_modular_inverse()
    test_fast_modular_reduction()
    test_modular_sqrt()
    
    Note: Chinese Remainder Theorem Tests
    Test.describe("Chinese Remainder Theorem")
    test_chinese_remainder_theorem()
    test_generalized_crt()
    test_crt_interpolation()
    test_mixed_radix_representation()
    
    Note: Quadratic Residue Tests
    Test.describe("Quadratic Residues")
    test_legendre_symbol()
    test_jacobi_symbol()
    test_is_quadratic_residue()
    test_quadratic_residues_mod_n()
    test_tonelli_shanks_algorithm()
    test_cipolla_algorithm()
    
    Note: Primitive Root and Discrete Log Tests
    Test.describe("Primitive Roots and Discrete Logarithms")
    test_find_primitive_root()
    test_test_primitive_root()
    test_multiplicative_order()
    test_discrete_logarithm()
    test_baby_step_giant_step()
    test_pollard_rho_log()
    
    Note: Congruence System Tests
    Test.describe("Congruence Systems")
    test_solve_linear_congruence()
    test_solve_quadratic_congruence()
    test_solve_modular_linear_system()
    test_hensel_lifting()
    
    Note: Arithmetic Function Tests
    Test.describe("Arithmetic Functions")
    test_euler_totient()
    test_carmichael_function()
    test_mobius_function()
    test_liouville_function()
    test_jacobsthal_function()
    
    Note: Advanced Operations Tests
    Test.describe("Advanced Modular Operations")
    test_modular_matrix_multiply()
    test_modular_matrix_power()
    test_modular_polynomial_arithmetic()
    test_berlekamp_factorization()
    
    Test.print_summary()

Note: Execute tests when this file is run
run_modular_arithmetic_tests()