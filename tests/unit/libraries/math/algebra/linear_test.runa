Note: Comprehensive unit tests for math/algebra/linear.runa module
Note: Tests cover vector spaces, linear transformations, matrix operations, eigenvalue analysis, and advanced linear algebra

Import "../../../../../../src/stdlib/math/algebra/linear" as LinearAlgebra
Import "../../../../../../src/stdlib/testing/framework" as Test

Note: Helper functions for creating test data structures

Process called "create_test_2x2_matrix":
    Note: Creates a simple 2x2 matrix for testing
    Let entries be [["1", "2"], ["3", "4"]]
    Let matrix be LinearAlgebra.create_matrix(entries, "Real")
    Return matrix

Process called "create_test_3x3_matrix":
    Note: Creates a 3x3 matrix for testing
    Let entries be [["1", "0", "2"], ["0", "3", "0"], ["4", "0", "5"]]
    Let matrix be LinearAlgebra.create_matrix(entries, "Real")
    Return matrix

Process called "create_test_symmetric_matrix":
    Note: Creates a symmetric matrix for eigenvalue tests
    Let entries be [["4", "1"], ["1", "2"]]
    Let matrix be LinearAlgebra.create_matrix(entries, "Real")
    Return matrix

Process called "create_test_identity_matrix":
    Note: Creates a 3x3 identity matrix
    Let entries be [["1", "0", "0"], ["0", "1", "0"], ["0", "0", "1"]]
    Let matrix be LinearAlgebra.create_matrix(entries, "Real")
    Return matrix

Process called "create_test_vector_space_r2":
    Note: Creates the standard R^2 vector space
    Let basis be [["1", "0"], ["0", "1"]]
    Let vector_space be LinearAlgebra.create_vector_space("Real", 2, basis)
    Return vector_space

Process called "create_test_vector_space_r3":
    Note: Creates the standard R^3 vector space
    Let basis be [["1", "0", "0"], ["0", "1", "0"], ["0", "0", "1"]]
    Let vector_space be LinearAlgebra.create_vector_space("Real", 3, basis)
    Return vector_space

Process called "create_test_linearly_dependent_vectors":
    Note: Creates linearly dependent vectors for testing
    Let vectors be [["1", "2"], ["2", "4"], ["3", "6"]]
    Return vectors

Process called "create_test_linearly_independent_vectors":
    Note: Creates linearly independent vectors for testing
    Let vectors be [["1", "0"], ["0", "1"], ["1", "1"]]
    Return vectors

Process called "assert_matrix_valid" that takes matrix as Matrix, expected_rows as Integer, expected_cols as Integer:
    Note: Assert basic matrix properties
    Test.assert_not_null(matrix, "Matrix should be created successfully")
    Test.assert_equal(matrix.rows, expected_rows, "Matrix should have expected rows")
    Test.assert_equal(matrix.columns, expected_cols, "Matrix should have expected columns")
    Test.assert_not_null(matrix.field, "Matrix should have field specified")

Process called "assert_vector_space_valid" that takes space as VectorSpace, expected_dimension as Integer:
    Note: Assert basic vector space properties
    Test.assert_not_null(space, "Vector space should be created successfully")
    Test.assert_equal(space.dimension, expected_dimension, "Vector space should have expected dimension")
    Test.assert_not_null(space.basis, "Vector space should have basis")
    Test.assert_equal(space.basis.length, expected_dimension, "Basis should have correct size")

Process called "assert_transformation_valid" that takes transform as LinearTransformation, domain_dim as Integer, codomain_dim as Integer:
    Note: Assert basic linear transformation properties
    Test.assert_not_null(transform, "Linear transformation should be created successfully")
    Test.assert_equal(transform.domain.dimension, domain_dim, "Domain should have expected dimension")
    Test.assert_equal(transform.codomain.dimension, codomain_dim, "Codomain should have expected dimension")
    Test.assert_not_null(transform.matrix_representation, "Should have matrix representation")

Process called "assert_numerical_close" that takes actual as String, expected as String, tolerance as String, message as String:
    Note: Assert numerical values are close within tolerance
    Let actual_num be LinearAlgebra.parse_number(actual)
    Let expected_num be LinearAlgebra.parse_number(expected)
    Let tolerance_num be LinearAlgebra.parse_number(tolerance)
    
    Let difference be LinearAlgebra.subtract_numbers(actual_num, expected_num)
    Let abs_diff be LinearAlgebra.absolute_value(difference)
    
    Test.assert_true(LinearAlgebra.less_than(abs_diff, tolerance_num), message)

Note: Vector Space Tests

Process called "test_create_vector_space":
    Note: Test vector space creation
    Let space be create_test_vector_space_r2()
    assert_vector_space_valid(space, 2)

Process called "test_vector_addition":
    Note: Test vector addition in vector space
    Let space be create_test_vector_space_r2()
    Let vector1 be ["1", "2"]
    Let vector2 be ["3", "4"]
    
    Let sum be LinearAlgebra.add_vectors(vector1, vector2, space)
    
    Test.assert_equal(sum[0], "4", "First component should be 4")
    Test.assert_equal(sum[1], "6", "Second component should be 6")

Process called "test_scalar_multiplication":
    Note: Test scalar multiplication in vector space
    Let space be create_test_vector_space_r2()
    Let vector be ["2", "3"]
    Let scalar be "5"
    
    Let result be LinearAlgebra.scalar_multiply(scalar, vector, space)
    
    Test.assert_equal(result[0], "10", "First component should be 10")
    Test.assert_equal(result[1], "15", "Second component should be 15")

Process called "test_linear_independence":
    Note: Test linear independence testing
    Let independent_vectors be create_test_linearly_independent_vectors()
    Let dependent_vectors be create_test_linearly_dependent_vectors()
    
    Let is_independent be LinearAlgebra.test_linear_independence(independent_vectors, "Real")
    Let is_dependent be LinearAlgebra.test_linear_independence(dependent_vectors, "Real")
    
    Test.assert_true(is_independent, "Independent vectors should be detected as independent")
    Test.assert_false(is_dependent, "Dependent vectors should be detected as dependent")

Process called "test_span_vectors":
    Note: Test vector span computation
    Let vectors be [["1", "0"], ["0", "1"]]
    Let span be LinearAlgebra.span_vectors(vectors, "Real")
    
    assert_vector_space_valid(span, 2)
    Test.assert_equal(span.dimension, 2, "Span of standard basis should be full space")

Process called "test_find_basis":
    Note: Test basis finding from spanning set
    Let vectors be [["1", "0"], ["0", "1"], ["1", "1"], ["2", "2"]]
    Let basis be LinearAlgebra.find_basis(vectors, "Real")
    
    Test.assert_equal(basis.length, 2, "Basis of R^2 should have 2 vectors")
    
    Let independence be LinearAlgebra.test_linear_independence(basis, "Real")
    Test.assert_true(independence, "Basis vectors should be linearly independent")

Process called "test_compute_dimension":
    Note: Test dimension computation
    Let space be create_test_vector_space_r3()
    Let dimension be LinearAlgebra.compute_dimension(space)
    
    Test.assert_equal(dimension, 3, "R^3 should have dimension 3")

Process called "test_subspace_operations":
    Note: Test subspace intersection and sum
    Let space1_basis be [["1", "0", "0"], ["0", "1", "0"]]
    Let space2_basis be [["0", "1", "0"], ["0", "0", "1"]]
    
    Let space1 be LinearAlgebra.create_subspace(space1_basis, "Real")
    Let space2 be LinearAlgebra.create_subspace(space2_basis, "Real")
    
    Let intersection be LinearAlgebra.subspace_intersection(space1, space2)
    Let sum be LinearAlgebra.subspace_sum(space1, space2)
    
    Test.assert_equal(intersection.dimension, 1, "Intersection should have dimension 1")
    Test.assert_equal(sum.dimension, 3, "Sum should have dimension 3")

Process called "test_quotient_space":
    Note: Test quotient space construction
    Let full_space be create_test_vector_space_r3()
    Let subspace_basis be [["1", "0", "0"]]
    Let subspace be LinearAlgebra.create_subspace(subspace_basis, "Real")
    
    Let quotient be LinearAlgebra.quotient_space(full_space, subspace)
    
    Test.assert_equal(quotient.dimension, 2, "Quotient space should have dimension 2")

Note: Matrix Operations Tests

Process called "test_create_matrix":
    Note: Test matrix creation
    Let matrix be create_test_2x2_matrix()
    assert_matrix_valid(matrix, 2, 2)

Process called "test_matrix_addition":
    Note: Test matrix addition
    Let matrix1 be create_test_2x2_matrix()
    Let matrix2 be create_test_2x2_matrix()
    
    Let sum be LinearAlgebra.matrix_add(matrix1, matrix2)
    
    assert_matrix_valid(sum, 2, 2)
    Test.assert_equal(sum.entries[0][0], "2", "Entry (0,0) should be 2")
    Test.assert_equal(sum.entries[1][1], "8", "Entry (1,1) should be 8")

Process called "test_matrix_multiplication":
    Note: Test matrix multiplication
    Let matrix1 be create_test_2x2_matrix()
    Let matrix2 be create_test_2x2_matrix()
    
    Let product be LinearAlgebra.matrix_multiply(matrix1, matrix2)
    
    assert_matrix_valid(product, 2, 2)
    Test.assert_equal(product.entries[0][0], "7", "Entry (0,0) should be 7")
    Test.assert_equal(product.entries[1][0], "15", "Entry (1,0) should be 15")

Process called "test_matrix_transpose":
    Note: Test matrix transpose
    Let matrix be create_test_2x2_matrix()
    Let transpose be LinearAlgebra.matrix_transpose(matrix)
    
    assert_matrix_valid(transpose, 2, 2)
    Test.assert_equal(transpose.entries[0][1], "3", "Entry (0,1) should be 3")
    Test.assert_equal(transpose.entries[1][0], "2", "Entry (1,0) should be 2")

Process called "test_matrix_determinant":
    Note: Test determinant computation
    Let matrix be create_test_2x2_matrix()
    Let det be LinearAlgebra.matrix_determinant(matrix)
    
    Test.assert_equal(det, "-2", "Determinant should be -2")

Process called "test_matrix_inverse":
    Note: Test matrix inverse computation
    Let matrix be create_test_2x2_matrix()
    Let inverse be LinearAlgebra.matrix_inverse(matrix)
    
    assert_matrix_valid(inverse, 2, 2)
    
    Note: Test that matrix * inverse = identity
    Let product be LinearAlgebra.matrix_multiply(matrix, inverse)
    Test.assert_equal(product.entries[0][0], "1", "Should get identity matrix")
    Test.assert_equal(product.entries[1][1], "1", "Should get identity matrix")

Process called "test_matrix_rank":
    Note: Test matrix rank computation
    Let matrix be create_test_3x3_matrix()
    Let rank be LinearAlgebra.matrix_rank(matrix)
    
    Test.assert_greater_equal(rank, 1, "Non-zero matrix should have positive rank")
    Test.assert_less_equal(rank, 3, "3x3 matrix should have rank at most 3")

Note: Linear Transformation Tests

Process called "test_create_linear_transformation":
    Note: Test linear transformation creation
    Let domain be create_test_vector_space_r2()
    Let codomain be create_test_vector_space_r2()
    Let matrix be create_test_2x2_matrix()
    
    Let transformation be LinearAlgebra.create_linear_transformation(domain, codomain, matrix.entries)
    
    assert_transformation_valid(transformation, 2, 2)

Process called "test_transformation_application":
    Note: Test applying linear transformation to vector
    Let domain be create_test_vector_space_r2()
    Let codomain be create_test_vector_space_r2()
    Let matrix_entries be [["2", "0"], ["0", "3"]]
    
    Let transformation be LinearAlgebra.create_linear_transformation(domain, codomain, matrix_entries)
    Let vector be ["1", "2"]
    
    Let result be LinearAlgebra.apply_transformation(transformation, vector)
    
    Test.assert_equal(result[0], "2", "First component should be 2")
    Test.assert_equal(result[1], "6", "Second component should be 6")

Process called "test_transformation_kernel":
    Note: Test kernel computation
    Let domain be create_test_vector_space_r3()
    Let codomain be create_test_vector_space_r2()
    Let matrix_entries be [["1", "2", "3"], ["0", "0", "0"]]
    
    Let transformation be LinearAlgebra.create_linear_transformation(domain, codomain, matrix_entries)
    Let kernel be LinearAlgebra.compute_kernel(transformation)
    
    Test.assert_equal(kernel.dimension, 2, "Kernel should have dimension 2")

Process called "test_transformation_image":
    Note: Test image computation
    Let domain be create_test_vector_space_r2()
    Let codomain be create_test_vector_space_r3()
    Let matrix_entries be [["1", "0"], ["0", "1"], ["1", "1"]]
    
    Let transformation be LinearAlgebra.create_linear_transformation(domain, codomain, matrix_entries)
    Let image be LinearAlgebra.compute_image(transformation)
    
    Test.assert_equal(image.dimension, 2, "Image should have dimension 2")

Process called "test_transformation_rank_nullity":
    Note: Test rank-nullity theorem
    Let domain be create_test_vector_space_r3()
    Let codomain be create_test_vector_space_r2()
    Let matrix_entries be [["1", "2", "3"], ["4", "5", "6"]]
    
    Let transformation be LinearAlgebra.create_linear_transformation(domain, codomain, matrix_entries)
    Let rank be LinearAlgebra.compute_rank(transformation)
    Let nullity be LinearAlgebra.compute_nullity(transformation)
    
    Test.assert_equal(rank + nullity, 3, "Rank + nullity should equal domain dimension")

Process called "test_compose_transformations":
    Note: Test composition of linear transformations
    Let space be create_test_vector_space_r2()
    Let matrix1_entries be [["2", "0"], ["0", "3"]]
    Let matrix2_entries be [["1", "1"], ["0", "1"]]
    
    Let transform1 be LinearAlgebra.create_linear_transformation(space, space, matrix1_entries)
    Let transform2 be LinearAlgebra.create_linear_transformation(space, space, matrix2_entries)
    
    Let composition be LinearAlgebra.compose_transformations(transform1, transform2)
    
    assert_transformation_valid(composition, 2, 2)

Process called "test_inverse_transformation":
    Note: Test inverse transformation computation
    Let space be create_test_vector_space_r2()
    Let matrix_entries be [["2", "0"], ["0", "3"]]
    
    Let transformation be LinearAlgebra.create_linear_transformation(space, space, matrix_entries)
    Let inverse be LinearAlgebra.inverse_transformation(transformation)
    
    assert_transformation_valid(inverse, 2, 2)
    
    Note: Test that composition gives identity
    Let composition be LinearAlgebra.compose_transformations(transformation, inverse)
    Let is_identity be LinearAlgebra.is_identity_transformation(composition)
    Test.assert_true(is_identity, "Composition should be identity")

Note: Eigenvalue and Eigenvector Tests

Process called "test_find_eigenvalues":
    Note: Test eigenvalue computation
    Let matrix be create_test_symmetric_matrix()
    Let eigenvalues be LinearAlgebra.find_eigenvalues(matrix)
    
    Test.assert_not_empty(eigenvalues, "Should find eigenvalues")
    Test.assert_less_equal(eigenvalues.length, 2, "2x2 matrix should have at most 2 eigenvalues")

Process called "test_find_eigenvectors":
    Note: Test eigenvector computation
    Let matrix be create_test_symmetric_matrix()
    Let eigenvalues be LinearAlgebra.find_eigenvalues(matrix)
    
    Test.assert_not_empty(eigenvalues, "Should find eigenvalues first")
    
    Let eigenvalue be eigenvalues[0]
    Let eigenvectors be LinearAlgebra.find_eigenvectors(matrix, eigenvalue)
    
    Test.assert_not_empty(eigenvectors, "Should find eigenvectors")

Process called "test_diagonalize_matrix":
    Note: Test matrix diagonalization
    Let matrix be create_test_symmetric_matrix()
    Let diagonalization be LinearAlgebra.diagonalize_matrix(matrix)
    
    Test.assert_not_null(diagonalization, "Should diagonalize symmetric matrix")
    Test.assert_contains_key(diagonalization, "P", "Should have transformation matrix P")
    Test.assert_contains_key(diagonalization, "D", "Should have diagonal matrix D")

Process called "test_eigenspace_computation":
    Note: Test eigenspace computation
    Let matrix be create_test_symmetric_matrix()
    Let eigenvalues be LinearAlgebra.find_eigenvalues(matrix)
    
    For eigenvalue in eigenvalues:
        Let eigenspace be LinearAlgebra.compute_eigenspace(matrix, eigenvalue)
        Test.assert_greater_equal(eigenspace.dimension, 1, "Eigenspace should have positive dimension")

Process called "test_characteristic_polynomial":
    Note: Test characteristic polynomial computation
    Let matrix be create_test_2x2_matrix()
    Let char_poly be LinearAlgebra.characteristic_polynomial(matrix)
    
    Test.assert_not_null(char_poly, "Should compute characteristic polynomial")
    Test.assert_not_empty(char_poly.coefficients, "Should have polynomial coefficients")

Process called "test_minimal_polynomial":
    Note: Test minimal polynomial computation
    Let matrix be create_test_2x2_matrix()
    Let min_poly be LinearAlgebra.minimal_polynomial(matrix)
    
    Test.assert_not_null(min_poly, "Should compute minimal polynomial")
    Test.assert_less_equal(min_poly.degree, 2, "Minimal polynomial degree should be at most matrix size")

Process called "test_jordan_normal_form":
    Note: Test Jordan normal form computation
    Let matrix be create_test_3x3_matrix()
    Let jordan_form be LinearAlgebra.jordan_normal_form(matrix)
    
    Test.assert_not_null(jordan_form, "Should compute Jordan normal form")
    Test.assert_contains_key(jordan_form, "jordan_matrix", "Should have Jordan matrix")
    Test.assert_contains_key(jordan_form, "transformation_matrix", "Should have transformation matrix")

Note: Bilinear Forms and Inner Products Tests

Process called "test_create_bilinear_form":
    Note: Test bilinear form creation
    Let space be create_test_vector_space_r2()
    Let matrix = create_test_2x2_matrix()
    
    Let bilinear_form be LinearAlgebra.create_bilinear_form(space, matrix.entries)
    
    Test.assert_not_null(bilinear_form, "Bilinear form should be created")
    Test.assert_equal(bilinear_form.vector_space.dimension, 2, "Should operate on correct space")

Process called "test_bilinear_form_evaluation":
    Note: Test bilinear form evaluation
    Let space be create_test_vector_space_r2()
    Let matrix_entries be [["1", "0"], ["0", "1"]]
    
    Let bilinear_form be LinearAlgebra.create_bilinear_form(space, matrix_entries)
    Let vector1 be ["2", "3"]
    Let vector2 be ["1", "4"]
    
    Let result be LinearAlgebra.evaluate_bilinear_form(bilinear_form, vector1, vector2)
    
    Test.assert_equal(result, "14", "Bilinear form should evaluate to 14")

Process called "test_symmetric_bilinear_form":
    Note: Test symmetric bilinear form properties
    Let space be create_test_vector_space_r2()
    Let matrix be create_test_symmetric_matrix()
    
    Let bilinear_form be LinearAlgebra.create_bilinear_form(space, matrix.entries)
    Let is_symmetric be LinearAlgebra.test_symmetry(bilinear_form)
    
    Test.assert_true(is_symmetric, "Form with symmetric matrix should be symmetric")

Process called "test_create_inner_product_space":
    Note: Test inner product space creation
    Let space be create_test_vector_space_r2()
    Let inner_product_matrix be create_test_identity_matrix()
    
    Let inner_space be LinearAlgebra.create_inner_product_space(space, inner_product_matrix.entries)
    
    Test.assert_not_null(inner_space, "Inner product space should be created")
    Test.assert_true(inner_space.positive_definite, "Standard inner product should be positive definite")

Process called "test_gram_schmidt_process":
    Note: Test Gram-Schmidt orthogonalization
    Let vectors be [["1", "1", "0"], ["1", "0", "1"], ["0", "1", "1"]]
    Let inner_space be LinearAlgebra.create_standard_inner_product_space(3, "Real")
    
    Let orthogonal_vectors be LinearAlgebra.gram_schmidt_orthogonalization(vectors, inner_space)
    
    Test.assert_equal(orthogonal_vectors.length, 3, "Should produce 3 orthogonal vectors")
    
    Note: Test orthogonality
    Let dot_product be LinearAlgebra.inner_product(orthogonal_vectors[0], orthogonal_vectors[1], inner_space)
    assert_numerical_close(dot_product, "0", "1e-10", "Orthogonal vectors should have zero dot product")

Process called "test_orthogonal_projection":
    Note: Test orthogonal projection computation
    Let vector be ["3", "4", "5"]
    Let subspace_basis be [["1", "0", "0"], ["0", "1", "0"]]
    Let inner_space be LinearAlgebra.create_standard_inner_product_space(3, "Real")
    
    Let projection be LinearAlgebra.orthogonal_projection(vector, subspace_basis, inner_space)
    
    Test.assert_equal(projection[0], "3", "First component should be 3")
    Test.assert_equal(projection[1], "4", "Second component should be 4")
    Test.assert_equal(projection[2], "0", "Third component should be 0")

Note: Advanced Linear Algebra Tests

Process called "test_tensor_product":
    Note: Test tensor product computation
    Let space1 be create_test_vector_space_r2()
    Let space2 be create_test_vector_space_r2()
    
    Let tensor_space be LinearAlgebra.tensor_product(space1, space2)
    
    Test.assert_equal(tensor_space.dimension, 4, "Tensor product should have dimension 4")

Process called "test_exterior_algebra":
    Note: Test exterior algebra operations
    Let space be create_test_vector_space_r3()
    Let exterior_2 be LinearAlgebra.exterior_power(space, 2)
    
    Test.assert_equal(exterior_2.dimension, 3, "Exterior square of R^3 should have dimension 3")

Process called "test_matrix_exponential":
    Note: Test matrix exponential computation
    Let matrix = create_test_2x2_matrix()
    Let matrix_exp be LinearAlgebra.matrix_exponential(matrix)
    
    assert_matrix_valid(matrix_exp, 2, 2)
    Test.assert_not_null(matrix_exp.entries, "Matrix exponential should have entries")

Process called "test_spectral_theorem":
    Note: Test spectral theorem for symmetric matrices
    Let symmetric_matrix be create_test_symmetric_matrix()
    Let spectral_decomposition be LinearAlgebra.spectral_decomposition(symmetric_matrix)
    
    Test.assert_not_null(spectral_decomposition, "Should compute spectral decomposition")
    Test.assert_contains_key(spectral_decomposition, "eigenvalues", "Should have eigenvalues")
    Test.assert_contains_key(spectral_decomposition, "eigenvectors", "Should have eigenvectors")

Process called "test_canonical_forms":
    Note: Test canonical form computations
    Let matrix be create_test_3x3_matrix()
    Let canonical_forms be LinearAlgebra.compute_canonical_forms(matrix)
    
    Test.assert_not_null(canonical_forms, "Should compute canonical forms")
    Test.assert_contains_key(canonical_forms, "rational_canonical_form", "Should have rational canonical form")

Note: Main test execution process

Process called "run_linear_algebra_tests":
    Note: Execute all linear algebra tests
    Test.describe("Linear Algebra Module Tests")
    
    Note: Vector Space Tests
    Test.describe("Vector Spaces")
    test_create_vector_space()
    test_vector_addition()
    test_scalar_multiplication()
    test_linear_independence()
    test_span_vectors()
    test_find_basis()
    test_compute_dimension()
    test_subspace_operations()
    test_quotient_space()
    
    Note: Matrix Operations Tests
    Test.describe("Matrix Operations")
    test_create_matrix()
    test_matrix_addition()
    test_matrix_multiplication()
    test_matrix_transpose()
    test_matrix_determinant()
    test_matrix_inverse()
    test_matrix_rank()
    
    Note: Linear Transformation Tests
    Test.describe("Linear Transformations")
    test_create_linear_transformation()
    test_transformation_application()
    test_transformation_kernel()
    test_transformation_image()
    test_transformation_rank_nullity()
    test_compose_transformations()
    test_inverse_transformation()
    
    Note: Eigenvalue Tests
    Test.describe("Eigenvalues and Eigenvectors")
    test_find_eigenvalues()
    test_find_eigenvectors()
    test_diagonalize_matrix()
    test_eigenspace_computation()
    test_characteristic_polynomial()
    test_minimal_polynomial()
    test_jordan_normal_form()
    
    Note: Bilinear Forms Tests
    Test.describe("Bilinear Forms and Inner Products")
    test_create_bilinear_form()
    test_bilinear_form_evaluation()
    test_symmetric_bilinear_form()
    test_create_inner_product_space()
    test_gram_schmidt_process()
    test_orthogonal_projection()
    
    Note: Advanced Tests
    Test.describe("Advanced Linear Algebra")
    test_tensor_product()
    test_exterior_algebra()
    test_matrix_exponential()
    test_spectral_theorem()
    test_canonical_forms()
    
    Test.print_summary()

Note: Execute tests when this file is run
run_linear_algebra_tests()