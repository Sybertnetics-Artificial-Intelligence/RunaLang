Note: ===== RUNA UNIT TESTS: MATH/PRECISION/RATIONAL =====

Import "math/precision/rational" as Rational
Import "math/precision/biginteger" as BigInteger
Import "dev/debug/testing/unit" as UnitTest

Note: ===== TEST DATA GENERATORS =====

Process called "create_test_rationals" returns Array[Rational.Rational]:
    Note: Creates array of test Rational values for comprehensive testing
    Let test_values be Array.create([
        Rational.create_zero(),
        Rational.create_one(),
        Rational.create_from_integers(1, 2),
        Rational.create_from_integers(3, 4),
        Rational.create_from_integers(-1, 3),
        Rational.create_from_integers(22, 7),  Note: π approximation
        Rational.create_from_integers(5, 1),   Note: Integer as rational
        Rational.create_from_integers(-7, 2),  Note: Negative rational
        Rational.create_from_integers(100, 25), Note: Reducible fraction
        Rational.create_from_integers(17, 19), Note: Irreducible fraction
        Rational.create_from_string("2/3"),
        Rational.create_from_string("-5/8"),
        Rational.create_from_string("12"),     Note: Integer string
        Rational.create_from_decimal_string("0.125"), Note: 1/8
        Rational.create_from_decimal_string("3.14159") Note: π approximation
    ])
    Return test_values

Process called "create_large_rationals" returns Array[Rational.Rational]:
    Note: Creates large rational numbers for stress testing
    Let large_num be BigInteger.create_from_string("123456789012345678901234567890", 10)
    Let large_den be BigInteger.create_from_string("987654321098765432109876543210", 10)
    
    Let test_values be Array.create([
        Rational.create_from_bigintegers(large_num, large_den),
        Rational.create_from_bigintegers(large_den, large_num),
        Rational.create_from_bigintegers(large_num, BigInteger.create_from_integer(1)),
        Rational.create_from_bigintegers(BigInteger.create_from_integer(1), large_den)
    ])
    Return test_values

Note: ===== ASSERTION HELPERS =====

Process called "assert_rational_equals" that takes actual as Rational.Rational, expected as Rational.Rational, message as String:
    Note: Asserts rational equality using cross multiplication
    Let are_equal be Rational.equals(actual, expected)
    UnitTest.assert(are_equal, message + " - Expected: " + Rational.to_string(expected) + ", Actual: " + Rational.to_string(actual))

Process called "assert_rational_approximately_equals" that takes actual as Rational.Rational, expected as Rational.Rational, tolerance as Rational.Rational, message as String:
    Note: Asserts rational equality within tolerance
    Let difference be Rational.abs(Rational.subtract(actual, expected))
    Let within_tolerance be Rational.compare(difference, tolerance) <= 0
    UnitTest.assert(within_tolerance, message + " - Expected: " + Rational.to_string(expected) + ", Actual: " + Rational.to_string(actual) + ", Tolerance: " + Rational.to_string(tolerance))

Process called "assert_comparison_result" that takes result as Integer, expected as Integer, message as String:
    Note: Asserts comparison results (-1, 0, 1)
    UnitTest.assert(result equals expected, message + " - Expected comparison: " + Integer.to_string(expected) + ", Actual: " + Integer.to_string(result))

Process called "assert_string_representation" that takes rational as Rational.Rational, expected as String, message as String:
    Note: Asserts string representation matches expected
    Let actual be Rational.to_string(rational)
    UnitTest.assert(actual equals expected, message + " - Expected: '" + expected + "', Actual: '" + actual + "'")

Process called "assert_is_in_reduced_form" that takes rational as Rational.Rational, message as String:
    Note: Asserts rational is in lowest terms (GCD of numerator and denominator is 1)
    Let gcd be BigInteger.gcd(Rational.get_numerator(rational), Rational.get_denominator(rational))
    Let is_reduced be BigInteger.equals(gcd, BigInteger.create_from_integer(1))
    UnitTest.assert(is_reduced, message + " - Rational should be in reduced form: " + Rational.to_string(rational))

Note: ===== CONSTRUCTION TESTS =====

Process called "test_create_from_integers":
    Note: Test Rational creation from integer numerator and denominator
    Let simple_fraction be Rational.create_from_integers(3, 4)
    assert_string_representation(simple_fraction, "3/4", "Simple fraction creation")
    assert_is_in_reduced_form(simple_fraction, "Simple fraction should be reduced")
    
    Let reducible_fraction be Rational.create_from_integers(6, 8)
    assert_string_representation(reducible_fraction, "3/4", "Reducible fraction should be reduced")
    assert_is_in_reduced_form(reducible_fraction, "Reducible fraction should be in reduced form")
    
    Let negative_numerator be Rational.create_from_integers(-3, 4)
    assert_string_representation(negative_numerator, "-3/4", "Negative numerator")
    
    Let negative_denominator be Rational.create_from_integers(3, -4)
    assert_string_representation(negative_denominator, "-3/4", "Negative denominator should normalize sign")
    
    Let both_negative be Rational.create_from_integers(-3, -4)
    assert_string_representation(both_negative, "3/4", "Both negative should result in positive")
    
    Let integer_as_rational be Rational.create_from_integers(5, 1)
    assert_string_representation(integer_as_rational, "5", "Integer as rational")

Process called "test_create_from_bigintegers":
    Note: Test Rational creation from BigInteger numerator and denominator
    Let big_num be BigInteger.create_from_string("12345678901234567890", 10)
    Let big_den be BigInteger.create_from_string("98765432109876543210", 10)
    
    Let big_rational be Rational.create_from_bigintegers(big_num, big_den)
    UnitTest.assert(BigInteger.equals(Rational.get_numerator(big_rational), big_num), "BigInteger numerator preservation")
    UnitTest.assert(BigInteger.equals(Rational.get_denominator(big_rational), big_den), "BigInteger denominator preservation")
    
    Let zero_big be Rational.create_from_bigintegers(BigInteger.create_from_integer(0), big_den)
    UnitTest.assert(Rational.is_zero(zero_big), "Zero BigInteger rational")

Process called "test_create_from_string":
    Note: Test Rational creation from string representations
    Let fraction_string be Rational.create_from_string("22/7")
    assert_string_representation(fraction_string, "22/7", "Fraction string parsing")
    
    Let integer_string be Rational.create_from_string("42")
    assert_rational_equals(integer_string, Rational.create_from_integers(42, 1), "Integer string parsing")
    
    Let negative_string be Rational.create_from_string("-5/8")
    assert_string_representation(negative_string, "-5/8", "Negative fraction string")
    
    Let reducible_string be Rational.create_from_string("10/15")
    assert_string_representation(reducible_string, "2/3", "Reducible fraction string should be reduced")

Process called "test_create_from_decimal_string":
    Note: Test Rational creation from decimal string representations
    Let half_decimal be Rational.create_from_decimal_string("0.5")
    assert_rational_equals(half_decimal, Rational.create_from_integers(1, 2), "Decimal 0.5 should be 1/2")
    
    Let quarter_decimal be Rational.create_from_decimal_string("0.25")
    assert_rational_equals(quarter_decimal, Rational.create_from_integers(1, 4), "Decimal 0.25 should be 1/4")
    
    Let eighth_decimal be Rational.create_from_decimal_string("0.125")
    assert_rational_equals(eighth_decimal, Rational.create_from_integers(1, 8), "Decimal 0.125 should be 1/8")
    
    Let integer_decimal be Rational.create_from_decimal_string("3.0")
    assert_rational_equals(integer_decimal, Rational.create_from_integers(3, 1), "Integer decimal should be integer rational")
    
    Let negative_decimal be Rational.create_from_decimal_string("-1.75")
    assert_rational_equals(negative_decimal, Rational.create_from_integers(-7, 4), "Negative decimal -1.75 should be -7/4")

Process called "test_create_zero_and_one":
    Note: Test creation of zero and one constants
    Let zero be Rational.create_zero()
    UnitTest.assert(Rational.is_zero(zero), "Zero should be zero")
    assert_string_representation(zero, "0", "Zero string representation")
    
    Let one be Rational.create_one()
    UnitTest.assert(Rational.is_one(one), "One should be one")
    assert_string_representation(one, "1", "One string representation")
    
    Note: Test that zero and one are in reduced form
    assert_is_in_reduced_form(zero, "Zero should be in reduced form")
    assert_is_in_reduced_form(one, "One should be in reduced form")

Note: ===== ARITHMETIC OPERATION TESTS =====

Process called "test_addition":
    Note: Test rational addition with various denominators
    Let a be Rational.create_from_integers(1, 3)
    Let b be Rational.create_from_integers(1, 4)
    Let sum be Rational.add(a, b)
    assert_rational_equals(sum, Rational.create_from_integers(7, 12), "1/3 + 1/4 = 7/12")
    
    Let same_denominator be Rational.add(
        Rational.create_from_integers(2, 5),
        Rational.create_from_integers(1, 5)
    )
    assert_rational_equals(same_denominator, Rational.create_from_integers(3, 5), "Same denominator addition")
    
    Let with_zero be Rational.add(a, Rational.create_zero())
    assert_rational_equals(with_zero, a, "Addition with zero")
    
    Let negative_addition be Rational.add(
        Rational.create_from_integers(3, 4),
        Rational.create_from_integers(-1, 4)
    )
    assert_rational_equals(negative_addition, Rational.create_from_integers(1, 2), "Addition with negative")
    
    Let integer_addition be Rational.add(
        Rational.create_from_integers(5, 1),
        Rational.create_from_integers(3, 2)
    )
    assert_rational_equals(integer_addition, Rational.create_from_integers(13, 2), "Integer plus fraction")

Process called "test_subtraction":
    Note: Test rational subtraction operations
    Let a be Rational.create_from_integers(3, 4)
    Let b be Rational.create_from_integers(1, 4)
    Let difference be Rational.subtract(a, b)
    assert_rational_equals(difference, Rational.create_from_integers(1, 2), "3/4 - 1/4 = 1/2")
    
    Let different_denominator be Rational.subtract(
        Rational.create_from_integers(2, 3),
        Rational.create_from_integers(1, 4)
    )
    assert_rational_equals(different_denominator, Rational.create_from_integers(5, 12), "2/3 - 1/4 = 5/12")
    
    Let from_zero be Rational.subtract(Rational.create_zero(), a)
    assert_rational_equals(from_zero, Rational.negate(a), "Subtraction from zero")
    
    Let self_subtraction be Rational.subtract(a, a)
    UnitTest.assert(Rational.is_zero(self_subtraction), "Self subtraction should be zero")
    
    Let negative_result be Rational.subtract(
        Rational.create_from_integers(1, 4),
        Rational.create_from_integers(3, 4)
    )
    assert_rational_equals(negative_result, Rational.create_from_integers(-1, 2), "Subtraction resulting in negative")

Process called "test_multiplication":
    Note: Test rational multiplication operations
    Let a be Rational.create_from_integers(2, 3)
    Let b be Rational.create_from_integers(3, 4)
    Let product be Rational.multiply(a, b)
    assert_rational_equals(product, Rational.create_from_integers(1, 2), "2/3 * 3/4 = 1/2")
    
    Let with_one be Rational.multiply(a, Rational.create_one())
    assert_rational_equals(with_one, a, "Multiplication by one")
    
    Let with_zero be Rational.multiply(a, Rational.create_zero())
    UnitTest.assert(Rational.is_zero(with_zero), "Multiplication by zero should be zero")
    
    Let negative_multiplication be Rational.multiply(
        Rational.create_from_integers(-2, 3),
        Rational.create_from_integers(1, 4)
    )
    assert_rational_equals(negative_multiplication, Rational.create_from_integers(-1, 6), "Negative multiplication")
    
    Let integer_multiplication be Rational.multiply(
        Rational.create_from_integers(3, 1),
        Rational.create_from_integers(2, 5)
    )
    assert_rational_equals(integer_multiplication, Rational.create_from_integers(6, 5), "Integer times fraction")

Process called "test_division":
    Note: Test rational division operations
    Let a be Rational.create_from_integers(2, 3)
    Let b be Rational.create_from_integers(4, 5)
    Let quotient be Rational.divide(a, b)
    assert_rational_equals(quotient, Rational.create_from_integers(5, 6), "2/3 ÷ 4/5 = 5/6")
    
    Let by_one be Rational.divide(a, Rational.create_one())
    assert_rational_equals(by_one, a, "Division by one")
    
    Let self_division be Rational.divide(a, a)
    assert_rational_equals(self_division, Rational.create_one(), "Self division should be one")
    
    Let reciprocal_check be Rational.divide(
        Rational.create_one(),
        Rational.create_from_integers(3, 4)
    )
    assert_rational_equals(reciprocal_check, Rational.create_from_integers(4, 3), "Division to get reciprocal")
    
    Let negative_division be Rational.divide(
        Rational.create_from_integers(-1, 2),
        Rational.create_from_integers(1, 4)
    )
    assert_rational_equals(negative_division, Rational.create_from_integers(-2, 1), "Negative division")

Process called "test_power":
    Note: Test rational exponentiation
    Let base be Rational.create_from_integers(2, 3)
    
    Let power_zero be Rational.power(base, 0)
    assert_rational_equals(power_zero, Rational.create_one(), "Any rational to power 0 is 1")
    
    Let power_one be Rational.power(base, 1)
    assert_rational_equals(power_one, base, "Any rational to power 1 is itself")
    
    Let power_two be Rational.power(base, 2)
    assert_rational_equals(power_two, Rational.create_from_integers(4, 9), "(2/3)² = 4/9")
    
    Let power_three be Rational.power(base, 3)
    assert_rational_equals(power_three, Rational.create_from_integers(8, 27), "(2/3)³ = 8/27")
    
    Let power_negative be Rational.power(base, -1)
    assert_rational_equals(power_negative, Rational.create_from_integers(3, 2), "(2/3)⁻¹ = 3/2")
    
    Let power_negative_two be Rational.power(base, -2)
    assert_rational_equals(power_negative_two, Rational.create_from_integers(9, 4), "(2/3)⁻² = 9/4")

Note: ===== REDUCTION AND NORMALIZATION TESTS =====

Process called "test_reduce":
    Note: Test fraction reduction to lowest terms
    Let reducible be Rational.create_from_bigintegers(
        BigInteger.create_from_integer(12),
        BigInteger.create_from_integer(18)
    )
    Note: Don't auto-reduce in constructor for this test
    Let reduced be Rational.reduce(reducible)
    assert_rational_equals(reduced, Rational.create_from_integers(2, 3), "12/18 reduces to 2/3")
    assert_is_in_reduced_form(reduced, "Reduced fraction should be in lowest terms")
    
    Let already_reduced be Rational.create_from_integers(3, 7)
    Let reduced_again be Rational.reduce(already_reduced)
    assert_rational_equals(reduced_again, already_reduced, "Already reduced fraction unchanged")
    
    Let zero_reduce be Rational.reduce(Rational.create_zero())
    UnitTest.assert(Rational.is_zero(zero_reduce), "Zero reduction should be zero")

Process called "test_reciprocal":
    Note: Test reciprocal (multiplicative inverse) calculation
    Let fraction be Rational.create_from_integers(3, 4)
    Let reciprocal be Rational.reciprocal(fraction)
    assert_rational_equals(reciprocal, Rational.create_from_integers(4, 3), "Reciprocal of 3/4 is 4/3")
    
    Let integer_rational be Rational.create_from_integers(5, 1)
    Let integer_reciprocal be Rational.reciprocal(integer_rational)
    assert_rational_equals(integer_reciprocal, Rational.create_from_integers(1, 5), "Reciprocal of 5 is 1/5")
    
    Let negative_reciprocal be Rational.reciprocal(Rational.create_from_integers(-2, 3))
    assert_rational_equals(negative_reciprocal, Rational.create_from_integers(-3, 2), "Reciprocal of -2/3 is -3/2")
    
    Note: Test that reciprocal of reciprocal is original
    Let double_reciprocal be Rational.reciprocal(reciprocal)
    assert_rational_equals(double_reciprocal, fraction, "Reciprocal of reciprocal should be original")

Process called "test_abs_and_negate":
    Note: Test absolute value and negation
    Let positive be Rational.create_from_integers(3, 4)
    Let negative be Rational.create_from_integers(-3, 4)
    
    Let abs_positive be Rational.abs(positive)
    assert_rational_equals(abs_positive, positive, "Absolute value of positive rational")
    
    Let abs_negative be Rational.abs(negative)
    assert_rational_equals(abs_negative, positive, "Absolute value of negative rational")
    
    Let negated_positive be Rational.negate(positive)
    assert_rational_equals(negated_positive, negative, "Negated positive rational")
    
    Let negated_negative be Rational.negate(negative)
    assert_rational_equals(negated_negative, positive, "Negated negative rational")
    
    Let zero_abs be Rational.abs(Rational.create_zero())
    UnitTest.assert(Rational.is_zero(zero_abs), "Absolute value of zero should be zero")
    
    Let zero_negate be Rational.negate(Rational.create_zero())
    UnitTest.assert(Rational.is_zero(zero_negate), "Negated zero should be zero")

Note: ===== COMPARISON TESTS =====

Process called "test_compare":
    Note: Test rational comparison operations
    Let a be Rational.create_from_integers(3, 4)
    Let b be Rational.create_from_integers(5, 6)
    Let c be Rational.create_from_integers(3, 4)
    
    assert_comparison_result(Rational.compare(a, b), -1, "3/4 < 5/6")
    assert_comparison_result(Rational.compare(b, a), 1, "5/6 > 3/4")
    assert_comparison_result(Rational.compare(a, c), 0, "3/4 == 3/4")
    
    Let different_form_equal be Rational.create_from_integers(6, 8)
    assert_comparison_result(Rational.compare(a, different_form_equal), 0, "3/4 == 6/8 (different form)")
    
    Let negative_comparison be Rational.compare(
        Rational.create_from_integers(-1, 2),
        Rational.create_from_integers(1, 3)
    )
    assert_comparison_result(negative_comparison, -1, "Negative vs positive comparison")

Process called "test_equals":
    Note: Test rational equality
    Let a be Rational.create_from_integers(3, 4)
    Let b be Rational.create_from_integers(3, 4)
    Let c be Rational.create_from_integers(6, 8)  Note: Same value, different form
    Let d be Rational.create_from_integers(5, 6)
    
    UnitTest.assert(Rational.equals(a, b), "Same rationals should be equal")
    UnitTest.assert(Rational.equals(a, c), "Equivalent rationals should be equal")
    UnitTest.assert(not Rational.equals(a, d), "Different rationals should not be equal")
    
    Note: Test zero equality
    UnitTest.assert(Rational.equals(Rational.create_zero(), Rational.create_from_integers(0, 5)), "Zero equality")

Process called "test_max_min":
    Note: Test maximum and minimum operations
    Let a be Rational.create_from_integers(3, 4)
    Let b be Rational.create_from_integers(5, 6)
    
    Let max_result be Rational.max(a, b)
    assert_rational_equals(max_result, b, "Maximum of 3/4 and 5/6")
    
    Let min_result be Rational.min(a, b)
    assert_rational_equals(min_result, a, "Minimum of 3/4 and 5/6")
    
    Let equal_max be Rational.max(a, a)
    assert_rational_equals(equal_max, a, "Maximum of equal values")
    
    Let negative_max be Rational.max(
        Rational.create_from_integers(-1, 2),
        Rational.create_from_integers(-1, 3)
    )
    assert_rational_equals(negative_max, Rational.create_from_integers(-1, 3), "Maximum of negative rationals")

Note: ===== CONVERSION TESTS =====

Process called "test_to_double":
    Note: Test conversion to double (with potential precision loss)
    Let half be Rational.create_from_integers(1, 2)
    Let half_double be Rational.to_double(half)
    UnitTest.assert(half_double equals 0.5, "1/2 converts to 0.5")
    
    Let quarter be Rational.create_from_integers(1, 4)
    Let quarter_double be Rational.to_double(quarter)
    UnitTest.assert(quarter_double equals 0.25, "1/4 converts to 0.25")
    
    Let third be Rational.create_from_integers(1, 3)
    Let third_double be Rational.to_double(third)
    UnitTest.assert(third_double > 0.33 and third_double < 0.34, "1/3 converts to approximately 0.333...")
    
    Let zero_double be Rational.to_double(Rational.create_zero())
    UnitTest.assert(zero_double equals 0.0, "Zero converts to 0.0")

Process called "test_to_decimal_string":
    Note: Test conversion to decimal string representation
    Let half be Rational.create_from_integers(1, 2)
    Let half_decimal be Rational.to_decimal_string(half, 4)
    UnitTest.assert(half_decimal equals "0.5000", "1/2 as decimal string with 4 places")
    
    Let quarter be Rational.create_from_integers(1, 4)
    Let quarter_decimal be Rational.to_decimal_string(quarter, 3)
    UnitTest.assert(quarter_decimal equals "0.250", "1/4 as decimal string with 3 places")
    
    Let third be Rational.create_from_integers(1, 3)
    Let third_decimal be Rational.to_decimal_string(third, 6)
    UnitTest.assert(third_decimal equals "0.333333", "1/3 as decimal string with 6 places")
    
    Let integer_decimal be Rational.to_decimal_string(Rational.create_from_integers(5, 1), 2)
    UnitTest.assert(integer_decimal equals "5.00", "Integer as decimal string")

Process called "test_to_string":
    Note: Test string representation of rationals
    Let simple_fraction be Rational.create_from_integers(3, 4)
    assert_string_representation(simple_fraction, "3/4", "Simple fraction string")
    
    Let integer_rational be Rational.create_from_integers(5, 1)
    assert_string_representation(integer_rational, "5", "Integer rational string")
    
    Let negative_rational be Rational.create_from_integers(-2, 3)
    assert_string_representation(negative_rational, "-2/3", "Negative rational string")
    
    let zero_string be Rational.to_string(Rational.create_zero())
    UnitTest.assert(zero_string equals "0", "Zero rational string")

Process called "test_to_mixed_number":
    Note: Test conversion to mixed number representation
    Let improper_fraction be Rational.create_from_integers(7, 3)
    Let mixed_number be Rational.to_mixed_number(improper_fraction)
    UnitTest.assert(mixed_number equals "2 1/3", "7/3 as mixed number")
    
    Let proper_fraction be Rational.create_from_integers(2, 3)
    Let proper_mixed be Rational.to_mixed_number(proper_fraction)
    UnitTest.assert(proper_mixed equals "2/3", "Proper fraction as mixed number")
    
    Let integer_mixed be Rational.to_mixed_number(Rational.create_from_integers(6, 1))
    UnitTest.assert(integer_mixed equals "6", "Integer as mixed number")
    
    Let negative_mixed be Rational.to_mixed_number(Rational.create_from_integers(-7, 3))
    UnitTest.assert(negative_mixed equals "-2 1/3", "Negative improper fraction as mixed number")

Note: ===== MATHEMATICAL FUNCTION TESTS =====

Process called "test_square_root_approximation":
    Note: Test square root approximation using continued fractions
    Let four be Rational.create_from_integers(4, 1)
    Let sqrt_four be Rational.square_root_approximation(four, 10)
    assert_rational_equals(sqrt_four, Rational.create_from_integers(2, 1), "Square root of 4 should be exactly 2")
    
    Let two be Rational.create_from_integers(2, 1)
    Let sqrt_two be Rational.square_root_approximation(two, 100)
    Note: √2 ≈ 1.414... should be close to 1414/1000
    Let expected_sqrt_two be Rational.create_from_integers(1414, 1000)
    Let difference be Rational.abs(Rational.subtract(sqrt_two, expected_sqrt_two))
    Let tolerance be Rational.create_from_integers(1, 100)
    UnitTest.assert(Rational.compare(difference, tolerance) <= 0, "Square root of 2 approximation")

Process called "test_nth_root_approximation":
    Note: Test nth root approximation
    Let eight be Rational.create_from_integers(8, 1)
    Let cube_root_eight be Rational.nth_root_approximation(eight, 3, 10)
    assert_rational_equals(cube_root_eight, Rational.create_from_integers(2, 1), "Cube root of 8 should be exactly 2")
    
    Let twenty_seven be Rational.create_from_integers(27, 1)
    Let cube_root_twenty_seven be Rational.nth_root_approximation(twenty_seven, 3, 10)
    assert_rational_equals(cube_root_twenty_seven, Rational.create_from_integers(3, 1), "Cube root of 27 should be exactly 3")

Process called "test_gcd_lcm":
    Note: Test GCD and LCM of rational numbers
    Let a be Rational.create_from_integers(4, 6)  Note: 2/3 in reduced form
    Let b be Rational.create_from_integers(6, 9)  Note: 2/3 in reduced form
    
    Let gcd_result be Rational.gcd(a, b)
    assert_rational_equals(gcd_result, Rational.create_from_integers(2, 3), "GCD of equivalent rationals")
    
    Let c be Rational.create_from_integers(1, 2)
    Let d be Rational.create_from_integers(1, 3)
    
    Let gcd_different be Rational.gcd(c, d)
    assert_rational_equals(gcd_different, Rational.create_from_integers(1, 6), "GCD of 1/2 and 1/3")
    
    Let lcm_different be Rational.lcm(c, d)
    assert_rational_equals(lcm_different, Rational.create_from_integers(1, 1), "LCM of 1/2 and 1/3")

Note: ===== UTILITY FUNCTION TESTS =====

Process called "test_utility_functions":
    Note: Test utility getter and checker functions
    Let rational be Rational.create_from_integers(3, 4)
    
    Let numerator be Rational.get_numerator(rational)
    UnitTest.assert(BigInteger.equals(numerator, BigInteger.create_from_integer(3)), "Numerator getter")
    
    Let denominator be Rational.get_denominator(rational)
    UnitTest.assert(BigInteger.equals(denominator, BigInteger.create_from_integer(4)), "Denominator getter")
    
    UnitTest.assert(Rational.is_positive(rational), "Positive rational check")
    UnitTest.assert(not Rational.is_negative(rational), "Positive rational is not negative")
    
    Let negative_rational be Rational.create_from_integers(-3, 4)
    UnitTest.assert(Rational.is_negative(negative_rational), "Negative rational check")
    UnitTest.assert(not Rational.is_positive(negative_rational), "Negative rational is not positive")
    
    let zero be Rational.create_zero()
    UnitTest.assert(Rational.is_zero(zero), "Zero check")
    UnitTest.assert(not Rational.is_positive(zero), "Zero is not positive")
    UnitTest.assert(not Rational.is_negative(zero), "Zero is not negative")
    
    Let one be Rational.create_one()
    UnitTest.assert(Rational.is_one(one), "One check")
    UnitTest.assert(Rational.is_positive(one), "One is positive")

Process called "test_is_integer":
    Note: Test integer rational detection
    Let integer_rational be Rational.create_from_integers(5, 1)
    UnitTest.assert(Rational.is_integer(integer_rational), "5/1 should be integer")
    
    Let zero_integer be Rational.create_from_integers(0, 1)
    UnitTest.assert(Rational.is_integer(zero_integer), "0/1 should be integer")
    
    Let reduced_integer be Rational.create_from_integers(10, 5)  Note: Should reduce to 2/1
    UnitTest.assert(Rational.is_integer(reduced_integer), "10/5 should be integer")
    
    Let proper_fraction be Rational.create_from_integers(3, 4)
    UnitTest.assert(not Rational.is_integer(proper_fraction), "3/4 should not be integer")
    
    Let improper_non_integer be Rational.create_from_integers(7, 3)
    UnitTest.assert(not Rational.is_integer(improper_non_integer), "7/3 should not be integer")

Process called "test_is_proper_improper":
    Note: Test proper and improper fraction detection
    Let proper be Rational.create_from_integers(3, 4)
    UnitTest.assert(Rational.is_proper_fraction(proper), "3/4 should be proper fraction")
    UnitTest.assert(not Rational.is_improper_fraction(proper), "3/4 should not be improper fraction")
    
    Let improper be Rational.create_from_integers(7, 3)
    UnitTest.assert(Rational.is_improper_fraction(improper), "7/3 should be improper fraction")
    UnitTest.assert(not Rational.is_proper_fraction(improper), "7/3 should not be proper fraction")
    
    Let unit_fraction be Rational.create_from_integers(1, 5)
    UnitTest.assert(Rational.is_unit_fraction(unit_fraction), "1/5 should be unit fraction")
    UnitTest.assert(Rational.is_proper_fraction(unit_fraction), "1/5 should be proper fraction")
    
    Let integer_rational be Rational.create_from_integers(5, 1)
    UnitTest.assert(not Rational.is_proper_fraction(integer_rational), "Integer should not be proper fraction")
    UnitTest.assert(Rational.is_improper_fraction(integer_rational), "Integer should be improper fraction")

Note: ===== CONTINUED FRACTION TESTS =====

Process called "test_to_continued_fraction":
    Note: Test conversion to continued fraction representation
    Let golden_ratio_approx be Rational.create_from_integers(8, 5)  Note: Fibonacci approximation
    Let continued_fraction be Rational.to_continued_fraction(golden_ratio_approx)
    
    Note: 8/5 = 1 + 3/5 = 1 + 1/(5/3) = 1 + 1/(1 + 2/3) = 1 + 1/(1 + 1/(3/2)) = [1; 1, 1, 1]
    Let expected_cf be Array.create([1, 1, 1, 1])
    UnitTest.assert(Array.equals(continued_fraction, expected_cf), "8/5 continued fraction")
    
    Let simple_fraction be Rational.create_from_integers(22, 7)
    Let cf_pi_approx be Rational.to_continued_fraction(simple_fraction)
    Note: 22/7 = 3 + 1/7 = [3; 7]
    Let expected_pi_cf be Array.create([3, 7])
    UnitTest.assert(Array.equals(cf_pi_approx, expected_pi_cf), "22/7 continued fraction")

Process called "test_from_continued_fraction":
    Note: Test construction from continued fraction representation
    Let cf be Array.create([1, 1, 1, 1])
    Let rational be Rational.from_continued_fraction(cf)
    assert_rational_equals(rational, Rational.create_from_integers(8, 5), "Continued fraction [1; 1, 1, 1] = 8/5")
    
    Let pi_cf be Array.create([3, 7])
    let pi_approx be Rational.from_continued_fraction(pi_cf)
    assert_rational_equals(pi_approx, Rational.create_from_integers(22, 7), "Continued fraction [3; 7] = 22/7")

Note: ===== LARGE NUMBER TESTS =====

Process called "test_large_number_operations":
    Note: Test operations with very large numerators and denominators
    Let large_rationals be create_large_rationals()
    
    Let large_a be large_rationals[0]
    let large_b be large_rationals[1]
    
    Note: Test that operations complete without overflow
    Let large_sum be Rational.add(large_a, large_b)
    UnitTest.assert(not Rational.is_zero(large_sum), "Large number addition produces non-zero result")
    
    Let large_product be Rational.multiply(large_a, large_b)
    UnitTest.assert(Rational.is_one(large_product), "a/b * b/a should equal 1")
    
    Let large_quotient be Rational.divide(large_a, large_b)
    assert_is_in_reduced_form(large_quotient, "Large number division result should be reduced")

Process called "test_precision_preservation":
    Note: Test that exact precision is maintained in operations
    Let precise_fraction be Rational.create_from_decimal_string("0.142857142857142857")  Note: 1/7 approximation
    Let seven be Rational.create_from_integers(7, 1)
    Let product be Rational.multiply(precise_fraction, seven)
    
    Note: The result should be very close to 1, testing precision preservation
    Let one be Rational.create_one()
    Let difference be Rational.abs(Rational.subtract(product, one))
    Let tolerance be Rational.create_from_integers(1, 1000000)
    UnitTest.assert(Rational.compare(difference, tolerance) <= 0, "Precision preservation in multiplication")

Note: ===== ERROR HANDLING TESTS =====

Process called "test_error_handling":
    Note: Test error conditions and edge cases
    
    Note: Division by zero should be handled appropriately
    Note: These would throw errors in real implementation
    Note: Test constructor with zero denominator
    Note: Test reciprocal of zero
    Note: Test invalid string formats
    
    Note: Test very small and very large rationals
    Let tiny be Rational.create_from_bigintegers(
        BigInteger.create_from_integer(1),
        BigInteger.power(BigInteger.create_from_integer(10), 100)
    )
    UnitTest.assert(not Rational.is_zero(tiny), "Very small rational should not be zero")
    
    Let huge be Rational.create_from_bigintegers(
        BigInteger.power(BigInteger.create_from_integer(10), 100),
        BigInteger.create_from_integer(1)
    )
    UnitTest.assert(Rational.is_positive(huge), "Very large rational should be positive")

Note: ===== TEST RUNNER =====

Process called "run_all_tests":
    Note: Executes all Rational unit tests
    UnitTest.start_test_suite("Rational Module Tests")
    
    Note: Construction tests
    UnitTest.run_test("Create from Integers", test_create_from_integers)
    UnitTest.run_test("Create from BigIntegers", test_create_from_bigintegers)
    UnitTest.run_test("Create from String", test_create_from_string)
    UnitTest.run_test("Create from Decimal String", test_create_from_decimal_string)
    UnitTest.run_test("Create Zero and One", test_create_zero_and_one)
    
    Note: Arithmetic operation tests
    UnitTest.run_test("Addition", test_addition)
    UnitTest.run_test("Subtraction", test_subtraction)
    UnitTest.run_test("Multiplication", test_multiplication)
    UnitTest.run_test("Division", test_division)
    UnitTest.run_test("Power", test_power)
    
    Note: Reduction and normalization tests
    UnitTest.run_test("Reduce", test_reduce)
    UnitTest.run_test("Reciprocal", test_reciprocal)
    UnitTest.run_test("Absolute Value and Negate", test_abs_and_negate)
    
    Note: Comparison tests
    UnitTest.run_test("Compare", test_compare)
    UnitTest.run_test("Equals", test_equals)
    UnitTest.run_test("Max Min", test_max_min)
    
    Note: Conversion tests
    UnitTest.run_test("To Double", test_to_double)
    UnitTest.run_test("To Decimal String", test_to_decimal_string)
    UnitTest.run_test("To String", test_to_string)
    UnitTest.run_test("To Mixed Number", test_to_mixed_number)
    
    Note: Mathematical function tests
    UnitTest.run_test("Square Root Approximation", test_square_root_approximation)
    UnitTest.run_test("Nth Root Approximation", test_nth_root_approximation)
    UnitTest.run_test("GCD LCM", test_gcd_lcm)
    
    Note: Utility function tests
    UnitTest.run_test("Utility Functions", test_utility_functions)
    UnitTest.run_test("Is Integer", test_is_integer)
    UnitTest.run_test("Is Proper/Improper", test_is_proper_improper)
    
    Note: Continued fraction tests
    UnitTest.run_test("To Continued Fraction", test_to_continued_fraction)
    UnitTest.run_test("From Continued Fraction", test_from_continued_fraction)
    
    Note: Large number tests
    UnitTest.run_test("Large Number Operations", test_large_number_operations)
    UnitTest.run_test("Precision Preservation", test_precision_preservation)
    
    Note: Error handling tests
    UnitTest.run_test("Error Handling", test_error_handling)
    
    UnitTest.end_test_suite()