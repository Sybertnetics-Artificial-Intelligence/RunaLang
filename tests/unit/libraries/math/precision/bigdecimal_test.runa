Note: ===== RUNA UNIT TESTS: MATH/PRECISION/BIGDECIMAL =====

Import "math/precision/bigdecimal" as BigDecimal
Import "dev/debug/testing/unit" as UnitTest

Note: ===== TEST DATA GENERATORS =====

Process called "create_test_decimals" returns Array[BigDecimal.BigDecimal]:
    Note: Creates array of test BigDecimal values for comprehensive testing
    Let test_values be Array.create([
        BigDecimal.create_zero(0),
        BigDecimal.create_zero(2),
        BigDecimal.create_one(0),
        BigDecimal.create_one(3),
        BigDecimal.create_from_integer(42, 0),
        BigDecimal.create_from_integer(42, 2),
        BigDecimal.create_from_integer(-42, 1),
        BigDecimal.create_from_string("123.456", create_default_context()),
        BigDecimal.create_from_string("-123.456", create_default_context()),
        BigDecimal.create_from_string("0.001", create_default_context()),
        BigDecimal.create_from_string("1000000", create_default_context()),
        BigDecimal.create_from_string("1.23E+10", create_default_context()),
        BigDecimal.create_from_string("1.23E-10", create_default_context()),
        BigDecimal.create_from_string("999.999", create_default_context()),
        BigDecimal.create_from_string("0.000001", create_default_context())
    ])
    Return test_values

Process called "create_default_context" returns BigDecimal.MathContext:
    Note: Creates standard math context for testing
    Let context be BigDecimal.MathContext.new()
    Set context.precision to 34
    Set context.rounding_mode to BigDecimal.RoundingMode.HALF_EVEN
    Set context.exact_arithmetic to false
    Return context

Process called "create_financial_context" returns BigDecimal.FinancialContext:
    Note: Creates financial context for currency testing
    Let context be BigDecimal.FinancialContext.new()
    Set context.currency_code to "USD"
    Set context.decimal_places to 2
    Set context.rounding_mode to BigDecimal.RoundingMode.HALF_UP
    Set context.use_banker_rounding to true
    Return context

Process called "create_format_options" returns BigDecimal.DecimalFormatOptions:
    Note: Creates formatting options for string conversion testing
    Let options be BigDecimal.DecimalFormatOptions.new()
    Set options.use_scientific_notation to false
    Set options.minimum_fraction_digits to 0
    Set options.maximum_fraction_digits to 10
    Set options.grouping_separator to ","
    Set options.decimal_separator to "."
    Return options

Note: ===== ASSERTION HELPERS =====

Process called "assert_decimal_equals" that takes actual as BigDecimal.BigDecimal, expected as BigDecimal.BigDecimal, message as String:
    Note: Asserts BigDecimal equality ignoring scale differences
    Let are_equal be BigDecimal.equals_ignoring_scale(actual, expected)
    UnitTest.assert(are_equal, message + " - Expected: " + BigDecimal.to_plain_string(expected) + ", Actual: " + BigDecimal.to_plain_string(actual))

Process called "assert_decimal_exact_equals" that takes actual as BigDecimal.BigDecimal, expected as BigDecimal.BigDecimal, message as String:
    Note: Asserts exact BigDecimal equality including scale
    Let are_equal be BigDecimal.equals(actual, expected)
    UnitTest.assert(are_equal, message + " - Expected: " + BigDecimal.to_plain_string(expected) + " (scale: " + Integer.to_string(BigDecimal.get_scale(expected)) + "), Actual: " + BigDecimal.to_plain_string(actual) + " (scale: " + Integer.to_string(BigDecimal.get_scale(actual)) + ")")

Process called "assert_comparison_result" that takes result as Integer, expected as Integer, message as String:
    Note: Asserts comparison results (-1, 0, 1)
    UnitTest.assert(result equals expected, message + " - Expected comparison: " + Integer.to_string(expected) + ", Actual: " + Integer.to_string(result))

Process called "assert_string_representation" that takes decimal as BigDecimal.BigDecimal, expected as String, message as String:
    Note: Asserts string representation matches expected
    Let actual be BigDecimal.to_plain_string(decimal)
    UnitTest.assert(actual equals expected, message + " - Expected: '" + expected + "', Actual: '" + actual + "'")

Process called "assert_precision_and_scale" that takes decimal as BigDecimal.BigDecimal, expected_precision as Integer, expected_scale as Integer, message as String:
    Note: Asserts BigDecimal has expected precision and scale
    Let actual_precision be BigDecimal.get_precision(decimal)
    Let actual_scale be BigDecimal.get_scale(decimal)
    UnitTest.assert(actual_precision equals expected_precision and actual_scale equals expected_scale, 
        message + " - Expected precision: " + Integer.to_string(expected_precision) + ", scale: " + Integer.to_string(expected_scale) + 
        ", Actual precision: " + Integer.to_string(actual_precision) + ", scale: " + Integer.to_string(actual_scale))

Note: ===== CONSTRUCTION TESTS =====

Process called "test_create_from_integer":
    Note: Test BigDecimal creation from integers with various scales
    Let zero_scale be BigDecimal.create_from_integer(42, 0)
    assert_decimal_equals(zero_scale, BigDecimal.create_from_string("42", create_default_context()), "Integer 42 with scale 0")
    assert_precision_and_scale(zero_scale, 2, 0, "Integer 42 precision and scale")
    
    Let two_scale be BigDecimal.create_from_integer(42, 2)
    assert_decimal_equals(two_scale, BigDecimal.create_from_string("0.42", create_default_context()), "Integer 42 with scale 2")
    assert_precision_and_scale(two_scale, 2, 2, "Integer 42 scale 2 precision and scale")
    
    Let negative be BigDecimal.create_from_integer(-123, 1)
    assert_decimal_equals(negative, BigDecimal.create_from_string("-12.3", create_default_context()), "Negative integer with scale")
    
    Let zero_int be BigDecimal.create_from_integer(0, 3)
    UnitTest.assert(BigDecimal.is_zero(zero_int), "Zero integer should be zero")

Process called "test_create_from_string":
    Note: Test BigDecimal creation from string representations
    Let simple_decimal be BigDecimal.create_from_string("123.456", create_default_context())
    assert_string_representation(simple_decimal, "123.456", "Simple decimal string")
    assert_precision_and_scale(simple_decimal, 6, 3, "Simple decimal precision and scale")
    
    Let negative_decimal be BigDecimal.create_from_string("-123.456", create_default_context())
    assert_string_representation(negative_decimal, "-123.456", "Negative decimal string")
    
    Let scientific_positive be BigDecimal.create_from_string("1.23E+2", create_default_context())
    assert_decimal_equals(scientific_positive, BigDecimal.create_from_string("123", create_default_context()), "Positive scientific notation")
    
    Let scientific_negative be BigDecimal.create_from_string("1.23E-2", create_default_context())
    assert_decimal_equals(scientific_negative, BigDecimal.create_from_string("0.0123", create_default_context()), "Negative scientific notation")
    
    Let zero_string be BigDecimal.create_from_string("0.000", create_default_context())
    UnitTest.assert(BigDecimal.is_zero(zero_string), "Zero string should be zero")
    
    Let integer_string be BigDecimal.create_from_string("42", create_default_context())
    assert_decimal_equals(integer_string, BigDecimal.create_from_integer(42, 0), "Integer string")

Process called "test_create_from_double":
    Note: Test BigDecimal creation from double values
    Let simple_double be BigDecimal.create_from_double(123.456, create_default_context())
    Let expected be BigDecimal.create_from_string("123.456", create_default_context())
    Note: Allow for small floating-point representation differences
    Let difference be BigDecimal.abs(BigDecimal.subtract(simple_double, expected, create_default_context()))
    Let tolerance be BigDecimal.create_from_string("0.000001", create_default_context())
    UnitTest.assert(BigDecimal.compare(difference, tolerance) <= 0, "Double conversion within tolerance")
    
    Let zero_double be BigDecimal.create_from_double(0.0, create_default_context())
    UnitTest.assert(BigDecimal.is_zero(zero_double), "Zero double should be zero")
    
    Let negative_double be BigDecimal.create_from_double(-42.5, create_default_context())
    UnitTest.assert(BigDecimal.is_negative(negative_double), "Negative double should be negative")

Process called "test_create_from_fraction":
    Note: Test BigDecimal creation from fraction (numerator/denominator)
    Let context be create_default_context()
    
    Let simple_fraction be BigDecimal.create_from_fraction(
        BigInteger.create_from_integer(1),
        BigInteger.create_from_integer(2),
        context
    )
    assert_decimal_equals(simple_fraction, BigDecimal.create_from_string("0.5", context), "Simple fraction 1/2")
    
    Let complex_fraction be BigDecimal.create_from_fraction(
        BigInteger.create_from_integer(22),
        BigInteger.create_from_integer(7),
        context
    )
    Note: 22/7 approximates Ï€
    Let expected_pi_approx be BigDecimal.create_from_string("3.14285714285714", context)
    Let difference be BigDecimal.abs(BigDecimal.subtract(complex_fraction, expected_pi_approx, context))
    Let tolerance be BigDecimal.create_from_string("0.000001", context)
    UnitTest.assert(BigDecimal.compare(difference, tolerance) <= 0, "Complex fraction 22/7")
    
    Let zero_fraction be BigDecimal.create_from_fraction(
        BigInteger.create_from_integer(0),
        BigInteger.create_from_integer(5),
        context
    )
    UnitTest.assert(BigDecimal.is_zero(zero_fraction), "Zero fraction should be zero")

Process called "test_create_zero_and_one":
    Note: Test creation of zero and one constants
    Let zero be BigDecimal.create_zero(0)
    UnitTest.assert(BigDecimal.is_zero(zero), "Zero should be zero")
    assert_precision_and_scale(zero, 1, 0, "Zero precision and scale")
    
    Let zero_scaled be BigDecimal.create_zero(3)
    UnitTest.assert(BigDecimal.is_zero(zero_scaled), "Scaled zero should be zero")
    assert_precision_and_scale(zero_scaled, 1, 3, "Scaled zero precision and scale")
    
    Let one be BigDecimal.create_one(0)
    assert_decimal_equals(one, BigDecimal.create_from_string("1", create_default_context()), "One should equal 1")
    assert_precision_and_scale(one, 1, 0, "One precision and scale")
    
    Let one_scaled be BigDecimal.create_one(2)
    assert_decimal_equals(one_scaled, BigDecimal.create_from_string("1.00", create_default_context()), "Scaled one should equal 1.00")

Note: ===== ARITHMETIC OPERATION TESTS =====

Process called "test_addition":
    Note: Test BigDecimal addition with various scales and precisions
    Let context be create_default_context()
    
    Let a be BigDecimal.create_from_string("123.45", context)
    Let b be BigDecimal.create_from_string("67.89", context)
    Let sum be BigDecimal.add(a, b, context)
    assert_decimal_equals(sum, BigDecimal.create_from_string("191.34", context), "Simple addition")
    
    Let different_scales be BigDecimal.add(
        BigDecimal.create_from_string("1.2", context),
        BigDecimal.create_from_string("3.456", context),
        context
    )
    assert_decimal_equals(different_scales, BigDecimal.create_from_string("4.656", context), "Addition with different scales")
    
    Let with_zero be BigDecimal.add(a, BigDecimal.create_zero(2), context)
    assert_decimal_equals(with_zero, a, "Addition with zero")
    
    Let negative_positive be BigDecimal.add(
        BigDecimal.create_from_string("-100.5", context),
        BigDecimal.create_from_string("50.25", context),
        context
    )
    assert_decimal_equals(negative_positive, BigDecimal.create_from_string("-50.25", context), "Addition of negative and positive")

Process called "test_subtraction":
    Note: Test BigDecimal subtraction operations
    Let context be create_default_context()
    
    Let a be BigDecimal.create_from_string("123.45", context)
    Let b be BigDecimal.create_from_string("23.45", context)
    Let difference be BigDecimal.subtract(a, b, context)
    assert_decimal_equals(difference, BigDecimal.create_from_string("100.00", context), "Simple subtraction")
    
    Let from_zero be BigDecimal.subtract(BigDecimal.create_zero(2), a, context)
    assert_decimal_equals(from_zero, BigDecimal.negate(a), "Subtraction from zero")
    
    Let same_values be BigDecimal.subtract(a, a, context)
    UnitTest.assert(BigDecimal.is_zero(same_values), "Subtraction of same values should be zero")
    
    Let negative_result be BigDecimal.subtract(
        BigDecimal.create_from_string("50.0", context),
        BigDecimal.create_from_string("75.5", context),
        context
    )
    assert_decimal_equals(negative_result, BigDecimal.create_from_string("-25.5", context), "Subtraction resulting in negative")

Process called "test_multiplication":
    Note: Test BigDecimal multiplication operations
    Let context be create_default_context()
    
    Let a be BigDecimal.create_from_string("12.5", context)
    Let b be BigDecimal.create_from_string("4.0", context)
    Let product be BigDecimal.multiply(a, b, context)
    assert_decimal_equals(product, BigDecimal.create_from_string("50.0", context), "Simple multiplication")
    
    Let with_one be BigDecimal.multiply(a, BigDecimal.create_one(0), context)
    assert_decimal_equals(with_one, a, "Multiplication by one")
    
    Let with_zero be BigDecimal.multiply(a, BigDecimal.create_zero(0), context)
    UnitTest.assert(BigDecimal.is_zero(with_zero), "Multiplication by zero should be zero")
    
    Let negative_multiplication be BigDecimal.multiply(
        BigDecimal.create_from_string("-3.5", context),
        BigDecimal.create_from_string("2.0", context),
        context
    )
    assert_decimal_equals(negative_multiplication, BigDecimal.create_from_string("-7.0", context), "Multiplication with negative")
    
    Let decimal_precision be BigDecimal.multiply(
        BigDecimal.create_from_string("0.123", context),
        BigDecimal.create_from_string("0.456", context),
        context
    )
    assert_decimal_equals(decimal_precision, BigDecimal.create_from_string("0.056088", context), "High precision decimal multiplication")

Process called "test_division":
    Note: Test BigDecimal division operations
    Let context be create_default_context()
    
    Let a be BigDecimal.create_from_string("10.0", context)
    Let b be BigDecimal.create_from_string("2.5", context)
    Let quotient be BigDecimal.divide(a, b, context)
    assert_decimal_equals(quotient, BigDecimal.create_from_string("4.0", context), "Simple division")
    
    Let by_one be BigDecimal.divide(a, BigDecimal.create_one(0), context)
    assert_decimal_equals(by_one, a, "Division by one")
    
    Let self_division be BigDecimal.divide(a, a, context)
    assert_decimal_equals(self_division, BigDecimal.create_one(0), "Division by self should be one")
    
    Let fraction_result be BigDecimal.divide(
        BigDecimal.create_from_string("1.0", context),
        BigDecimal.create_from_string("3.0", context),
        context
    )
    Note: 1/3 should be approximately 0.333...
    Let expected_third be BigDecimal.create_from_string("0.3333333333", context)
    Let difference be BigDecimal.abs(BigDecimal.subtract(fraction_result, expected_third, context))
    Let tolerance be BigDecimal.create_from_string("0.0000000001", context)
    UnitTest.assert(BigDecimal.compare(difference, tolerance) <= 0, "Division resulting in repeating decimal")

Process called "test_remainder":
    Note: Test BigDecimal remainder (modulo) operations
    Let context be create_default_context()
    
    Let dividend be BigDecimal.create_from_string("10.0", context)
    Let divisor be BigDecimal.create_from_string("3.0", context)
    Let remainder be BigDecimal.remainder(dividend, divisor, context)
    assert_decimal_equals(remainder, BigDecimal.create_from_string("1.0", context), "Integer-like remainder")
    
    Let decimal_remainder be BigDecimal.remainder(
        BigDecimal.create_from_string("10.5", context),
        BigDecimal.create_from_string("2.25", context),
        context
    )
    Note: 10.5 % 2.25 = 10.5 - 4*2.25 = 10.5 - 9.0 = 1.5
    assert_decimal_equals(decimal_remainder, BigDecimal.create_from_string("1.5", context), "Decimal remainder")
    
    Let zero_remainder be BigDecimal.remainder(
        BigDecimal.create_from_string("15.0", context),
        BigDecimal.create_from_string("5.0", context),
        context
    )
    UnitTest.assert(BigDecimal.is_zero(zero_remainder), "Remainder should be zero for exact division")

Process called "test_divide_to_integral_value":
    Note: Test integer division (truncating decimal part)
    Let a be BigDecimal.create_from_string("17.8", create_default_context())
    Let b be BigDecimal.create_from_string("3.2", create_default_context())
    Let integral_quotient be BigDecimal.divide_to_integral_value(a, b)
    assert_decimal_equals(integral_quotient, BigDecimal.create_from_string("5", create_default_context()), "Integer division result")
    
    Let exact_division be BigDecimal.divide_to_integral_value(
        BigDecimal.create_from_string("20.0", create_default_context()),
        BigDecimal.create_from_string("4.0", create_default_context())
    )
    assert_decimal_equals(exact_division, BigDecimal.create_from_string("5", create_default_context()), "Exact integer division")

Note: ===== PRECISION AND SCALE TESTS =====

Process called "test_round":
    Note: Test BigDecimal rounding with various modes
    Let value be BigDecimal.create_from_string("123.456789", create_default_context())
    
    Let context_half_up be create_default_context()
    Set context_half_up.precision to 5
    Set context_half_up.rounding_mode to BigDecimal.RoundingMode.HALF_UP
    
    Let rounded_half_up be BigDecimal.round(value, context_half_up)
    assert_decimal_equals(rounded_half_up, BigDecimal.create_from_string("123.46", create_default_context()), "HALF_UP rounding")
    
    Let context_half_down be create_default_context()
    Set context_half_down.precision to 5
    Set context_half_down.rounding_mode to BigDecimal.RoundingMode.HALF_DOWN
    
    Let rounded_half_down be BigDecimal.round(value, context_half_down)
    assert_decimal_equals(rounded_half_down, BigDecimal.create_from_string("123.45", create_default_context()), "HALF_DOWN rounding")
    
    Let context_ceiling be create_default_context()
    Set context_ceiling.precision to 4
    Set context_ceiling.rounding_mode to BigDecimal.RoundingMode.CEILING
    
    Let rounded_ceiling be BigDecimal.round(value, context_ceiling)
    assert_decimal_equals(rounded_ceiling, BigDecimal.create_from_string("123.5", create_default_context()), "CEILING rounding")

Process called "test_set_scale":
    Note: Test scale adjustment with rounding
    Let value be BigDecimal.create_from_string("123.456789", create_default_context())
    
    Let increased_scale be BigDecimal.set_scale(value, 8, BigDecimal.RoundingMode.HALF_UP)
    assert_precision_and_scale(increased_scale, 10, 8, "Increased scale precision and scale")
    assert_decimal_equals(increased_scale, BigDecimal.create_from_string("123.45678900", create_default_context()), "Increased scale adds zeros")
    
    Let decreased_scale be BigDecimal.set_scale(value, 2, BigDecimal.RoundingMode.HALF_UP)
    assert_precision_and_scale(decreased_scale, 5, 2, "Decreased scale precision and scale")
    assert_decimal_equals(decreased_scale, BigDecimal.create_from_string("123.46", create_default_context()), "Decreased scale with rounding")
    
    Let same_scale be BigDecimal.set_scale(value, BigDecimal.get_scale(value), BigDecimal.RoundingMode.HALF_UP)
    assert_decimal_exact_equals(same_scale, value, "Same scale should return identical value")

Process called "test_strip_trailing_zeros":
    Note: Test removal of trailing zeros
    Let with_zeros be BigDecimal.create_from_string("123.4500", create_default_context())
    Let stripped be BigDecimal.strip_trailing_zeros(with_zeros)
    assert_string_representation(stripped, "123.45", "Trailing zeros removed")
    
    Let integer_zeros be BigDecimal.create_from_string("1000.000", create_default_context())
    Let stripped_integer be BigDecimal.strip_trailing_zeros(integer_zeros)
    assert_string_representation(stripped_integer, "1000", "Integer trailing zeros removed")
    
    Let all_zeros be BigDecimal.create_from_string("0.000", create_default_context())
    Let stripped_all_zeros be BigDecimal.strip_trailing_zeros(all_zeros)
    assert_string_representation(stripped_all_zeros, "0", "All trailing zeros removed")

Process called "test_with_precision":
    Note: Test precision adjustment
    Let value be BigDecimal.create_from_string("123.456789", create_default_context())
    
    Let reduced_precision be BigDecimal.with_precision(value, 4, BigDecimal.RoundingMode.HALF_UP)
    assert_precision_and_scale(reduced_precision, 4, -1, "Reduced precision")
    assert_decimal_equals(reduced_precision, BigDecimal.create_from_string("123.5", create_default_context()), "Reduced precision value")
    
    Let same_precision be BigDecimal.with_precision(value, 9, BigDecimal.RoundingMode.HALF_UP)
    assert_decimal_exact_equals(same_precision, value, "Same precision should return identical value")

Process called "test_normalize":
    Note: Test normalization (canonical form)
    Let unnormalized be BigDecimal.create_from_string("123.4500", create_default_context())
    Let normalized be BigDecimal.normalize(unnormalized)
    assert_string_representation(normalized, "123.45", "Normalized removes trailing zeros")
    
    Let integer_normal be BigDecimal.create_from_string("1000", create_default_context())
    Let normalized_integer be BigDecimal.normalize(integer_normal)
    assert_string_representation(normalized_integer, "1000", "Integer normalization")

Note: ===== MATHEMATICAL FUNCTION TESTS =====

Process called "test_abs_and_negate":
    Note: Test absolute value and negation
    Let positive be BigDecimal.create_from_string("123.45", create_default_context())
    Let negative be BigDecimal.create_from_string("-123.45", create_default_context())
    
    Let abs_positive be BigDecimal.abs(positive)
    assert_decimal_equals(abs_positive, positive, "Absolute value of positive number")
    
    Let abs_negative be BigDecimal.abs(negative)
    assert_decimal_equals(abs_negative, positive, "Absolute value of negative number")
    
    Let negated_positive be BigDecimal.negate(positive)
    assert_decimal_equals(negated_positive, negative, "Negated positive number")
    
    Let negated_negative be BigDecimal.negate(negative)
    assert_decimal_equals(negated_negative, positive, "Negated negative number")
    
    Let zero be BigDecimal.create_zero(2)
    Let negated_zero be BigDecimal.negate(zero)
    UnitTest.assert(BigDecimal.is_zero(negated_zero), "Negated zero should be zero")

Process called "test_power":
    Note: Test integer exponentiation
    Let base be BigDecimal.create_from_string("2.5", create_default_context())
    Let context be create_default_context()
    
    Let power_zero be BigDecimal.power(base, 0, context)
    assert_decimal_equals(power_zero, BigDecimal.create_one(0), "Any number to power 0 is 1")
    
    Let power_one be BigDecimal.power(base, 1, context)
    assert_decimal_equals(power_one, base, "Any number to power 1 is itself")
    
    Let power_two be BigDecimal.power(base, 2, context)
    assert_decimal_equals(power_two, BigDecimal.create_from_string("6.25", context), "2.5 squared")
    
    Let power_three be BigDecimal.power(base, 3, context)
    assert_decimal_equals(power_three, BigDecimal.create_from_string("15.625", context), "2.5 cubed")
    
    Let power_negative be BigDecimal.power(base, -2, context)
    assert_decimal_equals(power_negative, BigDecimal.create_from_string("0.16", context), "2.5 to power -2")

Process called "test_square_root":
    Note: Test square root calculation
    Let context be create_default_context()
    
    Let perfect_square be BigDecimal.create_from_string("25.0", context)
    Let sqrt_perfect be BigDecimal.square_root(perfect_square, context)
    assert_decimal_equals(sqrt_perfect, BigDecimal.create_from_string("5.0", context), "Square root of perfect square")
    
    Let two be BigDecimal.create_from_string("2.0", context)
    Let sqrt_two be BigDecimal.square_root(two, context)
    Let sqrt_two_squared be BigDecimal.multiply(sqrt_two, sqrt_two, context)
    Let difference be BigDecimal.abs(BigDecimal.subtract(sqrt_two_squared, two, context))
    Let tolerance be BigDecimal.create_from_string("0.0000000001", context)
    UnitTest.assert(BigDecimal.compare(difference, tolerance) <= 0, "Square root precision check")
    
    Let zero_sqrt be BigDecimal.square_root(BigDecimal.create_zero(2), context)
    UnitTest.assert(BigDecimal.is_zero(zero_sqrt), "Square root of zero should be zero")

Process called "test_natural_log":
    Note: Test natural logarithm calculation
    Let context be create_default_context()
    
    Let one be BigDecimal.create_one(0)
    Let ln_one be BigDecimal.natural_log(one, context)
    UnitTest.assert(BigDecimal.is_zero(ln_one), "Natural log of 1 should be 0")
    
    Let e_approx be BigDecimal.create_from_string("2.718281828459045", context)
    Let ln_e be BigDecimal.natural_log(e_approx, context)
    let one_approx be BigDecimal.create_from_string("1.0", context)
    Let difference be BigDecimal.abs(BigDecimal.subtract(ln_e, one_approx, context))
    Let tolerance be BigDecimal.create_from_string("0.000001", context)
    UnitTest.assert(BigDecimal.compare(difference, tolerance) <= 0, "Natural log of e should be approximately 1")

Process called "test_exponential":
    Note: Test exponential function e^x
    Let context be create_default_context()
    
    Let zero be BigDecimal.create_zero(0)
    Let exp_zero be BigDecimal.exponential(zero, context)
    assert_decimal_equals(exp_zero, BigDecimal.create_one(0), "e^0 should be 1")
    
    Let one be BigDecimal.create_one(0)
    Let exp_one be BigDecimal.exponential(one, context)
    Let e_expected be BigDecimal.create_from_string("2.718281828459045", context)
    Let difference be BigDecimal.abs(BigDecimal.subtract(exp_one, e_expected, context))
    Let tolerance be BigDecimal.create_from_string("0.000001", context)
    UnitTest.assert(BigDecimal.compare(difference, tolerance) <= 0, "e^1 should be approximately e")

Note: ===== FINANCIAL CALCULATION TESTS =====

Process called "test_compound_interest":
    Note: Test compound interest calculations
    Let financial_context be create_financial_context()
    
    Let principal be BigDecimal.create_from_string("1000.00", create_default_context())
    Let rate be BigDecimal.create_from_string("0.05", create_default_context())  Note: 5%
    Let periods be 10
    
    Let future_value be BigDecimal.compound_interest(principal, rate, periods, financial_context)
    Let expected be BigDecimal.create_from_string("1628.89", create_default_context())  Note: 1000 * (1.05)^10
    Let difference be BigDecimal.abs(BigDecimal.subtract(future_value, expected, create_default_context()))
    Let tolerance be BigDecimal.create_from_string("0.01", create_default_context())
    UnitTest.assert(BigDecimal.compare(difference, tolerance) <= 0, "Compound interest calculation")
    
    Let zero_periods be BigDecimal.compound_interest(principal, rate, 0, financial_context)
    assert_decimal_equals(zero_periods, principal, "Zero periods should return principal")

Process called "test_present_value":
    Note: Test present value calculations
    Let financial_context be create_financial_context()
    
    Let future_value be BigDecimal.create_from_string("1628.89", create_default_context())
    Let rate be BigDecimal.create_from_string("0.05", create_default_context())
    Let periods be 10
    
    Let present_value be BigDecimal.present_value(future_value, rate, periods, financial_context)
    Let expected be BigDecimal.create_from_string("1000.00", create_default_context())
    Let difference be BigDecimal.abs(BigDecimal.subtract(present_value, expected, create_default_context()))
    Let tolerance be BigDecimal.create_from_string("0.01", create_default_context())
    UnitTest.assert(BigDecimal.compare(difference, tolerance) <= 0, "Present value calculation")

Process called "test_annuity_payment":
    Note: Test annuity payment calculations
    Let financial_context be create_financial_context()
    
    Let principal be BigDecimal.create_from_string("100000.00", create_default_context())
    Let rate be BigDecimal.create_from_string("0.06", create_default_context())  Note: 6% annual
    Let periods be 30  Note: 30 year mortgage
    
    Let payment be BigDecimal.annuity_payment(principal, rate, periods, financial_context)
    Let expected be BigDecimal.create_from_string("7264.49", create_default_context())  Note: Approximate monthly payment
    Let difference be BigDecimal.abs(BigDecimal.subtract(payment, expected, create_default_context()))
    Let tolerance be BigDecimal.create_from_string("1.00", create_default_context())
    UnitTest.assert(BigDecimal.compare(difference, tolerance) <= 0, "Annuity payment calculation")
    
    Let zero_rate_payment be BigDecimal.annuity_payment(principal, BigDecimal.create_zero(4), periods, financial_context)
    Let expected_zero_rate be BigDecimal.divide(principal, BigDecimal.create_from_integer(periods, 0), create_default_context())
    assert_decimal_equals(zero_rate_payment, expected_zero_rate, "Zero interest rate payment")

Process called "test_effective_rate":
    Note: Test effective annual rate calculations
    Let financial_context be create_financial_context()
    
    Let nominal_rate be BigDecimal.create_from_string("0.12", create_default_context())  Note: 12% nominal
    Let compounding_periods be 12  Note: Monthly compounding
    
    Let effective_rate be BigDecimal.effective_rate(nominal_rate, compounding_periods, financial_context)
    Let expected be BigDecimal.create_from_string("0.1268", create_default_context())  Note: Approximately 12.68%
    Let difference be BigDecimal.abs(BigDecimal.subtract(effective_rate, expected, create_default_context()))
    Let tolerance be BigDecimal.create_from_string("0.001", create_default_context())
    UnitTest.assert(BigDecimal.compare(difference, tolerance) <= 0, "Effective annual rate calculation")

Note: ===== COMPARISON TESTS =====

Process called "test_compare":
    Note: Test BigDecimal comparison operations
    Let a be BigDecimal.create_from_string("123.45", create_default_context())
    Let b be BigDecimal.create_from_string("123.46", create_default_context())
    Let c be BigDecimal.create_from_string("123.45", create_default_context())
    
    assert_comparison_result(BigDecimal.compare(a, b), -1, "a < b comparison")
    assert_comparison_result(BigDecimal.compare(b, a), 1, "b > a comparison")
    assert_comparison_result(BigDecimal.compare(a, c), 0, "a == c comparison")
    
    Let different_scale_equal be BigDecimal.create_from_string("123.450", create_default_context())
    assert_comparison_result(BigDecimal.compare(a, different_scale_equal), 0, "Different scale but equal value")

Process called "test_equals":
    Note: Test exact equality and value equality
    Let a be BigDecimal.create_from_string("123.45", create_default_context())
    Let b be BigDecimal.create_from_string("123.45", create_default_context())
    Let c be BigDecimal.create_from_string("123.450", create_default_context())
    
    UnitTest.assert(BigDecimal.equals(a, b), "Exact equality with same scale")
    UnitTest.assert(not BigDecimal.equals(a, c), "Exact equality fails with different scale")
    
    UnitTest.assert(BigDecimal.equals_ignoring_scale(a, c), "Value equality ignoring scale")
    UnitTest.assert(BigDecimal.equals_ignoring_scale(a, b), "Value equality with same scale")

Process called "test_max_min":
    Note: Test maximum and minimum operations
    Let a be BigDecimal.create_from_string("123.45", create_default_context())
    Let b be BigDecimal.create_from_string("67.89", create_default_context())
    
    Let max_result be BigDecimal.max(a, b)
    assert_decimal_equals(max_result, a, "Maximum of two values")
    
    Let min_result be BigDecimal.min(a, b)
    assert_decimal_equals(min_result, b, "Minimum of two values")
    
    Let equal_max be BigDecimal.max(a, a)
    assert_decimal_equals(equal_max, a, "Maximum of equal values")

Note: ===== CONVERSION TESTS =====

Process called "test_to_string_formatting":
    Note: Test string conversion with formatting options
    let value be BigDecimal.create_from_string("1234.567", create_default_context())
    
    let plain_string be BigDecimal.to_plain_string(value)
    UnitTest.assert(plain_string equals "1234.567", "Plain string conversion")
    
    let format_options be create_format_options()
    Set format_options.use_scientific_notation to true
    let scientific_string be BigDecimal.to_string(value, format_options)
    UnitTest.assert(scientific_string.contains("E"), "Scientific notation contains E")
    
    Set format_options.use_scientific_notation to false
    Set format_options.minimum_fraction_digits to 5
    let min_fraction_string be BigDecimal.to_string(value, format_options)
    UnitTest.assert(min_fraction_string equals "1,234.56700", "Minimum fraction digits formatting")
    
    let engineering_string be BigDecimal.to_engineering_string(value)
    UnitTest.assert(engineering_string.contains("E"), "Engineering notation contains E")

Process called "test_to_double":
    Note: Test conversion to double (with precision loss)
    let value be BigDecimal.create_from_string("123.456", create_default_context())
    let double_result be BigDecimal.to_double(value)
    UnitTest.assert(double_result > 123.0 and double_result < 124.0, "Double conversion in correct range")
    
    let zero be BigDecimal.create_zero(0)
    let zero_double be BigDecimal.to_double(zero)
    UnitTest.assert(zero_double equals 0.0, "Zero converts to 0.0")

Process called "test_to_integer":
    Note: Test conversion to integer with rounding
    let value be BigDecimal.create_from_string("123.456", create_default_context())
    
    let rounded_down be BigDecimal.to_integer(value, BigDecimal.RoundingMode.DOWN)
    UnitTest.assert(rounded_down equals 123, "Integer conversion with DOWN rounding")
    
    let rounded_up be BigDecimal.to_integer(value, BigDecimal.RoundingMode.UP)
    UnitTest.assert(rounded_up equals 124, "Integer conversion with UP rounding")
    
    let integer_value be BigDecimal.create_from_string("42.0", create_default_context())
    let exact_integer be BigDecimal.to_integer(integer_value, BigDecimal.RoundingMode.UNNECESSARY)
    UnitTest.assert(exact_integer equals 42, "Exact integer conversion")

Process called "test_to_fraction":
    Note: Test conversion to fraction representation
    let decimal be BigDecimal.create_from_string("0.25", create_default_context())
    let fraction be BigDecimal.to_fraction(decimal)
    
    let numerator be fraction[0]
    let denominator be fraction[1]
    
    UnitTest.assert(BigInteger.equals(numerator, BigInteger.create_from_integer(1)), "Fraction numerator for 0.25")
    UnitTest.assert(BigInteger.equals(denominator, BigInteger.create_from_integer(4)), "Fraction denominator for 0.25")
    
    let zero be BigDecimal.create_zero(2)
    let zero_fraction be BigDecimal.to_fraction(zero)
    UnitTest.assert(BigInteger.is_zero(zero_fraction[0]), "Zero fraction numerator")
    UnitTest.assert(BigInteger.equals(zero_fraction[1], BigInteger.create_from_integer(1)), "Zero fraction denominator")

Note: ===== UTILITY FUNCTION TESTS =====

Process called "test_utility_functions":
    Note: Test utility getter functions
    let value be BigDecimal.create_from_string("123.456", create_default_context())
    
    UnitTest.assert(BigDecimal.get_precision(value) equals 6, "Precision getter")
    UnitTest.assert(BigDecimal.get_scale(value) equals 3, "Scale getter")
    
    let unscaled be BigDecimal.get_unscaled_value(value)
    UnitTest.assert(BigInteger.equals(unscaled, BigInteger.create_from_integer(123456)), "Unscaled value getter")
    
    UnitTest.assert(BigDecimal.is_positive(value), "Positive value test")
    UnitTest.assert(not BigDecimal.is_negative(value), "Negative value test")
    
    let zero be BigDecimal.create_zero(0)
    UnitTest.assert(BigDecimal.is_zero(zero), "Zero value test")
    UnitTest.assert(not BigDecimal.is_positive(zero), "Zero not positive")
    UnitTest.assert(not BigDecimal.is_negative(zero), "Zero not negative")

Process called "test_sign_function":
    Note: Test sign function
    let positive be BigDecimal.create_from_string("123.456", create_default_context())
    UnitTest.assert(BigDecimal.sign(positive) equals 1, "Positive sign")
    
    let negative be BigDecimal.create_from_string("-123.456", create_default_context())
    UnitTest.assert(BigDecimal.sign(negative) equals -1, "Negative sign")
    
    let zero be BigDecimal.create_zero(0)
    UnitTest.assert(BigDecimal.sign(zero) equals 0, "Zero sign")

Process called "test_default_precision":
    Note: Test default precision setting
    let original_success be BigDecimal.set_default_precision(50)
    UnitTest.assert(original_success, "Setting valid default precision")
    
    let invalid_success be BigDecimal.set_default_precision(-5)
    UnitTest.assert(not invalid_success, "Setting invalid default precision should fail")
    
    Note: Restore original precision
    BigDecimal.set_default_precision(34)

Note: ===== MATHEMATICAL CONSTANT TESTS =====

Process called "test_mathematical_constants":
    Note: Test computation of mathematical constants
    let pi_value be BigDecimal.pi(10)
    let pi_string be BigDecimal.to_plain_string(pi_value)
    UnitTest.assert(pi_string.startsWith("3.14159"), "Pi computation starts correctly")
    
    let e_value be BigDecimal.e(10)
    let e_string be BigDecimal.to_plain_string(e_value)
    UnitTest.assert(e_string.startsWith("2.71828"), "e computation starts correctly")
    
    let golden_ratio_value be BigDecimal.golden_ratio(10)
    let golden_string be BigDecimal.to_plain_string(golden_ratio_value)
    UnitTest.assert(golden_string.startsWith("1.61803"), "Golden ratio computation starts correctly")

Note: ===== HIGH PRECISION STRING OPERATIONS TESTS =====

Process called "test_high_precision_string_operations":
    Note: Test high-precision string-based operations
    let a_str be "123.456789012345678901234567890"
    let b_str be "987.654321098765432109876543210"
    let precision be 50
    
    let sum_str be BigDecimal.add_high_precision(a_str, b_str, precision)
    UnitTest.assert(sum_str.startsWith("1111.111"), "High precision addition")
    
    let diff_str be BigDecimal.subtract_high_precision(b_str, a_str, precision)
    UnitTest.assert(diff_str.startsWith("864.197"), "High precision subtraction")
    
    let product_str be BigDecimal.multiply_high_precision(a_str, "2.0", precision)
    UnitTest.assert(product_str.startsWith("246.913"), "High precision multiplication")
    
    let comparison be BigDecimal.compare_high_precision(a_str, b_str)
    UnitTest.assert(comparison equals -1, "High precision comparison")

Note: ===== ERROR HANDLING TESTS =====

Process called "test_error_handling":
    Note: Test error conditions and edge cases
    let context be create_default_context()
    
    Note: Division by zero should throw error
    let zero be BigDecimal.create_zero(0)
    let one be BigDecimal.create_one(0)
    
    Note: Test invalid string parsing
    Note: These would throw errors in real implementation
    
    Note: Test invalid scale operations
    Note: Negative scale in creation should throw error
    
    Note: Test precision limits and overflow conditions
    Note: Very large numbers should be handled appropriately

Note: ===== TEST RUNNER =====

Process called "run_all_tests":
    Note: Executes all BigDecimal unit tests
    UnitTest.start_test_suite("BigDecimal Module Tests")
    
    Note: Construction tests
    UnitTest.run_test("Create from Integer", test_create_from_integer)
    UnitTest.run_test("Create from String", test_create_from_string)
    UnitTest.run_test("Create from Double", test_create_from_double)
    UnitTest.run_test("Create from Fraction", test_create_from_fraction)
    UnitTest.run_test("Create Zero and One", test_create_zero_and_one)
    
    Note: Arithmetic operation tests
    UnitTest.run_test("Addition", test_addition)
    UnitTest.run_test("Subtraction", test_subtraction)
    UnitTest.run_test("Multiplication", test_multiplication)
    UnitTest.run_test("Division", test_division)
    UnitTest.run_test("Remainder", test_remainder)
    UnitTest.run_test("Divide to Integral Value", test_divide_to_integral_value)
    
    Note: Precision and scale tests
    UnitTest.run_test("Round", test_round)
    UnitTest.run_test("Set Scale", test_set_scale)
    UnitTest.run_test("Strip Trailing Zeros", test_strip_trailing_zeros)
    UnitTest.run_test("With Precision", test_with_precision)
    UnitTest.run_test("Normalize", test_normalize)
    
    Note: Mathematical function tests
    UnitTest.run_test("Absolute Value and Negate", test_abs_and_negate)
    UnitTest.run_test("Power", test_power)
    UnitTest.run_test("Square Root", test_square_root)
    UnitTest.run_test("Natural Logarithm", test_natural_log)
    UnitTest.run_test("Exponential", test_exponential)
    
    Note: Financial calculation tests
    UnitTest.run_test("Compound Interest", test_compound_interest)
    UnitTest.run_test("Present Value", test_present_value)
    UnitTest.run_test("Annuity Payment", test_annuity_payment)
    UnitTest.run_test("Effective Rate", test_effective_rate)
    
    Note: Comparison tests
    UnitTest.run_test("Compare", test_compare)
    UnitTest.run_test("Equals", test_equals)
    UnitTest.run_test("Max Min", test_max_min)
    
    Note: Conversion tests
    UnitTest.run_test("String Formatting", test_to_string_formatting)
    UnitTest.run_test("To Double", test_to_double)
    UnitTest.run_test("To Integer", test_to_integer)
    UnitTest.run_test("To Fraction", test_to_fraction)
    
    Note: Utility function tests
    UnitTest.run_test("Utility Functions", test_utility_functions)
    UnitTest.run_test("Sign Function", test_sign_function)
    UnitTest.run_test("Default Precision", test_default_precision)
    
    Note: Mathematical constant tests
    UnitTest.run_test("Mathematical Constants", test_mathematical_constants)
    
    Note: High precision operations tests
    UnitTest.run_test("High Precision String Operations", test_high_precision_string_operations)
    
    Note: Error handling tests
    UnitTest.run_test("Error Handling", test_error_handling)
    
    UnitTest.end_test_suite()