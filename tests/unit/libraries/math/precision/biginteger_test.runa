Note:
tests/unit/libraries/math/precision/biginteger_test.runa
Unit Tests for Math Precision BigInteger Module

This test suite provides comprehensive testing for the math precision BigInteger module including:
- Arbitrary precision integer representation and storage
- Basic arithmetic operations (add, subtract, multiply, divide)
- Efficient algorithms (Karatsuba multiplication, Barrett reduction)
- Modular arithmetic operations for cryptographic applications
- Prime testing algorithms (Miller-Rabin, Lucas-Lehmer)
- Integer factorization methods (Pollard's rho, quadratic sieve)
- GCD/LCM calculations using extended Euclidean algorithm
- Bitwise operations on arbitrarily large integers
- Base conversion and string representation functions
- Construction, comparison, and utility operations
:End Note

Import "stdlib/math/precision/biginteger" as BigInteger
Import "dev/debug/test_framework/assertions" as Assert
Import "dev/debug/test_framework/test_runner" as TestRunner
Import "dev/debug/test_framework/data_generators" as DataGen

Note: =====================================================================
Note: HELPER FUNCTIONS AND TEST UTILITIES
Note: =====================================================================

Process called "assert_biginteger_equal" that takes a as BigInteger, b as BigInteger returns Boolean:
    Note: Assert that two BigIntegers are equal
    Assert.IsTrue(BigInteger.equals(a, b))
    Return True

Process called "assert_biginteger_from_string" that takes value_str as String, expected as BigInteger returns Boolean:
    Note: Assert BigInteger from string matches expected
    Let result be BigInteger.create_from_string(value_str, 10)
    Assert.IsTrue(BigInteger.equals(result, expected))
    Return True

Process called "create_test_bigint" that takes value as Integer returns BigInteger:
    Note: Create BigInteger from regular integer for testing
    Return BigInteger.create_from_integer(value)

Process called "generate_large_integers" that takes no parameters returns List[BigInteger]:
    Note: Generate various large integers for testing
    Let large_ints be List[BigInteger]()
    Let factors be [2, 3, 5, 7, 11, 13, 17, 19, 23]
    
    For factor in factors:
        Let large_value be BigInteger.create_from_integer(1)
        For i from 1 to 50:
            Set large_value to BigInteger.multiply(large_value, BigInteger.create_from_integer(factor))
        Append large_value to large_ints
    
    Return large_ints

Process called "is_correct_string_representation" that takes big_int as BigInteger, expected_str as String returns Boolean:
    Note: Check if string representation is correct
    Let actual_str be BigInteger.to_string(big_int, 10)
    Return actual_str equals expected_str

Note: =====================================================================
Note: CONSTRUCTION AND INITIALIZATION TESTS
Note: =====================================================================

Process called "test_create_from_integer_positive" that takes no parameters returns Boolean:
    Note: Test creation from positive integers
    Let zero_int be BigInteger.create_from_integer(0)
    Assert.IsTrue(BigInteger.is_zero(zero_int))
    
    Let one_int be BigInteger.create_from_integer(1)
    Assert.IsTrue(BigInteger.equals(one_int, BigInteger.one()))
    
    Let large_int be BigInteger.create_from_integer(2147483647)
    Let expected_str be "2147483647"
    Assert.IsTrue(is_correct_string_representation(large_int, expected_str))
    Return True

Process called "test_create_from_integer_negative" that takes no parameters returns Boolean:
    Note: Test creation from negative integers
    Let neg_one be BigInteger.create_from_integer(-1)
    Assert.IsTrue(BigInteger.is_negative(neg_one))
    Assert.IsTrue(is_correct_string_representation(neg_one, "-1"))
    
    Let neg_large be BigInteger.create_from_integer(-2147483648)
    Assert.IsTrue(BigInteger.is_negative(neg_large))
    Assert.IsTrue(is_correct_string_representation(neg_large, "-2147483648"))
    Return True

Process called "test_create_from_string_decimal" that takes no parameters returns Boolean:
    Note: Test creation from decimal string representations
    Let zero_str be BigInteger.create_from_string("0", 10)
    Assert.IsTrue(BigInteger.is_zero(zero_str))
    
    Let pos_str be BigInteger.create_from_string("123456789", 10)
    Assert.IsTrue(is_correct_string_representation(pos_str, "123456789"))
    
    Let neg_str be BigInteger.create_from_string("-987654321", 10)
    Assert.IsTrue(is_correct_string_representation(neg_str, "-987654321"))
    
    Let very_large_str be BigInteger.create_from_string("12345678901234567890123456789", 10)
    Assert.IsTrue(is_correct_string_representation(very_large_str, "12345678901234567890123456789"))
    Return True

Process called "test_create_from_string_hexadecimal" that takes no parameters returns Boolean:
    Note: Test creation from hexadecimal string representations
    Let hex_255 be BigInteger.create_from_string("FF", 16)
    Let decimal_255 be BigInteger.create_from_integer(255)
    Assert.IsTrue(BigInteger.equals(hex_255, decimal_255))
    
    Let hex_large be BigInteger.create_from_string("DEADBEEF", 16)
    Assert.IsTrue(is_correct_string_representation(hex_large, "3735928559"))
    
    Let hex_negative be BigInteger.create_from_string("-ABCD", 16)
    Assert.IsTrue(BigInteger.is_negative(hex_negative))
    Return True

Process called "test_create_from_string_binary" that takes no parameters returns Boolean:
    Note: Test creation from binary string representations
    Let bin_8 be BigInteger.create_from_string("1000", 2)
    Let decimal_8 be BigInteger.create_from_integer(8)
    Assert.IsTrue(BigInteger.equals(bin_8, decimal_8))
    
    Let bin_255 be BigInteger.create_from_string("11111111", 2)
    Let decimal_255 be BigInteger.create_from_integer(255)
    Assert.IsTrue(BigInteger.equals(bin_255, decimal_255))
    
    Let bin_large be BigInteger.create_from_string("1010101010101010101010101", 2)
    Assert.IsTrue(is_correct_string_representation(bin_large, "22369621"))
    Return True

Process called "test_create_from_invalid_string" that takes no parameters returns Boolean:
    Note: Test error handling for invalid string inputs
    Try:
        Let invalid be BigInteger.create_from_string("", 10)
        Return False
    Catch error:
        Pass
    
    Try:
        Let invalid_chars be BigInteger.create_from_string("123XYZ", 10)
        Return False
    Catch error:
        Pass
    
    Try:
        Let invalid_base be BigInteger.create_from_string("123", 1)
        Return False
    Catch error:
        Pass
    
    Return True

Note: =====================================================================
Note: BASIC ARITHMETIC OPERATIONS TESTS
Note: =====================================================================

Process called "test_addition_positive_numbers" that takes no parameters returns Boolean:
    Note: Test addition of positive BigIntegers
    Let a be BigInteger.create_from_integer(123)
    Let b be BigInteger.create_from_integer(456)
    Let result be BigInteger.add(a, b)
    Let expected be BigInteger.create_from_integer(579)
    Assert.IsTrue(BigInteger.equals(result, expected))
    
    Let large_a be BigInteger.create_from_string("999999999999999999999", 10)
    Let large_b be BigInteger.create_from_string("1", 10)
    Let large_result be BigInteger.add(large_a, large_b)
    Assert.IsTrue(is_correct_string_representation(large_result, "1000000000000000000000"))
    Return True

Process called "test_addition_with_negative_numbers" that takes no parameters returns Boolean:
    Note: Test addition involving negative numbers
    Let pos be BigInteger.create_from_integer(100)
    Let neg be BigInteger.create_from_integer(-50)
    Let result be BigInteger.add(pos, neg)
    Let expected be BigInteger.create_from_integer(50)
    Assert.IsTrue(BigInteger.equals(result, expected))
    
    Let neg_a be BigInteger.create_from_integer(-100)
    Let neg_b be BigInteger.create_from_integer(-200)
    Let neg_result be BigInteger.add(neg_a, neg_b)
    Let neg_expected be BigInteger.create_from_integer(-300)
    Assert.IsTrue(BigInteger.equals(neg_result, neg_expected))
    Return True

Process called "test_addition_identity" that takes no parameters returns Boolean:
    Note: Test addition identity (x + 0 = x)
    Let value be BigInteger.create_from_integer(12345)
    Let zero be BigInteger.zero()
    Let result be BigInteger.add(value, zero)
    Assert.IsTrue(BigInteger.equals(result, value))
    
    Let result2 be BigInteger.add(zero, value)
    Assert.IsTrue(BigInteger.equals(result2, value))
    Return True

Process called "test_subtraction_basic" that takes no parameters returns Boolean:
    Note: Test basic subtraction operations
    Let a be BigInteger.create_from_integer(1000)
    Let b be BigInteger.create_from_integer(300)
    Let result be BigInteger.subtract(a, b)
    Let expected be BigInteger.create_from_integer(700)
    Assert.IsTrue(BigInteger.equals(result, expected))
    
    Let large_a be BigInteger.create_from_string("1000000000000000000000", 10)
    Let large_b be BigInteger.create_from_string("1", 10)
    Let large_result be BigInteger.subtract(large_a, large_b)
    Assert.IsTrue(is_correct_string_representation(large_result, "999999999999999999999"))
    Return True

Process called "test_subtraction_negative_result" that takes no parameters returns Boolean:
    Note: Test subtraction resulting in negative numbers
    Let a be BigInteger.create_from_integer(300)
    Let b be BigInteger.create_from_integer(1000)
    Let result be BigInteger.subtract(a, b)
    Let expected be BigInteger.create_from_integer(-700)
    Assert.IsTrue(BigInteger.equals(result, expected))
    Assert.IsTrue(BigInteger.is_negative(result))
    Return True

Process called "test_multiplication_basic" that takes no parameters returns Boolean:
    Note: Test basic multiplication operations
    Let a be BigInteger.create_from_integer(123)
    Let b be BigInteger.create_from_integer(456)
    Let result be BigInteger.multiply(a, b)
    Let expected be BigInteger.create_from_integer(56088)
    Assert.IsTrue(BigInteger.equals(result, expected))
    
    Let large_a be BigInteger.create_from_string("999999999", 10)
    Let large_b be BigInteger.create_from_string("999999999", 10)
    Let large_result be BigInteger.multiply(large_a, large_b)
    Assert.IsTrue(is_correct_string_representation(large_result, "999999998000000001"))
    Return True

Process called "test_multiplication_by_zero" that takes no parameters returns Boolean:
    Note: Test multiplication by zero
    Let value be BigInteger.create_from_integer(12345)
    Let zero be BigInteger.zero()
    Let result be BigInteger.multiply(value, zero)
    Assert.IsTrue(BigInteger.is_zero(result))
    
    Let result2 be BigInteger.multiply(zero, value)
    Assert.IsTrue(BigInteger.is_zero(result2))
    Return True

Process called "test_multiplication_by_one" that takes no parameters returns Boolean:
    Note: Test multiplication identity (x * 1 = x)
    Let value be BigInteger.create_from_integer(12345)
    Let one be BigInteger.one()
    Let result be BigInteger.multiply(value, one)
    Assert.IsTrue(BigInteger.equals(result, value))
    
    Let result2 be BigInteger.multiply(one, value)
    Assert.IsTrue(BigInteger.equals(result2, value))
    Return True

Process called "test_multiplication_negative_numbers" that takes no parameters returns Boolean:
    Note: Test multiplication with negative numbers
    Let pos be BigInteger.create_from_integer(100)
    Let neg be BigInteger.create_from_integer(-50)
    Let result1 be BigInteger.multiply(pos, neg)
    Let expected1 be BigInteger.create_from_integer(-5000)
    Assert.IsTrue(BigInteger.equals(result1, expected1))
    
    Let neg_a be BigInteger.create_from_integer(-100)
    Let neg_b be BigInteger.create_from_integer(-200)
    Let result2 be BigInteger.multiply(neg_a, neg_b)
    Let expected2 be BigInteger.create_from_integer(20000)
    Assert.IsTrue(BigInteger.equals(result2, expected2))
    Return True

Process called "test_division_basic" that takes no parameters returns Boolean:
    Note: Test basic division operations
    Let dividend be BigInteger.create_from_integer(1000)
    Let divisor be BigInteger.create_from_integer(10)
    Let quotient be BigInteger.divide(dividend, divisor)
    Let expected be BigInteger.create_from_integer(100)
    Assert.IsTrue(BigInteger.equals(quotient, expected))
    
    Let large_dividend be BigInteger.create_from_string("123456789000", 10)
    Let large_divisor be BigInteger.create_from_string("1000", 10)
    Let large_quotient be BigInteger.divide(large_dividend, large_divisor)
    Assert.IsTrue(is_correct_string_representation(large_quotient, "123456789"))
    Return True

Process called "test_division_by_one" that takes no parameters returns Boolean:
    Note: Test division identity (x / 1 = x)
    Let value be BigInteger.create_from_integer(12345)
    Let one be BigInteger.one()
    Let result be BigInteger.divide(value, one)
    Assert.IsTrue(BigInteger.equals(result, value))
    Return True

Process called "test_division_by_zero_error" that takes no parameters returns Boolean:
    Note: Test division by zero error handling
    Let value be BigInteger.create_from_integer(12345)
    Let zero be BigInteger.zero()
    Try:
        Let result be BigInteger.divide(value, zero)
        Return False
    Catch error:
        Return True

Process called "test_modulo_operations" that takes no parameters returns Boolean:
    Note: Test modulo operations
    Let dividend be BigInteger.create_from_integer(17)
    Let divisor be BigInteger.create_from_integer(5)
    Let remainder be BigInteger.modulo(dividend, divisor)
    Let expected_remainder be BigInteger.create_from_integer(2)
    Assert.IsTrue(BigInteger.equals(remainder, expected_remainder))
    
    Let quotient be BigInteger.divide(dividend, divisor)
    Let expected_quotient be BigInteger.create_from_integer(3)
    Assert.IsTrue(BigInteger.equals(quotient, expected_quotient))
    Return True

Note: =====================================================================
Note: COMPARISON OPERATIONS TESTS
Note: =====================================================================

Process called "test_equality_comparison" that takes no parameters returns Boolean:
    Note: Test equality comparisons
    Let a be BigInteger.create_from_integer(12345)
    Let b be BigInteger.create_from_integer(12345)
    Let c be BigInteger.create_from_integer(54321)
    
    Assert.IsTrue(BigInteger.equals(a, b))
    Assert.IsFalse(BigInteger.equals(a, c))
    
    Let zero_a be BigInteger.zero()
    Let zero_b be BigInteger.create_from_integer(0)
    Assert.IsTrue(BigInteger.equals(zero_a, zero_b))
    Return True

Process called "test_less_than_comparison" that takes no parameters returns Boolean:
    Note: Test less than comparisons
    Let small be BigInteger.create_from_integer(100)
    Let large be BigInteger.create_from_integer(200)
    
    Assert.IsTrue(BigInteger.less_than(small, large))
    Assert.IsFalse(BigInteger.less_than(large, small))
    Assert.IsFalse(BigInteger.less_than(small, small))
    
    Let negative be BigInteger.create_from_integer(-50)
    Assert.IsTrue(BigInteger.less_than(negative, small))
    Return True

Process called "test_greater_than_comparison" that takes no parameters returns Boolean:
    Note: Test greater than comparisons
    Let small be BigInteger.create_from_integer(100)
    Let large be BigInteger.create_from_integer(200)
    
    Assert.IsTrue(BigInteger.greater_than(large, small))
    Assert.IsFalse(BigInteger.greater_than(small, large))
    Assert.IsFalse(BigInteger.greater_than(small, small))
    
    Let positive be BigInteger.create_from_integer(50)
    Let negative be BigInteger.create_from_integer(-50)
    Assert.IsTrue(BigInteger.greater_than(positive, negative))
    Return True

Process called "test_comparison_large_numbers" that takes no parameters returns Boolean:
    Note: Test comparisons with very large numbers
    Let large_a be BigInteger.create_from_string("999999999999999999999", 10)
    Let large_b be BigInteger.create_from_string("1000000000000000000000", 10)
    
    Assert.IsTrue(BigInteger.less_than(large_a, large_b))
    Assert.IsTrue(BigInteger.greater_than(large_b, large_a))
    Assert.IsFalse(BigInteger.equals(large_a, large_b))
    Return True

Note: =====================================================================
Note: GCD AND LCM OPERATIONS TESTS
Note: =====================================================================

Process called "test_gcd_basic" that takes no parameters returns Boolean:
    Note: Test greatest common divisor calculations
    Let a be BigInteger.create_from_integer(48)
    Let b be BigInteger.create_from_integer(18)
    Let gcd_result be BigInteger.gcd(a, b)
    Let expected be BigInteger.create_from_integer(6)
    Assert.IsTrue(BigInteger.equals(gcd_result, expected))
    
    Let coprime_a be BigInteger.create_from_integer(17)
    Let coprime_b be BigInteger.create_from_integer(13)
    Let coprime_gcd be BigInteger.gcd(coprime_a, coprime_b)
    Assert.IsTrue(BigInteger.equals(coprime_gcd, BigInteger.one()))
    Return True

Process called "test_gcd_large_numbers" that takes no parameters returns Boolean:
    Note: Test GCD with large numbers
    Let large_a be BigInteger.create_from_string("123456789012345678901234567890", 10)
    Let large_b be BigInteger.create_from_string("987654321098765432109876543210", 10)
    Let gcd_result be BigInteger.gcd(large_a, large_b)
    Assert.IsFalse(BigInteger.is_zero(gcd_result))
    Assert.IsTrue(BigInteger.greater_than(gcd_result, BigInteger.zero()))
    Return True

Process called "test_gcd_with_zero" that takes no parameters returns Boolean:
    Note: Test GCD with zero (gcd(a, 0) = |a|)
    Let value be BigInteger.create_from_integer(42)
    Let zero be BigInteger.zero()
    Let gcd_result be BigInteger.gcd(value, zero)
    Let abs_value be BigInteger.abs(value)
    Assert.IsTrue(BigInteger.equals(gcd_result, abs_value))
    
    Let negative_value be BigInteger.create_from_integer(-42)
    Let gcd_neg_result be BigInteger.gcd(negative_value, zero)
    Assert.IsTrue(BigInteger.equals(gcd_neg_result, abs_value))
    Return True

Process called "test_extended_gcd" that takes no parameters returns Boolean:
    Note: Test extended Euclidean algorithm
    Let a be BigInteger.create_from_integer(30)
    Let b be BigInteger.create_from_integer(18)
    Let extended_result be BigInteger.extended_gcd(a, b)
    
    Assert.IsTrue(BigInteger.equals(extended_result.gcd, BigInteger.create_from_integer(6)))
    
    Let verification be BigInteger.add(
        BigInteger.multiply(extended_result.x, a),
        BigInteger.multiply(extended_result.y, b)
    )
    Assert.IsTrue(BigInteger.equals(verification, extended_result.gcd))
    Return True

Process called "test_lcm_basic" that takes no parameters returns Boolean:
    Note: Test least common multiple calculations
    Let a be BigInteger.create_from_integer(12)
    Let b be BigInteger.create_from_integer(18)
    Let lcm_result be BigInteger.lcm(a, b)
    Let expected be BigInteger.create_from_integer(36)
    Assert.IsTrue(BigInteger.equals(lcm_result, expected))
    
    Let coprime_a be BigInteger.create_from_integer(7)
    Let coprime_b be BigInteger.create_from_integer(11)
    Let coprime_lcm be BigInteger.lcm(coprime_a, coprime_b)
    Let expected_coprime be BigInteger.create_from_integer(77)
    Assert.IsTrue(BigInteger.equals(coprime_lcm, expected_coprime))
    Return True

Process called "test_gcd_lcm_relationship" that takes no parameters returns Boolean:
    Note: Test relationship gcd(a,b) * lcm(a,b) = |a * b|
    Let a be BigInteger.create_from_integer(24)
    Let b be BigInteger.create_from_integer(36)
    
    Let gcd_val be BigInteger.gcd(a, b)
    Let lcm_val be BigInteger.lcm(a, b)
    Let product_ab be BigInteger.multiply(a, b)
    Let gcd_lcm_product be BigInteger.multiply(gcd_val, lcm_val)
    
    Assert.IsTrue(BigInteger.equals(BigInteger.abs(product_ab), gcd_lcm_product))
    Return True

Note: =====================================================================
Note: MODULAR ARITHMETIC TESTS
Note: =====================================================================

Process called "test_modular_addition" that takes no parameters returns Boolean:
    Note: Test modular addition operations
    Let a be BigInteger.create_from_integer(15)
    Let b be BigInteger.create_from_integer(28)
    Let modulus be BigInteger.create_from_integer(13)
    
    Let result be BigInteger.mod_add(a, b, modulus)
    Let expected be BigInteger.create_from_integer(4)  // (15 + 28) mod 13 = 43 mod 13 = 4
    Assert.IsTrue(BigInteger.equals(result, expected))
    Return True

Process called "test_modular_subtraction" that takes no parameters returns Boolean:
    Note: Test modular subtraction operations
    Let a be BigInteger.create_from_integer(10)
    Let b be BigInteger.create_from_integer(15)
    Let modulus be BigInteger.create_from_integer(13)
    
    Let result be BigInteger.mod_subtract(a, b, modulus)
    Let expected be BigInteger.create_from_integer(8)  // (10 - 15 + 13) mod 13 = 8
    Assert.IsTrue(BigInteger.equals(result, expected))
    Return True

Process called "test_modular_multiplication" that takes no parameters returns Boolean:
    Note: Test modular multiplication operations
    Let a be BigInteger.create_from_integer(7)
    Let b be BigInteger.create_from_integer(9)
    Let modulus be BigInteger.create_from_integer(13)
    
    Let result be BigInteger.mod_multiply(a, b, modulus)
    Let expected be BigInteger.create_from_integer(11)  // (7 * 9) mod 13 = 63 mod 13 = 11
    Assert.IsTrue(BigInteger.equals(result, expected))
    Return True

Process called "test_modular_exponentiation" that takes no parameters returns Boolean:
    Note: Test modular exponentiation using square-and-multiply
    Let base be BigInteger.create_from_integer(3)
    Let exponent be BigInteger.create_from_integer(4)
    Let modulus be BigInteger.create_from_integer(13)
    
    Let result be BigInteger.mod_pow(base, exponent, modulus)
    Let expected be BigInteger.create_from_integer(3)  // 3^4 mod 13 = 81 mod 13 = 3
    Assert.IsTrue(BigInteger.equals(result, expected))
    
    Let large_exp be BigInteger.create_from_integer(100)
    Let large_result be BigInteger.mod_pow(base, large_exp, modulus)
    Assert.IsFalse(BigInteger.is_zero(large_result))
    Assert.IsTrue(BigInteger.less_than(large_result, modulus))
    Return True

Process called "test_modular_inverse" that takes no parameters returns Boolean:
    Note: Test modular multiplicative inverse
    Let a be BigInteger.create_from_integer(7)
    Let modulus be BigInteger.create_from_integer(13)
    
    Let inverse be BigInteger.mod_inverse(a, modulus)
    Let verification be BigInteger.mod_multiply(a, inverse, modulus)
    Assert.IsTrue(BigInteger.equals(verification, BigInteger.one()))
    
    Let gcd_check be BigInteger.gcd(a, modulus)
    Assert.IsTrue(BigInteger.equals(gcd_check, BigInteger.one()))
    Return True

Process called "test_modular_inverse_nonexistent" that takes no parameters returns Boolean:
    Note: Test modular inverse when it doesn't exist
    Let a be BigInteger.create_from_integer(6)
    Let modulus be BigInteger.create_from_integer(12)  // gcd(6,12) = 6 ≠ 1
    
    Try:
        Let inverse be BigInteger.mod_inverse(a, modulus)
        Return False  // Should have thrown exception
    Catch error:
        Return True
    Return False

Note: =====================================================================
Note: BITWISE OPERATIONS TESTS
Note: =====================================================================

Process called "test_bitwise_and" that takes no parameters returns Boolean:
    Note: Test bitwise AND operation
    Let a be BigInteger.create_from_integer(15)  // 1111 in binary
    Let b be BigInteger.create_from_integer(10)  // 1010 in binary
    Let result be BigInteger.bitwise_and(a, b)
    Let expected be BigInteger.create_from_integer(10)  // 1010 in binary
    Assert.IsTrue(BigInteger.equals(result, expected))
    Return True

Process called "test_bitwise_or" that takes no parameters returns Boolean:
    Note: Test bitwise OR operation
    Let a be BigInteger.create_from_integer(15)  // 1111 in binary
    Let b be BigInteger.create_from_integer(10)  // 1010 in binary
    Let result be BigInteger.bitwise_or(a, b)
    Let expected be BigInteger.create_from_integer(15)  // 1111 in binary
    Assert.IsTrue(BigInteger.equals(result, expected))
    Return True

Process called "test_bitwise_xor" that takes no parameters returns Boolean:
    Note: Test bitwise XOR operation
    Let a be BigInteger.create_from_integer(15)  // 1111 in binary
    Let b be BigInteger.create_from_integer(10)  // 1010 in binary
    Let result be BigInteger.bitwise_xor(a, b)
    Let expected be BigInteger.create_from_integer(5)   // 0101 in binary
    Assert.IsTrue(BigInteger.equals(result, expected))
    Return True

Process called "test_bitwise_not" that takes no parameters returns Boolean:
    Note: Test bitwise NOT operation (two's complement)
    Let a be BigInteger.create_from_integer(5)   // 0101 in binary
    Let result be BigInteger.bitwise_not(a)
    Let expected be BigInteger.create_from_integer(-6)  // Two's complement of 5
    Assert.IsTrue(BigInteger.equals(result, expected))
    Return True

Process called "test_left_shift" that takes no parameters returns Boolean:
    Note: Test left shift operation (multiplication by powers of 2)
    Let a be BigInteger.create_from_integer(5)   // 101 in binary
    Let result be BigInteger.left_shift(a, 2)
    Let expected be BigInteger.create_from_integer(20)  // 10100 in binary (5 * 4)
    Assert.IsTrue(BigInteger.equals(result, expected))
    
    Let large_shift be BigInteger.left_shift(a, 10)
    Let expected_large be BigInteger.create_from_integer(5120)  // 5 * 1024
    Assert.IsTrue(BigInteger.equals(large_shift, expected_large))
    Return True

Process called "test_right_shift" that takes no parameters returns Boolean:
    Note: Test right shift operation (division by powers of 2)
    Let a be BigInteger.create_from_integer(20)  // 10100 in binary
    Let result be BigInteger.right_shift(a, 2)
    Let expected be BigInteger.create_from_integer(5)   // 101 in binary (20 / 4)
    Assert.IsTrue(BigInteger.equals(result, expected))
    
    Let negative be BigInteger.create_from_integer(-20)
    Let neg_result be BigInteger.right_shift(negative, 2)
    Let expected_neg be BigInteger.create_from_integer(-5)
    Assert.IsTrue(BigInteger.equals(neg_result, expected_neg))
    Return True

Process called "test_bit_operations_large_numbers" that takes no parameters returns Boolean:
    Note: Test bitwise operations on large numbers
    Let large_a be BigInteger.create_from_string("0xFFFFFFFFFFFFFFFF", 16)
    Let large_b be BigInteger.create_from_string("0xAAAAAAAAAAAAAAAA", 16)
    
    Let and_result be BigInteger.bitwise_and(large_a, large_b)
    Assert.IsTrue(BigInteger.equals(and_result, large_b))
    
    Let or_result be BigInteger.bitwise_or(large_a, large_b)
    Assert.IsTrue(BigInteger.equals(or_result, large_a))
    Return True

Note: =====================================================================
Note: PRIME TESTING TESTS
Note: =====================================================================

Process called "test_is_prime_small_primes" that takes no parameters returns Boolean:
    Note: Test primality testing for small known primes
    Let small_primes be [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]
    For prime in small_primes:
        Let big_prime be BigInteger.create_from_integer(prime)
        Let result be BigInteger.is_prime(big_prime)
        Assert.IsTrue(result.is_prime)
    Return True

Process called "test_is_prime_small_composites" that takes no parameters returns Boolean:
    Note: Test primality testing for small known composites
    Let small_composites be [4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20]
    For composite in small_composites:
        Let big_composite be BigInteger.create_from_integer(composite)
        Let result be BigInteger.is_prime(big_composite)
        Assert.IsFalse(result.is_prime)
    Return True

Process called "test_is_prime_large_known_prime" that takes no parameters returns Boolean:
    Note: Test primality testing for larger known prime
    Let large_prime_str be "982451653"  // Known prime
    Let large_prime be BigInteger.create_from_string(large_prime_str, 10)
    Let result be BigInteger.is_prime(large_prime)
    Assert.IsTrue(result.is_prime)
    Assert.IsTrue(result.confidence > 0.99)
    Return True

Process called "test_is_prime_mersenne_numbers" that takes no parameters returns Boolean:
    Note: Test primality of small Mersenne numbers
    Let mersenne_3 be BigInteger.create_from_integer(7)    // 2^3 - 1
    Let mersenne_5 be BigInteger.create_from_integer(31)   // 2^5 - 1
    Let mersenne_7 be BigInteger.create_from_integer(127)  // 2^7 - 1
    
    Assert.IsTrue(BigInteger.is_prime(mersenne_3).is_prime)
    Assert.IsTrue(BigInteger.is_prime(mersenne_5).is_prime)
    Assert.IsTrue(BigInteger.is_prime(mersenne_7).is_prime)
    
    Let mersenne_11 be BigInteger.create_from_integer(2047) // 2^11 - 1 = 23 × 89
    Assert.IsFalse(BigInteger.is_prime(mersenne_11).is_prime)
    Return True

Process called "test_miller_rabin_test_rounds" that takes no parameters returns Boolean:
    Note: Test Miller-Rabin with different number of rounds
    Let candidate be BigInteger.create_from_string("982451653", 10)
    
    Let result_10 be BigInteger.miller_rabin_test(candidate, 10)
    Let result_20 be BigInteger.miller_rabin_test(candidate, 20)
    
    Assert.IsTrue(result_10.is_prime)
    Assert.IsTrue(result_20.is_prime)
    Assert.IsTrue(result_20.confidence >= result_10.confidence)
    Assert.IsTrue(result_20.test_rounds >= result_10.test_rounds)
    Return True

Note: =====================================================================
Note: FACTORIZATION TESTS
Note: =====================================================================

Process called "test_trial_division_small_numbers" that takes no parameters returns Boolean:
    Note: Test trial division factorization for small numbers
    Let num_12 be BigInteger.create_from_integer(12)
    Let factors_12 be BigInteger.trial_division_factorize(num_12)
    
    Assert.IsTrue(factors_12.is_complete)
    Assert.IsTrue(factors_12.factors.contains_key(BigInteger.create_from_integer(2)))
    Assert.IsTrue(factors_12.factors.contains_key(BigInteger.create_from_integer(3)))
    Assert.AreEqual(factors_12.factors[BigInteger.create_from_integer(2)], 2)  // 2^2
    Assert.AreEqual(factors_12.factors[BigInteger.create_from_integer(3)], 1)  // 3^1
    Return True

Process called "test_trial_division_prime_number" that takes no parameters returns Boolean:
    Note: Test trial division on prime number
    Let prime be BigInteger.create_from_integer(17)
    Let factors be BigInteger.trial_division_factorize(prime)
    
    Assert.IsTrue(factors.is_complete)
    Assert.IsTrue(factors.factors.contains_key(prime))
    Assert.AreEqual(factors.factors[prime], 1)
    Return True

Process called "test_pollard_rho_factorization" that takes no parameters returns Boolean:
    Note: Test Pollard's rho factorization algorithm
    Let composite be BigInteger.create_from_integer(8051)  // 97 * 83
    Let factor be BigInteger.pollard_rho_factor(composite)
    
    Assert.IsFalse(BigInteger.equals(factor, BigInteger.one()))
    Assert.IsFalse(BigInteger.equals(factor, composite))
    
    Let remainder be BigInteger.divide(composite, factor)
    Let verification be BigInteger.multiply(factor, remainder)
    Assert.IsTrue(BigInteger.equals(verification, composite))
    Return True

Process called "test_complete_factorization" that takes no parameters returns Boolean:
    Note: Test complete factorization of composite number
    Let number be BigInteger.create_from_integer(60)  // 2^2 * 3 * 5
    Let factorization be BigInteger.complete_factorization(number)
    
    Assert.IsTrue(factorization.is_complete)
    Assert.IsTrue(factorization.factors.contains_key(BigInteger.create_from_integer(2)))
    Assert.IsTrue(factorization.factors.contains_key(BigInteger.create_from_integer(3)))
    Assert.IsTrue(factorization.factors.contains_key(BigInteger.create_from_integer(5)))
    
    Assert.AreEqual(factorization.factors[BigInteger.create_from_integer(2)], 2)
    Assert.AreEqual(factorization.factors[BigInteger.create_from_integer(3)], 1)
    Assert.AreEqual(factorization.factors[BigInteger.create_from_integer(5)], 1)
    Return True

Note: =====================================================================
Note: BASE CONVERSION AND STRING REPRESENTATION TESTS
Note: =====================================================================

Process called "test_to_string_various_bases" that takes no parameters returns Boolean:
    Note: Test string conversion to various bases
    Let number be BigInteger.create_from_integer(255)
    
    Let binary_str be BigInteger.to_string(number, 2)
    Assert.AreEqual(binary_str, "11111111")
    
    Let octal_str be BigInteger.to_string(number, 8)
    Assert.AreEqual(octal_str, "377")
    
    Let hex_str be BigInteger.to_string(number, 16)
    Assert.AreEqual(hex_str.to_upper(), "FF")
    
    Let decimal_str be BigInteger.to_string(number, 10)
    Assert.AreEqual(decimal_str, "255")
    Return True

Process called "test_to_string_negative_numbers" that takes no parameters returns Boolean:
    Note: Test string conversion for negative numbers
    Let negative be BigInteger.create_from_integer(-255)
    
    Let binary_str be BigInteger.to_string(negative, 2)
    Assert.AreEqual(binary_str, "-11111111")
    
    Let hex_str be BigInteger.to_string(negative, 16)
    Assert.AreEqual(hex_str.to_upper(), "-FF")
    Return True

Process called "test_to_string_large_numbers" that takes no parameters returns Boolean:
    Note: Test string conversion for very large numbers
    Let large_number be BigInteger.create_from_string("12345678901234567890123456789", 10)
    Let string_repr be BigInteger.to_string(large_number, 10)
    Assert.AreEqual(string_repr, "12345678901234567890123456789")
    
    Let hex_repr be BigInteger.to_string(large_number, 16)
    Assert.IsTrue(Length(hex_repr) > 0)
    Assert.IsFalse(Contains(hex_repr.to_upper(), "G"))  // No invalid hex digits
    Return True

Process called "test_base_conversion_round_trip" that takes no parameters returns Boolean:
    Note: Test round-trip conversion between bases
    Let original be BigInteger.create_from_integer(123456789)
    
    Let bases be [2, 8, 16, 36]
    For base in bases:
        Let string_repr be BigInteger.to_string(original, base)
        Let converted_back be BigInteger.create_from_string(string_repr, base)
        Assert.IsTrue(BigInteger.equals(original, converted_back))
    Return True

Note: =====================================================================
Note: PERFORMANCE AND EDGE CASE TESTS
Note: =====================================================================

Process called "test_large_number_arithmetic" that takes no parameters returns Boolean:
    Note: Test arithmetic with very large numbers
    Let large_integers be generate_large_integers()
    Let a be large_integers[0]
    Let b be large_integers[1]
    
    Let sum be BigInteger.add(a, b)
    Assert.IsFalse(BigInteger.is_zero(sum))
    
    Let product be BigInteger.multiply(a, b)
    Assert.IsTrue(BigInteger.greater_than(product, a))
    Assert.IsTrue(BigInteger.greater_than(product, b))
    
    If not BigInteger.is_zero(b):
        Let quotient be BigInteger.divide(a, b)
        Let verification be BigInteger.multiply(quotient, b)
        Let remainder be BigInteger.subtract(a, verification)
        Assert.IsTrue(BigInteger.less_than(BigInteger.abs(remainder), BigInteger.abs(b)))
    Return True

Process called "test_zero_and_one_operations" that takes no parameters returns Boolean:
    Note: Test special behavior with zero and one
    Let zero be BigInteger.zero()
    Let one be BigInteger.one()
    Let arbitrary be BigInteger.create_from_integer(42)
    
    Assert.IsTrue(BigInteger.equals(BigInteger.add(arbitrary, zero), arbitrary))
    Assert.IsTrue(BigInteger.equals(BigInteger.multiply(arbitrary, one), arbitrary))
    Assert.IsTrue(BigInteger.equals(BigInteger.multiply(arbitrary, zero), zero))
    
    Assert.IsTrue(BigInteger.is_zero(zero))
    Assert.IsFalse(BigInteger.is_negative(zero))
    Return True

Process called "test_sign_operations" that takes no parameters returns Boolean:
    Note: Test sign-related operations
    Let positive be BigInteger.create_from_integer(42)
    Let negative be BigInteger.create_from_integer(-42)
    Let zero be BigInteger.zero()
    
    Assert.IsFalse(BigInteger.is_negative(positive))
    Assert.IsTrue(BigInteger.is_negative(negative))
    Assert.IsFalse(BigInteger.is_negative(zero))
    
    Let abs_positive be BigInteger.abs(positive)
    Let abs_negative be BigInteger.abs(negative)
    Assert.IsTrue(BigInteger.equals(abs_positive, abs_negative))
    
    Let negated_positive be BigInteger.negate(positive)
    Assert.IsTrue(BigInteger.equals(negated_positive, negative))
    Return True

Process called "test_string_parsing_edge_cases" that takes no parameters returns Boolean:
    Note: Test edge cases in string parsing
    Let leading_zeros be BigInteger.create_from_string("00000123", 10)
    Let normal be BigInteger.create_from_integer(123)
    Assert.IsTrue(BigInteger.equals(leading_zeros, normal))
    
    Let plus_sign be BigInteger.create_from_string("+123", 10)
    Assert.IsTrue(BigInteger.equals(plus_sign, normal))
    
    Let single_zero be BigInteger.create_from_string("0", 10)
    Assert.IsTrue(BigInteger.is_zero(single_zero))
    Return True

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_all_tests" that takes no parameters returns Boolean:
    Note: Run all BigInteger module tests
    Let tests_passed be 0
    Let tests_failed be 0
    
    Note: Construction and initialization tests
    Let construction_tests be [
        "test_create_from_integer_positive",
        "test_create_from_integer_negative",
        "test_create_from_string_decimal",
        "test_create_from_string_hexadecimal",
        "test_create_from_string_binary",
        "test_create_from_invalid_string"
    ]
    
    Note: Basic arithmetic tests
    Let arithmetic_tests be [
        "test_addition_positive_numbers",
        "test_addition_with_negative_numbers",
        "test_addition_identity",
        "test_subtraction_basic",
        "test_subtraction_negative_result",
        "test_multiplication_basic",
        "test_multiplication_by_zero",
        "test_multiplication_by_one",
        "test_multiplication_negative_numbers",
        "test_division_basic",
        "test_division_by_one",
        "test_division_by_zero_error",
        "test_modulo_operations"
    ]
    
    Note: Comparison operation tests
    Let comparison_tests be [
        "test_equality_comparison",
        "test_less_than_comparison",
        "test_greater_than_comparison",
        "test_comparison_large_numbers"
    ]
    
    Note: GCD and LCM tests
    Let gcd_lcm_tests be [
        "test_gcd_basic",
        "test_gcd_large_numbers",
        "test_gcd_with_zero",
        "test_extended_gcd",
        "test_lcm_basic",
        "test_gcd_lcm_relationship"
    ]
    
    Note: Modular arithmetic tests
    Let modular_tests be [
        "test_modular_addition",
        "test_modular_subtraction",
        "test_modular_multiplication",
        "test_modular_exponentiation",
        "test_modular_inverse",
        "test_modular_inverse_nonexistent"
    ]
    
    Note: Bitwise operation tests
    Let bitwise_tests be [
        "test_bitwise_and",
        "test_bitwise_or",
        "test_bitwise_xor",
        "test_bitwise_not",
        "test_left_shift",
        "test_right_shift",
        "test_bit_operations_large_numbers"
    ]
    
    Note: Prime testing tests
    Let prime_tests be [
        "test_is_prime_small_primes",
        "test_is_prime_small_composites",
        "test_is_prime_large_known_prime",
        "test_is_prime_mersenne_numbers",
        "test_miller_rabin_test_rounds"
    ]
    
    Note: Factorization tests
    Let factorization_tests be [
        "test_trial_division_small_numbers",
        "test_trial_division_prime_number",
        "test_pollard_rho_factorization",
        "test_complete_factorization"
    ]
    
    Note: Base conversion tests
    Let conversion_tests be [
        "test_to_string_various_bases",
        "test_to_string_negative_numbers",
        "test_to_string_large_numbers",
        "test_base_conversion_round_trip"
    ]
    
    Note: Performance and edge case tests
    Let edge_case_tests be [
        "test_large_number_arithmetic",
        "test_zero_and_one_operations",
        "test_sign_operations",
        "test_string_parsing_edge_cases"
    ]
    
    Let all_test_groups be [construction_tests, arithmetic_tests, comparison_tests, gcd_lcm_tests,
                           modular_tests, bitwise_tests, prime_tests, factorization_tests,
                           conversion_tests, edge_case_tests]
    
    Let group_names be ["Construction & Initialization", "Basic Arithmetic", "Comparison Operations", "GCD & LCM",
                       "Modular Arithmetic", "Bitwise Operations", "Prime Testing", "Factorization",
                       "Base Conversion", "Performance & Edge Cases"]
    
    For group_index from 0 to Length(all_test_groups) - 1:
        Let test_group be all_test_groups[group_index]
        Let group_name be group_names[group_index]
        Print "Testing " + group_name + "..."
        
        For test_name in test_group:
            Try:
                Let test_result be Call test_name()
                If test_result:
                    Set tests_passed to tests_passed + 1
                    Print "  ✓ " + test_name
                Else:
                    Set tests_failed to tests_failed + 1  
                    Print "  ✗ " + test_name + " (returned false)"
            Catch error:
                Set tests_failed to tests_failed + 1
                Print "  ✗ " + test_name + " (error: " + error.message + ")"
    
    Let total_tests be tests_passed + tests_failed
    Print ""
    Print "BigInteger Module Test Results:"
    Print "==============================="
    Print "Tests passed: " + ToString(tests_passed)
    Print "Tests failed: " + ToString(tests_failed)
    Print "Total tests: " + ToString(total_tests)
    Print "Success rate: " + ToString((tests_passed * 100) / total_tests) + "%"
    
    Return tests_failed = 0