Note: ===== RUNA UNIT TESTS: MATH/PRECISION/CONTINUED =====

Import "math/precision/continued" as Continued
Import "math/precision/rational" as Rational
Import "math/precision/bigdecimal" as BigDecimal
Import "math/precision/biginteger" as BigInteger
Import "dev/debug/testing/unit" as UnitTest

Note: ===== TEST DATA GENERATORS =====

Process called "create_test_continued_fractions" returns Array[Continued.ContinuedFraction]:
    Note: Creates array of test ContinuedFraction values for comprehensive testing
    Let test_values be Array.create([
        Continued.create_from_rational(Rational.create_from_integers(22, 7)),  Note: π approximation
        Continued.create_from_rational(Rational.create_from_integers(8, 5)),   Note: Golden ratio approx
        Continued.create_from_rational(Rational.create_from_integers(3, 2)),   Note: Simple fraction
        Continued.create_from_rational(Rational.create_from_integers(1, 1)),   Note: Unity
        Continued.create_from_rational(Rational.create_from_integers(7, 3)),   Note: Improper fraction
        Continued.create_from_coefficients([3, 7, 15, 1, 292, 1]),  Note: π expansion
        Continued.create_from_coefficients([1, 1, 1, 1, 1, 1, 1]), Note: Golden ratio expansion
        Continued.create_from_coefficients([2, 1, 2, 1, 1, 4, 1]), Note: e expansion approximation
        Continued.create_from_coefficients([1, 2, 2, 2, 2, 2, 2]), Note: √2 expansion
        Continued.create_from_coefficients([0, 1, 1, 1, 1, 1, 1])  Note: 1/(golden ratio)
    ])
    Return test_values

Process called "create_mathematical_constants" returns Array[Continued.ContinuedFraction]:
    Note: Creates continued fractions for well-known mathematical constants
    Let test_values be Array.create([
        Continued.create_pi_approximation(10),    Note: π to 10 terms
        Continued.create_e_approximation(10),     Note: e to 10 terms
        Continued.create_golden_ratio(15),        Note: φ to 15 terms
        Continued.create_sqrt_approximation(2, 10), Note: √2 to 10 terms
        Continued.create_sqrt_approximation(3, 10), Note: √3 to 10 terms
        Continued.create_euler_gamma_approximation(8) Note: γ to 8 terms
    ])
    Return test_values

Process called "create_default_context" returns BigDecimal.MathContext:
    Note: Creates standard math context for BigDecimal operations
    Let context be BigDecimal.MathContext.new()
    Set context.precision to 50
    Set context.rounding_mode to BigDecimal.RoundingMode.HALF_EVEN
    Set context.exact_arithmetic to false
    Return context

Note: ===== ASSERTION HELPERS =====

Process called "assert_cf_equals" that takes actual as Continued.ContinuedFraction, expected as Continued.ContinuedFraction, message as String:
    Note: Asserts continued fraction equality using coefficient comparison
    Let are_equal be Continued.equals(actual, expected)
    UnitTest.assert(are_equal, message + " - Expected: " + Continued.to_string(expected) + ", Actual: " + Continued.to_string(actual))

Process called "assert_coefficients_equal" that takes actual as Array[Integer], expected as Array[Integer], message as String:
    Note: Asserts coefficient arrays are equal
    Let are_equal be Array.equals(actual, expected)
    UnitTest.assert(are_equal, message + " - Expected coefficients: " + Array.to_string(expected) + ", Actual: " + Array.to_string(actual))

Process called "assert_convergent_approximates" that takes convergent as Rational.Rational, target as BigDecimal.BigDecimal, tolerance as BigDecimal.BigDecimal, message as String:
    Note: Asserts that convergent approximates target within tolerance
    Let convergent_decimal be BigDecimal.create_from_fraction(
        Rational.get_numerator(convergent),
        Rational.get_denominator(convergent),
        create_default_context()
    )
    
    Let difference be BigDecimal.abs(BigDecimal.subtract(convergent_decimal, target, create_default_context()))
    Let within_tolerance be BigDecimal.compare(difference, tolerance) <= 0
    
    UnitTest.assert(within_tolerance, 
        message + " - Target: " + BigDecimal.to_plain_string(target) + 
        ", Convergent: " + BigDecimal.to_plain_string(convergent_decimal) + 
        ", Difference: " + BigDecimal.to_plain_string(difference) + 
        ", Tolerance: " + BigDecimal.to_plain_string(tolerance))

Process called "assert_string_representation" that takes cf as Continued.ContinuedFraction, expected as String, message as String:
    Note: Asserts string representation matches expected
    Let actual be Continued.to_string(cf)
    UnitTest.assert(actual equals expected, message + " - Expected: '" + expected + "', Actual: '" + actual + "'")

Note: ===== CONSTRUCTION TESTS =====

Process called "test_create_from_coefficients":
    Note: Test ContinuedFraction creation from coefficient arrays
    Let simple_cf be Continued.create_from_coefficients([3, 7])
    assert_string_representation(simple_cf, "[3; 7]", "Simple continued fraction from coefficients")
    
    Let complex_cf be Continued.create_from_coefficients([3, 7, 15, 1, 292])
    assert_string_representation(complex_cf, "[3; 7, 15, 1, 292]", "Complex continued fraction")
    
    Let integer_cf be Continued.create_from_coefficients([5])
    assert_string_representation(integer_cf, "[5]", "Integer as continued fraction")
    
    Let proper_fraction_cf be Continued.create_from_coefficients([0, 3, 2])
    assert_string_representation(proper_fraction_cf, "[0; 3, 2]", "Proper fraction continued fraction")

Process called "test_create_from_rational":
    Note: Test ContinuedFraction creation from Rational numbers
    Let simple_rational be Rational.create_from_integers(22, 7)
    Let cf_from_rational be Continued.create_from_rational(simple_rational)
    
    Note: 22/7 = 3 + 1/7, so should be [3; 7]
    let expected_coeffs be [3, 7]
    Let actual_coeffs be Continued.get_coefficients(cf_from_rational)
    assert_coefficients_equal(actual_coeffs, expected_coeffs, "22/7 continued fraction coefficients")
    
    Let golden_ratio_approx be Rational.create_from_integers(8, 5)
    Let golden_cf be Continued.create_from_rational(golden_ratio_approx)
    Note: 8/5 = 1 + 3/5 = 1 + 1/(5/3) = 1 + 1/(1 + 2/3) = 1 + 1/(1 + 1/(3/2)) = [1; 1, 1, 1]
    Let golden_expected be [1, 1, 1, 1]
    Let golden_actual be Continued.get_coefficients(golden_cf)
    assert_coefficients_equal(golden_actual, golden_expected, "Golden ratio approximation coefficients")
    
    Let integer_rational be Rational.create_from_integers(7, 1)
    Let integer_cf be Continued.create_from_rational(integer_rational)
    Let integer_expected be [7]
    Let integer_actual be Continued.get_coefficients(integer_cf)
    assert_coefficients_equal(integer_actual, integer_expected, "Integer rational as continued fraction")

Process called "test_create_from_decimal":
    Note: Test ContinuedFraction creation from decimal approximations
    Let decimal_half be BigDecimal.create_from_string("0.5", create_default_context())
    Let half_cf be Continued.create_from_decimal(decimal_half, 5)
    Note: 0.5 = 1/2, so should be [0; 2]
    Let half_expected be [0, 2]
    Let half_actual be Continued.get_coefficients(half_cf)
    assert_coefficients_equal(half_actual, half_expected, "Decimal 0.5 as continued fraction")
    
    Let pi_decimal be BigDecimal.pi(20)
    Let pi_cf be Continued.create_from_decimal(pi_decimal, 8)
    Note: π starts with [3; 7, 15, 1, 292, ...]
    Let pi_actual be Continued.get_coefficients(pi_cf)
    UnitTest.assert(pi_actual[0] equals 3, "π continued fraction should start with 3")
    UnitTest.assert(pi_actual[1] equals 7, "π continued fraction should have second term 7")

Process called "test_create_mathematical_constants":
    Note: Test creation of well-known mathematical constants
    Let pi_cf be Continued.create_pi_approximation(6)
    Let pi_coeffs be Continued.get_coefficients(pi_cf)
    UnitTest.assert(pi_coeffs[0] equals 3, "π approximation should start with 3")
    UnitTest.assert(pi_coeffs[1] equals 7, "π approximation second term should be 7")
    UnitTest.assert(pi_coeffs[2] equals 15, "π approximation third term should be 15")
    
    Let e_cf be Continued.create_e_approximation(8)
    Let e_coeffs be Continued.get_coefficients(e_cf)
    UnitTest.assert(e_coeffs[0] equals 2, "e approximation should start with 2")
    UnitTest.assert(e_coeffs[1] equals 1, "e approximation pattern should follow [2; 1, 2, 1, 1, 4, 1, 1]")
    UnitTest.assert(e_coeffs[2] equals 2, "e approximation third term should be 2")
    
    Let golden_cf be Continued.create_golden_ratio(10)
    Let golden_coeffs be Continued.get_coefficients(golden_cf)
    Note: Golden ratio has all coefficients equal to 1
    For i from 0 to 9:
        UnitTest.assert(golden_coeffs[i] equals 1, "Golden ratio coefficient " + Integer.to_string(i) + " should be 1")
    
    Let sqrt2_cf be Continued.create_sqrt_approximation(2, 8)
    Let sqrt2_coeffs be Continued.get_coefficients(sqrt2_cf)
    UnitTest.assert(sqrt2_coeffs[0] equals 1, "√2 should start with 1")
    UnitTest.assert(sqrt2_coeffs[1] equals 2, "√2 should have pattern [1; 2, 2, 2, ...]")
    UnitTest.assert(sqrt2_coeffs[2] equals 2, "√2 should have repeating 2s")

Note: ===== CONVERGENT CALCULATION TESTS =====

Process called "test_convergent_calculation":
    Note: Test calculation of convergents (rational approximations)
    Let pi_cf be Continued.create_from_coefficients([3, 7, 15, 1, 292])
    
    Let convergent_0 be Continued.get_convergent(pi_cf, 0)
    assert_rational_equals(convergent_0, Rational.create_from_integers(3, 1), "0th convergent of π")
    
    Let convergent_1 be Continued.get_convergent(pi_cf, 1)
    assert_rational_equals(convergent_1, Rational.create_from_integers(22, 7), "1st convergent of π (22/7)")
    
    Let convergent_2 be Continued.get_convergent(pi_cf, 2)
    assert_rational_equals(convergent_2, Rational.create_from_integers(333, 106), "2nd convergent of π")
    
    Let all_convergents be Continued.get_all_convergents(pi_cf)
    UnitTest.assert(Array.length(all_convergents) equals 5, "Should get 5 convergents from 5-term expansion")

Process called "assert_rational_equals" that takes actual as Rational.Rational, expected as Rational.Rational, message as String:
    Note: Helper for rational equality assertion
    Let are_equal be Rational.equals(actual, expected)
    UnitTest.assert(are_equal, message + " - Expected: " + Rational.to_string(expected) + ", Actual: " + Rational.to_string(actual))

Process called "test_convergent_accuracy":
    Note: Test accuracy of convergents as approximations
    Let context be create_default_context()
    
    Let pi_exact be BigDecimal.pi(50)
    Let pi_cf be Continued.create_pi_approximation(10)
    
    Let convergent_1 be Continued.get_convergent(pi_cf, 1)  Note: 22/7
    let tolerance_1 be BigDecimal.create_from_string("0.002", context)
    assert_convergent_approximates(convergent_1, pi_exact, tolerance_1, "22/7 approximation of π")
    
    Let convergent_3 be Continued.get_convergent(pi_cf, 3)  Note: More accurate
    Let tolerance_3 be BigDecimal.create_from_string("0.00001", context)
    assert_convergent_approximates(convergent_3, pi_exact, tolerance_3, "Higher order π convergent")
    
    Let e_exact be BigDecimal.e(50)
    Let e_cf be Continued.create_e_approximation(10)
    Let e_convergent_5 be Continued.get_convergent(e_cf, 5)
    Let e_tolerance be BigDecimal.create_from_string("0.0001", context)
    assert_convergent_approximates(e_convergent_5, e_exact, e_tolerance, "e convergent approximation")

Process called "test_convergent_properties":
    Note: Test mathematical properties of convergents
    Let cf be Continued.create_from_coefficients([3, 7, 15, 1, 292])
    
    Note: Test that convergents alternate around the true value
    Let convergents be Continued.get_all_convergents(cf)
    
    Note: Test that denominators are increasing (for finite continued fractions)
    For i from 1 to (Array.length(convergents) - 1):
        Let prev_denom be Rational.get_denominator(convergents[i-1])
        Let curr_denom be Rational.get_denominator(convergents[i])
        UnitTest.assert(BigInteger.compare(curr_denom, prev_denom) > 0, 
            "Convergent denominators should be increasing")
    
    Note: Test convergent accuracy improves
    Let target_rational be Continued.to_rational(cf)
    For i from 1 to (Array.length(convergents) - 1):
        Let prev_error be Rational.abs(Rational.subtract(convergents[i-1], target_rational))
        Let curr_error be Rational.abs(Rational.subtract(convergents[i], target_rational))
        UnitTest.assert(Rational.compare(curr_error, prev_error) <= 0,
            "Convergent accuracy should improve or stay same")

Note: ===== ARITHMETIC OPERATION TESTS =====

Process called "test_addition":
    Note: Test continued fraction addition
    Let a be Continued.create_from_coefficients([1, 2])  Note: 1 + 1/2 = 3/2
    Let b be Continued.create_from_coefficients([2, 3])  Note: 2 + 1/3 = 7/3
    
    Let sum be Continued.add(a, b)
    Let sum_rational be Continued.to_rational(sum)
    
    Note: 3/2 + 7/3 = 9/6 + 14/6 = 23/6
    Let expected_sum be Rational.create_from_integers(23, 6)
    assert_rational_equals(sum_rational, expected_sum, "Continued fraction addition")
    
    Let golden_cf be Continued.create_golden_ratio(8)
    Let one_cf be Continued.create_from_coefficients([1])
    Let golden_plus_one be Continued.add(golden_cf, one_cf)
    
    Note: φ + 1 should equal φ² (golden ratio property)
    Let phi_squared_cf be Continued.multiply(golden_cf, golden_cf)
    Let phi_plus_one_rational be Continued.to_rational(golden_plus_one)
    Let phi_squared_rational be Continued.to_rational(phi_squared_cf)
    
    Let difference be Rational.abs(Rational.subtract(phi_plus_one_rational, phi_squared_rational))
    Let tolerance be Rational.create_from_integers(1, 1000)
    UnitTest.assert(Rational.compare(difference, tolerance) <= 0, "Golden ratio property: φ + 1 ≈ φ²")

Process called "test_subtraction":
    Note: Test continued fraction subtraction
    Let a be Continued.create_from_coefficients([3, 7])   Note: 22/7
    Let b be Continued.create_from_coefficients([3])      Note: 3
    
    Let difference be Continued.subtract(a, b)
    Let diff_rational be Continued.to_rational(difference)
    
    Note: 22/7 - 3 = 22/7 - 21/7 = 1/7
    Let expected_diff be Rational.create_from_integers(1, 7)
    assert_rational_equals(diff_rational, expected_diff, "Continued fraction subtraction")
    
    Let self_difference be Continued.subtract(a, a)
    Let self_diff_rational be Continued.to_rational(self_difference)
    UnitTest.assert(Rational.is_zero(self_diff_rational), "Self subtraction should be zero")

Process called "test_multiplication":
    Note: Test continued fraction multiplication
    Let a be Continued.create_from_coefficients([0, 2])  Note: 1/2
    Let b be Continued.create_from_coefficients([0, 3])  Note: 1/3
    
    Let product be Continued.multiply(a, b)
    Let product_rational be Continued.to_rational(product)
    
    Note: 1/2 * 1/3 = 1/6
    Let expected_product be Rational.create_from_integers(1, 6)
    assert_rational_equals(product_rational, expected_product, "Continued fraction multiplication")
    
    Let integer_cf be Continued.create_from_coefficients([5])
    Let fraction_cf be Continued.create_from_coefficients([0, 4])  Note: 1/4
    
    Let int_frac_product be Continued.multiply(integer_cf, fraction_cf)
    Let int_frac_rational be Continued.to_rational(int_frac_product)
    
    Note: 5 * 1/4 = 5/4
    Let expected_int_frac be Rational.create_from_integers(5, 4)
    assert_rational_equals(int_frac_rational, expected_int_frac, "Integer times fraction")

Process called "test_division":
    Note: Test continued fraction division
    Let a be Continued.create_from_coefficients([3, 7])  Note: 22/7
    Let b be Continued.create_from_coefficients([2])     Note: 2
    
    Let quotient be Continued.divide(a, b)
    Let quotient_rational be Continued.to_rational(quotient)
    
    Note: (22/7) / 2 = 22/14 = 11/7
    Let expected_quotient be Rational.create_from_integers(11, 7)
    assert_rational_equals(quotient_rational, expected_quotient, "Continued fraction division")
    
    Let self_division be Continued.divide(a, a)
    Let self_div_rational be Continued.to_rational(self_division)
    UnitTest.assert(Rational.is_one(self_div_rational), "Self division should be one")

Process called "test_reciprocal":
    Note: Test continued fraction reciprocal
    let golden_cf be Continued.create_golden_ratio(10)
    Let golden_reciprocal be Continued.reciprocal(golden_cf)
    
    Note: 1/φ = φ - 1 (golden ratio property)
    Let one_cf be Continued.create_from_coefficients([1])
    Let phi_minus_one be Continued.subtract(golden_cf, one_cf)
    
    Let reciprocal_rational be Continued.to_rational(golden_reciprocal)
    Let phi_minus_one_rational be Continued.to_rational(phi_minus_one)
    
    Let difference be Rational.abs(Rational.subtract(reciprocal_rational, phi_minus_one_rational))
    Let tolerance be Rational.create_from_integers(1, 1000)
    UnitTest.assert(Rational.compare(difference, tolerance) <= 0, "Golden ratio reciprocal property")
    
    Let simple_fraction be Continued.create_from_coefficients([0, 3])  Note: 1/3
    Let reciprocal_simple be Continued.reciprocal(simple_fraction)
    Let reciprocal_rational_simple be Continued.to_rational(reciprocal_simple)
    
    Note: 1/(1/3) = 3
    Let expected_reciprocal be Rational.create_from_integers(3, 1)
    assert_rational_equals(reciprocal_rational_simple, expected_reciprocal, "Reciprocal of simple fraction")

Note: ===== TRUNCATION AND APPROXIMATION TESTS =====

Process called "test_truncation":
    Note: Test continued fraction truncation to specified number of terms
    Let pi_cf be Continued.create_pi_approximation(20)
    
    Let truncated_5 be Continued.truncate(pi_cf, 5)
    Let truncated_coeffs be Continued.get_coefficients(truncated_5)
    UnitTest.assert(Array.length(truncated_coeffs) equals 5, "Truncated CF should have 5 terms")
    
    Let pi_full_coeffs be Continued.get_coefficients(pi_cf)
    For i from 0 to 4:
        UnitTest.assert(truncated_coeffs[i] equals pi_full_coeffs[i], 
            "Truncated coefficients should match original")
    
    Let truncated_1 be Continued.truncate(pi_cf, 1)
    Let truncated_1_rational be Continued.to_rational(truncated_1)
    assert_rational_equals(truncated_1_rational, Rational.create_from_integers(3, 1), 
        "Single term truncation should give integer part")

Process called "test_best_approximation":
    Note: Test finding best rational approximations within error bounds
    Let context be create_default_context()
    let pi_exact be BigDecimal.pi(50)
    
    Let tolerance be BigDecimal.create_from_string("0.01", context)
    Let pi_approximation be Continued.best_approximation_within_error(pi_exact, tolerance)
    
    assert_convergent_approximates(pi_approximation, pi_exact, tolerance, "Best π approximation within tolerance")
    
    Let strict_tolerance be BigDecimal.create_from_string("0.0001", context)
    Let precise_pi_approx be Continued.best_approximation_within_error(pi_exact, strict_tolerance)
    
    Note: More strict tolerance should give more accurate approximation
    assert_convergent_approximates(precise_pi_approx, pi_exact, strict_tolerance, "Precise π approximation")
    
    Let denominator_bound be 100
    Let bounded_approx be Continued.best_approximation_with_denominator_bound(pi_exact, denominator_bound)
    
    Let bounded_denom be Rational.get_denominator(bounded_approx)
    UnitTest.assert(BigInteger.compare(bounded_denom, BigInteger.create_from_integer(denominator_bound)) <= 0,
        "Approximation denominator should be within bound")

Process called "test_semiconvergents":
    Note: Test calculation of semiconvergents (intermediate approximations)
    Let golden_cf be Continued.create_golden_ratio(5)
    Let semiconvergents be Continued.get_semiconvergents(golden_cf, 2)  Note: Between 2nd and 3rd convergent
    
    UnitTest.assert(Array.length(semiconvergents) > 0, "Should get semiconvergents between convergents")
    
    Let convergent_2 be Continued.get_convergent(golden_cf, 2)
    Let convergent_3 be Continued.get_convergent(golden_cf, 3)
    
    Note: Semiconvergents should lie between consecutive convergents
    For i from 0 to (Array.length(semiconvergents) - 1):
        Let semiconvergent be semiconvergents[i]
        UnitTest.assert(
            (Rational.compare(convergent_2, semiconvergent) <= 0 and 
             Rational.compare(semiconvergent, convergent_3) <= 0) or
            (Rational.compare(convergent_3, semiconvergent) <= 0 and 
             Rational.compare(semiconvergent, convergent_2) <= 0),
            "Semiconvergent should lie between consecutive convergents")

Note: ===== PERIOD DETECTION TESTS =====

Process called "test_periodic_detection":
    Note: Test detection of periodic continued fractions
    Let sqrt2_cf be Continued.create_sqrt_approximation(2, 20)
    UnitTest.assert(Continued.is_periodic(sqrt2_cf), "√2 continued fraction should be periodic")
    
    let sqrt2_period be Continued.get_period(sqrt2_cf)
    UnitTest.assert(Array.length(sqrt2_period) equals 1, "√2 period should have length 1")
    UnitTest.assert(sqrt2_period[0] equals 2, "√2 period should be [2]")
    
    Let rational_cf be Continued.create_from_rational(Rational.create_from_integers(22, 7))
    UnitTest.assert(not Continued.is_periodic(rational_cf), "Rational continued fractions should not be periodic")
    
    Let sqrt3_cf be Continued.create_sqrt_approximation(3, 15)
    UnitTest.assert(Continued.is_periodic(sqrt3_cf), "√3 continued fraction should be periodic")
    
    let sqrt3_period be Continued.get_period(sqrt3_cf)
    UnitTest.assert(Array.length(sqrt3_period) equals 2, "√3 period should have length 2")
    UnitTest.assert(sqrt3_period[0] equals 1 and sqrt3_period[1] equals 2, "√3 period should be [1, 2]")

Process called "test_purely_periodic":
    Note: Test purely periodic continued fractions
    let quadratic_irrationals be Continued.create_quadratic_irrational_examples()
    
    For i from 0 to (Array.length(quadratic_irrationals) - 1):
        Let qf be quadratic_irrationals[i]
        If Continued.is_purely_periodic(qf):
            Let period be Continued.get_period(qf)
            UnitTest.assert(Array.length(period) > 0, "Purely periodic CF should have non-empty period")
            
            Note: Check period repeats correctly
            Let full_coeffs be Continued.get_coefficients(qf)
            Let period_length be Array.length(period)
            For j from 0 to (period_length - 1):
                UnitTest.assert(full_coeffs[j] equals period[j], "Period should repeat from start")

Note: ===== COMPARISON TESTS =====

Process called "test_comparison":
    Note: Test continued fraction comparison
    Let a be Continued.create_from_coefficients([3, 7])      Note: 22/7 ≈ 3.142857
    Let b be Continued.create_from_coefficients([3, 7, 15])  Note: More accurate π approximation
    
    UnitTest.assert(Continued.compare(a, b) != 0, "Different continued fractions should not be equal")
    
    Let pi_cf_short be Continued.create_pi_approximation(3)
    let pi_cf_long be Continued.create_pi_approximation(10)
    
    Note: Both represent π, longer should be more accurate but represent same value
    Let pi_short_rational be Continued.to_rational(pi_cf_short)
    Let pi_long_rational be Continued.to_rational(pi_cf_long)
    
    Note: Compare truncated versions for equality
    Let pi_short_trunc be Continued.truncate(pi_cf_long, 3)
    assert_cf_equals(pi_cf_short, pi_short_trunc, "Truncated long π should equal short π")

Process called "test_equality":
    Note: Test continued fraction equality
    Let a be Continued.create_from_coefficients([3, 7, 15])
    let b be Continued.create_from_coefficients([3, 7, 15])
    Let c be Continued.create_from_coefficients([3, 7, 16])
    
    assert_cf_equals(a, b, "Identical coefficient arrays should be equal")
    UnitTest.assert(not Continued.equals(a, c), "Different coefficients should not be equal")
    
    Let from_rational be Continued.create_from_rational(Rational.create_from_integers(22, 7))
    Let from_coeffs be Continued.create_from_coefficients([3, 7])
    
    assert_cf_equals(from_rational, from_coeffs, "CF from rational should equal CF from coefficients")

Note: ===== CONVERSION TESTS =====

Process called "test_to_rational":
    Note: Test conversion back to rational numbers
    Let coeffs be [3, 7, 15, 1]
    Let cf be Continued.create_from_coefficients(coeffs)
    Let rational be Continued.to_rational(cf)
    
    Note: Verify conversion by recreating CF from rational
    Let cf_from_rational be Continued.create_from_rational(rational)
    assert_cf_equals(cf, cf_from_rational, "Round-trip conversion should preserve CF")
    
    Let simple_cf be Continued.create_from_coefficients([5])
    Let simple_rational be Continued.to_rational(simple_cf)
    assert_rational_equals(simple_rational, Rational.create_from_integers(5, 1), "Integer CF to rational")
    
    Let fraction_cf be Continued.create_from_coefficients([0, 7])
    Let fraction_rational be Continued.to_rational(fraction_cf)
    assert_rational_equals(fraction_rational, Rational.create_from_integers(1, 7), "Simple fraction CF to rational")

Process called "test_to_decimal":
    Note: Test conversion to decimal approximations
    Let context be create_default_context()
    
    Let pi_cf be Continued.create_pi_approximation(10)
    Let pi_decimal be Continued.to_decimal(pi_cf, 10)
    
    Let pi_string be BigDecimal.to_plain_string(pi_decimal)
    UnitTest.assert(pi_string.startsWith("3.14159"), "π decimal should start with 3.14159")
    
    Let golden_cf be Continued.create_golden_ratio(15)
    let golden_decimal be Continued.to_decimal(golden_cf, 10)
    
    let golden_string be BigDecimal.to_plain_string(golden_decimal)
    UnitTest.assert(golden_string.startsWith("1.61803"), "Golden ratio decimal should start with 1.61803")
    
    Let simple_cf be Continued.create_from_coefficients([2, 1, 4])
    Let simple_decimal be Continued.to_decimal(simple_cf, 8)
    
    Note: 2 + 1/(1 + 1/4) = 2 + 1/(5/4) = 2 + 4/5 = 2.8
    Let expected_simple be BigDecimal.create_from_string("2.8", context)
    UnitTest.assert(BigDecimal.equals_ignoring_scale(simple_decimal, expected_simple), "Simple CF to decimal")

Process called "test_to_string_representations":
    Note: Test various string representation formats
    Let cf be Continued.create_from_coefficients([3, 7, 15, 1, 292])
    
    assert_string_representation(cf, "[3; 7, 15, 1, 292]", "Standard bracket notation")
    
    Let mathematical_notation be Continued.to_mathematical_notation(cf)
    UnitTest.assert(mathematical_notation.contains("3 +"), "Mathematical notation should show addition")
    UnitTest.assert(mathematical_notation.contains("1/(7 +"), "Mathematical notation should show continued fraction")
    
    let latex_notation be Continued.to_latex(cf)
    UnitTest.assert(latex_notation.contains("\\cfrac"), "LaTeX notation should use continued fraction command")
    
    Let periodic_cf be Continued.create_sqrt_approximation(2, 10)
    Let periodic_string be Continued.to_string(periodic_cf)
    UnitTest.assert(periodic_string.contains("...") or periodic_string.contains("̄"), 
        "Periodic CF should indicate repetition")

Note: ===== SPECIAL PROPERTIES TESTS =====

Process called "test_mathematical_properties":
    Note: Test special mathematical properties of continued fractions
    Let golden_cf be Continued.create_golden_ratio(20)
    
    Note: Test that all coefficients of golden ratio are 1
    let golden_coeffs be Continued.get_coefficients(golden_cf)
    For i from 0 to (Array.length(golden_coeffs) - 1):
        UnitTest.assert(golden_coeffs[i] equals 1, "Golden ratio coefficient should be 1")
    
    Note: Test fibonacci sequence in golden ratio convergents
    Let golden_convergents be Continued.get_all_convergents(golden_cf)
    For i from 2 to (Array.length(golden_convergents) - 1):
        let curr_num be Rational.get_numerator(golden_convergents[i])
        Let prev_num be Rational.get_numerator(golden_convergents[i-1])
        let prev_prev_num be Rational.get_numerator(golden_convergents[i-2])
        
        Note: F(n) = F(n-1) + F(n-2) for Fibonacci sequence
        Let sum be BigInteger.add(prev_num, prev_prev_num)
        UnitTest.assert(BigInteger.equals(curr_num, sum), "Golden ratio numerators should follow Fibonacci sequence")

Process called "test_quadratic_irrational_properties":
    Note: Test properties specific to quadratic irrationals
    Let sqrt2_cf be Continued.create_sqrt_approximation(2, 20)
    
    UnitTest.assert(Continued.is_quadratic_irrational(sqrt2_cf), "√2 should be quadratic irrational")
    UnitTest.assert(Continued.is_periodic(sqrt2_cf), "√2 should be periodic")
    
    let discriminant be Continued.get_discriminant(sqrt2_cf)
    UnitTest.assert(discriminant equals 8, "√2 should have discriminant 8 (from x² - 2 = 0)")
    
    Let sqrt_non_square be Continued.create_sqrt_approximation(7, 15)
    UnitTest.assert(Continued.is_quadratic_irrational(sqrt_non_square), "√7 should be quadratic irrational")
    
    Let rational_cf be Continued.create_from_rational(Rational.create_from_integers(22, 7))
    UnitTest.assert(not Continued.is_quadratic_irrational(rational_cf), "Rational should not be quadratic irrational")

Note: ===== ACCURACY AND CONVERGENCE TESTS =====

Process called "test_convergence_rate":
    Note: Test rate of convergence for different continued fractions
    let context be create_default_context()
    
    Let pi_exact be BigDecimal.pi(100)
    Let pi_cf be Continued.create_pi_approximation(15)
    
    Note: Test that successive convergents get exponentially closer
    Let convergents be Continued.get_all_convergents(pi_cf)
    Let prev_error be BigDecimal.create_one(0)
    
    For i from 3 to (Array.length(convergents) - 1):
        Let convergent_decimal be BigDecimal.create_from_fraction(
            Rational.get_numerator(convergents[i]),
            Rational.get_denominator(convergents[i]),
            context
        )
        
        Let error be BigDecimal.abs(BigDecimal.subtract(convergent_decimal, pi_exact, context))
        
        Note: Error should generally decrease (with possible exceptions for very good coefficients)
        Let improvement_ratio be BigDecimal.divide(error, prev_error, context)
        UnitTest.assert(BigDecimal.compare(improvement_ratio, BigDecimal.create_one(0)) <= 0,
            "Error should generally decrease with higher order convergents")
        
        Set prev_error to error

Process called "test_best_approximation_theorem":
    Note: Test that convergents are best approximations for their denominator size
    Let context be create_default_context()
    let e_exact be BigDecimal.e(50)
    Let e_cf be Continued.create_e_approximation(8)
    
    let convergent_5 be Continued.get_convergent(e_cf, 5)
    Let conv_denominator be Rational.get_denominator(convergent_5)
    
    Note: Test that no other fraction with smaller denominator approximates e better
    Let denom_bound be BigInteger.to_integer(conv_denominator)
    
    Note: This is a theoretical test - in practice we'd sample some fractions
    Let test_better_found be false
    For test_num from 1 to 10:
        For test_den from 1 to (denom_bound - 1):
            Let test_fraction be Rational.create_from_integers(test_num, test_den)
            Let test_decimal be BigDecimal.create_from_fraction(
                Rational.get_numerator(test_fraction),
                Rational.get_denominator(test_fraction),
                context
            )
            
            Let test_error be BigDecimal.abs(BigDecimal.subtract(test_decimal, e_exact, context))
            Let convergent_decimal be BigDecimal.create_from_fraction(
                Rational.get_numerator(convergent_5),
                Rational.get_denominator(convergent_5),
                context
            )
            Let convergent_error be BigDecimal.abs(BigDecimal.subtract(convergent_decimal, e_exact, context))
            
            If BigDecimal.compare(test_error, convergent_error) < 0:
                Set test_better_found to true
    
    UnitTest.assert(not test_better_found, "Convergent should be best approximation for its denominator range")

Note: ===== ERROR HANDLING TESTS =====

Process called "test_error_handling":
    Note: Test error conditions and edge cases
    
    Note: Empty coefficient array should be handled
    Note: Invalid coefficients (negative except first) should be handled
    Note: Division by zero in operations should be handled
    
    Note: Test with very large coefficients
    Let large_coeffs be [1, 1000000, 1, 1000000]
    Let large_cf be Continued.create_from_coefficients(large_coeffs)
    Let large_rational be Continued.to_rational(large_cf)
    
    UnitTest.assert(not Rational.is_zero(large_rational), "Large coefficient CF should not be zero")
    
    Note: Test with very long continued fractions
    Let long_coeffs be Array.create_filled(100, 1)  Note: 100 ones
    let long_cf be Continued.create_from_coefficients(long_coeffs)
    let long_convergents be Continued.get_all_convergents(long_cf)
    
    UnitTest.assert(Array.length(long_convergents) equals 100, "Should handle long continued fractions")

Process called "test_precision_limits":
    Note: Test behavior at precision limits
    Let context be create_default_context()
    
    Note: Test with very high precision requirements
    let high_precision_pi be Continued.create_pi_approximation(50)
    let high_precision_decimal be Continued.to_decimal(high_precision_pi, 100)
    
    Let precision be BigDecimal.get_precision(high_precision_decimal)
    UnitTest.assert(precision >= 50, "Should maintain high precision in conversions")
    
    Note: Test with very small numbers
    let tiny_cf be Continued.create_from_decimal(BigDecimal.create_from_string("1e-50", context), 20)
    Let tiny_rational be Continued.to_rational(tiny_cf)
    
    UnitTest.assert(not Rational.is_zero(tiny_rational), "Should handle very small numbers")

Note: ===== TEST RUNNER =====

Process called "run_all_tests":
    Note: Executes all ContinuedFraction unit tests
    UnitTest.start_test_suite("ContinuedFraction Module Tests")
    
    Note: Construction tests
    UnitTest.run_test("Create from Coefficients", test_create_from_coefficients)
    UnitTest.run_test("Create from Rational", test_create_from_rational)
    UnitTest.run_test("Create from Decimal", test_create_from_decimal)
    UnitTest.run_test("Create Mathematical Constants", test_create_mathematical_constants)
    
    Note: Convergent calculation tests
    UnitTest.run_test("Convergent Calculation", test_convergent_calculation)
    UnitTest.run_test("Convergent Accuracy", test_convergent_accuracy)
    UnitTest.run_test("Convergent Properties", test_convergent_properties)
    
    Note: Arithmetic operation tests
    UnitTest.run_test("Addition", test_addition)
    UnitTest.run_test("Subtraction", test_subtraction)
    UnitTest.run_test("Multiplication", test_multiplication)
    UnitTest.run_test("Division", test_division)
    UnitTest.run_test("Reciprocal", test_reciprocal)
    
    Note: Truncation and approximation tests
    UnitTest.run_test("Truncation", test_truncation)
    UnitTest.run_test("Best Approximation", test_best_approximation)
    UnitTest.run_test("Semiconvergents", test_semiconvergents)
    
    Note: Period detection tests
    UnitTest.run_test("Periodic Detection", test_periodic_detection)
    UnitTest.run_test("Purely Periodic", test_purely_periodic)
    
    Note: Comparison tests
    UnitTest.run_test("Comparison", test_comparison)
    UnitTest.run_test("Equality", test_equality)
    
    Note: Conversion tests
    UnitTest.run_test("To Rational", test_to_rational)
    UnitTest.run_test("To Decimal", test_to_decimal)
    UnitTest.run_test("String Representations", test_to_string_representations)
    
    Note: Special properties tests
    UnitTest.run_test("Mathematical Properties", test_mathematical_properties)
    UnitTest.run_test("Quadratic Irrational Properties", test_quadratic_irrational_properties)
    
    Note: Accuracy and convergence tests
    UnitTest.run_test("Convergence Rate", test_convergence_rate)
    UnitTest.run_test("Best Approximation Theorem", test_best_approximation_theorem)
    
    Note: Error handling tests
    UnitTest.run_test("Error Handling", test_error_handling)
    UnitTest.run_test("Precision Limits", test_precision_limits)
    
    UnitTest.end_test_suite()