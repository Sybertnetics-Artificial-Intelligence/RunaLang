Note: ===== RUNA TEST RUNNER: MATH/PRECISION MODULES =====

Import "tests/unit/libraries/math/precision/biginteger_test" as BigIntegerTests
Import "tests/unit/libraries/math/precision/bigdecimal_test" as BigDecimalTests
Import "tests/unit/libraries/math/precision/rational_test" as RationalTests
Import "tests/unit/libraries/math/precision/interval_test" as IntervalTests
Import "tests/unit/libraries/math/precision/continued_test" as ContinuedTests
Import "dev/debug/testing/unit" as UnitTest

Note: ===== TEST SUITE CONFIGURATION =====

Type called "TestSuiteResults":
    Note: Aggregated results from all precision module tests
    total_tests as Integer
    passed_tests as Integer
    failed_tests as Integer
    execution_time_ms as Integer
    module_results as Dictionary[String, ModuleResult]

Type called "ModuleResult":
    Note: Individual module test results
    module_name as String
    tests_run as Integer
    tests_passed as Integer
    tests_failed as Integer
    execution_time_ms as Integer
    error_messages as Array[String]

Note: ===== UTILITY FUNCTIONS =====

Process called "initialize_test_environment":
    Note: Sets up testing environment for precision module tests
    UnitTest.set_verbose_mode(true)
    UnitTest.set_stop_on_first_failure(false)
    UnitTest.set_timeout_ms(300000)  Note: 5 minute timeout for precision tests
    UnitTest.initialize_performance_monitoring()

Process called "create_test_results" returns TestSuiteResults:
    Note: Creates empty test results structure
    Let results be TestSuiteResults.new()
    Set results.total_tests to 0
    Set results.passed_tests to 0
    Set results.failed_tests to 0
    Set results.execution_time_ms to 0
    Set results.module_results to Dictionary.create()
    Return results

Process called "update_results" that takes results as TestSuiteResults, module_name as String, module_result as ModuleResult:
    Note: Updates aggregate results with individual module results
    Set results.total_tests to results.total_tests + module_result.tests_run
    Set results.passed_tests to results.passed_tests + module_result.tests_passed
    Set results.failed_tests to results.failed_tests + module_result.tests_failed
    Set results.execution_time_ms to results.execution_time_ms + module_result.execution_time_ms
    Dictionary.set(results.module_results, module_name, module_result)

Process called "run_module_tests" that takes module_name as String, test_runner as Process returns ModuleResult:
    Note: Runs tests for a single module and captures results
    Let start_time be System.get_current_time_ms()
    
    UnitTest.print_header("Running " + module_name + " Module Tests")
    UnitTest.print_separator()
    
    Let initial_passed be UnitTest.get_total_passed_tests()
    Let initial_failed be UnitTest.get_total_failed_tests()
    Let initial_total be initial_passed + initial_failed
    
    Note: Run the module tests
    test_runner()
    
    Let final_passed be UnitTest.get_total_passed_tests()
    Let final_failed be UnitTest.get_total_failed_tests()
    Let final_total be final_passed + final_failed
    
    Let end_time be System.get_current_time_ms()
    
    Let module_result be ModuleResult.new()
    Set module_result.module_name to module_name
    Set module_result.tests_run to final_total - initial_total
    Set module_result.tests_passed to final_passed - initial_passed
    Set module_result.tests_failed to final_failed - initial_failed
    Set module_result.execution_time_ms to end_time - start_time
    Set module_result.error_messages to UnitTest.get_recent_error_messages()
    
    UnitTest.print_module_summary(module_result)
    UnitTest.print_separator()
    
    Return module_result

Note: ===== INDIVIDUAL MODULE TEST RUNNERS =====

Process called "run_biginteger_tests" returns ModuleResult:
    Note: Runs comprehensive BigInteger module tests
    Return run_module_tests("BigInteger", BigIntegerTests.run_all_tests)

Process called "run_bigdecimal_tests" returns ModuleResult:
    Note: Runs comprehensive BigDecimal module tests
    Return run_module_tests("BigDecimal", BigDecimalTests.run_all_tests)

Process called "run_rational_tests" returns ModuleResult:
    Note: Runs comprehensive Rational module tests
    Return run_module_tests("Rational", RationalTests.run_all_tests)

Process called "run_interval_tests" returns ModuleResult:
    Note: Runs comprehensive Interval module tests  
    Return run_module_tests("Interval", IntervalTests.run_all_tests)

Process called "run_continued_tests" returns ModuleResult:
    Note: Runs comprehensive ContinuedFraction module tests
    Return run_module_tests("ContinuedFraction", ContinuedTests.run_all_tests)

Note: ===== INTEGRATION TESTS =====

Process called "run_integration_tests" returns ModuleResult:
    Note: Tests integration between precision modules
    Let start_time be System.get_current_time_ms()
    
    UnitTest.print_header("Running Precision Module Integration Tests")
    UnitTest.print_separator()
    
    Let initial_passed be UnitTest.get_total_passed_tests()
    Let initial_failed be UnitTest.get_total_failed_tests()
    
    Note: Test BigInteger <-> BigDecimal integration
    UnitTest.run_test("BigInteger BigDecimal Integration", test_biginteger_bigdecimal_integration)
    
    Note: Test BigDecimal <-> Rational integration  
    UnitTest.run_test("BigDecimal Rational Integration", test_bigdecimal_rational_integration)
    
    Note: Test Rational <-> ContinuedFraction integration
    UnitTest.run_test("Rational ContinuedFraction Integration", test_rational_continued_integration)
    
    Note: Test Interval <-> BigDecimal integration
    UnitTest.run_test("Interval BigDecimal Integration", test_interval_bigdecimal_integration)
    
    Note: Test cross-module precision consistency
    UnitTest.run_test("Cross-Module Precision Consistency", test_cross_module_precision)
    
    Note: Test performance across modules
    UnitTest.run_test("Cross-Module Performance", test_cross_module_performance)
    
    Let final_passed be UnitTest.get_total_passed_tests()
    Let final_failed be UnitTest.get_total_failed_tests()
    Let end_time be System.get_current_time_ms()
    
    Let integration_result be ModuleResult.new()
    Set integration_result.module_name to "Integration Tests"
    Set integration_result.tests_run to (final_passed + final_failed) - (initial_passed + initial_failed)
    Set integration_result.tests_passed to final_passed - initial_passed
    Set integration_result.tests_failed to final_failed - initial_failed
    Set integration_result.execution_time_ms to end_time - start_time
    Set integration_result.error_messages to UnitTest.get_recent_error_messages()
    
    UnitTest.print_module_summary(integration_result)
    UnitTest.print_separator()
    
    Return integration_result

Note: ===== INTEGRATION TEST IMPLEMENTATIONS =====

Process called "test_biginteger_bigdecimal_integration":
    Note: Test seamless conversion between BigInteger and BigDecimal
    Import "math/precision/biginteger" as BigInteger
    Import "math/precision/bigdecimal" as BigDecimal
    
    Let large_integer be BigInteger.create_from_string("123456789012345678901234567890", 10)
    Let decimal_from_int be BigDecimal.create_from_biginteger(large_integer, 5)
    
    Let unscaled_back be BigDecimal.get_unscaled_value(decimal_from_int)
    UnitTest.assert(BigInteger.equals(unscaled_back, large_integer), "Round-trip BigInteger -> BigDecimal -> BigInteger conversion")
    
    let decimal_value be BigDecimal.create_from_string("98765.43210", BigDecimal.create_default_context())
    let integer_part be BigDecimal.to_integer(decimal_value, BigDecimal.RoundingMode.DOWN)
    UnitTest.assert(integer_part equals 98765, "BigDecimal to integer conversion")

Process called "test_bigdecimal_rational_integration":
    Note: Test conversion between BigDecimal and Rational with precision preservation
    Import "math/precision/bigdecimal" as BigDecimal
    Import "math/precision/rational" as Rational
    
    Let context be BigDecimal.create_default_context()
    let decimal_value be BigDecimal.create_from_string("0.125", context)
    
    Note: Convert to rational and back
    let fraction_array be BigDecimal.to_fraction(decimal_value)
    let rational_value be Rational.create_from_bigintegers(fraction_array[0], fraction_array[1])
    let decimal_back be BigDecimal.create_from_fraction(
        Rational.get_numerator(rational_value),
        Rational.get_denominator(rational_value),
        context
    )
    
    UnitTest.assert(BigDecimal.equals_ignoring_scale(decimal_value, decimal_back), 
        "Round-trip BigDecimal -> Rational -> BigDecimal conversion")

Process called "test_rational_continued_integration":
    Note: Test conversion between Rational and ContinuedFraction
    Import "math/precision/rational" as Rational  
    Import "math/precision/continued" as Continued
    
    let rational_value be Rational.create_from_integers(22, 7)  Note: π approximation
    let continued_fraction be Continued.create_from_rational(rational_value)
    let rational_back be Continued.to_rational(continued_fraction)
    
    UnitTest.assert(Rational.equals(rational_value, rational_back),
        "Round-trip Rational -> ContinuedFraction -> Rational conversion")
    
    Note: Test that well-known constants have expected CF representations
    let golden_ratio_cf be Continued.create_golden_ratio(10)
    let golden_rational be Continued.to_rational(golden_ratio_cf)
    let golden_double be Rational.to_double(golden_rational)
    
    UnitTest.assert(golden_double > 1.618 and golden_double < 1.619, 
        "Golden ratio from continued fraction should be approximately 1.618")

Process called "test_interval_bigdecimal_integration":
    Note: Test that Interval operations work correctly with BigDecimal endpoints
    Import "math/precision/interval" as Interval
    Import "math/precision/bigdecimal" as BigDecimal
    
    let context be BigDecimal.create_default_context()
    
    let high_precision_a be BigDecimal.create_from_string("1.234567890123456789012345", context)
    let high_precision_b be BigDecimal.create_from_string("2.345678901234567890123456", context)
    
    let precise_interval be Interval.create_from_endpoints(high_precision_a, high_precision_b)
    let interval_width be Interval.width(precise_interval)
    let interval_midpoint be Interval.midpoint(precise_interval)
    
    Note: Verify high precision is maintained in interval operations
    UnitTest.assert(BigDecimal.get_precision(interval_width) >= 20, 
        "Interval operations should preserve high precision")
    UnitTest.assert(BigDecimal.get_precision(interval_midpoint) >= 20,
        "Interval midpoint should preserve high precision")

Process called "test_cross_module_precision":
    Note: Test that precision is consistently maintained across module boundaries
    Import "math/precision/biginteger" as BigInteger
    Import "math/precision/bigdecimal" as BigDecimal
    Import "math/precision/rational" as Rational
    
    let context be BigDecimal.create_default_context()
    Set context.precision to 50
    
    Note: Start with high-precision BigInteger
    let precise_integer be BigInteger.create_from_string(
        "12345678901234567890123456789012345678901234567890", 10)
    
    Note: Convert through various modules
    let precise_decimal be BigDecimal.create_from_biginteger(precise_integer, 25)
    let fraction_array be BigDecimal.to_fraction(precise_decimal)
    let precise_rational be Rational.create_from_bigintegers(fraction_array[0], fraction_array[1])
    let final_decimal be BigDecimal.create_from_fraction(
        Rational.get_numerator(precise_rational),
        Rational.get_denominator(precise_rational),
        context
    )
    
    Note: Verify precision is maintained throughout the chain
    UnitTest.assert(BigDecimal.get_precision(final_decimal) >= 40,
        "Precision should be maintained through cross-module conversions")

Process called "test_cross_module_performance":
    Note: Test performance characteristics across modules
    let start_time be System.get_current_time_ms()
    
    Note: Run a mixed workload across all precision modules
    For i from 1 to 100:
        Note: BigInteger operations
        let big_int_a be BigInteger.create_from_integer(i * 12345)
        let big_int_b be BigInteger.create_from_integer(i * 67890)
        let big_int_product be BigInteger.multiply(big_int_a, big_int_b)
        
        Note: BigDecimal operations
        let context be BigDecimal.create_default_context()
        let decimal_a be BigDecimal.create_from_integer(i, 3)
        let decimal_b be BigDecimal.create_from_string("3.14159", context)
        let decimal_product be BigDecimal.multiply(decimal_a, decimal_b, context)
        
        Note: Rational operations
        let rational_a be Rational.create_from_integers(i, i + 1)
        let rational_b be Rational.create_from_integers(i + 2, i + 3)  
        let rational_sum be Rational.add(rational_a, rational_b)
    
    let end_time be System.get_current_time_ms()
    let execution_time be end_time - start_time
    
    UnitTest.assert(execution_time < 10000, "Cross-module operations should complete within 10 seconds")

Note: ===== STRESS TESTS =====

Process called "run_stress_tests" returns ModuleResult:
    Note: Runs stress tests for precision modules with large data and long operations
    Let start_time be System.get_current_time_ms()
    
    UnitTest.print_header("Running Precision Module Stress Tests")
    UnitTest.print_separator()
    
    Let initial_passed be UnitTest.get_total_passed_tests()
    Let initial_failed be UnitTest.get_total_failed_tests()
    
    Note: Memory stress tests
    UnitTest.run_test("Large Number Memory Stress", test_large_number_memory_stress)
    
    Note: Computation stress tests
    UnitTest.run_test("High Precision Computation Stress", test_high_precision_computation_stress)
    
    Note: Long-running operation tests
    UnitTest.run_test("Long Running Operations", test_long_running_operations)
    
    Note: Edge case stress tests
    UnitTest.run_test("Edge Case Stress", test_edge_case_stress)
    
    Let final_passed be UnitTest.get_total_passed_tests()
    Let final_failed be UnitTest.get_total_failed_tests()
    Let end_time be System.get_current_time_ms()
    
    Let stress_result be ModuleResult.new()
    Set stress_result.module_name to "Stress Tests"
    Set stress_result.tests_run to (final_passed + final_failed) - (initial_passed + initial_failed)
    Set stress_result.tests_passed to final_passed - initial_passed
    Set stress_result.tests_failed to final_failed - initial_failed
    Set stress_result.execution_time_ms to end_time - start_time
    Set stress_result.error_messages to UnitTest.get_recent_error_messages()
    
    UnitTest.print_module_summary(stress_result)
    UnitTest.print_separator()
    
    Return stress_result

Note: ===== STRESS TEST IMPLEMENTATIONS =====

Process called "test_large_number_memory_stress":
    Note: Test handling of very large numbers without memory issues
    Import "math/precision/biginteger" as BigInteger
    Import "math/precision/bigdecimal" as BigDecimal
    
    Note: Create extremely large BigInteger (10^10000)
    Let ten_power_10000 be BigInteger.power(BigInteger.create_from_integer(10), 10000)
    UnitTest.assert(not BigInteger.is_zero(ten_power_10000), "Extremely large BigInteger should not be zero")
    
    Note: Test BigDecimal with very high precision
    let context be BigDecimal.create_default_context()
    Set context.precision to 1000
    
    Let pi_1000_digits be BigDecimal.pi(1000)
    UnitTest.assert(BigDecimal.get_precision(pi_1000_digits) >= 900, 
        "Should handle 1000-digit precision calculations")

Process called "test_high_precision_computation_stress":
    Note: Test computationally intensive high-precision operations
    Import "math/precision/bigdecimal" as BigDecimal
    Import "math/precision/continued" as Continued
    
    let context be BigDecimal.create_default_context()
    Set context.precision to 200
    
    Note: Compute e to 200 digits
    let e_200 be BigDecimal.e(200)
    
    Note: Compute π to 200 digits
    let pi_200 be BigDecimal.pi(200)
    
    Note: Compute high-precision continued fraction
    let pi_cf_long be Continued.create_pi_approximation(100)
    let pi_convergent_50 be Continued.get_convergent(pi_cf_long, 50)
    
    UnitTest.assert(not Rational.is_zero(pi_convergent_50), "High-order convergent should not be zero")

Process called "test_long_running_operations":
    Note: Test operations that take significant time to complete
    Import "math/precision/biginteger" as BigInteger
    
    let start_time be System.get_current_time_ms()
    
    Note: Large prime testing
    let large_candidate be BigInteger.create_from_string("982451653", 10)  Note: Known prime
    let is_prime be BigInteger.is_prime_miller_rabin(large_candidate, 10)
    UnitTest.assert(is_prime, "Large prime should be detected correctly")
    
    Note: Large number factorization attempt (should be fast for known composites)
    let composite be BigInteger.multiply(
        BigInteger.create_from_integer(12345),
        BigInteger.create_from_integer(67890)
    )
    let factors be BigInteger.trial_division_factorize(composite, 100000)
    UnitTest.assert(Array.length(factors) >= 2, "Should find factors of composite number")
    
    let end_time be System.get_current_time_ms()
    UnitTest.assert(end_time - start_time < 30000, "Long-running operations should complete within 30 seconds")

Process called "test_edge_case_stress":
    Note: Test edge cases and boundary conditions across all modules
    Import "math/precision/biginteger" as BigInteger
    Import "math/precision/bigdecimal" as BigDecimal
    Import "math/precision/rational" as Rational
    Import "math/precision/interval" as Interval
    
    let context be BigDecimal.create_default_context()
    
    Note: Test operations near zero
    let tiny_decimal be BigDecimal.create_from_string("1e-100", context)
    let tiny_squared be BigDecimal.multiply(tiny_decimal, tiny_decimal, context)
    UnitTest.assert(not BigDecimal.is_zero(tiny_squared), "Very small number operations should work")
    
    Note: Test operations with maximum precision
    Set context.precision to 1000
    let max_precision_number be BigDecimal.create_from_string("1.23456789", context)
    let high_precision_result be BigDecimal.square_root(max_precision_number, context)
    UnitTest.assert(BigDecimal.get_precision(high_precision_result) >= 500,
        "High precision operations should maintain significant precision")
    
    Note: Test interval operations with extreme ranges
    let huge_interval be Interval.create_from_endpoints(
        BigDecimal.create_from_string("-1e50", context),
        BigDecimal.create_from_string("1e50", context)
    )
    UnitTest.assert(not Interval.is_empty(huge_interval), "Huge intervals should be valid")

Note: ===== REPORTING FUNCTIONS =====

Process called "print_detailed_results" that takes results as TestSuiteResults:
    Note: Prints comprehensive test results with detailed breakdown
    UnitTest.print_header("PRECISION MODULE TEST SUITE RESULTS")
    UnitTest.print_separator()
    
    UnitTest.print_line("Total Tests Run: " + Integer.to_string(results.total_tests))
    UnitTest.print_line("Tests Passed: " + Integer.to_string(results.passed_tests))
    UnitTest.print_line("Tests Failed: " + Integer.to_string(results.failed_tests))
    
    let success_rate be (results.passed_tests * 100) / results.total_tests
    UnitTest.print_line("Success Rate: " + Integer.to_string(success_rate) + "%")
    UnitTest.print_line("Total Execution Time: " + Integer.to_string(results.execution_time_ms) + "ms")
    
    UnitTest.print_separator()
    UnitTest.print_line("MODULE BREAKDOWN:")
    UnitTest.print_separator()
    
    let module_names be Dictionary.get_keys(results.module_results)
    For i from 0 to (Array.length(module_names) - 1):
        let module_name be module_names[i]
        let module_result be Dictionary.get(results.module_results, module_name)
        
        UnitTest.print_line(module_name + ":")
        UnitTest.print_line("  Tests: " + Integer.to_string(module_result.tests_run) +
                           " | Passed: " + Integer.to_string(module_result.tests_passed) +
                           " | Failed: " + Integer.to_string(module_result.tests_failed))
        UnitTest.print_line("  Time: " + Integer.to_string(module_result.execution_time_ms) + "ms")
        
        If Array.length(module_result.error_messages) > 0:
            UnitTest.print_line("  Errors:")
            For j from 0 to (Array.length(module_result.error_messages) - 1):
                UnitTest.print_line("    - " + module_result.error_messages[j])
        
        UnitTest.print_line("")

Process called "generate_test_report" that takes results as TestSuiteResults returns String:
    Note: Generates formatted test report for external consumption
    let report be "# Precision Module Test Results\n\n"
    
    Set report to report + "## Summary\n"
    Set report to report + "- **Total Tests:** " + Integer.to_string(results.total_tests) + "\n"
    Set report to report + "- **Passed:** " + Integer.to_string(results.passed_tests) + "\n"
    Set report to report + "- **Failed:** " + Integer.to_string(results.failed_tests) + "\n"
    
    let success_rate be (results.passed_tests * 100) / results.total_tests
    Set report to report + "- **Success Rate:** " + Integer.to_string(success_rate) + "%\n"
    Set report to report + "- **Execution Time:** " + Integer.to_string(results.execution_time_ms) + "ms\n\n"
    
    Set report to report + "## Module Results\n\n"
    
    let module_names be Dictionary.get_keys(results.module_results)
    For i from 0 to (Array.length(module_names) - 1):
        let module_name be module_names[i]
        Let module_result be Dictionary.get(results.module_results, module_name)
        
        Set report to report + "### " + module_name + "\n"
        Set report to report + "- Tests Run: " + Integer.to_string(module_result.tests_run) + "\n"
        Set report to report + "- Passed: " + Integer.to_string(module_result.tests_passed) + "\n"
        Set report to report + "- Failed: " + Integer.to_string(module_result.tests_failed) + "\n"
        Set report to report + "- Execution Time: " + Integer.to_string(module_result.execution_time_ms) + "ms\n\n"
    
    Return report

Note: ===== MAIN TEST RUNNER =====

Process called "run_all_precision_tests" returns TestSuiteResults:
    Note: Executes all precision module tests with comprehensive reporting
    
    UnitTest.print_title("RUNA PRECISION MODULE TEST SUITE")
    UnitTest.print_title("Comprehensive Testing of Arbitrary Precision Mathematics")
    UnitTest.print_separator()
    
    initialize_test_environment()
    
    Let results be create_test_results()
    Let suite_start_time be System.get_current_time_ms()
    
    Note: Run individual module tests
    update_results(results, "BigInteger", run_biginteger_tests())
    update_results(results, "BigDecimal", run_bigdecimal_tests())  
    update_results(results, "Rational", run_rational_tests())
    update_results(results, "Interval", run_interval_tests())
    update_results(results, "ContinuedFraction", run_continued_tests())
    
    Note: Run integration tests
    update_results(results, "Integration", run_integration_tests())
    
    Note: Run stress tests
    update_results(results, "Stress", run_stress_tests())
    
    let suite_end_time be System.get_current_time_ms()
    Set results.execution_time_ms to suite_end_time - suite_start_time
    
    Note: Print comprehensive results
    print_detailed_results(results)
    
    Note: Generate and save test report
    let report be generate_test_report(results)
    File.write_text("precision_test_results.md", report)
    
    UnitTest.print_separator()
    If results.failed_tests equals 0:
        UnitTest.print_success("ALL PRECISION MODULE TESTS PASSED!")
    Otherwise:
        UnitTest.print_warning("Some tests failed. See detailed results above.")
    
    UnitTest.print_separator()
    
    Return results

Note: ===== QUICK TEST RUNNER =====

Process called "run_quick_precision_tests" returns TestSuiteResults:
    Note: Runs a subset of tests for quick validation during development
    
    UnitTest.print_title("RUNA PRECISION MODULE QUICK TEST SUITE")
    UnitTest.print_separator()
    
    initialize_test_environment()
    UnitTest.set_quick_mode(true)  Note: Skip slow tests
    
    Let results be create_test_results()
    Let suite_start_time be System.get_current_time_ms()
    
    Note: Run core functionality tests only
    update_results(results, "BigInteger-Quick", run_biginteger_tests())
    update_results(results, "BigDecimal-Quick", run_bigdecimal_tests())
    update_results(results, "Rational-Quick", run_rational_tests())
    
    Note: Skip interval and continued fraction tests in quick mode
    Note: Skip stress tests in quick mode
    
    let suite_end_time be System.get_current_time_ms()
    Set results.execution_time_ms to suite_end_time - suite_start_time
    
    UnitTest.print_line("Quick Test Results:")
    UnitTest.print_line("Total: " + Integer.to_string(results.total_tests) + 
                       " | Passed: " + Integer.to_string(results.passed_tests) + 
                       " | Failed: " + Integer.to_string(results.failed_tests))
    UnitTest.print_line("Time: " + Integer.to_string(results.execution_time_ms) + "ms")
    
    Return results