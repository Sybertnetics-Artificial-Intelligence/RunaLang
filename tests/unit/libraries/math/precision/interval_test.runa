Note: ===== RUNA UNIT TESTS: MATH/PRECISION/INTERVAL =====

Import "math/precision/interval" as Interval
Import "math/precision/bigdecimal" as BigDecimal
Import "dev/debug/testing/unit" as UnitTest

Note: ===== TEST DATA GENERATORS =====

Process called "create_test_intervals" returns Array[Interval.Interval]:
    Note: Creates array of test Interval values for comprehensive testing
    Let context be create_default_context()
    
    Let test_values be Array.create([
        Interval.create_from_endpoints(
            BigDecimal.create_from_string("1.0", context),
            BigDecimal.create_from_string("2.0", context)
        ),
        Interval.create_from_endpoints(
            BigDecimal.create_from_string("-1.0", context),
            BigDecimal.create_from_string("1.0", context)
        ),
        Interval.create_from_endpoints(
            BigDecimal.create_from_string("0.0", context),
            BigDecimal.create_from_string("0.0", context)
        ),  Note: Degenerate interval (single point)
        Interval.create_from_midpoint_radius(
            BigDecimal.create_from_string("5.0", context),
            BigDecimal.create_from_string("0.1", context)
        ),
        Interval.create_from_string("[3.14, 3.15]"),
        Interval.create_from_string("(-∞, 0]"),
        Interval.create_from_string("[0, +∞)"),
        Interval.create_from_string("(-∞, +∞)"),  Note: Real number line
        Interval.create_from_uncertainty(
            BigDecimal.create_from_string("9.81", context),
            BigDecimal.create_from_string("0.01", context)
        )
    ])
    Return test_values

Process called "create_default_context" returns BigDecimal.MathContext:
    Note: Creates standard math context for BigDecimal operations
    Let context be BigDecimal.MathContext.new()
    Set context.precision to 34
    Set context.rounding_mode to BigDecimal.RoundingMode.HALF_EVEN
    Set context.exact_arithmetic to false
    Return context

Process called "create_special_intervals" returns Array[Interval.Interval]:
    Note: Creates intervals for special case testing
    Let context be create_default_context()
    
    Let test_values be Array.create([
        Interval.create_empty(),  Note: Empty interval
        Interval.create_full_real_line(),  Note: (-∞, +∞)
        Interval.create_positive_reals(),  Note: (0, +∞)
        Interval.create_negative_reals(),  Note: (-∞, 0)
        Interval.create_unit_interval(),   Note: [0, 1]
        Interval.create_from_endpoints(
            BigDecimal.create_from_string("1.0", context),
            BigDecimal.create_from_string("1.0", context)
        )  Note: Single point interval
    ])
    Return test_values

Note: ===== ASSERTION HELPERS =====

Process called "assert_interval_equals" that takes actual as Interval.Interval, expected as Interval.Interval, message as String:
    Note: Asserts interval equality using endpoint comparison
    Let are_equal be Interval.equals(actual, expected)
    UnitTest.assert(are_equal, message + " - Expected: " + Interval.to_string(expected) + ", Actual: " + Interval.to_string(actual))

Process called "assert_interval_contains" that takes interval as Interval.Interval, value as BigDecimal.BigDecimal, message as String:
    Note: Asserts that interval contains the specified value
    Let contains be Interval.contains_point(interval, value)
    UnitTest.assert(contains, message + " - Interval " + Interval.to_string(interval) + " should contain " + BigDecimal.to_plain_string(value))

Process called "assert_interval_not_contains" that takes interval as Interval.Interval, value as BigDecimal.BigDecimal, message as String:
    Note: Asserts that interval does not contain the specified value
    Let contains be Interval.contains_point(interval, value)
    UnitTest.assert(not contains, message + " - Interval " + Interval.to_string(interval) + " should not contain " + BigDecimal.to_plain_string(value))

Process called "assert_interval_properties" that takes interval as Interval.Interval, expected_width as BigDecimal.BigDecimal, expected_midpoint as BigDecimal.BigDecimal, message as String:
    Note: Asserts interval width and midpoint properties
    Let actual_width be Interval.width(interval)
    Let actual_midpoint be Interval.midpoint(interval)
    
    Let width_equal be BigDecimal.equals_ignoring_scale(actual_width, expected_width)
    Let midpoint_equal be BigDecimal.equals_ignoring_scale(actual_midpoint, expected_midpoint)
    
    UnitTest.assert(width_equal and midpoint_equal, 
        message + " - Expected width: " + BigDecimal.to_plain_string(expected_width) + 
        ", midpoint: " + BigDecimal.to_plain_string(expected_midpoint) +
        ", Actual width: " + BigDecimal.to_plain_string(actual_width) + 
        ", midpoint: " + BigDecimal.to_plain_string(actual_midpoint))

Process called "assert_string_representation" that takes interval as Interval.Interval, expected as String, message as String:
    Note: Asserts string representation matches expected
    Let actual be Interval.to_string(interval)
    UnitTest.assert(actual equals expected, message + " - Expected: '" + expected + "', Actual: '" + actual + "'")

Note: ===== CONSTRUCTION TESTS =====

Process called "test_create_from_endpoints":
    Note: Test Interval creation from endpoint values
    Let context be create_default_context()
    
    Let closed_interval be Interval.create_from_endpoints(
        BigDecimal.create_from_string("1.0", context),
        BigDecimal.create_from_string("3.0", context)
    )
    assert_string_representation(closed_interval, "[1.0, 3.0]", "Closed interval from endpoints")
    
    Let single_point be Interval.create_from_endpoints(
        BigDecimal.create_from_string("2.5", context),
        BigDecimal.create_from_string("2.5", context)
    )
    UnitTest.assert(Interval.is_degenerate(single_point), "Single point interval should be degenerate")
    
    Let negative_interval be Interval.create_from_endpoints(
        BigDecimal.create_from_string("-5.0", context),
        BigDecimal.create_from_string("-2.0", context)
    )
    assert_string_representation(negative_interval, "[-5.0, -2.0]", "Negative interval from endpoints")

Process called "test_create_from_midpoint_radius":
    Note: Test Interval creation from midpoint and radius
    Let context be create_default_context()
    
    Let interval be Interval.create_from_midpoint_radius(
        BigDecimal.create_from_string("5.0", context),
        BigDecimal.create_from_string("1.0", context)
    )
    assert_string_representation(interval, "[4.0, 6.0]", "Interval from midpoint and radius")
    
    Let expected_width be BigDecimal.create_from_string("2.0", context)
    Let expected_midpoint be BigDecimal.create_from_string("5.0", context)
    assert_interval_properties(interval, expected_width, expected_midpoint, "Midpoint-radius interval properties")
    
    Let zero_radius be Interval.create_from_midpoint_radius(
        BigDecimal.create_from_string("3.0", context),
        BigDecimal.create_zero(1)
    )
    UnitTest.assert(Interval.is_degenerate(zero_radius), "Zero radius should create degenerate interval")

Process called "test_create_from_string":
    Note: Test Interval creation from string representations
    Let closed_interval be Interval.create_from_string("[1.5, 2.5]")
    assert_string_representation(closed_interval, "[1.5, 2.5]", "Closed interval string parsing")
    
    Let open_interval be Interval.create_from_string("(0, 1)")
    assert_string_representation(open_interval, "(0, 1)", "Open interval string parsing")
    
    Let half_open_left be Interval.create_from_string("(2, 5]")
    assert_string_representation(half_open_left, "(2, 5]", "Half-open left interval string parsing")
    
    Let half_open_right be Interval.create_from_string("[3, 7)")
    assert_string_representation(half_open_right, "[3, 7)", "Half-open right interval string parsing")
    
    Let infinite_left be Interval.create_from_string("(-∞, 0]")
    UnitTest.assert(Interval.is_left_unbounded(infinite_left), "Left infinite interval should be left unbounded")
    
    Let infinite_right be Interval.create_from_string("[0, +∞)")
    UnitTest.assert(Interval.is_right_unbounded(infinite_right), "Right infinite interval should be right unbounded")
    
    Let full_real_line be Interval.create_from_string("(-∞, +∞)")
    UnitTest.assert(Interval.is_unbounded(full_real_line), "Full real line should be unbounded")

Process called "test_create_from_uncertainty":
    Note: Test Interval creation from measurement with uncertainty
    Let context be create_default_context()
    
    Let measurement be Interval.create_from_uncertainty(
        BigDecimal.create_from_string("9.81", context),
        BigDecimal.create_from_string("0.05", context)
    )
    Note: 9.81 ± 0.05 should be [9.76, 9.86]
    assert_string_representation(measurement, "[9.76, 9.86]", "Measurement with uncertainty")
    
    Let precise_measurement be Interval.create_from_uncertainty(
        BigDecimal.create_from_string("100.0", context),
        BigDecimal.create_zero(2)
    )
    UnitTest.assert(Interval.is_degenerate(precise_measurement), "Zero uncertainty should create degenerate interval")

Process called "test_create_special_intervals":
    Note: Test creation of special interval types
    Let empty be Interval.create_empty()
    UnitTest.assert(Interval.is_empty(empty), "Empty interval should be empty")
    
    Let full_real be Interval.create_full_real_line()
    UnitTest.assert(Interval.is_unbounded(full_real), "Full real line should be unbounded")
    
    Let unit_interval be Interval.create_unit_interval()
    assert_string_representation(unit_interval, "[0, 1]", "Unit interval")
    
    Let positive_reals be Interval.create_positive_reals()
    UnitTest.assert(Interval.is_right_unbounded(positive_reals), "Positive reals should be right unbounded")
    
    Let negative_reals be Interval.create_negative_reals()
    UnitTest.assert(Interval.is_left_unbounded(negative_reals), "Negative reals should be left unbounded")

Note: ===== BASIC PROPERTY TESTS =====

Process called "test_interval_properties":
    Note: Test basic interval properties (width, midpoint, bounds)
    Let context be create_default_context()
    
    Let interval be Interval.create_from_endpoints(
        BigDecimal.create_from_string("2.0", context),
        BigDecimal.create_from_string("8.0", context)
    )
    
    Let width be Interval.width(interval)
    Let expected_width be BigDecimal.create_from_string("6.0", context)
    UnitTest.assert(BigDecimal.equals_ignoring_scale(width, expected_width), "Interval width calculation")
    
    Let midpoint be Interval.midpoint(interval)
    Let expected_midpoint be BigDecimal.create_from_string("5.0", context)
    UnitTest.assert(BigDecimal.equals_ignoring_scale(midpoint, expected_midpoint), "Interval midpoint calculation")
    
    Let lower_bound be Interval.lower_bound(interval)
    Let expected_lower be BigDecimal.create_from_string("2.0", context)
    UnitTest.assert(BigDecimal.equals_ignoring_scale(lower_bound, expected_lower), "Interval lower bound")
    
    Let upper_bound be Interval.upper_bound(interval)
    Let expected_upper be BigDecimal.create_from_string("8.0", context)
    UnitTest.assert(BigDecimal.equals_ignoring_scale(upper_bound, expected_upper), "Interval upper bound")

Process called "test_interval_classification":
    Note: Test interval type classification
    Let context be create_default_context()
    
    Let point_interval be Interval.create_from_endpoints(
        BigDecimal.create_from_string("3.0", context),
        BigDecimal.create_from_string("3.0", context)
    )
    UnitTest.assert(Interval.is_degenerate(point_interval), "Point interval should be degenerate")
    UnitTest.assert(not Interval.is_empty(point_interval), "Point interval should not be empty")
    
    Let proper_interval be Interval.create_from_endpoints(
        BigDecimal.create_from_string("1.0", context),
        BigDecimal.create_from_string("2.0", context)
    )
    UnitTest.assert(not Interval.is_degenerate(proper_interval), "Proper interval should not be degenerate")
    UnitTest.assert(Interval.is_bounded(proper_interval), "Finite interval should be bounded")
    
    Let empty_interval be Interval.create_empty()
    UnitTest.assert(Interval.is_empty(empty_interval), "Empty interval should be empty")
    UnitTest.assert(Interval.is_bounded(empty_interval), "Empty interval should be bounded")

Process called "test_containment":
    Note: Test point and interval containment
    Let context be create_default_context()
    
    Let interval be Interval.create_from_string("[1.0, 5.0]")
    
    assert_interval_contains(interval, BigDecimal.create_from_string("1.0", context), "Lower bound should be contained")
    assert_interval_contains(interval, BigDecimal.create_from_string("3.0", context), "Interior point should be contained")
    assert_interval_contains(interval, BigDecimal.create_from_string("5.0", context), "Upper bound should be contained")
    
    assert_interval_not_contains(interval, BigDecimal.create_from_string("0.5", context), "Point below interval should not be contained")
    assert_interval_not_contains(interval, BigDecimal.create_from_string("5.5", context), "Point above interval should not be contained")
    
    Let open_interval be Interval.create_from_string("(1.0, 5.0)")
    assert_interval_not_contains(open_interval, BigDecimal.create_from_string("1.0", context), "Open interval should not contain lower bound")
    assert_interval_not_contains(open_interval, BigDecimal.create_from_string("5.0", context), "Open interval should not contain upper bound")
    assert_interval_contains(open_interval, BigDecimal.create_from_string("3.0", context), "Open interval should contain interior points")

Process called "test_interval_containment":
    Note: Test interval-to-interval containment
    Let outer be Interval.create_from_string("[0.0, 10.0]")
    Let inner be Interval.create_from_string("[2.0, 8.0]")
    Let overlapping be Interval.create_from_string("[5.0, 15.0]")
    Let disjoint be Interval.create_from_string("[15.0, 20.0]")
    
    UnitTest.assert(Interval.contains_interval(outer, inner), "Outer interval should contain inner interval")
    UnitTest.assert(not Interval.contains_interval(inner, outer), "Inner interval should not contain outer interval")
    UnitTest.assert(not Interval.contains_interval(outer, overlapping), "Overlapping interval should not be contained")
    UnitTest.assert(not Interval.contains_interval(outer, disjoint), "Disjoint interval should not be contained")
    
    UnitTest.assert(Interval.contains_interval(outer, outer), "Interval should contain itself")

Note: ===== ARITHMETIC OPERATION TESTS =====

Process called "test_interval_addition":
    Note: Test interval arithmetic addition
    Let a be Interval.create_from_string("[1.0, 2.0]")
    Let b be Interval.create_from_string("[3.0, 4.0]")
    
    Let sum be Interval.add(a, b)
    assert_string_representation(sum, "[4.0, 6.0]", "Interval addition [1,2] + [3,4] = [4,6]")
    
    Let with_negative be Interval.add(a, Interval.create_from_string("[-1.0, 0.5]"))
    assert_string_representation(with_negative, "[0.0, 2.5]", "Addition with negative interval")
    
    Let with_degenerate be Interval.add(a, Interval.create_from_string("[5.0, 5.0]"))
    assert_string_representation(with_degenerate, "[6.0, 7.0]", "Addition with degenerate interval")

Process called "test_interval_subtraction":
    Note: Test interval arithmetic subtraction
    Let a be Interval.create_from_string("[5.0, 8.0]")
    Let b be Interval.create_from_string("[1.0, 3.0]")
    
    Let difference be Interval.subtract(a, b)
    assert_string_representation(difference, "[2.0, 7.0]", "Interval subtraction [5,8] - [1,3] = [2,7]")
    
    Let self_subtraction be Interval.subtract(a, a)
    Note: [a,b] - [a,b] = [a-b, b-a]
    Let expected_self_diff be Interval.create_from_string("[-3.0, 3.0]")
    assert_interval_equals(self_subtraction, expected_self_diff, "Self subtraction")

Process called "test_interval_multiplication":
    Note: Test interval arithmetic multiplication
    Let positive_a be Interval.create_from_string("[2.0, 3.0]")
    Let positive_b be Interval.create_from_string("[4.0, 5.0]")
    
    Let positive_product be Interval.multiply(positive_a, positive_b)
    assert_string_representation(positive_product, "[8.0, 15.0]", "Positive interval multiplication")
    
    Let mixed_signs be Interval.multiply(
        Interval.create_from_string("[-2.0, 3.0]"),
        Interval.create_from_string("[1.0, 4.0]")
    )
    assert_string_representation(mixed_signs, "[-8.0, 12.0]", "Mixed sign interval multiplication")
    
    Let both_negative be Interval.multiply(
        Interval.create_from_string("[-3.0, -1.0]"),
        Interval.create_from_string("[-5.0, -2.0]")
    )
    assert_string_representation(both_negative, "[2.0, 15.0]", "Negative interval multiplication")
    
    Let with_zero be Interval.multiply(
        positive_a,
        Interval.create_from_string("[0.0, 2.0]")
    )
    assert_string_representation(with_zero, "[0.0, 6.0]", "Multiplication with interval containing zero")

Process called "test_interval_division":
    Note: Test interval arithmetic division
    Let a be Interval.create_from_string("[6.0, 12.0]")
    Let positive_divisor be Interval.create_from_string("[2.0, 3.0]")
    
    Let quotient be Interval.divide(a, positive_divisor)
    assert_string_representation(quotient, "[2.0, 6.0]", "Positive interval division")
    
    Let negative_divisor be Interval.create_from_string("[-3.0, -1.0]")
    Let negative_quotient be Interval.divide(a, negative_divisor)
    assert_string_representation(negative_quotient, "[-12.0, -2.0]", "Division by negative interval")
    
    Note: Division by interval containing zero should handle appropriately
    Let unit_interval be Interval.create_unit_interval()
    Let reciprocal be Interval.reciprocal(Interval.create_from_string("[2.0, 4.0]"))
    assert_string_representation(reciprocal, "[0.25, 0.5]", "Reciprocal of positive interval")

Process called "test_interval_power":
    Note: Test interval exponentiation
    Let base be Interval.create_from_string("[2.0, 3.0]")
    
    Let squared be Interval.power(base, 2)
    assert_string_representation(squared, "[4.0, 9.0]", "Positive interval squared")
    
    Let cubed be Interval.power(base, 3)
    assert_string_representation(cubed, "[8.0, 27.0]", "Positive interval cubed")
    
    Let mixed_base be Interval.create_from_string("[-2.0, 3.0]")
    Let mixed_squared be Interval.power(mixed_base, 2)
    assert_string_representation(mixed_squared, "[0.0, 9.0]", "Mixed interval squared")
    
    Let mixed_cubed be Interval.power(mixed_base, 3)
    assert_string_representation(mixed_cubed, "[-8.0, 27.0]", "Mixed interval cubed")

Note: ===== SET OPERATION TESTS =====

Process called "test_interval_union":
    Note: Test interval union operations
    Let a be Interval.create_from_string("[1.0, 3.0]")
    Let b be Interval.create_from_string("[2.0, 5.0]")
    
    Let overlapping_union be Interval.union(a, b)
    assert_string_representation(overlapping_union, "[1.0, 5.0]", "Overlapping interval union")
    
    Let adjacent_union be Interval.union(
        Interval.create_from_string("[1.0, 2.0]"),
        Interval.create_from_string("[2.0, 3.0]")
    )
    assert_string_representation(adjacent_union, "[1.0, 3.0]", "Adjacent interval union")
    
    Note: Disjoint intervals should return collection or error
    Let disjoint_a be Interval.create_from_string("[1.0, 2.0]")
    Let disjoint_b be Interval.create_from_string("[4.0, 5.0]")
    Note: This might return a multi-interval or handle differently
    
    Let self_union be Interval.union(a, a)
    assert_interval_equals(self_union, a, "Self union should be identity")

Process called "test_interval_intersection":
    Note: Test interval intersection operations
    Let a be Interval.create_from_string("[1.0, 4.0]")
    Let b be Interval.create_from_string("[2.0, 5.0]")
    
    Let overlapping_intersection be Interval.intersection(a, b)
    assert_string_representation(overlapping_intersection, "[2.0, 4.0]", "Overlapping interval intersection")
    
    Let disjoint_intersection be Interval.intersection(
        Interval.create_from_string("[1.0, 2.0]"),
        Interval.create_from_string("[3.0, 4.0]")
    )
    UnitTest.assert(Interval.is_empty(disjoint_intersection), "Disjoint intersection should be empty")
    
    Let contained_intersection be Interval.intersection(
        Interval.create_from_string("[1.0, 10.0]"),
        Interval.create_from_string("[3.0, 7.0]")
    )
    assert_string_representation(contained_intersection, "[3.0, 7.0]", "Contained interval intersection")
    
    Let self_intersection be Interval.intersection(a, a)
    assert_interval_equals(self_intersection, a, "Self intersection should be identity")

Process called "test_interval_complement":
    Note: Test interval complement operations
    Let interval be Interval.create_from_string("[2.0, 5.0]")
    Let complement be Interval.complement(interval)
    
    Note: Complement should be union of (-∞, 2.0) and (5.0, +∞)
    Note: This might return a multi-interval structure
    
    Let unit_complement be Interval.complement(Interval.create_unit_interval())
    Note: Should be (-∞, 0) ∪ (1, +∞)
    
    Let empty_complement be Interval.complement(Interval.create_empty())
    Let full_real_line be Interval.create_full_real_line()
    assert_interval_equals(empty_complement, full_real_line, "Complement of empty set should be full real line")

Note: ===== MATHEMATICAL FUNCTION TESTS =====

Process called "test_interval_square_root":
    Note: Test interval square root function
    Let positive_interval be Interval.create_from_string("[4.0, 9.0]")
    let sqrt_positive be Interval.square_root(positive_interval)
    assert_string_representation(sqrt_positive, "[2.0, 3.0]", "Square root of positive interval")
    
    Let unit_sqrt be Interval.square_root(Interval.create_unit_interval())
    assert_string_representation(unit_sqrt, "[0.0, 1.0]", "Square root of unit interval")
    
    Let mixed_interval be Interval.create_from_string("[-1.0, 4.0]")
    Let sqrt_mixed be Interval.square_root(mixed_interval)
    assert_string_representation(sqrt_mixed, "[0.0, 2.0]", "Square root of interval containing negative values")

Process called "test_interval_logarithm":
    Note: Test interval natural logarithm function
    Let positive_interval be Interval.create_from_string("[1.0, 2.71828]")  Note: e ≈ 2.71828
    Let ln_positive be Interval.natural_log(positive_interval)
    
    Note: ln([1, e]) should be approximately [0, 1]
    Let expected_ln be Interval.create_from_string("[0.0, 1.0]")
    Note: Allow some tolerance for e approximation
    
    Let exp_interval be Interval.create_from_string("[2.0, 7.389]")  Note: e² ≈ 7.389
    Let ln_exp be Interval.natural_log(exp_interval)
    Note: Should be approximately [ln(2), 2]

Process called "test_interval_exponential":
    Note: Test interval exponential function
    Let zero_one_interval be Interval.create_unit_interval()
    Let exp_unit be Interval.exponential(zero_one_interval)
    Note: exp([0, 1]) should be [1, e]
    
    Let negative_interval be Interval.create_from_string("[-1.0, 0.0]")
    Let exp_negative be Interval.exponential(negative_interval)
    Note: exp([-1, 0]) should be [1/e, 1]

Process called "test_interval_trigonometric":
    Note: Test interval trigonometric functions
    Let context be create_default_context()
    
    Note: Create interval [0, π/2]
    Let pi_half be BigDecimal.divide(
        BigDecimal.pi(10), 
        BigDecimal.create_from_integer(2, 0),
        context
    )
    Let first_quadrant be Interval.create_from_endpoints(
        BigDecimal.create_zero(2),
        pi_half
    )
    
    Let sin_first_quad be Interval.sine(first_quadrant)
    Note: sin([0, π/2]) should be [0, 1]
    assert_string_representation(sin_first_quad, "[0.0, 1.0]", "Sine of first quadrant")
    
    Let cos_first_quad be Interval.cosine(first_quadrant)
    Note: cos([0, π/2]) should be [0, 1]
    assert_string_representation(cos_first_quad, "[0.0, 1.0]", "Cosine of first quadrant")

Note: ===== COMPARISON AND RELATION TESTS =====

Process called "test_interval_relations":
    Note: Test interval ordering and relation predicates
    Let a be Interval.create_from_string("[1.0, 3.0]")
    Let b be Interval.create_from_string("[2.0, 4.0]")
    Let c be Interval.create_from_string("[4.0, 6.0]")
    Let d be Interval.create_from_string("[2.5, 2.7]")
    
    UnitTest.assert(Interval.overlaps(a, b), "Overlapping intervals should overlap")
    UnitTest.assert(not Interval.overlaps(a, c), "Disjoint intervals should not overlap")
    
    UnitTest.assert(Interval.precedes(a, c), "Non-overlapping intervals should have precedence relation")
    UnitTest.assert(not Interval.precedes(a, b), "Overlapping intervals should not have precedence")
    
    UnitTest.assert(Interval.contains_interval(a, Interval.create_from_string("[1.5, 2.5]")), "Interval containment")
    UnitTest.assert(not Interval.contains_interval(d, a), "Contained interval should not contain container")

Process called "test_interval_equality":
    Note: Test interval equality with different representations
    Let a be Interval.create_from_string("[1.0, 2.0]")
    Let b be Interval.create_from_endpoints(
        BigDecimal.create_from_string("1.0", create_default_context()),
        BigDecimal.create_from_string("2.0", create_default_context())
    )
    
    UnitTest.assert(Interval.equals(a, b), "Same intervals should be equal")
    UnitTest.assert(Interval.equals(a, a), "Interval should equal itself")
    
    Let different be Interval.create_from_string("[1.0, 2.1]")
    UnitTest.assert(not Interval.equals(a, different), "Different intervals should not be equal")

Note: ===== CONVERSION TESTS =====

Process called "test_to_string_representations":
    Note: Test various string representation formats
    Let closed_interval be Interval.create_from_string("[1.5, 3.7]")
    assert_string_representation(closed_interval, "[1.5, 3.7]", "Closed interval string")
    
    Let open_interval be Interval.create_from_string("(0.0, 1.0)")
    assert_string_representation(open_interval, "(0.0, 1.0)", "Open interval string")
    
    Let mixed_interval be Interval.create_from_string("(2.0, 5.0]")
    assert_string_representation(mixed_interval, "(2.0, 5.0]", "Half-open interval string")
    
    Let degenerate be Interval.create_from_endpoints(
        BigDecimal.create_from_string("4.0", create_default_context()),
        BigDecimal.create_from_string("4.0", create_default_context())
    )
    assert_string_representation(degenerate, "[4.0]", "Degenerate interval string")

Process called "test_to_set_notation":
    Note: Test mathematical set notation output
    Let interval be Interval.create_from_string("[0.0, 1.0]")
    Let set_notation be Interval.to_set_notation(interval)
    UnitTest.assert(set_notation equals "{x ∈ ℝ : 0.0 ≤ x ≤ 1.0}", "Set notation representation")
    
    let open_set_notation be Interval.to_set_notation(Interval.create_from_string("(0.0, 1.0)"))
    UnitTest.assert(open_set_notation equals "{x ∈ ℝ : 0.0 < x < 1.0}", "Open set notation")

Process called "test_to_decimal_approximation":
    Note: Test conversion to decimal approximations
    Let context be create_default_context()
    
    Let interval be Interval.create_from_string("[1.414, 1.415]")  Note: √2 approximation
    
    Let lower_decimal be Interval.lower_bound_decimal(interval, 6)
    UnitTest.assert(lower_decimal equals "1.414000", "Lower bound decimal approximation")
    
    Let upper_decimal be Interval.upper_bound_decimal(interval, 6)
    UnitTest.assert(upper_decimal equals "1.415000", "Upper bound decimal approximation")

Note: ===== SPECIAL CASE TESTS =====

Process called "test_empty_interval_operations":
    Note: Test operations with empty intervals
    Let empty be Interval.create_empty()
    Let regular be Interval.create_from_string("[1.0, 2.0]")
    
    Let union_with_empty be Interval.union(regular, empty)
    assert_interval_equals(union_with_empty, regular, "Union with empty should be identity")
    
    Let intersection_with_empty be Interval.intersection(regular, empty)
    UnitTest.assert(Interval.is_empty(intersection_with_empty), "Intersection with empty should be empty")
    
    UnitTest.assert(not Interval.contains_point(empty, BigDecimal.create_from_string("1.0", create_default_context())), "Empty interval contains no points")

Process called "test_infinite_interval_operations":
    Note: Test operations with infinite intervals
    Let full_real_line be Interval.create_full_real_line()
    Let finite_interval be Interval.create_from_string("[1.0, 2.0]")
    
    Let union_with_infinite be Interval.union(finite_interval, full_real_line)
    assert_interval_equals(union_with_infinite, full_real_line, "Union with infinite should be infinite")
    
    let intersection_with_infinite be Interval.intersection(finite_interval, full_real_line)
    assert_interval_equals(intersection_with_infinite, finite_interval, "Intersection with infinite should be finite")

Process called "test_degenerate_interval_operations":
    Note: Test operations with single-point intervals
    Let context be create_default_context()
    
    Let point_a be Interval.create_from_endpoints(
        BigDecimal.create_from_string("3.0", context),
        BigDecimal.create_from_string("3.0", context)
    )
    Let point_b be Interval.create_from_endpoints(
        BigDecimal.create_from_string("7.0", context),
        BigDecimal.create_from_string("7.0", context)
    )
    
    Let point_sum be Interval.add(point_a, point_b)
    Let expected_sum_point be Interval.create_from_endpoints(
        BigDecimal.create_from_string("10.0", context),
        BigDecimal.create_from_string("10.0", context)
    )
    assert_interval_equals(point_sum, expected_sum_point, "Addition of point intervals")
    
    UnitTest.assert(Interval.width(point_a).equals(BigDecimal.create_zero(1)), "Point interval should have zero width")

Note: ===== PRECISION AND ROUNDING TESTS =====

Process called "test_precision_handling":
    Note: Test precision handling in interval operations
    Let context be create_default_context()
    
    Note: Create intervals with high precision endpoints
    Let precise_a be Interval.create_from_endpoints(
        BigDecimal.create_from_string("1.123456789012345678901234567890", context),
        BigDecimal.create_from_string("2.987654321098765432109876543210", context)
    )
    
    Let precise_b be Interval.create_from_endpoints(
        BigDecimal.create_from_string("0.111111111111111111111111111111", context),
        BigDecimal.create_from_string("0.999999999999999999999999999999", context)
    )
    
    Let precise_sum be Interval.add(precise_a, precise_b)
    
    Note: Result should maintain high precision
    Let sum_width be Interval.width(precise_sum)
    UnitTest.assert(BigDecimal.get_precision(sum_width) >= 30, "High precision should be maintained in operations")

Process called "test_error_propagation":
    Note: Test error propagation in interval arithmetic
    Let measurement1 be Interval.create_from_uncertainty(
        BigDecimal.create_from_string("10.0", create_default_context()),
        BigDecimal.create_from_string("0.1", create_default_context())
    )
    
    Let measurement2 be Interval.create_from_uncertainty(
        BigDecimal.create_from_string("5.0", create_default_context()),
        BigDecimal.create_from_string("0.05", create_default_context())
    )
    
    Let combined_measurement be Interval.add(measurement1, measurement2)
    let expected_uncertainty be BigDecimal.create_from_string("0.15", create_default_context())  Note: 0.1 + 0.05
    let combined_width be Interval.width(combined_measurement)
    let expected_width be BigDecimal.multiply(expected_uncertainty, BigDecimal.create_from_integer(2, 0), create_default_context())
    
    UnitTest.assert(BigDecimal.equals_ignoring_scale(combined_width, expected_width), "Error propagation in addition")

Note: ===== ERROR HANDLING TESTS =====

Process called "test_error_handling":
    Note: Test error conditions and invalid operations
    Let context be create_default_context()
    
    Note: Invalid interval construction (lower > upper) should be handled
    Note: Division by interval containing zero should be handled appropriately  
    Note: Square root of negative intervals should be handled
    Note: Logarithm of intervals containing non-positive values should be handled
    
    Note: Test with very large intervals
    Let huge_interval be Interval.create_from_endpoints(
        BigDecimal.create_from_string("-1e100", context),
        BigDecimal.create_from_string("1e100", context)
    )
    UnitTest.assert(Interval.is_bounded(huge_interval), "Very large finite interval should still be bounded")
    
    Note: Test with very small intervals  
    Let tiny_interval be Interval.create_from_endpoints(
        BigDecimal.create_from_string("1e-100", context),
        BigDecimal.create_from_string("2e-100", context)
    )
    UnitTest.assert(not Interval.is_degenerate(tiny_interval), "Very small interval should not be degenerate")

Note: ===== TEST RUNNER =====

Process called "run_all_tests":
    Note: Executes all Interval unit tests
    UnitTest.start_test_suite("Interval Module Tests")
    
    Note: Construction tests
    UnitTest.run_test("Create from Endpoints", test_create_from_endpoints)
    UnitTest.run_test("Create from Midpoint Radius", test_create_from_midpoint_radius)
    UnitTest.run_test("Create from String", test_create_from_string)
    UnitTest.run_test("Create from Uncertainty", test_create_from_uncertainty)
    UnitTest.run_test("Create Special Intervals", test_create_special_intervals)
    
    Note: Basic property tests
    UnitTest.run_test("Interval Properties", test_interval_properties)
    UnitTest.run_test("Interval Classification", test_interval_classification)
    UnitTest.run_test("Containment", test_containment)
    UnitTest.run_test("Interval Containment", test_interval_containment)
    
    Note: Arithmetic operation tests
    UnitTest.run_test("Interval Addition", test_interval_addition)
    UnitTest.run_test("Interval Subtraction", test_interval_subtraction)
    UnitTest.run_test("Interval Multiplication", test_interval_multiplication)
    UnitTest.run_test("Interval Division", test_interval_division)
    UnitTest.run_test("Interval Power", test_interval_power)
    
    Note: Set operation tests
    UnitTest.run_test("Interval Union", test_interval_union)
    UnitTest.run_test("Interval Intersection", test_interval_intersection)
    UnitTest.run_test("Interval Complement", test_interval_complement)
    
    Note: Mathematical function tests
    UnitTest.run_test("Interval Square Root", test_interval_square_root)
    UnitTest.run_test("Interval Logarithm", test_interval_logarithm)
    UnitTest.run_test("Interval Exponential", test_interval_exponential)
    UnitTest.run_test("Interval Trigonometric", test_interval_trigonometric)
    
    Note: Comparison and relation tests
    UnitTest.run_test("Interval Relations", test_interval_relations)
    UnitTest.run_test("Interval Equality", test_interval_equality)
    
    Note: Conversion tests
    UnitTest.run_test("String Representations", test_to_string_representations)
    UnitTest.run_test("Set Notation", test_to_set_notation)
    UnitTest.run_test("Decimal Approximation", test_to_decimal_approximation)
    
    Note: Special case tests
    UnitTest.run_test("Empty Interval Operations", test_empty_interval_operations)
    UnitTest.run_test("Infinite Interval Operations", test_infinite_interval_operations)
    UnitTest.run_test("Degenerate Interval Operations", test_degenerate_interval_operations)
    
    Note: Precision and rounding tests
    UnitTest.run_test("Precision Handling", test_precision_handling)
    UnitTest.run_test("Error Propagation", test_error_propagation)
    
    Note: Error handling tests
    UnitTest.run_test("Error Handling", test_error_handling)
    
    UnitTest.end_test_suite()