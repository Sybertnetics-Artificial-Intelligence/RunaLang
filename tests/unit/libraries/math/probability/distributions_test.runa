Note:
runa/tests/unit/libraries/math/probability/distributions_test.runa
Comprehensive Unit Tests for Probability Distribution Functions

This test suite covers all probability distribution functionality including
continuous and discrete distributions, PDF/CDF calculations, parameter
estimation, distribution fitting, and multivariate distributions.

Test Categories:
- Continuous distribution operations (Normal, Exponential, Gamma, etc.)
- Discrete distribution operations (Binomial, Poisson, Geometric, etc.)
- Distribution parameter estimation and fitting
- Multivariate distribution analysis
- Statistical properties validation
- Numerical accuracy and edge case testing
:End Note

Import "dev/debug/testing" as Test
Import "math/probability/distributions" as Distributions
Import "dev/debug/errors/core" as Errors
Import "math/core/operations" as MathOps
Import "math/core/constants" as Constants
Import "data/collections/core" as Collections

Note: =====================================================================
Note: TEST DATA GENERATION HELPERS
Note: =====================================================================

Process called "generate_test_samples" that takes distribution_type as String, parameters as Dictionary[String, Float], sample_size as Integer returns List[Float]:
    Note: Generate sample data from specified distribution for testing
    Let samples be List[Float]
    
    If distribution_type equals "Normal":
        Let mean be parameters["mean"]
        Let variance be parameters["variance"]
        For i from 0 to sample_size - 1:
            Let sample be Distributions.generate_normal_sample(mean, variance)
            Append sample to samples
            
    Otherwise if distribution_type equals "Exponential":
        Let rate be parameters["rate"]
        For i from 0 to sample_size - 1:
            Let sample be Distributions.generate_exponential_sample(rate)
            Append sample to samples
            
    Otherwise if distribution_type equals "Uniform":
        Let min_val be parameters["min"]
        Let max_val be parameters["max"]
        For i from 0 to sample_size - 1:
            Let sample be Distributions.generate_uniform_sample(min_val, max_val)
            Append sample to samples
    
    Return samples

Process called "calculate_sample_statistics" that takes samples as List[Float] returns Dictionary[String, Float]:
    Note: Calculate basic statistics from sample data for validation
    Let stats be Collections.create_dictionary()
    Let n be Length(samples)
    
    Note: Calculate sample mean
    Let sum be 0.0
    For each sample in samples:
        Set sum to sum + sample
    Let mean be sum / Float(n)
    Set stats["mean"] to mean
    
    Note: Calculate sample variance
    Let variance_sum be 0.0
    For each sample in samples:
        Let diff be sample - mean
        Set variance_sum to variance_sum + (diff * diff)
    Let variance be variance_sum / Float(n - 1)
    Set stats["variance"] to variance
    Set stats["std_dev"] to MathOps.square_root(ToString(variance), 15).result_value
    
    Note: Calculate min and max
    Let min_val be samples[0]
    Let max_val be samples[0]
    For each sample in samples:
        If sample < min_val:
            Set min_val to sample
        If sample > max_val:
            Set max_val to sample
    Set stats["min"] to min_val
    Set stats["max"] to max_val
    
    Return stats

Process called "assert_approximately_equal" that takes actual as Float, expected as Float, tolerance as Float, test_name as String returns Boolean:
    Note: Assert values are approximately equal within tolerance
    Let difference be MathOps.absolute_value(actual - expected)
    If difference <= tolerance:
        Return Test.assert_true(True, test_name + " - values approximately equal")
    Return Test.assert_true(False, test_name + " - Expected: " + ToString(expected) + ", Got: " + ToString(actual) + ", Diff: " + ToString(difference))

Note: =====================================================================
Note: NORMAL DISTRIBUTION TESTS
Note: =====================================================================

Process called "test_normal_distribution_pdf" that takes no parameters returns Boolean:
    Note: Test normal distribution probability density function calculations
    Let all_passed be True
    
    Note: Test standard normal PDF at various points
    Let pdf_0 be Distributions.normal_distribution_pdf(0.0, 0.0, 1.0)
    Let expected_pdf_0 be 0.398942280401433  Note: 1/√(2π)
    Set all_passed to all_passed and assert_approximately_equal(pdf_0, expected_pdf_0, 1e-10, "Standard normal PDF at x=0")
    
    Let pdf_1 be Distributions.normal_distribution_pdf(1.0, 0.0, 1.0)
    Let expected_pdf_1 be 0.241970724519143  Note: exp(-0.5)/√(2π)
    Set all_passed to all_passed and assert_approximately_equal(pdf_1, expected_pdf_1, 1e-10, "Standard normal PDF at x=1")
    
    Note: Test normal PDF with different mean and variance
    Let pdf_custom be Distributions.normal_distribution_pdf(5.0, 3.0, 4.0)
    Let expected_custom be 0.176032663382281  Note: Calculated analytically
    Set all_passed to all_passed and assert_approximately_equal(pdf_custom, expected_custom, 1e-10, "Normal PDF with mean=3, var=4, x=5")
    
    Note: Test edge case - zero variance should throw error
    Try:
        Let invalid_pdf be Distributions.normal_distribution_pdf(0.0, 0.0, 0.0)
        Set all_passed to Test.assert_true(False, "Zero variance should throw error")
    Catch error as Errors.InvalidOperation:
        Set all_passed to all_passed and Test.assert_true(True, "Zero variance correctly throws InvalidOperation")
    
    Return all_passed

Process called "test_normal_distribution_cdf" that takes no parameters returns Boolean:
    Note: Test normal distribution cumulative distribution function calculations
    Let all_passed be True
    
    Note: Test standard normal CDF at critical points
    Let cdf_0 be Distributions.normal_distribution_cdf(0.0, 0.0, 1.0)
    Set all_passed to all_passed and assert_approximately_equal(cdf_0, 0.5, 1e-10, "Standard normal CDF at x=0")
    
    Let cdf_negative be Distributions.normal_distribution_cdf(-1.96, 0.0, 1.0)
    Set all_passed to all_passed and assert_approximately_equal(cdf_negative, 0.025, 1e-3, "Standard normal CDF at x=-1.96")
    
    Let cdf_positive be Distributions.normal_distribution_cdf(1.96, 0.0, 1.0)
    Set all_passed to all_passed and assert_approximately_equal(cdf_positive, 0.975, 1e-3, "Standard normal CDF at x=1.96")
    
    Note: Test CDF with custom parameters
    Let cdf_custom be Distributions.normal_distribution_cdf(10.0, 5.0, 9.0)
    Let expected_cdf_custom be 0.904382  Note: Calculated using standard normal table
    Set all_passed to all_passed and assert_approximately_equal(cdf_custom, expected_cdf_custom, 1e-3, "Normal CDF with mean=5, var=9, x=10")
    
    Return all_passed

Process called "test_normal_distribution_quantile" that takes no parameters returns Boolean:
    Note: Test normal distribution quantile function calculations
    Let all_passed be True
    
    Note: Test standard normal quantiles
    Let q_median be Distributions.normal_distribution_quantile(0.5, 0.0, 1.0)
    Set all_passed to all_passed and assert_approximately_equal(q_median, 0.0, 1e-10, "Standard normal median quantile")
    
    Let q_025 be Distributions.normal_distribution_quantile(0.025, 0.0, 1.0)
    Set all_passed to all_passed and assert_approximately_equal(q_025, -1.96, 1e-2, "Standard normal 2.5% quantile")
    
    Let q_975 be Distributions.normal_distribution_quantile(0.975, 0.0, 1.0)
    Set all_passed to all_passed and assert_approximately_equal(q_975, 1.96, 1e-2, "Standard normal 97.5% quantile")
    
    Note: Test quantiles with custom parameters
    Let q_custom be Distributions.normal_distribution_quantile(0.9, 100.0, 25.0)
    Let expected_custom be 106.408  Note: 100 + 1.282 * 5
    Set all_passed to all_passed and assert_approximately_equal(q_custom, expected_custom, 1e-1, "Normal quantile with mean=100, var=25, p=0.9")
    
    Return all_passed

Process called "test_exponential_distribution" that takes no parameters returns Boolean:
    Note: Test exponential distribution PDF, CDF, and quantile functions
    Let all_passed be True
    
    Note: Test exponential PDF
    Let pdf_0 be Distributions.exponential_distribution_pdf(0.0, 2.0)
    Set all_passed to all_passed and assert_approximately_equal(pdf_0, 2.0, 1e-10, "Exponential PDF at x=0, rate=2")
    
    Let pdf_1 be Distributions.exponential_distribution_pdf(1.0, 2.0)
    Let expected_pdf_1 be 2.0 * MathOps.exponential("-2", 15).result_value
    Set all_passed to all_passed and assert_approximately_equal(pdf_1, Parse expected_pdf_1 as Float, 1e-10, "Exponential PDF at x=1, rate=2")
    
    Note: Test exponential CDF
    Let cdf_0 be Distributions.exponential_distribution_cdf(0.0, 2.0)
    Set all_passed to all_passed and assert_approximately_equal(cdf_0, 0.0, 1e-10, "Exponential CDF at x=0, rate=2")
    
    Let cdf_1 be Distributions.exponential_distribution_cdf(1.0, 2.0)
    Let expected_cdf_1 be 1.0 - Parse MathOps.exponential("-2", 15).result_value as Float
    Set all_passed to all_passed and assert_approximately_equal(cdf_1, expected_cdf_1, 1e-10, "Exponential CDF at x=1, rate=2")
    
    Note: Test exponential quantile
    Let q_median be Distributions.exponential_distribution_quantile(0.5, 1.0)
    Let expected_median be Parse MathOps.logarithm_natural("2", 15).result_value as Float
    Set all_passed to all_passed and assert_approximately_equal(q_median, expected_median, 1e-10, "Exponential median quantile, rate=1")
    
    Return all_passed

Note: =====================================================================
Note: DISCRETE DISTRIBUTION TESTS
Note: =====================================================================

Process called "test_binomial_distribution" that takes no parameters returns Boolean:
    Note: Test binomial distribution probability mass function and CDF
    Let all_passed be True
    
    Note: Test binomial PMF
    Let pmf_0 be Distributions.binomial_distribution_pmf(0, 10, 0.3)
    Let expected_pmf_0 be MathOps.power("0.7", "10", 15).result_value
    Set all_passed to all_passed and assert_approximately_equal(pmf_0, Parse expected_pmf_0 as Float, 1e-10, "Binomial PMF k=0, n=10, p=0.3")
    
    Let pmf_5 be Distributions.binomial_distribution_pmf(5, 10, 0.5)
    Let expected_pmf_5 be 0.24609375  Note: C(10,5) * 0.5^10
    Set all_passed to all_passed and assert_approximately_equal(pmf_5, expected_pmf_5, 1e-8, "Binomial PMF k=5, n=10, p=0.5")
    
    Note: Test binomial CDF
    Let cdf_5 be Distributions.binomial_distribution_cdf(5, 10, 0.5)
    Set all_passed to all_passed and assert_approximately_equal(cdf_5, 0.623046875, 1e-8, "Binomial CDF k=5, n=10, p=0.5")
    
    Note: Test edge cases
    Let pmf_impossible be Distributions.binomial_distribution_pmf(15, 10, 0.5)
    Set all_passed to all_passed and assert_approximately_equal(pmf_impossible, 0.0, 1e-10, "Binomial PMF k>n should be 0")
    
    Return all_passed

Process called "test_poisson_distribution" that takes no parameters returns Boolean:
    Note: Test Poisson distribution probability mass function and CDF
    Let all_passed be True
    
    Note: Test Poisson PMF
    Let pmf_0 be Distributions.poisson_distribution_pmf(0, 2.0)
    Let expected_pmf_0 be Parse MathOps.exponential("-2", 15).result_value as Float
    Set all_passed to all_passed and assert_approximately_equal(pmf_0, expected_pmf_0, 1e-10, "Poisson PMF k=0, λ=2")
    
    Let pmf_2 be Distributions.poisson_distribution_pmf(2, 2.0)
    Let expected_pmf_2 be 2.0 * expected_pmf_0  Note: e^(-2) * 2^2 / 2!
    Set all_passed to all_passed and assert_approximately_equal(pmf_2, expected_pmf_2, 1e-10, "Poisson PMF k=2, λ=2")
    
    Note: Test Poisson CDF
    Let cdf_3 be Distributions.poisson_distribution_cdf(3, 1.5)
    Let expected_cdf_3 be 0.934  Note: Approximately from Poisson tables
    Set all_passed to all_passed and assert_approximately_equal(cdf_3, expected_cdf_3, 1e-2, "Poisson CDF k=3, λ=1.5")
    
    Return all_passed

Process called "test_geometric_distribution" that takes no parameters returns Boolean:
    Note: Test geometric distribution probability mass function and CDF
    Let all_passed be True
    
    Note: Test geometric PMF (number of trials until first success)
    Let pmf_1 be Distributions.geometric_distribution_pmf(1, 0.3)
    Set all_passed to all_passed and assert_approximately_equal(pmf_1, 0.3, 1e-10, "Geometric PMF k=1, p=0.3")
    
    Let pmf_3 be Distributions.geometric_distribution_pmf(3, 0.3)
    Let expected_pmf_3 be 0.3 * 0.7 * 0.7  Note: p * (1-p)^(k-1)
    Set all_passed to all_passed and assert_approximately_equal(pmf_3, expected_pmf_3, 1e-10, "Geometric PMF k=3, p=0.3")
    
    Note: Test geometric CDF
    Let cdf_4 be Distributions.geometric_distribution_cdf(4, 0.3)
    Let expected_cdf_4 be 1.0 - MathOps.power("0.7", "4", 15).result_value
    Set all_passed to all_passed and assert_approximately_equal(cdf_4, Parse expected_cdf_4 as Float, 1e-10, "Geometric CDF k=4, p=0.3")
    
    Return all_passed

Note: =====================================================================
Note: MULTIVARIATE DISTRIBUTION TESTS
Note: =====================================================================

Process called "test_multivariate_normal_distribution" that takes no parameters returns Boolean:
    Note: Test multivariate normal distribution PDF and random generation
    Let all_passed be True
    
    Note: Create 2D multivariate normal parameters
    Let mean_vector be [0.0, 0.0]
    Let covariance_matrix be [[1.0, 0.0], [0.0, 1.0]]  Note: Identity covariance
    
    Note: Test PDF at origin (should be maximum for zero mean)
    Let pdf_origin be Distributions.multivariate_normal_pdf([0.0, 0.0], mean_vector, covariance_matrix)
    Let expected_pdf_origin be 1.0 / (2.0 * Constants.pi)
    Set all_passed to all_passed and assert_approximately_equal(pdf_origin, expected_pdf_origin, 1e-10, "Multivariate normal PDF at origin")
    
    Note: Test PDF with correlation
    Let correlated_cov be [[1.0, 0.5], [0.5, 1.0]]
    Let pdf_correlated be Distributions.multivariate_normal_pdf([1.0, 1.0], [0.0, 0.0], correlated_cov)
    Set all_passed to all_passed and Test.assert_true(pdf_correlated > 0.0, "Multivariate normal PDF with correlation should be positive")
    
    Note: Test random sample generation
    Let samples be Distributions.generate_multivariate_normal_samples(mean_vector, covariance_matrix, 1000)
    Set all_passed to all_passed and Test.assert_equal(Length(samples), 1000, "Generated correct number of samples")
    Set all_passed to all_passed and Test.assert_equal(Length(samples[0]), 2, "Each sample has correct dimension")
    
    Return all_passed

Process called "test_multivariate_t_distribution" that takes no parameters returns Boolean:
    Note: Test multivariate t-distribution PDF and properties
    Let all_passed be True
    
    Note: Create multivariate t-distribution parameters
    Let mean_vector be [1.0, 2.0]
    Let scale_matrix be [[2.0, 0.5], [0.5, 1.0]]
    Let degrees_freedom be 5.0
    
    Note: Test PDF calculation
    Let pdf_value be Distributions.multivariate_t_pdf([1.0, 2.0], mean_vector, scale_matrix, degrees_freedom)
    Set all_passed to all_passed and Test.assert_true(pdf_value > 0.0, "Multivariate t PDF should be positive")
    
    Note: Test that t-distribution has heavier tails than normal
    Let pdf_tail be Distributions.multivariate_t_pdf([5.0, 5.0], mean_vector, scale_matrix, degrees_freedom)
    Let pdf_normal_tail be Distributions.multivariate_normal_pdf([5.0, 5.0], mean_vector, scale_matrix)
    Set all_passed to all_passed and Test.assert_true(pdf_tail > pdf_normal_tail, "t-distribution should have heavier tails than normal")
    
    Return all_passed

Note: =====================================================================
Note: DISTRIBUTION FITTING TESTS
Note: =====================================================================

Process called "test_maximum_likelihood_estimation" that takes no parameters returns Boolean:
    Note: Test maximum likelihood parameter estimation for various distributions
    Let all_passed be True
    
    Note: Generate known normal data and test MLE estimation
    Let true_mean be 5.0
    Let true_variance be 4.0
    Let normal_samples be generate_test_samples("Normal", 
        Collections.dictionary_with_pairs([["mean", true_mean], ["variance", true_variance]]), 1000)
    
    Let mle_result be Distributions.fit_normal_distribution_mle(normal_samples)
    Set all_passed to all_passed and assert_approximately_equal(mle_result.estimated_parameters["mean"], true_mean, 0.2, "MLE normal mean estimation")
    Set all_passed to all_passed and assert_approximately_equal(mle_result.estimated_parameters["variance"], true_variance, 0.5, "MLE normal variance estimation")
    
    Note: Test exponential MLE estimation
    Let true_rate be 2.0
    Let exp_samples be generate_test_samples("Exponential", 
        Collections.dictionary_with_pairs([["rate", true_rate]]), 1000)
    
    Let exp_mle_result be Distributions.fit_exponential_distribution_mle(exp_samples)
    Set all_passed to all_passed and assert_approximately_equal(exp_mle_result.estimated_parameters["rate"], true_rate, 0.2, "MLE exponential rate estimation")
    
    Return all_passed

Process called "test_method_of_moments_estimation" that takes no parameters returns Boolean:
    Note: Test method of moments parameter estimation
    Let all_passed be True
    
    Note: Test gamma distribution method of moments
    Let shape_param be 3.0
    Let scale_param be 2.0
    Let gamma_samples be generate_test_samples("Gamma",
        Collections.dictionary_with_pairs([["shape", shape_param], ["scale", scale_param]]), 1000)
    
    Let mom_result be Distributions.fit_gamma_distribution_mom(gamma_samples)
    Set all_passed to all_passed and assert_approximately_equal(mom_result.estimated_parameters["shape"], shape_param, 0.5, "MoM gamma shape estimation")
    Set all_passed to all_passed and assert_approximately_equal(mom_result.estimated_parameters["scale"], scale_param, 0.5, "MoM gamma scale estimation")
    
    Return all_passed

Process called "test_goodness_of_fit" that takes no parameters returns Boolean:
    Note: Test goodness of fit statistics for distribution fitting
    Let all_passed be True
    
    Note: Generate normal data and test various distributions
    Let normal_samples be generate_test_samples("Normal", 
        Collections.dictionary_with_pairs([["mean", 0.0], ["variance", 1.0]]), 500)
    
    Note: Test Kolmogorov-Smirnov test for normal fit
    Let ks_result be Distributions.kolmogorov_smirnov_test(normal_samples, "Normal", 
        Collections.dictionary_with_pairs([["mean", 0.0], ["variance", 1.0]]))
    Set all_passed to all_passed and Test.assert_true(ks_result.p_value > 0.05, "KS test should not reject true normal distribution")
    
    Note: Test Anderson-Darling test
    Let ad_result be Distributions.anderson_darling_test(normal_samples, "Normal")
    Set all_passed to all_passed and Test.assert_true(ad_result.p_value > 0.05, "AD test should not reject true normal distribution")
    
    Note: Test chi-square goodness of fit for discrete distributions
    Let poisson_samples be generate_test_samples("Poisson",
        Collections.dictionary_with_pairs([["lambda", 3.0]]), 1000)
    Let chi2_result be Distributions.chi_square_goodness_of_fit(poisson_samples, "Poisson", 
        Collections.dictionary_with_pairs([["lambda", 3.0]]))
    Set all_passed to all_passed and Test.assert_true(chi2_result.p_value > 0.05, "Chi-square test should not reject true Poisson distribution")
    
    Return all_passed

Note: =====================================================================
Note: DISTRIBUTION PROPERTIES TESTS
Note: =====================================================================

Process called "test_distribution_moments" that takes no parameters returns Boolean:
    Note: Test calculation of distribution moments (mean, variance, skewness, kurtosis)
    Let all_passed be True
    
    Note: Test normal distribution moments
    Let normal_moments be Distributions.calculate_distribution_moments("Normal", 
        Collections.dictionary_with_pairs([["mean", 3.0], ["variance", 16.0]]))
    Set all_passed to all_passed and assert_approximately_equal(normal_moments["mean"], 3.0, 1e-10, "Normal distribution mean")
    Set all_passed to all_passed and assert_approximately_equal(normal_moments["variance"], 16.0, 1e-10, "Normal distribution variance")
    Set all_passed to all_passed and assert_approximately_equal(normal_moments["skewness"], 0.0, 1e-10, "Normal distribution skewness")
    Set all_passed to all_passed and assert_approximately_equal(normal_moments["kurtosis"], 3.0, 1e-10, "Normal distribution kurtosis")
    
    Note: Test exponential distribution moments
    Let exp_moments be Distributions.calculate_distribution_moments("Exponential", 
        Collections.dictionary_with_pairs([["rate", 2.0]]))
    Set all_passed to all_passed and assert_approximately_equal(exp_moments["mean"], 0.5, 1e-10, "Exponential distribution mean")
    Set all_passed to all_passed and assert_approximately_equal(exp_moments["variance"], 0.25, 1e-10, "Exponential distribution variance")
    Set all_passed to all_passed and assert_approximately_equal(exp_moments["skewness"], 2.0, 1e-10, "Exponential distribution skewness")
    
    Return all_passed

Process called "test_distribution_support" that takes no parameters returns Boolean:
    Note: Test distribution support bounds and validity checks
    Let all_passed be True
    
    Note: Test normal distribution support (should be (-∞, ∞))
    Let normal_support be Distributions.get_distribution_support("Normal", 
        Collections.dictionary_with_pairs([["mean", 0.0], ["variance", 1.0]]))
    Set all_passed to all_passed and Test.assert_true(normal_support["lower_bound"] < -1000000.0, "Normal distribution lower support")
    Set all_passed to all_passed and Test.assert_true(normal_support["upper_bound"] > 1000000.0, "Normal distribution upper support")
    
    Note: Test uniform distribution support
    Let uniform_support be Distributions.get_distribution_support("Uniform", 
        Collections.dictionary_with_pairs([["min", 2.0], ["max", 8.0]]))
    Set all_passed to all_passed and assert_approximately_equal(uniform_support["lower_bound"], 2.0, 1e-10, "Uniform distribution lower bound")
    Set all_passed to all_passed and assert_approximately_equal(uniform_support["upper_bound"], 8.0, 1e-10, "Uniform distribution upper bound")
    
    Note: Test exponential distribution support (should be [0, ∞))
    Let exp_support be Distributions.get_distribution_support("Exponential", 
        Collections.dictionary_with_pairs([["rate", 1.0]]))
    Set all_passed to all_passed and assert_approximately_equal(exp_support["lower_bound"], 0.0, 1e-10, "Exponential distribution lower bound")
    Set all_passed to all_passed and Test.assert_true(exp_support["upper_bound"] > 1000000.0, "Exponential distribution upper support")
    
    Return all_passed

Note: =====================================================================
Note: EDGE CASE AND ERROR HANDLING TESTS
Note: =====================================================================

Process called "test_invalid_parameters" that takes no parameters returns Boolean:
    Note: Test error handling for invalid distribution parameters
    Let all_passed be True
    
    Note: Test normal distribution with invalid variance
    Try:
        Let invalid_pdf be Distributions.normal_distribution_pdf(0.0, 0.0, -1.0)
        Set all_passed to Test.assert_true(False, "Negative variance should throw error")
    Catch error as Errors.InvalidOperation:
        Set all_passed to all_passed and Test.assert_true(True, "Negative variance correctly throws error")
    
    Note: Test exponential distribution with invalid rate
    Try:
        Let invalid_exp be Distributions.exponential_distribution_pdf(1.0, 0.0)
        Set all_passed to Test.assert_true(False, "Zero rate should throw error")
    Catch error as Errors.InvalidOperation:
        Set all_passed to all_passed and Test.assert_true(True, "Zero rate correctly throws error")
    
    Note: Test binomial distribution with invalid probability
    Try:
        Let invalid_binom be Distributions.binomial_distribution_pmf(5, 10, 1.5)
        Set all_passed to Test.assert_true(False, "Probability > 1 should throw error")
    Catch error as Errors.InvalidOperation:
        Set all_passed to all_passed and Test.assert_true(True, "Invalid probability correctly throws error")
    
    Return all_passed

Process called "test_numerical_stability" that takes no parameters returns Boolean:
    Note: Test numerical stability with extreme parameter values
    Let all_passed be True
    
    Note: Test normal PDF with very small variance
    Let small_var_pdf be Distributions.normal_distribution_pdf(0.0, 0.0, 1e-10)
    Set all_passed to all_passed and Test.assert_true(small_var_pdf > 0.0, "Normal PDF with small variance should be positive")
    Set all_passed to all_passed and Test.assert_true(small_var_pdf < Float("inf"), "Normal PDF with small variance should be finite")
    
    Note: Test exponential PDF with very large rate
    Let large_rate_pdf be Distributions.exponential_distribution_pdf(0.0, 1e6)
    Set all_passed to all_passed and assert_approximately_equal(large_rate_pdf, 1e6, 1e-3, "Exponential PDF with large rate")
    
    Note: Test Poisson PMF with large lambda
    Let large_lambda_pmf be Distributions.poisson_distribution_pmf(100, 100.0)
    Set all_passed to all_passed and Test.assert_true(large_lambda_pmf > 0.0, "Poisson PMF with large lambda should be positive")
    Set all_passed to all_passed and Test.assert_true(large_lambda_pmf < 1.0, "Poisson PMF should be less than 1")
    
    Return all_passed

Note: =====================================================================
Note: MAIN TEST RUNNER
Note: =====================================================================

Process called "run_all_distributions_tests" that takes no parameters returns Boolean:
    Note: Execute all distribution tests and report results
    Test.print_test_header("PROBABILITY DISTRIBUTIONS MODULE TESTS")
    Let all_passed be True
    
    Note: Continuous Distribution Tests
    Test.print_test_section("Continuous Distribution Tests")
    Set all_passed to all_passed and test_normal_distribution_pdf()
    Set all_passed to all_passed and test_normal_distribution_cdf()
    Set all_passed to all_passed and test_normal_distribution_quantile()
    Set all_passed to all_passed and test_exponential_distribution()
    
    Note: Discrete Distribution Tests
    Test.print_test_section("Discrete Distribution Tests")
    Set all_passed to all_passed and test_binomial_distribution()
    Set all_passed to all_passed and test_poisson_distribution()
    Set all_passed to all_passed and test_geometric_distribution()
    
    Note: Multivariate Distribution Tests
    Test.print_test_section("Multivariate Distribution Tests")
    Set all_passed to all_passed and test_multivariate_normal_distribution()
    Set all_passed to all_passed and test_multivariate_t_distribution()
    
    Note: Distribution Fitting Tests
    Test.print_test_section("Distribution Fitting Tests")
    Set all_passed to all_passed and test_maximum_likelihood_estimation()
    Set all_passed to all_passed and test_method_of_moments_estimation()
    Set all_passed to all_passed and test_goodness_of_fit()
    
    Note: Distribution Properties Tests
    Test.print_test_section("Distribution Properties Tests")
    Set all_passed to all_passed and test_distribution_moments()
    Set all_passed to all_passed and test_distribution_support()
    
    Note: Edge Case and Error Handling Tests
    Test.print_test_section("Edge Case and Error Handling Tests")
    Set all_passed to all_passed and test_invalid_parameters()
    Set all_passed to all_passed and test_numerical_stability()
    
    Test.print_test_footer("DISTRIBUTIONS TESTS", all_passed)
    Return all_passed

Note: Entry point for individual test execution
Let test_result be run_all_distributions_tests()
If test_result:
    Test.print_success("All probability distributions tests passed!")
Otherwise:
    Test.print_failure("Some probability distributions tests failed!")
    Test.exit_with_code(1)