Note:
runa/tests/unit/libraries/math/probability/stochastic_test.runa
Comprehensive Unit Tests for Stochastic Processes and Random Dynamical Systems

This test suite covers all stochastic process functionality including Brownian
motion, geometric Brownian motion, Ornstein-Uhlenbeck processes, Poisson processes,
jump diffusion models, and stochastic differential equations for modeling random
phenomena evolving over time.

Test Categories:
- Brownian motion simulation and path properties
- Geometric Brownian motion for financial modeling
- Ornstein-Uhlenbeck mean-reverting processes
- Poisson processes and jump models
- Stochastic differential equation solvers
- Process path statistics and validation
- Numerical integration schemes
- Mathematical properties verification
:End Note

Import "dev/debug/testing" as Test
Import "math/probability/stochastic" as Stochastic
Import "math/probability/distributions" as Distributions
Import "math/probability/sampling" as Sampling
Import "dev/debug/errors/core" as Errors
Import "math/core/operations" as MathOps
Import "math/engine/linalg/core" as LinAlg
Import "math/statistics/descriptive" as DescriptiveStats
Import "data/collections/core" as Collections

Note: =====================================================================
Note: TEST DATA GENERATION AND VALIDATION HELPERS
Note: =====================================================================

Process called "create_uniform_time_grid" that takes start_time as Float, end_time as Float, num_steps as Integer returns List[Float]:
    Note: Create uniform time grid for process simulation
    Let time_grid be List[Float]
    Let dt be (end_time - start_time) / Float(num_steps - 1)
    
    For i from 0 to num_steps - 1:
        Let time_point be start_time + Float(i) * dt
        Append time_point to time_grid
    
    Return time_grid

Process called "calculate_path_statistics" that takes path as List[Float] returns Dictionary[String, Float]:
    Note: Calculate basic statistics for stochastic process paths
    Let stats be Collections.create_dictionary()
    Let n be Length(path)
    
    Note: Calculate path mean and variance
    Let sum be 0.0
    For each value in path:
        Set sum to sum + value
    Set stats["mean"] to sum / Float(n)
    
    Let variance_sum be 0.0
    For each value in path:
        Let diff be value - stats["mean"]
        Set variance_sum to variance_sum + (diff * diff)
    Set stats["variance"] to variance_sum / Float(n - 1)
    
    Note: Calculate path range
    Let min_val be path[0]
    Let max_val be path[0]
    For each value in path:
        If value < min_val:
            Set min_val to value
        If value > max_val:
            Set max_val to value
    Set stats["min"] to min_val
    Set stats["max"] to max_val
    Set stats["range"] to max_val - min_val
    
    Note: Calculate quadratic variation (approximate)
    Let quad_var be 0.0
    For i from 1 to n - 1:
        Let increment be path[i] - path[i-1]
        Set quad_var to quad_var + (increment * increment)
    Set stats["quadratic_variation"] to quad_var
    
    Return stats

Process called "assert_approximately_equal" that takes actual as Float, expected as Float, tolerance as Float, test_name as String returns Boolean:
    Note: Assert values are approximately equal within tolerance
    Let difference be MathOps.absolute_value(actual - expected)
    If difference <= tolerance:
        Return Test.assert_true(True, test_name + " - values approximately equal")
    Return Test.assert_true(False, test_name + " - Expected: " + ToString(expected) + ", Got: " + ToString(actual))

Process called "calculate_increments" that takes path as List[Float] returns List[Float]:
    Note: Calculate increments (differences) of a stochastic process path
    Let increments be List[Float]
    For i from 1 to Length(path) - 1:
        Let increment be path[i] - path[i-1]
        Append increment to increments
    Return increments

Note: =====================================================================
Note: BROWNIAN MOTION TESTS
Note: =====================================================================

Process called "test_standard_brownian_motion" that takes no parameters returns Boolean:
    Note: Test standard Brownian motion generation and properties
    Let all_passed be True
    
    Note: Generate standard Brownian motion path
    Let time_grid be create_uniform_time_grid(0.0, 1.0, 1001)  Note: 1000 time steps
    Let bm_paths be Stochastic.standard_brownian_motion(time_grid, 1, 12345)  Note: 1D, seed 12345
    
    Set all_passed to all_passed and Test.assert_equal(Length(bm_paths), 1, "Generated correct number of dimensions")
    Set all_passed to all_passed and Test.assert_equal(Length(bm_paths[0]), 1001, "Generated correct path length")
    
    Note: Brownian motion starts at 0
    Set all_passed to all_passed and assert_approximately_equal(bm_paths[0][0], 0.0, 1e-10, "Brownian motion starts at 0")
    
    Note: Check path statistics
    Let bm_path be bm_paths[0]
    Let path_stats be calculate_path_statistics(bm_path)
    
    Note: For Brownian motion, E[B(t)] = 0 and Var[B(t)] = t
    Note: At t=1, variance should be approximately 1
    Let final_value be bm_path[1000]
    Set all_passed to all_passed and Test.assert_true(MathOps.absolute_value(final_value) < 5.0, "Final Brownian motion value reasonable")
    
    Note: Check increments are approximately normal
    Let increments be calculate_increments(bm_path)
    Let increment_stats be calculate_path_statistics(increments)
    
    Note: Increments should have mean ≈ 0
    Set all_passed to all_passed and assert_approximately_equal(increment_stats["mean"], 0.0, 0.05, "Brownian increments have zero mean")
    
    Note: Check quadratic variation ≈ T for Brownian motion
    Set all_passed to all_passed and Test.assert_true(path_stats["quadratic_variation"] > 0.8, "Quadratic variation reasonable lower bound")
    Set all_passed to all_passed and Test.assert_true(path_stats["quadratic_variation"] < 1.2, "Quadratic variation reasonable upper bound")
    
    Return all_passed

Process called "test_multidimensional_brownian_motion" that takes no parameters returns Boolean:
    Note: Test multidimensional correlated Brownian motion
    Let all_passed be True
    
    Note: Generate 3D Brownian motion
    Let time_grid be create_uniform_time_grid(0.0, 2.0, 501)  Note: 500 time steps over [0,2]
    Let bm_3d_paths be Stochastic.standard_brownian_motion(time_grid, 3, 54321)
    
    Set all_passed to all_passed and Test.assert_equal(Length(bm_3d_paths), 3, "Generated 3 dimensions")
    For dim from 0 to 2:
        Set all_passed to all_passed and Test.assert_equal(Length(bm_3d_paths[dim]), 501, "Dimension " + ToString(dim) + " correct length")
        Set all_passed to all_passed and assert_approximately_equal(bm_3d_paths[dim][0], 0.0, 1e-10, "Dimension " + ToString(dim) + " starts at 0")
    
    Note: Check independence of different dimensions (covariance ≈ 0)
    Let increments_x be calculate_increments(bm_3d_paths[0])
    Let increments_y be calculate_increments(bm_3d_paths[1])
    
    Let covariance be calculate_sample_covariance(increments_x, increments_y)
    Set all_passed to all_passed and Test.assert_true(MathOps.absolute_value(covariance) < 0.1, "Independent Brownian dimensions have low covariance")
    
    Return all_passed

Process called "calculate_sample_covariance" that takes x_samples as List[Float], y_samples as List[Float] returns Float:
    Note: Helper to calculate sample covariance
    Let n be Length(x_samples)
    Let x_mean be 0.0
    Let y_mean be 0.0
    
    For i from 0 to n - 1:
        Set x_mean to x_mean + x_samples[i]
        Set y_mean to y_mean + y_samples[i]
    Set x_mean to x_mean / Float(n)
    Set y_mean to y_mean / Float(n)
    
    Let cov_sum be 0.0
    For i from 0 to n - 1:
        Let x_dev be x_samples[i] - x_mean
        Let y_dev be y_samples[i] - y_mean
        Set cov_sum to cov_sum + (x_dev * y_dev)
    
    Return cov_sum / Float(n - 1)

Note: =====================================================================
Note: GEOMETRIC BROWNIAN MOTION TESTS
Note: =====================================================================

Process called "test_geometric_brownian_motion" that takes no parameters returns Boolean:
    Note: Test geometric Brownian motion for financial modeling
    Let all_passed be True
    
    Note: Generate GBM path with known parameters
    Let initial_value be 100.0
    Let drift be 0.05  Note: 5% annual drift
    Let volatility be 0.2  Note: 20% annual volatility
    Let time_grid be create_uniform_time_grid(0.0, 1.0, 251)  Note: Daily steps for 1 year
    
    Let gbm_path be Stochastic.geometric_brownian_motion(initial_value, drift, volatility, time_grid)
    
    Set all_passed to all_passed and Test.assert_equal(Length(gbm_path), 251, "GBM path correct length")
    Set all_passed to all_passed and assert_approximately_equal(gbm_path[0], initial_value, 1e-10, "GBM starts at initial value")
    
    Note: GBM should remain positive
    For each value in gbm_path:
        Set all_passed to all_passed and Test.assert_true(value > 0.0, "GBM value remains positive")
    
    Note: Check expected growth (approximate)
    Let final_value be gbm_path[250]
    Let expected_final be initial_value * MathOps.exponential(ToString(drift * 1.0), 15).result_value  Note: E[S(T)] = S(0) * exp(μT)
    
    Note: Due to volatility, final value will vary, but should be in reasonable range
    Set all_passed to all_passed and Test.assert_true(final_value > initial_value * 0.5, "GBM final value reasonable lower bound")
    Set all_passed to all_passed and Test.assert_true(final_value < initial_value * 3.0, "GBM final value reasonable upper bound")
    
    Note: Test log returns are approximately normal
    Let log_returns be List[Float]
    For i from 1 to 250:
        Let log_return be MathOps.logarithm_natural(ToString(gbm_path[i] / gbm_path[i-1]), 15).result_value
        Append Parse log_return as Float to log_returns
    
    Let return_stats be calculate_path_statistics(log_returns)
    Note: Mean log return should be approximately (μ - σ²/2) * dt
    Let dt be 1.0 / 250.0
    Let expected_mean_return be (drift - volatility * volatility / 2.0) * dt
    Set all_passed to all_passed and assert_approximately_equal(return_stats["mean"], expected_mean_return, 0.01, "GBM log returns mean")
    
    Return all_passed

Process called "test_gbm_option_pricing_validation" that takes no parameters returns Boolean:
    Note: Test GBM paths for option pricing validation
    Let all_passed be True
    
    Note: Generate multiple GBM paths for Monte Carlo option pricing
    Let S0 be 50.0
    Let r be 0.03  Note: Risk-free rate
    Let sigma be 0.3  Note: Volatility
    Let T be 0.25  Note: 3 months
    Let K be 52.0  Note: Strike price
    
    Let time_grid be create_uniform_time_grid(0.0, T, 64)  Note: 63 time steps
    Let num_paths be 1000
    
    Let option_payoffs be List[Float]
    
    For path_idx from 0 to num_paths - 1:
        Let gbm_path be Stochastic.geometric_brownian_motion(S0, r, sigma, time_grid)
        Let final_price be gbm_path[63]
        Let call_payoff be MathOps.maximum(final_price - K, 0.0)
        Append call_payoff to option_payoffs
    
    Note: Calculate average payoff and discount
    Let avg_payoff be calculate_path_statistics(option_payoffs)["mean"]
    Let option_price be avg_payoff * MathOps.exponential(ToString(-r * T), 15).result_value
    
    Note: Option price should be reasonable (between 0 and spot price)
    Set all_passed to all_passed and Test.assert_true(Parse option_price as Float > 0.0, "Option price positive")
    Set all_passed to all_passed and Test.assert_true(Parse option_price as Float < S0, "Option price less than spot")
    
    Note: For at-the-money options with these parameters, price should be in reasonable range
    Set all_passed to all_passed and Test.assert_true(Parse option_price as Float > 0.5, "Option price reasonable lower bound")
    Set all_passed to all_passed and Test.assert_true(Parse option_price as Float < 8.0, "Option price reasonable upper bound")
    
    Return all_passed

Note: =====================================================================
Note: ORNSTEIN-UHLENBECK PROCESS TESTS
Note: =====================================================================

Process called "test_ornstein_uhlenbeck_process" that takes no parameters returns Boolean:
    Note: Test Ornstein-Uhlenbeck mean-reverting process
    Let all_passed be True
    
    Note: OU process parameters
    Let theta be 2.0  Note: Mean reversion speed
    Let mu be 1.5    Note: Long-term mean
    Let sigma be 0.5  Note: Volatility
    Let X0 be 0.0    Note: Initial value
    Let time_grid be create_uniform_time_grid(0.0, 2.0, 1001)
    
    Let ou_path be Stochastic.ornstein_uhlenbeck_process(X0, theta, mu, sigma, time_grid)
    
    Set all_passed to all_passed and Test.assert_equal(Length(ou_path), 1001, "OU process path correct length")
    Set all_passed to all_passed and assert_approximately_equal(ou_path[0], X0, 1e-10, "OU process starts at initial value")
    
    Note: OU process should exhibit mean reversion
    Let path_stats be calculate_path_statistics(ou_path)
    
    Note: Long-term mean should be approached
    Note: After sufficient time, process should be close to mu
    Let final_portion be List[Float]
    For i from 800 to 1000:  Note: Last 20% of path
        Append ou_path[i] to final_portion
    
    Let final_stats be calculate_path_statistics(final_portion)
    Set all_passed to all_passed and Test.assert_true(MathOps.absolute_value(final_stats["mean"] - mu) < 1.0, "OU process exhibits mean reversion")
    
    Note: Process should be bounded (due to mean reversion)
    Set all_passed to all_passed and Test.assert_true(path_stats["range"] < 20.0, "OU process remains bounded due to mean reversion")
    
    Note: Check stationary variance formula: σ²/(2θ)
    Let theoretical_stationary_var be (sigma * sigma) / (2.0 * theta)
    Set all_passed to all_passed and Test.assert_true(final_stats["variance"] > theoretical_stationary_var * 0.3, "OU stationary variance reasonable lower bound")
    Set all_passed to all_passed and Test.assert_true(final_stats["variance"] < theoretical_stationary_var * 3.0, "OU stationary variance reasonable upper bound")
    
    Return all_passed

Process called "test_ou_autocorrelation_structure" that takes no parameters returns Boolean:
    Note: Test autocorrelation structure of Ornstein-Uhlenbeck process
    Let all_passed be True
    
    Note: Generate long OU path for autocorrelation analysis
    Let theta be 1.0
    Let mu be 0.0  Note: Zero mean for simplicity
    Let sigma be 1.0
    Let X0 be 0.0
    Let time_grid be create_uniform_time_grid(0.0, 10.0, 2001)  Note: Long time series
    
    Let ou_path be Stochastic.ornstein_uhlenbeck_process(X0, theta, mu, sigma, time_grid)
    
    Note: Calculate autocorrelation at various lags
    Let dt be 10.0 / 2000.0
    Let autocorr_result be calculate_autocorrelation(ou_path, 50)
    
    Note: Theoretical autocorrelation: ρ(τ) = exp(-θτ)
    Let lag_1_theoretical be MathOps.exponential(ToString(-theta * dt), 15).result_value
    Let lag_10_theoretical be MathOps.exponential(ToString(-theta * 10.0 * dt), 15).result_value
    
    Set all_passed to all_passed and assert_approximately_equal(autocorr_result.autocorrelations[1], Parse lag_1_theoretical as Float, 0.1, "OU autocorrelation lag 1")
    Set all_passed to all_passed and Test.assert_true(autocorr_result.autocorrelations[10] < autocorr_result.autocorrelations[1], "OU autocorrelation decays with lag")
    
    Return all_passed

Process called "calculate_autocorrelation" that takes series as List[Float], max_lag as Integer returns Dictionary[String, List[Float]]:
    Note: Calculate autocorrelation function for time series
    Let result be Collections.create_dictionary()
    Let n be Length(series)
    
    Note: Calculate mean
    Let mean be calculate_path_statistics(series)["mean"]
    
    Note: Calculate variance
    Let variance be calculate_path_statistics(series)["variance"]
    
    Let autocorrelations be List[Float]
    
    For lag from 0 to max_lag:
        Let covariance_sum be 0.0
        Let valid_pairs be 0
        
        For i from 0 to n - lag - 1:
            Let x1 be series[i] - mean
            Let x2 be series[i + lag] - mean
            Set covariance_sum to covariance_sum + (x1 * x2)
            Set valid_pairs to valid_pairs + 1
        
        Let covariance be covariance_sum / Float(valid_pairs)
        Let correlation be covariance / variance
        Append correlation to autocorrelations
    
    Set result["autocorrelations"] to autocorrelations
    Return result

Note: =====================================================================
Note: POISSON PROCESS TESTS
Note: =====================================================================

Process called "test_homogeneous_poisson_process" that takes no parameters returns Boolean:
    Note: Test homogeneous Poisson process generation
    Let all_passed be True
    
    Note: Generate Poisson process with rate λ = 3.0 over [0, 2]
    Let lambda_rate be 3.0
    Let time_horizon be 2.0
    Let poisson_config be Stochastic.PoissonProcessConfig
    Set poisson_config.intensity_type to "Constant"
    Set poisson_config.intensity_parameters to Collections.dictionary_with_pairs([["rate", lambda_rate]])
    Set poisson_config.time_horizon to time_horizon
    
    Let poisson_process be Stochastic.generate_poisson_process(poisson_config)
    
    Note: Check process properties
    Let num_arrivals be Length(poisson_process.arrival_times)
    Let expected_arrivals be lambda_rate * time_horizon  Note: E[N(t)] = λt
    
    Note: Number of arrivals should be reasonable (Poisson distributed)
    Set all_passed to all_passed and Test.assert_true(num_arrivals >= 0, "Non-negative number of arrivals")
    Set all_passed to all_passed and Test.assert_true(num_arrivals < 20, "Reasonable upper bound on arrivals")
    Set all_passed to all_passed and Test.assert_true(MathOps.absolute_value(Float(num_arrivals) - expected_arrivals) < 5.0, "Number of arrivals near expected value")
    
    Note: Arrival times should be ordered and within time horizon
    For i from 0 to num_arrivals - 1:
        Set all_passed to all_passed and Test.assert_true(poisson_process.arrival_times[i] >= 0.0, "Arrival time non-negative")
        Set all_passed to all_passed and Test.assert_true(poisson_process.arrival_times[i] <= time_horizon, "Arrival time within horizon")
        
        If i > 0:
            Set all_passed to all_passed and Test.assert_true(poisson_process.arrival_times[i] > poisson_process.arrival_times[i-1], "Arrival times ordered")
    
    Note: Inter-arrival times should be approximately exponential with rate λ
    If num_arrivals > 1:
        Let inter_arrivals be List[Float]
        For i from 1 to num_arrivals - 1:
            Let inter_arrival be poisson_process.arrival_times[i] - poisson_process.arrival_times[i-1]
            Append inter_arrival to inter_arrivals
        
        Let inter_arrival_stats be calculate_path_statistics(inter_arrivals)
        Let expected_mean_inter be 1.0 / lambda_rate
        Set all_passed to all_passed and assert_approximately_equal(inter_arrival_stats["mean"], expected_mean_inter, 0.5, "Inter-arrival times mean")
    
    Return all_passed

Process called "test_compound_poisson_process" that takes no parameters returns Boolean:
    Note: Test compound Poisson process with random jump sizes
    Let all_passed be True
    
    Note: Generate compound Poisson process
    Let lambda_rate be 2.0
    Let jump_mean be 1.0
    Let jump_std be 0.5
    Let time_horizon be 3.0
    
    Let compound_config be Stochastic.CompoundPoissonConfig
    Set compound_config.intensity_rate to lambda_rate
    Set compound_config.jump_distribution to "Normal"
    Set compound_config.jump_parameters to Collections.dictionary_with_pairs([["mean", jump_mean], ["std", jump_std]])
    Set compound_config.time_horizon to time_horizon
    
    Let compound_process be Stochastic.generate_compound_poisson_process(compound_config)
    
    Let num_jumps be Length(compound_process.jump_times)
    Set all_passed to all_passed and Test.assert_true(num_jumps >= 0, "Non-negative number of jumps")
    Set all_passed to all_passed and Test.assert_equal(Length(compound_process.jump_sizes), num_jumps, "Jump times and sizes have same length")
    
    Note: Check jump size distribution
    If num_jumps > 5:
        Let jump_stats be calculate_path_statistics(compound_process.jump_sizes)
        Set all_passed to all_passed and assert_approximately_equal(jump_stats["mean"], jump_mean, 0.5, "Jump sizes mean")
        Set all_passed to all_passed and Test.assert_true(jump_stats["variance"] > 0.0, "Jump sizes have positive variance")
    
    Note: Calculate process value at final time
    Let final_value be 0.0
    For each jump_size in compound_process.jump_sizes:
        Set final_value to final_value + jump_size
    
    Note: Expected final value is E[N(T)] * E[Jump size] = λT * μ
    Let expected_final be lambda_rate * time_horizon * jump_mean
    If num_jumps > 0:
        Set all_passed to all_passed and Test.assert_true(MathOps.absolute_value(final_value - expected_final) < 10.0, "Compound process final value reasonable")
    
    Return all_passed

Note: =====================================================================
Note: STOCHASTIC DIFFERENTIAL EQUATION TESTS
Note: =====================================================================

Process called "test_euler_maruyama_scheme" that takes no parameters returns Boolean:
    Note: Test Euler-Maruyama numerical scheme for SDEs
    Let all_passed be True
    
    Note: Solve dX = μX dt + σX dW (Geometric Brownian Motion SDE)
    Let sde_config be Stochastic.StochasticDifferentialEquation
    Set sde_config.equation_type to "Geometric_Brownian_Motion"
    Set sde_config.drift_coefficient["constant"] to "0.05"  Note: μ = 5%
    Set sde_config.diffusion_coefficient["constant"] to "0.2"  Note: σ = 20%
    Set sde_config.numerical_scheme to "Euler_Maruyama"
    
    Let initial_condition be Collections.create_dictionary()
    Set initial_condition["X0"] to 100.0
    Set initial_condition["t0"] to 0.0
    
    Let time_grid be create_uniform_time_grid(0.0, 1.0, 501)
    
    Let sde_solution be Stochastic.solve_sde(sde_config, initial_condition, time_grid)
    
    Set all_passed to all_passed and Test.assert_equal(Length(sde_solution.solution_path), 501, "SDE solution correct length")
    Set all_passed to all_passed and assert_approximately_equal(sde_solution.solution_path[0], 100.0, 1e-10, "SDE solution starts at initial condition")
    
    Note: Compare with analytical GBM solution
    Let gbm_analytical be Stochastic.geometric_brownian_motion(100.0, 0.05, 0.2, time_grid)
    
    Note: Numerical and analytical solutions should be similar (not exact due to different random paths)
    Let final_numerical be sde_solution.solution_path[500]
    Let final_analytical be gbm_analytical[500]
    
    Note: Both should be positive and in reasonable range
    Set all_passed to all_passed and Test.assert_true(final_numerical > 0.0, "Numerical SDE solution remains positive")
    Set all_passed to all_passed and Test.assert_true(final_analytical > 0.0, "Analytical GBM solution remains positive")
    Set all_passed to all_passed and Test.assert_true(final_numerical > 50.0, "Numerical solution reasonable lower bound")
    Set all_passed to all_passed and Test.assert_true(final_numerical < 200.0, "Numerical solution reasonable upper bound")
    
    Return all_passed

Process called "test_milstein_scheme" that takes no parameters returns Boolean:
    Note: Test Milstein scheme for higher-order SDE integration
    Let all_passed be True
    
    Note: Test on Cox-Ingersoll-Ross (CIR) model: dX = κ(θ - X)dt + σ√X dW
    Let cir_config be Stochastic.StochasticDifferentialEquation
    Set cir_config.equation_type to "Cox_Ingersoll_Ross"
    Set cir_config.drift_coefficient["kappa"] to "2.0"   Note: Mean reversion speed
    Set cir_config.drift_coefficient["theta"] to "0.05"  Note: Long-term mean
    Set cir_config.diffusion_coefficient["sigma"] to "0.3"  Note: Volatility
    Set cir_config.numerical_scheme to "Milstein"
    
    Let cir_initial be Collections.create_dictionary()
    Set cir_initial["X0"] to 0.03  Note: Initial interest rate 3%
    Set cir_initial["t0"] to 0.0
    
    Let time_grid be create_uniform_time_grid(0.0, 5.0, 1001)  Note: 5 years
    
    Let cir_solution be Stochastic.solve_sde(cir_config, cir_initial, time_grid)
    
    Set all_passed to all_passed and Test.assert_equal(Length(cir_solution.solution_path), 1001, "CIR solution correct length")
    
    Note: CIR process should remain non-negative (if Feller condition satisfied: 2κθ ≥ σ²)
    Let feller_condition be 2.0 * 2.0 * 0.05  Note: 2κθ = 0.2
    Let sigma_squared be 0.3 * 0.3  Note: σ² = 0.09
    Set all_passed to all_passed and Test.assert_true(feller_condition > sigma_squared, "Feller condition satisfied")
    
    For each value in cir_solution.solution_path:
        Set all_passed to all_passed and Test.assert_true(value >= -0.001, "CIR process remains non-negative (allowing small numerical error)")
    
    Note: Process should exhibit mean reversion to θ = 0.05
    Let final_portion be List[Float]
    For i from 800 to 1000:
        Append cir_solution.solution_path[i] to final_portion
    
    Let final_stats be calculate_path_statistics(final_portion)
    Set all_passed to all_passed and Test.assert_true(MathOps.absolute_value(final_stats["mean"] - 0.05) < 0.02, "CIR process exhibits mean reversion")
    
    Return all_passed

Note: =====================================================================
Note: JUMP DIFFUSION PROCESS TESTS
Note: =====================================================================

Process called "test_merton_jump_diffusion" that takes no parameters returns Boolean:
    Note: Test Merton jump diffusion model
    Let all_passed be True
    
    Note: Merton model: dS = μS dt + σS dW + S(e^J - 1) dN
    Note: Where N is Poisson process and J is normal jump size
    Let merton_config be Stochastic.JumpDiffusionConfig
    Set merton_config.process_type to "Merton"
    Set merton_config.drift_rate to 0.08
    Set merton_config.volatility to 0.25
    Set merton_config.jump_intensity to 1.0  Note: 1 jump per year on average
    Set merton_config.jump_size_mean to -0.1  Note: Negative jumps (crashes)
    Set merton_config.jump_size_std to 0.2
    
    Let initial_price be 100.0
    Let time_grid be create_uniform_time_grid(0.0, 1.0, 253)  Note: Daily over 1 year
    
    Let merton_path be Stochastic.simulate_jump_diffusion(merton_config, initial_price, time_grid)
    
    Set all_passed to all_passed and Test.assert_equal(Length(merton_path.price_path), 253, "Merton path correct length")
    Set all_passed to all_passed and assert_approximately_equal(merton_path.price_path[0], initial_price, 1e-10, "Merton starts at initial price")
    
    Note: Process should remain positive
    For each price in merton_path.price_path:
        Set all_passed to all_passed and Test.assert_true(price > 0.0, "Merton price remains positive")
    
    Note: Check for presence of jumps
    Let daily_returns be List[Float]
    For i from 1 to 252:
        Let daily_return be (merton_path.price_path[i] - merton_path.price_path[i-1]) / merton_path.price_path[i-1]
        Append daily_return to daily_returns
    
    Let return_stats be calculate_path_statistics(daily_returns)
    
    Note: Jump diffusion should have higher variance than pure diffusion
    Note: And potentially some extreme returns (jumps)
    Set all_passed to all_passed and Test.assert_true(return_stats["variance"] > 0.0, "Returns have positive variance")
    
    Note: Check if we observed any jumps (large price movements)
    Let extreme_moves be 0
    For each daily_return in daily_returns:
        If MathOps.absolute_value(daily_return) > 0.05:  Note: 5% daily move
            Set extreme_moves to extreme_moves + 1
    
    Note: With jump intensity 1.0, we expect some jumps over the year
    Note: But this is random, so we can't guarantee jumps in every simulation
    Set all_passed to all_passed and Test.assert_true(extreme_moves >= 0, "Non-negative number of extreme moves")
    
    Return all_passed

Note: =====================================================================
Note: ERROR HANDLING AND EDGE CASES TESTS
Note: =====================================================================

Process called "test_stochastic_error_handling" that takes no parameters returns Boolean:
    Note: Test error handling for invalid stochastic process parameters
    Let all_passed be True
    
    Note: Test invalid time grid (non-increasing)
    Try:
        Let bad_time_grid be [0.0, 1.0, 0.5, 2.0]  Note: Not monotonic
        Let bad_bm be Stochastic.standard_brownian_motion(bad_time_grid, 1, 123)
        Set all_passed to Test.assert_true(False, "Non-monotonic time grid should throw error")
    Catch error as Errors.InvalidOperation:
        Set all_passed to all_passed and Test.assert_true(True, "Non-monotonic time grid correctly rejected")
    
    Note: Test invalid GBM parameters
    Try:
        Let time_grid be [0.0, 1.0, 2.0]
        Let bad_gbm be Stochastic.geometric_brownian_motion(100.0, 0.1, -0.2, time_grid)  Note: Negative volatility
        Set all_passed to Test.assert_true(False, "Negative volatility should throw error")
    Catch error as Errors.InvalidOperation:
        Set all_passed to all_passed and Test.assert_true(True, "Negative volatility correctly rejected")
    
    Note: Test invalid OU parameters
    Try:
        Let time_grid be [0.0, 1.0]
        Let bad_ou be Stochastic.ornstein_uhlenbeck_process(0.0, -1.0, 1.0, 0.5, time_grid)  Note: Negative mean reversion
        Set all_passed to Test.assert_true(False, "Negative mean reversion speed should throw error")
    Catch error as Errors.InvalidOperation:
        Set all_passed to all_passed and Test.assert_true(True, "Invalid OU parameters correctly rejected")
    
    Note: Test invalid Poisson process rate
    Try:
        Let bad_poisson_config be Stochastic.PoissonProcessConfig
        Set bad_poisson_config.intensity_type to "Constant"
        Set bad_poisson_config.intensity_parameters to Collections.dictionary_with_pairs([["rate", -2.0]])  Note: Negative rate
        Set bad_poisson_config.time_horizon to 1.0
        
        Let bad_poisson be Stochastic.generate_poisson_process(bad_poisson_config)
        Set all_passed to Test.assert_true(False, "Negative Poisson rate should throw error")
    Catch error as Errors.InvalidOperation:
        Set all_passed to all_passed and Test.assert_true(True, "Negative Poisson rate correctly rejected")
    
    Return all_passed

Process called "test_numerical_stability" that takes no parameters returns Boolean:
    Note: Test numerical stability with extreme parameters
    Let all_passed be True
    
    Note: Test Brownian motion with very fine time grid
    Let fine_time_grid be create_uniform_time_grid(0.0, 1.0, 10001)  Note: Very small dt
    Let fine_bm be Stochastic.standard_brownian_motion(fine_time_grid, 1, 999)
    
    Set all_passed to all_passed and Test.assert_equal(Length(fine_bm[0]), 10001, "Fine grid Brownian motion generated")
    
    Note: Path should still have reasonable properties
    Let fine_stats be calculate_path_statistics(fine_bm[0])
    Set all_passed to all_passed and Test.assert_true(fine_stats["quadratic_variation"] > 0.8, "Fine grid maintains quadratic variation")
    Set all_passed to all_passed and Test.assert_true(fine_stats["quadratic_variation"] < 1.2, "Fine grid quadratic variation reasonable")
    
    Note: Test GBM with extreme volatility
    Let time_grid be create_uniform_time_grid(0.0, 0.1, 101)  Note: Short time horizon
    Let extreme_vol_gbm be Stochastic.geometric_brownian_motion(100.0, 0.0, 2.0, time_grid)  Note: 200% volatility
    
    Note: Should remain positive despite high volatility
    For each value in extreme_vol_gbm:
        Set all_passed to all_passed and Test.assert_true(value > 0.0, "Extreme volatility GBM remains positive")
    
    Note: High volatility should produce wide range
    Let extreme_stats be calculate_path_statistics(extreme_vol_gbm)
    Set all_passed to all_passed and Test.assert_true(extreme_stats["range"] > 10.0, "High volatility produces wide range")
    
    Return all_passed

Note: =====================================================================
Note: MAIN TEST RUNNER
Note: =====================================================================

Process called "run_all_stochastic_tests" that takes no parameters returns Boolean:
    Note: Execute all stochastic process tests and report results
    Test.print_test_header("STOCHASTIC PROCESSES MODULE TESTS")
    Let all_passed be True
    
    Note: Brownian Motion Tests
    Test.print_test_section("Brownian Motion Tests")
    Set all_passed to all_passed and test_standard_brownian_motion()
    Set all_passed to all_passed and test_multidimensional_brownian_motion()
    
    Note: Geometric Brownian Motion Tests
    Test.print_test_section("Geometric Brownian Motion Tests")
    Set all_passed to all_passed and test_geometric_brownian_motion()
    Set all_passed to all_passed and test_gbm_option_pricing_validation()
    
    Note: Ornstein-Uhlenbeck Process Tests
    Test.print_test_section("Ornstein-Uhlenbeck Process Tests")
    Set all_passed to all_passed and test_ornstein_uhlenbeck_process()
    Set all_passed to all_passed and test_ou_autocorrelation_structure()
    
    Note: Poisson Process Tests
    Test.print_test_section("Poisson Process Tests")
    Set all_passed to all_passed and test_homogeneous_poisson_process()
    Set all_passed to all_passed and test_compound_poisson_process()
    
    Note: Stochastic Differential Equation Tests
    Test.print_test_section("Stochastic Differential Equation Tests")
    Set all_passed to all_passed and test_euler_maruyama_scheme()
    Set all_passed to all_passed and test_milstein_scheme()
    
    Note: Jump Diffusion Process Tests
    Test.print_test_section("Jump Diffusion Process Tests")
    Set all_passed to all_passed and test_merton_jump_diffusion()
    
    Note: Error Handling and Edge Cases Tests
    Test.print_test_section("Error Handling and Edge Cases Tests")
    Set all_passed to all_passed and test_stochastic_error_handling()
    Set all_passed to all_passed and test_numerical_stability()
    
    Test.print_test_footer("STOCHASTIC TESTS", all_passed)
    Return all_passed

Note: Entry point for individual test execution
Let test_result be run_all_stochastic_tests()
If test_result:
    Test.print_success("All stochastic processes tests passed!")
Otherwise:
    Test.print_failure("Some stochastic processes tests failed!")
    Test.exit_with_code(1)