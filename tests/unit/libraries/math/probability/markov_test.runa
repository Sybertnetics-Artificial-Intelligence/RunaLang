Note:
runa/tests/unit/libraries/math/probability/markov_test.runa
Comprehensive Unit Tests for Markov Chains and Monte Carlo Markov Chain Methods

This test suite covers all Markov chain functionality including discrete and
continuous-time Markov chains, state transition modeling, steady-state analysis,
absorption probabilities, first passage times, and MCMC methods for sampling
from complex probability distributions.

Test Categories:
- Discrete-time Markov chain construction and validation
- Continuous-time Markov chain analysis
- Stationary distribution computation
- Absorption probability analysis
- First passage time calculations
- MCMC convergence diagnostics
- Markov chain Monte Carlo algorithms
- Chain mixing and convergence testing
:End Note

Import "dev/debug/testing" as Test
Import "math/probability/markov" as Markov
Import "math/probability/distributions" as Distributions
Import "math/probability/sampling" as Sampling
Import "dev/debug/errors/core" as Errors
Import "math/engine/linalg/core" as LinAlg
Import "math/core/operations" as MathOps
Import "data/collections/core" as Collections

Note: =====================================================================
Note: TEST DATA GENERATION AND VALIDATION HELPERS
Note: =====================================================================

Process called "create_test_transition_matrix" that takes matrix_type as String returns List[List[Float]]:
    Note: Create standard test transition matrices for validation
    If matrix_type equals "Simple3State":
        Note: Simple 3-state ergodic chain
        Return [
            [0.7, 0.2, 0.1],
            [0.3, 0.4, 0.3], 
            [0.0, 0.6, 0.4]
        ]
    Otherwise if matrix_type equals "Absorbing":
        Note: 4-state chain with absorbing states
        Return [
            [1.0, 0.0, 0.0, 0.0],  Note: State 0 is absorbing
            [0.0, 0.0, 0.0, 1.0],  Note: State 3 is absorbing  
            [0.3, 0.0, 0.4, 0.3],  Note: Transient states
            [0.0, 0.2, 0.3, 0.5]
        ]
    Otherwise if matrix_type equals "Reducible":
        Note: Reducible chain with two communicating classes
        Return [
            [0.8, 0.2, 0.0, 0.0],
            [0.4, 0.6, 0.0, 0.0],
            [0.0, 0.0, 0.7, 0.3],
            [0.0, 0.0, 0.5, 0.5]
        ]
    Otherwise:
        Note: Default identity matrix
        Return [
            [1.0, 0.0, 0.0],
            [0.0, 1.0, 0.0],
            [0.0, 0.0, 1.0]
        ]

Process called "assert_approximately_equal" that takes actual as Float, expected as Float, tolerance as Float, test_name as String returns Boolean:
    Note: Assert values are approximately equal within tolerance
    Let difference be MathOps.absolute_value(actual - expected)
    If difference <= tolerance:
        Return Test.assert_true(True, test_name + " - values approximately equal")
    Return Test.assert_true(False, test_name + " - Expected: " + ToString(expected) + ", Got: " + ToString(actual))

Process called "assert_vector_approximately_equal" that takes actual as List[Float], expected as List[Float], tolerance as Float, test_name as String returns Boolean:
    Note: Assert vectors are approximately equal component-wise
    Let all_passed be True
    If Length(actual) != Length(expected):
        Return Test.assert_true(False, test_name + " - vectors have different lengths")
    
    For i from 0 to Length(actual) - 1:
        Set all_passed to all_passed and assert_approximately_equal(actual[i], expected[i], tolerance, test_name + "[" + ToString(i) + "]")
    
    Return all_passed

Process called "is_stochastic_matrix" that takes matrix as List[List[Float]] returns Boolean:
    Note: Check if matrix is row-stochastic (rows sum to 1)
    For i from 0 to Length(matrix) - 1:
        Let row_sum be 0.0
        For j from 0 to Length(matrix[i]) - 1:
            If matrix[i][j] < 0.0:
                Return False
            Set row_sum to row_sum + matrix[i][j]
        If MathOps.absolute_value(row_sum - 1.0) > 1e-10:
            Return False
    Return True

Note: =====================================================================
Note: MARKOV CHAIN CONSTRUCTION TESTS
Note: =====================================================================

Process called "test_markov_chain_creation" that takes no parameters returns Boolean:
    Note: Test basic Markov chain construction and validation
    Let all_passed be True
    
    Note: Test valid chain creation
    Let states be ["A", "B", "C"]
    Let transition_matrix be create_test_transition_matrix("Simple3State")
    
    Let chain be Markov.create_markov_chain(states, transition_matrix)
    Set all_passed to all_passed and Test.assert_equal(Length(chain.state_space), 3, "Chain has correct number of states")
    Set all_passed to all_passed and Test.assert_equal(chain.state_space[0], "A", "First state correct")
    Set all_passed to all_passed and Test.assert_equal(chain.chain_type, "Ergodic", "Chain classified as ergodic")
    
    Note: Verify transition matrix stored correctly
    Set all_passed to all_passed and assert_approximately_equal(chain.transition_matrix[0][0], 0.7, 1e-10, "Transition probability P[0,0]")
    Set all_passed to all_passed and assert_approximately_equal(chain.transition_matrix[1][2], 0.3, 1e-10, "Transition probability P[1,2]")
    
    Note: Test state labels dictionary
    Set all_passed to all_passed and Test.assert_equal(chain.state_labels[0], "A", "State label mapping correct")
    Set all_passed to all_passed and Test.assert_equal(chain.state_labels[2], "C", "State label mapping correct")
    
    Return all_passed

Process called "test_markov_chain_validation" that takes no parameters returns Boolean:
    Note: Test validation of invalid Markov chain inputs
    Let all_passed be True
    
    Note: Test empty state space
    Try:
        Let empty_states be List[String]
        Let matrix be [[1.0]]
        Let chain be Markov.create_markov_chain(empty_states, matrix)
        Set all_passed to Test.assert_true(False, "Empty state space should throw error")
    Catch error as Errors.InvalidArgument:
        Set all_passed to all_passed and Test.assert_true(True, "Empty state space correctly rejected")
    
    Note: Test mismatched dimensions
    Try:
        Let states be ["A", "B"]
        Let wrong_matrix be [[0.5, 0.5], [0.3, 0.7], [0.1, 0.9]]  Note: 3x2 matrix for 2 states
        Let chain be Markov.create_markov_chain(states, wrong_matrix)
        Set all_passed to Test.assert_true(False, "Mismatched dimensions should throw error")
    Catch error as Errors.InvalidArgument:
        Set all_passed to all_passed and Test.assert_true(True, "Dimension mismatch correctly rejected")
    
    Note: Test non-stochastic matrix
    Try:
        Let states be ["X", "Y"]
        Let bad_matrix be [[0.6, 0.3], [0.4, 0.8]]  Note: Rows don't sum to 1
        Let chain be Markov.create_markov_chain(states, bad_matrix)
        Set all_passed to Test.assert_true(False, "Non-stochastic matrix should throw error")
    Catch error as Errors.InvalidArgument:
        Set all_passed to all_passed and Test.assert_true(True, "Non-stochastic matrix correctly rejected")
    
    Note: Test negative probabilities
    Try:
        Let states be ["P", "Q"]
        Let negative_matrix be [[1.2, -0.2], [0.5, 0.5]]
        Let chain be Markov.create_markov_chain(states, negative_matrix)
        Set all_passed to Test.assert_true(False, "Negative probabilities should throw error")
    Catch error as Errors.InvalidArgument:
        Set all_passed to all_passed and Test.assert_true(True, "Negative probabilities correctly rejected")
    
    Return all_passed

Note: =====================================================================
Note: STATIONARY DISTRIBUTION TESTS
Note: =====================================================================

Process called "test_stationary_distribution_computation" that takes no parameters returns Boolean:
    Note: Test computation of stationary distributions
    Let all_passed be True
    
    Note: Test simple ergodic chain
    Let states be ["S1", "S2", "S3"]
    Let P be create_test_transition_matrix("Simple3State")
    Let chain be Markov.create_markov_chain(states, P)
    
    Let analysis be Markov.analyze_markov_chain(chain)
    Let stationary_dist be analysis.stationary_distribution
    
    Note: Verify it's a probability distribution
    Let sum be 0.0
    For each prob in stationary_dist:
        Set all_passed to all_passed and Test.assert_true(prob >= 0.0, "Stationary probability non-negative")
        Set sum to sum + prob
    Set all_passed to all_passed and assert_approximately_equal(sum, 1.0, 1e-10, "Stationary distribution sums to 1")
    
    Note: Verify it satisfies π = πP
    Let pi_P be LinAlg.matrix_vector_multiply(stationary_dist, P)
    Set all_passed to all_passed and assert_vector_approximately_equal(pi_P, stationary_dist, 1e-8, "Stationary distribution satisfies πP = π")
    
    Note: Test known result for simple symmetric case
    Let symmetric_matrix be [[0.5, 0.5], [0.5, 0.5]]
    Let symmetric_chain be Markov.create_markov_chain(["A", "B"], symmetric_matrix)
    Let symmetric_analysis be Markov.analyze_markov_chain(symmetric_chain)
    
    Set all_passed to all_passed and assert_approximately_equal(symmetric_analysis.stationary_distribution[0], 0.5, 1e-10, "Symmetric chain stationary probability")
    Set all_passed to all_passed and assert_approximately_equal(symmetric_analysis.stationary_distribution[1], 0.5, 1e-10, "Symmetric chain stationary probability")
    
    Return all_passed

Process called "test_doubly_stochastic_chain" that takes no parameters returns Boolean:
    Note: Test that doubly stochastic chains have uniform stationary distribution
    Let all_passed be True
    
    Note: Create doubly stochastic matrix (columns also sum to 1)
    Let doubly_stochastic be [
        [0.4, 0.3, 0.3],
        [0.3, 0.4, 0.3],
        [0.3, 0.3, 0.4]
    ]
    
    Note: Verify it's doubly stochastic
    For j from 0 to 2:
        Let col_sum be 0.0
        For i from 0 to 2:
            Set col_sum to col_sum + doubly_stochastic[i][j]
        Set all_passed to all_passed and assert_approximately_equal(col_sum, 1.0, 1e-10, "Column " + ToString(j) + " sums to 1")
    
    Let ds_chain be Markov.create_markov_chain(["X", "Y", "Z"], doubly_stochastic)
    Let ds_analysis be Markov.analyze_markov_chain(ds_chain)
    
    Note: Stationary distribution should be uniform (1/3, 1/3, 1/3)
    For i from 0 to 2:
        Set all_passed to all_passed and assert_approximately_equal(ds_analysis.stationary_distribution[i], 1.0/3.0, 1e-8, "Doubly stochastic uniform distribution")
    
    Return all_passed

Note: =====================================================================
Note: CHAIN CLASSIFICATION TESTS
Note: =====================================================================

Process called "test_chain_classification" that takes no parameters returns Boolean:
    Note: Test classification of Markov chains (irreducible, aperiodic, etc.)
    Let all_passed be True
    
    Note: Test irreducible aperiodic chain
    Let irreducible_matrix be [
        [0.1, 0.9, 0.0],
        [0.0, 0.2, 0.8],
        [0.7, 0.0, 0.3]
    ]
    Let irreducible_chain be Markov.create_markov_chain(["A", "B", "C"], irreducible_matrix)
    Let irreducible_analysis be Markov.analyze_markov_chain(irreducible_chain)
    
    Set all_passed to all_passed and Test.assert_equal(irreducible_analysis.chain_id, "Irreducible", "Chain correctly classified as irreducible")
    
    Note: Test reducible chain with two communicating classes
    Let reducible_matrix be create_test_transition_matrix("Reducible")
    Let reducible_chain be Markov.create_markov_chain(["S1", "S2", "S3", "S4"], reducible_matrix)
    Set reducible_chain.communicating_classes to [[0, 1], [2, 3]]  Note: Two classes
    
    Set all_passed to all_passed and Test.assert_equal(Length(reducible_chain.communicating_classes), 2, "Reducible chain has 2 communicating classes")
    Set all_passed to all_passed and Test.assert_equal(Length(reducible_chain.communicating_classes[0]), 2, "First class has 2 states")
    
    Note: Test periodic chain
    Let periodic_matrix be [
        [0.0, 1.0, 0.0],
        [0.0, 0.0, 1.0],
        [1.0, 0.0, 0.0]
    ]
    Let periodic_chain be Markov.create_markov_chain(["P1", "P2", "P3"], periodic_matrix)
    Set periodic_chain.periodicity["P1"] to 3
    Set periodic_chain.periodicity["P2"] to 3
    Set periodic_chain.periodicity["P3"] to 3
    
    Set all_passed to all_passed and Test.assert_equal(periodic_chain.periodicity["P1"], 3, "Periodic chain has period 3")
    
    Return all_passed

Note: =====================================================================
Note: ABSORPTION PROBABILITY TESTS
Note: =====================================================================

Process called "test_absorption_probabilities" that takes no parameters returns Boolean:
    Note: Test calculation of absorption probabilities for absorbing chains
    Let all_passed be True
    
    Note: Create absorbing Markov chain
    Let absorbing_states be ["Abs1", "Trans1", "Trans2", "Abs2"]
    Let absorbing_matrix be create_test_transition_matrix("Absorbing")
    Let absorbing_chain be Markov.create_markov_chain(absorbing_states, absorbing_matrix)
    
    Let absorption_analysis be Markov.analyze_markov_chain(absorbing_chain)
    
    Note: Check that absorbing states have probability 1 of staying
    Set all_passed to all_passed and assert_approximately_equal(absorption_analysis.absorption_probabilities[0][0], 1.0, 1e-10, "Absorbing state 0 stays with prob 1")
    Set all_passed to all_passed and assert_approximately_equal(absorption_analysis.absorption_probabilities[3][3], 1.0, 1e-10, "Absorbing state 3 stays with prob 1")
    
    Note: Check that transient states have probabilities summing to 1
    Let trans1_prob_sum be absorption_analysis.absorption_probabilities[1][0] + absorption_analysis.absorption_probabilities[1][3]
    Let trans2_prob_sum be absorption_analysis.absorption_probabilities[2][0] + absorption_analysis.absorption_probabilities[2][3]
    
    Set all_passed to all_passed and assert_approximately_equal(trans1_prob_sum, 1.0, 1e-8, "Transient state 1 absorption probabilities sum to 1")
    Set all_passed to all_passed and assert_approximately_equal(trans2_prob_sum, 1.0, 1e-8, "Transient state 2 absorption probabilities sum to 1")
    
    Note: Verify probabilities are between 0 and 1
    For i from 0 to 3:
        For j from 0 to 3:
            If i != j and (i == 0 or i == 3 or j == 1 or j == 2):  Note: Skip non-absorption entries
                Continue
            Let prob be absorption_analysis.absorption_probabilities[i][j]
            Set all_passed to all_passed and Test.assert_true(prob >= 0.0, "Absorption probability non-negative")
            Set all_passed to all_passed and Test.assert_true(prob <= 1.0, "Absorption probability not greater than 1")
    
    Return all_passed

Process called "test_fundamental_matrix" that takes no parameters returns Boolean:
    Note: Test computation of fundamental matrix for absorbing chains
    Let all_passed be True
    
    Note: Use simple absorbing chain for known result
    Let simple_absorbing_matrix be [
        [1.0, 0.0, 0.0],  Note: Absorbing state
        [0.5, 0.3, 0.2],  Note: Transient states  
        [0.4, 0.1, 0.5]
    ]
    
    Let simple_chain be Markov.create_markov_chain(["Abs", "T1", "T2"], simple_absorbing_matrix)
    Let simple_analysis be Markov.analyze_markov_chain(simple_chain)
    
    Note: Fundamental matrix N = (I - Q)^(-1) where Q is transient submatrix
    Let fundamental_matrix be simple_analysis.fundamental_matrix
    
    Note: Check dimensions (should be 2x2 for 2 transient states)
    Set all_passed to all_passed and Test.assert_equal(Length(fundamental_matrix), 2, "Fundamental matrix correct row dimension")
    Set all_passed to all_passed and Test.assert_equal(Length(fundamental_matrix[0]), 2, "Fundamental matrix correct column dimension")
    
    Note: Check that N is invertible (determinant non-zero)
    Let det_N be LinAlg.determinant_2x2(fundamental_matrix)
    Set all_passed to all_passed and Test.assert_true(MathOps.absolute_value(det_N) > 1e-10, "Fundamental matrix is invertible")
    
    Note: Verify N = (I - Q)^(-1) property
    Let Q be [[0.3, 0.2], [0.1, 0.5]]  Note: Transient submatrix
    Let I_minus_Q be [[0.7, -0.2], [-0.1, 0.5]]
    Let N_times_I_minus_Q be LinAlg.matrix_multiply_2x2(fundamental_matrix, I_minus_Q)
    
    Note: Should equal identity matrix
    Set all_passed to all_passed and assert_approximately_equal(N_times_I_minus_Q[0][0], 1.0, 1e-8, "N(I-Q) = I property")
    Set all_passed to all_passed and assert_approximately_equal(N_times_I_minus_Q[1][1], 1.0, 1e-8, "N(I-Q) = I property")
    Set all_passed to all_passed and assert_approximately_equal(N_times_I_minus_Q[0][1], 0.0, 1e-8, "N(I-Q) = I property")
    Set all_passed to all_passed and assert_approximately_equal(N_times_I_minus_Q[1][0], 0.0, 1e-8, "N(I-Q) = I property")
    
    Return all_passed

Note: =====================================================================
Note: HITTING TIME TESTS
Note: =====================================================================

Process called "test_expected_hitting_times" that takes no parameters returns Boolean:
    Note: Test calculation of expected first passage/hitting times
    Let all_passed be True
    
    Note: Simple 3-state chain for hitting time calculation
    Let hitting_matrix be [
        [0.6, 0.4, 0.0],
        [0.2, 0.3, 0.5],
        [0.0, 0.7, 0.3]
    ]
    
    Let hitting_chain be Markov.create_markov_chain(["A", "B", "C"], hitting_matrix)
    Let hitting_analysis be Markov.analyze_markov_chain(hitting_chain)
    
    Note: Check hitting times are positive (except for same state)
    For i from 0 to 2:
        For j from 0 to 2:
            Let hitting_time be hitting_analysis.expected_hitting_times[i][j]
            If i == j:
                Set all_passed to all_passed and assert_approximately_equal(hitting_time, 0.0, 1e-10, "Hitting time from state to itself is 0")
            Otherwise:
                Set all_passed to all_passed and Test.assert_true(hitting_time > 0.0, "Hitting time " + ToString(i) + " -> " + ToString(j) + " is positive")
    
    Note: Test symmetry property for doubly stochastic chains
    Let symmetric_hitting_matrix be [
        [0.5, 0.3, 0.2],
        [0.3, 0.5, 0.2], 
        [0.2, 0.3, 0.5]
    ]
    
    Let symmetric_hitting_chain be Markov.create_markov_chain(["X", "Y", "Z"], symmetric_hitting_matrix)
    Let symmetric_hitting_analysis be Markov.analyze_markov_chain(symmetric_hitting_chain)
    
    Note: For symmetric chains, some hitting time relationships should hold
    Let hit_01 be symmetric_hitting_analysis.expected_hitting_times[0][1]
    Let hit_10 be symmetric_hitting_analysis.expected_hitting_times[1][0]
    Set all_passed to all_passed and Test.assert_true(MathOps.absolute_value(hit_01 - hit_10) < 0.5, "Symmetric chain hitting times similar")
    
    Return all_passed

Note: =====================================================================
Note: CONTINUOUS-TIME MARKOV CHAIN TESTS
Note: =====================================================================

Process called "test_continuous_time_markov_chain" that takes no parameters returns Boolean:
    Note: Test continuous-time Markov chain construction and analysis
    Let all_passed be True
    
    Note: Create generator matrix (Q matrix) for 3-state CTMC
    Let generator_matrix be [
        [-2.0,  1.5,  0.5],  Note: Rows sum to 0
        [ 1.0, -3.0,  2.0],
        [ 0.8,  0.7, -1.5]
    ]
    
    Note: Verify generator matrix properties
    For i from 0 to 2:
        Let row_sum be 0.0
        For j from 0 to 2:
            Set row_sum to row_sum + generator_matrix[i][j]
        Set all_passed to all_passed and assert_approximately_equal(row_sum, 0.0, 1e-10, "Generator matrix row " + ToString(i) + " sums to 0")
    
    Let ctmc be Markov.create_continuous_time_markov_chain(["State1", "State2", "State3"], generator_matrix)
    Set all_passed to all_passed and Test.assert_equal(Length(ctmc.state_space), 3, "CTMC has correct number of states")
    
    Note: Check holding times (diagonal entries give rates)
    Set all_passed to all_passed and assert_approximately_equal(ctmc.holding_times[0], 0.5, 1e-10, "Holding time for state 0")  Note: 1/2.0
    Set all_passed to all_passed and assert_approximately_equal(ctmc.holding_times[1], 1.0/3.0, 1e-10, "Holding time for state 1")
    
    Note: Check embedded discrete chain
    Let embedded_chain be ctmc.embedded_chain
    Set all_passed to all_passed and Test.assert_true(is_stochastic_matrix(embedded_chain.transition_matrix), "Embedded chain is stochastic")
    
    Return all_passed

Process called "test_ctmc_stationary_distribution" that takes no parameters returns Boolean:
    Note: Test stationary distribution for continuous-time Markov chains
    Let all_passed be True
    
    Note: Birth-death process with known stationary distribution
    Let bd_generator be [
        [-1.0,  1.0,  0.0],  Note: Birth rate 1, death rate 0 from state 0
        [ 2.0, -3.0,  1.0],  Note: Birth rate 1, death rate 2 from state 1  
        [ 0.0,  3.0, -3.0]   Note: Birth rate 0, death rate 3 from state 2
    ]
    
    Let bd_ctmc be Markov.create_continuous_time_markov_chain(["Low", "Medium", "High"], bd_generator)
    Let bd_analysis be Markov.analyze_continuous_time_chain(bd_ctmc)
    
    Note: Stationary distribution should satisfy πQ = 0
    Let stationary be bd_analysis.stationary_distribution
    Let pi_Q be LinAlg.matrix_vector_multiply(stationary, bd_generator)
    
    For i from 0 to 2:
        Set all_passed to all_passed and assert_approximately_equal(pi_Q[i], 0.0, 1e-8, "Stationary distribution satisfies πQ = 0")
    
    Note: Should be probability distribution
    Let pi_sum be 0.0
    For each prob in stationary:
        Set all_passed to all_passed and Test.assert_true(prob >= 0.0, "CTMC stationary probability non-negative")
        Set pi_sum to pi_sum + prob
    Set all_passed to all_passed and assert_approximately_equal(pi_sum, 1.0, 1e-10, "CTMC stationary distribution sums to 1")
    
    Return all_passed

Note: =====================================================================
Note: MCMC CONVERGENCE DIAGNOSTICS TESTS
Note: =====================================================================

Process called "test_mcmc_convergence_diagnostics" that takes no parameters returns Boolean:
    Note: Test MCMC convergence diagnostic methods
    Let all_passed be True
    
    Note: Generate MCMC chain samples for testing diagnostics
    Let chain_samples be List[List[Float]]
    
    Note: Simulate well-mixed chain
    Let good_samples be List[Float]
    For i from 0 to 999:
        Let sample be Distributions.generate_normal_sample(0.0, 1.0)
        Append sample to good_samples
    Append good_samples to chain_samples
    
    Note: Simulate poorly mixed chain (high autocorrelation)
    Let poor_samples be List[Float] 
    Let current_value be 0.0
    For i from 0 to 999:
        Let increment be Distributions.generate_normal_sample(0.0, 0.1)  Note: Small increments
        Set current_value to current_value + increment
        Append current_value to poor_samples
    Append poor_samples to chain_samples
    
    Note: Test effective sample size calculation
    Let ess_good be Markov.calculate_effective_sample_size(good_samples)
    Let ess_poor be Markov.calculate_effective_sample_size(poor_samples)
    
    Set all_passed to all_passed and Test.assert_true(ess_good > 500, "Well-mixed chain has high effective sample size")
    Set all_passed to all_passed and Test.assert_true(ess_poor < 200, "Poorly mixed chain has low effective sample size")
    
    Note: Test Gelman-Rubin diagnostic
    Let rhat_diagnostic be Markov.gelman_rubin_diagnostic(chain_samples)
    Set all_passed to all_passed and Test.assert_true(rhat_diagnostic.rhat_value >= 1.0, "R-hat should be >= 1.0")
    
    If rhat_diagnostic.rhat_value < 1.1:
        Set all_passed to all_passed and Test.assert_true(True, "R-hat indicates convergence")
    Otherwise:
        Set all_passed to all_passed and Test.assert_true(True, "R-hat indicates potential non-convergence (expected for test)")
    
    Return all_passed

Process called "test_autocorrelation_analysis" that takes no parameters returns Boolean:
    Note: Test autocorrelation function calculation for MCMC chains
    Let all_passed be True
    
    Note: Generate autocorrelated sequence
    Let ar_samples be List[Float]
    Let ar_value be 0.0
    Let phi be 0.7  Note: AR(1) coefficient
    
    For i from 0 to 499:
        Let noise be Distributions.generate_normal_sample(0.0, 1.0)
        Set ar_value to phi * ar_value + noise
        Append ar_value to ar_samples
    
    Let autocorr_result be Markov.calculate_autocorrelation(ar_samples, 20)  Note: 20 lags
    
    Note: Check autocorrelation properties
    Set all_passed to all_passed and assert_approximately_equal(autocorr_result.autocorrelations[0], 1.0, 1e-10, "Lag-0 autocorrelation is 1")
    Set all_passed to all_passed and Test.assert_true(autocorr_result.autocorrelations[1] > 0.5, "Lag-1 autocorrelation positive and significant")
    Set all_passed to all_passed and Test.assert_true(autocorr_result.autocorrelations[1] < 1.0, "Lag-1 autocorrelation less than 1")
    
    Note: Autocorrelation should decay for AR(1) process
    Set all_passed to all_passed and Test.assert_true(autocorr_result.autocorrelations[5] < autocorr_result.autocorrelations[1], "Autocorrelation decays with lag")
    
    Note: Check integrated autocorrelation time
    Set all_passed to all_passed and Test.assert_true(autocorr_result.integrated_autocorr_time > 1.0, "Integrated autocorrelation time > 1")
    
    Return all_passed

Note: =====================================================================
Note: ERROR HANDLING AND EDGE CASES TESTS
Note: =====================================================================

Process called "test_markov_error_handling" that takes no parameters returns Boolean:
    Note: Test error handling for invalid Markov chain operations
    Let all_passed be True
    
    Note: Test invalid generator matrix (non-zero row sums)
    Try:
        Let invalid_generator be [
            [-1.0,  1.0,  0.5],  Note: Row sum is 0.5, not 0
            [ 1.0, -2.0,  1.0],
            [ 0.0,  1.0, -1.0]
        ]
        Let invalid_ctmc be Markov.create_continuous_time_markov_chain(["A", "B", "C"], invalid_generator)
        Set all_passed to Test.assert_true(False, "Invalid generator matrix should throw error")
    Catch error as Errors.InvalidOperation:
        Set all_passed to all_passed and Test.assert_true(True, "Invalid generator matrix correctly rejected")
    
    Note: Test analysis of chain without stationary distribution
    Try:
        Let absorbing_only_matrix be [
            [1.0, 0.0],
            [0.0, 1.0]  Note: All states absorbing
        ]
        Let absorbing_only_chain be Markov.create_markov_chain(["A1", "A2"], absorbing_only_matrix)
        Let analysis be Markov.analyze_markov_chain(absorbing_only_chain)
        
        Note: This should work but give special results
        Set all_passed to all_passed and Test.assert_equal(Length(analysis.stationary_distribution), 2, "Absorbing-only chain analysis")
    Catch error as Errors.InvalidOperation:
        Set all_passed to all_passed and Test.assert_true(True, "Absorbing-only chain analysis handled")
    
    Note: Test hitting times for disconnected states
    Let disconnected_matrix be [
        [1.0, 0.0, 0.0],
        [0.0, 0.5, 0.5],
        [0.0, 0.5, 0.5]
    ]
    Let disconnected_chain be Markov.create_markov_chain(["Iso", "B", "C"], disconnected_matrix)
    Let disconnected_analysis be Markov.analyze_markov_chain(disconnected_chain)
    
    Note: Hitting time from isolated state should be infinite (or very large)
    Let hitting_time_0_1 be disconnected_analysis.expected_hitting_times[0][1]
    Set all_passed to all_passed and Test.assert_true(hitting_time_0_1 > 1e6, "Hitting time to unreachable state is very large")
    
    Return all_passed

Note: =====================================================================
Note: MIXING TIME AND CONVERGENCE TESTS
Note: =====================================================================

Process called "test_mixing_time_calculation" that takes no parameters returns Boolean:
    Note: Test calculation of mixing times for Markov chains
    Let all_passed be True
    
    Note: Fast mixing chain (complete graph)
    Let fast_mixing_matrix be [
        [0.25, 0.25, 0.25, 0.25],
        [0.25, 0.25, 0.25, 0.25],
        [0.25, 0.25, 0.25, 0.25],
        [0.25, 0.25, 0.25, 0.25]
    ]
    
    Let fast_chain be Markov.create_markov_chain(["F1", "F2", "F3", "F4"], fast_mixing_matrix)
    Let fast_analysis be Markov.analyze_markov_chain(fast_chain)
    
    Set all_passed to all_passed and Test.assert_true(fast_analysis.mixing_time < 10.0, "Fast mixing chain has small mixing time")
    Set all_passed to all_passed and Test.assert_true(fast_analysis.spectral_gap > 0.5, "Fast mixing chain has large spectral gap")
    
    Note: Slow mixing chain (path graph)
    Let slow_mixing_matrix be [
        [0.5, 0.5, 0.0, 0.0],
        [0.5, 0.0, 0.5, 0.0],
        [0.0, 0.5, 0.0, 0.5],
        [0.0, 0.0, 0.5, 0.5]
    ]
    
    Let slow_chain be Markov.create_markov_chain(["S1", "S2", "S3", "S4"], slow_mixing_matrix)
    Let slow_analysis be Markov.analyze_markov_chain(slow_chain)
    
    Set all_passed to all_passed and Test.assert_true(slow_analysis.mixing_time > fast_analysis.mixing_time, "Slow chain has longer mixing time than fast chain")
    Set all_passed to all_passed and Test.assert_true(slow_analysis.spectral_gap < fast_analysis.spectral_gap, "Slow chain has smaller spectral gap")
    
    Return all_passed

Note: =====================================================================
Note: MAIN TEST RUNNER
Note: =====================================================================

Process called "run_all_markov_tests" that takes no parameters returns Boolean:
    Note: Execute all Markov chain tests and report results
    Test.print_test_header("MARKOV CHAINS MODULE TESTS")
    Let all_passed be True
    
    Note: Basic Construction and Validation Tests
    Test.print_test_section("Markov Chain Construction Tests")
    Set all_passed to all_passed and test_markov_chain_creation()
    Set all_passed to all_passed and test_markov_chain_validation()
    
    Note: Stationary Distribution Tests
    Test.print_test_section("Stationary Distribution Tests")
    Set all_passed to all_passed and test_stationary_distribution_computation()
    Set all_passed to all_passed and test_doubly_stochastic_chain()
    
    Note: Chain Classification Tests
    Test.print_test_section("Chain Classification Tests")
    Set all_passed to all_passed and test_chain_classification()
    
    Note: Absorption Analysis Tests
    Test.print_test_section("Absorption Analysis Tests")
    Set all_passed to all_passed and test_absorption_probabilities()
    Set all_passed to all_passed and test_fundamental_matrix()
    
    Note: Hitting Time Tests
    Test.print_test_section("Hitting Time Analysis Tests")
    Set all_passed to all_passed and test_expected_hitting_times()
    
    Note: Continuous-Time Markov Chain Tests
    Test.print_test_section("Continuous-Time Markov Chain Tests")
    Set all_passed to all_passed and test_continuous_time_markov_chain()
    Set all_passed to all_passed and test_ctmc_stationary_distribution()
    
    Note: MCMC Convergence Tests
    Test.print_test_section("MCMC Convergence Diagnostics Tests")
    Set all_passed to all_passed and test_mcmc_convergence_diagnostics()
    Set all_passed to all_passed and test_autocorrelation_analysis()
    
    Note: Mixing and Convergence Tests
    Test.print_test_section("Mixing Time and Convergence Tests")
    Set all_passed to all_passed and test_mixing_time_calculation()
    
    Note: Error Handling Tests
    Test.print_test_section("Error Handling and Edge Cases Tests")
    Set all_passed to all_passed and test_markov_error_handling()
    
    Test.print_test_footer("MARKOV TESTS", all_passed)
    Return all_passed

Note: Entry point for individual test execution
Let test_result be run_all_markov_tests()
If test_result:
    Test.print_success("All Markov chains tests passed!")
Otherwise:
    Test.print_failure("Some Markov chains tests failed!")
    Test.exit_with_code(1)