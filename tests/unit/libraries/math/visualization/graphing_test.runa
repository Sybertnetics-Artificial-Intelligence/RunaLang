Note:
tests/unit/libraries/math/visualization/graphing_test.runa
Unit Tests for Math Visualization Graphing Module

This test suite provides comprehensive testing for the math visualization graphing module including:
- Graph data structures (Vertex, Edge, Graph)
- Graph construction from adjacency matrices and edge lists
- Graph layout algorithms (force-directed, hierarchical, circular)
- Graph visualization and rendering
- Network analysis visualization (centrality, clustering, communities)
- Tree visualization (spanning trees, decision trees, phylogenetic)
- Flow network visualization (max flow, min cut)
- Specialized graph types (planar, bipartite, weighted, directed)
- Graph metrics computation and display
- Interactive graph exploration features
- Graph export and import functionality
- Performance optimization for large graphs
:End Note

Import "stdlib/math/visualization/graphing" as Graphing
Import "dev/debug/test_framework/assertions" as Assert
Import "dev/debug/test_framework/test_runner" as TestRunner
Import "dev/debug/test_framework/data_generators" as DataGen
Import "math/discrete/graph_theory" as GraphTheory

Note: =====================================================================
Note: HELPER FUNCTIONS AND TEST UTILITIES
Note: =====================================================================

Process called "create_test_adjacency_matrix" that takes no parameters returns List[List[Float64]]:
    Note: Creates simple 4x4 adjacency matrix for testing
    Return [
        [0.0, 1.0, 1.0, 0.0],
        [1.0, 0.0, 1.0, 1.0],
        [1.0, 1.0, 0.0, 1.0],
        [0.0, 1.0, 1.0, 0.0]
    ]

Process called "create_test_vertex_labels" that takes no parameters returns List[String]:
    Note: Creates vertex labels for test graphs
    Return ["A", "B", "C", "D"]

Process called "create_test_edge_list" that takes no parameters returns List[List[String]]:
    Note: Creates edge list representation for testing
    Return [
        ["A", "B"],
        ["A", "C"],
        ["B", "C"],
        ["B", "D"],
        ["C", "D"]
    ]

Process called "create_weighted_edge_list" that takes no parameters returns List[List]:
    Note: Creates weighted edge list for testing
    Return [
        ["A", "B", 2.5],
        ["A", "C", 1.0],
        ["B", "C", 3.2],
        ["B", "D", 1.8],
        ["C", "D", 2.1]
    ]

Process called "validate_vertex" that takes vertex as Vertex returns Boolean:
    Note: Validates vertex structure
    Assert.IsNotEmpty(vertex.identifier)
    Assert.IsNotNull(vertex.coordinates)
    Assert.IsNotNull(vertex.properties)
    Assert.IsTrue(vertex.degree >= 0)
    Assert.IsNotEmpty(vertex.color)
    Assert.IsTrue(vertex.size > 0.0)
    Assert.IsNotEmpty(vertex.shape)
    Return True

Process called "validate_edge" that takes edge as Edge returns Boolean:
    Note: Validates edge structure
    Assert.IsNotEmpty(edge.source_vertex)
    Assert.IsNotEmpty(edge.target_vertex)
    Assert.IsNotNull(edge.properties)
    Assert.IsNotEmpty(edge.color)
    Assert.IsTrue(edge.thickness > 0.0)
    Assert.IsNotEmpty(edge.style)
    Return True

Process called "validate_graph" that takes graph as Graph returns Boolean:
    Note: Validates graph structure
    Assert.IsNotNull(graph.vertices)
    Assert.IsNotNull(graph.edges)
    Assert.IsNotNull(graph.adjacency_matrix)
    Assert.IsNotNull(graph.adjacency_list)
    Assert.IsNotNull(graph.layout_coordinates)
    Assert.IsNotNull(graph.graph_properties)
    Return True

Process called "count_edges_in_adjacency_matrix" that takes matrix as List[List[Float64]], directed as Boolean returns Integer:
    Note: Counts edges in adjacency matrix
    Let edge_count be 0
    Let i be 0
    While i < matrix.length:
        Let j be 0
        While j < matrix[i].length:
            If matrix[i][j] != 0.0:
                If directed:
                    Set edge_count to edge_count + 1
                Otherwise if i <= j:
                    Set edge_count to edge_count + 1
            Let j be j + 1
        Let i be i + 1
    Return edge_count

Note: =====================================================================
Note: GRAPH DATA STRUCTURE TESTS
Note: =====================================================================

Process called "test_vertex_creation" that takes no parameters returns Boolean:
    Note: Test basic vertex structure creation
    Let vertex be Vertex
    Set vertex.identifier to "V1"
    Set vertex.coordinates to [0.0, 0.0]
    Set vertex.properties to {"type": "node"}
    Set vertex.degree to 3
    Set vertex.color to "blue"
    Set vertex.size to 1.5
    Set vertex.shape to "circle"
    Set vertex.label to "Vertex 1"
    
    Assert.IsTrue(validate_vertex(vertex))
    Assert.AreEqual(vertex.identifier, "V1")
    Assert.AreEqual(vertex.degree, 3)
    Assert.AreEqual(vertex.color, "blue")
    Assert.AreEqual(vertex.size, 1.5)
    Assert.AreEqual(vertex.shape, "circle")
    Return True

Process called "test_edge_creation" that takes no parameters returns Boolean:
    Note: Test basic edge structure creation
    Let edge be Edge
    Set edge.source_vertex to "A"
    Set edge.target_vertex to "B"
    Set edge.weight to 2.5
    Set edge.directed to False
    Set edge.properties to {"type": "connection"}
    Set edge.color to "red"
    Set edge.thickness to 2.0
    Set edge.style to "solid"
    Set edge.label to "Edge A-B"
    
    Assert.IsTrue(validate_edge(edge))
    Assert.AreEqual(edge.source_vertex, "A")
    Assert.AreEqual(edge.target_vertex, "B")
    Assert.AreEqual(edge.weight, 2.5)
    Assert.IsFalse(edge.directed)
    Assert.AreEqual(edge.color, "red")
    Return True

Process called "test_graph_structure_creation" that takes no parameters returns Boolean:
    Note: Test basic graph structure creation
    Let graph be Graph
    Set graph.vertices to []
    Set graph.edges to []
    Set graph.directed to False
    Set graph.weighted to True
    Set graph.adjacency_matrix to []
    Set graph.adjacency_list to {}
    Set graph.layout_coordinates to {}
    Set graph.graph_properties to {"vertex_count": 0, "edge_count": 0}
    
    Assert.IsTrue(validate_graph(graph))
    Assert.IsFalse(graph.directed)
    Assert.IsTrue(graph.weighted)
    Assert.AreEqual(graph.graph_properties["vertex_count"], 0)
    Return True

Note: =====================================================================
Note: GRAPH CONSTRUCTION TESTS
Note: =====================================================================

Process called "test_create_graph_from_adjacency_matrix_basic" that takes no parameters returns Boolean:
    Note: Test basic graph creation from adjacency matrix
    Let adjacency_matrix be create_test_adjacency_matrix()
    Let vertex_labels be create_test_vertex_labels()
    Let directed be False
    
    Let graph be Graphing.create_graph_from_adjacency_matrix(adjacency_matrix, vertex_labels, directed)
    
    Assert.IsTrue(validate_graph(graph))
    Assert.AreEqual(graph.vertices.length, 4)
    Assert.IsFalse(graph.directed)
    
    Let expected_edge_count be count_edges_in_adjacency_matrix(adjacency_matrix, directed)
    Assert.AreEqual(graph.edges.length, expected_edge_count)
    
    Let vertex_a be graph.vertices[0]
    Assert.AreEqual(vertex_a.identifier, "A")
    Assert.AreEqual(vertex_a.label, "A")
    Return True

Process called "test_create_graph_from_adjacency_matrix_directed" that takes no parameters returns Boolean:
    Note: Test directed graph creation from adjacency matrix
    Let adjacency_matrix be [
        [0.0, 1.0, 0.0],
        [0.0, 0.0, 1.0],
        [1.0, 0.0, 0.0]
    ]
    Let vertex_labels be ["X", "Y", "Z"]
    Let directed be True
    
    Let graph be Graphing.create_graph_from_adjacency_matrix(adjacency_matrix, vertex_labels, directed)
    
    Assert.IsTrue(validate_graph(graph))
    Assert.IsTrue(graph.directed)
    Assert.AreEqual(graph.edges.length, 3)
    
    Let all_edges_directed be True
    Let edge_index be 0
    While edge_index < graph.edges.length:
        If not graph.edges[edge_index].directed:
            Set all_edges_directed to False
        Let edge_index be edge_index + 1
    
    Assert.IsTrue(all_edges_directed)
    Return True

Process called "test_create_graph_from_adjacency_matrix_weighted" that takes no parameters returns Boolean:
    Note: Test weighted graph creation from adjacency matrix
    Let adjacency_matrix be [
        [0.0, 2.5, 1.0],
        [2.5, 0.0, 3.2],
        [1.0, 3.2, 0.0]
    ]
    Let vertex_labels be ["A", "B", "C"]
    Let directed be False
    
    Let graph be Graphing.create_graph_from_adjacency_matrix(adjacency_matrix, vertex_labels, directed)
    
    Assert.IsTrue(validate_graph(graph))
    Assert.IsTrue(graph.weighted)
    
    Let found_weight_25 be False
    Let found_weight_32 be False
    Let edge_index be 0
    While edge_index < graph.edges.length:
        Let edge be graph.edges[edge_index]
        If edge.weight = 2.5:
            Set found_weight_25 to True
        If edge.weight = 3.2:
            Set found_weight_32 to True
        Let edge_index be edge_index + 1
    
    Assert.IsTrue(found_weight_25)
    Assert.IsTrue(found_weight_32)
    Return True

Process called "test_create_graph_from_edge_list_basic" that takes no parameters returns Boolean:
    Note: Test graph creation from edge list
    Let edge_list be create_test_edge_list()
    Let directed be False
    
    Let graph be Graphing.create_graph_from_edge_list(edge_list, directed)
    
    Assert.IsTrue(validate_graph(graph))
    Assert.AreEqual(graph.edges.length, edge_list.length)
    Assert.IsFalse(graph.directed)
    
    Let vertex_set be {}
    Let edge_index be 0
    While edge_index < edge_list.length:
        Set vertex_set[edge_list[edge_index][0]] to True
        Set vertex_set[edge_list[edge_index][1]] to True
        Let edge_index be edge_index + 1
    
    Assert.AreEqual(graph.vertices.length, vertex_set.size())
    Return True

Process called "test_create_graph_from_weighted_edge_list" that takes no parameters returns Boolean:
    Note: Test graph creation from weighted edge list
    Let weighted_edges be create_weighted_edge_list()
    Let directed be False
    
    Let graph be Graphing.create_graph_from_weighted_edge_list(weighted_edges, directed)
    
    Assert.IsTrue(validate_graph(graph))
    Assert.IsTrue(graph.weighted)
    Assert.AreEqual(graph.edges.length, weighted_edges.length)
    
    Let edge_ab be null
    Let edge_index be 0
    While edge_index < graph.edges.length:
        Let edge be graph.edges[edge_index]
        If (edge.source_vertex = "A" and edge.target_vertex = "B") or 
           (edge.source_vertex = "B" and edge.target_vertex = "A"):
            Set edge_ab to edge
        Let edge_index be edge_index + 1
    
    Assert.IsNotNull(edge_ab)
    Assert.AreEqual(edge_ab.weight, 2.5)
    Return True

Note: =====================================================================
Note: GRAPH LAYOUT ALGORITHM TESTS
Note: =====================================================================

Process called "test_force_directed_layout_basic" that takes no parameters returns Boolean:
    Note: Test basic force-directed layout algorithm
    Let adjacency_matrix be create_test_adjacency_matrix()
    Let vertex_labels be create_test_vertex_labels()
    Let graph be Graphing.create_graph_from_adjacency_matrix(adjacency_matrix, vertex_labels, False)
    
    Let layout_parameters be {
        "iterations": 100,
        "spring_constant": 0.1,
        "repulsion_constant": 1000.0,
        "damping": 0.95
    }
    
    Let positioned_graph be Graphing.apply_force_directed_layout(graph, layout_parameters)
    
    Assert.IsTrue(validate_graph(positioned_graph))
    Assert.AreEqual(positioned_graph.vertices.length, graph.vertices.length)
    
    Let vertex_index be 0
    While vertex_index < positioned_graph.vertices.length:
        Let vertex be positioned_graph.vertices[vertex_index]
        Assert.IsTrue(vertex.coordinates.length >= 2)
        Assert.IsTrue(vertex.coordinates[0] != 0.0 or vertex.coordinates[1] != 0.0)
        Let vertex_index be vertex_index + 1
    
    Assert.IsTrue(positioned_graph.layout_coordinates.size() > 0)
    Return True

Process called "test_hierarchical_layout_basic" that takes no parameters returns Boolean:
    Note: Test basic hierarchical layout algorithm
    Let edge_list be [
        ["root", "child1"],
        ["root", "child2"],
        ["child1", "grandchild1"],
        ["child1", "grandchild2"],
        ["child2", "grandchild3"]
    ]
    Let graph be Graphing.create_graph_from_edge_list(edge_list, True)
    
    Let layout_parameters be {
        "root_node": "root",
        "level_spacing": 2.0,
        "node_spacing": 1.5
    }
    
    Let hierarchical_graph be Graphing.apply_hierarchical_layout(graph, layout_parameters)
    
    Assert.IsTrue(validate_graph(hierarchical_graph))
    
    Let root_vertex be null
    Let vertex_index be 0
    While vertex_index < hierarchical_graph.vertices.length:
        Let vertex be hierarchical_graph.vertices[vertex_index]
        If vertex.identifier = "root":
            Set root_vertex to vertex
        Let vertex_index be vertex_index + 1
    
    Assert.IsNotNull(root_vertex)
    Assert.AreEqual(root_vertex.coordinates[1], 0.0) Note: Root at top level
    Return True

Process called "test_circular_layout_basic" that takes no parameters returns Boolean:
    Note: Test basic circular layout algorithm
    Let adjacency_matrix be create_test_adjacency_matrix()
    Let vertex_labels be create_test_vertex_labels()
    Let graph be Graphing.create_graph_from_adjacency_matrix(adjacency_matrix, vertex_labels, False)
    
    Let layout_parameters be {
        "radius": 5.0,
        "center": [0.0, 0.0],
        "start_angle": 0.0
    }
    
    Let circular_graph be Graphing.apply_circular_layout(graph, layout_parameters)
    
    Assert.IsTrue(validate_graph(circular_graph))
    
    Let center_x be layout_parameters["center"][0]
    Let center_y be layout_parameters["center"][1]
    Let radius be layout_parameters["radius"]
    
    Let vertex_index be 0
    While vertex_index < circular_graph.vertices.length:
        Let vertex be circular_graph.vertices[vertex_index]
        Let x be vertex.coordinates[0]
        Let y be vertex.coordinates[1]
        Let distance be ((x - center_x)^2 + (y - center_y)^2)^0.5
        Assert.IsTrue(AbsoluteValue(distance - radius) < 0.01)
        Let vertex_index be vertex_index + 1
    
    Return True

Process called "test_spring_layout_convergence" that takes no parameters returns Boolean:
    Note: Test spring layout algorithm convergence
    Let adjacency_matrix be create_test_adjacency_matrix()
    Let vertex_labels be create_test_vertex_labels()
    Let graph be Graphing.create_graph_from_adjacency_matrix(adjacency_matrix, vertex_labels, False)
    
    Let layout_parameters be {
        "iterations": 50,
        "spring_length": 2.0,
        "spring_strength": 0.1,
        "convergence_threshold": 0.01
    }
    
    Let spring_graph be Graphing.apply_spring_layout(graph, layout_parameters)
    
    Assert.IsTrue(validate_graph(spring_graph))
    
    Let energy_before be Graphing.calculate_layout_energy(graph)
    Let energy_after be Graphing.calculate_layout_energy(spring_graph)
    
    Assert.IsTrue(energy_after <= energy_before) Note: Energy should decrease or stay same
    Return True

Note: =====================================================================
Note: GRAPH VISUALIZATION TESTS
Note: =====================================================================

Process called "test_render_graph_basic" that takes no parameters returns Boolean:
    Note: Test basic graph rendering
    Let adjacency_matrix be create_test_adjacency_matrix()
    Let vertex_labels be create_test_vertex_labels()
    Let graph be Graphing.create_graph_from_adjacency_matrix(adjacency_matrix, vertex_labels, False)
    
    Let rendering_options be {
        "vertex_size": 1.0,
        "edge_thickness": 1.5,
        "vertex_color": "blue",
        "edge_color": "black",
        "show_labels": True
    }
    
    Let rendered_graph be Graphing.render_graph(graph, rendering_options)
    
    Assert.IsNotNull(rendered_graph)
    Assert.IsTrue("vertices" in rendered_graph)
    Assert.IsTrue("edges" in rendered_graph)
    Assert.IsTrue("canvas_info" in rendered_graph)
    
    Assert.AreEqual(rendered_graph["vertices"].length, graph.vertices.length)
    Assert.AreEqual(rendered_graph["edges"].length, graph.edges.length)
    Return True

Process called "test_graph_styling_options" that takes no parameters returns Boolean:
    Note: Test graph styling and appearance options
    Let edge_list be [["A", "B"], ["B", "C"], ["C", "A"]]
    Let graph be Graphing.create_graph_from_edge_list(edge_list, False)
    
    Let custom_styles be {
        "vertex_styles": {
            "A": {"color": "red", "size": 2.0, "shape": "square"},
            "B": {"color": "green", "size": 1.5, "shape": "circle"},
            "C": {"color": "blue", "size": 1.8, "shape": "triangle"}
        },
        "edge_styles": {
            "A-B": {"color": "purple", "thickness": 3.0, "style": "dashed"},
            "B-C": {"color": "orange", "thickness": 2.0, "style": "dotted"}
        }
    }
    
    Let styled_graph be Graphing.apply_custom_styles(graph, custom_styles)
    
    Assert.IsTrue(validate_graph(styled_graph))
    
    Let vertex_a be null
    Let vertex_index be 0
    While vertex_index < styled_graph.vertices.length:
        If styled_graph.vertices[vertex_index].identifier = "A":
            Set vertex_a to styled_graph.vertices[vertex_index]
        Let vertex_index be vertex_index + 1
    
    Assert.IsNotNull(vertex_a)
    Assert.AreEqual(vertex_a.color, "red")
    Assert.AreEqual(vertex_a.size, 2.0)
    Assert.AreEqual(vertex_a.shape, "square")
    Return True

Process called "test_graph_labeling" that takes no parameters returns Boolean:
    Note: Test graph labeling functionality
    Let adjacency_matrix be create_test_adjacency_matrix()
    Let vertex_labels be create_test_vertex_labels()
    Let graph be Graphing.create_graph_from_adjacency_matrix(adjacency_matrix, vertex_labels, False)
    
    Let labeling_options be {
        "show_vertex_labels": True,
        "show_edge_labels": True,
        "vertex_label_format": "ID: {identifier}",
        "edge_label_format": "Weight: {weight}",
        "label_font_size": 12,
        "label_color": "black"
    }
    
    Let labeled_graph be Graphing.apply_graph_labeling(graph, labeling_options)
    
    Assert.IsTrue(validate_graph(labeled_graph))
    
    Let vertex_index be 0
    While vertex_index < labeled_graph.vertices.length:
        Let vertex be labeled_graph.vertices[vertex_index]
        Assert.IsNotEmpty(vertex.label)
        Assert.IsTrue(vertex.label.contains(vertex.identifier))
        Let vertex_index be vertex_index + 1
    
    Return True

Note: =====================================================================
Note: NETWORK ANALYSIS VISUALIZATION TESTS
Note: =====================================================================

Process called "test_visualize_centrality_measures" that takes no parameters returns Boolean:
    Note: Test centrality measures visualization
    Let adjacency_matrix be create_test_adjacency_matrix()
    Let vertex_labels be create_test_vertex_labels()
    Let graph be Graphing.create_graph_from_adjacency_matrix(adjacency_matrix, vertex_labels, False)
    
    Let centrality_options be {
        "measure_type": "betweenness",
        "color_mapping": "heat",
        "size_scaling": True,
        "show_values": True
    }
    
    Let centrality_graph be Graphing.visualize_centrality_measures(graph, centrality_options)
    
    Assert.IsTrue(validate_graph(centrality_graph))
    Assert.IsTrue("centrality_scores" in centrality_graph.graph_properties)
    
    Let vertex_index be 0
    While vertex_index < centrality_graph.vertices.length:
        Let vertex be centrality_graph.vertices[vertex_index]
        Assert.IsTrue(vertex.identifier in centrality_graph.graph_properties["centrality_scores"])
        Let vertex_index be vertex_index + 1
    
    Return True

Process called "test_visualize_clustering_coefficient" that takes no parameters returns Boolean:
    Note: Test clustering coefficient visualization
    Let adjacency_matrix be create_test_adjacency_matrix()
    Let vertex_labels be create_test_vertex_labels()
    Let graph be Graphing.create_graph_from_adjacency_matrix(adjacency_matrix, vertex_labels, False)
    
    Let clustering_options be {
        "local_clustering": True,
        "global_clustering": True,
        "color_by_clustering": True,
        "highlight_triangles": True
    }
    
    Let clustering_graph be Graphing.visualize_clustering_coefficient(graph, clustering_options)
    
    Assert.IsTrue(validate_graph(clustering_graph))
    Assert.IsTrue("clustering_coefficients" in clustering_graph.graph_properties)
    Assert.IsTrue("global_clustering" in clustering_graph.graph_properties)
    
    Let global_clustering be clustering_graph.graph_properties["global_clustering"]
    Assert.IsTrue(global_clustering >= 0.0 and global_clustering <= 1.0)
    Return True

Process called "test_community_detection_visualization" that takes no parameters returns Boolean:
    Note: Test community detection visualization
    Let adjacency_matrix be [
        [0.0, 1.0, 1.0, 0.0, 0.0, 0.0],
        [1.0, 0.0, 1.0, 0.0, 0.0, 0.0],
        [1.0, 1.0, 0.0, 1.0, 0.0, 0.0],
        [0.0, 0.0, 1.0, 0.0, 1.0, 1.0],
        [0.0, 0.0, 0.0, 1.0, 0.0, 1.0],
        [0.0, 0.0, 0.0, 1.0, 1.0, 0.0]
    ]
    Let vertex_labels be ["A", "B", "C", "D", "E", "F"]
    Let graph be Graphing.create_graph_from_adjacency_matrix(adjacency_matrix, vertex_labels, False)
    
    Let community_options be {
        "algorithm": "modularity",
        "color_by_community": True,
        "show_community_borders": True,
        "highlight_bridges": True
    }
    
    Let community_graph be Graphing.detect_and_visualize_communities(graph, community_options)
    
    Assert.IsTrue(validate_graph(community_graph))
    Assert.IsTrue("communities" in community_graph.graph_properties)
    Assert.IsTrue("modularity_score" in community_graph.graph_properties)
    
    Let communities be community_graph.graph_properties["communities"]
    Assert.IsTrue(communities.length > 0)
    Return True

Note: =====================================================================
Note: TREE VISUALIZATION TESTS
Note: =====================================================================

Process called "test_visualize_spanning_tree" that takes no parameters returns Boolean:
    Note: Test spanning tree visualization
    Let adjacency_matrix be create_test_adjacency_matrix()
    Let vertex_labels be create_test_vertex_labels()
    Let graph be Graphing.create_graph_from_adjacency_matrix(adjacency_matrix, vertex_labels, False)
    
    Let spanning_tree_options be {
        "algorithm": "kruskal",
        "highlight_tree_edges": True,
        "show_weights": True,
        "tree_edge_color": "red",
        "non_tree_edge_color": "gray"
    }
    
    Let spanning_tree_graph be Graphing.visualize_spanning_tree(graph, spanning_tree_options)
    
    Assert.IsTrue(validate_graph(spanning_tree_graph))
    Assert.IsTrue("spanning_tree_edges" in spanning_tree_graph.graph_properties)
    Assert.IsTrue("spanning_tree_weight" in spanning_tree_graph.graph_properties)
    
    Let tree_edges be spanning_tree_graph.graph_properties["spanning_tree_edges"]
    Assert.AreEqual(tree_edges.length, graph.vertices.length - 1)
    Return True

Process called "test_visualize_decision_tree" that takes no parameters returns Boolean:
    Note: Test decision tree visualization
    Let tree_structure be {
        "root": "feature_a > 5",
        "children": {
            "left": {
                "value": "feature_b <= 10",
                "children": {
                    "left": {"value": "class_1", "leaf": True},
                    "right": {"value": "class_2", "leaf": True}
                }
            },
            "right": {"value": "class_3", "leaf": True}
        }
    }
    
    Let decision_tree_options be {
        "node_shape": "rectangle",
        "leaf_shape": "ellipse",
        "show_conditions": True,
        "color_by_class": True,
        "edge_labels": True
    }
    
    Let decision_tree_graph be Graphing.visualize_decision_tree(tree_structure, decision_tree_options)
    
    Assert.IsTrue(validate_graph(decision_tree_graph))
    Assert.IsTrue("tree_depth" in decision_tree_graph.graph_properties)
    Assert.IsTrue("leaf_nodes" in decision_tree_graph.graph_properties)
    
    Let leaf_nodes be decision_tree_graph.graph_properties["leaf_nodes"]
    Assert.AreEqual(leaf_nodes.length, 3)
    Return True

Process called "test_phylogenetic_tree_visualization" that takes no parameters returns Boolean:
    Note: Test phylogenetic tree visualization
    Let phylo_data be {
        "taxa": ["Species_A", "Species_B", "Species_C", "Species_D"],
        "distances": [
            [0.0, 0.2, 0.8, 0.9],
            [0.2, 0.0, 0.7, 0.8],
            [0.8, 0.7, 0.0, 0.3],
            [0.9, 0.8, 0.3, 0.0]
        ],
        "branch_lengths": True
    }
    
    Let phylo_options be {
        "layout": "rectangular",
        "show_branch_lengths": True,
        "show_bootstrap_values": False,
        "root_position": "left"
    }
    
    Let phylo_tree be Graphing.create_phylogenetic_tree(phylo_data, phylo_options)
    
    Assert.IsTrue(validate_graph(phylo_tree))
    Assert.IsTrue("taxa_count" in phylo_tree.graph_properties)
    Assert.IsTrue("tree_length" in phylo_tree.graph_properties)
    
    Assert.AreEqual(phylo_tree.graph_properties["taxa_count"], 4)
    Return True

Note: =====================================================================
Note: FLOW NETWORK VISUALIZATION TESTS
Note: =====================================================================

Process called "test_max_flow_visualization" that takes no parameters returns Boolean:
    Note: Test maximum flow visualization
    Let flow_network be {
        "source": "S",
        "sink": "T",
        "capacities": {
            "S-A": 10, "S-B": 8,
            "A-B": 2, "A-T": 5,
            "B-T": 10
        }
    }
    
    Let flow_options be {
        "algorithm": "ford_fulkerson",
        "show_capacities": True,
        "show_flow_values": True,
        "highlight_max_flow": True,
        "edge_thickness_by_flow": True
    }
    
    Let max_flow_graph be Graphing.visualize_max_flow(flow_network, flow_options)
    
    Assert.IsTrue(validate_graph(max_flow_graph))
    Assert.IsTrue("max_flow_value" in max_flow_graph.graph_properties)
    Assert.IsTrue("flow_edges" in max_flow_graph.graph_properties)
    
    Let max_flow_value be max_flow_graph.graph_properties["max_flow_value"]
    Assert.IsTrue(max_flow_value > 0)
    Return True

Process called "test_min_cut_visualization" that takes no parameters returns Boolean:
    Note: Test minimum cut visualization
    Let flow_network be {
        "source": "S",
        "sink": "T",
        "capacities": {
            "S-A": 3, "S-B": 3,
            "A-B": 2, "A-T": 2,
            "B-T": 3
        }
    }
    
    Let cut_options be {
        "highlight_cut_edges": True,
        "show_cut_capacity": True,
        "color_partitions": True,
        "cut_edge_style": "dashed"
    }
    
    Let min_cut_graph be Graphing.visualize_min_cut(flow_network, cut_options)
    
    Assert.IsTrue(validate_graph(min_cut_graph))
    Assert.IsTrue("min_cut_value" in min_cut_graph.graph_properties)
    Assert.IsTrue("cut_edges" in min_cut_graph.graph_properties)
    Assert.IsTrue("source_partition" in min_cut_graph.graph_properties)
    Assert.IsTrue("sink_partition" in min_cut_graph.graph_properties)
    
    Let cut_edges be min_cut_graph.graph_properties["cut_edges"]
    Assert.IsTrue(cut_edges.length > 0)
    Return True

Note: =====================================================================
Note: SPECIALIZED GRAPH TYPE TESTS
Note: =====================================================================

Process called "test_bipartite_graph_visualization" that takes no parameters returns Boolean:
    Note: Test bipartite graph visualization
    Let bipartite_edges be [
        ["A1", "B1"], ["A1", "B2"],
        ["A2", "B1"], ["A2", "B3"],
        ["A3", "B2"], ["A3", "B3"]
    ]
    
    Let partitions be {
        "set_a": ["A1", "A2", "A3"],
        "set_b": ["B1", "B2", "B3"]
    }
    
    Let bipartite_options be {
        "layout": "two_column",
        "color_by_partition": True,
        "verify_bipartite": True,
        "show_matching": False
    }
    
    Let bipartite_graph be Graphing.create_bipartite_graph(bipartite_edges, partitions, bipartite_options)
    
    Assert.IsTrue(validate_graph(bipartite_graph))
    Assert.IsTrue("is_bipartite" in bipartite_graph.graph_properties)
    Assert.IsTrue("partition_a" in bipartite_graph.graph_properties)
    Assert.IsTrue("partition_b" in bipartite_graph.graph_properties)
    
    Assert.IsTrue(bipartite_graph.graph_properties["is_bipartite"])
    Return True

Process called "test_planar_graph_visualization" that takes no parameters returns Boolean:
    Note: Test planar graph visualization
    Let planar_edges be [
        ["A", "B"], ["B", "C"], ["C", "D"], ["D", "A"],
        ["A", "C"] Note: Diagonal that doesn't cause crossing
    ]
    
    Let planar_options be {
        "embedding_algorithm": "force_directed",
        "minimize_crossings": True,
        "show_faces": True,
        "verify_planarity": True
    }
    
    Let planar_graph be Graphing.create_planar_graph_embedding(planar_edges, planar_options)
    
    Assert.IsTrue(validate_graph(planar_graph))
    Assert.IsTrue("is_planar" in planar_graph.graph_properties)
    Assert.IsTrue("crossing_count" in planar_graph.graph_properties)
    
    Let crossing_count be planar_graph.graph_properties["crossing_count"]
    Assert.AreEqual(crossing_count, 0)
    Return True

Note: =====================================================================
Note: INTERACTIVE FEATURES TESTS
Note: =====================================================================

Process called "test_graph_interaction_basic" that takes no parameters returns Boolean:
    Note: Test basic graph interaction features
    Let adjacency_matrix be create_test_adjacency_matrix()
    Let vertex_labels be create_test_vertex_labels()
    Let graph be Graphing.create_graph_from_adjacency_matrix(adjacency_matrix, vertex_labels, False)
    
    Let interaction_options be {
        "vertex_selection": True,
        "edge_selection": True,
        "drag_vertices": True,
        "zoom_enabled": True,
        "pan_enabled": True
    }
    
    Let interactive_graph be Graphing.enable_graph_interaction(graph, interaction_options)
    
    Assert.IsTrue(validate_graph(interactive_graph))
    Assert.IsTrue("interaction_handlers" in interactive_graph.graph_properties)
    
    Let handlers be interactive_graph.graph_properties["interaction_handlers"]
    Assert.IsTrue("vertex_click" in handlers)
    Assert.IsTrue("vertex_drag" in handlers)
    Assert.IsTrue("edge_hover" in handlers)
    Return True

Process called "test_graph_animation_basic" that takes no parameters returns Boolean:
    Note: Test basic graph animation features
    Let initial_graph be Graphing.create_graph_from_edge_list([["A", "B"]], False)
    Let final_graph be Graphing.create_graph_from_edge_list([["A", "B"], ["B", "C"], ["C", "A"]], False)
    
    Let animation_options be {
        "duration": 2.0,
        "frame_rate": 30.0,
        "interpolation": "smooth",
        "animate_layout": True,
        "animate_appearance": True
    }
    
    Let graph_animation be Graphing.create_graph_animation(initial_graph, final_graph, animation_options)
    
    Assert.IsNotNull(graph_animation)
    Assert.IsTrue("frames" in graph_animation)
    Assert.IsTrue("duration" in graph_animation)
    Assert.IsTrue("frame_count" in graph_animation)
    
    Let frame_count be graph_animation["frame_count"]
    Assert.IsTrue(frame_count > 0)
    Return True

Note: =====================================================================
Note: PERFORMANCE AND ERROR HANDLING TESTS
Note: =====================================================================

Process called "test_large_graph_performance" that takes no parameters returns Boolean:
    Note: Test performance with larger graphs
    Let vertex_count be 50
    Let vertex_labels be []
    Let i be 0
    While i < vertex_count:
        Let vertex_labels be vertex_labels with ("V" + ToString(i)) added
        Let i be i + 1
    
    Let adjacency_matrix be []
    Let i be 0
    While i < vertex_count:
        Let row be []
        Let j be 0
        While j < vertex_count:
            If i != j and (i + j) % 5 = 0:
                Let row be row with 1.0 added
            Otherwise:
                Let row be row with 0.0 added
            Let j be j + 1
        Let adjacency_matrix be adjacency_matrix with row added
        Let i be i + 1
    
    Let start_time be GetCurrentTime()
    Let large_graph be Graphing.create_graph_from_adjacency_matrix(adjacency_matrix, vertex_labels, False)
    Let creation_time be GetCurrentTime() - start_time
    
    Assert.IsTrue(validate_graph(large_graph))
    Assert.AreEqual(large_graph.vertices.length, vertex_count)
    Assert.IsTrue(creation_time < 5.0) Note: Should complete within 5 seconds
    Return True

Process called "test_graph_error_handling" that takes no parameters returns Boolean:
    Note: Test error handling in graph operations
    Try:
        Let invalid_matrix be [[1.0, 2.0], [3.0]] Note: Non-square matrix
        Let invalid_labels be ["A", "B"]
        Let invalid_graph be Graphing.create_graph_from_adjacency_matrix(invalid_matrix, invalid_labels, False)
        Return False Note: Should throw error
    Catch error:
        Pass
    
    Try:
        Let valid_matrix be [[0.0, 1.0], [1.0, 0.0]]
        Let mismatched_labels be ["A"] Note: Wrong number of labels
        Let invalid_graph be Graphing.create_graph_from_adjacency_matrix(valid_matrix, mismatched_labels, False)
        Return False Note: Should throw error
    Catch error:
        Pass
    
    Try:
        Let empty_edge_list be []
        Let empty_graph be Graphing.create_graph_from_edge_list(empty_edge_list, False)
        Assert.AreEqual(empty_graph.vertices.length, 0)
        Assert.AreEqual(empty_graph.edges.length, 0)
    Catch error:
        Return False Note: Empty edge list should be valid
    
    Return True

Note: =====================================================================
Note: EXPORT AND IMPORT TESTS
Note: =====================================================================

Process called "test_export_graph_formats" that takes no parameters returns Boolean:
    Note: Test graph export to various formats
    Let adjacency_matrix be create_test_adjacency_matrix()
    Let vertex_labels be create_test_vertex_labels()
    Let graph be Graphing.create_graph_from_adjacency_matrix(adjacency_matrix, vertex_labels, False)
    
    Let json_export be Graphing.export_graph(graph, "json")
    Assert.IsNotEmpty(json_export)
    Assert.IsTrue(json_export.contains("vertices"))
    Assert.IsTrue(json_export.contains("edges"))
    
    Let graphml_export be Graphing.export_graph(graph, "graphml")
    Assert.IsNotEmpty(graphml_export)
    Assert.IsTrue(graphml_export.contains("<graph"))
    Assert.IsTrue(graphml_export.contains("<node"))
    Assert.IsTrue(graphml_export.contains("<edge"))
    
    Let dot_export be Graphing.export_graph(graph, "dot")
    Assert.IsNotEmpty(dot_export)
    Assert.IsTrue(dot_export.contains("graph"))
    Assert.IsTrue(dot_export.contains("--") or dot_export.contains("->"))
    
    Return True

Process called "test_import_graph_formats" that takes no parameters returns Boolean:
    Note: Test graph import from various formats
    Let json_data be "{\"vertices\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"edges\": [{\"source\": \"A\", \"target\": \"B\"}]}"
    
    Let imported_graph be Graphing.import_graph(json_data, "json")
    Assert.IsTrue(validate_graph(imported_graph))
    Assert.AreEqual(imported_graph.vertices.length, 2)
    Assert.AreEqual(imported_graph.edges.length, 1)
    
    Let vertex_found be False
    Let vertex_index be 0
    While vertex_index < imported_graph.vertices.length:
        If imported_graph.vertices[vertex_index].identifier = "A":
            Set vertex_found to True
        Let vertex_index be vertex_index + 1
    
    Assert.IsTrue(vertex_found)
    Return True

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_all_tests" that takes no parameters returns Boolean:
    Note: Run all graphing module tests
    Let tests_passed be 0
    Let tests_failed be 0
    
    Note: Graph data structure tests
    Let structure_tests be [
        "test_vertex_creation",
        "test_edge_creation", 
        "test_graph_structure_creation"
    ]
    
    Note: Graph construction tests
    Let construction_tests be [
        "test_create_graph_from_adjacency_matrix_basic",
        "test_create_graph_from_adjacency_matrix_directed",
        "test_create_graph_from_adjacency_matrix_weighted",
        "test_create_graph_from_edge_list_basic",
        "test_create_graph_from_weighted_edge_list"
    ]
    
    Note: Layout algorithm tests
    Let layout_tests be [
        "test_force_directed_layout_basic",
        "test_hierarchical_layout_basic",
        "test_circular_layout_basic",
        "test_spring_layout_convergence"
    ]
    
    Note: Visualization tests
    Let visualization_tests be [
        "test_render_graph_basic",
        "test_graph_styling_options",
        "test_graph_labeling"
    ]
    
    Note: Network analysis tests
    Let analysis_tests be [
        "test_visualize_centrality_measures",
        "test_visualize_clustering_coefficient",
        "test_community_detection_visualization"
    ]
    
    Note: Tree visualization tests
    Let tree_tests be [
        "test_visualize_spanning_tree",
        "test_visualize_decision_tree",
        "test_phylogenetic_tree_visualization"
    ]
    
    Note: Flow network tests
    Let flow_tests be [
        "test_max_flow_visualization",
        "test_min_cut_visualization"
    ]
    
    Note: Specialized graph tests
    Let specialized_tests be [
        "test_bipartite_graph_visualization",
        "test_planar_graph_visualization"
    ]
    
    Note: Interactive features tests
    Let interactive_tests be [
        "test_graph_interaction_basic",
        "test_graph_animation_basic"
    ]
    
    Note: Performance and error tests
    Let performance_tests be [
        "test_large_graph_performance",
        "test_graph_error_handling"
    ]
    
    Note: Export/import tests
    Let export_tests be [
        "test_export_graph_formats",
        "test_import_graph_formats"
    ]
    
    Let all_test_groups be [structure_tests, construction_tests, layout_tests, visualization_tests,
                           analysis_tests, tree_tests, flow_tests, specialized_tests,
                           interactive_tests, performance_tests, export_tests]
    
    Let group_names be ["Data Structures", "Graph Construction", "Layout Algorithms", "Visualization",
                       "Network Analysis", "Tree Visualization", "Flow Networks", "Specialized Graphs",
                       "Interactive Features", "Performance & Error Handling", "Export & Import"]
    
    For group_index from 0 to Length(all_test_groups) - 1:
        Let test_group be all_test_groups[group_index]
        Let group_name be group_names[group_index]
        Print "Testing " + group_name + "..."
        
        For test_name in test_group:
            Try:
                Let test_result be Call test_name()
                If test_result:
                    Set tests_passed to tests_passed + 1
                    Print "  ✓ " + test_name
                Else:
                    Set tests_failed to tests_failed + 1  
                    Print "  ✗ " + test_name + " (returned false)"
            Catch error:
                Set tests_failed to tests_failed + 1
                Print "  ✗ " + test_name + " (error: " + error.message + ")"
    
    Let total_tests be tests_passed + tests_failed
    Print ""
    Print "Graphing Module Test Results:"
    Print "============================"
    Print "Tests passed: " + ToString(tests_passed)
    Print "Tests failed: " + ToString(tests_failed)
    Print "Total tests: " + ToString(total_tests)
    Print "Success rate: " + ToString((tests_passed * 100) / total_tests) + "%"
    
    Return tests_failed = 0