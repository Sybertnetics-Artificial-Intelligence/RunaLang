Note:
tests/unit/libraries/math/visualization/plotting_test.runa
Unit Tests for Math Visualization Plotting Module

This test suite provides comprehensive testing for the math visualization plotting module including:
- Basic plotting infrastructure (PlotAxis, PlotSeries, PlotCanvas)
- 2D function plotting with adaptive sampling and error handling
- Parametric curve plotting and polar coordinate plotting
- Multi-variable function visualization and contour plots
- Implicit function plotting and level curve visualization
- Vector field plotting and streamline visualization
- Complex function visualization and domain coloring
- Statistical plotting (histograms, scatter plots, regression)
- Data visualization and custom plot styling
- Interactive plotting features and real-time updates
- Plot export functionality and performance optimization
- Error handling and boundary condition testing
:End Note

Import "stdlib/math/visualization/plotting" as Plotting
Import "dev/debug/test_framework/assertions" as Assert
Import "dev/debug/test_framework/test_runner" as TestRunner
Import "dev/debug/test_framework/data_generators" as DataGen
Import "math/core/constants" as Constants
Import "math/core/trigonometry" as Trig
Import "math/core/operations" as MathOps

Note: =====================================================================
Note: HELPER FUNCTIONS AND TEST UTILITIES
Note: =====================================================================

Process called "create_test_linear_function" that takes no parameters returns Function:
    Note: Creates simple linear function y = 2x + 1 for testing
    Process called "linear_func" that takes x as Float64 returns Float64:
        Return 2.0 * x + 1.0
    Return linear_func

Process called "create_test_quadratic_function" that takes no parameters returns Function:
    Note: Creates quadratic function y = x² - 4x + 3 for testing
    Process called "quadratic_func" that takes x as Float64 returns Float64:
        Return x * x - 4.0 * x + 3.0
    Return quadratic_func

Process called "create_test_sine_function" that takes no parameters returns Function:
    Note: Creates sine function y = sin(x) for testing
    Process called "sine_func" that takes x as Float64 returns Float64:
        Return Trig.sin(x)
    Return sine_func

Process called "create_test_parametric_function" that takes no parameters returns Function:
    Note: Creates parametric circle function [cos(t), sin(t)]
    Process called "parametric_circle" that takes t as Float64 returns List[Float64]:
        Return [Trig.cos(t), Trig.sin(t)]
    Return parametric_circle

Process called "create_test_multivariate_function" that takes no parameters returns Function:
    Note: Creates multivariate function z = x² + y²
    Process called "multivar_func" that takes x as Float64, y as Float64 returns Float64:
        Return x * x + y * y
    Return multivar_func

Process called "create_test_vector_field" that takes no parameters returns Function:
    Note: Creates vector field [y, -x] for testing
    Process called "vector_field" that takes x as Float64, y as Float64 returns List[Float64]:
        Return [y, -x]
    Return vector_field

Process called "generate_test_data_points" that takes count as Integer returns List[List[Float64]]:
    Note: Generates test data points for scatter plots
    Let data_points be []
    Let i be 0
    While i < count:
        Let x be i / 10.0
        Let y be x * x + 0.1 * Trig.sin(10.0 * x)
        Let data_points be data_points with [x, y] added
        Let i be i + 1
    Return data_points

Process called "validate_plot_axis" that takes axis as PlotAxis returns Boolean:
    Note: Validates plot axis structure
    Assert.IsNotEmpty(axis.label)
    Assert.IsTrue(axis.range.0 < axis.range.1)
    Assert.IsNotNull(axis.tick_positions)
    Assert.IsNotNull(axis.tick_labels)
    Assert.IsNotEmpty(axis.scale_type)
    Assert.IsNotEmpty(axis.axis_color)
    Return True

Process called "validate_plot_series" that takes series as PlotSeries returns Boolean:
    Note: Validates plot series structure
    Assert.IsNotNull(series.data_points)
    Assert.IsNotEmpty(series.series_type)
    Assert.IsNotEmpty(series.color)
    Assert.IsNotEmpty(series.line_style)
    Assert.IsNotEmpty(series.label)
    Return True

Process called "validate_plot_canvas" that takes canvas as PlotCanvas returns Boolean:
    Note: Validates plot canvas structure
    Assert.IsTrue(canvas.width > 0.0)
    Assert.IsTrue(canvas.height > 0.0)
    Assert.IsTrue(validate_plot_axis(canvas.x_axis))
    Assert.IsTrue(validate_plot_axis(canvas.y_axis))
    Assert.IsNotNull(canvas.series_list)
    Assert.IsNotNull(canvas.annotations)
    Return True

Note: =====================================================================
Note: BASIC PLOTTING INFRASTRUCTURE TESTS
Note: =====================================================================

Process called "test_plot_axis_creation" that takes no parameters returns Boolean:
    Note: Test basic plot axis creation
    Let axis be PlotAxis
    Set axis.label to "X Axis"
    Set axis.range to [-5.0, 5.0]
    Set axis.tick_positions to [-5.0, -2.5, 0.0, 2.5, 5.0]
    Set axis.tick_labels to ["-5", "-2.5", "0", "2.5", "5"]
    Set axis.scale_type to "linear"
    Set axis.grid_visible to True
    Set axis.axis_color to "#000000"
    
    Assert.IsTrue(validate_plot_axis(axis))
    Assert.AreEqual(axis.label, "X Axis")
    Assert.AreEqual(axis.range.0, -5.0)
    Assert.AreEqual(axis.range.1, 5.0)
    Assert.AreEqual(axis.scale_type, "linear")
    Assert.IsTrue(axis.grid_visible)
    Return True

Process called "test_plot_series_creation" that takes no parameters returns Boolean:
    Note: Test basic plot series creation
    Let data_points be [[0.0, 0.0], [1.0, 1.0], [2.0, 4.0]]
    
    Let series be PlotSeries
    Set series.data_points to data_points
    Set series.series_type to "line"
    Set series.color to "#FF0000"
    Set series.line_style to "solid"
    Set series.marker_style to "circle"
    Set series.label to "Test Series"
    Set series.visibility to True
    
    Assert.IsTrue(validate_plot_series(series))
    Assert.AreEqual(series.data_points.length, 3)
    Assert.AreEqual(series.series_type, "line")
    Assert.AreEqual(series.color, "#FF0000")
    Assert.IsTrue(series.visibility)
    Return True

Process called "test_plot_canvas_creation" that takes no parameters returns Boolean:
    Note: Test basic plot canvas creation
    Let x_axis be PlotAxis
    Set x_axis.label to "X"
    Set x_axis.range to [0.0, 10.0]
    Set x_axis.scale_type to "linear"
    Set x_axis.grid_visible to True
    Set x_axis.axis_color to "#000000"
    Set x_axis.tick_positions to []
    Set x_axis.tick_labels to []
    
    Let y_axis be PlotAxis
    Set y_axis.label to "Y"
    Set y_axis.range to [-1.0, 1.0]
    Set y_axis.scale_type to "linear"
    Set y_axis.grid_visible to True
    Set y_axis.axis_color to "#000000"
    Set y_axis.tick_positions to []
    Set y_axis.tick_labels to []
    
    Let canvas be PlotCanvas
    Set canvas.width to 800.0
    Set canvas.height to 600.0
    Set canvas.x_axis to x_axis
    Set canvas.y_axis to y_axis
    Set canvas.title to "Test Plot"
    Set canvas.legend_visible to True
    Set canvas.series_list to []
    Set canvas.annotations to []
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    Assert.AreEqual(canvas.width, 800.0)
    Assert.AreEqual(canvas.height, 600.0)
    Assert.AreEqual(canvas.title, "Test Plot")
    Assert.IsTrue(canvas.legend_visible)
    Return True

Note: =====================================================================
Note: 2D FUNCTION PLOTTING TESTS
Note: =====================================================================

Process called "test_plot_function_basic" that takes no parameters returns Boolean:
    Note: Test basic function plotting
    Let function be create_test_linear_function()
    Let domain be [-2.0, 2.0]
    Let resolution be 50
    Let plot_style be {"color": "#0066CC", "line_style": "solid"}
    
    Let canvas be Plotting.plot_function(function, domain, resolution, plot_style)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    Assert.AreEqual(canvas.series_list.length, 1)
    
    Let series be canvas.series_list[0]
    Assert.IsTrue(validate_plot_series(series))
    Assert.AreEqual(series.series_type, "line")
    Assert.AreEqual(series.color, "#0066CC")
    Assert.IsTrue(series.data_points.length > 0)
    
    Let first_point be series.data_points[0]
    Let last_point be series.data_points[series.data_points.length - 1]
    Assert.IsTrue(first_point[0] >= domain.0 - 0.1)
    Assert.IsTrue(last_point[0] <= domain.1 + 0.1)
    Return True

Process called "test_plot_function_quadratic" that takes no parameters returns Boolean:
    Note: Test quadratic function plotting
    Let function be create_test_quadratic_function()
    Let domain be [-1.0, 5.0]
    Let resolution be 100
    Let plot_style be {"color": "#FF6600", "line_style": "dashed"}
    
    Let canvas be Plotting.plot_function(function, domain, resolution, plot_style)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    Assert.AreEqual(canvas.series_list.length, 1)
    
    Let series be canvas.series_list[0]
    Assert.AreEqual(series.color, "#FF6600")
    Assert.AreEqual(series.line_style, "dashed")
    
    Note: Check that vertex is at x = 2 (where derivative = 0)
    Let vertex_x be 2.0
    Let expected_y be function(vertex_x)
    
    Let found_vertex be False
    Let point_index be 0
    While point_index < series.data_points.length:
        Let point be series.data_points[point_index]
        If AbsoluteValue(point[0] - vertex_x) < 0.1:
            If AbsoluteValue(point[1] - expected_y) < 0.1:
                Set found_vertex to True
        Let point_index be point_index + 1
    
    Assert.IsTrue(found_vertex)
    Return True

Process called "test_plot_function_trigonometric" that takes no parameters returns Boolean:
    Note: Test trigonometric function plotting
    Let function be create_test_sine_function()
    Let domain be [0.0, 2.0 * Constants.PI]
    Let resolution be 200
    Let plot_style be {"color": "#009900", "marker_style": "none"}
    
    Let canvas be Plotting.plot_function(function, domain, resolution, plot_style)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    
    Let series be canvas.series_list[0]
    Assert.AreEqual(series.color, "#009900")
    
    Note: Check that function passes through known points
    Let tolerance be 0.05
    Let found_zero be False
    Let found_one be False
    
    Let point_index be 0
    While point_index < series.data_points.length:
        Let point be series.data_points[point_index]
        If AbsoluteValue(point[0] - 0.0) < tolerance:
            If AbsoluteValue(point[1] - 0.0) < tolerance:
                Set found_zero to True
        If AbsoluteValue(point[0] - Constants.PI/2.0) < tolerance:
            If AbsoluteValue(point[1] - 1.0) < tolerance:
                Set found_one to True
        Let point_index be point_index + 1
    
    Assert.IsTrue(found_zero)
    Assert.IsTrue(found_one)
    Return True

Process called "test_plot_multiple_functions" that takes no parameters returns Boolean:
    Note: Test plotting multiple functions on same canvas
    Let linear_func be create_test_linear_function()
    Let sine_func be create_test_sine_function()
    Let domain be [-2.0, 2.0]
    Let resolution be 100
    
    Let linear_style be {"color": "#FF0000", "label": "Linear"}
    Let sine_style be {"color": "#0000FF", "label": "Sine"}
    
    Let canvas1 be Plotting.plot_function(linear_func, domain, resolution, linear_style)
    Let canvas2 be Plotting.plot_function(sine_func, domain, resolution, sine_style)
    
    Let combined_canvas be Plotting.combine_plots([canvas1, canvas2])
    
    Assert.IsTrue(validate_plot_canvas(combined_canvas))
    Assert.AreEqual(combined_canvas.series_list.length, 2)
    
    Let linear_series be combined_canvas.series_list[0]
    Let sine_series be combined_canvas.series_list[1]
    
    Assert.AreEqual(linear_series.color, "#FF0000")
    Assert.AreEqual(sine_series.color, "#0000FF")
    Assert.AreEqual(linear_series.label, "Linear")
    Assert.AreEqual(sine_series.label, "Sine")
    Return True

Note: =====================================================================
Note: PARAMETRIC AND POLAR PLOTTING TESTS
Note: =====================================================================

Process called "test_plot_parametric_curve_basic" that takes no parameters returns Boolean:
    Note: Test basic parametric curve plotting
    Let parametric_func be create_test_parametric_function()
    Let parameter_range be [0.0, 2.0 * Constants.PI]
    Let resolution be 100
    Let plot_style be {"color": "#9900CC", "line_style": "solid"}
    
    Let canvas be Plotting.plot_parametric_curve(parametric_func, parameter_range, resolution, plot_style)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    Assert.AreEqual(canvas.series_list.length, 1)
    
    Let series be canvas.series_list[0]
    Assert.AreEqual(series.series_type, "line")
    Assert.AreEqual(series.color, "#9900CC")
    
    Note: Check that curve forms a circle
    Let point_index be 0
    While point_index < series.data_points.length:
        Let point be series.data_points[point_index]
        Let x be point[0]
        Let y be point[1]
        Let radius be (x * x + y * y) ^ 0.5
        Assert.IsTrue(AbsoluteValue(radius - 1.0) < 0.1)
        Let point_index be point_index + 1
    
    Return True

Process called "test_plot_parametric_curve_spiral" that takes no parameters returns Boolean:
    Note: Test parametric spiral curve plotting
    Process called "spiral_function" that takes t as Float64 returns List[Float64]:
        Let r be t / (2.0 * Constants.PI)
        Return [r * Trig.cos(t), r * Trig.sin(t)]
    
    Let spiral_func as Function be spiral_function
    Let parameter_range be [0.0, 4.0 * Constants.PI]
    Let resolution be 200
    Let plot_style be {"color": "#FF9900", "line_style": "solid"}
    
    Let canvas be Plotting.plot_parametric_curve(spiral_func, parameter_range, resolution, plot_style)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    
    Let series be canvas.series_list[0]
    
    Note: Check that radius increases with parameter
    Let first_point be series.data_points[0]
    Let last_point be series.data_points[series.data_points.length - 1]
    
    Let first_radius be (first_point[0]^2 + first_point[1]^2)^0.5
    Let last_radius be (last_point[0]^2 + last_point[1]^2)^0.5
    
    Assert.IsTrue(last_radius > first_radius)
    Return True

Process called "test_plot_polar_curve_basic" that takes no parameters returns Boolean:
    Note: Test basic polar curve plotting
    Process called "cardioid_function" that takes theta as Float64 returns Float64:
        Return 1.0 + Trig.cos(theta)
    
    Let polar_func as Function be cardioid_function
    Let angle_range be [0.0, 2.0 * Constants.PI]
    Let resolution be 150
    Let plot_style be {"color": "#00CC99", "marker_style": "none"}
    
    Let canvas be Plotting.plot_polar_curve(polar_func, angle_range, resolution, plot_style)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    
    Let series be canvas.series_list[0]
    Assert.AreEqual(series.color, "#00CC99")
    
    Note: Check cardioid properties (should have cusp at origin)
    Let found_cusp be False
    Let point_index be 0
    While point_index < series.data_points.length:
        Let point be series.data_points[point_index]
        Let distance_from_origin be (point[0]^2 + point[1]^2)^0.5
        If distance_from_origin < 0.1:
            Set found_cusp to True
        Let point_index be point_index + 1
    
    Assert.IsTrue(found_cusp)
    Return True

Process called "test_plot_polar_curve_rose" that takes no parameters returns Boolean:
    Note: Test polar rose curve plotting
    Process called "rose_function" that takes theta as Float64 returns Float64:
        Return Trig.cos(3.0 * theta)
    
    Let rose_func as Function be rose_function
    Let angle_range be [0.0, Constants.PI]
    Let resolution be 100
    Let plot_style be {"color": "#FF0099"}
    
    Let canvas be Plotting.plot_polar_curve(rose_func, angle_range, resolution, plot_style)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    
    Let series be canvas.series_list[0]
    
    Note: Check that curve has three petals (rose with k=3)
    Let petal_count be 0
    Let max_radius be 0.0
    
    Let point_index be 0
    While point_index < series.data_points.length:
        Let point be series.data_points[point_index]
        Let radius be (point[0]^2 + point[1]^2)^0.5
        If radius > max_radius:
            Set max_radius to radius
        Let point_index be point_index + 1
    
    Assert.IsTrue(max_radius > 0.8) Note: Rose should reach near unit circle
    Return True

Note: =====================================================================
Note: MULTIVARIATE FUNCTION VISUALIZATION TESTS
Note: =====================================================================

Process called "test_plot_contour_basic" that takes no parameters returns Boolean:
    Note: Test basic contour plot creation
    Let function be create_test_multivariate_function()
    Let x_range be [-2.0, 2.0]
    Let y_range be [-2.0, 2.0]
    Let resolution be [20, 20]
    Let contour_levels be [1.0, 4.0, 9.0, 16.0]
    
    Let contour_options be {
        "levels": contour_levels,
        "colors": ["#0000FF", "#00FF00", "#FFFF00", "#FF0000"],
        "line_styles": ["solid", "solid", "solid", "solid"],
        "show_labels": True
    }
    
    Let canvas be Plotting.plot_contour(function, x_range, y_range, resolution, contour_options)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    Assert.AreEqual(canvas.series_list.length, contour_levels.length)
    
    Let level_index be 0
    While level_index < contour_levels.length:
        Let series be canvas.series_list[level_index]
        Assert.AreEqual(series.series_type, "contour")
        Assert.IsTrue(series.data_points.length > 0)
        Let level_index be level_index + 1
    
    Return True

Process called "test_plot_filled_contour" that takes no parameters returns Boolean:
    Note: Test filled contour plot creation
    Let function be create_test_multivariate_function()
    Let x_range be [-1.5, 1.5]
    Let y_range be [-1.5, 1.5]
    Let resolution be [15, 15]
    
    Let filled_options be {
        "levels": 10,
        "colormap": "viridis",
        "alpha": 0.8,
        "show_contour_lines": True
    }
    
    Let canvas be Plotting.plot_filled_contour(function, x_range, y_range, resolution, filled_options)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    Assert.IsTrue(canvas.series_list.length > 0)
    
    Let filled_series be canvas.series_list[0]
    Assert.AreEqual(filled_series.series_type, "filled_contour")
    Return True

Process called "test_plot_3d_surface_projection" that takes no parameters returns Boolean:
    Note: Test 3D surface as 2D projection
    Let function be create_test_multivariate_function()
    Let x_range be [-2.0, 2.0]
    Let y_range be [-2.0, 2.0]
    Let resolution be [25, 25]
    
    Let surface_options be {
        "projection": "orthographic",
        "elevation_angle": 45.0,
        "azimuth_angle": 30.0,
        "wireframe": True,
        "color_by_height": True
    }
    
    Let canvas be Plotting.plot_surface_projection(function, x_range, y_range, resolution, surface_options)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    Assert.IsTrue(canvas.series_list.length > 0)
    
    Let surface_series be canvas.series_list[0]
    Assert.AreEqual(surface_series.series_type, "surface_projection")
    Return True

Note: =====================================================================
Note: IMPLICIT FUNCTION PLOTTING TESTS
Note: =====================================================================

Process called "test_plot_implicit_function_basic" that takes no parameters returns Boolean:
    Note: Test basic implicit function plotting
    Process called "circle_implicit" that takes x as Float64, y as Float64 returns Float64:
        Return x * x + y * y - 1.0
    
    Let implicit_func as Function be circle_implicit
    Let x_range be [-1.5, 1.5]
    Let y_range be [-1.5, 1.5]
    Let resolution be [50, 50]
    Let level be 0.0
    
    Let implicit_options be {
        "level": level,
        "tolerance": 0.01,
        "color": "#9900FF",
        "line_width": 2.0
    }
    
    Let canvas be Plotting.plot_implicit_function(implicit_func, x_range, y_range, resolution, implicit_options)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    Assert.AreEqual(canvas.series_list.length, 1)
    
    Let series be canvas.series_list[0]
    Assert.AreEqual(series.series_type, "implicit")
    Assert.AreEqual(series.color, "#9900FF")
    
    Note: Check that points approximate a circle
    Let point_index be 0
    While point_index < series.data_points.length:
        Let point be series.data_points[point_index]
        Let x be point[0]
        Let y be point[1]
        Let radius be (x * x + y * y) ^ 0.5
        Assert.IsTrue(AbsoluteValue(radius - 1.0) < 0.2)
        Let point_index be point_index + 1
    
    Return True

Process called "test_plot_level_curves" that takes no parameters returns Boolean:
    Note: Test level curve plotting
    Process called "hyperbola_function" that takes x as Float64, y as Float64 returns Float64:
        Return x * x - y * y
    
    Let level_func as Function be hyperbola_function
    Let x_range be [-3.0, 3.0]
    Let y_range be [-3.0, 3.0]
    Let resolution be [40, 40]
    Let levels be [-4.0, -1.0, 0.0, 1.0, 4.0]
    
    Let level_options be {
        "levels": levels,
        "colors": ["#FF0000", "#FF8800", "#FFFF00", "#88FF00", "#00FF00"],
        "show_level_labels": True
    }
    
    Let canvas be Plotting.plot_level_curves(level_func, x_range, y_range, resolution, level_options)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    Assert.AreEqual(canvas.series_list.length, levels.length)
    
    Let level_index be 0
    While level_index < levels.length:
        Let series be canvas.series_list[level_index]
        Assert.AreEqual(series.series_type, "level_curve")
        Let level_index be level_index + 1
    
    Return True

Note: =====================================================================
Note: VECTOR FIELD VISUALIZATION TESTS
Note: =====================================================================

Process called "test_plot_vector_field_basic" that takes no parameters returns Boolean:
    Note: Test basic vector field plotting
    Let vector_field be create_test_vector_field()
    Let x_range be [-2.0, 2.0]
    Let y_range be [-2.0, 2.0]
    Let grid_resolution be [10, 10]
    
    Let vector_options be {
        "arrow_scale": 0.5,
        "arrow_color": "#0066FF",
        "normalize_arrows": False,
        "show_magnitude": False
    }
    
    Let canvas be Plotting.plot_vector_field(vector_field, x_range, y_range, grid_resolution, vector_options)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    Assert.AreEqual(canvas.series_list.length, 1)
    
    Let series be canvas.series_list[0]
    Assert.AreEqual(series.series_type, "vector_field")
    Assert.AreEqual(series.color, "#0066FF")
    Return True

Process called "test_plot_streamlines" that takes no parameters returns Boolean:
    Note: Test streamline plotting for vector fields
    Let vector_field be create_test_vector_field()
    Let x_range be [-2.0, 2.0]
    Let y_range be [-2.0, 2.0]
    Let starting_points be [[1.0, 0.0], [0.0, 1.0], [-1.0, 0.0], [0.0, -1.0]]
    
    Let streamline_options be {
        "integration_method": "rk4",
        "step_size": 0.01,
        "max_length": 100,
        "color": "#FF6600",
        "line_width": 1.5
    }
    
    Let canvas be Plotting.plot_streamlines(vector_field, x_range, y_range, starting_points, streamline_options)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    Assert.AreEqual(canvas.series_list.length, starting_points.length)
    
    Let stream_index be 0
    While stream_index < canvas.series_list.length:
        Let series be canvas.series_list[stream_index]
        Assert.AreEqual(series.series_type, "streamline")
        Assert.IsTrue(series.data_points.length > 1)
        Let stream_index be stream_index + 1
    
    Return True

Process called "test_plot_gradient_field" that takes no parameters returns Boolean:
    Note: Test gradient field visualization
    Let scalar_field be create_test_multivariate_function()
    Let x_range be [-1.0, 1.0]
    Let y_range be [-1.0, 1.0]
    Let grid_resolution be [8, 8]
    
    Let gradient_options be {
        "compute_gradient": True,
        "arrow_scale": 0.3,
        "color_by_magnitude": True,
        "show_potential_lines": True
    }
    
    Let canvas be Plotting.plot_gradient_field(scalar_field, x_range, y_range, grid_resolution, gradient_options)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    Assert.IsTrue(canvas.series_list.length >= 1)
    
    Let gradient_series be canvas.series_list[0]
    Assert.AreEqual(gradient_series.series_type, "gradient_field")
    Return True

Note: =====================================================================
Note: STATISTICAL PLOTTING TESTS
Note: =====================================================================

Process called "test_plot_histogram_basic" that takes no parameters returns Boolean:
    Note: Test basic histogram plotting
    Let data_values be [1.2, 2.3, 2.1, 3.4, 3.2, 3.8, 4.1, 4.5, 4.3, 5.1, 5.4, 5.7]
    Let bin_count be 5
    
    Let histogram_options be {
        "bins": bin_count,
        "color": "#66CC99",
        "alpha": 0.7,
        "edge_color": "#004466",
        "density": False
    }
    
    Let canvas be Plotting.plot_histogram(data_values, histogram_options)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    Assert.AreEqual(canvas.series_list.length, 1)
    
    Let series be canvas.series_list[0]
    Assert.AreEqual(series.series_type, "histogram")
    Assert.AreEqual(series.color, "#66CC99")
    
    Note: Check that bins cover data range
    Let min_value be data_values[0]
    Let max_value be data_values[0]
    Let value_index be 0
    While value_index < data_values.length:
        If data_values[value_index] < min_value:
            Set min_value to data_values[value_index]
        If data_values[value_index] > max_value:
            Set max_value to data_values[value_index]
        Let value_index be value_index + 1
    
    Assert.IsTrue(canvas.x_axis.range.0 <= min_value)
    Assert.IsTrue(canvas.x_axis.range.1 >= max_value)
    Return True

Process called "test_plot_scatter_basic" that takes no parameters returns Boolean:
    Note: Test basic scatter plot
    Let data_points be generate_test_data_points(20)
    
    Let scatter_options be {
        "marker": "circle",
        "size": 50,
        "color": "#FF3366",
        "alpha": 0.8,
        "edge_color": "#990022"
    }
    
    Let canvas be Plotting.plot_scatter(data_points, scatter_options)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    Assert.AreEqual(canvas.series_list.length, 1)
    
    Let series be canvas.series_list[0]
    Assert.AreEqual(series.series_type, "scatter")
    Assert.AreEqual(series.color, "#FF3366")
    Assert.AreEqual(series.data_points.length, data_points.length)
    Return True

Process called "test_plot_regression_analysis" that takes no parameters returns Boolean:
    Note: Test linear regression plotting
    Let data_points be generate_test_data_points(30)
    
    Let regression_options be {
        "regression_type": "linear",
        "show_equation": True,
        "show_r_squared": True,
        "confidence_interval": 0.95,
        "line_color": "#0066CC",
        "point_color": "#666666"
    }
    
    Let canvas be Plotting.plot_regression(data_points, regression_options)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    Assert.IsTrue(canvas.series_list.length >= 2) Note: Points + regression line
    
    Let found_regression_line be False
    Let found_scatter_points be False
    
    Let series_index be 0
    While series_index < canvas.series_list.length:
        Let series be canvas.series_list[series_index]
        If series.series_type = "line":
            Set found_regression_line to True
        If series.series_type = "scatter":
            Set found_scatter_points to True
        Let series_index be series_index + 1
    
    Assert.IsTrue(found_regression_line)
    Assert.IsTrue(found_scatter_points)
    Return True

Process called "test_plot_box_plot" that takes no parameters returns Boolean:
    Note: Test box plot creation
    Let dataset1 be [1.0, 2.0, 2.5, 3.0, 3.2, 3.8, 4.0, 4.5, 5.0, 6.0]
    Let dataset2 be [2.0, 2.8, 3.1, 3.3, 3.5, 3.7, 4.0, 4.2, 4.8, 5.5]
    Let datasets be [dataset1, dataset2]
    Let labels be ["Group A", "Group B"]
    
    Let box_options be {
        "show_outliers": True,
        "show_means": True,
        "box_colors": ["#99CCFF", "#FFCC99"],
        "whisker_style": "solid"
    }
    
    Let canvas be Plotting.plot_box_plot(datasets, labels, box_options)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    Assert.AreEqual(canvas.series_list.length, datasets.length)
    
    Let box_index be 0
    While box_index < canvas.series_list.length:
        Let series be canvas.series_list[box_index]
        Assert.AreEqual(series.series_type, "box_plot")
        Let box_index be box_index + 1
    
    Return True

Note: =====================================================================
Note: PLOT STYLING AND CUSTOMIZATION TESTS
Note: =====================================================================

Process called "test_plot_custom_styling" that takes no parameters returns Boolean:
    Note: Test custom plot styling options
    Let function be create_test_sine_function()
    Let domain be [0.0, 2.0 * Constants.PI]
    Let resolution be 100
    
    Let custom_style be {
        "color": "#8A2BE2",
        "line_style": "dashdot",
        "line_width": 3.0,
        "marker_style": "square",
        "marker_size": 8,
        "marker_color": "#FF4500",
        "alpha": 0.8
    }
    
    Let canvas be Plotting.plot_function(function, domain, resolution, custom_style)
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    
    Let series be canvas.series_list[0]
    Assert.AreEqual(series.color, "#8A2BE2")
    Assert.AreEqual(series.line_style, "dashdot")
    Assert.AreEqual(series.marker_style, "square")
    Return True

Process called "test_plot_annotations" that takes no parameters returns Boolean:
    Note: Test plot annotations and labels
    Let function be create_test_quadratic_function()
    Let domain be [-1.0, 5.0]
    Let resolution be 50
    Let plot_style be {"color": "#006600"}
    
    Let canvas be Plotting.plot_function(function, domain, resolution, plot_style)
    
    Let annotations be [
        {"type": "text", "position": [2.0, -1.0], "text": "Vertex", "color": "#FF0000", "font_size": 12},
        {"type": "arrow", "start": [1.5, 0.0], "end": [2.0, -1.0], "color": "#FF0000"},
        {"type": "point", "position": [1.0, 0.0], "color": "#0000FF", "size": 8},
        {"type": "point", "position": [3.0, 0.0], "color": "#0000FF", "size": 8}
    ]
    
    Let annotated_canvas be Plotting.add_annotations(canvas, annotations)
    
    Assert.IsTrue(validate_plot_canvas(annotated_canvas))
    Assert.AreEqual(annotated_canvas.annotations.length, annotations.length)
    Return True

Process called "test_plot_axis_customization" that takes no parameters returns Boolean:
    Note: Test plot axis customization
    Let function be create_test_linear_function()
    Let domain be [-5.0, 5.0]
    Let resolution be 50
    Let plot_style be {"color": "#333333"}
    
    Let canvas be Plotting.plot_function(function, domain, resolution, plot_style)
    
    Let axis_options be {
        "x_label": "Input Variable (x)",
        "y_label": "Output Variable (y)",
        "title": "Linear Function: y = 2x + 1",
        "x_scale": "linear",
        "y_scale": "linear",
        "grid": True,
        "grid_color": "#CCCCCC",
        "axis_color": "#000000"
    }
    
    Let customized_canvas be Plotting.customize_axes(canvas, axis_options)
    
    Assert.IsTrue(validate_plot_canvas(customized_canvas))
    Assert.AreEqual(customized_canvas.x_axis.label, "Input Variable (x)")
    Assert.AreEqual(customized_canvas.y_axis.label, "Output Variable (y)")
    Assert.AreEqual(customized_canvas.title, "Linear Function: y = 2x + 1")
    Assert.IsTrue(customized_canvas.x_axis.grid_visible)
    Return True

Note: =====================================================================
Note: INTERACTIVE FEATURES TESTS
Note: =====================================================================

Process called "test_plot_interactivity_basic" that takes no parameters returns Boolean:
    Note: Test basic plot interactivity features
    Let function be create_test_sine_function()
    Let domain be [0.0, 2.0 * Constants.PI]
    Let resolution be 100
    Let plot_style be {"color": "#0099FF"}
    
    Let canvas be Plotting.plot_function(function, domain, resolution, plot_style)
    
    Let interaction_options be {
        "zoom_enabled": True,
        "pan_enabled": True,
        "crosshair_cursor": True,
        "data_tips": True,
        "legend_interactive": True
    }
    
    Let interactive_canvas be Plotting.enable_interactivity(canvas, interaction_options)
    
    Assert.IsTrue(validate_plot_canvas(interactive_canvas))
    Assert.IsTrue("interaction_handlers" in interactive_canvas.annotations[0])
    Return True

Process called "test_real_time_plot_update" that takes no parameters returns Boolean:
    Note: Test real-time plot updates
    Let initial_data be [[0.0, 0.0], [1.0, 1.0]]
    Let scatter_options be {"marker": "circle", "color": "#FF6600"}
    
    Let canvas be Plotting.plot_scatter(initial_data, scatter_options)
    
    Let new_data be [[0.0, 0.0], [1.0, 1.0], [2.0, 4.0], [3.0, 9.0]]
    Let updated_canvas be Plotting.update_plot_data(canvas, new_data)
    
    Assert.IsTrue(validate_plot_canvas(updated_canvas))
    Assert.AreEqual(updated_canvas.series_list[0].data_points.length, 4)
    
    Let last_point be updated_canvas.series_list[0].data_points[3]
    Assert.AreEqual(last_point[0], 3.0)
    Assert.AreEqual(last_point[1], 9.0)
    Return True

Note: =====================================================================
Note: EXPORT AND PERFORMANCE TESTS
Note: =====================================================================

Process called "test_plot_export_formats" that takes no parameters returns Boolean:
    Note: Test plot export to various formats
    Let function be create_test_quadratic_function()
    Let domain be [-2.0, 4.0]
    Let resolution be 100
    Let plot_style be {"color": "#9900CC"}
    
    Let canvas be Plotting.plot_function(function, domain, resolution, plot_style)
    
    Let svg_export be Plotting.export_plot(canvas, "svg", {"width": 800, "height": 600})
    Assert.IsNotEmpty(svg_export)
    Assert.IsTrue(svg_export.contains("<svg"))
    Assert.IsTrue(svg_export.contains("</svg>"))
    
    Let png_export be Plotting.export_plot(canvas, "png", {"width": 800, "height": 600, "dpi": 300})
    Assert.IsNotNull(png_export)
    
    Let json_export be Plotting.export_plot(canvas, "json", {})
    Assert.IsNotEmpty(json_export)
    Assert.IsTrue(json_export.contains("series_list"))
    
    Return True

Process called "test_large_dataset_performance" that takes no parameters returns Boolean:
    Note: Test performance with large datasets
    Let large_data_points be generate_test_data_points(1000)
    
    Let start_time be GetCurrentTime()
    
    Let scatter_options be {"marker": "point", "size": 2, "color": "#666666"}
    Let canvas be Plotting.plot_scatter(large_data_points, scatter_options)
    
    Let plot_time be GetCurrentTime() - start_time
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    Assert.AreEqual(canvas.series_list[0].data_points.length, 1000)
    Assert.IsTrue(plot_time < 2.0) Note: Should complete within 2 seconds
    Return True

Note: =====================================================================
Note: ERROR HANDLING AND EDGE CASES
Note: =====================================================================

Process called "test_plot_error_handling" that takes no parameters returns Boolean:
    Note: Test error handling in plotting functions
    Try:
        Let invalid_domain be [2.0, 1.0] Note: min > max
        Let function be create_test_linear_function()
        Let invalid_canvas be Plotting.plot_function(function, invalid_domain, 50, {})
        Return False Note: Should throw error
    Catch error:
        Pass
    
    Try:
        Let zero_resolution be 0
        Let function be create_test_sine_function()
        Let domain be [0.0, 1.0]
        Let invalid_canvas be Plotting.plot_function(function, domain, zero_resolution, {})
        Return False Note: Should throw error
    Catch error:
        Pass
    
    Try:
        Let empty_data be []
        Let empty_canvas be Plotting.plot_scatter(empty_data, {})
        Assert.AreEqual(empty_canvas.series_list[0].data_points.length, 0)
    Catch error:
        Return False Note: Empty data should be handled gracefully
    
    Return True

Process called "test_plot_boundary_conditions" that takes no parameters returns Boolean:
    Note: Test plotting behavior at boundaries and edge cases
    Let function be create_test_sine_function()
    Let tiny_domain be [0.0, 0.001]
    Let resolution be 2
    
    Let canvas be Plotting.plot_function(function, tiny_domain, resolution, {"color": "#000000"})
    
    Assert.IsTrue(validate_plot_canvas(canvas))
    Assert.AreEqual(canvas.series_list[0].data_points.length, 2)
    
    Let first_point be canvas.series_list[0].data_points[0]
    Let last_point be canvas.series_list[0].data_points[1]
    
    Assert.IsTrue(first_point[0] >= tiny_domain.0 - 0.0001)
    Assert.IsTrue(last_point[0] <= tiny_domain.1 + 0.0001)
    Return True

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_all_tests" that takes no parameters returns Boolean:
    Note: Run all plotting module tests
    Let tests_passed be 0
    Let tests_failed be 0
    
    Note: Basic infrastructure tests
    Let infrastructure_tests be [
        "test_plot_axis_creation",
        "test_plot_series_creation",
        "test_plot_canvas_creation"
    ]
    
    Note: 2D function plotting tests
    Let function_tests be [
        "test_plot_function_basic",
        "test_plot_function_quadratic",
        "test_plot_function_trigonometric",
        "test_plot_multiple_functions"
    ]
    
    Note: Parametric and polar tests
    Let parametric_tests be [
        "test_plot_parametric_curve_basic",
        "test_plot_parametric_curve_spiral",
        "test_plot_polar_curve_basic",
        "test_plot_polar_curve_rose"
    ]
    
    Note: Multivariate visualization tests
    Let multivariate_tests be [
        "test_plot_contour_basic",
        "test_plot_filled_contour",
        "test_plot_3d_surface_projection"
    ]
    
    Note: Implicit function tests
    Let implicit_tests be [
        "test_plot_implicit_function_basic",
        "test_plot_level_curves"
    ]
    
    Note: Vector field tests
    Let vector_tests be [
        "test_plot_vector_field_basic",
        "test_plot_streamlines",
        "test_plot_gradient_field"
    ]
    
    Note: Statistical plotting tests
    Let statistical_tests be [
        "test_plot_histogram_basic",
        "test_plot_scatter_basic",
        "test_plot_regression_analysis",
        "test_plot_box_plot"
    ]
    
    Note: Styling and customization tests
    Let styling_tests be [
        "test_plot_custom_styling",
        "test_plot_annotations",
        "test_plot_axis_customization"
    ]
    
    Note: Interactive features tests
    Let interactive_tests be [
        "test_plot_interactivity_basic",
        "test_real_time_plot_update"
    ]
    
    Note: Export and performance tests
    Let export_tests be [
        "test_plot_export_formats",
        "test_large_dataset_performance"
    ]
    
    Note: Error handling tests
    Let error_tests be [
        "test_plot_error_handling",
        "test_plot_boundary_conditions"
    ]
    
    Let all_test_groups be [infrastructure_tests, function_tests, parametric_tests, multivariate_tests,
                           implicit_tests, vector_tests, statistical_tests, styling_tests,
                           interactive_tests, export_tests, error_tests]
    
    Let group_names be ["Infrastructure", "2D Functions", "Parametric & Polar", "Multivariate",
                       "Implicit Functions", "Vector Fields", "Statistical", "Styling",
                       "Interactive", "Export & Performance", "Error Handling"]
    
    For group_index from 0 to Length(all_test_groups) - 1:
        Let test_group be all_test_groups[group_index]
        Let group_name be group_names[group_index]
        Print "Testing " + group_name + " plotting..."
        
        For test_name in test_group:
            Try:
                Let test_result be Call test_name()
                If test_result:
                    Set tests_passed to tests_passed + 1
                    Print "  ✓ " + test_name
                Else:
                    Set tests_failed to tests_failed + 1  
                    Print "  ✗ " + test_name + " (returned false)"
            Catch error:
                Set tests_failed to tests_failed + 1
                Print "  ✗ " + test_name + " (error: " + error.message + ")"
    
    Let total_tests be tests_passed + tests_failed
    Print ""
    Print "Plotting Module Test Results:"
    Print "============================"
    Print "Tests passed: " + ToString(tests_passed)
    Print "Tests failed: " + ToString(tests_failed)
    Print "Total tests: " + ToString(total_tests)
    Print "Success rate: " + ToString((tests_passed * 100) / total_tests) + "%"
    
    Return tests_failed = 0