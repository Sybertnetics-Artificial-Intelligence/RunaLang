Note:
tests/unit/libraries/math/visualization/surfaces_test.runa
Unit Tests for Math Visualization Surfaces Module

This test suite provides comprehensive testing for the math visualization surfaces module including:
- 3D plotting infrastructure (Surface3D, Volume3D, Camera3D)
- Basic surface plotting for functions z = f(x,y)
- Parametric surface plotting and mesh generation
- Implicit surface extraction and isosurface visualization
- Volume rendering and scalar field visualization
- Vector field streamlines in 3D space
- Surface lighting, shading, and material properties
- Camera control and projection systems
- Surface mesh operations and optimization
- Interactive 3D navigation and manipulation
- Export functionality for 3D formats
- Performance optimization for complex surfaces
:End Note

Import "stdlib/math/visualization/surfaces" as Surfaces
Import "dev/debug/test_framework/assertions" as Assert
Import "dev/debug/test_framework/test_runner" as TestRunner
Import "dev/debug/test_framework/data_generators" as DataGen
Import "math/core/constants" as Constants
Import "math/core/trigonometry" as Trig
Import "math/engine/linalg/core" as LinearAlgebra

Note: =====================================================================
Note: HELPER FUNCTIONS AND TEST UTILITIES
Note: =====================================================================

Process called "create_test_surface_function" that takes no parameters returns Function:
    Note: Creates simple surface function z = x² + y²
    Process called "paraboloid" that takes x as Float64, y as Float64 returns Float64:
        Return x * x + y * y
    Return paraboloid

Process called "create_test_parametric_surface" that takes no parameters returns Function:
    Note: Creates parametric surface [u*cos(v), u*sin(v), u] (cone)
    Process called "cone_surface" that takes u as Float64, v as Float64 returns List[Float64]:
        Return [u * Trig.cos(v), u * Trig.sin(v), u]
    Return cone_surface

Process called "create_test_implicit_surface" that takes no parameters returns Function:
    Note: Creates implicit surface x² + y² + z² - 1 = 0 (sphere)
    Process called "sphere_implicit" that takes x as Float64, y as Float64, z as Float64 returns Float64:
        Return x * x + y * y + z * z - 1.0
    Return sphere_implicit

Process called "create_test_vector_field_3d" that takes no parameters returns Function:
    Note: Creates 3D vector field [-y, x, z]
    Process called "spiral_field" that takes x as Float64, y as Float64, z as Float64 returns List[Float64]:
        Return [-y, x, z]
    Return spiral_field

Process called "create_test_scalar_field" that takes no parameters returns Function:
    Note: Creates scalar field for volume rendering
    Process called "gaussian_field" that takes x as Float64, y as Float64, z as Float64 returns Float64:
        Let r_squared be x * x + y * y + z * z
        Return Constants.E ^ (-r_squared)
    Return gaussian_field

Process called "validate_surface_3d" that takes surface as Surface3D returns Boolean:
    Note: Validates Surface3D structure
    Assert.IsNotNull(surface.vertices)
    Assert.IsNotNull(surface.faces)
    Assert.IsNotNull(surface.normals)
    Assert.IsNotNull(surface.colors)
    Assert.IsNotNull(surface.material_properties)
    Assert.IsTrue(surface.vertices.length > 0)
    Return True

Process called "validate_volume_3d" that takes volume as Volume3D returns Boolean:
    Note: Validates Volume3D structure
    Assert.IsNotNull(volume.dimensions)
    Assert.IsNotNull(volume.spacing)
    Assert.IsNotNull(volume.origin)
    Assert.IsNotNull(volume.scalar_field)
    Assert.IsTrue(volume.dimensions.length = 3)
    Assert.IsTrue(volume.spacing.length = 3)
    Assert.IsTrue(volume.origin.length = 3)
    Return True

Process called "validate_camera_3d" that takes camera as Camera3D returns Boolean:
    Note: Validates Camera3D structure
    Assert.IsNotNull(camera.position)
    Assert.IsNotNull(camera.target)
    Assert.IsNotNull(camera.up_vector)
    Assert.IsTrue(camera.position.length = 3)
    Assert.IsTrue(camera.target.length = 3)
    Assert.IsTrue(camera.up_vector.length = 3)
    Assert.IsTrue(camera.field_of_view > 0.0 and camera.field_of_view < 180.0)
    Assert.IsTrue(camera.near_clip > 0.0)
    Assert.IsTrue(camera.far_clip > camera.near_clip)
    Return True

Process called "calculate_surface_area" that takes surface as Surface3D returns Float64:
    Note: Calculates approximate surface area
    Let total_area be 0.0
    Let face_index be 0
    While face_index < surface.faces.length:
        Let face be surface.faces[face_index]
        If face.length >= 3:
            Let v1 be surface.vertices[face[0]]
            Let v2 be surface.vertices[face[1]]
            Let v3 be surface.vertices[face[2]]
            
            Let edge1 be [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]]
            Let edge2 be [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]]
            
            Let cross_product be [
                edge1[1] * edge2[2] - edge1[2] * edge2[1],
                edge1[2] * edge2[0] - edge1[0] * edge2[2],
                edge1[0] * edge2[1] - edge1[1] * edge2[0]
            ]
            
            Let magnitude be (cross_product[0]^2 + cross_product[1]^2 + cross_product[2]^2)^0.5
            Let triangle_area be 0.5 * magnitude
            Set total_area to total_area + triangle_area
        Let face_index be face_index + 1
    
    Return total_area

Note: =====================================================================
Note: 3D PLOTTING INFRASTRUCTURE TESTS
Note: =====================================================================

Process called "test_surface_3d_creation" that takes no parameters returns Boolean:
    Note: Test basic Surface3D structure creation
    Let surface be Surface3D
    Set surface.vertices to [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]
    Set surface.faces to [[0, 1, 2]]
    Set surface.normals to [[0.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 0.0, 1.0]]
    Set surface.colors to [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]
    Set surface.texture_coordinates to [[0.0, 0.0], [1.0, 0.0], [0.5, 1.0]]
    Set surface.material_properties to {"shininess": 32.0, "metallic": 0.0, "roughness": 0.5}
    
    Assert.IsTrue(validate_surface_3d(surface))
    Assert.AreEqual(surface.vertices.length, 3)
    Assert.AreEqual(surface.faces.length, 1)
    Assert.AreEqual(surface.faces[0].length, 3)
    Assert.AreEqual(surface.material_properties["shininess"], 32.0)
    Return True

Process called "test_volume_3d_creation" that takes no parameters returns Boolean:
    Note: Test basic Volume3D structure creation
    Let volume be Volume3D
    Set volume.dimensions to [10, 10, 10]
    Set volume.spacing to [0.1, 0.1, 0.1]
    Set volume.origin to [-0.5, -0.5, -0.5]
    Set volume.scalar_field to [[[0.5]]]
    Set volume.vector_field to [[[[1.0, 0.0, 0.0]]]]
    
    Assert.IsTrue(validate_volume_3d(volume))
    Assert.AreEqual(volume.dimensions[0], 10)
    Assert.AreEqual(volume.dimensions[1], 10)
    Assert.AreEqual(volume.dimensions[2], 10)
    Assert.AreEqual(volume.spacing[0], 0.1)
    Assert.AreEqual(volume.origin[2], -0.5)
    Return True

Process called "test_camera_3d_creation" that takes no parameters returns Boolean:
    Note: Test basic Camera3D structure creation
    Let camera be Camera3D
    Set camera.position to [5.0, 5.0, 5.0]
    Set camera.target to [0.0, 0.0, 0.0]
    Set camera.up_vector to [0.0, 0.0, 1.0]
    Set camera.field_of_view to 45.0
    Set camera.near_clip to 0.1
    Set camera.far_clip to 100.0
    Set camera.projection_type to "perspective"
    
    Assert.IsTrue(validate_camera_3d(camera))
    Assert.AreEqual(camera.position[0], 5.0)
    Assert.AreEqual(camera.target[1], 0.0)
    Assert.AreEqual(camera.field_of_view, 45.0)
    Assert.AreEqual(camera.projection_type, "perspective")
    Return True

Note: =====================================================================
Note: BASIC SURFACE PLOTTING TESTS
Note: =====================================================================

Process called "test_plot_surface_function_basic" that takes no parameters returns Boolean:
    Note: Test basic surface function plotting
    Let function be create_test_surface_function()
    Let x_range be [-2.0, 2.0]
    Let y_range be [-2.0, 2.0]
    Let resolution be [10, 10]
    
    Let surface be Surfaces.plot_surface_function(function, x_range, y_range, resolution)
    
    Assert.IsTrue(validate_surface_3d(surface))
    Assert.AreEqual(surface.vertices.length, 10 * 10)
    
    Note: Check that vertices are within expected bounds
    Let vertex_index be 0
    While vertex_index < surface.vertices.length:
        Let vertex be surface.vertices[vertex_index]
        Assert.IsTrue(vertex[0] >= x_range.0 and vertex[0] <= x_range.1)
        Assert.IsTrue(vertex[1] >= y_range.0 and vertex[1] <= y_range.1)
        Assert.IsTrue(vertex[2] >= 0.0) Note: z = x² + y² should be non-negative
        Let vertex_index be vertex_index + 1
    
    Return True

Process called "test_plot_surface_function_higher_resolution" that takes no parameters returns Boolean:
    Note: Test surface function with higher resolution
    Let function be create_test_surface_function()
    Let x_range be [-1.0, 1.0]
    Let y_range be [-1.0, 1.0]
    Let resolution be [20, 15]
    
    Let surface be Surfaces.plot_surface_function(function, x_range, y_range, resolution)
    
    Assert.IsTrue(validate_surface_3d(surface))
    Assert.AreEqual(surface.vertices.length, 20 * 15)
    
    Note: Check face count - should be (nx-1)*(ny-1)*2 triangles
    Let expected_faces be (20 - 1) * (15 - 1) * 2
    Assert.AreEqual(surface.faces.length, expected_faces)
    
    Note: Verify that normals are computed
    Assert.AreEqual(surface.normals.length, surface.vertices.length)
    Return True

Process called "test_plot_surface_function_with_singularities" that takes no parameters returns Boolean:
    Note: Test surface function with potential singularities
    Process called "hyperbolic_surface" that takes x as Float64, y as Float64 returns Float64:
        If AbsoluteValue(x) < 0.01 and AbsoluteValue(y) < 0.01:
            Return 0.0 Note: Avoid division by zero
        Return 1.0 / (x * x + y * y + 0.1)
    
    Let function as Function be hyperbolic_surface
    Let x_range be [-1.0, 1.0]
    Let y_range be [-1.0, 1.0]
    Let resolution be [15, 15]
    
    Let surface be Surfaces.plot_surface_function(function, x_range, y_range, resolution)
    
    Assert.IsTrue(validate_surface_3d(surface))
    
    Note: Check that all z-values are finite
    Let vertex_index be 0
    While vertex_index < surface.vertices.length:
        Let vertex be surface.vertices[vertex_index]
        Assert.IsTrue(vertex[2] != Infinity and vertex[2] != -Infinity)
        Assert.IsFalse(IsNaN(vertex[2]))
        Let vertex_index be vertex_index + 1
    
    Return True

Process called "test_surface_normal_computation" that takes no parameters returns Boolean:
    Note: Test surface normal vector computation
    Let function be create_test_surface_function()
    Let x_range be [-1.0, 1.0]
    Let y_range be [-1.0, 1.0]
    Let resolution be [5, 5]
    
    Let surface be Surfaces.plot_surface_function(function, x_range, y_range, resolution)
    
    Assert.IsTrue(validate_surface_3d(surface))
    
    Note: Check that normals are unit vectors
    Let normal_index be 0
    While normal_index < surface.normals.length:
        Let normal be surface.normals[normal_index]
        Let magnitude be (normal[0]^2 + normal[1]^2 + normal[2]^2)^0.5
        Assert.IsTrue(AbsoluteValue(magnitude - 1.0) < 0.01)
        Let normal_index be normal_index + 1
    
    Return True

Note: =====================================================================
Note: PARAMETRIC SURFACE TESTS
Note: =====================================================================

Process called "test_plot_parametric_surface_basic" that takes no parameters returns Boolean:
    Note: Test basic parametric surface plotting
    Let parametric_func be create_test_parametric_surface()
    Let u_range be [0.0, 2.0]
    Let v_range be [0.0, 2.0 * Constants.PI]
    Let resolution be [10, 20]
    
    Let surface be Surfaces.plot_parametric_surface(parametric_func, u_range, v_range, resolution)
    
    Assert.IsTrue(validate_surface_3d(surface))
    Assert.AreEqual(surface.vertices.length, 10 * 20)
    
    Note: Check that surface forms a cone
    Let vertex_index be 0
    While vertex_index < surface.vertices.length:
        Let vertex be surface.vertices[vertex_index]
        Let x be vertex[0]
        Let y be vertex[1]
        Let z be vertex[2]
        Let radius be (x^2 + y^2)^0.5
        
        Note: For cone, radius should approximately equal z
        If z > 0.1: Note: Avoid near-apex issues
            Assert.IsTrue(AbsoluteValue(radius - z) < 0.2)
        Let vertex_index be vertex_index + 1
    
    Return True

Process called "test_plot_parametric_torus" that takes no parameters returns Boolean:
    Note: Test parametric torus surface
    Process called "torus_surface" that takes u as Float64, v as Float64 returns List[Float64]:
        Let R be 2.0 Note: Major radius
        Let r be 0.5 Note: Minor radius
        Let x be (R + r * Trig.cos(v)) * Trig.cos(u)
        Let y be (R + r * Trig.cos(v)) * Trig.sin(u)
        Let z be r * Trig.sin(v)
        Return [x, y, z]
    
    Let torus_func as Function be torus_surface
    Let u_range be [0.0, 2.0 * Constants.PI]
    Let v_range be [0.0, 2.0 * Constants.PI]
    Let resolution be [16, 12]
    
    Let surface be Surfaces.plot_parametric_surface(torus_func, u_range, v_range, resolution)
    
    Assert.IsTrue(validate_surface_3d(surface))
    
    Note: Check torus topology - should be genus-1 surface
    Let center_vertex_found be False
    Let vertex_index be 0
    While vertex_index < surface.vertices.length:
        Let vertex be surface.vertices[vertex_index]
        Let distance_from_origin be (vertex[0]^2 + vertex[1]^2 + vertex[2]^2)^0.5
        
        Note: All points should be within reasonable distance
        Assert.IsTrue(distance_from_origin < 3.0)
        Assert.IsTrue(distance_from_origin > 1.0)
        Let vertex_index be vertex_index + 1
    
    Return True

Process called "test_plot_parametric_mobius_strip" that takes no parameters returns Boolean:
    Note: Test parametric Möbius strip surface
    Process called "mobius_surface" that takes u as Float64, v as Float64 returns List[Float64]:
        Let x be (1.0 + v/2.0 * Trig.cos(u/2.0)) * Trig.cos(u)
        Let y be (1.0 + v/2.0 * Trig.cos(u/2.0)) * Trig.sin(u)
        Let z be v/2.0 * Trig.sin(u/2.0)
        Return [x, y, z]
    
    Let mobius_func as Function be mobius_surface
    Let u_range be [0.0, 2.0 * Constants.PI]
    Let v_range be [-0.5, 0.5]
    Let resolution be [20, 8]
    
    Let surface be Surfaces.plot_parametric_surface(mobius_func, u_range, v_range, resolution)
    
    Assert.IsTrue(validate_surface_3d(surface))
    
    Note: Möbius strip should be a non-orientable surface
    Let surface_area be calculate_surface_area(surface)
    Assert.IsTrue(surface_area > 0.0)
    Return True

Note: =====================================================================
Note: IMPLICIT SURFACE TESTS
Note: =====================================================================

Process called "test_plot_implicit_surface_sphere" that takes no parameters returns Boolean:
    Note: Test implicit sphere surface extraction
    Let implicit_func be create_test_implicit_surface()
    Let domain_bounds be [-1.5, 1.5, -1.5, 1.5, -1.5, 1.5]
    Let resolution be [20, 20, 20]
    Let iso_level be 0.0
    
    Let surface be Surfaces.plot_implicit_surface(implicit_func, domain_bounds, resolution, iso_level)
    
    Assert.IsTrue(validate_surface_3d(surface))
    Assert.IsTrue(surface.vertices.length > 0)
    
    Note: Check that vertices approximate a unit sphere
    Let vertex_index be 0
    While vertex_index < surface.vertices.length:
        Let vertex be surface.vertices[vertex_index]
        Let distance_from_origin be (vertex[0]^2 + vertex[1]^2 + vertex[2]^2)^0.5
        Assert.IsTrue(AbsoluteValue(distance_from_origin - 1.0) < 0.2)
        Let vertex_index be vertex_index + 1
    
    Return True

Process called "test_plot_implicit_surface_torus_equation" that takes no parameters returns Boolean:
    Note: Test implicit torus surface
    Process called "torus_implicit" that takes x as Float64, y as Float64, z as Float64 returns Float64:
        Let R be 2.0
        Let r be 0.8
        Let term1 be (x^2 + y^2 + z^2 + R^2 - r^2)^2
        Let term2 be 4.0 * R^2 * (x^2 + y^2)
        Return term1 - term2
    
    Let torus_func as Function be torus_implicit
    Let domain_bounds be [-3.0, 3.0, -3.0, 3.0, -1.0, 1.0]
    Let resolution be [25, 25, 15]
    Let iso_level be 0.0
    
    Let surface be Surfaces.plot_implicit_surface(torus_func, domain_bounds, resolution, iso_level)
    
    Assert.IsTrue(validate_surface_3d(surface))
    
    Note: Check torus properties
    Let min_distance_from_z_axis be Float64.MAX_VALUE
    Let max_distance_from_z_axis be 0.0
    
    Let vertex_index be 0
    While vertex_index < surface.vertices.length:
        Let vertex be surface.vertices[vertex_index]
        Let distance_from_z_axis be (vertex[0]^2 + vertex[1]^2)^0.5
        
        If distance_from_z_axis < min_distance_from_z_axis:
            Set min_distance_from_z_axis to distance_from_z_axis
        If distance_from_z_axis > max_distance_from_z_axis:
            Set max_distance_from_z_axis to distance_from_z_axis
        Let vertex_index be vertex_index + 1
    
    Assert.IsTrue(min_distance_from_z_axis > 1.0) Note: Inner radius
    Assert.IsTrue(max_distance_from_z_axis < 3.0) Note: Outer radius
    Return True

Process called "test_marching_cubes_algorithm" that takes no parameters returns Boolean:
    Note: Test marching cubes isosurface extraction
    Process called "simple_sphere" that takes x as Float64, y as Float64, z as Float64 returns Float64:
        Return x^2 + y^2 + z^2 - 0.25
    
    Let sphere_func as Function be simple_sphere
    Let bounds be [-1.0, 1.0, -1.0, 1.0, -1.0, 1.0]
    Let grid_resolution be [12, 12, 12]
    Let iso_value be 0.0
    
    Let marching_options be {
        "algorithm": "marching_cubes",
        "edge_interpolation": True,
        "generate_normals": True,
        "smooth_normals": True
    }
    
    Let surface be Surfaces.extract_isosurface(sphere_func, bounds, grid_resolution, iso_value, marching_options)
    
    Assert.IsTrue(validate_surface_3d(surface))
    
    Note: Check mesh quality
    Assert.IsTrue(surface.vertices.length >= 8) Note: At least basic mesh
    Assert.IsTrue(surface.faces.length > 0)
    
    Note: All faces should be triangles
    Let face_index be 0
    While face_index < surface.faces.length:
        Assert.AreEqual(surface.faces[face_index].length, 3)
        Let face_index be face_index + 1
    
    Return True

Note: =====================================================================
Note: VOLUME RENDERING TESTS
Note: =====================================================================

Process called "test_volume_rendering_basic" that takes no parameters returns Boolean:
    Note: Test basic volume rendering setup
    Let scalar_field_func be create_test_scalar_field()
    Let volume_bounds be [-2.0, 2.0, -2.0, 2.0, -2.0, 2.0]
    Let resolution be [16, 16, 16]
    
    Let volume be Surfaces.create_volume_from_function(scalar_field_func, volume_bounds, resolution)
    
    Assert.IsTrue(validate_volume_3d(volume))
    Assert.AreEqual(volume.dimensions[0], 16)
    Assert.AreEqual(volume.dimensions[1], 16)
    Assert.AreEqual(volume.dimensions[2], 16)
    
    Note: Check scalar field values
    Assert.IsNotNull(volume.scalar_field)
    Assert.AreEqual(volume.scalar_field.length, 16)
    Assert.AreEqual(volume.scalar_field[0].length, 16)
    Assert.AreEqual(volume.scalar_field[0][0].length, 16)
    Return True

Process called "test_volume_ray_casting" that takes no parameters returns Boolean:
    Note: Test volume ray casting rendering
    Let scalar_field_func be create_test_scalar_field()
    Let volume_bounds be [-1.0, 1.0, -1.0, 1.0, -1.0, 1.0]
    Let resolution be [12, 12, 12]
    
    Let volume be Surfaces.create_volume_from_function(scalar_field_func, volume_bounds, resolution)
    
    Let ray_casting_options be {
        "step_size": 0.01,
        "opacity_function": "linear",
        "color_transfer_function": "hot",
        "shading_enabled": True,
        "ambient_occlusion": False
    }
    
    Let rendered_volume be Surfaces.render_volume_ray_casting(volume, ray_casting_options)
    
    Assert.IsNotNull(rendered_volume)
    Assert.IsTrue("image_data" in rendered_volume)
    Assert.IsTrue("rendering_parameters" in rendered_volume)
    Return True

Process called "test_volume_isosurface_rendering" that takes no parameters returns Boolean:
    Note: Test volume isosurface rendering at multiple levels
    Let scalar_field_func be create_test_scalar_field()
    Let volume_bounds be [-1.5, 1.5, -1.5, 1.5, -1.5, 1.5]
    Let resolution be [20, 20, 20]
    
    Let volume be Surfaces.create_volume_from_function(scalar_field_func, volume_bounds, resolution)
    
    Let iso_levels be [0.1, 0.3, 0.6]
    Let iso_colors be ["#FF0000", "#00FF00", "#0000FF"]
    
    Let isosurface_options be {
        "levels": iso_levels,
        "colors": iso_colors,
        "transparency": [0.3, 0.5, 0.7],
        "smooth_surfaces": True
    }
    
    Let isosurfaces be Surfaces.render_volume_isosurfaces(volume, isosurface_options)
    
    Assert.IsNotNull(isosurfaces)
    Assert.AreEqual(isosurfaces.length, iso_levels.length)
    
    Let surface_index be 0
    While surface_index < isosurfaces.length:
        Assert.IsTrue(validate_surface_3d(isosurfaces[surface_index]))
        Let surface_index be surface_index + 1
    
    Return True

Note: =====================================================================
Note: 3D VECTOR FIELD TESTS
Note: =====================================================================

Process called "test_plot_3d_vector_field_basic" that takes no parameters returns Boolean:
    Note: Test basic 3D vector field visualization
    Let vector_field be create_test_vector_field_3d()
    Let domain_bounds be [-2.0, 2.0, -2.0, 2.0, -2.0, 2.0]
    Let grid_resolution be [8, 8, 8]
    
    Let vector_options be {
        "arrow_scale": 0.5,
        "normalize_vectors": False,
        "color_by_magnitude": True,
        "arrow_style": "3d"
    }
    
    Let vector_visualization be Surfaces.plot_3d_vector_field(vector_field, domain_bounds, grid_resolution, vector_options)
    
    Assert.IsNotNull(vector_visualization)
    Assert.IsTrue("vector_arrows" in vector_visualization)
    Assert.IsTrue("field_properties" in vector_visualization)
    
    Let arrows be vector_visualization["vector_arrows"]
    Assert.AreEqual(arrows.length, 8 * 8 * 8)
    
    Let arrow_index be 0
    While arrow_index < arrows.length:
        Let arrow be arrows[arrow_index]
        Assert.IsNotNull(arrow["position"])
        Assert.IsNotNull(arrow["direction"])
        Assert.IsNotNull(arrow["magnitude"])
        Let arrow_index be arrow_index + 1
    
    Return True

Process called "test_3d_streamlines_integration" that takes no parameters returns Boolean:
    Note: Test 3D streamline integration
    Let vector_field be create_test_vector_field_3d()
    Let starting_points be [
        [1.0, 0.0, 0.0],
        [0.0, 1.0, 0.0], 
        [0.0, 0.0, 1.0],
        [-1.0, 0.0, 0.0]
    ]
    
    Let streamline_options be {
        "integration_method": "rk4",
        "step_size": 0.05,
        "max_steps": 200,
        "domain_bounds": [-3.0, 3.0, -3.0, 3.0, -3.0, 3.0],
        "stop_at_boundary": True
    }
    
    Let streamlines be Surfaces.compute_3d_streamlines(vector_field, starting_points, streamline_options)
    
    Assert.IsNotNull(streamlines)
    Assert.AreEqual(streamlines.length, starting_points.length)
    
    Let streamline_index be 0
    While streamline_index < streamlines.length:
        Let streamline be streamlines[streamline_index]
        Assert.IsNotNull(streamline["path"])
        Assert.IsTrue(streamline["path"].length > 1)
        
        Let path_point_index be 0
        While path_point_index < streamline["path"].length:
            Let point be streamline["path"][path_point_index]
            Assert.AreEqual(point.length, 3) Note: 3D points
            Let path_point_index be path_point_index + 1
        
        Let streamline_index be streamline_index + 1
    
    Return True

Process called "test_3d_flow_visualization" that takes no parameters returns Boolean:
    Note: Test comprehensive 3D flow visualization
    Let vector_field be create_test_vector_field_3d()
    Let domain_bounds be [-2.0, 2.0, -2.0, 2.0, -1.0, 1.0]
    
    Let flow_options be {
        "show_vector_field": True,
        "show_streamlines": True,
        "show_divergence": True,
        "show_curl": True,
        "grid_resolution": [10, 10, 6],
        "streamline_density": "medium"
    }
    
    Let flow_viz be Surfaces.visualize_3d_flow(vector_field, domain_bounds, flow_options)
    
    Assert.IsNotNull(flow_viz)
    Assert.IsTrue("vector_field" in flow_viz)
    Assert.IsTrue("streamlines" in flow_viz)
    Assert.IsTrue("divergence_field" in flow_viz)
    Assert.IsTrue("curl_field" in flow_viz)
    Return True

Note: =====================================================================
Note: SURFACE LIGHTING AND SHADING TESTS
Note: =====================================================================

Process called "test_surface_lighting_basic" that takes no parameters returns Boolean:
    Note: Test basic surface lighting setup
    Let surface be Surface3D
    Set surface.vertices to [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]
    Set surface.faces to [[0, 1, 2]]
    Set surface.normals to [[0.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 0.0, 1.0]]
    Set surface.colors to [[0.8, 0.2, 0.2], [0.2, 0.8, 0.2], [0.2, 0.2, 0.8]]
    Set surface.material_properties to {"shininess": 64.0, "metallic": 0.1, "roughness": 0.3}
    
    Let light_sources be [
        {"type": "directional", "direction": [0.0, 0.0, -1.0], "color": [1.0, 1.0, 1.0], "intensity": 1.0},
        {"type": "point", "position": [2.0, 2.0, 2.0], "color": [0.8, 0.8, 1.0], "intensity": 0.5}
    ]
    
    Let lighting_options be {
        "ambient_light": [0.2, 0.2, 0.2],
        "light_sources": light_sources,
        "shading_model": "phong",
        "cast_shadows": False
    }
    
    Let lit_surface be Surfaces.apply_surface_lighting(surface, lighting_options)
    
    Assert.IsTrue(validate_surface_3d(lit_surface))
    Assert.IsTrue("lighting_data" in lit_surface.material_properties)
    Return True

Process called "test_surface_material_properties" that takes no parameters returns Boolean:
    Note: Test surface material property effects
    Let function be create_test_surface_function()
    Let x_range be [-1.0, 1.0]
    Let y_range be [-1.0, 1.0]
    Let resolution be [15, 15]
    
    Let surface be Surfaces.plot_surface_function(function, x_range, y_range, resolution)
    
    Let material_options be {
        "base_color": [0.7, 0.3, 0.1],
        "metallic": 0.8,
        "roughness": 0.2,
        "specular": 0.9,
        "emission": [0.0, 0.0, 0.0],
        "normal_map": None,
        "displacement_scale": 0.0
    }
    
    Let material_surface be Surfaces.apply_material_properties(surface, material_options)
    
    Assert.IsTrue(validate_surface_3d(material_surface))
    Assert.AreEqual(material_surface.material_properties["metallic"], 0.8)
    Assert.AreEqual(material_surface.material_properties["roughness"], 0.2)
    Return True

Process called "test_surface_texture_mapping" that takes no parameters returns Boolean:
    Note: Test surface texture coordinate mapping
    Let function be create_test_surface_function()
    Let x_range be [-1.0, 1.0]
    Let y_range be [-1.0, 1.0]
    Let resolution be [10, 10]
    
    Let surface be Surfaces.plot_surface_function(function, x_range, y_range, resolution)
    
    Let texture_options be {
        "mapping_type": "planar",
        "texture_scale": [2.0, 2.0],
        "texture_offset": [0.0, 0.0],
        "wrap_mode": "repeat"
    }
    
    Let textured_surface be Surfaces.apply_texture_mapping(surface, texture_options)
    
    Assert.IsTrue(validate_surface_3d(textured_surface))
    Assert.IsNotNull(textured_surface.texture_coordinates)
    Assert.AreEqual(textured_surface.texture_coordinates.length, textured_surface.vertices.length)
    
    Note: Check texture coordinate ranges
    Let tex_coord_index be 0
    While tex_coord_index < textured_surface.texture_coordinates.length:
        Let tex_coord be textured_surface.texture_coordinates[tex_coord_index]
        Assert.AreEqual(tex_coord.length, 2)
        Assert.IsTrue(tex_coord[0] >= 0.0 and tex_coord[0] <= 2.0)
        Assert.IsTrue(tex_coord[1] >= 0.0 and tex_coord[1] <= 2.0)
        Let tex_coord_index be tex_coord_index + 1
    
    Return True

Note: =====================================================================
Note: CAMERA CONTROL TESTS
Note: =====================================================================

Process called "test_camera_orbit_controls" that takes no parameters returns Boolean:
    Note: Test camera orbital movement controls
    Let initial_camera be Camera3D
    Set initial_camera.position to [5.0, 0.0, 0.0]
    Set initial_camera.target to [0.0, 0.0, 0.0]
    Set initial_camera.up_vector to [0.0, 0.0, 1.0]
    Set initial_camera.field_of_view to 45.0
    Set initial_camera.near_clip to 0.1
    Set initial_camera.far_clip to 100.0
    Set initial_camera.projection_type to "perspective"
    
    Let orbit_parameters be {
        "azimuth_angle": 45.0,
        "elevation_angle": 30.0,
        "distance": 5.0,
        "target_point": [0.0, 0.0, 0.0]
    }
    
    Let orbited_camera be Surfaces.orbit_camera(initial_camera, orbit_parameters)
    
    Assert.IsTrue(validate_camera_3d(orbited_camera))
    Assert.AreEqual(orbited_camera.target[0], 0.0)
    Assert.AreEqual(orbited_camera.target[1], 0.0)
    Assert.AreEqual(orbited_camera.target[2], 0.0)
    
    Note: Check that distance from target is maintained
    Let distance be ((orbited_camera.position[0] - orbited_camera.target[0])^2 + 
                     (orbited_camera.position[1] - orbited_camera.target[1])^2 + 
                     (orbited_camera.position[2] - orbited_camera.target[2])^2)^0.5
    
    Assert.IsTrue(AbsoluteValue(distance - 5.0) < 0.01)
    Return True

Process called "test_camera_projection_matrices" that takes no parameters returns Boolean:
    Note: Test camera projection matrix computation
    Let camera be Camera3D
    Set camera.position to [3.0, 4.0, 5.0]
    Set camera.target to [0.0, 0.0, 0.0]
    Set camera.up_vector to [0.0, 0.0, 1.0]
    Set camera.field_of_view to 60.0
    Set camera.near_clip to 0.5
    Set camera.far_clip to 50.0
    Set camera.projection_type to "perspective"
    
    Let projection_matrix be Surfaces.compute_projection_matrix(camera)
    
    Assert.IsNotNull(projection_matrix)
    Assert.AreEqual(projection_matrix.length, 4)
    Assert.AreEqual(projection_matrix[0].length, 4)
    
    Note: Check perspective projection properties
    Assert.IsTrue(projection_matrix[3][2] != 0.0) Note: Perspective division term
    
    Let view_matrix be Surfaces.compute_view_matrix(camera)
    
    Assert.IsNotNull(view_matrix)
    Assert.AreEqual(view_matrix.length, 4)
    Assert.AreEqual(view_matrix[0].length, 4)
    Return True

Process called "test_camera_frustum_culling" that takes no parameters returns Boolean:
    Note: Test camera frustum culling
    Let camera be Camera3D
    Set camera.position to [0.0, 0.0, 5.0]
    Set camera.target to [0.0, 0.0, 0.0]
    Set camera.up_vector to [0.0, 1.0, 0.0]
    Set camera.field_of_view to 45.0
    Set camera.near_clip to 1.0
    Set camera.far_clip to 10.0
    Set camera.projection_type to "perspective"
    
    Let test_points be [
        [0.0, 0.0, 2.0],   Note: Inside frustum
        [0.0, 0.0, 15.0],  Note: Beyond far plane
        [0.0, 0.0, 0.5],   Note: Before near plane
        [10.0, 0.0, 2.0],  Note: Outside side planes
    ]
    
    Let frustum_data be Surfaces.compute_camera_frustum(camera)
    
    Let visibility_results be []
    Let point_index be 0
    While point_index < test_points.length:
        Let point be test_points[point_index]
        Let is_visible be Surfaces.point_in_frustum(point, frustum_data)
        Let visibility_results be visibility_results with is_visible added
        Let point_index be point_index + 1
    
    Assert.IsTrue(visibility_results[0])  Note: Inside should be visible
    Assert.IsFalse(visibility_results[1]) Note: Beyond far should not be visible
    Assert.IsFalse(visibility_results[2]) Note: Before near should not be visible
    Assert.IsFalse(visibility_results[3]) Note: Outside sides should not be visible
    
    Return True

Note: =====================================================================
Note: SURFACE OPTIMIZATION TESTS
Note: =====================================================================

Process called "test_surface_mesh_simplification" that takes no parameters returns Boolean:
    Note: Test mesh simplification algorithms
    Let function be create_test_surface_function()
    Let x_range be [-2.0, 2.0]
    Let y_range be [-2.0, 2.0]
    Let resolution be [30, 30] Note: High resolution mesh
    
    Let original_surface be Surfaces.plot_surface_function(function, x_range, y_range, resolution)
    
    Let simplification_options be {
        "target_faces": 200,
        "preserve_boundaries": True,
        "quality_threshold": 0.8,
        "method": "quadric_error"
    }
    
    Let simplified_surface be Surfaces.simplify_mesh(original_surface, simplification_options)
    
    Assert.IsTrue(validate_surface_3d(simplified_surface))
    Assert.IsTrue(simplified_surface.faces.length <= 200)
    Assert.IsTrue(simplified_surface.faces.length < original_surface.faces.length)
    Assert.IsTrue(simplified_surface.vertices.length < original_surface.vertices.length)
    Return True

Process called "test_adaptive_mesh_refinement" that takes no parameters returns Boolean:
    Note: Test adaptive mesh refinement
    Process called "high_curvature_function" that takes x as Float64, y as Float64 returns Float64:
        Return x^4 - 2.0*x^2 + y^4 - 2.0*y^2 + 0.1*Trig.sin(10.0*x)*Trig.sin(10.0*y)
    
    Let function as Function be high_curvature_function
    Let x_range be [-1.5, 1.5]
    Let y_range be [-1.5, 1.5]
    Let initial_resolution be [8, 8]
    
    Let refinement_options be {
        "curvature_threshold": 0.5,
        "max_subdivision_levels": 3,
        "area_threshold": 0.01,
        "adaptive_strategy": "curvature_based"
    }
    
    Let adaptive_surface be Surfaces.adaptive_mesh_refinement(function, x_range, y_range, initial_resolution, refinement_options)
    
    Assert.IsTrue(validate_surface_3d(adaptive_surface))
    Assert.IsTrue(adaptive_surface.vertices.length > 8 * 8) Note: Should be more refined
    
    Note: Check that high-curvature regions have more vertices
    Let high_detail_count be 0
    Let vertex_index be 0
    While vertex_index < adaptive_surface.vertices.length:
        Let vertex be adaptive_surface.vertices[vertex_index]
        Let x be vertex[0]
        Let y be vertex[1]
        
        Note: Count vertices near high-curvature regions
        If AbsoluteValue(x) < 0.5 and AbsoluteValue(y) < 0.5:
            Set high_detail_count to high_detail_count + 1
        Let vertex_index be vertex_index + 1
    
    Assert.IsTrue(high_detail_count > 20) Note: Should have concentrated detail
    Return True

Process called "test_surface_mesh_smoothing" that takes no parameters returns Boolean:
    Note: Test mesh smoothing algorithms
    Let function be create_test_surface_function()
    Let x_range be [-1.0, 1.0]
    Let y_range be [-1.0, 1.0]
    Let resolution be [15, 15]
    
    Let noisy_surface be Surfaces.plot_surface_function(function, x_range, y_range, resolution)
    
    Note: Add artificial noise to vertices
    Let vertex_index be 0
    While vertex_index < noisy_surface.vertices.length:
        Let vertex be noisy_surface.vertices[vertex_index]
        Set vertex[2] to vertex[2] + 0.1 * (vertex_index % 3 - 1.0) Note: Simple noise
        Let vertex_index be vertex_index + 1
    
    Let smoothing_options be {
        "method": "laplacian",
        "iterations": 5,
        "smoothing_factor": 0.5,
        "preserve_features": True
    }
    
    Let smoothed_surface be Surfaces.smooth_mesh(noisy_surface, smoothing_options)
    
    Assert.IsTrue(validate_surface_3d(smoothed_surface))
    Assert.AreEqual(smoothed_surface.vertices.length, noisy_surface.vertices.length)
    Assert.AreEqual(smoothed_surface.faces.length, noisy_surface.faces.length)
    Return True

Note: =====================================================================
Note: EXPORT AND PERFORMANCE TESTS
Note: =====================================================================

Process called "test_surface_export_formats" that takes no parameters returns Boolean:
    Note: Test surface export to various 3D formats
    Let function be create_test_surface_function()
    Let x_range be [-1.0, 1.0]
    Let y_range be [-1.0, 1.0]
    Let resolution be [10, 10]
    
    Let surface be Surfaces.plot_surface_function(function, x_range, y_range, resolution)
    
    Let obj_export be Surfaces.export_surface(surface, "obj")
    Assert.IsNotEmpty(obj_export)
    Assert.IsTrue(obj_export.contains("v ")) Note: Vertex lines
    Assert.IsTrue(obj_export.contains("f ")) Note: Face lines
    
    Let stl_export be Surfaces.export_surface(surface, "stl")
    Assert.IsNotEmpty(stl_export)
    Assert.IsTrue(stl_export.contains("solid"))
    Assert.IsTrue(stl_export.contains("facet"))
    
    Let ply_export be Surfaces.export_surface(surface, "ply")
    Assert.IsNotEmpty(ply_export)
    Assert.IsTrue(ply_export.contains("ply"))
    Assert.IsTrue(ply_export.contains("vertex"))
    
    Return True

Process called "test_large_surface_performance" that takes no parameters returns Boolean:
    Note: Test performance with large surface meshes
    Let function be create_test_surface_function()
    Let x_range be [-2.0, 2.0]
    Let y_range be [-2.0, 2.0]
    Let resolution be [50, 50] Note: Large resolution
    
    Let start_time be GetCurrentTime()
    Let large_surface be Surfaces.plot_surface_function(function, x_range, y_range, resolution)
    Let computation_time be GetCurrentTime() - start_time
    
    Assert.IsTrue(validate_surface_3d(large_surface))
    Assert.AreEqual(large_surface.vertices.length, 50 * 50)
    Assert.IsTrue(computation_time < 3.0) Note: Should complete within 3 seconds
    
    Note: Test rendering performance
    Let render_start be GetCurrentTime()
    Let lighting_options be {"ambient_light": [0.2, 0.2, 0.2], "light_sources": [], "shading_model": "flat"}
    Let rendered_surface be Surfaces.apply_surface_lighting(large_surface, lighting_options)
    Let render_time be GetCurrentTime() - render_start
    
    Assert.IsTrue(render_time < 2.0) Note: Rendering should also be fast
    Return True

Note: =====================================================================
Note: ERROR HANDLING TESTS
Note: =====================================================================

Process called "test_surface_error_handling" that takes no parameters returns Boolean:
    Note: Test error handling in surface operations
    Try:
        Let invalid_range be [2.0, 1.0] Note: min > max
        Let function be create_test_surface_function()
        Let invalid_surface be Surfaces.plot_surface_function(function, invalid_range, [-1.0, 1.0], [5, 5])
        Return False Note: Should throw error
    Catch error:
        Pass
    
    Try:
        Let zero_resolution be [0, 5]
        Let function be create_test_surface_function()
        Let invalid_surface be Surfaces.plot_surface_function(function, [-1.0, 1.0], [-1.0, 1.0], zero_resolution)
        Return False Note: Should throw error
    Catch error:
        Pass
    
    Try:
        Let empty_surface be Surface3D
        Set empty_surface.vertices to []
        Set empty_surface.faces to []
        Set empty_surface.normals to []
        Set empty_surface.colors to []
        Set empty_surface.material_properties to {}
        
        Let lighting_options be {"ambient_light": [0.2, 0.2, 0.2], "light_sources": [], "shading_model": "phong"}
        Let result be Surfaces.apply_surface_lighting(empty_surface, lighting_options)
        Assert.AreEqual(result.vertices.length, 0) Note: Should handle empty surface gracefully
    Catch error:
        Return False Note: Empty surface should be handled without error
    
    Return True

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_all_tests" that takes no parameters returns Boolean:
    Note: Run all surfaces module tests
    Let tests_passed be 0
    Let tests_failed be 0
    
    Note: Infrastructure tests
    Let infrastructure_tests be [
        "test_surface_3d_creation",
        "test_volume_3d_creation",
        "test_camera_3d_creation"
    ]
    
    Note: Basic surface plotting tests
    Let surface_tests be [
        "test_plot_surface_function_basic",
        "test_plot_surface_function_higher_resolution",
        "test_plot_surface_function_with_singularities",
        "test_surface_normal_computation"
    ]
    
    Note: Parametric surface tests
    Let parametric_tests be [
        "test_plot_parametric_surface_basic",
        "test_plot_parametric_torus",
        "test_plot_parametric_mobius_strip"
    ]
    
    Note: Implicit surface tests
    Let implicit_tests be [
        "test_plot_implicit_surface_sphere",
        "test_plot_implicit_surface_torus_equation",
        "test_marching_cubes_algorithm"
    ]
    
    Note: Volume rendering tests
    Let volume_tests be [
        "test_volume_rendering_basic",
        "test_volume_ray_casting",
        "test_volume_isosurface_rendering"
    ]
    
    Note: 3D vector field tests
    Let vector_tests be [
        "test_plot_3d_vector_field_basic",
        "test_3d_streamlines_integration",
        "test_3d_flow_visualization"
    ]
    
    Note: Lighting and shading tests
    Let lighting_tests be [
        "test_surface_lighting_basic",
        "test_surface_material_properties",
        "test_surface_texture_mapping"
    ]
    
    Note: Camera control tests
    Let camera_tests be [
        "test_camera_orbit_controls",
        "test_camera_projection_matrices",
        "test_camera_frustum_culling"
    ]
    
    Note: Optimization tests
    Let optimization_tests be [
        "test_surface_mesh_simplification",
        "test_adaptive_mesh_refinement",
        "test_surface_mesh_smoothing"
    ]
    
    Note: Export and performance tests
    Let export_tests be [
        "test_surface_export_formats",
        "test_large_surface_performance"
    ]
    
    Note: Error handling tests
    Let error_tests be [
        "test_surface_error_handling"
    ]
    
    Let all_test_groups be [infrastructure_tests, surface_tests, parametric_tests, implicit_tests,
                           volume_tests, vector_tests, lighting_tests, camera_tests,
                           optimization_tests, export_tests, error_tests]
    
    Let group_names be ["Infrastructure", "Basic Surfaces", "Parametric Surfaces", "Implicit Surfaces",
                       "Volume Rendering", "3D Vector Fields", "Lighting & Shading", "Camera Control",
                       "Mesh Optimization", "Export & Performance", "Error Handling"]
    
    For group_index from 0 to Length(all_test_groups) - 1:
        Let test_group be all_test_groups[group_index]
        Let group_name be group_names[group_index]
        Print "Testing " + group_name + " surfaces..."
        
        For test_name in test_group:
            Try:
                Let test_result be Call test_name()
                If test_result:
                    Set tests_passed to tests_passed + 1
                    Print "  ✓ " + test_name
                Else:
                    Set tests_failed to tests_failed + 1  
                    Print "  ✗ " + test_name + " (returned false)"
            Catch error:
                Set tests_failed to tests_failed + 1
                Print "  ✗ " + test_name + " (error: " + error.message + ")"
    
    Let total_tests be tests_passed + tests_failed
    Print ""
    Print "Surfaces Module Test Results:"
    Print "============================"
    Print "Tests passed: " + ToString(tests_passed)
    Print "Tests failed: " + ToString(tests_failed)
    Print "Total tests: " + ToString(total_tests)
    Print "Success rate: " + ToString((tests_passed * 100) / total_tests) + "%"
    
    Return tests_failed = 0