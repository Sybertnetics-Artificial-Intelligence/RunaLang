Note: Comprehensive unit tests for the math/symbols/set_theory module
Note: Tests set membership, set relations, set operations, quantifiers, cardinality, functions/relations, order theory, special sets, and category theory

Import "dev/test" as UnitTest
Import "stdlib/math/symbols/set_theory" as SetTheory
Import "collections" as Collections

Note: Test helper functions for set theory symbols testing

Process called "create_set_membership_test" returns Dictionary[String, Any]:
    Return Collections.create_dictionary([
        ("symbol", "∈"),
        ("name", "element_of"),
        ("unicode", "U+2208"),
        ("latex", "\\in"),
        ("relation_type", "membership"),
        ("arity", 2),
        ("expected_valid", true)
    ])

Process called "create_set_operation_test" returns Dictionary[String, Any]:
    Return Collections.create_dictionary([
        ("symbol", "∪"),
        ("name", "union"),
        ("unicode", "U+222A"),
        ("latex", "\\cup"),
        ("operation_type", "binary_set_operation"),
        ("associative", true),
        ("commutative", true),
        ("expected_valid", true)
    ])

Process called "create_cardinality_test" returns Dictionary[String, Any]:
    Return Collections.create_dictionary([
        ("symbol", "|A|"),
        ("name", "cardinality"),
        ("notation", "absolute_value_bars"),
        ("meaning", "size_of_set"),
        ("expected_valid", true)
    ])

Process called "assert_set_symbol_properties" that takes symbol as Dictionary[String, Any], expected as Dictionary[String, Any], message as String:
    UnitTest.assert_equals(Collections.get_from_dictionary(symbol, "symbol"), Collections.get_from_dictionary(expected, "symbol"), message + " - Symbol should match")
    UnitTest.assert_equals(Collections.get_from_dictionary(symbol, "name"), Collections.get_from_dictionary(expected, "name"), message + " - Name should match")
    UnitTest.assert_equals(Collections.get_from_dictionary(symbol, "unicode"), Collections.get_from_dictionary(expected, "unicode"), message + " - Unicode should match")
    UnitTest.assert_true(Collections.has_key(symbol, "latex"), message + " - Should have LaTeX representation")

Process called "assert_operation_properties" that takes operation as Dictionary[String, Any], expected_commutative as Boolean, message as String:
    UnitTest.assert_equals(Collections.get_from_dictionary(operation, "commutative"), expected_commutative, message + " - Commutativity should match")
    UnitTest.assert_true(Collections.has_key(operation, "associative"), message + " - Should have associativity property")
    UnitTest.assert_true(Collections.has_key(operation, "identity_element"), message + " - Should have identity element")

Note: Set Membership Tests

Process called "test_get_membership_symbols":
    Let membership_symbols be SetTheory.get_membership_symbols()
    
    UnitTest.assert_true(Collections.size(membership_symbols) >= 4, "Should have at least 4 membership symbols")
    UnitTest.assert_true(Collections.has_key(membership_symbols, "∈"), "Should contain element of")
    UnitTest.assert_true(Collections.has_key(membership_symbols, "∉"), "Should contain not element of")
    UnitTest.assert_true(Collections.has_key(membership_symbols, "∋"), "Should contain contains")
    UnitTest.assert_true(Collections.has_key(membership_symbols, "∌"), "Should contain does not contain")

Process called "test_element_of_symbol":
    Let element_of be SetTheory.element_of_symbol()
    Let expected be create_set_membership_test()
    
    assert_set_symbol_properties(element_of, expected, "Element of symbol")
    UnitTest.assert_equals(element_of.relation_type, "membership", "Should be membership relation")

Process called "test_not_element_of_symbol":
    Let not_element be SetTheory.not_element_of_symbol()
    
    UnitTest.assert_equals(not_element.symbol, "∉", "Not element of symbol should be ∉")
    UnitTest.assert_equals(not_element.name, "not_element_of", "Name should be not_element_of")
    UnitTest.assert_equals(not_element.unicode, "U+2209", "Unicode should be correct")
    UnitTest.assert_equals(not_element.relation_type, "negated_membership", "Should be negated membership")

Process called "test_contains_symbol":
    Let contains be SetTheory.contains_symbol()
    
    UnitTest.assert_equals(contains.symbol, "∋", "Contains symbol should be ∋")
    UnitTest.assert_equals(contains.name, "contains", "Name should be contains")
    UnitTest.assert_equals(contains.unicode, "U+220B", "Unicode should be correct")
    UnitTest.assert_equals(contains.relation_type, "reverse_membership", "Should be reverse membership")

Process called "test_does_not_contain_symbol":
    Let not_contains be SetTheory.does_not_contain_symbol()
    
    UnitTest.assert_equals(not_contains.symbol, "∌", "Does not contain symbol should be ∌")
    UnitTest.assert_equals(not_contains.name, "does_not_contain", "Name should be does_not_contain")
    UnitTest.assert_equals(not_contains.unicode, "U+220C", "Unicode should be correct")

Note: Set Relations Tests

Process called "test_get_set_relation_symbols":
    Let relations be SetTheory.get_set_relation_symbols()
    
    UnitTest.assert_true(Collections.size(relations) >= 8, "Should have at least 8 set relation symbols")
    UnitTest.assert_true(Collections.has_key(relations, "⊂"), "Should contain subset")
    UnitTest.assert_true(Collections.has_key(relations, "⊃"), "Should contain superset")
    UnitTest.assert_true(Collections.has_key(relations, "⊆"), "Should contain subset or equal")
    UnitTest.assert_true(Collections.has_key(relations, "⊇"), "Should contain superset or equal")

Process called "test_subset_symbol":
    Let subset be SetTheory.subset_symbol()
    
    UnitTest.assert_equals(subset.symbol, "⊂", "Subset symbol should be ⊂")
    UnitTest.assert_equals(subset.name, "subset", "Name should be subset")
    UnitTest.assert_equals(subset.unicode, "U+2282", "Unicode should be correct")
    UnitTest.assert_equals(subset.relation_type, "strict_inclusion", "Should be strict inclusion")

Process called "test_superset_symbol":
    Let superset be SetTheory.superset_symbol()
    
    UnitTest.assert_equals(superset.symbol, "⊃", "Superset symbol should be ⊃")
    UnitTest.assert_equals(superset.name, "superset", "Name should be superset")
    UnitTest.assert_equals(superset.unicode, "U+2283", "Unicode should be correct")
    UnitTest.assert_equals(superset.relation_type, "strict_inclusion", "Should be strict inclusion")

Process called "test_subset_or_equal_symbol":
    Let subset_eq be SetTheory.subset_or_equal_symbol()
    
    UnitTest.assert_equals(subset_eq.symbol, "⊆", "Subset or equal symbol should be ⊆")
    UnitTest.assert_equals(subset_eq.name, "subset_or_equal", "Name should be subset_or_equal")
    UnitTest.assert_equals(subset_eq.unicode, "U+2286", "Unicode should be correct")
    UnitTest.assert_equals(subset_eq.relation_type, "inclusion", "Should be inclusion")

Process called "test_superset_or_equal_symbol":
    Let superset_eq be SetTheory.superset_or_equal_symbol()
    
    UnitTest.assert_equals(superset_eq.symbol, "⊇", "Superset or equal symbol should be ⊇")
    UnitTest.assert_equals(superset_eq.name, "superset_or_equal", "Name should be superset_or_equal")
    UnitTest.assert_equals(superset_eq.unicode, "U+2287", "Unicode should be correct")

Process called "test_proper_subset_symbol":
    Let proper_subset be SetTheory.proper_subset_symbol()
    
    UnitTest.assert_equals(proper_subset.symbol, "⊊", "Proper subset symbol should be ⊊")
    UnitTest.assert_equals(proper_subset.name, "proper_subset", "Name should be proper_subset")
    UnitTest.assert_equals(proper_subset.unicode, "U+228A", "Unicode should be correct")

Process called "test_proper_superset_symbol":
    Let proper_superset be SetTheory.proper_superset_symbol()
    
    UnitTest.assert_equals(proper_superset.symbol, "⊋", "Proper superset symbol should be ⊋")
    UnitTest.assert_equals(proper_superset.name, "proper_superset", "Name should be proper_superset")
    UnitTest.assert_equals(proper_superset.unicode, "U+228B", "Unicode should be correct")

Note: Set Operations Tests

Process called "test_get_set_operation_symbols":
    Let operations be SetTheory.get_set_operation_symbols()
    
    UnitTest.assert_true(Collections.size(operations) >= 6, "Should have at least 6 set operation symbols")
    UnitTest.assert_true(Collections.has_key(operations, "∪"), "Should contain union")
    UnitTest.assert_true(Collections.has_key(operations, "∩"), "Should contain intersection")
    UnitTest.assert_true(Collections.has_key(operations, "∖"), "Should contain set difference")
    UnitTest.assert_true(Collections.has_key(operations, "△"), "Should contain symmetric difference")

Process called "test_union_symbol":
    Let union be SetTheory.union_symbol()
    Let expected be create_set_operation_test()
    
    assert_set_symbol_properties(union, expected, "Union symbol")
    assert_operation_properties(union, true, "Union operation")

Process called "test_intersection_symbol":
    Let intersection be SetTheory.intersection_symbol()
    
    UnitTest.assert_equals(intersection.symbol, "∩", "Intersection symbol should be ∩")
    UnitTest.assert_equals(intersection.name, "intersection", "Name should be intersection")
    UnitTest.assert_equals(intersection.unicode, "U+2229", "Unicode should be correct")
    assert_operation_properties(intersection, true, "Intersection operation")

Process called "test_set_difference_symbol":
    Let difference be SetTheory.set_difference_symbol()
    
    UnitTest.assert_equals(difference.symbol, "∖", "Set difference symbol should be ∖")
    UnitTest.assert_equals(difference.name, "set_difference", "Name should be set_difference")
    UnitTest.assert_equals(difference.unicode, "U+2216", "Unicode should be correct")
    UnitTest.assert_false(difference.commutative, "Set difference should not be commutative")

Process called "test_symmetric_difference_symbol":
    Let sym_diff be SetTheory.symmetric_difference_symbol()
    
    UnitTest.assert_equals(sym_diff.symbol, "△", "Symmetric difference symbol should be △")
    UnitTest.assert_equals(sym_diff.name, "symmetric_difference", "Name should be symmetric_difference")
    UnitTest.assert_equals(sym_diff.unicode, "U+25B3", "Unicode should be correct")
    UnitTest.assert_true(sym_diff.commutative, "Symmetric difference should be commutative")

Process called "test_cartesian_product_symbol":
    Let cartesian be SetTheory.cartesian_product_symbol()
    
    UnitTest.assert_equals(cartesian.symbol, "×", "Cartesian product symbol should be ×")
    UnitTest.assert_equals(cartesian.name, "cartesian_product", "Name should be cartesian_product")
    UnitTest.assert_equals(cartesian.unicode, "U+00D7", "Unicode should be correct")
    UnitTest.assert_false(cartesian.commutative, "Cartesian product should not be commutative")

Process called "test_complement_symbol":
    Let complement be SetTheory.complement_symbol()
    
    UnitTest.assert_equals(complement.symbol, "∁", "Complement symbol should be ∁")
    UnitTest.assert_equals(complement.name, "complement", "Name should be complement")
    UnitTest.assert_equals(complement.unicode, "U+2201", "Unicode should be correct")
    UnitTest.assert_equals(complement.arity, 1, "Complement should be unary operation")

Note: Cardinality Tests

Process called "test_get_cardinality_symbols":
    Let cardinality_symbols be SetTheory.get_cardinality_symbols()
    
    UnitTest.assert_true(Collections.size(cardinality_symbols) >= 6, "Should have at least 6 cardinality symbols")
    UnitTest.assert_true(Collections.has_key(cardinality_symbols, "|A|"), "Should contain cardinality notation")
    UnitTest.assert_true(Collections.has_key(cardinality_symbols, "ℵ₀"), "Should contain aleph null")
    UnitTest.assert_true(Collections.has_key(cardinality_symbols, "∞"), "Should contain infinity")

Process called "test_cardinality_notation":
    Let cardinality be SetTheory.cardinality_notation()
    Let expected be create_cardinality_test()
    
    UnitTest.assert_equals(cardinality.notation, "|A|", "Notation should be |A|")
    UnitTest.assert_equals(cardinality.name, "cardinality", "Name should be cardinality")
    UnitTest.assert_equals(cardinality.meaning, "size_of_set", "Should represent size of set")

Process called "test_aleph_null_symbol":
    Let aleph_null be SetTheory.aleph_null_symbol()
    
    UnitTest.assert_equals(aleph_null.symbol, "ℵ₀", "Aleph null symbol should be ℵ₀")
    UnitTest.assert_equals(aleph_null.name, "aleph_null", "Name should be aleph_null")
    UnitTest.assert_equals(aleph_null.cardinality_type, "countably_infinite", "Should be countably infinite")

Process called "test_aleph_one_symbol":
    Let aleph_one be SetTheory.aleph_one_symbol()
    
    UnitTest.assert_equals(aleph_one.symbol, "ℵ₁", "Aleph one symbol should be ℵ₁")
    UnitTest.assert_equals(aleph_one.name, "aleph_one", "Name should be aleph_one")
    UnitTest.assert_equals(aleph_one.cardinality_type, "uncountably_infinite", "Should be uncountably infinite")

Process called "test_beth_zero_symbol":
    Let beth_zero be SetTheory.beth_zero_symbol()
    
    UnitTest.assert_equals(beth_zero.symbol, "ℶ₀", "Beth zero symbol should be ℶ₀")
    UnitTest.assert_equals(beth_zero.name, "beth_zero", "Name should be beth_zero")
    UnitTest.assert_equals(beth_zero.cardinality_type, "continuum", "Should be continuum cardinality")

Process called "test_power_set_symbol":
    Let power_set be SetTheory.power_set_symbol()
    
    UnitTest.assert_equals(power_set.symbol, "℘", "Power set symbol should be ℘")
    UnitTest.assert_equals(power_set.name, "power_set", "Name should be power_set")
    UnitTest.assert_equals(power_set.unicode, "U+2118", "Unicode should be correct")

Note: Functions and Relations Tests

Process called "test_get_function_symbols":
    Let function_symbols be SetTheory.get_function_symbols()
    
    UnitTest.assert_true(Collections.size(function_symbols) >= 6, "Should have at least 6 function symbols")
    UnitTest.assert_true(Collections.has_key(function_symbols, "→"), "Should contain function arrow")
    UnitTest.assert_true(Collections.has_key(function_symbols, "↦"), "Should contain maps to")
    UnitTest.assert_true(Collections.has_key(function_symbols, "⇸"), "Should contain partial function")

Process called "test_function_arrow_symbol":
    Let function_arrow be SetTheory.function_arrow_symbol()
    
    UnitTest.assert_equals(function_arrow.symbol, "→", "Function arrow symbol should be →")
    UnitTest.assert_equals(function_arrow.name, "function_arrow", "Name should be function_arrow")
    UnitTest.assert_equals(function_arrow.usage, "function_type", "Should be used for function types")

Process called "test_maps_to_symbol":
    Let maps_to be SetTheory.maps_to_symbol()
    
    UnitTest.assert_equals(maps_to.symbol, "↦", "Maps to symbol should be ↦")
    UnitTest.assert_equals(maps_to.name, "maps_to", "Name should be maps_to")
    UnitTest.assert_equals(maps_to.unicode, "U+21A6", "Unicode should be correct")
    UnitTest.assert_equals(maps_to.usage, "element_mapping", "Should be used for element mapping")

Process called "test_partial_function_symbol":
    Let partial_func be SetTheory.partial_function_symbol()
    
    UnitTest.assert_equals(partial_func.symbol, "⇸", "Partial function symbol should be ⇸")
    UnitTest.assert_equals(partial_func.name, "partial_function", "Name should be partial_function")
    UnitTest.assert_equals(partial_func.unicode, "U+21F8", "Unicode should be correct")

Process called "test_bijection_symbol":
    Let bijection be SetTheory.bijection_symbol()
    
    UnitTest.assert_equals(bijection.symbol, "↔", "Bijection symbol should be ↔")
    UnitTest.assert_equals(bijection.name, "bijection", "Name should be bijection")
    UnitTest.assert_equals(bijection.function_type, "one_to_one_correspondence", "Should be one-to-one correspondence")

Process called "test_composition_symbol":
    Let composition be SetTheory.composition_symbol()
    
    UnitTest.assert_equals(composition.symbol, "∘", "Composition symbol should be ∘")
    UnitTest.assert_equals(composition.name, "composition", "Name should be composition")
    UnitTest.assert_equals(composition.unicode, "U+2218", "Unicode should be correct")
    UnitTest.assert_false(composition.commutative, "Function composition should not be commutative")

Note: Order Theory Tests

Process called "test_get_order_symbols":
    Let order_symbols be SetTheory.get_order_symbols()
    
    UnitTest.assert_true(Collections.size(order_symbols) >= 8, "Should have at least 8 order symbols")
    UnitTest.assert_true(Collections.has_key(order_symbols, "≤"), "Should contain less than or equal")
    UnitTest.assert_true(Collections.has_key(order_symbols, "≥"), "Should contain greater than or equal")
    UnitTest.assert_true(Collections.has_key(order_symbols, "≺"), "Should contain precedes")

Process called "test_less_than_or_equal_symbol":
    Let leq be SetTheory.less_than_or_equal_symbol()
    
    UnitTest.assert_equals(leq.symbol, "≤", "Less than or equal symbol should be ≤")
    UnitTest.assert_equals(leq.name, "less_than_or_equal", "Name should be less_than_or_equal")
    UnitTest.assert_equals(leq.unicode, "U+2264", "Unicode should be correct")
    UnitTest.assert_equals(leq.order_type, "partial_order", "Should be partial order")

Process called "test_greater_than_or_equal_symbol":
    Let geq be SetTheory.greater_than_or_equal_symbol()
    
    UnitTest.assert_equals(geq.symbol, "≥", "Greater than or equal symbol should be ≥")
    UnitTest.assert_equals(geq.name, "greater_than_or_equal", "Name should be greater_than_or_equal")
    UnitTest.assert_equals(geq.unicode, "U+2265", "Unicode should be correct")

Process called "test_precedes_symbol":
    Let precedes be SetTheory.precedes_symbol()
    
    UnitTest.assert_equals(precedes.symbol, "≺", "Precedes symbol should be ≺")
    UnitTest.assert_equals(precedes.name, "precedes", "Name should be precedes")
    UnitTest.assert_equals(precedes.unicode, "U+227A", "Unicode should be correct")
    UnitTest.assert_equals(precedes.order_type, "strict_order", "Should be strict order")

Process called "test_succeeds_symbol":
    Let succeeds be SetTheory.succeeds_symbol()
    
    UnitTest.assert_equals(succeeds.symbol, "≻", "Succeeds symbol should be ≻")
    UnitTest.assert_equals(succeeds.name, "succeeds", "Name should be succeeds")
    UnitTest.assert_equals(succeeds.unicode, "U+227B", "Unicode should be correct")

Process called "test_square_image_of_symbol":
    Let square_image be SetTheory.square_image_of_symbol()
    
    UnitTest.assert_equals(square_image.symbol, "⊑", "Square image of symbol should be ⊑")
    UnitTest.assert_equals(square_image.name, "square_image_of", "Name should be square_image_of")
    UnitTest.assert_equals(square_image.unicode, "U+2291", "Unicode should be correct")

Process called "test_square_original_of_symbol":
    Let square_original be SetTheory.square_original_of_symbol()
    
    UnitTest.assert_equals(square_original.symbol, "⊒", "Square original of symbol should be ⊒")
    UnitTest.assert_equals(square_original.name, "square_original_of", "Name should be square_original_of")
    UnitTest.assert_equals(square_original.unicode, "U+2292", "Unicode should be correct")

Note: Special Sets Tests

Process called "test_get_special_sets":
    Let special_sets be SetTheory.get_special_sets()
    
    UnitTest.assert_true(Collections.size(special_sets) >= 8, "Should have at least 8 special sets")
    UnitTest.assert_true(Collections.has_key(special_sets, "∅"), "Should contain empty set")
    UnitTest.assert_true(Collections.has_key(special_sets, "ℕ"), "Should contain natural numbers")
    UnitTest.assert_true(Collections.has_key(special_sets, "ℤ"), "Should contain integers")
    UnitTest.assert_true(Collections.has_key(special_sets, "ℝ"), "Should contain real numbers")

Process called "test_empty_set_symbol":
    Let empty_set be SetTheory.empty_set_symbol()
    
    UnitTest.assert_equals(empty_set.symbol, "∅", "Empty set symbol should be ∅")
    UnitTest.assert_equals(empty_set.name, "empty_set", "Name should be empty_set")
    UnitTest.assert_equals(empty_set.unicode, "U+2205", "Unicode should be correct")
    UnitTest.assert_equals(empty_set.cardinality, 0, "Empty set should have cardinality 0")

Process called "test_natural_numbers_symbol":
    Let naturals be SetTheory.natural_numbers_symbol()
    
    UnitTest.assert_equals(naturals.symbol, "ℕ", "Natural numbers symbol should be ℕ")
    UnitTest.assert_equals(naturals.name, "natural_numbers", "Name should be natural_numbers")
    UnitTest.assert_equals(naturals.unicode, "U+2115", "Unicode should be correct")
    UnitTest.assert_equals(naturals.cardinality_type, "countably_infinite", "Should be countably infinite")

Process called "test_integers_symbol":
    Let integers be SetTheory.integers_symbol()
    
    UnitTest.assert_equals(integers.symbol, "ℤ", "Integers symbol should be ℤ")
    UnitTest.assert_equals(integers.name, "integers", "Name should be integers")
    UnitTest.assert_equals(integers.unicode, "U+2124", "Unicode should be correct")

Process called "test_rational_numbers_symbol":
    Let rationals be SetTheory.rational_numbers_symbol()
    
    UnitTest.assert_equals(rationals.symbol, "ℚ", "Rational numbers symbol should be ℚ")
    UnitTest.assert_equals(rationals.name, "rational_numbers", "Name should be rational_numbers")
    UnitTest.assert_equals(rationals.unicode, "U+211A", "Unicode should be correct")

Process called "test_real_numbers_symbol":
    Let reals be SetTheory.real_numbers_symbol()
    
    UnitTest.assert_equals(reals.symbol, "ℝ", "Real numbers symbol should be ℝ")
    UnitTest.assert_equals(reals.name, "real_numbers", "Name should be real_numbers")
    UnitTest.assert_equals(reals.unicode, "U+211D", "Unicode should be correct")

Process called "test_complex_numbers_symbol":
    Let complex be SetTheory.complex_numbers_symbol()
    
    UnitTest.assert_equals(complex.symbol, "ℂ", "Complex numbers symbol should be ℂ")
    UnitTest.assert_equals(complex.name, "complex_numbers", "Name should be complex_numbers")
    UnitTest.assert_equals(complex.unicode, "U+2102", "Unicode should be correct")

Note: Category Theory Tests

Process called "test_get_category_theory_symbols":
    Let category_symbols be SetTheory.get_category_theory_symbols()
    
    UnitTest.assert_true(Collections.size(category_symbols) >= 6, "Should have at least 6 category theory symbols")
    UnitTest.assert_true(Collections.has_key(category_symbols, "⇄"), "Should contain adjunction")
    UnitTest.assert_true(Collections.has_key(category_symbols, "⊣"), "Should contain left adjoint")

Process called "test_adjunction_symbol":
    Let adjunction be SetTheory.adjunction_symbol()
    
    UnitTest.assert_equals(adjunction.symbol, "⇄", "Adjunction symbol should be ⇄")
    UnitTest.assert_equals(adjunction.name, "adjunction", "Name should be adjunction")
    UnitTest.assert_equals(adjunction.unicode, "U+21C4", "Unicode should be correct")
    UnitTest.assert_equals(adjunction.category_concept, "adjoint_functors", "Should represent adjoint functors")

Process called "test_left_adjoint_symbol":
    Let left_adj be SetTheory.left_adjoint_symbol()
    
    UnitTest.assert_equals(left_adj.symbol, "⊣", "Left adjoint symbol should be ⊣")
    UnitTest.assert_equals(left_adj.name, "left_adjoint", "Name should be left_adjoint")
    UnitTest.assert_equals(left_adj.unicode, "U+22A3", "Unicode should be correct")

Process called "test_right_adjoint_symbol":
    Let right_adj be SetTheory.right_adjoint_symbol()
    
    UnitTest.assert_equals(right_adj.symbol, "⊢", "Right adjoint symbol should be ⊢")
    UnitTest.assert_equals(right_adj.name, "right_adjoint", "Name should be right_adjoint")
    UnitTest.assert_equals(right_adj.unicode, "U+22A2", "Unicode should be correct")

Process called "test_natural_transformation_symbol":
    Let nat_trans be SetTheory.natural_transformation_symbol()
    
    UnitTest.assert_equals(nat_trans.symbol, "⟹", "Natural transformation symbol should be ⟹")
    UnitTest.assert_equals(nat_trans.name, "natural_transformation", "Name should be natural_transformation")
    UnitTest.assert_equals(nat_trans.category_concept, "natural_transformation", "Should represent natural transformation")

Process called "test_functor_composition_symbol":
    Let functor_comp be SetTheory.functor_composition_symbol()
    
    UnitTest.assert_equals(functor_comp.symbol, "∘", "Functor composition should use ∘")
    UnitTest.assert_equals(functor_comp.name, "functor_composition", "Name should be functor_composition")
    UnitTest.assert_false(functor_comp.commutative, "Functor composition should not be commutative")

Note: Set Notation Validation Tests

Process called "test_validate_set_notation":
    Let valid_notation be "{x ∈ ℕ | x > 0}"
    Let result be SetTheory.validate_set_notation(valid_notation)
    
    UnitTest.assert_true(result.is_valid, "Valid set notation should pass validation")
    UnitTest.assert_equals(Collections.size(result.errors), 0, "Should have no validation errors")

Process called "test_parse_set_builder_notation":
    Let set_builder be "{x ∈ ℝ | x² < 4}"
    Let parsed be SetTheory.parse_set_builder_notation(set_builder)
    
    UnitTest.assert_true(parsed.parsing_successful, "Set builder notation should parse successfully")
    UnitTest.assert_equals(parsed.variable, "x", "Should identify variable")
    UnitTest.assert_equals(parsed.domain, "ℝ", "Should identify domain")
    UnitTest.assert_equals(parsed.condition, "x² < 4", "Should identify condition")

Process called "test_validate_set_operations":
    Let operation_expr be "A ∪ (B ∩ C)"
    Let validation be SetTheory.validate_set_operations(operation_expr)
    
    UnitTest.assert_true(validation.operations_valid, "Valid set operations should pass validation")
    UnitTest.assert_true(Collections.has_key(validation, "precedence_correct"), "Should check operator precedence")

Process called "test_check_set_equality":
    Let set1 be "{1, 2, 3}"
    Let set2 be "{3, 2, 1}"
    Let equality_check be SetTheory.check_set_equality(set1, set2)
    
    UnitTest.assert_true(equality_check.sets_equal, "Sets with same elements should be equal")
    UnitTest.assert_true(equality_check.order_independent, "Set equality should be order independent")

Note: Set Theory Utility Tests

Process called "test_convert_to_roster_notation":
    Let set_builder be "{x ∈ ℕ | x ≤ 5}"
    Let roster be SetTheory.convert_to_roster_notation(set_builder)
    
    UnitTest.assert_equals(roster.roster_form, "{1, 2, 3, 4, 5}", "Should convert to roster notation")
    UnitTest.assert_true(roster.conversion_successful, "Conversion should succeed")

Process called "test_convert_to_set_builder":
    Let roster_set be "{2, 4, 6, 8, 10}"
    Let set_builder be SetTheory.convert_to_set_builder(roster_set)
    
    UnitTest.assert_true(set_builder.conversion_successful, "Conversion should succeed")
    UnitTest.assert_true(Collections.has_key(set_builder, "builder_form"), "Should have set builder form")

Process called "test_calculate_set_operations":
    Let set_a be Collections.create_set([1, 2, 3])
    Let set_b be Collections.create_set([3, 4, 5])
    Let operations = SetTheory.calculate_set_operations(set_a, set_b)
    
    UnitTest.assert_equals(Collections.size(operations.union), 5, "Union should have 5 elements")
    UnitTest.assert_equals(Collections.size(operations.intersection), 1, "Intersection should have 1 element")
    UnitTest.assert_equals(Collections.size(operations.difference), 2, "Difference should have 2 elements")

Process called "test_determine_set_relationships":
    Let set_a be Collections.create_set([1, 2])
    Let set_b be Collections.create_set([1, 2, 3, 4])
    Let relationships be SetTheory.determine_set_relationships(set_a, set_b)
    
    UnitTest.assert_true(relationships.a_subset_of_b, "A should be subset of B")
    UnitTest.assert_false(relationships.sets_disjoint, "Sets should not be disjoint")
    UnitTest.assert_false(relationships.sets_equal, "Sets should not be equal")

Note: Test suite coordination

Process called "run_all_set_theory_tests":
    UnitTest.start_test_suite("Math Symbols Set Theory Module Tests")
    
    Note: Set membership tests
    UnitTest.run_test("Get Membership Symbols", test_get_membership_symbols)
    UnitTest.run_test("Element Of Symbol", test_element_of_symbol)
    UnitTest.run_test("Not Element Of Symbol", test_not_element_of_symbol)
    UnitTest.run_test("Contains Symbol", test_contains_symbol)
    UnitTest.run_test("Does Not Contain Symbol", test_does_not_contain_symbol)
    
    Note: Set relations tests
    UnitTest.run_test("Get Set Relation Symbols", test_get_set_relation_symbols)
    UnitTest.run_test("Subset Symbol", test_subset_symbol)
    UnitTest.run_test("Superset Symbol", test_superset_symbol)
    UnitTest.run_test("Subset Or Equal Symbol", test_subset_or_equal_symbol)
    UnitTest.run_test("Superset Or Equal Symbol", test_superset_or_equal_symbol)
    UnitTest.run_test("Proper Subset Symbol", test_proper_subset_symbol)
    UnitTest.run_test("Proper Superset Symbol", test_proper_superset_symbol)
    
    Note: Set operations tests
    UnitTest.run_test("Get Set Operation Symbols", test_get_set_operation_symbols)
    UnitTest.run_test("Union Symbol", test_union_symbol)
    UnitTest.run_test("Intersection Symbol", test_intersection_symbol)
    UnitTest.run_test("Set Difference Symbol", test_set_difference_symbol)
    UnitTest.run_test("Symmetric Difference Symbol", test_symmetric_difference_symbol)
    UnitTest.run_test("Cartesian Product Symbol", test_cartesian_product_symbol)
    UnitTest.run_test("Complement Symbol", test_complement_symbol)
    
    Note: Cardinality tests
    UnitTest.run_test("Get Cardinality Symbols", test_get_cardinality_symbols)
    UnitTest.run_test("Cardinality Notation", test_cardinality_notation)
    UnitTest.run_test("Aleph Null Symbol", test_aleph_null_symbol)
    UnitTest.run_test("Aleph One Symbol", test_aleph_one_symbol)
    UnitTest.run_test("Beth Zero Symbol", test_beth_zero_symbol)
    UnitTest.run_test("Power Set Symbol", test_power_set_symbol)
    
    Note: Functions and relations tests
    UnitTest.run_test("Get Function Symbols", test_get_function_symbols)
    UnitTest.run_test("Function Arrow Symbol", test_function_arrow_symbol)
    UnitTest.run_test("Maps To Symbol", test_maps_to_symbol)
    UnitTest.run_test("Partial Function Symbol", test_partial_function_symbol)
    UnitTest.run_test("Bijection Symbol", test_bijection_symbol)
    UnitTest.run_test("Composition Symbol", test_composition_symbol)
    
    Note: Order theory tests
    UnitTest.run_test("Get Order Symbols", test_get_order_symbols)
    UnitTest.run_test("Less Than Or Equal Symbol", test_less_than_or_equal_symbol)
    UnitTest.run_test("Greater Than Or Equal Symbol", test_greater_than_or_equal_symbol)
    UnitTest.run_test("Precedes Symbol", test_precedes_symbol)
    UnitTest.run_test("Succeeds Symbol", test_succeeds_symbol)
    UnitTest.run_test("Square Image Of Symbol", test_square_image_of_symbol)
    UnitTest.run_test("Square Original Of Symbol", test_square_original_of_symbol)
    
    Note: Special sets tests
    UnitTest.run_test("Get Special Sets", test_get_special_sets)
    UnitTest.run_test("Empty Set Symbol", test_empty_set_symbol)
    UnitTest.run_test("Natural Numbers Symbol", test_natural_numbers_symbol)
    UnitTest.run_test("Integers Symbol", test_integers_symbol)
    UnitTest.run_test("Rational Numbers Symbol", test_rational_numbers_symbol)
    UnitTest.run_test("Real Numbers Symbol", test_real_numbers_symbol)
    UnitTest.run_test("Complex Numbers Symbol", test_complex_numbers_symbol)
    
    Note: Category theory tests
    UnitTest.run_test("Get Category Theory Symbols", test_get_category_theory_symbols)
    UnitTest.run_test("Adjunction Symbol", test_adjunction_symbol)
    UnitTest.run_test("Left Adjoint Symbol", test_left_adjoint_symbol)
    UnitTest.run_test("Right Adjoint Symbol", test_right_adjoint_symbol)
    UnitTest.run_test("Natural Transformation Symbol", test_natural_transformation_symbol)
    UnitTest.run_test("Functor Composition Symbol", test_functor_composition_symbol)
    
    Note: Validation tests
    UnitTest.run_test("Validate Set Notation", test_validate_set_notation)
    UnitTest.run_test("Parse Set Builder Notation", test_parse_set_builder_notation)
    UnitTest.run_test("Validate Set Operations", test_validate_set_operations)
    UnitTest.run_test("Check Set Equality", test_check_set_equality)
    
    Note: Utility tests
    UnitTest.run_test("Convert to Roster Notation", test_convert_to_roster_notation)
    UnitTest.run_test("Convert to Set Builder", test_convert_to_set_builder)
    UnitTest.run_test("Calculate Set Operations", test_calculate_set_operations)
    UnitTest.run_test("Determine Set Relationships", test_determine_set_relationships)
    
    Let results be UnitTest.end_test_suite()
    Return results

Process called "get_set_theory_test_count" returns Integer:
    Return 54

Process called "get_set_theory_test_categories" returns List[String]:
    Return Collections.create_list([
        "Set Membership",
        "Set Relations",
        "Set Operations",
        "Cardinality",
        "Functions and Relations",
        "Order Theory",
        "Special Sets",
        "Category Theory",
        "Validation",
        "Utilities"
    ])