Note: Comprehensive unit tests for math/geometry/computational.runa module
Note: Tests cover convex hulls, Delaunay triangulation, Voronoi diagrams, spatial data structures, and mesh operations

Import "../../../../../../src/stdlib/math/geometry/computational" as ComputationalGeometry
Import "../../../../../../src/stdlib/testing/framework" as Test

Note: Helper functions for creating test data structures

Process called "create_test_points_2d":
    Note: Creates a set of 2D points for testing algorithms
    Let points be List[Point2D]()
    points.append(ComputationalGeometry.create_point_2d(0.0, 0.0))
    points.append(ComputationalGeometry.create_point_2d(4.0, 0.0))
    points.append(ComputationalGeometry.create_point_2d(4.0, 3.0))
    points.append(ComputationalGeometry.create_point_2d(0.0, 3.0))
    points.append(ComputationalGeometry.create_point_2d(2.0, 1.5))  Note: Interior point
    Return points

Process called "create_test_points_3d":
    Note: Creates a set of 3D points for testing 3D algorithms
    Let points be List[Point3D]()
    points.append(ComputationalGeometry.create_point_3d(0.0, 0.0, 0.0))
    points.append(ComputationalGeometry.create_point_3d(1.0, 0.0, 0.0))
    points.append(ComputationalGeometry.create_point_3d(0.0, 1.0, 0.0))
    points.append(ComputationalGeometry.create_point_3d(0.0, 0.0, 1.0))
    points.append(ComputationalGeometry.create_point_3d(0.5, 0.5, 0.5))  Note: Interior point
    Return points

Process called "create_collinear_points":
    Note: Creates collinear points for edge case testing
    Let points be List[Point2D]()
    points.append(ComputationalGeometry.create_point_2d(0.0, 0.0))
    points.append(ComputationalGeometry.create_point_2d(1.0, 1.0))
    points.append(ComputationalGeometry.create_point_2d(2.0, 2.0))
    points.append(ComputationalGeometry.create_point_2d(3.0, 3.0))
    Return points

Process called "create_test_line_segments":
    Note: Creates line segments for intersection testing
    Let segments be List[LineSegment2D]()
    
    Let seg1_start be ComputationalGeometry.create_point_2d(0.0, 0.0)
    Let seg1_end be ComputationalGeometry.create_point_2d(4.0, 4.0)
    segments.append(ComputationalGeometry.create_line_segment_2d(seg1_start, seg1_end))
    
    Let seg2_start be ComputationalGeometry.create_point_2d(0.0, 4.0)
    Let seg2_end be ComputationalGeometry.create_point_2d(4.0, 0.0)
    segments.append(ComputationalGeometry.create_line_segment_2d(seg2_start, seg2_end))
    
    Return segments

Process called "create_test_polygon":
    Note: Creates a simple convex polygon for testing
    Let vertices be List[Point2D]()
    vertices.append(ComputationalGeometry.create_point_2d(0.0, 0.0))
    vertices.append(ComputationalGeometry.create_point_2d(6.0, 0.0))
    vertices.append(ComputationalGeometry.create_point_2d(6.0, 4.0))
    vertices.append(ComputationalGeometry.create_point_2d(3.0, 6.0))
    vertices.append(ComputationalGeometry.create_point_2d(0.0, 4.0))
    Return ComputationalGeometry.create_polygon_2d(vertices)

Process called "assert_convex_hull_valid" that takes hull as ConvexHull, min_vertices as Integer:
    Note: Assert convex hull properties
    Test.assert_not_null(hull, "Convex hull should be created")
    Test.assert_greater_equal(hull.vertices.length, min_vertices, "Hull should have minimum vertices")
    Test.assert_greater(hull.area, 0.0, "Hull area should be positive")
    Test.assert_greater(hull.perimeter, 0.0, "Hull perimeter should be positive")

Process called "assert_triangulation_valid" that takes triangulation as DelaunayTriangulation:
    Note: Assert Delaunay triangulation properties
    Test.assert_not_null(triangulation, "Triangulation should be created")
    Test.assert_not_empty(triangulation.triangles, "Should have triangles")
    Test.assert_not_empty(triangulation.vertices, "Should have vertices")
    
    Note: Check Delaunay property for each triangle
    For triangle in triangulation.triangles:
        Let is_delaunay be ComputationalGeometry.validate_delaunay_property(triangulation, triangle)
        Test.assert_true(is_delaunay, "Triangle should satisfy Delaunay property")

Process called "assert_voronoi_valid" that takes voronoi as VoronoiDiagram, expected_sites as Integer:
    Note: Assert Voronoi diagram properties
    Test.assert_not_null(voronoi, "Voronoi diagram should be created")
    Test.assert_equal(voronoi.sites.length, expected_sites, "Should have expected number of sites")
    Test.assert_not_empty(voronoi.cells, "Should have Voronoi cells")

Process called "assert_float_close" that takes actual as Float, expected as Float, tolerance as Float, message as String:
    Note: Assert floating point values are close within tolerance
    Let difference be actual - expected
    If difference < 0.0:
        difference = -difference
    Test.assert_true(difference < tolerance, message + " (actual: " + actual.toString() + ", expected: " + expected.toString() + ")")

Note: Convex Hull Tests

Process called "test_graham_scan_convex_hull":
    Note: Test Graham scan convex hull algorithm
    Let points be create_test_points_2d()
    Let hull be ComputationalGeometry.graham_scan(points)
    
    assert_convex_hull_valid(hull, 3)
    Test.assert_equal(hull.vertices.length, 4, "Square should have 4 hull vertices")

Process called "test_quickhull_2d":
    Note: Test QuickHull algorithm
    Let points be create_test_points_2d()
    Let hull be ComputationalGeometry.quickhull_2d(points)
    
    assert_convex_hull_valid(hull, 3)

Process called "test_jarvis_march":
    Note: Test Jarvis march (gift wrapping) algorithm
    Let points be create_test_points_2d()
    Let hull be ComputationalGeometry.jarvis_march(points)
    
    assert_convex_hull_valid(hull, 3)
    Test.assert_equal(hull.vertices.length, 4, "Should find 4 vertices for rectangle")

Process called "test_convex_hull_collinear_points":
    Note: Test convex hull with collinear points
    Let collinear_points be create_collinear_points()
    Let hull be ComputationalGeometry.compute_convex_hull_2d(collinear_points)
    
    Test.assert_not_null(hull, "Should handle collinear points")
    Test.assert_equal(hull.vertices.length, 2, "Collinear points should give 2 hull vertices")

Process called "test_convex_hull_3d":
    Note: Test 3D convex hull computation
    Let points be create_test_points_3d()
    Let hull_3d be ComputationalGeometry.compute_convex_hull_3d(points)
    
    Test.assert_not_null(hull_3d, "3D hull should be created")
    Test.assert_not_empty(hull_3d.vertices, "3D hull should have vertices")
    Test.assert_not_empty(hull_3d.faces, "3D hull should have faces")
    Test.assert_greater(hull_3d.volume, 0.0, "3D hull volume should be positive")

Process called "test_convex_hull_area_calculation":
    Note: Test convex hull area calculation
    Let square_points be List[Point2D]()
    square_points.append(ComputationalGeometry.create_point_2d(0.0, 0.0))
    square_points.append(ComputationalGeometry.create_point_2d(2.0, 0.0))
    square_points.append(ComputationalGeometry.create_point_2d(2.0, 2.0))
    square_points.append(ComputationalGeometry.create_point_2d(0.0, 2.0))
    
    Let hull be ComputationalGeometry.compute_convex_hull_2d(square_points)
    
    assert_float_close(hull.area, 4.0, 1e-10, "Square hull should have area 4")
    assert_float_close(hull.perimeter, 8.0, 1e-10, "Square hull should have perimeter 8")

Note: Delaunay Triangulation Tests

Process called "test_bowyer_watson_triangulation":
    Note: Test Bowyer-Watson Delaunay triangulation
    Let points be create_test_points_2d()
    Let triangulation be ComputationalGeometry.bowyer_watson_triangulation(points)
    
    assert_triangulation_valid(triangulation)

Process called "test_delaunay_property_validation":
    Note: Test validation of Delaunay property
    Let points be create_test_points_2d()
    Let triangulation be ComputationalGeometry.compute_delaunay_triangulation(points)
    
    For triangle in triangulation.triangles:
        Let is_valid be ComputationalGeometry.validate_delaunay_property(triangulation, triangle)
        Test.assert_true(is_valid, "Each triangle should satisfy Delaunay property (empty circumcircle)")

Process called "test_edge_flipping":
    Note: Test edge flipping for Delaunay maintenance
    Let points be create_test_points_2d()
    Let triangulation be ComputationalGeometry.compute_delaunay_triangulation(points)
    
    Note: Test edge flip operation
    If triangulation.edges.length > 0:
        Let edge = triangulation.edges[0]
        Let flipped_successfully be ComputationalGeometry.flip_edge(triangulation, edge)
        
        If flipped_successfully:
            Note: After flip, triangulation should still be valid
            For triangle in triangulation.triangles:
                Let is_valid be ComputationalGeometry.validate_delaunay_property(triangulation, triangle)
                Test.assert_true(is_valid, "Triangulation should remain valid after edge flip")

Process called "test_triangulation_circumcenters":
    Note: Test circumcenter calculations
    Let points be create_test_points_2d()
    Let triangulation be ComputationalGeometry.compute_delaunay_triangulation(points)
    
    Test.assert_not_empty(triangulation.circumcenters, "Should compute circumcenters")
    Test.assert_equal(triangulation.circumcenters.length, triangulation.triangles.length, "Should have one circumcenter per triangle")

Process called "test_point_location_triangulation":
    Note: Test point location in triangulation
    Let points be create_test_points_2d()
    Let triangulation be ComputationalGeometry.compute_delaunay_triangulation(points)
    Let query_point be ComputationalGeometry.create_point_2d(2.0, 1.5)
    
    Let location_result be ComputationalGeometry.point_location_triangulation(triangulation, query_point)
    
    Test.assert_not_null(location_result, "Should locate point in triangulation")

Note: Voronoi Diagram Tests

Process called "test_fortune_sweep_line":
    Note: Test Fortune's sweep line algorithm for Voronoi diagrams
    Let sites be create_test_points_2d()
    Let voronoi be ComputationalGeometry.fortune_sweep_line(sites)
    
    assert_voronoi_valid(voronoi, sites.length)

Process called "test_voronoi_delaunay_duality":
    Note: Test duality between Voronoi and Delaunay
    Let sites be create_test_points_2d()
    Let triangulation be ComputationalGeometry.compute_delaunay_triangulation(sites)
    Let voronoi be ComputationalGeometry.compute_voronoi_diagram(sites)
    
    Test.assert_equal(voronoi.sites.length, triangulation.vertices.length, "Voronoi sites should match Delaunay vertices")

Process called "test_voronoi_cell_area":
    Note: Test Voronoi cell area calculation
    Let sites be create_test_points_2d()
    Let voronoi be ComputationalGeometry.compute_voronoi_diagram(sites)
    
    For i in 0 to voronoi.cells.length - 1:
        Let cell_area be ComputationalGeometry.voronoi_cell_area(voronoi, i)
        Test.assert_greater(cell_area, 0.0, "Voronoi cell area should be positive")

Process called "test_nearest_site_query":
    Note: Test nearest site queries in Voronoi diagram
    Let sites be create_test_points_2d()
    Let voronoi be ComputationalGeometry.compute_voronoi_diagram(sites)
    Let query_point be ComputationalGeometry.create_point_2d(1.0, 1.0)
    
    Let nearest_site be ComputationalGeometry.nearest_site_query(voronoi, query_point)
    
    Test.assert_greater_equal(nearest_site, 0, "Should find valid nearest site index")
    Test.assert_less(nearest_site, sites.length, "Site index should be within bounds")

Note: Spatial Data Structure Tests

Process called "test_build_kd_tree":
    Note: Test KD-tree construction
    Let points be create_test_points_2d()
    Let kd_tree be ComputationalGeometry.build_kd_tree(points)
    
    Test.assert_not_null(kd_tree, "KD-tree should be constructed")
    Test.assert_not_null(kd_tree.root, "KD-tree should have root node")

Process called "test_kd_tree_range_query":
    Note: Test KD-tree range queries
    Let points be create_test_points_2d()
    Let kd_tree be ComputationalGeometry.build_kd_tree(points)
    
    Let min_point be ComputationalGeometry.create_point_2d(1.0, 1.0)
    Let max_point be ComputationalGeometry.create_point_2d(3.0, 3.0)
    Let query be ComputationalGeometry.create_range_query(min_point, max_point)
    
    Let results be ComputationalGeometry.kd_tree_range_query(kd_tree, query)
    
    Test.assert_not_null(results, "Range query should return results")
    
    For result_point in results:
        Test.assert_greater_equal(result_point.x, 1.0, "Result point x should be >= 1.0")
        Test.assert_less_equal(result_point.x, 3.0, "Result point x should be <= 3.0")
        Test.assert_greater_equal(result_point.y, 1.0, "Result point y should be >= 1.0")
        Test.assert_less_equal(result_point.y, 3.0, "Result point y should be <= 3.0")

Process called "test_kd_tree_nearest_neighbor":
    Note: Test KD-tree k-nearest neighbor queries
    Let points be create_test_points_2d()
    Let kd_tree be ComputationalGeometry.build_kd_tree(points)
    Let query_point be ComputationalGeometry.create_point_2d(2.1, 1.4)
    
    Let nn_query be ComputationalGeometry.create_nearest_neighbor_query(query_point, 2)
    Let nearest_neighbors be ComputationalGeometry.kd_tree_nearest_neighbor(kd_tree, nn_query)
    
    Test.assert_not_null(nearest_neighbors, "Should find nearest neighbors")
    Test.assert_less_equal(nearest_neighbors.length, 2, "Should find at most 2 neighbors")

Process called "test_build_quad_tree":
    Note: Test QuadTree construction
    Let points be create_test_points_2d()
    Let boundary be ComputationalGeometry.create_rectangle(0.0, 0.0, 5.0, 5.0)
    Let quad_tree be ComputationalGeometry.build_quad_tree(points, boundary)
    
    Test.assert_not_null(quad_tree, "QuadTree should be constructed")
    Test.assert_not_null(quad_tree.root, "QuadTree should have root node")

Process called "test_quad_tree_insert_query":
    Note: Test QuadTree insertion and querying
    Let boundary be ComputationalGeometry.create_rectangle(0.0, 0.0, 10.0, 10.0)
    Let quad_tree be ComputationalGeometry.create_quad_tree(boundary)
    
    Note: Insert points one by one
    Let points be create_test_points_2d()
    For point in points:
        ComputationalGeometry.quad_tree_insert(quad_tree, point)
    
    Note: Query for points in a region
    Let query_region be ComputationalGeometry.create_rectangle(1.0, 1.0, 3.0, 3.0)
    Let query_results be ComputationalGeometry.quad_tree_query(quad_tree, query_region)
    
    Test.assert_not_null(query_results, "QuadTree query should return results")

Note: Line Segment Intersection Tests

Process called "test_bentley_ottmann_sweep":
    Note: Test Bentley-Ottmann sweep line algorithm for line intersections
    Let segments be create_test_line_segments()
    Let intersections be ComputationalGeometry.bentley_ottmann_sweep(segments)
    
    Test.assert_not_null(intersections, "Should find intersections")
    Test.assert_equal(intersections.length, 1, "Should find one intersection between crossing segments")

Process called "test_segment_intersection_test":
    Note: Test individual segment intersection
    Let segments be create_test_line_segments()
    Let seg1 be segments[0]
    Let seg2 be segments[1]
    
    Let intersection_result be ComputationalGeometry.segment_intersection_test(seg1, seg2)
    
    Test.assert_not_null(intersection_result, "Should detect intersection")
    Test.assert_true(intersection_result.intersects, "Segments should intersect")
    Test.assert_not_null(intersection_result.intersection_point, "Should have intersection point")
    
    Note: Intersection of diagonals of square should be at (2,2)
    assert_float_close(intersection_result.intersection_point.x, 2.0, 1e-10, "Intersection x should be 2")
    assert_float_close(intersection_result.intersection_point.y, 2.0, 1e-10, "Intersection y should be 2")

Process called "test_line_segment_intersection_all_pairs":
    Note: Test finding all pairwise line segment intersections
    Let segments be create_test_line_segments()
    Let all_intersections be ComputationalGeometry.line_segment_intersection(segments)
    
    Test.assert_not_null(all_intersections, "Should compute all intersections")

Note: Polygon Operations Tests

Process called "test_polygon_triangulation":
    Note: Test polygon triangulation
    Let polygon be create_test_polygon()
    Let triangulation be ComputationalGeometry.polygon_triangulation(polygon)
    
    Test.assert_not_null(triangulation, "Should triangulate polygon")
    Test.assert_not_empty(triangulation.triangles, "Should produce triangles")
    
    Note: Check that triangulation uses correct number of triangles (n-2 for n vertices)
    Let expected_triangles be polygon.vertices.length - 2
    Test.assert_equal(triangulation.triangles.length, expected_triangles, "Should have n-2 triangles")

Process called "test_ear_clipping_triangulation":
    Note: Test ear clipping algorithm
    Let polygon be create_test_polygon()
    Let triangulation be ComputationalGeometry.ear_clipping_triangulation(polygon)
    
    Test.assert_not_null(triangulation, "Ear clipping should produce triangulation")

Process called "test_polygon_clipping":
    Note: Test polygon clipping operations
    Let subject_polygon be create_test_polygon()
    Let clip_vertices be List[Point2D]()
    clip_vertices.append(ComputationalGeometry.create_point_2d(1.0, 1.0))
    clip_vertices.append(ComputationalGeometry.create_point_2d(5.0, 1.0))
    clip_vertices.append(ComputationalGeometry.create_point_2d(5.0, 5.0))
    clip_vertices.append(ComputationalGeometry.create_point_2d(1.0, 5.0))
    Let clip_polygon be ComputationalGeometry.create_polygon_2d(clip_vertices)
    
    Let clipped_result be ComputationalGeometry.polygon_clipping(subject_polygon, clip_polygon)
    
    Test.assert_not_null(clipped_result, "Should perform polygon clipping")

Process called "test_sutherland_hodgman_clip":
    Note: Test Sutherland-Hodgman clipping algorithm
    Let polygon be create_test_polygon()
    Let clip_vertices be List[Point2D]()
    clip_vertices.append(ComputationalGeometry.create_point_2d(2.0, 2.0))
    clip_vertices.append(ComputationalGeometry.create_point_2d(4.0, 2.0))
    clip_vertices.append(ComputationalGeometry.create_point_2d(4.0, 4.0))
    clip_vertices.append(ComputationalGeometry.create_point_2d(2.0, 4.0))
    Let clip_polygon be ComputationalGeometry.create_polygon_2d(clip_vertices)
    
    Let clipped_polygon be ComputationalGeometry.sutherland_hodgman_clip(polygon, clip_polygon)
    
    Test.assert_not_null(clipped_polygon, "Sutherland-Hodgman should produce clipped polygon")

Process called "test_polygon_boolean_operations":
    Note: Test polygon union and intersection
    Let poly1 be create_test_polygon()
    Let poly2_vertices be List[Point2D]()
    poly2_vertices.append(ComputationalGeometry.create_point_2d(3.0, 1.0))
    poly2_vertices.append(ComputationalGeometry.create_point_2d(7.0, 1.0))
    poly2_vertices.append(ComputationalGeometry.create_point_2d(7.0, 3.0))
    poly2_vertices.append(ComputationalGeometry.create_point_2d(3.0, 3.0))
    Let poly2 be ComputationalGeometry.create_polygon_2d(poly2_vertices)
    
    Let union_result be ComputationalGeometry.polygon_union(poly1, poly2)
    Let intersection_result be ComputationalGeometry.polygon_intersection(poly1, poly2)
    
    Test.assert_not_null(union_result, "Should compute polygon union")
    Test.assert_not_null(intersection_result, "Should compute polygon intersection")

Note: Mesh Generation Tests

Process called "test_generate_triangular_mesh":
    Note: Test triangular mesh generation
    Let boundary_polygon be create_test_polygon()
    Let mesh be ComputationalGeometry.generate_triangular_mesh(boundary_polygon)
    
    Test.assert_not_null(mesh, "Should generate triangular mesh")
    Test.assert_not_empty(mesh.vertices, "Mesh should have vertices")
    Test.assert_not_empty(mesh.triangles, "Mesh should have triangles")

Process called "test_mesh_quality_analysis":
    Note: Test mesh quality analysis
    Let boundary_polygon be create_test_polygon()
    Let mesh be ComputationalGeometry.generate_triangular_mesh(boundary_polygon)
    
    Let quality_metrics be ComputationalGeometry.mesh_quality_analysis(mesh)
    
    Test.assert_not_null(quality_metrics, "Should analyze mesh quality")
    Test.assert_contains_key(quality_metrics, "min_angle", "Should include minimum angle")
    Test.assert_contains_key(quality_metrics, "max_angle", "Should include maximum angle")
    Test.assert_contains_key(quality_metrics, "aspect_ratio", "Should include aspect ratio")

Process called "test_mesh_refinement":
    Note: Test Delaunay mesh refinement
    Let boundary_polygon be create_test_polygon()
    Let mesh be ComputationalGeometry.generate_triangular_mesh(boundary_polygon)
    
    Let refined_mesh be ComputationalGeometry.refine_mesh(mesh)
    
    Test.assert_not_null(refined_mesh, "Should refine mesh")
    Test.assert_greater_equal(refined_mesh.triangles.length, mesh.triangles.length, "Refined mesh should have at least as many triangles")

Process called "test_mesh_smoothing":
    Note: Test Laplacian mesh smoothing
    Let boundary_polygon be create_test_polygon()
    Let mesh be ComputationalGeometry.generate_triangular_mesh(boundary_polygon)
    
    Let smoothed_mesh be ComputationalGeometry.smooth_mesh(mesh)
    
    Test.assert_not_null(smoothed_mesh, "Should smooth mesh")
    Test.assert_equal(smoothed_mesh.vertices.length, mesh.vertices.length, "Smoothed mesh should have same number of vertices")

Note: Point Location Tests

Process called "test_point_in_polygon_winding":
    Note: Test point-in-polygon using winding number
    Let polygon be create_test_polygon()
    Let point_inside be ComputationalGeometry.create_point_2d(3.0, 2.0)
    Let point_outside be ComputationalGeometry.create_point_2d(10.0, 10.0)
    
    Let is_inside be ComputationalGeometry.point_in_polygon_winding(point_inside, polygon)
    Let is_outside be ComputationalGeometry.point_in_polygon_winding(point_outside, polygon)
    
    Test.assert_true(is_inside, "Interior point should be inside polygon")
    Test.assert_false(is_outside, "Exterior point should be outside polygon")

Process called "test_ray_casting_test":
    Note: Test ray casting algorithm for point containment
    Let polygon be create_test_polygon()
    Let point_inside be ComputationalGeometry.create_point_2d(3.0, 2.0)
    Let point_outside be ComputationalGeometry.create_point_2d(8.0, 8.0)
    
    Let is_inside be ComputationalGeometry.ray_casting_test(point_inside, polygon)
    Let is_outside be ComputationalGeometry.ray_casting_test(point_outside, polygon)
    
    Test.assert_true(is_inside, "Ray casting should detect interior point")
    Test.assert_false(is_outside, "Ray casting should detect exterior point")

Note: Advanced Geometric Operations Tests

Process called "test_barycentric_coordinates":
    Note: Test barycentric coordinate calculation
    Let triangle_vertices be List[Point2D]()
    triangle_vertices.append(ComputationalGeometry.create_point_2d(0.0, 0.0))
    triangle_vertices.append(ComputationalGeometry.create_point_2d(4.0, 0.0))
    triangle_vertices.append(ComputationalGeometry.create_point_2d(0.0, 3.0))
    Let triangle be ComputationalGeometry.create_triangle_2d(triangle_vertices[0], triangle_vertices[1], triangle_vertices[2])
    
    Let point be ComputationalGeometry.create_point_2d(1.0, 1.0)
    Let barycentric be ComputationalGeometry.compute_barycentric_coordinates(point, triangle)
    
    Test.assert_not_null(barycentric, "Should compute barycentric coordinates")
    Test.assert_equal(barycentric.length, 3, "Should have 3 barycentric coordinates")
    
    Note: Check that coordinates sum to 1
    Let coordinate_sum be barycentric[0] + barycentric[1] + barycentric[2]
    assert_float_close(coordinate_sum, 1.0, 1e-10, "Barycentric coordinates should sum to 1")

Process called "test_circumcenter_calculation":
    Note: Test circumcenter and circumcircle calculations
    Let triangle_vertices be List[Point2D]()
    triangle_vertices.append(ComputationalGeometry.create_point_2d(0.0, 0.0))
    triangle_vertices.append(ComputationalGeometry.create_point_2d(4.0, 0.0))
    triangle_vertices.append(ComputationalGeometry.create_point_2d(0.0, 3.0))
    Let triangle be ComputationalGeometry.create_triangle_2d(triangle_vertices[0], triangle_vertices[1], triangle_vertices[2])
    
    Let circumcenter be ComputationalGeometry.compute_circumcenter(triangle)
    Let circumradius be ComputationalGeometry.compute_circumradius(triangle)
    
    Test.assert_not_null(circumcenter, "Should compute circumcenter")
    Test.assert_greater(circumradius, 0.0, "Circumradius should be positive")
    
    Note: Verify that all vertices are equidistant from circumcenter
    For vertex in triangle_vertices:
        Let distance be ComputationalGeometry.calculate_distance_2d(vertex, circumcenter)
        assert_float_close(distance, circumradius, 1e-10, "All vertices should be equidistant from circumcenter")

Note: Main test execution process

Process called "run_computational_geometry_tests":
    Note: Execute all computational geometry tests
    Test.describe("Computational Geometry Module Tests")
    
    Note: Convex Hull Tests
    Test.describe("Convex Hull Algorithms")
    test_graham_scan_convex_hull()
    test_quickhull_2d()
    test_jarvis_march()
    test_convex_hull_collinear_points()
    test_convex_hull_3d()
    test_convex_hull_area_calculation()
    
    Note: Delaunay Triangulation Tests
    Test.describe("Delaunay Triangulation")
    test_bowyer_watson_triangulation()
    test_delaunay_property_validation()
    test_edge_flipping()
    test_triangulation_circumcenters()
    test_point_location_triangulation()
    
    Note: Voronoi Diagram Tests
    Test.describe("Voronoi Diagrams")
    test_fortune_sweep_line()
    test_voronoi_delaunay_duality()
    test_voronoi_cell_area()
    test_nearest_site_query()
    
    Note: Spatial Data Structure Tests
    Test.describe("Spatial Data Structures")
    test_build_kd_tree()
    test_kd_tree_range_query()
    test_kd_tree_nearest_neighbor()
    test_build_quad_tree()
    test_quad_tree_insert_query()
    
    Note: Line Segment Intersection Tests
    Test.describe("Line Segment Intersections")
    test_bentley_ottmann_sweep()
    test_segment_intersection_test()
    test_line_segment_intersection_all_pairs()
    
    Note: Polygon Operation Tests
    Test.describe("Polygon Operations")
    test_polygon_triangulation()
    test_ear_clipping_triangulation()
    test_polygon_clipping()
    test_sutherland_hodgman_clip()
    test_polygon_boolean_operations()
    
    Note: Mesh Generation Tests
    Test.describe("Mesh Generation")
    test_generate_triangular_mesh()
    test_mesh_quality_analysis()
    test_mesh_refinement()
    test_mesh_smoothing()
    
    Note: Point Location Tests
    Test.describe("Point Location")
    test_point_in_polygon_winding()
    test_ray_casting_test()
    
    Note: Advanced Operations Tests
    Test.describe("Advanced Geometric Operations")
    test_barycentric_coordinates()
    test_circumcenter_calculation()
    
    Test.print_summary()

Note: Execute tests when this file is run
run_computational_geometry_tests()