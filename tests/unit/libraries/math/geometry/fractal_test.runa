Note:
runa/tests/unit/libraries/math/geometry/fractal_test.runa
Comprehensive Unit Tests for Fractal Geometry Module

This test suite provides complete coverage of the fractal geometry operations
including fractal dimension calculations, L-systems, iterated function systems,
Mandelbrot and Julia sets, chaos game, strange attractors, and classic fractals.

Mathematical validation covers:
- Box-counting and Hausdorff dimension calculations
- L-system evolution and turtle graphics interpretation
- IFS attractor generation and convergence analysis
- Complex fractal set membership testing
- Newton fractal root finding and iteration
- Chaos game and strange attractor simulation
- Classic fractal generation (Sierpinski, Koch, Dragon, Cantor)
:End Note

Import "dev/testing/framework/core" as Test
Import "math/geometry/fractal" as FractalGeometry
Import "math/geometry/euclidean" as Euclidean
Import "math/core/operations" as MathOps

Note: =====================================================================
Note: TEST HELPER FUNCTIONS
Note: =====================================================================

Process called "assert_float_close" that takes actual as Float, expected as Float, tolerance as Float, message as String:
    Let difference be actual - expected
    If difference < 0.0:
        Set difference to -difference
    Test.assert_true(difference < tolerance, message + " - Expected: " + String(expected) + ", Actual: " + String(actual))

Process called "assert_dimension_valid" that takes dimension as Float, min_val as Float, max_val as Float, message as String:
    Test.assert_true(dimension >= min_val, message + " - dimension too low: " + String(dimension))
    Test.assert_true(dimension <= max_val, message + " - dimension too high: " + String(dimension))

Process called "create_test_fractal" that returns FractalGeometry.Fractal:
    Let fractal be FractalGeometry.Fractal
    Set fractal.fractal_type to "test_fractal"
    Set fractal.dimension_estimate to 1.5
    Set fractal.generating_functions to List[String]
    fractal.generating_functions.append("f1")
    fractal.generating_functions.append("f2")
    
    Let corner be Euclidean.create_point_2d(0.0, 0.0)
    Let rectangle be Euclidean.Rectangle
    Set rectangle.corner to corner
    Set rectangle.width to 2.0
    Set rectangle.height to 2.0
    Set fractal.bounding_box to rectangle
    
    Set fractal.iteration_count to 1000
    Set fractal.convergence_tolerance to 0.001
    
    Return fractal

Process called "create_test_l_system" that returns FractalGeometry.LSystem:
    Let alphabet be Set[String]
    alphabet.add("A")
    alphabet.add("B")
    alphabet.add("+")
    alphabet.add("-")
    
    Let rules be Dictionary[String, String]
    rules["A"] = "A+B++"
    rules["B"] = "-A--A"
    
    Return FractalGeometry.create_l_system("A", rules, alphabet)

Process called "create_test_triangle_vertices" that returns List[FractalGeometry.Point2D]:
    Let vertices be List[FractalGeometry.Point2D]
    vertices.append(Euclidean.create_point_2d(0.0, 0.0))
    vertices.append(Euclidean.create_point_2d(2.0, 0.0))
    vertices.append(Euclidean.create_point_2d(1.0, 1.732))
    Return vertices

Process called "create_test_affine_transformations" that returns List[FractalGeometry.AffineTransformation]:
    Let transformations be List[FractalGeometry.AffineTransformation]
    
    Note: Create first transformation (scaling by 0.5)
    Let t1 be FractalGeometry.AffineTransformation
    Set t1.matrix to FractalGeometry.create_2x2_matrix(0.5, 0.0, 0.0, 0.5)
    Set t1.translation to Euclidean.create_vector_2d(0.0, 0.0)
    Set t1.scaling_factor to 0.5
    Set t1.rotation_angle to 0.0
    Set t1.probability_weight to 0.5
    transformations.append(t1)
    
    Note: Create second transformation (scaling by 0.5 with translation)
    Let t2 be FractalGeometry.AffineTransformation
    Set t2.matrix to FractalGeometry.create_2x2_matrix(0.5, 0.0, 0.0, 0.5)
    Set t2.translation to Euclidean.create_vector_2d(0.5, 0.5)
    Set t2.scaling_factor to 0.5
    Set t2.rotation_angle to 0.0
    Set t2.probability_weight to 0.5
    transformations.append(t2)
    
    Return transformations

Note: =====================================================================
Note: FRACTAL DIMENSION CALCULATION TESTS
Note: =====================================================================

Process called "test_calculate_box_counting_dimension":
    Let fractal be create_test_fractal()
    Let scale_range be List[Float]
    scale_range.append(1.0)
    scale_range.append(0.5)
    scale_range.append(0.25)
    scale_range.append(0.125)
    
    Let dimension be FractalGeometry.calculate_box_counting_dimension(fractal, scale_range)
    assert_dimension_valid(dimension, 0.0, 3.0, "Box-counting dimension should be between 0 and 3")
    Test.assert_not_equal(dimension, 0.0, "Box-counting dimension should not be zero")

Process called "test_calculate_hausdorff_dimension":
    Let fractal be create_test_fractal()
    Let precision be 0.1
    
    Let dimension be FractalGeometry.calculate_hausdorff_dimension(fractal, precision)
    assert_dimension_valid(dimension, 0.0, 3.0, "Hausdorff dimension should be between 0 and 3")
    Test.assert_not_equal(dimension, 0.0, "Hausdorff dimension should not be zero")

Process called "test_calculate_correlation_dimension":
    Let points be List[FractalGeometry.Point2D]
    points.append(Euclidean.create_point_2d(0.0, 0.0))
    points.append(Euclidean.create_point_2d(1.0, 1.0))
    points.append(Euclidean.create_point_2d(2.0, 0.5))
    points.append(Euclidean.create_point_2d(0.5, 2.0))
    
    Let radius_range be List[Float]
    radius_range.append(2.0)
    radius_range.append(1.0)
    radius_range.append(0.5)
    
    Let dimension be FractalGeometry.calculate_correlation_dimension(points, radius_range)
    assert_dimension_valid(dimension, -5.0, 5.0, "Correlation dimension should be reasonable")

Process called "test_estimate_fractal_dimension_multi":
    Let fractal be create_test_fractal()
    Set fractal.fractal_type to "point_cloud"
    
    Let dimension_result be FractalGeometry.estimate_fractal_dimension_multi(fractal)
    Test.assert_equal(dimension_result.calculation_method, "multi_method", "Should use multi-method calculation")
    assert_dimension_valid(dimension_result.box_counting_dimension, 0.0, 3.0, "Box-counting dimension valid")
    Test.assert_true(dimension_result.hausdorff_dimension != None, "Should calculate Hausdorff dimension")
    Test.assert_true(dimension_result.correlation_dimension != None, "Should calculate correlation dimension for point cloud")

Note: =====================================================================
Note: L-SYSTEM TESTS
Note: =====================================================================

Process called "test_create_l_system":
    Let alphabet be Set[String]
    alphabet.add("F")
    alphabet.add("+")
    alphabet.add("-")
    
    Let rules be Dictionary[String, String]
    rules["F"] = "F+F-F-F+F"
    
    Let l_system be FractalGeometry.create_l_system("F", rules, alphabet)
    Test.assert_equal(l_system.axiom, "F", "Axiom should be set correctly")
    Test.assert_equal(l_system.generation_count, 0, "Generation count should start at 0")
    Test.assert_true(l_system.production_rules.contains_key("F"), "Should contain production rule for F")

Process called "test_evolve_l_system":
    Let l_system be create_test_l_system()
    Let generations be 2
    
    Let final_string be FractalGeometry.evolve_l_system(l_system, generations)
    Test.assert_not_equal(final_string, l_system.axiom, "Final string should differ from axiom")
    Test.assert_true(final_string.length > l_system.axiom.length, "String should grow with generations")

Process called "test_interpret_l_system":
    Let alphabet be Set[String]
    alphabet.add("F")
    alphabet.add("+")
    alphabet.add("-")
    
    Let rules be Dictionary[String, String]
    rules["F"] = "F+F"
    
    Let l_system be FractalGeometry.create_l_system("F+F", rules, alphabet)
    
    Let turtle be FractalGeometry.TurtleGraphics
    Set turtle.position to Euclidean.create_point_2d(0.0, 0.0)
    Set turtle.heading_angle to 0.0
    Set turtle.pen_down to true
    Set turtle.step_size to 1.0
    Set turtle.angle_increment to 1.571
    Set turtle.drawing_stack to List[Tuple[FractalGeometry.Point2D, Float]]
    
    Let drawing_points be FractalGeometry.interpret_l_system(l_system, "F+F-F", turtle)
    Test.assert_true(drawing_points.length > 0, "Should generate drawing points")
    Test.assert_true(drawing_points.length % 2 == 0, "Should have even number of points (start/end pairs)")

Process called "test_create_plant_model":
    Let l_system be create_test_l_system()
    
    Let growth_params be Dictionary[String, Float]
    growth_params["step_size"] = 1.0
    growth_params["angle_increment"] = 0.785
    growth_params["thickness_ratio"] = 0.8
    growth_params["length_ratio"] = 0.9
    growth_params["angle_variation"] = 0.1
    growth_params["leaf_size"] = 0.5
    growth_params["leaf_density"] = 0.3
    
    Let plant be FractalGeometry.create_plant_model(l_system, growth_params)
    Test.assert_not_null(plant.l_system, "Plant should have L-system")
    Test.assert_not_null(plant.turtle_graphics, "Plant should have turtle graphics")
    assert_float_close(plant.turtle_graphics.step_size, 1.0, 1e-10, "Step size should be set")
    Test.assert_true(plant.growth_stages.length > 0, "Should have growth stages")

Note: =====================================================================
Note: ITERATED FUNCTION SYSTEM TESTS
Note: =====================================================================

Process called "test_create_ifs":
    Let transformations be create_test_affine_transformations()
    Let probabilities be List[Float]
    probabilities.append(0.5)
    probabilities.append(0.5)
    
    Let ifs be FractalGeometry.create_ifs(transformations, probabilities)
    Test.assert_equal(ifs.transformations.length, 2, "Should have 2 transformations")
    Test.assert_equal(ifs.probabilities.length, 2, "Should have 2 probabilities")
    Test.assert_equal(ifs.iteration_limit, 10000, "Should set default iteration limit")

Process called "test_create_ifs_invalid_probabilities":
    Let transformations be create_test_affine_transformations()
    Let probabilities be List[Float]
    probabilities.append(0.3)
    probabilities.append(0.3)
    
    Try:
        Let ifs be FractalGeometry.create_ifs(transformations, probabilities)
        Test.fail("Should throw error for probabilities not summing to 1.0")
    Catch error:
        Test.assert_true(true, "Should throw error for invalid probabilities")

Process called "test_generate_ifs_attractor":
    Let transformations be create_test_affine_transformations()
    Let probabilities be List[Float]
    probabilities.append(0.5)
    probabilities.append(0.5)
    
    Let ifs be FractalGeometry.create_ifs(transformations, probabilities)
    Let iterations be 1000
    Let initial_point be Euclidean.create_point_2d(0.5, 0.5)
    
    Let attractor_points be FractalGeometry.generate_ifs_attractor(ifs, iterations, initial_point)
    Test.assert_true(attractor_points.length > 0, "Should generate attractor points")
    Test.assert_true(attractor_points.length <= iterations, "Should not exceed iteration count")

Process called "test_analyze_ifs_convergence":
    Let transformations be create_test_affine_transformations()
    Let probabilities be List[Float]
    probabilities.append(0.5)
    probabilities.append(0.5)
    
    Let ifs be FractalGeometry.create_ifs(transformations, probabilities)
    Let analysis be FractalGeometry.analyze_ifs_convergence(ifs)
    
    Test.assert_true(analysis.contains_key("max_contraction_ratio"), "Should calculate max contraction ratio")
    Test.assert_true(analysis.contains_key("min_contraction_ratio"), "Should calculate min contraction ratio")
    Test.assert_true(analysis.contains_key("convergence_guaranteed"), "Should determine convergence guarantee")
    
    Let max_ratio be analysis.get("max_contraction_ratio")
    Test.assert_true(max_ratio >= 0.0, "Max contraction ratio should be non-negative")

Process called "test_create_barnsley_fern":
    Let scale_factor be 1.0
    Let ifs be FractalGeometry.create_barnsley_fern(scale_factor)
    
    Test.assert_equal(ifs.transformations.length, 4, "Barnsley fern should have 4 transformations")
    Test.assert_equal(ifs.probabilities.length, 4, "Barnsley fern should have 4 probabilities")
    
    Let prob_sum be 0.0
    Let i be 0
    While i < ifs.probabilities.length:
        Set prob_sum to prob_sum + ifs.probabilities.get(i)
        Set i to i + 1
    assert_float_close(prob_sum, 1.0, 1e-10, "Probabilities should sum to 1.0")

Note: =====================================================================
Note: MANDELBROT SET TESTS
Note: =====================================================================

Process called "test_create_mandelbrot_set":
    Let bounds be (-2.0, -2.0, 2.0, 2.0)
    Let max_iterations be 100
    
    Let mandelbrot be FractalGeometry.create_mandelbrot_set(bounds, max_iterations)
    Test.assert_equal(mandelbrot.complex_plane_bounds, bounds, "Bounds should be set correctly")
    Test.assert_equal(mandelbrot.max_iterations, max_iterations, "Max iterations should be set")
    assert_float_close(mandelbrot.escape_radius, 2.0, 1e-10, "Escape radius should be 2.0")
    Test.assert_equal(mandelbrot.center_point, (0.0, 0.0), "Center should be origin")

Process called "test_mandelbrot_membership_in_set":
    Let c be (0.0, 0.0)
    Let max_iterations be 1000
    
    Let iterations be FractalGeometry.test_mandelbrot_membership(c, max_iterations)
    Test.assert_equal(iterations, max_iterations, "Origin should be in Mandelbrot set")

Process called "test_mandelbrot_membership_outside_set":
    Let c be (2.0, 2.0)
    Let max_iterations be 100
    
    Let iterations be FractalGeometry.test_mandelbrot_membership(c, max_iterations)
    Test.assert_true(iterations < max_iterations, "Point (2,2) should escape quickly")

Process called "test_generate_mandelbrot_image":
    Let bounds be (-1.0, -1.0, 1.0, 1.0)
    Let mandelbrot be FractalGeometry.create_mandelbrot_set(bounds, 50)
    Let resolution be (10, 10)
    
    Let image_matrix be FractalGeometry.generate_mandelbrot_image(mandelbrot, resolution)
    Test.assert_equal(image_matrix.rows, 10, "Image should have correct height")
    Test.assert_equal(image_matrix.columns, 10, "Image should have correct width")

Process called "test_zoom_mandelbrot":
    Let bounds be (-2.0, -2.0, 2.0, 2.0)
    Let mandelbrot be FractalGeometry.create_mandelbrot_set(bounds, 100)
    Let center be (0.0, 0.0)
    Let zoom_factor be 2.0
    
    Let zoomed be FractalGeometry.zoom_mandelbrot(mandelbrot, center, zoom_factor)
    Test.assert_equal(zoomed.center_point, center, "Center should be set correctly")
    assert_float_close(zoomed.zoom_level, 2.0, 1e-10, "Zoom level should be doubled")
    
    Let new_bounds be zoomed.complex_plane_bounds
    Let new_width be new_bounds.2 - new_bounds.0
    Let original_width be bounds.2 - bounds.0
    assert_float_close(new_width, original_width / zoom_factor, 1e-10, "Width should be reduced by zoom factor")

Note: =====================================================================
Note: JULIA SET TESTS
Note: =====================================================================

Process called "test_create_julia_set":
    Let parameter_c be (-0.7, 0.27015)
    Let bounds be (-2.0, -2.0, 2.0, 2.0)
    
    Let julia be FractalGeometry.create_julia_set(parameter_c, bounds)
    Test.assert_equal(julia.parameter_c, parameter_c, "Parameter c should be set")
    Test.assert_equal(julia.complex_plane_bounds, bounds, "Bounds should be set")
    Test.assert_equal(julia.max_iterations, 100, "Should set default iterations")
    assert_float_close(julia.escape_radius, 2.0, 1e-10, "Escape radius should be 2.0")

Process called "test_julia_membership":
    Let z be (0.0, 0.0)
    Let c be (-0.5, 0.0)
    Let max_iterations be 100
    
    Let iterations be FractalGeometry.test_julia_membership(z, c, max_iterations)
    Test.assert_true(iterations >= 0, "Iterations should be non-negative")
    Test.assert_true(iterations <= max_iterations, "Iterations should not exceed maximum")

Process called "test_analyze_julia_connectivity":
    Note: Test with parameter in main bulb (connected)
    Let c_connected be (0.0, 0.0)
    Let bounds be (-2.0, -2.0, 2.0, 2.0)
    Let julia_connected be FractalGeometry.create_julia_set(c_connected, bounds)
    
    Let connectivity be FractalGeometry.analyze_julia_connectivity(julia_connected)
    Test.assert_true(connectivity, "Julia set for c=0 should be connected")
    
    Note: Test with parameter outside main set (disconnected)
    Let c_disconnected be (1.0, 0.0)
    Let julia_disconnected be FractalGeometry.create_julia_set(c_disconnected, bounds)
    
    Let connectivity_2 be FractalGeometry.analyze_julia_connectivity(julia_disconnected)
    Test.assert_false(connectivity_2, "Julia set for c=1 should be disconnected")

Process called "test_generate_julia_family":
    Let parameter_range be List[Tuple[Float, Float]]
    parameter_range.append((-0.5, 0.0))
    parameter_range.append((0.0, 0.5))
    parameter_range.append((0.3, 0.5))
    
    Let julia_family be FractalGeometry.generate_julia_family(parameter_range)
    Test.assert_equal(julia_family.length, 3, "Should generate 3 Julia sets")
    
    Let i be 0
    While i < julia_family.length:
        Let julia_set be julia_family.get(i)
        Test.assert_not_null(julia_set, "Julia set should not be null")
        Test.assert_true(julia_set.connectivity == true or julia_set.connectivity == false, "Connectivity should be determined")
        Set i to i + 1

Note: =====================================================================
Note: NEWTON FRACTAL TESTS
Note: =====================================================================

Process called "test_create_newton_fractal":
    Note: Create polynomial z^3 - 1 = 0
    Let polynomial be List[Tuple[Float, Float]]
    polynomial.append((-1.0, 0.0))  Note: Constant term
    polynomial.append((0.0, 0.0))   Note: Linear term
    polynomial.append((0.0, 0.0))   Note: Quadratic term
    polynomial.append((1.0, 0.0))   Note: Cubic term
    
    Let newton_fractal be FractalGeometry.create_newton_fractal(polynomial)
    Test.assert_equal(newton_fractal.polynomial_coefficients.length, 4, "Should have 4 coefficients")
    Test.assert_equal(newton_fractal.derivative_coefficients.length, 3, "Derivative should have 3 coefficients")
    assert_float_close(newton_fractal.tolerance, 0.0001, 1e-10, "Should set default tolerance")

Process called "test_newton_iteration":
    Note: Test Newton iteration for z^2 - 1 = 0
    Let polynomial be List[Tuple[Float, Float]]
    polynomial.append((-1.0, 0.0))  Note: -1
    polynomial.append((0.0, 0.0))   Note: 0*z
    polynomial.append((1.0, 0.0))   Note: z^2
    
    Let derivative be List[Tuple[Float, Float]]
    derivative.append((0.0, 0.0))   Note: 0
    derivative.append((2.0, 0.0))   Note: 2*z
    
    Let z_start be (2.0, 0.0)
    Let z_new be FractalGeometry.newton_iteration(z_start, polynomial, derivative)
    
    Note: Should move closer to root at (1,0)
    Test.assert_true(z_new.0 < 2.0, "Real part should decrease toward root")
    Test.assert_true(z_new.0 > 0.0, "Should stay in correct quadrant")

Process called "test_find_polynomial_roots":
    Note: Find roots of z^2 - 1 = 0 (should be ±1)
    Let polynomial be List[Tuple[Float, Float]]
    polynomial.append((-1.0, 0.0))  Note: -1
    polynomial.append((0.0, 0.0))   Note: 0*z
    polynomial.append((1.0, 0.0))   Note: z^2
    
    Let tolerance be 0.001
    Let roots be FractalGeometry.find_polynomial_roots(polynomial, tolerance)
    
    Test.assert_true(roots.length >= 1, "Should find at least one root")
    Test.assert_true(roots.length <= 2, "Should find at most two roots")
    
    Note: Check that found roots are approximately ±1
    Let i be 0
    While i < roots.length:
        Let root be roots.get(i)
        Let magnitude be ((root.0 * root.0 + root.1 * root.1) ^ 0.5)
        assert_float_close(magnitude, 1.0, 0.1, "Root magnitude should be approximately 1")
        Set i to i + 1

Note: =====================================================================
Note: CHAOS GAME TESTS
Note: =====================================================================

Process called "test_create_chaos_game":
    Let vertices be create_test_triangle_vertices()
    Let rules be List[String]
    rules.append("midpoint")
    rules.append("random_vertex")
    
    Let game be FractalGeometry.create_chaos_game(vertices, rules)
    Test.assert_equal(game.vertices.length, 3, "Should have 3 vertices")
    Test.assert_equal(game.transformation_rules.length, 2, "Should have 2 rules")
    Test.assert_equal(game.iteration_count, 0, "Iteration count should start at 0")
    Test.assert_not_null(game.current_point, "Should have current point")

Process called "test_play_chaos_game":
    Let vertices be create_test_triangle_vertices()
    Let rules be List[String]
    rules.append("midpoint")
    
    Let game be FractalGeometry.create_chaos_game(vertices, rules)
    Let iterations be 100
    Let initial_point be Euclidean.create_point_2d(1.0, 0.5)
    
    Let result_points be FractalGeometry.play_chaos_game(game, iterations, initial_point)
    Test.assert_equal(result_points.length, iterations, "Should generate exact number of points")
    
    Note: All points should be within the triangle bounds
    Let i be 0
    While i < result_points.length:
        Let point be result_points.get(i)
        Test.assert_true(point.x >= 0.0, "X coordinate should be non-negative")
        Test.assert_true(point.y >= 0.0, "Y coordinate should be non-negative")
        Test.assert_true(point.x <= 2.0, "X coordinate should be within bounds")
        Test.assert_true(point.y <= 2.0, "Y coordinate should be within bounds")
        Set i to i + 1

Process called "test_sierpinski_chaos_game":
    Let vertices be create_test_triangle_vertices()
    Let iterations be 500
    
    Let result_points be FractalGeometry.sierpinski_chaos_game(vertices, iterations)
    Test.assert_equal(result_points.length, iterations, "Should generate exact number of points")
    
    Note: Points should tend to cluster in fractal pattern
    Let avg_x be 0.0
    Let avg_y be 0.0
    Let i be 0
    While i < result_points.length:
        Let point be result_points.get(i)
        Set avg_x to avg_x + point.x
        Set avg_y to avg_y + point.y
        Set i to i + 1
    
    Set avg_x to avg_x / Float(result_points.length)
    Set avg_y to avg_y / Float(result_points.length)
    
    Note: Average should be near triangle centroid
    assert_float_close(avg_x, 1.0, 0.3, "Average X should be near centroid")
    assert_float_close(avg_y, 0.577, 0.3, "Average Y should be near centroid")

Process called "test_sierpinski_invalid_vertices":
    Let vertices be List[FractalGeometry.Point2D]
    vertices.append(Euclidean.create_point_2d(0.0, 0.0))
    vertices.append(Euclidean.create_point_2d(1.0, 0.0))
    
    Try:
        Let result be FractalGeometry.sierpinski_chaos_game(vertices, 100)
        Test.fail("Should throw error for non-triangle vertices")
    Catch error:
        Test.assert_true(true, "Should reject invalid vertex count")

Note: =====================================================================
Note: STRANGE ATTRACTOR TESTS
Note: =====================================================================

Process called "test_create_lorenz_attractor":
    Let sigma be 10.0
    Let rho be 28.0
    Let beta be 2.667
    
    Let attractor be FractalGeometry.create_lorenz_attractor(sigma, rho, beta)
    assert_float_close(attractor.sigma, sigma, 1e-10, "Sigma parameter should be set")
    assert_float_close(attractor.rho, rho, 1e-10, "Rho parameter should be set")
    assert_float_close(attractor.beta, beta, 1e-10, "Beta parameter should be set")
    Test.assert_not_null(attractor.initial_conditions, "Should have initial conditions")
    assert_float_close(attractor.time_step, 0.01, 1e-10, "Should set default time step")

Process called "test_simulate_lorenz_system":
    Let sigma be 10.0
    Let rho be 28.0
    Let beta be 2.667
    Let attractor be FractalGeometry.create_lorenz_attractor(sigma, rho, beta)
    
    Let time_steps be 100
    Let dt be 0.01
    
    Let trajectory be FractalGeometry.simulate_lorenz_system(attractor, time_steps, dt)
    Test.assert_equal(trajectory.length, time_steps, "Should generate correct number of points")
    
    Note: Check that trajectory shows chaotic behavior (bounded but non-periodic)
    Let first_point be trajectory.get(0)
    Let last_point be trajectory.get(trajectory.length - 1)
    
    Let distance be Euclidean.calculate_distance_3d(first_point, last_point)
    Test.assert_true(distance > 0.1, "End point should differ significantly from start")
    
    Note: All points should be bounded (Lorenz attractor is bounded)
    Let i be 0
    While i < trajectory.length:
        Let point be trajectory.get(i)
        Test.assert_true(point.x.abs() < 50.0, "X coordinate should be bounded")
        Test.assert_true(point.y.abs() < 50.0, "Y coordinate should be bounded")
        Test.assert_true(point.z.abs() < 50.0, "Z coordinate should be bounded")
        Set i to i + 1

Process called "test_create_henon_map":
    Let a be 1.4
    Let b be 0.3
    
    Let henon be FractalGeometry.create_henon_map(a, b)
    assert_float_close(henon.parameter_a, a, 1e-10, "Parameter a should be set")
    assert_float_close(henon.parameter_b, b, 1e-10, "Parameter b should be set")
    Test.assert_not_null(henon.initial_point, "Should have initial point")
    Test.assert_equal(henon.orbit_points.length, 0, "Orbit should start empty")

Process called "test_iterate_henon_map":
    Let a be 1.4
    Let b be 0.3
    Let henon be FractalGeometry.create_henon_map(a, b)
    
    Let iterations be 50
    Let initial_point be Euclidean.create_point_2d(0.1, 0.1)
    
    Let orbit be FractalGeometry.iterate_henon_map(henon, iterations, initial_point)
    Test.assert_equal(orbit.length, iterations, "Should generate correct number of points")
    
    Note: Check for chaotic behavior (sensitivity to initial conditions)
    Let second_point be orbit.get(1)
    Let third_point be orbit.get(2)
    
    Test.assert_not_equal(second_point.x, initial_point.x, "Should evolve from initial point")
    Test.assert_not_equal(third_point.x, second_point.x, "Should continue evolving")

Process called "test_calculate_lyapunov_exponents":
    Note: Test Lorenz attractor Lyapunov exponents
    Let attractor be FractalGeometry.StrangeAttractor
    Set attractor.attractor_type to "lorenz"
    Set attractor.parameters to Dictionary[String, Float]
    attractor.parameters["sigma"] = 10.0
    attractor.parameters["rho"] = 28.0
    attractor.parameters["beta"] = 2.667
    
    Let exponents be FractalGeometry.calculate_lyapunov_exponents(attractor)
    Test.assert_equal(exponents.length, 3, "Lorenz should have 3 Lyapunov exponents")
    Test.assert_true(exponents.get(0) > 0.0, "Largest exponent should be positive (chaos)")
    Test.assert_true(exponents.get(2) < 0.0, "Smallest exponent should be negative")

Process called "test_calculate_lyapunov_exponents_henon":
    Note: Test Hénon map Lyapunov exponents
    Let attractor be FractalGeometry.StrangeAttractor
    Set attractor.attractor_type to "henon"
    Set attractor.parameters to Dictionary[String, Float]
    attractor.parameters["a"] = 1.4
    attractor.parameters["b"] = 0.3
    
    Let exponents be FractalGeometry.calculate_lyapunov_exponents(attractor)
    Test.assert_equal(exponents.length, 2, "Hénon should have 2 Lyapunov exponents")
    Test.assert_true(exponents.get(0) > 0.0, "Largest exponent should be positive")
    Test.assert_true(exponents.get(1) < 0.0, "Smallest exponent should be negative")

Note: =====================================================================
Note: CLASSIC FRACTAL TESTS
Note: =====================================================================

Process called "test_generate_sierpinski_triangle":
    Let vertices be create_test_triangle_vertices()
    Let subdivision_level be 3
    
    Let triangle be FractalGeometry.generate_sierpinski_triangle(vertices, subdivision_level)
    Test.assert_equal(triangle.vertices.length, 3, "Should preserve original vertices")
    Test.assert_equal(triangle.subdivision_level, subdivision_level, "Should set subdivision level")
    Test.assert_true(triangle.triangle_points.length > 0, "Should generate triangle points")
    assert_float_close(triangle.area_ratio, 0.421875, 1e-6, "Area ratio should be 0.75^3")

Process called "test_generate_koch_curve":
    Let p1 be Euclidean.create_point_2d(0.0, 0.0)
    Let p2 be Euclidean.create_point_2d(3.0, 0.0)
    Let initial_segment be (p1, p2)
    Let level be 2
    
    Let curve be FractalGeometry.generate_koch_curve(initial_segment, level)
    Test.assert_equal(curve.subdivision_level, level, "Should set subdivision level")
    Test.assert_true(curve.curve_points.length > 0, "Should generate curve points")
    
    Note: Length should be 3 * (4/3)^level = 3 * (16/9) = 5.333...
    assert_float_close(curve.total_length, 5.333, 0.01, "Length should follow Koch curve formula")

Process called "test_generate_dragon_curve":
    Let p1 be Euclidean.create_point_2d(0.0, 0.0)
    Let p2 be Euclidean.create_point_2d(1.0, 0.0)
    Let initial_segment be (p1, p2)
    Let generation be 3
    
    Let curve be FractalGeometry.generate_dragon_curve(initial_segment, generation)
    Test.assert_equal(curve.generation, generation, "Should set generation")
    Test.assert_true(curve.fold_sequence.length > 0, "Should have fold sequence")
    Test.assert_true(curve.curve_points.length > 0, "Should generate curve points")

Process called "test_generate_cantor_set":
    Let initial_interval be (0.0, 1.0)
    Let subdivision_level be 3
    
    Let cantor be FractalGeometry.generate_cantor_set(initial_interval, subdivision_level)
    Test.assert_equal(cantor.subdivision_level, subdivision_level, "Should set subdivision level")
    Test.assert_true(cantor.remaining_intervals.length > 0, "Should have remaining intervals")
    
    Note: At level 3, should have 2^3 = 8 intervals
    Test.assert_equal(cantor.remaining_intervals.length, 8, "Should have 8 intervals at level 3")
    
    Note: Total length should be (2/3)^3 = 8/27 ≈ 0.296
    assert_float_close(cantor.total_length, 0.296, 0.01, "Total length should follow Cantor set formula")

Note: =====================================================================
Note: FRACTAL ANALYSIS TESTS
Note: =====================================================================

Process called "test_analyze_self_similarity":
    Let fractal be create_test_fractal()
    Let scale_factors be List[Float]
    scale_factors.append(1.0)
    scale_factors.append(0.5)
    scale_factors.append(0.25)
    scale_factors.append(0.125)
    
    Let analysis be FractalGeometry.analyze_self_similarity(fractal, scale_factors)
    
    Test.assert_true(analysis.contains_key("average_scaling_dimension"), "Should calculate average dimension")
    Test.assert_true(analysis.contains_key("dimension_variance"), "Should calculate variance")
    Test.assert_true(analysis.contains_key("self_similar"), "Should determine self-similarity")
    Test.assert_true(analysis.contains_key("scale_invariance_score"), "Should calculate invariance score")
    
    Let invariance_score be analysis.get("scale_invariance_score")
    Test.assert_true(invariance_score >= 0.0, "Invariance score should be non-negative")
    Test.assert_true(invariance_score <= 1.0, "Invariance score should be at most 1.0")

Process called "test_measure_fractal_complexity":
    Let fractal be create_test_fractal()
    Let complexity be FractalGeometry.measure_fractal_complexity(fractal)
    
    Test.assert_true(complexity.contains_key("box_counting_dimension"), "Should have box-counting dimension")
    Test.assert_true(complexity.contains_key("hausdorff_dimension"), "Should have Hausdorff dimension")
    Test.assert_true(complexity.contains_key("topological_dimension"), "Should have topological dimension")
    Test.assert_true(complexity.contains_key("fractal_excess"), "Should calculate fractal excess")
    Test.assert_true(complexity.contains_key("lacunarity"), "Should calculate lacunarity")
    Test.assert_true(complexity.contains_key("overall_complexity_score"), "Should have overall score")
    
    Let topological_dim be complexity.get("topological_dimension")
    Test.assert_true(topological_dim >= 1.0, "Topological dimension should be at least 1")
    Test.assert_true(topological_dim <= 3.0, "Topological dimension should be at most 3")

Process called "test_compare_fractal_dimensions":
    Let fractals be List[FractalGeometry.Fractal]
    fractals.append(create_test_fractal())
    
    Let fractal2 be create_test_fractal()
    Set fractal2.dimension_estimate to 2.0
    fractals.append(fractal2)
    
    Let fractal3 be create_test_fractal()
    Set fractal3.dimension_estimate to 1.8
    fractals.append(fractal3)
    
    Let comparison_matrix be FractalGeometry.compare_fractal_dimensions(fractals)
    Test.assert_equal(comparison_matrix.rows, 3, "Matrix should have 3 rows")
    Test.assert_equal(comparison_matrix.columns, 3, "Matrix should have 3 columns")
    
    Note: Diagonal elements should be zero
    Let diagonal_1 be Parse comparison_matrix.entries.get(0).get(0) as Float
    Let diagonal_2 be Parse comparison_matrix.entries.get(1).get(1) as Float
    Let diagonal_3 be Parse comparison_matrix.entries.get(2).get(2) as Float
    assert_float_close(diagonal_1, 0.0, 1e-10, "Diagonal element should be zero")
    assert_float_close(diagonal_2, 0.0, 1e-10, "Diagonal element should be zero")
    assert_float_close(diagonal_3, 0.0, 1e-10, "Diagonal element should be zero")

Process called "test_detect_fractal_patterns":
    Note: Create a simple test image matrix
    Let image_entries be List[List[String]]
    Let y be 0
    While y < 20:
        Let row be List[String]
        Let x be 0
        While x < 20:
            Let value be (x + y) % 256
            row.append(String(value))
            Set x to x + 1
        image_entries.append(row)
        Set y to y + 1
    
    Let image be LinAlg.create_matrix(image_entries, "integer")
    Let detected_patterns be FractalGeometry.detect_fractal_patterns(image)
    
    Test.assert_true(detected_patterns != None, "Should return pattern list")
    Test.assert_true(detected_patterns.length >= 0, "Pattern list should be valid")
    
    Note: Check pattern structure if any patterns found
    Let i be 0
    While i < detected_patterns.length:
        Let pattern be detected_patterns.get(i)
        Test.assert_true(pattern.contains_key("type"), "Pattern should have type")
        Test.assert_true(pattern.contains_key("x"), "Pattern should have x coordinate")
        Test.assert_true(pattern.contains_key("y"), "Pattern should have y coordinate")
        Test.assert_true(pattern.contains_key("confidence"), "Pattern should have confidence")
        Set i to i + 1

Note: =====================================================================
Note: HELPER FUNCTION TESTS
Note: =====================================================================

Process called "test_count_boxes_at_scale":
    Let fractal be create_test_fractal()
    Let scale be 0.5
    
    Let box_count be FractalGeometry.count_boxes_at_scale(fractal, scale)
    Test.assert_true(box_count > 0, "Should count at least one box")
    Test.assert_true(box_count < 1000, "Box count should be reasonable")

Process called "test_calculate_linear_regression_slope":
    Let x_values be List[Float]
    x_values.append(1.0)
    x_values.append(2.0)
    x_values.append(3.0)
    x_values.append(4.0)
    
    Let y_values be List[Float]
    y_values.append(2.0)
    y_values.append(4.0)
    y_values.append(6.0)
    y_values.append(8.0)
    
    Let slope be FractalGeometry.calculate_linear_regression_slope(x_values, y_values)
    assert_float_close(slope, 2.0, 1e-10, "Slope of y=2x should be 2.0")

Process called "test_create_2x2_matrix":
    Let matrix be FractalGeometry.create_2x2_matrix(1.0, 2.0, 3.0, 4.0)
    Test.assert_equal(matrix.rows, 2, "Should be 2x2 matrix")
    Test.assert_equal(matrix.columns, 2, "Should be 2x2 matrix")
    
    Let a11 be Parse matrix.entries.get(0).get(0) as Float
    Let a12 be Parse matrix.entries.get(0).get(1) as Float
    Let a21 be Parse matrix.entries.get(1).get(0) as Float
    Let a22 be Parse matrix.entries.get(1).get(1) as Float
    
    assert_float_close(a11, 1.0, 1e-10, "Element (0,0) should be 1.0")
    assert_float_close(a12, 2.0, 1e-10, "Element (0,1) should be 2.0")
    assert_float_close(a21, 3.0, 1e-10, "Element (1,0) should be 3.0")
    assert_float_close(a22, 4.0, 1e-10, "Element (1,1) should be 4.0")

Process called "test_complex_distance":
    Let z1 be (0.0, 0.0)
    Let z2 be (3.0, 4.0)
    
    Let distance be FractalGeometry.complex_distance(z1, z2)
    assert_float_close(distance, 5.0, 1e-10, "Distance should be 5.0 (3-4-5 triangle)")

Process called "test_apply_affine_transformation_2d":
    Let transformation be FractalGeometry.AffineTransformation
    Set transformation.matrix to FractalGeometry.create_2x2_matrix(2.0, 0.0, 0.0, 2.0)
    Set transformation.translation to Euclidean.create_vector_2d(1.0, 1.0)
    
    Let point be Euclidean.create_point_2d(1.0, 1.0)
    Let transformed_point be FractalGeometry.apply_affine_transformation_2d(transformation, point)
    
    assert_float_close(transformed_point.x, 3.0, 1e-10, "X should be 2*1 + 1 = 3")
    assert_float_close(transformed_point.y, 3.0, 1e-10, "Y should be 2*1 + 1 = 3")

Process called "test_calculate_transformation_contraction_ratio":
    Let transformation be FractalGeometry.AffineTransformation
    Set transformation.matrix to FractalGeometry.create_2x2_matrix(0.5, 0.0, 0.0, 0.5)
    
    Let ratio be FractalGeometry.calculate_transformation_contraction_ratio(transformation)
    assert_float_close(ratio, 0.5, 1e-10, "Contraction ratio should be 0.5")

Process called "test_calculate_list_average":
    Let values be List[Float]
    values.append(1.0)
    values.append(2.0)
    values.append(3.0)
    values.append(4.0)
    values.append(5.0)
    
    Let average be FractalGeometry.calculate_list_average(values)
    assert_float_close(average, 3.0, 1e-10, "Average of 1,2,3,4,5 should be 3.0")

Process called "test_calculate_list_variance":
    Let values be List[Float]
    values.append(1.0)
    values.append(2.0)
    values.append(3.0)
    values.append(4.0)
    values.append(5.0)
    
    Let mean be 3.0
    Let variance be FractalGeometry.calculate_list_variance(values, mean)
    assert_float_close(variance, 2.5, 1e-10, "Variance should be 2.5")

Note: =====================================================================
Note: TEST RUNNER FUNCTIONS
Note: =====================================================================

Process called "run_all_fractal_tests":
    Test.describe("Fractal Geometry Tests")
    
    Note: Fractal dimension tests
    Test.it("should calculate box-counting dimension", test_calculate_box_counting_dimension)
    Test.it("should calculate Hausdorff dimension", test_calculate_hausdorff_dimension)
    Test.it("should calculate correlation dimension", test_calculate_correlation_dimension)
    Test.it("should estimate fractal dimension using multiple methods", test_estimate_fractal_dimension_multi)
    
    Note: L-system tests
    Test.it("should create L-system", test_create_l_system)
    Test.it("should evolve L-system", test_evolve_l_system)
    Test.it("should interpret L-system with turtle graphics", test_interpret_l_system)
    Test.it("should create plant model", test_create_plant_model)
    
    Note: IFS tests
    Test.it("should create IFS", test_create_ifs)
    Test.it("should reject invalid probabilities", test_create_ifs_invalid_probabilities)
    Test.it("should generate IFS attractor", test_generate_ifs_attractor)
    Test.it("should analyze IFS convergence", test_analyze_ifs_convergence)
    Test.it("should create Barnsley fern", test_create_barnsley_fern)
    
    Note: Mandelbrot set tests
    Test.it("should create Mandelbrot set", test_create_mandelbrot_set)
    Test.it("should test Mandelbrot membership (in set)", test_mandelbrot_membership_in_set)
    Test.it("should test Mandelbrot membership (outside set)", test_mandelbrot_membership_outside_set)
    Test.it("should generate Mandelbrot image", test_generate_mandelbrot_image)
    Test.it("should zoom Mandelbrot set", test_zoom_mandelbrot)
    
    Note: Julia set tests
    Test.it("should create Julia set", test_create_julia_set)
    Test.it("should test Julia membership", test_julia_membership)
    Test.it("should analyze Julia connectivity", test_analyze_julia_connectivity)
    Test.it("should generate Julia family", test_generate_julia_family)
    
    Note: Newton fractal tests
    Test.it("should create Newton fractal", test_create_newton_fractal)
    Test.it("should perform Newton iteration", test_newton_iteration)
    Test.it("should find polynomial roots", test_find_polynomial_roots)
    
    Note: Chaos game tests
    Test.it("should create chaos game", test_create_chaos_game)
    Test.it("should play chaos game", test_play_chaos_game)
    Test.it("should generate Sierpinski triangle via chaos game", test_sierpinski_chaos_game)
    Test.it("should reject invalid triangle vertices", test_sierpinski_invalid_vertices)
    
    Note: Strange attractor tests
    Test.it("should create Lorenz attractor", test_create_lorenz_attractor)
    Test.it("should simulate Lorenz system", test_simulate_lorenz_system)
    Test.it("should create Hénon map", test_create_henon_map)
    Test.it("should iterate Hénon map", test_iterate_henon_map)
    Test.it("should calculate Lyapunov exponents (Lorenz)", test_calculate_lyapunov_exponents)
    Test.it("should calculate Lyapunov exponents (Hénon)", test_calculate_lyapunov_exponents_henon)
    
    Note: Classic fractal tests
    Test.it("should generate Sierpinski triangle", test_generate_sierpinski_triangle)
    Test.it("should generate Koch curve", test_generate_koch_curve)
    Test.it("should generate Dragon curve", test_generate_dragon_curve)
    Test.it("should generate Cantor set", test_generate_cantor_set)
    
    Note: Fractal analysis tests
    Test.it("should analyze self-similarity", test_analyze_self_similarity)
    Test.it("should measure fractal complexity", test_measure_fractal_complexity)
    Test.it("should compare fractal dimensions", test_compare_fractal_dimensions)
    Test.it("should detect fractal patterns", test_detect_fractal_patterns)
    
    Note: Helper function tests
    Test.it("should count boxes at scale", test_count_boxes_at_scale)
    Test.it("should calculate linear regression slope", test_calculate_linear_regression_slope)
    Test.it("should create 2x2 matrix", test_create_2x2_matrix)
    Test.it("should calculate complex distance", test_complex_distance)
    Test.it("should apply affine transformation 2D", test_apply_affine_transformation_2d)
    Test.it("should calculate transformation contraction ratio", test_calculate_transformation_contraction_ratio)
    Test.it("should calculate list average", test_calculate_list_average)
    Test.it("should calculate list variance", test_calculate_list_variance)
    
    Test.run()