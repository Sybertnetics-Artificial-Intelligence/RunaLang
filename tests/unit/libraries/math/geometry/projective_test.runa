Note: Comprehensive unit tests for math/geometry/projective.runa module
Note: Tests cover projective spaces, homogeneous coordinates, transformations, cross-ratios, conics, and classical theorems

Import "../../../../../../src/stdlib/math/geometry/projective" as ProjectiveGeometry
Import "../../../../../../src/stdlib/testing/framework" as Test

Note: Helper functions for creating test projective geometric structures

Process called "create_test_projective_point":
    Note: Creates test projective point [2:3:1] in 2D projective plane
    Return ProjectiveGeometry.create_projective_point([2.0, 3.0, 1.0])

Process called "create_test_point_at_infinity":
    Note: Creates point at infinity [1:2:0]
    Return ProjectiveGeometry.create_projective_point([1.0, 2.0, 0.0])

Process called "create_test_projective_line":
    Note: Creates line x + 2y + 3z = 0
    Return ProjectiveGeometry.create_projective_line([1.0, 2.0, 3.0])

Process called "create_test_identity_transformation":
    Note: Creates identity transformation matrix
    Let identity_matrix be [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]
    Return ProjectiveGeometry.create_projective_transformation(identity_matrix)

Process called "create_test_perspective_transformation":
    Note: Creates simple perspective transformation
    Let perspective_matrix be [[2.0, 0.0, 0.0], [0.0, 2.0, 0.0], [0.0, 0.0, 1.0]]
    Return ProjectiveGeometry.create_projective_transformation(perspective_matrix)

Process called "create_test_projective_conic":
    Note: Creates unit circle as projective conic x² + y² - z² = 0
    Let conic_matrix be [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]
    Return ProjectiveGeometry.create_projective_conic(conic_matrix)

Process called "create_test_four_points":
    Note: Creates four points for cross-ratio testing
    Let points be List[ProjectivePoint]()
    points.append(ProjectiveGeometry.create_projective_point([1.0, 0.0, 1.0]))  Note: (1,0)
    points.append(ProjectiveGeometry.create_projective_point([0.0, 0.0, 1.0]))  Note: (0,0)
    points.append(ProjectiveGeometry.create_projective_point([2.0, 0.0, 1.0]))  Note: (2,0)
    points.append(ProjectiveGeometry.create_projective_point([1.0, 0.0, 0.0]))  Note: point at infinity
    Return points

Process called "create_reference_triangle":
    Note: Creates reference triangle with vertices at [1:0:0], [0:1:0], [0:0:1]
    Let vertices be List[ProjectivePoint]()
    vertices.append(ProjectiveGeometry.create_projective_point([1.0, 0.0, 0.0]))
    vertices.append(ProjectiveGeometry.create_projective_point([0.0, 1.0, 0.0]))
    vertices.append(ProjectiveGeometry.create_projective_point([0.0, 0.0, 1.0]))
    Return vertices

Process called "assert_projective_point_valid" that takes point as ProjectivePoint, expected_coords as List[Float]:
    Note: Assert projective point properties
    Test.assert_not_null(point, "Projective point should be created")
    Test.assert_equal(point.coordinates.length, expected_coords.length, "Should have expected number of coordinates")
    
    Note: Check coordinates up to scalar multiple
    Let normalized_actual be ProjectiveGeometry.normalize_homogeneous_coordinates(point)
    Let normalized_expected be ProjectiveGeometry.normalize_homogeneous_coordinates(
        ProjectiveGeometry.create_projective_point(expected_coords))
    
    For i in 0 to expected_coords.length - 1:
        assert_float_close(normalized_actual.coordinates[i], normalized_expected.coordinates[i], 
                          1e-10, "Coordinate " + i.toString() + " should match")

Process called "assert_projective_line_valid" that takes line as ProjectiveLine, expected_coeffs as List[Float]:
    Note: Assert projective line properties
    Test.assert_not_null(line, "Projective line should be created")
    Test.assert_equal(line.equation_coefficients.length, expected_coeffs.length, "Should have expected number of coefficients")

Process called "assert_float_close" that takes actual as Float, expected as Float, tolerance as Float, message as String:
    Note: Assert floating point values are close within tolerance
    Let difference be actual - expected
    If difference < 0.0:
        difference = -difference
    Test.assert_true(difference < tolerance, message + " (actual: " + actual.toString() + ", expected: " + expected.toString() + ")")

Note: Homogeneous Coordinate Tests

Process called "test_create_projective_point":
    Note: Test projective point creation
    Let point be create_test_projective_point()
    assert_projective_point_valid(point, [2.0, 3.0, 1.0])

Process called "test_normalize_homogeneous_coordinates":
    Note: Test homogeneous coordinate normalization
    Let point be ProjectiveGeometry.create_projective_point([4.0, 6.0, 2.0])  Note: [2:3:1] scaled by 2
    Let normalized be ProjectiveGeometry.normalize_homogeneous_coordinates(point)
    
    assert_projective_point_valid(normalized, [2.0, 3.0, 1.0])

Process called "test_convert_to_euclidean":
    Note: Test conversion from projective to Euclidean coordinates
    Let point be create_test_projective_point()  Note: [2:3:1]
    Let euclidean = ProjectiveGeometry.convert_to_euclidean(point)
    
    Test.assert_not_null(euclidean, "Should convert to Euclidean coordinates")
    assert_float_close(euclidean[0], 2.0, 1e-10, "X coordinate should be 2")
    assert_float_close(euclidean[1], 3.0, 1e-10, "Y coordinate should be 3")

Process called "test_convert_from_euclidean":
    Note: Test conversion from Euclidean to projective coordinates
    Let euclidean_point be [2.0, 3.0]
    Let projective_point be ProjectiveGeometry.convert_from_euclidean(euclidean_point)
    
    assert_projective_point_valid(projective_point, [2.0, 3.0, 1.0])

Process called "test_convert_point_at_infinity":
    Note: Test handling of points at infinity
    Let point_at_infinity be create_test_point_at_infinity()  Note: [1:2:0]
    Let euclidean_result be ProjectiveGeometry.convert_to_euclidean(point_at_infinity)
    
    Test.assert_null(euclidean_result, "Point at infinity should not convert to Euclidean")

Process called "test_point_equality":
    Note: Test projective point equality (up to scalar)
    Let point1 be ProjectiveGeometry.create_projective_point([2.0, 3.0, 1.0])
    Let point2 be ProjectiveGeometry.create_projective_point([4.0, 6.0, 2.0])  Note: Same point scaled
    Let point3 be ProjectiveGeometry.create_projective_point([2.0, 4.0, 1.0])  Note: Different point
    
    Let are_equal_1_2 be ProjectiveGeometry.test_point_equality(point1, point2)
    Let are_equal_1_3 be ProjectiveGeometry.test_point_equality(point1, point3)
    
    Test.assert_true(are_equal_1_2, "Scaled points should be equal")
    Test.assert_false(are_equal_1_3, "Different points should not be equal")

Note: Line Operations Tests

Process called "test_create_projective_line":
    Note: Test projective line creation
    Let line be create_test_projective_line()
    assert_projective_line_valid(line, [1.0, 2.0, 3.0])

Process called "test_line_through_points":
    Note: Test line construction through two points
    Let point_a be ProjectiveGeometry.create_projective_point([1.0, 0.0, 1.0])  Note: (1,0)
    Let point_b be ProjectiveGeometry.create_projective_point([0.0, 1.0, 1.0])  Note: (0,1)
    
    Let line be ProjectiveGeometry.line_through_points(point_a, point_b)
    
    Test.assert_not_null(line, "Line should be created through two points")
    
    Note: Verify both points lie on the line
    Test.assert_true(ProjectiveGeometry.test_point_on_line(point_a, line), "Point A should lie on line")
    Test.assert_true(ProjectiveGeometry.test_point_on_line(point_b, line), "Point B should lie on line")

Process called "test_intersection_of_lines":
    Note: Test intersection of two lines
    Let line1 be ProjectiveGeometry.create_projective_line([1.0, 0.0, -1.0])  Note: x = 1
    Let line2 be ProjectiveGeometry.create_projective_line([0.0, 1.0, -1.0])  Note: y = 1
    
    Let intersection be ProjectiveGeometry.intersection_of_lines(line1, line2)
    
    Test.assert_not_null(intersection, "Lines should intersect")
    
    Note: Intersection should be at (1,1)
    Let euclidean = ProjectiveGeometry.convert_to_euclidean(intersection)
    assert_float_close(euclidean[0], 1.0, 1e-10, "X coordinate should be 1")
    assert_float_close(euclidean[1], 1.0, 1e-10, "Y coordinate should be 1")

Process called "test_point_on_line":
    Note: Test point-line incidence
    Let point be ProjectiveGeometry.create_projective_point([2.0, 1.0, 1.0])  Note: (2,1)
    Let line be ProjectiveGeometry.create_projective_line([1.0, -2.0, 0.0])  Note: x - 2y = 0
    
    Let is_on_line be ProjectiveGeometry.test_point_on_line(point, line)
    
    Test.assert_true(is_on_line, "Point (2,1) should be on line x - 2y = 0")

Process called "test_parallel_lines_intersection":
    Note: Test intersection of parallel lines (meet at infinity)
    Let line1 be ProjectiveGeometry.create_projective_line([1.0, 1.0, -1.0])  Note: x + y = 1
    Let line2 be ProjectiveGeometry.create_projective_line([1.0, 1.0, -2.0])  Note: x + y = 2
    
    Let intersection be ProjectiveGeometry.intersection_of_lines(line1, line2)
    
    Test.assert_not_null(intersection, "Parallel lines should meet at infinity")
    
    Note: Check that intersection is at infinity (z-coordinate = 0)
    assert_float_close(intersection.coordinates[2], 0.0, 1e-10, "Intersection should be at infinity")

Note: Transformation Tests

Process called "test_create_projective_transformation":
    Note: Test projective transformation creation
    Let transform be create_test_identity_transformation()
    
    Test.assert_not_null(transform, "Transformation should be created")
    Test.assert_not_null(transform.matrix, "Should have transformation matrix")

Process called "test_apply_projective_transformation":
    Note: Test applying transformation to points
    Let point be create_test_projective_point()  Note: [2:3:1]
    Let transform be create_test_perspective_transformation()  Note: Scale by 2
    
    Let transformed_point be ProjectiveGeometry.apply_projective_transformation(transform, point)
    
    Test.assert_not_null(transformed_point, "Transformed point should exist")
    assert_projective_point_valid(transformed_point, [4.0, 6.0, 1.0])

Process called "test_identity_transformation":
    Note: Test that identity transformation preserves points
    Let point be create_test_projective_point()
    Let identity_transform be create_test_identity_transformation()
    
    Let transformed_point be ProjectiveGeometry.apply_projective_transformation(identity_transform, point)
    
    Test.assert_true(ProjectiveGeometry.test_point_equality(point, transformed_point), 
                    "Identity transformation should preserve points")

Process called "test_compose_transformations":
    Note: Test composition of transformations
    Let transform1 be create_test_perspective_transformation()  Note: Scale by 2
    Let transform2 be create_test_perspective_transformation()  Note: Scale by 2
    
    Let composed be ProjectiveGeometry.compose_transformations(transform1, transform2)
    
    Test.assert_not_null(composed, "Composed transformation should exist")
    
    Note: Test that composition scales by 4
    Let point be ProjectiveGeometry.create_projective_point([1.0, 1.0, 1.0])
    Let result be ProjectiveGeometry.apply_projective_transformation(composed, point)
    
    assert_projective_point_valid(result, [4.0, 4.0, 1.0])

Process called "test_transformation_from_correspondences":
    Note: Test finding transformation from point correspondences
    Let source_points be List[ProjectivePoint]()
    source_points.append(ProjectiveGeometry.create_projective_point([1.0, 0.0, 1.0]))
    source_points.append(ProjectiveGeometry.create_projective_point([0.0, 1.0, 1.0]))
    source_points.append(ProjectiveGeometry.create_projective_point([0.0, 0.0, 1.0]))
    source_points.append(ProjectiveGeometry.create_projective_point([1.0, 1.0, 1.0]))
    
    Let target_points be List[ProjectivePoint]()
    target_points.append(ProjectiveGeometry.create_projective_point([2.0, 0.0, 1.0]))
    target_points.append(ProjectiveGeometry.create_projective_point([0.0, 2.0, 1.0]))
    target_points.append(ProjectiveGeometry.create_projective_point([0.0, 0.0, 1.0]))
    target_points.append(ProjectiveGeometry.create_projective_point([2.0, 2.0, 1.0]))
    
    Let transform be ProjectiveGeometry.find_transformation_from_correspondences(source_points, target_points)
    
    Test.assert_not_null(transform, "Transformation should be found from correspondences")

Process called "test_compute_fixed_points":
    Note: Test fixed point computation
    Let transform be create_test_identity_transformation()
    Let fixed_points be ProjectiveGeometry.compute_fixed_points(transform)
    
    Test.assert_not_null(fixed_points, "Should compute fixed points")
    Note: Identity transformation fixes all points, so should be a special case

Note: Cross-Ratio Tests

Process called "test_compute_cross_ratio":
    Note: Test cross-ratio computation
    Let points be create_test_four_points()
    Let A be points[0]  Note: (1,0)
    Let B be points[1]  Note: (0,0)
    Let C be points[2]  Note: (2,0)
    Let D be points[3]  Note: point at infinity
    
    Let cross_ratio be ProjectiveGeometry.compute_cross_ratio(A, B, C, D)
    
    Test.assert_not_null(cross_ratio, "Cross-ratio should be computed")
    Note: For collinear points with one at infinity, cross-ratio = AC/BC = (1-2)/(0-2) = 1/2
    assert_float_close(cross_ratio, 0.5, 1e-10, "Cross-ratio should be 0.5")

Process called "test_harmonic_division":
    Note: Test harmonic division detection
    Let A be ProjectiveGeometry.create_projective_point([1.0, 0.0, 1.0])   Note: (1,0)
    Let B be ProjectiveGeometry.create_projective_point([-1.0, 0.0, 1.0])  Note: (-1,0)
    Let C be ProjectiveGeometry.create_projective_point([3.0, 0.0, 1.0])   Note: (3,0)
    Let D be ProjectiveGeometry.create_projective_point([1.0, 0.0, 0.0])   Note: point at infinity
    
    Let is_harmonic be ProjectiveGeometry.test_harmonic_range(A, B, C, D)
    
    Test.assert_true(is_harmonic, "Points should form harmonic range")

Process called "test_harmonic_conjugate":
    Note: Test harmonic conjugate construction
    Let A be ProjectiveGeometry.create_projective_point([1.0, 0.0, 1.0])   Note: (1,0)
    Let B be ProjectiveGeometry.create_projective_point([-1.0, 0.0, 1.0])  Note: (-1,0)
    Let C be ProjectiveGeometry.create_projective_point([3.0, 0.0, 1.0])   Note: (3,0)
    
    Let D be ProjectiveGeometry.compute_harmonic_conjugate(A, B, C)
    
    Test.assert_not_null(D, "Harmonic conjugate should be computed")
    
    Note: Verify harmonic property
    Test.assert_true(ProjectiveGeometry.test_harmonic_range(A, B, C, D), 
                    "Constructed point should form harmonic range")

Note: Conic Tests

Process called "test_create_projective_conic":
    Note: Test projective conic creation
    Let conic be create_test_projective_conic()
    
    Test.assert_not_null(conic, "Projective conic should be created")
    Test.assert_not_null(conic.matrix, "Conic should have matrix representation")

Process called "test_point_on_conic":
    Note: Test point-on-conic testing
    Let conic be create_test_projective_conic()  Note: Unit circle x² + y² = z²
    Let point_on be ProjectiveGeometry.create_projective_point([1.0, 0.0, 1.0])    Note: (1,0) on circle
    Let point_off be ProjectiveGeometry.create_projective_point([2.0, 0.0, 1.0])   Note: (2,0) off circle
    
    Let is_on_conic be ProjectiveGeometry.test_point_on_conic(point_on, conic)
    Let is_off_conic be ProjectiveGeometry.test_point_on_conic(point_off, conic)
    
    Test.assert_true(is_on_conic, "Point (1,0) should be on unit circle")
    Test.assert_false(is_off_conic, "Point (2,0) should not be on unit circle")

Process called "test_conic_tangent_line":
    Note: Test tangent line to conic at point
    Let conic be create_test_projective_conic()  Note: Unit circle
    Let point_on_conic be ProjectiveGeometry.create_projective_point([1.0, 0.0, 1.0])  Note: (1,0)
    
    Let tangent_line be ProjectiveGeometry.compute_tangent_line(conic, point_on_conic)
    
    Test.assert_not_null(tangent_line, "Tangent line should be computed")
    
    Note: At (1,0), tangent to x² + y² = 1 should be x = 1
    Test.assert_true(ProjectiveGeometry.test_point_on_line(point_on_conic, tangent_line), 
                    "Point should lie on its tangent line")

Process called "test_conic_through_five_points":
    Note: Test conic construction through five points
    Let points be List[ProjectivePoint]()
    points.append(ProjectiveGeometry.create_projective_point([1.0, 0.0, 1.0]))   Note: (1,0)
    points.append(ProjectiveGeometry.create_projective_point([0.0, 1.0, 1.0]))   Note: (0,1)
    points.append(ProjectiveGeometry.create_projective_point([-1.0, 0.0, 1.0]))  Note: (-1,0)
    points.append(ProjectiveGeometry.create_projective_point([0.0, -1.0, 1.0]))  Note: (0,-1)
    points.append(ProjectiveGeometry.create_projective_point([0.7071, 0.7071, 1.0]))  Note: (√2/2, √2/2)
    
    Let conic be ProjectiveGeometry.conic_through_five_points(points)
    
    Test.assert_not_null(conic, "Conic through five points should be constructed")
    
    Note: Verify all points lie on the conic
    For point in points:
        Test.assert_true(ProjectiveGeometry.test_point_on_conic(point, conic), 
                        "All five points should lie on constructed conic")

Process called "test_conic_classification":
    Note: Test conic classification
    Let ellipse_conic be create_test_projective_conic()  Note: Circle/ellipse
    Let classification be ProjectiveGeometry.classify_conic(ellipse_conic)
    
    Test.assert_not_null(classification, "Conic should be classified")
    Test.assert_equal(classification.type, "ellipse", "Unit circle should be classified as ellipse")

Note: Duality Tests

Process called "test_point_line_duality":
    Note: Test point-line duality principle
    Let point be ProjectiveGeometry.create_projective_point([1.0, 2.0, 3.0])
    Let dual_line be ProjectiveGeometry.point_to_dual_line(point)
    
    Test.assert_not_null(dual_line, "Dual line should be computed")
    
    Note: Dual of point [a:b:c] should be line ax + by + cz = 0
    assert_projective_line_valid(dual_line, [1.0, 2.0, 3.0])

Process called "test_pole_polar_relation":
    Note: Test pole-polar relationship with respect to conic
    Let conic be create_test_projective_conic()
    Let pole be ProjectiveGeometry.create_projective_point([2.0, 0.0, 1.0])  Note: (2,0)
    
    Let polar_line be ProjectiveGeometry.compute_polar_line(conic, pole)
    
    Test.assert_not_null(polar_line, "Polar line should be computed")

Process called "test_trilinear_polarity":
    Note: Test trilinear polarity
    Let reference_triangle be create_reference_triangle()
    Let point be ProjectiveGeometry.create_projective_point([1.0, 1.0, 1.0])
    
    Let polar_triangle be ProjectiveGeometry.compute_trilinear_polar(reference_triangle, point)
    
    Test.assert_not_null(polar_triangle, "Trilinear polar should be computed")

Note: Classical Theorem Tests

Process called "test_desargues_theorem":
    Note: Test verification of Desargues' theorem
    Note: Create two triangles in perspective from a point
    Let triangle1_vertices be List[ProjectivePoint]()
    triangle1_vertices.append(ProjectiveGeometry.create_projective_point([1.0, 0.0, 1.0]))
    triangle1_vertices.append(ProjectiveGeometry.create_projective_point([0.0, 1.0, 1.0]))
    triangle1_vertices.append(ProjectiveGeometry.create_projective_point([0.0, 0.0, 1.0]))
    
    Let triangle2_vertices be List[ProjectivePoint]()
    triangle2_vertices.append(ProjectiveGeometry.create_projective_point([2.0, 0.0, 1.0]))
    triangle2_vertices.append(ProjectiveGeometry.create_projective_point([0.0, 2.0, 1.0]))
    triangle2_vertices.append(ProjectiveGeometry.create_projective_point([0.0, 0.0, 1.0]))
    
    Let perspective_center be ProjectiveGeometry.create_projective_point([1.0, 1.0, 0.0])
    
    Let desargues_result be ProjectiveGeometry.verify_desargues_theorem(triangle1_vertices, triangle2_vertices, perspective_center)
    
    Test.assert_not_null(desargues_result, "Desargues theorem verification should complete")

Process called "test_pappus_theorem":
    Note: Test verification of Pappus' theorem
    Let line1_points be List[ProjectivePoint]()
    line1_points.append(ProjectiveGeometry.create_projective_point([1.0, 0.0, 1.0]))
    line1_points.append(ProjectiveGeometry.create_projective_point([2.0, 0.0, 1.0]))
    line1_points.append(ProjectiveGeometry.create_projective_point([3.0, 0.0, 1.0]))
    
    Let line2_points be List[ProjectivePoint]()
    line2_points.append(ProjectiveGeometry.create_projective_point([0.0, 1.0, 1.0]))
    line2_points.append(ProjectiveGeometry.create_projective_point([0.0, 2.0, 1.0]))
    line2_points.append(ProjectiveGeometry.create_projective_point([0.0, 3.0, 1.0]))
    
    Let pappus_result be ProjectiveGeometry.verify_pappus_theorem(line1_points, line2_points)
    
    Test.assert_not_null(pappus_result, "Pappus theorem verification should complete")

Note: Perspective and Camera Tests

Process called "test_perspective_projection":
    Note: Test perspective projection
    Let camera_center be ProjectiveGeometry.create_projective_point([0.0, 0.0, 5.0, 1.0])  Note: Camera at (0,0,5)
    Let focal_length be 1.0
    
    Let world_point be ProjectiveGeometry.create_projective_point([1.0, 1.0, 0.0, 1.0])  Note: 3D point
    Let projected_point be ProjectiveGeometry.perspective_projection(world_point, camera_center, focal_length)
    
    Test.assert_not_null(projected_point, "Perspective projection should be computed")

Process called "test_fundamental_matrix":
    Note: Test fundamental matrix computation
    Let camera1_points be List[ProjectivePoint]()
    Let camera2_points be List[ProjectivePoint]()
    
    Note: Create corresponding points (simplified example)
    For i in 0 to 7:  Note: Need at least 8 points for fundamental matrix
        camera1_points.append(ProjectiveGeometry.create_projective_point([Float(i), Float(i), 1.0]))
        camera2_points.append(ProjectiveGeometry.create_projective_point([Float(i+1), Float(i), 1.0]))
    
    Let fundamental_matrix be ProjectiveGeometry.compute_fundamental_matrix(camera1_points, camera2_points)
    
    Test.assert_not_null(fundamental_matrix, "Fundamental matrix should be computed")

Note: Advanced Operations Tests

Process called "test_projective_invariants":
    Note: Test computation of projective invariants
    Let points be create_test_four_points()
    Let invariants be ProjectiveGeometry.compute_projective_invariants(points)
    
    Test.assert_not_null(invariants, "Projective invariants should be computed")

Process called "test_canonical_form_transformation":
    Note: Test transformation to canonical form
    Let conic be create_test_projective_conic()
    Let canonical_transform be ProjectiveGeometry.compute_canonical_form_transformation(conic)
    
    Test.assert_not_null(canonical_transform, "Canonical form transformation should be computed")

Process called "test_quadric_operations":
    Note: Test basic quadric operations
    Let quadric_matrix be create_identity_4x4_matrix()
    Let quadric be ProjectiveGeometry.create_projective_quadric(quadric_matrix)
    
    Test.assert_not_null(quadric, "Projective quadric should be created")
    
    Let test_point be ProjectiveGeometry.create_projective_point([1.0, 0.0, 0.0, 1.0])
    Let is_on_quadric be ProjectiveGeometry.test_point_on_quadric(test_point, quadric)
    
    Test.assert_true(is_on_quadric, "Point should be on unit sphere quadric")

Process called "create_identity_4x4_matrix":
    Note: Helper to create 4x4 identity matrix
    Return [[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, -1.0]]

Note: Main test execution process

Process called "run_projective_geometry_tests":
    Note: Execute all projective geometry tests
    Test.describe("Projective Geometry Module Tests")
    
    Note: Homogeneous Coordinate Tests
    Test.describe("Homogeneous Coordinates")
    test_create_projective_point()
    test_normalize_homogeneous_coordinates()
    test_convert_to_euclidean()
    test_convert_from_euclidean()
    test_convert_point_at_infinity()
    test_point_equality()
    
    Note: Line Operation Tests
    Test.describe("Projective Lines")
    test_create_projective_line()
    test_line_through_points()
    test_intersection_of_lines()
    test_point_on_line()
    test_parallel_lines_intersection()
    
    Note: Transformation Tests
    Test.describe("Projective Transformations")
    test_create_projective_transformation()
    test_apply_projective_transformation()
    test_identity_transformation()
    test_compose_transformations()
    test_transformation_from_correspondences()
    test_compute_fixed_points()
    
    Note: Cross-Ratio Tests
    Test.describe("Cross-Ratios and Harmonic Division")
    test_compute_cross_ratio()
    test_harmonic_division()
    test_harmonic_conjugate()
    
    Note: Conic Tests
    Test.describe("Projective Conics")
    test_create_projective_conic()
    test_point_on_conic()
    test_conic_tangent_line()
    test_conic_through_five_points()
    test_conic_classification()
    
    Note: Duality Tests
    Test.describe("Projective Duality")
    test_point_line_duality()
    test_pole_polar_relation()
    test_trilinear_polarity()
    
    Note: Classical Theorem Tests
    Test.describe("Classical Theorems")
    test_desargues_theorem()
    test_pappus_theorem()
    
    Note: Perspective Tests
    Test.describe("Perspective and Camera Geometry")
    test_perspective_projection()
    test_fundamental_matrix()
    
    Note: Advanced Operation Tests
    Test.describe("Advanced Operations")
    test_projective_invariants()
    test_canonical_form_transformation()
    test_quadric_operations()
    
    Test.print_summary()

Note: Execute tests when this file is run
run_projective_geometry_tests()