Note: Comprehensive unit tests for math/geometry/euclidean.runa module
Note: Tests cover 2D/3D points, vectors, lines, shapes, transformations, and geometric operations

Import "../../../../../../src/stdlib/math/geometry/euclidean" as EuclideanGeometry
Import "../../../../../../src/stdlib/testing/framework" as Test

Note: Helper functions for creating test geometric structures

Process called "create_test_point_2d":
    Note: Creates a test 2D point at (3, 4)
    Return EuclideanGeometry.create_point_2d(3.0, 4.0)

Process called "create_test_point_3d":
    Note: Creates a test 3D point at (1, 2, 3)
    Return EuclideanGeometry.create_point_3d(1.0, 2.0, 3.0)

Process called "create_test_vector_2d":
    Note: Creates a test 2D vector (5, 12)
    Return EuclideanGeometry.create_vector_2d(5.0, 12.0)

Process called "create_test_vector_3d":
    Note: Creates a test 3D vector (1, 1, 1)
    Return EuclideanGeometry.create_vector_3d(1.0, 1.0, 1.0)

Process called "create_test_unit_vector_2d":
    Note: Creates a unit vector in 2D (1, 0)
    Return EuclideanGeometry.create_vector_2d(1.0, 0.0)

Process called "create_test_unit_vector_3d":
    Note: Creates a unit vector in 3D (1, 0, 0)
    Return EuclideanGeometry.create_vector_3d(1.0, 0.0, 0.0)

Process called "create_test_line_2d":
    Note: Creates a test 2D line through origin with slope 1
    Let point be EuclideanGeometry.create_point_2d(0.0, 0.0)
    Let direction be EuclideanGeometry.create_vector_2d(1.0, 1.0)
    Return EuclideanGeometry.create_line_2d(point, direction)

Process called "create_test_line_3d":
    Note: Creates a test 3D line through origin
    Let point be EuclideanGeometry.create_point_3d(0.0, 0.0, 0.0)
    Let direction be EuclideanGeometry.create_vector_3d(1.0, 1.0, 1.0)
    Return EuclideanGeometry.create_line_3d(point, direction)

Process called "create_test_plane_3d":
    Note: Creates a test plane z = 1
    Let point be EuclideanGeometry.create_point_3d(0.0, 0.0, 1.0)
    Let normal be EuclideanGeometry.create_vector_3d(0.0, 0.0, 1.0)
    Return EuclideanGeometry.create_plane_3d(point, normal)

Process called "create_test_circle":
    Note: Creates a test circle with radius 5 at origin
    Let center be create_test_point_2d()
    Return EuclideanGeometry.create_circle(center, 5.0)

Process called "create_test_triangle_2d":
    Note: Creates a test triangle
    Let vertex_a be EuclideanGeometry.create_point_2d(0.0, 0.0)
    Let vertex_b be EuclideanGeometry.create_point_2d(3.0, 0.0)
    Let vertex_c be EuclideanGeometry.create_point_2d(0.0, 4.0)
    Return EuclideanGeometry.create_triangle_2d(vertex_a, vertex_b, vertex_c)

Process called "assert_point_valid" that takes point as Point2D, expected_x as Float, expected_y as Float:
    Note: Assert 2D point properties
    Test.assert_not_null(point, "Point should be created successfully")
    assert_float_close(point.x, expected_x, 1e-10, "X coordinate should match")
    assert_float_close(point.y, expected_y, 1e-10, "Y coordinate should match")

Process called "assert_point_3d_valid" that takes point as Point3D, expected_x as Float, expected_y as Float, expected_z as Float:
    Note: Assert 3D point properties
    Test.assert_not_null(point, "3D Point should be created successfully")
    assert_float_close(point.x, expected_x, 1e-10, "X coordinate should match")
    assert_float_close(point.y, expected_y, 1e-10, "Y coordinate should match")
    assert_float_close(point.z, expected_z, 1e-10, "Z coordinate should match")

Process called "assert_vector_valid" that takes vector as Vector2D, expected_x as Float, expected_y as Float:
    Note: Assert 2D vector properties
    Test.assert_not_null(vector, "Vector should be created successfully")
    assert_float_close(vector.x, expected_x, 1e-10, "X component should match")
    assert_float_close(vector.y, expected_y, 1e-10, "Y component should match")

Process called "assert_vector_3d_valid" that takes vector as Vector3D, expected_x as Float, expected_y as Float, expected_z as Float:
    Note: Assert 3D vector properties
    Test.assert_not_null(vector, "3D Vector should be created successfully")
    assert_float_close(vector.x, expected_x, 1e-10, "X component should match")
    assert_float_close(vector.y, expected_y, 1e-10, "Y component should match")
    assert_float_close(vector.z, expected_z, 1e-10, "Z component should match")

Process called "assert_float_close" that takes actual as Float, expected as Float, tolerance as Float, message as String:
    Note: Assert floating point values are close within tolerance
    Let difference be actual - expected
    If difference < 0.0:
        difference = -difference
    Test.assert_true(difference < tolerance, message + " (actual: " + actual.toString() + ", expected: " + expected.toString() + ")")

Note: Point and Vector Creation Tests

Process called "test_create_point_2d":
    Note: Test 2D point creation
    Let point be create_test_point_2d()
    assert_point_valid(point, 3.0, 4.0)

Process called "test_create_point_3d":
    Note: Test 3D point creation
    Let point be create_test_point_3d()
    assert_point_3d_valid(point, 1.0, 2.0, 3.0)

Process called "test_create_vector_2d":
    Note: Test 2D vector creation
    Let vector be create_test_vector_2d()
    assert_vector_valid(vector, 5.0, 12.0)

Process called "test_create_vector_3d":
    Note: Test 3D vector creation
    Let vector be create_test_vector_3d()
    assert_vector_3d_valid(vector, 1.0, 1.0, 1.0)

Note: Distance Calculation Tests

Process called "test_calculate_distance_2d":
    Note: Test 2D distance calculation
    Let point_a be EuclideanGeometry.create_point_2d(0.0, 0.0)
    Let point_b be EuclideanGeometry.create_point_2d(3.0, 4.0)
    
    Let distance be EuclideanGeometry.calculate_distance_2d(point_a, point_b)
    
    assert_float_close(distance, 5.0, 1e-10, "Distance should be 5.0 (3-4-5 triangle)")

Process called "test_calculate_distance_3d":
    Note: Test 3D distance calculation
    Let point_a be EuclideanGeometry.create_point_3d(0.0, 0.0, 0.0)
    Let point_b be EuclideanGeometry.create_point_3d(1.0, 2.0, 2.0)
    
    Let distance be EuclideanGeometry.calculate_distance_3d(point_a, point_b)
    
    assert_float_close(distance, 3.0, 1e-10, "Distance should be 3.0 (√(1² + 2² + 2²))")

Process called "test_calculate_vector_magnitude_2d":
    Note: Test 2D vector magnitude calculation
    Let vector be create_test_vector_2d()  Note: (5, 12)
    
    Let magnitude be EuclideanGeometry.calculate_vector_magnitude_2d(vector)
    
    assert_float_close(magnitude, 13.0, 1e-10, "Magnitude should be 13.0 (5-12-13 triangle)")

Process called "test_calculate_vector_magnitude_3d":
    Note: Test 3D vector magnitude calculation
    Let vector be EuclideanGeometry.create_vector_3d(2.0, 3.0, 6.0)
    
    Let magnitude be EuclideanGeometry.calculate_vector_magnitude_3d(vector)
    
    assert_float_close(magnitude, 7.0, 1e-10, "Magnitude should be 7.0 (√(4 + 9 + 36))")

Note: Vector Operations Tests

Process called "test_normalize_vector_2d":
    Note: Test 2D vector normalization
    Let vector be create_test_vector_2d()  Note: (5, 12)
    
    Let normalized be EuclideanGeometry.normalize_vector_2d(vector)
    
    assert_vector_valid(normalized, 5.0/13.0, 12.0/13.0)
    
    Let magnitude be EuclideanGeometry.calculate_vector_magnitude_2d(normalized)
    assert_float_close(magnitude, 1.0, 1e-10, "Normalized vector should have magnitude 1")

Process called "test_normalize_vector_3d":
    Note: Test 3D vector normalization
    Let vector be create_test_vector_3d()  Note: (1, 1, 1)
    
    Let normalized be EuclideanGeometry.normalize_vector_3d(vector)
    
    Let expected_component be 1.0 / 1.732050807568877  Note: 1/√3
    assert_vector_3d_valid(normalized, expected_component, expected_component, expected_component)
    
    Let magnitude be EuclideanGeometry.calculate_vector_magnitude_3d(normalized)
    assert_float_close(magnitude, 1.0, 1e-10, "Normalized vector should have magnitude 1")

Process called "test_add_vectors_2d":
    Note: Test 2D vector addition
    Let vector_a be EuclideanGeometry.create_vector_2d(2.0, 3.0)
    Let vector_b be EuclideanGeometry.create_vector_2d(4.0, 1.0)
    
    Let sum be EuclideanGeometry.add_vectors_2d(vector_a, vector_b)
    
    assert_vector_valid(sum, 6.0, 4.0)

Process called "test_subtract_vectors_2d":
    Note: Test 2D vector subtraction
    Let vector_a be EuclideanGeometry.create_vector_2d(5.0, 7.0)
    Let vector_b be EuclideanGeometry.create_vector_2d(2.0, 3.0)
    
    Let difference be EuclideanGeometry.subtract_vectors_2d(vector_a, vector_b)
    
    assert_vector_valid(difference, 3.0, 4.0)

Process called "test_scale_vector_2d":
    Note: Test 2D vector scaling
    Let vector be EuclideanGeometry.create_vector_2d(3.0, 4.0)
    Let scalar be 2.5
    
    Let scaled be EuclideanGeometry.scale_vector_2d(vector, scalar)
    
    assert_vector_valid(scaled, 7.5, 10.0)

Process called "test_dot_product_2d":
    Note: Test 2D dot product
    Let vector_a be EuclideanGeometry.create_vector_2d(3.0, 4.0)
    Let vector_b be EuclideanGeometry.create_vector_2d(2.0, 1.0)
    
    Let dot_product be EuclideanGeometry.dot_product_2d(vector_a, vector_b)
    
    assert_float_close(dot_product, 10.0, 1e-10, "Dot product should be 10 (3×2 + 4×1)")

Process called "test_dot_product_3d":
    Note: Test 3D dot product
    Let vector_a be EuclideanGeometry.create_vector_3d(1.0, 2.0, 3.0)
    Let vector_b be EuclideanGeometry.create_vector_3d(4.0, 5.0, 6.0)
    
    Let dot_product be EuclideanGeometry.dot_product_3d(vector_a, vector_b)
    
    assert_float_close(dot_product, 32.0, 1e-10, "Dot product should be 32 (1×4 + 2×5 + 3×6)")

Process called "test_cross_product_3d":
    Note: Test 3D cross product
    Let vector_a be EuclideanGeometry.create_vector_3d(1.0, 0.0, 0.0)
    Let vector_b be EuclideanGeometry.create_vector_3d(0.0, 1.0, 0.0)
    
    Let cross_product be EuclideanGeometry.cross_product_3d(vector_a, vector_b)
    
    assert_vector_3d_valid(cross_product, 0.0, 0.0, 1.0)

Note: Angle Calculation Tests

Process called "test_angle_between_vectors_2d":
    Note: Test angle calculation between 2D vectors
    Let vector_a be EuclideanGeometry.create_vector_2d(1.0, 0.0)  Note: Along x-axis
    Let vector_b be EuclideanGeometry.create_vector_2d(0.0, 1.0)  Note: Along y-axis
    
    Let angle be EuclideanGeometry.angle_between_vectors_2d(vector_a, vector_b)
    
    assert_float_close(angle, 1.5707963267948966, 1e-10, "Angle should be π/2 radians (90°)")

Process called "test_angle_between_vectors_3d":
    Note: Test angle calculation between 3D vectors
    Let vector_a be EuclideanGeometry.create_vector_3d(1.0, 0.0, 0.0)
    Let vector_b be EuclideanGeometry.create_vector_3d(1.0, 1.0, 0.0)
    
    Let angle be EuclideanGeometry.angle_between_vectors_3d(vector_a, vector_b)
    
    assert_float_close(angle, 0.7853981633974483, 1e-10, "Angle should be π/4 radians (45°)")

Note: Line and Plane Tests

Process called "test_create_line_2d":
    Note: Test 2D line creation
    Let line be create_test_line_2d()
    
    Test.assert_not_null(line, "Line should be created successfully")
    Test.assert_not_null(line.point, "Line should have a point")
    Test.assert_not_null(line.direction, "Line should have a direction vector")

Process called "test_create_line_3d":
    Note: Test 3D line creation
    Let line be create_test_line_3d()
    
    Test.assert_not_null(line, "3D Line should be created successfully")
    Test.assert_not_null(line.point, "Line should have a point")
    Test.assert_not_null(line.direction, "Line should have a direction vector")

Process called "test_create_plane_3d":
    Note: Test plane creation
    Let plane be create_test_plane_3d()
    
    Test.assert_not_null(plane, "Plane should be created successfully")
    Test.assert_not_null(plane.point, "Plane should have a point")
    Test.assert_not_null(plane.normal, "Plane should have a normal vector")

Process called "test_point_to_line_distance_2d":
    Note: Test distance from point to 2D line
    Let point be EuclideanGeometry.create_point_2d(2.0, 2.0)
    Let line_point be EuclideanGeometry.create_point_2d(0.0, 0.0)
    Let line_direction be EuclideanGeometry.create_vector_2d(1.0, 0.0)  Note: Horizontal line through origin
    Let line be EuclideanGeometry.create_line_2d(line_point, line_direction)
    
    Let distance be EuclideanGeometry.point_to_line_distance_2d(point, line)
    
    assert_float_close(distance, 2.0, 1e-10, "Distance from (2,2) to x-axis should be 2")

Process called "test_point_to_plane_distance_3d":
    Note: Test distance from point to plane
    Let point be EuclideanGeometry.create_point_3d(0.0, 0.0, 3.0)
    Let plane be create_test_plane_3d()  Note: Plane z = 1 with normal (0,0,1)
    
    Let distance be EuclideanGeometry.point_to_plane_distance_3d(point, plane)
    
    assert_float_close(distance, 2.0, 1e-10, "Distance from (0,0,3) to plane z=1 should be 2")

Note: Shape Tests

Process called "test_create_circle":
    Note: Test circle creation
    Let circle be create_test_circle()
    
    Test.assert_not_null(circle, "Circle should be created successfully")
    assert_float_close(circle.radius, 5.0, 1e-10, "Circle radius should be 5")
    Test.assert_not_null(circle.center, "Circle should have a center point")

Process called "test_circle_area":
    Note: Test circle area calculation
    Let circle be create_test_circle()  Note: Radius 5
    
    Let area be EuclideanGeometry.calculate_circle_area(circle)
    
    assert_float_close(area, 78.53981633974483, 1e-10, "Area should be 25π")

Process called "test_circle_circumference":
    Note: Test circle circumference calculation
    Let circle be create_test_circle()  Note: Radius 5
    
    Let circumference be EuclideanGeometry.calculate_circle_circumference(circle)
    
    assert_float_close(circumference, 31.41592653589793, 1e-10, "Circumference should be 10π")

Process called "test_create_sphere":
    Note: Test sphere creation
    Let center be create_test_point_3d()
    Let sphere be EuclideanGeometry.create_sphere(center, 3.0)
    
    Test.assert_not_null(sphere, "Sphere should be created successfully")
    assert_float_close(sphere.radius, 3.0, 1e-10, "Sphere radius should be 3")

Process called "test_sphere_volume":
    Note: Test sphere volume calculation
    Let center be EuclideanGeometry.create_point_3d(0.0, 0.0, 0.0)
    Let sphere be EuclideanGeometry.create_sphere(center, 3.0)
    
    Let volume be EuclideanGeometry.calculate_sphere_volume(sphere)
    
    assert_float_close(volume, 113.09733552923255, 1e-10, "Volume should be (4/3)π×27 = 36π")

Process called "test_sphere_surface_area":
    Note: Test sphere surface area calculation
    Let center be EuclideanGeometry.create_point_3d(0.0, 0.0, 0.0)
    Let sphere be EuclideanGeometry.create_sphere(center, 3.0)
    
    Let surface_area be EuclideanGeometry.calculate_sphere_surface_area(sphere)
    
    assert_float_close(surface_area, 113.09733552923255, 1e-10, "Surface area should be 4π×9 = 36π")

Note: Triangle Tests

Process called "test_create_triangle_2d":
    Note: Test 2D triangle creation
    Let triangle be create_test_triangle_2d()
    
    Test.assert_not_null(triangle, "Triangle should be created successfully")
    Test.assert_not_null(triangle.vertex_a, "Triangle should have vertex A")
    Test.assert_not_null(triangle.vertex_b, "Triangle should have vertex B")
    Test.assert_not_null(triangle.vertex_c, "Triangle should have vertex C")

Process called "test_triangle_area_2d":
    Note: Test 2D triangle area calculation
    Let triangle be create_test_triangle_2d()  Note: Right triangle with legs 3 and 4
    
    Let area be EuclideanGeometry.calculate_triangle_area_2d(triangle)
    
    assert_float_close(area, 6.0, 1e-10, "Area should be 6 (0.5 × 3 × 4)")

Process called "test_triangle_perimeter_2d":
    Note: Test 2D triangle perimeter calculation
    Let triangle be create_test_triangle_2d()  Note: 3-4-5 triangle
    
    Let perimeter be EuclideanGeometry.calculate_triangle_perimeter_2d(triangle)
    
    assert_float_close(perimeter, 12.0, 1e-10, "Perimeter should be 12 (3 + 4 + 5)")

Process called "test_triangle_angles_2d":
    Note: Test 2D triangle angle calculation
    Let triangle be create_test_triangle_2d()
    
    Let angles be EuclideanGeometry.calculate_triangle_angles_2d(triangle)
    
    Test.assert_not_null(angles, "Angles should be calculated")
    Test.assert_equal(angles.length, 3, "Should have 3 angles")
    
    Note: Check that angles sum to π
    Let angle_sum be angles[0] + angles[1] + angles[2]
    assert_float_close(angle_sum, 3.141592653589793, 1e-9, "Angles should sum to π")

Note: Point-in-Shape Tests

Process called "test_point_in_circle":
    Note: Test point-in-circle detection
    Let circle = create_test_circle()  Note: Center at (3,4), radius 5
    Let point_inside be EuclideanGeometry.create_point_2d(3.0, 4.0)  Note: Center point
    Let point_outside be EuclideanGeometry.create_point_2d(10.0, 10.0)
    
    Let is_inside be EuclideanGeometry.point_in_circle(point_inside, circle)
    Let is_outside be EuclideanGeometry.point_in_circle(point_outside, circle)
    
    Test.assert_true(is_inside, "Center point should be inside circle")
    Test.assert_false(is_outside, "Distant point should be outside circle")

Process called "test_point_in_triangle_2d":
    Note: Test point-in-triangle detection using barycentric coordinates
    Let triangle be create_test_triangle_2d()  Note: Triangle with vertices (0,0), (3,0), (0,4)
    Let point_inside be EuclideanGeometry.create_point_2d(1.0, 1.0)
    Let point_outside be EuclideanGeometry.create_point_2d(5.0, 5.0)
    
    Let is_inside be EuclideanGeometry.point_in_triangle_2d(point_inside, triangle)
    Let is_outside be EuclideanGeometry.point_in_triangle_2d(point_outside, triangle)
    
    Test.assert_true(is_inside, "Point (1,1) should be inside triangle")
    Test.assert_false(is_outside, "Point (5,5) should be outside triangle")

Note: Transformation Tests

Process called "test_create_transform_2d":
    Note: Test 2D transformation creation
    Let translation be EuclideanGeometry.create_vector_2d(5.0, 3.0)
    Let rotation_angle be 1.5707963267948966  Note: π/2 radians (90°)
    Let scale_x be 2.0
    Let scale_y be 2.0
    
    Let transform be EuclideanGeometry.create_transform_2d(translation, rotation_angle, scale_x, scale_y)
    
    Test.assert_not_null(transform, "Transform should be created successfully")
    assert_float_close(transform.rotation_angle, rotation_angle, 1e-10, "Rotation angle should match")

Process called "test_apply_transform_2d":
    Note: Test applying 2D transformation
    Let point be EuclideanGeometry.create_point_2d(1.0, 0.0)
    Let translation be EuclideanGeometry.create_vector_2d(0.0, 0.0)  Note: No translation
    Let rotation_angle be 1.5707963267948966  Note: 90° rotation
    Let transform be EuclideanGeometry.create_transform_2d(translation, rotation_angle, 1.0, 1.0)
    
    Let transformed_point be EuclideanGeometry.apply_transform_2d(point, transform)
    
    Note: (1,0) rotated 90° should become (0,1)
    assert_float_close(transformed_point.x, 0.0, 1e-10, "X should be 0 after 90° rotation")
    assert_float_close(transformed_point.y, 1.0, 1e-10, "Y should be 1 after 90° rotation")

Process called "test_create_transform_3d":
    Note: Test 3D transformation creation
    Let translation be EuclideanGeometry.create_vector_3d(1.0, 2.0, 3.0)
    Let rotation_axis be EuclideanGeometry.create_vector_3d(0.0, 0.0, 1.0)  Note: Z-axis
    Let rotation_angle be 1.5707963267948966  Note: π/2 radians
    Let scale_x be 1.0
    Let scale_y be 1.0
    Let scale_z be 1.0
    
    Let transform be EuclideanGeometry.create_transform_3d(translation, rotation_axis, rotation_angle, scale_x, scale_y, scale_z)
    
    Test.assert_not_null(transform, "3D Transform should be created successfully")

Process called "test_compose_transforms_2d":
    Note: Test composition of 2D transformations
    Let translation1 be EuclideanGeometry.create_vector_2d(2.0, 3.0)
    Let translation2 be EuclideanGeometry.create_vector_2d(1.0, 1.0)
    Let transform1 be EuclideanGeometry.create_transform_2d(translation1, 0.0, 1.0, 1.0)
    Let transform2 be EuclideanGeometry.create_transform_2d(translation2, 0.0, 1.0, 1.0)
    
    Let composed be EuclideanGeometry.compose_transforms_2d(transform1, transform2)
    
    Test.assert_not_null(composed, "Composed transform should be created")

Process called "test_invert_transform_2d":
    Note: Test 2D transformation inversion
    Let translation be EuclideanGeometry.create_vector_2d(5.0, 3.0)
    Let rotation_angle be 0.5235987755982988  Note: π/6 radians (30°)
    Let transform be EuclideanGeometry.create_transform_2d(translation, rotation_angle, 2.0, 2.0)
    
    Let inverse be EuclideanGeometry.invert_transform_2d(transform)
    
    Test.assert_not_null(inverse, "Inverse transform should be created")

Note: Intersection Tests

Process called "test_line_intersection_2d":
    Note: Test intersection of two 2D lines
    Let line1_point be EuclideanGeometry.create_point_2d(0.0, 0.0)
    Let line1_direction be EuclideanGeometry.create_vector_2d(1.0, 0.0)  Note: Horizontal line
    Let line1 be EuclideanGeometry.create_line_2d(line1_point, line1_direction)
    
    Let line2_point be EuclideanGeometry.create_point_2d(2.0, -1.0)
    Let line2_direction be EuclideanGeometry.create_vector_2d(0.0, 1.0)  Note: Vertical line
    Let line2 be EuclideanGeometry.create_line_2d(line2_point, line2_direction)
    
    Let intersection be EuclideanGeometry.line_intersection_2d(line1, line2)
    
    Test.assert_not_null(intersection, "Lines should intersect")
    assert_point_valid(intersection, 2.0, 0.0)

Process called "test_line_plane_intersection_3d":
    Note: Test intersection of line and plane in 3D
    Let line_point be EuclideanGeometry.create_point_3d(0.0, 0.0, 0.0)
    Let line_direction be EuclideanGeometry.create_vector_3d(0.0, 0.0, 1.0)  Note: Vertical line
    Let line be EuclideanGeometry.create_line_3d(line_point, line_direction)
    
    Let plane be create_test_plane_3d()  Note: Plane z = 1
    
    Let intersection be EuclideanGeometry.line_plane_intersection_3d(line, plane)
    
    Test.assert_not_null(intersection, "Line should intersect plane")
    assert_point_3d_valid(intersection, 0.0, 0.0, 1.0)

Note: Polygon Tests

Process called "test_create_polygon_2d":
    Note: Test polygon creation
    Let vertices be List[Point2D]()
    vertices.append(EuclideanGeometry.create_point_2d(0.0, 0.0))
    vertices.append(EuclideanGeometry.create_point_2d(2.0, 0.0))
    vertices.append(EuclideanGeometry.create_point_2d(2.0, 2.0))
    vertices.append(EuclideanGeometry.create_point_2d(0.0, 2.0))
    
    Let polygon be EuclideanGeometry.create_polygon_2d(vertices)
    
    Test.assert_not_null(polygon, "Polygon should be created successfully")
    Test.assert_equal(polygon.vertices.length, 4, "Polygon should have 4 vertices")

Process called "test_polygon_area_2d":
    Note: Test polygon area calculation using shoelace formula
    Let vertices be List[Point2D]()
    vertices.append(EuclideanGeometry.create_point_2d(0.0, 0.0))
    vertices.append(EuclideanGeometry.create_point_2d(2.0, 0.0))
    vertices.append(EuclideanGeometry.create_point_2d(2.0, 2.0))
    vertices.append(EuclideanGeometry.create_point_2d(0.0, 2.0))
    Let polygon be EuclideanGeometry.create_polygon_2d(vertices)
    
    Let area be EuclideanGeometry.calculate_polygon_area_2d(polygon)
    
    assert_float_close(area, 4.0, 1e-10, "Square polygon should have area 4")

Process called "test_point_in_polygon_2d":
    Note: Test point-in-polygon using ray casting algorithm
    Let vertices be List[Point2D]()
    vertices.append(EuclideanGeometry.create_point_2d(0.0, 0.0))
    vertices.append(EuclideanGeometry.create_point_2d(4.0, 0.0))
    vertices.append(EuclideanGeometry.create_point_2d(4.0, 4.0))
    vertices.append(EuclideanGeometry.create_point_2d(0.0, 4.0))
    Let polygon be EuclideanGeometry.create_polygon_2d(vertices)
    
    Let point_inside be EuclideanGeometry.create_point_2d(2.0, 2.0)
    Let point_outside be EuclideanGeometry.create_point_2d(5.0, 5.0)
    
    Let is_inside be EuclideanGeometry.point_in_polygon_2d(point_inside, polygon)
    Let is_outside be EuclideanGeometry.point_in_polygon_2d(point_outside, polygon)
    
    Test.assert_true(is_inside, "Center point should be inside square")
    Test.assert_false(is_outside, "Outside point should not be in square")

Note: Advanced Geometric Operations Tests

Process called "test_centroid_calculation":
    Note: Test centroid calculation for triangle
    Let triangle be create_test_triangle_2d()
    
    Let centroid be EuclideanGeometry.calculate_triangle_centroid_2d(triangle)
    
    Note: Centroid of triangle with vertices (0,0), (3,0), (0,4) should be (1,4/3)
    assert_point_valid(centroid, 1.0, 1.3333333333333333)

Process called "test_orthogonal_projection":
    Note: Test orthogonal projection of point onto line
    Let point be EuclideanGeometry.create_point_2d(3.0, 2.0)
    Let line_point be EuclideanGeometry.create_point_2d(0.0, 0.0)
    Let line_direction be EuclideanGeometry.create_vector_2d(1.0, 0.0)  Note: X-axis
    Let line be EuclideanGeometry.create_line_2d(line_point, line_direction)
    
    Let projection be EuclideanGeometry.project_point_onto_line_2d(point, line)
    
    assert_point_valid(projection, 3.0, 0.0)

Process called "test_reflection_across_line":
    Note: Test reflection of point across line
    Let point be EuclideanGeometry.create_point_2d(2.0, 3.0)
    Let line_point be EuclideanGeometry.create_point_2d(0.0, 0.0)
    Let line_direction be EuclideanGeometry.create_vector_2d(1.0, 0.0)  Note: X-axis
    Let line be EuclideanGeometry.create_line_2d(line_point, line_direction)
    
    Let reflection be EuclideanGeometry.reflect_point_across_line_2d(point, line)
    
    assert_point_valid(reflection, 2.0, -3.0)

Note: Main test execution process

Process called "run_euclidean_geometry_tests":
    Note: Execute all euclidean geometry tests
    Test.describe("Euclidean Geometry Module Tests")
    
    Note: Point and Vector Creation Tests
    Test.describe("Point and Vector Creation")
    test_create_point_2d()
    test_create_point_3d()
    test_create_vector_2d()
    test_create_vector_3d()
    
    Note: Distance Calculation Tests
    Test.describe("Distance Calculations")
    test_calculate_distance_2d()
    test_calculate_distance_3d()
    test_calculate_vector_magnitude_2d()
    test_calculate_vector_magnitude_3d()
    
    Note: Vector Operations Tests
    Test.describe("Vector Operations")
    test_normalize_vector_2d()
    test_normalize_vector_3d()
    test_add_vectors_2d()
    test_subtract_vectors_2d()
    test_scale_vector_2d()
    test_dot_product_2d()
    test_dot_product_3d()
    test_cross_product_3d()
    
    Note: Angle Calculation Tests
    Test.describe("Angle Calculations")
    test_angle_between_vectors_2d()
    test_angle_between_vectors_3d()
    
    Note: Line and Plane Tests
    Test.describe("Lines and Planes")
    test_create_line_2d()
    test_create_line_3d()
    test_create_plane_3d()
    test_point_to_line_distance_2d()
    test_point_to_plane_distance_3d()
    
    Note: Shape Tests
    Test.describe("Geometric Shapes")
    test_create_circle()
    test_circle_area()
    test_circle_circumference()
    test_create_sphere()
    test_sphere_volume()
    test_sphere_surface_area()
    
    Note: Triangle Tests
    Test.describe("Triangles")
    test_create_triangle_2d()
    test_triangle_area_2d()
    test_triangle_perimeter_2d()
    test_triangle_angles_2d()
    
    Note: Point-in-Shape Tests
    Test.describe("Point-in-Shape Detection")
    test_point_in_circle()
    test_point_in_triangle_2d()
    
    Note: Transformation Tests
    Test.describe("Geometric Transformations")
    test_create_transform_2d()
    test_apply_transform_2d()
    test_create_transform_3d()
    test_compose_transforms_2d()
    test_invert_transform_2d()
    
    Note: Intersection Tests
    Test.describe("Geometric Intersections")
    test_line_intersection_2d()
    test_line_plane_intersection_3d()
    
    Note: Polygon Tests
    Test.describe("Polygons")
    test_create_polygon_2d()
    test_polygon_area_2d()
    test_point_in_polygon_2d()
    
    Note: Advanced Operations Tests
    Test.describe("Advanced Operations")
    test_centroid_calculation()
    test_orthogonal_projection()
    test_reflection_across_line()
    
    Test.print_summary()

Note: Execute tests when this file is run
run_euclidean_geometry_tests()