Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles arena utility operations for the Runa compiler internal system.

ARENA UTILITIES - Tier 2 Memory Management Engine
- Process arena allocation and arena management operations for compiler temporaries
- Handle arena resizing and arena capacity management for compiler data
- Manage arena operations and arena manipulation utilities for compiler workflows
- Process arena optimization and arena performance utilities for compiler efficiency
- Handle integration with compiler phases for temporary memory allocation

This file is essential because of the following reasons:
- Arena utilities enable efficient memory management for compiler temporaries
- Proper arena handling ensures O(1) cleanup for temporary compiler data
- Arena utilities support all compiler phases that need temporary storage with fast allocation
- Arena-based allocation provides deterministic memory management for compiler operations

This file consists of the following functions/features/operation types:
- Arena creation, destruction, and lifecycle management
- Arena allocation and deallocation operations
- Arena resizing and capacity management
- Arena performance optimization and monitoring
- Integration with compiler phases for temporary memory needs

Dependencies:
- Imports memory_safety.runa for memory safety validation
- Imports debug_utils.runa for arena debugging and diagnostics
- Imports collections.runa for arena data structure management
:End Note

Import "compiler/internal/memory_utils.runa" as MemoryUtils
Import "compiler/internal/memory_safety.runa" as MemorySafety
Import "compiler/internal/debug_utils.runa" as DebugUtils
Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/frontend/primitives/core/bitwise_core.runa" as BitwiseCore
Import "compiler/frontend/primitives/core/syscall_core.runa" as Syscall

Note: ============================================================================
Note: Arena Management Structures
Note: ============================================================================

Type called "Arena":
    memory_block as Integer    Note: Pointer to current active memory block
    current_pos as Integer     Note: Current position in active block
    size as Integer           Note: Size of current block
    capacity as Integer        Note: Capacity of current block
    alignment as Integer       Note: Memory alignment requirement
    first_block as Integer     Note: Pointer to first block in chain
    current_block as Integer   Note: Pointer to current block node
    is_active as Integer       Note: Boolean: 1 if arena is active
    allocation_count as Integer Note: Number of allocations made
    total_allocated as Integer  Note: Total bytes allocated across all blocks

Type called "ArenaBlock":
    memory as Integer          Note: Pointer to memory in this block
    size as Integer           Note: Size of this block
    used as Integer           Note: Bytes used in this block
    next as Integer           Note: Pointer to next block in chain

Type called "ArenaAllocation":
    arena as Integer          Note: Pointer to parent arena
    memory_ptr as Integer     Note: Pointer to allocated memory
    size as Integer           Note: Size of allocation
    alignment as Integer       Note: Alignment of allocation
    is_freed as Integer       Note: Boolean: 1 if allocation is freed
    next as Integer           Note: Pointer to next allocation in chain

Type called "ArenaStats":
    total_allocations as Integer Note: Total number of allocations
    total_bytes as Integer     Note: Total bytes allocated
    peak_usage as Integer      Note: Peak memory usage
    fragmentation as Integer   Note: Memory fragmentation percentage
    allocation_time as Integer Note: Time spent on allocations
    deallocation_time as Integer Note: Time spent on deallocations

Note: ============================================================================
Note: Arena Constants
Note: ============================================================================

Constant ARENA_DEFAULT_SIZE as Integer is 65536
Constant ARENA_MIN_SIZE as Integer is 4096
Constant ARENA_MAX_SIZE as Integer is 1073741824
Constant ARENA_ALIGNMENT as Integer is 8
Constant ARENA_GROWTH_FACTOR as Integer is 2
Constant ARENA_SHRINK_THRESHOLD as Integer is 4

Constant ARENA_ALLOCATION_SUCCESS as Integer is 0
Constant ARENA_ALLOCATION_FAILED as Integer is -1
Constant ARENA_ALLOCATION_OVERFLOW as Integer is -2
Constant ARENA_ALLOCATION_INVALID as Integer is -3

Note: ============================================================================
Note: Arena Creation and Destruction
Note: ============================================================================

Process called "arena_create" takes initial_size as Integer, alignment as Integer returns Integer:
    Note: Create new arena with chained-block growth support
    Note: Returns pointer to Arena structure
    Note: Initializes arena with first block

    Note: Validate size
    Let size_to_use be initial_size
    If size_to_use is less than ARENA_MIN_SIZE:
        Set size_to_use to ARENA_MIN_SIZE
    End If
    If size_to_use is greater than ARENA_MAX_SIZE:
        Set size_to_use to ARENA_MAX_SIZE
    End If

    Note: Validate alignment (must be power of 2)
    Let alignment_to_use be alignment
    If alignment_to_use is less than ARENA_ALIGNMENT:
        Set alignment_to_use to ARENA_ALIGNMENT
    End If

    Note: Allocate Arena structure (10 fields * 8 bytes = 80 bytes)
    Let arena_struct_size be 80
    Let arena_ptr be proc allocate from MemoryUtils with arena_struct_size
    If arena_ptr is equal to 0:
        Return 0
    End If

    Note: Allocate first ArenaBlock node (4 fields * 8 bytes = 32 bytes)
    Let block_node_size be 32
    Let first_block_node be proc allocate from MemoryUtils with block_node_size
    If first_block_node is equal to 0:
        Let dealloc_result be proc deallocate from MemoryUtils with arena_ptr
        Return 0
    End If

    Note: Allocate memory for first block
    Let memory_block be proc allocate from MemoryUtils with size_to_use
    If memory_block is equal to 0:
        Let dealloc1 be proc deallocate from MemoryUtils with arena_ptr
        Let dealloc2 be proc deallocate from MemoryUtils with first_block_node
        Return 0
    End If

    Note: Initialize ArenaBlock node
    Let dummy1 be proc memory_set_integer from MemoryCore with first_block_node, 0, memory_block  Note: memory
    Let dummy2 be proc memory_set_integer from MemoryCore with first_block_node, 8, size_to_use   Note: size
    Let dummy3 be proc memory_set_integer from MemoryCore with first_block_node, 16, 0            Note: used = 0
    Let dummy4 be proc memory_set_integer from MemoryCore with first_block_node, 24, 0            Note: next = null

    Note: Initialize Arena structure fields
    Let dummy5 be proc memory_set_integer from MemoryCore with arena_ptr, 0, memory_block         Note: memory_block (current)
    Let dummy6 be proc memory_set_integer from MemoryCore with arena_ptr, 8, 0                    Note: current_pos = 0
    Let dummy7 be proc memory_set_integer from MemoryCore with arena_ptr, 16, size_to_use         Note: size (current)
    Let dummy8 be proc memory_set_integer from MemoryCore with arena_ptr, 24, size_to_use         Note: capacity (current)
    Let dummy9 be proc memory_set_integer from MemoryCore with arena_ptr, 32, alignment_to_use    Note: alignment
    Let dummy10 be proc memory_set_integer from MemoryCore with arena_ptr, 40, first_block_node   Note: first_block
    Let dummy11 be proc memory_set_integer from MemoryCore with arena_ptr, 48, first_block_node   Note: current_block
    Let dummy12 be proc memory_set_integer from MemoryCore with arena_ptr, 56, 1                  Note: is_active = true
    Let dummy13 be proc memory_set_integer from MemoryCore with arena_ptr, 64, 0                  Note: allocation_count = 0
    Let dummy14 be proc memory_set_integer from MemoryCore with arena_ptr, 72, 0                  Note: total_allocated = 0

    Return arena_ptr
End Process

Process called "arena_destroy" takes arena as Integer returns Nothing:
    Note: Destroy arena and free all blocks in the chain
    Note: Frees all allocations in all blocks
    Note: Validates memory safety before destruction

    If arena is equal to 0:
        Return
    End If

    Note: Validate arena pointer
    Let is_valid be proc memory_validate_pointer from MemorySafety with arena
    If is_valid is equal to 0:
        Return
    End If

    Note: Mark arena as inactive
    Let dummy1 be proc memory_set_integer from MemoryCore with arena, 56, 0  Note: is_active = false

    Note: Get first block in chain
    Let current_block be proc memory_get_integer from MemoryCore with arena, 40  Note: first_block

    Note: Walk through block chain and free each block
    While current_block is not equal to 0:
        Note: Get memory pointer from this block
        Let block_memory be proc memory_get_integer from MemoryCore with current_block, 0

        Note: Get next block before freeing current
        Let next_block be proc memory_get_integer from MemoryCore with current_block, 24

        Note: Free the memory in this block
        If block_memory is not equal to 0:
            Let dealloc1 be proc deallocate from MemoryUtils with block_memory
        End If

        Note: Free the block node itself
        Let dealloc2 be proc deallocate from MemoryUtils with current_block

        Note: Move to next block
        Set current_block to next_block
    End While

    Note: Free arena structure itself
    Let dealloc3 be proc deallocate from MemoryUtils with arena

    Return
End Process

Process called "arena_reset" takes arena as Integer returns Integer:
    Note: Reset arena to initial state across all blocks in chain
    Note: Returns 1 if successful, 0 if failed
    Note: Frees all additional blocks, keeps first block, zeros memory

    If arena is equal to 0:
        Return 0
    End If

    Note: Check if arena is active
    Let is_active be proc memory_get_integer from MemoryCore with arena, 56
    If is_active is equal to 0:
        Return 0
    End If

    Note: Get first block and current block
    Let first_block_node be proc memory_get_integer from MemoryCore with arena, 40
    Let current_block_node be proc memory_get_integer from MemoryCore with arena, 48

    Note: If there are additional blocks beyond first, free them
    If first_block_node is not equal to 0:
        Note: Get the second block in chain (first.next)
        Let second_block be proc memory_get_integer from MemoryCore with first_block_node, 24

        Note: Walk through chain starting from second block and free all
        Let block_to_free be second_block
        While block_to_free is not equal to 0:
            Let block_memory be proc memory_get_integer from MemoryCore with block_to_free, 0
            Let next_block be proc memory_get_integer from MemoryCore with block_to_free, 24

            Note: Free the memory in this block
            If block_memory is not equal to 0:
                Let dealloc1 be proc deallocate from MemoryUtils with block_memory
            End If

            Note: Free the block node itself
            Let dealloc2 be proc deallocate from MemoryUtils with block_to_free

            Set block_to_free to next_block
        End While

        Note: Terminate first block's chain (set next to null)
        Let dummy_term be proc memory_set_integer from MemoryCore with first_block_node, 24, 0

        Note: Reset first block's used field to 0
        Let dummy_used be proc memory_set_integer from MemoryCore with first_block_node, 16, 0

        Note: Get first block's memory and size
        Let first_memory be proc memory_get_integer from MemoryCore with first_block_node, 0
        Let first_size be proc memory_get_integer from MemoryCore with first_block_node, 8

        Note: Update arena to use first block as current
        Let dummy1 be proc memory_set_integer from MemoryCore with arena, 0, first_memory
        Let dummy2 be proc memory_set_integer from MemoryCore with arena, 16, first_size
        Let dummy3 be proc memory_set_integer from MemoryCore with arena, 24, first_size
        Let dummy4 be proc memory_set_integer from MemoryCore with arena, 48, first_block_node

        Note: Zero first block's memory for security
        Let dummy5 be proc memory_zero from MemoryCore with first_memory, first_size
    End If

    Note: Reset current position to 0
    Let dummy6 be proc memory_set_integer from MemoryCore with arena, 8, 0

    Note: Reset allocation count
    Let dummy7 be proc memory_set_integer from MemoryCore with arena, 64, 0

    Note: Reset total allocated
    Let dummy8 be proc memory_set_integer from MemoryCore with arena, 72, 0

    Return 1
End Process

Process called "arena_clear" takes arena as Integer returns Integer:
    Note: Clear arena and reset position across all blocks
    Note: Returns 1 if successful, 0 if failed
    Note: Does not free block memory, just resets positions

    If arena is equal to 0:
        Return 0
    End If

    Note: Check if arena is active
    Let is_active be proc memory_get_integer from MemoryCore with arena, 56
    If is_active is equal to 0:
        Return 0
    End If

    Note: Reset all blocks' used fields to 0
    Let current_block be proc memory_get_integer from MemoryCore with arena, 40  Note: first_block
    While current_block is not equal to 0:
        Let dummy_reset be proc memory_set_integer from MemoryCore with current_block, 16, 0  Note: used = 0
        Set current_block to proc memory_get_integer from MemoryCore with current_block, 24  Note: next
    End While

    Note: Get first block as current
    Let first_block_node be proc memory_get_integer from MemoryCore with arena, 40
    If first_block_node is not equal to 0:
        Let first_memory be proc memory_get_integer from MemoryCore with first_block_node, 0
        Let first_size be proc memory_get_integer from MemoryCore with first_block_node, 8

        Note: Update arena to use first block as current
        Let dummy1 be proc memory_set_integer from MemoryCore with arena, 0, first_memory
        Let dummy2 be proc memory_set_integer from MemoryCore with arena, 16, first_size
        Let dummy3 be proc memory_set_integer from MemoryCore with arena, 24, first_size
        Let dummy4 be proc memory_set_integer from MemoryCore with arena, 48, first_block_node
    End If

    Note: Reset current position to 0
    Let dummy5 be proc memory_set_integer from MemoryCore with arena, 8, 0

    Note: Reset allocation count
    Let dummy6 be proc memory_set_integer from MemoryCore with arena, 64, 0

    Note: Reset total allocated
    Let dummy7 be proc memory_set_integer from MemoryCore with arena, 72, 0

    Return 1
End Process

Process called "arena_clone" takes source_arena as Integer returns Integer:
    Note: Create complete copy of arena including entire block chain
    Note: Returns pointer to new Arena structure
    Note: Copies all blocks, allocations, and settings

    If source_arena is equal to 0:
        Return 0
    End If

    Note: Get source arena properties from first block
    Let src_first_block be proc memory_get_integer from MemoryCore with source_arena, 40
    If src_first_block is equal to 0:
        Return 0
    End If

    Let first_block_size be proc memory_get_integer from MemoryCore with src_first_block, 8
    Let alignment be proc memory_get_integer from MemoryCore with source_arena, 32

    Note: Create new arena with same first block size
    Let new_arena be proc arena_create with first_block_size, alignment
    If new_arena is equal to 0:
        Return 0
    End If

    Note: Clone all blocks in the chain
    Let src_block be src_first_block
    Let dst_block be proc memory_get_integer from MemoryCore with new_arena, 40  Note: new first_block
    Let last_dst_block be dst_block

    While src_block is not equal to 0:
        Note: Get source block info
        Let src_memory be proc memory_get_integer from MemoryCore with src_block, 0
        Let src_size be proc memory_get_integer from MemoryCore with src_block, 8
        Let src_used be proc memory_get_integer from MemoryCore with src_block, 16
        Let src_next be proc memory_get_integer from MemoryCore with src_block, 24

        Note: Get destination block memory
        Let dst_memory be proc memory_get_integer from MemoryCore with dst_block, 0

        Note: Copy memory contents up to used amount
        If src_used is greater than 0:
            Let copy_result be proc memory_copy from MemoryCore with dst_memory, src_memory, src_used
        End If

        Note: Set destination block's used field
        Let dummy_used be proc memory_set_integer from MemoryCore with dst_block, 16, src_used

        Note: If source has next block, create corresponding block in destination
        If src_next is not equal to 0:
            Note: Get next block size
            Let next_src_size be proc memory_get_integer from MemoryCore with src_next, 8

            Note: Allocate new ArenaBlock node
            Let block_node_size be 32
            Let new_dst_block be proc allocate from MemoryUtils with block_node_size
            If new_dst_block is equal to 0:
                Note: Failed to allocate - cleanup and return 0
                Let destroy_result be proc arena_destroy with new_arena
                Return 0
            End If

            Note: Allocate memory for new block
            Let new_dst_memory be proc allocate from MemoryUtils with next_src_size
            If new_dst_memory is equal to 0:
                Let dealloc_node be proc deallocate from MemoryUtils with new_dst_block
                Let destroy_result be proc arena_destroy with new_arena
                Return 0
            End If

            Note: Initialize new destination block
            Let dummy1 be proc memory_set_integer from MemoryCore with new_dst_block, 0, new_dst_memory  Note: memory
            Let dummy2 be proc memory_set_integer from MemoryCore with new_dst_block, 8, next_src_size   Note: size
            Let dummy3 be proc memory_set_integer from MemoryCore with new_dst_block, 16, 0               Note: used = 0
            Let dummy4 be proc memory_set_integer from MemoryCore with new_dst_block, 24, 0               Note: next = null

            Note: Link to previous destination block
            Let dummy5 be proc memory_set_integer from MemoryCore with dst_block, 24, new_dst_block

            Note: Advance to next blocks
            Set src_block to src_next
            Set dst_block to new_dst_block
            Set last_dst_block to new_dst_block
        End If
        Otherwise:
            Note: No more source blocks
            Set src_block to 0
        End If
    End While

    Note: Update new arena's current_block to point to last block
    Let dummy6 be proc memory_set_integer from MemoryCore with new_arena, 48, last_dst_block

    Note: Get final memory block and position from last destination block
    Let final_memory be proc memory_get_integer from MemoryCore with last_dst_block, 0
    Let final_size be proc memory_get_integer from MemoryCore with last_dst_block, 8
    Let final_used be proc memory_get_integer from MemoryCore with last_dst_block, 16

    Note: Update new arena's current state
    Let dummy7 be proc memory_set_integer from MemoryCore with new_arena, 0, final_memory   Note: memory_block
    Let dummy8 be proc memory_set_integer from MemoryCore with new_arena, 8, final_used     Note: current_pos
    Let dummy9 be proc memory_set_integer from MemoryCore with new_arena, 16, final_size    Note: size
    Let dummy10 be proc memory_set_integer from MemoryCore with new_arena, 24, final_size   Note: capacity

    Note: Copy allocation count and total allocated
    Let allocation_count be proc memory_get_integer from MemoryCore with source_arena, 64
    Let dummy11 be proc memory_set_integer from MemoryCore with new_arena, 64, allocation_count

    Let total_allocated be proc memory_get_integer from MemoryCore with source_arena, 72
    Let dummy12 be proc memory_set_integer from MemoryCore with new_arena, 72, total_allocated

    Return new_arena
End Process

Note: ============================================================================
Note: Arena Allocation Operations
Note: ============================================================================

Process called "arena_allocate" takes arena as Integer, size as Integer, alignment as Integer returns Integer:
    Note: Allocate memory from arena with automatic growth
    Note: Returns pointer to allocated memory or 0 if failed
    Note: Automatically allocates new block if current block is full
    Note: This is the CORE arena allocation function - bump allocator with chained blocks

    If arena is equal to 0:
        Return 0
    End If

    If size is equal to 0:
        Return 0
    End If

    Note: Check if arena is active
    Let is_active be proc memory_get_integer from MemoryCore with arena, 56
    If is_active is equal to 0:
        Return 0
    End If

    Note: Get current position and memory block
    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Let memory_block be proc memory_get_integer from MemoryCore with arena, 0

    Note: Align current position if needed
    Let aligned_pos be current_pos
    If alignment is greater than 1:
        Let mask be alignment minus 1
        Let offset be current_pos bitwise and mask
        If offset is not equal to 0:
            Let padding be alignment minus offset
            Set aligned_pos to current_pos plus padding
        End If
    End If

    Note: Calculate new position after allocation
    Let new_pos be aligned_pos plus size

    Note: Check if we have enough space in current block
    Let capacity be proc memory_get_integer from MemoryCore with arena, 24
    If new_pos is greater than capacity:
        Note: AUTOMATIC GROWTH: Current block is full, allocate new block

        Note: Update current block's used field before allocating new block
        Let current_block_node be proc memory_get_integer from MemoryCore with arena, 48
        If current_block_node is not equal to 0:
            Let dummy_update_used be proc memory_set_integer from MemoryCore with current_block_node, 16, current_pos
        End If

        Note: Calculate new block size (double previous size or fit allocation, whichever larger)
        Let new_block_size be capacity multiplied by 2
        Let size_needed be size plus alignment  Note: Add alignment for padding
        If new_block_size is less than size_needed:
            Set new_block_size to size_needed
        End If

        Note: Cap at ARENA_MAX_SIZE
        If new_block_size is greater than ARENA_MAX_SIZE:
            Set new_block_size to ARENA_MAX_SIZE
        End If

        Note: Allocate new ArenaBlock node
        Let block_node_size be 32
        Let new_block_node be proc allocate from MemoryUtils with block_node_size
        If new_block_node is equal to 0:
            Return 0  Note: Failed to allocate block node
        End If

        Note: Allocate memory for new block
        Let new_memory_block be proc allocate from MemoryUtils with new_block_size
        If new_memory_block is equal to 0:
            Let dealloc_node be proc deallocate from MemoryUtils with new_block_node
            Return 0  Note: Failed to allocate new block memory
        End If

        Note: Initialize new ArenaBlock node
        Let dummy1 be proc memory_set_integer from MemoryCore with new_block_node, 0, new_memory_block  Note: memory
        Let dummy2 be proc memory_set_integer from MemoryCore with new_block_node, 8, new_block_size     Note: size
        Let dummy3 be proc memory_set_integer from MemoryCore with new_block_node, 16, 0                  Note: used = 0
        Let dummy4 be proc memory_set_integer from MemoryCore with new_block_node, 24, 0                  Note: next = null

        Note: Link new block to current block's next pointer
        If current_block_node is not equal to 0:
            Let dummy5 be proc memory_set_integer from MemoryCore with current_block_node, 24, new_block_node
        End If

        Note: Update arena to use new block as current
        Let dummy6 be proc memory_set_integer from MemoryCore with arena, 0, new_memory_block    Note: memory_block
        Let dummy7 be proc memory_set_integer from MemoryCore with arena, 8, 0                   Note: current_pos = 0
        Let dummy8 be proc memory_set_integer from MemoryCore with arena, 16, new_block_size     Note: size
        Let dummy9 be proc memory_set_integer from MemoryCore with arena, 24, new_block_size     Note: capacity
        Let dummy10 be proc memory_set_integer from MemoryCore with arena, 48, new_block_node    Note: current_block

        Note: Recalculate positions for new block
        Set current_pos to 0
        Set memory_block to new_memory_block
        Set aligned_pos to 0
        Set new_pos to size
        Set capacity to new_block_size

        Note: Verify new block has space (should always be true after growing)
        If new_pos is greater than capacity:
            Return 0  Note: Allocation too large even for new block
        End If
    End If

    Note: Calculate pointer to allocated memory
    Let alloc_ptr be memory_block plus aligned_pos

    Note: Update current position
    Let dummy11 be proc memory_set_integer from MemoryCore with arena, 8, new_pos

    Note: Increment allocation count
    Let allocation_count be proc memory_get_integer from MemoryCore with arena, 64
    Let new_count be allocation_count plus 1
    Let dummy12 be proc memory_set_integer from MemoryCore with arena, 64, new_count

    Note: Update total allocated bytes across all blocks
    Let total_allocated be proc memory_get_integer from MemoryCore with arena, 72
    Let new_total be total_allocated plus size
    Let dummy13 be proc memory_set_integer from MemoryCore with arena, 72, new_total

    Return alloc_ptr
End Process

Process called "arena_allocate_aligned" takes arena as Integer, size as Integer, alignment as Integer returns Integer:
    Note: Allocate aligned memory from arena
    Note: Returns pointer to aligned memory or 0 if failed
    Note: Ensures proper alignment for performance

    Note: This is just an alias for arena_allocate with explicit alignment
    Let result be proc arena_allocate with arena, size, alignment
    Return result
End Process

Process called "arena_allocate_zeroed" takes arena as Integer, size as Integer returns Integer:
    Note: Allocate zero-initialized memory from arena
    Note: Returns pointer to zeroed memory or 0 if failed
    Note: All memory is initialized to zero

    Note: Get arena alignment
    Let alignment be ARENA_ALIGNMENT
    If arena is not equal to 0:
        Set alignment to proc memory_get_integer from MemoryCore with arena, 32
    End If

    Note: Allocate memory
    Let alloc_ptr be proc arena_allocate with arena, size, alignment
    If alloc_ptr is equal to 0:
        Return 0
    End If

    Note: Zero the allocated memory
    Let dummy be proc memory_zero from MemoryCore with alloc_ptr, size

    Return alloc_ptr
End Process

Process called "arena_allocate_array" takes arena as Integer, element_size as Integer, count as Integer returns Integer:
    Note: Allocate array from arena
    Note: Returns pointer to array memory or 0 if failed
    Note: Handles array alignment and sizing

    Note: Calculate total size
    Let total_size be element_size multiplied by count

    Note: Use element size as alignment (up to 16 bytes)
    Let alignment be element_size
    If alignment is greater than 16:
        Set alignment to 16
    End If

    Note: Allocate array memory
    Let result be proc arena_allocate with arena, total_size, alignment
    Return result
End Process

Process called "arena_allocate_string" takes arena as Integer, length as Integer returns Integer:
    Note: Allocate string buffer from arena
    Note: Returns pointer to string buffer or 0 if failed
    Note: Includes null terminator space

    Note: Add 1 for null terminator
    Let buffer_size be length plus 1

    Note: Strings use 1-byte alignment
    Let result be proc arena_allocate with arena, buffer_size, 1
    Return result
End Process

Process called "arena_allocate_struct" takes arena as Integer, struct_size as Integer returns Integer:
    Note: Allocate structure from arena
    Note: Returns pointer to structure or 0 if failed
    Note: Handles structure alignment

    Note: Structures use 8-byte alignment
    Let alignment be 8

    Let result be proc arena_allocate with arena, struct_size, alignment
    Return result
End Process

Note: ============================================================================
Note: Arena Memory Management
Note: ============================================================================

Process called "arena_compact" takes arena as Integer returns Integer:
    Note: Compact arena to reduce fragmentation
    Note: Returns 1 if successful, 0 if failed
    Note: For bump allocator with chained blocks, this is a no-op

    If arena is equal to 0:
        Return 0
    End If

    Note: Bump allocators with chained blocks don't fragment
    Note: Allocations are contiguous within each block
    Note: Compaction is not needed and would be harmful
    Return 1
End Process

Note: ============================================================================
Note: Arena Query Operations
Note: ============================================================================

Process called "arena_get_size" takes arena as Integer returns Integer:
    Note: Get total size of arena across all blocks
    Note: Returns total size in bytes

    If arena is equal to 0:
        Return 0
    End If

    Note: Sum sizes of all blocks in chain
    Let total_size be 0
    Let current_block be proc memory_get_integer from MemoryCore with arena, 40  Note: first_block
    While current_block is not equal to 0:
        Let block_size be proc memory_get_integer from MemoryCore with current_block, 8
        Set total_size to total_size plus block_size
        Set current_block to proc memory_get_integer from MemoryCore with current_block, 24  Note: next
    End While

    Return total_size
End Process

Process called "arena_get_capacity" takes arena as Integer returns Integer:
    Note: Get total capacity of arena across all blocks
    Note: Returns total capacity in bytes

    If arena is equal to 0:
        Return 0
    End If

    Note: Sum capacities of all blocks in chain (for chained blocks, capacity = size)
    Let total_capacity be 0
    Let current_block be proc memory_get_integer from MemoryCore with arena, 40  Note: first_block
    While current_block is not equal to 0:
        Let block_size be proc memory_get_integer from MemoryCore with current_block, 8
        Set total_capacity to total_capacity plus block_size
        Set current_block to proc memory_get_integer from MemoryCore with current_block, 24  Note: next
    End While

    Return total_capacity
End Process

Process called "arena_get_usage" takes arena as Integer returns Integer:
    Note: Get current usage of arena across all blocks
    Note: Returns total bytes used across all blocks

    If arena is equal to 0:
        Return 0
    End If

    Note: Sum used bytes from all blocks in chain
    Let total_used be 0
    Let current_block be proc memory_get_integer from MemoryCore with arena, 40  Note: first_block
    While current_block is not equal to 0:
        Let block_used be proc memory_get_integer from MemoryCore with current_block, 16
        Set total_used to total_used plus block_used
        Set current_block to proc memory_get_integer from MemoryCore with current_block, 24  Note: next
    End While

    Note: Add current block's position (which may not be saved to block.used yet)
    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Set total_used to total_used plus current_pos

    Return total_used
End Process

Process called "arena_get_peak_usage" takes arena as Integer returns Integer:
    Note: Get peak usage of arena
    Note: Returns peak usage in bytes

    If arena is equal to 0:
        Return 0
    End If

    Let peak_usage be proc memory_get_integer from MemoryCore with arena, 72
    Return peak_usage
End Process

Process called "arena_get_fragmentation" takes arena as Integer returns Integer:
    Note: Get fragmentation percentage of arena
    Note: Returns fragmentation as percentage (0-100)
    Note: Bump allocators don't fragment - always returns 0

    If arena is equal to 0:
        Return 0
    End If

    Note: Bump allocators allocate linearly - no fragmentation
    Return 0
End Process

Process called "arena_get_allocation_count" takes arena as Integer returns Integer:
    Note: Get number of allocations in arena
    Note: Returns allocation count

    If arena is equal to 0:
        Return 0
    End If

    Let allocation_count be proc memory_get_integer from MemoryCore with arena, 64
    Return allocation_count
End Process

Process called "arena_is_full" takes arena as Integer returns Integer:
    Note: Check if current block is full
    Note: Returns 1 if current block full, 0 if not
    Note: With automatic growth, arena never truly fills (allocates new block)

    If arena is equal to 0:
        Return 1
    End If

    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Let capacity be proc memory_get_integer from MemoryCore with arena, 24

    If current_pos is greater than or equal to capacity:
        Return 1
    End If

    Return 0
End Process

Process called "arena_has_space" takes arena as Integer, size as Integer returns Integer:
    Note: Check if arena can accommodate allocation
    Note: Returns 1 if has space (considering automatic growth), 0 if not
    Note: With automatic growth, this always returns 1 unless size exceeds MAX_SIZE

    If arena is equal to 0:
        Return 0
    End If

    If size is equal to 0:
        Return 1
    End If

    Note: Check if allocation would exceed maximum arena block size
    If size is greater than ARENA_MAX_SIZE:
        Return 0
    End If

    Note: With automatic growth via chained blocks, arena can always accommodate
    Note: allocations up to ARENA_MAX_SIZE per block
    Return 1
End Process

Note: ============================================================================
Note: Arena Performance Operations
Note: ============================================================================

Process called "arena_get_stats" takes arena as Integer returns Integer:
    Note: Get arena statistics across all blocks
    Note: Returns pointer to ArenaStats structure
    Note: Provides detailed performance metrics

    If arena is equal to 0:
        Return 0
    End If

    Note: ArenaStats structure:
    Note: offset 0:  total_size (8 bytes) - sum of all block sizes
    Note: offset 8:  total_capacity (8 bytes) - sum of all block capacities
    Note: offset 16: current_usage (8 bytes) - sum of used bytes across blocks
    Note: offset 24: peak_usage (8 bytes) - total_allocated field
    Note: offset 32: allocation_count (8 bytes)
    Note: offset 40: total_allocated (8 bytes)
    Note: offset 48: total_freed (8 bytes) - always 0 for bump allocator
    Note: offset 56: fragmentation (8 bytes) - always 0 for bump allocator
    Note: offset 64: block_count (8 bytes) - number of blocks in chain
    Note: Total size: 72 bytes

    Let stats_size be 72
    Let stats_ptr be proc allocate from MemoryUtils with stats_size

    If stats_ptr is equal to 0:
        Return 0
    End If

    Note: Sum sizes, capacities, and usage across all blocks
    Let total_size be 0
    Let total_capacity be 0
    Let total_usage be 0
    Let block_count be 0

    Let current_block be proc memory_get_integer from MemoryCore with arena, 40  Note: first_block
    While current_block is not equal to 0:
        Let block_size be proc memory_get_integer from MemoryCore with current_block, 8
        Let block_used be proc memory_get_integer from MemoryCore with current_block, 16

        Set total_size to total_size plus block_size
        Set total_capacity to total_capacity plus block_size  Note: For chained blocks, capacity = size
        Set total_usage to total_usage plus block_used
        Set block_count to block_count plus 1

        Set current_block to proc memory_get_integer from MemoryCore with current_block, 24  Note: next
    End While

    Note: Add current position from arena (current block's uncommitted usage)
    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Set total_usage to total_usage plus current_pos

    Note: Set stats fields
    Let dummy1 be proc memory_set_integer from MemoryCore with stats_ptr, 0, total_size
    Let dummy2 be proc memory_set_integer from MemoryCore with stats_ptr, 8, total_capacity
    Let dummy3 be proc memory_set_integer from MemoryCore with stats_ptr, 16, total_usage

    Note: Get total allocated from arena field
    Let total_allocated be proc memory_get_integer from MemoryCore with arena, 72
    Let dummy4 be proc memory_set_integer from MemoryCore with stats_ptr, 24, total_allocated
    Let dummy5 be proc memory_set_integer from MemoryCore with stats_ptr, 40, total_allocated

    Note: Get allocation count
    Let allocation_count be proc memory_get_integer from MemoryCore with arena, 64
    Let dummy6 be proc memory_set_integer from MemoryCore with stats_ptr, 32, allocation_count

    Note: Total freed is 0 for bump allocator (no individual frees)
    Let dummy7 be proc memory_set_integer from MemoryCore with stats_ptr, 48, 0

    Note: Fragmentation is 0 for bump allocator
    Let dummy8 be proc memory_set_integer from MemoryCore with stats_ptr, 56, 0

    Note: Set block count
    Let dummy9 be proc memory_set_integer from MemoryCore with stats_ptr, 64, block_count

    Return stats_ptr
End Process

Process called "arena_reset_stats" takes arena as Integer returns Nothing:
    Note: Reset arena statistics
    Note: Clears all performance counters

    If arena is equal to 0:
        Return
    End If

    Note: Reset allocation count to 0
    Let dummy1 be proc memory_set_integer from MemoryCore with arena, 64, 0

    Note: Reset peak usage to current usage
    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Let dummy2 be proc memory_set_integer from MemoryCore with arena, 72, current_pos

    Note: Note: Other stats are structural and should not be reset
    Note: (memory_block, current_pos, size, capacity remain)

    Return
End Process

Process called "arena_profile" takes arena as Integer returns Integer:
    Note: Profile arena performance across all blocks
    Note: Returns pointer to performance profile data
    Note: Analyzes allocation patterns and efficiency

    If arena is equal to 0:
        Return 0
    End If

    Note: ArenaProfile structure:
    Note: offset 0:  utilization_percentage (8 bytes)
    Note: offset 8:  average_allocation_size (8 bytes)
    Note: offset 16: allocation_efficiency (8 bytes)
    Note: offset 24: memory_waste (8 bytes)
    Note: offset 32: allocation_rate (8 bytes)
    Note: offset 40: block_count (8 bytes)
    Note: offset 48: average_block_utilization (8 bytes)
    Note: Total size: 56 bytes

    Let profile_size be 56
    Let profile_ptr be proc allocate from MemoryUtils with profile_size

    If profile_ptr is equal to 0:
        Return 0
    End If

    Note: Sum across all blocks
    Let total_capacity be 0
    Let total_usage be 0
    Let block_count be 0

    Let current_block be proc memory_get_integer from MemoryCore with arena, 40  Note: first_block
    While current_block is not equal to 0:
        Let block_size be proc memory_get_integer from MemoryCore with current_block, 8
        Let block_used be proc memory_get_integer from MemoryCore with current_block, 16

        Set total_capacity to total_capacity plus block_size
        Set total_usage to total_usage plus block_used
        Set block_count to block_count plus 1

        Set current_block to proc memory_get_integer from MemoryCore with current_block, 24  Note: next
    End While

    Note: Add current position
    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Set total_usage to total_usage plus current_pos

    Note: Calculate utilization percentage
    Let utilization be 0
    If total_capacity is greater than 0:
        Let hundred be 100
        Let numerator be total_usage multiplied by hundred
        Set utilization to numerator divided by total_capacity
    End If

    Let dummy1 be proc memory_set_integer from MemoryCore with profile_ptr, 0, utilization

    Note: Calculate average allocation size
    Let allocation_count be proc memory_get_integer from MemoryCore with arena, 64
    Let average_size be 0
    If allocation_count is greater than 0:
        Set average_size to total_usage divided by allocation_count
    End If

    Let dummy2 be proc memory_set_integer from MemoryCore with profile_ptr, 8, average_size

    Note: Calculate allocation efficiency (100% for bump allocator - no overhead)
    Let hundred be 100
    Let dummy3 be proc memory_set_integer from MemoryCore with profile_ptr, 16, hundred

    Note: Calculate memory waste (unused capacity)
    Let waste be total_capacity minus total_usage
    Let dummy4 be proc memory_set_integer from MemoryCore with profile_ptr, 24, waste

    Note: Allocation rate is allocation count (simple metric)
    Let dummy5 be proc memory_set_integer from MemoryCore with profile_ptr, 32, allocation_count

    Note: Block count
    Let dummy6 be proc memory_set_integer from MemoryCore with profile_ptr, 40, block_count

    Note: Average block utilization
    Let avg_block_util be 0
    If block_count is greater than 0:
        Set avg_block_util to utilization divided by block_count
    End If
    Let dummy7 be proc memory_set_integer from MemoryCore with profile_ptr, 48, avg_block_util

    Return profile_ptr
End Process

Process called "arena_optimize" takes arena as Integer returns Integer:
    Note: Optimize arena for performance by freeing unused blocks
    Note: Returns 1 if successful, 0 if failed
    Note: Removes empty trailing blocks in chain

    If arena is equal to 0:
        Return 0
    End If

    Note: Walk through block chain and find last used block
    Let last_used_block be 0
    Let current_block be proc memory_get_integer from MemoryCore with arena, 40  Note: first_block

    While current_block is not equal to 0:
        Let block_used be proc memory_get_integer from MemoryCore with current_block, 16
        Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
        Let current_arena_block be proc memory_get_integer from MemoryCore with arena, 48

        Note: Check if this block has any data
        If block_used is greater than 0:
            Set last_used_block to current_block
        End If
        Otherwise If current_block is equal to current_arena_block:
            Note: Current block - check current_pos
            If current_pos is greater than 0:
                Set last_used_block to current_block
            End If
        End If

        Set current_block to proc memory_get_integer from MemoryCore with current_block, 24  Note: next
    End While

    Note: If we found a last used block, free all blocks after it
    If last_used_block is not equal to 0:
        Let next_block be proc memory_get_integer from MemoryCore with last_used_block, 24

        Note: Terminate chain at last used block
        Let dummy1 be proc memory_set_integer from MemoryCore with last_used_block, 24, 0

        Note: Free all blocks after last used
        While next_block is not equal to 0:
            Let block_memory be proc memory_get_integer from MemoryCore with next_block, 0
            Let following_block be proc memory_get_integer from MemoryCore with next_block, 24

            Note: Free block memory
            If block_memory is not equal to 0:
                Let dealloc1 be proc deallocate from MemoryUtils with block_memory
            End If

            Note: Free block node
            Let dealloc2 be proc deallocate from MemoryUtils with next_block

            Set next_block to following_block
        End While

        Note: Update arena to use last_used_block as current
        Let last_memory be proc memory_get_integer from MemoryCore with last_used_block, 0
        Let last_size be proc memory_get_integer from MemoryCore with last_used_block, 8
        Let last_used be proc memory_get_integer from MemoryCore with last_used_block, 16

        Let dummy2 be proc memory_set_integer from MemoryCore with arena, 0, last_memory
        Let dummy3 be proc memory_set_integer from MemoryCore with arena, 8, last_used
        Let dummy4 be proc memory_set_integer from MemoryCore with arena, 16, last_size
        Let dummy5 be proc memory_set_integer from MemoryCore with arena, 24, last_size
        Let dummy6 be proc memory_set_integer from MemoryCore with arena, 48, last_used_block

        Return 1
    End If

    Note: No unused blocks to remove
    Return 1
End Process

Process called "arena_benchmark" takes arena as Integer, iterations as Integer returns Integer:
    Note: Benchmark arena performance
    Note: Returns pointer to benchmark results
    Note: Measures allocation and deallocation speed

    If arena is equal to 0:
        Return 0
    End If

    If iterations is less than 1:
        Return 0
    End If

    Note: BenchmarkResults structure:
    Note: offset 0:  allocations_per_second (8 bytes)
    Note: offset 8:  average_allocation_time_ns (8 bytes)
    Note: offset 16: total_time_ns (8 bytes)
    Note: offset 24: iterations_completed (8 bytes)
    Note: Total size: 32 bytes

    Let results_size be 32
    Let results_ptr be proc allocate from MemoryUtils with results_size

    If results_ptr is equal to 0:
        Return 0
    End If

    Note: Get start timestamp
    Let CLOCK_MONOTONIC be 1
    Let timespec_size be 16
    Let timespec_ptr be proc allocate from MemoryUtils with timespec_size

    Let syscall_num be 228
    Let dummy1 be proc syscall_2 from Syscall with syscall_num, CLOCK_MONOTONIC, timespec_ptr

    Let start_sec be proc memory_get_integer from MemoryCore with timespec_ptr, 0
    Let start_nsec be proc memory_get_integer from MemoryCore with timespec_ptr, 8
    Let billion be 1000000000
    Let start_time be start_sec multiplied by billion
    Set start_time to start_time plus start_nsec

    Note: Perform benchmark iterations
    Let test_size be 64
    Let i be 0
    While i is less than iterations:
        Let alloc_ptr be proc arena_allocate with arena, test_size, 8
        Set i to i plus 1
    End While

    Note: Get end timestamp
    Let dummy2 be proc syscall_2 from Syscall with syscall_num, CLOCK_MONOTONIC, timespec_ptr

    Let end_sec be proc memory_get_integer from MemoryCore with timespec_ptr, 0
    Let end_nsec be proc memory_get_integer from MemoryCore with timespec_ptr, 8
    Let end_time be end_sec multiplied by billion
    Set end_time to end_time plus end_nsec

    Note: Calculate results
    Let total_time be end_time minus start_time
    Let dummy3 be proc memory_set_integer from MemoryCore with results_ptr, 16, total_time

    Let average_time be 0
    If iterations is greater than 0:
        Set average_time to total_time divided by iterations
    End If
    Let dummy4 be proc memory_set_integer from MemoryCore with results_ptr, 8, average_time

    Note: Calculate allocations per second
    Let allocs_per_sec be 0
    If total_time is greater than 0:
        Let iterations_times_billion be iterations multiplied by billion
        Set allocs_per_sec to iterations_times_billion divided by total_time
    End If
    Let dummy5 be proc memory_set_integer from MemoryCore with results_ptr, 0, allocs_per_sec

    Let dummy6 be proc memory_set_integer from MemoryCore with results_ptr, 24, iterations

    Note: Reset arena after benchmark
    Let dummy7 be proc arena_reset with arena

    Note: Free timespec
    Let dummy8 be proc deallocate from MemoryUtils with timespec_ptr

    Return results_ptr
End Process

Note: ============================================================================
Note: Arena Debugging Operations
Note: ============================================================================

Process called "arena_validate" takes arena as Integer returns Integer:
    Note: Validate arena integrity
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks for corruption and leaks

    If arena is equal to 0:
        Return 0
    End If

    Note: Check memory block is not null
    Let memory_block be proc memory_get_integer from MemoryCore with arena, 0
    If memory_block is equal to 0:
        Return 0
    End If

    Note: Check current position is within bounds
    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Let capacity be proc memory_get_integer from MemoryCore with arena, 24

    If current_pos is less than 0:
        Return 0
    End If

    If current_pos is greater than capacity:
        Return 0
    End If

    Note: Check size is within capacity
    Let size be proc memory_get_integer from MemoryCore with arena, 16
    If size is greater than capacity:
        Return 0
    End If

    Note: Check allocation count is non-negative
    Let allocation_count be proc memory_get_integer from MemoryCore with arena, 64
    If allocation_count is less than 0:
        Return 0
    End If

    Note: Check peak usage is within capacity
    Let peak_usage be proc memory_get_integer from MemoryCore with arena, 72
    If peak_usage is greater than capacity:
        Return 0
    End If

    Note: All validation checks passed
    Return 1
End Process

Process called "arena_dump" takes arena as Integer returns Integer:
    Note: Dump arena contents for debugging
    Note: Returns pointer to debug information
    Note: Provides detailed arena state

    If arena is equal to 0:
        Return 0
    End If

    Note: ArenaDump structure:
    Note: offset 0:  memory_block_ptr (8 bytes)
    Note: offset 8:  current_position (8 bytes)
    Note: offset 16: size (8 bytes)
    Note: offset 24: capacity (8 bytes)
    Note: offset 32: allocation_count (8 bytes)
    Note: offset 40: peak_usage (8 bytes)
    Note: offset 48: is_valid (8 bytes)
    Note: offset 56: utilization_percent (8 bytes)
    Note: Total size: 64 bytes

    Let dump_size be 64
    Let dump_ptr be proc allocate from MemoryUtils with dump_size

    If dump_ptr is equal to 0:
        Return 0
    End If

    Note: Copy all arena fields to dump structure
    Let memory_block be proc memory_get_integer from MemoryCore with arena, 0
    Let dummy1 be proc memory_set_integer from MemoryCore with dump_ptr, 0, memory_block

    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Let dummy2 be proc memory_set_integer from MemoryCore with dump_ptr, 8, current_pos

    Let size be proc memory_get_integer from MemoryCore with arena, 16
    Let dummy3 be proc memory_set_integer from MemoryCore with dump_ptr, 16, size

    Let capacity be proc memory_get_integer from MemoryCore with arena, 24
    Let dummy4 be proc memory_set_integer from MemoryCore with dump_ptr, 24, capacity

    Let allocation_count be proc memory_get_integer from MemoryCore with arena, 64
    Let dummy5 be proc memory_set_integer from MemoryCore with dump_ptr, 32, allocation_count

    Let peak_usage be proc memory_get_integer from MemoryCore with arena, 72
    Let dummy6 be proc memory_set_integer from MemoryCore with dump_ptr, 40, peak_usage

    Note: Validate arena
    Let is_valid be proc arena_validate with arena
    Let dummy7 be proc memory_set_integer from MemoryCore with dump_ptr, 48, is_valid

    Note: Calculate utilization percentage
    Let utilization be 0
    If capacity is greater than 0:
        Let hundred be 100
        Let numerator be current_pos multiplied by hundred
        Set utilization to numerator divided by capacity
    End If
    Let dummy8 be proc memory_set_integer from MemoryCore with dump_ptr, 56, utilization

    Return dump_ptr
End Process

Process called "arena_trace" takes arena as Integer returns Integer:
    Note: Trace arena allocations
    Note: Returns pointer to allocation trace
    Note: Shows allocation history and patterns

    If arena is equal to 0:
        Return 0
    End If

    Note: AllocationTrace structure:
    Note: offset 0:  total_allocations (8 bytes)
    Note: offset 8:  total_bytes_allocated (8 bytes)
    Note: offset 16: current_allocations (8 bytes)
    Note: offset 24: largest_allocation (8 bytes)
    Note: offset 32: smallest_allocation (8 bytes)
    Note: offset 40: average_allocation_size (8 bytes)
    Note: Total size: 48 bytes

    Let trace_size be 48
    Let trace_ptr be proc allocate from MemoryUtils with trace_size

    If trace_ptr is equal to 0:
        Return 0
    End If

    Note: Get allocation count
    Let allocation_count be proc memory_get_integer from MemoryCore with arena, 64
    Let dummy1 be proc memory_set_integer from MemoryCore with trace_ptr, 0, allocation_count

    Note: Get total bytes allocated (current position)
    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Let dummy2 be proc memory_set_integer from MemoryCore with trace_ptr, 8, current_pos

    Note: Current allocations is allocation count (no individual frees in bump allocator)
    Let dummy3 be proc memory_set_integer from MemoryCore with trace_ptr, 16, allocation_count

    Note: Calculate average allocation size
    Let average_size be 0
    If allocation_count is greater than 0:
        Set average_size to current_pos divided by allocation_count
    End If

    Note: For bump allocator, we don't track individual allocation sizes
    Note: Use average as approximation for largest/smallest
    Let dummy4 be proc memory_set_integer from MemoryCore with trace_ptr, 24, average_size
    Let dummy5 be proc memory_set_integer from MemoryCore with trace_ptr, 32, average_size
    Let dummy6 be proc memory_set_integer from MemoryCore with trace_ptr, 40, average_size

    Return trace_ptr
End Process

Process called "arena_check_leaks" takes arena as Integer returns Integer:
    Note: Check for memory leaks in arena
    Note: Returns number of leaks found
    Note: Identifies unfreed allocations

    If arena is equal to 0:
        Return 0
    End If

    Note: Bump allocators don't have individual deallocation
    Note: Leaks are detected by checking if arena was reset before destruction
    Note: For leak detection, check if allocations exist without reset

    Let allocation_count be proc memory_get_integer from MemoryCore with arena, 64
    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8

    Note: If there are allocations and current position is not zero, potential leak
    If allocation_count is greater than 0:
        If current_pos is greater than 0:
            Note: Return allocation count as number of potential leaks
            Return allocation_count
        End If
    End If

    Note: No leaks detected
    Return 0
End Process

Process called "arena_verify" takes arena as Integer returns Integer:
    Note: Verify arena memory integrity
    Note: Returns 1 if verified, 0 if corrupted
    Note: Checks for buffer overflows and corruption

    If arena is equal to 0:
        Return 0
    End If

    Note: First, validate basic arena structure
    Let is_valid be proc arena_validate with arena
    If is_valid is equal to 0:
        Return 0
    End If

    Note: Check for memory corruption by verifying key invariants
    Let memory_block be proc memory_get_integer from MemoryCore with arena, 0
    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Let size be proc memory_get_integer from MemoryCore with arena, 16
    Let capacity be proc memory_get_integer from MemoryCore with arena, 24

    Note: Verify current_pos <= size <= capacity
    If current_pos is greater than size:
        Return 0
    End If

    If size is greater than capacity:
        Return 0
    End If

    Note: Verify allocation count makes sense
    Let allocation_count be proc memory_get_integer from MemoryCore with arena, 64
    If allocation_count is less than 0:
        Return 0
    End If

    Note: Verify peak usage
    Let peak_usage be proc memory_get_integer from MemoryCore with arena, 72
    If peak_usage is less than current_pos:
        Return 0
    End If

    If peak_usage is greater than capacity:
        Return 0
    End If

    Note: Check memory block alignment (should be 8-byte aligned for x86_64)
    Let alignment_mask be 7
    Let offset be proc bitwise_and from BitwiseCore with memory_block, alignment_mask
    If offset is not equal to 0:
        Note: Memory block is not aligned - potential corruption
        Return 0
    End If

    Note: All verification checks passed
    Return 1
End Process

Note: ============================================================================
Note: ARENA UTILITIES IMPLEMENTATION (TIER 2 Memory Management)
Note: ============================================================================

Note: Arena implementation follows TIER 2 architecture:
Note: - Fast bulk allocation with O(1) cleanup
Note: - Operation-scoped temporaries
Note: - Simple bump pointer allocation
Note: - No individual deallocation - reset entire arena

Note: ============================================================================
Note: Implementation follows - Arena utilities complete
Note: ============================================================================

Note: ============================================================================
Note: MEMORY POOLING ENHANCEMENT (Production Optimization)
Note: ============================================================================

Note: Memory pools for frequently-used allocation sizes
Note: Reduces fragmentation and improves performance for small allocations
Note: Pool size classes: 8, 16, 32, 64, 128, 256 bytes
Note: Each pool maintains a free list for instant O(1) allocation/deallocation

Constant POOL_SIZE_CLASS_COUNT as Integer is 6
Constant POOL_SIZE_8 as Integer is 8
Constant POOL_SIZE_16 as Integer is 16
Constant POOL_SIZE_32 as Integer is 32
Constant POOL_SIZE_64 as Integer is 64
Constant POOL_SIZE_128 as Integer is 128
Constant POOL_SIZE_256 as Integer is 256
Constant POOL_BLOCK_COUNT as Integer is 64

Note: MemoryPool instance structure (TIER 3 OWNED)
Note: Instance-based pool - no globals
Note: Caller creates pool with pool_create, destroys with pool_destroy
Note: Pool structure (per size class):
Note: - free_list: pointer to first free block (linked list)
Note: - total_blocks: total blocks allocated for this pool
Note: - free_blocks: number of blocks currently free
Note: - block_size: size of each block in this pool
Note: - allocations: total allocations served
Note: - deallocations: total deallocations
Note: - batches_list: pointer to first batch node (linked list for cleanup)

Private Process called "pool_get_size_class_index" takes size as Integer returns Integer:
    Note: Get pool size class index for given size
    Note: Returns -1 if size doesn't fit in any pool class
    Note: Returns 0-5 for valid pool classes

    If size is less than or equal to POOL_SIZE_8:
        Return 0
    End If
    Otherwise If size is less than or equal to POOL_SIZE_16:
        Return 1
    End If
    Otherwise If size is less than or equal to POOL_SIZE_32:
        Return 2
    End If
    Otherwise If size is less than or equal to POOL_SIZE_64:
        Return 3
    End If
    Otherwise If size is less than or equal to POOL_SIZE_128:
        Return 4
    End If
    Otherwise If size is less than or equal to POOL_SIZE_256:
        Return 5
    End If

    Return negative 1
End Process

Private Process called "pool_get_size_for_class" takes class_index as Integer returns Integer:
    Note: Get actual block size for pool class index
    Note: Returns 0 if invalid class index

    If class_index is equal to 0:
        Return POOL_SIZE_8
    End If
    Otherwise If class_index is equal to 1:
        Return POOL_SIZE_16
    End If
    Otherwise If class_index is equal to 2:
        Return POOL_SIZE_32
    End If
    Otherwise If class_index is equal to 3:
        Return POOL_SIZE_64
    End If
    Otherwise If class_index is equal to 4:
        Return POOL_SIZE_128
    End If
    Otherwise If class_index is equal to 5:
        Return POOL_SIZE_256
    End If

    Return 0
End Process

Process called "pool_create" returns Integer:
    Note: Create and initialize memory pool instance (TIER 3 OWNED)
    Note: Returns pointer to MemoryPool instance, 0 on failure
    Note: Caller owns pool and must call pool_destroy
    Note: No global state - follows MEMORY_ARCHITECTURE.md

    Note: Allocate pool structure (6 classes * 56 bytes = 336 bytes)
    Note: Each pool entry: free_list(8) + total_blocks(8) + free_blocks(8) + block_size(8) + allocations(8) + deallocations(8) + batches_list(8)
    Let pool_struct_size be 336
    Let pool be proc allocate from MemoryUtils with pool_struct_size

    If pool is equal to 0:
        Return 0
    End If

    Note: Initialize each pool size class
    Let class_index be 0
    While class_index is less than POOL_SIZE_CLASS_COUNT:
        Let pool_entry_offset be class_index multiplied by 56
        Let pool_entry_ptr be pool plus pool_entry_offset

        Note: Get block size for this class
        Let block_size be proc pool_get_size_for_class with class_index

        Note: Initialize pool entry fields
        Let dummy1 be proc memory_set_integer from MemoryCore with pool_entry_ptr, 0, 0             Note: free_list = null
        Let dummy2 be proc memory_set_integer from MemoryCore with pool_entry_ptr, 8, 0             Note: total_blocks = 0
        Let dummy3 be proc memory_set_integer from MemoryCore with pool_entry_ptr, 16, 0            Note: free_blocks = 0
        Let dummy4 be proc memory_set_integer from MemoryCore with pool_entry_ptr, 24, block_size   Note: block_size
        Let dummy5 be proc memory_set_integer from MemoryCore with pool_entry_ptr, 32, 0            Note: allocations = 0
        Let dummy6 be proc memory_set_integer from MemoryCore with pool_entry_ptr, 40, 0            Note: deallocations = 0
        Let dummy7 be proc memory_set_integer from MemoryCore with pool_entry_ptr, 48, 0            Note: batches_list = null

        Set class_index to class_index plus 1
    End While

    Return pool
End Process

Private Process called "pool_allocate_block_batch" takes pool as Integer, class_index as Integer returns Integer:
    Note: Allocate a batch of blocks for the pool
    Note: Returns number of blocks allocated (64 blocks per batch)
    Note: Each block is prepended with 8-byte next pointer for free list
    Note: Tracks batch in batches_list for proper cleanup
    Note: pool is pointer to MemoryPool instance

    If pool is equal to 0:
        Return 0
    End If

    If class_index is less than 0:
        Return 0
    End If

    If class_index is greater than or equal to POOL_SIZE_CLASS_COUNT:
        Return 0
    End If

    Note: Get pool entry
    Let pool_entry_offset be class_index multiplied by 56
    Let pool_entry_ptr be pool plus pool_entry_offset

    Note: Get block size for this class
    Let block_size be proc memory_get_integer from MemoryCore with pool_entry_ptr, 24

    Note: Add 8 bytes for next pointer in free list
    Let actual_block_size be block_size plus 8

    Note: Allocate batch of blocks
    Let batch_size be actual_block_size multiplied by POOL_BLOCK_COUNT
    Let batch_ptr be proc allocate from MemoryUtils with batch_size

    If batch_ptr is equal to 0:
        Return 0
    End If

    Note: Allocate batch tracking node (16 bytes: batch_ptr + next)
    Let batch_node_size be 16
    Let batch_node be proc allocate from MemoryUtils with batch_node_size

    If batch_node is equal to 0:
        Let dummy_free_batch be proc deallocate from MemoryUtils with batch_ptr
        Return 0
    End If

    Note: Initialize batch tracking node
    Let dummy_bn1 be proc memory_set_integer from MemoryCore with batch_node, 0, batch_ptr  Note: batch_ptr
    Let dummy_bn2 be proc memory_set_integer from MemoryCore with batch_node, 8, 0         Note: next = null

    Note: Add batch node to batches_list
    Let old_batches_list be proc memory_get_integer from MemoryCore with pool_entry_ptr, 48
    Let dummy_bn3 be proc memory_set_integer from MemoryCore with batch_node, 8, old_batches_list
    Let dummy_bn4 be proc memory_set_integer from MemoryCore with pool_entry_ptr, 48, batch_node

    Note: Initialize free list by linking all blocks
    Let i be 0
    While i is less than POOL_BLOCK_COUNT:
        Let block_offset be i multiplied by actual_block_size
        Let block_ptr be batch_ptr plus block_offset

        Note: Calculate next block pointer
        Let next_block_ptr be 0
        Let next_i be i plus 1
        If next_i is less than POOL_BLOCK_COUNT:
            Let next_block_offset be next_i multiplied by actual_block_size
            Set next_block_ptr to batch_ptr plus next_block_offset
        End If

        Note: Set next pointer in block (first 8 bytes)
        Let dummy_next be proc memory_set_integer from MemoryCore with block_ptr, 0, next_block_ptr

        Set i to i plus 1
    End While

    Note: Update pool entry to add new blocks to free list
    Let old_free_list be proc memory_get_integer from MemoryCore with pool_entry_ptr, 0
    Let dummy_set_free be proc memory_set_integer from MemoryCore with pool_entry_ptr, 0, batch_ptr

    Note: Link old free list to end of new blocks
    If old_free_list is not equal to 0:
        Note: Find last block in new batch
        Let last_block_offset be POOL_BLOCK_COUNT minus 1
        Set last_block_offset to last_block_offset multiplied by actual_block_size
        Let last_block_ptr be batch_ptr plus last_block_offset

        Note: Link to old free list
        Let dummy_link be proc memory_set_integer from MemoryCore with last_block_ptr, 0, old_free_list
    End If

    Note: Update statistics
    Let old_total_blocks be proc memory_get_integer from MemoryCore with pool_entry_ptr, 8
    Let new_total_blocks be old_total_blocks plus POOL_BLOCK_COUNT
    Let dummy_total be proc memory_set_integer from MemoryCore with pool_entry_ptr, 8, new_total_blocks

    Let old_free_blocks be proc memory_get_integer from MemoryCore with pool_entry_ptr, 16
    Let new_free_blocks be old_free_blocks plus POOL_BLOCK_COUNT
    Let dummy_free be proc memory_set_integer from MemoryCore with pool_entry_ptr, 16, new_free_blocks

    Return POOL_BLOCK_COUNT
End Process

Process called "pool_allocate" takes pool as Integer, size as Integer returns Integer:
    Note: Allocate memory from pool for frequently-used sizes
    Note: Returns pointer to allocated block or 0 if pool cannot serve
    Note: Falls back to 0 if size doesn't match any pool class
    Note: O(1) allocation from free list
    Note: pool is pointer to MemoryPool instance created by pool_create

    If pool is equal to 0:
        Return 0
    End If

    Note: Check if size fits in any pool class
    Let class_index be proc pool_get_size_class_index with size

    If class_index is less than 0:
        Note: Size too large for pooling
        Return 0
    End If

    Note: Get pool entry for this size class
    Let pool_entry_offset be class_index multiplied by 56
    Let pool_entry_ptr be pool plus pool_entry_offset

    Note: Check if free blocks available
    Let free_blocks be proc memory_get_integer from MemoryCore with pool_entry_ptr, 16

    If free_blocks is equal to 0:
        Note: No free blocks, allocate new batch
        Let batch_count be proc pool_allocate_block_batch with pool, class_index

        If batch_count is equal to 0:
            Note: Failed to allocate batch
            Return 0
        End If

        Note: Reload free_blocks after batch allocation
        Set free_blocks to proc memory_get_integer from MemoryCore with pool_entry_ptr, 16
    End If

    Note: Get first block from free list
    Let free_list_head be proc memory_get_integer from MemoryCore with pool_entry_ptr, 0

    If free_list_head is equal to 0:
        Note: Free list is empty (should not happen after batch allocation)
        Return 0
    End If

    Note: Read next pointer from block (first 8 bytes)
    Let next_free_block be proc memory_get_integer from MemoryCore with free_list_head, 0

    Note: Update free list head to next block
    Let dummy_update_head be proc memory_set_integer from MemoryCore with pool_entry_ptr, 0, next_free_block

    Note: Update statistics
    Let new_free_blocks be free_blocks minus 1
    Let dummy_free_count be proc memory_set_integer from MemoryCore with pool_entry_ptr, 16, new_free_blocks

    Let allocations be proc memory_get_integer from MemoryCore with pool_entry_ptr, 32
    Let new_allocations be allocations plus 1
    Let dummy_alloc_count be proc memory_set_integer from MemoryCore with pool_entry_ptr, 32, new_allocations

    Note: Return pointer to usable memory (skip 8-byte header)
    Let usable_ptr be free_list_head plus 8

    Return usable_ptr
End Process

Process called "pool_deallocate" takes pool as Integer, ptr as Integer, size as Integer returns Integer:
    Note: Return memory block to pool
    Note: Returns 1 if successful, 0 if pointer not from pool
    Note: O(1) deallocation - adds block back to free list
    Note: pool is pointer to MemoryPool instance

    If pool is equal to 0:
        Return 0
    End If

    If ptr is equal to 0:
        Return 0
    End If

    Note: Check if size fits in any pool class
    Let class_index be proc pool_get_size_class_index with size

    If class_index is less than 0:
        Note: Size doesn't match any pool class
        Return 0
    End If

    Note: Get pool entry for this size class
    Let pool_entry_offset be class_index multiplied by 56
    Let pool_entry_ptr be pool plus pool_entry_offset

    Note: Get block header pointer (subtract 8 bytes)
    Let block_header_ptr be ptr minus 8

    Note: Get current free list head
    Let free_list_head be proc memory_get_integer from MemoryCore with pool_entry_ptr, 0

    Note: Set next pointer in returned block to current head
    Let dummy_next be proc memory_set_integer from MemoryCore with block_header_ptr, 0, free_list_head

    Note: Update free list head to returned block
    Let dummy_head be proc memory_set_integer from MemoryCore with pool_entry_ptr, 0, block_header_ptr

    Note: Update statistics
    Let free_blocks be proc memory_get_integer from MemoryCore with pool_entry_ptr, 16
    Let new_free_blocks be free_blocks plus 1
    Let dummy_free_count be proc memory_set_integer from MemoryCore with pool_entry_ptr, 16, new_free_blocks

    Let deallocations be proc memory_get_integer from MemoryCore with pool_entry_ptr, 40
    Let new_deallocations be deallocations plus 1
    Let dummy_dealloc_count be proc memory_set_integer from MemoryCore with pool_entry_ptr, 40, new_deallocations

    Return 1
End Process

Process called "pool_get_statistics" takes pool as Integer, class_index as Integer returns Integer:
    Note: Get statistics for specific pool size class
    Note: Returns pointer to statistics structure (56 bytes)
    Note: Caller must copy data if needed, pointer is to internal structure
    Note: pool is pointer to MemoryPool instance

    If pool is equal to 0:
        Return 0
    End If

    If class_index is less than 0:
        Return 0
    End If

    If class_index is greater than or equal to POOL_SIZE_CLASS_COUNT:
        Return 0
    End If

    Note: Return pointer to pool entry (contains all statistics)
    Let pool_entry_offset be class_index multiplied by 56
    Let pool_entry_ptr be pool plus pool_entry_offset

    Return pool_entry_ptr
End Process

Process called "pool_destroy" takes pool as Integer returns Integer:
    Note: Destroy pool and free all memory (TIER 3 OWNED cleanup)
    Note: Frees pool structure - caller no longer owns pool
    Note: WARNING: Invalidates all pointers from pool_allocate
    Note: Returns 1 on success, 0 if pool was null
    Note: Walks through all batches_lists and frees all memory - zero memory leaks

    If pool is equal to 0:
        Return 0
    End If

    Note: Walk through all 6 size classes and free their batches
    Let class_index be 0
    While class_index is less than POOL_SIZE_CLASS_COUNT:
        Let pool_entry_offset be class_index multiplied by 56
        Let pool_entry_ptr be pool plus pool_entry_offset

        Note: Get batches_list for this size class
        Let batches_list be proc memory_get_integer from MemoryCore with pool_entry_ptr, 48

        Note: Walk through batches_list and free all batches
        Let current_batch_node be batches_list
        While current_batch_node is not equal to 0:
            Note: Get batch pointer and next node
            Let batch_ptr be proc memory_get_integer from MemoryCore with current_batch_node, 0
            Let next_batch_node be proc memory_get_integer from MemoryCore with current_batch_node, 8

            Note: Free the actual batch memory
            If batch_ptr is not equal to 0:
                Let dummy_free_batch be proc deallocate from MemoryUtils with batch_ptr
            End If

            Note: Free the batch tracking node
            Let dummy_free_node be proc deallocate from MemoryUtils with current_batch_node

            Note: Move to next batch node
            Set current_batch_node to next_batch_node
        End While

        Set class_index to class_index plus 1
    End While

    Note: Free the pool structure itself
    Let dummy_free_pool be proc deallocate from MemoryUtils with pool

    Return 1
End Process