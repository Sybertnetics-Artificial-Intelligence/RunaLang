Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles arena utility operations for the Runa compiler internal system.

ARENA UTILITIES - Tier 2 Memory Management Engine
- Process arena allocation and arena management operations for compiler temporaries
- Handle arena resizing and arena capacity management for compiler data
- Manage arena operations and arena manipulation utilities for compiler workflows
- Process arena optimization and arena performance utilities for compiler efficiency
- Handle integration with compiler phases for temporary memory allocation

This file is essential because of the following reasons:
- Arena utilities enable efficient memory management for compiler temporaries
- Proper arena handling ensures O(1) cleanup for temporary compiler data
- Arena utilities support all compiler phases that need temporary storage with fast allocation
- Arena-based allocation provides deterministic memory management for compiler operations

This file consists of the following functions/features/operation types:
- Arena creation, destruction, and lifecycle management
- Arena allocation and deallocation operations
- Arena resizing and capacity management
- Arena performance optimization and monitoring
- Integration with compiler phases for temporary memory needs

Dependencies:
- Imports memory_safety.runa for memory safety validation
- Imports debug_utils.runa for arena debugging and diagnostics
- Imports collections.runa for arena data structure management
:End Note

Import "compiler/internal/memory_utils.runa" as MemoryUtils
Import "compiler/internal/memory_safety.runa" as MemorySafety
Import "compiler/internal/debug_utils.runa" as DebugUtils
Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/frontend/primitives/core/bitwise_core.runa" as BitwiseCore
Import "compiler/frontend/primitives/core/syscall_core.runa" as Syscall

Note: ============================================================================
Note: Arena Management Structures
Note: ============================================================================

Type called "Arena":
    memory_block as Integer    Note: Pointer to allocated memory block
    current_pos as Integer     Note: Current position in arena
    size as Integer           Note: Total size of arena
    capacity as Integer        Note: Maximum capacity of arena
    alignment as Integer       Note: Memory alignment requirement
    parent as Integer          Note: Pointer to parent arena (for nested arenas)
    children as Integer        Note: Pointer to list of child arenas
    is_active as Integer       Note: Boolean: 1 if arena is active
    allocation_count as Integer Note: Number of allocations made
    peak_usage as Integer      Note: Peak memory usage in arena

Type called "ArenaAllocation":
    arena as Integer          Note: Pointer to parent arena
    memory_ptr as Integer     Note: Pointer to allocated memory
    size as Integer           Note: Size of allocation
    alignment as Integer       Note: Alignment of allocation
    is_freed as Integer       Note: Boolean: 1 if allocation is freed
    next as Integer           Note: Pointer to next allocation in chain

Type called "ArenaStats":
    total_allocations as Integer Note: Total number of allocations
    total_bytes as Integer     Note: Total bytes allocated
    peak_usage as Integer      Note: Peak memory usage
    fragmentation as Integer   Note: Memory fragmentation percentage
    allocation_time as Integer Note: Time spent on allocations
    deallocation_time as Integer Note: Time spent on deallocations

Note: ============================================================================
Note: Arena Constants
Note: ============================================================================

Define constant ARENA_DEFAULT_SIZE as 65536
Define constant ARENA_MIN_SIZE as 4096
Define constant ARENA_MAX_SIZE as 1073741824
Define constant ARENA_ALIGNMENT as 8
Define constant ARENA_GROWTH_FACTOR as 2
Define constant ARENA_SHRINK_THRESHOLD as 4

Define constant ARENA_ALLOCATION_SUCCESS as 0
Define constant ARENA_ALLOCATION_FAILED as -1
Define constant ARENA_ALLOCATION_OVERFLOW as -2
Define constant ARENA_ALLOCATION_INVALID as -3

Note: ============================================================================
Note: Arena Creation and Destruction
Note: ============================================================================

Process called "arena_create" takes initial_size as Integer, alignment as Integer returns Integer:
    Note: Create new arena with specified size and alignment
    Note: Returns pointer to Arena structure
    Note: Initializes arena with default settings

    Note: Validate size
    Let size_to_use be initial_size
    If size_to_use is less than ARENA_MIN_SIZE:
        Set size_to_use to ARENA_MIN_SIZE
    End If
    If size_to_use is greater than ARENA_MAX_SIZE:
        Set size_to_use to ARENA_MAX_SIZE
    End If

    Note: Validate alignment (must be power of 2)
    Let alignment_to_use be alignment
    If alignment_to_use is less than ARENA_ALIGNMENT:
        Set alignment_to_use to ARENA_ALIGNMENT
    End If

    Note: Allocate Arena structure (10 fields * 8 bytes = 80 bytes)
    Let arena_struct_size be 80
    Let arena_ptr be proc allocate from MemoryUtils with arena_struct_size
    If arena_ptr is equal to 0:
        Return 0
    End If

    Note: Allocate memory block for arena
    Let memory_block be proc allocate from MemoryUtils with size_to_use
    If memory_block is equal to 0:
        Let dealloc_result be proc deallocate from MemoryUtils with arena_ptr
        Return 0
    End If

    Note: Initialize Arena structure fields
    Let dummy1 be proc memory_set_integer from MemoryCore with arena_ptr, 0, memory_block    Note: memory_block
    Let dummy2 be proc memory_set_integer from MemoryCore with arena_ptr, 8, 0              Note: current_pos = 0
    Let dummy3 be proc memory_set_integer from MemoryCore with arena_ptr, 16, size_to_use   Note: size
    Let dummy4 be proc memory_set_integer from MemoryCore with arena_ptr, 24, size_to_use   Note: capacity
    Let dummy5 be proc memory_set_integer from MemoryCore with arena_ptr, 32, alignment_to_use Note: alignment
    Let dummy6 be proc memory_set_integer from MemoryCore with arena_ptr, 40, 0             Note: parent = null
    Let dummy7 be proc memory_set_integer from MemoryCore with arena_ptr, 48, 0             Note: children = null
    Let dummy8 be proc memory_set_integer from MemoryCore with arena_ptr, 56, 1             Note: is_active = true
    Let dummy9 be proc memory_set_integer from MemoryCore with arena_ptr, 64, 0             Note: allocation_count = 0
    Let dummy10 be proc memory_set_integer from MemoryCore with arena_ptr, 72, 0            Note: peak_usage = 0

    Return arena_ptr
End Process

Process called "arena_destroy" takes arena as Integer returns Nothing:
    Note: Destroy arena and free all associated memory
    Note: Frees all allocations in arena
    Note: Validates memory safety before destruction

    If arena is equal to 0:
        Return
    End If

    Note: Validate arena pointer
    Let is_valid be proc memory_is_valid_pointer from MemorySafety with arena
    If is_valid is equal to 0:
        Return
    End If

    Note: Mark arena as inactive
    Let dummy1 be proc memory_set_integer from MemoryCore with arena, 56, 0  Note: is_active = false

    Note: Get memory block pointer
    Let memory_block be proc memory_get_integer from MemoryCore with arena, 0

    Note: Free memory block
    If memory_block is not equal to 0:
        Let dealloc1 be proc deallocate from MemoryUtils with memory_block
    End If

    Note: Free arena structure itself
    Let dealloc2 be proc deallocate from MemoryUtils with arena

    Return
End Process

Process called "arena_reset" takes arena as Integer returns Integer:
    Note: Reset arena to initial state
    Note: Returns 1 if successful, 0 if failed
    Note: Frees all allocations but keeps arena structure

    If arena is equal to 0:
        Return 0
    End If

    Note: Check if arena is active
    Let is_active be proc memory_get_integer from MemoryCore with arena, 56
    If is_active is equal to 0:
        Return 0
    End If

    Note: Reset current position to 0
    Let dummy1 be proc memory_set_integer from MemoryCore with arena, 8, 0

    Note: Reset allocation count
    Let dummy2 be proc memory_set_integer from MemoryCore with arena, 64, 0

    Note: Zero the memory block for security
    Let memory_block be proc memory_get_integer from MemoryCore with arena, 0
    Let size be proc memory_get_integer from MemoryCore with arena, 16
    Let dummy3 be proc memory_zero from MemoryCore with memory_block, size

    Return 1
End Process

Process called "arena_clear" takes arena as Integer returns Integer:
    Note: Clear arena and reset position
    Note: Returns 1 if successful, 0 if failed
    Note: Does not free arena memory, just resets position

    If arena is equal to 0:
        Return 0
    End If

    Note: Check if arena is active
    Let is_active be proc memory_get_integer from MemoryCore with arena, 56
    If is_active is equal to 0:
        Return 0
    End If

    Note: Reset current position to 0 (but don't zero memory)
    Let dummy1 be proc memory_set_integer from MemoryCore with arena, 8, 0

    Note: Reset allocation count
    Let dummy2 be proc memory_set_integer from MemoryCore with arena, 64, 0

    Return 1
End Process

Process called "arena_clone" takes source_arena as Integer returns Integer:
    Note: Create copy of arena
    Note: Returns pointer to new Arena structure
    Note: Copies all allocations and settings

    If source_arena is equal to 0:
        Return 0
    End If

    Note: Get source arena properties
    Let size be proc memory_get_integer from MemoryCore with source_arena, 16
    Let alignment be proc memory_get_integer from MemoryCore with source_arena, 32

    Note: Create new arena with same properties
    Let new_arena be proc arena_create with size, alignment
    If new_arena is equal to 0:
        Return 0
    End If

    Note: Get source memory block and current position
    Let src_memory_block be proc memory_get_integer from MemoryCore with source_arena, 0
    Let current_pos be proc memory_get_integer from MemoryCore with source_arena, 8

    Note: Get destination memory block
    Let dst_memory_block be proc memory_get_integer from MemoryCore with new_arena, 0

    Note: Copy memory contents up to current position
    If current_pos is greater than 0:
        Let dummy1 be proc memory_copy from MemoryCore with dst_memory_block, src_memory_block, current_pos
    End If

    Note: Set current position in new arena
    Let dummy2 be proc memory_set_integer from MemoryCore with new_arena, 8, current_pos

    Note: Copy allocation count
    Let allocation_count be proc memory_get_integer from MemoryCore with source_arena, 64
    Let dummy3 be proc memory_set_integer from MemoryCore with new_arena, 64, allocation_count

    Note: Copy peak usage
    Let peak_usage be proc memory_get_integer from MemoryCore with source_arena, 72
    Let dummy4 be proc memory_set_integer from MemoryCore with new_arena, 72, peak_usage

    Return new_arena
End Process

Note: ============================================================================
Note: Arena Allocation Operations
Note: ============================================================================

Process called "arena_allocate" takes arena as Integer, size as Integer, alignment as Integer returns Integer:
    Note: Allocate memory from arena
    Note: Returns pointer to allocated memory or 0 if failed
    Note: Handles alignment requirements
    Note: This is the CORE arena allocation function - bump allocator pattern

    If arena is equal to 0:
        Return 0
    End If

    If size is equal to 0:
        Return 0
    End If

    Note: Check if arena is active
    Let is_active be proc memory_get_integer from MemoryCore with arena, 56
    If is_active is equal to 0:
        Return 0
    End If

    Note: Get current position and memory block
    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Let memory_block be proc memory_get_integer from MemoryCore with arena, 0

    Note: Align current position if needed
    Let aligned_pos be current_pos
    If alignment is greater than 1:
        Let mask be alignment minus 1
        Let offset be current_pos bitwise and mask
        If offset is not equal to 0:
            Let padding be alignment minus offset
            Set aligned_pos to current_pos plus padding
        End If
    End If

    Note: Calculate new position after allocation
    Let new_pos be aligned_pos plus size

    Note: Check if we have enough space
    Let capacity be proc memory_get_integer from MemoryCore with arena, 24
    If new_pos is greater than capacity:
        Return 0  Note: Out of arena space
    End If

    Note: Calculate pointer to allocated memory
    Let alloc_ptr be memory_block plus aligned_pos

    Note: Update current position
    Let dummy1 be proc memory_set_integer from MemoryCore with arena, 8, new_pos

    Note: Increment allocation count
    Let allocation_count be proc memory_get_integer from MemoryCore with arena, 64
    Let new_count be allocation_count plus 1
    Let dummy2 be proc memory_set_integer from MemoryCore with arena, 64, new_count

    Note: Update peak usage if needed
    Let peak_usage be proc memory_get_integer from MemoryCore with arena, 72
    If new_pos is greater than peak_usage:
        Let dummy3 be proc memory_set_integer from MemoryCore with arena, 72, new_pos
    End If

    Return alloc_ptr
End Process

Process called "arena_allocate_aligned" takes arena as Integer, size as Integer, alignment as Integer returns Integer:
    Note: Allocate aligned memory from arena
    Note: Returns pointer to aligned memory or 0 if failed
    Note: Ensures proper alignment for performance

    Note: This is just an alias for arena_allocate with explicit alignment
    Let result be proc arena_allocate with arena, size, alignment
    Return result
End Process

Process called "arena_allocate_zeroed" takes arena as Integer, size as Integer returns Integer:
    Note: Allocate zero-initialized memory from arena
    Note: Returns pointer to zeroed memory or 0 if failed
    Note: All memory is initialized to zero

    Note: Get arena alignment
    Let alignment be ARENA_ALIGNMENT
    If arena is not equal to 0:
        Set alignment to proc memory_get_integer from MemoryCore with arena, 32
    End If

    Note: Allocate memory
    Let alloc_ptr be proc arena_allocate with arena, size, alignment
    If alloc_ptr is equal to 0:
        Return 0
    End If

    Note: Zero the allocated memory
    Let dummy be proc memory_zero from MemoryCore with alloc_ptr, size

    Return alloc_ptr
End Process

Process called "arena_allocate_array" takes arena as Integer, element_size as Integer, count as Integer returns Integer:
    Note: Allocate array from arena
    Note: Returns pointer to array memory or 0 if failed
    Note: Handles array alignment and sizing

    Note: Calculate total size
    Let total_size be element_size multiplied by count

    Note: Use element size as alignment (up to 16 bytes)
    Let alignment be element_size
    If alignment is greater than 16:
        Set alignment to 16
    End If

    Note: Allocate array memory
    Let result be proc arena_allocate with arena, total_size, alignment
    Return result
End Process

Process called "arena_allocate_string" takes arena as Integer, length as Integer returns Integer:
    Note: Allocate string buffer from arena
    Note: Returns pointer to string buffer or 0 if failed
    Note: Includes null terminator space

    Note: Add 1 for null terminator
    Let buffer_size be length plus 1

    Note: Strings use 1-byte alignment
    Let result be proc arena_allocate with arena, buffer_size, 1
    Return result
End Process

Process called "arena_allocate_struct" takes arena as Integer, struct_size as Integer returns Integer:
    Note: Allocate structure from arena
    Note: Returns pointer to structure or 0 if failed
    Note: Handles structure alignment

    Note: Structures use 8-byte alignment
    Let alignment be 8

    Let result be proc arena_allocate with arena, struct_size, alignment
    Return result
End Process

Note: ============================================================================
Note: Arena Memory Management
Note: ============================================================================

Process called "arena_resize" takes arena as Integer, new_size as Integer returns Integer:
    Note: DISABLED - Arena resize invalidates all existing pointers (memory corruption)
    Note: Bump allocators cannot be resized without invalidating all pointers
    Note: Proper solution: Create arena with sufficient size or create new arena
    Note: This function always returns 0 to prevent memory corruption

    If arena is equal to 0:
        Return 0
    End If

    Note: CRITICAL: Resizing arena changes memory_block address which invalidates
    Note: ALL pointers returned by arena_allocate. This causes use-after-free bugs.
    Note: Example broken flow:
    Note:   ptr1 = arena_allocate(arena, 100)  // ptr1 = base + 0
    Note:   arena_resize(arena, larger_size)   // base changes!
    Note:   *ptr1 = 42                         // CRASH: ptr1 now points to freed memory
    Note:
    Note: Arenas are for O(1) bulk deallocation, NOT dynamic resizing.
    Note: If more space needed: estimate size upfront or create new arena.

    Return 0  Note: Always fail - function is unsafe and should not be used
End Process

Process called "arena_grow" takes arena as Integer, growth_size as Integer returns Integer:
    Note: Grow arena by specified amount
    Note: Returns 1 if successful, 0 if failed
    Note: Uses growth factor for efficient resizing

    If arena is equal to 0:
        Return 0
    End If

    Note: Get current size
    Let current_size be proc memory_get_integer from MemoryCore with arena, 16

    Note: Calculate new size
    Let new_size be current_size plus growth_size

    Note: Resize to new size
    Let result be proc arena_resize with arena, new_size
    Return result
End Process

Process called "arena_shrink" takes arena as Integer returns Integer:
    Note: Shrink arena to fit current usage
    Note: Returns 1 if successful, 0 if failed
    Note: Reduces memory usage while preserving allocations

    If arena is equal to 0:
        Return 0
    End If

    Note: Get current position (this is the minimum size needed)
    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8

    Note: Add some headroom (10% or min 4KB)
    Let headroom be current_pos divided by 10
    If headroom is less than 4096:
        Set headroom to 4096
    End If

    Let new_size be current_pos plus headroom

    Note: Resize to fit
    Let result be proc arena_resize with arena, new_size
    Return result
End Process

Process called "arena_compact" takes arena as Integer returns Integer:
    Note: Compact arena to reduce fragmentation
    Note: Returns 1 if successful, 0 if failed
    Note: Moves allocations to reduce gaps
    Note: For bump allocator, this is a no-op (no fragmentation in linear allocation)

    If arena is equal to 0:
        Return 0
    End If

    Note: Bump allocators don't fragment - allocations are contiguous
    Note: Compaction is not needed and would be harmful
    Return 1
End Process

Process called "arena_merge" takes arena1 as Integer, arena2 as Integer returns Integer:
    Note: Merge two arenas into one
    Note: Returns pointer to merged arena or 0 if failed
    Note: Combines allocations from both arenas

    If arena1 is equal to 0:
        Return 0
    End If

    If arena2 is equal to 0:
        Return 0
    End If

    Note: Get sizes and positions
    Let size1 be proc memory_get_integer from MemoryCore with arena1, 16
    Let pos1 be proc memory_get_integer from MemoryCore with arena1, 8
    Let size2 be proc memory_get_integer from MemoryCore with arena2, 16
    Let pos2 be proc memory_get_integer from MemoryCore with arena2, 8

    Note: Calculate merged size
    Let merged_size be pos1 plus pos2

    Note: Get alignment (use max of both)
    Let align1 be proc memory_get_integer from MemoryCore with arena1, 32
    Let align2 be proc memory_get_integer from MemoryCore with arena2, 32
    Let merged_alignment be align1
    If align2 is greater than align1:
        Set merged_alignment to align2
    End If

    Note: Create new merged arena
    Let merged_arena be proc arena_create with merged_size, merged_alignment
    If merged_arena is equal to 0:
        Return 0
    End If

    Note: Get memory blocks
    Let block1 be proc memory_get_integer from MemoryCore with arena1, 0
    Let block2 be proc memory_get_integer from MemoryCore with arena2, 0
    Let merged_block be proc memory_get_integer from MemoryCore with merged_arena, 0

    Note: Copy data from first arena
    If pos1 is greater than 0:
        Let dummy1 be proc memory_copy from MemoryCore with merged_block, block1, pos1
    End If

    Note: Copy data from second arena
    If pos2 is greater than 0:
        Let dest_offset be pos1
        Let dest_ptr be merged_block plus dest_offset
        Let dummy2 be proc memory_copy from MemoryCore with dest_ptr, block2, pos2
    End If

    Note: Update merged arena position
    Let final_pos be pos1 plus pos2
    Let dummy3 be proc memory_set_integer from MemoryCore with merged_arena, 8, final_pos

    Return merged_arena
End Process

Note: ============================================================================
Note: Arena Query Operations
Note: ============================================================================

Process called "arena_get_size" takes arena as Integer returns Integer:
    Note: Get current size of arena
    Note: Returns size in bytes

    If arena is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with arena, 16
    Return size
End Process

Process called "arena_get_capacity" takes arena as Integer returns Integer:
    Note: Get capacity of arena
    Note: Returns capacity in bytes

    If arena is equal to 0:
        Return 0
    End If

    Let capacity be proc memory_get_integer from MemoryCore with arena, 24
    Return capacity
End Process

Process called "arena_get_usage" takes arena as Integer returns Integer:
    Note: Get current usage of arena
    Note: Returns usage in bytes

    If arena is equal to 0:
        Return 0
    End If

    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Return current_pos
End Process

Process called "arena_get_peak_usage" takes arena as Integer returns Integer:
    Note: Get peak usage of arena
    Note: Returns peak usage in bytes

    If arena is equal to 0:
        Return 0
    End If

    Let peak_usage be proc memory_get_integer from MemoryCore with arena, 72
    Return peak_usage
End Process

Process called "arena_get_fragmentation" takes arena as Integer returns Integer:
    Note: Get fragmentation percentage of arena
    Note: Returns fragmentation as percentage (0-100)
    Note: Bump allocators don't fragment - always returns 0

    If arena is equal to 0:
        Return 0
    End If

    Note: Bump allocators allocate linearly - no fragmentation
    Return 0
End Process

Process called "arena_get_allocation_count" takes arena as Integer returns Integer:
    Note: Get number of allocations in arena
    Note: Returns allocation count

    If arena is equal to 0:
        Return 0
    End If

    Let allocation_count be proc memory_get_integer from MemoryCore with arena, 64
    Return allocation_count
End Process

Process called "arena_is_full" takes arena as Integer returns Integer:
    Note: Check if arena is full
    Note: Returns 1 if full, 0 if not full

    If arena is equal to 0:
        Return 1
    End If

    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Let capacity be proc memory_get_integer from MemoryCore with arena, 24

    If current_pos is greater than or equal to capacity:
        Return 1
    End If

    Return 0
End Process

Process called "arena_has_space" takes arena as Integer, size as Integer returns Integer:
    Note: Check if arena has space for allocation
    Note: Returns 1 if has space, 0 if not

    If arena is equal to 0:
        Return 0
    End If

    If size is equal to 0:
        Return 1
    End If

    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Let capacity be proc memory_get_integer from MemoryCore with arena, 24

    Let space_remaining be capacity minus current_pos

    If space_remaining is greater than or equal to size:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Arena Performance Operations
Note: ============================================================================

Process called "arena_get_stats" takes arena as Integer returns Integer:
    Note: Get arena statistics
    Note: Returns pointer to ArenaStats structure
    Note: Provides detailed performance metrics

    If arena is equal to 0:
        Return 0
    End If

    Note: ArenaStats structure:
    Note: offset 0:  current_size (8 bytes)
    Note: offset 8:  capacity (8 bytes)
    Note: offset 16: current_usage (8 bytes)
    Note: offset 24: peak_usage (8 bytes)
    Note: offset 32: allocation_count (8 bytes)
    Note: offset 40: total_allocated (8 bytes)
    Note: offset 48: total_freed (8 bytes)
    Note: offset 56: fragmentation (8 bytes)
    Note: Total size: 64 bytes

    Let stats_size be 64
    Let stats_ptr be proc allocate from MemoryUtils with stats_size

    If stats_ptr is equal to 0:
        Return 0
    End If

    Note: Get current size
    Let size be proc memory_get_integer from MemoryCore with arena, 16
    Let dummy1 be proc memory_set_integer from MemoryCore with stats_ptr, 0, size

    Note: Get capacity
    Let capacity be proc memory_get_integer from MemoryCore with arena, 24
    Let dummy2 be proc memory_set_integer from MemoryCore with stats_ptr, 8, capacity

    Note: Get current usage (current position)
    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Let dummy3 be proc memory_set_integer from MemoryCore with stats_ptr, 16, current_pos

    Note: Get peak usage
    Let peak_usage be proc memory_get_integer from MemoryCore with arena, 72
    Let dummy4 be proc memory_set_integer from MemoryCore with stats_ptr, 24, peak_usage

    Note: Get allocation count
    Let allocation_count be proc memory_get_integer from MemoryCore with arena, 64
    Let dummy5 be proc memory_set_integer from MemoryCore with stats_ptr, 32, allocation_count

    Note: Total allocated is current usage
    Let dummy6 be proc memory_set_integer from MemoryCore with stats_ptr, 40, current_pos

    Note: Total freed is 0 for bump allocator (no individual frees)
    Let dummy7 be proc memory_set_integer from MemoryCore with stats_ptr, 48, 0

    Note: Fragmentation is 0 for bump allocator
    Let dummy8 be proc memory_set_integer from MemoryCore with stats_ptr, 56, 0

    Return stats_ptr
End Process

Process called "arena_reset_stats" takes arena as Integer returns Nothing:
    Note: Reset arena statistics
    Note: Clears all performance counters

    If arena is equal to 0:
        Return
    End If

    Note: Reset allocation count to 0
    Let dummy1 be proc memory_set_integer from MemoryCore with arena, 64, 0

    Note: Reset peak usage to current usage
    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Let dummy2 be proc memory_set_integer from MemoryCore with arena, 72, current_pos

    Note: Note: Other stats are structural and should not be reset
    Note: (memory_block, current_pos, size, capacity remain)

    Return
End Process

Process called "arena_profile" takes arena as Integer returns Integer:
    Note: Profile arena performance
    Note: Returns pointer to performance profile data
    Note: Analyzes allocation patterns and efficiency

    If arena is equal to 0:
        Return 0
    End If

    Note: ArenaProfile structure:
    Note: offset 0:  utilization_percentage (8 bytes)
    Note: offset 8:  average_allocation_size (8 bytes)
    Note: offset 16: allocation_efficiency (8 bytes)
    Note: offset 24: memory_waste (8 bytes)
    Note: offset 32: allocation_rate (8 bytes)
    Note: Total size: 40 bytes

    Let profile_size be 40
    Let profile_ptr be proc allocate from MemoryUtils with profile_size

    If profile_ptr is equal to 0:
        Return 0
    End If

    Note: Calculate utilization percentage
    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Let capacity be proc memory_get_integer from MemoryCore with arena, 24

    Let utilization be 0
    If capacity is greater than 0:
        Let hundred be 100
        Let numerator be current_pos multiplied by hundred
        Set utilization to numerator divided by capacity
    End If

    Let dummy1 be proc memory_set_integer from MemoryCore with profile_ptr, 0, utilization

    Note: Calculate average allocation size
    Let allocation_count be proc memory_get_integer from MemoryCore with arena, 64
    Let average_size be 0
    If allocation_count is greater than 0:
        Set average_size to current_pos divided by allocation_count
    End If

    Let dummy2 be proc memory_set_integer from MemoryCore with profile_ptr, 8, average_size

    Note: Calculate allocation efficiency (100% for bump allocator - no overhead)
    Let hundred be 100
    Let dummy3 be proc memory_set_integer from MemoryCore with profile_ptr, 16, hundred

    Note: Calculate memory waste (unused capacity)
    Let waste be capacity minus current_pos
    Let dummy4 be proc memory_set_integer from MemoryCore with profile_ptr, 24, waste

    Note: Allocation rate is allocation count (simple metric)
    Let dummy5 be proc memory_set_integer from MemoryCore with profile_ptr, 32, allocation_count

    Return profile_ptr
End Process

Process called "arena_optimize" takes arena as Integer returns Integer:
    Note: Optimize arena for performance
    Note: Returns 1 if successful, 0 if failed
    Note: Applies performance optimizations

    If arena is equal to 0:
        Return 0
    End If

    Note: For bump allocators, optimization is compaction
    Note: Compact the arena to remove wasted space

    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Let capacity be proc memory_get_integer from MemoryCore with arena, 24

    Note: If arena is less than 25% utilized, consider shrinking
    Let quarter_capacity be capacity divided by 4
    If current_pos is less than quarter_capacity:
        Note: Shrink to double the current usage (give some headroom)
        Let new_capacity be current_pos multiplied by 2

        Note: Ensure minimum capacity of 1024 bytes
        Let min_capacity be 1024
        If new_capacity is less than min_capacity:
            Set new_capacity to min_capacity
        End If

        Note: Don't shrink if new capacity would be same or larger
        If new_capacity is greater than or equal to capacity:
            Return 1
        End If

        Let memory_block be proc memory_get_integer from MemoryCore with arena, 0

        Note: Use mremap to shrink the memory mapping
        Note: mremap(addr, old_len, new_len, flags)
        Note: syscall number 25 on x86_64 Linux
        Let MREMAP_MAYMOVE be 1
        Let syscall_num be 25

        Let new_addr be proc syscall_4 from Syscall with syscall_num, memory_block, capacity, new_capacity, MREMAP_MAYMOVE

        Note: Check if mremap failed (returns -1 or addresses close to -1)
        Let max_error be 0
        Let error_threshold be max_error minus 4096
        If new_addr is greater than error_threshold:
            Note: mremap failed, cannot optimize
            Return 0
        End If

        Note: mremap succeeded - update arena structure
        Let dummy1 be proc memory_set_integer from MemoryCore with arena, 0, new_addr
        Let dummy2 be proc memory_set_integer from MemoryCore with arena, 24, new_capacity
        Let dummy3 be proc memory_set_integer from MemoryCore with arena, 16, new_capacity

        Note: Ensure peak usage doesn't exceed new capacity
        Let peak_usage be proc memory_get_integer from MemoryCore with arena, 72
        If peak_usage is greater than new_capacity:
            Let dummy4 be proc memory_set_integer from MemoryCore with arena, 72, new_capacity
        End If

        Return 1
    End If

    Note: Already optimized or too full to shrink
    Return 1
End Process

Process called "arena_benchmark" takes arena as Integer, iterations as Integer returns Integer:
    Note: Benchmark arena performance
    Note: Returns pointer to benchmark results
    Note: Measures allocation and deallocation speed

    If arena is equal to 0:
        Return 0
    End If

    If iterations is less than 1:
        Return 0
    End If

    Note: BenchmarkResults structure:
    Note: offset 0:  allocations_per_second (8 bytes)
    Note: offset 8:  average_allocation_time_ns (8 bytes)
    Note: offset 16: total_time_ns (8 bytes)
    Note: offset 24: iterations_completed (8 bytes)
    Note: Total size: 32 bytes

    Let results_size be 32
    Let results_ptr be proc allocate from MemoryUtils with results_size

    If results_ptr is equal to 0:
        Return 0
    End If

    Note: Get start timestamp
    Let CLOCK_MONOTONIC be 1
    Let timespec_size be 16
    Let timespec_ptr be proc allocate from MemoryUtils with timespec_size

    Let syscall_num be 228
    Let dummy1 be proc syscall_2 from Syscall with syscall_num, CLOCK_MONOTONIC, timespec_ptr

    Let start_sec be proc memory_get_integer from MemoryCore with timespec_ptr, 0
    Let start_nsec be proc memory_get_integer from MemoryCore with timespec_ptr, 8
    Let billion be 1000000000
    Let start_time be start_sec multiplied by billion
    Set start_time to start_time plus start_nsec

    Note: Perform benchmark iterations
    Let test_size be 64
    Let i be 0
    While i is less than iterations:
        Let alloc_ptr be proc arena_allocate with arena, test_size, 8
        Set i to i plus 1
    End While

    Note: Get end timestamp
    Let dummy2 be proc syscall_2 from Syscall with syscall_num, CLOCK_MONOTONIC, timespec_ptr

    Let end_sec be proc memory_get_integer from MemoryCore with timespec_ptr, 0
    Let end_nsec be proc memory_get_integer from MemoryCore with timespec_ptr, 8
    Let end_time be end_sec multiplied by billion
    Set end_time to end_time plus end_nsec

    Note: Calculate results
    Let total_time be end_time minus start_time
    Let dummy3 be proc memory_set_integer from MemoryCore with results_ptr, 16, total_time

    Let average_time be 0
    If iterations is greater than 0:
        Set average_time to total_time divided by iterations
    End If
    Let dummy4 be proc memory_set_integer from MemoryCore with results_ptr, 8, average_time

    Note: Calculate allocations per second
    Let allocs_per_sec be 0
    If total_time is greater than 0:
        Let iterations_times_billion be iterations multiplied by billion
        Set allocs_per_sec to iterations_times_billion divided by total_time
    End If
    Let dummy5 be proc memory_set_integer from MemoryCore with results_ptr, 0, allocs_per_sec

    Let dummy6 be proc memory_set_integer from MemoryCore with results_ptr, 24, iterations

    Note: Reset arena after benchmark
    Let dummy7 be proc arena_reset with arena

    Note: Free timespec
    Let dummy8 be proc deallocate from MemoryUtils with timespec_ptr

    Return results_ptr
End Process

Note: ============================================================================
Note: Arena Debugging Operations
Note: ============================================================================

Process called "arena_validate" takes arena as Integer returns Integer:
    Note: Validate arena integrity
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks for corruption and leaks

    If arena is equal to 0:
        Return 0
    End If

    Note: Check memory block is not null
    Let memory_block be proc memory_get_integer from MemoryCore with arena, 0
    If memory_block is equal to 0:
        Return 0
    End If

    Note: Check current position is within bounds
    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Let capacity be proc memory_get_integer from MemoryCore with arena, 24

    If current_pos is less than 0:
        Return 0
    End If

    If current_pos is greater than capacity:
        Return 0
    End If

    Note: Check size is within capacity
    Let size be proc memory_get_integer from MemoryCore with arena, 16
    If size is greater than capacity:
        Return 0
    End If

    Note: Check allocation count is non-negative
    Let allocation_count be proc memory_get_integer from MemoryCore with arena, 64
    If allocation_count is less than 0:
        Return 0
    End If

    Note: Check peak usage is within capacity
    Let peak_usage be proc memory_get_integer from MemoryCore with arena, 72
    If peak_usage is greater than capacity:
        Return 0
    End If

    Note: All validation checks passed
    Return 1
End Process

Process called "arena_dump" takes arena as Integer returns Integer:
    Note: Dump arena contents for debugging
    Note: Returns pointer to debug information
    Note: Provides detailed arena state

    If arena is equal to 0:
        Return 0
    End If

    Note: ArenaDump structure:
    Note: offset 0:  memory_block_ptr (8 bytes)
    Note: offset 8:  current_position (8 bytes)
    Note: offset 16: size (8 bytes)
    Note: offset 24: capacity (8 bytes)
    Note: offset 32: allocation_count (8 bytes)
    Note: offset 40: peak_usage (8 bytes)
    Note: offset 48: is_valid (8 bytes)
    Note: offset 56: utilization_percent (8 bytes)
    Note: Total size: 64 bytes

    Let dump_size be 64
    Let dump_ptr be proc allocate from MemoryUtils with dump_size

    If dump_ptr is equal to 0:
        Return 0
    End If

    Note: Copy all arena fields to dump structure
    Let memory_block be proc memory_get_integer from MemoryCore with arena, 0
    Let dummy1 be proc memory_set_integer from MemoryCore with dump_ptr, 0, memory_block

    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Let dummy2 be proc memory_set_integer from MemoryCore with dump_ptr, 8, current_pos

    Let size be proc memory_get_integer from MemoryCore with arena, 16
    Let dummy3 be proc memory_set_integer from MemoryCore with dump_ptr, 16, size

    Let capacity be proc memory_get_integer from MemoryCore with arena, 24
    Let dummy4 be proc memory_set_integer from MemoryCore with dump_ptr, 24, capacity

    Let allocation_count be proc memory_get_integer from MemoryCore with arena, 64
    Let dummy5 be proc memory_set_integer from MemoryCore with dump_ptr, 32, allocation_count

    Let peak_usage be proc memory_get_integer from MemoryCore with arena, 72
    Let dummy6 be proc memory_set_integer from MemoryCore with dump_ptr, 40, peak_usage

    Note: Validate arena
    Let is_valid be proc arena_validate with arena
    Let dummy7 be proc memory_set_integer from MemoryCore with dump_ptr, 48, is_valid

    Note: Calculate utilization percentage
    Let utilization be 0
    If capacity is greater than 0:
        Let hundred be 100
        Let numerator be current_pos multiplied by hundred
        Set utilization to numerator divided by capacity
    End If
    Let dummy8 be proc memory_set_integer from MemoryCore with dump_ptr, 56, utilization

    Return dump_ptr
End Process

Process called "arena_trace" takes arena as Integer returns Integer:
    Note: Trace arena allocations
    Note: Returns pointer to allocation trace
    Note: Shows allocation history and patterns

    If arena is equal to 0:
        Return 0
    End If

    Note: AllocationTrace structure:
    Note: offset 0:  total_allocations (8 bytes)
    Note: offset 8:  total_bytes_allocated (8 bytes)
    Note: offset 16: current_allocations (8 bytes)
    Note: offset 24: largest_allocation (8 bytes)
    Note: offset 32: smallest_allocation (8 bytes)
    Note: offset 40: average_allocation_size (8 bytes)
    Note: Total size: 48 bytes

    Let trace_size be 48
    Let trace_ptr be proc allocate from MemoryUtils with trace_size

    If trace_ptr is equal to 0:
        Return 0
    End If

    Note: Get allocation count
    Let allocation_count be proc memory_get_integer from MemoryCore with arena, 64
    Let dummy1 be proc memory_set_integer from MemoryCore with trace_ptr, 0, allocation_count

    Note: Get total bytes allocated (current position)
    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Let dummy2 be proc memory_set_integer from MemoryCore with trace_ptr, 8, current_pos

    Note: Current allocations is allocation count (no individual frees in bump allocator)
    Let dummy3 be proc memory_set_integer from MemoryCore with trace_ptr, 16, allocation_count

    Note: Calculate average allocation size
    Let average_size be 0
    If allocation_count is greater than 0:
        Set average_size to current_pos divided by allocation_count
    End If

    Note: For bump allocator, we don't track individual allocation sizes
    Note: Use average as approximation for largest/smallest
    Let dummy4 be proc memory_set_integer from MemoryCore with trace_ptr, 24, average_size
    Let dummy5 be proc memory_set_integer from MemoryCore with trace_ptr, 32, average_size
    Let dummy6 be proc memory_set_integer from MemoryCore with trace_ptr, 40, average_size

    Return trace_ptr
End Process

Process called "arena_check_leaks" takes arena as Integer returns Integer:
    Note: Check for memory leaks in arena
    Note: Returns number of leaks found
    Note: Identifies unfreed allocations

    If arena is equal to 0:
        Return 0
    End If

    Note: Bump allocators don't have individual deallocation
    Note: Leaks are detected by checking if arena was reset before destruction
    Note: For leak detection, check if allocations exist without reset

    Let allocation_count be proc memory_get_integer from MemoryCore with arena, 64
    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8

    Note: If there are allocations and current position is not zero, potential leak
    If allocation_count is greater than 0:
        If current_pos is greater than 0:
            Note: Return allocation count as number of potential leaks
            Return allocation_count
        End If
    End If

    Note: No leaks detected
    Return 0
End Process

Process called "arena_verify" takes arena as Integer returns Integer:
    Note: Verify arena memory integrity
    Note: Returns 1 if verified, 0 if corrupted
    Note: Checks for buffer overflows and corruption

    If arena is equal to 0:
        Return 0
    End If

    Note: First, validate basic arena structure
    Let is_valid be proc arena_validate with arena
    If is_valid is equal to 0:
        Return 0
    End If

    Note: Check for memory corruption by verifying key invariants
    Let memory_block be proc memory_get_integer from MemoryCore with arena, 0
    Let current_pos be proc memory_get_integer from MemoryCore with arena, 8
    Let size be proc memory_get_integer from MemoryCore with arena, 16
    Let capacity be proc memory_get_integer from MemoryCore with arena, 24

    Note: Verify current_pos <= size <= capacity
    If current_pos is greater than size:
        Return 0
    End If

    If size is greater than capacity:
        Return 0
    End If

    Note: Verify allocation count makes sense
    Let allocation_count be proc memory_get_integer from MemoryCore with arena, 64
    If allocation_count is less than 0:
        Return 0
    End If

    Note: Verify peak usage
    Let peak_usage be proc memory_get_integer from MemoryCore with arena, 72
    If peak_usage is less than current_pos:
        Return 0
    End If

    If peak_usage is greater than capacity:
        Return 0
    End If

    Note: Check memory block alignment (should be 8-byte aligned for x86_64)
    Let alignment_mask be 7
    Let offset be proc bitwise_and from BitwiseCore with memory_block, alignment_mask
    If offset is not equal to 0:
        Note: Memory block is not aligned - potential corruption
        Return 0
    End If

    Note: All verification checks passed
    Return 1
End Process

Note: ============================================================================
Note: ARENA UTILITIES IMPLEMENTATION (TIER 2 Memory Management)
Note: ============================================================================

Note: Arena implementation follows TIER 2 architecture:
Note: - Fast bulk allocation with O(1) cleanup
Note: - Operation-scoped temporaries
Note: - Simple bump pointer allocation
Note: - No individual deallocation - reset entire arena

Note: ============================================================================
Note: Implementation follows - Arena utilities complete
Note: ============================================================================