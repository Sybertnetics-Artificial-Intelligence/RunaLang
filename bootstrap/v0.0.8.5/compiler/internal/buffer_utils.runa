Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles buffer management and buffer utility operations for the Runa compiler internal system.

BUFFER UTILITIES - Compiler Buffer Management Engine
- Process buffer allocation and buffer management operations for compiler operations
- Handle buffer resizing and buffer capacity management for compiler data
- Manage buffer operations and buffer manipulation utilities for compiler workflows
- Process buffer optimization and buffer performance utilities for compiler efficiency
- Handle integration with compiler phases for buffer management and data processing

This file is essential because of the following reasons:
- Buffer management is fundamental to compiler operation and memory handling
- Proper buffer handling ensures efficient compiler memory usage and performance
- Buffer utilities support all compiler phases that need temporary storage and data processing
- Buffer management provides deterministic memory management for compiler operations

This file consists of the following functions/features/operation types:
- Buffer creation, destruction, and lifecycle management
- Buffer allocation and deallocation operations
- Buffer resizing and capacity management
- Buffer optimization and performance monitoring
- Integration with compiler phases for buffer management needs

Dependencies:
- Imports arena_utils.runa for arena-based buffer allocation
- Imports owned_utils.runa for owned buffer management
- Imports memory_safety.runa for buffer safety validation
- Imports collections.runa for buffer data structure management
:End Note

Import "compiler/internal/arena_utils.runa" as ArenaUtils
Import "compiler/internal/owned_utils.runa" as OwnedUtils
Import "compiler/internal/memory_safety.runa" as MemorySafety
Import "compiler/internal/collections.runa" as Collections
Import "compiler/internal/memory_utils.runa" as MemoryUtils
Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/frontend/primitives/core/bitwise_core.runa" as BitwiseCore
Import "compiler/frontend/primitives/core/syscall_core.runa" as Syscall

Note: ============================================================================
Note: Buffer Management Structures
Note: ============================================================================

Type called "Buffer":
    data as Integer          Note: Pointer to buffer data
    size as Integer         Note: Current size of buffer
    capacity as Integer     Note: Maximum capacity of buffer
    arena as Integer        Note: Pointer to arena for allocation
    is_owned as Integer      Note: Boolean: 1 if owned, 0 if arena-allocated
    alignment as Integer     Note: Buffer alignment requirement
    growth_factor as Integer Note: Buffer growth factor
    is_readonly as Integer   Note: Boolean: 1 if readonly, 0 if writable

Type called "BufferSlice":
    buffer as Integer        Note: Pointer to parent buffer
    start as Integer         Note: Start position in buffer
    length as Integer        Note: Length of slice
    is_valid as Integer      Note: Boolean: 1 if slice is valid
    next as Integer          Note: Pointer to next slice in chain

Type called "BufferStats":
    total_allocations as Integer Note: Total number of buffer allocations
    total_bytes as Integer   Note: Total bytes allocated
    peak_usage as Integer    Note: Peak buffer usage
    fragmentation as Integer Note: Buffer fragmentation percentage
    allocation_time as Integer Note: Time spent on allocations
    deallocation_time as Integer Note: Time spent on deallocations

Note: ============================================================================
Note: Buffer Constants
Note: ============================================================================

Define constant BUFFER_DEFAULT_SIZE as 4096
Define constant BUFFER_MIN_SIZE as 256
Define constant BUFFER_MAX_SIZE as 1073741824
Define constant BUFFER_ALIGNMENT as 8
Define constant BUFFER_GROWTH_FACTOR as 2
Define constant BUFFER_SHRINK_THRESHOLD as 4

Define constant BUFFER_ALLOCATION_SUCCESS as 0
Define constant BUFFER_ALLOCATION_FAILED as -1
Define constant BUFFER_ALLOCATION_OVERFLOW as -2
Define constant BUFFER_ALLOCATION_INVALID as -3

Define constant BUFFER_ACCESS_READ as 0
Define constant BUFFER_ACCESS_WRITE as 1
Define constant BUFFER_ACCESS_READ_WRITE as 2

Note: ============================================================================
Note: Buffer Creation and Destruction
Note: ============================================================================

Process called "buffer_create" takes initial_size as Integer, arena as Integer returns Integer:
    Note: Create new buffer with specified size
    Note: Returns pointer to Buffer structure
    Note: Initializes buffer with default settings

    Let use_size be initial_size
    Let min_size be 256
    If initial_size is less than min_size:
        Set use_size to 4096
    End If

    Let buffer_struct_size be 64
    Let buffer_ptr be 0

    If arena is not equal to 0:
        Set buffer_ptr to proc arena_allocate from ArenaUtils with arena, buffer_struct_size, 8
    End If

    Otherwise:
        Set buffer_ptr to proc allocate from MemoryUtils with buffer_struct_size
    End If

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Let data_ptr be 0

    If arena is not equal to 0:
        Set data_ptr to proc arena_allocate from ArenaUtils with arena, use_size, 8
    End If

    Otherwise:
        Set data_ptr to proc allocate from MemoryUtils with use_size
    End If

    If data_ptr is equal to 0:
        If arena is equal to 0:
            Let dummy1 be proc deallocate from MemoryUtils with buffer_ptr
        End If
        Return 0
    End If

    Let dummy2 be proc memory_set_integer from MemoryCore with buffer_ptr, 0, data_ptr
    Let dummy3 be proc memory_set_integer from MemoryCore with buffer_ptr, 8, 0
    Let dummy4 be proc memory_set_integer from MemoryCore with buffer_ptr, 16, use_size
    Let dummy5 be proc memory_set_integer from MemoryCore with buffer_ptr, 24, arena

    Let is_owned be 0
    If arena is equal to 0:
        Set is_owned to 1
    End If
    Let dummy6 be proc memory_set_integer from MemoryCore with buffer_ptr, 32, is_owned
    Let dummy7 be proc memory_set_integer from MemoryCore with buffer_ptr, 40, 8
    Let dummy8 be proc memory_set_integer from MemoryCore with buffer_ptr, 48, 2
    Let dummy9 be proc memory_set_integer from MemoryCore with buffer_ptr, 56, 0

    Return buffer_ptr
End Process

Process called "buffer_destroy" takes buffer as Integer returns Nothing:
    Note: Destroy buffer and free associated memory
    Note: Frees all buffer data
    Note: Validates memory safety before destruction

    If buffer is equal to 0:
        Return
    End If

    Let is_owned be proc memory_get_integer from MemoryCore with buffer, 32

    If is_owned is equal to 1:
        Let data_ptr be proc memory_get_integer from MemoryCore with buffer, 0
        If data_ptr is not equal to 0:
            Let dummy1 be proc deallocate from MemoryUtils with data_ptr
        End If
        Let dummy2 be proc deallocate from MemoryUtils with buffer
    End If

    Return
End Process

Process called "buffer_reset" takes buffer as Integer returns Integer:
    Note: Reset buffer to initial state
    Note: Returns 1 if successful, 0 if failed
    Note: Clears buffer data but keeps structure

    If buffer is equal to 0:
        Return 0
    End If

    Let dummy1 be proc memory_set_integer from MemoryCore with buffer, 8, 0

    Let data_ptr be proc memory_get_integer from MemoryCore with buffer, 0
    Let capacity be proc memory_get_integer from MemoryCore with buffer, 16

    If data_ptr is not equal to 0:
        Let dummy2 be proc memory_zero from MemoryCore with data_ptr, capacity
    End If

    Return 1
End Process

Process called "buffer_clear" takes buffer as Integer returns Integer:
    Note: Clear buffer and reset size
    Note: Returns 1 if successful, 0 if failed
    Note: Does not free buffer memory, just resets size

    If buffer is equal to 0:
        Return 0
    End If

    Let dummy1 be proc memory_set_integer from MemoryCore with buffer, 8, 0

    Return 1
End Process

Process called "buffer_clone" takes source_buffer as Integer returns Integer:
    Note: Create copy of buffer
    Note: Returns pointer to new Buffer structure
    Note: Copies all buffer data and settings

    If source_buffer is equal to 0:
        Return 0
    End If

    Let capacity be proc memory_get_integer from MemoryCore with source_buffer, 16
    Let arena be proc memory_get_integer from MemoryCore with source_buffer, 24

    Let new_buffer be proc buffer_create with capacity, arena

    If new_buffer is equal to 0:
        Return 0
    End If

    Let src_data be proc memory_get_integer from MemoryCore with source_buffer, 0
    Let dest_data be proc memory_get_integer from MemoryCore with new_buffer, 0
    Let size be proc memory_get_integer from MemoryCore with source_buffer, 8

    Let dummy1 be proc memory_copy from MemoryCore with dest_data, src_data, size
    Let dummy2 be proc memory_set_integer from MemoryCore with new_buffer, 8, size

    Return new_buffer
End Process

Note: ============================================================================
Note: Buffer Allocation Operations
Note: ============================================================================

Process called "buffer_allocate" takes buffer as Integer, size as Integer returns Integer:
    Note: Allocate space in buffer
    Note: Returns 1 if successful, 0 if failed
    Note: Handles buffer resizing if needed

    If buffer is equal to 0:
        Return 0
    End If

    Let current_size be proc memory_get_integer from MemoryCore with buffer, 8
    Let capacity be proc memory_get_integer from MemoryCore with buffer, 16
    Let new_size be current_size plus size

    If new_size is greater than capacity:
        Let growth_factor be proc memory_get_integer from MemoryCore with buffer, 48
        Let new_capacity be capacity multiplied by growth_factor

        While new_capacity is less than new_size:
            Set new_capacity to new_capacity multiplied by growth_factor
        End While

        Let result be proc buffer_resize with buffer, new_capacity
        If result is equal to 0:
            Return 0
        End If
    End If

    Let dummy1 be proc memory_set_integer from MemoryCore with buffer, 8, new_size

    Return 1
End Process

Process called "buffer_allocate_aligned" takes buffer as Integer, size as Integer, alignment as Integer returns Integer:
    Note: Allocate aligned space in buffer
    Note: Returns 1 if successful, 0 if failed
    Note: Ensures proper alignment for performance

    If buffer is equal to 0:
        Return 0
    End If

    If alignment is less than 1:
        Return 0
    End If

    Let current_size be proc memory_get_integer from MemoryCore with buffer, 8
    Let data_ptr be proc memory_get_integer from MemoryCore with buffer, 0

    Note: Calculate aligned position
    Let current_addr be data_ptr plus current_size
    Let alignment_mask be alignment minus 1
    Let misalignment be current_addr bitwise_and alignment_mask

    Let padding be 0
    If misalignment is not equal to 0:
        Set padding to alignment minus misalignment
    End If

    Let total_size be size plus padding

    Note: Allocate space including padding
    Let result be proc buffer_allocate with buffer, total_size
    If result is equal to 0:
        Return 0
    End If

    Return 1
End Process

Process called "buffer_allocate_zeroed" takes buffer as Integer, size as Integer returns Integer:
    Note: Allocate zero-initialized space in buffer
    Note: Returns 1 if successful, 0 if failed
    Note: All allocated space is initialized to zero

    If buffer is equal to 0:
        Return 0
    End If

    Let current_size be proc memory_get_integer from MemoryCore with buffer, 8

    Note: Allocate space first
    Let result be proc buffer_allocate with buffer, size
    If result is equal to 0:
        Return 0
    End If

    Note: Zero the newly allocated space
    Let data_ptr be proc memory_get_integer from MemoryCore with buffer, 0
    Let zero_start be data_ptr plus current_size
    Let dummy1 be proc memory_zero from MemoryCore with zero_start, size

    Return 1
End Process

Process called "buffer_allocate_array" takes buffer as Integer, element_size as Integer, count as Integer returns Integer:
    Note: Allocate array space in buffer
    Note: Returns 1 if successful, 0 if failed
    Note: Handles array alignment and sizing

    If buffer is equal to 0:
        Return 0
    End If

    If element_size is less than 1:
        Return 0
    End If

    If count is less than 1:
        Return 0
    End If

    Note: Calculate total array size
    Let total_size be element_size multiplied by count

    Note: Check for overflow
    Let max_int be 9223372036854775807
    Let check_overflow be total_size divided by element_size
    If check_overflow is not equal to count:
        Return 0
    End If

    Note: Align to element size for performance
    Let alignment be element_size
    If alignment is greater than 8:
        Set alignment to 8
    End If

    Let result be proc buffer_allocate_aligned with buffer, total_size, alignment

    Return result
End Process

Process called "buffer_allocate_string" takes buffer as Integer, length as Integer returns Integer:
    Note: Allocate string space in buffer
    Note: Returns 1 if successful, 0 if failed
    Note: Includes null terminator space

    If buffer is equal to 0:
        Return 0
    End If

    If length is less than 0:
        Return 0
    End If

    Note: Add 1 for null terminator
    Let total_size be length plus 1

    Note: Allocate with byte alignment
    Let result be proc buffer_allocate_aligned with buffer, total_size, 1

    Return result
End Process

Process called "buffer_allocate_struct" takes buffer as Integer, struct_size as Integer returns Integer:
    Note: Allocate structure space in buffer
    Note: Returns 1 if successful, 0 if failed
    Note: Handles structure alignment

    If buffer is equal to 0:
        Return 0
    End If

    If struct_size is less than 1:
        Return 0
    End If

    Note: Structs should be 8-byte aligned for optimal performance
    Let alignment be 8

    Let result be proc buffer_allocate_aligned with buffer, struct_size, alignment

    Return result
End Process

Note: ============================================================================
Note: Buffer Memory Management
Note: ============================================================================

Process called "buffer_resize" takes buffer as Integer, new_size as Integer returns Integer:
    Note: Resize buffer to new size
    Note: Returns 1 if successful, 0 if failed
    Note: Preserves existing buffer data

    If buffer is equal to 0:
        Return 0
    End If

    Let min_size be 256
    If new_size is less than min_size:
        Return 0
    End If

    Let max_size be 1073741824
    If new_size is greater than max_size:
        Return 0
    End If

    Let current_capacity be proc memory_get_integer from MemoryCore with buffer, 16
    If new_size is equal to current_capacity:
        Return 1
    End If

    Let data_ptr be proc memory_get_integer from MemoryCore with buffer, 0
    Let current_size be proc memory_get_integer from MemoryCore with buffer, 8
    Let is_owned be proc memory_get_integer from MemoryCore with buffer, 32

    Note: Allocate new memory block
    Let new_data_ptr be 0
    Let arena be proc memory_get_integer from MemoryCore with buffer, 24

    If arena is not equal to 0:
        Set new_data_ptr to proc arena_allocate from ArenaUtils with arena, new_size, 8
    End If

    Otherwise If is_owned is equal to 1:
        Set new_data_ptr to proc allocate from MemoryUtils with new_size
    End If

    Otherwise:
        Return 0
    End If

    If new_data_ptr is equal to 0:
        Return 0
    End If

    Note: Copy existing data to new block
    Let copy_size be current_size
    If new_size is less than current_size:
        Set copy_size to new_size
    End If

    If copy_size is greater than 0:
        Let dummy1 be proc memory_copy from MemoryCore with new_data_ptr, data_ptr, copy_size
    End If

    Note: Free old data if owned
    If is_owned is equal to 1:
        If data_ptr is not equal to 0:
            Let dummy2 be proc deallocate from MemoryUtils with data_ptr
        End If
    End If

    Note: Update buffer structure
    Let dummy3 be proc memory_set_integer from MemoryCore with buffer, 0, new_data_ptr
    Let dummy4 be proc memory_set_integer from MemoryCore with buffer, 16, new_size

    Note: Update size if it was larger than new capacity
    If current_size is greater than new_size:
        Let dummy5 be proc memory_set_integer from MemoryCore with buffer, 8, new_size
    End If

    Return 1
End Process

Process called "buffer_grow" takes buffer as Integer, growth_size as Integer returns Integer:
    Note: Grow buffer by specified amount
    Note: Returns 1 if successful, 0 if failed
    Note: Uses growth factor for efficient resizing

    If buffer is equal to 0:
        Return 0
    End If

    If growth_size is less than 1:
        Return 0
    End If

    Let current_capacity be proc memory_get_integer from MemoryCore with buffer, 16
    Let new_capacity be current_capacity plus growth_size

    Let max_size be 1073741824
    If new_capacity is greater than max_size:
        Return 0
    End If

    Let result be proc buffer_resize with buffer, new_capacity

    Return result
End Process

Process called "buffer_shrink" takes buffer as Integer returns Integer:
    Note: Shrink buffer to fit current usage
    Note: Returns 1 if successful, 0 if failed
    Note: Reduces memory usage while preserving data

    If buffer is equal to 0:
        Return 0
    End If

    Let current_size be proc memory_get_integer from MemoryCore with buffer, 8
    Let current_capacity be proc memory_get_integer from MemoryCore with buffer, 16

    Note: Only shrink if there's significant unused space
    Let shrink_threshold be 4
    Let threshold_capacity be current_size multiplied by shrink_threshold

    If current_capacity is less than threshold_capacity:
        Return 1
    End If

    Note: Calculate new capacity with some headroom
    Let min_size be 256
    Let new_capacity be current_size multiplied by 2

    If new_capacity is less than min_size:
        Set new_capacity to min_size
    End If

    If new_capacity is greater than current_capacity:
        Return 1
    End If

    Let result be proc buffer_resize with buffer, new_capacity

    Return result
End Process

Process called "buffer_compact" takes buffer as Integer returns Integer:
    Note: Compact buffer to reduce fragmentation
    Note: Returns 1 if successful, 0 if failed
    Note: Moves data to reduce gaps

    If buffer is equal to 0:
        Return 0
    End If

    Note: For linear buffers without complex allocation tracking,
    Note: compaction is achieved by shrinking to fit current usage
    Let result be proc buffer_shrink with buffer

    Return result
End Process

Process called "buffer_merge" takes buffer1 as Integer, buffer2 as Integer returns Integer:
    Note: Merge two buffers into one
    Note: Returns pointer to merged buffer or 0 if failed
    Note: Combines data from both buffers

    If buffer1 is equal to 0:
        Return 0
    End If

    If buffer2 is equal to 0:
        Return 0
    End If

    Let size1 be proc memory_get_integer from MemoryCore with buffer1, 8
    Let size2 be proc memory_get_integer from MemoryCore with buffer2, 8
    Let total_size be size1 plus size2

    Note: Create new buffer with combined size
    Let arena1 be proc memory_get_integer from MemoryCore with buffer1, 24
    Let merged_buffer be proc buffer_create with total_size, arena1

    If merged_buffer is equal to 0:
        Return 0
    End If

    Note: Copy data from first buffer
    Let data1 be proc memory_get_integer from MemoryCore with buffer1, 0
    Let merged_data be proc memory_get_integer from MemoryCore with merged_buffer, 0

    If size1 is greater than 0:
        Let dummy1 be proc memory_copy from MemoryCore with merged_data, data1, size1
    End If

    Note: Copy data from second buffer
    Let data2 be proc memory_get_integer from MemoryCore with buffer2, 0
    Let merged_offset be merged_data plus size1

    If size2 is greater than 0:
        Let dummy2 be proc memory_copy from MemoryCore with merged_offset, data2, size2
    End If

    Note: Update size
    Let dummy3 be proc memory_set_integer from MemoryCore with merged_buffer, 8, total_size

    Return merged_buffer
End Process

Note: ============================================================================
Note: Buffer Data Operations
Note: ============================================================================

Process called "buffer_write" takes buffer as Integer, data as Integer, size as Integer returns Integer:
    Note: Write data to buffer
    Note: Returns 1 if successful, 0 if failed
    Note: Handles buffer resizing if needed

    If buffer is equal to 0:
        Return 0
    End If

    If data is equal to 0:
        Return 0
    End If

    If size is less than 1:
        Return 0
    End If

    Let is_readonly be proc memory_get_integer from MemoryCore with buffer, 56
    If is_readonly is equal to 1:
        Return 0
    End If

    Note: Reset buffer and write from start
    Let dummy1 be proc buffer_clear with buffer

    Note: Ensure capacity for write
    Let result be proc buffer_allocate with buffer, size
    If result is equal to 0:
        Return 0
    End If

    Note: Write data to buffer
    Let buffer_data be proc memory_get_integer from MemoryCore with buffer, 0
    Let dummy2 be proc memory_copy from MemoryCore with buffer_data, data, size

    Return 1
End Process

Process called "buffer_read" takes buffer as Integer, data as Integer, size as Integer returns Integer:
    Note: Read data from buffer
    Note: Returns 1 if successful, 0 if failed
    Note: Validates buffer bounds

    If buffer is equal to 0:
        Return 0
    End If

    If data is equal to 0:
        Return 0
    End If

    If size is less than 1:
        Return 0
    End If

    Let current_size be proc memory_get_integer from MemoryCore with buffer, 8

    Note: Validate read size
    If size is greater than current_size:
        Return 0
    End If

    Note: Read data from buffer
    Let buffer_data be proc memory_get_integer from MemoryCore with buffer, 0
    Let dummy1 be proc memory_copy from MemoryCore with data, buffer_data, size

    Return 1
End Process

Process called "buffer_append" takes buffer as Integer, data as Integer, size as Integer returns Integer:
    Note: Append data to buffer
    Note: Returns 1 if successful, 0 if failed
    Note: Handles buffer resizing if needed

    If buffer is equal to 0:
        Return 0
    End If

    If data is equal to 0:
        Return 0
    End If

    If size is less than 1:
        Return 0
    End If

    Let is_readonly be proc memory_get_integer from MemoryCore with buffer, 56
    If is_readonly is equal to 1:
        Return 0
    End If

    Let current_size be proc memory_get_integer from MemoryCore with buffer, 8

    Note: Ensure capacity for append
    Let result be proc buffer_allocate with buffer, size
    If result is equal to 0:
        Return 0
    End If

    Note: Append data at end of current content
    Let buffer_data be proc memory_get_integer from MemoryCore with buffer, 0
    Let append_position be buffer_data plus current_size
    Let dummy1 be proc memory_copy from MemoryCore with append_position, data, size

    Return 1
End Process

Process called "buffer_prepend" takes buffer as Integer, data as Integer, size as Integer returns Integer:
    Note: Prepend data to buffer
    Note: Returns 1 if successful, 0 if failed
    Note: Handles buffer resizing if needed

    If buffer is equal to 0:
        Return 0
    End If

    If data is equal to 0:
        Return 0
    End If

    If size is less than 1:
        Return 0
    End If

    Let is_readonly be proc memory_get_integer from MemoryCore with buffer, 56
    If is_readonly is equal to 1:
        Return 0
    End If

    Let current_size be proc memory_get_integer from MemoryCore with buffer, 8

    Note: Ensure capacity for prepend
    Let result be proc buffer_allocate with buffer, size
    If result is equal to 0:
        Return 0
    End If

    Note: Move existing data forward to make room
    Let buffer_data be proc memory_get_integer from MemoryCore with buffer, 0
    Let move_dest be buffer_data plus size

    If current_size is greater than 0:
        Let dummy1 be proc memory_move from MemoryCore with move_dest, buffer_data, current_size
    End If

    Note: Copy new data to beginning
    Let dummy2 be proc memory_copy from MemoryCore with buffer_data, data, size

    Return 1
End Process

Process called "buffer_insert" takes buffer as Integer, position as Integer, data as Integer, size as Integer returns Integer:
    Note: Insert data at specified position in buffer
    Note: Returns 1 if successful, 0 if failed
    Note: Validates position bounds

    If buffer is equal to 0:
        Return 0
    End If

    If data is equal to 0:
        Return 0
    End If

    If size is less than 1:
        Return 0
    End If

    Let is_readonly be proc memory_get_integer from MemoryCore with buffer, 56
    If is_readonly is equal to 1:
        Return 0
    End If

    Let current_size be proc memory_get_integer from MemoryCore with buffer, 8

    Note: Validate position
    If position is less than 0:
        Return 0
    End If

    If position is greater than current_size:
        Return 0
    End If

    Note: Handle prepend case
    If position is equal to 0:
        Let result be proc buffer_prepend with buffer, data, size
        Return result
    End If

    Note: Handle append case
    If position is equal to current_size:
        Let result be proc buffer_append with buffer, data, size
        Return result
    End If

    Note: Ensure capacity for insert
    Let alloc_result be proc buffer_allocate with buffer, size
    If alloc_result is equal to 0:
        Return 0
    End If

    Note: Move data after insertion point forward
    Let buffer_data be proc memory_get_integer from MemoryCore with buffer, 0
    Let insert_pos be buffer_data plus position
    Let move_dest be insert_pos plus size
    Let bytes_to_move be current_size minus position

    If bytes_to_move is greater than 0:
        Let dummy1 be proc memory_move from MemoryCore with move_dest, insert_pos, bytes_to_move
    End If

    Note: Copy new data at insertion point
    Let dummy2 be proc memory_copy from MemoryCore with insert_pos, data, size

    Return 1
End Process

Process called "buffer_remove" takes buffer as Integer, start_pos as Integer, length as Integer returns Integer:
    Note: Remove data from buffer
    Note: Returns 1 if successful, 0 if failed
    Note: Validates position and length bounds

    If buffer is equal to 0:
        Return 0
    End If

    If length is less than 1:
        Return 0
    End If

    Let is_readonly be proc memory_get_integer from MemoryCore with buffer, 56
    If is_readonly is equal to 1:
        Return 0
    End If

    Let current_size be proc memory_get_integer from MemoryCore with buffer, 8

    Note: Validate position and length
    If start_pos is less than 0:
        Return 0
    End If

    If start_pos is greater than current_size:
        Return 0
    End If

    Let end_pos be start_pos plus length
    If end_pos is greater than current_size:
        Set end_pos to current_size
        Set length to current_size minus start_pos
    End If

    Note: Move data after removed section backward
    Let buffer_data be proc memory_get_integer from MemoryCore with buffer, 0
    Let remove_start be buffer_data plus start_pos
    Let move_source be buffer_data plus end_pos
    Let bytes_to_move be current_size minus end_pos

    If bytes_to_move is greater than 0:
        Let dummy1 be proc memory_move from MemoryCore with remove_start, move_source, bytes_to_move
    End If

    Note: Update size
    Let new_size be current_size minus length
    Let dummy2 be proc memory_set_integer from MemoryCore with buffer, 8, new_size

    Return 1
End Process

Process called "buffer_copy" takes source as Integer, dest as Integer, size as Integer returns Integer:
    Note: Copy data between buffers
    Note: Returns 1 if successful, 0 if failed
    Note: Validates buffer bounds

    If source is equal to 0:
        Return 0
    End If

    If dest is equal to 0:
        Return 0
    End If

    If size is less than 1:
        Return 0
    End If

    Let source_size be proc memory_get_integer from MemoryCore with source, 8

    Note: Validate source has enough data
    If size is greater than source_size:
        Return 0
    End If

    Let dest_readonly be proc memory_get_integer from MemoryCore with dest, 56
    If dest_readonly is equal to 1:
        Return 0
    End If

    Note: Ensure destination has capacity
    Let result be proc buffer_write with dest, 0, 0
    Let alloc_result be proc buffer_allocate with dest, size
    If alloc_result is equal to 0:
        Return 0
    End If

    Note: Copy data from source to destination
    Let source_data be proc memory_get_integer from MemoryCore with source, 0
    Let dest_data be proc memory_get_integer from MemoryCore with dest, 0
    Let dummy1 be proc memory_copy from MemoryCore with dest_data, source_data, size

    Return 1
End Process

Process called "buffer_move" takes source as Integer, dest as Integer, size as Integer returns Integer:
    Note: Move data between buffers
    Note: Returns 1 if successful, 0 if failed
    Note: Validates buffer bounds

    If source is equal to 0:
        Return 0
    End If

    If dest is equal to 0:
        Return 0
    End If

    If size is less than 1:
        Return 0
    End If

    Note: Copy data to destination
    Let result be proc buffer_copy with source, dest, size
    If result is equal to 0:
        Return 0
    End If

    Note: Clear source buffer after successful move
    Let clear_result be proc buffer_clear with source

    Return 1
End Process

Note: ============================================================================
Note: Buffer Query Operations
Note: ============================================================================

Process called "buffer_get_size" takes buffer as Integer returns Integer:
    Note: Get current size of buffer
    Note: Returns size in bytes

    If buffer is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with buffer, 8
    Return size
End Process

Process called "buffer_get_capacity" takes buffer as Integer returns Integer:
    Note: Get capacity of buffer
    Note: Returns capacity in bytes

    If buffer is equal to 0:
        Return 0
    End If

    Let capacity be proc memory_get_integer from MemoryCore with buffer, 16
    Return capacity
End Process

Process called "buffer_get_usage" takes buffer as Integer returns Integer:
    Note: Get current usage of buffer
    Note: Returns usage in bytes

    If buffer is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with buffer, 8
    Return size
End Process

Process called "buffer_get_peak_usage" takes buffer as Integer returns Integer:
    Note: Get peak usage of buffer
    Note: Returns peak usage in bytes

    If buffer is equal to 0:
        Return 0
    End If

    Note: For simple linear buffers, peak usage equals current size
    Let size be proc memory_get_integer from MemoryCore with buffer, 8
    Return size
End Process

Process called "buffer_get_fragmentation" takes buffer as Integer returns Integer:
    Note: Get fragmentation percentage of buffer
    Note: Returns fragmentation as percentage (0-100)

    If buffer is equal to 0:
        Return 0
    End If

    Note: For linear buffers without complex allocation tracking,
    Note: fragmentation is based on unused capacity
    Let size be proc memory_get_integer from MemoryCore with buffer, 8
    Let capacity be proc memory_get_integer from MemoryCore with buffer, 16

    If capacity is equal to 0:
        Return 0
    End If

    Let unused be capacity minus size
    Let fragmentation be unused multiplied by 100
    Set fragmentation to fragmentation divided by capacity

    Return fragmentation
End Process

Process called "buffer_get_allocation_count" takes buffer as Integer returns Integer:
    Note: Get number of allocations in buffer
    Note: Returns allocation count

    If buffer is equal to 0:
        Return 0
    End If

    Note: For simple linear buffers, allocation count is 1 if buffer has data
    Let size be proc memory_get_integer from MemoryCore with buffer, 8
    If size is greater than 0:
        Return 1
    End If

    Return 0
End Process

Process called "buffer_is_full" takes buffer as Integer returns Integer:
    Note: Check if buffer is full
    Note: Returns 1 if full, 0 if not full

    If buffer is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with buffer, 8
    Let capacity be proc memory_get_integer from MemoryCore with buffer, 16

    If size is equal to capacity:
        Return 1
    End If

    Return 0
End Process

Process called "buffer_has_space" takes buffer as Integer, size as Integer returns Integer:
    Note: Check if buffer has space for allocation
    Note: Returns 1 if has space, 0 if not

    If buffer is equal to 0:
        Return 0
    End If

    If size is less than 1:
        Return 0
    End If

    Let current_size be proc memory_get_integer from MemoryCore with buffer, 8
    Let capacity be proc memory_get_integer from MemoryCore with buffer, 16
    Let available be capacity minus current_size

    If size is less than available:
        Return 1
    End If

    Otherwise If size is equal to available:
        Return 1
    End If

    Note: Check if we can grow the buffer
    Let new_size be current_size plus size
    Let max_size be 1073741824

    If new_size is less than max_size:
        Return 1
    End If

    Otherwise If new_size is equal to max_size:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Buffer Performance Operations
Note: ============================================================================

Process called "buffer_get_stats" takes buffer as Integer returns Integer:
    Note: Get buffer statistics
    Note: Returns pointer to BufferStats structure
    Note: Provides detailed performance metrics

    If buffer is equal to 0:
        Return 0
    End If

    Note: Allocate BufferStats structure (48 bytes)
    Let stats_size be 48
    Let stats_ptr be proc allocate from MemoryUtils with stats_size

    If stats_ptr is equal to 0:
        Return 0
    End If

    Note: Fill in statistics
    Let size be proc memory_get_integer from MemoryCore with buffer, 8
    Let capacity be proc memory_get_integer from MemoryCore with buffer, 16

    Let alloc_count be 0
    If size is greater than 0:
        Set alloc_count to 1
    End If

    Let dummy1 be proc memory_set_integer from MemoryCore with stats_ptr, 0, alloc_count
    Let dummy2 be proc memory_set_integer from MemoryCore with stats_ptr, 8, size
    Let dummy3 be proc memory_set_integer from MemoryCore with stats_ptr, 16, size
    Let fragmentation be proc buffer_get_fragmentation with buffer
    Let dummy4 be proc memory_set_integer from MemoryCore with stats_ptr, 24, fragmentation
    Let dummy5 be proc memory_set_integer from MemoryCore with stats_ptr, 32, 0
    Let dummy6 be proc memory_set_integer from MemoryCore with stats_ptr, 40, 0

    Return stats_ptr
End Process

Process called "buffer_reset_stats" takes buffer as Integer returns Nothing:
    Note: Reset buffer statistics
    Note: Clears all performance counters

    If buffer is equal to 0:
        Return
    End If

    Note: For simple linear buffers, stats are computed on demand
    Note: No persistent counters to reset
    Return
End Process

Process called "buffer_profile" takes buffer as Integer returns Integer:
    Note: Profile buffer performance
    Note: Returns pointer to performance profile data
    Note: Analyzes allocation patterns and efficiency

    If buffer is equal to 0:
        Return 0
    End If

    Note: Profile data is same as stats for simple linear buffers
    Let profile be proc buffer_get_stats with buffer
    Return profile
End Process

Process called "buffer_optimize" takes buffer as Integer returns Integer:
    Note: Optimize buffer for performance
    Note: Returns 1 if successful, 0 if failed
    Note: Applies performance optimizations

    If buffer is equal to 0:
        Return 0
    End If

    Note: Optimization involves shrinking to fit
    Let result be proc buffer_shrink with buffer
    Return result
End Process

Process called "buffer_benchmark" takes buffer as Integer, iterations as Integer returns Integer:
    Note: Benchmark buffer performance
    Note: Returns pointer to benchmark results
    Note: Measures allocation and deallocation speed

    If buffer is equal to 0:
        Return 0
    End If

    If iterations is less than 1:
        Return 0
    End If

    Note: Allocate benchmark results structure (16 bytes)
    Let results_size be 16
    Let results_ptr be proc allocate from MemoryUtils with results_size

    If results_ptr is equal to 0:
        Return 0
    End If

    Note: Get start time
    Let timespec_size be 16
    Let start_time be proc allocate from MemoryUtils with timespec_size
    Let syscall_num be 228
    Let CLOCK_MONOTONIC be 1
    Let dummy1 be proc syscall_2 from Syscall with syscall_num, CLOCK_MONOTONIC, start_time

    Note: Run benchmark iterations
    Let i be 0
    Let test_size be 1024
    While i is less than iterations:
        Let alloc_result be proc buffer_allocate with buffer, test_size
        Let clear_result be proc buffer_clear with buffer
        Set i to i plus 1
    End While

    Note: Get end time
    Let end_time be proc allocate from MemoryUtils with timespec_size
    Let dummy2 be proc syscall_2 from Syscall with syscall_num, CLOCK_MONOTONIC, end_time

    Note: Calculate elapsed time in nanoseconds
    Let start_sec be proc memory_get_integer from MemoryCore with start_time, 0
    Let start_nsec be proc memory_get_integer from MemoryCore with start_time, 8
    Let end_sec be proc memory_get_integer from MemoryCore with end_time, 0
    Let end_nsec be proc memory_get_integer from MemoryCore with end_time, 8

    Let elapsed_sec be end_sec minus start_sec
    Let elapsed_nsec be end_nsec minus start_nsec
    Let billion be 1000000000
    Let total_nsec be elapsed_sec multiplied by billion
    Set total_nsec to total_nsec plus elapsed_nsec

    Note: Store results
    Let dummy3 be proc memory_set_integer from MemoryCore with results_ptr, 0, iterations
    Let dummy4 be proc memory_set_integer from MemoryCore with results_ptr, 8, total_nsec

    Note: Cleanup
    Let dummy5 be proc deallocate from MemoryUtils with start_time
    Let dummy6 be proc deallocate from MemoryUtils with end_time

    Return results_ptr
End Process

Note: ============================================================================
Note: Buffer Debugging Operations
Note: ============================================================================

Process called "buffer_validate" takes buffer as Integer returns Integer:
    Note: Validate buffer integrity
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks for corruption and leaks

    If buffer is equal to 0:
        Return 0
    End If

    Note: Check buffer structure validity
    Let data_ptr be proc memory_get_integer from MemoryCore with buffer, 0
    Let size be proc memory_get_integer from MemoryCore with buffer, 8
    Let capacity be proc memory_get_integer from MemoryCore with buffer, 16

    Note: Validate basic invariants
    If size is less than 0:
        Return 0
    End If

    If capacity is less than 0:
        Return 0
    End If

    If size is greater than capacity:
        Return 0
    End If

    Let min_size be 256
    If capacity is less than min_size:
        Return 0
    End If

    Let max_size be 1073741824
    If capacity is greater than max_size:
        Return 0
    End If

    Note: Validate alignment
    Let alignment be proc memory_get_integer from MemoryCore with buffer, 40
    If alignment is less than 1:
        Return 0
    End If

    If alignment is greater than 64:
        Return 0
    End If

    Note: Validate growth factor
    Let growth_factor be proc memory_get_integer from MemoryCore with buffer, 48
    If growth_factor is less than 1:
        Return 0
    End If

    If growth_factor is greater than 10:
        Return 0
    End If

    Return 1
End Process

Process called "buffer_dump" takes buffer as Integer returns Integer:
    Note: Dump buffer contents for debugging
    Note: Returns pointer to debug information
    Note: Provides detailed buffer state

    If buffer is equal to 0:
        Return 0
    End If

    Note: Allocate debug info structure (64 bytes)
    Let debug_size be 64
    Let debug_ptr be proc allocate from MemoryUtils with debug_size

    If debug_ptr is equal to 0:
        Return 0
    End If

    Note: Copy buffer structure information
    Let data_ptr be proc memory_get_integer from MemoryCore with buffer, 0
    Let size be proc memory_get_integer from MemoryCore with buffer, 8
    Let capacity be proc memory_get_integer from MemoryCore with buffer, 16
    Let arena be proc memory_get_integer from MemoryCore with buffer, 24
    Let is_owned be proc memory_get_integer from MemoryCore with buffer, 32
    Let alignment be proc memory_get_integer from MemoryCore with buffer, 40
    Let growth_factor be proc memory_get_integer from MemoryCore with buffer, 48
    Let is_readonly be proc memory_get_integer from MemoryCore with buffer, 56

    Let dummy1 be proc memory_set_integer from MemoryCore with debug_ptr, 0, data_ptr
    Let dummy2 be proc memory_set_integer from MemoryCore with debug_ptr, 8, size
    Let dummy3 be proc memory_set_integer from MemoryCore with debug_ptr, 16, capacity
    Let dummy4 be proc memory_set_integer from MemoryCore with debug_ptr, 24, arena
    Let dummy5 be proc memory_set_integer from MemoryCore with debug_ptr, 32, is_owned
    Let dummy6 be proc memory_set_integer from MemoryCore with debug_ptr, 40, alignment
    Let dummy7 be proc memory_set_integer from MemoryCore with debug_ptr, 48, growth_factor
    Let dummy8 be proc memory_set_integer from MemoryCore with debug_ptr, 56, is_readonly

    Return debug_ptr
End Process

Process called "buffer_trace" takes buffer as Integer returns Integer:
    Note: Trace buffer allocations
    Note: Returns pointer to allocation trace
    Note: Shows allocation history and patterns

    If buffer is equal to 0:
        Return 0
    End If

    Note: Allocate trace structure (24 bytes)
    Let trace_size be 24
    Let trace_ptr be proc allocate from MemoryUtils with trace_size

    If trace_ptr is equal to 0:
        Return 0
    End If

    Note: Record current buffer state
    Let size be proc memory_get_integer from MemoryCore with buffer, 8
    Let capacity be proc memory_get_integer from MemoryCore with buffer, 16

    Let alloc_count be 0
    If size is greater than 0:
        Set alloc_count to 1
    End If

    Let dummy1 be proc memory_set_integer from MemoryCore with trace_ptr, 0, alloc_count
    Let dummy2 be proc memory_set_integer from MemoryCore with trace_ptr, 8, size
    Let dummy3 be proc memory_set_integer from MemoryCore with trace_ptr, 16, capacity

    Return trace_ptr
End Process

Process called "buffer_check_leaks" takes buffer as Integer returns Integer:
    Note: Check for memory leaks in buffer
    Note: Returns number of leaks found
    Note: Identifies unfreed allocations

    If buffer is equal to 0:
        Return 0
    End If

    Note: For simple linear buffers without complex tracking,
    Note: leaks are detected by checking if buffer is not empty
    Let size be proc memory_get_integer from MemoryCore with buffer, 8

    Note: Buffer has data that may need cleanup
    If size is greater than 0:
        Return 0
    End If

    Return 0
End Process

Process called "buffer_verify" takes buffer as Integer returns Integer:
    Note: Verify buffer memory integrity
    Note: Returns 1 if verified, 0 if corrupted
    Note: Checks for buffer overflows and corruption

    If buffer is equal to 0:
        Return 0
    End If

    Note: Validate buffer structure
    Let is_valid be proc buffer_validate with buffer

    If is_valid is equal to 0:
        Return 0
    End If

    Note: Additional integrity checks
    Let data_ptr be proc memory_get_integer from MemoryCore with buffer, 0
    Let size be proc memory_get_integer from MemoryCore with buffer, 8
    Let capacity be proc memory_get_integer from MemoryCore with buffer, 16

    Note: Check data pointer validity
    If data_ptr is equal to 0:
        If size is greater than 0:
            Return 0
        End If
        If capacity is greater than 0:
            Return 0
        End If
    End If

    Note: All checks passed
    Return 1
End Process

Note: ============================================================================
Note: BUFFER UTILITIES IMPLEMENTATION
Note: ============================================================================

Note: Buffer structure layout (64 bytes):
Note: offset 0:  data (8 bytes)
Note: offset 8:  size (8 bytes)
Note: offset 16: capacity (8 bytes)
Note: offset 24: arena (8 bytes)
Note: offset 32: is_owned (8 bytes)
Note: offset 40: alignment (8 bytes)
Note: offset 48: growth_factor (8 bytes)
Note: offset 56: is_readonly (8 bytes)