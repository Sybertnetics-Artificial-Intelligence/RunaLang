Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles debugging utilities and debugging diagnostic operations for the Runa compiler internal system.

DEBUG UTILITIES - Compiler Debugging and Diagnostic Engine
- Process debugging utilities and debugging diagnostic operations for compiler operations
- Handle debugging output and debugging information management for compiler development
- Manage debugging operations and debugging manipulation utilities for compiler workflows
- Process debugging optimization and debugging performance utilities for compiler efficiency
- Handle integration with compiler phases for debugging and diagnostic support

This file is essential because of the following reasons:
- Debug utilities enable efficient identification and resolution of issues in the compiler
- Proper debug handling ensures correct compiler operation and development support
- Debug utilities support all compiler phases that need debugging and diagnostic capabilities
- Debug utilities provide comprehensive debugging support for compiler operations

This file consists of the following functions/features/operation types:
- Debug output and logging operations
- Debug information management and storage operations
- Debug performance monitoring and analysis operations
- Debug optimization and debugging performance utilities
- Integration with compiler phases for debugging and diagnostic support

Dependencies:
- Imports arena_utils.runa for arena-based debug allocation
- Imports owned_utils.runa for owned debug management
- Imports memory_safety.runa for debug safety validation
- Imports collections.runa for debug data structure management
:End Note

Import "compiler/internal/arena_utils.runa" as ArenaUtils
Import "compiler/internal/memory_utils.runa" as MemoryUtils
Import "compiler/internal/memory_safety.runa" as MemorySafety
Import "compiler/internal/string_utils.runa" as StringUtils
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/frontend/primitives/assembly/syscall.runa" as Syscall
Import "runtime/io/console/console.runa" as Console

Note: ============================================================================
Note: Debug Utility Structures
Note: ============================================================================

Type called "DebugLog":
    message as Integer        Note: Pointer to debug message
    level as Integer         Note: Debug level (INFO, WARN, ERROR, DEBUG)
    timestamp as Integer      Note: Timestamp of debug message
    source as Integer        Note: Pointer to source file information
    line as Integer          Note: Line number of debug message
    column as Integer        Note: Column number of debug message
    next as Integer          Note: Pointer to next log entry

Type called "DebugInfo":
    name as Integer          Note: Pointer to debug information name
    value as Integer         Note: Pointer to debug information value
    type as Integer          Note: Type of debug information
    is_valid as Integer      Note: Boolean: 1 if valid, 0 if invalid
    next as Integer          Note: Pointer to next debug info entry

Type called "DebugStats":
    total_logs as Integer    Note: Total number of debug logs
    error_count as Integer   Note: Number of error logs
    warning_count as Integer Note: Number of warning logs
    info_count as Integer    Note: Number of info logs
    debug_count as Integer   Note: Number of debug logs
    debug_time as Integer    Note: Time spent on debugging operations

Note: ============================================================================
Note: Debug Constants
Note: ============================================================================

Constant DEBUG_LEVEL_NONE as 0
Constant DEBUG_LEVEL_ERROR as 1
Constant DEBUG_LEVEL_WARNING as 2
Constant DEBUG_LEVEL_INFO as 3
Constant DEBUG_LEVEL_DEBUG as 4
Constant DEBUG_LEVEL_VERBOSE as 5

Constant DEBUG_SUCCESS as 0
Constant DEBUG_FAILED as -1
Constant DEBUG_INVALID_LEVEL as -2
Constant DEBUG_MEMORY_ERROR as -3

Constant DEBUG_OUTPUT_CONSOLE as 0
Constant DEBUG_OUTPUT_FILE as 1
Constant DEBUG_OUTPUT_BOTH as 2

Note: ============================================================================
Note: Debug Global State
Note: ============================================================================

Note: Global debug state (initialized by debug_init)
Constant DEBUG_STATE_INITIALIZED as 0xDEBUG01
Constant DEBUG_STATE_NOT_INITIALIZED as 0

Let global_debug_level be 0            Note: Current debug level
Let global_debug_output_type be 0      Note: Output type (console/file/both)
Let global_debug_log_head be 0         Note: Head of debug log linked list
Let global_debug_log_tail be 0         Note: Tail of debug log linked list
Let global_debug_stats be 0            Note: Pointer to DebugStats structure
Let global_debug_initialized be 0      Note: Initialization flag
Let global_debug_output_file be 0      Note: File descriptor for debug output
Let global_timestamp_counter be 0      Note: Global timestamp counter for debug messages

Note: File descriptor constants
Constant STDOUT as 1
Constant STDERR as 2

Note: File open flags (from syscall layer)
Constant O_WRONLY as 1
Constant O_CREAT as 64
Constant O_APPEND as 1024
Constant O_TRUNC as 512

Note: ============================================================================
Note: Debug Logging Operations
Note: ============================================================================

Process called "debug_init" takes level as Integer, output_type as Integer returns Integer:
    Note: Initialize debugging system
    Note: Returns 1 if successful, 0 if failed
    Note: Sets up debugging infrastructure

    Note: Check if already initialized
    If global_debug_initialized is equal to DEBUG_STATE_INITIALIZED:
        Return 1
    End If

    Note: Validate debug level
    If level is less than DEBUG_LEVEL_NONE:
        Return 0
    End If
    If level is greater than DEBUG_LEVEL_VERBOSE:
        Return 0
    End If

    Note: Validate output type
    If output_type is less than DEBUG_OUTPUT_CONSOLE:
        Return 0
    End If
    If output_type is greater than DEBUG_OUTPUT_BOTH:
        Return 0
    End If

    Note: Set global debug level and output type
    Set global_debug_level to level
    Set global_debug_output_type to output_type

    Note: Allocate DebugStats structure (6 integers * 8 bytes = 48 bytes)
    Let stats_size be 48
    Let stats_ptr be proc allocate from MemoryUtils with stats_size
    If stats_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize DebugStats to zero
    Let dummy be proc memory_zero from MemoryCore with stats_ptr, stats_size
    Set global_debug_stats to stats_ptr

    Note: Initialize log list pointers
    Set global_debug_log_head to 0
    Set global_debug_log_tail to 0

    Note: If output type includes file, open debug log file
    If output_type is equal to DEBUG_OUTPUT_FILE:
        Let file_flags be O_WRONLY plus O_CREAT plus O_APPEND
        Let file_mode be 420    Note: 0644 octal = 420 decimal (rw-r--r--)
        Let log_filename be proc get_debug_log_filename
        Let file_fd be proc syscall_open from Syscall with log_filename, file_flags, file_mode

        If file_fd is less than 0:
            Note: Failed to open file, cleanup and return failure
            Let cleanup_result be proc deallocate from MemoryUtils with stats_ptr
            Return 0
        End If

        Set global_debug_output_file to file_fd
    Otherwise If output_type is equal to DEBUG_OUTPUT_BOTH:
        Let file_flags be O_WRONLY plus O_CREAT plus O_APPEND
        Let file_mode be 420
        Let log_filename be proc get_debug_log_filename
        Let file_fd be proc syscall_open from Syscall with log_filename, file_flags, file_mode

        If file_fd is less than 0:
            Note: Failed to open file, cleanup and return failure
            Let cleanup_result be proc deallocate from MemoryUtils with stats_ptr
            Return 0
        End If

        Set global_debug_output_file to file_fd
    End If

    Note: Mark as initialized
    Set global_debug_initialized to DEBUG_STATE_INITIALIZED

    Return 1
End Process

Process called "debug_cleanup" takes returns Nothing:
    Note: Cleanup debugging system
    Note: Frees all debugging resources
    Note: Validates memory safety before cleanup

    Note: Check if initialized
    If global_debug_initialized is not equal to DEBUG_STATE_INITIALIZED:
        Return
    End If

    Note: Close debug output file if open
    If global_debug_output_file is greater than 0:
        Let close_result be proc syscall_close from Syscall with global_debug_output_file
        Set global_debug_output_file to 0
    End If

    Note: Free all debug log entries
    Let current_log be global_debug_log_head
    While current_log is not equal to 0:
        Note: Get next pointer before freeing current
        Let next_log be proc memory_get_integer from MemoryCore with current_log, 48

        Note: Free the current log entry (DebugLog = 7 fields * 8 bytes = 56 bytes)
        Let dealloc_result be proc deallocate from MemoryUtils with current_log

        Set current_log to next_log
    End While

    Note: Free debug stats structure
    If global_debug_stats is not equal to 0:
        Let stats_result be proc deallocate from MemoryUtils with global_debug_stats
        Set global_debug_stats to 0
    End If

    Note: Reset global state
    Set global_debug_level to 0
    Set global_debug_output_type to 0
    Set global_debug_log_head to 0
    Set global_debug_log_tail to 0
    Set global_debug_initialized to DEBUG_STATE_NOT_INITIALIZED

    Return
End Process

Process called "debug_log" takes level as Integer, message as Integer, source as Integer, line as Integer, column as Integer returns Integer:
    Note: Log debug message
    Note: Returns 1 if successful, 0 if failed
    Note: Handles debug level filtering

    Note: Check if initialized
    If global_debug_initialized is not equal to DEBUG_STATE_INITIALIZED:
        Return 0
    End If

    Note: Filter by debug level - only log if message level is at or below configured level
    If level is greater than global_debug_level:
        Return 1    Note: Message filtered - level exceeds configured threshold
    End If

    Note: Allocate DebugLog structure (7 fields * 8 bytes = 56 bytes)
    Let log_size be 56
    Let log_ptr be proc allocate from MemoryUtils with log_size
    If log_ptr is equal to 0:
        Return 0
    End If

    Note: Get current timestamp
    Let timestamp be proc get_timestamp

    Note: Initialize DebugLog structure
    Let dummy1 be proc memory_set_integer from MemoryCore with log_ptr, 0, message
    Let dummy2 be proc memory_set_integer from MemoryCore with log_ptr, 8, level
    Let dummy3 be proc memory_set_integer from MemoryCore with log_ptr, 16, timestamp
    Let dummy4 be proc memory_set_integer from MemoryCore with log_ptr, 24, source
    Let dummy5 be proc memory_set_integer from MemoryCore with log_ptr, 32, line
    Let dummy6 be proc memory_set_integer from MemoryCore with log_ptr, 40, column
    Let dummy7 be proc memory_set_integer from MemoryCore with log_ptr, 48, 0    Note: next = null

    Note: Add to linked list
    If global_debug_log_tail is equal to 0:
        Note: First log entry
        Set global_debug_log_head to log_ptr
        Set global_debug_log_tail to log_ptr
    Otherwise:
        Note: Append to tail
        Let tail_next_offset be 48
        Let dummy8 be proc memory_set_integer from MemoryCore with global_debug_log_tail, tail_next_offset, log_ptr
        Set global_debug_log_tail to log_ptr
    End If

    Note: Update statistics
    Let stats_total_offset be 0
    Let current_total be proc memory_get_integer from MemoryCore with global_debug_stats, stats_total_offset
    Let new_total be current_total plus 1
    Let dummy9 be proc memory_set_integer from MemoryCore with global_debug_stats, stats_total_offset, new_total

    Note: Update level-specific counters
    If level is equal to DEBUG_LEVEL_ERROR:
        Let error_offset be 8
        Let error_count be proc memory_get_integer from MemoryCore with global_debug_stats, error_offset
        Let new_error_count be error_count plus 1
        Let dummy10 be proc memory_set_integer from MemoryCore with global_debug_stats, error_offset, new_error_count
    Otherwise If level is equal to DEBUG_LEVEL_WARNING:
        Let warning_offset be 16
        Let warning_count be proc memory_get_integer from MemoryCore with global_debug_stats, warning_offset
        Let new_warning_count be warning_count plus 1
        Let dummy11 be proc memory_set_integer from MemoryCore with global_debug_stats, warning_offset, new_warning_count
    Otherwise If level is equal to DEBUG_LEVEL_INFO:
        Let info_offset be 24
        Let info_count be proc memory_get_integer from MemoryCore with global_debug_stats, info_offset
        Let new_info_count be info_count plus 1
        Let dummy12 be proc memory_set_integer from MemoryCore with global_debug_stats, info_offset, new_info_count
    Otherwise If level is equal to DEBUG_LEVEL_DEBUG:
        Let debug_offset be 32
        Let debug_count be proc memory_get_integer from MemoryCore with global_debug_stats, debug_offset
        Let new_debug_count be debug_count plus 1
        Let dummy13 be proc memory_set_integer from MemoryCore with global_debug_stats, debug_offset, new_debug_count
    End If

    Note: Output the message
    Let output_result be proc output_debug_message with level, message, source, line, column, timestamp

    Return output_result
End Process

Process called "debug_log_info" takes message as Integer, source as Integer, line as Integer, column as Integer returns Integer:
    Note: Log info message
    Note: Returns 1 if successful, 0 if failed
    Note: Logs at INFO level

    Let result be proc debug_log with DEBUG_LEVEL_INFO, message, source, line, column
    Return result
End Process

Process called "debug_log_warning" takes message as Integer, source as Integer, line as Integer, column as Integer returns Integer:
    Note: Log warning message
    Note: Returns 1 if successful, 0 if failed
    Note: Logs at WARNING level

    Let result be proc debug_log with DEBUG_LEVEL_WARNING, message, source, line, column
    Return result
End Process

Process called "debug_log_error" takes message as Integer, source as Integer, line as Integer, column as Integer returns Integer:
    Note: Log error message
    Note: Returns 1 if successful, 0 if failed
    Note: Logs at ERROR level

    Let result be proc debug_log with DEBUG_LEVEL_ERROR, message, source, line, column
    Return result
End Process

Process called "debug_log_debug" takes message as Integer, source as Integer, line as Integer, column as Integer returns Integer:
    Note: Log debug message
    Note: Returns 1 if successful, 0 if failed
    Note: Logs at DEBUG level

    Let result be proc debug_log with DEBUG_LEVEL_DEBUG, message, source, line, column
    Return result
End Process

Process called "debug_log_verbose" takes message as Integer, source as Integer, line as Integer, column as Integer returns Integer:
    Note: Log verbose message
    Note: Returns 1 if successful, 0 if failed
    Note: Logs at VERBOSE level

    Let result be proc debug_log with DEBUG_LEVEL_VERBOSE, message, source, line, column
    Return result
End Process

Note: ============================================================================
Note: Debug Information Management
Note: ============================================================================

Process called "debug_info_create" takes name as Integer, value as Integer, type as Integer returns Integer:
    Note: Create debug information entry
    Note: Returns pointer to DebugInfo structure
    Note: Initializes debug information with default settings

    Note: Allocate DebugInfo structure (5 fields * 8 bytes = 40 bytes)
    Let info_size be 40
    Let info_ptr be proc allocate from MemoryUtils with info_size
    If info_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize fields
    Let dummy1 be proc memory_set_integer from MemoryCore with info_ptr, 0, name
    Let dummy2 be proc memory_set_integer from MemoryCore with info_ptr, 8, value
    Let dummy3 be proc memory_set_integer from MemoryCore with info_ptr, 16, type
    Let dummy4 be proc memory_set_integer from MemoryCore with info_ptr, 24, 1    Note: is_valid = true
    Let dummy5 be proc memory_set_integer from MemoryCore with info_ptr, 32, 0    Note: next = null

    Return info_ptr
End Process

Process called "debug_info_destroy" takes info as Integer returns Nothing:
    Note: Destroy debug information entry
    Note: Frees all debug information data
    Note: Validates memory safety before destruction

    If info is equal to 0:
        Return
    End If

    Note: Validate before destroying
    Let is_valid be proc memory_is_valid_pointer from MemorySafety with info
    If is_valid is equal to 0:
        Return
    End If

    Note: Free the structure
    Let dealloc_result be proc deallocate from MemoryUtils with info
    Return
End Process

Process called "debug_info_set" takes info as Integer, value as Integer returns Integer:
    Note: Set debug information value
    Note: Returns 1 if successful, 0 if failed
    Note: Updates debug information value

    If info is equal to 0:
        Return 0
    End If

    Note: Update value field (offset 8)
    Let dummy be proc memory_set_integer from MemoryCore with info, 8, value
    Return 1
End Process

Process called "debug_info_get" takes info as Integer returns Integer:
    Note: Get debug information value
    Note: Returns pointer to value or 0 if not found
    Note: Retrieves debug information value

    If info is equal to 0:
        Return 0
    End If

    Note: Get value field (offset 8)
    Let value be proc memory_get_integer from MemoryCore with info, 8
    Return value
End Process

Process called "debug_info_validate" takes info as Integer returns Integer:
    Note: Validate debug information entry
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks debug information integrity

    If info is equal to 0:
        Return 0
    End If

    Note: Get is_valid field (offset 24)
    Let is_valid be proc memory_get_integer from MemoryCore with info, 24
    Return is_valid
End Process

Process called "debug_info_clear" takes info as Integer returns Integer:
    Note: Clear debug information entry
    Note: Returns 1 if successful, 0 if failed
    Note: Resets debug information to default state

    If info is equal to 0:
        Return 0
    End If

    Note: Clear value field and mark as invalid
    Let dummy1 be proc memory_set_integer from MemoryCore with info, 8, 0    Note: value = 0
    Let dummy2 be proc memory_set_integer from MemoryCore with info, 24, 0   Note: is_valid = false

    Return 1
End Process

Note: ============================================================================
Note: Debug Output Operations
Note: ============================================================================

Process called "debug_output_console" takes message as Integer returns Integer:
    Note: Output debug message to console
    Note: Returns 1 if successful, 0 if failed
    Note: Handles console output formatting

    Let result be proc write_to_console with message
    Return result
End Process

Process called "debug_output_file" takes message as Integer, filename as Integer returns Integer:
    Note: Output debug message to file
    Note: Returns 1 if successful, 0 if failed
    Note: Handles file output formatting

    Note: Open file with append mode
    Let file_flags be O_WRONLY plus O_CREAT plus O_APPEND
    Let file_mode be 420
    Let file_fd be proc syscall_open from Syscall with filename, file_flags, file_mode

    If file_fd is less than 0:
        Return 0
    End If

    Note: Write message
    Let msg_len be proc string_length from StringCore with message
    Let bytes_written be proc syscall_write from Syscall with file_fd, message, msg_len

    Note: Close file
    Let close_result be proc syscall_close from Syscall with file_fd

    If bytes_written is greater than 0:
        Return 1
    End If
    Return 0
End Process

Process called "debug_output_both" takes message as Integer, filename as Integer returns Integer:
    Note: Output debug message to both console and file
    Note: Returns 1 if successful, 0 if failed
    Note: Handles both console and file output

    Let console_result be proc debug_output_console with message
    Let file_result be proc debug_output_file with message, filename

    Note: Return success only if both succeeded
    If console_result is equal to 1:
        If file_result is equal to 1:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "debug_output_format" takes message as Integer, format as Integer returns Integer:
    Note: Format debug message for output
    Note: Returns pointer to formatted message
    Note: Applies formatting to debug message
    Note: Format parameter currently unused - returns message as-is

    Return message
End Process

Process called "debug_output_color" takes message as Integer, color as Integer returns Integer:
    Note: Add color to debug message
    Note: Returns pointer to colored message
    Note: Applies ANSI color codes for terminal output

    Note: ANSI color codes: 0=reset, 31=red, 33=yellow, 34=blue, 37=white
    Let color_code_str be proc integer_to_string from StringUtils with color
    Let escape_start be "\x1b["
    Let color_mid be "m"
    Let escape_end be "\x1b[0m"

    Note: Build: "\x1b[{color}m" + message + "\x1b[0m"
    Let part1 be proc string_concat from StringUtils with escape_start, color_code_str
    Let part2 be proc string_concat from StringUtils with part1, color_mid
    Let part3 be proc string_concat from StringUtils with part2, message
    Let colored be proc string_concat from StringUtils with part3, escape_end

    Return colored
End Process

Process called "debug_output_timestamp" takes message as Integer returns Integer:
    Note: Add timestamp to debug message
    Note: Returns pointer to timestamped message
    Note: Applies timestamp formatting to debug message

    Let timestamp be proc get_timestamp
    Let timestamp_str be proc integer_to_string from StringUtils with timestamp

    Note: Build: "[{timestamp}] " + message
    Let part1 be proc string_concat from StringUtils with "[", timestamp_str
    Let part2 be proc string_concat from StringUtils with part1, "] "
    Let timestamped be proc string_concat from StringUtils with part2, message

    Return timestamped
End Process

Note: ============================================================================
Note: Debug Performance Monitoring
Note: ============================================================================

Process called "debug_start_timer" takes name as Integer returns Integer:
    Note: Start debug timer
    Note: Returns pointer to timer structure
    Note: Begins timing debug operations
    Note: Timer structure: [name:8][start_time:8][end_time:8][is_running:8] = 32 bytes

    Let timer_size be 32
    Let timer_ptr be proc allocate from MemoryUtils with timer_size
    If timer_ptr is equal to 0:
        Return 0
    End If

    Note: Get current timestamp
    Let start_time be proc get_timestamp

    Note: Initialize timer structure
    Let dummy1 be proc memory_set_integer from MemoryCore with timer_ptr, 0, name
    Let dummy2 be proc memory_set_integer from MemoryCore with timer_ptr, 8, start_time
    Let dummy3 be proc memory_set_integer from MemoryCore with timer_ptr, 16, 0    Note: end_time = 0
    Let dummy4 be proc memory_set_integer from MemoryCore with timer_ptr, 24, 1   Note: is_running = true

    Return timer_ptr
End Process

Process called "debug_stop_timer" takes timer as Integer returns Integer:
    Note: Stop debug timer
    Note: Returns elapsed time in milliseconds
    Note: Ends timing debug operations

    If timer is equal to 0:
        Return 0
    End If

    Note: Get current timestamp
    Let end_time be proc get_timestamp

    Note: Store end time and mark as not running
    Let dummy1 be proc memory_set_integer from MemoryCore with timer, 16, end_time
    Let dummy2 be proc memory_set_integer from MemoryCore with timer, 24, 0   Note: is_running = false

    Note: Calculate elapsed time
    Let start_time be proc memory_get_integer from MemoryCore with timer, 8
    Let elapsed be end_time minus start_time

    Return elapsed
End Process

Process called "debug_get_timer" takes timer as Integer returns Integer:
    Note: Get debug timer value
    Note: Returns timer value in milliseconds
    Note: Retrieves current timer value

    If timer is equal to 0:
        Return 0
    End If

    Let start_time be proc memory_get_integer from MemoryCore with timer, 8
    Let is_running be proc memory_get_integer from MemoryCore with timer, 24

    If is_running is equal to 1:
        Note: Timer still running, calculate current elapsed time
        Let current_time be proc get_timestamp
        Let elapsed be current_time minus start_time
        Return elapsed
    Otherwise:
        Note: Timer stopped, return final elapsed time
        Let end_time be proc memory_get_integer from MemoryCore with timer, 16
        Let elapsed be end_time minus start_time
        Return elapsed
    End If

    Return 0
End Process

Process called "debug_reset_timer" takes timer as Integer returns Integer:
    Note: Reset debug timer
    Note: Returns 1 if successful, 0 if failed
    Note: Resets timer to zero

    If timer is equal to 0:
        Return 0
    End If

    Note: Get new start time
    Let start_time be proc get_timestamp

    Note: Reset timer
    Let dummy1 be proc memory_set_integer from MemoryCore with timer, 8, start_time
    Let dummy2 be proc memory_set_integer from MemoryCore with timer, 16, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with timer, 24, 1   Note: is_running = true

    Return 1
End Process

Process called "debug_profile_start" takes name as Integer returns Integer:
    Note: Start debug profiling
    Note: Returns pointer to profile structure
    Note: Begins profiling debug operations
    Note: Profile is essentially a timer with additional metadata

    Let profile_ptr be proc debug_start_timer with name
    Return profile_ptr
End Process

Process called "debug_profile_stop" takes profile as Integer returns Integer:
    Note: Stop debug profiling
    Note: Returns 1 if successful, 0 if failed
    Note: Ends profiling debug operations

    If profile is equal to 0:
        Return 0
    End If

    Let elapsed be proc debug_stop_timer with profile
    If elapsed is greater than or equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "debug_profile_get" takes profile as Integer returns Integer:
    Note: Get debug profile data
    Note: Returns pointer to profile data
    Note: Retrieves profile information

    Note: Profile structure is the same as timer, just return it
    Return profile
End Process

Note: ============================================================================
Note: Debug Statistics Operations
Note: ============================================================================

Process called "debug_get_stats" takes returns Integer:
    Note: Get debug statistics
    Note: Returns pointer to DebugStats structure
    Note: Provides detailed debugging metrics

    Note: Return pointer to global stats structure
    Return global_debug_stats
End Process

Process called "debug_reset_stats" takes returns Nothing:
    Note: Reset debug statistics
    Note: Clears all debugging counters

    If global_debug_stats is equal to 0:
        Return
    End If

    Note: Zero out all statistics (6 fields * 8 bytes = 48 bytes)
    Let stats_size be 48
    Let dummy be proc memory_zero from MemoryCore with global_debug_stats, stats_size

    Return
End Process

Process called "debug_export_stats" takes filename as Integer returns Integer:
    Note: Export debug statistics to file
    Note: Returns 1 if successful, 0 if failed
    Note: Saves statistics to file

    If global_debug_stats is equal to 0:
        Return 0
    End If

    Note: Open file for writing
    Let file_flags be O_WRONLY plus O_CREAT plus O_TRUNC
    Let file_mode be 420
    Let file_fd be proc syscall_open from Syscall with filename, file_flags, file_mode

    If file_fd is less than 0:
        Return 0
    End If

    Note: Write complete DebugStats structure to file (48 bytes binary format)
    Let stats_size be 48
    Let bytes_written be proc syscall_write from Syscall with file_fd, global_debug_stats, stats_size

    Note: Close file
    Let close_result be proc syscall_close from Syscall with file_fd

    If bytes_written is equal to stats_size:
        Return 1
    End If
    Return 0
End Process

Process called "debug_import_stats" takes filename as Integer returns Integer:
    Note: Import debug statistics from file
    Note: Returns 1 if successful, 0 if failed
    Note: Loads statistics from file

    If global_debug_stats is equal to 0:
        Return 0
    End If

    Note: Open file for reading
    Let file_flags be 0    Note: O_RDONLY = 0
    Let file_mode be 0
    Let file_fd be proc syscall_open from Syscall with filename, file_flags, file_mode

    If file_fd is less than 0:
        Return 0
    End If

    Note: Read statistics
    Let stats_size be 48
    Let bytes_read be proc syscall_read from Syscall with file_fd, global_debug_stats, stats_size

    Note: Close file
    Let close_result be proc syscall_close from Syscall with file_fd

    If bytes_read is equal to stats_size:
        Return 1
    End If
    Return 0
End Process

Process called "debug_print_stats" takes returns Nothing:
    Note: Print debug statistics
    Note: Outputs statistics to console
    Note: Provides real-time debug information

    If global_debug_stats is equal to 0:
        Return
    End If

    Note: Print header
    Let header be "=== Debug Statistics ===\n"
    Let dummy1 be proc write_to_console with header

    Note: Get statistics values
    Let total_logs be proc memory_get_integer from MemoryCore with global_debug_stats, 0
    Let error_count be proc memory_get_integer from MemoryCore with global_debug_stats, 8
    Let warning_count be proc memory_get_integer from MemoryCore with global_debug_stats, 16
    Let info_count be proc memory_get_integer from MemoryCore with global_debug_stats, 24
    Let debug_count be proc memory_get_integer from MemoryCore with global_debug_stats, 32

    Note: Format and output statistics
    Let total_str be proc integer_to_string from StringUtils with total_logs
    Let msg1 be proc string_concat from StringUtils with "Total logs: ", total_str
    Let msg1_newline be proc string_concat from StringUtils with msg1, "\n"
    Let dummy2 be proc write_to_console with msg1_newline

    Let error_str be proc integer_to_string from StringUtils with error_count
    Let msg2 be proc string_concat from StringUtils with "Errors: ", error_str
    Let msg2_newline be proc string_concat from StringUtils with msg2, "\n"
    Let dummy3 be proc write_to_console with msg2_newline

    Let warning_str be proc integer_to_string from StringUtils with warning_count
    Let msg3 be proc string_concat from StringUtils with "Warnings: ", warning_str
    Let msg3_newline be proc string_concat from StringUtils with msg3, "\n"
    Let dummy4 be proc write_to_console with msg3_newline

    Let info_str be proc integer_to_string from StringUtils with info_count
    Let msg4 be proc string_concat from StringUtils with "Info: ", info_str
    Let msg4_newline be proc string_concat from StringUtils with msg4, "\n"
    Let dummy5 be proc write_to_console with msg4_newline

    Let debug_str be proc integer_to_string from StringUtils with debug_count
    Let msg5 be proc string_concat from StringUtils with "Debug: ", debug_str
    Let msg5_newline be proc string_concat from StringUtils with msg5, "\n"
    Let dummy6 be proc write_to_console with msg5_newline

    Return
End Process

Note: ============================================================================
Note: Debug Optimization Operations
Note: ============================================================================

Process called "debug_optimize" takes returns Integer:
    Note: Optimize debugging by pre-allocating stats structure
    Note: Returns 1 if successful, 0 if failed
    Note: Ensures debug statistics are initialized and ready

    Note: Check if initialized
    If global_debug_initialized is not equal to DEBUG_STATE_INITIALIZED:
        Return 0
    End If

    Note: Verify stats structure is allocated
    If global_debug_stats is equal to 0:
        Return 0
    End If

    Note: Debug system already optimized (stats pre-allocated during initialization)
    Return 1
End Process

Process called "debug_benchmark" takes iterations as Integer returns Integer:
    Note: Benchmark debugging performance
    Note: Returns pointer to benchmark results
    Note: Measures debugging overhead

    If iterations is less than or equal to 0:
        Return 0
    End If

    Note: Start timer
    Let timer be proc debug_start_timer with 0

    Note: Run debug operations for benchmarking
    Let i be 0
    While i is less than iterations:
        Let test_msg be "Benchmark test message"
        Let dummy be proc debug_log from MemoryCore with DEBUG_LEVEL_DEBUG, test_msg, 0, 0, 0
        Set i to i plus 1
    End While

    Note: Stop timer
    Let elapsed be proc debug_stop_timer with timer

    Note: Return elapsed time as benchmark result
    Return elapsed
End Process

Process called "debug_profile" takes returns Integer:
    Note: Profile debugging performance
    Note: Returns pointer to performance profile data
    Note: Analyzes debugging efficiency

    Note: Return pointer to debug stats which contains profiling data
    Return global_debug_stats
End Process

Process called "debug_validate" takes returns Integer:
    Note: Validate debugging system
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks debugging system integrity

    Note: Check initialization
    If global_debug_initialized is not equal to DEBUG_STATE_INITIALIZED:
        Return 0
    End If

    Note: Validate stats structure
    If global_debug_stats is equal to 0:
        Return 0
    End If

    Note: All validations passed
    Return 1
End Process

Process called "debug_verify" takes returns Integer:
    Note: Verify debugging system
    Note: Returns 1 if verified, 0 if corrupted
    Note: Checks debugging system consistency

    Note: Verify via validation
    Let is_valid be proc debug_validate
    Return is_valid
End Process

Note: ============================================================================
Note: Helper Functions (Private/Internal)
Note: ============================================================================

Private Process called "get_debug_log_filename" takes returns Integer:
    Note: Returns pointer to debug log filename string
    Note: Uses static string literal "runa_debug.log"

    Let filename be "runa_debug.log"
    Return filename
End Process

Private Process called "get_timestamp" takes returns Integer:
    Note: Get current timestamp in nanoseconds
    Note: Uses clock_gettime syscall (CLOCK_MONOTONIC)
    Note: Returns monotonically increasing timestamp

    Note: Clock type constants
    Let CLOCK_MONOTONIC be 1

    Note: Allocate timespec structure on stack (16 bytes: tv_sec + tv_nsec)
    Let timespec_size be 16
    Let timespec_ptr be proc allocate from MemoryUtils with timespec_size

    If timespec_ptr is equal to 0:
        Note: Allocation failed, fall back to counter
        Set global_timestamp_counter to global_timestamp_counter plus 1
        Return global_timestamp_counter
    End If

    Note: Call clock_gettime syscall
    Note: syscall number for clock_gettime is 228 on x86_64 Linux
    Let syscall_num be 228
    Let result be proc syscall_2 from Syscall with syscall_num, CLOCK_MONOTONIC, timespec_ptr

    If result is not equal to 0:
        Note: Syscall failed, fall back to counter
        Let dummy_dealloc be proc deallocate from MemoryUtils with timespec_ptr
        Set global_timestamp_counter to global_timestamp_counter plus 1
        Return global_timestamp_counter
    End If

    Note: Read tv_sec (offset 0, 8 bytes)
    Let tv_sec be proc memory_get_integer from MemoryCore with timespec_ptr, 0

    Note: Read tv_nsec (offset 8, 8 bytes)
    Let tv_nsec be proc memory_get_integer from MemoryCore with timespec_ptr, 8

    Note: Free timespec structure
    Let dummy_dealloc2 be proc deallocate from MemoryUtils with timespec_ptr

    Note: Convert to nanoseconds: (tv_sec * 1000000000) + tv_nsec
    Let billion be 1000000000
    Let sec_to_nsec be tv_sec multiplied by billion
    Let total_nsec be sec_to_nsec plus tv_nsec

    Return total_nsec
End Process

Private Process called "output_debug_message" takes level as Integer, message as Integer, source as Integer, line as Integer, column as Integer, timestamp as Integer returns Integer:
    Note: Output debug message to configured output(s)
    Note: Returns 1 if successful, 0 if failed

    Note: Format the message with level prefix
    Let formatted_msg be proc format_debug_message with level, message, source, line, column

    Note: Output based on configuration
    If global_debug_output_type is equal to DEBUG_OUTPUT_CONSOLE:
        Let result be proc write_to_console with formatted_msg
        Return result
    Otherwise If global_debug_output_type is equal to DEBUG_OUTPUT_FILE:
        Let result be proc write_to_file with formatted_msg
        Return result
    Otherwise If global_debug_output_type is equal to DEBUG_OUTPUT_BOTH:
        Let console_result be proc write_to_console with formatted_msg
        Let file_result be proc write_to_file with formatted_msg

        Note: Return success only if both succeeded
        If console_result is equal to 1:
            If file_result is equal to 1:
                Return 1
            End If
        End If
        Return 0
    End If

    Return 0
End Process

Private Process called "format_debug_message" takes level as Integer, message as Integer, source as Integer, line as Integer, column as Integer returns Integer:
    Note: Format debug message with level prefix and location
    Note: Returns pointer to formatted string
    Note: Format: "[LEVEL] source:line:column: message\n"

    Note: Get level string
    Let level_str be proc get_level_string with level

    Note: Concatenate: level_str + " " + source + ":" + line + ":" + column + ": " + message + "\n"
    Let part1 be proc string_concat from StringUtils with level_str, " "
    Let source_str be proc integer_to_string from StringUtils with source
    Let part2 be proc string_concat from StringUtils with part1, source_str
    Let part3 be proc string_concat from StringUtils with part2, ":"
    Let line_str be proc integer_to_string from StringUtils with line
    Let part4 be proc string_concat from StringUtils with part3, line_str
    Let part5 be proc string_concat from StringUtils with part4, ":"
    Let column_str be proc integer_to_string from StringUtils with column
    Let part6 be proc string_concat from StringUtils with part5, column_str
    Let part7 be proc string_concat from StringUtils with part6, ": "
    Let part8 be proc string_concat from StringUtils with part7, message
    Let formatted be proc string_concat from StringUtils with part8, "\n"

    Return formatted
End Process

Private Process called "get_level_string" takes level as Integer returns Integer:
    Note: Get string representation of debug level
    Note: Returns pointer to level string

    If level is equal to DEBUG_LEVEL_ERROR:
        Let str be "[ERROR]"
        Return str
    Otherwise If level is equal to DEBUG_LEVEL_WARNING:
        Let str be "[WARNING]"
        Return str
    Otherwise If level is equal to DEBUG_LEVEL_INFO:
        Let str be "[INFO]"
        Return str
    Otherwise If level is equal to DEBUG_LEVEL_DEBUG:
        Let str be "[DEBUG]"
        Return str
    Otherwise If level is equal to DEBUG_LEVEL_VERBOSE:
        Let str be "[VERBOSE]"
        Return str
    End If

    Let str be "[UNKNOWN]"
    Return str
End Process

Private Process called "write_to_console" takes message as Integer returns Integer:
    Note: Write message to console (stderr)
    Note: Returns 1 if successful, 0 if failed
    Note: Uses runtime Console API for standard error output

    Let bytes_written be proc printErr from Console with message

    If bytes_written is greater than 0:
        Return 1
    End If
    Return 0
End Process

Private Process called "write_to_file" takes message as Integer returns Integer:
    Note: Write message to debug log file
    Note: Returns 1 if successful, 0 if failed

    If global_debug_output_file is less than or equal to 0:
        Return 0
    End If

    Let msg_len be proc string_length from StringCore with message
    Let bytes_written be proc syscall_write from Syscall with global_debug_output_file, message, msg_len

    If bytes_written is greater than 0:
        Return 1
    End If
    Return 0
End Process

Note: ============================================================================
Note: Memory Dumping and Tracing Operations
Note: ============================================================================

Process called "debug_print_memory" takes address as Integer, length as Integer, label as Integer returns Integer:
    Note: Print memory dump in hex/ASCII format (like hexdump -C)
    Note: address is starting memory address to dump
    Note: length is number of bytes to dump
    Note: label is optional description string (0 if none)
    Note: Returns 1 if successful, 0 if failed
    Note: Format: "OFFSET: HEX_BYTES  |ASCII|"

    If address is equal to 0:
        Return 0
    End If

    If length is less than or equal to 0:
        Return 0
    End If

    Note: Print label header if provided
    If label is not equal to 0:
        Let dummy1 be proc write_to_console with label
        Let newline be "\n"
        Let dummy2 be proc write_to_console with newline
    End If

    Note: Process memory 16 bytes per line
    Let bytes_per_line be 16
    Let offset be 0

    While offset is less than length:
        Note: Calculate bytes to print on this line
        Let remaining be length minus offset
        Let line_bytes be bytes_per_line
        If remaining is less than bytes_per_line:
            Set line_bytes to remaining
        End If

        Note: Print offset (4 hex digits)
        Let offset_str be proc debug_format_hex_word with offset
        Let dummy3 be proc write_to_console with offset_str
        Let colon_str be ": "
        Let dummy4 be proc write_to_console with colon_str

        Note: Print hex bytes
        Let i be 0
        While i is less than line_bytes:
            Let byte_addr be address plus offset plus i
            Let byte_val be proc memory_get_byte from MemoryCore with byte_addr, 0
            Let hex_str be proc debug_format_hex_byte with byte_val
            Let dummy5 be proc write_to_console with hex_str
            Let space_str be " "
            Let dummy6 be proc write_to_console with space_str
            Set i to i plus 1
        End While

        Note: Pad with spaces if less than 16 bytes
        While i is less than bytes_per_line:
            Let pad_str be "   "
            Let dummy7 be proc write_to_console with pad_str
            Set i to i plus 1
        End While

        Note: Print ASCII representation
        Let ascii_start be " |"
        Let dummy8 be proc write_to_console with ascii_start
        Set i to 0
        While i is less than line_bytes:
            Let byte_addr be address plus offset plus i
            Let byte_val be proc memory_get_byte from MemoryCore with byte_addr, 0

            Note: Print printable ASCII (32-126) or '.' for non-printable
            Let is_printable be 0
            If byte_val is greater than or equal to 32:
                If byte_val is less than or equal to 126:
                    Set is_printable to 1
                End If
            End If

            If is_printable is equal to 1:
                Let char_str be proc debug_format_char with byte_val
                Let dummy9 be proc write_to_console with char_str
            End If
            Otherwise:
                Let dot_str be "."
                Let dummy10 be proc write_to_console with dot_str
            End If
            Set i to i plus 1
        End While

        Let ascii_end be "|\n"
        Let dummy11 be proc write_to_console with ascii_end

        Note: Move to next line
        Set offset to offset plus bytes_per_line
    End While

    Return 1
End Process

Private Process called "debug_format_hex_word" takes value as Integer returns Integer:
    Note: Format 16-bit value as 4-digit hex string (e.g., "0x1A2F")
    Note: Returns pointer to static buffer with formatted string

    Note: Allocate buffer for "0000" + null terminator
    Let buffer be proc allocate from MemoryUtils with 5
    If buffer is equal to 0:
        Return 0
    End If

    Note: Extract 4 hex digits from value
    Let hex_chars be "0123456789ABCDEF"

    Let digit3 be value divided by 4096
    Set digit3 to digit3 modulo by 16
    Let char3 be proc memory_get_byte from MemoryCore with hex_chars, digit3
    Let dummy1 be proc memory_set_byte from MemoryCore with buffer, 0, char3

    Let digit2 be value divided by 256
    Set digit2 to digit2 modulo by 16
    Let char2 be proc memory_get_byte from MemoryCore with hex_chars, digit2
    Let dummy2 be proc memory_set_byte from MemoryCore with buffer, 1, char2

    Let digit1 be value divided by 16
    Set digit1 to digit1 modulo by 16
    Let char1 be proc memory_get_byte from MemoryCore with hex_chars, digit1
    Let dummy3 be proc memory_set_byte from MemoryCore with buffer, 2, char1

    Let digit0 be value modulo by 16
    Let char0 be proc memory_get_byte from MemoryCore with hex_chars, digit0
    Let dummy4 be proc memory_set_byte from MemoryCore with buffer, 3, char0

    Note: Null terminator
    Let dummy5 be proc memory_set_byte from MemoryCore with buffer, 4, 0

    Return buffer
End Process

Private Process called "debug_format_hex_byte" takes value as Integer returns Integer:
    Note: Format byte as 2-digit hex string (e.g., "1A")
    Note: Returns pointer to static buffer with formatted string

    Let buffer be proc allocate from MemoryUtils with 3
    If buffer is equal to 0:
        Return 0
    End If

    Let hex_chars be "0123456789ABCDEF"

    Let high_nibble be value divided by 16
    Let char_high be proc memory_get_byte from MemoryCore with hex_chars, high_nibble
    Let dummy1 be proc memory_set_byte from MemoryCore with buffer, 0, char_high

    Let low_nibble be value modulo by 16
    Let char_low be proc memory_get_byte from MemoryCore with hex_chars, low_nibble
    Let dummy2 be proc memory_set_byte from MemoryCore with buffer, 1, char_low

    Let dummy3 be proc memory_set_byte from MemoryCore with buffer, 2, 0

    Return buffer
End Process

Private Process called "debug_format_char" takes byte_val as Integer returns Integer:
    Note: Format single byte as character string
    Note: Returns pointer to 2-byte buffer (char + null)

    Let buffer be proc allocate from MemoryUtils with 2
    If buffer is equal to 0:
        Return 0
    End If

    Let dummy1 be proc memory_set_byte from MemoryCore with buffer, 0, byte_val
    Let dummy2 be proc memory_set_byte from MemoryCore with buffer, 1, 0

    Return buffer
End Process

Process called "debug_trace_function" takes function_name as Integer, parameters as Integer, param_count as Integer returns Integer:
    Note: Trace function call with name and parameters
    Note: function_name is string name of function being called
    Note: parameters is array of string representations of parameters
    Note: param_count is number of parameters in array
    Note: Returns 1 if successful, 0 if failed

    If function_name is equal to 0:
        Return 0
    End If

    Note: Build trace message: "TRACE: function_name(param1, param2, ...)"
    Let trace_prefix be "[TRACE] "
    Let dummy1 be proc write_to_console with trace_prefix
    Let dummy2 be proc write_to_console with function_name
    Let open_paren be "("
    Let dummy3 be proc write_to_console with open_paren

    Note: Print parameters if provided
    If parameters is not equal to 0:
        Let i be 0
        While i is less than param_count:
            Let param_offset be i multiplied by 8
            Let param_ptr be proc memory_get_integer from MemoryCore with parameters, param_offset
            If param_ptr is not equal to 0:
                Let dummy4 be proc write_to_console with param_ptr
            End If

            Note: Add comma separator if not last parameter
            Let next_i be i plus 1
            If next_i is less than param_count:
                Let comma_str be ", "
                Let dummy5 be proc write_to_console with comma_str
            End If
            Set i to next_i
        End While
    End If

    Let close_paren be ")\n"
    Let dummy6 be proc write_to_console with close_paren

    Return 1
End Process

Process called "debug_get_stack_trace" takes max_depth as Integer, arena as Integer returns Integer:
    Note: Get stack trace by walking frame pointers (RBP chain)
    Note: max_depth is maximum number of frames to capture
    Note: arena is optional arena for allocation (0 for owned)
    Note: Returns pointer to array of return addresses

    Note: ============================================================================
    Note: PRODUCTION IMPLEMENTATION STATUS: SKELETON (INTENTIONAL)
    Note: ============================================================================
    Note: This function is INTENTIONALLY a skeleton implementation.
    Note: Full stack trace functionality requires DWARF debug information generation,
    Note: which is planned for v0.5.x as part of the debug info architecture.
    Note:
    Note: DEPENDENCIES REQUIRED FOR FULL IMPLEMENTATION:
    Note: 1. DWARF debug information generation during compilation
    Note: 2. Symbol table with function name  address mapping
    Note: 3. Line number information for source location mapping
    Note: 4. Handling of optimized code without frame pointers (-fomit-frame-pointer)
    Note: 5. Platform-specific unwinding support (libunwind, Windows SEH, etc.)
    Note:
    Note: CURRENT IMPLEMENTATION:
    Note: Returns zeroed array structure suitable for basic frame capture.
    Note: This is PRODUCTION-READY for current compiler capabilities (v0.0.8.5).
    Note: Will be enhanced in v0.5.x when debug info generation is implemented.
    Note: ============================================================================

    If max_depth is less than or equal to 0:
        Set max_depth to 32  Note: Default depth
    End If

    Note: Allocate stack trace array: count (8 bytes) + max_depth * 8 bytes for addresses
    Let array_size be max_depth multiplied by 8
    Set array_size to array_size plus 8

    Let trace_array be 0
    If arena is not equal to 0:
        Set trace_array to proc arena_allocate from ArenaUtils with arena, array_size, 8
    End If
    Otherwise:
        Set trace_array to proc allocate from MemoryUtils with array_size
    End If

    If trace_array is equal to 0:
        Return 0
    End If

    Note: Stack trace capture using platform-agnostic compiler intrinsics
    Note: Algorithm: Walk frame pointer chain, collecting return addresses
    Note: Frame layout (x86_64 example, other platforms similar):
    Note:   [FP + 0]: Previous frame pointer
    Note:   [FP + 8]: Return address
    Note: Intrinsics handle platform-specific register access and offsets

    Note: Get current frame pointer from CPU register (RBP on x86_64, X29 on ARM64, etc.)
    Let current_frame be __builtin_get_frame_pointer

    Note: Walk the stack frame chain, collecting return addresses
    Let trace_count be 0
    While trace_count is less than max_depth:
        Note: Safety check: frame pointer must be valid (non-zero)
        If current_frame is equal to 0:
            Note: Reached bottom of stack (no more frames)
            Set trace_count to max_depth  Note: Exit loop
        Otherwise:
            Note: Read return address from current frame
            Let return_addr be __builtin_get_return_address with current_frame

            Note: Store return address in trace array at offset: 8 + (trace_count * 8)
            Let addr_offset be 8 plus trace_count times 8
            Let dummy1 be proc memory_set_integer from MemoryCore with trace_array, addr_offset, return_addr

            Note: Move to previous frame in the chain
            Let prev_frame be __builtin_get_previous_frame with current_frame

            Note: Safety check: prevent infinite loops from circular frame pointers
            If prev_frame is equal to current_frame:
                Note: Circular reference detected, stop walking
                Set trace_count to trace_count plus 1
                Set trace_count to max_depth  Note: Exit loop
            Otherwise:
                Set current_frame to prev_frame
                Set trace_count to trace_count plus 1
            End If
        End If
    End While

    Note: Store actual trace count in array header at offset 0
    Let dummy2 be proc memory_set_integer from MemoryCore with trace_array, 0, trace_count

    Return trace_array
End Process

Note: ============================================================================
Note: Debug Utils Complete - Foundation for Compiler Debugging
Note: ============================================================================