Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles debugging utilities and debugging diagnostic operations for the Runa compiler internal system.

DEBUG UTILITIES - Compiler Debugging and Diagnostic Engine
- Process debugging utilities and debugging diagnostic operations for compiler operations
- Handle debugging output and debugging information management for compiler development
- Manage debugging operations and debugging manipulation utilities for compiler workflows
- Process debugging optimization and debugging performance utilities for compiler efficiency
- Handle integration with compiler phases for debugging and diagnostic support

This file is essential because of the following reasons:
- Debug utilities enable efficient identification and resolution of issues in the compiler
- Proper debug handling ensures correct compiler operation and development support
- Debug utilities support all compiler phases that need debugging and diagnostic capabilities
- Debug utilities provide comprehensive debugging support for compiler operations

This file consists of the following functions/features/operation types:
- Debug output and logging operations
- Debug information management and storage operations
- Debug performance monitoring and analysis operations
- Debug optimization and debugging performance utilities
- Integration with compiler phases for debugging and diagnostic support

Dependencies:
- Imports arena_utils.runa for arena-based debug allocation
- Imports owned_utils.runa for owned debug management
- Imports memory_safety.runa for debug safety validation
- Imports collections.runa for debug data structure management
:End Note

Import "compiler/internal/memory_utils.runa" as MemoryUtils
Import "compiler/internal/memory_safety.runa" as MemorySafety
Import "compiler/internal/string_utils.runa" as StringUtils
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/frontend/primitives/assembly/syscall.runa" as Syscall

Note: ============================================================================
Note: Debug Utility Structures
Note: ============================================================================

Type called "DebugLog":
    message as Integer        Note: Pointer to debug message
    level as Integer         Note: Debug level (INFO, WARN, ERROR, DEBUG)
    timestamp as Integer      Note: Timestamp of debug message
    source as Integer        Note: Pointer to source file information
    line as Integer          Note: Line number of debug message
    column as Integer        Note: Column number of debug message
    next as Integer          Note: Pointer to next log entry

Type called "DebugInfo":
    name as Integer          Note: Pointer to debug information name
    value as Integer         Note: Pointer to debug information value
    type as Integer          Note: Type of debug information
    is_valid as Integer      Note: Boolean: 1 if valid, 0 if invalid
    next as Integer          Note: Pointer to next debug info entry

Type called "DebugStats":
    total_logs as Integer    Note: Total number of debug logs
    error_count as Integer   Note: Number of error logs
    warning_count as Integer Note: Number of warning logs
    info_count as Integer    Note: Number of info logs
    debug_count as Integer   Note: Number of debug logs
    debug_time as Integer    Note: Time spent on debugging operations

Note: ============================================================================
Note: Debug Constants
Note: ============================================================================

Define constant DEBUG_LEVEL_NONE as 0
Define constant DEBUG_LEVEL_ERROR as 1
Define constant DEBUG_LEVEL_WARNING as 2
Define constant DEBUG_LEVEL_INFO as 3
Define constant DEBUG_LEVEL_DEBUG as 4
Define constant DEBUG_LEVEL_VERBOSE as 5

Define constant DEBUG_SUCCESS as 0
Define constant DEBUG_FAILED as -1
Define constant DEBUG_INVALID_LEVEL as -2
Define constant DEBUG_MEMORY_ERROR as -3

Define constant DEBUG_OUTPUT_CONSOLE as 0
Define constant DEBUG_OUTPUT_FILE as 1
Define constant DEBUG_OUTPUT_BOTH as 2

Note: ============================================================================
Note: Debug Global State
Note: ============================================================================

Note: Global debug state (initialized by debug_init)
Define constant DEBUG_STATE_INITIALIZED as 0xDEBUG01
Define constant DEBUG_STATE_NOT_INITIALIZED as 0

Let global_debug_level be 0            Note: Current debug level
Let global_debug_output_type be 0      Note: Output type (console/file/both)
Let global_debug_log_head be 0         Note: Head of debug log linked list
Let global_debug_log_tail be 0         Note: Tail of debug log linked list
Let global_debug_stats be 0            Note: Pointer to DebugStats structure
Let global_debug_initialized be 0      Note: Initialization flag
Let global_debug_output_file be 0      Note: File descriptor for debug output
Let global_timestamp_counter be 0      Note: Global timestamp counter for debug messages

Note: File descriptor constants
Define constant STDOUT as 1
Define constant STDERR as 2

Note: File open flags (from syscall layer)
Define constant O_WRONLY as 1
Define constant O_CREAT as 64
Define constant O_APPEND as 1024
Define constant O_TRUNC as 512

Note: ============================================================================
Note: Debug Logging Operations
Note: ============================================================================

Process called "debug_init" takes level as Integer, output_type as Integer returns Integer:
    Note: Initialize debugging system
    Note: Returns 1 if successful, 0 if failed
    Note: Sets up debugging infrastructure

    Note: Check if already initialized
    If global_debug_initialized is equal to DEBUG_STATE_INITIALIZED:
        Return 1
    End If

    Note: Validate debug level
    If level is less than DEBUG_LEVEL_NONE:
        Return 0
    End If
    If level is greater than DEBUG_LEVEL_VERBOSE:
        Return 0
    End If

    Note: Validate output type
    If output_type is less than DEBUG_OUTPUT_CONSOLE:
        Return 0
    End If
    If output_type is greater than DEBUG_OUTPUT_BOTH:
        Return 0
    End If

    Note: Set global debug level and output type
    Set global_debug_level to level
    Set global_debug_output_type to output_type

    Note: Allocate DebugStats structure (6 integers * 8 bytes = 48 bytes)
    Let stats_size be 48
    Let stats_ptr be proc allocate from MemoryUtils with stats_size
    If stats_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize DebugStats to zero
    Let dummy be proc memory_zero from MemoryCore with stats_ptr, stats_size
    Set global_debug_stats to stats_ptr

    Note: Initialize log list pointers
    Set global_debug_log_head to 0
    Set global_debug_log_tail to 0

    Note: If output type includes file, open debug log file
    If output_type is equal to DEBUG_OUTPUT_FILE:
        Let file_flags be O_WRONLY plus O_CREAT plus O_APPEND
        Let file_mode be 420    Note: 0644 octal = 420 decimal (rw-r--r--)
        Let log_filename be proc get_debug_log_filename
        Let file_fd be proc syscall_open from Syscall with log_filename, file_flags, file_mode

        If file_fd is less than 0:
            Note: Failed to open file, cleanup and return failure
            Let cleanup_result be proc deallocate from MemoryUtils with stats_ptr
            Return 0
        End If

        Set global_debug_output_file to file_fd
    Otherwise If output_type is equal to DEBUG_OUTPUT_BOTH:
        Let file_flags be O_WRONLY plus O_CREAT plus O_APPEND
        Let file_mode be 420
        Let log_filename be proc get_debug_log_filename
        Let file_fd be proc syscall_open from Syscall with log_filename, file_flags, file_mode

        If file_fd is less than 0:
            Note: Failed to open file, cleanup and return failure
            Let cleanup_result be proc deallocate from MemoryUtils with stats_ptr
            Return 0
        End If

        Set global_debug_output_file to file_fd
    End If

    Note: Mark as initialized
    Set global_debug_initialized to DEBUG_STATE_INITIALIZED

    Return 1
End Process

Process called "debug_cleanup" takes returns Nothing:
    Note: Cleanup debugging system
    Note: Frees all debugging resources
    Note: Validates memory safety before cleanup

    Note: Check if initialized
    If global_debug_initialized is not equal to DEBUG_STATE_INITIALIZED:
        Return
    End If

    Note: Close debug output file if open
    If global_debug_output_file is greater than 0:
        Let close_result be proc syscall_close from Syscall with global_debug_output_file
        Set global_debug_output_file to 0
    End If

    Note: Free all debug log entries
    Let current_log be global_debug_log_head
    While current_log is not equal to 0:
        Note: Get next pointer before freeing current
        Let next_log be proc memory_get_integer from MemoryCore with current_log, 48

        Note: Free the current log entry (DebugLog = 7 fields * 8 bytes = 56 bytes)
        Let dealloc_result be proc deallocate from MemoryUtils with current_log

        Set current_log to next_log
    End While

    Note: Free debug stats structure
    If global_debug_stats is not equal to 0:
        Let stats_result be proc deallocate from MemoryUtils with global_debug_stats
        Set global_debug_stats to 0
    End If

    Note: Reset global state
    Set global_debug_level to 0
    Set global_debug_output_type to 0
    Set global_debug_log_head to 0
    Set global_debug_log_tail to 0
    Set global_debug_initialized to DEBUG_STATE_NOT_INITIALIZED

    Return
End Process

Process called "debug_log" takes level as Integer, message as Integer, source as Integer, line as Integer, column as Integer returns Integer:
    Note: Log debug message
    Note: Returns 1 if successful, 0 if failed
    Note: Handles debug level filtering

    Note: Check if initialized
    If global_debug_initialized is not equal to DEBUG_STATE_INITIALIZED:
        Return 0
    End If

    Note: Filter by debug level - only log if message level is at or below configured level
    If level is greater than global_debug_level:
        Return 1    Note: Message filtered - level exceeds configured threshold
    End If

    Note: Allocate DebugLog structure (7 fields * 8 bytes = 56 bytes)
    Let log_size be 56
    Let log_ptr be proc allocate from MemoryUtils with log_size
    If log_ptr is equal to 0:
        Return 0
    End If

    Note: Get current timestamp
    Let timestamp be proc get_timestamp

    Note: Initialize DebugLog structure
    Let dummy1 be proc memory_set_integer from MemoryCore with log_ptr, 0, message
    Let dummy2 be proc memory_set_integer from MemoryCore with log_ptr, 8, level
    Let dummy3 be proc memory_set_integer from MemoryCore with log_ptr, 16, timestamp
    Let dummy4 be proc memory_set_integer from MemoryCore with log_ptr, 24, source
    Let dummy5 be proc memory_set_integer from MemoryCore with log_ptr, 32, line
    Let dummy6 be proc memory_set_integer from MemoryCore with log_ptr, 40, column
    Let dummy7 be proc memory_set_integer from MemoryCore with log_ptr, 48, 0    Note: next = null

    Note: Add to linked list
    If global_debug_log_tail is equal to 0:
        Note: First log entry
        Set global_debug_log_head to log_ptr
        Set global_debug_log_tail to log_ptr
    Otherwise:
        Note: Append to tail
        Let tail_next_offset be 48
        Let dummy8 be proc memory_set_integer from MemoryCore with global_debug_log_tail, tail_next_offset, log_ptr
        Set global_debug_log_tail to log_ptr
    End If

    Note: Update statistics
    Let stats_total_offset be 0
    Let current_total be proc memory_get_integer from MemoryCore with global_debug_stats, stats_total_offset
    Let new_total be current_total plus 1
    Let dummy9 be proc memory_set_integer from MemoryCore with global_debug_stats, stats_total_offset, new_total

    Note: Update level-specific counters
    If level is equal to DEBUG_LEVEL_ERROR:
        Let error_offset be 8
        Let error_count be proc memory_get_integer from MemoryCore with global_debug_stats, error_offset
        Let new_error_count be error_count plus 1
        Let dummy10 be proc memory_set_integer from MemoryCore with global_debug_stats, error_offset, new_error_count
    Otherwise If level is equal to DEBUG_LEVEL_WARNING:
        Let warning_offset be 16
        Let warning_count be proc memory_get_integer from MemoryCore with global_debug_stats, warning_offset
        Let new_warning_count be warning_count plus 1
        Let dummy11 be proc memory_set_integer from MemoryCore with global_debug_stats, warning_offset, new_warning_count
    Otherwise If level is equal to DEBUG_LEVEL_INFO:
        Let info_offset be 24
        Let info_count be proc memory_get_integer from MemoryCore with global_debug_stats, info_offset
        Let new_info_count be info_count plus 1
        Let dummy12 be proc memory_set_integer from MemoryCore with global_debug_stats, info_offset, new_info_count
    Otherwise If level is equal to DEBUG_LEVEL_DEBUG:
        Let debug_offset be 32
        Let debug_count be proc memory_get_integer from MemoryCore with global_debug_stats, debug_offset
        Let new_debug_count be debug_count plus 1
        Let dummy13 be proc memory_set_integer from MemoryCore with global_debug_stats, debug_offset, new_debug_count
    End If

    Note: Output the message
    Let output_result be proc output_debug_message with level, message, source, line, column, timestamp

    Return output_result
End Process

Process called "debug_log_info" takes message as Integer, source as Integer, line as Integer, column as Integer returns Integer:
    Note: Log info message
    Note: Returns 1 if successful, 0 if failed
    Note: Logs at INFO level

    Let result be proc debug_log with DEBUG_LEVEL_INFO, message, source, line, column
    Return result
End Process

Process called "debug_log_warning" takes message as Integer, source as Integer, line as Integer, column as Integer returns Integer:
    Note: Log warning message
    Note: Returns 1 if successful, 0 if failed
    Note: Logs at WARNING level

    Let result be proc debug_log with DEBUG_LEVEL_WARNING, message, source, line, column
    Return result
End Process

Process called "debug_log_error" takes message as Integer, source as Integer, line as Integer, column as Integer returns Integer:
    Note: Log error message
    Note: Returns 1 if successful, 0 if failed
    Note: Logs at ERROR level

    Let result be proc debug_log with DEBUG_LEVEL_ERROR, message, source, line, column
    Return result
End Process

Process called "debug_log_debug" takes message as Integer, source as Integer, line as Integer, column as Integer returns Integer:
    Note: Log debug message
    Note: Returns 1 if successful, 0 if failed
    Note: Logs at DEBUG level

    Let result be proc debug_log with DEBUG_LEVEL_DEBUG, message, source, line, column
    Return result
End Process

Process called "debug_log_verbose" takes message as Integer, source as Integer, line as Integer, column as Integer returns Integer:
    Note: Log verbose message
    Note: Returns 1 if successful, 0 if failed
    Note: Logs at VERBOSE level

    Let result be proc debug_log with DEBUG_LEVEL_VERBOSE, message, source, line, column
    Return result
End Process

Note: ============================================================================
Note: Debug Information Management
Note: ============================================================================

Process called "debug_info_create" takes name as Integer, value as Integer, type as Integer returns Integer:
    Note: Create debug information entry
    Note: Returns pointer to DebugInfo structure
    Note: Initializes debug information with default settings

    Note: Allocate DebugInfo structure (5 fields * 8 bytes = 40 bytes)
    Let info_size be 40
    Let info_ptr be proc allocate from MemoryUtils with info_size
    If info_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize fields
    Let dummy1 be proc memory_set_integer from MemoryCore with info_ptr, 0, name
    Let dummy2 be proc memory_set_integer from MemoryCore with info_ptr, 8, value
    Let dummy3 be proc memory_set_integer from MemoryCore with info_ptr, 16, type
    Let dummy4 be proc memory_set_integer from MemoryCore with info_ptr, 24, 1    Note: is_valid = true
    Let dummy5 be proc memory_set_integer from MemoryCore with info_ptr, 32, 0    Note: next = null

    Return info_ptr
End Process

Process called "debug_info_destroy" takes info as Integer returns Nothing:
    Note: Destroy debug information entry
    Note: Frees all debug information data
    Note: Validates memory safety before destruction

    If info is equal to 0:
        Return
    End If

    Note: Validate before destroying
    Let is_valid be proc memory_is_valid_pointer from MemorySafety with info
    If is_valid is equal to 0:
        Return
    End If

    Note: Free the structure
    Let dealloc_result be proc deallocate from MemoryUtils with info
    Return
End Process

Process called "debug_info_set" takes info as Integer, value as Integer returns Integer:
    Note: Set debug information value
    Note: Returns 1 if successful, 0 if failed
    Note: Updates debug information value

    If info is equal to 0:
        Return 0
    End If

    Note: Update value field (offset 8)
    Let dummy be proc memory_set_integer from MemoryCore with info, 8, value
    Return 1
End Process

Process called "debug_info_get" takes info as Integer returns Integer:
    Note: Get debug information value
    Note: Returns pointer to value or 0 if not found
    Note: Retrieves debug information value

    If info is equal to 0:
        Return 0
    End If

    Note: Get value field (offset 8)
    Let value be proc memory_get_integer from MemoryCore with info, 8
    Return value
End Process

Process called "debug_info_validate" takes info as Integer returns Integer:
    Note: Validate debug information entry
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks debug information integrity

    If info is equal to 0:
        Return 0
    End If

    Note: Get is_valid field (offset 24)
    Let is_valid be proc memory_get_integer from MemoryCore with info, 24
    Return is_valid
End Process

Process called "debug_info_clear" takes info as Integer returns Integer:
    Note: Clear debug information entry
    Note: Returns 1 if successful, 0 if failed
    Note: Resets debug information to default state

    If info is equal to 0:
        Return 0
    End If

    Note: Clear value field and mark as invalid
    Let dummy1 be proc memory_set_integer from MemoryCore with info, 8, 0    Note: value = 0
    Let dummy2 be proc memory_set_integer from MemoryCore with info, 24, 0   Note: is_valid = false

    Return 1
End Process

Note: ============================================================================
Note: Debug Output Operations
Note: ============================================================================

Process called "debug_output_console" takes message as Integer returns Integer:
    Note: Output debug message to console
    Note: Returns 1 if successful, 0 if failed
    Note: Handles console output formatting

    Let result be proc write_to_console with message
    Return result
End Process

Process called "debug_output_file" takes message as Integer, filename as Integer returns Integer:
    Note: Output debug message to file
    Note: Returns 1 if successful, 0 if failed
    Note: Handles file output formatting

    Note: Open file with append mode
    Let file_flags be O_WRONLY plus O_CREAT plus O_APPEND
    Let file_mode be 420
    Let file_fd be proc syscall_open from Syscall with filename, file_flags, file_mode

    If file_fd is less than 0:
        Return 0
    End If

    Note: Write message
    Let msg_len be proc string_length from StringCore with message
    Let bytes_written be proc syscall_write from Syscall with file_fd, message, msg_len

    Note: Close file
    Let close_result be proc syscall_close from Syscall with file_fd

    If bytes_written is greater than 0:
        Return 1
    End If
    Return 0
End Process

Process called "debug_output_both" takes message as Integer, filename as Integer returns Integer:
    Note: Output debug message to both console and file
    Note: Returns 1 if successful, 0 if failed
    Note: Handles both console and file output

    Let console_result be proc debug_output_console with message
    Let file_result be proc debug_output_file with message, filename

    Note: Return success only if both succeeded
    If console_result is equal to 1:
        If file_result is equal to 1:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "debug_output_format" takes message as Integer, format as Integer returns Integer:
    Note: Format debug message for output
    Note: Returns pointer to formatted message
    Note: Applies formatting to debug message
    Note: Format parameter currently unused - returns message as-is

    Return message
End Process

Process called "debug_output_color" takes message as Integer, color as Integer returns Integer:
    Note: Add color to debug message
    Note: Returns pointer to colored message
    Note: Applies ANSI color codes for terminal output

    Note: ANSI color codes: 0=reset, 31=red, 33=yellow, 34=blue, 37=white
    Let color_code_str be proc integer_to_string from StringUtils with color
    Let escape_start be "\x1b["
    Let color_mid be "m"
    Let escape_end be "\x1b[0m"

    Note: Build: "\x1b[{color}m" + message + "\x1b[0m"
    Let part1 be proc string_concat from StringUtils with escape_start, color_code_str
    Let part2 be proc string_concat from StringUtils with part1, color_mid
    Let part3 be proc string_concat from StringUtils with part2, message
    Let colored be proc string_concat from StringUtils with part3, escape_end

    Return colored
End Process

Process called "debug_output_timestamp" takes message as Integer returns Integer:
    Note: Add timestamp to debug message
    Note: Returns pointer to timestamped message
    Note: Applies timestamp formatting to debug message

    Let timestamp be proc get_timestamp
    Let timestamp_str be proc integer_to_string from StringUtils with timestamp

    Note: Build: "[{timestamp}] " + message
    Let part1 be proc string_concat from StringUtils with "[", timestamp_str
    Let part2 be proc string_concat from StringUtils with part1, "] "
    Let timestamped be proc string_concat from StringUtils with part2, message

    Return timestamped
End Process

Note: ============================================================================
Note: Debug Performance Monitoring
Note: ============================================================================

Process called "debug_start_timer" takes name as Integer returns Integer:
    Note: Start debug timer
    Note: Returns pointer to timer structure
    Note: Begins timing debug operations
    Note: Timer structure: [name:8][start_time:8][end_time:8][is_running:8] = 32 bytes

    Let timer_size be 32
    Let timer_ptr be proc allocate from MemoryUtils with timer_size
    If timer_ptr is equal to 0:
        Return 0
    End If

    Note: Get current timestamp
    Let start_time be proc get_timestamp

    Note: Initialize timer structure
    Let dummy1 be proc memory_set_integer from MemoryCore with timer_ptr, 0, name
    Let dummy2 be proc memory_set_integer from MemoryCore with timer_ptr, 8, start_time
    Let dummy3 be proc memory_set_integer from MemoryCore with timer_ptr, 16, 0    Note: end_time = 0
    Let dummy4 be proc memory_set_integer from MemoryCore with timer_ptr, 24, 1   Note: is_running = true

    Return timer_ptr
End Process

Process called "debug_stop_timer" takes timer as Integer returns Integer:
    Note: Stop debug timer
    Note: Returns elapsed time in milliseconds
    Note: Ends timing debug operations

    If timer is equal to 0:
        Return 0
    End If

    Note: Get current timestamp
    Let end_time be proc get_timestamp

    Note: Store end time and mark as not running
    Let dummy1 be proc memory_set_integer from MemoryCore with timer, 16, end_time
    Let dummy2 be proc memory_set_integer from MemoryCore with timer, 24, 0   Note: is_running = false

    Note: Calculate elapsed time
    Let start_time be proc memory_get_integer from MemoryCore with timer, 8
    Let elapsed be end_time minus start_time

    Return elapsed
End Process

Process called "debug_get_timer" takes timer as Integer returns Integer:
    Note: Get debug timer value
    Note: Returns timer value in milliseconds
    Note: Retrieves current timer value

    If timer is equal to 0:
        Return 0
    End If

    Let start_time be proc memory_get_integer from MemoryCore with timer, 8
    Let is_running be proc memory_get_integer from MemoryCore with timer, 24

    If is_running is equal to 1:
        Note: Timer still running, calculate current elapsed time
        Let current_time be proc get_timestamp
        Let elapsed be current_time minus start_time
        Return elapsed
    Otherwise:
        Note: Timer stopped, return final elapsed time
        Let end_time be proc memory_get_integer from MemoryCore with timer, 16
        Let elapsed be end_time minus start_time
        Return elapsed
    End If

    Return 0
End Process

Process called "debug_reset_timer" takes timer as Integer returns Integer:
    Note: Reset debug timer
    Note: Returns 1 if successful, 0 if failed
    Note: Resets timer to zero

    If timer is equal to 0:
        Return 0
    End If

    Note: Get new start time
    Let start_time be proc get_timestamp

    Note: Reset timer
    Let dummy1 be proc memory_set_integer from MemoryCore with timer, 8, start_time
    Let dummy2 be proc memory_set_integer from MemoryCore with timer, 16, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with timer, 24, 1   Note: is_running = true

    Return 1
End Process

Process called "debug_profile_start" takes name as Integer returns Integer:
    Note: Start debug profiling
    Note: Returns pointer to profile structure
    Note: Begins profiling debug operations
    Note: Profile is essentially a timer with additional metadata

    Let profile_ptr be proc debug_start_timer with name
    Return profile_ptr
End Process

Process called "debug_profile_stop" takes profile as Integer returns Integer:
    Note: Stop debug profiling
    Note: Returns 1 if successful, 0 if failed
    Note: Ends profiling debug operations

    If profile is equal to 0:
        Return 0
    End If

    Let elapsed be proc debug_stop_timer with profile
    If elapsed is greater than or equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "debug_profile_get" takes profile as Integer returns Integer:
    Note: Get debug profile data
    Note: Returns pointer to profile data
    Note: Retrieves profile information

    Note: Profile structure is the same as timer, just return it
    Return profile
End Process

Note: ============================================================================
Note: Debug Statistics Operations
Note: ============================================================================

Process called "debug_get_stats" takes returns Integer:
    Note: Get debug statistics
    Note: Returns pointer to DebugStats structure
    Note: Provides detailed debugging metrics

    Note: Return pointer to global stats structure
    Return global_debug_stats
End Process

Process called "debug_reset_stats" takes returns Nothing:
    Note: Reset debug statistics
    Note: Clears all debugging counters

    If global_debug_stats is equal to 0:
        Return
    End If

    Note: Zero out all statistics (6 fields * 8 bytes = 48 bytes)
    Let stats_size be 48
    Let dummy be proc memory_zero from MemoryCore with global_debug_stats, stats_size

    Return
End Process

Process called "debug_export_stats" takes filename as Integer returns Integer:
    Note: Export debug statistics to file
    Note: Returns 1 if successful, 0 if failed
    Note: Saves statistics to file

    If global_debug_stats is equal to 0:
        Return 0
    End If

    Note: Open file for writing
    Let file_flags be O_WRONLY plus O_CREAT plus O_TRUNC
    Let file_mode be 420
    Let file_fd be proc syscall_open from Syscall with filename, file_flags, file_mode

    If file_fd is less than 0:
        Return 0
    End If

    Note: Write complete DebugStats structure to file (48 bytes binary format)
    Let stats_size be 48
    Let bytes_written be proc syscall_write from Syscall with file_fd, global_debug_stats, stats_size

    Note: Close file
    Let close_result be proc syscall_close from Syscall with file_fd

    If bytes_written is equal to stats_size:
        Return 1
    End If
    Return 0
End Process

Process called "debug_import_stats" takes filename as Integer returns Integer:
    Note: Import debug statistics from file
    Note: Returns 1 if successful, 0 if failed
    Note: Loads statistics from file

    If global_debug_stats is equal to 0:
        Return 0
    End If

    Note: Open file for reading
    Let file_flags be 0    Note: O_RDONLY = 0
    Let file_mode be 0
    Let file_fd be proc syscall_open from Syscall with filename, file_flags, file_mode

    If file_fd is less than 0:
        Return 0
    End If

    Note: Read statistics
    Let stats_size be 48
    Let bytes_read be proc syscall_read from Syscall with file_fd, global_debug_stats, stats_size

    Note: Close file
    Let close_result be proc syscall_close from Syscall with file_fd

    If bytes_read is equal to stats_size:
        Return 1
    End If
    Return 0
End Process

Process called "debug_print_stats" takes returns Nothing:
    Note: Print debug statistics
    Note: Outputs statistics to console
    Note: Provides real-time debug information

    If global_debug_stats is equal to 0:
        Return
    End If

    Note: Print header
    Let header be "=== Debug Statistics ===\n"
    Let dummy1 be proc write_to_console with header

    Note: Get statistics values
    Let total_logs be proc memory_get_integer from MemoryCore with global_debug_stats, 0
    Let error_count be proc memory_get_integer from MemoryCore with global_debug_stats, 8
    Let warning_count be proc memory_get_integer from MemoryCore with global_debug_stats, 16
    Let info_count be proc memory_get_integer from MemoryCore with global_debug_stats, 24
    Let debug_count be proc memory_get_integer from MemoryCore with global_debug_stats, 32

    Note: Format and output statistics
    Let total_str be proc integer_to_string from StringUtils with total_logs
    Let msg1 be proc string_concat from StringUtils with "Total logs: ", total_str
    Let msg1_newline be proc string_concat from StringUtils with msg1, "\n"
    Let dummy2 be proc write_to_console with msg1_newline

    Let error_str be proc integer_to_string from StringUtils with error_count
    Let msg2 be proc string_concat from StringUtils with "Errors: ", error_str
    Let msg2_newline be proc string_concat from StringUtils with msg2, "\n"
    Let dummy3 be proc write_to_console with msg2_newline

    Let warning_str be proc integer_to_string from StringUtils with warning_count
    Let msg3 be proc string_concat from StringUtils with "Warnings: ", warning_str
    Let msg3_newline be proc string_concat from StringUtils with msg3, "\n"
    Let dummy4 be proc write_to_console with msg3_newline

    Let info_str be proc integer_to_string from StringUtils with info_count
    Let msg4 be proc string_concat from StringUtils with "Info: ", info_str
    Let msg4_newline be proc string_concat from StringUtils with msg4, "\n"
    Let dummy5 be proc write_to_console with msg4_newline

    Let debug_str be proc integer_to_string from StringUtils with debug_count
    Let msg5 be proc string_concat from StringUtils with "Debug: ", debug_str
    Let msg5_newline be proc string_concat from StringUtils with msg5, "\n"
    Let dummy6 be proc write_to_console with msg5_newline

    Return
End Process

Note: ============================================================================
Note: Debug Optimization Operations
Note: ============================================================================

Process called "debug_optimize" takes returns Integer:
    Note: Optimize debugging by pre-allocating stats structure
    Note: Returns 1 if successful, 0 if failed
    Note: Ensures debug statistics are initialized and ready

    Note: Check if initialized
    If global_debug_initialized is not equal to DEBUG_STATE_INITIALIZED:
        Return 0
    End If

    Note: Verify stats structure is allocated
    If global_debug_stats is equal to 0:
        Return 0
    End If

    Note: Debug system already optimized (stats pre-allocated during initialization)
    Return 1
End Process

Process called "debug_benchmark" takes iterations as Integer returns Integer:
    Note: Benchmark debugging performance
    Note: Returns pointer to benchmark results
    Note: Measures debugging overhead

    If iterations is less than or equal to 0:
        Return 0
    End If

    Note: Start timer
    Let timer be proc debug_start_timer with 0

    Note: Run debug operations for benchmarking
    Let i be 0
    While i is less than iterations:
        Let test_msg be "Benchmark test message"
        Let dummy be proc debug_log from MemoryCore with DEBUG_LEVEL_DEBUG, test_msg, 0, 0, 0
        Set i to i plus 1
    End While

    Note: Stop timer
    Let elapsed be proc debug_stop_timer with timer

    Note: Return elapsed time as benchmark result
    Return elapsed
End Process

Process called "debug_profile" takes returns Integer:
    Note: Profile debugging performance
    Note: Returns pointer to performance profile data
    Note: Analyzes debugging efficiency

    Note: Return pointer to debug stats which contains profiling data
    Return global_debug_stats
End Process

Process called "debug_validate" takes returns Integer:
    Note: Validate debugging system
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks debugging system integrity

    Note: Check initialization
    If global_debug_initialized is not equal to DEBUG_STATE_INITIALIZED:
        Return 0
    End If

    Note: Validate stats structure
    If global_debug_stats is equal to 0:
        Return 0
    End If

    Note: All validations passed
    Return 1
End Process

Process called "debug_verify" takes returns Integer:
    Note: Verify debugging system
    Note: Returns 1 if verified, 0 if corrupted
    Note: Checks debugging system consistency

    Note: Verify via validation
    Let is_valid be proc debug_validate
    Return is_valid
End Process

Note: ============================================================================
Note: Helper Functions (Private/Internal)
Note: ============================================================================

Private Process called "get_debug_log_filename" takes returns Integer:
    Note: Returns pointer to debug log filename string
    Note: Uses static string literal "runa_debug.log"

    Let filename be "runa_debug.log"
    Return filename
End Process

Private Process called "get_timestamp" takes returns Integer:
    Note: Get current timestamp in nanoseconds
    Note: Uses clock_gettime syscall (CLOCK_MONOTONIC)
    Note: Returns monotonically increasing timestamp

    Note: Clock type constants
    Let CLOCK_MONOTONIC be 1

    Note: Allocate timespec structure on stack (16 bytes: tv_sec + tv_nsec)
    Let timespec_size be 16
    Let timespec_ptr be proc allocate from MemoryUtils with timespec_size

    If timespec_ptr is equal to 0:
        Note: Allocation failed, fall back to counter
        Set global_timestamp_counter to global_timestamp_counter plus 1
        Return global_timestamp_counter
    End If

    Note: Call clock_gettime syscall
    Note: syscall number for clock_gettime is 228 on x86_64 Linux
    Let syscall_num be 228
    Let result be proc syscall_2 from Syscall with syscall_num, CLOCK_MONOTONIC, timespec_ptr

    If result is not equal to 0:
        Note: Syscall failed, fall back to counter
        Let dummy_dealloc be proc deallocate from MemoryUtils with timespec_ptr
        Set global_timestamp_counter to global_timestamp_counter plus 1
        Return global_timestamp_counter
    End If

    Note: Read tv_sec (offset 0, 8 bytes)
    Let tv_sec be proc memory_get_integer from MemoryCore with timespec_ptr, 0

    Note: Read tv_nsec (offset 8, 8 bytes)
    Let tv_nsec be proc memory_get_integer from MemoryCore with timespec_ptr, 8

    Note: Free timespec structure
    Let dummy_dealloc2 be proc deallocate from MemoryUtils with timespec_ptr

    Note: Convert to nanoseconds: (tv_sec * 1000000000) + tv_nsec
    Let billion be 1000000000
    Let sec_to_nsec be tv_sec multiplied by billion
    Let total_nsec be sec_to_nsec plus tv_nsec

    Return total_nsec
End Process

Private Process called "output_debug_message" takes level as Integer, message as Integer, source as Integer, line as Integer, column as Integer, timestamp as Integer returns Integer:
    Note: Output debug message to configured output(s)
    Note: Returns 1 if successful, 0 if failed

    Note: Format the message with level prefix
    Let formatted_msg be proc format_debug_message with level, message, source, line, column

    Note: Output based on configuration
    If global_debug_output_type is equal to DEBUG_OUTPUT_CONSOLE:
        Let result be proc write_to_console with formatted_msg
        Return result
    Otherwise If global_debug_output_type is equal to DEBUG_OUTPUT_FILE:
        Let result be proc write_to_file with formatted_msg
        Return result
    Otherwise If global_debug_output_type is equal to DEBUG_OUTPUT_BOTH:
        Let console_result be proc write_to_console with formatted_msg
        Let file_result be proc write_to_file with formatted_msg

        Note: Return success only if both succeeded
        If console_result is equal to 1:
            If file_result is equal to 1:
                Return 1
            End If
        End If
        Return 0
    End If

    Return 0
End Process

Private Process called "format_debug_message" takes level as Integer, message as Integer, source as Integer, line as Integer, column as Integer returns Integer:
    Note: Format debug message with level prefix and location
    Note: Returns pointer to formatted string
    Note: Format: "[LEVEL] source:line:column: message\n"

    Note: Get level string
    Let level_str be proc get_level_string with level

    Note: Concatenate: level_str + " " + source + ":" + line + ":" + column + ": " + message + "\n"
    Let part1 be proc string_concat from StringUtils with level_str, " "
    Let source_str be proc integer_to_string from StringUtils with source
    Let part2 be proc string_concat from StringUtils with part1, source_str
    Let part3 be proc string_concat from StringUtils with part2, ":"
    Let line_str be proc integer_to_string from StringUtils with line
    Let part4 be proc string_concat from StringUtils with part3, line_str
    Let part5 be proc string_concat from StringUtils with part4, ":"
    Let column_str be proc integer_to_string from StringUtils with column
    Let part6 be proc string_concat from StringUtils with part5, column_str
    Let part7 be proc string_concat from StringUtils with part6, ": "
    Let part8 be proc string_concat from StringUtils with part7, message
    Let formatted be proc string_concat from StringUtils with part8, "\n"

    Return formatted
End Process

Private Process called "get_level_string" takes level as Integer returns Integer:
    Note: Get string representation of debug level
    Note: Returns pointer to level string

    If level is equal to DEBUG_LEVEL_ERROR:
        Let str be "[ERROR]"
        Return str
    Otherwise If level is equal to DEBUG_LEVEL_WARNING:
        Let str be "[WARNING]"
        Return str
    Otherwise If level is equal to DEBUG_LEVEL_INFO:
        Let str be "[INFO]"
        Return str
    Otherwise If level is equal to DEBUG_LEVEL_DEBUG:
        Let str be "[DEBUG]"
        Return str
    Otherwise If level is equal to DEBUG_LEVEL_VERBOSE:
        Let str be "[VERBOSE]"
        Return str
    End If

    Let str be "[UNKNOWN]"
    Return str
End Process

Private Process called "write_to_console" takes message as Integer returns Integer:
    Note: Write message to console (stderr)
    Note: Returns 1 if successful, 0 if failed

    Let msg_len be proc string_length from StringCore with message
    Let bytes_written be proc syscall_write from Syscall with STDERR, message, msg_len

    If bytes_written is greater than 0:
        Return 1
    End If
    Return 0
End Process

Private Process called "write_to_file" takes message as Integer returns Integer:
    Note: Write message to debug log file
    Note: Returns 1 if successful, 0 if failed

    If global_debug_output_file is less than or equal to 0:
        Return 0
    End If

    Let msg_len be proc string_length from StringCore with message
    Let bytes_written be proc syscall_write from Syscall with global_debug_output_file, message, msg_len

    If bytes_written is greater than 0:
        Return 1
    End If
    Return 0
End Process

Note: ============================================================================
Note: Debug Utils Complete - Foundation for Compiler Debugging
Note: ============================================================================