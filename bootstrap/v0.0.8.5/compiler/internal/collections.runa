Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles collection data structures and collection utility operations for the Runa compiler internal system.

COLLECTIONS - Compiler Data Structure Management Engine
- Process collection creation and collection management operations for compiler data structures
- Handle collection resizing and collection capacity management for compiler operations
- Manage collection operations and collection manipulation utilities for compiler workflows
- Process collection optimization and collection performance utilities for compiler efficiency
- Handle integration with compiler phases for data structure management and processing

This file is essential because of the following reasons:
- Collection management is fundamental to compiler operation and data structure handling
- Proper collection handling ensures efficient compiler data operations and performance
- Collection utilities support all compiler phases that need data structure management
- Collection management provides deterministic memory management for compiler operations

This file consists of the following functions/features/operation types:
- Collection creation, destruction, and lifecycle management
- Collection allocation and deallocation operations
- Collection resizing and capacity management
- Collection optimization and performance monitoring
- Integration with compiler phases for collection management needs

Dependencies:
- Imports arena_utils.runa for arena-based collection allocation
- Imports owned_utils.runa for owned collection management
- Imports memory_safety.runa for collection safety validation
- Imports buffer_utils.runa for collection buffer management
:End Note

Import "compiler/internal/arena_utils.runa" as ArenaUtils
Import "compiler/internal/owned_utils.runa" as OwnedUtils
Import "compiler/internal/memory_safety.runa" as MemorySafety
Import "compiler/internal/buffer_utils.runa" as BufferUtils
Import "compiler/internal/hash_utils.runa" as HashUtils
Import "compiler/primitives/memory_core.runa" as MemoryCore
Import "compiler/primitives/memory_utils.runa" as MemoryUtils

Note: ============================================================================
Note: Collection Data Structures
Note: ============================================================================

Type called "ArrayList":
    data as Integer          Note: Pointer to array data
    size as Integer         Note: Current size of array
    capacity as Integer     Note: Maximum capacity of array
    element_size as Integer Note: Size of each element
    arena as Integer         Note: Pointer to arena for allocation
    is_owned as Integer      Note: Boolean: 1 if owned, 0 if arena-allocated

Type called "LinkedList":
    head as Integer         Note: Pointer to head node
    tail as Integer         Note: Pointer to tail node
    size as Integer         Note: Current size of list
    arena as Integer         Note: Pointer to arena for allocation
    is_owned as Integer      Note: Boolean: 1 if owned, 0 if arena-allocated

Type called "HashTable":
    buckets as Integer      Note: Pointer to bucket array
    size as Integer         Note: Current size of table
    capacity as Integer     Note: Maximum capacity of table
    load_factor as Integer  Note: Load factor threshold
    arena as Integer         Note: Pointer to arena for allocation
    is_owned as Integer      Note: Boolean: 1 if owned, 0 if arena-allocated

Type called "Stack":
    data as Integer         Note: Pointer to stack data
    top as Integer          Note: Current top position
    capacity as Integer     Note: Maximum capacity of stack
    arena as Integer         Note: Pointer to arena for allocation
    is_owned as Integer      Note: Boolean: 1 if owned, 0 if arena-allocated

Type called "Queue":
    data as Integer         Note: Pointer to queue data
    front as Integer        Note: Front position in queue
    rear as Integer         Note: Rear position in queue
    size as Integer         Note: Current size of queue
    capacity as Integer     Note: Maximum capacity of queue
    arena as Integer         Note: Pointer to arena for allocation
    is_owned as Integer      Note: Boolean: 1 if owned, 0 if arena-allocated

Type called "Tree":
    root as Integer         Note: Pointer to root node
    size as Integer         Note: Current size of tree
    comparator as Integer   Note: Pointer to comparison function
    arena as Integer         Note: Pointer to arena for allocation
    is_owned as Integer      Note: Boolean: 1 if owned, 0 if arena-allocated

Note: ============================================================================
Note: Collection Constants
Note: ============================================================================

Constant COLLECTION_DEFAULT_SIZE as Integer is 16
Constant COLLECTION_MIN_SIZE as Integer is 4
Constant COLLECTION_MAX_SIZE as Integer is 1073741824
Constant COLLECTION_GROWTH_FACTOR as Integer is 2
Constant COLLECTION_SHRINK_THRESHOLD as Integer is 4

Constant COLLECTION_SUCCESS as Integer is 0
Constant COLLECTION_FAILED as Integer is -1
Constant COLLECTION_OVERFLOW as Integer is -2
Constant COLLECTION_UNDERFLOW as Integer is -3
Constant COLLECTION_NOT_FOUND as Integer is -4

Constant COLLECTION_ORDER_ASCENDING as Integer is 0
Constant COLLECTION_ORDER_DESCENDING as Integer is 1
Constant COLLECTION_ORDER_NONE as Integer is 2

Note: ============================================================================
Note: ArrayList Operations
Note: ============================================================================

Process called "arraylist_create" takes initial_capacity as Integer, element_size as Integer, arena as Integer returns Integer:
    Note: Create new array list
    Note: Returns pointer to ArrayList structure
    Note: Initializes array list with default settings

    If element_size is less than 1:
        Return 0
    End If

    Let use_capacity be initial_capacity
    Let min_size be 4
    If use_capacity is less than min_size:
        Set use_capacity to min_size
    End If

    Let max_size be 1073741824
    If use_capacity is greater than max_size:
        Return 0
    End If

    Note: Allocate ArrayList structure (48 bytes)
    Let list_size be 48
    Let list_ptr be 0

    If arena is not equal to 0:
        Set list_ptr to proc arena_allocate from ArenaUtils with arena, list_size, 8
    End If

    Otherwise:
        Set list_ptr to proc allocate from MemoryUtils with list_size
    End If

    If list_ptr is equal to 0:
        Return 0
    End If

    Note: Allocate data array
    Let data_size be use_capacity multiplied by element_size
    Let data_ptr be 0

    If arena is not equal to 0:
        Set data_ptr to proc arena_allocate from ArenaUtils with arena, data_size, 8
    End If

    Otherwise:
        Set data_ptr to proc allocate from MemoryUtils with data_size
    End If

    If data_ptr is equal to 0:
        If arena is equal to 0:
            Let dummy1 be proc deallocate from MemoryUtils with list_ptr
        End If
        Return 0
    End If

    Note: Initialize ArrayList structure
    Let dummy2 be proc memory_set_integer from MemoryCore with list_ptr, 0, data_ptr
    Let dummy3 be proc memory_set_integer from MemoryCore with list_ptr, 8, 0
    Let dummy4 be proc memory_set_integer from MemoryCore with list_ptr, 16, use_capacity
    Let dummy5 be proc memory_set_integer from MemoryCore with list_ptr, 24, element_size
    Let dummy6 be proc memory_set_integer from MemoryCore with list_ptr, 32, arena

    Let is_owned be 0
    If arena is equal to 0:
        Set is_owned to 1
    End If

    Let dummy7 be proc memory_set_integer from MemoryCore with list_ptr, 40, is_owned

    Return list_ptr
End Process

Process called "arraylist_destroy" takes list as Integer returns Nothing:
    Note: Destroy array list and free associated memory
    Note: Frees all array list data
    Note: Validates memory safety before destruction

    If list is equal to 0:
        Return
    End If

    Let is_owned be proc memory_get_integer from MemoryCore with list, 40

    If is_owned is equal to 1:
        Let data_ptr be proc memory_get_integer from MemoryCore with list, 0
        If data_ptr is not equal to 0:
            Let dummy1 be proc deallocate from MemoryUtils with data_ptr
        End If
        Let dummy2 be proc deallocate from MemoryUtils with list
    End If

    Return
End Process

Process called "arraylist_add" takes list as Integer, element as Integer returns Integer:
    Note: Add element to array list
    Note: Returns 1 if successful, 0 if failed
    Note: Handles array list resizing if needed

    If list is equal to 0:
        Return 0
    End If

    If element is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with list, 8
    Let capacity be proc memory_get_integer from MemoryCore with list, 16

    Note: Resize if at capacity
    If size is equal to capacity:
        Let growth_factor be 2
        Let new_capacity be capacity multiplied by growth_factor
        Let max_size be 1073741824

        If new_capacity is greater than max_size:
            Return 0
        End If

        Let element_size be proc memory_get_integer from MemoryCore with list, 24
        Let new_data_size be new_capacity multiplied by element_size
        Let old_data_ptr be proc memory_get_integer from MemoryCore with list, 0
        Let new_data_ptr be proc allocate from MemoryUtils with new_data_size

        If new_data_ptr is equal to 0:
            Return 0
        End If

        Let old_data_size be capacity multiplied by element_size
        Let dummy1 be proc memory_copy from MemoryCore with new_data_ptr, old_data_ptr, old_data_size

        Let is_owned be proc memory_get_integer from MemoryCore with list, 40
        If is_owned is equal to 1:
            Let dummy2 be proc deallocate from MemoryUtils with old_data_ptr
        End If

        Let dummy3 be proc memory_set_integer from MemoryCore with list, 0, new_data_ptr
        Let dummy4 be proc memory_set_integer from MemoryCore with list, 16, new_capacity
        Let dummy5 be proc memory_set_integer from MemoryCore with list, 40, 1
    End If

    Note: Add element at end
    Let data_ptr be proc memory_get_integer from MemoryCore with list, 0
    Let element_size be proc memory_get_integer from MemoryCore with list, 24
    Let offset be size multiplied by element_size
    Let target_ptr be data_ptr plus offset
    Let dummy6 be proc memory_copy from MemoryCore with target_ptr, element, element_size

    Let new_size be size plus 1
    Let dummy7 be proc memory_set_integer from MemoryCore with list, 8, new_size

    Return 1
End Process

Process called "arraylist_insert" takes list as Integer, index as Integer, element as Integer returns Integer:
    Note: Insert element at specified index in array list
    Note: Returns 1 if successful, 0 if failed
    Note: Validates index bounds

    If list is equal to 0:
        Return 0
    End If

    If element is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with list, 8

    If index is less than 0:
        Return 0
    End If

    If index is greater than size:
        Return 0
    End If

    Note: If inserting at end, use arraylist_add
    If index is equal to size:
        Let result be proc arraylist_add with list, element
        Return result
    End If

    Note: Ensure capacity for insertion
    Let capacity be proc memory_get_integer from MemoryCore with list, 16

    If size is equal to capacity:
        Let dummy_element be 0
        Let resize_result be proc arraylist_add with list, dummy_element
        If resize_result is equal to 0:
            Return 0
        End If
        Set size to size plus 1
        Let dummy1 be proc memory_set_integer from MemoryCore with list, 8, size
    End If

    Note: Shift elements to make space
    Let data_ptr be proc memory_get_integer from MemoryCore with list, 0
    Let element_size be proc memory_get_integer from MemoryCore with list, 24
    Let insert_offset be index multiplied by element_size
    Let insert_ptr be data_ptr plus insert_offset
    Let next_offset be index plus 1
    Set next_offset to next_offset multiplied by element_size
    Let next_ptr be data_ptr plus next_offset
    Let elements_to_move be size minus index
    Let bytes_to_move be elements_to_move multiplied by element_size

    If bytes_to_move is greater than 0:
        Let dummy2 be proc memory_move from MemoryCore with next_ptr, insert_ptr, bytes_to_move
    End If

    Note: Insert element
    Let dummy3 be proc memory_copy from MemoryCore with insert_ptr, element, element_size

    Let new_size be size plus 1
    Let dummy4 be proc memory_set_integer from MemoryCore with list, 8, new_size

    Return 1
End Process

Process called "arraylist_remove" takes list as Integer, index as Integer returns Integer:
    Note: Remove element at specified index from array list
    Note: Returns 1 if successful, 0 if failed
    Note: Validates index bounds

    If list is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with list, 8

    If index is less than 0:
        Return 0
    End If

    If index is greater than size:
        Return 0
    End If

    Otherwise If index is equal to size:
        Return 0
    End If

    Note: Shift elements to fill gap
    Let data_ptr be proc memory_get_integer from MemoryCore with list, 0
    Let element_size be proc memory_get_integer from MemoryCore with list, 24
    Let remove_offset be index multiplied by element_size
    Let remove_ptr be data_ptr plus remove_offset
    Let next_index be index plus 1
    Let next_offset be next_index multiplied by element_size
    Let next_ptr be data_ptr plus next_offset
    Let elements_to_move be size minus next_index
    Let bytes_to_move be elements_to_move multiplied by element_size

    If bytes_to_move is greater than 0:
        Let dummy1 be proc memory_move from MemoryCore with remove_ptr, next_ptr, bytes_to_move
    End If

    Let new_size be size minus 1
    Let dummy2 be proc memory_set_integer from MemoryCore with list, 8, new_size

    Return 1
End Process

Process called "arraylist_get" takes list as Integer, index as Integer returns Integer:
    Note: Get element at specified index from array list
    Note: Returns pointer to element or 0 if not found
    Note: Validates index bounds

    If list is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with list, 8

    If index is less than 0:
        Return 0
    End If

    If index is greater than size:
        Return 0
    End If

    Otherwise If index is equal to size:
        Return 0
    End If

    Let data_ptr be proc memory_get_integer from MemoryCore with list, 0
    Let element_size be proc memory_get_integer from MemoryCore with list, 24
    Let offset be index multiplied by element_size
    Let element_ptr be data_ptr plus offset

    Return element_ptr
End Process

Process called "arraylist_set" takes list as Integer, index as Integer, element as Integer returns Integer:
    Note: Set element at specified index in array list
    Note: Returns 1 if successful, 0 if failed
    Note: Validates index bounds

    If list is equal to 0:
        Return 0
    End If

    If element is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with list, 8

    If index is less than 0:
        Return 0
    End If

    If index is greater than size:
        Return 0
    End If

    Otherwise If index is equal to size:
        Return 0
    End If

    Let data_ptr be proc memory_get_integer from MemoryCore with list, 0
    Let element_size be proc memory_get_integer from MemoryCore with list, 24
    Let offset be index multiplied by element_size
    Let target_ptr be data_ptr plus offset
    Let dummy1 be proc memory_copy from MemoryCore with target_ptr, element, element_size

    Return 1
End Process

Process called "arraylist_size" takes list as Integer returns Integer:
    Note: Get size of array list
    Note: Returns size of array list

    If list is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with list, 8
    Return size
End Process

Process called "arraylist_capacity" takes list as Integer returns Integer:
    Note: Get capacity of array list
    Note: Returns capacity of array list

    If list is equal to 0:
        Return 0
    End If

    Let capacity be proc memory_get_integer from MemoryCore with list, 16
    Return capacity
End Process

Process called "arraylist_clear" takes list as Integer returns Integer:
    Note: Clear array list
    Note: Returns 1 if successful, 0 if failed
    Note: Removes all elements but keeps structure

    If list is equal to 0:
        Return 0
    End If

    Let dummy1 be proc memory_set_integer from MemoryCore with list, 8, 0
    Return 1
End Process

Note: ============================================================================
Note: LinkedList Operations
Note: ============================================================================

Process called "linkedlist_create" takes arena as Integer returns Integer:
    Note: Create new linked list
    Note: Returns pointer to LinkedList structure
    Note: Initializes linked list with default settings

    Note: Allocate LinkedList structure (40 bytes)
    Let list_size be 40
    Let list_ptr be 0

    If arena is not equal to 0:
        Set list_ptr to proc arena_allocate from ArenaUtils with arena, list_size, 8
    End If

    Otherwise:
        Set list_ptr to proc allocate from MemoryUtils with list_size
    End If

    If list_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize LinkedList structure
    Let dummy1 be proc memory_set_integer from MemoryCore with list_ptr, 0, 0
    Let dummy2 be proc memory_set_integer from MemoryCore with list_ptr, 8, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with list_ptr, 16, 0
    Let dummy4 be proc memory_set_integer from MemoryCore with list_ptr, 24, arena

    Let is_owned be 0
    If arena is equal to 0:
        Set is_owned to 1
    End If

    Let dummy5 be proc memory_set_integer from MemoryCore with list_ptr, 32, is_owned

    Return list_ptr
End Process

Process called "linkedlist_destroy" takes list as Integer returns Nothing:
    Note: Destroy linked list and free associated memory
    Note: Frees all linked list data
    Note: Validates memory safety before destruction

    If list is equal to 0:
        Return
    End If

    Let is_owned be proc memory_get_integer from MemoryCore with list, 32

    If is_owned is equal to 1:
        Note: Free all nodes
        Let current be proc memory_get_integer from MemoryCore with list, 0
        While current is not equal to 0:
            Let next be proc memory_get_integer from MemoryCore with current, 8
            Let dummy1 be proc deallocate from MemoryUtils with current
            Set current to next
        End While

        Note: Free list structure
        Let dummy2 be proc deallocate from MemoryUtils with list
    End If

    Return
End Process

Process called "linkedlist_add_front" takes list as Integer, element as Integer returns Integer:
    Note: Add element to front of linked list
    Note: Returns 1 if successful, 0 if failed
    Note: Handles linked list resizing if needed

    If list is equal to 0:
        Return 0
    End If

    If element is equal to 0:
        Return 0
    End If

    Note: Allocate new node (24 bytes: data ptr, next ptr, prev ptr)
    Let node_size be 24
    Let arena be proc memory_get_integer from MemoryCore with list, 24
    Let node_ptr be 0

    If arena is not equal to 0:
        Set node_ptr to proc arena_allocate from ArenaUtils with arena, node_size, 8
    End If

    Otherwise:
        Set node_ptr to proc allocate from MemoryUtils with node_size
    End If

    If node_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize node
    Let dummy1 be proc memory_set_integer from MemoryCore with node_ptr, 0, element
    Let dummy2 be proc memory_set_integer from MemoryCore with node_ptr, 8, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with node_ptr, 16, 0

    Note: Insert at front
    Let head be proc memory_get_integer from MemoryCore with list, 0

    If head is equal to 0:
        Note: Empty list, node becomes both head and tail
        Let dummy4 be proc memory_set_integer from MemoryCore with list, 0, node_ptr
        Let dummy5 be proc memory_set_integer from MemoryCore with list, 8, node_ptr
    End If

    Otherwise:
        Note: Set node's next to current head
        Let dummy6 be proc memory_set_integer from MemoryCore with node_ptr, 8, head
        Note: Set old head's prev to new node
        Let dummy7 be proc memory_set_integer from MemoryCore with head, 16, node_ptr
        Note: Update list head
        Let dummy8 be proc memory_set_integer from MemoryCore with list, 0, node_ptr
    End If

    Note: Increment size
    Let size be proc memory_get_integer from MemoryCore with list, 16
    Let new_size be size plus 1
    Let dummy9 be proc memory_set_integer from MemoryCore with list, 16, new_size

    Return 1
End Process

Process called "linkedlist_add_back" takes list as Integer, element as Integer returns Integer:
    Note: Add element to back of linked list
    Note: Returns 1 if successful, 0 if failed
    Note: Handles linked list resizing if needed

    If list is equal to 0:
        Return 0
    End If

    If element is equal to 0:
        Return 0
    End If

    Note: Allocate new node (24 bytes)
    Let node_size be 24
    Let arena be proc memory_get_integer from MemoryCore with list, 24
    Let node_ptr be 0

    If arena is not equal to 0:
        Set node_ptr to proc arena_allocate from ArenaUtils with arena, node_size, 8
    End If

    Otherwise:
        Set node_ptr to proc allocate from MemoryUtils with node_size
    End If

    If node_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize node
    Let dummy1 be proc memory_set_integer from MemoryCore with node_ptr, 0, element
    Let dummy2 be proc memory_set_integer from MemoryCore with node_ptr, 8, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with node_ptr, 16, 0

    Note: Insert at back
    Let tail be proc memory_get_integer from MemoryCore with list, 8

    If tail is equal to 0:
        Note: Empty list, node becomes both head and tail
        Let dummy4 be proc memory_set_integer from MemoryCore with list, 0, node_ptr
        Let dummy5 be proc memory_set_integer from MemoryCore with list, 8, node_ptr
    End If

    Otherwise:
        Note: Set old tail's next to new node
        Let dummy6 be proc memory_set_integer from MemoryCore with tail, 8, node_ptr
        Note: Set node's prev to old tail
        Let dummy7 be proc memory_set_integer from MemoryCore with node_ptr, 16, tail
        Note: Update list tail
        Let dummy8 be proc memory_set_integer from MemoryCore with list, 8, node_ptr
    End If

    Note: Increment size
    Let size be proc memory_get_integer from MemoryCore with list, 16
    Let new_size be size plus 1
    Let dummy9 be proc memory_set_integer from MemoryCore with list, 16, new_size

    Return 1
End Process

Process called "linkedlist_remove_front" takes list as Integer returns Integer:
    Note: Remove element from front of linked list
    Note: Returns 1 if successful, 0 if failed
    Note: Validates list is not empty

    If list is equal to 0:
        Return 0
    End If

    Let head be proc memory_get_integer from MemoryCore with list, 0

    If head is equal to 0:
        Return 0
    End If

    Note: Get next node
    Let next be proc memory_get_integer from MemoryCore with head, 8

    Note: Update list head
    Let dummy1 be proc memory_set_integer from MemoryCore with list, 0, next

    If next is equal to 0:
        Note: List is now empty, clear tail
        Let dummy2 be proc memory_set_integer from MemoryCore with list, 8, 0
    End If

    Otherwise:
        Note: Clear new head's prev pointer
        Let dummy3 be proc memory_set_integer from MemoryCore with next, 16, 0
    End If

    Note: Free old head if owned
    Let is_owned be proc memory_get_integer from MemoryCore with list, 32
    If is_owned is equal to 1:
        Let dummy4 be proc deallocate from MemoryUtils with head
    End If

    Note: Decrement size
    Let size be proc memory_get_integer from MemoryCore with list, 16
    Let new_size be size minus 1
    Let dummy5 be proc memory_set_integer from MemoryCore with list, 16, new_size

    Return 1
End Process

Process called "linkedlist_remove_back" takes list as Integer returns Integer:
    Note: Remove element from back of linked list
    Note: Returns 1 if successful, 0 if failed
    Note: Validates list is not empty

    If list is equal to 0:
        Return 0
    End If

    Let tail be proc memory_get_integer from MemoryCore with list, 8

    If tail is equal to 0:
        Return 0
    End If

    Note: Get prev node
    Let prev be proc memory_get_integer from MemoryCore with tail, 16

    Note: Update list tail
    Let dummy1 be proc memory_set_integer from MemoryCore with list, 8, prev

    If prev is equal to 0:
        Note: List is now empty, clear head
        Let dummy2 be proc memory_set_integer from MemoryCore with list, 0, 0
    End If

    Otherwise:
        Note: Clear new tail's next pointer
        Let dummy3 be proc memory_set_integer from MemoryCore with prev, 8, 0
    End If

    Note: Free old tail if owned
    Let is_owned be proc memory_get_integer from MemoryCore with list, 32
    If is_owned is equal to 1:
        Let dummy4 be proc deallocate from MemoryUtils with tail
    End If

    Note: Decrement size
    Let size be proc memory_get_integer from MemoryCore with list, 16
    Let new_size be size minus 1
    Let dummy5 be proc memory_set_integer from MemoryCore with list, 16, new_size

    Return 1
End Process

Process called "linkedlist_get_front" takes list as Integer returns Integer:
    Note: Get element from front of linked list
    Note: Returns pointer to element or 0 if not found
    Note: Validates list is not empty

    If list is equal to 0:
        Return 0
    End If

    Let head be proc memory_get_integer from MemoryCore with list, 0

    If head is equal to 0:
        Return 0
    End If

    Let element be proc memory_get_integer from MemoryCore with head, 0
    Return element
End Process

Process called "linkedlist_get_back" takes list as Integer returns Integer:
    Note: Get element from back of linked list
    Note: Returns pointer to element or 0 if not found
    Note: Validates list is not empty

    If list is equal to 0:
        Return 0
    End If

    Let tail be proc memory_get_integer from MemoryCore with list, 8

    If tail is equal to 0:
        Return 0
    End If

    Let element be proc memory_get_integer from MemoryCore with tail, 0
    Return element
End Process

Process called "linkedlist_size" takes list as Integer returns Integer:
    Note: Get size of linked list
    Note: Returns size of linked list

    If list is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with list, 16
    Return size
End Process

Process called "linkedlist_clear" takes list as Integer returns Integer:
    Note: Clear linked list
    Note: Returns 1 if successful, 0 if failed
    Note: Removes all elements but keeps structure

    If list is equal to 0:
        Return 0
    End If

    Let is_owned be proc memory_get_integer from MemoryCore with list, 32

    If is_owned is equal to 1:
        Note: Free all nodes
        Let current be proc memory_get_integer from MemoryCore with list, 0
        While current is not equal to 0:
            Let next be proc memory_get_integer from MemoryCore with current, 8
            Let dummy1 be proc deallocate from MemoryUtils with current
            Set current to next
        End While
    End If

    Note: Reset list pointers and size
    Let dummy2 be proc memory_set_integer from MemoryCore with list, 0, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with list, 8, 0
    Let dummy4 be proc memory_set_integer from MemoryCore with list, 16, 0

    Return 1
End Process

Note: ============================================================================
Note: HashTable Operations
Note: ============================================================================

Process called "hashtable_create" takes initial_capacity as Integer, arena as Integer returns Integer:
    Note: Create new hash table
    Note: Returns pointer to HashTable structure
    Note: Initializes hash table with default settings

    Let use_capacity be initial_capacity
    Let min_size be 16
    If use_capacity is less than min_size:
        Set use_capacity to min_size
    End If

    Let max_size be 1073741824
    If use_capacity is greater than max_size:
        Return 0
    End If

    Note: Use hash_utils to create the actual hashtable
    Let hash_func be 0
    Let table_ptr be proc hashtable_create from HashUtils with use_capacity, hash_func

    Return table_ptr
End Process

Process called "hashtable_destroy" takes table as Integer returns Nothing:
    Note: Destroy hash table and free associated memory
    Note: Frees all hash table data
    Note: Validates memory safety before destruction

    If table is equal to 0:
        Return
    End If

    Let dummy1 be proc hashtable_destroy from HashUtils with table
    Return
End Process

Process called "hashtable_put" takes table as Integer, key as Integer, value as Integer returns Integer:
    Note: Put key-value pair in hash table
    Note: Returns 1 if successful, 0 if failed
    Note: Handles hash table resizing if needed

    If table is equal to 0:
        Return 0
    End If

    Let result be proc hashtable_put from HashUtils with table, key, value
    Return result
End Process

Process called "hashtable_get" takes table as Integer, key as Integer returns Integer:
    Note: Get value for key from hash table
    Note: Returns pointer to value or 0 if not found
    Note: Validates key exists

    If table is equal to 0:
        Return 0
    End If

    Let value be proc hashtable_get from HashUtils with table, key
    Return value
End Process

Process called "hashtable_remove" takes table as Integer, key as Integer returns Integer:
    Note: Remove key-value pair from hash table
    Note: Returns 1 if successful, 0 if failed
    Note: Validates key exists

    If table is equal to 0:
        Return 0
    End If

    Let result be proc hashtable_remove from HashUtils with table, key
    Return result
End Process

Process called "hashtable_contains" takes table as Integer, key as Integer returns Integer:
    Note: Check if key exists in hash table
    Note: Returns 1 if exists, 0 if not exists

    If table is equal to 0:
        Return 0
    End If

    Let result be proc hashtable_contains from HashUtils with table, key
    Return result
End Process

Process called "hashtable_size" takes table as Integer returns Integer:
    Note: Get size of hash table
    Note: Returns size of hash table

    If table is equal to 0:
        Return 0
    End If

    Let size be proc hashtable_size from HashUtils with table
    Return size
End Process

Process called "hashtable_capacity" takes table as Integer returns Integer:
    Note: Get capacity of hash table
    Note: Returns capacity of hash table

    If table is equal to 0:
        Return 0
    End If

    Let capacity be proc hashtable_capacity from HashUtils with table
    Return capacity
End Process

Process called "hashtable_clear" takes table as Integer returns Integer:
    Note: Clear hash table
    Note: Returns 1 if successful, 0 if failed
    Note: Removes all key-value pairs but keeps structure

    If table is equal to 0:
        Return 0
    End If

    Let result be proc hashtable_clear from HashUtils with table
    Return result
End Process

Note: ============================================================================
Note: Stack Operations
Note: ============================================================================

Process called "stack_create" takes initial_capacity as Integer, arena as Integer returns Integer:
    Note: Create new stack
    Note: Returns pointer to Stack structure
    Note: Initializes stack with default settings

    Note: Stack is implemented as an arraylist with element_size of 8 (pointer size)
    Let element_size be 8
    Let stack_ptr be proc arraylist_create with initial_capacity, element_size, arena
    Return stack_ptr
End Process

Process called "stack_destroy" takes stack as Integer returns Nothing:
    Note: Destroy stack and free associated memory
    Note: Frees all stack data
    Note: Validates memory safety before destruction

    If stack is equal to 0:
        Return
    End If

    Let dummy1 be proc arraylist_destroy with stack
    Return
End Process

Process called "stack_push" takes stack as Integer, element as Integer returns Integer:
    Note: Push element onto stack
    Note: Returns 1 if successful, 0 if failed
    Note: Handles stack resizing if needed

    If stack is equal to 0:
        Return 0
    End If

    Note: Push is same as arraylist add
    Let result be proc arraylist_add with stack, element
    Return result
End Process

Process called "stack_pop" takes stack as Integer returns Integer:
    Note: Pop element from stack
    Note: Returns 1 if successful, 0 if failed
    Note: Validates stack is not empty

    If stack is equal to 0:
        Return 0
    End If

    Let size be proc arraylist_size with stack

    If size is equal to 0:
        Return 0
    End If

    Note: Remove last element
    Let last_index be size minus 1
    Let result be proc arraylist_remove with stack, last_index
    Return result
End Process

Process called "stack_peek" takes stack as Integer returns Integer:
    Note: Peek at top element of stack
    Note: Returns pointer to element or 0 if not found
    Note: Validates stack is not empty

    If stack is equal to 0:
        Return 0
    End If

    Let size be proc arraylist_size with stack

    If size is equal to 0:
        Return 0
    End If

    Note: Get last element
    Let last_index be size minus 1
    Let element be proc arraylist_get with stack, last_index
    Return element
End Process

Process called "stack_size" takes stack as Integer returns Integer:
    Note: Get size of stack
    Note: Returns size of stack

    If stack is equal to 0:
        Return 0
    End If

    Let size be proc arraylist_size with stack
    Return size
End Process

Process called "stack_capacity" takes stack as Integer returns Integer:
    Note: Get capacity of stack
    Note: Returns capacity of stack

    If stack is equal to 0:
        Return 0
    End If

    Let capacity be proc arraylist_capacity with stack
    Return capacity
End Process

Process called "stack_clear" takes stack as Integer returns Integer:
    Note: Clear stack
    Note: Returns 1 if successful, 0 if failed
    Note: Removes all elements but keeps structure

    If stack is equal to 0:
        Return 0
    End If

    Let result be proc arraylist_clear with stack
    Return result
End Process

Note: ============================================================================
Note: Queue Operations
Note: ============================================================================

Process called "queue_create" takes initial_capacity as Integer, arena as Integer returns Integer:
    Note: Create new queue
    Note: Returns pointer to Queue structure
    Note: Initializes queue with default settings

    Note: Queue is implemented as a linkedlist
    Let queue_ptr be proc linkedlist_create with arena
    Return queue_ptr
End Process

Process called "queue_destroy" takes queue as Integer returns Nothing:
    Note: Destroy queue and free associated memory
    Note: Frees all queue data
    Note: Validates memory safety before destruction

    If queue is equal to 0:
        Return
    End If

    Let dummy1 be proc linkedlist_destroy with queue
    Return
End Process

Process called "queue_enqueue" takes queue as Integer, element as Integer returns Integer:
    Note: Enqueue element in queue
    Note: Returns 1 if successful, 0 if failed
    Note: Handles queue resizing if needed

    If queue is equal to 0:
        Return 0
    End If

    Note: Enqueue adds to back
    Let result be proc linkedlist_add_back with queue, element
    Return result
End Process

Process called "queue_dequeue" takes queue as Integer returns Integer:
    Note: Dequeue element from queue
    Note: Returns 1 if successful, 0 if failed
    Note: Validates queue is not empty

    If queue is equal to 0:
        Return 0
    End If

    Note: Dequeue removes from front
    Let result be proc linkedlist_remove_front with queue
    Return result
End Process

Process called "queue_front" takes queue as Integer returns Integer:
    Note: Get front element of queue
    Note: Returns pointer to element or 0 if not found
    Note: Validates queue is not empty

    If queue is equal to 0:
        Return 0
    End If

    Let element be proc linkedlist_get_front with queue
    Return element
End Process

Process called "queue_back" takes queue as Integer returns Integer:
    Note: Get back element of queue
    Note: Returns pointer to element or 0 if not found
    Note: Validates queue is not empty

    If queue is equal to 0:
        Return 0
    End If

    Let element be proc linkedlist_get_back with queue
    Return element
End Process

Process called "queue_size" takes queue as Integer returns Integer:
    Note: Get size of queue
    Note: Returns size of queue

    If queue is equal to 0:
        Return 0
    End If

    Let size be proc linkedlist_size with queue
    Return size
End Process

Process called "queue_capacity" takes queue as Integer returns Integer:
    Note: Get capacity of queue
    Note: Returns capacity of queue

    If queue is equal to 0:
        Return 0
    End If

    Note: LinkedList has no fixed capacity
    Let size be proc linkedlist_size with queue
    Return size
End Process

Process called "queue_clear" takes queue as Integer returns Integer:
    Note: Clear queue
    Note: Returns 1 if successful, 0 if failed
    Note: Removes all elements but keeps structure

    If queue is equal to 0:
        Return 0
    End If

    Let result be proc linkedlist_clear with queue
    Return result
End Process

Note: ============================================================================
Note: Tree Operations
Note: ============================================================================

Process called "tree_create" takes comparator as Integer, arena as Integer returns Integer:
    Note: Create new tree
    Note: Returns pointer to Tree structure
    Note: Initializes tree with default settings

    Note: Allocate Tree structure (40 bytes)
    Let tree_size be 40
    Let tree_ptr be 0

    If arena is not equal to 0:
        Set tree_ptr to proc arena_allocate from ArenaUtils with arena, tree_size, 8
    End If

    Otherwise:
        Set tree_ptr to proc allocate from MemoryUtils with tree_size
    End If

    If tree_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize Tree structure
    Let dummy1 be proc memory_set_integer from MemoryCore with tree_ptr, 0, 0
    Let dummy2 be proc memory_set_integer from MemoryCore with tree_ptr, 8, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with tree_ptr, 16, comparator
    Let dummy4 be proc memory_set_integer from MemoryCore with tree_ptr, 24, arena

    Let is_owned be 0
    If arena is equal to 0:
        Set is_owned to 1
    End If

    Let dummy5 be proc memory_set_integer from MemoryCore with tree_ptr, 32, is_owned

    Return tree_ptr
End Process

Process called "tree_destroy" takes tree as Integer returns Nothing:
    Note: Destroy tree and free associated memory
    Note: Frees all tree data
    Note: Validates memory safety before destruction

    If tree is equal to 0:
        Return
    End If

    Note: Clear tree first to free all nodes
    Let dummy1 be proc tree_clear with tree

    Note: Free tree structure if owned
    Let is_owned be proc memory_get_integer from MemoryCore with tree, 32
    If is_owned is equal to 1:
        Let dummy2 be proc deallocate from MemoryUtils with tree
    End If

    Return
End Process

Process called "tree_insert" takes tree as Integer, element as Integer returns Integer:
    Note: Insert element in tree
    Note: Returns 1 if successful, 0 if failed
    Note: Handles tree balancing if needed

    If tree is equal to 0:
        Return 0
    End If

    If element is equal to 0:
        Return 0
    End If

    Note: Allocate tree node (32 bytes: element, left, right, parent)
    Let node_size be 32
    Let arena be proc memory_get_integer from MemoryCore with tree, 24
    Let node_ptr be 0

    If arena is not equal to 0:
        Set node_ptr to proc arena_allocate from ArenaUtils with arena, node_size, 8
    End If

    Otherwise:
        Set node_ptr to proc allocate from MemoryUtils with node_size
    End If

    If node_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize node
    Let dummy1 be proc memory_set_integer from MemoryCore with node_ptr, 0, element
    Let dummy2 be proc memory_set_integer from MemoryCore with node_ptr, 8, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with node_ptr, 16, 0
    Let dummy4 be proc memory_set_integer from MemoryCore with node_ptr, 24, 0

    Note: Get root
    Let root be proc memory_get_integer from MemoryCore with tree, 0

    If root is equal to 0:
        Note: Empty tree, node becomes root
        Let dummy5 be proc memory_set_integer from MemoryCore with tree, 0, node_ptr
    End If

    Otherwise:
        Note: Insert using simple comparison (element value as integer)
        Let current be root
        Let parent be 0

        Note: Find insertion point
        Let inserted be 0
        While inserted is equal to 0:
            Set parent to current
            Let current_element be proc memory_get_integer from MemoryCore with current, 0

            If element is less than current_element:
                Let left be proc memory_get_integer from MemoryCore with current, 8
                If left is equal to 0:
                    Let dummy6 be proc memory_set_integer from MemoryCore with current, 8, node_ptr
                    Let dummy7 be proc memory_set_integer from MemoryCore with node_ptr, 24, current
                    Set inserted to 1
                End If
                Otherwise:
                    Set current to left
                End If
            End If

            Otherwise:
                Let right be proc memory_get_integer from MemoryCore with current, 16
                If right is equal to 0:
                    Let dummy8 be proc memory_set_integer from MemoryCore with current, 16, node_ptr
                    Let dummy9 be proc memory_set_integer from MemoryCore with node_ptr, 24, current
                    Set inserted to 1
                End If
                Otherwise:
                    Set current to right
                End If
            End If
        End While
    End If

    Note: Increment size
    Let size be proc memory_get_integer from MemoryCore with tree, 8
    Let new_size be size plus 1
    Let dummy10 be proc memory_set_integer from MemoryCore with tree, 8, new_size

    Return 1
End Process

Process called "tree_remove" takes tree as Integer, element as Integer returns Integer:
    Note: Remove element from tree using proper BST deletion algorithm
    Note: Returns 1 if successful, 0 if element not found
    Note: Handles three cases: leaf node, one child, two children

    If tree is equal to 0:
        Return 0
    End If

    If element is equal to 0:
        Return 0
    End If

    Note: Find node with element
    Let node be proc tree_find with tree, element

    If node is equal to 0:
        Return 0
    End If

    Note: Get node's children and parent
    Let left be proc memory_get_integer from MemoryCore with node, 8
    Let right be proc memory_get_integer from MemoryCore with node, 16
    Let parent be proc memory_get_integer from MemoryCore with node, 24

    Note: CASE 1: Node is a leaf (no children)
    If left is equal to 0:
        If right is equal to 0:
            Note: Remove leaf node
            If parent is equal to 0:
                Note: Node is root
                Let dummy1 be proc memory_set_integer from MemoryCore with tree, 0, 0
            End If
            Otherwise:
                Note: Determine if node is left or right child of parent
                Let parent_left be proc memory_get_integer from MemoryCore with parent, 8
                If parent_left is equal to node:
                    Let dummy2 be proc memory_set_integer from MemoryCore with parent, 8, 0
                End If
                Otherwise:
                    Let dummy3 be proc memory_set_integer from MemoryCore with parent, 16, 0
                End If
            End If

            Note: Free node
            Let is_owned be proc memory_get_integer from MemoryCore with tree, 32
            If is_owned is equal to 1:
                Let dummy4 be proc deallocate from MemoryUtils with node
            End If

            Note: Decrement size
            Let size be proc memory_get_integer from MemoryCore with tree, 8
            Let new_size be size minus 1
            Let dummy5 be proc memory_set_integer from MemoryCore with tree, 8, new_size

            Return 1
        End If
    End If

    Note: CASE 2: Node has only right child
    If left is equal to 0:
        If right is not equal to 0:
            Note: Replace node with right child
            If parent is equal to 0:
                Note: Node is root
                Let dummy6 be proc memory_set_integer from MemoryCore with tree, 0, right
                Let dummy7 be proc memory_set_integer from MemoryCore with right, 24, 0
            End If
            Otherwise:
                Let parent_left be proc memory_get_integer from MemoryCore with parent, 8
                If parent_left is equal to node:
                    Let dummy8 be proc memory_set_integer from MemoryCore with parent, 8, right
                End If
                Otherwise:
                    Let dummy9 be proc memory_set_integer from MemoryCore with parent, 16, right
                End If
                Let dummy10 be proc memory_set_integer from MemoryCore with right, 24, parent
            End If

            Note: Free node
            Let is_owned be proc memory_get_integer from MemoryCore with tree, 32
            If is_owned is equal to 1:
                Let dummy11 be proc deallocate from MemoryUtils with node
            End If

            Note: Decrement size
            Let size be proc memory_get_integer from MemoryCore with tree, 8
            Let new_size be size minus 1
            Let dummy12 be proc memory_set_integer from MemoryCore with tree, 8, new_size

            Return 1
        End If
    End If

    Note: CASE 3: Node has only left child
    If right is equal to 0:
        If left is not equal to 0:
            Note: Replace node with left child
            If parent is equal to 0:
                Note: Node is root
                Let dummy13 be proc memory_set_integer from MemoryCore with tree, 0, left
                Let dummy14 be proc memory_set_integer from MemoryCore with left, 24, 0
            End If
            Otherwise:
                Let parent_left be proc memory_get_integer from MemoryCore with parent, 8
                If parent_left is equal to node:
                    Let dummy15 be proc memory_set_integer from MemoryCore with parent, 8, left
                End If
                Otherwise:
                    Let dummy16 be proc memory_set_integer from MemoryCore with parent, 16, left
                End If
                Let dummy17 be proc memory_set_integer from MemoryCore with left, 24, parent
            End If

            Note: Free node
            Let is_owned be proc memory_get_integer from MemoryCore with tree, 32
            If is_owned is equal to 1:
                Let dummy18 be proc deallocate from MemoryUtils with node
            End If

            Note: Decrement size
            Let size be proc memory_get_integer from MemoryCore with tree, 8
            Let new_size be size minus 1
            Let dummy19 be proc memory_set_integer from MemoryCore with tree, 8, new_size

            Return 1
        End If
    End If

    Note: CASE 4: Node has two children - find inorder successor
    If left is not equal to 0:
        If right is not equal to 0:
            Note: Find minimum in right subtree (inorder successor)
            Let successor be right
            While successor is not equal to 0:
                Let successor_left be proc memory_get_integer from MemoryCore with successor, 8
                If successor_left is equal to 0:
                    Let break be 1
                End If
                Otherwise:
                    Set successor to successor_left
                End If
            End While

            Note: Copy successor's element to node
            Let successor_element be proc memory_get_integer from MemoryCore with successor, 0
            Let dummy20 be proc memory_set_integer from MemoryCore with node, 0, successor_element

            Note: Remove successor (which has at most one child)
            Let successor_right be proc memory_get_integer from MemoryCore with successor, 16
            Let successor_parent be proc memory_get_integer from MemoryCore with successor, 24

            If successor_parent is equal to node:
                Note: Successor is direct right child
                Let dummy21 be proc memory_set_integer from MemoryCore with node, 16, successor_right
                If successor_right is not equal to 0:
                    Let dummy22 be proc memory_set_integer from MemoryCore with successor_right, 24, node
                End If
            End If
            Otherwise:
                Note: Successor is deeper in tree
                Let dummy23 be proc memory_set_integer from MemoryCore with successor_parent, 8, successor_right
                If successor_right is not equal to 0:
                    Let dummy24 be proc memory_set_integer from MemoryCore with successor_right, 24, successor_parent
                End If
            End If

            Note: Free successor
            Let is_owned be proc memory_get_integer from MemoryCore with tree, 32
            If is_owned is equal to 1:
                Let dummy25 be proc deallocate from MemoryUtils with successor
            End If

            Note: Decrement size
            Let size be proc memory_get_integer from MemoryCore with tree, 8
            Let new_size be size minus 1
            Let dummy26 be proc memory_set_integer from MemoryCore with tree, 8, new_size

            Return 1
        End If
    End If

    Return 0
End Process

Process called "tree_find" takes tree as Integer, element as Integer returns Integer:
    Note: Find element in tree
    Note: Returns pointer to element or 0 if not found
    Note: Uses tree search algorithm

    If tree is equal to 0:
        Return 0
    End If

    If element is equal to 0:
        Return 0
    End If

    Let root be proc memory_get_integer from MemoryCore with tree, 0

    If root is equal to 0:
        Return 0
    End If

    Note: Search tree
    Let current be root

    While current is not equal to 0:
        Let current_element be proc memory_get_integer from MemoryCore with current, 0

        If element is equal to current_element:
            Return current
        End If

        Otherwise If element is less than current_element:
            Let left be proc memory_get_integer from MemoryCore with current, 8
            Set current to left
        End If

        Otherwise:
            Let right be proc memory_get_integer from MemoryCore with current, 16
            Set current to right
        End If
    End While

    Return 0
End Process

Process called "tree_size" takes tree as Integer returns Integer:
    Note: Get size of tree
    Note: Returns size of tree

    If tree is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with tree, 8
    Return size
End Process

Process called "tree_clear" takes tree as Integer returns Integer:
    Note: Clear tree by recursively freeing all nodes
    Note: Returns 1 if successful, 0 if failed
    Note: Removes all elements but keeps tree structure

    If tree is equal to 0:
        Return 0
    End If

    Let root be proc memory_get_integer from MemoryCore with tree, 0

    If root is not equal to 0:
        Note: Recursively clear tree using post-order traversal
        Let result be proc tree_clear_recursive with tree, root
    End If

    Note: Reset root and size
    Let dummy1 be proc memory_set_integer from MemoryCore with tree, 0, 0
    Let dummy2 be proc memory_set_integer from MemoryCore with tree, 8, 0

    Return 1
End Process

Private Process called "tree_clear_recursive" takes tree as Integer, node as Integer returns Integer:
    Note: Recursively free tree nodes using post-order traversal
    Note: Frees left subtree, then right subtree, then node itself
    Note: Returns 1 on success

    If node is equal to 0:
        Return 1
    End If

    Note: Get left and right children
    Let left be proc memory_get_integer from MemoryCore with node, 8
    Let right be proc memory_get_integer from MemoryCore with node, 16

    Note: Clear left subtree
    If left is not equal to 0:
        Let result1 be proc tree_clear_recursive with tree, left
    End If

    Note: Clear right subtree
    If right is not equal to 0:
        Let result2 be proc tree_clear_recursive with tree, right
    End If

    Note: Free current node if owned
    Let is_owned be proc memory_get_integer from MemoryCore with tree, 32
    If is_owned is equal to 1:
        Let dummy1 be proc deallocate from MemoryUtils with node
    End If

    Return 1
End Process

Note: ============================================================================
Note: ArrayList Sorting and Searching Operations
Note: ============================================================================

Process called "arraylist_sort" takes list as Integer, comparator as Integer, order as Integer returns Integer:
    Note: Sort array list using quicksort algorithm
    Note: comparator is pointer to comparison function(elem1, elem2) returning -1/0/1
    Note: order is COLLECTION_ORDER_ASCENDING or COLLECTION_ORDER_DESCENDING
    Note: Returns 1 if successful, 0 if failed
    Note: Sorts in-place with O(n log n) average time complexity

    If list is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with list, 8
    If size is less than 2:
        Return 1  Note: Already sorted
    End If

    Let data be proc memory_get_integer from MemoryCore with list, 0
    Let element_size be proc memory_get_integer from MemoryCore with list, 24

    Note: Call quicksort on entire array
    Let result be proc arraylist_quicksort with data, 0, size minus 1, element_size, comparator, order
    Return result
End Process

Private Process called "arraylist_quicksort" takes data as Integer, low as Integer, high as Integer, element_size as Integer, comparator as Integer, order as Integer returns Integer:
    Note: Quicksort implementation with Hoare partition scheme
    Note: Recursively sorts array[low..high]
    Note: Returns 1 on success

    If low is greater than or equal to high:
        Return 1
    End If

    Note: Partition array and get pivot index
    Let pivot_index be proc arraylist_partition with data, low, high, element_size, comparator, order

    Note: Recursively sort left partition (low to pivot)
    Let result1 be proc arraylist_quicksort with data, low, pivot_index, element_size, comparator, order

    Note: Recursively sort right partition (pivot+1 to high)
    Let pivot_plus_1 be pivot_index plus 1
    Let result2 be proc arraylist_quicksort with data, pivot_plus_1, high, element_size, comparator, order

    Return 1
End Process

Private Process called "arraylist_partition" takes data as Integer, low as Integer, high as Integer, element_size as Integer, comparator as Integer, order as Integer returns Integer:
    Note: Hoare partition scheme for quicksort
    Note: Returns pivot index after partitioning
    Note: Elements <= pivot are on left, elements >= pivot are on right

    Note: Choose middle element as pivot to avoid worst case on sorted data
    Let mid_index be low plus high
    Set mid_index to mid_index divided by 2
    Let pivot_offset be mid_index multiplied by element_size
    Let pivot be data plus pivot_offset

    Let i be low minus 1
    Let j be high plus 1

    Note: Partition loop
    Let max_iterations be 1000000
    Let iteration be 0
    While iteration is less than max_iterations:
        Set iteration to iteration plus 1

        Note: Move i right while elements are less than pivot
        Set i to i plus 1
        Let i_offset be i multiplied by element_size
        Let elem_i be data plus i_offset
        Let comp_result be proc arraylist_compare_elements with elem_i, pivot, comparator, order

        While comp_result is less than 0:
            Set i to i plus 1
            Set i_offset to i multiplied by element_size
            Set elem_i to data plus i_offset
            Set comp_result to proc arraylist_compare_elements with elem_i, pivot, comparator, order
        End While

        Note: Move j left while elements are greater than pivot
        Set j to j minus 1
        Let j_offset be j multiplied by element_size
        Let elem_j be data plus j_offset
        Set comp_result to proc arraylist_compare_elements with pivot, elem_j, comparator, order

        While comp_result is less than 0:
            Set j to j minus 1
            Set j_offset to j multiplied by element_size
            Set elem_j to data plus j_offset
            Set comp_result to proc arraylist_compare_elements with pivot, elem_j, comparator, order
        End While

        Note: If indices crossed, return partition index
        If i is greater than or equal to j:
            Return j
        End If

        Note: Swap elements at i and j
        Let swap_result be proc arraylist_swap_elements with data, i, j, element_size

        Note: Continue partitioning
    End While

    Return j
End Process

Private Process called "arraylist_compare_elements" takes elem1 as Integer, elem2 as Integer, comparator as Integer, order as Integer returns Integer:
    Note: Compare two elements using comparator function or default integer comparison
    Note: Returns -1 if elem1 < elem2, 0 if equal, 1 if elem1 > elem2
    Note: Reverses comparison if order is DESCENDING
    Note: If comparator is 0, uses default integer comparison (first 8 bytes of elements)
    Note: If comparator is non-zero, it is a function pointer called via __builtin_call_indirect_2

    Let result be 0

    Note: Check if custom comparator provided
    If comparator is equal to 0:
        Note: Use default integer comparison
        Note: Compare first 8 bytes of each element as integers
        Let val1 be proc memory_get_integer from MemoryCore with elem1, 0
        Let val2 be proc memory_get_integer from MemoryCore with elem2, 0

        If val1 is less than val2:
            Set result to -1
        End If
        Otherwise If val1 is greater than val2:
            Set result to 1
        End If
        Otherwise:
            Set result to 0
        End If
    End If
    Otherwise:
        Note: Custom comparator function pointer provided
        Note: Call comparator function: result = comparator(elem1, elem2)
        Note: Comparator returns: -1 if elem1 < elem2, 0 if equal, 1 if elem1 > elem2
        Note: Uses __builtin_call_indirect_2 for platform-agnostic function pointer invocation
        Set result to __builtin_call_indirect_2 with comparator, elem1, elem2
    End If

    Note: Reverse comparison for descending order
    If order is equal to COLLECTION_ORDER_DESCENDING:
        Let zero_minus_result be 0 minus result
        Set result to zero_minus_result
    End If

    Return result
End Process

Private Process called "arraylist_swap_elements" takes data as Integer, index1 as Integer, index2 as Integer, element_size as Integer returns Integer:
    Note: Swap elements at index1 and index2
    Note: Returns 1 on success

    If index1 is equal to index2:
        Return 1
    End If

    Let offset1 be index1 multiplied by element_size
    Let offset2 be index2 multiplied by element_size
    Let elem1 be data plus offset1
    Let elem2 be data plus offset2

    Note: Swap bytes one at a time
    Let i be 0
    While i is less than element_size:
        Let byte1 be proc memory_get_byte from MemoryCore with elem1, i
        Let byte2 be proc memory_get_byte from MemoryCore with elem2, i
        Let dummy1 be proc memory_set_byte from MemoryCore with elem1, i, byte2
        Let dummy2 be proc memory_set_byte from MemoryCore with elem2, i, byte1
        Set i to i plus 1
    End While

    Return 1
End Process

Process called "arraylist_binary_search" takes list as Integer, target as Integer, comparator as Integer returns Integer:
    Note: Binary search in sorted array list
    Note: comparator is pointer to comparison function(elem, target) returning -1/0/1
    Note: Returns index if found, -1 if not found
    Note: Array MUST be sorted in ascending order before calling
    Note: O(log n) time complexity

    If list is equal to 0:
        Return -1
    End If

    Let size be proc memory_get_integer from MemoryCore with list, 8
    If size is equal to 0:
        Return -1
    End If

    Let data be proc memory_get_integer from MemoryCore with list, 0
    Let element_size be proc memory_get_integer from MemoryCore with list, 24

    Let low be 0
    Let high be size minus 1

    Note: Binary search loop
    While low is less than or equal to high:
        Note: Calculate middle index
        Let mid be low plus high
        Set mid to mid divided by 2

        Note: Get element at mid
        Let mid_offset be mid multiplied by element_size
        Let mid_elem be data plus mid_offset

        Note: Compare mid element with target
        Let mid_val be proc memory_get_integer from MemoryCore with mid_elem, 0
        Let target_val be proc memory_get_integer from MemoryCore with target, 0

        Note: Found exact match
        If mid_val is equal to target_val:
            Return mid
        End If

        Note: Target is in right half
        Otherwise If mid_val is less than target_val:
            Set low to mid plus 1
        End If

        Note: Target is in left half
        Otherwise:
            Set high to mid minus 1
        End If
    End While

    Note: Not found
    Return -1
End Process

Note: ============================================================================
Note: HashTable Key/Value Extraction Operations
Note: ============================================================================

Process called "hashtable_get_keys" takes table as Integer, arena as Integer returns Integer:
    Note: Extract all keys from hash table into array
    Note: Returns pointer to Integer array of key pointers
    Note: First element is count, followed by key pointers
    Note: Single-pass implementation for efficiency

    If table is equal to 0:
        Return 0
    End If

    Note: Get table properties
    Let buckets be proc memory_get_integer from MemoryCore with table, 0
    Let capacity be proc memory_get_integer from MemoryCore with table, 16
    Let size be proc memory_get_integer from MemoryCore with table, 8

    If size is equal to 0:
        Note: Return array with count = 0
        Let result_size be 8
        Let result be 0
        If arena is not equal to 0:
            Set result to proc arena_allocate from ArenaUtils with arena, result_size, 8
        End If
        Otherwise:
            Set result to proc allocate from MemoryUtils with result_size
        End If
        If result is not equal to 0:
            Let dummy be proc memory_set_integer from MemoryCore with result, 0, 0
        End If
        Return result
    End If

    Note: Allocate result array: count (8 bytes) + size * 8 bytes for pointers
    Let result_size be size multiplied by 8
    Set result_size to result_size plus 8
    Let result be 0
    If arena is not equal to 0:
        Set result to proc arena_allocate from ArenaUtils with arena, result_size, 8
    End If
    Otherwise:
        Set result to proc allocate from MemoryUtils with result_size
    End If

    If result is equal to 0:
        Return 0
    End If

    Note: Set count at offset 0
    Let dummy1 be proc memory_set_integer from MemoryCore with result, 0, size

    Note: Walk through all buckets and collect keys (single pass)
    Let write_index be 0
    Let bucket_index be 0

    While bucket_index is less than capacity:
        Let bucket_offset be bucket_index multiplied by 8
        Let entry_ptr be proc memory_get_integer from MemoryCore with buckets, bucket_offset

        Note: Walk chain in this bucket
        While entry_ptr is not equal to 0:
            Note: Get key from entry
            Let key be proc memory_get_integer from MemoryCore with entry_ptr, 0

            Note: Store key pointer in result array
            Let key_offset be write_index multiplied by 8
            Set key_offset to key_offset plus 8
            Let dummy2 be proc memory_set_integer from MemoryCore with result, key_offset, key

            Set write_index to write_index plus 1

            Note: Move to next entry in chain
            Set entry_ptr to proc memory_get_integer from MemoryCore with entry_ptr, 24
        End While

        Set bucket_index to bucket_index plus 1
    End While

    Return result
End Process

Process called "hashtable_get_values" takes table as Integer, arena as Integer returns Integer:
    Note: Extract all values from hash table into array
    Note: Returns pointer to Integer array of value pointers
    Note: First element is count, followed by value pointers
    Note: Single-pass implementation for efficiency

    If table is equal to 0:
        Return 0
    End If

    Note: Get table properties
    Let buckets be proc memory_get_integer from MemoryCore with table, 0
    Let capacity be proc memory_get_integer from MemoryCore with table, 16
    Let size be proc memory_get_integer from MemoryCore with table, 8

    If size is equal to 0:
        Note: Return array with count = 0
        Let result_size be 8
        Let result be 0
        If arena is not equal to 0:
            Set result to proc arena_allocate from ArenaUtils with arena, result_size, 8
        End If
        Otherwise:
            Set result to proc allocate from MemoryUtils with result_size
        End If
        If result is not equal to 0:
            Let dummy be proc memory_set_integer from MemoryCore with result, 0, 0
        End If
        Return result
    End If

    Note: Allocate result array: count (8 bytes) + size * 8 bytes for pointers
    Let result_size be size multiplied by 8
    Set result_size to result_size plus 8
    Let result be 0
    If arena is not equal to 0:
        Set result to proc arena_allocate from ArenaUtils with arena, result_size, 8
    End If
    Otherwise:
        Set result to proc allocate from MemoryUtils with result_size
    End If

    If result is equal to 0:
        Return 0
    End If

    Note: Set count at offset 0
    Let dummy1 be proc memory_set_integer from MemoryCore with result, 0, size

    Note: Walk through all buckets and collect values (single pass)
    Let write_index be 0
    Let bucket_index be 0

    While bucket_index is less than capacity:
        Let bucket_offset be bucket_index multiplied by 8
        Let entry_ptr be proc memory_get_integer from MemoryCore with buckets, bucket_offset

        Note: Walk chain in this bucket
        While entry_ptr is not equal to 0:
            Note: Get value from entry (offset 8)
            Let value be proc memory_get_integer from MemoryCore with entry_ptr, 8

            Note: Store value pointer in result array
            Let value_offset be write_index multiplied by 8
            Set value_offset to value_offset plus 8
            Let dummy2 be proc memory_set_integer from MemoryCore with result, value_offset, value

            Set write_index to write_index plus 1

            Note: Move to next entry in chain
            Set entry_ptr to proc memory_get_integer from MemoryCore with entry_ptr, 24
        End While

        Set bucket_index to bucket_index plus 1
    End While

    Return result
End Process