Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles collection data structures and collection utility operations for the Runa compiler internal system.

COLLECTIONS - Compiler Data Structure Management Engine
- Process collection creation and collection management operations for compiler data structures
- Handle collection resizing and collection capacity management for compiler operations
- Manage collection operations and collection manipulation utilities for compiler workflows
- Process collection optimization and collection performance utilities for compiler efficiency
- Handle integration with compiler phases for data structure management and processing

This file is essential because of the following reasons:
- Collection management is fundamental to compiler operation and data structure handling
- Proper collection handling ensures efficient compiler data operations and performance
- Collection utilities support all compiler phases that need data structure management
- Collection management provides deterministic memory management for compiler operations

This file consists of the following functions/features/operation types:
- Collection creation, destruction, and lifecycle management
- Collection allocation and deallocation operations
- Collection resizing and capacity management
- Collection optimization and performance monitoring
- Integration with compiler phases for collection management needs

Dependencies:
- Imports arena_utils.runa for arena-based collection allocation
- Imports owned_utils.runa for owned collection management
- Imports memory_safety.runa for collection safety validation
- Imports buffer_utils.runa for collection buffer management
:End Note

Import "compiler/internal/arena_utils.runa" as ArenaUtils
Import "compiler/internal/owned_utils.runa" as OwnedUtils
Import "compiler/internal/memory_safety.runa" as MemorySafety
Import "compiler/internal/buffer_utils.runa" as BufferUtils
Import "compiler/internal/hash_utils.runa" as HashUtils
Import "compiler/primitives/memory_core.runa" as MemoryCore
Import "compiler/primitives/memory_utils.runa" as MemoryUtils

Note: ============================================================================
Note: Collection Data Structures
Note: ============================================================================

Type called "ArrayList":
    data as Integer          Note: Pointer to array data
    size as Integer         Note: Current size of array
    capacity as Integer     Note: Maximum capacity of array
    element_size as Integer Note: Size of each element
    arena as Integer         Note: Pointer to arena for allocation
    is_owned as Integer      Note: Boolean: 1 if owned, 0 if arena-allocated

Type called "LinkedList":
    head as Integer         Note: Pointer to head node
    tail as Integer         Note: Pointer to tail node
    size as Integer         Note: Current size of list
    arena as Integer         Note: Pointer to arena for allocation
    is_owned as Integer      Note: Boolean: 1 if owned, 0 if arena-allocated

Type called "HashTable":
    buckets as Integer      Note: Pointer to bucket array
    size as Integer         Note: Current size of table
    capacity as Integer     Note: Maximum capacity of table
    load_factor as Integer  Note: Load factor threshold
    arena as Integer         Note: Pointer to arena for allocation
    is_owned as Integer      Note: Boolean: 1 if owned, 0 if arena-allocated

Type called "Stack":
    data as Integer         Note: Pointer to stack data
    top as Integer          Note: Current top position
    capacity as Integer     Note: Maximum capacity of stack
    arena as Integer         Note: Pointer to arena for allocation
    is_owned as Integer      Note: Boolean: 1 if owned, 0 if arena-allocated

Type called "Queue":
    data as Integer         Note: Pointer to queue data
    front as Integer        Note: Front position in queue
    rear as Integer         Note: Rear position in queue
    size as Integer         Note: Current size of queue
    capacity as Integer     Note: Maximum capacity of queue
    arena as Integer         Note: Pointer to arena for allocation
    is_owned as Integer      Note: Boolean: 1 if owned, 0 if arena-allocated

Type called "Tree":
    root as Integer         Note: Pointer to root node
    size as Integer         Note: Current size of tree
    comparator as Integer   Note: Pointer to comparison function
    arena as Integer         Note: Pointer to arena for allocation
    is_owned as Integer      Note: Boolean: 1 if owned, 0 if arena-allocated

Note: ============================================================================
Note: Collection Constants
Note: ============================================================================

Define constant COLLECTION_DEFAULT_SIZE as 16
Define constant COLLECTION_MIN_SIZE as 4
Define constant COLLECTION_MAX_SIZE as 1073741824
Define constant COLLECTION_GROWTH_FACTOR as 2
Define constant COLLECTION_SHRINK_THRESHOLD as 4

Define constant COLLECTION_SUCCESS as 0
Define constant COLLECTION_FAILED as -1
Define constant COLLECTION_OVERFLOW as -2
Define constant COLLECTION_UNDERFLOW as -3
Define constant COLLECTION_NOT_FOUND as -4

Define constant COLLECTION_ORDER_ASCENDING as 0
Define constant COLLECTION_ORDER_DESCENDING as 1
Define constant COLLECTION_ORDER_NONE as 2

Note: ============================================================================
Note: ArrayList Operations
Note: ============================================================================

Process called "arraylist_create" takes initial_capacity as Integer, element_size as Integer, arena as Integer returns Integer:
    Note: Create new array list
    Note: Returns pointer to ArrayList structure
    Note: Initializes array list with default settings

    If element_size is less than 1:
        Return 0
    End If

    Let use_capacity be initial_capacity
    Let min_size be 4
    If use_capacity is less than min_size:
        Set use_capacity to min_size
    End If

    Let max_size be 1073741824
    If use_capacity is greater than max_size:
        Return 0
    End If

    Note: Allocate ArrayList structure (48 bytes)
    Let list_size be 48
    Let list_ptr be 0

    If arena is not equal to 0:
        Set list_ptr to proc arena_allocate from ArenaUtils with arena, list_size, 8
    End If

    Otherwise:
        Set list_ptr to proc allocate from MemoryUtils with list_size
    End If

    If list_ptr is equal to 0:
        Return 0
    End If

    Note: Allocate data array
    Let data_size be use_capacity multiplied by element_size
    Let data_ptr be 0

    If arena is not equal to 0:
        Set data_ptr to proc arena_allocate from ArenaUtils with arena, data_size, 8
    End If

    Otherwise:
        Set data_ptr to proc allocate from MemoryUtils with data_size
    End If

    If data_ptr is equal to 0:
        If arena is equal to 0:
            Let dummy1 be proc deallocate from MemoryUtils with list_ptr
        End If
        Return 0
    End If

    Note: Initialize ArrayList structure
    Let dummy2 be proc memory_set_integer from MemoryCore with list_ptr, 0, data_ptr
    Let dummy3 be proc memory_set_integer from MemoryCore with list_ptr, 8, 0
    Let dummy4 be proc memory_set_integer from MemoryCore with list_ptr, 16, use_capacity
    Let dummy5 be proc memory_set_integer from MemoryCore with list_ptr, 24, element_size
    Let dummy6 be proc memory_set_integer from MemoryCore with list_ptr, 32, arena

    Let is_owned be 0
    If arena is equal to 0:
        Set is_owned to 1
    End If

    Let dummy7 be proc memory_set_integer from MemoryCore with list_ptr, 40, is_owned

    Return list_ptr
End Process

Process called "arraylist_destroy" takes list as Integer returns Nothing:
    Note: Destroy array list and free associated memory
    Note: Frees all array list data
    Note: Validates memory safety before destruction

    If list is equal to 0:
        Return
    End If

    Let is_owned be proc memory_get_integer from MemoryCore with list, 40

    If is_owned is equal to 1:
        Let data_ptr be proc memory_get_integer from MemoryCore with list, 0
        If data_ptr is not equal to 0:
            Let dummy1 be proc deallocate from MemoryUtils with data_ptr
        End If
        Let dummy2 be proc deallocate from MemoryUtils with list
    End If

    Return
End Process

Process called "arraylist_add" takes list as Integer, element as Integer returns Integer:
    Note: Add element to array list
    Note: Returns 1 if successful, 0 if failed
    Note: Handles array list resizing if needed

    If list is equal to 0:
        Return 0
    End If

    If element is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with list, 8
    Let capacity be proc memory_get_integer from MemoryCore with list, 16

    Note: Resize if at capacity
    If size is equal to capacity:
        Let growth_factor be 2
        Let new_capacity be capacity multiplied by growth_factor
        Let max_size be 1073741824

        If new_capacity is greater than max_size:
            Return 0
        End If

        Let element_size be proc memory_get_integer from MemoryCore with list, 24
        Let new_data_size be new_capacity multiplied by element_size
        Let old_data_ptr be proc memory_get_integer from MemoryCore with list, 0
        Let new_data_ptr be proc allocate from MemoryUtils with new_data_size

        If new_data_ptr is equal to 0:
            Return 0
        End If

        Let old_data_size be capacity multiplied by element_size
        Let dummy1 be proc memory_copy from MemoryCore with new_data_ptr, old_data_ptr, old_data_size

        Let is_owned be proc memory_get_integer from MemoryCore with list, 40
        If is_owned is equal to 1:
            Let dummy2 be proc deallocate from MemoryUtils with old_data_ptr
        End If

        Let dummy3 be proc memory_set_integer from MemoryCore with list, 0, new_data_ptr
        Let dummy4 be proc memory_set_integer from MemoryCore with list, 16, new_capacity
        Let dummy5 be proc memory_set_integer from MemoryCore with list, 40, 1
    End If

    Note: Add element at end
    Let data_ptr be proc memory_get_integer from MemoryCore with list, 0
    Let element_size be proc memory_get_integer from MemoryCore with list, 24
    Let offset be size multiplied by element_size
    Let target_ptr be data_ptr plus offset
    Let dummy6 be proc memory_copy from MemoryCore with target_ptr, element, element_size

    Let new_size be size plus 1
    Let dummy7 be proc memory_set_integer from MemoryCore with list, 8, new_size

    Return 1
End Process

Process called "arraylist_insert" takes list as Integer, index as Integer, element as Integer returns Integer:
    Note: Insert element at specified index in array list
    Note: Returns 1 if successful, 0 if failed
    Note: Validates index bounds

    If list is equal to 0:
        Return 0
    End If

    If element is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with list, 8

    If index is less than 0:
        Return 0
    End If

    If index is greater than size:
        Return 0
    End If

    Note: If inserting at end, use arraylist_add
    If index is equal to size:
        Let result be proc arraylist_add with list, element
        Return result
    End If

    Note: Ensure capacity for insertion
    Let capacity be proc memory_get_integer from MemoryCore with list, 16

    If size is equal to capacity:
        Let dummy_element be 0
        Let resize_result be proc arraylist_add with list, dummy_element
        If resize_result is equal to 0:
            Return 0
        End If
        Set size to size plus 1
        Let dummy1 be proc memory_set_integer from MemoryCore with list, 8, size
    End If

    Note: Shift elements to make space
    Let data_ptr be proc memory_get_integer from MemoryCore with list, 0
    Let element_size be proc memory_get_integer from MemoryCore with list, 24
    Let insert_offset be index multiplied by element_size
    Let insert_ptr be data_ptr plus insert_offset
    Let next_offset be index plus 1
    Set next_offset to next_offset multiplied by element_size
    Let next_ptr be data_ptr plus next_offset
    Let elements_to_move be size minus index
    Let bytes_to_move be elements_to_move multiplied by element_size

    If bytes_to_move is greater than 0:
        Let dummy2 be proc memory_move from MemoryCore with next_ptr, insert_ptr, bytes_to_move
    End If

    Note: Insert element
    Let dummy3 be proc memory_copy from MemoryCore with insert_ptr, element, element_size

    Let new_size be size plus 1
    Let dummy4 be proc memory_set_integer from MemoryCore with list, 8, new_size

    Return 1
End Process

Process called "arraylist_remove" takes list as Integer, index as Integer returns Integer:
    Note: Remove element at specified index from array list
    Note: Returns 1 if successful, 0 if failed
    Note: Validates index bounds

    If list is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with list, 8

    If index is less than 0:
        Return 0
    End If

    If index is greater than size:
        Return 0
    End If

    Otherwise If index is equal to size:
        Return 0
    End If

    Note: Shift elements to fill gap
    Let data_ptr be proc memory_get_integer from MemoryCore with list, 0
    Let element_size be proc memory_get_integer from MemoryCore with list, 24
    Let remove_offset be index multiplied by element_size
    Let remove_ptr be data_ptr plus remove_offset
    Let next_index be index plus 1
    Let next_offset be next_index multiplied by element_size
    Let next_ptr be data_ptr plus next_offset
    Let elements_to_move be size minus next_index
    Let bytes_to_move be elements_to_move multiplied by element_size

    If bytes_to_move is greater than 0:
        Let dummy1 be proc memory_move from MemoryCore with remove_ptr, next_ptr, bytes_to_move
    End If

    Let new_size be size minus 1
    Let dummy2 be proc memory_set_integer from MemoryCore with list, 8, new_size

    Return 1
End Process

Process called "arraylist_get" takes list as Integer, index as Integer returns Integer:
    Note: Get element at specified index from array list
    Note: Returns pointer to element or 0 if not found
    Note: Validates index bounds

    If list is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with list, 8

    If index is less than 0:
        Return 0
    End If

    If index is greater than size:
        Return 0
    End If

    Otherwise If index is equal to size:
        Return 0
    End If

    Let data_ptr be proc memory_get_integer from MemoryCore with list, 0
    Let element_size be proc memory_get_integer from MemoryCore with list, 24
    Let offset be index multiplied by element_size
    Let element_ptr be data_ptr plus offset

    Return element_ptr
End Process

Process called "arraylist_set" takes list as Integer, index as Integer, element as Integer returns Integer:
    Note: Set element at specified index in array list
    Note: Returns 1 if successful, 0 if failed
    Note: Validates index bounds

    If list is equal to 0:
        Return 0
    End If

    If element is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with list, 8

    If index is less than 0:
        Return 0
    End If

    If index is greater than size:
        Return 0
    End If

    Otherwise If index is equal to size:
        Return 0
    End If

    Let data_ptr be proc memory_get_integer from MemoryCore with list, 0
    Let element_size be proc memory_get_integer from MemoryCore with list, 24
    Let offset be index multiplied by element_size
    Let target_ptr be data_ptr plus offset
    Let dummy1 be proc memory_copy from MemoryCore with target_ptr, element, element_size

    Return 1
End Process

Process called "arraylist_size" takes list as Integer returns Integer:
    Note: Get size of array list
    Note: Returns size of array list

    If list is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with list, 8
    Return size
End Process

Process called "arraylist_capacity" takes list as Integer returns Integer:
    Note: Get capacity of array list
    Note: Returns capacity of array list

    If list is equal to 0:
        Return 0
    End If

    Let capacity be proc memory_get_integer from MemoryCore with list, 16
    Return capacity
End Process

Process called "arraylist_clear" takes list as Integer returns Integer:
    Note: Clear array list
    Note: Returns 1 if successful, 0 if failed
    Note: Removes all elements but keeps structure

    If list is equal to 0:
        Return 0
    End If

    Let dummy1 be proc memory_set_integer from MemoryCore with list, 8, 0
    Return 1
End Process

Note: ============================================================================
Note: LinkedList Operations
Note: ============================================================================

Process called "linkedlist_create" takes arena as Integer returns Integer:
    Note: Create new linked list
    Note: Returns pointer to LinkedList structure
    Note: Initializes linked list with default settings

    Note: Allocate LinkedList structure (40 bytes)
    Let list_size be 40
    Let list_ptr be 0

    If arena is not equal to 0:
        Set list_ptr to proc arena_allocate from ArenaUtils with arena, list_size, 8
    End If

    Otherwise:
        Set list_ptr to proc allocate from MemoryUtils with list_size
    End If

    If list_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize LinkedList structure
    Let dummy1 be proc memory_set_integer from MemoryCore with list_ptr, 0, 0
    Let dummy2 be proc memory_set_integer from MemoryCore with list_ptr, 8, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with list_ptr, 16, 0
    Let dummy4 be proc memory_set_integer from MemoryCore with list_ptr, 24, arena

    Let is_owned be 0
    If arena is equal to 0:
        Set is_owned to 1
    End If

    Let dummy5 be proc memory_set_integer from MemoryCore with list_ptr, 32, is_owned

    Return list_ptr
End Process

Process called "linkedlist_destroy" takes list as Integer returns Nothing:
    Note: Destroy linked list and free associated memory
    Note: Frees all linked list data
    Note: Validates memory safety before destruction

    If list is equal to 0:
        Return
    End If

    Let is_owned be proc memory_get_integer from MemoryCore with list, 32

    If is_owned is equal to 1:
        Note: Free all nodes
        Let current be proc memory_get_integer from MemoryCore with list, 0
        While current is not equal to 0:
            Let next be proc memory_get_integer from MemoryCore with current, 8
            Let dummy1 be proc deallocate from MemoryUtils with current
            Set current to next
        End While

        Note: Free list structure
        Let dummy2 be proc deallocate from MemoryUtils with list
    End If

    Return
End Process

Process called "linkedlist_add_front" takes list as Integer, element as Integer returns Integer:
    Note: Add element to front of linked list
    Note: Returns 1 if successful, 0 if failed
    Note: Handles linked list resizing if needed

    If list is equal to 0:
        Return 0
    End If

    If element is equal to 0:
        Return 0
    End If

    Note: Allocate new node (24 bytes: data ptr, next ptr, prev ptr)
    Let node_size be 24
    Let arena be proc memory_get_integer from MemoryCore with list, 24
    Let node_ptr be 0

    If arena is not equal to 0:
        Set node_ptr to proc arena_allocate from ArenaUtils with arena, node_size, 8
    End If

    Otherwise:
        Set node_ptr to proc allocate from MemoryUtils with node_size
    End If

    If node_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize node
    Let dummy1 be proc memory_set_integer from MemoryCore with node_ptr, 0, element
    Let dummy2 be proc memory_set_integer from MemoryCore with node_ptr, 8, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with node_ptr, 16, 0

    Note: Insert at front
    Let head be proc memory_get_integer from MemoryCore with list, 0

    If head is equal to 0:
        Note: Empty list, node becomes both head and tail
        Let dummy4 be proc memory_set_integer from MemoryCore with list, 0, node_ptr
        Let dummy5 be proc memory_set_integer from MemoryCore with list, 8, node_ptr
    End If

    Otherwise:
        Note: Set node's next to current head
        Let dummy6 be proc memory_set_integer from MemoryCore with node_ptr, 8, head
        Note: Set old head's prev to new node
        Let dummy7 be proc memory_set_integer from MemoryCore with head, 16, node_ptr
        Note: Update list head
        Let dummy8 be proc memory_set_integer from MemoryCore with list, 0, node_ptr
    End If

    Note: Increment size
    Let size be proc memory_get_integer from MemoryCore with list, 16
    Let new_size be size plus 1
    Let dummy9 be proc memory_set_integer from MemoryCore with list, 16, new_size

    Return 1
End Process

Process called "linkedlist_add_back" takes list as Integer, element as Integer returns Integer:
    Note: Add element to back of linked list
    Note: Returns 1 if successful, 0 if failed
    Note: Handles linked list resizing if needed

    If list is equal to 0:
        Return 0
    End If

    If element is equal to 0:
        Return 0
    End If

    Note: Allocate new node (24 bytes)
    Let node_size be 24
    Let arena be proc memory_get_integer from MemoryCore with list, 24
    Let node_ptr be 0

    If arena is not equal to 0:
        Set node_ptr to proc arena_allocate from ArenaUtils with arena, node_size, 8
    End If

    Otherwise:
        Set node_ptr to proc allocate from MemoryUtils with node_size
    End If

    If node_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize node
    Let dummy1 be proc memory_set_integer from MemoryCore with node_ptr, 0, element
    Let dummy2 be proc memory_set_integer from MemoryCore with node_ptr, 8, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with node_ptr, 16, 0

    Note: Insert at back
    Let tail be proc memory_get_integer from MemoryCore with list, 8

    If tail is equal to 0:
        Note: Empty list, node becomes both head and tail
        Let dummy4 be proc memory_set_integer from MemoryCore with list, 0, node_ptr
        Let dummy5 be proc memory_set_integer from MemoryCore with list, 8, node_ptr
    End If

    Otherwise:
        Note: Set old tail's next to new node
        Let dummy6 be proc memory_set_integer from MemoryCore with tail, 8, node_ptr
        Note: Set node's prev to old tail
        Let dummy7 be proc memory_set_integer from MemoryCore with node_ptr, 16, tail
        Note: Update list tail
        Let dummy8 be proc memory_set_integer from MemoryCore with list, 8, node_ptr
    End If

    Note: Increment size
    Let size be proc memory_get_integer from MemoryCore with list, 16
    Let new_size be size plus 1
    Let dummy9 be proc memory_set_integer from MemoryCore with list, 16, new_size

    Return 1
End Process

Process called "linkedlist_remove_front" takes list as Integer returns Integer:
    Note: Remove element from front of linked list
    Note: Returns 1 if successful, 0 if failed
    Note: Validates list is not empty

    If list is equal to 0:
        Return 0
    End If

    Let head be proc memory_get_integer from MemoryCore with list, 0

    If head is equal to 0:
        Return 0
    End If

    Note: Get next node
    Let next be proc memory_get_integer from MemoryCore with head, 8

    Note: Update list head
    Let dummy1 be proc memory_set_integer from MemoryCore with list, 0, next

    If next is equal to 0:
        Note: List is now empty, clear tail
        Let dummy2 be proc memory_set_integer from MemoryCore with list, 8, 0
    End If

    Otherwise:
        Note: Clear new head's prev pointer
        Let dummy3 be proc memory_set_integer from MemoryCore with next, 16, 0
    End If

    Note: Free old head if owned
    Let is_owned be proc memory_get_integer from MemoryCore with list, 32
    If is_owned is equal to 1:
        Let dummy4 be proc deallocate from MemoryUtils with head
    End If

    Note: Decrement size
    Let size be proc memory_get_integer from MemoryCore with list, 16
    Let new_size be size minus 1
    Let dummy5 be proc memory_set_integer from MemoryCore with list, 16, new_size

    Return 1
End Process

Process called "linkedlist_remove_back" takes list as Integer returns Integer:
    Note: Remove element from back of linked list
    Note: Returns 1 if successful, 0 if failed
    Note: Validates list is not empty

    If list is equal to 0:
        Return 0
    End If

    Let tail be proc memory_get_integer from MemoryCore with list, 8

    If tail is equal to 0:
        Return 0
    End If

    Note: Get prev node
    Let prev be proc memory_get_integer from MemoryCore with tail, 16

    Note: Update list tail
    Let dummy1 be proc memory_set_integer from MemoryCore with list, 8, prev

    If prev is equal to 0:
        Note: List is now empty, clear head
        Let dummy2 be proc memory_set_integer from MemoryCore with list, 0, 0
    End If

    Otherwise:
        Note: Clear new tail's next pointer
        Let dummy3 be proc memory_set_integer from MemoryCore with prev, 8, 0
    End If

    Note: Free old tail if owned
    Let is_owned be proc memory_get_integer from MemoryCore with list, 32
    If is_owned is equal to 1:
        Let dummy4 be proc deallocate from MemoryUtils with tail
    End If

    Note: Decrement size
    Let size be proc memory_get_integer from MemoryCore with list, 16
    Let new_size be size minus 1
    Let dummy5 be proc memory_set_integer from MemoryCore with list, 16, new_size

    Return 1
End Process

Process called "linkedlist_get_front" takes list as Integer returns Integer:
    Note: Get element from front of linked list
    Note: Returns pointer to element or 0 if not found
    Note: Validates list is not empty

    If list is equal to 0:
        Return 0
    End If

    Let head be proc memory_get_integer from MemoryCore with list, 0

    If head is equal to 0:
        Return 0
    End If

    Let element be proc memory_get_integer from MemoryCore with head, 0
    Return element
End Process

Process called "linkedlist_get_back" takes list as Integer returns Integer:
    Note: Get element from back of linked list
    Note: Returns pointer to element or 0 if not found
    Note: Validates list is not empty

    If list is equal to 0:
        Return 0
    End If

    Let tail be proc memory_get_integer from MemoryCore with list, 8

    If tail is equal to 0:
        Return 0
    End If

    Let element be proc memory_get_integer from MemoryCore with tail, 0
    Return element
End Process

Process called "linkedlist_size" takes list as Integer returns Integer:
    Note: Get size of linked list
    Note: Returns size of linked list

    If list is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with list, 16
    Return size
End Process

Process called "linkedlist_clear" takes list as Integer returns Integer:
    Note: Clear linked list
    Note: Returns 1 if successful, 0 if failed
    Note: Removes all elements but keeps structure

    If list is equal to 0:
        Return 0
    End If

    Let is_owned be proc memory_get_integer from MemoryCore with list, 32

    If is_owned is equal to 1:
        Note: Free all nodes
        Let current be proc memory_get_integer from MemoryCore with list, 0
        While current is not equal to 0:
            Let next be proc memory_get_integer from MemoryCore with current, 8
            Let dummy1 be proc deallocate from MemoryUtils with current
            Set current to next
        End While
    End If

    Note: Reset list pointers and size
    Let dummy2 be proc memory_set_integer from MemoryCore with list, 0, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with list, 8, 0
    Let dummy4 be proc memory_set_integer from MemoryCore with list, 16, 0

    Return 1
End Process

Note: ============================================================================
Note: HashTable Operations
Note: ============================================================================

Process called "hashtable_create" takes initial_capacity as Integer, arena as Integer returns Integer:
    Note: Create new hash table
    Note: Returns pointer to HashTable structure
    Note: Initializes hash table with default settings

    Let use_capacity be initial_capacity
    Let min_size be 16
    If use_capacity is less than min_size:
        Set use_capacity to min_size
    End If

    Let max_size be 1073741824
    If use_capacity is greater than max_size:
        Return 0
    End If

    Note: Use hash_utils to create the actual hashtable
    Let hash_func be 0
    Let table_ptr be proc hashtable_create from HashUtils with use_capacity, hash_func

    Return table_ptr
End Process

Process called "hashtable_destroy" takes table as Integer returns Nothing:
    Note: Destroy hash table and free associated memory
    Note: Frees all hash table data
    Note: Validates memory safety before destruction

    If table is equal to 0:
        Return
    End If

    Let dummy1 be proc hashtable_destroy from HashUtils with table
    Return
End Process

Process called "hashtable_put" takes table as Integer, key as Integer, value as Integer returns Integer:
    Note: Put key-value pair in hash table
    Note: Returns 1 if successful, 0 if failed
    Note: Handles hash table resizing if needed

    If table is equal to 0:
        Return 0
    End If

    Let result be proc hashtable_put from HashUtils with table, key, value
    Return result
End Process

Process called "hashtable_get" takes table as Integer, key as Integer returns Integer:
    Note: Get value for key from hash table
    Note: Returns pointer to value or 0 if not found
    Note: Validates key exists

    If table is equal to 0:
        Return 0
    End If

    Let value be proc hashtable_get from HashUtils with table, key
    Return value
End Process

Process called "hashtable_remove" takes table as Integer, key as Integer returns Integer:
    Note: Remove key-value pair from hash table
    Note: Returns 1 if successful, 0 if failed
    Note: Validates key exists

    If table is equal to 0:
        Return 0
    End If

    Let result be proc hashtable_remove from HashUtils with table, key
    Return result
End Process

Process called "hashtable_contains" takes table as Integer, key as Integer returns Integer:
    Note: Check if key exists in hash table
    Note: Returns 1 if exists, 0 if not exists

    If table is equal to 0:
        Return 0
    End If

    Let result be proc hashtable_contains from HashUtils with table, key
    Return result
End Process

Process called "hashtable_size" takes table as Integer returns Integer:
    Note: Get size of hash table
    Note: Returns size of hash table

    If table is equal to 0:
        Return 0
    End If

    Let size be proc hashtable_size from HashUtils with table
    Return size
End Process

Process called "hashtable_capacity" takes table as Integer returns Integer:
    Note: Get capacity of hash table
    Note: Returns capacity of hash table

    If table is equal to 0:
        Return 0
    End If

    Let capacity be proc hashtable_capacity from HashUtils with table
    Return capacity
End Process

Process called "hashtable_clear" takes table as Integer returns Integer:
    Note: Clear hash table
    Note: Returns 1 if successful, 0 if failed
    Note: Removes all key-value pairs but keeps structure

    If table is equal to 0:
        Return 0
    End If

    Let result be proc hashtable_clear from HashUtils with table
    Return result
End Process

Note: ============================================================================
Note: Stack Operations
Note: ============================================================================

Process called "stack_create" takes initial_capacity as Integer, arena as Integer returns Integer:
    Note: Create new stack
    Note: Returns pointer to Stack structure
    Note: Initializes stack with default settings

    Note: Stack is implemented as an arraylist with element_size of 8 (pointer size)
    Let element_size be 8
    Let stack_ptr be proc arraylist_create with initial_capacity, element_size, arena
    Return stack_ptr
End Process

Process called "stack_destroy" takes stack as Integer returns Nothing:
    Note: Destroy stack and free associated memory
    Note: Frees all stack data
    Note: Validates memory safety before destruction

    If stack is equal to 0:
        Return
    End If

    Let dummy1 be proc arraylist_destroy with stack
    Return
End Process

Process called "stack_push" takes stack as Integer, element as Integer returns Integer:
    Note: Push element onto stack
    Note: Returns 1 if successful, 0 if failed
    Note: Handles stack resizing if needed

    If stack is equal to 0:
        Return 0
    End If

    Note: Push is same as arraylist add
    Let result be proc arraylist_add with stack, element
    Return result
End Process

Process called "stack_pop" takes stack as Integer returns Integer:
    Note: Pop element from stack
    Note: Returns 1 if successful, 0 if failed
    Note: Validates stack is not empty

    If stack is equal to 0:
        Return 0
    End If

    Let size be proc arraylist_size with stack

    If size is equal to 0:
        Return 0
    End If

    Note: Remove last element
    Let last_index be size minus 1
    Let result be proc arraylist_remove with stack, last_index
    Return result
End Process

Process called "stack_peek" takes stack as Integer returns Integer:
    Note: Peek at top element of stack
    Note: Returns pointer to element or 0 if not found
    Note: Validates stack is not empty

    If stack is equal to 0:
        Return 0
    End If

    Let size be proc arraylist_size with stack

    If size is equal to 0:
        Return 0
    End If

    Note: Get last element
    Let last_index be size minus 1
    Let element be proc arraylist_get with stack, last_index
    Return element
End Process

Process called "stack_size" takes stack as Integer returns Integer:
    Note: Get size of stack
    Note: Returns size of stack

    If stack is equal to 0:
        Return 0
    End If

    Let size be proc arraylist_size with stack
    Return size
End Process

Process called "stack_capacity" takes stack as Integer returns Integer:
    Note: Get capacity of stack
    Note: Returns capacity of stack

    If stack is equal to 0:
        Return 0
    End If

    Let capacity be proc arraylist_capacity with stack
    Return capacity
End Process

Process called "stack_clear" takes stack as Integer returns Integer:
    Note: Clear stack
    Note: Returns 1 if successful, 0 if failed
    Note: Removes all elements but keeps structure

    If stack is equal to 0:
        Return 0
    End If

    Let result be proc arraylist_clear with stack
    Return result
End Process

Note: ============================================================================
Note: Queue Operations
Note: ============================================================================

Process called "queue_create" takes initial_capacity as Integer, arena as Integer returns Integer:
    Note: Create new queue
    Note: Returns pointer to Queue structure
    Note: Initializes queue with default settings

    Note: Queue is implemented as a linkedlist
    Let queue_ptr be proc linkedlist_create with arena
    Return queue_ptr
End Process

Process called "queue_destroy" takes queue as Integer returns Nothing:
    Note: Destroy queue and free associated memory
    Note: Frees all queue data
    Note: Validates memory safety before destruction

    If queue is equal to 0:
        Return
    End If

    Let dummy1 be proc linkedlist_destroy with queue
    Return
End Process

Process called "queue_enqueue" takes queue as Integer, element as Integer returns Integer:
    Note: Enqueue element in queue
    Note: Returns 1 if successful, 0 if failed
    Note: Handles queue resizing if needed

    If queue is equal to 0:
        Return 0
    End If

    Note: Enqueue adds to back
    Let result be proc linkedlist_add_back with queue, element
    Return result
End Process

Process called "queue_dequeue" takes queue as Integer returns Integer:
    Note: Dequeue element from queue
    Note: Returns 1 if successful, 0 if failed
    Note: Validates queue is not empty

    If queue is equal to 0:
        Return 0
    End If

    Note: Dequeue removes from front
    Let result be proc linkedlist_remove_front with queue
    Return result
End Process

Process called "queue_front" takes queue as Integer returns Integer:
    Note: Get front element of queue
    Note: Returns pointer to element or 0 if not found
    Note: Validates queue is not empty

    If queue is equal to 0:
        Return 0
    End If

    Let element be proc linkedlist_get_front with queue
    Return element
End Process

Process called "queue_back" takes queue as Integer returns Integer:
    Note: Get back element of queue
    Note: Returns pointer to element or 0 if not found
    Note: Validates queue is not empty

    If queue is equal to 0:
        Return 0
    End If

    Let element be proc linkedlist_get_back with queue
    Return element
End Process

Process called "queue_size" takes queue as Integer returns Integer:
    Note: Get size of queue
    Note: Returns size of queue

    If queue is equal to 0:
        Return 0
    End If

    Let size be proc linkedlist_size with queue
    Return size
End Process

Process called "queue_capacity" takes queue as Integer returns Integer:
    Note: Get capacity of queue
    Note: Returns capacity of queue

    If queue is equal to 0:
        Return 0
    End If

    Note: LinkedList has no fixed capacity
    Let size be proc linkedlist_size with queue
    Return size
End Process

Process called "queue_clear" takes queue as Integer returns Integer:
    Note: Clear queue
    Note: Returns 1 if successful, 0 if failed
    Note: Removes all elements but keeps structure

    If queue is equal to 0:
        Return 0
    End If

    Let result be proc linkedlist_clear with queue
    Return result
End Process

Note: ============================================================================
Note: Tree Operations
Note: ============================================================================

Process called "tree_create" takes comparator as Integer, arena as Integer returns Integer:
    Note: Create new tree
    Note: Returns pointer to Tree structure
    Note: Initializes tree with default settings

    Note: Allocate Tree structure (40 bytes)
    Let tree_size be 40
    Let tree_ptr be 0

    If arena is not equal to 0:
        Set tree_ptr to proc arena_allocate from ArenaUtils with arena, tree_size, 8
    End If

    Otherwise:
        Set tree_ptr to proc allocate from MemoryUtils with tree_size
    End If

    If tree_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize Tree structure
    Let dummy1 be proc memory_set_integer from MemoryCore with tree_ptr, 0, 0
    Let dummy2 be proc memory_set_integer from MemoryCore with tree_ptr, 8, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with tree_ptr, 16, comparator
    Let dummy4 be proc memory_set_integer from MemoryCore with tree_ptr, 24, arena

    Let is_owned be 0
    If arena is equal to 0:
        Set is_owned to 1
    End If

    Let dummy5 be proc memory_set_integer from MemoryCore with tree_ptr, 32, is_owned

    Return tree_ptr
End Process

Process called "tree_destroy" takes tree as Integer returns Nothing:
    Note: Destroy tree and free associated memory
    Note: Frees all tree data
    Note: Validates memory safety before destruction

    If tree is equal to 0:
        Return
    End If

    Note: Clear tree first to free all nodes
    Let dummy1 be proc tree_clear with tree

    Note: Free tree structure if owned
    Let is_owned be proc memory_get_integer from MemoryCore with tree, 32
    If is_owned is equal to 1:
        Let dummy2 be proc deallocate from MemoryUtils with tree
    End If

    Return
End Process

Process called "tree_insert" takes tree as Integer, element as Integer returns Integer:
    Note: Insert element in tree
    Note: Returns 1 if successful, 0 if failed
    Note: Handles tree balancing if needed

    If tree is equal to 0:
        Return 0
    End If

    If element is equal to 0:
        Return 0
    End If

    Note: Allocate tree node (32 bytes: element, left, right, parent)
    Let node_size be 32
    Let arena be proc memory_get_integer from MemoryCore with tree, 24
    Let node_ptr be 0

    If arena is not equal to 0:
        Set node_ptr to proc arena_allocate from ArenaUtils with arena, node_size, 8
    End If

    Otherwise:
        Set node_ptr to proc allocate from MemoryUtils with node_size
    End If

    If node_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize node
    Let dummy1 be proc memory_set_integer from MemoryCore with node_ptr, 0, element
    Let dummy2 be proc memory_set_integer from MemoryCore with node_ptr, 8, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with node_ptr, 16, 0
    Let dummy4 be proc memory_set_integer from MemoryCore with node_ptr, 24, 0

    Note: Get root
    Let root be proc memory_get_integer from MemoryCore with tree, 0

    If root is equal to 0:
        Note: Empty tree, node becomes root
        Let dummy5 be proc memory_set_integer from MemoryCore with tree, 0, node_ptr
    End If

    Otherwise:
        Note: Insert using simple comparison (element value as integer)
        Let current be root
        Let parent be 0

        Note: Find insertion point
        Let inserted be 0
        While inserted is equal to 0:
            Set parent to current
            Let current_element be proc memory_get_integer from MemoryCore with current, 0

            If element is less than current_element:
                Let left be proc memory_get_integer from MemoryCore with current, 8
                If left is equal to 0:
                    Let dummy6 be proc memory_set_integer from MemoryCore with current, 8, node_ptr
                    Let dummy7 be proc memory_set_integer from MemoryCore with node_ptr, 24, current
                    Set inserted to 1
                End If
                Otherwise:
                    Set current to left
                End If
            End If

            Otherwise:
                Let right be proc memory_get_integer from MemoryCore with current, 16
                If right is equal to 0:
                    Let dummy8 be proc memory_set_integer from MemoryCore with current, 16, node_ptr
                    Let dummy9 be proc memory_set_integer from MemoryCore with node_ptr, 24, current
                    Set inserted to 1
                End If
                Otherwise:
                    Set current to right
                End If
            End If
        End While
    End If

    Note: Increment size
    Let size be proc memory_get_integer from MemoryCore with tree, 8
    Let new_size be size plus 1
    Let dummy10 be proc memory_set_integer from MemoryCore with tree, 8, new_size

    Return 1
End Process

Process called "tree_remove" takes tree as Integer, element as Integer returns Integer:
    Note: Remove element from tree using proper BST deletion algorithm
    Note: Returns 1 if successful, 0 if element not found
    Note: Handles three cases: leaf node, one child, two children

    If tree is equal to 0:
        Return 0
    End If

    If element is equal to 0:
        Return 0
    End If

    Note: Find node with element
    Let node be proc tree_find with tree, element

    If node is equal to 0:
        Return 0
    End If

    Note: Get node's children and parent
    Let left be proc memory_get_integer from MemoryCore with node, 8
    Let right be proc memory_get_integer from MemoryCore with node, 16
    Let parent be proc memory_get_integer from MemoryCore with node, 24

    Note: CASE 1: Node is a leaf (no children)
    If left is equal to 0:
        If right is equal to 0:
            Note: Remove leaf node
            If parent is equal to 0:
                Note: Node is root
                Let dummy1 be proc memory_set_integer from MemoryCore with tree, 0, 0
            End If
            Otherwise:
                Note: Determine if node is left or right child of parent
                Let parent_left be proc memory_get_integer from MemoryCore with parent, 8
                If parent_left is equal to node:
                    Let dummy2 be proc memory_set_integer from MemoryCore with parent, 8, 0
                End If
                Otherwise:
                    Let dummy3 be proc memory_set_integer from MemoryCore with parent, 16, 0
                End If
            End If

            Note: Free node
            Let is_owned be proc memory_get_integer from MemoryCore with tree, 32
            If is_owned is equal to 1:
                Let dummy4 be proc deallocate from MemoryUtils with node
            End If

            Note: Decrement size
            Let size be proc memory_get_integer from MemoryCore with tree, 8
            Let new_size be size minus 1
            Let dummy5 be proc memory_set_integer from MemoryCore with tree, 8, new_size

            Return 1
        End If
    End If

    Note: CASE 2: Node has only right child
    If left is equal to 0:
        If right is not equal to 0:
            Note: Replace node with right child
            If parent is equal to 0:
                Note: Node is root
                Let dummy6 be proc memory_set_integer from MemoryCore with tree, 0, right
                Let dummy7 be proc memory_set_integer from MemoryCore with right, 24, 0
            End If
            Otherwise:
                Let parent_left be proc memory_get_integer from MemoryCore with parent, 8
                If parent_left is equal to node:
                    Let dummy8 be proc memory_set_integer from MemoryCore with parent, 8, right
                End If
                Otherwise:
                    Let dummy9 be proc memory_set_integer from MemoryCore with parent, 16, right
                End If
                Let dummy10 be proc memory_set_integer from MemoryCore with right, 24, parent
            End If

            Note: Free node
            Let is_owned be proc memory_get_integer from MemoryCore with tree, 32
            If is_owned is equal to 1:
                Let dummy11 be proc deallocate from MemoryUtils with node
            End If

            Note: Decrement size
            Let size be proc memory_get_integer from MemoryCore with tree, 8
            Let new_size be size minus 1
            Let dummy12 be proc memory_set_integer from MemoryCore with tree, 8, new_size

            Return 1
        End If
    End If

    Note: CASE 3: Node has only left child
    If right is equal to 0:
        If left is not equal to 0:
            Note: Replace node with left child
            If parent is equal to 0:
                Note: Node is root
                Let dummy13 be proc memory_set_integer from MemoryCore with tree, 0, left
                Let dummy14 be proc memory_set_integer from MemoryCore with left, 24, 0
            End If
            Otherwise:
                Let parent_left be proc memory_get_integer from MemoryCore with parent, 8
                If parent_left is equal to node:
                    Let dummy15 be proc memory_set_integer from MemoryCore with parent, 8, left
                End If
                Otherwise:
                    Let dummy16 be proc memory_set_integer from MemoryCore with parent, 16, left
                End If
                Let dummy17 be proc memory_set_integer from MemoryCore with left, 24, parent
            End If

            Note: Free node
            Let is_owned be proc memory_get_integer from MemoryCore with tree, 32
            If is_owned is equal to 1:
                Let dummy18 be proc deallocate from MemoryUtils with node
            End If

            Note: Decrement size
            Let size be proc memory_get_integer from MemoryCore with tree, 8
            Let new_size be size minus 1
            Let dummy19 be proc memory_set_integer from MemoryCore with tree, 8, new_size

            Return 1
        End If
    End If

    Note: CASE 4: Node has two children - find inorder successor
    If left is not equal to 0:
        If right is not equal to 0:
            Note: Find minimum in right subtree (inorder successor)
            Let successor be right
            While successor is not equal to 0:
                Let successor_left be proc memory_get_integer from MemoryCore with successor, 8
                If successor_left is equal to 0:
                    Let break be 1
                End If
                Otherwise:
                    Set successor to successor_left
                End If
            End While

            Note: Copy successor's element to node
            Let successor_element be proc memory_get_integer from MemoryCore with successor, 0
            Let dummy20 be proc memory_set_integer from MemoryCore with node, 0, successor_element

            Note: Remove successor (which has at most one child)
            Let successor_right be proc memory_get_integer from MemoryCore with successor, 16
            Let successor_parent be proc memory_get_integer from MemoryCore with successor, 24

            If successor_parent is equal to node:
                Note: Successor is direct right child
                Let dummy21 be proc memory_set_integer from MemoryCore with node, 16, successor_right
                If successor_right is not equal to 0:
                    Let dummy22 be proc memory_set_integer from MemoryCore with successor_right, 24, node
                End If
            End If
            Otherwise:
                Note: Successor is deeper in tree
                Let dummy23 be proc memory_set_integer from MemoryCore with successor_parent, 8, successor_right
                If successor_right is not equal to 0:
                    Let dummy24 be proc memory_set_integer from MemoryCore with successor_right, 24, successor_parent
                End If
            End If

            Note: Free successor
            Let is_owned be proc memory_get_integer from MemoryCore with tree, 32
            If is_owned is equal to 1:
                Let dummy25 be proc deallocate from MemoryUtils with successor
            End If

            Note: Decrement size
            Let size be proc memory_get_integer from MemoryCore with tree, 8
            Let new_size be size minus 1
            Let dummy26 be proc memory_set_integer from MemoryCore with tree, 8, new_size

            Return 1
        End If
    End If

    Return 0
End Process

Process called "tree_find" takes tree as Integer, element as Integer returns Integer:
    Note: Find element in tree
    Note: Returns pointer to element or 0 if not found
    Note: Uses tree search algorithm

    If tree is equal to 0:
        Return 0
    End If

    If element is equal to 0:
        Return 0
    End If

    Let root be proc memory_get_integer from MemoryCore with tree, 0

    If root is equal to 0:
        Return 0
    End If

    Note: Search tree
    Let current be root

    While current is not equal to 0:
        Let current_element be proc memory_get_integer from MemoryCore with current, 0

        If element is equal to current_element:
            Return current
        End If

        Otherwise If element is less than current_element:
            Let left be proc memory_get_integer from MemoryCore with current, 8
            Set current to left
        End If

        Otherwise:
            Let right be proc memory_get_integer from MemoryCore with current, 16
            Set current to right
        End If
    End While

    Return 0
End Process

Process called "tree_size" takes tree as Integer returns Integer:
    Note: Get size of tree
    Note: Returns size of tree

    If tree is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with tree, 8
    Return size
End Process

Process called "tree_clear" takes tree as Integer returns Integer:
    Note: Clear tree by recursively freeing all nodes
    Note: Returns 1 if successful, 0 if failed
    Note: Removes all elements but keeps tree structure

    If tree is equal to 0:
        Return 0
    End If

    Let root be proc memory_get_integer from MemoryCore with tree, 0

    If root is not equal to 0:
        Note: Recursively clear tree using post-order traversal
        Let result be proc tree_clear_recursive with tree, root
    End If

    Note: Reset root and size
    Let dummy1 be proc memory_set_integer from MemoryCore with tree, 0, 0
    Let dummy2 be proc memory_set_integer from MemoryCore with tree, 8, 0

    Return 1
End Process

Private Process called "tree_clear_recursive" takes tree as Integer, node as Integer returns Integer:
    Note: Recursively free tree nodes using post-order traversal
    Note: Frees left subtree, then right subtree, then node itself
    Note: Returns 1 on success

    If node is equal to 0:
        Return 1
    End If

    Note: Get left and right children
    Let left be proc memory_get_integer from MemoryCore with node, 8
    Let right be proc memory_get_integer from MemoryCore with node, 16

    Note: Clear left subtree
    If left is not equal to 0:
        Let result1 be proc tree_clear_recursive with tree, left
    End If

    Note: Clear right subtree
    If right is not equal to 0:
        Let result2 be proc tree_clear_recursive with tree, right
    End If

    Note: Free current node if owned
    Let is_owned be proc memory_get_integer from MemoryCore with tree, 32
    If is_owned is equal to 1:
        Let dummy1 be proc deallocate from MemoryUtils with node
    End If

    Return 1
End Process