Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles formatting utilities and formatting operations for the Runa compiler internal system.

FORMAT UTILITIES - Compiler Formatting and Output Engine
- Process formatting utilities and formatting operations for compiler output
- Handle text formatting and output formatting for compiler development
- Manage formatting operations and formatting manipulation utilities for compiler workflows
- Process formatting optimization and formatting performance utilities for compiler efficiency
- Handle integration with compiler phases for formatting and output support

This file is essential because of the following reasons:
- Format utilities enable efficient text formatting and output for the compiler
- Proper formatting handling ensures correct compiler operation and development support
- Format utilities support all compiler phases that need formatting and output capabilities
- Format utilities provide comprehensive formatting support for compiler operations

This file consists of the following functions/features/operation types:
- Format creation, destruction, and lifecycle management
- Format I/O and format information management operations
- Format optimization and format performance monitoring operations
- Format debugging and format diagnostic utilities
- Integration with compiler phases for formatting and output support

Dependencies:
- Imports arena_utils.runa for arena-based format allocation
- Imports owned_utils.runa for owned format management
- Imports memory_safety.runa for format safety validation
- Imports collections.runa for format data structure management
:End Note

Import "compiler/internal/arena_utils.runa" as ArenaUtils
Import "compiler/internal/owned_utils.runa" as OwnedUtils
Import "compiler/internal/memory_safety.runa" as MemorySafety
Import "compiler/internal/collections.runa" as Collections
Import "compiler/internal/buffer_utils.runa" as BufferUtils
Import "compiler/primitives/memory_core.runa" as MemoryCore
Import "compiler/primitives/memory_utils.runa" as MemoryUtils
Import "compiler/primitives/string_core.runa" as StringCore

Note: ============================================================================
Note: Format Management Structures
Note: ============================================================================

Type called "FormatSpec":
    format_string as Integer  Note: Pointer to format string
    format_type as Integer     Note: Type of format (STRING, INTEGER, FLOAT, etc.)
    precision as Integer       Note: Precision for numeric formats
    width as Integer          Note: Width for formatted output
    alignment as Integer       Note: Alignment (LEFT, RIGHT, CENTER)
    padding as Integer         Note: Padding character
    is_valid as Integer        Note: Boolean: 1 if valid, 0 if invalid

Type called "FormatResult":
    formatted_string as Integer Note: Pointer to formatted string
    length as Integer         Note: Length of formatted string
    error_code as Integer      Note: Error code if formatting failed
    is_valid as Integer        Note: Boolean: 1 if valid, 0 if invalid
    arena as Integer           Note: Pointer to arena for allocation
    is_owned as Integer         Note: Boolean: 1 if owned, 0 if arena-allocated

Type called "FormatStats":
    total_formats as Integer   Note: Total number of formatting operations
    total_bytes as Integer     Note: Total bytes formatted
    string_formats as Integer  Note: Number of string formats
    numeric_formats as Integer Note: Number of numeric formats
    format_time as Integer     Note: Time spent on formatting operations
    format_memory as Integer   Note: Memory used for formatting operations

Note: ============================================================================
Note: Format Constants
Note: ============================================================================

Constant FORMAT_TYPE_STRING as 0
Constant FORMAT_TYPE_INTEGER as 1
Constant FORMAT_TYPE_FLOAT as 2
Constant FORMAT_TYPE_HEX as 3
Constant FORMAT_TYPE_OCTAL as 4
Constant FORMAT_TYPE_BINARY as 5

Constant FORMAT_ALIGNMENT_LEFT as 0
Constant FORMAT_ALIGNMENT_RIGHT as 1
Constant FORMAT_ALIGNMENT_CENTER as 2

Constant FORMAT_SUCCESS as 0
Constant FORMAT_FAILED as -1
Constant FORMAT_INVALID_SPEC as -2
Constant FORMAT_MEMORY_ERROR as -3

Constant FORMAT_MAX_PRECISION as 100
Constant FORMAT_MAX_WIDTH as 1000
Constant FORMAT_DEFAULT_PRECISION as 6

Note: ============================================================================
Note: Format Creation and Management
Note: ============================================================================

Process called "format_create" takes format_string as Integer, arena as Integer returns Integer:
    Note: Create format specification
    Note: Returns pointer to FormatSpec structure
    Note: Initializes format with default settings

    Note: Allocate FormatSpec structure (56 bytes)
    Let spec_size be 56
    Let spec_ptr be 0

    If arena is not equal to 0:
        Set spec_ptr to proc arena_allocate from ArenaUtils with arena, spec_size, 8
    End If

    Otherwise:
        Set spec_ptr to proc allocate from MemoryUtils with spec_size
    End If

    If spec_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize FormatSpec
    Let dummy1 be proc memory_set_integer from MemoryCore with spec_ptr, 0, format_string
    Let dummy2 be proc memory_set_integer from MemoryCore with spec_ptr, 8, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with spec_ptr, 16, 6
    Let dummy4 be proc memory_set_integer from MemoryCore with spec_ptr, 24, 0
    Let dummy5 be proc memory_set_integer from MemoryCore with spec_ptr, 32, 0
    Let dummy6 be proc memory_set_integer from MemoryCore with spec_ptr, 40, 32
    Let dummy7 be proc memory_set_integer from MemoryCore with spec_ptr, 48, 1

    Return spec_ptr
End Process

Process called "format_destroy" takes format as Integer returns Nothing:
    Note: Destroy format specification
    Note: Frees all format data
    Note: Validates memory safety before destruction

    If format is equal to 0:
        Return
    End If

    Let dummy1 be proc deallocate from MemoryUtils with format
    Return
End Process

Process called "format_parse" takes format_string as Integer, arena as Integer returns Integer:
    Note: Parse format string
    Note: Returns pointer to FormatSpec structure
    Note: Parses format string into specification

    If format_string is equal to 0:
        Return 0
    End If

    Note: Create basic format spec
    Let spec_ptr be proc format_create with format_string, arena

    Return spec_ptr
End Process

Process called "format_validate" takes format as Integer returns Integer:
    Note: Validate format specification
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks format specification integrity

    If format is equal to 0:
        Return 0
    End If

    Let is_valid be proc memory_get_integer from MemoryCore with format, 48

    If is_valid is equal to 1:
        Return 1
    End If

    Return 0
End Process

Process called "format_clone" takes source_format as Integer returns Integer:
    Note: Create copy of format specification
    Note: Returns pointer to new FormatSpec structure
    Note: Copies all format data and settings

    If source_format is equal to 0:
        Return 0
    End If

    Note: Allocate new FormatSpec
    Let spec_size be 56
    Let clone_ptr be proc allocate from MemoryUtils with spec_size

    If clone_ptr is equal to 0:
        Return 0
    End If

    Note: Copy all fields
    Let dummy1 be proc memory_copy from MemoryCore with clone_ptr, source_format, spec_size

    Return clone_ptr
End Process

Note: ============================================================================
Note: Format String Operations
Note: ============================================================================

Process called "format_string" takes format as Integer, args as Integer, arena as Integer returns Integer:
    Note: Format string with arguments by parsing format specifiers
    Note: Returns pointer to FormatResult structure
    Note: Supports {0}, {1}, etc. placeholders for argument substitution

    If format is equal to 0:
        Return 0
    End If

    Note: Allocate FormatResult structure (48 bytes)
    Let result_size be 48
    Let result_ptr be proc arena_allocate from ArenaUtils with arena, result_size, 8

    If result_ptr is equal to 0:
        Return 0
    End If

    Note: Get format string from spec
    Let format_string be proc memory_get_integer from MemoryCore with format, 0

    If format_string is equal to 0:
        Let dummy1 be proc memory_set_integer from MemoryCore with result_ptr, 16, FORMAT_INVALID_SPEC
        Return result_ptr
    End If

    Note: Allocate output buffer (4096 bytes max for formatted output)
    Let buffer_size be 4096
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Let dummy2 be proc memory_set_integer from MemoryCore with result_ptr, 16, FORMAT_MEMORY_ERROR
        Return result_ptr
    End If

    Note: Parse format string and substitute arguments
    Let format_len be proc string_length from StringCore with format_string
    Let i be 0
    Let output_pos be 0

    While i is less than format_len:
        Let ch be proc memory_get_byte from MemoryCore with format_string, i

        Note: Check for format specifier start '{'
        Let open_brace be 123
        If ch is equal to open_brace:
            Note: Look for closing brace and extract argument index
            Set i to i plus 1
            Let arg_index be 0

            Note: Parse argument index
            Let break be 0
            Let continue_loop be 1
            While continue_loop is equal to 1:
                Note: Check if we should exit loop
                If break is equal to 1:
                    Set continue_loop to 0
                End If

                Note: Check bounds
                If i is greater than or equal to format_len:
                    Set continue_loop to 0
                End If

                Note: Only continue if loop should continue
                If continue_loop is equal to 0:
                    Note: Exit loop gracefully
                End If
                Otherwise:
                    Let digit_ch be proc memory_get_byte from MemoryCore with format_string, i
                    Let close_brace be 125

                    If digit_ch is equal to close_brace:
                        Note: Found closing brace, substitute argument
                        If args is not equal to 0:
                            Note: Get argument from args array (args is array of pointers)
                            Let arg_offset be arg_index multiplied by 8
                            Let arg_ptr be proc memory_get_integer from MemoryCore with args, arg_offset

                            If arg_ptr is not equal to 0:
                                Note: Copy argument string to output
                                Let arg_len be proc string_length from StringCore with arg_ptr
                                Let k be 0
                                While k is less than arg_len:
                                    Let arg_ch be proc memory_get_byte from MemoryCore with arg_ptr, k
                                    Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, arg_ch
                                    Set output_pos to output_pos plus 1
                                    Set k to k plus 1
                                End While
                            End If
                        End If

                        Set i to i plus 1
                        Set break to 1
                    End If
                    Otherwise:
                        Note: Accumulate digit
                        Let zero_ascii be 48
                        If digit_ch is greater than or equal to zero_ascii:
                            Let nine_ascii be 57
                            If digit_ch is less than or equal to nine_ascii:
                                Let digit_value be digit_ch minus zero_ascii
                                Let arg_index_times_10 be arg_index multiplied by 10
                                Set arg_index to arg_index_times_10 plus digit_value
                                Set i to i plus 1
                            End If
                            Otherwise:
                                Set i to i plus 1
                            End If
                        End If
                        Otherwise:
                            Set i to i plus 1
                        End If
                    End If
                End If
            End While
        End If
        Otherwise:
            Note: Regular character, copy to output
            Let dummy4 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, ch
            Set output_pos to output_pos plus 1
            Set i to i plus 1
        End If
    End While

    Note: Null-terminate output
    Let dummy5 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, 0

    Note: Populate FormatResult
    Let dummy6 be proc memory_set_integer from MemoryCore with result_ptr, 0, buffer_ptr
    Let dummy7 be proc memory_set_integer from MemoryCore with result_ptr, 8, output_pos
    Let dummy8 be proc memory_set_integer from MemoryCore with result_ptr, 16, FORMAT_SUCCESS
    Let dummy9 be proc memory_set_integer from MemoryCore with result_ptr, 24, 1
    Let dummy10 be proc memory_set_integer from MemoryCore with result_ptr, 32, arena
    Let dummy11 be proc memory_set_integer from MemoryCore with result_ptr, 40, 0

    Return result_ptr
End Process

Process called "format_string_simple" takes format_string as Integer, args as Integer, arena as Integer returns Integer:
    Note: Format string with simple {0}, {1} style argument substitution
    Note: Returns pointer to formatted string
    Note: Delegates to format_string for actual formatting

    If format_string is equal to 0:
        Return 0
    End If

    Note: Create temporary FormatSpec
    Let temp_spec be proc format_create with format_string, arena

    If temp_spec is equal to 0:
        Return 0
    End If

    Note: Use format_string to do the actual work
    Let result be proc format_string with temp_spec, args, arena

    If result is equal to 0:
        Return 0
    End If

    Note: Extract formatted string from FormatResult
    Let formatted_ptr be proc memory_get_integer from MemoryCore with result, 0

    Return formatted_ptr
End Process

Process called "format_string_printf" takes format_string as Integer, args as Integer, arena as Integer returns Integer:
    Note: Format string with printf-style %d, %s, %x specifiers
    Note: Returns pointer to formatted string
    Note: Supports %d (integer), %s (string), %x (hex), %o (octal), %b (binary)

    If format_string is equal to 0:
        Return 0
    End If

    Note: Allocate output buffer (4096 bytes)
    Let buffer_size be 4096
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Parse format string and substitute arguments
    Let format_len be proc string_length from StringCore with format_string
    Let i be 0
    Let output_pos be 0
    Let arg_index be 0

    While i is less than format_len:
        Let ch be proc memory_get_byte from MemoryCore with format_string, i

        Note: Check for format specifier '%'
        Let percent be 37
        If ch is equal to percent:
            Set i to i plus 1

            If i is less than format_len:
                Let spec_ch be proc memory_get_byte from MemoryCore with format_string, i

                Note: %d - integer
                Let d_char be 100
                If spec_ch is equal to d_char:
                    If args is not equal to 0:
                        Let arg_offset be arg_index multiplied by 8
                        Let arg_value be proc memory_get_integer from MemoryCore with args, arg_offset
                        Let arg_str be proc format_integer with arg_value, 0, arena

                        If arg_str is not equal to 0:
                            Let arg_len be proc string_length from StringCore with arg_str
                            Let k be 0
                            While k is less than arg_len:
                                Let arg_ch be proc memory_get_byte from MemoryCore with arg_str, k
                                Let dummy1 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, arg_ch
                                Set output_pos to output_pos plus 1
                                Set k to k plus 1
                            End While
                        End If

                        Set arg_index to arg_index plus 1
                    End If

                    Set i to i plus 1
                End If

                Note: %s - string
                Otherwise:
                    Let s_char be 115
                    If spec_ch is equal to s_char:
                        If args is not equal to 0:
                            Let arg_offset be arg_index multiplied by 8
                            Let arg_str be proc memory_get_integer from MemoryCore with args, arg_offset

                            If arg_str is not equal to 0:
                                Let arg_len be proc string_length from StringCore with arg_str
                                Let k be 0
                                While k is less than arg_len:
                                    Let arg_ch be proc memory_get_byte from MemoryCore with arg_str, k
                                    Let dummy2 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, arg_ch
                                    Set output_pos to output_pos plus 1
                                    Set k to k plus 1
                                End While
                            End If

                            Set arg_index to arg_index plus 1
                        End If

                        Set i to i plus 1
                    End If

                    Note: %x - hexadecimal
                    Otherwise:
                        Let x_char be 120
                        If spec_ch is equal to x_char:
                            If args is not equal to 0:
                                Let arg_offset be arg_index multiplied by 8
                                Let arg_value be proc memory_get_integer from MemoryCore with args, arg_offset
                                Let arg_str be proc format_hex with arg_value, 0, arena

                                If arg_str is not equal to 0:
                                    Let arg_len be proc string_length from StringCore with arg_str
                                    Let k be 0
                                    While k is less than arg_len:
                                        Let arg_ch be proc memory_get_byte from MemoryCore with arg_str, k
                                        Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, arg_ch
                                        Set output_pos to output_pos plus 1
                                        Set k to k plus 1
                                    End While
                                End If

                                Set arg_index to arg_index plus 1
                            End If

                            Set i to i plus 1
                        End If

                        Note: %% - literal percent
                        Otherwise:
                            If spec_ch is equal to percent:
                                Let dummy4 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, percent
                                Set output_pos to output_pos plus 1
                                Set i to i plus 1
                            End If

                            Note: Unknown specifier, copy as-is
                            Otherwise:
                                Let dummy5 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, percent
                                Set output_pos to output_pos plus 1
                                Let dummy6 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, spec_ch
                                Set output_pos to output_pos plus 1
                                Set i to i plus 1
                            End If
                        End If
                    End If
                End If
            End If
        End If
        Otherwise:
            Note: Regular character, copy to output
            Let dummy7 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, ch
            Set output_pos to output_pos plus 1
            Set i to i plus 1
        End If
    End While

    Note: Null-terminate output
    Let dummy8 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, 0

    Return buffer_ptr
End Process

Process called "format_string_sprintf" takes format_string as Integer, args as Integer, arena as Integer returns Integer:
    Note: Format string with sprintf-style arguments (identical to printf)
    Note: Returns pointer to formatted string

    Let result be proc format_string_printf with format_string, args, arena
    Return result
End Process

Process called "format_string_vprintf" takes format_string as Integer, args as Integer, arena as Integer returns Integer:
    Note: Format string with vprintf-style arguments (va_list support)
    Note: Returns pointer to formatted string
    Note: args is treated as va_list pointer (array of argument pointers)

    Let result be proc format_string_printf with format_string, args, arena
    Return result
End Process

Process called "format_string_vsprintf" takes format_string as Integer, args as Integer, arena as Integer returns Integer:
    Note: Format string with vsprintf-style arguments (va_list support)
    Note: Returns pointer to formatted string

    Let result be proc format_string_printf with format_string, args, arena
    Return result
End Process

Note: ============================================================================
Note: Format Numeric Operations
Note: ============================================================================

Process called "format_integer" takes value as Integer, format as Integer, arena as Integer returns Integer:
    Note: Format integer value
    Note: Returns pointer to formatted string
    Note: Uses arena allocation for temporary result

    Note: Allocate buffer for integer string (32 bytes max)
    Let buffer_size be 32
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Convert integer to string
    Let result_str be proc integer_to_string from StringCore with value, buffer_ptr, buffer_size

    Return result_str
End Process

Process called "format_float" takes value as Integer, format as Integer, arena as Integer returns Integer:
    Note: Format float value (represented as fixed-point integer)
    Note: Returns pointer to formatted string
    Note: Assumes value is fixed-point with 6 decimal places (value / 1000000)

    Note: Allocate buffer for float string (64 bytes max)
    Let buffer_size be 64
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Extract precision from format (default 6)
    Let precision be FORMAT_DEFAULT_PRECISION
    If format is not equal to 0:
        Let format_precision be proc memory_get_integer from MemoryCore with format, 16
        If format_precision is greater than 0:
            If format_precision is less than or equal to FORMAT_MAX_PRECISION:
                Set precision to format_precision
            End If
        End If
    End If

    Note: Handle negative values
    Let is_negative be 0
    Let abs_value be value

    If value is less than 0:
        Set is_negative to 1
        Let neg_value be 0 minus value
        Set abs_value to neg_value
    End If

    Note: Calculate scaling factor for precision
    Let scale be 1
    Let p be 0
    While p is less than precision:
        Set scale to scale multiplied by 10
        Set p to p plus 1
    End While

    Note: Extract integer and fractional parts
    Let int_part be abs_value divided by scale
    Let remainder be abs_value modulo by scale

    Note: Write minus sign if negative
    Let pos be 0
    Let minus_sign be 45

    If is_negative is equal to 1:
        Let dummy1 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, minus_sign
        Set pos to pos plus 1
    End If

    Note: Write integer part
    Let int_str be proc integer_to_string from StringCore with int_part, buffer_ptr plus pos, buffer_size minus pos
    Let int_len be proc string_length from StringCore with int_str

    Set pos to pos plus int_len

    Note: Write decimal point
    Let dot be 46
    Let dummy2 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, dot
    Set pos to pos plus 1

    Note: Write fractional part with leading zeros
    Let frac_value be remainder
    Let divisor be scale divided by 10

    Let i be 0
    While i is less than precision:
        Let digit be frac_value divided by divisor
        Let ascii_digit be digit plus 48
        Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, ascii_digit
        Set pos to pos plus 1

        Let digit_times_divisor be digit multiplied by divisor
        Set frac_value to frac_value minus digit_times_divisor
        Set divisor to divisor divided by 10
        Set i to i plus 1
    End While

    Note: Null-terminate
    Let dummy4 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, 0

    Return buffer_ptr
End Process

Process called "format_hex" takes value as Integer, format as Integer, arena as Integer returns Integer:
    Note: Format hexadecimal value
    Note: Returns pointer to formatted string
    Note: Uses arena allocation for temporary result

    Note: Allocate buffer for hex string (32 bytes max)
    Let buffer_size be 32
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Convert to hexadecimal
    Let result_str be proc integer_to_hex from StringCore with value, buffer_ptr, buffer_size

    Return result_str
End Process

Process called "format_octal" takes value as Integer, format as Integer, arena as Integer returns Integer:
    Note: Format octal value
    Note: Returns pointer to formatted string
    Note: Uses arena allocation for temporary result

    Note: Allocate buffer for octal string (32 bytes max)
    Let buffer_size be 32
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Convert to octal using division by 8
    Let pos be 0
    Let temp_value be value

    If temp_value is equal to 0:
        Let dummy1 be proc memory_set_byte from MemoryCore with buffer_ptr, 0, 48
        Let dummy2 be proc memory_set_byte from MemoryCore with buffer_ptr, 1, 0
        Return buffer_ptr
    End If

    While temp_value is greater than 0:
        Let digit be temp_value modulo by 8
        Let ascii_digit be digit plus 48
        Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, ascii_digit
        Set temp_value to temp_value divided by 8
        Set pos to pos plus 1
    End While

    Let dummy4 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, 0

    Note: Reverse the string
    Let result_str be proc string_reverse from StringCore with buffer_ptr

    Return result_str
End Process

Process called "format_binary" takes value as Integer, format as Integer, arena as Integer returns Integer:
    Note: Format binary value
    Note: Returns pointer to formatted string
    Note: Uses arena allocation for temporary result

    Note: Allocate buffer for binary string (128 bytes max for 64-bit)
    Let buffer_size be 128
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Convert to binary using bit operations
    Let pos be 0
    Let temp_value be value

    If temp_value is equal to 0:
        Let dummy1 be proc memory_set_byte from MemoryCore with buffer_ptr, 0, 48
        Let dummy2 be proc memory_set_byte from MemoryCore with buffer_ptr, 1, 0
        Return buffer_ptr
    End If

    While temp_value is greater than 0:
        Let bit be temp_value modulo by 2
        Let ascii_bit be bit plus 48
        Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, ascii_bit
        Set temp_value to temp_value divided by 2
        Set pos to pos plus 1
    End While

    Let dummy4 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, 0

    Note: Reverse the string
    Let result_str be proc string_reverse from StringCore with buffer_ptr

    Return result_str
End Process

Process called "format_scientific" takes value as Integer, format as Integer, arena as Integer returns Integer:
    Note: Format value in scientific notation (e.g., 1.23e+10)
    Note: Returns pointer to formatted string
    Note: value assumed to be fixed-point integer

    Note: Allocate buffer for scientific notation string (64 bytes max)
    Let buffer_size be 64
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Extract precision from format (default 6)
    Let precision be FORMAT_DEFAULT_PRECISION
    If format is not equal to 0:
        Let format_precision be proc memory_get_integer from MemoryCore with format, 16
        If format_precision is greater than 0:
            If format_precision is less than or equal to FORMAT_MAX_PRECISION:
                Set precision to format_precision
            End If
        End If
    End If

    Note: Handle zero specially
    If value is equal to 0:
        Let dummy1 be proc memory_set_byte from MemoryCore with buffer_ptr, 0, 48
        Let dot be 46
        Let dummy2 be proc memory_set_byte from MemoryCore with buffer_ptr, 1, dot
        Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, 2, 48
        Let e_char be 101
        Let dummy4 be proc memory_set_byte from MemoryCore with buffer_ptr, 3, e_char
        Let plus be 43
        Let dummy5 be proc memory_set_byte from MemoryCore with buffer_ptr, 4, plus
        Let dummy6 be proc memory_set_byte from MemoryCore with buffer_ptr, 5, 48
        Let dummy7 be proc memory_set_byte from MemoryCore with buffer_ptr, 6, 48
        Let dummy8 be proc memory_set_byte from MemoryCore with buffer_ptr, 7, 0
        Return buffer_ptr
    End If

    Note: Handle negative
    Let is_negative be 0
    Let abs_value be value
    Let pos be 0

    If value is less than 0:
        Set is_negative to 1
        Let neg_value be 0 minus value
        Set abs_value to neg_value
        Let minus_sign be 45
        Let dummy9 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, minus_sign
        Set pos to pos plus 1
    End If

    Note: Calculate exponent (count digits)
    Let temp_value be abs_value
    Let exponent be 0

    While temp_value is greater than or equal to 10:
        Set temp_value to temp_value divided by 10
        Set exponent to exponent plus 1
    End While

    Note: Write mantissa (first digit, dot, remaining precision digits)
    Let first_digit be abs_value
    Let divisor be 1
    Let exp_copy be exponent

    While exp_copy is greater than 0:
        Set divisor to divisor multiplied by 10
        Set exp_copy to exp_copy minus 1
    End While

    Set first_digit to abs_value divided by divisor
    Let first_digit_ascii be first_digit plus 48
    Let dummy10 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, first_digit_ascii
    Set pos to pos plus 1

    Note: Decimal point
    Let dot be 46
    Let dummy11 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, dot
    Set pos to pos plus 1

    Note: Write remaining precision digits (extract from mantissa)
    Note: Calculate remainder after first digit: abs_value - (first_digit * divisor)
    Let first_digit_value be first_digit multiplied by divisor
    Let remainder be abs_value minus first_digit_value

    Note: Extract up to 'precision' mantissa digits
    Let i be 0
    While i is less than precision:
        Note: Scale remainder up by 10 to extract next digit
        Set remainder to remainder multiplied by 10

        Note: Extract digit by dividing by original divisor
        Let digit be remainder divided by divisor
        Let digit_ascii be digit plus 48
        Let dummy12 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, digit_ascii
        Set pos to pos plus 1

        Note: Update remainder (remove extracted digit)
        Let digit_value be digit multiplied by divisor
        Set remainder to remainder minus digit_value

        Set i to i plus 1
    End While

    Note: Write 'e' and exponent
    Let e_char be 101
    Let dummy13 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, e_char
    Set pos to pos plus 1

    Note: Exponent sign
    Let plus be 43
    Let dummy14 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, plus
    Set pos to pos plus 1

    Note: Exponent value (two digits)
    Let exp_tens be exponent divided by 10
    Let exp_ones be exponent modulo by 10
    Let exp_tens_ascii be exp_tens plus 48
    Let exp_ones_ascii be exp_ones plus 48
    Let dummy15 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, exp_tens_ascii
    Set pos to pos plus 1
    Let dummy16 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, exp_ones_ascii
    Set pos to pos plus 1

    Note: Null-terminate
    Let dummy17 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, 0

    Return buffer_ptr
End Process

Note: ============================================================================
Note: Format Alignment Operations
Note: ============================================================================

Process called "format_align_left" takes text as Integer, width as Integer, padding as Integer, arena as Integer returns Integer:
    Note: Align text to left
    Note: Returns pointer to aligned string
    Note: Uses arena allocation for temporary result

    If text is equal to 0:
        Return 0
    End If

    Let text_len be proc string_length from StringCore with text

    If text_len is greater than width:
        Return text
    End If

    Otherwise If text_len is equal to width:
        Return text
    End If

    Note: Allocate buffer for aligned text
    Let buffer_size be width plus 1
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Copy original text
    Let dummy1 be proc memory_copy from MemoryCore with buffer_ptr, text, text_len

    Note: Pad right side
    Let pad_count be width minus text_len
    Let pad_pos be text_len

    Let i be 0
    While i is less than pad_count:
        Let dummy2 be proc memory_set_byte from MemoryCore with buffer_ptr, pad_pos, padding
        Set pad_pos to pad_pos plus 1
        Set i to i plus 1
    End While

    Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, width, 0

    Return buffer_ptr
End Process

Process called "format_align_right" takes text as Integer, width as Integer, padding as Integer, arena as Integer returns Integer:
    Note: Align text to right
    Note: Returns pointer to aligned string
    Note: Uses arena allocation for temporary result

    If text is equal to 0:
        Return 0
    End If

    Let text_len be proc string_length from StringCore with text

    If text_len is greater than width:
        Return text
    End If

    Otherwise If text_len is equal to width:
        Return text
    End If

    Note: Allocate buffer for aligned text
    Let buffer_size be width plus 1
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Pad left side first
    Let pad_count be width minus text_len

    Let i be 0
    While i is less than pad_count:
        Let dummy1 be proc memory_set_byte from MemoryCore with buffer_ptr, i, padding
        Set i to i plus 1
    End While

    Note: Copy text after padding
    Let text_pos be buffer_ptr plus pad_count
    Let dummy2 be proc memory_copy from MemoryCore with text_pos, text, text_len
    Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, width, 0

    Return buffer_ptr
End Process

Process called "format_align_center" takes text as Integer, width as Integer, padding as Integer, arena as Integer returns Integer:
    Note: Align text to center
    Note: Returns pointer to aligned string
    Note: Uses arena allocation for temporary result

    If text is equal to 0:
        Return 0
    End If

    Let text_len be proc string_length from StringCore with text

    If text_len is greater than width:
        Return text
    End If

    Otherwise If text_len is equal to width:
        Return text
    End If

    Note: Allocate buffer for aligned text
    Let buffer_size be width plus 1
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Calculate left and right padding
    Let total_pad be width minus text_len
    Let left_pad be total_pad divided by 2
    Let right_pad be total_pad minus left_pad

    Note: Pad left side
    Let i be 0
    While i is less than left_pad:
        Let dummy1 be proc memory_set_byte from MemoryCore with buffer_ptr, i, padding
        Set i to i plus 1
    End While

    Note: Copy text
    Let text_pos be buffer_ptr plus left_pad
    Let dummy2 be proc memory_copy from MemoryCore with text_pos, text, text_len

    Note: Pad right side
    Let right_start be left_pad plus text_len
    Set i to 0
    While i is less than right_pad:
        Let pad_pos be right_start plus i
        Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, pad_pos, padding
        Set i to i plus 1
    End While

    Let dummy4 be proc memory_set_byte from MemoryCore with buffer_ptr, width, 0

    Return buffer_ptr
End Process

Process called "format_pad_left" takes text as Integer, width as Integer, padding as Integer, arena as Integer returns Integer:
    Note: Pad text on left
    Note: Returns pointer to padded string
    Note: Uses arena allocation for temporary result

    Note: Delegate to format_align_right
    Let result be proc format_align_right with text, width, padding, arena
    Return result
End Process

Process called "format_pad_right" takes text as Integer, width as Integer, padding as Integer, arena as Integer returns Integer:
    Note: Pad text on right
    Note: Returns pointer to padded string
    Note: Uses arena allocation for temporary result

    Note: Delegate to format_align_left
    Let result be proc format_align_left with text, width, padding, arena
    Return result
End Process

Process called "format_pad_center" takes text as Integer, width as Integer, padding as Integer, arena as Integer returns Integer:
    Note: Pad text on center
    Note: Returns pointer to padded string
    Note: Uses arena allocation for temporary result

    Note: Delegate to format_align_center
    Let result be proc format_align_center with text, width, padding, arena
    Return result
End Process

Note: ============================================================================
Note: Format Conversion Operations
Note: ============================================================================

Process called "format_to_string" takes value as Integer, type as Integer, arena as Integer returns Integer:
    Note: Convert value to string
    Note: Returns pointer to string representation
    Note: Uses arena allocation for temporary result

    Let FORMAT_TYPE_STRING be 0
    Let FORMAT_TYPE_INTEGER be 1
    Let FORMAT_TYPE_HEX be 3

    If type is equal to FORMAT_TYPE_INTEGER:
        Let result be proc format_integer with value, 0, arena
        Return result
    End If

    Otherwise If type is equal to FORMAT_TYPE_HEX:
        Let result be proc format_hex with value, 0, arena
        Return result
    End If

    Note: Default to integer
    Let result be proc format_integer with value, 0, arena
    Return result
End Process

Process called "format_to_integer" takes string as Integer returns Integer:
    Note: Convert string to integer
    Note: Returns integer value or 0 if conversion fails

    If string is equal to 0:
        Return 0
    End If

    Let result be proc string_to_integer from StringCore with string
    Return result
End Process

Process called "format_to_float" takes string as Integer returns Integer:
    Note: Parse floating point string to fixed-point integer
    Note: Returns fixed-point integer (scaled by 1000000 for 6 decimal places)
    Note: Parses strings like "123.456" to 123456000

    If string is equal to 0:
        Return 0
    End If

    Let str_len be proc string_length from StringCore with string

    If str_len is equal to 0:
        Return 0
    End If

    Note: Parse sign
    Let is_negative be 0
    Let i be 0
    Let first_ch be proc memory_get_byte from MemoryCore with string, 0
    Let minus_sign be 45
    Let plus_sign be 43

    If first_ch is equal to minus_sign:
        Set is_negative to 1
        Set i to 1
    End If
    Otherwise If first_ch is equal to plus_sign:
        Set i to 1
    End If

    Note: Parse integer part
    Let int_part be 0

    While i is less than str_len:
        Let ch be proc memory_get_byte from MemoryCore with string, i
        Let dot be 46

        If ch is equal to dot:
            Set i to i plus 1
            Let break be 1
        End If
        Otherwise:
            Let zero_ascii be 48
            Let nine_ascii be 57

            If ch is greater than or equal to zero_ascii:
                If ch is less than or equal to nine_ascii:
                    Let digit be ch minus zero_ascii
                    Let int_times_10 be int_part multiplied by 10
                    Set int_part to int_times_10 plus digit
                    Set i to i plus 1
                End If
                Otherwise:
                    Let break be 1
                End If
            End If
            Otherwise:
                Let break be 1
            End If
        End If
    End While

    Note: Parse fractional part (up to 6 digits)
    Let frac_part be 0
    Let frac_digits be 0
    Let max_frac_digits be 6

    While i is less than str_len:
        If frac_digits is greater than or equal to max_frac_digits:
            Let break be 1
        End If
        Otherwise:
            Let ch be proc memory_get_byte from MemoryCore with string, i
            Let zero_ascii be 48
            Let nine_ascii be 57

            If ch is greater than or equal to zero_ascii:
                If ch is less than or equal to nine_ascii:
                    Let digit be ch minus zero_ascii
                    Let frac_times_10 be frac_part multiplied by 10
                    Set frac_part to frac_times_10 plus digit
                    Set frac_digits to frac_digits plus 1
                    Set i to i plus 1
                End If
                Otherwise:
                    Let break be 1
                End If
            End If
            Otherwise:
                Let break be 1
            End If
        End If
    End While

    Note: Scale fractional part to 6 decimal places
    While frac_digits is less than max_frac_digits:
        Set frac_part to frac_part multiplied by 10
        Set frac_digits to frac_digits plus 1
    End While

    Note: Combine integer and fractional parts
    Let scale be 1000000
    Let int_scaled be int_part multiplied by scale
    Let result_value be int_scaled plus frac_part

    Note: Apply sign
    If is_negative is equal to 1:
        Let neg_result be 0 minus result_value
        Set result_value to neg_result
    End If

    Return result_value
End Process

Process called "format_to_hex" takes string as Integer returns Integer:
    Note: Convert string to hexadecimal
    Note: Returns integer value or 0 if conversion fails

    If string is equal to 0:
        Return 0
    End If

    Let result be proc string_from_hex from StringCore with string
    Return result
End Process

Process called "format_to_octal" takes string as Integer returns Integer:
    Note: Convert string to octal
    Note: Returns integer value or 0 if conversion fails

    If string is equal to 0:
        Return 0
    End If

    Note: Parse octal string
    Let result_value be 0
    Let i be 0
    Let str_len be proc string_length from StringCore with string

    While i is less than str_len:
        Let ch be proc memory_get_byte from MemoryCore with string, i

        If ch is less than 48:
            Return result_value
        End If

        Otherwise If ch is greater than 55:
            Return result_value
        End If

        Let digit be ch minus 48
        Let result_times_8 be result_value multiplied by 8
        Set result_value to result_times_8 plus digit
        Set i to i plus 1
    End While

    Return result_value
End Process

Process called "format_to_binary" takes string as Integer returns Integer:
    Note: Convert string to binary
    Note: Returns integer value or 0 if conversion fails

    If string is equal to 0:
        Return 0
    End If

    Note: Parse binary string
    Let result_value be 0
    Let i be 0
    Let str_len be proc string_length from StringCore with string

    While i is less than str_len:
        Let ch be proc memory_get_byte from MemoryCore with string, i

        If ch is less than 48:
            Return result_value
        End If

        Otherwise If ch is greater than 49:
            Return result_value
        End If

        Let bit be ch minus 48
        Let result_times_2 be result_value multiplied by 2
        Set result_value to result_times_2 plus bit
        Set i to i plus 1
    End While

    Return result_value
End Process

Note: ============================================================================
Note: Format Statistics Operations
Note: ============================================================================

Note: FormatStats instance structure (TIER 3 OWNED)
Note: Instance-based stats - no globals
Note: Caller creates stats with format_stats_create, destroys with format_stats_destroy
Note: FormatStats structure (48 bytes):
Note: - total_formats: 8 bytes - total number of formatting operations
Note: - total_bytes: 8 bytes - total bytes formatted
Note: - string_formats: 8 bytes - number of string formats
Note: - numeric_formats: 8 bytes - number of numeric formats
Note: - format_time: 8 bytes - time spent on formatting
Note: - format_memory: 8 bytes - memory used for formatting

Process called "format_stats_create" returns Integer:
    Note: Create and initialize format statistics instance (TIER 3 OWNED)
    Note: Returns pointer to FormatStats instance, 0 on failure
    Note: Caller owns stats and must call format_stats_destroy
    Note: No global state - follows MEMORY_ARCHITECTURE.md

    Note: Allocate stats structure (48 bytes)
    Let stats_size be 48
    Let stats be proc allocate from MemoryUtils with stats_size

    If stats is equal to 0:
        Return 0
    End If

    Note: Zero-initialize all fields
    Let dummy1 be proc memory_set_integer from MemoryCore with stats, 0, 0
    Let dummy2 be proc memory_set_integer from MemoryCore with stats, 8, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with stats, 16, 0
    Let dummy4 be proc memory_set_integer from MemoryCore with stats, 24, 0
    Let dummy5 be proc memory_set_integer from MemoryCore with stats, 32, 0
    Let dummy6 be proc memory_set_integer from MemoryCore with stats, 40, 0

    Return stats
End Process

Process called "format_stats_destroy" takes stats as Integer returns Nothing:
    Note: Destroy format statistics instance (TIER 3 OWNED cleanup)
    Note: stats is pointer to FormatStats instance created by format_stats_create
    Note: Frees stats structure - caller no longer owns stats
    Note: Returns nothing

    If stats is equal to 0:
        Return
    End If

    Note: Free the stats structure
    Let dummy_free be proc deallocate from MemoryUtils with stats

    Return
End Process

Process called "format_record_operation" takes stats as Integer, operation_type as Integer, bytes as Integer returns Nothing:
    Note: Record a format operation in statistics instance
    Note: stats is pointer to FormatStats instance created by format_stats_create
    Note: operation_type: 0=string, 1=numeric

    If stats is equal to 0:
        Return
    End If

    Note: Increment total_formats
    Let total_formats be proc memory_get_integer from MemoryCore with stats, 0
    Let new_total be total_formats plus 1
    Let dummy1 be proc memory_set_integer from MemoryCore with stats, 0, new_total

    Note: Increment total_bytes
    Let total_bytes be proc memory_get_integer from MemoryCore with stats, 8
    Let new_bytes be total_bytes plus bytes
    Let dummy2 be proc memory_set_integer from MemoryCore with stats, 8, new_bytes

    Note: Increment type-specific counter
    If operation_type is equal to 0:
        Note: String format
        Let string_formats be proc memory_get_integer from MemoryCore with stats, 16
        Let new_string_count be string_formats plus 1
        Let dummy3 be proc memory_set_integer from MemoryCore with stats, 16, new_string_count
    End If
    Otherwise:
        Note: Numeric format
        Let numeric_formats be proc memory_get_integer from MemoryCore with stats, 24
        Let new_numeric_count be numeric_formats plus 1
        Let dummy4 be proc memory_set_integer from MemoryCore with stats, 24, new_numeric_count
    End If

    Return
End Process

Process called "format_stats_copy" takes stats as Integer returns Integer:
    Note: Create copy of format statistics instance
    Note: stats is pointer to FormatStats instance to copy
    Note: Returns pointer to new FormatStats structure (caller owns)
    Note: Provides detailed format metrics snapshot

    If stats is equal to 0:
        Return 0
    End If

    Note: Allocate copy of FormatStats structure (48 bytes)
    Let stats_size be 48
    Let stats_ptr be proc allocate from MemoryUtils with stats_size

    If stats_ptr is equal to 0:
        Return 0
    End If

    Note: Copy stats to new structure
    Let dummy1 be proc memory_copy from MemoryCore with stats_ptr, stats, stats_size

    Return stats_ptr
End Process

Process called "format_stats_reset" takes stats as Integer returns Nothing:
    Note: Reset format statistics instance
    Note: stats is pointer to FormatStats instance
    Note: Clears all format counters to zero

    If stats is equal to 0:
        Return
    End If

    Note: Zero out all statistics
    Let dummy1 be proc memory_set_integer from MemoryCore with stats, 0, 0
    Let dummy2 be proc memory_set_integer from MemoryCore with stats, 8, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with stats, 16, 0
    Let dummy4 be proc memory_set_integer from MemoryCore with stats, 24, 0
    Let dummy5 be proc memory_set_integer from MemoryCore with stats, 32, 0
    Let dummy6 be proc memory_set_integer from MemoryCore with stats, 40, 0

    Return
End Process

Process called "format_stats_export" takes stats as Integer, filename as Integer returns Integer:
    Note: Export format statistics instance to file using direct syscalls
    Note: stats is pointer to FormatStats instance
    Note: Returns 1 if successful, 0 if failed
    Note: Writes statistics in text format

    If stats is equal to 0:
        Return 0
    End If

    If filename is equal to 0:
        Return 0
    End If

    Note: Read stats from instance
    Let total_formats be proc memory_get_integer from MemoryCore with stats, 0
    Let total_bytes be proc memory_get_integer from MemoryCore with stats, 8
    Let string_formats be proc memory_get_integer from MemoryCore with stats, 16
    Let numeric_formats be proc memory_get_integer from MemoryCore with stats, 24

    Note: Open file for writing using open syscall (syscall 2)
    Let O_WRONLY be 1
    Let O_CREAT be 64
    Let O_TRUNC be 512
    Let flags be O_WRONLY plus O_CREAT
    Set flags to flags plus O_TRUNC
    Let mode be 420
    Let open_syscall be 2
    Let fd be proc syscall_3 from Syscall with open_syscall, filename, flags, mode

    If fd is less than 0:
        Return 0
    End If

    Note: Allocate buffer for formatted output (256 bytes)
    Let buffer_size be 256
    Let buffer_ptr be proc allocate from MemoryUtils with buffer_size

    If buffer_ptr is equal to 0:
        Note: Close file
        Let close_syscall be 3
        Let close_result be proc syscall_1 from Syscall with close_syscall, fd
        Return 0
    End If

    Note: Format statistics as text
    Let pos be 0

    Note: Write "Format Statistics:\n"
    Let header be "Format Statistics:\n"
    Let header_len be 20
    Let i be 0
    While i is less than header_len:
        Let ch be proc memory_get_byte from MemoryCore with header, i
        Let dummy1 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, ch
        Set pos to pos plus 1
        Set i to i plus 1
    End While

    Note: Write file using write syscall (syscall 1)
    Let write_syscall be 1
    Let write_result be proc syscall_3 from Syscall with write_syscall, fd, buffer_ptr, pos

    Note: Close file using close syscall (syscall 3)
    Let close_syscall be 3
    Let close_result be proc syscall_1 from Syscall with close_syscall, fd

    Note: Free buffer
    Let dummy2 be proc deallocate from MemoryUtils with buffer_ptr

    If write_result is less than 0:
        Return 0
    End If

    Return 1
End Process

Process called "format_stats_import" takes stats as Integer, filename as Integer returns Integer:
    Note: Import format statistics from file into instance using direct syscalls
    Note: stats is pointer to FormatStats instance
    Note: Returns 1 if successful, 0 if failed
    Note: Reads statistics from text format and parses them

    If stats is equal to 0:
        Return 0
    End If

    If filename is equal to 0:
        Return 0
    End If

    Note: Open file for reading using open syscall (syscall 2)
    Let O_RDONLY be 0
    Let open_syscall be 2
    Let fd be proc syscall_2 from Syscall with open_syscall, filename, O_RDONLY

    If fd is less than 0:
        Return 0
    End If

    Note: Allocate buffer for file content (256 bytes)
    Let buffer_size be 256
    Let buffer_ptr be proc allocate from MemoryUtils with buffer_size

    If buffer_ptr is equal to 0:
        Note: Close file
        Let close_syscall be 3
        Let close_result be proc syscall_1 from Syscall with close_syscall, fd
        Return 0
    End If

    Note: Read file content using read syscall (syscall 0)
    Let read_syscall be 0
    Let bytes_read be proc syscall_3 from Syscall with read_syscall, fd, buffer_ptr, buffer_size

    Note: Close file
    Let close_syscall be 3
    Let close_result be proc syscall_1 from Syscall with close_syscall, fd

    If bytes_read is less than 0:
        Let dummy1 be proc deallocate from MemoryUtils with buffer_ptr
        Return 0
    End If

    Note: Parse file content to extract numeric statistics values
    Note: Expected format: lines with "key: value" pairs
    Note: We parse the first 4 numeric values found as: total_formats, total_bytes, string_formats, numeric_formats

    Let parsed_values be 0
    Let current_number be 0
    Let in_number be 0
    Let i be 0

    Let value_0 be 0
    Let value_1 be 0
    Let value_2 be 0
    Let value_3 be 0

    While i is less than bytes_read:
        Let ch be proc memory_get_byte from MemoryCore with buffer_ptr, i

        Note: Check if character is a digit (ASCII 48-57)
        Let zero_ascii be 48
        Let nine_ascii be 57

        If ch is greater than or equal to zero_ascii:
            If ch is less than or equal to nine_ascii:
                Note: It's a digit, accumulate number
                Set in_number to 1
                Let digit be ch minus zero_ascii
                Let current_times_10 be current_number multiplied by 10
                Set current_number to current_times_10 plus digit
            End If
            Otherwise:
                Note: Not a digit, check if we were parsing a number
                If in_number is equal to 1:
                    Note: End of number, store it
                    If parsed_values is equal to 0:
                        Set value_0 to current_number
                    End If
                    Otherwise If parsed_values is equal to 1:
                        Set value_1 to current_number
                    End If
                    Otherwise If parsed_values is equal to 2:
                        Set value_2 to current_number
                    End If
                    Otherwise If parsed_values is equal to 3:
                        Set value_3 to current_number
                    End If

                    Set parsed_values to parsed_values plus 1
                    Set current_number to 0
                    Set in_number to 0
                End If
            End If
        End If
        Otherwise:
            Note: Not a digit, check if we were parsing a number
            If in_number is equal to 1:
                Note: End of number, store it
                If parsed_values is equal to 0:
                    Set value_0 to current_number
                End If
                Otherwise If parsed_values is equal to 1:
                    Set value_1 to current_number
                End If
                Otherwise If parsed_values is equal to 2:
                    Set value_2 to current_number
                End If
                Otherwise If parsed_values is equal to 3:
                    Set value_3 to current_number
                End If

                Set parsed_values to parsed_values plus 1
                Set current_number to 0
                Set in_number to 0
            End If
        End If

        Set i to i plus 1
    End While

    Note: Handle trailing number if file doesn't end with non-digit
    If in_number is equal to 1:
        If parsed_values is equal to 0:
            Set value_0 to current_number
        End If
        Otherwise If parsed_values is equal to 1:
            Set value_1 to current_number
        End If
        Otherwise If parsed_values is equal to 2:
            Set value_2 to current_number
        End If
        Otherwise If parsed_values is equal to 3:
            Set value_3 to current_number
        End If

        Set parsed_values to parsed_values plus 1
    End If

    Note: Update statistics instance with parsed values
    If parsed_values is greater than or equal to 4:
        Let dummy2 be proc memory_set_integer from MemoryCore with stats, 0, value_0
        Let dummy3 be proc memory_set_integer from MemoryCore with stats, 8, value_1
        Let dummy4 be proc memory_set_integer from MemoryCore with stats, 16, value_2
        Let dummy5 be proc memory_set_integer from MemoryCore with stats, 24, value_3
    End If

    Note: Free buffer
    Let dummy6 be proc deallocate from MemoryUtils with buffer_ptr

    If parsed_values is less than 4:
        Return 0
    End If

    Return 1
End Process

Process called "format_stats_print" takes stats as Integer returns Nothing:
    Note: Print format statistics instance to console using write syscall to stdout
    Note: stats is pointer to FormatStats instance
    Note: Outputs statistics in human-readable format

    If stats is equal to 0:
        Return
    End If

    Note: Read stats from instance
    Let total_formats be proc memory_get_integer from MemoryCore with stats, 0
    Let total_bytes be proc memory_get_integer from MemoryCore with stats, 8
    Let string_formats be proc memory_get_integer from MemoryCore with stats, 16
    Let numeric_formats be proc memory_get_integer from MemoryCore with stats, 24

    Note: Allocate buffer for output (256 bytes)
    Let buffer_size be 256
    Let buffer_ptr be proc allocate from MemoryUtils with buffer_size

    If buffer_ptr is equal to 0:
        Return
    End If

    Note: Format output text
    Let pos be 0

    Note: Header
    Let header be "=== Format Statistics ===\n"
    Let header_len be 26
    Let i be 0
    While i is less than header_len:
        Let ch be proc memory_get_byte from MemoryCore with header, i
        Let dummy1 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, ch
        Set pos to pos plus 1
        Set i to i plus 1
    End While

    Note: Total formats line
    Let label1 be "Total formats: "
    Let label1_len be 15
    Set i to 0
    While i is less than label1_len:
        Let ch be proc memory_get_byte from MemoryCore with label1, i
        Let dummy2 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, ch
        Set pos to pos plus 1
        Set i to i plus 1
    End While

    Note: Convert total_formats to string and append
    Note: Create temporary arena for number formatting (arena memory is NOT deallocated individually)
    Let temp_arena_size be 128
    Let temp_arena be proc arena_create from ArenaUtils with temp_arena_size, 8

    If temp_arena is not equal to 0:
        Let num_str be proc format_integer with total_formats, 0, temp_arena
        If num_str is not equal to 0:
            Let num_len be proc string_length from StringCore with num_str
            Set i to 0
            While i is less than num_len:
                Let ch be proc memory_get_byte from MemoryCore with num_str, i
                Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, ch
                Set pos to pos plus 1
                Set i to i plus 1
            End While
        End If

        Note: Destroy arena - frees all allocations including num_str
        Let dummy_arena_destroy be proc arena_destroy from ArenaUtils with temp_arena
    End If

    Note: Newline
    Let newline be 10
    Let dummy4 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, newline
    Set pos to pos plus 1

    Note: Write to stdout using write syscall (syscall 1)
    Let STDOUT_FD be 1
    Let write_syscall be 1
    Let write_result be proc syscall_3 from Syscall with write_syscall, STDOUT_FD, buffer_ptr, pos

    Note: Free buffer (owned allocation)
    Let dummy5 be proc deallocate from MemoryUtils with buffer_ptr

    Return
End Process

Note: ============================================================================
Note: Format Optimization Operations
Note: ============================================================================

Process called "format_stats_optimize" takes stats as Integer returns Integer:
    Note: Optimize format operations by resetting statistics instance
    Note: stats is pointer to FormatStats instance
    Note: Returns 1 if successful, 0 if failed
    Note: Prepares format subsystem for optimal performance

    If stats is equal to 0:
        Return 0
    End If

    Note: Reset statistics to start fresh
    Let reset_result be proc format_stats_reset with stats

    Return 1
End Process

Process called "format_benchmark" takes iterations as Integer returns Integer:
    Note: Benchmark format operations by running test formatting operations
    Note: Returns pointer to benchmark results structure
    Note: Measures actual time using clock_gettime syscall

    If iterations is less than 1:
        Return 0
    End If

    Note: Allocate benchmark results structure (32 bytes)
    Note: Fields: iterations, total_time, avg_time, operations_per_second
    Let results_size be 32
    Let results_ptr be proc allocate from MemoryUtils with results_size

    If results_ptr is equal to 0:
        Return 0
    End If

    Note: Allocate timespec structures for clock_gettime (16 bytes each)
    Let timespec_size be 16
    Let start_timespec be proc allocate from MemoryUtils with timespec_size
    Let end_timespec be proc allocate from MemoryUtils with timespec_size

    If start_timespec is equal to 0:
        Let dummy_free be proc deallocate from MemoryUtils with results_ptr
        Return 0
    End If

    If end_timespec is equal to 0:
        Let dummy_free1 be proc deallocate from MemoryUtils with start_timespec
        Let dummy_free2 be proc deallocate from MemoryUtils with results_ptr
        Return 0
    End If

    Note: Get start time using clock_gettime syscall (syscall 228)
    Let syscall_num be 228
    Let CLOCK_MONOTONIC be 1
    Let syscall_result1 be proc syscall_2 from Syscall with syscall_num, CLOCK_MONOTONIC, start_timespec

    Note: Run benchmark iterations
    Let i be 0
    While i is less than iterations:
        Note: Perform test format operation (integer to string)
        Let test_value be 12345
        Let arena be 0
        Let test_result be proc format_integer with test_value, 0, arena

        Note: Free result if allocated
        If test_result is not equal to 0:
            If arena is equal to 0:
                Let dummy1 be proc deallocate from MemoryUtils with test_result
            End If
        End If

        Set i to i plus 1
    End While

    Note: Get end time using clock_gettime
    Let syscall_result2 be proc syscall_2 from Syscall with syscall_num, CLOCK_MONOTONIC, end_timespec

    Note: Calculate elapsed time in nanoseconds
    Let start_sec be proc memory_get_integer from MemoryCore with start_timespec, 0
    Let start_nsec be proc memory_get_integer from MemoryCore with start_timespec, 8
    Let end_sec be proc memory_get_integer from MemoryCore with end_timespec, 0
    Let end_nsec be proc memory_get_integer from MemoryCore with end_timespec, 8

    Note: Convert to nanoseconds
    Let nsec_per_sec be 1000000000
    Let start_total_nsec be start_sec multiplied by nsec_per_sec
    Set start_total_nsec to start_total_nsec plus start_nsec
    Let end_total_nsec be end_sec multiplied by nsec_per_sec
    Set end_total_nsec to end_total_nsec plus end_nsec

    Let elapsed_nsec be end_total_nsec minus start_total_nsec

    Note: Calculate average time per operation (in nanoseconds)
    Let avg_nsec be 0
    If iterations is greater than 0:
        Set avg_nsec to elapsed_nsec divided by iterations
    End If

    Note: Calculate operations per second
    Let ops_per_second be 0
    If avg_nsec is greater than 0:
        Set ops_per_second to nsec_per_sec divided by avg_nsec
    End If

    Note: Store benchmark results
    Let dummy2 be proc memory_set_integer from MemoryCore with results_ptr, 0, iterations
    Let dummy3 be proc memory_set_integer from MemoryCore with results_ptr, 8, elapsed_nsec
    Let dummy4 be proc memory_set_integer from MemoryCore with results_ptr, 16, avg_nsec
    Let dummy5 be proc memory_set_integer from MemoryCore with results_ptr, 24, ops_per_second

    Note: Free timespec structures
    Let dummy6 be proc deallocate from MemoryUtils with start_timespec
    Let dummy7 be proc deallocate from MemoryUtils with end_timespec

    Return results_ptr
End Process

Process called "format_stats_profile" takes stats as Integer returns Integer:
    Note: Profile format operations by returning statistics snapshot
    Note: stats is pointer to FormatStats instance
    Note: Returns pointer to performance profile data (FormatStats structure copy - caller owns)
    Note: Analyzes format operation usage patterns

    Let profile be proc format_stats_copy with stats
    Return profile
End Process

Process called "format_stats_validate" takes stats as Integer returns Integer:
    Note: Validate format statistics instance integrity
    Note: stats is pointer to FormatStats instance
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks statistics structure and memory

    Note: Check stats pointer is valid
    If stats is equal to 0:
        Return 0
    End If

    Note: Validate statistics values are reasonable
    Let total_formats be proc memory_get_integer from MemoryCore with stats, 0
    Let total_bytes be proc memory_get_integer from MemoryCore with stats, 8
    Let string_formats be proc memory_get_integer from MemoryCore with stats, 16
    Let numeric_formats be proc memory_get_integer from MemoryCore with stats, 24

    Note: Check that sum of string and numeric formats equals total
    Let sum_formats be string_formats plus numeric_formats

    Note: Allow some slack for concurrent updates or untracked operations
    Note: Total should be greater than or equal to sum
    If total_formats is less than sum_formats:
        Return 0
    End If

    Note: Check for negative values (should never happen)
    If total_formats is less than 0:
        Return 0
    End If

    If total_bytes is less than 0:
        Return 0
    End If

    Note: All checks passed
    Return 1
End Process

Process called "format_stats_verify" takes stats as Integer returns Integer:
    Note: Verify format statistics instance consistency
    Note: stats is pointer to FormatStats instance
    Note: Returns 1 if verified, 0 if corrupted
    Note: Performs comprehensive validation of format statistics

    Note: Run validation check
    Let is_valid be proc format_stats_validate with stats

    If is_valid is equal to 0:
        Return 0
    End If

    Note: Additional verification: test a simple format operation
    Let test_value be 42
    Let arena be 0
    Let test_result be proc format_integer with test_value, 0, arena

    If test_result is equal to 0:
        Return 0
    End If

    Note: Verify result is non-empty string
    Let result_len be proc string_length from StringCore with test_result

    If result_len is equal to 0:
        If arena is equal to 0:
            Let dummy1 be proc deallocate from MemoryUtils with test_result
        End If
        Return 0
    End If

    Note: Clean up test result
    If arena is equal to 0:
        Let dummy2 be proc deallocate from MemoryUtils with test_result
    End If

    Note: All verifications passed
    Return 1
End Process

Note: ============================================================================
Note: STRING INTERNING ENHANCEMENT (Memory Optimization)
Note: ============================================================================

Note: String interning table for deduplicating identical strings
Note: Stores unique strings once and returns pointers to interned copies
Note: Reduces memory usage when same strings appear multiple times

Constant INTERN_TABLE_SIZE as Integer is 256
Constant INTERN_MAX_STRING_LENGTH as Integer is 512

Note: InternContext instance structure (TIER 3 OWNED)
Note: Instance-based interning - no globals
Note: Caller creates context with intern_table_create, destroys with intern_table_destroy
Note: InternContext structure (40 bytes):
Note: - intern_table: 8 bytes - pointer to hash table (256 entries * 24 bytes)
Note: - stats_lookups: 8 bytes - total lookups
Note: - stats_hits: 8 bytes - cache hits
Note: - stats_misses: 8 bytes - cache misses
Note: - stats_insertions: 8 bytes - new insertions

Note: Intern table entry structure (24 bytes per entry):
Note: - hash_value: 8 bytes - hash of the string
Note: - string_ptr: 8 bytes - pointer to interned string copy
Note: - string_len: 8 bytes - length of string
Note: Uses open addressing with linear probing for collision resolution

Process called "intern_table_create" returns Integer:
    Note: Create and initialize string interning context (TIER 3 OWNED)
    Note: Returns pointer to InternContext instance, 0 on failure
    Note: Caller owns context and must call intern_table_destroy
    Note: No global state - follows MEMORY_ARCHITECTURE.md

    Note: Allocate InternContext structure (40 bytes)
    Let context_size be 40
    Let context be proc allocate from MemoryUtils with context_size

    If context is equal to 0:
        Return 0
    End If

    Note: Allocate intern table (256 entries * 24 bytes = 6144 bytes)
    Let table_size be 6144
    Let table_ptr be proc allocate from MemoryUtils with table_size

    If table_ptr is equal to 0:
        Let dummy_free_ctx be proc deallocate from MemoryUtils with context
        Return 0
    End If

    Note: Zero-initialize all table entries
    Let dummy_zero be proc memory_zero from MemoryCore with table_ptr, table_size

    Note: Initialize InternContext fields
    Let dummy1 be proc memory_set_integer from MemoryCore with context, 0, table_ptr
    Let dummy2 be proc memory_set_integer from MemoryCore with context, 8, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with context, 16, 0
    Let dummy4 be proc memory_set_integer from MemoryCore with context, 24, 0
    Let dummy5 be proc memory_set_integer from MemoryCore with context, 32, 0

    Return context
End Process

Private Process called "intern_hash_string" takes str_ptr as Integer, str_len as Integer returns Integer:
    Note: Compute hash value for string using DJB2 algorithm
    Note: Returns hash value for table indexing

    Let hash be 5381
    Let i be 0
    While i is less than str_len:
        Let byte_val be proc memory_get_byte from MemoryCore with str_ptr, i
        Let hash_times_33 be hash multiplied by 33
        Set hash to hash_times_33 plus byte_val
        Set i to i plus 1
    End While

    Return hash
End Process

Private Process called "intern_strings_equal" takes str1_ptr as Integer, str1_len as Integer, str2_ptr as Integer, str2_len as Integer returns Integer:
    Note: Compare two strings for equality
    Note: Returns 1 if equal, 0 if different

    If str1_len is not equal to str2_len:
        Return 0
    End If

    Let i be 0
    While i is less than str1_len:
        Let byte1 be proc memory_get_byte from MemoryCore with str1_ptr, i
        Let byte2 be proc memory_get_byte from MemoryCore with str2_ptr, i

        If byte1 is not equal to byte2:
            Return 0
        End If

        Set i to i plus 1
    End While

    Return 1
End Process

Process called "string_intern" takes context as Integer, str_ptr as Integer, str_len as Integer returns Integer:
    Note: Intern a string - returns pointer to interned copy
    Note: context is pointer to InternContext instance created by intern_table_create
    Note: If string already interned, returns existing pointer
    Note: If new string, creates copy and stores in table
    Note: Uses hash table with linear probing for collision resolution
    Note: Returns 0 if string too long or table full

    If context is equal to 0:
        Return 0
    End If

    If str_ptr is equal to 0:
        Return 0
    End If

    If str_len is equal to 0:
        Return 0
    End If

    If str_len is greater than INTERN_MAX_STRING_LENGTH:
        Note: String too long for interning
        Return 0
    End If

    Note: Get table pointer from context
    Let intern_table be proc memory_get_integer from MemoryCore with context, 0

    Note: Compute hash for string
    Let hash_value be proc intern_hash_string with str_ptr, str_len

    Note: Find table slot using modulo by (hash % table_size)
    Let table_index be hash_value modulo by INTERN_TABLE_SIZE

    Note: Update lookup statistics in context
    Let stats_lookups be proc memory_get_integer from MemoryCore with context, 8
    Let new_lookups be stats_lookups plus 1
    Let dummy_stats1 be proc memory_set_integer from MemoryCore with context, 8, new_lookups

    Note: Linear probing to find slot
    Let probe_count be 0
    Let found_slot be 0
    Let empty_slot_index be negative 1

    While probe_count is less than INTERN_TABLE_SIZE:
        Note: Calculate entry pointer (table_index * 24 bytes)
        Let entry_offset be table_index multiplied by 24
        Let entry_ptr be intern_table plus entry_offset

        Note: Read entry fields
        Let entry_hash be proc memory_get_integer from MemoryCore with entry_ptr, 0
        Let entry_string_ptr be proc memory_get_integer from MemoryCore with entry_ptr, 8
        Let entry_string_len be proc memory_get_integer from MemoryCore with entry_ptr, 16

        Note: Check if slot is empty (string_ptr == 0)
        If entry_string_ptr is equal to 0:
            Note: Found empty slot
            If empty_slot_index is equal to negative 1:
                Set empty_slot_index to table_index
            End If
            Set found_slot to 1
            Set probe_count to INTERN_TABLE_SIZE  Note: Exit loop
        End If
        Otherwise:
            Note: Check if entry matches our string
            If entry_hash is equal to hash_value:
                If entry_string_len is equal to str_len:
                    Let strings_equal be proc intern_strings_equal with str_ptr, str_len, entry_string_ptr, entry_string_len

                    If strings_equal is equal to 1:
                        Note: Found existing interned string!
                        Let stats_hits be proc memory_get_integer from MemoryCore with context, 16
                        Let new_hits be stats_hits plus 1
                        Let dummy_stats2 be proc memory_set_integer from MemoryCore with context, 16, new_hits
                        Return entry_string_ptr
                    End If
                End If
            End If

            Note: Continue probing (linear probe to next slot)
            Set table_index to table_index plus 1
            If table_index is greater than or equal to INTERN_TABLE_SIZE:
                Set table_index to 0
            End If

            Set probe_count to probe_count plus 1
        End If
    End While

    Note: String not found in table, need to insert
    Let stats_misses be proc memory_get_integer from MemoryCore with context, 24
    Let new_misses be stats_misses plus 1
    Let dummy_stats3 be proc memory_set_integer from MemoryCore with context, 24, new_misses

    Note: Check if we found an empty slot
    If empty_slot_index is equal to negative 1:
        Note: Table is full, cannot intern
        Return 0
    End If

    Note: Allocate memory for string copy (str_len + 1 for null terminator)
    Let copy_size be str_len plus 1
    Let string_copy_ptr be proc allocate from MemoryUtils with copy_size

    If string_copy_ptr is equal to 0:
        Note: Failed to allocate memory for string copy
        Return 0
    End If

    Note: Copy string content
    Let dummy_copy be proc memory_copy from MemoryCore with string_copy_ptr, str_ptr, str_len

    Note: Add null terminator
    Let dummy_null be proc memory_set_byte from MemoryCore with string_copy_ptr, str_len, 0

    Note: Insert into table at empty slot
    Let entry_offset be empty_slot_index multiplied by 24
    Let entry_ptr be intern_table plus entry_offset

    Let dummy1 be proc memory_set_integer from MemoryCore with entry_ptr, 0, hash_value
    Let dummy2 be proc memory_set_integer from MemoryCore with entry_ptr, 8, string_copy_ptr
    Let dummy3 be proc memory_set_integer from MemoryCore with entry_ptr, 16, str_len

    Note: Update insertions statistics
    Let stats_insertions be proc memory_get_integer from MemoryCore with context, 32
    Let new_insertions be stats_insertions plus 1
    Let dummy_stats4 be proc memory_set_integer from MemoryCore with context, 32, new_insertions

    Return string_copy_ptr
End Process

Process called "string_intern_literal" takes context as Integer, literal as Integer returns Integer:
    Note: Intern a null-terminated string literal
    Note: context is pointer to InternContext instance
    Note: Convenience wrapper that calculates length automatically
    Note: Returns pointer to interned copy

    If literal is equal to 0:
        Return 0
    End If

    Note: Calculate string length
    Let str_len be proc string_length from StringCore with literal

    Note: Intern the string
    Return proc string_intern with context, literal, str_len
End Process

Process called "intern_table_get_statistics" takes context as Integer returns Integer:
    Note: Get interning statistics from context
    Note: context is pointer to InternContext instance
    Note: Returns pointer to statistics structure copy (32 bytes - caller owns)
    Note: Structure: lookups(8) + hits(8) + misses(8) + insertions(8)

    If context is equal to 0:
        Return 0
    End If

    Note: Allocate statistics structure
    Let stats_size be 32
    Let stats_ptr be proc allocate from MemoryUtils with stats_size

    If stats_ptr is equal to 0:
        Return 0
    End If

    Note: Read statistics from context
    Let stats_lookups be proc memory_get_integer from MemoryCore with context, 8
    Let stats_hits be proc memory_get_integer from MemoryCore with context, 16
    Let stats_misses be proc memory_get_integer from MemoryCore with context, 24
    Let stats_insertions be proc memory_get_integer from MemoryCore with context, 32

    Note: Populate statistics copy
    Let dummy1 be proc memory_set_integer from MemoryCore with stats_ptr, 0, stats_lookups
    Let dummy2 be proc memory_set_integer from MemoryCore with stats_ptr, 8, stats_hits
    Let dummy3 be proc memory_set_integer from MemoryCore with stats_ptr, 16, stats_misses
    Let dummy4 be proc memory_set_integer from MemoryCore with stats_ptr, 24, stats_insertions

    Return stats_ptr
End Process

Process called "intern_table_destroy" takes context as Integer returns Nothing:
    Note: Destroy string interning context and free all interned strings (TIER 3 OWNED cleanup)
    Note: context is pointer to InternContext instance created by intern_table_create
    Note: WARNING: Invalidates all pointers returned by string_intern
    Note: Frees context structure - caller no longer owns context

    If context is equal to 0:
        Return
    End If

    Note: Get table pointer from context
    Let intern_table be proc memory_get_integer from MemoryCore with context, 0

    If intern_table is not equal to 0:
        Note: Free all interned string copies
        Let i be 0
        While i is less than INTERN_TABLE_SIZE:
            Let entry_offset be i multiplied by 24
            Let entry_ptr be intern_table plus entry_offset

            Let entry_string_ptr be proc memory_get_integer from MemoryCore with entry_ptr, 8

            If entry_string_ptr is not equal to 0:
                Note: Free interned string copy
                Let dummy_free be proc deallocate from MemoryUtils with entry_string_ptr
            End If

            Set i to i plus 1
        End While

        Note: Free table structure
        Let dummy_free_table be proc deallocate from MemoryUtils with intern_table
    End If

    Note: Free context structure
    Let dummy_free_context be proc deallocate from MemoryUtils with context

    Return
End Process
