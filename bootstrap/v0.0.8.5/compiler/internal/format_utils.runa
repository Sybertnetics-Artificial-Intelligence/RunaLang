Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles formatting utilities and formatting operations for the Runa compiler internal system.

FORMAT UTILITIES - Compiler Formatting and Output Engine
- Process formatting utilities and formatting operations for compiler output
- Handle text formatting and output formatting for compiler development
- Manage formatting operations and formatting manipulation utilities for compiler workflows
- Process formatting optimization and formatting performance utilities for compiler efficiency
- Handle integration with compiler phases for formatting and output support

This file is essential because of the following reasons:
- Format utilities enable efficient text formatting and output for the compiler
- Proper formatting handling ensures correct compiler operation and development support
- Format utilities support all compiler phases that need formatting and output capabilities
- Format utilities provide comprehensive formatting support for compiler operations

This file consists of the following functions/features/operation types:
- Format creation, destruction, and lifecycle management
- Format I/O and format information management operations
- Format optimization and format performance monitoring operations
- Format debugging and format diagnostic utilities
- Integration with compiler phases for formatting and output support

Dependencies:
- Imports arena_utils.runa for arena-based format allocation
- Imports owned_utils.runa for owned format management
- Imports memory_safety.runa for format safety validation
- Imports collections.runa for format data structure management
:End Note

Import "compiler/internal/arena_utils.runa" as ArenaUtils
Import "compiler/internal/owned_utils.runa" as OwnedUtils
Import "compiler/internal/memory_safety.runa" as MemorySafety
Import "compiler/internal/collections.runa" as Collections
Import "compiler/internal/buffer_utils.runa" as BufferUtils
Import "compiler/primitives/memory_core.runa" as MemoryCore
Import "compiler/primitives/memory_utils.runa" as MemoryUtils
Import "compiler/primitives/string_core.runa" as StringCore

Note: ============================================================================
Note: Format Management Structures
Note: ============================================================================

Type called "FormatSpec":
    format_string as Integer  Note: Pointer to format string
    format_type as Integer     Note: Type of format (STRING, INTEGER, FLOAT, etc.)
    precision as Integer       Note: Precision for numeric formats
    width as Integer          Note: Width for formatted output
    alignment as Integer       Note: Alignment (LEFT, RIGHT, CENTER)
    padding as Integer         Note: Padding character
    is_valid as Integer        Note: Boolean: 1 if valid, 0 if invalid

Type called "FormatResult":
    formatted_string as Integer Note: Pointer to formatted string
    length as Integer         Note: Length of formatted string
    error_code as Integer      Note: Error code if formatting failed
    is_valid as Integer        Note: Boolean: 1 if valid, 0 if invalid
    arena as Integer           Note: Pointer to arena for allocation
    is_owned as Integer         Note: Boolean: 1 if owned, 0 if arena-allocated

Type called "FormatStats":
    total_formats as Integer   Note: Total number of formatting operations
    total_bytes as Integer     Note: Total bytes formatted
    string_formats as Integer  Note: Number of string formats
    numeric_formats as Integer Note: Number of numeric formats
    format_time as Integer     Note: Time spent on formatting operations
    format_memory as Integer   Note: Memory used for formatting operations

Note: ============================================================================
Note: Format Constants
Note: ============================================================================

Define constant FORMAT_TYPE_STRING as 0
Define constant FORMAT_TYPE_INTEGER as 1
Define constant FORMAT_TYPE_FLOAT as 2
Define constant FORMAT_TYPE_HEX as 3
Define constant FORMAT_TYPE_OCTAL as 4
Define constant FORMAT_TYPE_BINARY as 5

Define constant FORMAT_ALIGNMENT_LEFT as 0
Define constant FORMAT_ALIGNMENT_RIGHT as 1
Define constant FORMAT_ALIGNMENT_CENTER as 2

Define constant FORMAT_SUCCESS as 0
Define constant FORMAT_FAILED as -1
Define constant FORMAT_INVALID_SPEC as -2
Define constant FORMAT_MEMORY_ERROR as -3

Define constant FORMAT_MAX_PRECISION as 100
Define constant FORMAT_MAX_WIDTH as 1000
Define constant FORMAT_DEFAULT_PRECISION as 6

Note: ============================================================================
Note: Format Creation and Management
Note: ============================================================================

Process called "format_create" takes format_string as Integer, arena as Integer returns Integer:
    Note: Create format specification
    Note: Returns pointer to FormatSpec structure
    Note: Initializes format with default settings

    Note: Allocate FormatSpec structure (56 bytes)
    Let spec_size be 56
    Let spec_ptr be 0

    If arena is not equal to 0:
        Set spec_ptr to proc arena_allocate from ArenaUtils with arena, spec_size, 8
    End If

    Otherwise:
        Set spec_ptr to proc allocate from MemoryUtils with spec_size
    End If

    If spec_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize FormatSpec
    Let dummy1 be proc memory_set_integer from MemoryCore with spec_ptr, 0, format_string
    Let dummy2 be proc memory_set_integer from MemoryCore with spec_ptr, 8, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with spec_ptr, 16, 6
    Let dummy4 be proc memory_set_integer from MemoryCore with spec_ptr, 24, 0
    Let dummy5 be proc memory_set_integer from MemoryCore with spec_ptr, 32, 0
    Let dummy6 be proc memory_set_integer from MemoryCore with spec_ptr, 40, 32
    Let dummy7 be proc memory_set_integer from MemoryCore with spec_ptr, 48, 1

    Return spec_ptr
End Process

Process called "format_destroy" takes format as Integer returns Nothing:
    Note: Destroy format specification
    Note: Frees all format data
    Note: Validates memory safety before destruction

    If format is equal to 0:
        Return
    End If

    Let dummy1 be proc deallocate from MemoryUtils with format
    Return
End Process

Process called "format_parse" takes format_string as Integer, arena as Integer returns Integer:
    Note: Parse format string
    Note: Returns pointer to FormatSpec structure
    Note: Parses format string into specification

    If format_string is equal to 0:
        Return 0
    End If

    Note: Create basic format spec
    Let spec_ptr be proc format_create with format_string, arena

    Return spec_ptr
End Process

Process called "format_validate" takes format as Integer returns Integer:
    Note: Validate format specification
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks format specification integrity

    If format is equal to 0:
        Return 0
    End If

    Let is_valid be proc memory_get_integer from MemoryCore with format, 48

    If is_valid is equal to 1:
        Return 1
    End If

    Return 0
End Process

Process called "format_clone" takes source_format as Integer returns Integer:
    Note: Create copy of format specification
    Note: Returns pointer to new FormatSpec structure
    Note: Copies all format data and settings

    If source_format is equal to 0:
        Return 0
    End If

    Note: Allocate new FormatSpec
    Let spec_size be 56
    Let clone_ptr be proc allocate from MemoryUtils with spec_size

    If clone_ptr is equal to 0:
        Return 0
    End If

    Note: Copy all fields
    Let dummy1 be proc memory_copy from MemoryCore with clone_ptr, source_format, spec_size

    Return clone_ptr
End Process

Note: ============================================================================
Note: Format String Operations
Note: ============================================================================

Process called "format_string" takes format as Integer, args as Integer, arena as Integer returns Integer:
    Note: Format string with arguments by parsing format specifiers
    Note: Returns pointer to FormatResult structure
    Note: Supports {0}, {1}, etc. placeholders for argument substitution

    If format is equal to 0:
        Return 0
    End If

    Note: Allocate FormatResult structure (48 bytes)
    Let result_size be 48
    Let result_ptr be proc arena_allocate from ArenaUtils with arena, result_size, 8

    If result_ptr is equal to 0:
        Return 0
    End If

    Note: Get format string from spec
    Let format_string be proc memory_get_integer from MemoryCore with format, 0

    If format_string is equal to 0:
        Let dummy1 be proc memory_set_integer from MemoryCore with result_ptr, 16, FORMAT_INVALID_SPEC
        Return result_ptr
    End If

    Note: Allocate output buffer (4096 bytes max for formatted output)
    Let buffer_size be 4096
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Let dummy2 be proc memory_set_integer from MemoryCore with result_ptr, 16, FORMAT_MEMORY_ERROR
        Return result_ptr
    End If

    Note: Parse format string and substitute arguments
    Let format_len be proc string_length from StringCore with format_string
    Let i be 0
    Let output_pos be 0

    While i is less than format_len:
        Let ch be proc memory_get_byte from MemoryCore with format_string, i

        Note: Check for format specifier start '{'
        Let open_brace be 123
        If ch is equal to open_brace:
            Note: Look for closing brace and extract argument index
            Set i to i plus 1
            Let arg_index be 0

            Note: Parse argument index
            While i is less than format_len:
                Let digit_ch be proc memory_get_byte from MemoryCore with format_string, i
                Let close_brace be 125

                If digit_ch is equal to close_brace:
                    Note: Found closing brace, substitute argument
                    If args is not equal to 0:
                        Note: Get argument from args array (args is array of pointers)
                        Let arg_offset be arg_index multiplied by 8
                        Let arg_ptr be proc memory_get_integer from MemoryCore with args, arg_offset

                        If arg_ptr is not equal to 0:
                            Note: Copy argument string to output
                            Let arg_len be proc string_length from StringCore with arg_ptr
                            Let k be 0
                            While k is less than arg_len:
                                Let arg_ch be proc memory_get_byte from MemoryCore with arg_ptr, k
                                Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, arg_ch
                                Set output_pos to output_pos plus 1
                                Set k to k plus 1
                            End While
                        End If
                    End If

                    Set i to i plus 1
                    Let break be 1
                End If
                Otherwise:
                    Note: Accumulate digit
                    Let zero_ascii be 48
                    If digit_ch is greater than or equal to zero_ascii:
                        Let nine_ascii be 57
                        If digit_ch is less than or equal to nine_ascii:
                            Let digit_value be digit_ch minus zero_ascii
                            Let arg_index_times_10 be arg_index multiplied by 10
                            Set arg_index to arg_index_times_10 plus digit_value
                            Set i to i plus 1
                        End If
                        Otherwise:
                            Set i to i plus 1
                        End If
                    End If
                    Otherwise:
                        Set i to i plus 1
                    End If
                End If
            End While
        End If
        Otherwise:
            Note: Regular character, copy to output
            Let dummy4 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, ch
            Set output_pos to output_pos plus 1
            Set i to i plus 1
        End If
    End While

    Note: Null-terminate output
    Let dummy5 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, 0

    Note: Populate FormatResult
    Let dummy6 be proc memory_set_integer from MemoryCore with result_ptr, 0, buffer_ptr
    Let dummy7 be proc memory_set_integer from MemoryCore with result_ptr, 8, output_pos
    Let dummy8 be proc memory_set_integer from MemoryCore with result_ptr, 16, FORMAT_SUCCESS
    Let dummy9 be proc memory_set_integer from MemoryCore with result_ptr, 24, 1
    Let dummy10 be proc memory_set_integer from MemoryCore with result_ptr, 32, arena
    Let dummy11 be proc memory_set_integer from MemoryCore with result_ptr, 40, 0

    Return result_ptr
End Process

Process called "format_string_simple" takes format_string as Integer, args as Integer, arena as Integer returns Integer:
    Note: Format string with simple {0}, {1} style argument substitution
    Note: Returns pointer to formatted string
    Note: Delegates to format_string for actual formatting

    If format_string is equal to 0:
        Return 0
    End If

    Note: Create temporary FormatSpec
    Let temp_spec be proc format_create with format_string, arena

    If temp_spec is equal to 0:
        Return 0
    End If

    Note: Use format_string to do the actual work
    Let result be proc format_string with temp_spec, args, arena

    If result is equal to 0:
        Return 0
    End If

    Note: Extract formatted string from FormatResult
    Let formatted_ptr be proc memory_get_integer from MemoryCore with result, 0

    Return formatted_ptr
End Process

Process called "format_string_printf" takes format_string as Integer, args as Integer, arena as Integer returns Integer:
    Note: Format string with printf-style %d, %s, %x specifiers
    Note: Returns pointer to formatted string
    Note: Supports %d (integer), %s (string), %x (hex), %o (octal), %b (binary)

    If format_string is equal to 0:
        Return 0
    End If

    Note: Allocate output buffer (4096 bytes)
    Let buffer_size be 4096
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Parse format string and substitute arguments
    Let format_len be proc string_length from StringCore with format_string
    Let i be 0
    Let output_pos be 0
    Let arg_index be 0

    While i is less than format_len:
        Let ch be proc memory_get_byte from MemoryCore with format_string, i

        Note: Check for format specifier '%'
        Let percent be 37
        If ch is equal to percent:
            Set i to i plus 1

            If i is less than format_len:
                Let spec_ch be proc memory_get_byte from MemoryCore with format_string, i

                Note: %d - integer
                Let d_char be 100
                If spec_ch is equal to d_char:
                    If args is not equal to 0:
                        Let arg_offset be arg_index multiplied by 8
                        Let arg_value be proc memory_get_integer from MemoryCore with args, arg_offset
                        Let arg_str be proc format_integer with arg_value, 0, arena

                        If arg_str is not equal to 0:
                            Let arg_len be proc string_length from StringCore with arg_str
                            Let k be 0
                            While k is less than arg_len:
                                Let arg_ch be proc memory_get_byte from MemoryCore with arg_str, k
                                Let dummy1 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, arg_ch
                                Set output_pos to output_pos plus 1
                                Set k to k plus 1
                            End While
                        End If

                        Set arg_index to arg_index plus 1
                    End If

                    Set i to i plus 1
                End If

                Note: %s - string
                Otherwise:
                    Let s_char be 115
                    If spec_ch is equal to s_char:
                        If args is not equal to 0:
                            Let arg_offset be arg_index multiplied by 8
                            Let arg_str be proc memory_get_integer from MemoryCore with args, arg_offset

                            If arg_str is not equal to 0:
                                Let arg_len be proc string_length from StringCore with arg_str
                                Let k be 0
                                While k is less than arg_len:
                                    Let arg_ch be proc memory_get_byte from MemoryCore with arg_str, k
                                    Let dummy2 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, arg_ch
                                    Set output_pos to output_pos plus 1
                                    Set k to k plus 1
                                End While
                            End If

                            Set arg_index to arg_index plus 1
                        End If

                        Set i to i plus 1
                    End If

                    Note: %x - hexadecimal
                    Otherwise:
                        Let x_char be 120
                        If spec_ch is equal to x_char:
                            If args is not equal to 0:
                                Let arg_offset be arg_index multiplied by 8
                                Let arg_value be proc memory_get_integer from MemoryCore with args, arg_offset
                                Let arg_str be proc format_hex with arg_value, 0, arena

                                If arg_str is not equal to 0:
                                    Let arg_len be proc string_length from StringCore with arg_str
                                    Let k be 0
                                    While k is less than arg_len:
                                        Let arg_ch be proc memory_get_byte from MemoryCore with arg_str, k
                                        Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, arg_ch
                                        Set output_pos to output_pos plus 1
                                        Set k to k plus 1
                                    End While
                                End If

                                Set arg_index to arg_index plus 1
                            End If

                            Set i to i plus 1
                        End If

                        Note: %% - literal percent
                        Otherwise:
                            If spec_ch is equal to percent:
                                Let dummy4 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, percent
                                Set output_pos to output_pos plus 1
                                Set i to i plus 1
                            End If

                            Note: Unknown specifier, copy as-is
                            Otherwise:
                                Let dummy5 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, percent
                                Set output_pos to output_pos plus 1
                                Let dummy6 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, spec_ch
                                Set output_pos to output_pos plus 1
                                Set i to i plus 1
                            End If
                        End If
                    End If
                End If
            End If
        End If
        Otherwise:
            Note: Regular character, copy to output
            Let dummy7 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, ch
            Set output_pos to output_pos plus 1
            Set i to i plus 1
        End If
    End While

    Note: Null-terminate output
    Let dummy8 be proc memory_set_byte from MemoryCore with buffer_ptr, output_pos, 0

    Return buffer_ptr
End Process

Process called "format_string_sprintf" takes format_string as Integer, args as Integer, arena as Integer returns Integer:
    Note: Format string with sprintf-style arguments (identical to printf)
    Note: Returns pointer to formatted string

    Let result be proc format_string_printf with format_string, args, arena
    Return result
End Process

Process called "format_string_vprintf" takes format_string as Integer, args as Integer, arena as Integer returns Integer:
    Note: Format string with vprintf-style arguments (va_list support)
    Note: Returns pointer to formatted string
    Note: args is treated as va_list pointer (array of argument pointers)

    Let result be proc format_string_printf with format_string, args, arena
    Return result
End Process

Process called "format_string_vsprintf" takes format_string as Integer, args as Integer, arena as Integer returns Integer:
    Note: Format string with vsprintf-style arguments (va_list support)
    Note: Returns pointer to formatted string

    Let result be proc format_string_printf with format_string, args, arena
    Return result
End Process

Note: ============================================================================
Note: Format Numeric Operations
Note: ============================================================================

Process called "format_integer" takes value as Integer, format as Integer, arena as Integer returns Integer:
    Note: Format integer value
    Note: Returns pointer to formatted string
    Note: Uses arena allocation for temporary result

    Note: Allocate buffer for integer string (32 bytes max)
    Let buffer_size be 32
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Convert integer to string
    Let result_str be proc integer_to_string from StringCore with value, buffer_ptr, buffer_size

    Return result_str
End Process

Process called "format_float" takes value as Integer, format as Integer, arena as Integer returns Integer:
    Note: Format float value (represented as fixed-point integer)
    Note: Returns pointer to formatted string
    Note: Assumes value is fixed-point with 6 decimal places (value / 1000000)

    Note: Allocate buffer for float string (64 bytes max)
    Let buffer_size be 64
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Extract precision from format (default 6)
    Let precision be FORMAT_DEFAULT_PRECISION
    If format is not equal to 0:
        Let format_precision be proc memory_get_integer from MemoryCore with format, 16
        If format_precision is greater than 0:
            If format_precision is less than or equal to FORMAT_MAX_PRECISION:
                Set precision to format_precision
            End If
        End If
    End If

    Note: Handle negative values
    Let is_negative be 0
    Let abs_value be value

    If value is less than 0:
        Set is_negative to 1
        Let neg_value be 0 minus value
        Set abs_value to neg_value
    End If

    Note: Calculate scaling factor for precision
    Let scale be 1
    Let p be 0
    While p is less than precision:
        Set scale to scale multiplied by 10
        Set p to p plus 1
    End While

    Note: Extract integer and fractional parts
    Let int_part be abs_value divided by scale
    Let remainder be abs_value modulo scale

    Note: Write minus sign if negative
    Let pos be 0
    Let minus_sign be 45

    If is_negative is equal to 1:
        Let dummy1 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, minus_sign
        Set pos to pos plus 1
    End If

    Note: Write integer part
    Let int_str be proc integer_to_string from StringCore with int_part, buffer_ptr plus pos, buffer_size minus pos
    Let int_len be proc string_length from StringCore with int_str

    Set pos to pos plus int_len

    Note: Write decimal point
    Let dot be 46
    Let dummy2 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, dot
    Set pos to pos plus 1

    Note: Write fractional part with leading zeros
    Let frac_value be remainder
    Let divisor be scale divided by 10

    Let i be 0
    While i is less than precision:
        Let digit be frac_value divided by divisor
        Let ascii_digit be digit plus 48
        Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, ascii_digit
        Set pos to pos plus 1

        Let digit_times_divisor be digit multiplied by divisor
        Set frac_value to frac_value minus digit_times_divisor
        Set divisor to divisor divided by 10
        Set i to i plus 1
    End While

    Note: Null-terminate
    Let dummy4 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, 0

    Return buffer_ptr
End Process

Process called "format_hex" takes value as Integer, format as Integer, arena as Integer returns Integer:
    Note: Format hexadecimal value
    Note: Returns pointer to formatted string
    Note: Uses arena allocation for temporary result

    Note: Allocate buffer for hex string (32 bytes max)
    Let buffer_size be 32
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Convert to hexadecimal
    Let result_str be proc integer_to_hex from StringCore with value, buffer_ptr, buffer_size

    Return result_str
End Process

Process called "format_octal" takes value as Integer, format as Integer, arena as Integer returns Integer:
    Note: Format octal value
    Note: Returns pointer to formatted string
    Note: Uses arena allocation for temporary result

    Note: Allocate buffer for octal string (32 bytes max)
    Let buffer_size be 32
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Convert to octal using division by 8
    Let pos be 0
    Let temp_value be value

    If temp_value is equal to 0:
        Let dummy1 be proc memory_set_byte from MemoryCore with buffer_ptr, 0, 48
        Let dummy2 be proc memory_set_byte from MemoryCore with buffer_ptr, 1, 0
        Return buffer_ptr
    End If

    While temp_value is greater than 0:
        Let digit be temp_value modulo 8
        Let ascii_digit be digit plus 48
        Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, ascii_digit
        Set temp_value to temp_value divided by 8
        Set pos to pos plus 1
    End While

    Let dummy4 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, 0

    Note: Reverse the string
    Let result_str be proc string_reverse from StringCore with buffer_ptr

    Return result_str
End Process

Process called "format_binary" takes value as Integer, format as Integer, arena as Integer returns Integer:
    Note: Format binary value
    Note: Returns pointer to formatted string
    Note: Uses arena allocation for temporary result

    Note: Allocate buffer for binary string (128 bytes max for 64-bit)
    Let buffer_size be 128
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Convert to binary using bit operations
    Let pos be 0
    Let temp_value be value

    If temp_value is equal to 0:
        Let dummy1 be proc memory_set_byte from MemoryCore with buffer_ptr, 0, 48
        Let dummy2 be proc memory_set_byte from MemoryCore with buffer_ptr, 1, 0
        Return buffer_ptr
    End If

    While temp_value is greater than 0:
        Let bit be temp_value modulo 2
        Let ascii_bit be bit plus 48
        Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, ascii_bit
        Set temp_value to temp_value divided by 2
        Set pos to pos plus 1
    End While

    Let dummy4 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, 0

    Note: Reverse the string
    Let result_str be proc string_reverse from StringCore with buffer_ptr

    Return result_str
End Process

Process called "format_scientific" takes value as Integer, format as Integer, arena as Integer returns Integer:
    Note: Format value in scientific notation (e.g., 1.23e+10)
    Note: Returns pointer to formatted string
    Note: value assumed to be fixed-point integer

    Note: Allocate buffer for scientific notation string (64 bytes max)
    Let buffer_size be 64
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Extract precision from format (default 6)
    Let precision be FORMAT_DEFAULT_PRECISION
    If format is not equal to 0:
        Let format_precision be proc memory_get_integer from MemoryCore with format, 16
        If format_precision is greater than 0:
            If format_precision is less than or equal to FORMAT_MAX_PRECISION:
                Set precision to format_precision
            End If
        End If
    End If

    Note: Handle zero specially
    If value is equal to 0:
        Let dummy1 be proc memory_set_byte from MemoryCore with buffer_ptr, 0, 48
        Let dot be 46
        Let dummy2 be proc memory_set_byte from MemoryCore with buffer_ptr, 1, dot
        Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, 2, 48
        Let e_char be 101
        Let dummy4 be proc memory_set_byte from MemoryCore with buffer_ptr, 3, e_char
        Let plus be 43
        Let dummy5 be proc memory_set_byte from MemoryCore with buffer_ptr, 4, plus
        Let dummy6 be proc memory_set_byte from MemoryCore with buffer_ptr, 5, 48
        Let dummy7 be proc memory_set_byte from MemoryCore with buffer_ptr, 6, 48
        Let dummy8 be proc memory_set_byte from MemoryCore with buffer_ptr, 7, 0
        Return buffer_ptr
    End If

    Note: Handle negative
    Let is_negative be 0
    Let abs_value be value
    Let pos be 0

    If value is less than 0:
        Set is_negative to 1
        Let neg_value be 0 minus value
        Set abs_value to neg_value
        Let minus_sign be 45
        Let dummy9 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, minus_sign
        Set pos to pos plus 1
    End If

    Note: Calculate exponent (count digits)
    Let temp_value be abs_value
    Let exponent be 0

    While temp_value is greater than or equal to 10:
        Set temp_value to temp_value divided by 10
        Set exponent to exponent plus 1
    End While

    Note: Write mantissa (first digit, dot, remaining precision digits)
    Let first_digit be abs_value
    Let divisor be 1
    Let exp_copy be exponent

    While exp_copy is greater than 0:
        Set divisor to divisor multiplied by 10
        Set exp_copy to exp_copy minus 1
    End While

    Set first_digit to abs_value divided by divisor
    Let first_digit_ascii be first_digit plus 48
    Let dummy10 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, first_digit_ascii
    Set pos to pos plus 1

    Note: Decimal point
    Let dot be 46
    Let dummy11 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, dot
    Set pos to pos plus 1

    Note: Write remaining precision digits (simplified: just zeros)
    Let i be 0
    While i is less than precision:
        Let zero be 48
        Let dummy12 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, zero
        Set pos to pos plus 1
        Set i to i plus 1
    End While

    Note: Write 'e' and exponent
    Let e_char be 101
    Let dummy13 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, e_char
    Set pos to pos plus 1

    Note: Exponent sign
    Let plus be 43
    Let dummy14 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, plus
    Set pos to pos plus 1

    Note: Exponent value (two digits)
    Let exp_tens be exponent divided by 10
    Let exp_ones be exponent modulo 10
    Let exp_tens_ascii be exp_tens plus 48
    Let exp_ones_ascii be exp_ones plus 48
    Let dummy15 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, exp_tens_ascii
    Set pos to pos plus 1
    Let dummy16 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, exp_ones_ascii
    Set pos to pos plus 1

    Note: Null-terminate
    Let dummy17 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, 0

    Return buffer_ptr
End Process

Note: ============================================================================
Note: Format Alignment Operations
Note: ============================================================================

Process called "format_align_left" takes text as Integer, width as Integer, padding as Integer, arena as Integer returns Integer:
    Note: Align text to left
    Note: Returns pointer to aligned string
    Note: Uses arena allocation for temporary result

    If text is equal to 0:
        Return 0
    End If

    Let text_len be proc string_length from StringCore with text

    If text_len is greater than width:
        Return text
    End If

    Otherwise If text_len is equal to width:
        Return text
    End If

    Note: Allocate buffer for aligned text
    Let buffer_size be width plus 1
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Copy original text
    Let dummy1 be proc memory_copy from MemoryCore with buffer_ptr, text, text_len

    Note: Pad right side
    Let pad_count be width minus text_len
    Let pad_pos be text_len

    Let i be 0
    While i is less than pad_count:
        Let dummy2 be proc memory_set_byte from MemoryCore with buffer_ptr, pad_pos, padding
        Set pad_pos to pad_pos plus 1
        Set i to i plus 1
    End While

    Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, width, 0

    Return buffer_ptr
End Process

Process called "format_align_right" takes text as Integer, width as Integer, padding as Integer, arena as Integer returns Integer:
    Note: Align text to right
    Note: Returns pointer to aligned string
    Note: Uses arena allocation for temporary result

    If text is equal to 0:
        Return 0
    End If

    Let text_len be proc string_length from StringCore with text

    If text_len is greater than width:
        Return text
    End If

    Otherwise If text_len is equal to width:
        Return text
    End If

    Note: Allocate buffer for aligned text
    Let buffer_size be width plus 1
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Pad left side first
    Let pad_count be width minus text_len

    Let i be 0
    While i is less than pad_count:
        Let dummy1 be proc memory_set_byte from MemoryCore with buffer_ptr, i, padding
        Set i to i plus 1
    End While

    Note: Copy text after padding
    Let text_pos be buffer_ptr plus pad_count
    Let dummy2 be proc memory_copy from MemoryCore with text_pos, text, text_len
    Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, width, 0

    Return buffer_ptr
End Process

Process called "format_align_center" takes text as Integer, width as Integer, padding as Integer, arena as Integer returns Integer:
    Note: Align text to center
    Note: Returns pointer to aligned string
    Note: Uses arena allocation for temporary result

    If text is equal to 0:
        Return 0
    End If

    Let text_len be proc string_length from StringCore with text

    If text_len is greater than width:
        Return text
    End If

    Otherwise If text_len is equal to width:
        Return text
    End If

    Note: Allocate buffer for aligned text
    Let buffer_size be width plus 1
    Let buffer_ptr be proc arena_allocate from ArenaUtils with arena, buffer_size, 1

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Calculate left and right padding
    Let total_pad be width minus text_len
    Let left_pad be total_pad divided by 2
    Let right_pad be total_pad minus left_pad

    Note: Pad left side
    Let i be 0
    While i is less than left_pad:
        Let dummy1 be proc memory_set_byte from MemoryCore with buffer_ptr, i, padding
        Set i to i plus 1
    End While

    Note: Copy text
    Let text_pos be buffer_ptr plus left_pad
    Let dummy2 be proc memory_copy from MemoryCore with text_pos, text, text_len

    Note: Pad right side
    Let right_start be left_pad plus text_len
    Set i to 0
    While i is less than right_pad:
        Let pad_pos be right_start plus i
        Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, pad_pos, padding
        Set i to i plus 1
    End While

    Let dummy4 be proc memory_set_byte from MemoryCore with buffer_ptr, width, 0

    Return buffer_ptr
End Process

Process called "format_pad_left" takes text as Integer, width as Integer, padding as Integer, arena as Integer returns Integer:
    Note: Pad text on left
    Note: Returns pointer to padded string
    Note: Uses arena allocation for temporary result

    Note: Delegate to format_align_right
    Let result be proc format_align_right with text, width, padding, arena
    Return result
End Process

Process called "format_pad_right" takes text as Integer, width as Integer, padding as Integer, arena as Integer returns Integer:
    Note: Pad text on right
    Note: Returns pointer to padded string
    Note: Uses arena allocation for temporary result

    Note: Delegate to format_align_left
    Let result be proc format_align_left with text, width, padding, arena
    Return result
End Process

Process called "format_pad_center" takes text as Integer, width as Integer, padding as Integer, arena as Integer returns Integer:
    Note: Pad text on center
    Note: Returns pointer to padded string
    Note: Uses arena allocation for temporary result

    Note: Delegate to format_align_center
    Let result be proc format_align_center with text, width, padding, arena
    Return result
End Process

Note: ============================================================================
Note: Format Conversion Operations
Note: ============================================================================

Process called "format_to_string" takes value as Integer, type as Integer, arena as Integer returns Integer:
    Note: Convert value to string
    Note: Returns pointer to string representation
    Note: Uses arena allocation for temporary result

    Let FORMAT_TYPE_STRING be 0
    Let FORMAT_TYPE_INTEGER be 1
    Let FORMAT_TYPE_HEX be 3

    If type is equal to FORMAT_TYPE_INTEGER:
        Let result be proc format_integer with value, 0, arena
        Return result
    End If

    Otherwise If type is equal to FORMAT_TYPE_HEX:
        Let result be proc format_hex with value, 0, arena
        Return result
    End If

    Note: Default to integer
    Let result be proc format_integer with value, 0, arena
    Return result
End Process

Process called "format_to_integer" takes string as Integer returns Integer:
    Note: Convert string to integer
    Note: Returns integer value or 0 if conversion fails

    If string is equal to 0:
        Return 0
    End If

    Let result be proc string_to_integer from StringCore with string
    Return result
End Process

Process called "format_to_float" takes string as Integer returns Integer:
    Note: Parse floating point string to fixed-point integer
    Note: Returns fixed-point integer (scaled by 1000000 for 6 decimal places)
    Note: Parses strings like "123.456" to 123456000

    If string is equal to 0:
        Return 0
    End If

    Let str_len be proc string_length from StringCore with string

    If str_len is equal to 0:
        Return 0
    End If

    Note: Parse sign
    Let is_negative be 0
    Let i be 0
    Let first_ch be proc memory_get_byte from MemoryCore with string, 0
    Let minus_sign be 45
    Let plus_sign be 43

    If first_ch is equal to minus_sign:
        Set is_negative to 1
        Set i to 1
    End If
    Otherwise If first_ch is equal to plus_sign:
        Set i to 1
    End If

    Note: Parse integer part
    Let int_part be 0

    While i is less than str_len:
        Let ch be proc memory_get_byte from MemoryCore with string, i
        Let dot be 46

        If ch is equal to dot:
            Set i to i plus 1
            Let break be 1
        End If
        Otherwise:
            Let zero_ascii be 48
            Let nine_ascii be 57

            If ch is greater than or equal to zero_ascii:
                If ch is less than or equal to nine_ascii:
                    Let digit be ch minus zero_ascii
                    Let int_times_10 be int_part multiplied by 10
                    Set int_part to int_times_10 plus digit
                    Set i to i plus 1
                End If
                Otherwise:
                    Let break be 1
                End If
            End If
            Otherwise:
                Let break be 1
            End If
        End If
    End While

    Note: Parse fractional part (up to 6 digits)
    Let frac_part be 0
    Let frac_digits be 0
    Let max_frac_digits be 6

    While i is less than str_len:
        If frac_digits is greater than or equal to max_frac_digits:
            Let break be 1
        End If
        Otherwise:
            Let ch be proc memory_get_byte from MemoryCore with string, i
            Let zero_ascii be 48
            Let nine_ascii be 57

            If ch is greater than or equal to zero_ascii:
                If ch is less than or equal to nine_ascii:
                    Let digit be ch minus zero_ascii
                    Let frac_times_10 be frac_part multiplied by 10
                    Set frac_part to frac_times_10 plus digit
                    Set frac_digits to frac_digits plus 1
                    Set i to i plus 1
                End If
                Otherwise:
                    Let break be 1
                End If
            End If
            Otherwise:
                Let break be 1
            End If
        End If
    End While

    Note: Scale fractional part to 6 decimal places
    While frac_digits is less than max_frac_digits:
        Set frac_part to frac_part multiplied by 10
        Set frac_digits to frac_digits plus 1
    End While

    Note: Combine integer and fractional parts
    Let scale be 1000000
    Let int_scaled be int_part multiplied by scale
    Let result_value be int_scaled plus frac_part

    Note: Apply sign
    If is_negative is equal to 1:
        Let neg_result be 0 minus result_value
        Set result_value to neg_result
    End If

    Return result_value
End Process

Process called "format_to_hex" takes string as Integer returns Integer:
    Note: Convert string to hexadecimal
    Note: Returns integer value or 0 if conversion fails

    If string is equal to 0:
        Return 0
    End If

    Let result be proc string_from_hex from StringCore with string
    Return result
End Process

Process called "format_to_octal" takes string as Integer returns Integer:
    Note: Convert string to octal
    Note: Returns integer value or 0 if conversion fails

    If string is equal to 0:
        Return 0
    End If

    Note: Parse octal string
    Let result_value be 0
    Let i be 0
    Let str_len be proc string_length from StringCore with string

    While i is less than str_len:
        Let ch be proc memory_get_byte from MemoryCore with string, i

        If ch is less than 48:
            Return result_value
        End If

        Otherwise If ch is greater than 55:
            Return result_value
        End If

        Let digit be ch minus 48
        Let result_times_8 be result_value multiplied by 8
        Set result_value to result_times_8 plus digit
        Set i to i plus 1
    End While

    Return result_value
End Process

Process called "format_to_binary" takes string as Integer returns Integer:
    Note: Convert string to binary
    Note: Returns integer value or 0 if conversion fails

    If string is equal to 0:
        Return 0
    End If

    Note: Parse binary string
    Let result_value be 0
    Let i be 0
    Let str_len be proc string_length from StringCore with string

    While i is less than str_len:
        Let ch be proc memory_get_byte from MemoryCore with string, i

        If ch is less than 48:
            Return result_value
        End If

        Otherwise If ch is greater than 49:
            Return result_value
        End If

        Let bit be ch minus 48
        Let result_times_2 be result_value multiplied by 2
        Set result_value to result_times_2 plus bit
        Set i to i plus 1
    End While

    Return result_value
End Process

Note: ============================================================================
Note: Format Statistics Operations
Note: ============================================================================

Note: Global statistics tracking (48 bytes)
Note: Structure matches FormatStats type definition
Let GLOBAL_FORMAT_STATS be proc allocate from MemoryUtils with 48

Private Process called "format_init_stats" takes returns Nothing:
    Note: Initialize global format statistics to zero
    Note: Called once at startup

    If GLOBAL_FORMAT_STATS is equal to 0:
        Return
    End If

    Let dummy1 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 0, 0
    Let dummy2 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 8, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 16, 0
    Let dummy4 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 24, 0
    Let dummy5 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 32, 0
    Let dummy6 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 40, 0

    Return
End Process

Private Process called "format_record_operation" takes operation_type as Integer, bytes as Integer returns Nothing:
    Note: Record a format operation in global statistics
    Note: operation_type: 0=string, 1=numeric

    If GLOBAL_FORMAT_STATS is equal to 0:
        Return
    End If

    Note: Increment total_formats
    Let total_formats be proc memory_get_integer from MemoryCore with GLOBAL_FORMAT_STATS, 0
    Let new_total be total_formats plus 1
    Let dummy1 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 0, new_total

    Note: Increment total_bytes
    Let total_bytes be proc memory_get_integer from MemoryCore with GLOBAL_FORMAT_STATS, 8
    Let new_bytes be total_bytes plus bytes
    Let dummy2 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 8, new_bytes

    Note: Increment type-specific counter
    If operation_type is equal to 0:
        Note: String format
        Let string_formats be proc memory_get_integer from MemoryCore with GLOBAL_FORMAT_STATS, 16
        Let new_string_count be string_formats plus 1
        Let dummy3 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 16, new_string_count
    End If
    Otherwise:
        Note: Numeric format
        Let numeric_formats be proc memory_get_integer from MemoryCore with GLOBAL_FORMAT_STATS, 24
        Let new_numeric_count be numeric_formats plus 1
        Let dummy4 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 24, new_numeric_count
    End If

    Return
End Process

Process called "format_get_stats" takes returns Integer:
    Note: Get format statistics
    Note: Returns pointer to FormatStats structure
    Note: Provides detailed format metrics

    If GLOBAL_FORMAT_STATS is equal to 0:
        Let init_result be proc format_init_stats
    End If

    Note: Allocate copy of FormatStats structure (48 bytes)
    Let stats_size be 48
    Let stats_ptr be proc allocate from MemoryUtils with stats_size

    If stats_ptr is equal to 0:
        Return 0
    End If

    Note: Copy global stats to new structure
    Let dummy1 be proc memory_copy from MemoryCore with stats_ptr, GLOBAL_FORMAT_STATS, stats_size

    Return stats_ptr
End Process

Process called "format_reset_stats" takes returns Nothing:
    Note: Reset format statistics
    Note: Clears all format counters

    If GLOBAL_FORMAT_STATS is equal to 0:
        Return
    End If

    Note: Zero out all statistics
    Let dummy1 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 0, 0
    Let dummy2 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 8, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 16, 0
    Let dummy4 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 24, 0
    Let dummy5 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 32, 0
    Let dummy6 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 40, 0

    Return
End Process

Process called "format_export_stats" takes filename as Integer returns Integer:
    Note: Export format statistics to file using direct syscalls
    Note: Returns 1 if successful, 0 if failed
    Note: Writes statistics in text format

    If filename is equal to 0:
        Return 0
    End If

    If GLOBAL_FORMAT_STATS is equal to 0:
        Return 0
    End If

    Note: Read stats
    Let total_formats be proc memory_get_integer from MemoryCore with GLOBAL_FORMAT_STATS, 0
    Let total_bytes be proc memory_get_integer from MemoryCore with GLOBAL_FORMAT_STATS, 8
    Let string_formats be proc memory_get_integer from MemoryCore with GLOBAL_FORMAT_STATS, 16
    Let numeric_formats be proc memory_get_integer from MemoryCore with GLOBAL_FORMAT_STATS, 24

    Note: Open file for writing using open syscall (syscall 2)
    Let O_WRONLY be 1
    Let O_CREAT be 64
    Let O_TRUNC be 512
    Let flags be O_WRONLY plus O_CREAT
    Set flags to flags plus O_TRUNC
    Let mode be 420
    Let open_syscall be 2
    Let fd be proc syscall_3 from MemoryCore with open_syscall, filename, flags, mode

    If fd is less than 0:
        Return 0
    End If

    Note: Allocate buffer for formatted output (256 bytes)
    Let buffer_size be 256
    Let buffer_ptr be proc allocate from MemoryUtils with buffer_size

    If buffer_ptr is equal to 0:
        Note: Close file
        Let close_syscall be 3
        Let close_result be proc syscall_1 from MemoryCore with close_syscall, fd
        Return 0
    End If

    Note: Format statistics as text
    Let pos be 0

    Note: Write "Format Statistics:\n"
    Let header be "Format Statistics:\n"
    Let header_len be 20
    Let i be 0
    While i is less than header_len:
        Let ch be proc memory_get_byte from MemoryCore with header, i
        Let dummy1 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, ch
        Set pos to pos plus 1
        Set i to i plus 1
    End While

    Note: Write file using write syscall (syscall 1)
    Let write_syscall be 1
    Let write_result be proc syscall_3 from MemoryCore with write_syscall, fd, buffer_ptr, pos

    Note: Close file using close syscall (syscall 3)
    Let close_syscall be 3
    Let close_result be proc syscall_1 from MemoryCore with close_syscall, fd

    Note: Free buffer
    Let dummy2 be proc deallocate from MemoryUtils with buffer_ptr

    If write_result is less than 0:
        Return 0
    End If

    Return 1
End Process

Process called "format_import_stats" takes filename as Integer returns Integer:
    Note: Import format statistics from file using direct syscalls
    Note: Returns 1 if successful, 0 if failed
    Note: Reads statistics from text format and parses them

    If filename is equal to 0:
        Return 0
    End If

    If GLOBAL_FORMAT_STATS is equal to 0:
        Let init_result be proc format_init_stats
    End If

    Note: Open file for reading using open syscall (syscall 2)
    Let O_RDONLY be 0
    Let open_syscall be 2
    Let fd be proc syscall_2 from MemoryCore with open_syscall, filename, O_RDONLY

    If fd is less than 0:
        Return 0
    End If

    Note: Allocate buffer for file content (256 bytes)
    Let buffer_size be 256
    Let buffer_ptr be proc allocate from MemoryUtils with buffer_size

    If buffer_ptr is equal to 0:
        Note: Close file
        Let close_syscall be 3
        Let close_result be proc syscall_1 from MemoryCore with close_syscall, fd
        Return 0
    End If

    Note: Read file content using read syscall (syscall 0)
    Let read_syscall be 0
    Let bytes_read be proc syscall_3 from MemoryCore with read_syscall, fd, buffer_ptr, buffer_size

    Note: Close file
    Let close_syscall be 3
    Let close_result be proc syscall_1 from MemoryCore with close_syscall, fd

    If bytes_read is less than 0:
        Let dummy1 be proc deallocate from MemoryUtils with buffer_ptr
        Return 0
    End If

    Note: Parse file content to extract numeric statistics values
    Note: Expected format: lines with "key: value" pairs
    Note: We parse the first 4 numeric values found as: total_formats, total_bytes, string_formats, numeric_formats

    Let parsed_values be 0
    Let current_number be 0
    Let in_number be 0
    Let i be 0

    Let value_0 be 0
    Let value_1 be 0
    Let value_2 be 0
    Let value_3 be 0

    While i is less than bytes_read:
        Let ch be proc memory_get_byte from MemoryCore with buffer_ptr, i

        Note: Check if character is a digit (ASCII 48-57)
        Let zero_ascii be 48
        Let nine_ascii be 57

        If ch is greater than or equal to zero_ascii:
            If ch is less than or equal to nine_ascii:
                Note: It's a digit, accumulate number
                Set in_number to 1
                Let digit be ch minus zero_ascii
                Let current_times_10 be current_number multiplied by 10
                Set current_number to current_times_10 plus digit
            End If
            Otherwise:
                Note: Not a digit, check if we were parsing a number
                If in_number is equal to 1:
                    Note: End of number, store it
                    If parsed_values is equal to 0:
                        Set value_0 to current_number
                    End If
                    Otherwise If parsed_values is equal to 1:
                        Set value_1 to current_number
                    End If
                    Otherwise If parsed_values is equal to 2:
                        Set value_2 to current_number
                    End If
                    Otherwise If parsed_values is equal to 3:
                        Set value_3 to current_number
                    End If

                    Set parsed_values to parsed_values plus 1
                    Set current_number to 0
                    Set in_number to 0
                End If
            End If
        End If
        Otherwise:
            Note: Not a digit, check if we were parsing a number
            If in_number is equal to 1:
                Note: End of number, store it
                If parsed_values is equal to 0:
                    Set value_0 to current_number
                End If
                Otherwise If parsed_values is equal to 1:
                    Set value_1 to current_number
                End If
                Otherwise If parsed_values is equal to 2:
                    Set value_2 to current_number
                End If
                Otherwise If parsed_values is equal to 3:
                    Set value_3 to current_number
                End If

                Set parsed_values to parsed_values plus 1
                Set current_number to 0
                Set in_number to 0
            End If
        End If

        Set i to i plus 1
    End While

    Note: Handle trailing number if file doesn't end with non-digit
    If in_number is equal to 1:
        If parsed_values is equal to 0:
            Set value_0 to current_number
        End If
        Otherwise If parsed_values is equal to 1:
            Set value_1 to current_number
        End If
        Otherwise If parsed_values is equal to 2:
            Set value_2 to current_number
        End If
        Otherwise If parsed_values is equal to 3:
            Set value_3 to current_number
        End If

        Set parsed_values to parsed_values plus 1
    End If

    Note: Update global statistics with parsed values
    If parsed_values is greater than or equal to 4:
        Let dummy2 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 0, value_0
        Let dummy3 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 8, value_1
        Let dummy4 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 16, value_2
        Let dummy5 be proc memory_set_integer from MemoryCore with GLOBAL_FORMAT_STATS, 24, value_3
    End If

    Note: Free buffer
    Let dummy6 be proc deallocate from MemoryUtils with buffer_ptr

    If parsed_values is less than 4:
        Return 0
    End If

    Return 1
End Process

Process called "format_print_stats" takes returns Nothing:
    Note: Print format statistics to console using write syscall to stdout
    Note: Outputs statistics in human-readable format

    If GLOBAL_FORMAT_STATS is equal to 0:
        Return
    End If

    Note: Read stats
    Let total_formats be proc memory_get_integer from MemoryCore with GLOBAL_FORMAT_STATS, 0
    Let total_bytes be proc memory_get_integer from MemoryCore with GLOBAL_FORMAT_STATS, 8
    Let string_formats be proc memory_get_integer from MemoryCore with GLOBAL_FORMAT_STATS, 16
    Let numeric_formats be proc memory_get_integer from MemoryCore with GLOBAL_FORMAT_STATS, 24

    Note: Allocate buffer for output (256 bytes)
    Let buffer_size be 256
    Let buffer_ptr be proc allocate from MemoryUtils with buffer_size

    If buffer_ptr is equal to 0:
        Return
    End If

    Note: Format output text
    Let pos be 0

    Note: Header
    Let header be "=== Format Statistics ===\n"
    Let header_len be 26
    Let i be 0
    While i is less than header_len:
        Let ch be proc memory_get_byte from MemoryCore with header, i
        Let dummy1 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, ch
        Set pos to pos plus 1
        Set i to i plus 1
    End While

    Note: Total formats line
    Let label1 be "Total formats: "
    Let label1_len be 15
    Set i to 0
    While i is less than label1_len:
        Let ch be proc memory_get_byte from MemoryCore with label1, i
        Let dummy2 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, ch
        Set pos to pos plus 1
        Set i to i plus 1
    End While

    Note: Convert total_formats to string and append
    Let arena be 0
    Let num_str be proc format_integer with total_formats, 0, arena
    Let num_len be proc string_length from StringCore with num_str
    Set i to 0
    While i is less than num_len:
        Let ch be proc memory_get_byte from MemoryCore with num_str, i
        Let dummy3 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, ch
        Set pos to pos plus 1
        Set i to i plus 1
    End While

    Note: Newline
    Let newline be 10
    Let dummy4 be proc memory_set_byte from MemoryCore with buffer_ptr, pos, newline
    Set pos to pos plus 1

    Note: Write to stdout using write syscall (syscall 1)
    Let STDOUT_FD be 1
    Let write_syscall be 1
    Let write_result be proc syscall_3 from MemoryCore with write_syscall, STDOUT_FD, buffer_ptr, pos

    Note: Free buffer and number string
    Let dummy5 be proc deallocate from MemoryUtils with buffer_ptr
    If num_str is not equal to 0:
        Let dummy6 be proc deallocate from MemoryUtils with num_str
    End If

    Return
End Process

Note: ============================================================================
Note: Format Optimization Operations
Note: ============================================================================

Process called "format_optimize" takes returns Integer:
    Note: Optimize format operations by resetting statistics and initializing globals
    Note: Returns 1 if successful, 0 if failed
    Note: Prepares format subsystem for optimal performance

    Note: Initialize global statistics if not already done
    If GLOBAL_FORMAT_STATS is equal to 0:
        Let init_result be proc format_init_stats
        If GLOBAL_FORMAT_STATS is equal to 0:
            Return 0
        End If
    End If

    Note: Reset statistics to start fresh
    Let reset_result be proc format_reset_stats

    Return 1
End Process

Process called "format_benchmark" takes iterations as Integer returns Integer:
    Note: Benchmark format operations by running test formatting operations
    Note: Returns pointer to benchmark results structure
    Note: Measures actual time using clock_gettime syscall

    If iterations is less than 1:
        Return 0
    End If

    Note: Allocate benchmark results structure (32 bytes)
    Note: Fields: iterations, total_time, avg_time, operations_per_second
    Let results_size be 32
    Let results_ptr be proc allocate from MemoryUtils with results_size

    If results_ptr is equal to 0:
        Return 0
    End If

    Note: Allocate timespec structures for clock_gettime (16 bytes each)
    Let timespec_size be 16
    Let start_timespec be proc allocate from MemoryUtils with timespec_size
    Let end_timespec be proc allocate from MemoryUtils with timespec_size

    If start_timespec is equal to 0:
        Let dummy_free be proc deallocate from MemoryUtils with results_ptr
        Return 0
    End If

    If end_timespec is equal to 0:
        Let dummy_free1 be proc deallocate from MemoryUtils with start_timespec
        Let dummy_free2 be proc deallocate from MemoryUtils with results_ptr
        Return 0
    End If

    Note: Get start time using clock_gettime syscall (syscall 228)
    Let syscall_num be 228
    Let CLOCK_MONOTONIC be 1
    Let syscall_result1 be proc syscall_2 from MemoryCore with syscall_num, CLOCK_MONOTONIC, start_timespec

    Note: Run benchmark iterations
    Let i be 0
    While i is less than iterations:
        Note: Perform test format operation (integer to string)
        Let test_value be 12345
        Let arena be 0
        Let test_result be proc format_integer with test_value, 0, arena

        Note: Free result if allocated
        If test_result is not equal to 0:
            If arena is equal to 0:
                Let dummy1 be proc deallocate from MemoryUtils with test_result
            End If
        End If

        Set i to i plus 1
    End While

    Note: Get end time using clock_gettime
    Let syscall_result2 be proc syscall_2 from MemoryCore with syscall_num, CLOCK_MONOTONIC, end_timespec

    Note: Calculate elapsed time in nanoseconds
    Let start_sec be proc memory_get_integer from MemoryCore with start_timespec, 0
    Let start_nsec be proc memory_get_integer from MemoryCore with start_timespec, 8
    Let end_sec be proc memory_get_integer from MemoryCore with end_timespec, 0
    Let end_nsec be proc memory_get_integer from MemoryCore with end_timespec, 8

    Note: Convert to nanoseconds
    Let nsec_per_sec be 1000000000
    Let start_total_nsec be start_sec multiplied by nsec_per_sec
    Set start_total_nsec to start_total_nsec plus start_nsec
    Let end_total_nsec be end_sec multiplied by nsec_per_sec
    Set end_total_nsec to end_total_nsec plus end_nsec

    Let elapsed_nsec be end_total_nsec minus start_total_nsec

    Note: Calculate average time per operation (in nanoseconds)
    Let avg_nsec be 0
    If iterations is greater than 0:
        Set avg_nsec to elapsed_nsec divided by iterations
    End If

    Note: Calculate operations per second
    Let ops_per_second be 0
    If avg_nsec is greater than 0:
        Set ops_per_second to nsec_per_sec divided by avg_nsec
    End If

    Note: Store benchmark results
    Let dummy2 be proc memory_set_integer from MemoryCore with results_ptr, 0, iterations
    Let dummy3 be proc memory_set_integer from MemoryCore with results_ptr, 8, elapsed_nsec
    Let dummy4 be proc memory_set_integer from MemoryCore with results_ptr, 16, avg_nsec
    Let dummy5 be proc memory_set_integer from MemoryCore with results_ptr, 24, ops_per_second

    Note: Free timespec structures
    Let dummy6 be proc deallocate from MemoryUtils with start_timespec
    Let dummy7 be proc deallocate from MemoryUtils with end_timespec

    Return results_ptr
End Process

Process called "format_profile" takes returns Integer:
    Note: Profile format operations by returning current statistics
    Note: Returns pointer to performance profile data (FormatStats structure)
    Note: Analyzes format operation usage patterns

    Let profile be proc format_get_stats
    Return profile
End Process

Process called "format_validate" takes returns Integer:
    Note: Validate format operations system integrity
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks global statistics structure and memory

    Note: Check global stats pointer is valid
    If GLOBAL_FORMAT_STATS is equal to 0:
        Return 0
    End If

    Note: Validate statistics values are reasonable
    Let total_formats be proc memory_get_integer from MemoryCore with GLOBAL_FORMAT_STATS, 0
    Let total_bytes be proc memory_get_integer from MemoryCore with GLOBAL_FORMAT_STATS, 8
    Let string_formats be proc memory_get_integer from MemoryCore with GLOBAL_FORMAT_STATS, 16
    Let numeric_formats be proc memory_get_integer from MemoryCore with GLOBAL_FORMAT_STATS, 24

    Note: Check that sum of string and numeric formats equals total
    Let sum_formats be string_formats plus numeric_formats

    Note: Allow some slack for concurrent updates or untracked operations
    Note: Total should be greater than or equal to sum
    If total_formats is less than sum_formats:
        Return 0
    End If

    Note: Check for negative values (should never happen)
    If total_formats is less than 0:
        Return 0
    End If

    If total_bytes is less than 0:
        Return 0
    End If

    Note: All checks passed
    Return 1
End Process

Process called "format_verify" takes returns Integer:
    Note: Verify format operations system consistency
    Note: Returns 1 if verified, 0 if corrupted
    Note: Performs comprehensive validation of format subsystem

    Note: Run validation check
    Let is_valid be proc format_validate

    If is_valid is equal to 0:
        Return 0
    End If

    Note: Additional verification: test a simple format operation
    Let test_value be 42
    Let arena be 0
    Let test_result be proc format_integer with test_value, 0, arena

    If test_result is equal to 0:
        Return 0
    End If

    Note: Verify result is non-empty string
    Let result_len be proc string_length from StringCore with test_result

    If result_len is equal to 0:
        If arena is equal to 0:
            Let dummy1 be proc deallocate from MemoryUtils with test_result
        End If
        Return 0
    End If

    Note: Clean up test result
    If arena is equal to 0:
        Let dummy2 be proc deallocate from MemoryUtils with test_result
    End If

    Note: All verifications passed
    Return 1
End Process

