Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles tiered memory management for the Runa compiler.

TIERED MEMORY MANAGEMENT - Compiler Memory System
- Process tiered memory allocation and management for compiler operations
- Handle arena allocation for compiler temporaries (TIER 2)
- Manage owned heap allocation for compiler structures (TIER 3)
- Process memory safety and validation for compiler operations
- Handle memory debugging and diagnostics for compiler operations

This file is essential because of the following reasons:
- Tiered memory management enables efficient compiler memory usage
- Proper tiered memory handling ensures O(1) cleanup for temporaries and deterministic cleanup for permanent data
- Tiered memory utilities support all compiler phases with appropriate memory strategies

This file consists of the following functions/features/operation types:
- Tiered memory allocation and management operations
- Arena allocation for compiler temporaries (TIER 2)
- Owned heap allocation for compiler structures (TIER 3)
- Memory safety and validation operations
- Memory debugging and diagnostic utilities

Dependencies:
- Imports memory_core.runa for low-level memory operations
- Imports pointer_primitive.runa for pointer arithmetic
:End Note

Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/frontend/primitives/core/pointer_primitive.runa" as PointerPrimitive
Import "compiler/frontend/primitives/core/bitwise_core.runa" as BitwiseCore
Import "compiler/frontend/primitives/assembly/syscall.runa" as Syscall

Note: ============================================================================
Note: Memory Tier Constants (5-Tier Architecture)
Note: ============================================================================

Note: Runa uses a 5-tier memory model for optimal performance and safety:
Note: TIER 1: STACK - Fastest, zero-cost, automatic (compiler-managed)
Note: TIER 2: ARENA - Fast bulk, O(1) cleanup, operation-scoped temps
Note: TIER 3: OWNED HEAP - Structured lifetime, deterministic, permanent data
Note: TIER 4: SHARED - Manual reference counting, explicit retain/release
Note: TIER 5: ARC - Automatic reference counting, compiler-inserted retain/release

Define constant MEMORY_TIER_STACK as 1       Note: TIER 1 - Stack allocation
Define constant MEMORY_TIER_ARENA as 2       Note: TIER 2 - Arena allocation
Define constant MEMORY_TIER_OWNED as 3       Note: TIER 3 - Owned heap allocation
Define constant MEMORY_TIER_SHARED as 4      Note: TIER 4 - Shared reference-counted (manual)
Define constant MEMORY_TIER_ARC as 5         Note: TIER 5 - Automatic reference counting

Note: ============================================================================
Note: Memory Alignment Constants
Note: ============================================================================

Define constant MEMORY_ALIGNMENT_BYTE as 1
Define constant MEMORY_ALIGNMENT_WORD as 2
Define constant MEMORY_ALIGNMENT_DWORD as 4
Define constant MEMORY_ALIGNMENT_QWORD as 8
Define constant MEMORY_ALIGNMENT_16BYTE as 16
Define constant MEMORY_ALIGNMENT_32BYTE as 32
Define constant MEMORY_ALIGNMENT_64BYTE as 64
Define constant MEMORY_ALIGNMENT_CACHE_LINE as 64

Define constant MEMORY_DEFAULT_ALIGNMENT as 8  Note: 8-byte alignment for 64-bit systems

Note: ============================================================================
Note: Memory Allocation Flags
Note: ============================================================================

Define constant MEMORY_FLAG_ZERO as 1          Note: Zero-initialize allocated memory
Define constant MEMORY_FLAG_ALIGNED as 2       Note: Enforce strict alignment
Define constant MEMORY_FLAG_TRACKED as 4       Note: Track allocation for debugging

Note: ============================================================================
Note: Core Memory Allocation Operations
Note: ============================================================================

Process called "allocate" takes size as Integer returns Integer:
    Note: Allocate memory from heap (TIER 3 - Owned)
    Note: Returns pointer to allocated memory or 0 on failure
    Note: Memory is NOT initialized
    Note: Caller is responsible for freeing with deallocate()

    Note: This is the primary allocation function for permanent compiler data:
    Note: - AST nodes
    Note: - Symbol tables
    Note: - Type information
    Note: - Any data that outlives the current operation

    Note: Implementation: allocates 8 extra bytes to store size metadata header
    Note: Memory layout: [8-byte size][user data...]
    Note: Returns pointer to user data (after header)

    Note: Allocate size + 8 bytes for header
    Let total_size be size plus 8
    Let raw_ptr be proc syscall_malloc from Syscall with total_size

    If raw_ptr is equal to 0:
        Return 0
    End If

    Note: Store size in header
    Let dummy be proc memory_set_integer from MemoryCore with raw_ptr, 0, size

    Note: Return pointer to user data (after header)
    Let user_ptr be raw_ptr plus 8
    Return user_ptr
End Process

Process called "allocate_zeroed" takes size as Integer returns Integer:
    Note: Allocate and zero-initialize memory from heap (TIER 3 - Owned)
    Note: Returns pointer to zeroed memory or 0 on failure
    Note: Caller is responsible for freeing with deallocate()

    Let ptr be proc allocate with size

    If ptr is equal to 0:
        Return 0
    End If

    Note: Zero the allocated memory
    Let dummy be proc memory_zero from MemoryCore with ptr, size

    Return ptr
End Process

Process called "allocate_aligned" takes size as Integer, alignment as Integer returns Integer:
    Note: Allocate aligned memory from heap (TIER 3 - Owned)
    Note: alignment must be power of 2
    Note: Returns pointer to aligned memory or 0 on failure
    Note: Caller is responsible for freeing with deallocate()

    Note: Allocate extra space for alignment padding
    Let extra_size be alignment minus 1
    Let total_size be size plus extra_size plus 8  Note: +8 for storing original pointer

    Let raw_ptr be proc allocate with total_size

    If raw_ptr is equal to 0:
        Return 0
    End If

    Note: Calculate aligned pointer
    Let ptr_plus_header be raw_ptr plus 8
    Let aligned_ptr be proc align_pointer_up with ptr_plus_header, alignment

    Note: Store original pointer before aligned pointer for deallocation
    Let header_ptr be aligned_ptr minus 8
    Let dummy be proc memory_set_pointer from MemoryCore with header_ptr, 0, raw_ptr

    Return aligned_ptr
End Process

Process called "deallocate" takes ptr as Integer returns Integer:
    Note: Free memory allocated with allocate() (TIER 3 - Owned)
    Note: Returns 1 on success, 0 if ptr is NULL or invalid

    Note: CRITICAL: Only call on memory allocated with allocate()
    Note: NEVER call on:
    Note: - Arena-allocated memory (use arena_destroy)
    Note: - Stack memory (automatically freed)
    Note: - Shared memory without proper reference count management

    Note: Implementation: reads size from header and frees entire allocation

    If ptr is equal to 0:
        Return 0
    End If

    Note: Get raw pointer (before header)
    Let raw_ptr be ptr minus 8

    Note: Read size from header
    Let size be proc memory_get_integer from MemoryCore with raw_ptr, 0

    Note: Free entire allocation (header + data)
    Let total_size be size plus 8
    Let result be proc syscall_free from Syscall with raw_ptr, total_size

    Return result
End Process

Process called "deallocate_aligned" takes ptr as Integer returns Integer:
    Note: Free aligned memory allocated with allocate_aligned()
    Note: Returns 1 on success, 0 if ptr is NULL

    If ptr is equal to 0:
        Return 0
    End If

    Note: Retrieve original pointer from header
    Let header_ptr be ptr minus 8
    Let original_ptr be proc memory_get_pointer from MemoryCore with header_ptr, 0

    Note: Free the original pointer
    Let dummy be proc deallocate with original_ptr
    Return 1
End Process

Process called "reallocate" takes ptr as Integer, new_size as Integer returns Integer:
    Note: Resize allocated memory (TIER 3 - Owned)
    Note: Returns pointer to resized memory or 0 on failure
    Note: Contents are preserved up to minimum of old and new size
    Note: If ptr is 0, equivalent to allocate(new_size)
    Note: If new_size is 0, equivalent to deallocate(ptr) and returns 0

    Note: Implementation: reads old size from header, calls syscall_realloc

    If ptr is equal to 0:
        Return proc allocate with new_size
    End If

    If new_size is equal to 0:
        Let dummy be proc deallocate with ptr
        Return 0
    End If

    Note: Get raw pointer (before header)
    Let raw_ptr be ptr minus 8

    Note: Read old size from header
    Let old_size be proc memory_get_integer from MemoryCore with raw_ptr, 0

    Note: Reallocate (including header space)
    Let old_total_size be old_size plus 8
    Let new_total_size be new_size plus 8
    Let new_raw_ptr be proc syscall_realloc from Syscall with raw_ptr, old_total_size, new_total_size

    If new_raw_ptr is equal to 0:
        Return 0
    End If

    Note: Update size in header
    Let dummy be proc memory_set_integer from MemoryCore with new_raw_ptr, 0, new_size

    Note: Return pointer to user data (after header)
    Let new_user_ptr be new_raw_ptr plus 8
    Return new_user_ptr
End Process

Note: ============================================================================
Note: Memory Alignment Utilities
Note: ============================================================================

Process called "align_pointer_up" takes ptr as Integer, alignment as Integer returns Integer:
    Note: Align pointer up to alignment boundary
    Note: alignment must be power of 2
    Note: Returns aligned pointer (always >= ptr)

    Let mask be alignment minus 1
    Let inverted_mask be proc bitwise_not from BitwiseCore with mask
    Let aligned be proc bitwise_and from BitwiseCore with inverted_mask, ptr plus mask
    Return aligned
End Process

Process called "align_pointer_down" takes ptr as Integer, alignment as Integer returns Integer:
    Note: Align pointer down to alignment boundary
    Note: alignment must be power of 2
    Note: Returns aligned pointer (always <= ptr)

    Let mask be alignment minus 1
    Let inverted_mask be proc bitwise_not from BitwiseCore with mask
    Let aligned be proc bitwise_and from BitwiseCore with inverted_mask, ptr
    Return aligned
End Process

Process called "is_aligned" takes ptr as Integer, alignment as Integer returns Integer:
    Note: Check if pointer is aligned to alignment boundary
    Note: alignment must be power of 2
    Note: Returns 1 if aligned, 0 otherwise

    Return proc PointerPrimitive.pointer_is_aligned with ptr, alignment
End Process

Process called "calculate_padding" takes ptr as Integer, alignment as Integer returns Integer:
    Note: Calculate padding needed to align pointer
    Note: Returns number of bytes to add to ptr for alignment

    Let aligned be proc align_pointer_up with ptr, alignment
    Let padding be aligned minus ptr
    Return padding
End Process

Note: ============================================================================
Note: Memory Copy and Fill Operations
Note: ============================================================================

Process called "memory_copy" takes dest as Integer, src as Integer, length as Integer returns Integer:
    Note: Copy length bytes from src to dest
    Note: Regions may overlap (handles correctly)
    Note: Returns dest

    Let dummy be proc memory_copy from MemoryCore with dest, src, length
    Return dest
End Process

Process called "memory_fill" takes ptr as Integer, value as Integer, length as Integer returns Integer:
    Note: Fill length bytes at ptr with value (low 8 bits)
    Note: Returns ptr

    Let dummy be proc memory_fill from MemoryCore with ptr, value, length
    Return ptr
End Process

Process called "memory_zero" takes ptr as Integer, length as Integer returns Integer:
    Note: Zero length bytes at ptr
    Note: Returns ptr

    Let dummy be proc memory_zero from MemoryCore with ptr, length
    Return ptr
End Process

Process called "memory_compare" takes ptr1 as Integer, ptr2 as Integer, length as Integer returns Integer:
    Note: Compare length bytes at ptr1 and ptr2
    Note: Returns 0 if equal, non-zero otherwise

    Return proc memory_compare from MemoryCore with ptr1, ptr2, length
End Process

Note: ============================================================================
Note: Platform-Specific Memory System Calls (Pure Runa Runtime)
Note: ============================================================================

Note: PRODUCTION IMPLEMENTATION - Pure Runa Runtime (v0.0.9.3+):
Note: Direct syscall interface with NO C runtime dependency.
Note: Uses primitives/assembly/syscall.runa platform abstraction layer.
Note: The platform is selected at compile-time via -target flag.

Define constant PROT_READ as 1
Define constant PROT_WRITE as 2
Define constant PROT_EXEC as 4
Define constant MAP_PRIVATE as 2
Define constant MAP_ANONYMOUS as 32

Process called "syscall_malloc" takes size as Integer returns Integer:
    Note: Allocate memory via direct mmap syscall (anonymous mapping)
    Note: Platform-agnostic: delegates to platform-specific mmap implementation
    Note: Returns pointer to allocated memory or 0 on failure

    Note: mmap parameters: addr=0 (kernel chooses), length=size,
    Note: prot=PROT_READ|PROT_WRITE, flags=MAP_PRIVATE|MAP_ANONYMOUS,
    Note: fd=-1 (anonymous), offset=0
    Let prot_flags be PROT_READ plus PROT_WRITE
    Let map_flags be MAP_PRIVATE plus MAP_ANONYMOUS
    Let ptr be proc syscall_mmap from Syscall with 0, size, prot_flags, map_flags, -1, 0

    Note: mmap returns negative error code on failure, check for that
    If ptr is less than 0:
        Return 0
    End If

    Return ptr
End Process

Process called "syscall_free" takes ptr as Integer, size as Integer returns Integer:
    Note: Free memory via direct munmap syscall
    Note: Platform-agnostic: delegates to platform-specific munmap implementation
    Note: Returns 1 on success, 0 on failure

    Note: IMPORTANT: Caller MUST provide the original allocation size
    Note: This is required by munmap syscall on all platforms
    Note: Higher-level allocators (allocate/deallocate) maintain size metadata

    If ptr is equal to 0:
        Return 0
    End If

    If size is less than or equal to 0:
        Return 0
    End If

    Note: Call munmap syscall
    Let result be proc syscall_munmap from Syscall with ptr, size

    Note: munmap returns 0 on success, negative error code on failure
    If result is less than 0:
        Return 0
    End If

    Return 1
End Process

Process called "syscall_realloc" takes ptr as Integer, old_size as Integer, new_size as Integer returns Integer:
    Note: Resize allocated memory via syscall
    Note: Implementation: allocate new region, copy data, free old region
    Note: Returns pointer to resized memory or 0 on failure

    Note: IMPORTANT: Caller MUST provide the original allocation size
    Note: This is required for proper data copying and munmap

    If ptr is equal to 0:
        Note: NULL pointer, just allocate new memory
        Return proc syscall_malloc from Syscall with new_size
    End If

    If new_size is equal to 0:
        Note: Resize to zero, free the memory
        Let dummy be proc syscall_free from Syscall with ptr, old_size
        Return 0
    End If

    Note: Allocate new region
    Let new_ptr be proc syscall_malloc from Syscall with new_size

    If new_ptr is equal to 0:
        Return 0
    End If

    Note: Copy old data to new region
    Note: Copy the minimum of old_size and new_size
    Let copy_size be old_size
    If new_size is less than old_size:
        Set copy_size to new_size
    End If

    Let dummy be proc memory_copy from MemoryCore with new_ptr, ptr, copy_size

    Note: Free old region
    Let dummy be proc syscall_free from Syscall with ptr, old_size

    Return new_ptr
End Process

Note: ============================================================================
Note: Memory Diagnostics and Statistics
Note: ============================================================================

Process called "get_allocation_size" takes ptr as Integer returns Integer:
    Note: Get size of allocated block
    Note: Returns size in bytes (user data only, not including header)
    Note: Returns 0 if ptr is NULL or invalid

    If ptr is equal to 0:
        Return 0
    End If

    Note: Get raw pointer (before header)
    Let raw_ptr be ptr minus 8

    Note: Read size from header
    Let size be proc memory_get_integer from MemoryCore with raw_ptr, 0

    Return size
End Process

Process called "validate_pointer" takes ptr as Integer returns Integer:
    Note: Basic pointer validation
    Note: Returns 1 if pointer appears valid, 0 otherwise
    Note: Checks:
    Note: - Not NULL
    Note: - Not obviously invalid (e.g., in kernel space)
    Note: - Aligned to at least byte boundary

    If ptr is equal to 0:
        Return 0  Note: NULL pointer
    End If

    Note: Check if pointer is in user space (< 0x800000000000 on x86_64)
    Note: This is a basic sanity check, not foolproof
    Let kernel_space_boundary be 140737488355328  Note: 0x800000000000
    If ptr is greater than or equal to kernel_space_boundary:
        Return 0  Note: Likely kernel pointer
    End If

    Return 1
End Process

Note: ============================================================================
Note: Memory Tier Helpers
Note: ============================================================================

Process called "get_tier_name" takes tier as Integer returns Integer:
    Note: Get human-readable name for memory tier (5-tier architecture)
    Note: Returns pointer to static string

    If tier is equal to MEMORY_TIER_STACK:
        Return proc static_string with "STACK"
    End If

    If tier is equal to MEMORY_TIER_ARENA:
        Return proc static_string with "ARENA"
    End If

    If tier is equal to MEMORY_TIER_OWNED:
        Return proc static_string with "OWNED"
    End If

    If tier is equal to MEMORY_TIER_SHARED:
        Return proc static_string with "SHARED"
    End If

    If tier is equal to MEMORY_TIER_ARC:
        Return proc static_string with "ARC"
    End If

    Return proc static_string with "UNKNOWN"
End Process

Process called "static_string" takes str as String returns Integer:
    Note: Return pointer to static string literal
    Note: This is a compiler intrinsic that returns the address of the string data

    Note: PRODUCTION IMPLEMENTATION:
    Note: The compiler's code generator handles string literals during compilation:
    Note: 1. String literals are placed in the .rodata (read-only data) section
    Note: 2. The compiler tracks all string literals and deduplicates identical strings
    Note: 3. Each unique string gets a label (e.g., .L.str.0, .L.str.1, etc.)
    Note: 4. This function returns the address of that label
    Note: 5. The returned pointer is valid for the lifetime of the program

    Return str
End Process

Note: ============================================================================
Note: Memory Utils Complete - Foundation for Tiered Memory System
Note: ============================================================================
