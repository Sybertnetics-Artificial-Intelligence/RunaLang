Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles threading utilities and concurrency operations for the Runa compiler internal system.

THREAD UTILITIES - Compiler Threading and Concurrency Engine
- Process thread creation and thread management operations for parallel compilation
- Handle mutex operations and synchronization primitives for thread safety
- Manage channel operations and thread communication for compiler pipelines
- Process thread lifecycle and thread joining for compilation coordination
- Handle integration with Linux threading syscalls (clone, futex)

This file is essential because of the following reasons:
- Threading enables parallel compilation for faster build times
- Proper synchronization ensures thread-safe compiler data structures
- Thread utilities support concurrent code generation and optimization passes
- Threading primitives provide foundation for multi-core compiler performance

This file consists of the following functions/features/operation types:
- Thread creation using clone syscall with proper stack allocation
- Mutex operations using futex syscall for efficient synchronization
- Channel operations for thread communication and data passing
- Thread joining and lifecycle management
- Integration with compiler phases for parallel compilation

Dependencies:
- Imports memory_utils.runa for thread stack allocation
- Imports arena_utils.runa for thread-local allocations
- Imports thread_core.runa for platform-agnostic thread operations
- Imports sync_core.runa for platform-agnostic synchronization primitives
- Platform-agnostic: delegates to platform-specific implementations
:End Note

Import "compiler/internal/memory_utils.runa" as MemoryUtils
Import "compiler/internal/arena_utils.runa" as ArenaUtils
Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/frontend/primitives/threading/thread_core.runa" as ThreadCore
Import "compiler/frontend/primitives/threading/sync_core.runa" as SyncCore

Note: ============================================================================
Note: Thread and Channel Structures
Note: ============================================================================

Note: Thread structure (internal wrapper around platform thread)
Note: Structure: 56 bytes
Note: offset 0: platform_thread_id (8 bytes) - platform-specific thread handle
Note: offset 8: stack_pointer (8 bytes) - managed by platform
Note: offset 16: stack_size (8 bytes) - managed by platform
Note: offset 24: function_ptr (8 bytes) - thread function pointer
Note: offset 32: argument_ptr (8 bytes) - argument to thread function
Note: offset 40: is_running (8 bytes) - boolean: 1 if running
Note: offset 48: exit_code (8 bytes) - thread exit code

Note: Mutex: Platform-agnostic (managed by SyncCore)

Type called "Channel":
    buffer as Integer        Note: Pointer to message buffer
    capacity as Integer      Note: Maximum number of messages
    size as Integer          Note: Current number of messages
    head as Integer          Note: Read position
    tail as Integer          Note: Write position
    mutex as Integer         Note: Pointer to platform-agnostic Mutex
    not_empty as Integer     Note: Pointer to semaphore for reader waiting
    not_full as Integer      Note: Pointer to semaphore for writer waiting

Note: ============================================================================
Note: Channel Configuration
Note: ============================================================================

Constant CHANNEL_DEFAULT_CAPACITY as 16

Note: ============================================================================
Note: Thread Creation and Management
Note: ============================================================================

Process called "thread_create" takes function_ptr as Integer, argument_ptr as Integer returns Integer:
    Note: Create new thread (platform-agnostic)
    Note: function_ptr is pointer to thread function: fn(arg) -> int
    Note: argument_ptr is pointer to argument passed to function
    Note: Returns pointer to Thread structure, 0 if failed
    Note: Delegates to ThreadCore for platform-specific implementation

    Note: Allocate Thread structure (56 bytes)
    Let thread_size be 56
    Let thread_ptr be proc allocate from MemoryUtils with thread_size

    If thread_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize Thread structure
    Let dummy1 be proc memory_set_integer from MemoryCore with thread_ptr, 8, 0   Note: stack_pointer (managed by platform)
    Let dummy2 be proc memory_set_integer from MemoryCore with thread_ptr, 16, 0  Note: stack_size (managed by platform)
    Let dummy3 be proc memory_set_integer from MemoryCore with thread_ptr, 24, function_ptr
    Let dummy4 be proc memory_set_integer from MemoryCore with thread_ptr, 32, argument_ptr
    Let dummy5 be proc memory_set_integer from MemoryCore with thread_ptr, 40, 1  Note: is_running = 1
    Let dummy6 be proc memory_set_integer from MemoryCore with thread_ptr, 48, 0  Note: exit_code = 0

    Note: Create platform-agnostic thread using ThreadCore
    Let platform_thread_id be proc thread_create from ThreadCore with function_ptr, argument_ptr

    Note: Check for error
    If platform_thread_id is equal to 0:
        Let dealloc1 be proc deallocate from MemoryUtils with thread_ptr
        Return 0
    End If

    Note: Store platform thread ID in thread structure
    Let dummy7 be proc memory_set_integer from MemoryCore with thread_ptr, 0, platform_thread_id

    Return thread_ptr
End Process

Process called "thread_join" takes thread as Integer returns Integer:
    Note: Wait for thread to complete (platform-agnostic)
    Note: Returns thread exit code, -1 if failed
    Note: Delegates to ThreadCore for platform-specific implementation

    If thread is equal to 0:
        Return -1
    End If

    Note: Get platform thread ID from thread structure
    Let platform_thread_id be proc memory_get_integer from MemoryCore with thread, 0

    Note: Join thread using platform-agnostic ThreadCore
    Let exit_code be proc thread_join from ThreadCore with platform_thread_id

    Note: Mark thread as not running
    Let dummy1 be proc memory_set_integer from MemoryCore with thread, 40, 0

    Note: Store exit code
    Let dummy2 be proc memory_set_integer from MemoryCore with thread, 48, exit_code

    Note: Cleanup thread structure
    Let dealloc1 be proc deallocate from MemoryUtils with thread

    Return exit_code
End Process

Note: ============================================================================
Note: Mutex Operations (Platform-Agnostic)
Note: ============================================================================

Process called "mutex_create" takes returns Integer:
    Note: Create new mutex (platform-agnostic)
    Note: Returns pointer to Mutex wrapper structure
    Note: Delegates to SyncCore for platform-specific implementation

    Note: Create platform-agnostic mutex using SyncCore
    Let platform_mutex_ptr be proc mutex_create from SyncCore

    Return platform_mutex_ptr
End Process

Process called "mutex_destroy" takes mutex as Integer returns Nothing:
    Note: Destroy mutex (platform-agnostic)
    Note: WARNING: Caller must ensure no threads are waiting on mutex
    Note: Delegates to SyncCore for platform-specific implementation

    If mutex is equal to 0:
        Return
    End If

    Let dummy_result be proc mutex_destroy from SyncCore with mutex
    Return
End Process

Process called "mutex_lock" takes mutex as Integer returns Integer:
    Note: Acquire mutex lock (platform-agnostic)
    Note: Returns 1 if successful, 0 if failed
    Note: Delegates to SyncCore for platform-specific implementation

    Return proc mutex_lock from SyncCore with mutex
End Process

Process called "mutex_unlock" takes mutex as Integer returns Integer:
    Note: Release mutex lock (platform-agnostic)
    Note: Returns 1 if successful, 0 if failed
    Note: Delegates to SyncCore for platform-specific implementation

    Return proc mutex_unlock from SyncCore with mutex
End Process

Note: ============================================================================
Note: Channel Operations (Thread Communication)
Note: ============================================================================

Process called "channel_create" takes capacity as Integer returns Integer:
    Note: Create bounded channel for thread communication
    Note: capacity is maximum number of messages in channel
    Note: Returns pointer to Channel structure

    Let use_capacity be capacity
    If use_capacity is less than or equal to 0:
        Set use_capacity to CHANNEL_DEFAULT_CAPACITY
    End If

    Note: Allocate Channel structure (64 bytes: buffer, capacity, size, head, tail, mutex, not_empty, not_full)
    Let channel_size be 64
    Let channel_ptr be proc allocate from MemoryUtils with channel_size

    If channel_ptr is equal to 0:
        Return 0
    End If

    Note: Allocate message buffer (capacity * 8 bytes for pointers)
    Let buffer_size be use_capacity multiplied by 8
    Let buffer_ptr be proc allocate from MemoryUtils with buffer_size

    If buffer_ptr is equal to 0:
        Let dealloc1 be proc deallocate from MemoryUtils with channel_ptr
        Return 0
    End If

    Note: Zero buffer
    Let dummy_zero be proc memory_zero from MemoryCore with buffer_ptr, buffer_size

    Note: Create mutex for synchronization
    Let mutex_ptr be proc mutex_create

    If mutex_ptr is equal to 0:
        Let dealloc2 be proc deallocate from MemoryUtils with buffer_ptr
        Let dealloc3 be proc deallocate from MemoryUtils with channel_ptr
        Return 0
    End If

    Note: Create not_empty semaphore (starts at 0 - no items available)
    Let not_empty_sem be proc semaphore_create from SyncCore with 0
    If not_empty_sem is equal to 0:
        Let destroy1 be proc mutex_destroy with mutex_ptr
        Let dealloc4 be proc deallocate from MemoryUtils with buffer_ptr
        Let dealloc5 be proc deallocate from MemoryUtils with channel_ptr
        Return 0
    End If

    Note: Create not_full semaphore (starts at capacity - all slots available)
    Let not_full_sem be proc semaphore_create from SyncCore with use_capacity
    If not_full_sem is equal to 0:
        Let destroy_sem1 be proc semaphore_destroy from SyncCore with not_empty_sem
        Let destroy2 be proc mutex_destroy with mutex_ptr
        Let dealloc7 be proc deallocate from MemoryUtils with buffer_ptr
        Let dealloc8 be proc deallocate from MemoryUtils with channel_ptr
        Return 0
    End If

    Note: Initialize Channel structure
    Let dummy1 be proc memory_set_integer from MemoryCore with channel_ptr, 0, buffer_ptr
    Let dummy2 be proc memory_set_integer from MemoryCore with channel_ptr, 8, use_capacity
    Let dummy3 be proc memory_set_integer from MemoryCore with channel_ptr, 16, 0  Note: size = 0
    Let dummy4 be proc memory_set_integer from MemoryCore with channel_ptr, 24, 0  Note: head = 0
    Let dummy5 be proc memory_set_integer from MemoryCore with channel_ptr, 32, 0  Note: tail = 0
    Let dummy6 be proc memory_set_integer from MemoryCore with channel_ptr, 40, mutex_ptr
    Let dummy7 be proc memory_set_integer from MemoryCore with channel_ptr, 48, not_empty_sem
    Let dummy8 be proc memory_set_integer from MemoryCore with channel_ptr, 56, not_full_sem

    Return channel_ptr
End Process

Process called "channel_send" takes channel as Integer, message as Integer returns Integer:
    Note: Send message through channel (platform-agnostic blocking)
    Note: message is pointer to data to send
    Note: Returns 1 if successful, 0 if failed
    Note: Uses semaphores for cross-platform synchronization

    If channel is equal to 0:
        Return 0
    End If

    Note: Get semaphores and mutex
    Let not_full_sem be proc memory_get_integer from MemoryCore with channel, 56
    Let mutex_ptr be proc memory_get_integer from MemoryCore with channel, 40
    Let not_empty_sem be proc memory_get_integer from MemoryCore with channel, 48

    Note: Wait for available slot (decrement not_full semaphore)
    Note: This blocks if channel is full
    Let wait_result be proc semaphore_wait from SyncCore with not_full_sem
    If wait_result is equal to 0:
        Return 0
    End If

    Note: Acquire mutex for exclusive access to buffer
    Let lock_result be proc mutex_lock with mutex_ptr
    If lock_result is equal to 0:
        Note: Failed to lock, signal not_full to restore semaphore
        Let signal_restore be proc semaphore_signal from SyncCore with not_full_sem
        Return 0
    End If

    Note: Add message to buffer at tail position
    Let buffer_ptr be proc memory_get_integer from MemoryCore with channel, 0
    Let tail be proc memory_get_integer from MemoryCore with channel, 32
    Let capacity be proc memory_get_integer from MemoryCore with channel, 8
    Let tail_offset be tail multiplied by 8
    Let dummy1 be proc memory_set_integer from MemoryCore with buffer_ptr, tail_offset, message

    Note: Update tail (wrap around)
    Let new_tail be tail plus 1
    If new_tail is greater than or equal to capacity:
        Set new_tail to 0
    End If
    Let dummy2 be proc memory_set_integer from MemoryCore with channel, 32, new_tail

    Note: Update size
    Let size be proc memory_get_integer from MemoryCore with channel, 16
    Let new_size be size plus 1
    Let dummy3 be proc memory_set_integer from MemoryCore with channel, 16, new_size

    Note: Release mutex
    Let unlock_result be proc mutex_unlock with mutex_ptr

    Note: Signal not_empty semaphore (wake receiver)
    Let signal_result be proc semaphore_signal from SyncCore with not_empty_sem

    Return 1
End Process

Process called "channel_receive" takes channel as Integer returns Integer:
    Note: Receive message from channel (platform-agnostic blocking)
    Note: Returns pointer to message, 0 if failed
    Note: Uses semaphores for cross-platform synchronization

    If channel is equal to 0:
        Return 0
    End If

    Note: Get semaphores and mutex
    Let not_empty_sem be proc memory_get_integer from MemoryCore with channel, 48
    Let mutex_ptr be proc memory_get_integer from MemoryCore with channel, 40
    Let not_full_sem be proc memory_get_integer from MemoryCore with channel, 56

    Note: Wait for available item (decrement not_empty semaphore)
    Note: This blocks if channel is empty
    Let wait_result be proc semaphore_wait from SyncCore with not_empty_sem
    If wait_result is equal to 0:
        Return 0
    End If

    Note: Acquire mutex for exclusive access to buffer
    Let lock_result be proc mutex_lock with mutex_ptr
    If lock_result is equal to 0:
        Note: Failed to lock, signal not_empty to restore semaphore
        Let signal_restore be proc semaphore_signal from SyncCore with not_empty_sem
        Return 0
    End If

    Note: Get message from buffer at head position
    Let buffer_ptr be proc memory_get_integer from MemoryCore with channel, 0
    Let head be proc memory_get_integer from MemoryCore with channel, 24
    Let head_offset be head multiplied by 8
    Let message be proc memory_get_integer from MemoryCore with buffer_ptr, head_offset

    Note: Update head (wrap around)
    Let capacity be proc memory_get_integer from MemoryCore with channel, 8
    Let new_head be head plus 1
    If new_head is greater than or equal to capacity:
        Set new_head to 0
    End If
    Let dummy1 be proc memory_set_integer from MemoryCore with channel, 24, new_head

    Note: Update size
    Let size be proc memory_get_integer from MemoryCore with channel, 16
    Let new_size be size minus 1
    Let dummy2 be proc memory_set_integer from MemoryCore with channel, 16, new_size

    Note: Release mutex
    Let unlock_result be proc mutex_unlock with mutex_ptr

    Note: Signal not_full semaphore (wake sender)
    Let signal_result be proc semaphore_signal from SyncCore with not_full_sem

    Return message
End Process

Note: ============================================================================
Note: Thread Utils Complete - Platform-Agnostic Threading Primitives
Note: ============================================================================
Note:
Note: All threading operations delegate to platform-specific implementations:
Note: - Linux: pthread + futex
Note: - macOS: pthread + dispatch
Note: - Windows: Windows threads + WaitOnAddress
Note: - BSD: pthread + kqueue
Note: - WebAssembly: Web Workers + Atomics.wait
Note:
Note: Cross-platform compatibility achieved through ThreadCore and SyncCore
Note: ============================================================================
