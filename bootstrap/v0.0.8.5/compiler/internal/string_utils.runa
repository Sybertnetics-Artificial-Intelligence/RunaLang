Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file implements comprehensive string manipulation and utility operations for the Runa compiler internal system.

COMPILER STRING UTILITIES - Core Text Processing Engine
- Process advanced string manipulation with memory-efficient operations and performance optimization
- Handle string formatting, conversion, and encoding with Unicode support and internationalization
- Manage string validation, sanitization, and security with input validation and error handling
- Process string optimization with arena allocation, string interning, and performance monitoring
- Handle integration with compiler phases for source code processing and text manipulation

This file is essential because of the following reasons:
- String utilities enable comprehensive text processing for all compiler phases and operations
- Proper string handling ensures efficient compiler text operations and memory management
- String utilities support lexical analysis, parsing, semantic analysis, and code generation workflows

This file consists of the following functions/features/operation types:
- Advanced string manipulation with memory-efficient operations and performance optimization
- String formatting, conversion, and encoding with Unicode support and internationalization
- String validation, sanitization, and security with input validation and error handling
- String optimization with arena allocation, string interning, and performance monitoring
- Integration with compiler phases for source code processing and text manipulation

Dependencies:
- Imports arena_utils.runa for arena-based string allocation
- Imports owned_utils.runa for owned string management
- Imports memory_safety.runa for memory safety validation
- Imports format_utils.runa for string formatting operations
- Imports hash_utils.runa for string hashing and interning
:End Note

Import "compiler/internal/memory_utils.runa" as MemoryUtils
Import "compiler/internal/arena_utils.runa" as ArenaUtils
Import "compiler/internal/unicode_tables.runa" as UnicodeTables
Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore

Note: ============================================================================
Note: String Utility Structures
Note: ============================================================================

Type called "StringBuffer":
    data as Integer          Note: Pointer to string data buffer
    length as Integer        Note: Current string length
    capacity as Integer      Note: Buffer capacity
    arena as Integer         Note: Pointer to arena for allocation
    encoding as Integer      Note: String encoding (UTF-8, UTF-16, etc.)
    is_owned as Integer      Note: Boolean: 1 if owned, 0 if arena-allocated

Type called "StringIntern":
    string_data as Integer   Note: Pointer to interned string data
    hash_value as Integer    Note: Precomputed hash value
    reference_count as Integer Note: Number of references to this string
    next as Integer          Note: Pointer to next string in hash bucket

Type called "StringFormat":
    format_string as Integer Note: Pointer to format string
    arguments as Integer     Note: Pointer to array of format arguments
    result as Integer        Note: Pointer to formatted result string
    error_code as Integer    Note: Format error code (0 = success)

Note: ============================================================================
Note: String Constants
Note: ============================================================================

Constant STRING_ENCODING_UTF8 as Integer is 0
Constant STRING_ENCODING_UTF16 as Integer is 1
Constant STRING_ENCODING_ASCII as Integer is 2
Constant STRING_ENCODING_LATIN1 as Integer is 3

Constant STRING_ALLOCATION_ARENA as Integer is 0
Constant STRING_ALLOCATION_OWNED as Integer is 1
Constant STRING_ALLOCATION_STACK as Integer is 2

Constant STRING_COMPARISON_EQUAL as Integer is 0
Constant STRING_COMPARISON_LESS as Integer is -1
Constant STRING_COMPARISON_GREATER as Integer is 1

Constant MAX_STRING_LENGTH as Integer is 2147483647
Constant DEFAULT_STRING_CAPACITY as Integer is 256
Constant STRING_INTERN_HASH_SIZE as Integer is 65536

Note: ============================================================================
Note: Core String Operations
Note: ============================================================================

Process called "string_create" takes arena as Integer, initial_capacity as Integer returns Integer:
    Note: Create a new string buffer with specified capacity
    Note: Returns pointer to StringBuffer structure (48 bytes)
    Note: Uses arena or owned allocation based on arena parameter

    Note: Determine capacity (minimum 16 bytes)
    Let use_capacity be initial_capacity
    Let min_capacity be 16
    If use_capacity is less than min_capacity:
        Set use_capacity to min_capacity
    End If

    Note: Allocate StringBuffer structure (48 bytes)
    Let buffer_size be 48
    Let buffer_ptr be 0

    If arena is not equal to 0:
        Set buffer_ptr to proc arena_allocate from ArenaUtils with arena, buffer_size, 8
    End If
    Otherwise:
        Set buffer_ptr to proc allocate from MemoryUtils with buffer_size
    End If

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Allocate data buffer
    Let data_ptr be 0
    If arena is not equal to 0:
        Set data_ptr to proc arena_allocate from ArenaUtils with arena, use_capacity, 1
    End If
    Otherwise:
        Set data_ptr to proc allocate from MemoryUtils with use_capacity
    End If

    If data_ptr is equal to 0:
        If arena is equal to 0:
            Let dummy1 be proc deallocate from MemoryUtils with buffer_ptr
        End If
        Return 0
    End If

    Note: Initialize StringBuffer: data, length, capacity, arena, encoding, is_owned
    Let dummy2 be proc memory_set_integer from MemoryCore with buffer_ptr, 0, data_ptr
    Let dummy3 be proc memory_set_integer from MemoryCore with buffer_ptr, 8, 0
    Let dummy4 be proc memory_set_integer from MemoryCore with buffer_ptr, 16, use_capacity
    Let dummy5 be proc memory_set_integer from MemoryCore with buffer_ptr, 24, arena
    Let dummy6 be proc memory_set_integer from MemoryCore with buffer_ptr, 32, STRING_ENCODING_UTF8

    Let is_owned be 0
    If arena is equal to 0:
        Set is_owned to 1
    End If
    Let dummy7 be proc memory_set_integer from MemoryCore with buffer_ptr, 40, is_owned

    Note: Null-terminate initial buffer
    Let dummy8 be proc memory_set_byte from MemoryCore with data_ptr, 0, 0

    Return buffer_ptr
End Process

Process called "string_destroy" takes string_buffer as Integer returns Nothing:
    Note: Destroy string buffer and free associated memory
    Note: Only frees if is_owned flag is set

    If string_buffer is equal to 0:
        Return
    End If

    Note: Get is_owned flag
    Let is_owned be proc memory_get_integer from MemoryCore with string_buffer, 40

    If is_owned is equal to 1:
        Note: Free data buffer
        Let data_ptr be proc memory_get_integer from MemoryCore with string_buffer, 0
        If data_ptr is not equal to 0:
            Let dummy1 be proc deallocate from MemoryUtils with data_ptr
        End If

        Note: Free buffer structure
        Let dummy2 be proc deallocate from MemoryUtils with string_buffer
    End If

    Return
End Process

Process called "string_append" takes buffer as Integer, text as Integer returns Integer:
    Note: Append text to string buffer
    Note: Returns new length of string
    Note: Handles automatic buffer resizing

    If buffer is equal to 0:
        Return 0
    End If

    If text is equal to 0:
        Let length be proc memory_get_integer from MemoryCore with buffer, 8
        Return length
    End If

    Note: Get current state
    Let data_ptr be proc memory_get_integer from MemoryCore with buffer, 0
    Let current_len be proc memory_get_integer from MemoryCore with buffer, 8
    Let capacity be proc memory_get_integer from MemoryCore with buffer, 16
    Let text_len be proc string_length from StringCore with text

    Note: Check if resize needed
    Let required_capacity be current_len plus text_len plus 1
    If required_capacity is greater than capacity:
        Note: Resize buffer (double capacity until sufficient)
        Let new_capacity be capacity multiplied by 2
        While new_capacity is less than required_capacity:
            Set new_capacity to new_capacity multiplied by 2
        End While

        Note: Allocate new data buffer
        Let new_data be proc allocate from MemoryUtils with new_capacity

        If new_data is equal to 0:
            Return current_len
        End If

        Note: Copy existing data
        Let dummy1 be proc memory_copy from MemoryCore with new_data, data_ptr, current_len

        Note: Free old buffer if owned
        Let is_owned be proc memory_get_integer from MemoryCore with buffer, 40
        If is_owned is equal to 1:
            Let dummy2 be proc deallocate from MemoryUtils with data_ptr
        End If

        Note: Update buffer pointers
        Let dummy3 be proc memory_set_integer from MemoryCore with buffer, 0, new_data
        Let dummy4 be proc memory_set_integer from MemoryCore with buffer, 16, new_capacity
        Set data_ptr to new_data
    End If

    Note: Append text
    Let dest_offset be current_len
    Let dest_ptr be data_ptr plus dest_offset
    Let dummy5 be proc memory_copy from MemoryCore with dest_ptr, text, text_len

    Note: Update length and null-terminate
    Let new_len be current_len plus text_len
    Let dummy6 be proc memory_set_integer from MemoryCore with buffer, 8, new_len
    Let dummy7 be proc memory_set_byte from MemoryCore with data_ptr, new_len, 0

    Return new_len
End Process

Process called "string_prepend" takes buffer as Integer, text as Integer returns Integer:
    Note: Prepend text to string buffer
    Note: Returns new length of string
    Note: Shifts existing content right

    If buffer is equal to 0:
        Return 0
    End If

    If text is equal to 0:
        Let length be proc memory_get_integer from MemoryCore with buffer, 8
        Return length
    End If

    Note: Get current state
    Let data_ptr be proc memory_get_integer from MemoryCore with buffer, 0
    Let current_len be proc memory_get_integer from MemoryCore with buffer, 8
    Let capacity be proc memory_get_integer from MemoryCore with buffer, 16
    Let text_len be proc string_length from StringCore with text

    Note: Check if resize needed
    Let required_capacity be current_len plus text_len plus 1
    Let new_data be data_ptr

    If required_capacity is greater than capacity:
        Note: Allocate larger buffer
        Let new_capacity be capacity multiplied by 2
        While new_capacity is less than required_capacity:
            Set new_capacity to new_capacity multiplied by 2
        End While

        Set new_data to proc allocate from MemoryUtils with new_capacity

        If new_data is equal to 0:
            Return current_len
        End If

        Note: Update capacity
        Let dummy1 be proc memory_set_integer from MemoryCore with buffer, 16, new_capacity
    End If

    Note: Shift existing content right
    Let i be current_len
    While i is greater than 0:
        Set i to i minus 1
        Let byte_val be proc memory_get_byte from MemoryCore with data_ptr, i
        Let dest_offset be i plus text_len
        Let dummy2 be proc memory_set_byte from MemoryCore with new_data, dest_offset, byte_val
    End While

    Note: Copy prepended text
    Let dummy3 be proc memory_copy from MemoryCore with new_data, text, text_len

    Note: Update buffer if reallocated
    If new_data is not equal to data_ptr:
        Let is_owned be proc memory_get_integer from MemoryCore with buffer, 40
        If is_owned is equal to 1:
            Let dummy4 be proc deallocate from MemoryUtils with data_ptr
        End If
        Let dummy5 be proc memory_set_integer from MemoryCore with buffer, 0, new_data
    End If

    Note: Update length and null-terminate
    Let new_len be current_len plus text_len
    Let dummy6 be proc memory_set_integer from MemoryCore with buffer, 8, new_len
    Let dummy7 be proc memory_set_byte from MemoryCore with new_data, new_len, 0

    Return new_len
End Process

Process called "string_insert" takes buffer as Integer, position as Integer, text as Integer returns Integer:
    Note: Insert text at specified position in string
    Note: Returns new length of string
    Note: Validates position bounds

    If buffer is equal to 0:
        Return 0
    End If

    If text is equal to 0:
        Let length be proc memory_get_integer from MemoryCore with buffer, 8
        Return length
    End If

    Note: Get current state
    Let data_ptr be proc memory_get_integer from MemoryCore with buffer, 0
    Let current_len be proc memory_get_integer from MemoryCore with buffer, 8
    Let capacity be proc memory_get_integer from MemoryCore with buffer, 16
    Let text_len be proc string_length from StringCore with text

    Note: Validate position
    If position is less than 0:
        Return current_len
    End If

    If position is greater than current_len:
        Set position to current_len
    End If

    Note: Check if resize needed
    Let required_capacity be current_len plus text_len plus 1
    Let new_data be data_ptr

    If required_capacity is greater than capacity:
        Let new_capacity be capacity multiplied by 2
        While new_capacity is less than required_capacity:
            Set new_capacity to new_capacity multiplied by 2
        End While

        Set new_data to proc allocate from MemoryUtils with new_capacity

        If new_data is equal to 0:
            Return current_len
        End If

        Note: Copy data before insertion point
        Let dummy1 be proc memory_copy from MemoryCore with new_data, data_ptr, position

        Note: Update capacity
        Let dummy2 be proc memory_set_integer from MemoryCore with buffer, 16, new_capacity
    End If

    Note: Shift data after insertion point
    Let i be current_len
    While i is greater than or equal to position:
        Let byte_val be proc memory_get_byte from MemoryCore with data_ptr, i
        Let dest_offset be i plus text_len
        Let dummy3 be proc memory_set_byte from MemoryCore with new_data, dest_offset, byte_val

        If i is equal to 0:
            Let break be 1
        End If
        Otherwise:
            Set i to i minus 1
        End If
    End While

    Note: Insert text
    Let insert_dest be new_data plus position
    Let dummy4 be proc memory_copy from MemoryCore with insert_dest, text, text_len

    Note: Update buffer if reallocated
    If new_data is not equal to data_ptr:
        Let is_owned be proc memory_get_integer from MemoryCore with buffer, 40
        If is_owned is equal to 1:
            Let dummy5 be proc deallocate from MemoryUtils with data_ptr
        End If
        Let dummy6 be proc memory_set_integer from MemoryCore with buffer, 0, new_data
    End If

    Note: Update length
    Let new_len be current_len plus text_len
    Let dummy7 be proc memory_set_integer from MemoryCore with buffer, 8, new_len
    Let dummy8 be proc memory_set_byte from MemoryCore with new_data, new_len, 0

    Return new_len
End Process

Process called "string_remove" takes buffer as Integer, start_pos as Integer, length as Integer returns Integer:
    Note: Remove substring from string buffer
    Note: Returns new length of string
    Note: Validates position and length bounds

    If buffer is equal to 0:
        Return 0
    End If

    Let data_ptr be proc memory_get_integer from MemoryCore with buffer, 0
    Let current_len be proc memory_get_integer from MemoryCore with buffer, 8

    Note: Validate bounds
    If start_pos is less than 0:
        Return current_len
    End If

    If start_pos is greater than or equal to current_len:
        Return current_len
    End If

    Note: Adjust length if too large
    Let actual_length be length
    Let remaining be current_len minus start_pos

    If actual_length is greater than remaining:
        Set actual_length to remaining
    End If

    If actual_length is less than or equal to 0:
        Return current_len
    End If

    Note: Shift data left
    Let src_start be start_pos plus actual_length
    Let i be src_start

    While i is less than current_len:
        Let byte_val be proc memory_get_byte from MemoryCore with data_ptr, i
        Let dest_pos be i minus actual_length
        Let dummy1 be proc memory_set_byte from MemoryCore with data_ptr, dest_pos, byte_val
        Set i to i plus 1
    End While

    Note: Update length and null-terminate
    Let new_len be current_len minus actual_length
    Let dummy2 be proc memory_set_integer from MemoryCore with buffer, 8, new_len
    Let dummy3 be proc memory_set_byte from MemoryCore with data_ptr, new_len, 0

    Return new_len
End Process

Process called "string_substring" takes buffer as Integer, start_pos as Integer, length as Integer returns Integer:
    Note: Extract substring from string buffer
    Note: Returns pointer to new string (owned allocation)
    Note: Validates bounds

    If buffer is equal to 0:
        Return 0
    End If

    Let data_ptr be proc memory_get_integer from MemoryCore with buffer, 0
    Let current_len be proc memory_get_integer from MemoryCore with buffer, 8

    Note: Validate bounds
    If start_pos is less than 0:
        Return 0
    End If

    If start_pos is greater than or equal to current_len:
        Return 0
    End If

    Note: Adjust length
    Let actual_length be length
    Let remaining be current_len minus start_pos

    If actual_length is greater than remaining:
        Set actual_length to remaining
    End If

    If actual_length is less than or equal to 0:
        Return 0
    End If

    Note: Allocate result string
    Let result_size be actual_length plus 1
    Let result_ptr be proc allocate from MemoryUtils with result_size

    If result_ptr is equal to 0:
        Return 0
    End If

    Note: Copy substring
    Let src_ptr be data_ptr plus start_pos
    Let dummy1 be proc memory_copy from MemoryCore with result_ptr, src_ptr, actual_length

    Note: Null-terminate
    Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, actual_length, 0

    Return result_ptr
End Process

Process called "string_copy" takes source as Integer, arena as Integer returns Integer:
    Note: Create a copy of string buffer
    Note: Returns pointer to new string buffer
    Note: Uses arena if provided, otherwise owned allocation

    If source is equal to 0:
        Return 0
    End If

    Let data_ptr be proc memory_get_integer from MemoryCore with source, 0
    Let length be proc memory_get_integer from MemoryCore with source, 8
    Let capacity be proc memory_get_integer from MemoryCore with source, 16

    Note: Create new buffer with same capacity
    Let new_buffer be proc string_create with arena, capacity

    If new_buffer is equal to 0:
        Return 0
    End If

    Note: Copy data
    Let new_data be proc memory_get_integer from MemoryCore with new_buffer, 0
    Let dummy1 be proc memory_copy from MemoryCore with new_data, data_ptr, length

    Note: Update length
    Let dummy2 be proc memory_set_integer from MemoryCore with new_buffer, 8, length
    Let dummy3 be proc memory_set_byte from MemoryCore with new_data, length, 0

    Return new_buffer
End Process

Process called "string_duplicate" takes source as Integer returns Integer:
    Note: Create owned copy of string buffer
    Note: Returns pointer to owned string buffer
    Note: Uses owned heap allocation

    Let arena be 0
    Let result be proc string_copy with source, arena
    Return result
End Process

Note: ============================================================================
Note: String Comparison Operations
Note: ============================================================================

Process called "string_equals" takes str1 as Integer, str2 as Integer returns Integer:
    Note: Compare two strings for equality byte-by-byte
    Note: Returns 1 if equal, 0 if not equal

    If str1 is equal to str2:
        Return 1
    End If

    If str1 is equal to 0:
        Return 0
    End If

    If str2 is equal to 0:
        Return 0
    End If

    Let result be proc string_equals from StringCore with str1, str2
    Return result
End Process

Process called "string_compare" takes str1 as Integer, str2 as Integer returns Integer:
    Note: Compare two strings lexicographically
    Note: Returns -1 if str1 < str2, 0 if equal, 1 if str1 > str2

    If str1 is equal to str2:
        Return 0
    End If

    If str1 is equal to 0:
        Return -1
    End If

    If str2 is equal to 0:
        Return 1
    End If

    Let result be proc string_compare from StringCore with str1, str2
    Return result
End Process

Process called "string_compare_ignore_case" takes str1 as Integer, str2 as Integer returns Integer:
    Note: Compare two strings case-insensitively
    Note: Returns -1 if str1 < str2, 0 if equal, 1 if str1 > str2

    If str1 is equal to str2:
        Return 0
    End If

    If str1 is equal to 0:
        Return -1
    End If

    If str2 is equal to 0:
        Return 1
    End If

    Let len1 be proc string_length from StringCore with str1
    Let len2 be proc string_length from StringCore with str2
    Let min_len be len1
    If len2 is less than min_len:
        Set min_len to len2
    End If

    Let i be 0
    While i is less than min_len:
        Let ch1 be proc memory_get_byte from MemoryCore with str1, i
        Let ch2 be proc memory_get_byte from MemoryCore with str2, i
        Let lower1 be ch1
        Let lower2 be ch2

        If ch1 is greater than or equal to 65:
            If ch1 is less than or equal to 90:
                Set lower1 to ch1 plus 32
            End If
        End If

        If ch2 is greater than or equal to 65:
            If ch2 is less than or equal to 90:
                Set lower2 to ch2 plus 32
            End If
        End If

        If lower1 is less than lower2:
            Return -1
        End If

        If lower1 is greater than lower2:
            Return 1
        End If

        Set i to i plus 1
    End While

    If len1 is less than len2:
        Return -1
    End If

    If len1 is greater than len2:
        Return 1
    End If

    Return 0
End Process

Process called "string_starts_with" takes str as Integer, prefix as Integer returns Integer:
    Note: Check if string starts with prefix
    Note: Returns 1 if match, 0 otherwise

    If str is equal to 0:
        Return 0
    End If

    If prefix is equal to 0:
        Return 1
    End If

    Let str_len be proc string_length from StringCore with str
    Let prefix_len be proc string_length from StringCore with prefix

    If prefix_len is greater than str_len:
        Return 0
    End If

    Let i be 0
    While i is less than prefix_len:
        Let str_ch be proc memory_get_byte from MemoryCore with str, i
        Let prefix_ch be proc memory_get_byte from MemoryCore with prefix, i

        If str_ch is not equal to prefix_ch:
            Return 0
        End If

        Set i to i plus 1
    End While

    Return 1
End Process

Process called "string_ends_with" takes str as Integer, suffix as Integer returns Integer:
    Note: Check if string ends with suffix
    Note: Returns 1 if match, 0 otherwise

    If str is equal to 0:
        Return 0
    End If

    If suffix is equal to 0:
        Return 1
    End If

    Let str_len be proc string_length from StringCore with str
    Let suffix_len be proc string_length from StringCore with suffix

    If suffix_len is greater than str_len:
        Return 0
    End If

    Let offset be str_len minus suffix_len
    Let i be 0
    While i is less than suffix_len:
        Let str_pos be offset plus i
        Let str_ch be proc memory_get_byte from MemoryCore with str, str_pos
        Let suffix_ch be proc memory_get_byte from MemoryCore with suffix, i

        If str_ch is not equal to suffix_ch:
            Return 0
        End If

        Set i to i plus 1
    End While

    Return 1
End Process

Process called "string_contains" takes str as Integer, substring as Integer returns Integer:
    Note: Check if string contains substring
    Note: Returns 1 if found, 0 otherwise

    Let pos be proc string_find with str, substring, 0
    If pos is greater than or equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "string_find" takes str as Integer, substring as Integer, start_pos as Integer returns Integer:
    Note: Find first occurrence of substring
    Note: Returns position or -1 if not found

    If str is equal to 0:
        Return -1
    End If

    If substring is equal to 0:
        Return -1
    End If

    Let str_len be proc string_length from StringCore with str
    Let sub_len be proc string_length from StringCore with substring

    If sub_len is equal to 0:
        Return start_pos
    End If

    If sub_len is greater than str_len:
        Return -1
    End If

    Let search_limit be str_len minus sub_len
    Let i be start_pos
    If i is less than 0:
        Set i to 0
    End If

    While i is less than or equal to search_limit:
        Let match be 1
        Let j be 0
        While j is less than sub_len:
            Let str_pos be i plus j
            Let str_ch be proc memory_get_byte from MemoryCore with str, str_pos
            Let sub_ch be proc memory_get_byte from MemoryCore with substring, j

            If str_ch is not equal to sub_ch:
                Set match to 0
                Let break be 1
            End If

            Set j to j plus 1
        End While

        If match is equal to 1:
            Return i
        End If

        Set i to i plus 1
    End While

    Return -1
End Process

Process called "string_find_last" takes str as Integer, substring as Integer returns Integer:
    Note: Find last occurrence of substring
    Note: Returns position or -1 if not found

    If str is equal to 0:
        Return -1
    End If

    If substring is equal to 0:
        Return -1
    End If

    Let str_len be proc string_length from StringCore with str
    Let sub_len be proc string_length from StringCore with substring

    If sub_len is equal to 0:
        Return str_len
    End If

    If sub_len is greater than str_len:
        Return -1
    End If

    Let i be str_len minus sub_len

    While i is greater than or equal to 0:
        Let match be 1
        Let j be 0
        While j is less than sub_len:
            Let str_pos be i plus j
            Let str_ch be proc memory_get_byte from MemoryCore with str, str_pos
            Let sub_ch be proc memory_get_byte from MemoryCore with substring, j

            If str_ch is not equal to sub_ch:
                Set match to 0
                Let break be 1
            End If

            Set j to j plus 1
        End While

        If match is equal to 1:
            Return i
        End If

        Set i to i minus 1
    End While

    Return -1
End Process

Note: ============================================================================
Note: String Conversion Operations
Note: ============================================================================

Process called "string_to_integer" takes str as Integer returns Integer:
    Note: Convert string to integer
    Note: Returns integer value or 0 if conversion fails

    If str is equal to 0:
        Return 0
    End If

    Let result be proc string_to_integer from StringCore with str
    Return result
End Process

Process called "string_to_float" takes str as Integer returns Integer:
    Note: Convert string to float (fixed-point)
    Note: Returns fixed-point integer value

    If str is equal to 0:
        Return 0
    End If

    Note: Delegate to StringCore for parsing
    Let result be proc string_to_float from StringCore with str
    Return result
End Process

Process called "integer_to_string" takes value as Integer, arena as Integer returns Integer:
    Note: Convert integer to string with arena support
    Note: Returns pointer to string buffer

    Note: Allocate buffer (32 bytes max for 64-bit integer)
    Let buffer_size be 32
    Let buffer_ptr be 0

    If arena is not equal to 0:
        Set buffer_ptr to proc arena_allocate from ArenaUtils with arena, buffer_size, 1
    End If
    Otherwise:
        Set buffer_ptr to proc allocate from MemoryUtils with buffer_size
    End If

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Convert using StringCore
    Let result be proc integer_to_string from StringCore with value, buffer_ptr, buffer_size
    Return result
End Process

Process called "float_to_string" takes value as Integer, precision as Integer, arena as Integer returns Integer:
    Note: Convert float to string with precision
    Note: Returns pointer to string buffer

    Let buffer_size be 64
    Let buffer_ptr be 0

    If arena is not equal to 0:
        Set buffer_ptr to proc arena_allocate from ArenaUtils with arena, buffer_size, 1
    End If
    Otherwise:
        Set buffer_ptr to proc allocate from MemoryUtils with buffer_size
    End If

    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Use StringCore for conversion
    Let result be proc float_to_string from StringCore with value, precision, buffer_ptr, buffer_size
    Return result
End Process

Process called "string_to_upper" takes str as Integer, arena as Integer returns Integer:
    Note: Convert string to uppercase
    Note: Returns pointer to new string

    If str is equal to 0:
        Return 0
    End If

    Let len be proc string_length from StringCore with str
    Let result_ptr be 0

    If arena is not equal to 0:
        Set result_ptr to proc arena_allocate from ArenaUtils with arena, len plus 1, 1
    End If
    Otherwise:
        Set result_ptr to proc allocate from MemoryUtils with len plus 1
    End If

    If result_ptr is equal to 0:
        Return 0
    End If

    Let i be 0
    While i is less than len:
        Let ch be proc memory_get_byte from MemoryCore with str, i
        Let upper_ch be ch

        If ch is greater than or equal to 97:
            If ch is less than or equal to 122:
                Set upper_ch to ch minus 32
            End If
        End If

        Let dummy1 be proc memory_set_byte from MemoryCore with result_ptr, i, upper_ch
        Set i to i plus 1
    End While

    Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, len, 0
    Return result_ptr
End Process

Process called "string_to_lower" takes str as Integer, arena as Integer returns Integer:
    Note: Convert string to lowercase
    Note: Returns pointer to new string

    If str is equal to 0:
        Return 0
    End If

    Let len be proc string_length from StringCore with str
    Let result_ptr be 0

    If arena is not equal to 0:
        Set result_ptr to proc arena_allocate from ArenaUtils with arena, len plus 1, 1
    End If
    Otherwise:
        Set result_ptr to proc allocate from MemoryUtils with len plus 1
    End If

    If result_ptr is equal to 0:
        Return 0
    End If

    Let i be 0
    While i is less than len:
        Let ch be proc memory_get_byte from MemoryCore with str, i
        Let lower_ch be ch

        If ch is greater than or equal to 65:
            If ch is less than or equal to 90:
                Set lower_ch to ch plus 32
            End If
        End If

        Let dummy1 be proc memory_set_byte from MemoryCore with result_ptr, i, lower_ch
        Set i to i plus 1
    End While

    Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, len, 0
    Return result_ptr
End Process

Process called "string_trim" takes str as Integer, arena as Integer returns Integer:
    Note: Remove leading and trailing whitespace
    Note: Returns pointer to new string

    If str is equal to 0:
        Return 0
    End If

    Let len be proc string_length from StringCore with str
    Let start be 0
    Let end be len

    Note: Find first non-whitespace
    While start is less than len:
        Let ch be proc memory_get_byte from MemoryCore with str, start
        If ch is not equal to 32:
            If ch is not equal to 9:
                If ch is not equal to 10:
                    If ch is not equal to 13:
                        Let break be 1
                    End If
                End If
            End If
        End If
        Otherwise:
            Set start to start plus 1
        End If
    End While

    Note: Find last non-whitespace
    While end is greater than start:
        Let pos be end minus 1
        Let ch be proc memory_get_byte from MemoryCore with str, pos
        If ch is not equal to 32:
            If ch is not equal to 9:
                If ch is not equal to 10:
                    If ch is not equal to 13:
                        Let break be 1
                    End If
                End If
            End If
        End If
        Otherwise:
            Set end to end minus 1
        End If
    End While

    Let trimmed_len be end minus start
    Let result_ptr be 0

    If arena is not equal to 0:
        Set result_ptr to proc arena_allocate from ArenaUtils with arena, trimmed_len plus 1, 1
    End If
    Otherwise:
        Set result_ptr to proc allocate from MemoryUtils with trimmed_len plus 1
    End If

    If result_ptr is equal to 0:
        Return 0
    End If

    Let src_ptr be str plus start
    Let dummy1 be proc memory_copy from MemoryCore with result_ptr, src_ptr, trimmed_len
    Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, trimmed_len, 0

    Return result_ptr
End Process

Process called "string_trim_left" takes str as Integer, arena as Integer returns Integer:
    Note: Remove leading whitespace
    Note: Returns pointer to new string

    If str is equal to 0:
        Return 0
    End If

    Let len be proc string_length from StringCore with str
    Let start be 0

    While start is less than len:
        Let ch be proc memory_get_byte from MemoryCore with str, start
        If ch is not equal to 32:
            If ch is not equal to 9:
                If ch is not equal to 10:
                    If ch is not equal to 13:
                        Let break be 1
                    End If
                End If
            End If
        End If
        Otherwise:
            Set start to start plus 1
        End If
    End While

    Let trimmed_len be len minus start
    Let result_ptr be 0

    If arena is not equal to 0:
        Set result_ptr to proc arena_allocate from ArenaUtils with arena, trimmed_len plus 1, 1
    End If
    Otherwise:
        Set result_ptr to proc allocate from MemoryUtils with trimmed_len plus 1
    End If

    If result_ptr is equal to 0:
        Return 0
    End If

    Let src_ptr be str plus start
    Let dummy1 be proc memory_copy from MemoryCore with result_ptr, src_ptr, trimmed_len
    Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, trimmed_len, 0

    Return result_ptr
End Process

Process called "string_trim_right" takes str as Integer, arena as Integer returns Integer:
    Note: Remove trailing whitespace
    Note: Returns pointer to new string

    If str is equal to 0:
        Return 0
    End If

    Let len be proc string_length from StringCore with str
    Let end be len

    While end is greater than 0:
        Let pos be end minus 1
        Let ch be proc memory_get_byte from MemoryCore with str, pos
        If ch is not equal to 32:
            If ch is not equal to 9:
                If ch is not equal to 10:
                    If ch is not equal to 13:
                        Let break be 1
                    End If
                End If
            End If
        End If
        Otherwise:
            Set end to end minus 1
        End If
    End While

    Let result_ptr be 0

    If arena is not equal to 0:
        Set result_ptr to proc arena_allocate from ArenaUtils with arena, end plus 1, 1
    End If
    Otherwise:
        Set result_ptr to proc allocate from MemoryUtils with end plus 1
    End If

    If result_ptr is equal to 0:
        Return 0
    End If

    Let dummy1 be proc memory_copy from MemoryCore with result_ptr, str, end
    Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, end, 0

    Return result_ptr
End Process

Note: ============================================================================
Note: String Formatting Operations
Note: ============================================================================

Process called "string_format" takes format_str as Integer, args as Integer, arena as Integer returns Integer:
    Note: Format string with arguments using {0}, {1}, {2}, etc. placeholders
    Note: Returns pointer to formatted string buffer
    Note: args is pointer to array of string pointers
    Note: Example: string_format("Hello {0}, you are {1} years old", ["Alice", "25"], arena)

    If format_str is equal to 0:
        Return 0
    End If

    Note: Create result buffer using string_create
    Let buffer be proc string_create with arena, 256
    If buffer is equal to 0:
        Return 0
    End If

    Let format_len be proc string_length from StringCore with format_str
    Let i be 0

    While i is less than format_len:
        Let ch be proc memory_get_byte from MemoryCore with format_str, i

        Note: Check for placeholder start
        If ch is equal to 123:  Note: '{'
            Let next_i be i plus 1
            If next_i is less than format_len:
                Let next_ch be proc memory_get_byte from MemoryCore with format_str, next_i

                Note: Check if it's a digit (0-9, ASCII 48-57)
                If next_ch is greater than or equal to 48:
                    If next_ch is less than or equal to 57:
                        Let arg_index be next_ch minus 48

                        Note: Check for closing brace
                        Let close_i be next_i plus 1
                        If close_i is less than format_len:
                            Let close_ch be proc memory_get_byte from MemoryCore with format_str, close_i
                            If close_ch is equal to 125:  Note: '}'
                                Note: Valid placeholder - get argument
                                Let arg_offset be arg_index times 8
                                Let arg_ptr_addr be args plus arg_offset
                                Let arg_str be proc memory_get_integer from MemoryCore with arg_ptr_addr, 0

                                If arg_str is not equal to 0:
                                    Note: Append argument string to result
                                    Let dummy be proc string_append with buffer, arg_str
                                End If

                                Set i to close_i plus 1
                                Let continue be 1
                            End If
                        End If
                    End If
                End If
            End If
        End If

        Otherwise If continue is equal to 0:
            Note: Regular character - append to result
            Let temp_str be 0
            If arena is not equal to 0:
                Set temp_str to proc arena_allocate from ArenaUtils with arena, 2, 1
            End If
            Otherwise:
                Set temp_str to proc allocate from MemoryUtils with 2
            End If

            If temp_str is not equal to 0:
                Let dummy1 be proc memory_set_byte from MemoryCore with temp_str, 0, ch
                Let dummy2 be proc memory_set_byte from MemoryCore with temp_str, 1, 0
                Let dummy3 be proc string_append with buffer, temp_str
            End If

            Set i to i plus 1
        End If
        Otherwise:
            Set continue to 0
        End If
    End While

    Note: Extract final string from buffer
    Let buffer_data be proc memory_get_integer from MemoryCore with buffer, 0
    Return buffer_data
End Process

Process called "string_join" takes strings as Integer, count as Integer, separator as Integer, arena as Integer returns Integer:
    Note: Join array of strings with separator
    Note: strings is pointer to array of string pointers
    Note: count is number of strings in array
    Note: Returns pointer to joined string

    If strings is equal to 0:
        Return 0
    End If

    If count is equal to 0:
        Note: Return empty string
        Let result_ptr be 0
        If arena is not equal to 0:
            Set result_ptr to proc arena_allocate from ArenaUtils with arena, 1, 1
        End If
        Otherwise:
            Set result_ptr to proc allocate from MemoryUtils with 1
        End If
        If result_ptr is not equal to 0:
            Let dummy be proc memory_set_byte from MemoryCore with result_ptr, 0, 0
        End If
        Return result_ptr
    End If

    Note: Calculate total length needed
    Let sep_len be 0
    If separator is not equal to 0:
        Set sep_len to proc string_length from StringCore with separator
    End If

    Let total_len be 0
    Let i be 0
    While i is less than count:
        Let str_offset be i times 8
        Let str_ptr_addr be strings plus str_offset
        Let str_ptr be proc memory_get_integer from MemoryCore with str_ptr_addr, 0
        If str_ptr is not equal to 0:
            Let str_len be proc string_length from StringCore with str_ptr
            Set total_len to total_len plus str_len
        End If
        If i is less than count minus 1:
            Set total_len to total_len plus sep_len
        End If
        Set i to i plus 1
    End While

    Note: Allocate result buffer
    Let result_size be total_len plus 1
    Let result_ptr be 0
    If arena is not equal to 0:
        Set result_ptr to proc arena_allocate from ArenaUtils with arena, result_size, 1
    End If
    Otherwise:
        Set result_ptr to proc allocate from MemoryUtils with result_size
    End If

    If result_ptr is equal to 0:
        Return 0
    End If

    Note: Copy strings with separators
    Let pos be 0
    Set i to 0
    While i is less than count:
        Let str_offset be i times 8
        Let str_ptr_addr be strings plus str_offset
        Let str_ptr be proc memory_get_integer from MemoryCore with str_ptr_addr, 0

        If str_ptr is not equal to 0:
            Let str_len be proc string_length from StringCore with str_ptr
            Let dest_ptr be result_ptr plus pos
            Let dummy1 be proc memory_copy from MemoryCore with dest_ptr, str_ptr, str_len
            Set pos to pos plus str_len
        End If

        Note: Add separator between strings
        If i is less than count minus 1:
            If separator is not equal to 0:
                Let dest_ptr be result_ptr plus pos
                Let dummy2 be proc memory_copy from MemoryCore with dest_ptr, separator, sep_len
                Set pos to pos plus sep_len
            End If
        End If

        Set i to i plus 1
    End While

    Note: Null terminate
    Let dummy3 be proc memory_set_byte from MemoryCore with result_ptr, pos, 0

    Return result_ptr
End Process

Process called "string_split" takes str as Integer, delimiter as Integer, arena as Integer returns Integer:
    Note: Split string by delimiter into array of string pointers
    Note: Returns pointer to ArrayList containing string pointers
    Note: Caller must manage returned ArrayList and strings

    If str is equal to 0:
        Return 0
    End If

    If delimiter is equal to 0:
        Return 0
    End If

    Note: Create ArrayList to hold string pointers
    Let result_list be proc allocate from MemoryUtils with 48
    If result_list is equal to 0:
        Return 0
    End If

    Note: Initialize ArrayList fields (48 bytes: data, count, capacity, arena, growth, is_owned)
    Let initial_capacity be 16
    Let list_data be proc allocate from MemoryUtils with initial_capacity times 8
    If list_data is equal to 0:
        Let dummy_free be proc deallocate from MemoryUtils with result_list
        Return 0
    End If

    Let dummy1 be proc memory_set_integer from MemoryCore with result_list, 0, list_data
    Let dummy2 be proc memory_set_integer from MemoryCore with result_list, 8, 0  Note: count
    Let dummy3 be proc memory_set_integer from MemoryCore with result_list, 16, initial_capacity
    Let dummy4 be proc memory_set_integer from MemoryCore with result_list, 24, 0  Note: no arena
    Let dummy5 be proc memory_set_integer from MemoryCore with result_list, 32, 2  Note: growth factor
    Let dummy6 be proc memory_set_integer from MemoryCore with result_list, 40, 1  Note: is_owned

    Let str_len be proc string_length from StringCore with str
    Let delim_len be proc string_length from StringCore with delimiter
    Let start be 0
    Let i be 0

    While i is less than or equal to str_len:
        Let found be 0

        Note: Check if we're at delimiter or end of string
        If i is equal to str_len:
            Set found to 1
        End If
        Otherwise If i plus delim_len is less than or equal to str_len:
            Note: Check if delimiter matches at current position
            Let match be 1
            Let j be 0
            While j is less than delim_len:
                Let str_ch be proc memory_get_byte from MemoryCore with str, i plus j
                Let delim_ch be proc memory_get_byte from MemoryCore with delimiter, j
                If str_ch is not equal to delim_ch:
                    Set match to 0
                    Let break be 1
                End If
                Set j to j plus 1
            End While
            If match is equal to 1:
                Set found to 1
            End If
        End If

        If found is equal to 1:
            Note: Extract substring from start to i
            Let substr_len be i minus start
            Let substr_ptr be 0

            If arena is not equal to 0:
                Set substr_ptr to proc arena_allocate from ArenaUtils with arena, substr_len plus 1, 1
            End If
            Otherwise:
                Set substr_ptr to proc allocate from MemoryUtils with substr_len plus 1
            End If

            If substr_ptr is not equal to 0:
                Let src_ptr be str plus start
                Let dummy7 be proc memory_copy from MemoryCore with substr_ptr, src_ptr, substr_len
                Let dummy8 be proc memory_set_byte from MemoryCore with substr_ptr, substr_len, 0

                Note: Add to result list (grow if needed)
                Let list_count be proc memory_get_integer from MemoryCore with result_list, 8
                Let list_capacity be proc memory_get_integer from MemoryCore with result_list, 16

                If list_count is equal to list_capacity:
                    Note: Grow array
                    Let new_capacity be list_capacity times 2
                    Let new_data be proc allocate from MemoryUtils with new_capacity times 8
                    If new_data is not equal to 0:
                        Let old_data be proc memory_get_integer from MemoryCore with result_list, 0
                        Let dummy9 be proc memory_copy from MemoryCore with new_data, old_data, list_count times 8
                        Let dummy10 be proc deallocate from MemoryUtils with old_data
                        Let dummy11 be proc memory_set_integer from MemoryCore with result_list, 0, new_data
                        Let dummy12 be proc memory_set_integer from MemoryCore with result_list, 16, new_capacity
                    End If
                End If

                Note: Store string pointer in array
                Let list_data_ptr be proc memory_get_integer from MemoryCore with result_list, 0
                Set list_count to proc memory_get_integer from MemoryCore with result_list, 8
                Let item_offset be list_count times 8
                Let item_addr be list_data_ptr plus item_offset
                Let dummy13 be proc memory_set_integer from MemoryCore with item_addr, 0, substr_ptr
                Let dummy14 be proc memory_set_integer from MemoryCore with result_list, 8, list_count plus 1
            End If

            Set start to i plus delim_len
            Set i to i plus delim_len
            Let continue be 1
        End If

        Otherwise If continue is equal to 0:
            Set i to i plus 1
        End If
        Otherwise:
            Set continue to 0
        End If
    End While

    Return result_list
End Process

Process called "string_replace" takes str as Integer, old_substr as Integer, new_substr as Integer, arena as Integer returns Integer:
    Note: Replace all occurrences of old_substr with new_substr
    Note: Returns pointer to new string with replacements

    If str is equal to 0:
        Return 0
    End If

    If old_substr is equal to 0:
        Return str
    End If

    Let str_len be proc string_length from StringCore with str
    Let old_len be proc string_length from StringCore with old_substr
    Let new_len be 0
    If new_substr is not equal to 0:
        Set new_len to proc string_length from StringCore with new_substr
    End If

    Note: Count occurrences first
    Let occurrence_count be 0
    Let i be 0
    While i is less than or equal to str_len minus old_len:
        Let match be 1
        Let j be 0
        While j is less than old_len:
            Let str_ch be proc memory_get_byte from MemoryCore with str, i plus j
            Let old_ch be proc memory_get_byte from MemoryCore with old_substr, j
            If str_ch is not equal to old_ch:
                Set match to 0
                Let break be 1
            End If
            Set j to j plus 1
        End While

        If match is equal to 1:
            Set occurrence_count to occurrence_count plus 1
            Set i to i plus old_len
        End If
        Otherwise:
            Set i to i plus 1
        End If
    End While

    Note: Calculate result length
    Let result_len be str_len minus occurrence_count times old_len plus occurrence_count times new_len

    Note: Allocate result buffer
    Let result_ptr be 0
    If arena is not equal to 0:
        Set result_ptr to proc arena_allocate from ArenaUtils with arena, result_len plus 1, 1
    End If
    Otherwise:
        Set result_ptr to proc allocate from MemoryUtils with result_len plus 1
    End If

    If result_ptr is equal to 0:
        Return 0
    End If

    Note: Perform replacements
    Let src_pos be 0
    Let dest_pos be 0

    While src_pos is less than str_len:
        Note: Check for match at current position
        Let match be 0
        If src_pos is less than or equal to str_len minus old_len:
            Set match to 1
            Let j be 0
            While j is less than old_len:
                Let str_ch be proc memory_get_byte from MemoryCore with str, src_pos plus j
                Let old_ch be proc memory_get_byte from MemoryCore with old_substr, j
                If str_ch is not equal to old_ch:
                    Set match to 0
                    Let break be 1
                End If
                Set j to j plus 1
            End While
        End If

        If match is equal to 1:
            Note: Copy new_substr
            If new_substr is not equal to 0:
                Let dest_ptr be result_ptr plus dest_pos
                Let dummy1 be proc memory_copy from MemoryCore with dest_ptr, new_substr, new_len
                Set dest_pos to dest_pos plus new_len
            End If
            Set src_pos to src_pos plus old_len
        End If
        Otherwise:
            Note: Copy single character
            Let ch be proc memory_get_byte from MemoryCore with str, src_pos
            Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, dest_pos, ch
            Set src_pos to src_pos plus 1
            Set dest_pos to dest_pos plus 1
        End If
    End While

    Note: Null terminate
    Let dummy3 be proc memory_set_byte from MemoryCore with result_ptr, dest_pos, 0

    Return result_ptr
End Process

Process called "string_replace_first" takes str as Integer, old_substr as Integer, new_substr as Integer, arena as Integer returns Integer:
    Note: Replace first occurrence of old_substr with new_substr
    Note: Returns pointer to new string with replacement

    If str is equal to 0:
        Return 0
    End If

    If old_substr is equal to 0:
        Return str
    End If

    Let str_len be proc string_length from StringCore with str
    Let old_len be proc string_length from StringCore with old_substr
    Let new_len be 0
    If new_substr is not equal to 0:
        Set new_len to proc string_length from StringCore with new_substr
    End If

    Note: Find first occurrence
    Let found_pos be negative 1
    Let i be 0
    While i is less than or equal to str_len minus old_len:
        Let match be 1
        Let j be 0
        While j is less than old_len:
            Let str_ch be proc memory_get_byte from MemoryCore with str, i plus j
            Let old_ch be proc memory_get_byte from MemoryCore with old_substr, j
            If str_ch is not equal to old_ch:
                Set match to 0
                Let break be 1
            End If
            Set j to j plus 1
        End While

        If match is equal to 1:
            Set found_pos to i
            Let break be 1
        End If

        Set i to i plus 1
    End While

    Note: If not found, return copy of original
    If found_pos is equal to negative 1:
        Let result_ptr be 0
        If arena is not equal to 0:
            Set result_ptr to proc arena_allocate from ArenaUtils with arena, str_len plus 1, 1
        End If
        Otherwise:
            Set result_ptr to proc allocate from MemoryUtils with str_len plus 1
        End If
        If result_ptr is not equal to 0:
            Let dummy1 be proc memory_copy from MemoryCore with result_ptr, str, str_len
            Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, str_len, 0
        End If
        Return result_ptr
    End If

    Note: Calculate result length
    Let result_len be str_len minus old_len plus new_len

    Note: Allocate result buffer
    Let result_ptr be 0
    If arena is not equal to 0:
        Set result_ptr to proc arena_allocate from ArenaUtils with arena, result_len plus 1, 1
    End If
    Otherwise:
        Set result_ptr to proc allocate from MemoryUtils with result_len plus 1
    End If

    If result_ptr is equal to 0:
        Return 0
    End If

    Note: Copy part before match
    If found_pos is greater than 0:
        Let dummy3 be proc memory_copy from MemoryCore with result_ptr, str, found_pos
    End If

    Note: Copy new_substr
    Let dest_pos be found_pos
    If new_substr is not equal to 0:
        Let dest_ptr be result_ptr plus dest_pos
        Let dummy4 be proc memory_copy from MemoryCore with dest_ptr, new_substr, new_len
        Set dest_pos to dest_pos plus new_len
    End If

    Note: Copy part after match
    Let after_match_pos be found_pos plus old_len
    Let remaining_len be str_len minus after_match_pos
    If remaining_len is greater than 0:
        Let src_ptr be str plus after_match_pos
        Let dest_ptr be result_ptr plus dest_pos
        Let dummy5 be proc memory_copy from MemoryCore with dest_ptr, src_ptr, remaining_len
    End If

    Note: Null terminate
    Let dummy6 be proc memory_set_byte from MemoryCore with result_ptr, result_len, 0

    Return result_ptr
End Process

Note: ============================================================================
Note: String Interning Operations
Note: ============================================================================

Note: Global interning hashtable (initialized on first use)
Let GLOBAL_INTERN_TABLE be 0

Note: Interned String Entry Structure (24 bytes)
Note:   offset 0:  string_ptr (pointer to interned string, 8 bytes)
Note:   offset 8:  string_len (length of string, 8 bytes)
Note:   offset 16: ref_count (reference count, 8 bytes)

Private Process called "string_intern_init" returns Integer:
    Note: Initialize global interning table if needed
    Note: Returns 1 if initialized, 0 on failure

    If GLOBAL_INTERN_TABLE is not equal to 0:
        Return 1  Note: Already initialized
    End If

    Note: Create hashtable with initial capacity of 256
    Set GLOBAL_INTERN_TABLE to proc allocate from MemoryUtils with 64

    If GLOBAL_INTERN_TABLE is equal to 0:
        Return 0
    End If

    Note: Initialize hashtable fields (64 bytes)
    Note: buckets, capacity, count, load_factor, arena, hash_func, is_owned, collision_count
    Let initial_capacity be 256
    Let buckets be proc allocate from MemoryUtils with initial_capacity times 8

    If buckets is equal to 0:
        Let dummy_free be proc deallocate from MemoryUtils with GLOBAL_INTERN_TABLE
        Set GLOBAL_INTERN_TABLE to 0
        Return 0
    End If

    Let dummy1 be proc memory_set_integer from MemoryCore with GLOBAL_INTERN_TABLE, 0, buckets
    Let dummy2 be proc memory_set_integer from MemoryCore with GLOBAL_INTERN_TABLE, 8, initial_capacity
    Let dummy3 be proc memory_set_integer from MemoryCore with GLOBAL_INTERN_TABLE, 16, 0  Note: count
    Let dummy4 be proc memory_set_integer from MemoryCore with GLOBAL_INTERN_TABLE, 24, 75  Note: load_factor 75%
    Let dummy5 be proc memory_set_integer from MemoryCore with GLOBAL_INTERN_TABLE, 32, 0  Note: no arena
    Let dummy6 be proc memory_set_integer from MemoryCore with GLOBAL_INTERN_TABLE, 40, 1  Note: DJB2 hash
    Let dummy7 be proc memory_set_integer from MemoryCore with GLOBAL_INTERN_TABLE, 48, 1  Note: is_owned
    Let dummy8 be proc memory_set_integer from MemoryCore with GLOBAL_INTERN_TABLE, 56, 0  Note: collision_count

    Return 1
End Process

Private Process called "string_intern_hash" takes str as Integer, len as Integer returns Integer:
    Note: DJB2 hash algorithm for string interning
    Let hash be 5381
    Let i be 0

    While i is less than len:
        Let ch be proc memory_get_byte from MemoryCore with str, i
        Let hash_times_33 be hash times 33
        Set hash to hash_times_33 plus ch
        Set i to i plus 1
    End While

    Return hash
End Process

Process called "string_intern" takes str as Integer returns Integer:
    Note: Intern string for efficient comparison and storage
    Note: Returns pointer to interned entry (not the string itself)
    Note: Increments reference count if already interned

    If str is equal to 0:
        Return 0
    End If

    Note: Initialize interning table if needed
    Let init_result be proc string_intern_init
    If init_result is equal to 0:
        Return 0
    End If

    Let str_len be proc string_length from StringCore with str
    Let hash_value be proc string_intern_hash with str, str_len
    Let capacity be proc memory_get_integer from MemoryCore with GLOBAL_INTERN_TABLE, 8
    Let bucket_index be hash_value modulo by capacity

    Note: Get bucket linked list
    Let buckets be proc memory_get_integer from MemoryCore with GLOBAL_INTERN_TABLE, 0
    Let bucket_offset be bucket_index times 8
    Let bucket_addr be buckets plus bucket_offset
    Let entry be proc memory_get_integer from MemoryCore with bucket_addr, 0

    Note: Search for existing interned string
    While entry is not equal to 0:
        Let entry_str be proc memory_get_integer from MemoryCore with entry, 0
        Let entry_len be proc memory_get_integer from MemoryCore with entry, 8

        Note: Compare strings
        If entry_len is equal to str_len:
            Let match be 1
            Let i be 0
            While i is less than str_len:
                Let ch1 be proc memory_get_byte from MemoryCore with entry_str, i
                Let ch2 be proc memory_get_byte from MemoryCore with str, i
                If ch1 is not equal to ch2:
                    Set match to 0
                    Let break be 1
                End If
                Set i to i plus 1
            End While

            If match is equal to 1:
                Note: Found - increment reference count
                Let ref_count be proc memory_get_integer from MemoryCore with entry, 16
                Let dummy be proc memory_set_integer from MemoryCore with entry, 16, ref_count plus 1
                Return entry
            End If
        End If

        Note: Move to next entry in bucket (entry structure has next pointer at offset 24)
        Set entry to proc memory_get_integer from MemoryCore with entry, 24
    End While

    Note: Not found - create new interned string
    Let new_entry be proc allocate from MemoryUtils with 32  Note: 24 bytes + 8 for next pointer
    If new_entry is equal to 0:
        Return 0
    End If

    Note: Allocate copy of string
    Let interned_str be proc allocate from MemoryUtils with str_len plus 1
    If interned_str is equal to 0:
        Let dummy_free be proc deallocate from MemoryUtils with new_entry
        Return 0
    End If

    Let dummy1 be proc memory_copy from MemoryCore with interned_str, str, str_len
    Let dummy2 be proc memory_set_byte from MemoryCore with interned_str, str_len, 0

    Note: Initialize entry
    Let dummy3 be proc memory_set_integer from MemoryCore with new_entry, 0, interned_str
    Let dummy4 be proc memory_set_integer from MemoryCore with new_entry, 8, str_len
    Let dummy5 be proc memory_set_integer from MemoryCore with new_entry, 16, 1  Note: ref_count = 1
    Let dummy6 be proc memory_set_integer from MemoryCore with new_entry, 24, entry  Note: next = old head

    Note: Insert at head of bucket
    Let dummy7 be proc memory_set_integer from MemoryCore with bucket_addr, 0, new_entry

    Note: Update count
    Let count be proc memory_get_integer from MemoryCore with GLOBAL_INTERN_TABLE, 16
    Let dummy8 be proc memory_set_integer from MemoryCore with GLOBAL_INTERN_TABLE, 16, count plus 1

    Return new_entry
End Process

Process called "string_intern_release" takes interned_entry as Integer returns Nothing:
    Note: Release reference to interned string
    Note: Decrements reference count
    Note: Frees string if reference count reaches zero

    If interned_entry is equal to 0:
        Return
    End If

    Let ref_count be proc memory_get_integer from MemoryCore with interned_entry, 16
    If ref_count is less than or equal to 0:
        Return  Note: Already freed or invalid
    End If

    Set ref_count to ref_count minus 1
    Let dummy1 be proc memory_set_integer from MemoryCore with interned_entry, 16, ref_count

    If ref_count is equal to 0:
        Note: Free interned string and entry
        Let str_ptr be proc memory_get_integer from MemoryCore with interned_entry, 0
        If str_ptr is not equal to 0:
            Let dummy2 be proc deallocate from MemoryUtils with str_ptr
        End If
        Let dummy3 be proc deallocate from MemoryUtils with interned_entry

        Note: Update count
        If GLOBAL_INTERN_TABLE is not equal to 0:
            Let count be proc memory_get_integer from MemoryCore with GLOBAL_INTERN_TABLE, 16
            Let dummy4 be proc memory_set_integer from MemoryCore with GLOBAL_INTERN_TABLE, 16, count minus 1
        End If
    End If
End Process

Process called "string_intern_get" takes str as Integer returns Integer:
    Note: Get interned string if it exists
    Note: Returns pointer to interned entry or 0 if not found
    Note: Does NOT increment reference count

    If str is equal to 0:
        Return 0
    End If

    If GLOBAL_INTERN_TABLE is equal to 0:
        Return 0  Note: No interning table initialized
    End If

    Let str_len be proc string_length from StringCore with str
    Let hash_value be proc string_intern_hash with str, str_len
    Let capacity be proc memory_get_integer from MemoryCore with GLOBAL_INTERN_TABLE, 8
    Let bucket_index be hash_value modulo by capacity

    Note: Get bucket linked list
    Let buckets be proc memory_get_integer from MemoryCore with GLOBAL_INTERN_TABLE, 0
    Let bucket_offset be bucket_index times 8
    Let bucket_addr be buckets plus bucket_offset
    Let entry be proc memory_get_integer from MemoryCore with bucket_addr, 0

    Note: Search for existing interned string
    While entry is not equal to 0:
        Let entry_str be proc memory_get_integer from MemoryCore with entry, 0
        Let entry_len be proc memory_get_integer from MemoryCore with entry, 8

        Note: Compare strings
        If entry_len is equal to str_len:
            Let match be 1
            Let i be 0
            While i is less than str_len:
                Let ch1 be proc memory_get_byte from MemoryCore with entry_str, i
                Let ch2 be proc memory_get_byte from MemoryCore with str, i
                If ch1 is not equal to ch2:
                    Set match to 0
                    Let break be 1
                End If
                Set i to i plus 1
            End While

            If match is equal to 1:
                Return entry  Note: Found - return without incrementing ref count
            End If
        End If

        Note: Move to next entry in bucket
        Set entry to proc memory_get_integer from MemoryCore with entry, 24
    End While

    Return 0  Note: Not found
End Process

Process called "string_intern_clear" returns Nothing:
    Note: Clear all interned strings
    Note: Frees all interned string data and buckets
    Note: Resets global interning table

    If GLOBAL_INTERN_TABLE is equal to 0:
        Return  Note: Nothing to clear
    End If

    Let capacity be proc memory_get_integer from MemoryCore with GLOBAL_INTERN_TABLE, 8
    Let buckets be proc memory_get_integer from MemoryCore with GLOBAL_INTERN_TABLE, 0

    Note: Free all entries in all buckets
    Let i be 0
    While i is less than capacity:
        Let bucket_offset be i times 8
        Let bucket_addr be buckets plus bucket_offset
        Let entry be proc memory_get_integer from MemoryCore with bucket_addr, 0

        Note: Free linked list in this bucket
        While entry is not equal to 0:
            Let next_entry be proc memory_get_integer from MemoryCore with entry, 24
            Let str_ptr be proc memory_get_integer from MemoryCore with entry, 0

            Note: Free interned string
            If str_ptr is not equal to 0:
                Let dummy1 be proc deallocate from MemoryUtils with str_ptr
            End If

            Note: Free entry
            Let dummy2 be proc deallocate from MemoryUtils with entry

            Set entry to next_entry
        End While

        Set i to i plus 1
    End While

    Note: Free buckets array
    If buckets is not equal to 0:
        Let dummy3 be proc deallocate from MemoryUtils with buckets
    End If

    Note: Free hashtable structure
    Let dummy4 be proc deallocate from MemoryUtils with GLOBAL_INTERN_TABLE
    Set GLOBAL_INTERN_TABLE to 0
End Process

Note: ============================================================================
Note: String Validation Operations
Note: ============================================================================

Process called "string_validate" takes str as Integer returns Integer:
    Note: Validate string for correctness and safety
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks for null pointer, valid UTF-8, no embedded nulls

    If str is equal to 0:
        Return 0  Note: Null pointer is invalid
    End If

    Let len be proc string_length from StringCore with str
    Let i be 0
    Let is_valid be 1

    While i is less than len:
        Let byte be proc memory_get_byte from MemoryCore with str, i

        Note: Check for embedded null bytes (security issue)
        If byte is equal to 0:
            Set is_valid to 0
            Let break be 1
        End If

        Note: Basic UTF-8 validation
        Note: ASCII: 0-127 (single byte)
        If byte is less than 128:
            Set i to i plus 1
        End If
        Otherwise If byte is greater than or equal to 192:
            Note: Multi-byte UTF-8 sequence
            Note: 110xxxxx = 2-byte (192-223)
            Note: 1110xxxx = 3-byte (224-239)
            Note: 11110xxx = 4-byte (240-247)

            Let expected_bytes be 0
            If byte is less than 224:
                Set expected_bytes to 2
            End If
            Otherwise If byte is less than 240:
                Set expected_bytes to 3
            End If
            Otherwise If byte is less than 248:
                Set expected_bytes to 4
            End If
            Otherwise:
                Note: Invalid UTF-8 start byte
                Set is_valid to 0
                Let break be 1
            End If

            Note: Validate continuation bytes (10xxxxxx = 128-191)
            Let j be 1
            While j is less than expected_bytes:
                If i plus j is greater than or equal to len:
                    Set is_valid to 0
                    Let break be 1
                End If

                Let cont_byte be proc memory_get_byte from MemoryCore with str, i plus j
                If cont_byte is less than 128:
                    Set is_valid to 0
                    Let break be 1
                End If
                Otherwise If cont_byte is greater than or equal to 192:
                    Set is_valid to 0
                    Let break be 1
                End If

                Set j to j plus 1
            End While

            Set i to i plus expected_bytes
        End If
        Otherwise:
            Note: Invalid UTF-8 byte (128-191 outside continuation)
            Set is_valid to 0
            Let break be 1
        End If
    End While

    Return is_valid
End Process

Process called "string_sanitize" takes str as Integer, arena as Integer returns Integer:
    Note: Sanitize string for security
    Note: Removes control characters, nulls, and dangerous sequences
    Note: Returns pointer to sanitized string

    If str is equal to 0:
        Return 0
    End If

    Let len be proc string_length from StringCore with str

    Note: Allocate result buffer (worst case: same size)
    Let result_ptr be 0
    If arena is not equal to 0:
        Set result_ptr to proc arena_allocate from ArenaUtils with arena, len plus 1, 1
    End If
    Otherwise:
        Set result_ptr to proc allocate from MemoryUtils with len plus 1
    End If

    If result_ptr is equal to 0:
        Return 0
    End If

    Let i be 0
    Let j be 0

    While i is less than len:
        Let ch be proc memory_get_byte from MemoryCore with str, i
        Let should_keep be 1

        Note: Filter out dangerous characters
        Note: Remove null bytes (0)
        If ch is equal to 0:
            Set should_keep to 0
        End If

        Note: Remove control characters (except tab, newline, carriage return)
        Otherwise If ch is less than 32:
            If ch is not equal to 9:  Note: tab
                If ch is not equal to 10:  Note: newline
                    If ch is not equal to 13:  Note: carriage return
                        Set should_keep to 0
                    End If
                End If
            End If
        End If

        Note: Remove DEL character (127)
        Otherwise If ch is equal to 127:
            Set should_keep to 0
        End If

        If should_keep is equal to 1:
            Let dummy be proc memory_set_byte from MemoryCore with result_ptr, j, ch
            Set j to j plus 1
        End If

        Set i to i plus 1
    End While

    Note: Null terminate
    Let dummy be proc memory_set_byte from MemoryCore with result_ptr, j, 0

    Return result_ptr
End Process

Process called "string_escape" takes str as Integer, arena as Integer returns Integer:
    Note: Escape special characters for safe display
    Note: Converts \n, \r, \t, \", \\, etc. to escaped forms
    Note: Returns pointer to escaped string

    If str is equal to 0:
        Return 0
    End If

    Let len be proc string_length from StringCore with str

    Note: Count characters that need escaping (worst case: every char needs 2 bytes)
    Let escape_count be 0
    Let i be 0
    While i is less than len:
        Let ch be proc memory_get_byte from MemoryCore with str, i
        Note: Characters that need escaping: \n(10), \r(13), \t(9), \"(34), \\(92)
        If ch is equal to 10:
            Set escape_count to escape_count plus 1
        End If
        Otherwise If ch is equal to 13:
            Set escape_count to escape_count plus 1
        End If
        Otherwise If ch is equal to 9:
            Set escape_count to escape_count plus 1
        End If
        Otherwise If ch is equal to 34:
            Set escape_count to escape_count plus 1
        End If
        Otherwise If ch is equal to 92:
            Set escape_count to escape_count plus 1
        End If
        Set i to i plus 1
    End While

    Note: Allocate result buffer
    Let result_len be len plus escape_count
    Let result_ptr be 0
    If arena is not equal to 0:
        Set result_ptr to proc arena_allocate from ArenaUtils with arena, result_len plus 1, 1
    End If
    Otherwise:
        Set result_ptr to proc allocate from MemoryUtils with result_len plus 1
    End If

    If result_ptr is equal to 0:
        Return 0
    End If

    Note: Perform escaping
    Set i to 0
    Let j be 0
    While i is less than len:
        Let ch be proc memory_get_byte from MemoryCore with str, i

        If ch is equal to 10:  Note: newline
            Let dummy1 be proc memory_set_byte from MemoryCore with result_ptr, j, 92  Note: backslash
            Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, j plus 1, 110  Note: 'n'
            Set j to j plus 2
        End If
        Otherwise If ch is equal to 13:  Note: carriage return
            Let dummy1 be proc memory_set_byte from MemoryCore with result_ptr, j, 92
            Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, j plus 1, 114  Note: 'r'
            Set j to j plus 2
        End If
        Otherwise If ch is equal to 9:  Note: tab
            Let dummy1 be proc memory_set_byte from MemoryCore with result_ptr, j, 92
            Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, j plus 1, 116  Note: 't'
            Set j to j plus 2
        End If
        Otherwise If ch is equal to 34:  Note: double quote
            Let dummy1 be proc memory_set_byte from MemoryCore with result_ptr, j, 92
            Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, j plus 1, 34
            Set j to j plus 2
        End If
        Otherwise If ch is equal to 92:  Note: backslash
            Let dummy1 be proc memory_set_byte from MemoryCore with result_ptr, j, 92
            Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, j plus 1, 92
            Set j to j plus 2
        End If
        Otherwise:
            Let dummy be proc memory_set_byte from MemoryCore with result_ptr, j, ch
            Set j to j plus 1
        End If

        Set i to i plus 1
    End While

    Note: Null terminate
    Let dummy be proc memory_set_byte from MemoryCore with result_ptr, j, 0

    Return result_ptr
End Process

Process called "string_unescape" takes str as Integer, arena as Integer returns Integer:
    Note: Unescape escaped characters
    Note: Converts \\n, \\r, \\t, \\\", \\\\ back to original
    Note: Returns pointer to unescaped string

    If str is equal to 0:
        Return 0
    End If

    Let len be proc string_length from StringCore with str

    Note: Allocate result buffer (at most same size as input)
    Let result_ptr be 0
    If arena is not equal to 0:
        Set result_ptr to proc arena_allocate from ArenaUtils with arena, len plus 1, 1
    End If
    Otherwise:
        Set result_ptr to proc allocate from MemoryUtils with len plus 1
    End If

    If result_ptr is equal to 0:
        Return 0
    End If

    Let i be 0
    Let j be 0

    While i is less than len:
        Let ch be proc memory_get_byte from MemoryCore with str, i

        Note: Check for escape sequence
        If ch is equal to 92:  Note: backslash
            Let next_i be i plus 1
            If next_i is less than len:
                Let next_ch be proc memory_get_byte from MemoryCore with str, next_i

                If next_ch is equal to 110:  Note: 'n'
                    Let dummy be proc memory_set_byte from MemoryCore with result_ptr, j, 10  Note: newline
                    Set j to j plus 1
                    Set i to i plus 2
                    Let continue be 1
                End If
                Otherwise If next_ch is equal to 114:  Note: 'r'
                    Let dummy be proc memory_set_byte from MemoryCore with result_ptr, j, 13  Note: carriage return
                    Set j to j plus 1
                    Set i to i plus 2
                    Let continue be 1
                End If
                Otherwise If next_ch is equal to 116:  Note: 't'
                    Let dummy be proc memory_set_byte from MemoryCore with result_ptr, j, 9  Note: tab
                    Set j to j plus 1
                    Set i to i plus 2
                    Let continue be 1
                End If
                Otherwise If next_ch is equal to 34:  Note: '"'
                    Let dummy be proc memory_set_byte from MemoryCore with result_ptr, j, 34
                    Set j to j plus 1
                    Set i to i plus 2
                    Let continue be 1
                End If
                Otherwise If next_ch is equal to 92:  Note: backslash
                    Let dummy be proc memory_set_byte from MemoryCore with result_ptr, j, 92
                    Set j to j plus 1
                    Set i to i plus 2
                    Let continue be 1
                End If
            End If
        End If

        If continue is equal to 0:
            Note: Not an escape sequence, copy character as-is
            Let dummy be proc memory_set_byte from MemoryCore with result_ptr, j, ch
            Set j to j plus 1
            Set i to i plus 1
        End If
        Otherwise:
            Set continue to 0
        End If
    End While

    Note: Null terminate
    Let dummy be proc memory_set_byte from MemoryCore with result_ptr, j, 0

    Return result_ptr
End Process

Note: ============================================================================
Note: String Performance Operations
Note: ============================================================================

Process called "string_length" takes buffer as Integer returns Integer:
    Note: Get length of StringBuffer
    Note: buffer is pointer to StringBuffer structure (48 bytes)
    Note: Returns string length in bytes

    If buffer is equal to 0:
        Return 0
    End If

    Note: Extract length field from StringBuffer (offset 8)
    Let length be proc memory_get_integer from MemoryCore with buffer, 8
    Return length
End Process

Process called "string_capacity" takes buffer as Integer returns Integer:
    Note: Get capacity of StringBuffer
    Note: buffer is pointer to StringBuffer structure (48 bytes)
    Note: Returns buffer capacity in bytes

    If buffer is equal to 0:
        Return 0
    End If

    Note: Extract capacity field from StringBuffer (offset 16)
    Let capacity be proc memory_get_integer from MemoryCore with buffer, 16
    Return capacity
End Process

Process called "string_is_empty" takes buffer as Integer returns Integer:
    Note: Check if StringBuffer is empty
    Note: Returns 1 if empty (length is 0), 0 if not empty

    If buffer is equal to 0:
        Return 1  Note: Null buffer is considered empty
    End If

    Let length be proc memory_get_integer from MemoryCore with buffer, 8
    If length is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "string_reserve" takes buffer as Integer, new_capacity as Integer returns Integer:
    Note: Reserve capacity for StringBuffer
    Note: Ensures buffer has at least new_capacity bytes available
    Note: Returns 1 on success, 0 on failure

    If buffer is equal to 0:
        Return 0
    End If

    If new_capacity is less than or equal to 0:
        Return 0
    End If

    Note: Get current capacity
    Let current_capacity be proc memory_get_integer from MemoryCore with buffer, 16

    Note: If already large enough, nothing to do
    If new_capacity is less than or equal to current_capacity:
        Return 1
    End If

    Note: Check if buffer is arena-allocated or owned
    Let arena be proc memory_get_integer from MemoryCore with buffer, 24
    Let is_owned be proc memory_get_integer from MemoryCore with buffer, 40

    Note: Get current data pointer and length
    Let old_data be proc memory_get_integer from MemoryCore with buffer, 0
    Let length be proc memory_get_integer from MemoryCore with buffer, 8

    Note: Allocate new buffer
    Let new_data be 0
    If arena is not equal to 0:
        Set new_data to proc arena_allocate from ArenaUtils with arena, new_capacity, 1
    End If
    Otherwise:
        Set new_data to proc allocate from MemoryUtils with new_capacity
    End If

    If new_data is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Copy existing data to new buffer
    If old_data is not equal to 0:
        If length is greater than 0:
            Let dummy1 be proc memory_copy from MemoryCore with new_data, old_data, length
        End If

        Note: Free old buffer if owned
        If is_owned is equal to 1:
            Let dummy2 be proc deallocate from MemoryUtils with old_data
        End If
    End If

    Note: Update StringBuffer fields
    Let dummy3 be proc memory_set_integer from MemoryCore with buffer, 0, new_data
    Let dummy4 be proc memory_set_integer from MemoryCore with buffer, 16, new_capacity

    Return 1
End Process

Process called "string_shrink" takes buffer as Integer returns Integer:
    Note: Shrink StringBuffer capacity to fit current content
    Note: Reduces memory usage by reallocating to exact size needed
    Note: Returns 1 on success, 0 on failure

    If buffer is equal to 0:
        Return 0
    End If

    Note: Get current length and capacity
    Let length be proc memory_get_integer from MemoryCore with buffer, 8
    Let current_capacity be proc memory_get_integer from MemoryCore with buffer, 16

    Note: Calculate needed capacity (length + 1 for null terminator)
    Let needed_capacity be length plus 1

    Note: If already at optimal size, nothing to do
    If current_capacity is less than or equal to needed_capacity:
        Return 1
    End If

    Note: Check if buffer is arena-allocated
    Let arena be proc memory_get_integer from MemoryCore with buffer, 24
    If arena is not equal to 0:
        Note: Arena allocations cannot be shrunk (arena owns memory)
        Return 1  Note: Return success but don't actually shrink
    End If

    Note: Get current data pointer
    Let old_data be proc memory_get_integer from MemoryCore with buffer, 0

    If old_data is equal to 0:
        Return 0
    End If

    Note: Allocate new smaller buffer
    Let new_data be proc allocate from MemoryUtils with needed_capacity

    If new_data is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Copy existing data to new buffer
    If length is greater than 0:
        Let dummy1 be proc memory_copy from MemoryCore with new_data, old_data, length
    End If

    Note: Null terminate
    Let dummy2 be proc memory_set_byte from MemoryCore with new_data, length, 0

    Note: Check if old buffer was owned
    Let is_owned be proc memory_get_integer from MemoryCore with buffer, 40
    If is_owned is equal to 1:
        Let dummy3 be proc deallocate from MemoryUtils with old_data
    End If

    Note: Update StringBuffer fields
    Let dummy4 be proc memory_set_integer from MemoryCore with buffer, 0, new_data
    Let dummy5 be proc memory_set_integer from MemoryCore with buffer, 16, needed_capacity
    Let dummy6 be proc memory_set_integer from MemoryCore with buffer, 40, 1  Note: Mark as owned

    Return 1
End Process

Note: ============================================================================
Note: String Encoding Operations
Note: ============================================================================

Note: Encoding Constants
Let ENCODING_ASCII be 1
Let ENCODING_UTF8 be 2
Let ENCODING_UTF16_LE be 3
Let ENCODING_UTF16_BE be 4
Let ENCODING_UTF32_LE be 5
Let ENCODING_UTF32_BE be 6
Let ENCODING_LATIN1 be 7

Note: Normalization Form Constants
Let NORMALIZATION_NFC be 1   Note: Canonical Decomposition followed by Canonical Composition
Let NORMALIZATION_NFD be 2   Note: Canonical Decomposition
Let NORMALIZATION_NFKC be 3  Note: Compatibility Decomposition followed by Canonical Composition
Let NORMALIZATION_NFKD be 4  Note: Compatibility Decomposition

Process called "string_encode" takes str as Integer, encoding as Integer, arena as Integer returns Integer:
    Note: Encode string to specified encoding
    Note: Currently supports ASCII, UTF-8, and Latin-1
    Note: Returns pointer to encoded string

    If str is equal to 0:
        Return 0
    End If

    Let len be proc string_length from StringCore with str

    Note: UTF-8 encoding (current internal format - just copy)
    If encoding is equal to ENCODING_UTF8:
        Let result_ptr be 0
        If arena is not equal to 0:
            Set result_ptr to proc arena_allocate from ArenaUtils with arena, len plus 1, 1
        End If
        Otherwise:
            Set result_ptr to proc allocate from MemoryUtils with len plus 1
        End If

        If result_ptr is not equal to 0:
            Let dummy1 be proc memory_copy from MemoryCore with result_ptr, str, len
            Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, len, 0
        End If

        Return result_ptr
    End If

    Note: ASCII encoding (strip high bytes)
    If encoding is equal to ENCODING_ASCII:
        Let result_ptr be 0
        If arena is not equal to 0:
            Set result_ptr to proc arena_allocate from ArenaUtils with arena, len plus 1, 1
        End If
        Otherwise:
            Set result_ptr to proc allocate from MemoryUtils with len plus 1
        End If

        If result_ptr is equal to 0:
            Return 0
        End If

        Let i be 0
        While i is less than len:
            Let ch be proc memory_get_byte from MemoryCore with str, i
            Note: Convert non-ASCII to question mark
            If ch is greater than or equal to 128:
                Set ch to 63  Note: '?'
            End If
            Let dummy be proc memory_set_byte from MemoryCore with result_ptr, i, ch
            Set i to i plus 1
        End While

        Let dummy_null be proc memory_set_byte from MemoryCore with result_ptr, len, 0
        Return result_ptr
    End If

    Note: Latin-1 (ISO-8859-1) encoding
    If encoding is equal to ENCODING_LATIN1:
        Note: Convert UTF-8 to Latin-1 (limited to first 256 Unicode codepoints)
        Let result_ptr be 0
        If arena is not equal to 0:
            Set result_ptr to proc arena_allocate from ArenaUtils with arena, len plus 1, 1
        End If
        Otherwise:
            Set result_ptr to proc allocate from MemoryUtils with len plus 1
        End If

        If result_ptr is equal to 0:
            Return 0
        End If

        Let i be 0
        Let j be 0
        While i is less than len:
            Let byte be proc memory_get_byte from MemoryCore with str, i

            Note: ASCII pass-through
            If byte is less than 128:
                Let dummy be proc memory_set_byte from MemoryCore with result_ptr, j, byte
                Set j to j plus 1
                Set i to i plus 1
            End If
            Otherwise If byte is greater than or equal to 192:
                Note: 2-byte UTF-8 sequence (covers Latin-1 extended range)
                If byte is less than 224:
                    If i plus 1 is less than len:
                        Let byte2 be proc memory_get_byte from MemoryCore with str, i plus 1
                        Note: Decode to Latin-1 codepoint
                        Let high_bits be byte minus 192 times 64
                        Let low_bits be byte2 minus 128
                        Let codepoint be high_bits plus low_bits
                        Let dummy be proc memory_set_byte from MemoryCore with result_ptr, j, codepoint
                        Set j to j plus 1
                        Set i to i plus 2
                    End If
                    Otherwise:
                        Set i to i plus 1  Note: Invalid sequence
                    End If
                End If
                Otherwise:
                    Note: Multi-byte sequences beyond Latin-1 - replace with '?'
                    Let dummy be proc memory_set_byte from MemoryCore with result_ptr, j, 63
                    Set j to j plus 1
                    Set i to i plus 1
                End If
            End If
            Otherwise:
                Set i to i plus 1  Note: Invalid byte
            End If
        End While

        Let dummy_null be proc memory_set_byte from MemoryCore with result_ptr, j, 0
        Return result_ptr
    End If

    Note: Unsupported encoding - return copy as UTF-8
    Let result_ptr be 0
    If arena is not equal to 0:
        Set result_ptr to proc arena_allocate from ArenaUtils with arena, len plus 1, 1
    End If
    Otherwise:
        Set result_ptr to proc allocate from MemoryUtils with len plus 1
    End If

    If result_ptr is not equal to 0:
        Let dummy1 be proc memory_copy from MemoryCore with result_ptr, str, len
        Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, len, 0
    End If

    Return result_ptr
End Process

Process called "string_decode" takes str as Integer, encoding as Integer, arena as Integer returns Integer:
    Note: Decode string from specified encoding to UTF-8
    Note: Currently supports ASCII, UTF-8, and Latin-1
    Note: Returns pointer to decoded UTF-8 string

    If str is equal to 0:
        Return 0
    End If

    Let len be proc string_length from StringCore with str

    Note: UTF-8 decoding (already UTF-8 - just copy)
    If encoding is equal to ENCODING_UTF8:
        Let result_ptr be 0
        If arena is not equal to 0:
            Set result_ptr to proc arena_allocate from ArenaUtils with arena, len plus 1, 1
        End If
        Otherwise:
            Set result_ptr to proc allocate from MemoryUtils with len plus 1
        End If

        If result_ptr is not equal to 0:
            Let dummy1 be proc memory_copy from MemoryCore with result_ptr, str, len
            Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, len, 0
        End If

        Return result_ptr
    End If

    Note: ASCII decoding (ASCII is subset of UTF-8)
    If encoding is equal to ENCODING_ASCII:
        Let result_ptr be 0
        If arena is not equal to 0:
            Set result_ptr to proc arena_allocate from ArenaUtils with arena, len plus 1, 1
        End If
        Otherwise:
            Set result_ptr to proc allocate from MemoryUtils with len plus 1
        End If

        If result_ptr is not equal to 0:
            Let dummy1 be proc memory_copy from MemoryCore with result_ptr, str, len
            Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, len, 0
        End If

        Return result_ptr
    End If

    Note: Latin-1 (ISO-8859-1) decoding to UTF-8
    If encoding is equal to ENCODING_LATIN1:
        Note: Latin-1 bytes 128-255 need 2-byte UTF-8 encoding
        Note: Count extended characters
        Let extended_count be 0
        Let i be 0
        While i is less than len:
            Let byte be proc memory_get_byte from MemoryCore with str, i
            If byte is greater than or equal to 128:
                Set extended_count to extended_count plus 1
            End If
            Set i to i plus 1
        End While

        Note: Allocate result (original length + 1 extra byte per extended char)
        Let result_len be len plus extended_count
        Let result_ptr be 0
        If arena is not equal to 0:
            Set result_ptr to proc arena_allocate from ArenaUtils with arena, result_len plus 1, 1
        End If
        Otherwise:
            Set result_ptr to proc allocate from MemoryUtils with result_len plus 1
        End If

        If result_ptr is equal to 0:
            Return 0
        End If

        Note: Convert Latin-1 to UTF-8
        Set i to 0
        Let j be 0
        While i is less than len:
            Let byte be proc memory_get_byte from MemoryCore with str, i

            Note: ASCII bytes pass through
            If byte is less than 128:
                Let dummy be proc memory_set_byte from MemoryCore with result_ptr, j, byte
                Set j to j plus 1
            End If
            Otherwise:
                Note: Extended Latin-1 needs 2-byte UTF-8 encoding
                Note: Codepoint 128-255 = 110000xx 10xxxxxx
                Let high_byte be 192 plus byte divided by 64
                Let low_byte be 128 plus byte modulo by 64
                Let dummy1 be proc memory_set_byte from MemoryCore with result_ptr, j, high_byte
                Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, j plus 1, low_byte
                Set j to j plus 2
            End If

            Set i to i plus 1
        End While

        Let dummy_null be proc memory_set_byte from MemoryCore with result_ptr, j, 0
        Return result_ptr
    End If

    Note: Unsupported encoding - return copy as-is
    Let result_ptr be 0
    If arena is not equal to 0:
        Set result_ptr to proc arena_allocate from ArenaUtils with arena, len plus 1, 1
    End If
    Otherwise:
        Set result_ptr to proc allocate from MemoryUtils with len plus 1
    End If

    If result_ptr is not equal to 0:
        Let dummy1 be proc memory_copy from MemoryCore with result_ptr, str, len
        Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, len, 0
    End If

    Return result_ptr
End Process

Process called "string_detect_encoding" takes str as Integer returns Integer:
    Note: Detect string encoding using heuristics and BOM detection
    Note: Returns encoding constant (ENCODING_ASCII, ENCODING_UTF8, etc.)

    If str is equal to 0:
        Return ENCODING_UTF8  Note: Default to UTF-8
    End If

    Let len be proc string_length from StringCore with str

    If len is equal to 0:
        Return ENCODING_ASCII  Note: Empty string is valid ASCII
    End If

    Note: Check for UTF-8 BOM (EF BB BF)
    If len is greater than or equal to 3:
        Let byte1 be proc memory_get_byte from MemoryCore with str, 0
        Let byte2 be proc memory_get_byte from MemoryCore with str, 1
        Let byte3 be proc memory_get_byte from MemoryCore with str, 2

        If byte1 is equal to 239:
            If byte2 is equal to 187:
                If byte3 is equal to 191:
                    Return ENCODING_UTF8
                End If
            End If
        End If
    End If

    Note: Check for UTF-16 BOM (FE FF = BE, FF FE = LE)
    If len is greater than or equal to 2:
        Let byte1 be proc memory_get_byte from MemoryCore with str, 0
        Let byte2 be proc memory_get_byte from MemoryCore with str, 1

        If byte1 is equal to 254:
            If byte2 is equal to 255:
                Return ENCODING_UTF16_BE
            End If
        End If

        If byte1 is equal to 255:
            If byte2 is equal to 254:
                Return ENCODING_UTF16_LE
            End If
        End If
    End If

    Note: Heuristic detection - scan for character patterns
    Let has_extended be 0
    Let has_multibyte be 0
    Let is_valid_utf8 be 1
    Let i be 0

    While i is less than len:
        Let byte be proc memory_get_byte from MemoryCore with str, i

        Note: Extended ASCII (128-255)
        If byte is greater than or equal to 128:
            Set has_extended to 1

            Note: Check for valid UTF-8 multi-byte sequences
            If byte is greater than or equal to 192:
                Set has_multibyte to 1

                Note: Determine expected continuation bytes
                Let expected be 0
                If byte is less than 224:
                    Set expected to 1
                End If
                Otherwise If byte is less than 240:
                    Set expected to 2
                End If
                Otherwise If byte is less than 248:
                    Set expected to 3
                End If

                Note: Validate continuation bytes
                Let j be 1
                While j is less than or equal to expected:
                    If i plus j is greater than or equal to len:
                        Set is_valid_utf8 to 0
                        Let break be 1
                    End If

                    Let cont_byte be proc memory_get_byte from MemoryCore with str, i plus j
                    If cont_byte is less than 128:
                        Set is_valid_utf8 to 0
                        Let break be 1
                    End If
                    Otherwise If cont_byte is greater than or equal to 192:
                        Set is_valid_utf8 to 0
                        Let break be 1
                    End If

                    Set j to j plus 1
                End While

                Set i to i plus expected
            End If
            Otherwise:
                Note: Lone continuation byte (invalid UTF-8)
                Set is_valid_utf8 to 0
            End If
        End If

        Set i to i plus 1
    End While

    Note: Determine encoding based on heuristics
    If has_extended is equal to 0:
        Return ENCODING_ASCII  Note: Pure ASCII
    End If

    If has_multibyte is equal to 1:
        If is_valid_utf8 is equal to 1:
            Return ENCODING_UTF8  Note: Valid UTF-8 multi-byte
        End If
    End If

    Note: Has extended bytes but not valid UTF-8 - probably Latin-1
    Return ENCODING_LATIN1
End Process

Private Process called "unicode_decode_codepoint" takes str as Integer, pos as Integer, out_codepoint as Integer, out_bytes as Integer returns Integer:
    Note: Decode single UTF-8 codepoint at position
    Note: out_codepoint = pointer to store decoded codepoint (32-bit)
    Note: out_bytes = pointer to store number of bytes consumed
    Note: Returns 1 on success, 0 on failure

    Let byte1 be proc memory_get_byte from MemoryCore with str, pos

    Note: Single-byte ASCII (0-127)
    If byte1 is less than 128:
        Let dummy1 be proc memory_set_integer from MemoryCore with out_codepoint, 0, byte1
        Let dummy2 be proc memory_set_integer from MemoryCore with out_bytes, 0, 1
        Return 1
    End If

    Note: 2-byte sequence (110xxxxx 10xxxxxx)
    If byte1 is greater than or equal to 192:
        If byte1 is less than 224:
            Let byte2 be proc memory_get_byte from MemoryCore with str, pos plus 1
            If byte2 is greater than or equal to 128:
                If byte2 is less than 192:
                    Let val1 be byte1 minus 192 times 64
                    Let val2 be byte2 minus 128
                    Let codepoint be val1 plus val2
                    Let dummy1 be proc memory_set_integer from MemoryCore with out_codepoint, 0, codepoint
                    Let dummy2 be proc memory_set_integer from MemoryCore with out_bytes, 0, 2
                    Return 1
                End If
            End If
            Return 0
        End If
    End If

    Note: 3-byte sequence (1110xxxx 10xxxxxx 10xxxxxx)
    If byte1 is greater than or equal to 224:
        If byte1 is less than 240:
            Let byte2 be proc memory_get_byte from MemoryCore with str, pos plus 1
            Let byte3 be proc memory_get_byte from MemoryCore with str, pos plus 2
            If byte2 is greater than or equal to 128:
                If byte2 is less than 192:
                    If byte3 is greater than or equal to 128:
                        If byte3 is less than 192:
                            Let val1 be byte1 minus 224 times 4096
                            Let val2 be byte2 minus 128 times 64
                            Let val3 be byte3 minus 128
                            Let codepoint be val1 plus val2 plus val3
                            Let dummy1 be proc memory_set_integer from MemoryCore with out_codepoint, 0, codepoint
                            Let dummy2 be proc memory_set_integer from MemoryCore with out_bytes, 0, 3
                            Return 1
                        End If
                    End If
                End If
            End If
            Return 0
        End If
    End If

    Note: 4-byte sequence (11110xxx 10xxxxxx 10xxxxxx 10xxxxxx)
    If byte1 is greater than or equal to 240:
        If byte1 is less than 248:
            Let byte2 be proc memory_get_byte from MemoryCore with str, pos plus 1
            Let byte3 be proc memory_get_byte from MemoryCore with str, pos plus 2
            Let byte4 be proc memory_get_byte from MemoryCore with str, pos plus 3
            If byte2 is greater than or equal to 128:
                If byte2 is less than 192:
                    If byte3 is greater than or equal to 128:
                        If byte3 is less than 192:
                            If byte4 is greater than or equal to 128:
                                If byte4 is less than 192:
                                    Let val1 be byte1 minus 240 times 262144
                                    Let val2 be byte2 minus 128 times 4096
                                    Let val3 be byte3 minus 128 times 64
                                    Let val4 be byte4 minus 128
                                    Let codepoint be val1 plus val2 plus val3 plus val4
                                    Let dummy1 be proc memory_set_integer from MemoryCore with out_codepoint, 0, codepoint
                                    Let dummy2 be proc memory_set_integer from MemoryCore with out_bytes, 0, 4
                                    Return 1
                                End If
                            End If
                        End If
                    End If
                End If
            End If
            Return 0
        End If
    End If

    Return 0
End Process

Private Process called "unicode_encode_codepoint" takes codepoint as Integer, out_buffer as Integer returns Integer:
    Note: Encode codepoint to UTF-8 bytes
    Note: out_buffer = pointer to buffer (must have at least 4 bytes)
    Note: Returns number of bytes written

    Note: ASCII (0-127)
    If codepoint is less than 128:
        Let dummy be proc memory_set_byte from MemoryCore with out_buffer, 0, codepoint
        Return 1
    End If

    Note: 2-byte (128-2047)
    If codepoint is less than 2048:
        Let byte1 be 192 plus codepoint divided by 64
        Let byte2 be 128 plus codepoint modulo by 64
        Let dummy1 be proc memory_set_byte from MemoryCore with out_buffer, 0, byte1
        Let dummy2 be proc memory_set_byte from MemoryCore with out_buffer, 1, byte2
        Return 2
    End If

    Note: 3-byte (2048-65535)
    If codepoint is less than 65536:
        Let byte1 be 224 plus codepoint divided by 4096
        Let remainder be codepoint modulo by 4096
        Let byte2 be 128 plus remainder divided by 64
        Let byte3 be 128 plus remainder modulo by 64
        Let dummy1 be proc memory_set_byte from MemoryCore with out_buffer, 0, byte1
        Let dummy2 be proc memory_set_byte from MemoryCore with out_buffer, 1, byte2
        Let dummy3 be proc memory_set_byte from MemoryCore with out_buffer, 2, byte3
        Return 3
    End If

    Note: 4-byte (65536-1114111)
    If codepoint is less than or equal to 1114111:
        Let byte1 be 240 plus codepoint divided by 262144
        Let remainder be codepoint modulo by 262144
        Let byte2 be 128 plus remainder divided by 4096
        Let remainder2 be remainder modulo by 4096
        Let byte3 be 128 plus remainder2 divided by 64
        Let byte4 be 128 plus remainder2 modulo by 64
        Let dummy1 be proc memory_set_byte from MemoryCore with out_buffer, 0, byte1
        Let dummy2 be proc memory_set_byte from MemoryCore with out_buffer, 1, byte2
        Let dummy3 be proc memory_set_byte from MemoryCore with out_buffer, 2, byte3
        Let dummy4 be proc memory_set_byte from MemoryCore with out_buffer, 3, byte4
        Return 4
    End If

    Return 0
End Process

Private Process called "unicode_get_combining_class" takes codepoint as Integer returns Integer:
    Note: Get Unicode Canonical Combining Class (CCC) for codepoint
    Note: Implements subset of Unicode combining classes for common diacritics
    Note: Returns 0 for non-combining, >0 for combining characters

    Note: Common combining diacritical marks (U+0300-U+036F)
    If codepoint is greater than or equal to 768:
        If codepoint is less than or equal to 879:
            Note: Combining diacritical marks have various classes
            Note: Return non-zero to indicate combining
            Return 230  Note: Most diacritics are class 230
        End If
    End If

    Note: Hebrew points (U+0591-U+05BD)
    If codepoint is greater than or equal to 1425:
        If codepoint is less than or equal to 1469:
            Return 220
        End If
    End If

    Note: Arabic combining marks (U+064B-U+0652)
    If codepoint is greater than or equal to 1611:
        If codepoint is less than or equal to 1618:
            Return 230
        End If
    End If

    Note: Default: non-combining
    Return 0
End Process

Private Process called "unicode_canonical_sort" takes codepoints as Integer, count as Integer returns Nothing:
    Note: Sort codepoints array by canonical combining class (bubble sort)
    Note: codepoints = pointer to array of integers (codepoint values)
    Note: count = number of codepoints in array
    Note: Stable sort maintains relative order of equal elements

    If count is less than or equal to 1:
        Return
    End If

    Let i be 0
    While i is less than count minus 1:
        Let j be 0
        While j is less than count minus i minus 1:
            Let offset_j be j times 8
            Let addr_j be codepoints plus offset_j
            Let cp_j be proc memory_get_integer from MemoryCore with addr_j, 0

            Let offset_j_plus_1 be j plus 1 times 8
            Let addr_j_plus_1 be codepoints plus offset_j_plus_1
            Let cp_j_plus_1 be proc memory_get_integer from MemoryCore with addr_j_plus_1, 0

            Let class_j be proc unicode_get_combining_class with cp_j
            Let class_j_plus_1 be proc unicode_get_combining_class with cp_j_plus_1

            Note: Swap if out of order (larger class should come later)
            If class_j is greater than class_j_plus_1:
                If class_j_plus_1 is greater than 0:
                    Note: Swap elements
                    Let dummy1 be proc memory_set_integer from MemoryCore with addr_j, 0, cp_j_plus_1
                    Let dummy2 be proc memory_set_integer from MemoryCore with addr_j_plus_1, 0, cp_j
                End If
            End If

            Set j to j plus 1
        End While
        Set i to i plus 1
    End While
End Process

Private Process called "unicode_compose" takes codepoints as Integer, count_ptr as Integer returns Nothing:
    Note: Perform Unicode canonical composition on decomposed codepoint sequence
    Note: codepoints = pointer to array of integers (codepoint values) - MODIFIED IN PLACE
    Note: count_ptr = pointer to integer containing codepoint count - UPDATED with new count
    Note: Implements Unicode Standard Annex #15 composition algorithm
    Note: Uses binary search on UNICODE_COMPOSITION_TABLE from unicode_tables.runa

    If codepoints is equal to 0:
        Return
    End If

    If count_ptr is equal to 0:
        Return
    End If

    Let count be proc memory_get_integer from MemoryCore with count_ptr, 0

    If count is less than or equal to 1:
        Return
    End If

    Note: Get composition table and count from unicode_tables.runa
    Let table_ptr be UNICODE_COMPOSITION_TABLE from UnicodeTables
    Let table_count be UNICODE_COMPOSITION_COUNT from UnicodeTables

    Note: Composition pass: combine base + combining mark sequences
    Note: Write position for composed output (compaction)
    Let write_pos be 1

    Note: Read position (start from second codepoint)
    Let read_pos be 1

    Note: Get first codepoint as starter
    Let starter_offset be 0
    Let starter_addr be codepoints plus starter_offset
    Let starter be proc memory_get_integer from MemoryCore with starter_addr, 0

    Note: Process each codepoint looking for composition opportunities
    While read_pos is less than count:
        Note: Get current codepoint
        Let current_offset be read_pos times 8
        Let current_addr be codepoints plus current_offset
        Let current be proc memory_get_integer from MemoryCore with current_addr, 0

        Note: Try to compose starter + current
        Note: Binary search in composition table for (starter, current) pair
        Let left be 0
        Let right be table_count minus 1
        Let found_composition be 0
        Let composed_result be 0

        While left is less than or equal to right:
            Let mid be left plus right divided by 2
            Let entry_offset be mid times 3 times 8
            Let entry_addr be table_ptr plus entry_offset

            Note: Read [base, combining, result] triple
            Let table_base be proc memory_get_integer from MemoryCore with entry_addr, 0
            Let table_combining_offset be entry_offset plus 8
            Let table_combining_addr be table_ptr plus table_combining_offset
            Let table_combining be proc memory_get_integer from MemoryCore with table_combining_addr, 0

            Note: Compare (base, combining) pair
            If table_base is less than starter:
                Set left to mid plus 1
            End If
            Otherwise If table_base is greater than starter:
                Set right to mid minus 1
            End If
            Otherwise:
                Note: Base matches, check combining mark
                If table_combining is less than current:
                    Set left to mid plus 1
                End If
                Otherwise If table_combining is greater than current:
                    Set right to mid minus 1
                End If
                Otherwise:
                    Note: Found composition! Get result codepoint
                    Let table_result_offset be entry_offset plus 16
                    Let table_result_addr be table_ptr plus table_result_offset
                    Set composed_result to proc memory_get_integer from MemoryCore with table_result_addr, 0
                    Set found_composition to 1
                    Set left to right plus 1
                End If
            End If
        End While

        Note: If composition found, update starter and skip current codepoint
        If found_composition is equal to 1:
            Note: Replace starter with composed result
            Let dummy_update be proc memory_set_integer from MemoryCore with starter_addr, 0, composed_result
            Set starter to composed_result
            Note: Skip current codepoint (it was consumed in composition)
        End If
        Otherwise:
            Note: No composition, write current codepoint to output
            Note: First, finalize previous starter (write to write_pos - 1)
            If write_pos is greater than 1:
                Let prev_write_offset be write_pos minus 1 times 8
                Let prev_write_addr be codepoints plus prev_write_offset
                Let dummy_write be proc memory_set_integer from MemoryCore with prev_write_addr, 0, starter
            End If

            Note: Current becomes new starter
            Set starter to current
            Set starter_addr to current_addr
            Set write_pos to write_pos plus 1
        End If

        Set read_pos to read_pos plus 1
    End While

    Note: Write final starter to output
    Let final_offset be write_pos minus 1 times 8
    Let final_addr be codepoints plus final_offset
    Let dummy_final be proc memory_set_integer from MemoryCore with final_addr, 0, starter

    Note: Update count with new compacted length
    Let dummy_count be proc memory_set_integer from MemoryCore with count_ptr, 0, write_pos
End Process

Process called "string_normalize" takes str as Integer, form as Integer, arena as Integer returns Integer:
    Note: Normalize Unicode string according to specified normalization form
    Note: Implements NFD (Canonical Decomposition) and NFC (Canonical Decomposition + Composition)
    Note: NFKD and NFKC compatibility forms are treated as NFD/NFC (subset implementation)

    If str is equal to 0:
        Return 0
    End If

    Let len be proc string_length from StringCore with str

    Note: Allocate temporary buffer for codepoints (worst case: every byte is a codepoint)
    Let codepoints_buffer be proc allocate from MemoryUtils with len times 8
    If codepoints_buffer is equal to 0:
        Return 0
    End If

    Note: Allocate temporary buffers for decode/encode operations
    Let out_codepoint be proc allocate from MemoryUtils with 8
    Let out_bytes be proc allocate from MemoryUtils with 8
    Let encode_buffer be proc allocate from MemoryUtils with 4

    If out_codepoint is equal to 0:
        Let dummy_free1 be proc deallocate from MemoryUtils with codepoints_buffer
        Return 0
    End If

    If out_bytes is equal to 0:
        Let dummy_free1 be proc deallocate from MemoryUtils with codepoints_buffer
        Let dummy_free2 be proc deallocate from MemoryUtils with out_codepoint
        Return 0
    End If

    If encode_buffer is equal to 0:
        Let dummy_free1 be proc deallocate from MemoryUtils with codepoints_buffer
        Let dummy_free2 be proc deallocate from MemoryUtils with out_codepoint
        Let dummy_free3 be proc deallocate from MemoryUtils with out_bytes
        Return 0
    End If

    Note: Decode UTF-8 string to codepoints
    Let codepoint_count be 0
    Let i be 0

    While i is less than len:
        Let decode_result be proc unicode_decode_codepoint with str, i, out_codepoint, out_bytes
        If decode_result is equal to 1:
            Let cp be proc memory_get_integer from MemoryCore with out_codepoint, 0
            Let consumed be proc memory_get_integer from MemoryCore with out_bytes, 0

            Note: Store codepoint in buffer
            Let cp_offset be codepoint_count times 8
            Let cp_addr be codepoints_buffer plus cp_offset
            Let dummy_store be proc memory_set_integer from MemoryCore with cp_addr, 0, cp

            Set codepoint_count to codepoint_count plus 1
            Set i to i plus consumed
        End If
        Otherwise:
            Set i to i plus 1  Note: Skip invalid byte
        End If
    End While

    Note: Apply normalization based on form
    If form is equal to NORMALIZATION_NFD:
        Note: NFD: Canonical Decomposition only (sort combining marks)
        Let dummy_sort be proc unicode_canonical_sort with codepoints_buffer, codepoint_count
    End If
    Otherwise If form is equal to NORMALIZATION_NFC:
        Note: NFC: Canonical Decomposition + Composition
        Note: Sort first (decomposition)
        Let dummy_sort be proc unicode_canonical_sort with codepoints_buffer, codepoint_count

        Note: Composition step: combine base + combining marks using composition tables
        Note: Allocate pointer for count (unicode_compose modifies count in place)
        Let count_ptr be proc allocate from MemoryUtils with 8
        If count_ptr is not equal to 0:
            Let dummy_set_count be proc memory_set_integer from MemoryCore with count_ptr, 0, codepoint_count
            Let dummy_compose be proc unicode_compose with codepoints_buffer, count_ptr
            Set codepoint_count to proc memory_get_integer from MemoryCore with count_ptr, 0
            Let dummy_free_count be proc deallocate from MemoryUtils with count_ptr
        End If
    End If
    Otherwise If form is equal to NORMALIZATION_NFKD:
        Note: NFKD: Compatibility Decomposition (treat as NFD)
        Let dummy_sort be proc unicode_canonical_sort with codepoints_buffer, codepoint_count
    End If
    Otherwise If form is equal to NORMALIZATION_NFKC:
        Note: NFKC: Compatibility Decomposition + Composition (treat as NFC)
        Note: Sort first (decomposition)
        Let dummy_sort be proc unicode_canonical_sort with codepoints_buffer, codepoint_count

        Note: Composition step: combine base + combining marks using composition tables
        Note: Allocate pointer for count (unicode_compose modifies count in place)
        Let count_ptr be proc allocate from MemoryUtils with 8
        If count_ptr is not equal to 0:
            Let dummy_set_count be proc memory_set_integer from MemoryCore with count_ptr, 0, codepoint_count
            Let dummy_compose be proc unicode_compose with codepoints_buffer, count_ptr
            Set codepoint_count to proc memory_get_integer from MemoryCore with count_ptr, 0
            Let dummy_free_count be proc deallocate from MemoryUtils with count_ptr
        End If
    End If

    Note: Encode codepoints back to UTF-8
    Note: Allocate result buffer (worst case: 4 bytes per codepoint)
    Let max_result_len be codepoint_count times 4
    Let result_ptr be 0
    If arena is not equal to 0:
        Set result_ptr to proc arena_allocate from ArenaUtils with arena, max_result_len plus 1, 1
    End If
    Otherwise:
        Set result_ptr to proc allocate from MemoryUtils with max_result_len plus 1
    End If

    If result_ptr is equal to 0:
        Let dummy_free1 be proc deallocate from MemoryUtils with codepoints_buffer
        Let dummy_free2 be proc deallocate from MemoryUtils with out_codepoint
        Let dummy_free3 be proc deallocate from MemoryUtils with out_bytes
        Let dummy_free4 be proc deallocate from MemoryUtils with encode_buffer
        Return 0
    End If

    Let result_pos be 0
    Set i to 0

    While i is less than codepoint_count:
        Let cp_offset be i times 8
        Let cp_addr be codepoints_buffer plus cp_offset
        Let cp be proc memory_get_integer from MemoryCore with cp_addr, 0

        Let encoded_bytes be proc unicode_encode_codepoint with cp, encode_buffer

        Note: Copy encoded bytes to result
        Let j be 0
        While j is less than encoded_bytes:
            Let byte_val be proc memory_get_byte from MemoryCore with encode_buffer, j
            Let dummy_write be proc memory_set_byte from MemoryCore with result_ptr, result_pos, byte_val
            Set result_pos to result_pos plus 1
            Set j to j plus 1
        End While

        Set i to i plus 1
    End While

    Note: Null terminate
    Let dummy_null be proc memory_set_byte from MemoryCore with result_ptr, result_pos, 0

    Note: Free temporary buffers
    Let dummy_free1 be proc deallocate from MemoryUtils with codepoints_buffer
    Let dummy_free2 be proc deallocate from MemoryUtils with out_codepoint
    Let dummy_free3 be proc deallocate from MemoryUtils with out_bytes
    Let dummy_free4 be proc deallocate from MemoryUtils with encode_buffer

    Return result_ptr
End Process

Note: ============================================================================
Note: IMPLEMENTED STRING UTILITIES (Required by debug_utils)
Note: ============================================================================

Process called "string_concat" takes str1 as Integer, str2 as Integer returns Integer:
    Note: Concatenate two strings
    Note: Returns pointer to new concatenated string (owned allocation)

    Note: Get lengths of both strings
    Let len1 be proc string_length from StringCore with str1
    Let len2 be proc string_length from StringCore with str2
    Let total_len be len1 plus len2

    Note: Allocate memory for result (+1 for null terminator)
    Let result_size be total_len plus 1
    Let result_ptr be proc allocate from MemoryUtils with result_size

    If result_ptr is equal to 0:
        Return 0
    End If

    Note: Copy first string
    Let dummy1 be proc memory_copy from MemoryCore with result_ptr, str1, len1

    Note: Copy second string
    Let dest_offset be len1
    Let dest_ptr be result_ptr plus dest_offset
    Let dummy2 be proc memory_copy from MemoryCore with dest_ptr, str2, len2

    Note: Add null terminator
    Let null_offset be total_len
    Let dummy3 be proc memory_set_byte from MemoryCore with result_ptr, null_offset, 0

    Return result_ptr
End Process

Process called "integer_to_string" takes value as Integer returns Integer:
    Note: Convert integer to string
    Note: Returns pointer to new string (owned allocation)
    Note: Handles negative numbers

    Note: Handle zero case
    If value is equal to 0:
        Let result_ptr be proc allocate from MemoryUtils with 2
        If result_ptr is equal to 0:
            Return 0
        End If
        Let dummy1 be proc memory_set_byte from MemoryCore with result_ptr, 0, 48  Note: '0'
        Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, 1, 0   Note: null
        Return result_ptr
    End If

    Note: Determine if negative
    Let is_negative be 0
    Let abs_value be value
    If value is less than 0:
        Set is_negative to 1
        Set abs_value to 0 minus value
    End If

    Note: Count digits
    Let digit_count be 0
    Let temp_value be abs_value
    While temp_value is greater than 0:
        Set temp_value to temp_value divided by 10
        Set digit_count to digit_count plus 1
    End While

    Note: Calculate total length (digits + optional minus + null)
    Let total_len be digit_count plus is_negative plus 1

    Note: Allocate result string
    Let result_ptr be proc allocate from MemoryUtils with total_len
    If result_ptr is equal to 0:
        Return 0
    End If

    Note: Add minus sign if negative
    Let write_pos be 0
    If is_negative is equal to 1:
        Let dummy1 be proc memory_set_byte from MemoryCore with result_ptr, 0, 45  Note: '-'
        Set write_pos to 1
    End If

    Note: Write digits in reverse order, then reverse them
    Let digit_start be write_pos
    Set temp_value to abs_value
    While temp_value is greater than 0:
        Let digit be temp_value modulo by 10
        Let digit_char be digit plus 48  Note: '0' is 48 in ASCII
        Let dummy2 be proc memory_set_byte from MemoryCore with result_ptr, write_pos, digit_char
        Set write_pos to write_pos plus 1
        Set temp_value to temp_value divided by 10
    End While

    Note: Reverse the digits
    Let left_idx be digit_start
    Let right_idx be write_pos minus 1
    While left_idx is less than right_idx:
        Let left_byte be proc memory_get_byte from MemoryCore with result_ptr, left_idx
        Let right_byte be proc memory_get_byte from MemoryCore with result_ptr, right_idx
        Let dummy3 be proc memory_set_byte from MemoryCore with result_ptr, left_idx, right_byte
        Let dummy4 be proc memory_set_byte from MemoryCore with result_ptr, right_idx, left_byte
        Set left_idx to left_idx plus 1
        Set right_idx to right_idx minus 1
    End While

    Note: Add null terminator
    Let null_pos be write_pos
    Let dummy5 be proc memory_set_byte from MemoryCore with result_ptr, null_pos, 0

    Return result_ptr
End Process

Note: ============================================================================
Note: String Utils - string_concat and integer_to_string Implemented
Note: ============================================================================