Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles file utilities and file management operations for the Runa compiler internal system.

FILE UTILITIES - Compiler File Management Engine
- Process file utilities and file management operations for compiler operations
- Handle file I/O and file information management for compiler development
- Manage file operations and file manipulation utilities for compiler workflows
- Process file optimization and file performance utilities for compiler efficiency
- Handle integration with compiler phases for file management and I/O support

This file is essential because of the following reasons:
- File utilities enable efficient file I/O operations for the compiler
- Proper file handling ensures correct compiler operation and development support
- File utilities support all compiler phases that need file management and I/O capabilities
- File utilities provide comprehensive file support for compiler operations

This file consists of the following functions/features/operation types:
- File creation, destruction, and lifecycle management
- File I/O and file information management operations
- File optimization and file performance monitoring operations
- File debugging and file diagnostic utilities
- Integration with compiler phases for file management and I/O support

Dependencies:
- Imports arena_utils.runa for arena-based file allocation
- Imports owned_utils.runa for owned file management
- Imports memory_safety.runa for file safety validation
- Imports collections.runa for file data structure management
:End Note

Import "compiler/internal/arena_utils.runa" as ArenaUtils
Import "compiler/internal/owned_utils.runa" as OwnedUtils
Import "compiler/internal/memory_safety.runa" as MemorySafety
Import "compiler/internal/collections.runa" as Collections
Import "compiler/frontend/primitives/io/file_metadata.runa" as FileMetadata
Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/core/syscall_core.runa" as Syscall

Note: ============================================================================
Note: File Management Structures
Note: ============================================================================

Type called "FileHandle":
    file_path as Integer     Note: Pointer to file path
    file_descriptor as Integer Note: File descriptor
    file_size as Integer     Note: Size of file in bytes
    file_mode as Integer     Note: File access mode
    file_position as Integer Note: Current file position
    is_open as Integer       Note: Boolean: 1 if open, 0 if closed
    is_readonly as Integer   Note: Boolean: 1 if readonly, 0 if writable
    arena as Integer         Note: Pointer to arena for allocation
    is_owned as Integer      Note: Boolean: 1 if owned, 0 if arena-allocated

Type called "FileInfo":
    file_path as Integer     Note: Pointer to file path
    file_size as Integer     Note: Size of file in bytes
    file_type as Integer     Note: Type of file (REGULAR, DIRECTORY, SYMLINK, etc.)
    permissions as Integer    Note: File permissions
    creation_time as Integer Note: File creation timestamp
    modification_time as Integer Note: File modification timestamp
    access_time as Integer   Note: File access timestamp
    is_valid as Integer      Note: Boolean: 1 if valid, 0 if invalid

Type called "FileStats":
    total_files as Integer   Note: Total number of files processed
    total_bytes as Integer   Note: Total bytes processed
    read_operations as Integer Note: Number of read operations
    write_operations as Integer Note: Number of write operations
    file_time as Integer     Note: Time spent on file operations
    file_memory as Integer   Note: Memory used for file operations

Note: ============================================================================
Note: File Constants
Note: ============================================================================

Constant FILE_MODE_READ as Integer is 0
Constant FILE_MODE_WRITE as Integer is 1
Constant FILE_MODE_APPEND as Integer is 2
Constant FILE_MODE_READ_WRITE as Integer is 3

Constant FILE_TYPE_REGULAR as Integer is 0
Constant FILE_TYPE_DIRECTORY as Integer is 1
Constant FILE_TYPE_SYMLINK as Integer is 2
Constant FILE_TYPE_SPECIAL as Integer is 3

Constant FILE_SUCCESS as Integer is 0
Constant FILE_FAILED as Integer is -1
Constant FILE_NOT_FOUND as Integer is -2
Constant FILE_PERMISSION_DENIED as Integer is -3
Constant FILE_ALREADY_EXISTS as Integer is -4

Constant FILE_BUFFER_SIZE as Integer is 8192
Constant FILE_MAX_PATH as Integer is 4096
Constant FILE_MAX_NAME as Integer is 255

Note: ============================================================================
Note: File Creation and Management
Note: ============================================================================

Note: Global file statistics
Let GLOBAL_FILE_STATS be 0

Private Process called "file_init_stats" returns Integer:
    Note: Initialize global file statistics if needed
    If GLOBAL_FILE_STATS is not equal to 0:
        Return 1
    End If

    Note: Allocate FileStats structure (48 bytes)
    Set GLOBAL_FILE_STATS to proc allocate from OwnedUtils with 48
    If GLOBAL_FILE_STATS is equal to 0:
        Return 0
    End If

    Note: Initialize all stats to 0
    Let dummy1 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 0, 0
    Let dummy2 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 8, 0
    Let dummy3 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 16, 0
    Let dummy4 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 24, 0
    Let dummy5 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 32, 0
    Let dummy6 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 40, 0

    Return 1
End Process

Process called "file_open" takes file_path as Integer, mode as Integer, arena as Integer returns Integer:
    Note: Open file for I/O operations using syscall
    Note: Returns pointer to FileHandle structure (72 bytes)
    Note: FileHandle layout: file_path(8), file_descriptor(8), file_size(8), file_mode(8),
    Note:                    file_position(8), is_open(8), is_readonly(8), arena(8), is_owned(8)

    If file_path is equal to 0:
        Return 0
    End If

    Note: Map file mode to open flags
    Let flags be 0
    If mode is equal to FILE_MODE_READ:
        Set flags to 0  Note: O_RDONLY
    End If
    Otherwise If mode is equal to FILE_MODE_WRITE:
        Set flags to 577  Note: O_WRONLY | O_CREAT | O_TRUNC
    End If
    Otherwise If mode is equal to FILE_MODE_APPEND:
        Set flags to 1089  Note: O_WRONLY | O_CREAT | O_APPEND
    End If
    Otherwise If mode is equal to FILE_MODE_READ_WRITE:
        Set flags to 578  Note: O_RDWR | O_CREAT | O_TRUNC
    End If

    Note: Open file (syscall 2: open, mode 0644 = 420)
    Let syscall_open be 2
    Let file_mode be 420
    Let fd be proc syscall_3 from Syscall with syscall_open, file_path, flags, file_mode

    If fd is less than 0:
        Return 0
    End If

    Note: Get file size using lseek to end, then back to start
    Let syscall_lseek be 8
    Let SEEK_END be 2
    Let SEEK_SET be 0
    Let file_size be proc syscall_3 from Syscall with syscall_lseek, fd, 0, SEEK_END
    Let seek_back be proc syscall_3 from Syscall with syscall_lseek, fd, 0, SEEK_SET

    Note: Allocate FileHandle structure
    Let handle be 0
    If arena is not equal to 0:
        Set handle to proc arena_allocate from ArenaUtils with arena, 72, 8
    End If
    Otherwise:
        Set handle to proc allocate from OwnedUtils with 72
    End If

    If handle is equal to 0:
        Note: Close file descriptor if allocation failed
        Let syscall_close be 3
        Let close_result be proc syscall_1 from Syscall with syscall_close, fd
        Return 0
    End If

    Note: Initialize FileHandle fields
    Let dummy1 be proc memory_set_integer from MemorySafety with handle, 0, file_path
    Let dummy2 be proc memory_set_integer from MemorySafety with handle, 8, fd
    Let dummy3 be proc memory_set_integer from MemorySafety with handle, 16, file_size
    Let dummy4 be proc memory_set_integer from MemorySafety with handle, 24, mode
    Let dummy5 be proc memory_set_integer from MemorySafety with handle, 32, 0  Note: position
    Let dummy6 be proc memory_set_integer from MemorySafety with handle, 40, 1  Note: is_open

    Let is_readonly be 0
    If mode is equal to FILE_MODE_READ:
        Set is_readonly to 1
    End If
    Let dummy7 be proc memory_set_integer from MemorySafety with handle, 48, is_readonly
    Let dummy8 be proc memory_set_integer from MemorySafety with handle, 56, arena

    Let is_owned be 0
    If arena is equal to 0:
        Set is_owned to 1
    End If
    Let dummy9 be proc memory_set_integer from MemorySafety with handle, 64, is_owned

    Note: Update statistics
    Let init_result be proc file_init_stats
    If init_result is equal to 1:
        If GLOBAL_FILE_STATS is not equal to 0:
            Let total_files be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 0
            Let dummy10 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 0, total_files plus 1
        End If
    End If

    Return handle
End Process

Process called "file_close" takes handle as Integer returns Integer:
    Note: Close file handle and free resources
    Note: Returns 1 if successful, 0 if failed

    If handle is equal to 0:
        Return 0
    End If

    Note: Check if already closed
    Let is_open be proc memory_get_integer from MemorySafety with handle, 40
    If is_open is equal to 0:
        Return 0
    End If

    Note: Get file descriptor
    Let fd be proc memory_get_integer from MemorySafety with handle, 8

    Note: Close file descriptor (syscall 3: close)
    Let syscall_close be 3
    Let close_result be proc syscall_1 from Syscall with syscall_close, fd

    If close_result is less than 0:
        Return 0
    End If

    Note: Mark as closed
    Let dummy1 be proc memory_set_integer from MemorySafety with handle, 40, 0

    Note: Free handle if owned
    Let is_owned be proc memory_get_integer from MemorySafety with handle, 64
    If is_owned is equal to 1:
        Let dummy2 be proc deallocate from OwnedUtils with handle
    End If

    Return 1
End Process

Process called "file_create" takes file_path as Integer, mode as Integer, arena as Integer returns Integer:
    Note: Create new file and open for I/O
    Note: Returns pointer to FileHandle structure
    Note: Uses O_CREAT flag to create file if it doesn't exist

    Note: file_open already handles creation with O_CREAT flag
    Let handle be proc file_open with file_path, mode, arena
    Return handle
End Process

Process called "file_delete" takes file_path as Integer returns Integer:
    Note: Delete file using unlink syscall
    Note: Returns 1 if successful, 0 if failed

    If file_path is equal to 0:
        Return 0
    End If

    Note: Delete file (syscall 87: unlink)
    Let syscall_unlink be 87
    Let result be proc syscall_1 from Syscall with syscall_unlink, file_path

    If result is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "file_exists" takes file_path as Integer returns Integer:
    Note: Check if file exists using platform-agnostic file metadata module
    Note: Returns 1 if exists, 0 if not exists

    If file_path is equal to 0:
        Return 0
    End If

    Return proc file_exists from FileMetadata with file_path
End Process

Process called "file_is_readable" takes file_path as Integer returns Integer:
    Note: Check if file is readable using platform-agnostic file metadata module
    Note: Returns 1 if readable, 0 if not readable

    If file_path is equal to 0:
        Return 0
    End If

    Return proc is_readable from FileMetadata with file_path
End Process

Process called "file_is_writable" takes file_path as Integer returns Integer:
    Note: Check if file is writable using platform-agnostic file metadata module
    Note: Returns 1 if writable, 0 if not writable

    If file_path is equal to 0:
        Return 0
    End If

    Return proc is_writable from FileMetadata with file_path
End Process

Note: ============================================================================
Note: File I/O Operations
Note: ============================================================================

Process called "file_read" takes handle as Integer, buffer as Integer, size as Integer returns Integer:
    Note: Read data from file using read syscall
    Note: Returns number of bytes read or -1 if failed
    Note: Handles file bounds checking and position tracking

    If handle is equal to 0:
        Return -1
    End If

    If buffer is equal to 0:
        Return -1
    End If

    If size is less than or equal to 0:
        Return -1
    End If

    Note: Check if file is open
    Let is_open be proc memory_get_integer from MemorySafety with handle, 40
    If is_open is equal to 0:
        Return -1
    End If

    Note: Get file descriptor
    Let fd be proc memory_get_integer from MemorySafety with handle, 8

    Note: Read data from file (syscall 0: read)
    Let syscall_read be 0
    Let bytes_read be proc syscall_3 from Syscall with syscall_read, fd, buffer, size

    If bytes_read is less than 0:
        Return -1
    End If

    Note: Update file position
    Let current_position be proc memory_get_integer from MemorySafety with handle, 32
    Let new_position be current_position plus bytes_read
    Let dummy1 be proc memory_set_integer from MemorySafety with handle, 32, new_position

    Note: Update statistics
    Let init_result be proc file_init_stats
    If init_result is equal to 1:
        If GLOBAL_FILE_STATS is not equal to 0:
            Let total_bytes be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 8
            Let dummy2 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 8, total_bytes plus bytes_read

            Let read_ops be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 16
            Let dummy3 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 16, read_ops plus 1
        End If
    End If

    Return bytes_read
End Process

Process called "file_write" takes handle as Integer, buffer as Integer, size as Integer returns Integer:
    Note: Write data to file using write syscall
    Note: Returns number of bytes written or -1 if failed
    Note: Handles file permissions checking and position tracking

    If handle is equal to 0:
        Return -1
    End If

    If buffer is equal to 0:
        Return -1
    End If

    If size is less than or equal to 0:
        Return -1
    End If

    Note: Check if file is open
    Let is_open be proc memory_get_integer from MemorySafety with handle, 40
    If is_open is equal to 0:
        Return -1
    End If

    Note: Check if file is writable
    Let is_readonly be proc memory_get_integer from MemorySafety with handle, 48
    If is_readonly is equal to 1:
        Return -1
    End If

    Note: Get file descriptor
    Let fd be proc memory_get_integer from MemorySafety with handle, 8

    Note: Write data to file (syscall 1: write)
    Let syscall_write be 1
    Let bytes_written be proc syscall_3 from Syscall with syscall_write, fd, buffer, size

    If bytes_written is less than 0:
        Return -1
    End If

    Note: Update file position
    Let current_position be proc memory_get_integer from MemorySafety with handle, 32
    Let new_position be current_position plus bytes_written
    Let dummy1 be proc memory_set_integer from MemorySafety with handle, 32, new_position

    Note: Update file size if position exceeds current size
    Let file_size be proc memory_get_integer from MemorySafety with handle, 16
    If new_position is greater than file_size:
        Let dummy2 be proc memory_set_integer from MemorySafety with handle, 16, new_position
    End If

    Note: Update statistics
    Let init_result be proc file_init_stats
    If init_result is equal to 1:
        If GLOBAL_FILE_STATS is not equal to 0:
            Let total_bytes be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 8
            Let dummy3 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 8, total_bytes plus bytes_written

            Let write_ops be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 24
            Let dummy4 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 24, write_ops plus 1
        End If
    End If

    Return bytes_written
End Process

Process called "file_read_line" takes handle as Integer, buffer as Integer, size as Integer returns Integer:
    Note: Read line from file until newline or EOF
    Note: Returns number of bytes read (including newline) or -1 if failed
    Note: Reads one byte at a time until newline (10) or buffer full

    If handle is equal to 0:
        Return -1
    End If

    If buffer is equal to 0:
        Return -1
    End If

    If size is less than or equal to 0:
        Return -1
    End If

    Note: Check if file is open
    Let is_open be proc memory_get_integer from MemorySafety with handle, 40
    If is_open is equal to 0:
        Return -1
    End If

    Note: Get file descriptor
    Let fd be proc memory_get_integer from MemorySafety with handle, 8

    Note: Read line character by character
    Let bytes_read be 0
    Let syscall_read be 0

    While bytes_read is less than size:
        Note: Read single byte
        Let read_result be proc syscall_3 from Syscall with syscall_read, fd, buffer plus bytes_read, 1

        If read_result is less than or equal to 0:
            Note: EOF or error reached
            If bytes_read is equal to 0:
                Return -1
            End If
            Note: Break loop (return what we have)
            Set bytes_read to bytes_read
            Note: Exit loop by setting condition
            Set bytes_read to size
        End If

        If read_result is equal to 1:
            Note: Check if newline
            Let char_byte be proc memory_get_byte from MemoryCore with buffer plus bytes_read, 0
            Set bytes_read to bytes_read plus 1

            If char_byte is equal to 10:
                Note: Newline found, stop reading
                Set bytes_read to size  Note: Exit loop
            End If
        End If
    End While

    Note: Get actual bytes read (before loop exit manipulation)
    Let actual_bytes be bytes_read
    If actual_bytes is greater than size:
        Set actual_bytes to size
    End If

    Note: Update file position
    Let current_position be proc memory_get_integer from MemorySafety with handle, 32
    Let new_position be current_position plus actual_bytes
    Let dummy1 be proc memory_set_integer from MemorySafety with handle, 32, new_position

    Note: Update statistics
    Let init_result be proc file_init_stats
    If init_result is equal to 1:
        If GLOBAL_FILE_STATS is not equal to 0:
            Let total_bytes be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 8
            Let dummy2 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 8, total_bytes plus actual_bytes

            Let read_ops be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 16
            Let dummy3 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 16, read_ops plus 1
        End If
    End If

    Return actual_bytes
End Process

Process called "file_write_line" takes handle as Integer, buffer as Integer, size as Integer returns Integer:
    Note: Write line to file with newline appended
    Note: Returns number of bytes written (including newline) or -1 if failed
    Note: Writes buffer contents followed by newline character (10)

    If handle is equal to 0:
        Return -1
    End If

    If buffer is equal to 0:
        Return -1
    End If

    If size is less than 0:
        Return -1
    End If

    Note: Check if file is open
    Let is_open be proc memory_get_integer from MemorySafety with handle, 40
    If is_open is equal to 0:
        Return -1
    End If

    Note: Check if file is writable
    Let is_readonly be proc memory_get_integer from MemorySafety with handle, 48
    If is_readonly is equal to 1:
        Return -1
    End If

    Note: Get file descriptor
    Let fd be proc memory_get_integer from MemorySafety with handle, 8

    Note: Write buffer contents (syscall 1: write)
    Let syscall_write be 1
    Let bytes_written be 0

    If size is greater than 0:
        Let write_result be proc syscall_3 from Syscall with syscall_write, fd, buffer, size
        If write_result is less than 0:
            Return -1
        End If
        Set bytes_written to write_result
    End If

    Note: Allocate single byte for newline
    Let newline_ptr be proc allocate from OwnedUtils with 1
    If newline_ptr is equal to 0:
        Return bytes_written
    End If
    Let dummy1 be proc memory_set_byte from MemoryCore with newline_ptr, 0, 10

    Note: Write newline character
    Let newline_result be proc syscall_3 from Syscall with syscall_write, fd, newline_ptr, 1
    Let dummy2 be proc deallocate from OwnedUtils with newline_ptr

    If newline_result is less than 0:
        Return bytes_written
    End If

    Set bytes_written to bytes_written plus newline_result

    Note: Update file position
    Let current_position be proc memory_get_integer from MemorySafety with handle, 32
    Let new_position be current_position plus bytes_written
    Let dummy3 be proc memory_set_integer from MemorySafety with handle, 32, new_position

    Note: Update file size if position exceeds current size
    Let file_size be proc memory_get_integer from MemorySafety with handle, 16
    If new_position is greater than file_size:
        Let dummy4 be proc memory_set_integer from MemorySafety with handle, 16, new_position
    End If

    Note: Update statistics
    Let init_result be proc file_init_stats
    If init_result is equal to 1:
        If GLOBAL_FILE_STATS is not equal to 0:
            Let total_bytes be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 8
            Let dummy5 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 8, total_bytes plus bytes_written

            Let write_ops be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 24
            Let dummy6 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 24, write_ops plus 1
        End If
    End If

    Return bytes_written
End Process

Process called "file_seek" takes handle as Integer, position as Integer returns Integer:
    Note: Seek to position in file using lseek syscall
    Note: Returns 1 if successful, 0 if failed
    Note: Position is absolute from start of file

    If handle is equal to 0:
        Return 0
    End If

    If position is less than 0:
        Return 0
    End If

    Note: Check if file is open
    Let is_open be proc memory_get_integer from MemorySafety with handle, 40
    If is_open is equal to 0:
        Return 0
    End If

    Note: Get file descriptor
    Let fd be proc memory_get_integer from MemorySafety with handle, 8

    Note: Seek to position (syscall 8: lseek, SEEK_SET = 0)
    Let syscall_lseek be 8
    Let SEEK_SET be 0
    Let result be proc syscall_3 from Syscall with syscall_lseek, fd, position, SEEK_SET

    If result is less than 0:
        Return 0
    End If

    Note: Update file position in handle
    Let dummy1 be proc memory_set_integer from MemorySafety with handle, 32, position

    Return 1
End Process

Process called "file_tell" takes handle as Integer returns Integer:
    Note: Get current file position from FileHandle structure
    Note: Returns current position or -1 if failed
    Note: Returns cached position value from handle

    If handle is equal to 0:
        Return -1
    End If

    Note: Check if file is open
    Let is_open be proc memory_get_integer from MemorySafety with handle, 40
    If is_open is equal to 0:
        Return -1
    End If

    Note: Get current position from handle
    Let position be proc memory_get_integer from MemorySafety with handle, 32

    Return position
End Process

Process called "file_flush" takes handle as Integer returns Integer:
    Note: Flush file buffers to disk using fsync syscall
    Note: Returns 1 if successful, 0 if failed
    Note: Ensures all modified data is written to physical storage

    If handle is equal to 0:
        Return 0
    End If

    Note: Check if file is open
    Let is_open be proc memory_get_integer from MemorySafety with handle, 40
    If is_open is equal to 0:
        Return 0
    End If

    Note: Get file descriptor
    Let fd be proc memory_get_integer from MemorySafety with handle, 8

    Note: Flush file buffers (syscall 74: fsync)
    Let syscall_fsync be 74
    Let result be proc syscall_1 from Syscall with syscall_fsync, fd

    If result is equal to 0:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: File Information Operations
Note: ============================================================================

Process called "file_get_info" takes file_path as Integer returns Integer:
    Note: Get file information using stat syscall
    Note: Returns pointer to FileInfo structure (64 bytes) or 0 if failed
    Note: FileInfo layout: file_path(8), file_size(8), file_type(8), permissions(8),
    Note:                  creation_time(8), modification_time(8), access_time(8), is_valid(8)

    If file_path is equal to 0:
        Return 0
    End If

    Note: Allocate stat buffer (144 bytes for struct stat)
    Let stat_buf be proc allocate from OwnedUtils with 144
    If stat_buf is equal to 0:
        Return 0
    End If

    Note: Call stat syscall (syscall 4: stat)
    Let syscall_stat be 4
    Let stat_result be proc syscall_2 from Syscall with syscall_stat, file_path, stat_buf

    If stat_result is less than 0:
        Let dummy1 be proc deallocate from OwnedUtils with stat_buf
        Return 0
    End If

    Note: Allocate FileInfo structure (64 bytes)
    Let info be proc allocate from OwnedUtils with 64
    If info is equal to 0:
        Let dummy2 be proc deallocate from OwnedUtils with stat_buf
        Return 0
    End If

    Note: Extract file information from stat buffer
    Note: struct stat layout: st_dev(8), st_ino(8), st_nlink(8), st_mode(4), st_uid(4),
    Note:                      st_gid(4), padding(4), st_rdev(8), st_size(8), st_blksize(8),
    Note:                      st_blocks(8), st_atime(8), st_atime_nsec(8), st_mtime(8),
    Note:                      st_mtime_nsec(8), st_ctime(8), st_ctime_nsec(8)

    Note: Get file size (at offset 48)
    Let file_size be proc memory_get_integer from MemorySafety with stat_buf, 48

    Note: Get file mode (at offset 24, 4 bytes)
    Let file_mode be proc memory_get_integer from MemorySafety with stat_buf, 24

    Note: Get file type from mode (S_IFMT = 0xF000, shifted right 12 bits)
    Let file_type be FILE_TYPE_REGULAR
    Let mode_masked be file_mode
    Note: Check S_IFDIR (0x4000) - directory
    If mode_masked is greater than or equal to 16384:
        If mode_masked is less than 32768:
            Set file_type to FILE_TYPE_DIRECTORY
        End If
    End If
    Note: Check S_IFLNK (0xA000) - symbolic link
    If mode_masked is greater than or equal to 40960:
        If mode_masked is less than 49152:
            Set file_type to FILE_TYPE_SYMLINK
        End If
    End If

    Note: Get file permissions (lower 9 bits of mode)
    Let permissions be file_mode

    Note: Get timestamps (atime at offset 72, mtime at offset 88, ctime at offset 104)
    Let access_time be proc memory_get_integer from MemorySafety with stat_buf, 72
    Let modification_time be proc memory_get_integer from MemorySafety with stat_buf, 88
    Let creation_time be proc memory_get_integer from MemorySafety with stat_buf, 104

    Note: Initialize FileInfo structure
    Let dummy3 be proc memory_set_integer from MemorySafety with info, 0, file_path
    Let dummy4 be proc memory_set_integer from MemorySafety with info, 8, file_size
    Let dummy5 be proc memory_set_integer from MemorySafety with info, 16, file_type
    Let dummy6 be proc memory_set_integer from MemorySafety with info, 24, permissions
    Let dummy7 be proc memory_set_integer from MemorySafety with info, 32, creation_time
    Let dummy8 be proc memory_set_integer from MemorySafety with info, 40, modification_time
    Let dummy9 be proc memory_set_integer from MemorySafety with info, 48, access_time
    Let dummy10 be proc memory_set_integer from MemorySafety with info, 56, 1  Note: is_valid

    Note: Free stat buffer
    Let dummy11 be proc deallocate from OwnedUtils with stat_buf

    Return info
End Process

Process called "file_get_size" takes file_path as Integer returns Integer:
    Note: Get file size using platform-agnostic file metadata module
    Note: Returns file size in bytes or -1 if failed

    If file_path is equal to 0:
        Return -1
    End If

    Return proc get_file_size from FileMetadata with file_path
End Process

Process called "file_get_type" takes file_path as Integer returns Integer:
    Note: Get file type using platform-agnostic file metadata module
    Note: Returns file type constant or -1 if failed

    If file_path is equal to 0:
        Return -1
    End If

    Return proc get_file_type from FileMetadata with file_path
End Process

Process called "file_get_permissions" takes file_path as Integer returns Integer:
    Note: Get file permissions using platform-agnostic file metadata module
    Note: Returns file permissions or -1 if failed

    If file_path is equal to 0:
        Return -1
    End If

    Return proc get_file_permissions from FileMetadata with file_path
End Process

Process called "file_get_creation_time" takes file_path as Integer returns Integer:
    Note: Get file change time (ctime) using platform-agnostic file metadata module
    Note: Returns change timestamp or -1 if failed
    Note: Note that ctime is change time, not creation time (POSIX limitation)

    If file_path is equal to 0:
        Return -1
    End If

    Return proc get_file_change_time from FileMetadata with file_path
End Process

Process called "file_get_modification_time" takes file_path as Integer returns Integer:
    Note: Get file modification time (mtime) using platform-agnostic file metadata module
    Note: Returns modification timestamp or -1 if failed

    If file_path is equal to 0:
        Return -1
    End If

    Return proc get_file_modification_time from FileMetadata with file_path
End Process

Process called "file_get_access_time" takes file_path as Integer returns Integer:
    Note: Get file access time (atime) using platform-agnostic file metadata module
    Note: Returns access timestamp or -1 if failed

    If file_path is equal to 0:
        Return -1
    End If

    Return proc get_file_access_time from FileMetadata with file_path
End Process

Note: ============================================================================
Note: File Path Operations
Note: ============================================================================

Process called "file_path_join" takes path1 as Integer, path2 as Integer, arena as Integer returns Integer:
    Note: Join two file paths with path separator
    Note: Returns pointer to joined path string (arena or owned allocation)
    Note: Handles trailing/leading slashes appropriately

    If path1 is equal to 0:
        Return 0
    End If

    If path2 is equal to 0:
        Return 0
    End If

    Note: Get lengths of both paths
    Let len1 be proc string_length from StringCore with path1
    Let len2 be proc string_length from StringCore with path2

    Note: Check if path1 ends with slash
    Let needs_separator be 1
    If len1 is greater than 0:
        Let last_char be proc memory_get_byte from MemoryCore with path1 plus len1 minus 1, 0
        If last_char is equal to 47:  Note: '/' character
            Set needs_separator to 0
        End If
    End If

    Note: Check if path2 starts with slash
    If len2 is greater than 0:
        Let first_char be proc memory_get_byte from MemoryCore with path2, 0
        If first_char is equal to 47:  Note: '/' character
            Set needs_separator to 0
        End If
    End If

    Note: Calculate total length (path1 + separator + path2 + null terminator)
    Let total_len be len1 plus len2 plus needs_separator plus 1

    Note: Allocate result buffer
    Let result be 0
    If arena is not equal to 0:
        Set result to proc arena_allocate from ArenaUtils with arena, total_len, 1
    End If
    Otherwise:
        Set result to proc allocate from OwnedUtils with total_len
    End If

    If result is equal to 0:
        Return 0
    End If

    Note: Copy path1
    Let i be 0
    While i is less than len1:
        Let byte_val be proc memory_get_byte from MemoryCore with path1 plus i, 0
        Let dummy1 be proc memory_set_byte from MemoryCore with result plus i, 0, byte_val
        Set i to i plus 1
    End While

    Note: Add separator if needed
    Let write_pos be len1
    If needs_separator is equal to 1:
        Let dummy2 be proc memory_set_byte from MemoryCore with result plus write_pos, 0, 47  Note: '/'
        Set write_pos to write_pos plus 1
    End If

    Note: Copy path2
    Set i to 0
    While i is less than len2:
        Let byte_val be proc memory_get_byte from MemoryCore with path2 plus i, 0
        Let dummy3 be proc memory_set_byte from MemoryCore with result plus write_pos plus i, 0, byte_val
        Set i to i plus 1
    End While

    Note: Add null terminator
    Let dummy4 be proc memory_set_byte from MemoryCore with result plus write_pos plus len2, 0, 0

    Return result
End Process

Process called "file_path_split" takes path as Integer, arena as Integer returns Integer:
    Note: Split file path into directory and filename components
    Note: Returns pointer to array of 2 strings: [directory, filename]
    Note: Array is 16 bytes (2 pointers), allocated in arena or owned heap

    If path is equal to 0:
        Return 0
    End If

    Note: Find last slash in path
    Let len be proc string_length from StringCore with path
    Let last_slash_pos be -1
    Let i be 0
    While i is less than len:
        Let char_byte be proc memory_get_byte from MemoryCore with path plus i, 0
        If char_byte is equal to 47:  Note: '/' character
            Set last_slash_pos to i
        End If
        Set i to i plus 1
    End While

    Note: Allocate array for 2 pointers
    Let result_array be 0
    If arena is not equal to 0:
        Set result_array to proc arena_allocate from ArenaUtils with arena, 16, 8
    End If
    Otherwise:
        Set result_array to proc allocate from OwnedUtils with 16
    End If

    If result_array is equal to 0:
        Return 0
    End If

    Note: If no slash found, directory is "." and filename is copy of entire path
    If last_slash_pos is less than 0:
        Note: Allocate "." string for directory
        Let dir_ptr be 0
        If arena is not equal to 0:
            Set dir_ptr to proc arena_allocate from ArenaUtils with arena, 2, 1
        End If
        Otherwise:
            Set dir_ptr to proc allocate from OwnedUtils with 2
        End If
        If dir_ptr is not equal to 0:
            Let dummy1 be proc memory_set_byte from MemoryCore with dir_ptr, 0, 46  Note: '.'
            Let dummy2 be proc memory_set_byte from MemoryCore with dir_ptr plus 1, 0, 0
        End If

        Note: CRITICAL: Copy the path as filename to avoid aliasing
        Let filename_copy be 0
        If arena is not equal to 0:
            Set filename_copy to proc arena_allocate from ArenaUtils with arena, len plus 1, 1
        End If
        Otherwise:
            Set filename_copy to proc allocate from OwnedUtils with len plus 1
        End If

        If filename_copy is not equal to 0:
            Note: Copy entire path as filename
            Let copy_i be 0
            While copy_i is less than or equal to len:
                Let path_byte be proc memory_get_byte from MemoryCore with path plus copy_i, 0
                Let dummy_copy be proc memory_set_byte from MemoryCore with filename_copy plus copy_i, 0, path_byte
                Set copy_i to copy_i plus 1
            End While
        End If

        Let dummy3 be proc memory_set_integer from MemorySafety with result_array, 0, dir_ptr
        Let dummy4 be proc memory_set_integer from MemorySafety with result_array, 8, filename_copy
        Return result_array
    End If

    Note: Extract directory part (everything before last slash)
    Let dir_len be last_slash_pos plus 1
    Let dir_ptr be 0
    If arena is not equal to 0:
        Set dir_ptr to proc arena_allocate from ArenaUtils with arena, dir_len, 1
    End If
    Otherwise:
        Set dir_ptr to proc allocate from OwnedUtils with dir_len
    End If

    If dir_ptr is not equal to 0:
        Set i to 0
        While i is less than last_slash_pos:
            Let byte_val be proc memory_get_byte from MemoryCore with path plus i, 0
            Let dummy5 be proc memory_set_byte from MemoryCore with dir_ptr plus i, 0, byte_val
            Set i to i plus 1
        End While
        Let dummy6 be proc memory_set_byte from MemoryCore with dir_ptr plus last_slash_pos, 0, 0
    End If

    Note: Extract filename part (everything after last slash)
    Let filename_len be len minus last_slash_pos
    Let filename_ptr be 0
    If arena is not equal to 0:
        Set filename_ptr to proc arena_allocate from ArenaUtils with arena, filename_len, 1
    End If
    Otherwise:
        Set filename_ptr to proc allocate from OwnedUtils with filename_len
    End If

    If filename_ptr is not equal to 0:
        Set i to 0
        While i is less than filename_len minus 1:
            Let byte_val be proc memory_get_byte from MemoryCore with path plus last_slash_pos plus 1 plus i, 0
            Let dummy7 be proc memory_set_byte from MemoryCore with filename_ptr plus i, 0, byte_val
            Set i to i plus 1
        End While
        Let dummy8 be proc memory_set_byte from MemoryCore with filename_ptr plus filename_len minus 1, 0, 0
    End If

    Note: Store both pointers in result array
    Let dummy9 be proc memory_set_integer from MemorySafety with result_array, 0, dir_ptr
    Let dummy10 be proc memory_set_integer from MemorySafety with result_array, 8, filename_ptr

    Return result_array
End Process

Process called "file_path_normalize" takes path as Integer, arena as Integer returns Integer:
    Note: Normalize file path by removing . and .. components and redundant slashes
    Note: Returns pointer to normalized path (arena or owned allocation)
    Note: Handles /./  and /../ sequences, removes trailing slashes

    If path is equal to 0:
        Return 0
    End If

    Let len be proc string_length from StringCore with path

    Note: Allocate component stack (max 256 components, each is pointer to start and length)
    Let max_components be 256
    Let component_starts be proc allocate from OwnedUtils with max_components times 8
    Let component_lengths be proc allocate from OwnedUtils with max_components times 8
    If component_starts is equal to 0:
        Return 0
    End If
    If component_lengths is equal to 0:
        Let dummy1 be proc deallocate from OwnedUtils with component_starts
        Return 0
    End If

    Note: Split path into components
    Let component_count be 0
    Let component_start be 0
    Let i be 0
    Let is_absolute be 0

    Note: Check if path is absolute
    Let first_char be proc memory_get_byte from MemoryCore with path, 0
    If first_char is equal to 47:  Note: '/'
        Set is_absolute to 1
        Set component_start to 1
        Set i to 1
    End If

    Note: Parse components separated by /
    While i is less than or equal to len:
        Let char_byte be 0
        If i is less than len:
            Set char_byte to proc memory_get_byte from MemoryCore with path plus i, 0
        End If

        If char_byte is equal to 47:  Note: '/' found
            Note: Process component from component_start to i
            Let component_len be i minus component_start

            If component_len is greater than 0:
                Note: Check if component is "." or ".."
                Let is_dot be 0
                Let is_dotdot be 0

                If component_len is equal to 1:
                    Let c1 be proc memory_get_byte from MemoryCore with path plus component_start, 0
                    If c1 is equal to 46:  Note: '.'
                        Set is_dot to 1
                    End If
                End If
                Otherwise If component_len is equal to 2:
                    Let c1 be proc memory_get_byte from MemoryCore with path plus component_start, 0
                    Let c2 be proc memory_get_byte from MemoryCore with path plus component_start plus 1, 0
                    If c1 is equal to 46:
                        If c2 is equal to 46:
                            Set is_dotdot to 1
                        End If
                    End If
                End If

                If is_dot is equal to 0:
                    If is_dotdot is equal to 0:
                        Note: Regular component, add to stack
                        If component_count is less than max_components:
                            Let dummy2 be proc memory_set_integer from MemorySafety with component_starts plus component_count times 8, 0, component_start
                            Let dummy3 be proc memory_set_integer from MemorySafety with component_lengths plus component_count times 8, 0, component_len
                            Set component_count to component_count plus 1
                        End If
                    End If
                    Otherwise:
                        Note: ".." component, pop from stack if possible
                        If component_count is greater than 0:
                            Set component_count to component_count minus 1
                        End If
                    End If
                End If
            End If

            Set component_start to i plus 1
        End If

        Set i to i plus 1
    End While

    Note: Build normalized path from component stack
    Let total_len be 0
    If is_absolute is equal to 1:
        Set total_len to 1  Note: Leading /
    End If

    Note: Calculate total length needed
    Let c be 0
    While c is less than component_count:
        Let comp_len be proc memory_get_integer from MemorySafety with component_lengths plus c times 8, 0
        Set total_len to total_len plus comp_len
        If c is less than component_count minus 1:
            Set total_len to total_len plus 1  Note: Separator /
        End If
        Set c to c plus 1
    End While

    Note: Handle empty path case
    If total_len is equal to 0:
        Set total_len to 1  Note: "." for empty relative path
    End If

    Note: Allocate result
    Let result be 0
    If arena is not equal to 0:
        Set result to proc arena_allocate from ArenaUtils with arena, total_len plus 1, 1
    End If
    Otherwise:
        Set result to proc allocate from OwnedUtils with total_len plus 1
    End If

    If result is equal to 0:
        Let dummy4 be proc deallocate from OwnedUtils with component_starts
        Let dummy5 be proc deallocate from OwnedUtils with component_lengths
        Return 0
    End If

    Note: Write normalized path
    Let write_pos be 0

    If is_absolute is equal to 1:
        Let dummy6 be proc memory_set_byte from MemoryCore with result, 0, 47  Note: '/'
        Set write_pos to 1
    End If

    If component_count is equal to 0:
        If is_absolute is equal to 0:
            Note: Empty relative path becomes "."
            Let dummy7 be proc memory_set_byte from MemoryCore with result, 0, 46
            Set write_pos to 1
        End If
    End If
    Otherwise:
        Set c to 0
        While c is less than component_count:
            Let comp_start be proc memory_get_integer from MemorySafety with component_starts plus c times 8, 0
            Let comp_len be proc memory_get_integer from MemorySafety with component_lengths plus c times 8, 0

            Note: Copy component
            Let j be 0
            While j is less than comp_len:
                Let comp_byte be proc memory_get_byte from MemoryCore with path plus comp_start plus j, 0
                Let dummy8 be proc memory_set_byte from MemoryCore with result plus write_pos, 0, comp_byte
                Set write_pos to write_pos plus 1
                Set j to j plus 1
            End While

            Note: Add separator if not last component
            If c is less than component_count minus 1:
                Let dummy9 be proc memory_set_byte from MemoryCore with result plus write_pos, 0, 47
                Set write_pos to write_pos plus 1
            End If

            Set c to c plus 1
        End While
    End If

    Note: Null terminate
    Let dummy10 be proc memory_set_byte from MemoryCore with result plus write_pos, 0, 0

    Note: Free temporary buffers
    Let dummy11 be proc deallocate from OwnedUtils with component_starts
    Let dummy12 be proc deallocate from OwnedUtils with component_lengths

    Return result
End Process

Process called "file_path_absolute" takes path as Integer, arena as Integer returns Integer:
    Note: Get absolute file path by prepending current working directory
    Note: Returns pointer to absolute path (arena or owned allocation)
    Note: Uses getcwd syscall (79) to get current directory

    If path is equal to 0:
        Return 0
    End If

    Note: Check if already absolute (starts with /)
    Let first_char be proc memory_get_byte from MemoryCore with path, 0
    If first_char is equal to 47:  Note: Already absolute
        Note: Just copy the path
        Let len be proc string_length from StringCore with path
        Let result be 0
        If arena is not equal to 0:
            Set result to proc arena_allocate from ArenaUtils with arena, len plus 1, 1
        End If
        Otherwise:
            Set result to proc allocate from OwnedUtils with len plus 1
        End If
        If result is not equal to 0:
            Let i be 0
            While i is less than or equal to len:
                Let byte_val be proc memory_get_byte from MemoryCore with path plus i, 0
                Let dummy1 be proc memory_set_byte from MemoryCore with result plus i, 0, byte_val
                Set i to i plus 1
            End While
        End If
        Return result
    End If

    Note: Get current working directory (syscall 79: getcwd)
    Let cwd_buffer be proc allocate from OwnedUtils with 4096
    If cwd_buffer is equal to 0:
        Return 0
    End If

    Let syscall_getcwd be 79
    Let getcwd_result be proc syscall_2 from Syscall with syscall_getcwd, cwd_buffer, 4096

    If getcwd_result is equal to 0:
        Let dummy2 be proc deallocate from OwnedUtils with cwd_buffer
        Return 0
    End If

    Note: Join cwd with path
    Let result be proc file_path_join with cwd_buffer, path, arena
    Let dummy3 be proc deallocate from OwnedUtils with cwd_buffer

    Return result
End Process

Process called "file_path_relative" takes path as Integer, base as Integer, arena as Integer returns Integer:
    Note: Calculate relative path from base directory to target path
    Note: Returns pointer to relative path (arena or owned allocation)
    Note: Handles ../ components for navigating up directory tree

    If path is equal to 0:
        Return 0
    End If

    If base is equal to 0:
        Return path
    End If

    Note: Normalize both paths first to handle . and .. properly
    Let norm_path be proc file_path_normalize with path, 0
    Let norm_base be proc file_path_normalize with base, 0

    If norm_path is equal to 0:
        Return 0
    End If

    If norm_base is equal to 0:
        If norm_path is not equal to 0:
            Let dummy1 be proc deallocate from OwnedUtils with norm_path
        End If
        Return 0
    End If

    Note: Split both paths into components
    Let max_components be 256
    Let path_components be proc allocate from OwnedUtils with max_components times 8
    Let base_components be proc allocate from OwnedUtils with max_components times 8

    If path_components is equal to 0:
        Let dummy2 be proc deallocate from OwnedUtils with norm_path
        Let dummy3 be proc deallocate from OwnedUtils with norm_base
        Return 0
    End If

    If base_components is equal to 0:
        Let dummy4 be proc deallocate from OwnedUtils with norm_path
        Let dummy5 be proc deallocate from OwnedUtils with norm_base
        Let dummy6 be proc deallocate from OwnedUtils with path_components
        Return 0
    End If

    Note: Parse path components
    Let path_count be 0
    Let path_len be proc string_length from StringCore with norm_path
    Let start be 0
    If path_len is greater than 0:
        Let first_byte be proc memory_get_byte from MemoryCore with norm_path, 0
        If first_byte is equal to 47:
            Set start to 1
        End If
    End If

    Let i be start
    While i is less than or equal to path_len:
        Let is_sep be 0
        If i is equal to path_len:
            Set is_sep to 1
        End If
        Otherwise:
            Let char_byte be proc memory_get_byte from MemoryCore with norm_path plus i, 0
            If char_byte is equal to 47:
                Set is_sep to 1
            End If
        End If

        If is_sep is equal to 1:
            Let comp_len be i minus start
            If comp_len is greater than 0:
                If path_count is less than max_components:
                    Note: Allocate and copy component
                    Let comp_str be proc allocate from OwnedUtils with comp_len plus 1
                    If comp_str is not equal to 0:
                        Let j be 0
                        While j is less than comp_len:
                            Let comp_byte be proc memory_get_byte from MemoryCore with norm_path plus start plus j, 0
                            Let dummy7 be proc memory_set_byte from MemoryCore with comp_str plus j, 0, comp_byte
                            Set j to j plus 1
                        End While
                        Let dummy8 be proc memory_set_byte from MemoryCore with comp_str plus comp_len, 0, 0
                        Let dummy9 be proc memory_set_integer from MemorySafety with path_components plus path_count times 8, 0, comp_str
                        Set path_count to path_count plus 1
                    End If
                End If
            End If
            Set start to i plus 1
        End If
        Set i to i plus 1
    End While

    Note: Parse base components (same logic)
    Let base_count be 0
    Let base_len be proc string_length from StringCore with norm_base
    Set start to 0
    If base_len is greater than 0:
        Let first_byte2 be proc memory_get_byte from MemoryCore with norm_base, 0
        If first_byte2 is equal to 47:
            Set start to 1
        End If
    End If

    Set i to start
    While i is less than or equal to base_len:
        Let is_sep be 0
        If i is equal to base_len:
            Set is_sep to 1
        End If
        Otherwise:
            Let char_byte be proc memory_get_byte from MemoryCore with norm_base plus i, 0
            If char_byte is equal to 47:
                Set is_sep to 1
            End If
        End If

        If is_sep is equal to 1:
            Let comp_len be i minus start
            If comp_len is greater than 0:
                If base_count is less than max_components:
                    Let comp_str be proc allocate from OwnedUtils with comp_len plus 1
                    If comp_str is not equal to 0:
                        Let j be 0
                        While j is less than comp_len:
                            Let comp_byte be proc memory_get_byte from MemoryCore with norm_base plus start plus j, 0
                            Let dummy10 be proc memory_set_byte from MemoryCore with comp_str plus j, 0, comp_byte
                            Set j to j plus 1
                        End While
                        Let dummy11 be proc memory_set_byte from MemoryCore with comp_str plus comp_len, 0, 0
                        Let dummy12 be proc memory_set_integer from MemorySafety with base_components plus base_count times 8, 0, comp_str
                        Set base_count to base_count plus 1
                    End If
                End If
            End If
            Set start to i plus 1
        End If
        Set i to i plus 1
    End While

    Note: Find common prefix length
    Let common_count be 0
    While common_count is less than path_count:
        If common_count is greater than or equal to base_count:
            Set common_count to path_count  Note: Exit loop
        End If
        Otherwise:
            Let path_comp be proc memory_get_integer from MemorySafety with path_components plus common_count times 8, 0
            Let base_comp be proc memory_get_integer from MemorySafety with base_components plus common_count times 8, 0
            Let comp_match be proc string_equals from StringCore with path_comp, base_comp
            If comp_match is equal to 0:
                Set common_count to path_count  Note: Exit loop
            End If
            Otherwise:
                Set common_count to common_count plus 1
            End If
        End If
    End While

    Note: Build relative path: ../ for each remaining base component, then remaining path components
    Let up_count be base_count minus common_count
    Let remaining_count be path_count minus common_count

    Note: Calculate result length
    Let result_len be up_count times 3  Note: "../" per up
    Set i to common_count
    While i is less than path_count:
        Let comp_ptr be proc memory_get_integer from MemorySafety with path_components plus i times 8, 0
        Let comp_len be proc string_length from StringCore with comp_ptr
        Set result_len to result_len plus comp_len
        If i is less than path_count minus 1:
            Set result_len to result_len plus 1  Note: "/"
        End If
        Set i to i plus 1
    End While

    If result_len is equal to 0:
        Set result_len to 1  Note: "."
    End If

    Note: Allocate result
    Let result be 0
    If arena is not equal to 0:
        Set result to proc arena_allocate from ArenaUtils with arena, result_len plus 1, 1
    End If
    Otherwise:
        Set result to proc allocate from OwnedUtils with result_len plus 1
    End If

    If result is equal to 0:
        Note: Cleanup and return
        Set i to 0
        While i is less than path_count:
            Let comp_ptr be proc memory_get_integer from MemorySafety with path_components plus i times 8, 0
            Let dummy13 be proc deallocate from OwnedUtils with comp_ptr
            Set i to i plus 1
        End While
        Set i to 0
        While i is less than base_count:
            Let comp_ptr be proc memory_get_integer from MemorySafety with base_components plus i times 8, 0
            Let dummy14 be proc deallocate from OwnedUtils with comp_ptr
            Set i to i plus 1
        End While
        Let dummy15 be proc deallocate from OwnedUtils with path_components
        Let dummy16 be proc deallocate from OwnedUtils with base_components
        Let dummy17 be proc deallocate from OwnedUtils with norm_path
        Let dummy18 be proc deallocate from OwnedUtils with norm_base
        Return 0
    End If

    Note: Write result
    Let write_pos be 0

    Note: Write ../ for each up level
    Set i to 0
    While i is less than up_count:
        Let dummy19 be proc memory_set_byte from MemoryCore with result plus write_pos, 0, 46  Note: '.'
        Let dummy20 be proc memory_set_byte from MemoryCore with result plus write_pos plus 1, 0, 46  Note: '.'
        Let dummy21 be proc memory_set_byte from MemoryCore with result plus write_pos plus 2, 0, 47  Note: '/'
        Set write_pos to write_pos plus 3
        Set i to i plus 1
    End While

    Note: Write remaining path components
    Set i to common_count
    While i is less than path_count:
        Let comp_ptr be proc memory_get_integer from MemorySafety with path_components plus i times 8, 0
        Let comp_len be proc string_length from StringCore with comp_ptr
        Let j be 0
        While j is less than comp_len:
            Let comp_byte be proc memory_get_byte from MemoryCore with comp_ptr plus j, 0
            Let dummy22 be proc memory_set_byte from MemoryCore with result plus write_pos, 0, comp_byte
            Set write_pos to write_pos plus 1
            Set j to j plus 1
        End While
        If i is less than path_count minus 1:
            Let dummy23 be proc memory_set_byte from MemoryCore with result plus write_pos, 0, 47
            Set write_pos to write_pos plus 1
        End If
        Set i to i plus 1
    End While

    Note: Handle empty result (same directory)
    If write_pos is equal to 0:
        Let dummy24 be proc memory_set_byte from MemoryCore with result, 0, 46  Note: '.'
        Set write_pos to 1
    End If

    Note: Null terminate
    Let dummy25 be proc memory_set_byte from MemoryCore with result plus write_pos, 0, 0

    Note: Cleanup component arrays
    Set i to 0
    While i is less than path_count:
        Let comp_ptr be proc memory_get_integer from MemorySafety with path_components plus i times 8, 0
        Let dummy26 be proc deallocate from OwnedUtils with comp_ptr
        Set i to i plus 1
    End While
    Set i to 0
    While i is less than base_count:
        Let comp_ptr be proc memory_get_integer from MemorySafety with base_components plus i times 8, 0
        Let dummy27 be proc deallocate from OwnedUtils with comp_ptr
        Set i to i plus 1
    End While

    Let dummy28 be proc deallocate from OwnedUtils with path_components
    Let dummy29 be proc deallocate from OwnedUtils with base_components
    Let dummy30 be proc deallocate from OwnedUtils with norm_path
    Let dummy31 be proc deallocate from OwnedUtils with norm_base

    Return result
End Process

Process called "file_path_exists" takes path as Integer returns Integer:
    Note: Check if path exists (delegates to file_exists)
    Note: Returns 1 if exists, 0 if not exists

    Return proc file_exists with path
End Process

Process called "file_path_is_absolute" takes path as Integer returns Integer:
    Note: Check if path is absolute (starts with /)
    Note: Returns 1 if absolute, 0 if relative

    If path is equal to 0:
        Return 0
    End If

    Let first_char be proc memory_get_byte from MemoryCore with path, 0
    If first_char is equal to 47:  Note: '/' character
        Return 1
    End If

    Return 0
End Process

Process called "file_path_is_relative" takes path as Integer returns Integer:
    Note: Check if path is relative (does not start with /)
    Note: Returns 1 if relative, 0 if absolute

    Let is_absolute be proc file_path_is_absolute with path
    If is_absolute is equal to 1:
        Return 0
    End If

    Return 1
End Process

Note: ============================================================================
Note: File Directory Operations
Note: ============================================================================

Process called "file_directory_create" takes path as Integer returns Integer:
    Note: Create directory using mkdir syscall
    Note: Returns 1 if successful, 0 if failed
    Note: Creates single directory (mode 0755)

    If path is equal to 0:
        Return 0
    End If

    Note: Create directory (syscall 83: mkdir, mode 0755 = 493)
    Let syscall_mkdir be 83
    Let dir_mode be 493  Note: 0755 permissions
    Let result be proc syscall_2 from Syscall with syscall_mkdir, path, dir_mode

    If result is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "file_directory_delete" takes path as Integer returns Integer:
    Note: Delete directory using rmdir syscall
    Note: Returns 1 if successful, 0 if failed
    Note: Only removes empty directories

    If path is equal to 0:
        Return 0
    End If

    Note: Delete directory (syscall 84: rmdir)
    Let syscall_rmdir be 84
    Let result be proc syscall_1 from Syscall with syscall_rmdir, path

    If result is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "file_directory_exists" takes path as Integer returns Integer:
    Note: Check if directory exists using file_get_type
    Note: Returns 1 if exists and is directory, 0 otherwise

    If path is equal to 0:
        Return 0
    End If

    Let file_type be proc file_get_type with path
    If file_type is equal to FILE_TYPE_DIRECTORY:
        Return 1
    End If

    Return 0
End Process

Process called "file_directory_list" takes path as Integer, arena as Integer returns Integer:
    Note: List directory contents using getdents64 syscall
    Note: Returns pointer to array of filename strings (null-terminated array of pointers)
    Note: Uses arena allocation for result

    If path is equal to 0:
        Return 0
    End If

    Note: Open directory for reading
    Let fd be proc syscall_2 from Syscall with 2, path, 0  Note: open syscall with O_RDONLY

    If fd is less than 0:
        Return 0
    End If

    Note: Allocate buffer for directory entries (32KB)
    Let buffer_size be 32768
    Let buffer be proc allocate from OwnedUtils with buffer_size
    If buffer is equal to 0:
        Let close_result be proc syscall_1 from Syscall with 3, fd  Note: close syscall
        Return 0
    End If

    Note: Allocate result array (maximum 1024 entries)
    Let max_entries be 1024
    Let result_array be 0
    If arena is not equal to 0:
        Set result_array to proc arena_allocate from ArenaUtils with arena, max_entries times 8, 8
    End If
    Otherwise:
        Set result_array to proc allocate from OwnedUtils with max_entries times 8
    End If

    If result_array is equal to 0:
        Let dummy1 be proc deallocate from OwnedUtils with buffer
        Let close_result be proc syscall_1 from Syscall with 3, fd
        Return 0
    End If

    Note: Read directory entries (syscall 217: getdents64)
    Let syscall_getdents64 be 217
    Let bytes_read be proc syscall_3 from Syscall with syscall_getdents64, fd, buffer, buffer_size

    Note: Close directory
    Let close_result be proc syscall_1 from Syscall with 3, fd

    If bytes_read is less than or equal to 0:
        Let dummy2 be proc deallocate from OwnedUtils with buffer
        Return result_array  Note: Return empty array
    End If

    Note: Parse directory entries using dirent64 structure
    Note: struct linux_dirent64: d_ino(8), d_off(8), d_reclen(2), d_type(1), d_name(variable)
    Let entry_count be 0
    Let pos be 0

    While pos is less than bytes_read:
        If entry_count is greater than or equal to max_entries:
            Note: Array full, stop parsing
            Set pos to bytes_read
        End If
        Otherwise:
            Note: Get d_reclen (record length) at offset pos+16 (2 bytes)
            Let reclen_byte1 be proc memory_get_byte from MemoryCore with buffer plus pos plus 16, 0
            Let reclen_byte2 be proc memory_get_byte from MemoryCore with buffer plus pos plus 17, 0
            Let reclen be reclen_byte1 plus reclen_byte2 times 256

            If reclen is equal to 0:
                Note: Invalid record, stop parsing
                Set pos to bytes_read
            End If
            Otherwise:
                Note: d_name starts at offset 19
                Let name_offset be pos plus 19
                Let name_ptr be buffer plus name_offset

                Note: Calculate name length
                Let name_len be 0
                While name_len is less than 256:
                    Let name_byte be proc memory_get_byte from MemoryCore with name_ptr plus name_len, 0
                    If name_byte is equal to 0:
                        Set name_len to 256  Note: Exit loop
                    End If
                    Otherwise:
                        Set name_len to name_len plus 1
                    End If
                End While

                Note: Skip "." and ".." entries
                Let is_dot be 0
                Let first_char be proc memory_get_byte from MemoryCore with name_ptr, 0
                If first_char is equal to 46:  Note: '.'
                    Let second_char be proc memory_get_byte from MemoryCore with name_ptr plus 1, 0
                    If second_char is equal to 0:
                        Set is_dot to 1  Note: "." entry
                    End If
                    Otherwise If second_char is equal to 46:  Note: '.'
                        Let third_char be proc memory_get_byte from MemoryCore with name_ptr plus 2, 0
                        If third_char is equal to 0:
                            Set is_dot to 1  Note: ".." entry
                        End If
                    End If
                End If

                If is_dot is equal to 0:
                    Note: Allocate string for filename
                    Let filename_str be 0
                    If arena is not equal to 0:
                        Set filename_str to proc arena_allocate from ArenaUtils with arena, name_len plus 1, 1
                    End If
                    Otherwise:
                        Set filename_str to proc allocate from OwnedUtils with name_len plus 1
                    End If

                    If filename_str is not equal to 0:
                        Note: Copy filename
                        Let i be 0
                        While i is less than name_len:
                            Let char_byte be proc memory_get_byte from MemoryCore with name_ptr plus i, 0
                            If char_byte is equal to 0:
                                Set i to name_len  Note: Exit loop
                            End If
                            Otherwise:
                                Let dummy_copy be proc memory_set_byte from MemoryCore with filename_str plus i, 0, char_byte
                                Set i to i plus 1
                            End If
                        End While
                        Let dummy_null be proc memory_set_byte from MemoryCore with filename_str plus name_len, 0, 0

                        Note: Store pointer in result array
                        Let dummy_store be proc memory_set_integer from MemorySafety with result_array plus entry_count times 8, 0, filename_str
                        Set entry_count to entry_count plus 1
                    End If
                End If

                Note: Move to next entry
                Set pos to pos plus reclen
            End If
        End If
    End While

    Note: Null-terminate array
    If entry_count is less than max_entries:
        Let dummy_term be proc memory_set_integer from MemorySafety with result_array plus entry_count times 8, 0, 0
    End If

    Let dummy3 be proc deallocate from OwnedUtils with buffer
    Return result_array
End Process

Process called "file_directory_walk" takes path as Integer, callback as Integer, arena as Integer returns Integer:
    Note: Walk directory tree recursively calling callback for each entry
    Note: Returns 1 if successful, 0 if failed
    Note: Callback receives (path_string, is_directory) and returns 1 to continue

    If path is equal to 0:
        Return 0
    End If

    If callback is equal to 0:
        Return 0
    End If

    Note: Check if path is directory
    Let is_dir be proc file_directory_exists with path
    If is_dir is equal to 0:
        Note: Not a directory, just call callback on this file
        Let callback_result be proc syscall_2 from Syscall with callback, path, 0
        If callback_result is equal to 1:
            Return 1
        End If
        Return 0
    End If

    Note: Call callback on directory itself
    Let callback_result be proc syscall_2 from Syscall with callback, path, 1
    If callback_result is not equal to 1:
        Return 0
    End If

    Note: List directory contents
    Let entries be proc file_directory_list with path, arena
    If entries is equal to 0:
        Return 1  Note: Empty directory is success
    End If

    Note: Iterate through entries array and recursively process each
    Let i be 0
    Let max_iterations be 1024  Note: Safety limit

    While i is less than max_iterations:
        Note: Get entry pointer from array
        Let entry_ptr be proc memory_get_integer from MemorySafety with entries plus i times 8, 0

        If entry_ptr is equal to 0:
            Note: End of array (null terminator)
            Set i to max_iterations  Note: Exit loop
        End If
        Otherwise:
            Note: Build full path by joining directory with entry name
            Let full_path be proc file_path_join with path, entry_ptr, arena

            If full_path is not equal to 0:
                Note: Check if this entry is a directory
                Let entry_is_dir be proc file_directory_exists with full_path

                If entry_is_dir is equal to 1:
                    Note: Recursively walk subdirectory
                    Let walk_result be proc file_directory_walk with full_path, callback, arena
                    If walk_result is equal to 0:
                        Return 0  Note: Callback requested stop
                    End If
                End If
                Otherwise:
                    Note: Regular file, call callback
                    Let file_callback_result be proc syscall_2 from Syscall with callback, full_path, 0
                    If file_callback_result is not equal to 1:
                        Return 0  Note: Callback requested stop
                    End If
                End If
            End If

            Set i to i plus 1
        End If
    End While

    Return 1
End Process

Note: ============================================================================
Note: File Statistics Operations
Note: ============================================================================

Process called "file_get_stats" takes returns Integer:
    Note: Get file statistics from global stats
    Note: Returns pointer to FileStats structure copy (owned allocation)
    Note: Provides detailed file metrics

    Note: Initialize stats if needed
    Let init_result be proc file_init_stats
    If init_result is equal to 0:
        Return 0
    End If

    If GLOBAL_FILE_STATS is equal to 0:
        Return 0
    End If

    Note: Allocate copy of stats structure (48 bytes)
    Let stats_copy be proc allocate from OwnedUtils with 48
    If stats_copy is equal to 0:
        Return 0
    End If

    Note: Copy all fields
    Let total_files be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 0
    Let total_bytes be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 8
    Let read_ops be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 16
    Let write_ops be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 24
    Let file_time be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 32
    Let file_memory be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 40

    Let dummy1 be proc memory_set_integer from MemorySafety with stats_copy, 0, total_files
    Let dummy2 be proc memory_set_integer from MemorySafety with stats_copy, 8, total_bytes
    Let dummy3 be proc memory_set_integer from MemorySafety with stats_copy, 16, read_ops
    Let dummy4 be proc memory_set_integer from MemorySafety with stats_copy, 24, write_ops
    Let dummy5 be proc memory_set_integer from MemorySafety with stats_copy, 32, file_time
    Let dummy6 be proc memory_set_integer from MemorySafety with stats_copy, 40, file_memory

    Return stats_copy
End Process

Process called "file_reset_stats" takes returns Nothing:
    Note: Reset file statistics to zero
    Note: Clears all file counters in global stats

    Note: Initialize stats if needed
    Let init_result be proc file_init_stats
    If init_result is equal to 0:
        Return
    End If

    If GLOBAL_FILE_STATS is equal to 0:
        Return
    End If

    Note: Reset all stats to 0
    Let dummy1 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 0, 0
    Let dummy2 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 8, 0
    Let dummy3 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 16, 0
    Let dummy4 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 24, 0
    Let dummy5 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 32, 0
    Let dummy6 be proc memory_set_integer from MemorySafety with GLOBAL_FILE_STATS, 40, 0

    Return
End Process

Process called "file_export_stats" takes filename as Integer returns Integer:
    Note: Export file statistics to binary file
    Note: Returns 1 if successful, 0 if failed
    Note: Writes FileStats structure (48 bytes) to file

    If filename is equal to 0:
        Return 0
    End If

    Note: Initialize stats if needed
    Let init_result be proc file_init_stats
    If init_result is equal to 0:
        Return 0
    End If

    If GLOBAL_FILE_STATS is equal to 0:
        Return 0
    End If

    Note: Open file for writing (syscall 2: open, O_WRONLY | O_CREAT | O_TRUNC = 577, mode 0644 = 420)
    Let syscall_open be 2
    Let flags be 577
    Let file_mode be 420
    Let fd be proc syscall_3 from Syscall with syscall_open, filename, flags, file_mode

    If fd is less than 0:
        Return 0
    End If

    Note: Write stats structure (syscall 1: write)
    Let syscall_write be 1
    Let bytes_written be proc syscall_3 from Syscall with syscall_write, fd, GLOBAL_FILE_STATS, 48

    Note: Close file (syscall 3: close)
    Let syscall_close be 3
    Let close_result be proc syscall_1 from Syscall with syscall_close, fd

    If bytes_written is equal to 48:
        Return 1
    End If

    Return 0
End Process

Process called "file_import_stats" takes filename as Integer returns Integer:
    Note: Import file statistics from binary file
    Note: Returns 1 if successful, 0 if failed
    Note: Reads FileStats structure (48 bytes) from file

    If filename is equal to 0:
        Return 0
    End If

    Note: Initialize stats if needed
    Let init_result be proc file_init_stats
    If init_result is equal to 0:
        Return 0
    End If

    If GLOBAL_FILE_STATS is equal to 0:
        Return 0
    End If

    Note: Open file for reading (syscall 2: open, O_RDONLY = 0)
    Let syscall_open be 2
    Let fd be proc syscall_2 from Syscall with syscall_open, filename, 0

    If fd is less than 0:
        Return 0
    End If

    Note: Read stats structure (syscall 0: read)
    Let syscall_read be 0
    Let bytes_read be proc syscall_3 from Syscall with syscall_read, fd, GLOBAL_FILE_STATS, 48

    Note: Close file (syscall 3: close)
    Let syscall_close be 3
    Let close_result be proc syscall_1 from Syscall with syscall_close, fd

    If bytes_read is equal to 48:
        Return 1
    End If

    Return 0
End Process

Process called "file_print_stats" takes returns Nothing:
    Note: Print file statistics to stdout with complete formatting
    Note: Outputs all statistics values in human-readable format
    Note: Uses write syscall to output each line

    Note: Initialize stats if needed
    Let init_result be proc file_init_stats
    If init_result is equal to 0:
        Return
    End If

    If GLOBAL_FILE_STATS is equal to 0:
        Return
    End If

    Note: Get all stats
    Let total_files be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 0
    Let total_bytes be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 8
    Let read_ops be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 16
    Let write_ops be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 24
    Let file_time be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 32
    Let file_memory be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 40

    Let syscall_write be 1
    Let fd_stdout be 1

    Note: Write "File Statistics:\n" header
    Let header be proc allocate from OwnedUtils with 18
    If header is not equal to 0:
        Let dummy1 be proc memory_set_byte from MemoryCore with header, 0, 70  Note: 'F'
        Let dummy2 be proc memory_set_byte from MemoryCore with header, 1, 105  Note: 'i'
        Let dummy3 be proc memory_set_byte from MemoryCore with header, 2, 108  Note: 'l'
        Let dummy4 be proc memory_set_byte from MemoryCore with header, 3, 101  Note: 'e'
        Let dummy5 be proc memory_set_byte from MemoryCore with header, 4, 32  Note: ' '
        Let dummy6 be proc memory_set_byte from MemoryCore with header, 5, 83  Note: 'S'
        Let dummy7 be proc memory_set_byte from MemoryCore with header, 6, 116  Note: 't'
        Let dummy8 be proc memory_set_byte from MemoryCore with header, 7, 97  Note: 'a'
        Let dummy9 be proc memory_set_byte from MemoryCore with header, 8, 116  Note: 't'
        Let dummy10 be proc memory_set_byte from MemoryCore with header, 9, 105  Note: 'i'
        Let dummy11 be proc memory_set_byte from MemoryCore with header, 10, 115  Note: 's'
        Let dummy12 be proc memory_set_byte from MemoryCore with header, 11, 116  Note: 't'
        Let dummy13 be proc memory_set_byte from MemoryCore with header, 12, 105  Note: 'i'
        Let dummy14 be proc memory_set_byte from MemoryCore with header, 13, 99  Note: 'c'
        Let dummy15 be proc memory_set_byte from MemoryCore with header, 14, 115  Note: 's'
        Let dummy16 be proc memory_set_byte from MemoryCore with header, 15, 58  Note: ':'
        Let dummy17 be proc memory_set_byte from MemoryCore with header, 16, 10  Note: newline
        Let write_result1 be proc syscall_3 from Syscall with syscall_write, fd_stdout, header, 17
        Let dummy18 be proc deallocate from OwnedUtils with header
    End If

    Note: Write "  Total Files: N\n"
    Let line1 be proc allocate from OwnedUtils with 64
    If line1 is not equal to 0:
        Note: "  Total Files: "
        Let dummy20 be proc memory_set_byte from MemoryCore with line1, 0, 32  Note: ' '
        Let dummy21 be proc memory_set_byte from MemoryCore with line1, 1, 32  Note: ' '
        Let dummy22 be proc memory_set_byte from MemoryCore with line1, 2, 84  Note: 'T'
        Let dummy23 be proc memory_set_byte from MemoryCore with line1, 3, 111  Note: 'o'
        Let dummy24 be proc memory_set_byte from MemoryCore with line1, 4, 116  Note: 't'
        Let dummy25 be proc memory_set_byte from MemoryCore with line1, 5, 97  Note: 'a'
        Let dummy26 be proc memory_set_byte from MemoryCore with line1, 6, 108  Note: 'l'
        Let dummy27 be proc memory_set_byte from MemoryCore with line1, 7, 32  Note: ' '
        Let dummy28 be proc memory_set_byte from MemoryCore with line1, 8, 70  Note: 'F'
        Let dummy29 be proc memory_set_byte from MemoryCore with line1, 9, 105  Note: 'i'
        Let dummy30 be proc memory_set_byte from MemoryCore with line1, 10, 108  Note: 'l'
        Let dummy31 be proc memory_set_byte from MemoryCore with line1, 11, 101  Note: 'e'
        Let dummy32 be proc memory_set_byte from MemoryCore with line1, 12, 115  Note: 's'
        Let dummy33 be proc memory_set_byte from MemoryCore with line1, 13, 58  Note: ':'
        Let dummy34 be proc memory_set_byte from MemoryCore with line1, 14, 32  Note: ' '

        Note: Convert total_files to decimal string (inline algorithm)
        Let num_copy be total_files
        Let digit_count be 0
        Let temp_buffer be proc allocate from OwnedUtils with 20

        If temp_buffer is not equal to 0:
            Note: Extract digits in reverse order
            If num_copy is equal to 0:
                Let dummy35 be proc memory_set_byte from MemoryCore with temp_buffer, 0, 48  Note: '0'
                Set digit_count to 1
            End If
            Otherwise:
                While num_copy is greater than 0:
                    Let digit be num_copy
                    Let quotient be digit divided by 10
                    Let remainder be digit minus quotient times 10
                    Let digit_char be 48 plus remainder  Note: '0' + digit
                    Let dummy36 be proc memory_set_byte from MemoryCore with temp_buffer plus digit_count, 0, digit_char
                    Set digit_count to digit_count plus 1
                    Set num_copy to quotient
                End While
            End If

            Note: Reverse digits into line1
            Let i be 0
            While i is less than digit_count:
                Let digit_byte be proc memory_get_byte from MemoryCore with temp_buffer plus digit_count minus i minus 1, 0
                Let dummy37 be proc memory_set_byte from MemoryCore with line1 plus 15 plus i, 0, digit_byte
                Set i to i plus 1
            End While

            Let dummy38 be proc memory_set_byte from MemoryCore with line1 plus 15 plus digit_count, 0, 10  Note: newline
            Let write_result2 be proc syscall_3 from Syscall with syscall_write, fd_stdout, line1, 16 plus digit_count
            Let dummy39 be proc deallocate from OwnedUtils with temp_buffer
        End If

        Let dummy40 be proc deallocate from OwnedUtils with line1
    End If

    Note: Write "  Total Bytes: N\n" (same pattern as Total Files)
    Let line2 be proc allocate from OwnedUtils with 64
    If line2 is not equal to 0:
        Let dummy41 be proc memory_set_byte from MemoryCore with line2, 0, 32
        Let dummy42 be proc memory_set_byte from MemoryCore with line2, 1, 32
        Let dummy43 be proc memory_set_byte from MemoryCore with line2, 2, 84  Note: 'T'
        Let dummy44 be proc memory_set_byte from MemoryCore with line2, 3, 111  Note: 'o'
        Let dummy45 be proc memory_set_byte from MemoryCore with line2, 4, 116  Note: 't'
        Let dummy46 be proc memory_set_byte from MemoryCore with line2, 5, 97  Note: 'a'
        Let dummy47 be proc memory_set_byte from MemoryCore with line2, 6, 108  Note: 'l'
        Let dummy48 be proc memory_set_byte from MemoryCore with line2, 7, 32
        Let dummy49 be proc memory_set_byte from MemoryCore with line2, 8, 66  Note: 'B'
        Let dummy50 be proc memory_set_byte from MemoryCore with line2, 9, 121  Note: 'y'
        Let dummy51 be proc memory_set_byte from MemoryCore with line2, 10, 116  Note: 't'
        Let dummy52 be proc memory_set_byte from MemoryCore with line2, 11, 101  Note: 'e'
        Let dummy53 be proc memory_set_byte from MemoryCore with line2, 12, 115  Note: 's'
        Let dummy54 be proc memory_set_byte from MemoryCore with line2, 13, 58
        Let dummy55 be proc memory_set_byte from MemoryCore with line2, 14, 32

        Let num_copy2 be total_bytes
        Let digit_count2 be 0
        Let temp_buffer2 be proc allocate from OwnedUtils with 20
        If temp_buffer2 is not equal to 0:
            If num_copy2 is equal to 0:
                Let dummy56 be proc memory_set_byte from MemoryCore with temp_buffer2, 0, 48
                Set digit_count2 to 1
            End If
            Otherwise:
                While num_copy2 is greater than 0:
                    Let digit2 be num_copy2
                    Let quotient2 be digit2 divided by 10
                    Let remainder2 be digit2 minus quotient2 times 10
                    Let digit_char2 be 48 plus remainder2
                    Let dummy57 be proc memory_set_byte from MemoryCore with temp_buffer2 plus digit_count2, 0, digit_char2
                    Set digit_count2 to digit_count2 plus 1
                    Set num_copy2 to quotient2
                End While
            End If
            Let i2 be 0
            While i2 is less than digit_count2:
                Let digit_byte2 be proc memory_get_byte from MemoryCore with temp_buffer2 plus digit_count2 minus i2 minus 1, 0
                Let dummy58 be proc memory_set_byte from MemoryCore with line2 plus 15 plus i2, 0, digit_byte2
                Set i2 to i2 plus 1
            End While
            Let dummy59 be proc memory_set_byte from MemoryCore with line2 plus 15 plus digit_count2, 0, 10
            Let write_result3 be proc syscall_3 from Syscall with syscall_write, fd_stdout, line2, 16 plus digit_count2
            Let dummy60 be proc deallocate from OwnedUtils with temp_buffer2
        End If
        Let dummy61 be proc deallocate from OwnedUtils with line2
    End If

    Note: Write "  Read Operations: N\n"
    Let line3 be proc allocate from OwnedUtils with 64
    If line3 is not equal to 0:
        Let dummy62 be proc memory_set_byte from MemoryCore with line3, 0, 32
        Let dummy63 be proc memory_set_byte from MemoryCore with line3, 1, 32
        Let dummy64 be proc memory_set_byte from MemoryCore with line3, 2, 82  Note: 'R'
        Let dummy65 be proc memory_set_byte from MemoryCore with line3, 3, 101  Note: 'e'
        Let dummy66 be proc memory_set_byte from MemoryCore with line3, 4, 97  Note: 'a'
        Let dummy67 be proc memory_set_byte from MemoryCore with line3, 5, 100  Note: 'd'
        Let dummy68 be proc memory_set_byte from MemoryCore with line3, 6, 32
        Let dummy69 be proc memory_set_byte from MemoryCore with line3, 7, 79  Note: 'O'
        Let dummy70 be proc memory_set_byte from MemoryCore with line3, 8, 112  Note: 'p'
        Let dummy71 be proc memory_set_byte from MemoryCore with line3, 9, 115  Note: 's'
        Let dummy72 be proc memory_set_byte from MemoryCore with line3, 10, 58
        Let dummy73 be proc memory_set_byte from MemoryCore with line3, 11, 32

        Let num_copy3 be read_ops
        Let digit_count3 be 0
        Let temp_buffer3 be proc allocate from OwnedUtils with 20
        If temp_buffer3 is not equal to 0:
            If num_copy3 is equal to 0:
                Let dummy74 be proc memory_set_byte from MemoryCore with temp_buffer3, 0, 48
                Set digit_count3 to 1
            End If
            Otherwise:
                While num_copy3 is greater than 0:
                    Let digit3 be num_copy3
                    Let quotient3 be digit3 divided by 10
                    Let remainder3 be digit3 minus quotient3 times 10
                    Let digit_char3 be 48 plus remainder3
                    Let dummy75 be proc memory_set_byte from MemoryCore with temp_buffer3 plus digit_count3, 0, digit_char3
                    Set digit_count3 to digit_count3 plus 1
                    Set num_copy3 to quotient3
                End While
            End If
            Let i3 be 0
            While i3 is less than digit_count3:
                Let digit_byte3 be proc memory_get_byte from MemoryCore with temp_buffer3 plus digit_count3 minus i3 minus 1, 0
                Let dummy76 be proc memory_set_byte from MemoryCore with line3 plus 12 plus i3, 0, digit_byte3
                Set i3 to i3 plus 1
            End While
            Let dummy77 be proc memory_set_byte from MemoryCore with line3 plus 12 plus digit_count3, 0, 10
            Let write_result4 be proc syscall_3 from Syscall with syscall_write, fd_stdout, line3, 13 plus digit_count3
            Let dummy78 be proc deallocate from OwnedUtils with temp_buffer3
        End If
        Let dummy79 be proc deallocate from OwnedUtils with line3
    End If

    Note: Write "  Write Operations: N\n"
    Let line4 be proc allocate from OwnedUtils with 64
    If line4 is not equal to 0:
        Let dummy80 be proc memory_set_byte from MemoryCore with line4, 0, 32
        Let dummy81 be proc memory_set_byte from MemoryCore with line4, 1, 32
        Let dummy82 be proc memory_set_byte from MemoryCore with line4, 2, 87  Note: 'W'
        Let dummy83 be proc memory_set_byte from MemoryCore with line4, 3, 114  Note: 'r'
        Let dummy84 be proc memory_set_byte from MemoryCore with line4, 4, 105  Note: 'i'
        Let dummy85 be proc memory_set_byte from MemoryCore with line4, 5, 116  Note: 't'
        Let dummy86 be proc memory_set_byte from MemoryCore with line4, 6, 101  Note: 'e'
        Let dummy87 be proc memory_set_byte from MemoryCore with line4, 7, 32
        Let dummy88 be proc memory_set_byte from MemoryCore with line4, 8, 79  Note: 'O'
        Let dummy89 be proc memory_set_byte from MemoryCore with line4, 9, 112  Note: 'p'
        Let dummy90 be proc memory_set_byte from MemoryCore with line4, 10, 115  Note: 's'
        Let dummy91 be proc memory_set_byte from MemoryCore with line4, 11, 58
        Let dummy92 be proc memory_set_byte from MemoryCore with line4, 12, 32

        Let num_copy4 be write_ops
        Let digit_count4 be 0
        Let temp_buffer4 be proc allocate from OwnedUtils with 20
        If temp_buffer4 is not equal to 0:
            If num_copy4 is equal to 0:
                Let dummy93 be proc memory_set_byte from MemoryCore with temp_buffer4, 0, 48
                Set digit_count4 to 1
            End If
            Otherwise:
                While num_copy4 is greater than 0:
                    Let digit4 be num_copy4
                    Let quotient4 be digit4 divided by 10
                    Let remainder4 be digit4 minus quotient4 times 10
                    Let digit_char4 be 48 plus remainder4
                    Let dummy94 be proc memory_set_byte from MemoryCore with temp_buffer4 plus digit_count4, 0, digit_char4
                    Set digit_count4 to digit_count4 plus 1
                    Set num_copy4 to quotient4
                End While
            End If
            Let i4 be 0
            While i4 is less than digit_count4:
                Let digit_byte4 be proc memory_get_byte from MemoryCore with temp_buffer4 plus digit_count4 minus i4 minus 1, 0
                Let dummy95 be proc memory_set_byte from MemoryCore with line4 plus 13 plus i4, 0, digit_byte4
                Set i4 to i4 plus 1
            End While
            Let dummy96 be proc memory_set_byte from MemoryCore with line4 plus 13 plus digit_count4, 0, 10
            Let write_result5 be proc syscall_3 from Syscall with syscall_write, fd_stdout, line4, 14 plus digit_count4
            Let dummy97 be proc deallocate from OwnedUtils with temp_buffer4
        End If
        Let dummy98 be proc deallocate from OwnedUtils with line4
    End If

    Note: Write "  File Time: N\n"
    Let line5 be proc allocate from OwnedUtils with 64
    If line5 is not equal to 0:
        Let dummy99 be proc memory_set_byte from MemoryCore with line5, 0, 32
        Let dummy100 be proc memory_set_byte from MemoryCore with line5, 1, 32
        Let dummy101 be proc memory_set_byte from MemoryCore with line5, 2, 70  Note: 'F'
        Let dummy102 be proc memory_set_byte from MemoryCore with line5, 3, 105  Note: 'i'
        Let dummy103 be proc memory_set_byte from MemoryCore with line5, 4, 108  Note: 'l'
        Let dummy104 be proc memory_set_byte from MemoryCore with line5, 5, 101  Note: 'e'
        Let dummy105 be proc memory_set_byte from MemoryCore with line5, 6, 32
        Let dummy106 be proc memory_set_byte from MemoryCore with line5, 7, 84  Note: 'T'
        Let dummy107 be proc memory_set_byte from MemoryCore with line5, 8, 105  Note: 'i'
        Let dummy108 be proc memory_set_byte from MemoryCore with line5, 9, 109  Note: 'm'
        Let dummy109 be proc memory_set_byte from MemoryCore with line5, 10, 101  Note: 'e'
        Let dummy110 be proc memory_set_byte from MemoryCore with line5, 11, 58
        Let dummy111 be proc memory_set_byte from MemoryCore with line5, 12, 32

        Let num_copy5 be file_time
        Let digit_count5 be 0
        Let temp_buffer5 be proc allocate from OwnedUtils with 20
        If temp_buffer5 is not equal to 0:
            If num_copy5 is equal to 0:
                Let dummy112 be proc memory_set_byte from MemoryCore with temp_buffer5, 0, 48
                Set digit_count5 to 1
            End If
            Otherwise:
                While num_copy5 is greater than 0:
                    Let digit5 be num_copy5
                    Let quotient5 be digit5 divided by 10
                    Let remainder5 be digit5 minus quotient5 times 10
                    Let digit_char5 be 48 plus remainder5
                    Let dummy113 be proc memory_set_byte from MemoryCore with temp_buffer5 plus digit_count5, 0, digit_char5
                    Set digit_count5 to digit_count5 plus 1
                    Set num_copy5 to quotient5
                End While
            End If
            Let i5 be 0
            While i5 is less than digit_count5:
                Let digit_byte5 be proc memory_get_byte from MemoryCore with temp_buffer5 plus digit_count5 minus i5 minus 1, 0
                Let dummy114 be proc memory_set_byte from MemoryCore with line5 plus 13 plus i5, 0, digit_byte5
                Set i5 to i5 plus 1
            End While
            Let dummy115 be proc memory_set_byte from MemoryCore with line5 plus 13 plus digit_count5, 0, 10
            Let write_result6 be proc syscall_3 from Syscall with syscall_write, fd_stdout, line5, 14 plus digit_count5
            Let dummy116 be proc deallocate from OwnedUtils with temp_buffer5
        End If
        Let dummy117 be proc deallocate from OwnedUtils with line5
    End If

    Note: Write "  File Memory: N\n"
    Let line6 be proc allocate from OwnedUtils with 64
    If line6 is not equal to 0:
        Let dummy118 be proc memory_set_byte from MemoryCore with line6, 0, 32
        Let dummy119 be proc memory_set_byte from MemoryCore with line6, 1, 32
        Let dummy120 be proc memory_set_byte from MemoryCore with line6, 2, 70  Note: 'F'
        Let dummy121 be proc memory_set_byte from MemoryCore with line6, 3, 105  Note: 'i'
        Let dummy122 be proc memory_set_byte from MemoryCore with line6, 4, 108  Note: 'l'
        Let dummy123 be proc memory_set_byte from MemoryCore with line6, 5, 101  Note: 'e'
        Let dummy124 be proc memory_set_byte from MemoryCore with line6, 6, 32
        Let dummy125 be proc memory_set_byte from MemoryCore with line6, 7, 77  Note: 'M'
        Let dummy126 be proc memory_set_byte from MemoryCore with line6, 8, 101  Note: 'e'
        Let dummy127 be proc memory_set_byte from MemoryCore with line6, 9, 109  Note: 'm'
        Let dummy128 be proc memory_set_byte from MemoryCore with line6, 10, 111  Note: 'o'
        Let dummy129 be proc memory_set_byte from MemoryCore with line6, 11, 114  Note: 'r'
        Let dummy130 be proc memory_set_byte from MemoryCore with line6, 12, 121  Note: 'y'
        Let dummy131 be proc memory_set_byte from MemoryCore with line6, 13, 58
        Let dummy132 be proc memory_set_byte from MemoryCore with line6, 14, 32

        Let num_copy6 be file_memory
        Let digit_count6 be 0
        Let temp_buffer6 be proc allocate from OwnedUtils with 20
        If temp_buffer6 is not equal to 0:
            If num_copy6 is equal to 0:
                Let dummy133 be proc memory_set_byte from MemoryCore with temp_buffer6, 0, 48
                Set digit_count6 to 1
            End If
            Otherwise:
                While num_copy6 is greater than 0:
                    Let digit6 be num_copy6
                    Let quotient6 be digit6 divided by 10
                    Let remainder6 be digit6 minus quotient6 times 10
                    Let digit_char6 be 48 plus remainder6
                    Let dummy134 be proc memory_set_byte from MemoryCore with temp_buffer6 plus digit_count6, 0, digit_char6
                    Set digit_count6 to digit_count6 plus 1
                    Set num_copy6 to quotient6
                End While
            End If
            Let i6 be 0
            While i6 is less than digit_count6:
                Let digit_byte6 be proc memory_get_byte from MemoryCore with temp_buffer6 plus digit_count6 minus i6 minus 1, 0
                Let dummy135 be proc memory_set_byte from MemoryCore with line6 plus 15 plus i6, 0, digit_byte6
                Set i6 to i6 plus 1
            End While
            Let dummy136 be proc memory_set_byte from MemoryCore with line6 plus 15 plus digit_count6, 0, 10
            Let write_result7 be proc syscall_3 from Syscall with syscall_write, fd_stdout, line6, 16 plus digit_count6
            Let dummy137 be proc deallocate from OwnedUtils with temp_buffer6
        End If
        Let dummy138 be proc deallocate from OwnedUtils with line6
    End If

    Return
End Process

Note: ============================================================================
Note: File Optimization Operations
Note: ============================================================================

Process called "file_optimize" takes returns Integer:
    Note: Optimize file operations by pre-allocating global stats
    Note: Returns 1 if successful, 0 if failed
    Note: Ensures file statistics structure is ready for use

    Note: Initialize stats if needed
    Let init_result be proc file_init_stats
    If init_result is equal to 0:
        Return 0
    End If

    If GLOBAL_FILE_STATS is equal to 0:
        Return 0
    End If

    Note: Stats already optimized (pre-allocated)
    Return 1
End Process

Process called "file_benchmark" takes iterations as Integer returns Integer:
    Note: Benchmark file operations performance
    Note: Returns elapsed time in nanoseconds or -1 if failed
    Note: Measures open/close overhead using clock_gettime

    If iterations is less than or equal to 0:
        Return -1
    End If

    Note: Allocate timespec structures (16 bytes each: tv_sec(8), tv_nsec(8))
    Let start_timespec be proc allocate from OwnedUtils with 16
    If start_timespec is equal to 0:
        Return -1
    End If

    Let end_timespec be proc allocate from OwnedUtils with 16
    If end_timespec is equal to 0:
        Let dummy1 be proc deallocate from OwnedUtils with start_timespec
        Return -1
    End If

    Note: Get start time (syscall 228: clock_gettime, CLOCK_MONOTONIC = 1)
    Let syscall_clock_gettime be 228
    Let CLOCK_MONOTONIC be 1
    Let start_result be proc syscall_2 from Syscall with syscall_clock_gettime, CLOCK_MONOTONIC, start_timespec

    If start_result is less than 0:
        Let dummy2 be proc deallocate from OwnedUtils with start_timespec
        Let dummy3 be proc deallocate from OwnedUtils with end_timespec
        Return -1
    End If

    Note: Create temporary test file path
    Let test_path be proc allocate from OwnedUtils with 20
    If test_path is equal to 0:
        Let dummy4 be proc deallocate from OwnedUtils with start_timespec
        Let dummy5 be proc deallocate from OwnedUtils with end_timespec
        Return -1
    End If

    Note: Build "/tmp/file_test" string
    Let dummy6 be proc memory_set_byte from MemoryCore with test_path, 0, 47  Note: '/'
    Let dummy7 be proc memory_set_byte from MemoryCore with test_path, 1, 116  Note: 't'
    Let dummy8 be proc memory_set_byte from MemoryCore with test_path, 2, 109  Note: 'm'
    Let dummy9 be proc memory_set_byte from MemoryCore with test_path, 3, 112  Note: 'p'
    Let dummy10 be proc memory_set_byte from MemoryCore with test_path, 4, 47  Note: '/'
    Let dummy11 be proc memory_set_byte from MemoryCore with test_path, 5, 116  Note: 't'
    Let dummy12 be proc memory_set_byte from MemoryCore with test_path, 6, 101  Note: 'e'
    Let dummy13 be proc memory_set_byte from MemoryCore with test_path, 7, 115  Note: 's'
    Let dummy14 be proc memory_set_byte from MemoryCore with test_path, 8, 116  Note: 't'
    Let dummy15 be proc memory_set_byte from MemoryCore with test_path, 9, 0  Note: null

    Note: Run benchmark iterations
    Let i be 0
    While i is less than iterations:
        Let handle be proc file_open with test_path, FILE_MODE_WRITE, 0
        If handle is not equal to 0:
            Let close_result be proc file_close with handle
        End If
        Set i to i plus 1
    End While

    Note: Clean up test file
    Let delete_result be proc file_delete with test_path

    Note: Get end time
    Let end_result be proc syscall_2 from Syscall with syscall_clock_gettime, CLOCK_MONOTONIC, end_timespec

    If end_result is less than 0:
        Let dummy16 be proc deallocate from OwnedUtils with test_path
        Let dummy17 be proc deallocate from OwnedUtils with start_timespec
        Let dummy18 be proc deallocate from OwnedUtils with end_timespec
        Return -1
    End If

    Note: Calculate elapsed time
    Let start_sec be proc memory_get_integer from MemorySafety with start_timespec, 0
    Let start_nsec be proc memory_get_integer from MemorySafety with start_timespec, 8
    Let end_sec be proc memory_get_integer from MemorySafety with end_timespec, 0
    Let end_nsec be proc memory_get_integer from MemorySafety with end_timespec, 8

    Let elapsed_sec be end_sec minus start_sec
    Let elapsed_nsec be end_nsec minus start_nsec

    If elapsed_nsec is less than 0:
        Set elapsed_sec to elapsed_sec minus 1
        Set elapsed_nsec to elapsed_nsec plus 1000000000
    End If

    Note: Convert to total nanoseconds
    Let total_nsec be elapsed_sec times 1000000000 plus elapsed_nsec

    Note: Free allocated memory
    Let dummy19 be proc deallocate from OwnedUtils with test_path
    Let dummy20 be proc deallocate from OwnedUtils with start_timespec
    Let dummy21 be proc deallocate from OwnedUtils with end_timespec

    Return total_nsec
End Process

Process called "file_profile" takes returns Integer:
    Note: Profile file operations performance
    Note: Returns pointer to FileStats structure copy (same as file_get_stats)
    Note: Provides current performance metrics

    Return proc file_get_stats
End Process

Process called "file_validate" takes returns Integer:
    Note: Validate file operations system integrity
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks that global stats structure is properly initialized

    Note: Initialize stats if needed
    Let init_result be proc file_init_stats
    If init_result is equal to 0:
        Return 0
    End If

    If GLOBAL_FILE_STATS is equal to 0:
        Return 0
    End If

    Note: Verify all fields are accessible
    Let total_files be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 0
    Let total_bytes be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 8
    Let read_ops be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 16
    Let write_ops be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 24
    Let file_time be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 32
    Let file_memory be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 40

    Note: Check that values are non-negative (basic validation)
    If total_files is less than 0:
        Return 0
    End If

    If total_bytes is less than 0:
        Return 0
    End If

    If read_ops is less than 0:
        Return 0
    End If

    If write_ops is less than 0:
        Return 0
    End If

    Note: System validated
    Return 1
End Process

Process called "file_verify" takes returns Integer:
    Note: Verify file operations system consistency
    Note: Returns 1 if verified, 0 if corrupted
    Note: Performs comprehensive consistency checks

    Note: Initialize stats if needed
    Let init_result be proc file_init_stats
    If init_result is equal to 0:
        Return 0
    End If

    If GLOBAL_FILE_STATS is equal to 0:
        Return 0
    End If

    Note: Verify all fields are accessible and within reasonable bounds
    Let total_files be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 0
    Let total_bytes be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 8
    Let read_ops be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 16
    Let write_ops be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 24
    Let file_time be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 32
    Let file_memory be proc memory_get_integer from MemorySafety with GLOBAL_FILE_STATS, 40

    Note: Check consistency: read_ops + write_ops should be reasonable relative to total_files
    Let total_ops be read_ops plus write_ops
    If total_ops is less than 0:
        Return 0  Note: Overflow or corruption
    End If

    Note: Check that total_bytes is reasonable
    Note: Allow total_bytes to be any non-negative value as large files are valid
    If total_bytes is less than 0:
        Return 0
    End If

    Note: Check that file_time is non-negative
    If file_time is less than 0:
        Return 0
    End If

    Note: Check that file_memory is non-negative
    If file_memory is less than 0:
        Return 0
    End If

    Note: All consistency checks passed
    Return 1
End Process

Note: File utilities implementation complete