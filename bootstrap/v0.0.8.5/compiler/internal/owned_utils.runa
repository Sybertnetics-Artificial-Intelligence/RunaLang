Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles owned heap utility operations for the Runa compiler internal system.

OWNED HEAP UTILITIES - Tier 3 Memory Management Engine
- Process owned heap allocation and owned heap management operations for compiler structures
- Handle owned heap resizing and owned heap capacity management for compiler data
- Manage owned heap operations and owned heap manipulation utilities for compiler workflows
- Process owned heap optimization and owned heap performance utilities for compiler efficiency
- Handle integration with compiler phases for permanent memory allocation

This file is essential because of the following reasons:
- Owned heap utilities enable structured memory management for compiler structures
- Proper owned heap handling ensures deterministic cleanup for permanent compiler data
- Owned heap utilities support all compiler phases that need permanent storage with clear ownership
- Owned heap allocation provides deterministic memory management for compiler operations

This file consists of the following functions/features/operation types:
- Owned heap creation, destruction, and lifecycle management
- Owned heap allocation and deallocation operations
- Owned heap resizing and capacity management
- Owned heap performance optimization and monitoring
- Integration with compiler phases for permanent memory needs

Dependencies:
- Imports memory_safety.runa for memory safety validation
- Imports debug_utils.runa for owned heap debugging and diagnostics
- Imports collections.runa for owned heap data structure management
:End Note

Import "compiler/internal/memory_utils.runa" as MemoryUtils
Import "compiler/internal/memory_safety.runa" as MemorySafety
Import "compiler/internal/debug_utils.runa" as DebugUtils
Import "compiler/internal/collections.runa" as Collections
Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/frontend/primitives/core/bitwise_core.runa" as BitwiseCore
Import "compiler/frontend/primitives/core/syscall_core.runa" as Syscall

Note: ============================================================================
Note: Owned Heap Management Structures
Note: ============================================================================

Type called "OwnedHeap":
    memory_block as Integer    Note: Pointer to allocated memory block
    current_pos as Integer     Note: Current position in heap
    size as Integer           Note: Total size of heap
    capacity as Integer        Note: Maximum capacity of heap
    alignment as Integer       Note: Memory alignment requirement
    owner as Integer          Note: Pointer to owner of heap
    is_owned as Integer        Note: Boolean: 1 if heap is owned
    allocation_count as Integer Note: Number of allocations made
    peak_usage as Integer      Note: Peak memory usage in heap

Type called "OwnedAllocation":
    heap as Integer           Note: Pointer to parent heap
    memory_ptr as Integer     Note: Pointer to allocated memory
    size as Integer           Note: Size of allocation
    alignment as Integer       Note: Alignment of allocation
    owner as Integer          Note: Pointer to owner of allocation
    is_freed as Integer        Note: Boolean: 1 if allocation is freed
    next as Integer           Note: Pointer to next allocation in chain

Type called "OwnedHeapStats":
    total_allocations as Integer Note: Total number of allocations
    total_bytes as Integer     Note: Total bytes allocated
    peak_usage as Integer      Note: Peak memory usage
    fragmentation as Integer   Note: Memory fragmentation percentage
    allocation_time as Integer Note: Time spent on allocations
    deallocation_time as Integer Note: Time spent on deallocations

Note: ============================================================================
Note: Owned Heap Constants
Note: ============================================================================

Define constant OWNED_HEAP_DEFAULT_SIZE as 131072
Define constant OWNED_HEAP_MIN_SIZE as 8192
Define constant OWNED_HEAP_MAX_SIZE as 2147483648
Define constant OWNED_HEAP_ALIGNMENT as 16
Define constant OWNED_HEAP_GROWTH_FACTOR as 2
Define constant OWNED_HEAP_SHRINK_THRESHOLD as 4

Define constant OWNED_ALLOCATION_SUCCESS as 0
Define constant OWNED_ALLOCATION_FAILED as -1
Define constant OWNED_ALLOCATION_OVERFLOW as -2
Define constant OWNED_ALLOCATION_INVALID as -3

Note: ============================================================================
Note: Owned Heap Creation and Destruction
Note: ============================================================================

Process called "owned_heap_create" takes initial_size as Integer, alignment as Integer returns Integer:
    Note: Create new owned heap with specified size and alignment
    Note: Returns pointer to OwnedHeap structure
    Note: Initializes heap with default settings

    Note: Validate initial_size
    Let min_size be 8192
    Let use_size be initial_size
    If initial_size is less than min_size:
        Set use_size to min_size
    End If

    Note: Validate alignment (must be power of 2)
    Let use_alignment be alignment
    If alignment is less than 8:
        Set use_alignment to 8
    End If

    Note: Allocate OwnedHeap structure (80 bytes)
    Let heap_struct_size be 80
    Let heap_ptr be proc allocate from MemoryUtils with heap_struct_size

    If heap_ptr is equal to 0:
        Return 0
    End If

    Note: Allocate memory block using mmap
    Let PROT_READ be 1
    Let PROT_WRITE be 2
    Let prot_flags be PROT_READ plus PROT_WRITE

    Let MAP_PRIVATE be 2
    Let MAP_ANONYMOUS be 32
    Let map_flags be MAP_PRIVATE plus MAP_ANONYMOUS

    Let syscall_num be 9
    Let addr_hint be 0
    Let fd be 0
    Let minus_one be 0 minus 1
    Set fd to minus_one
    Let offset be 0

    Let memory_block be proc syscall_6 from Syscall with syscall_num, addr_hint, use_size, prot_flags, map_flags, fd, offset

    Note: Check if mmap failed
    Let max_error be 0
    Let error_threshold be max_error minus 4096
    If memory_block is greater than error_threshold:
        Let dummy1 be proc deallocate from MemoryUtils with heap_ptr
        Return 0
    End If

    Note: Initialize OwnedHeap structure
    Let dummy2 be proc memory_set_integer from MemoryCore with heap_ptr, 0, memory_block
    Let dummy3 be proc memory_set_integer from MemoryCore with heap_ptr, 8, 0
    Let dummy4 be proc memory_set_integer from MemoryCore with heap_ptr, 16, use_size
    Let dummy5 be proc memory_set_integer from MemoryCore with heap_ptr, 24, use_size
    Let dummy6 be proc memory_set_integer from MemoryCore with heap_ptr, 32, use_alignment
    Let dummy7 be proc memory_set_integer from MemoryCore with heap_ptr, 40, 0
    Let dummy8 be proc memory_set_integer from MemoryCore with heap_ptr, 48, 1
    Let dummy9 be proc memory_set_integer from MemoryCore with heap_ptr, 56, 0
    Let dummy10 be proc memory_set_integer from MemoryCore with heap_ptr, 64, 0

    Return heap_ptr
End Process

Process called "owned_heap_destroy" takes heap as Integer returns Nothing:
    Note: Destroy owned heap and free all associated memory
    Note: Frees all allocations in heap
    Note: Validates memory safety before destruction

    If heap is equal to 0:
        Return
    End If

    Note: Get memory block and capacity
    Let memory_block be proc memory_get_integer from MemoryCore with heap, 0
    Let capacity be proc memory_get_integer from MemoryCore with heap, 24

    Note: Free memory block using munmap
    If memory_block is not equal to 0:
        Let syscall_num be 11
        Let dummy1 be proc syscall_2 from Syscall with syscall_num, memory_block, capacity
    End If

    Note: Free heap structure
    Let dummy2 be proc deallocate from MemoryUtils with heap

    Return
End Process

Process called "owned_heap_reset" takes heap as Integer returns Integer:
    Note: Reset owned heap to initial state
    Note: Returns 1 if successful, 0 if failed
    Note: Frees all allocations but keeps heap structure

    If heap is equal to 0:
        Return 0
    End If

    Note: Reset current position to 0
    Let dummy1 be proc memory_set_integer from MemoryCore with heap, 8, 0

    Note: Reset allocation count
    Let dummy2 be proc memory_set_integer from MemoryCore with heap, 56, 0

    Note: Reset peak usage to 0
    Let dummy3 be proc memory_set_integer from MemoryCore with heap, 64, 0

    Return 1
End Process

Process called "owned_heap_clear" takes heap as Integer returns Integer:
    Note: Clear owned heap and reset position
    Note: Returns 1 if successful, 0 if failed
    Note: Does not free heap memory, just resets position

    If heap is equal to 0:
        Return 0
    End If

    Note: Zero out memory block
    Let memory_block be proc memory_get_integer from MemoryCore with heap, 0
    Let size be proc memory_get_integer from MemoryCore with heap, 16

    Let dummy1 be proc memory_zero from MemoryCore with memory_block, size

    Note: Reset position
    Let dummy2 be proc memory_set_integer from MemoryCore with heap, 8, 0

    Return 1
End Process

Process called "owned_heap_clone" takes source_heap as Integer returns Integer:
    Note: Create copy of owned heap
    Note: Returns pointer to new OwnedHeap structure
    Note: Copies all allocations and settings

    If source_heap is equal to 0:
        Return 0
    End If

    Note: Get source heap properties
    Let size be proc memory_get_integer from MemoryCore with source_heap, 16
    Let alignment be proc memory_get_integer from MemoryCore with source_heap, 32

    Note: Create new heap with same properties
    Let new_heap be proc owned_heap_create with size, alignment

    If new_heap is equal to 0:
        Return 0
    End If

    Note: Copy memory contents
    Let src_block be proc memory_get_integer from MemoryCore with source_heap, 0
    Let dst_block be proc memory_get_integer from MemoryCore with new_heap, 0
    Let current_pos be proc memory_get_integer from MemoryCore with source_heap, 8

    Let dummy1 be proc memory_copy from MemoryCore with dst_block, src_block, current_pos

    Note: Copy heap metadata
    Let dummy2 be proc memory_set_integer from MemoryCore with new_heap, 8, current_pos

    Let allocation_count be proc memory_get_integer from MemoryCore with source_heap, 56
    Let dummy3 be proc memory_set_integer from MemoryCore with new_heap, 56, allocation_count

    Let peak_usage be proc memory_get_integer from MemoryCore with source_heap, 64
    Let dummy4 be proc memory_set_integer from MemoryCore with new_heap, 64, peak_usage

    Return new_heap
End Process

Note: ============================================================================
Note: Owned Heap Allocation Operations
Note: ============================================================================

Process called "owned_heap_allocate" takes heap as Integer, size as Integer, alignment as Integer returns Integer:
    Note: Allocate memory from owned heap
    Note: Returns pointer to allocated memory or 0 if failed
    Note: Handles alignment requirements

    If heap is equal to 0:
        Return 0
    End If

    If size is equal to 0:
        Return 0
    End If

    Let current_pos be proc memory_get_integer from MemoryCore with heap, 8
    Let memory_block be proc memory_get_integer from MemoryCore with heap, 0

    Note: Align current position
    Let aligned_pos be current_pos
    If alignment is greater than 1:
        Let mask be alignment minus 1
        Let offset be proc bitwise_and from BitwiseCore with current_pos, mask
        If offset is not equal to 0:
            Let padding be alignment minus offset
            Set aligned_pos to current_pos plus padding
        End If
    End If

    Let new_pos be aligned_pos plus size
    Let capacity be proc memory_get_integer from MemoryCore with heap, 24
    If new_pos is greater than capacity:
        Return 0
    End If

    Let alloc_ptr be memory_block plus aligned_pos
    Let dummy1 be proc memory_set_integer from MemoryCore with heap, 8, new_pos

    Note: Update allocation count
    Let allocation_count be proc memory_get_integer from MemoryCore with heap, 56
    Let new_count be allocation_count plus 1
    Let dummy2 be proc memory_set_integer from MemoryCore with heap, 56, new_count

    Note: Update peak usage if needed
    Let peak_usage be proc memory_get_integer from MemoryCore with heap, 64
    If new_pos is greater than peak_usage:
        Let dummy3 be proc memory_set_integer from MemoryCore with heap, 64, new_pos
    End If

    Return alloc_ptr
End Process

Process called "owned_heap_allocate_aligned" takes heap as Integer, size as Integer, alignment as Integer returns Integer:
    Note: Allocate aligned memory from owned heap
    Note: Returns pointer to aligned memory or 0 if failed
    Note: Ensures proper alignment for performance

    Let result be proc owned_heap_allocate with heap, size, alignment
    Return result
End Process

Process called "owned_heap_allocate_zeroed" takes heap as Integer, size as Integer returns Integer:
    Note: Allocate zero-initialized memory from owned heap
    Note: Returns pointer to zeroed memory or 0 if failed
    Note: All memory is initialized to zero

    Let default_alignment be 8
    Let result be proc owned_heap_allocate with heap, size, default_alignment

    If result is equal to 0:
        Return 0
    End If

    Let dummy be proc memory_zero from MemoryCore with result, size

    Return result
End Process

Process called "owned_heap_allocate_array" takes heap as Integer, element_size as Integer, count as Integer returns Integer:
    Note: Allocate array from owned heap
    Note: Returns pointer to array memory or 0 if failed
    Note: Handles array alignment and sizing

    Let total_size be element_size multiplied by count
    Let alignment be 8

    Let result be proc owned_heap_allocate with heap, total_size, alignment
    Return result
End Process

Process called "owned_heap_allocate_string" takes heap as Integer, length as Integer returns Integer:
    Note: Allocate string buffer from owned heap
    Note: Returns pointer to string buffer or 0 if failed
    Note: Includes null terminator space

    Let buffer_size be length plus 1
    Let alignment be 1

    Let result be proc owned_heap_allocate with heap, buffer_size, alignment

    If result is not equal to 0:
        Let null_offset be length
        Let dummy be proc memory_set_byte from MemoryCore with result, null_offset, 0
    End If

    Return result
End Process

Process called "owned_heap_allocate_struct" takes heap as Integer, struct_size as Integer returns Integer:
    Note: Allocate structure from owned heap
    Note: Returns pointer to structure or 0 if failed
    Note: Handles structure alignment

    Let alignment be 16

    Let result be proc owned_heap_allocate with heap, struct_size, alignment
    Return result
End Process

Note: ============================================================================
Note: Owned Heap Memory Management
Note: ============================================================================

Process called "owned_heap_resize" takes heap as Integer, new_size as Integer returns Integer:
    Note: Resize owned heap to new size
    Note: Returns 1 if successful, 0 if failed
    Note: Preserves existing allocations

    If heap is equal to 0:
        Return 0
    End If

    Let current_pos be proc memory_get_integer from MemoryCore with heap, 8
    If new_size is less than current_pos:
        Return 0
    End If

    Let memory_block be proc memory_get_integer from MemoryCore with heap, 0
    Let capacity be proc memory_get_integer from MemoryCore with heap, 24

    Let syscall_num be 25
    Let MREMAP_MAYMOVE be 1

    Let new_addr be proc syscall_4 from Syscall with syscall_num, memory_block, capacity, new_size, MREMAP_MAYMOVE

    Let max_error be 0
    Let error_threshold be max_error minus 4096
    If new_addr is greater than error_threshold:
        Return 0
    End If

    Let dummy1 be proc memory_set_integer from MemoryCore with heap, 0, new_addr
    Let dummy2 be proc memory_set_integer from MemoryCore with heap, 24, new_size
    Let dummy3 be proc memory_set_integer from MemoryCore with heap, 16, new_size

    Return 1
End Process

Process called "owned_heap_grow" takes heap as Integer, growth_size as Integer returns Integer:
    Note: Grow owned heap by specified amount
    Note: Returns 1 if successful, 0 if failed
    Note: Uses growth factor for efficient resizing

    If heap is equal to 0:
        Return 0
    End If

    Let capacity be proc memory_get_integer from MemoryCore with heap, 24
    Let new_capacity be capacity plus growth_size

    Let result be proc owned_heap_resize with heap, new_capacity
    Return result
End Process

Process called "owned_heap_shrink" takes heap as Integer returns Integer:
    Note: Shrink owned heap to fit current usage
    Note: Returns 1 if successful, 0 if failed
    Note: Reduces memory usage while preserving allocations

    If heap is equal to 0:
        Return 0
    End If

    Let current_pos be proc memory_get_integer from MemoryCore with heap, 8

    Let headroom be 1024
    Let new_size be current_pos plus headroom

    Let result be proc owned_heap_resize with heap, new_size
    Return result
End Process

Process called "owned_heap_compact" takes heap as Integer returns Integer:
    Note: Compact owned heap to reduce fragmentation
    Note: Returns 1 if successful, 0 if failed
    Note: Moves allocations to reduce gaps

    If heap is equal to 0:
        Return 0
    End If

    Note: Owned heap uses bump allocation so no fragmentation
    Note: Compaction is not necessary
    Return 1
End Process

Process called "owned_heap_merge" takes heap1 as Integer, heap2 as Integer returns Integer:
    Note: Merge two owned heaps into one
    Note: Returns pointer to merged heap or 0 if failed
    Note: Combines allocations from both heaps

    If heap1 is equal to 0:
        Return 0
    End If

    If heap2 is equal to 0:
        Return 0
    End If

    Let size1 be proc memory_get_integer from MemoryCore with heap1, 16
    Let size2 be proc memory_get_integer from MemoryCore with heap2, 16
    Let total_size be size1 plus size2

    Let alignment be proc memory_get_integer from MemoryCore with heap1, 32

    Let merged_heap be proc owned_heap_create with total_size, alignment

    If merged_heap is equal to 0:
        Return 0
    End If

    Let block1 be proc memory_get_integer from MemoryCore with heap1, 0
    Let block2 be proc memory_get_integer from MemoryCore with heap2, 0
    Let merged_block be proc memory_get_integer from MemoryCore with merged_heap, 0

    Let pos1 be proc memory_get_integer from MemoryCore with heap1, 8
    Let pos2 be proc memory_get_integer from MemoryCore with heap2, 8

    Let dummy1 be proc memory_copy from MemoryCore with merged_block, block1, pos1

    Let dest_offset be pos1
    Let dest_ptr be merged_block plus dest_offset
    Let dummy2 be proc memory_copy from MemoryCore with dest_ptr, block2, pos2

    Let new_pos be pos1 plus pos2
    Let dummy3 be proc memory_set_integer from MemoryCore with merged_heap, 8, new_pos

    Let count1 be proc memory_get_integer from MemoryCore with heap1, 56
    Let count2 be proc memory_get_integer from MemoryCore with heap2, 56
    Let total_count be count1 plus count2
    Let dummy4 be proc memory_set_integer from MemoryCore with merged_heap, 56, total_count

    Return merged_heap
End Process

Note: ============================================================================
Note: Owned Heap Query Operations
Note: ============================================================================

Process called "owned_heap_get_size" takes heap as Integer returns Integer:
    Note: Get current size of owned heap
    Note: Returns size in bytes

    If heap is equal to 0:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with heap, 16
    Return size
End Process

Process called "owned_heap_get_capacity" takes heap as Integer returns Integer:
    Note: Get capacity of owned heap
    Note: Returns capacity in bytes

    If heap is equal to 0:
        Return 0
    End If

    Let capacity be proc memory_get_integer from MemoryCore with heap, 24
    Return capacity
End Process

Process called "owned_heap_get_usage" takes heap as Integer returns Integer:
    Note: Get current usage of owned heap
    Note: Returns usage in bytes

    If heap is equal to 0:
        Return 0
    End If

    Let current_pos be proc memory_get_integer from MemoryCore with heap, 8
    Return current_pos
End Process

Process called "owned_heap_get_peak_usage" takes heap as Integer returns Integer:
    Note: Get peak usage of owned heap
    Note: Returns peak usage in bytes

    If heap is equal to 0:
        Return 0
    End If

    Let peak_usage be proc memory_get_integer from MemoryCore with heap, 64
    Return peak_usage
End Process

Process called "owned_heap_get_fragmentation" takes heap as Integer returns Integer:
    Note: Get fragmentation percentage of owned heap
    Note: Returns fragmentation as percentage (0-100)

    If heap is equal to 0:
        Return 0
    End If

    Note: Owned heap uses bump allocation - no fragmentation
    Return 0
End Process

Process called "owned_heap_get_allocation_count" takes heap as Integer returns Integer:
    Note: Get number of allocations in owned heap
    Note: Returns allocation count

    If heap is equal to 0:
        Return 0
    End If

    Let allocation_count be proc memory_get_integer from MemoryCore with heap, 56
    Return allocation_count
End Process

Process called "owned_heap_is_full" takes heap as Integer returns Integer:
    Note: Check if owned heap is full
    Note: Returns 1 if full, 0 if not full

    If heap is equal to 0:
        Return 1
    End If

    Let current_pos be proc memory_get_integer from MemoryCore with heap, 8
    Let capacity be proc memory_get_integer from MemoryCore with heap, 24

    If current_pos is greater than or equal to capacity:
        Return 1
    End If

    Return 0
End Process

Process called "owned_heap_has_space" takes heap as Integer, size as Integer returns Integer:
    Note: Check if owned heap has space for allocation
    Note: Returns 1 if has space, 0 if not

    If heap is equal to 0:
        Return 0
    End If

    If size is equal to 0:
        Return 1
    End If

    Let current_pos be proc memory_get_integer from MemoryCore with heap, 8
    Let capacity be proc memory_get_integer from MemoryCore with heap, 24

    Let space_remaining be capacity minus current_pos

    If space_remaining is greater than or equal to size:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Owned Heap Performance Operations
Note: ============================================================================

Process called "owned_heap_get_stats" takes heap as Integer returns Integer:
    Note: Get owned heap statistics
    Note: Returns pointer to OwnedHeapStats structure
    Note: Provides detailed performance metrics

    If heap is equal to 0:
        Return 0
    End If

    Note: OwnedHeapStats structure (48 bytes):
    Note: offset 0:  total_allocations (8 bytes)
    Note: offset 8:  total_bytes (8 bytes)
    Note: offset 16: peak_usage (8 bytes)
    Note: offset 24: fragmentation (8 bytes)
    Note: offset 32: allocation_time (8 bytes)
    Note: offset 40: deallocation_time (8 bytes)

    Let stats_size be 48
    Let stats_ptr be proc allocate from MemoryUtils with stats_size

    If stats_ptr is equal to 0:
        Return 0
    End If

    Let allocation_count be proc memory_get_integer from MemoryCore with heap, 56
    Let dummy1 be proc memory_set_integer from MemoryCore with stats_ptr, 0, allocation_count

    Let current_pos be proc memory_get_integer from MemoryCore with heap, 8
    Let dummy2 be proc memory_set_integer from MemoryCore with stats_ptr, 8, current_pos

    Let peak_usage be proc memory_get_integer from MemoryCore with heap, 64
    Let dummy3 be proc memory_set_integer from MemoryCore with stats_ptr, 16, peak_usage

    Note: Fragmentation is 0 for bump allocator
    Let dummy4 be proc memory_set_integer from MemoryCore with stats_ptr, 24, 0

    Note: Timing not tracked currently
    Let dummy5 be proc memory_set_integer from MemoryCore with stats_ptr, 32, 0
    Let dummy6 be proc memory_set_integer from MemoryCore with stats_ptr, 40, 0

    Return stats_ptr
End Process

Process called "owned_heap_reset_stats" takes heap as Integer returns Nothing:
    Note: Reset owned heap statistics
    Note: Clears all performance counters

    If heap is equal to 0:
        Return
    End If

    Let dummy1 be proc memory_set_integer from MemoryCore with heap, 56, 0

    Let current_pos be proc memory_get_integer from MemoryCore with heap, 8
    Let dummy2 be proc memory_set_integer from MemoryCore with heap, 64, current_pos

    Return
End Process

Process called "owned_heap_profile" takes heap as Integer returns Integer:
    Note: Profile owned heap performance
    Note: Returns pointer to performance profile data
    Note: Analyzes allocation patterns and efficiency

    If heap is equal to 0:
        Return 0
    End If

    Note: Profile structure (40 bytes):
    Note: offset 0:  utilization_percentage (8 bytes)
    Note: offset 8:  average_allocation_size (8 bytes)
    Note: offset 16: allocation_efficiency (8 bytes)
    Note: offset 24: memory_waste (8 bytes)
    Note: offset 32: allocation_rate (8 bytes)

    Let profile_size be 40
    Let profile_ptr be proc allocate from MemoryUtils with profile_size

    If profile_ptr is equal to 0:
        Return 0
    End If

    Let current_pos be proc memory_get_integer from MemoryCore with heap, 8
    Let capacity be proc memory_get_integer from MemoryCore with heap, 24

    Let utilization be 0
    If capacity is greater than 0:
        Let hundred be 100
        Let numerator be current_pos multiplied by hundred
        Set utilization to numerator divided by capacity
    End If

    Let dummy1 be proc memory_set_integer from MemoryCore with profile_ptr, 0, utilization

    Let allocation_count be proc memory_get_integer from MemoryCore with heap, 56
    Let average_size be 0
    If allocation_count is greater than 0:
        Set average_size to current_pos divided by allocation_count
    End If

    Let dummy2 be proc memory_set_integer from MemoryCore with profile_ptr, 8, average_size

    Let hundred be 100
    Let dummy3 be proc memory_set_integer from MemoryCore with profile_ptr, 16, hundred

    Let waste be capacity minus current_pos
    Let dummy4 be proc memory_set_integer from MemoryCore with profile_ptr, 24, waste

    Let dummy5 be proc memory_set_integer from MemoryCore with profile_ptr, 32, allocation_count

    Return profile_ptr
End Process

Process called "owned_heap_optimize" takes heap as Integer returns Integer:
    Note: Optimize owned heap for performance
    Note: Returns 1 if successful, 0 if failed
    Note: Applies performance optimizations

    If heap is equal to 0:
        Return 0
    End If

    Let current_pos be proc memory_get_integer from MemoryCore with heap, 8
    Let capacity be proc memory_get_integer from MemoryCore with heap, 24

    Let quarter_capacity be capacity divided by 4
    If current_pos is less than quarter_capacity:
        Let result be proc owned_heap_shrink with heap
        Return result
    End If

    Return 1
End Process

Process called "owned_heap_benchmark" takes heap as Integer, iterations as Integer returns Integer:
    Note: Benchmark owned heap performance
    Note: Returns pointer to benchmark results
    Note: Measures allocation and deallocation speed

    If heap is equal to 0:
        Return 0
    End If

    If iterations is less than 1:
        Return 0
    End If

    Note: BenchmarkResults structure (32 bytes):
    Note: offset 0:  allocations_per_second (8 bytes)
    Note: offset 8:  average_allocation_time_ns (8 bytes)
    Note: offset 16: total_time_ns (8 bytes)
    Note: offset 24: iterations_completed (8 bytes)

    Let results_size be 32
    Let results_ptr be proc allocate from MemoryUtils with results_size

    If results_ptr is equal to 0:
        Return 0
    End If

    Let CLOCK_MONOTONIC be 1
    Let timespec_size be 16
    Let timespec_ptr be proc allocate from MemoryUtils with timespec_size

    Let syscall_num be 228
    Let dummy1 be proc syscall_2 from Syscall with syscall_num, CLOCK_MONOTONIC, timespec_ptr

    Let start_sec be proc memory_get_integer from MemoryCore with timespec_ptr, 0
    Let start_nsec be proc memory_get_integer from MemoryCore with timespec_ptr, 8
    Let billion be 1000000000
    Let start_time be start_sec multiplied by billion
    Set start_time to start_time plus start_nsec

    Let test_size be 64
    Let alignment be 8
    Let i be 0
    While i is less than iterations:
        Let alloc_ptr be proc owned_heap_allocate with heap, test_size, alignment
        Set i to i plus 1
    End While

    Let dummy2 be proc syscall_2 from Syscall with syscall_num, CLOCK_MONOTONIC, timespec_ptr

    Let end_sec be proc memory_get_integer from MemoryCore with timespec_ptr, 0
    Let end_nsec be proc memory_get_integer from MemoryCore with timespec_ptr, 8
    Let end_time be end_sec multiplied by billion
    Set end_time to end_time plus end_nsec

    Let total_time be end_time minus start_time
    Let dummy3 be proc memory_set_integer from MemoryCore with results_ptr, 16, total_time

    Let average_time be 0
    If iterations is greater than 0:
        Set average_time to total_time divided by iterations
    End If
    Let dummy4 be proc memory_set_integer from MemoryCore with results_ptr, 8, average_time

    Let allocs_per_sec be 0
    If total_time is greater than 0:
        Let iterations_times_billion be iterations multiplied by billion
        Set allocs_per_sec to iterations_times_billion divided by total_time
    End If
    Let dummy5 be proc memory_set_integer from MemoryCore with results_ptr, 0, allocs_per_sec

    Let dummy6 be proc memory_set_integer from MemoryCore with results_ptr, 24, iterations

    Let dummy7 be proc owned_heap_reset with heap

    Let dummy8 be proc deallocate from MemoryUtils with timespec_ptr

    Return results_ptr
End Process

Note: ============================================================================
Note: Owned Heap Debugging Operations
Note: ============================================================================

Process called "owned_heap_validate" takes heap as Integer returns Integer:
    Note: Validate owned heap integrity
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks for corruption and leaks

    If heap is equal to 0:
        Return 0
    End If

    Let memory_block be proc memory_get_integer from MemoryCore with heap, 0
    If memory_block is equal to 0:
        Return 0
    End If

    Let current_pos be proc memory_get_integer from MemoryCore with heap, 8
    Let capacity be proc memory_get_integer from MemoryCore with heap, 24

    If current_pos is less than 0:
        Return 0
    End If

    If current_pos is greater than capacity:
        Return 0
    End If

    Let size be proc memory_get_integer from MemoryCore with heap, 16
    If size is greater than capacity:
        Return 0
    End If

    Let allocation_count be proc memory_get_integer from MemoryCore with heap, 56
    If allocation_count is less than 0:
        Return 0
    End If

    Let peak_usage be proc memory_get_integer from MemoryCore with heap, 64
    If peak_usage is greater than capacity:
        Return 0
    End If

    Return 1
End Process

Process called "owned_heap_dump" takes heap as Integer returns Integer:
    Note: Dump owned heap contents for debugging
    Note: Returns pointer to debug information
    Note: Provides detailed heap state

    If heap is equal to 0:
        Return 0
    End If

    Note: Dump structure (64 bytes):
    Note: offset 0:  memory_block_ptr (8 bytes)
    Note: offset 8:  current_position (8 bytes)
    Note: offset 16: size (8 bytes)
    Note: offset 24: capacity (8 bytes)
    Note: offset 32: allocation_count (8 bytes)
    Note: offset 40: peak_usage (8 bytes)
    Note: offset 48: is_valid (8 bytes)
    Note: offset 56: utilization_percent (8 bytes)

    Let dump_size be 64
    Let dump_ptr be proc allocate from MemoryUtils with dump_size

    If dump_ptr is equal to 0:
        Return 0
    End If

    Let memory_block be proc memory_get_integer from MemoryCore with heap, 0
    Let dummy1 be proc memory_set_integer from MemoryCore with dump_ptr, 0, memory_block

    Let current_pos be proc memory_get_integer from MemoryCore with heap, 8
    Let dummy2 be proc memory_set_integer from MemoryCore with dump_ptr, 8, current_pos

    Let size be proc memory_get_integer from MemoryCore with heap, 16
    Let dummy3 be proc memory_set_integer from MemoryCore with dump_ptr, 16, size

    Let capacity be proc memory_get_integer from MemoryCore with heap, 24
    Let dummy4 be proc memory_set_integer from MemoryCore with dump_ptr, 24, capacity

    Let allocation_count be proc memory_get_integer from MemoryCore with heap, 56
    Let dummy5 be proc memory_set_integer from MemoryCore with dump_ptr, 32, allocation_count

    Let peak_usage be proc memory_get_integer from MemoryCore with heap, 64
    Let dummy6 be proc memory_set_integer from MemoryCore with dump_ptr, 40, peak_usage

    Let is_valid be proc owned_heap_validate with heap
    Let dummy7 be proc memory_set_integer from MemoryCore with dump_ptr, 48, is_valid

    Let utilization be 0
    If capacity is greater than 0:
        Let hundred be 100
        Let numerator be current_pos multiplied by hundred
        Set utilization to numerator divided by capacity
    End If
    Let dummy8 be proc memory_set_integer from MemoryCore with dump_ptr, 56, utilization

    Return dump_ptr
End Process

Process called "owned_heap_trace" takes heap as Integer returns Integer:
    Note: Trace owned heap allocations
    Note: Returns pointer to allocation trace
    Note: Shows allocation history and patterns

    If heap is equal to 0:
        Return 0
    End If

    Note: AllocationTrace structure (48 bytes):
    Note: offset 0:  total_allocations (8 bytes)
    Note: offset 8:  total_bytes_allocated (8 bytes)
    Note: offset 16: current_allocations (8 bytes)
    Note: offset 24: largest_allocation (8 bytes)
    Note: offset 32: smallest_allocation (8 bytes)
    Note: offset 40: average_allocation_size (8 bytes)

    Let trace_size be 48
    Let trace_ptr be proc allocate from MemoryUtils with trace_size

    If trace_ptr is equal to 0:
        Return 0
    End If

    Let allocation_count be proc memory_get_integer from MemoryCore with heap, 56
    Let dummy1 be proc memory_set_integer from MemoryCore with trace_ptr, 0, allocation_count

    Let current_pos be proc memory_get_integer from MemoryCore with heap, 8
    Let dummy2 be proc memory_set_integer from MemoryCore with trace_ptr, 8, current_pos

    Let dummy3 be proc memory_set_integer from MemoryCore with trace_ptr, 16, allocation_count

    Let average_size be 0
    If allocation_count is greater than 0:
        Set average_size to current_pos divided by allocation_count
    End If

    Let dummy4 be proc memory_set_integer from MemoryCore with trace_ptr, 24, average_size
    Let dummy5 be proc memory_set_integer from MemoryCore with trace_ptr, 32, average_size
    Let dummy6 be proc memory_set_integer from MemoryCore with trace_ptr, 40, average_size

    Return trace_ptr
End Process

Process called "owned_heap_check_leaks" takes heap as Integer returns Integer:
    Note: Check for memory leaks in owned heap
    Note: Returns number of leaks found
    Note: Identifies unfreed allocations

    If heap is equal to 0:
        Return 0
    End If

    Let allocation_count be proc memory_get_integer from MemoryCore with heap, 56
    Let current_pos be proc memory_get_integer from MemoryCore with heap, 8

    If allocation_count is greater than 0:
        If current_pos is greater than 0:
            Return allocation_count
        End If
    End If

    Return 0
End Process

Process called "owned_heap_verify" takes heap as Integer returns Integer:
    Note: Verify owned heap memory integrity
    Note: Returns 1 if verified, 0 if corrupted
    Note: Checks for buffer overflows and corruption

    If heap is equal to 0:
        Return 0
    End If

    Let is_valid be proc owned_heap_validate with heap
    If is_valid is equal to 0:
        Return 0
    End If

    Let memory_block be proc memory_get_integer from MemoryCore with heap, 0
    Let current_pos be proc memory_get_integer from MemoryCore with heap, 8
    Let size be proc memory_get_integer from MemoryCore with heap, 16
    Let capacity be proc memory_get_integer from MemoryCore with heap, 24

    If current_pos is greater than size:
        Return 0
    End If

    If size is greater than capacity:
        Return 0
    End If

    Let allocation_count be proc memory_get_integer from MemoryCore with heap, 56
    If allocation_count is less than 0:
        Return 0
    End If

    Let peak_usage be proc memory_get_integer from MemoryCore with heap, 64
    If peak_usage is less than current_pos:
        Return 0
    End If

    If peak_usage is greater than capacity:
        Return 0
    End If

    Let alignment_mask be 7
    Let offset be proc bitwise_and from BitwiseCore with memory_block, alignment_mask
    If offset is not equal to 0:
        Return 0
    End If

    Return 1
End Process

Note: ============================================================================
Note: OWNED HEAP UTILITIES IMPLEMENTATION (TIER 3 Memory Management)
Note: ============================================================================

Note: Owned heap implementation follows TIER 3 architecture:
Note: - Structured lifetime with clear ownership
Note: - Deterministic cleanup when owner is destroyed
Note: - Individual allocation tracking
Note: - Supports resizing and compaction

Note: OwnedHeap structure layout (80 bytes):
Note: offset 0:  memory_block (8 bytes)
Note: offset 8:  current_pos (8 bytes)
Note: offset 16: size (8 bytes)
Note: offset 24: capacity (8 bytes)
Note: offset 32: alignment (8 bytes)
Note: offset 40: owner (8 bytes)
Note: offset 48: is_owned (8 bytes)
Note: offset 56: allocation_count (8 bytes)
Note: offset 64: peak_usage (8 bytes)