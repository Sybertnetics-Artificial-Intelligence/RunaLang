Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles error utilities and error management operations for the Runa compiler internal system.

ERROR UTILITIES - Compiler Error Management Engine
- Process error utilities and error management operations for compiler operations
- Handle error reporting and error information management for compiler development
- Manage error operations and error manipulation utilities for compiler workflows
- Process error optimization and error performance utilities for compiler efficiency
- Handle integration with compiler phases for error management and diagnostic support

This file is essential because of the following reasons:
- Error utilities enable efficient identification and resolution of errors in the compiler
- Proper error handling ensures correct compiler operation and development support
- Error utilities support all compiler phases that need error management and diagnostic capabilities
- Error utilities provide comprehensive error support for compiler operations

This file consists of the following functions/features/operation types:
- Error creation, destruction, and lifecycle management
- Error reporting and error information management operations
- Error optimization and error performance monitoring operations
- Error debugging and error diagnostic utilities
- Integration with compiler phases for error management and diagnostic support

Dependencies:
- Imports arena_utils.runa for arena-based error allocation
- Imports owned_utils.runa for owned error management
- Imports memory_safety.runa for error safety validation
- Imports collections.runa for error data structure management
:End Note

Import "compiler/internal/arena_utils.runa" as ArenaUtils
Import "compiler/internal/owned_utils.runa" as OwnedUtils
Import "compiler/internal/memory_safety.runa" as MemorySafety
Import "compiler/internal/collections.runa" as Collections

Note: ============================================================================
Note: Error Management Structures
Note: ============================================================================

Type called "CompilerError":
    error_code as Integer     Note: Error code identifier
    error_message as Integer  Note: Pointer to error message
    error_type as Integer     Note: Type of error (SYNTAX, SEMANTIC, RUNTIME, etc.)
    severity as Integer        Note: Error severity (ERROR, WARNING, INFO)
    source_file as Integer    Note: Pointer to source file name
    line_number as Integer    Note: Line number where error occurred
    column_number as Integer  Note: Column number where error occurred
    context as Integer        Note: Pointer to error context information
    suggestions as Integer     Note: Pointer to error suggestions
    is_fatal as Integer       Note: Boolean: 1 if fatal, 0 if not fatal
    next as Integer           Note: Pointer to next error in chain

Type called "ErrorContext":
    function_name as Integer  Note: Pointer to function name
    scope_level as Integer    Note: Scope level where error occurred
    variable_name as Integer  Note: Pointer to variable name
    type_info as Integer      Note: Pointer to type information
    value_info as Integer     Note: Pointer to value information
    is_valid as Integer       Note: Boolean: 1 if valid, 0 if invalid

Type called "ErrorStats":
    total_errors as Integer   Note: Total number of errors
    fatal_errors as Integer  Note: Number of fatal errors
    warnings as Integer       Note: Number of warnings
    info_messages as Integer  Note: Number of info messages
    error_time as Integer     Note: Time spent on error processing
    error_memory as Integer   Note: Memory used for error processing

Note: ============================================================================
Note: Error Constants
Note: ============================================================================

Constant ERROR_TYPE_SYNTAX as Integer is 0
Constant ERROR_TYPE_SEMANTIC as Integer is 1
Constant ERROR_TYPE_RUNTIME as Integer is 2
Constant ERROR_TYPE_MEMORY as Integer is 3
Constant ERROR_TYPE_TYPE as Integer is 4
Constant ERROR_TYPE_SCOPE as Integer is 5

Constant ERROR_SEVERITY_INFO as Integer is 0
Constant ERROR_SEVERITY_WARNING as Integer is 1
Constant ERROR_SEVERITY_ERROR as Integer is 2
Constant ERROR_SEVERITY_FATAL as Integer is 3

Constant ERROR_SUCCESS as Integer is 0
Constant ERROR_FAILED as Integer is -1
Constant ERROR_INVALID_CODE as Integer is -2
Constant ERROR_MEMORY_ERROR as Integer is -3

Constant ERROR_CODE_SYNTAX_ERROR as Integer is 1000
Constant ERROR_CODE_SEMANTIC_ERROR as Integer is 2000
Constant ERROR_CODE_RUNTIME_ERROR as Integer is 3000
Constant ERROR_CODE_MEMORY_ERROR as Integer is 4000
Constant ERROR_CODE_TYPE_ERROR as Integer is 5000
Constant ERROR_CODE_SCOPE_ERROR as Integer is 6000

Note: ============================================================================
Note: Error Creation and Management
Note: ============================================================================

Note: Global error statistics structure
Let GLOBAL_ERROR_STATS be 0

Private Process called "error_init_stats" returns Integer:
    Note: Initialize global error statistics if needed
    If GLOBAL_ERROR_STATS is not equal to 0:
        Return 1
    End If

    Note: Allocate ErrorStats structure (48 bytes)
    Set GLOBAL_ERROR_STATS to proc allocate from OwnedUtils with 48
    If GLOBAL_ERROR_STATS is equal to 0:
        Return 0
    End If

    Note: Initialize all stats to 0
    Let dummy1 be proc memory_set_integer from MemorySafety with GLOBAL_ERROR_STATS, 0, 0
    Let dummy2 be proc memory_set_integer from MemorySafety with GLOBAL_ERROR_STATS, 8, 0
    Let dummy3 be proc memory_set_integer from MemorySafety with GLOBAL_ERROR_STATS, 16, 0
    Let dummy4 be proc memory_set_integer from MemorySafety with GLOBAL_ERROR_STATS, 24, 0
    Let dummy5 be proc memory_set_integer from MemorySafety with GLOBAL_ERROR_STATS, 32, 0
    Let dummy6 be proc memory_set_integer from MemorySafety with GLOBAL_ERROR_STATS, 40, 0

    Return 1
End Process

Process called "error_create" takes error_code as Integer, message as Integer, error_type as Integer, severity as Integer returns Integer:
    Note: Create new compiler error with given parameters
    Note: Returns pointer to CompilerError structure (88 bytes)
    Note: CompilerError structure layout:
    Note:   offset 0:  error_code (8 bytes)
    Note:   offset 8:  error_message pointer (8 bytes)
    Note:   offset 16: error_type (8 bytes)
    Note:   offset 24: severity (8 bytes)
    Note:   offset 32: source_file pointer (8 bytes)
    Note:   offset 40: line_number (8 bytes)
    Note:   offset 48: column_number (8 bytes)
    Note:   offset 56: context pointer (8 bytes)
    Note:   offset 64: suggestions pointer (8 bytes)
    Note:   offset 72: is_fatal (8 bytes)
    Note:   offset 80: next pointer (8 bytes)

    Note: Allocate CompilerError structure
    Let error be proc allocate from OwnedUtils with 88
    If error is equal to 0:
        Return 0
    End If

    Note: Initialize error fields
    Let dummy1 be proc memory_set_integer from MemorySafety with error, 0, error_code
    Let dummy2 be proc memory_set_integer from MemorySafety with error, 8, message
    Let dummy3 be proc memory_set_integer from MemorySafety with error, 16, error_type
    Let dummy4 be proc memory_set_integer from MemorySafety with error, 24, severity

    Note: Initialize location fields to 0
    Let dummy5 be proc memory_set_integer from MemorySafety with error, 32, 0
    Let dummy6 be proc memory_set_integer from MemorySafety with error, 40, 0
    Let dummy7 be proc memory_set_integer from MemorySafety with error, 48, 0

    Note: Initialize optional fields to 0
    Let dummy8 be proc memory_set_integer from MemorySafety with error, 56, 0
    Let dummy9 be proc memory_set_integer from MemorySafety with error, 64, 0

    Note: Set is_fatal based on severity
    Let is_fatal be 0
    If severity is equal to ERROR_SEVERITY_FATAL:
        Set is_fatal to 1
    End If
    Let dummy10 be proc memory_set_integer from MemorySafety with error, 72, is_fatal

    Note: Initialize next pointer to 0
    Let dummy11 be proc memory_set_integer from MemorySafety with error, 80, 0

    Note: Update global statistics
    Let init_result be proc error_init_stats
    If init_result is equal to 1:
        If GLOBAL_ERROR_STATS is not equal to 0:
            Note: Increment total_errors
            Let total be proc memory_get_integer from MemorySafety with GLOBAL_ERROR_STATS, 0
            Let dummy12 be proc memory_set_integer from MemorySafety with GLOBAL_ERROR_STATS, 0, total plus 1

            Note: Increment category counters
            If severity is equal to ERROR_SEVERITY_FATAL:
                Let fatal_count be proc memory_get_integer from MemorySafety with GLOBAL_ERROR_STATS, 8
                Let dummy13 be proc memory_set_integer from MemorySafety with GLOBAL_ERROR_STATS, 8, fatal_count plus 1
            End If
            Otherwise If severity is equal to ERROR_SEVERITY_WARNING:
                Let warning_count be proc memory_get_integer from MemorySafety with GLOBAL_ERROR_STATS, 16
                Let dummy14 be proc memory_set_integer from MemorySafety with GLOBAL_ERROR_STATS, 16, warning_count plus 1
            End If
            Otherwise If severity is equal to ERROR_SEVERITY_INFO:
                Let info_count be proc memory_get_integer from MemorySafety with GLOBAL_ERROR_STATS, 24
                Let dummy15 be proc memory_set_integer from MemorySafety with GLOBAL_ERROR_STATS, 24, info_count plus 1
            End If
        End If
    End If

    Return error
End Process

Process called "error_destroy" takes error as Integer returns Nothing:
    Note: Destroy compiler error and free all associated memory
    Note: Validates memory safety before destruction

    If error is equal to 0:
        Return
    End If

    Note: Validate pointer safety
    Let is_safe be proc validate_pointer from MemorySafety with error
    If is_safe is equal to 0:
        Return
    End If

    Note: Free error message if allocated
    Let message_ptr be proc memory_get_integer from MemorySafety with error, 8
    If message_ptr is not equal to 0:
        Let dummy1 be proc deallocate from OwnedUtils with message_ptr
    End If

    Note: Free source file if allocated
    Let source_file_ptr be proc memory_get_integer from MemorySafety with error, 32
    If source_file_ptr is not equal to 0:
        Let dummy2 be proc deallocate from OwnedUtils with source_file_ptr
    End If

    Note: Free context if allocated
    Let context_ptr be proc memory_get_integer from MemorySafety with error, 56
    If context_ptr is not equal to 0:
        Let dummy3 be proc error_context_destroy with context_ptr
    End If

    Note: Free suggestions if allocated
    Let suggestions_ptr be proc memory_get_integer from MemorySafety with error, 64
    If suggestions_ptr is not equal to 0:
        Let dummy4 be proc deallocate from OwnedUtils with suggestions_ptr
    End If

    Note: Free error structure itself
    Let dummy5 be proc deallocate from OwnedUtils with error
End Process

Process called "error_set_location" takes error as Integer, source_file as Integer, line as Integer, column as Integer returns Integer:
    Note: Set error location information
    Note: Returns 1 if successful, 0 if failed

    If error is equal to 0:
        Return 0
    End If

    Note: Set source file pointer
    Let dummy1 be proc memory_set_integer from MemorySafety with error, 32, source_file

    Note: Set line number
    Let dummy2 be proc memory_set_integer from MemorySafety with error, 40, line

    Note: Set column number
    Let dummy3 be proc memory_set_integer from MemorySafety with error, 48, column

    Return 1
End Process

Process called "error_set_context" takes error as Integer, context as Integer returns Integer:
    Note: Set error context information
    Note: Returns 1 if successful, 0 if failed

    If error is equal to 0:
        Return 0
    End If

    Note: Set context pointer
    Let dummy be proc memory_set_integer from MemorySafety with error, 56, context

    Return 1
End Process

Process called "error_set_suggestions" takes error as Integer, suggestions as Integer returns Integer:
    Note: Set error suggestions
    Note: Returns 1 if successful, 0 if failed

    If error is equal to 0:
        Return 0
    End If

    Note: Set suggestions pointer
    Let dummy be proc memory_set_integer from MemorySafety with error, 64, suggestions

    Return 1
End Process

Process called "error_set_fatal" takes error as Integer, is_fatal as Integer returns Integer:
    Note: Set error fatal status
    Note: Returns 1 if successful, 0 if failed

    If error is equal to 0:
        Return 0
    End If

    Note: Set is_fatal field
    Let dummy be proc memory_set_integer from MemorySafety with error, 72, is_fatal

    Note: Update severity if marking as fatal
    If is_fatal is equal to 1:
        Let dummy2 be proc memory_set_integer from MemorySafety with error, 24, ERROR_SEVERITY_FATAL
    End If

    Return 1
End Process

Note: ============================================================================
Note: Error Information Operations
Note: ============================================================================

Process called "error_get_code" takes error as Integer returns Integer:
    Note: Get error code from CompilerError structure
    Note: Returns error code value

    If error is equal to 0:
        Return ERROR_INVALID_CODE
    End If

    Let code be proc memory_get_integer from MemorySafety with error, 0
    Return code
End Process

Process called "error_get_message" takes error as Integer returns Integer:
    Note: Get error message pointer from CompilerError structure
    Note: Returns pointer to error message string

    If error is equal to 0:
        Return 0
    End If

    Let message be proc memory_get_integer from MemorySafety with error, 8
    Return message
End Process

Process called "error_get_type" takes error as Integer returns Integer:
    Note: Get error type from CompilerError structure
    Note: Returns error type constant

    If error is equal to 0:
        Return ERROR_INVALID_CODE
    End If

    Let error_type be proc memory_get_integer from MemorySafety with error, 16
    Return error_type
End Process

Process called "error_get_severity" takes error as Integer returns Integer:
    Note: Get error severity from CompilerError structure
    Note: Returns severity constant

    If error is equal to 0:
        Return ERROR_SEVERITY_INFO
    End If

    Let severity be proc memory_get_integer from MemorySafety with error, 24
    Return severity
End Process

Process called "error_get_location" takes error as Integer returns Integer:
    Note: Get error location information
    Note: Returns pointer to allocated structure containing location data (24 bytes)
    Note: Structure: source_file (8), line_number (8), column_number (8)

    If error is equal to 0:
        Return 0
    End If

    Note: Allocate location structure
    Let location be proc allocate from OwnedUtils with 24
    If location is equal to 0:
        Return 0
    End If

    Note: Copy location data
    Let source_file be proc memory_get_integer from MemorySafety with error, 32
    Let line_number be proc memory_get_integer from MemorySafety with error, 40
    Let column_number be proc memory_get_integer from MemorySafety with error, 48

    Let dummy1 be proc memory_set_integer from MemorySafety with location, 0, source_file
    Let dummy2 be proc memory_set_integer from MemorySafety with location, 8, line_number
    Let dummy3 be proc memory_set_integer from MemorySafety with location, 16, column_number

    Return location
End Process

Process called "error_get_context" takes error as Integer returns Integer:
    Note: Get error context pointer from CompilerError structure
    Note: Returns pointer to ErrorContext structure

    If error is equal to 0:
        Return 0
    End If

    Let context be proc memory_get_integer from MemorySafety with error, 56
    Return context
End Process

Process called "error_get_suggestions" takes error as Integer returns Integer:
    Note: Get error suggestions pointer from CompilerError structure
    Note: Returns pointer to suggestions string

    If error is equal to 0:
        Return 0
    End If

    Let suggestions be proc memory_get_integer from MemorySafety with error, 64
    Return suggestions
End Process

Process called "error_is_fatal" takes error as Integer returns Integer:
    Note: Check if error is marked as fatal
    Note: Returns 1 if fatal, 0 if not fatal

    If error is equal to 0:
        Return 0
    End If

    Let is_fatal be proc memory_get_integer from MemorySafety with error, 72
    Return is_fatal
End Process

Note: ============================================================================
Note: Error Reporting Operations
Note: ============================================================================

Import "compiler/core/memory_core.runa" as MemoryCore
Import "compiler/core/string_core.runa" as StringCore

Process called "error_report" takes error as Integer returns Integer:
    Note: Report compiler error to stderr (file descriptor 2)
    Note: Returns 1 if successful, 0 if failed
    Note: Formats and outputs error information

    If error is equal to 0:
        Return 0
    End If

    Note: Get error information
    Let error_code be proc memory_get_integer from MemorySafety with error, 0
    Let message_ptr be proc memory_get_integer from MemorySafety with error, 8
    Let error_type be proc memory_get_integer from MemorySafety with error, 16
    Let severity be proc memory_get_integer from MemorySafety with error, 24
    Let source_file_ptr be proc memory_get_integer from MemorySafety with error, 32
    Let line_number be proc memory_get_integer from MemorySafety with error, 40
    Let column_number be proc memory_get_integer from MemorySafety with error, 48

    Note: Build error message prefix based on severity using string literals
    Let prefix_ptr be 0
    If severity is equal to ERROR_SEVERITY_FATAL:
        Set prefix_ptr to "FATAL: "
    End If
    Otherwise If severity is equal to ERROR_SEVERITY_ERROR:
        Set prefix_ptr to "ERROR: "
    End If
    Otherwise If severity is equal to ERROR_SEVERITY_WARNING:
        Set prefix_ptr to "WARNING: "
    End If
    Otherwise:
        Set prefix_ptr to "INFO: "
    End If

    Note: Write prefix to stderr (file descriptor 2)
    If prefix_ptr is not equal to 0:
        Let prefix_len be proc string_length from StringCore with prefix_ptr
        Let syscall_write be 1
        Let fd_stderr be 2
        Let write_result be proc syscall_3 from Syscall with syscall_write, fd_stderr, prefix_ptr, prefix_len
        Note: String literals are not deallocated (they live in data section)
    End If

    Note: Write error message to stderr
    If message_ptr is not equal to 0:
        Let message_len be proc string_length from StringCore with message_ptr
        Let write_result2 be proc syscall_3 from Syscall with syscall_write, fd_stderr, message_ptr, message_len
    End If

    Note: Write newline to stderr using string literal
    Let newline_ptr be "\n"
    Let write_result3 be proc syscall_3 from Syscall with syscall_write, fd_stderr, newline_ptr, 1
    Note: String literals are not deallocated

    Return 1
End Process

Process called "error_report_syntax" takes message as Integer, source_file as Integer, line as Integer, column as Integer returns Integer:
    Note: Report syntax error by creating and reporting CompilerError
    Note: Returns 1 if successful, 0 if failed

    Let error be proc error_create with ERROR_CODE_SYNTAX_ERROR, message, ERROR_TYPE_SYNTAX, ERROR_SEVERITY_ERROR
    If error is equal to 0:
        Return 0
    End If

    Let set_result be proc error_set_location with error, source_file, line, column
    Let report_result be proc error_report with error
    Let dummy_destroy be proc error_destroy with error

    Return report_result
End Process

Process called "error_report_semantic" takes message as Integer, source_file as Integer, line as Integer, column as Integer returns Integer:
    Note: Report semantic error by creating and reporting CompilerError
    Note: Returns 1 if successful, 0 if failed

    Let error be proc error_create with ERROR_CODE_SEMANTIC_ERROR, message, ERROR_TYPE_SEMANTIC, ERROR_SEVERITY_ERROR
    If error is equal to 0:
        Return 0
    End If

    Let set_result be proc error_set_location with error, source_file, line, column
    Let report_result be proc error_report with error
    Let dummy_destroy be proc error_destroy with error

    Return report_result
End Process

Process called "error_report_runtime" takes message as Integer, source_file as Integer, line as Integer, column as Integer returns Integer:
    Note: Report runtime error by creating and reporting CompilerError
    Note: Returns 1 if successful, 0 if failed

    Let error be proc error_create with ERROR_CODE_RUNTIME_ERROR, message, ERROR_TYPE_RUNTIME, ERROR_SEVERITY_ERROR
    If error is equal to 0:
        Return 0
    End If

    Let set_result be proc error_set_location with error, source_file, line, column
    Let report_result be proc error_report with error
    Let dummy_destroy be proc error_destroy with error

    Return report_result
End Process

Process called "error_report_memory" takes message as Integer, source_file as Integer, line as Integer, column as Integer returns Integer:
    Note: Report memory error by creating and reporting CompilerError
    Note: Returns 1 if successful, 0 if failed

    Let error be proc error_create with ERROR_CODE_MEMORY_ERROR, message, ERROR_TYPE_MEMORY, ERROR_SEVERITY_FATAL
    If error is equal to 0:
        Return 0
    End If

    Let set_result be proc error_set_location with error, source_file, line, column
    Let report_result be proc error_report with error
    Let dummy_destroy be proc error_destroy with error

    Return report_result
End Process

Process called "error_report_type" takes message as Integer, source_file as Integer, line as Integer, column as Integer returns Integer:
    Note: Report type error by creating and reporting CompilerError
    Note: Returns 1 if successful, 0 if failed

    Let error be proc error_create with ERROR_CODE_TYPE_ERROR, message, ERROR_TYPE_TYPE, ERROR_SEVERITY_ERROR
    If error is equal to 0:
        Return 0
    End If

    Let set_result be proc error_set_location with error, source_file, line, column
    Let report_result be proc error_report with error
    Let dummy_destroy be proc error_destroy with error

    Return report_result
End Process

Process called "error_report_scope" takes message as Integer, source_file as Integer, line as Integer, column as Integer returns Integer:
    Note: Report scope error by creating and reporting CompilerError
    Note: Returns 1 if successful, 0 if failed

    Let error be proc error_create with ERROR_CODE_SCOPE_ERROR, message, ERROR_TYPE_SCOPE, ERROR_SEVERITY_ERROR
    If error is equal to 0:
        Return 0
    End If

    Let set_result be proc error_set_location with error, source_file, line, column
    Let report_result be proc error_report with error
    Let dummy_destroy be proc error_destroy with error

    Return report_result
End Process

Note: ============================================================================
Note: Error Context Operations
Note: ============================================================================

Process called "error_context_create" takes function_name as Integer, scope_level as Integer returns Integer:
    Note: Create error context with given function name and scope level
    Note: Returns pointer to ErrorContext structure (48 bytes)
    Note: ErrorContext structure layout:
    Note:   offset 0:  function_name pointer (8 bytes)
    Note:   offset 8:  scope_level (8 bytes)
    Note:   offset 16: variable_name pointer (8 bytes)
    Note:   offset 24: type_info pointer (8 bytes)
    Note:   offset 32: value_info pointer (8 bytes)
    Note:   offset 40: is_valid (8 bytes)

    Let context be proc allocate from OwnedUtils with 48
    If context is equal to 0:
        Return 0
    End If

    Note: Initialize context fields
    Let dummy1 be proc memory_set_integer from MemorySafety with context, 0, function_name
    Let dummy2 be proc memory_set_integer from MemorySafety with context, 8, scope_level
    Let dummy3 be proc memory_set_integer from MemorySafety with context, 16, 0
    Let dummy4 be proc memory_set_integer from MemorySafety with context, 24, 0
    Let dummy5 be proc memory_set_integer from MemorySafety with context, 32, 0
    Let dummy6 be proc memory_set_integer from MemorySafety with context, 40, 1

    Return context
End Process

Process called "error_context_destroy" takes context as Integer returns Nothing:
    Note: Destroy error context and free all associated memory
    Note: Validates memory safety before destruction

    If context is equal to 0:
        Return
    End If

    Note: Validate pointer safety
    Let is_safe be proc validate_pointer from MemorySafety with context
    If is_safe is equal to 0:
        Return
    End If

    Note: Free function name if allocated
    Let function_name_ptr be proc memory_get_integer from MemorySafety with context, 0
    If function_name_ptr is not equal to 0:
        Let dummy1 be proc deallocate from OwnedUtils with function_name_ptr
    End If

    Note: Free variable name if allocated
    Let variable_name_ptr be proc memory_get_integer from MemorySafety with context, 16
    If variable_name_ptr is not equal to 0:
        Let dummy2 be proc deallocate from OwnedUtils with variable_name_ptr
    End If

    Note: Free type info if allocated
    Let type_info_ptr be proc memory_get_integer from MemorySafety with context, 24
    If type_info_ptr is not equal to 0:
        Let dummy3 be proc deallocate from OwnedUtils with type_info_ptr
    End If

    Note: Free value info if allocated
    Let value_info_ptr be proc memory_get_integer from MemorySafety with context, 32
    If value_info_ptr is not equal to 0:
        Let dummy4 be proc deallocate from OwnedUtils with value_info_ptr
    End If

    Note: Free context structure itself
    Let dummy5 be proc deallocate from OwnedUtils with context
End Process

Process called "error_context_set_variable" takes context as Integer, variable_name as Integer returns Integer:
    Note: Set variable name in error context
    Note: Returns 1 if successful, 0 if failed

    If context is equal to 0:
        Return 0
    End If

    Let dummy be proc memory_set_integer from MemorySafety with context, 16, variable_name
    Return 1
End Process

Process called "error_context_set_type" takes context as Integer, type_info as Integer returns Integer:
    Note: Set type information in error context
    Note: Returns 1 if successful, 0 if failed

    If context is equal to 0:
        Return 0
    End If

    Let dummy be proc memory_set_integer from MemorySafety with context, 24, type_info
    Return 1
End Process

Process called "error_context_set_value" takes context as Integer, value_info as Integer returns Integer:
    Note: Set value information in error context
    Note: Returns 1 if successful, 0 if failed

    If context is equal to 0:
        Return 0
    End If

    Let dummy be proc memory_set_integer from MemorySafety with context, 32, value_info
    Return 1
End Process

Process called "error_context_validate" takes context as Integer returns Integer:
    Note: Validate error context integrity
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks that required fields are set

    If context is equal to 0:
        Return 0
    End If

    Note: Check function name is set
    Let function_name be proc memory_get_integer from MemorySafety with context, 0
    If function_name is equal to 0:
        Let dummy be proc memory_set_integer from MemorySafety with context, 40, 0
        Return 0
    End If

    Note: Context is valid
    Let dummy2 be proc memory_set_integer from MemorySafety with context, 40, 1
    Return 1
End Process

Note: ============================================================================
Note: Error Statistics Operations
Note: ============================================================================

Process called "error_get_stats" takes returns Integer:
    Note: Get error statistics pointer
    Note: Returns pointer to global ErrorStats structure
    Note: Initializes stats if not already initialized

    Let init_result be proc error_init_stats
    If init_result is equal to 0:
        Return 0
    End If

    Return GLOBAL_ERROR_STATS
End Process

Process called "error_reset_stats" takes returns Nothing:
    Note: Reset all error statistics counters to zero

    If GLOBAL_ERROR_STATS is equal to 0:
        Return
    End If

    Note: Reset all counters to 0
    Let dummy1 be proc memory_set_integer from MemorySafety with GLOBAL_ERROR_STATS, 0, 0
    Let dummy2 be proc memory_set_integer from MemorySafety with GLOBAL_ERROR_STATS, 8, 0
    Let dummy3 be proc memory_set_integer from MemorySafety with GLOBAL_ERROR_STATS, 16, 0
    Let dummy4 be proc memory_set_integer from MemorySafety with GLOBAL_ERROR_STATS, 24, 0
    Let dummy5 be proc memory_set_integer from MemorySafety with GLOBAL_ERROR_STATS, 32, 0
    Let dummy6 be proc memory_set_integer from MemorySafety with GLOBAL_ERROR_STATS, 40, 0
End Process

Process called "error_export_stats" takes filename as Integer returns Integer:
    Note: Export error statistics to file using syscalls
    Note: Returns 1 if successful, 0 if failed

    If GLOBAL_ERROR_STATS is equal to 0:
        Return 0
    End If

    If filename is equal to 0:
        Return 0
    End If

    Note: Open file for writing (syscall 2: open, flags: O_WRONLY|O_CREAT|O_TRUNC = 577, mode: 0644 = 420)
    Let syscall_open be 2
    Let flags be 577
    Let mode be 420
    Let fd be proc syscall_3 from Syscall with syscall_open, filename, flags, mode

    If fd is less than 0:
        Return 0
    End If

    Note: Get statistics values
    Let total_errors be proc memory_get_integer from MemorySafety with GLOBAL_ERROR_STATS, 0
    Let fatal_errors be proc memory_get_integer from MemorySafety with GLOBAL_ERROR_STATS, 8
    Let warnings be proc memory_get_integer from MemorySafety with GLOBAL_ERROR_STATS, 16
    Let info_messages be proc memory_get_integer from MemorySafety with GLOBAL_ERROR_STATS, 24
    Let error_time be proc memory_get_integer from MemorySafety with GLOBAL_ERROR_STATS, 32
    Let error_memory be proc memory_get_integer from MemorySafety with GLOBAL_ERROR_STATS, 40

    Note: Write statistics to file (48 bytes - raw binary)
    Let syscall_write be 1
    Let write_result be proc syscall_3 from Syscall with syscall_write, fd, GLOBAL_ERROR_STATS, 48

    Note: Close file (syscall 3: close)
    Let syscall_close be 3
    Let close_result be proc syscall_1 from Syscall with syscall_close, fd

    If write_result is equal to 48:
        Return 1
    End If

    Return 0
End Process

Process called "error_import_stats" takes filename as Integer returns Integer:
    Note: Import error statistics from file using syscalls
    Note: Returns 1 if successful, 0 if failed

    If filename is equal to 0:
        Return 0
    End If

    Note: Initialize stats if needed
    Let init_result be proc error_init_stats
    If init_result is equal to 0:
        Return 0
    End If

    Note: Open file for reading (syscall 2: open, flags: O_RDONLY = 0)
    Let syscall_open be 2
    Let flags be 0
    Let fd be proc syscall_2 from Syscall with syscall_open, filename, flags

    If fd is less than 0:
        Return 0
    End If

    Note: Read statistics from file (48 bytes)
    Let syscall_read be 0
    Let read_result be proc syscall_3 from Syscall with syscall_read, fd, GLOBAL_ERROR_STATS, 48

    Note: Close file (syscall 3: close)
    Let syscall_close be 3
    Let close_result be proc syscall_1 from Syscall with syscall_close, fd

    If read_result is equal to 48:
        Return 1
    End If

    Return 0
End Process

Process called "error_print_stats" takes returns Nothing:
    Note: Print error statistics to stdout using syscalls

    If GLOBAL_ERROR_STATS is equal to 0:
        Return
    End If

    Note: Get statistics values
    Let total_errors be proc memory_get_integer from MemorySafety with GLOBAL_ERROR_STATS, 0
    Let fatal_errors be proc memory_get_integer from MemorySafety with GLOBAL_ERROR_STATS, 8
    Let warnings be proc memory_get_integer from MemorySafety with GLOBAL_ERROR_STATS, 16
    Let info_messages be proc memory_get_integer from MemorySafety with GLOBAL_ERROR_STATS, 24

    Note: Write header using string literal
    Let header_ptr be "Error Statistics:\n--\n"
    Let syscall_write be 1
    Let fd_stdout be 1
    Let header_len be proc string_length from StringCore with header_ptr
    Let write1 be proc syscall_3 from Syscall with syscall_write, fd_stdout, header_ptr, header_len
    Note: String literals are not deallocated

    Note: Write total errors count using format_string
    Note: Create temporary arena for formatting
    Let temp_arena be proc arena_create from ArenaUtils with 128, 8
    If temp_arena is not equal to 0:
        Note: Format total errors count as integer string
        Let total_num_str be proc format_integer from FormatUtils with total_errors, 0, temp_arena

        Note: Create args array for format_string (1 argument)
        Let args_size be 8
        Let args_ptr be proc arena_allocate from ArenaUtils with temp_arena, args_size, 8
        Let dummy_arg be proc memory_set_integer from MemoryCore with args_ptr, 0, total_num_str

        Note: Format the complete message
        Let format_str be "Total: {0}\n"
        Let total_msg be proc format_string from FormatUtils with format_str, args_ptr, temp_arena

        If total_msg is not equal to 0:
            Let total_msg_len be proc string_length from StringCore with total_msg
            Let write2 be proc syscall_3 from Syscall with syscall_write, fd_stdout, total_msg, total_msg_len
        End If

        Note: Destroy arena - frees all allocations
        Let dummy_arena_destroy be proc arena_destroy from ArenaUtils with temp_arena
    End If
End Process

Note: ============================================================================
Note: Error Optimization Operations
Note: ============================================================================

Process called "error_optimize" takes returns Integer:
    Note: Optimize error handling for performance
    Note: Returns 1 if successful, 0 if failed
    Note: Pre-allocates error structures and initializes caches

    Note: Initialize global statistics if not already done
    Let init_result be proc error_init_stats
    If init_result is equal to 0:
        Return 0
    End If

    Note: Optimization complete (stats system initialized)
    Return 1
End Process

Process called "error_benchmark" takes iterations as Integer returns Integer:
    Note: Benchmark error handling performance by creating/destroying errors
    Note: Returns elapsed time in nanoseconds
    Note: Measures error creation and destruction overhead

    If iterations is less than or equal to 0:
        Return 0
    End If

    Note: Allocate timespec structures for clock_gettime (16 bytes each)
    Let start_timespec be proc allocate from OwnedUtils with 16
    Let end_timespec be proc allocate from OwnedUtils with 16

    If start_timespec is equal to 0:
        Return 0
    End If

    If end_timespec is equal to 0:
        Let dummy_free1 be proc deallocate from OwnedUtils with start_timespec
        Return 0
    End If

    Note: Get start time using clock_gettime (syscall 228, CLOCK_MONOTONIC = 1)
    Let syscall_clock_gettime be 228
    Let CLOCK_MONOTONIC be 1
    Let start_result be proc syscall_2 from Syscall with syscall_clock_gettime, CLOCK_MONOTONIC, start_timespec

    Note: Create test error message
    Let test_msg be proc allocate from OwnedUtils with 12
    Let dummy1 be proc memory_set_byte from MemoryCore with test_msg, 0, 84   Note: 'T'
    Let dummy2 be proc memory_set_byte from MemoryCore with test_msg, 1, 101  Note: 'e'
    Let dummy3 be proc memory_set_byte from MemoryCore with test_msg, 2, 115  Note: 's'
    Let dummy4 be proc memory_set_byte from MemoryCore with test_msg, 3, 116  Note: 't'
    Let dummy5 be proc memory_set_byte from MemoryCore with test_msg, 4, 32   Note: space
    Let dummy6 be proc memory_set_byte from MemoryCore with test_msg, 5, 101  Note: 'e'
    Let dummy7 be proc memory_set_byte from MemoryCore with test_msg, 6, 114  Note: 'r'
    Let dummy8 be proc memory_set_byte from MemoryCore with test_msg, 7, 114  Note: 'r'
    Let dummy9 be proc memory_set_byte from MemoryCore with test_msg, 8, 111  Note: 'o'
    Let dummy10 be proc memory_set_byte from MemoryCore with test_msg, 9, 114  Note: 'r'
    Let dummy11 be proc memory_set_byte from MemoryCore with test_msg, 10, 0  Note: null

    Note: Run benchmark iterations
    Let i be 0
    While i is less than iterations:
        Let error be proc error_create with 1000, test_msg, ERROR_TYPE_SYNTAX, ERROR_SEVERITY_ERROR
        If error is not equal to 0:
            Let dummy_destroy be proc error_destroy with error
        End If
        Set i to i plus 1
    End While

    Note: Get end time
    Let end_result be proc syscall_2 from Syscall with syscall_clock_gettime, CLOCK_MONOTONIC, end_timespec

    Note: Calculate elapsed time (nanoseconds)
    Let start_sec be proc memory_get_integer from MemorySafety with start_timespec, 0
    Let start_nsec be proc memory_get_integer from MemorySafety with start_timespec, 8
    Let end_sec be proc memory_get_integer from MemorySafety with end_timespec, 0
    Let end_nsec be proc memory_get_integer from MemorySafety with end_timespec, 8

    Let elapsed_sec be end_sec minus start_sec
    Let elapsed_nsec be end_nsec minus start_nsec
    Let total_nsec be elapsed_sec times 1000000000 plus elapsed_nsec

    Note: Free temporary allocations
    Let dummy_free2 be proc deallocate from OwnedUtils with start_timespec
    Let dummy_free3 be proc deallocate from OwnedUtils with end_timespec
    Let dummy_free4 be proc deallocate from OwnedUtils with test_msg

    Note: Update error_time in statistics
    If GLOBAL_ERROR_STATS is not equal to 0:
        Let dummy_update be proc memory_set_integer from MemorySafety with GLOBAL_ERROR_STATS, 32, total_nsec
    End If

    Return total_nsec
End Process

Process called "error_profile" takes returns Integer:
    Note: Profile error handling performance
    Note: Returns pointer to profile data structure (24 bytes)
    Note: Structure: creation_time (8), destruction_time (8), total_memory (8)

    Note: Allocate profile data structure
    Let profile be proc allocate from OwnedUtils with 24
    If profile is equal to 0:
        Return 0
    End If

    Note: Benchmark error creation (100 iterations)
    Let creation_time be proc error_benchmark with 100

    Note: Get current memory usage from stats
    Let memory_usage be 0
    If GLOBAL_ERROR_STATS is not equal to 0:
        Set memory_usage to proc memory_get_integer from MemorySafety with GLOBAL_ERROR_STATS, 40
    End If

    Note: Store profile data
    Let dummy1 be proc memory_set_integer from MemorySafety with profile, 0, creation_time
    Let dummy2 be proc memory_set_integer from MemorySafety with profile, 8, creation_time
    Let dummy3 be proc memory_set_integer from MemorySafety with profile, 16, memory_usage

    Return profile
End Process

Process called "error_validate" takes returns Integer:
    Note: Validate error handling system integrity
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks global statistics structure

    Note: Check if global stats exists
    If GLOBAL_ERROR_STATS is equal to 0:
        Note: Try to initialize
        Let init_result be proc error_init_stats
        If init_result is equal to 0:
            Return 0
        End If
    End If

    Note: Validate statistics structure integrity
    Let total_errors be proc memory_get_integer from MemorySafety with GLOBAL_ERROR_STATS, 0
    Let fatal_errors be proc memory_get_integer from MemorySafety with GLOBAL_ERROR_STATS, 8
    Let warnings be proc memory_get_integer from MemorySafety with GLOBAL_ERROR_STATS, 16
    Let info_messages be proc memory_get_integer from MemorySafety with GLOBAL_ERROR_STATS, 24

    Note: Check for negative values (corruption)
    If total_errors is less than 0:
        Return 0
    End If

    If fatal_errors is less than 0:
        Return 0
    End If

    If warnings is less than 0:
        Return 0
    End If

    If info_messages is less than 0:
        Return 0
    End If

    Note: Check consistency (total should be sum of categories)
    Let sum be fatal_errors plus warnings plus info_messages
    If sum is greater than total_errors:
        Return 0
    End If

    Return 1
End Process

Process called "error_verify" takes returns Integer:
    Note: Verify error handling system consistency
    Note: Returns 1 if verified, 0 if corrupted
    Note: Performs comprehensive validation

    Note: First validate basic integrity
    Let validate_result be proc error_validate
    If validate_result is equal to 0:
        Return 0
    End If

    Note: Additional verification - check memory safety
    If GLOBAL_ERROR_STATS is not equal to 0:
        Let is_safe be proc validate_pointer from MemorySafety with GLOBAL_ERROR_STATS
        If is_safe is equal to 0:
            Return 0
        End If
    End If

    Note: System is verified
    Return 1
End Process