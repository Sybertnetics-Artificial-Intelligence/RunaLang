Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file implements the symbol table for symbol management and name resolution.

This file performs the following tasks:
- Manage symbol definitions and symbol lookups with proper ownership patterns
- Handle symbol scope and symbol visibility with memory-efficient operations
- Process symbol resolution and name binding with arena-based temporary lookups
- Manage symbol table operations and symbol lifecycle with deterministic cleanup

This file is essential because of the following reasons:
- Symbol tables enable accurate name resolution and symbol lookup
- Proper symbol management prevents naming conflicts and resolution errors
- Symbol tables support all language features requiring name resolution
- Memory-efficient symbol management enables scalable semantic analysis

This file consists of the following functions/features/operation types:
- Symbol definition and symbol lookup management with ownership tracking
- Symbol scope and visibility handling with arena-based temporary operations
- Name resolution and symbol binding with memory-safe operations
- Symbol table operations and symbol lifecycle management with deterministic cleanup
:End Note

Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/primitives/collections/hashtable.runa" as HashTable
Import "compiler/frontend/primitives/collections/stack.runa" as Stack
Import "compiler/frontend/primitives/collections/list.runa" as List
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Constant SYMBOL_TYPE_VARIABLE as Integer is 1
Constant SYMBOL_TYPE_FUNCTION as Integer is 2
Constant SYMBOL_TYPE_TYPE as Integer is 3
Constant SYMBOL_TYPE_MODULE as Integer is 4
Constant SYMBOL_TYPE_TRAIT as Integer is 5
Constant SYMBOL_TYPE_GENERIC as Integer is 6
Constant SYMBOL_TYPE_CONSTANT as Integer is 7
Constant SYMBOL_TYPE_PARAMETER as Integer is 8

Constant SYMBOL_SCOPE_GLOBAL as Integer is 1
Constant SYMBOL_SCOPE_LOCAL as Integer is 2
Constant SYMBOL_SCOPE_MODULE as Integer is 3
Constant SYMBOL_SCOPE_FUNCTION as Integer is 4
Constant SYMBOL_SCOPE_BLOCK as Integer is 5

Constant SYMBOL_VISIBILITY_PUBLIC as Integer is 1
Constant SYMBOL_VISIBILITY_PRIVATE as Integer is 2
Constant SYMBOL_VISIBILITY_PROTECTED as Integer is 3
Constant SYMBOL_VISIBILITY_INTERNAL as Integer is 4

Constant OWNERSHIP_OWNED as Integer is 1
Constant OWNERSHIP_BORROWED as Integer is 2
Constant OWNERSHIP_MUTABLE_BORROW as Integer is 3
Constant OWNERSHIP_MOVED as Integer is 4
Constant OWNERSHIP_SHARED as Integer is 5

Constant OPERATION_READ as Integer is 1
Constant OPERATION_WRITE as Integer is 2
Constant OPERATION_MOVE as Integer is 3
Constant OPERATION_BORROW_IMMUTABLE as Integer is 4
Constant OPERATION_BORROW_MUTABLE as Integer is 5

Type called "Symbol":
    name as String                    Note: OWNED - symbol name
    symbol_type as Integer            Note: STACK - symbol type constant
    scope_level as Integer           Note: STACK - scope nesting level
    visibility as Integer            Note: STACK - visibility level
    line_number as Integer           Note: STACK - declaration line
    column_number as Integer         Note: STACK - declaration column
    type_info as Integer             Note: OWNED - type information pointer
    ownership_info as Integer         Note: OWNED - ownership tracking info
    parent_scope as Integer          Note: OWNED - parent scope reference
    children as Integer              Note: OWNED - child symbols array
    metadata as Integer              Note: OWNED - additional metadata
    is_initialized as Integer        Note: STACK - initialization status
    is_mutable as Integer           Note: STACK - mutability status
    is_exported as Integer           Note: STACK - export status
End Type

Type called "SymbolTable":
    symbols as Integer               Note: OWNED - hashtable of symbols
    scope_stack as Integer           Note: OWNED - scope nesting stack
    current_scope as Integer         Note: STACK - current scope level
    symbol_count as Integer          Note: STACK - total symbol count
    scope_count as Integer           Note: STACK - total scope count
    arena as Integer                 Note: OWNED - arena for temporary operations
    ownership_tracker as Integer     Note: OWNED - ownership tracking system
    type_registry as Integer          Note: OWNED - type definition registry
    trait_registry as Integer         Note: OWNED - trait definition registry
    module_registry as Integer       Note: OWNED - module symbol registry
    error_handler as Integer         Note: OWNED - error reporting system
    debug_logger as Integer          Note: OWNED - debug logging system
    borrow_registry as Integer       Note: OWNED - hashtable mapping borrow_id to symbol
    next_borrow_id as Integer        Note: STACK - next unique borrow ID
End Type

Type called "ScopeInfo":
    scope_id as Integer              Note: STACK - unique scope identifier
    parent_scope as Integer          Note: STACK - parent scope ID
    scope_type as Integer            Note: STACK - scope type constant
    depth as Integer                 Note: STACK - nesting depth
    symbol_count as Integer          Note: STACK - symbols in this scope
    start_line as Integer            Note: STACK - scope start line
    end_line as Integer              Note: STACK - scope end line
    is_function_scope as Integer     Note: STACK - function scope flag
    is_loop_scope as Integer         Note: STACK - loop scope flag
    is_match_scope as Integer        Note: STACK - match scope flag
End Type

Type called "OwnershipInfo":
    ownership_type as Integer        Note: STACK - ownership type constant
    owner_symbol as Integer          Note: OWNED - owner symbol reference
    borrow_count as Integer          Note: STACK - number of active borrows
    move_count as Integer            Note: STACK - number of moves
    lifetime_start as Integer        Note: STACK - lifetime start line
    lifetime_end as Integer          Note: STACK - lifetime end line
    is_moved as Integer              Note: STACK - moved status
    is_borrowed as Integer           Note: STACK - borrowed status
    borrow_tracker as Integer        Note: OWNED - borrow tracking system
End Type

Process called "symbol_table_create" takes arena as Integer returns Integer:
    Note:
    Creates a new symbol table with proper memory management and borrow tracking.

    Parameters:
    - arena: Arena for temporary symbol operations (ARENA)

    Returns:
    - Integer: Pointer to OWNED SymbolTable structure

    Side Effects:
    - Allocates OWNED SymbolTable structure
    - Initializes OWNED hashtable for symbol storage
    - Initializes OWNED scope stack for scope management
    - Initializes OWNED borrow registry hashtable
    - Sets up OWNED ownership tracking system

    Algorithm:
    1. Allocate OWNED SymbolTable structure (14 fields × 8 bytes = 112 bytes)
    2. Initialize OWNED hashtable for symbol storage (1024 entries)
    3. Initialize OWNED scope stack for scope management
    4. Initialize OWNED borrow registry hashtable (256 entries)
    5. Initialize current_scope to 0 (global scope)
    6. Initialize next_borrow_id to 1
    7. Initialize counters to 0
    8. Store arena reference
    9. Return OWNED symbol table pointer
    :End Note

    Note: Allocate SymbolTable structure (14 fields × 8 bytes = 112 bytes)
    Let table_size be 112
    Let table be proc allocate from Layout with table_size

    If table is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Create HashTable for symbols (key: symbol_name, value: Symbol pointer)
    Let symbols_table be proc hashtable_create from HashTable with 1024

    If symbols_table is equal to 0:
        proc deallocate from Layout with table
        Return 0
    End If

    Note: Create Stack for scope management
    Let scope_stack be proc stack_create from Stack

    If scope_stack is equal to 0:
        proc hashtable_destroy from HashTable with symbols_table
        proc deallocate from Layout with table
        Return 0
    End If

    Note: Create HashTable for borrow registry (key: borrow_id as string, value: symbol pointer)
    Let borrow_registry be proc hashtable_create from HashTable with 256

    If borrow_registry is equal to 0:
        proc stack_destroy from Stack with scope_stack
        proc hashtable_destroy from HashTable with symbols_table
        proc deallocate from Layout with table
        Return 0
    End If

    Note: Initialize SymbolTable fields
    proc memory_set_qword from Memory with table, 0, symbols_table       Note: symbols
    proc memory_set_qword from Memory with table, 8, scope_stack          Note: scope_stack
    proc memory_set_qword from Memory with table, 16, 0                   Note: current_scope (global = 0)
    proc memory_set_qword from Memory with table, 24, 0                   Note: symbol_count
    proc memory_set_qword from Memory with table, 32, 0                   Note: scope_count
    proc memory_set_qword from Memory with table, 40, arena               Note: arena reference
    proc memory_set_qword from Memory with table, 48, 0                   Note: ownership_tracker
    proc memory_set_qword from Memory with table, 56, 0                   Note: type_registry
    proc memory_set_qword from Memory with table, 64, 0                   Note: trait_registry
    proc memory_set_qword from Memory with table, 72, 0                   Note: module_registry
    proc memory_set_qword from Memory with table, 80, 0                   Note: error_handler
    proc memory_set_qword from Memory with table, 88, 0                   Note: debug_logger
    proc memory_set_qword from Memory with table, 96, borrow_registry     Note: borrow_registry
    proc memory_set_qword from Memory with table, 104, 1                  Note: next_borrow_id (start at 1)

    Return table
End Process

Process called "symbol_table_destroy" takes table as Integer returns Nothing:
    Note:
    Destroys symbol table and frees all owned memory.

    Parameters:
    - table: OWNED SymbolTable to destroy

    Side Effects:
    - Frees all OWNED symbol data
    - Destroys OWNED hashtable
    - Destroys OWNED scope stack
    - Destroys OWNED borrow registry
    - Destroys OWNED ownership tracker
    - Frees OWNED SymbolTable structure

    Algorithm:
    1. Validate table pointer
    2. Destroy OWNED symbols hashtable
    3. Destroy OWNED scope stack
    4. Destroy OWNED borrow registry hashtable
    5. Destroy optional registries if allocated
    6. Free OWNED SymbolTable structure
    :End Note

    If table is equal to 0:
        Return  Note: NULL table already destroyed
    End If

    Note: Get symbols HashTable (offset 0)
    Let symbols_table be proc memory_get_qword from Memory with table, 0

    Note: Destroy symbols HashTable if present
    If symbols_table is not equal to 0:
        proc hashtable_destroy from HashTable with symbols_table
    End If

    Note: Get scope_stack (offset 8)
    Let scope_stack be proc memory_get_qword from Memory with table, 8

    Note: Destroy scope stack if present
    If scope_stack is not equal to 0:
        proc stack_destroy from Stack with scope_stack
    End If

    Note: Get borrow_registry (offset 96)
    Let borrow_registry be proc memory_get_qword from Memory with table, 96

    Note: Destroy borrow registry if present
    If borrow_registry is not equal to 0:
        proc hashtable_destroy from HashTable with borrow_registry
    End If

    Note: Get ownership_tracker (offset 48)
    Let ownership_tracker be proc memory_get_qword from Memory with table, 48

    Note: Destroy ownership tracker if allocated
    If ownership_tracker is not equal to 0:
        Note: Deallocate ownership tracker structure
        proc deallocate from Layout with ownership_tracker
    End If

    Note: Get type_registry (offset 56)
    Let type_registry be proc memory_get_qword from Memory with table, 56

    Note: Destroy type registry if allocated
    If type_registry is not equal to 0:
        Note: Deallocate type registry structure
        proc deallocate from Layout with type_registry
    End If

    Note: Get trait_registry (offset 64)
    Let trait_registry be proc memory_get_qword from Memory with table, 64

    Note: Destroy trait registry if allocated
    If trait_registry is not equal to 0:
        Note: Deallocate trait registry structure
        proc deallocate from Layout with trait_registry
    End If

    Note: Free SymbolTable structure itself
    proc deallocate from Layout with table

    Return
End Process

Process called "symbol_table_add_symbol" takes table as Integer, name as String, symbol_type as Integer, scope_level as Integer, line as Integer, column as Integer returns Integer:
    Note:
    Adds a new symbol to the symbol table with proper ownership tracking.

    Parameters:
    - table: OWNED SymbolTable reference
    - name: String symbol name (will be OWNED by symbol)
    - symbol_type: Symbol type constant (STACK)
    - scope_level: Scope nesting level (STACK)
    - line: Declaration line number (STACK)
    - column: Declaration column number (STACK)

    Returns:
    - Integer: OWNED Symbol pointer or 0 on error

    Side Effects:
    - Allocates OWNED Symbol structure
    - Adds symbol to OWNED hashtable
    - Updates scope information
    - Initializes ownership tracking

    Algorithm:
    1. Validate inputs
    2. Check for symbol conflicts in current scope
    3. Allocate OWNED Symbol structure (14 fields × 8 bytes = 112 bytes)
    4. Copy name string to OWNED Symbol.name
    5. Set symbol type and scope information
    6. Initialize all fields (type_info, ownership_info, etc. to NULL)
    7. Add to OWNED hashtable
    8. Update symbol count
    9. Return OWNED Symbol pointer
    :End Note

    If table is equal to 0:
        Return 0
    End If

    If name is equal to 0:
        Return 0
    End If

    Note: Get symbols HashTable
    Let symbols_table be proc memory_get_qword from Memory with table, 0

    If symbols_table is equal to 0:
        Return 0
    End If

    Note: Check for duplicate symbol in current scope
    Let existing be proc hashtable_get from HashTable with symbols_table, name

    If existing is not equal to 0:
        Note: Symbol already exists - check if same scope
        Let existing_scope be proc memory_get_qword from Memory with existing, 16
        If existing_scope is equal to scope_level:
            Return 0  Note: Duplicate symbol in same scope
        End If
    End If

    Note: Allocate Symbol structure (14 fields × 8 bytes = 112 bytes)
    Let symbol_size be 112
    Let symbol be proc allocate from Layout with symbol_size

    If symbol is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Duplicate the name string for owned storage
    Let name_copy be proc string_duplicate from StringCore with name

    If name_copy is equal to 0:
        proc deallocate from Layout with symbol
        Return 0
    End If

    Note: Initialize Symbol fields
    proc memory_set_qword from Memory with symbol, 0, name_copy             Note: name (OWNED)
    proc memory_set_qword from Memory with symbol, 8, symbol_type           Note: symbol_type
    proc memory_set_qword from Memory with symbol, 16, scope_level          Note: scope_level
    proc memory_set_qword from Memory with symbol, 24, 1                    Note: visibility (default PUBLIC)
    proc memory_set_qword from Memory with symbol, 32, line                 Note: line_number
    proc memory_set_qword from Memory with symbol, 40, column               Note: column_number
    proc memory_set_qword from Memory with symbol, 48, 0                    Note: type_info (NULL)
    proc memory_set_qword from Memory with symbol, 56, 0                    Note: ownership_info (NULL)
    proc memory_set_qword from Memory with symbol, 64, 0                    Note: parent_scope (NULL)
    proc memory_set_qword from Memory with symbol, 72, 0                    Note: children (NULL)
    proc memory_set_qword from Memory with symbol, 80, 0                    Note: metadata (NULL)
    proc memory_set_qword from Memory with symbol, 88, 0                    Note: is_initialized (false)
    proc memory_set_qword from Memory with symbol, 96, 0                    Note: is_mutable (false)
    proc memory_set_qword from Memory with symbol, 104, 0                   Note: is_exported (false)

    Note: Add symbol to hashtable (key: name, value: symbol pointer)
    Let set_result be proc hashtable_set from HashTable with symbols_table, name, symbol

    If set_result is equal to 0:
        proc deallocate from Layout with name_copy
        proc deallocate from Layout with symbol
        Return 0
    End If

    Note: Increment symbol count (offset 24)
    Let symbol_count be proc memory_get_qword from Memory with table, 24
    Set symbol_count to symbol_count plus 1
    proc memory_set_qword from Memory with table, 24, symbol_count

    Return symbol
End Process

Process called "symbol_table_lookup_symbol" takes table as Integer, name as String, arena as Integer returns Integer:
    Note:
    Looks up a symbol by name with complete scope traversal.

    Parameters:
    - table: OWNED SymbolTable reference
    - name: String symbol name to lookup
    - arena: Arena for temporary lookup operations (ARENA)

    Returns:
    - Integer: Symbol pointer or 0 if not found

    Side Effects:
    - Searches current scope first, then parent scopes
    - No memory allocation for lookup operations
    - Implements proper lexical scoping rules

    Algorithm:
    1. Validate inputs
    2. Get current scope ID from table
    3. Start from current scope
    4. Search for symbol by name in hashtable
    5. If found and symbol's scope matches or is parent of current, return it
    6. If not found in any scope, return 0

    Implementation Strategy:
    Since the hashtable stores all symbols globally by name, we need to:
    - Search the hashtable for the name
    - Check if the found symbol's scope is visible from current scope
    - A symbol is visible if its scope_level <= current_scope
    - This implements proper lexical scoping with shadowing support
    :End Note

    If table is equal to 0:
        Return 0
    End If

    If name is equal to 0:
        Return 0
    End If

    Note: Get symbols HashTable (offset 0)
    Let symbols_table be proc memory_get_qword from Memory with table, 0

    If symbols_table is equal to 0:
        Return 0
    End If

    Note: Get current scope (offset 16)
    Let current_scope be proc memory_get_qword from Memory with table, 16

    Note: Search for symbol by name in hashtable
    Note: The hashtable stores symbols by name, but multiple symbols with same name
    Note: can exist in different scopes. We need to find the most recent one
    Note: that is visible from the current scope.

    Note: First, try direct hashtable lookup for exact name match
    Let symbol be proc hashtable_get from HashTable with symbols_table, name

    If symbol is not equal to 0:
        Note: Found a symbol with this name
        Note: Check if this symbol is visible from current scope
        Let symbol_scope be proc memory_get_qword from Memory with symbol, 16

        Note: A symbol is visible if its scope_level <= current_scope
        Note: This implements proper lexical scoping
        If symbol_scope is less than or equal to current_scope:
            Return symbol
        End If
    End If

    Note: Direct lookup failed, need to search for symbol in parent scopes
    Note: Iterate through all symbols to find best match
    Note: This handles shadowing: inner scope symbols override outer scope symbols

    Let entries be proc memory_get_qword from Memory with symbols_table, 0
    Let capacity be proc memory_get_qword from Memory with symbols_table, 8

    Let HASHTABLE_ENTRY_SIZE be 32
    Let ENTRY_STATE_OCCUPIED be 1

    Note: Track the best matching symbol (closest scope to current)
    Let best_symbol be 0
    Let best_scope_distance be 9999999  Note: Large number for comparison

    Let i be 0
    While i is less than capacity:
        Let entry_offset be i multiplied by HASHTABLE_ENTRY_SIZE
        Let entry_ptr be entries plus entry_offset
        Let state be proc memory_get_qword from Memory with entry_ptr, 0

        If state is equal to ENTRY_STATE_OCCUPIED:
            Note: Get key and value from entry
            Let key_ptr be proc memory_get_qword from Memory with entry_ptr, 16
            Let value_ptr be proc memory_get_qword from Memory with entry_ptr, 24

            Note: Compare key with search name
            Let keys_match be proc string_equals from StringCore with key_ptr, name

            If keys_match is equal to 1:
                Note: Found a symbol with matching name
                Let candidate_scope be proc memory_get_qword from Memory with value_ptr, 16

                Note: Check if visible from current scope
                If candidate_scope is less than or equal to current_scope:
                    Note: Calculate scope distance (closer is better)
                    Let scope_distance be current_scope minus candidate_scope

                    Note: If this is closer than best so far, use it
                    If scope_distance is less than best_scope_distance:
                        Set best_symbol to value_ptr
                        Set best_scope_distance to scope_distance
                    End If
                End If
            End If
        End If

        Set i to i plus 1
    End While

    Return best_symbol
End Process

Process called "symbol_table_enter_scope" takes table as Integer, scope_type as Integer, start_line as Integer returns Integer:
    Note:
    Enters a new scope with proper scope tracking.

    Parameters:
    - table: OWNED SymbolTable reference
    - scope_type: Type of scope being entered (STACK)
    - start_line: Line where scope begins (STACK)

    Returns:
    - Integer: New scope ID (STACK)

    Side Effects:
    - Increments scope nesting level
    - Pushes scope info to OWNED scope stack
    - Updates current scope reference

    Algorithm:
    1. Get current scope as parent
    2. Allocate OWNED ScopeInfo structure (10 fields × 8 bytes = 80 bytes)
    3. Set scope type, parent, and nesting information
    4. Push to OWNED scope stack
    5. Increment scope counter to get new scope ID
    6. Update current scope reference
    7. Return new scope ID
    :End Note

    If table is equal to 0:
        Return 0
    End If

    Note: Get scope stack
    Let scope_stack be proc memory_get_qword from Memory with table, 8

    If scope_stack is equal to 0:
        Return 0
    End If

    Note: Get current scope as parent (offset 16)
    Let parent_scope be proc memory_get_qword from Memory with table, 16

    Note: Get scope count and increment for new ID (offset 32)
    Let scope_count be proc memory_get_qword from Memory with table, 32
    Set scope_count to scope_count plus 1
    proc memory_set_qword from Memory with table, 32, scope_count

    Note: New scope ID is the incremented count
    Let new_scope_id be scope_count

    Note: Calculate depth (parent depth + 1, or 0 if no parent)
    Let depth be 0
    If parent_scope is not equal to 0:
        Set depth to parent_scope plus 1
    End If

    Note: Allocate ScopeInfo structure (10 fields × 8 bytes = 80 bytes)
    Let scope_info_size be 80
    Let scope_info be proc allocate from Layout with scope_info_size

    If scope_info is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Initialize ScopeInfo fields
    proc memory_set_qword from Memory with scope_info, 0, new_scope_id     Note: scope_id
    proc memory_set_qword from Memory with scope_info, 8, parent_scope     Note: parent_scope
    proc memory_set_qword from Memory with scope_info, 16, scope_type      Note: scope_type
    proc memory_set_qword from Memory with scope_info, 24, depth           Note: depth
    proc memory_set_qword from Memory with scope_info, 32, 0               Note: symbol_count
    proc memory_set_qword from Memory with scope_info, 40, start_line      Note: start_line
    proc memory_set_qword from Memory with scope_info, 48, 0               Note: end_line (unknown yet)
    proc memory_set_qword from Memory with scope_info, 56, 0               Note: is_function_scope
    proc memory_set_qword from Memory with scope_info, 64, 0               Note: is_loop_scope
    proc memory_set_qword from Memory with scope_info, 72, 0               Note: is_match_scope

    Note: Set scope-specific flags based on scope_type
    If scope_type is equal to 4:  Note: SYMBOL_SCOPE_FUNCTION
        proc memory_set_qword from Memory with scope_info, 56, 1  Note: is_function_scope = true
    End If

    Note: Push scope info onto stack
    Let push_result be proc stack_push from Stack with scope_stack, scope_info

    If push_result is equal to 0:
        proc deallocate from Layout with scope_info
        Return 0
    End If

    Note: Update current_scope (offset 16)
    proc memory_set_qword from Memory with table, 16, new_scope_id

    Return new_scope_id
End Process

Process called "symbol_table_exit_scope" takes table as Integer returns Nothing:
    Note:
    Exits current scope and cleans up scope-specific symbols.

    Parameters:
    - table: OWNED SymbolTable reference

    Side Effects:
    - Decrements scope nesting level
    - Pops scope info from OWNED scope stack
    - Cleans up scope-specific symbols
    - Updates current scope reference

    Algorithm:
    1. Get scope stack
    2. Pop current scope info
    3. Get parent scope ID from popped scope
    4. Update current_scope to parent
    5. Free scope info structure
    :End Note

    If table is equal to 0:
        Return
    End If

    Note: Get scope stack
    Let scope_stack be proc memory_get_qword from Memory with table, 8

    If scope_stack is equal to 0:
        Return
    End If

    Note: Pop current scope from stack
    Let scope_info be proc stack_pop from Stack with scope_stack

    If scope_info is equal to 0:
        Return  Note: No scope to exit (already at global)
    End If

    Note: Get parent_scope from scope_info (offset 8)
    Let parent_scope be proc memory_get_qword from Memory with scope_info, 8

    Note: Update current_scope to parent (offset 16)
    proc memory_set_qword from Memory with table, 16, parent_scope

    Note: Free scope_info structure
    proc deallocate from Layout with scope_info

    Return
End Process

Process called "symbol_table_get_scope_depth" takes table as Integer returns Integer:
    Note:
    Gets current scope nesting depth.

    Parameters:
    - table: OWNED SymbolTable reference

    Returns:
    - Integer: Current scope depth (STACK)

    Algorithm:
    1. Get scope stack
    2. Return stack size as depth
    :End Note

    If table is equal to 0:
        Return 0
    End If

    Note: Get scope stack
    Let scope_stack be proc memory_get_qword from Memory with table, 8

    If scope_stack is equal to 0:
        Return 0
    End If

    Note: Get stack count (depth)
    Let depth be proc stack_count from Stack with scope_stack

    Return depth
End Process

Process called "symbol_table_get_symbols_in_scope" takes table as Integer, scope_id as Integer, arena as Integer returns Integer:
    Note:
    Gets all symbols in a specific scope using arena-based operations.

    Parameters:
    - table: OWNED SymbolTable reference
    - scope_id: Scope ID to query (STACK)
    - arena: Arena for temporary symbol list (ARENA)

    Returns:
    - Integer: OWNED List pointer containing symbol pointers

    Side Effects:
    - Allocates OWNED List structure
    - List must be destroyed by caller
    - Iterates all symbols in hashtable

    Algorithm:
    1. Validate inputs
    2. Create OWNED List for results
    3. Get symbols hashtable structure
    4. Iterate all hashtable entries
    5. For each occupied entry, check symbol scope_level
    6. If scope_level matches scope_id, add symbol to list
    7. Return OWNED list pointer
    :End Note

    If table is equal to 0:
        Return 0
    End If

    Note: Create List for symbols in scope
    Let symbols_list be proc list_create from List

    If symbols_list is equal to 0:
        Return 0  Note: Failed to create list
    End If

    Note: Get symbols hashtable (offset 0)
    Let symbols_table be proc memory_get_qword from Memory with table, 0

    If symbols_table is equal to 0:
        proc list_destroy from List with symbols_list
        Return 0
    End If

    Note: Get hashtable internal structure
    Note: HashTable structure: entries at offset 0, capacity at offset 8
    Let entries be proc memory_get_qword from Memory with symbols_table, 0
    Let capacity be proc memory_get_qword from Memory with symbols_table, 8

    Note: HashTable entry structure (32 bytes):
    Note:   offset 0:  state (8 bytes) - 0=empty, 1=occupied, 2=deleted
    Note:   offset 8:  hash (8 bytes)
    Note:   offset 16: key (8 bytes) - pointer to key string
    Note:   offset 24: value (8 bytes) - pointer to symbol
    Let HASHTABLE_ENTRY_SIZE be 32
    Let ENTRY_STATE_OCCUPIED be 1

    Note: Iterate all hashtable entries
    Let i be 0
    While i is less than capacity:
        Let entry_offset be i multiplied by HASHTABLE_ENTRY_SIZE
        Let entry_ptr be entries plus entry_offset
        Let state be proc memory_get_qword from Memory with entry_ptr, 0

        If state is equal to ENTRY_STATE_OCCUPIED:
            Note: Get symbol pointer from entry value field (offset 24)
            Let symbol_ptr be proc memory_get_qword from Memory with entry_ptr, 24

            Note: Get scope_level from symbol (offset 16 in Symbol structure)
            Let symbol_scope_level be proc memory_get_qword from Memory with symbol_ptr, 16

            Note: If this symbol is in the requested scope, add it to the list
            If symbol_scope_level is equal to scope_id:
                Let push_result be proc list_push from List with symbols_list, symbol_ptr
                If push_result is equal to 0:
                    Note: Failed to add to list, destroy list and return failure
                    proc list_destroy from List with symbols_list
                    Return 0
                End If
            End If
        End If

        Set i to i plus 1
    End While

    Return symbols_list
End Process

Process called "symbol_table_check_ownership" takes table as Integer, symbol as Integer, operation as Integer, arena as Integer returns Integer:
    Note:
    Checks ownership constraints for symbol operations with complete validation rules.

    Parameters:
    - table: OWNED SymbolTable reference
    - symbol: Symbol to check (OWNED)
    - operation: Operation type (STACK) - OPERATION_READ, OPERATION_WRITE, OPERATION_MOVE,
                 OPERATION_BORROW_IMMUTABLE, OPERATION_BORROW_MUTABLE
    - arena: Arena for temporary analysis (ARENA)

    Returns:
    - Integer: Ownership validation result (STACK)
            1 = valid, 0 = invalid

    Side Effects:
    - Uses ARENA for temporary ownership analysis
    - Performs operation-specific ownership validation

    Algorithm:
    1. Validate inputs
    2. Get ownership_info from symbol
    3. Check if symbol has been moved (always invalid after move)
    4. Switch on operation type:
       - OPERATION_READ: Valid unless moved
       - OPERATION_WRITE: Valid unless moved or immutably borrowed
       - OPERATION_MOVE: Invalid if moved or borrowed (any type)
       - OPERATION_BORROW_IMMUTABLE: Invalid if moved or mutably borrowed
       - OPERATION_BORROW_MUTABLE: Invalid if moved or borrowed (any type)
    5. Return validation result
    :End Note

    If table is equal to 0:
        Return 0
    End If

    If symbol is equal to 0:
        Return 0
    End If

    Note: Get ownership_info from symbol (offset 56)
    Let ownership_info be proc memory_get_qword from Memory with symbol, 56

    If ownership_info is equal to 0:
        Return 1  Note: No ownership tracking configured for this symbol, valid by default
    End If

    Note: Get is_moved flag (offset 56 in OwnershipInfo)
    Let is_moved be proc memory_get_qword from Memory with ownership_info, 56

    Note: If symbol has been moved, ALL operations are invalid
    If is_moved is not equal to 0:
        Return 0  Note: Cannot use moved symbol
    End If

    Note: Get borrow_count (offset 72 in OwnershipInfo)
    Let borrow_count be proc memory_get_qword from Memory with ownership_info, 72

    Note: Check operation-specific ownership constraints
    If operation is equal to 1:  Note: OPERATION_READ
        Note: Reading is always valid unless moved (already checked)
        Return 1

    Otherwise If operation is equal to 2:  Note: OPERATION_WRITE
        Note: Writing requires exclusive access (no borrows)
        If borrow_count is greater than 0:
            Return 0  Note: Cannot write while borrowed
        End If
        Return 1

    Otherwise If operation is equal to 3:  Note: OPERATION_MOVE
        Note: Moving requires exclusive access (no borrows)
        If borrow_count is greater than 0:
            Return 0  Note: Cannot move borrowed value
        End If
        Return 1

    Otherwise If operation is equal to 4:  Note: OPERATION_BORROW_IMMUTABLE
        Note: Immutable borrow allowed unless mutably borrowed
        Note: Multiple immutable borrows are allowed
        Note: Check if there's a mutable borrow by examining ownership_type
        Let ownership_type be proc memory_get_qword from Memory with ownership_info, 8

        Note: If currently mutably borrowed (ownership_type = OWNERSHIP_MUTABLE_BORROW)
        If ownership_type is equal to 3:  Note: OWNERSHIP_MUTABLE_BORROW
            Return 0  Note: Cannot immutably borrow while mutably borrowed
        End If
        Return 1

    Otherwise If operation is equal to 5:  Note: OPERATION_BORROW_MUTABLE
        Note: Mutable borrow requires exclusive access (no existing borrows)
        If borrow_count is greater than 0:
            Return 0  Note: Cannot mutably borrow while borrowed
        End If
        Return 1

    Otherwise:
        Note: Unknown operation type
        Return 0
    End If
End Process

Process called "symbol_table_track_move" takes table as Integer, symbol as Integer, new_owner as Integer returns Nothing:
    Note:
    Tracks ownership transfer for moved symbols.

    Parameters:
    - table: OWNED SymbolTable reference
    - symbol: Symbol being moved (OWNED)
    - new_owner: New owner symbol (OWNED)

    Side Effects:
    - Updates ownership tracking
    - Marks symbol as moved
    - Updates ownership relationships

    Algorithm:
    1. Validate inputs
    2. Get ownership_info from symbol
    3. Mark symbol as moved
    4. Update ownership relationships
    :End Note

    If table is equal to 0:
        Return
    End If

    If symbol is equal to 0:
        Return
    End If

    Note: Get ownership_info from symbol (offset 56)
    Let ownership_info be proc memory_get_qword from Memory with symbol, 56

    If ownership_info is equal to 0:
        Return  Note: No ownership tracking
    End If

    Note: Mark as moved (offset 56 in OwnershipInfo)
    proc memory_set_qword from Memory with ownership_info, 56, 1

    Note: Increment move_count (offset 64 in OwnershipInfo)
    Let move_count be proc memory_get_qword from Memory with ownership_info, 64
    Set move_count to move_count plus 1
    proc memory_set_qword from Memory with ownership_info, 64, move_count

    Note: Store new_owner reference (offset 16 in OwnershipInfo - new_owner field)
    If new_owner is not equal to 0:
        proc memory_set_qword from Memory with ownership_info, 16, new_owner
    End If

    Return
End Process

Process called "symbol_table_track_borrow" takes table as Integer, symbol as Integer, borrower as Integer, is_mutable as Integer returns Integer:
    Note:
    Tracks borrowing of symbols with complete mutability tracking and borrow registry.

    Parameters:
    - table: OWNED SymbolTable reference
    - symbol: Symbol being borrowed (OWNED)
    - borrower: Borrowing symbol (OWNED)
    - is_mutable: Mutable borrow flag (STACK)

    Returns:
    - Integer: Unique borrow ID for tracking (STACK)
            Returns unique ID from next_borrow_id, or 0 on failure

    Side Effects:
    - Updates borrow tracking in OwnershipInfo
    - Increments borrow count
    - Registers borrow in borrow_registry hashtable
    - Increments next_borrow_id counter
    - Tracks mutability constraints

    Algorithm:
    1. Validate inputs
    2. Get ownership_info from symbol
    3. Check if already moved (cannot borrow moved values)
    4. Mark symbol as borrowed
    5. Increment borrow_count in OwnershipInfo
    6. Get next_borrow_id and increment it
    7. Register borrow in borrow_registry (borrow_id -> symbol mapping)
    8. Return unique borrow ID
    :End Note

    If table is equal to 0:
        Return 0
    End If

    If symbol is equal to 0:
        Return 0
    End If

    Note: Get ownership_info from symbol (offset 56)
    Let ownership_info be proc memory_get_qword from Memory with symbol, 56

    If ownership_info is equal to 0:
        Return 0  Note: No ownership tracking
    End If

    Note: Check if already moved
    Let is_moved be proc memory_get_qword from Memory with ownership_info, 56
    If is_moved is not equal to 0:
        Return 0  Note: Cannot borrow moved value
    End If

    Note: Mark as borrowed (offset 64 in OwnershipInfo)
    proc memory_set_qword from Memory with ownership_info, 64, 1

    Note: Increment borrow_count (offset 72 in OwnershipInfo)
    Let borrow_count be proc memory_get_qword from Memory with ownership_info, 72
    Set borrow_count to borrow_count plus 1
    proc memory_set_qword from Memory with ownership_info, 72, borrow_count

    Note: Get and increment next_borrow_id (offset 104)
    Let borrow_id be proc memory_get_qword from Memory with table, 104
    Let next_id be borrow_id plus 1
    proc memory_set_qword from Memory with table, 104, next_id

    Note: Register borrow in borrow_registry (borrow_id -> symbol)
    Let borrow_registry be proc memory_get_qword from Memory with table, 96

    If borrow_registry is not equal to 0:
        Note: Use borrow_id as integer key (hashtable supports integer keys)
        Note: Store symbol pointer as value
        Let set_result be proc hashtable_set from HashTable with borrow_registry, borrow_id, symbol

        If set_result is equal to 0:
            Note: Failed to register borrow, rollback changes
            Set borrow_count to borrow_count minus 1
            proc memory_set_qword from Memory with ownership_info, 72, borrow_count

            If borrow_count is equal to 0:
                proc memory_set_qword from Memory with ownership_info, 64, 0
            End If

            Return 0
        End If
    End If

    Note: Return unique borrow ID
    Return borrow_id
End Process

Process called "symbol_table_release_borrow" takes table as Integer, borrow_id as Integer returns Nothing:
    Note:
    Releases a borrow and updates complete tracking information using borrow registry.

    Parameters:
    - table: OWNED SymbolTable reference
    - borrow_id: Unique borrow ID to release (STACK)

    Side Effects:
    - Looks up symbol in borrow_registry
    - Decrements borrow count in symbol's OwnershipInfo
    - Updates is_borrowed flag if count reaches 0
    - Removes borrow from borrow_registry
    - Validates borrow release

    Algorithm:
    1. Validate inputs
    2. Lookup symbol in borrow_registry using borrow_id
    3. If found, get symbol's OwnershipInfo
    4. Decrement borrow_count
    5. If borrow_count reaches 0, clear is_borrowed flag
    6. Remove borrow_id from borrow_registry
    7. Return
    :End Note

    If table is equal to 0:
        Return
    End If

    If borrow_id is equal to 0:
        Return
    End If

    Note: Get borrow_registry (offset 96)
    Let borrow_registry be proc memory_get_qword from Memory with table, 96

    If borrow_registry is equal to 0:
        Return  Note: No borrow registry
    End If

    Note: Lookup symbol using borrow_id
    Let symbol be proc hashtable_get from HashTable with borrow_registry, borrow_id

    If symbol is equal to 0:
        Return  Note: Borrow ID not found (already released or invalid)
    End If

    Note: Get ownership_info from symbol (offset 56)
    Let ownership_info be proc memory_get_qword from Memory with symbol, 56

    If ownership_info is equal to 0:
        Note: Remove from registry even if no ownership info
        proc hashtable_remove from HashTable with borrow_registry, borrow_id
        Return
    End If

    Note: Decrement borrow_count (offset 72 in OwnershipInfo)
    Let borrow_count be proc memory_get_qword from Memory with ownership_info, 72

    If borrow_count is greater than 0:
        Set borrow_count to borrow_count minus 1
        proc memory_set_qword from Memory with ownership_info, 72, borrow_count

        Note: If borrow_count reaches 0, clear is_borrowed flag (offset 64)
        If borrow_count is equal to 0:
            proc memory_set_qword from Memory with ownership_info, 64, 0
        End If
    End If

    Note: Remove borrow from registry
    proc hashtable_remove from HashTable with borrow_registry, borrow_id

    Return
End Process

Process called "symbol_table_get_ownership_info" takes table as Integer, symbol as Integer returns Integer:
    Note:
    Gets ownership information for a symbol.

    Parameters:
    - table: OWNED SymbolTable reference
    - symbol: Symbol to query (OWNED)

    Returns:
    - Integer: OWNED OwnershipInfo pointer, or 0 if none

    Algorithm:
    1. Validate inputs
    2. Get ownership_info from symbol
    3. Return ownership_info pointer
    :End Note

    If table is equal to 0:
        Return 0
    End If

    If symbol is equal to 0:
        Return 0
    End If

    Note: Get ownership_info from symbol (offset 56)
    Let ownership_info be proc memory_get_qword from Memory with symbol, 56

    Return ownership_info
End Process

Process called "symbol_table_validate_ownership" takes table as Integer, arena as Integer returns Integer:
    Note:
    Validates all ownership constraints in the symbol table.

    Parameters:
    - table: OWNED SymbolTable reference
    - arena: Arena for temporary validation (ARENA)

    Returns:
    - Integer: Validation result (STACK)
            1 = valid, 0 = has violations

    Side Effects:
    - Uses ARENA for temporary validation data
    - Reports ownership violations

    Algorithm:
    1. Validate inputs
    2. Iterate all hashtable entries
    3. For each occupied entry, validate symbol ownership constraints
    4. Check for invalid states (moved AND borrowed simultaneously)
    5. Validate borrow counts are non-negative
    6. Validate global table counts are non-negative
    7. Return validation result (1=valid, 0=violations found)
    :End Note

    If table is equal to 0:
        Return 0
    End If

    Note: Get symbols hashtable (offset 0)
    Let symbols_table be proc memory_get_qword from Memory with table, 0
    Let entries be proc memory_get_qword from Memory with symbols_table, 0
    Let capacity be proc memory_get_qword from Memory with symbols_table, 8

    Let HASHTABLE_ENTRY_SIZE be 32
    Let ENTRY_STATE_OCCUPIED be 1

    Note: Iterate all symbols and check ownership constraints
    Let i be 0
    While i is less than capacity:
        Let entry_offset be i multiplied by HASHTABLE_ENTRY_SIZE
        Let entry_ptr be entries plus entry_offset
        Let state be proc memory_get_qword from Memory with entry_ptr, 0

        If state is equal to ENTRY_STATE_OCCUPIED:
            Let symbol_ptr be proc memory_get_qword from Memory with entry_ptr, 16

            Note: Get ownership_info from symbol (offset 56)
            Let ownership_info be proc memory_get_qword from Memory with symbol_ptr, 56

            If ownership_info is not equal to 0:
                Note: Check is_moved and borrow_count validity
                Let is_moved be proc memory_get_qword from Memory with ownership_info, 56
                Let borrow_count be proc memory_get_qword from Memory with ownership_info, 72

                Note: Symbol cannot be both moved and borrowed
                If is_moved is not equal to 0:
                    If borrow_count is not equal to 0:
                        Return 0  Note: Invalid state
                    End If
                End If

                Note: Borrow count cannot be negative
                If borrow_count is less than 0:
                    Return 0
                End If
            End If
        End If

        Set i to i plus 1
    End While

    Note: Check that global counts are non-negative
    Let symbol_count be proc memory_get_qword from Memory with table, 24
    Let move_count be proc memory_get_qword from Memory with table, 80
    Let borrow_count_global be proc memory_get_qword from Memory with table, 88

    If symbol_count is less than 0:
        Return 0
    End If

    If move_count is less than 0:
        Return 0
    End If

    If borrow_count_global is less than 0:
        Return 0
    End If

    Return 1
End Process

Process called "symbol_table_get_statistics" takes table as Integer, arena as Integer returns Integer:
    Note:
    Gets symbol table statistics using arena-based operations.

    Parameters:
    - table: OWNED SymbolTable reference
    - arena: Arena for temporary statistics (ARENA)

    Returns:
    - Integer: ARENA pointer to statistics structure

    Side Effects:
    - Uses ARENA for temporary statistics
    - No permanent memory allocation

    Algorithm:
    1. Validate inputs
    2. Allocate statistics structure in ARENA
    3. Populate with symbol_count and scope_count
    4. Return ARENA pointer

    Statistics structure (4 fields × 8 bytes = 32 bytes):
    - symbol_count
    - scope_count
    - current_depth
    - max_depth
    :End Note

    If table is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Allocate statistics structure in ARENA (4 fields × 8 bytes = 32 bytes)
    Let stats_size be 32
    Let stats be proc allocate from Layout with stats_size

    If stats is equal to 0:
        Return 0
    End If

    Note: Get symbol_count (offset 24)
    Let symbol_count be proc memory_get_qword from Memory with table, 24

    Note: Get scope_count (offset 32)
    Let scope_count be proc memory_get_qword from Memory with table, 32

    Note: Get current depth
    Let current_depth be proc symbol_table_get_scope_depth with table

    Note: Populate statistics
    proc memory_set_qword from Memory with stats, 0, symbol_count     Note: symbol_count
    proc memory_set_qword from Memory with stats, 8, scope_count      Note: scope_count
    proc memory_set_qword from Memory with stats, 16, current_depth   Note: current_depth
    proc memory_set_qword from Memory with stats, 24, current_depth   Note: max_depth

    Return stats
End Process