Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file implements type checking and type validation for Runa programs.

This file performs the following tasks:
- Perform type checking and type validation across all language constructs with memory-efficient operations
- Handle type inference and type deduction with arena-based temporary analysis
- Process type compatibility and type conversion validation with ownership-aware operations
- Manage type error detection and type error reporting with deterministic memory management

This file is essential because of the following reasons:
- Type checking ensures program correctness and prevents type-related errors
- Proper type validation enables safe and reliable program execution
- Type inference improves developer experience and code clarity
- Memory-efficient type checking enables scalable semantic analysis

This file consists of the following functions/features/operation types:
- Type checking and type validation algorithms with ownership patterns
- Type inference and type deduction processing with arena-based operations
- Type compatibility checking and type conversion validation with memory safety
- Type error detection and type error reporting with deterministic cleanup
:End Note

Import "compiler/frontend/semantic/symbol_table.runa" as SymbolTable
Import "compiler/frontend/semantic/scope_analyzer.runa" as ScopeAnalyzer
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/primitives/collections/hashtable.runa" as HashTable
Import "compiler/frontend/primitives/collections/list.runa" as List
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
Import "compiler/frontend/parsing/ast.runa" as AST

Constant TYPE_KIND_BASIC as Integer is 1
Constant TYPE_KIND_COMPOSITE as Integer is 2
Constant TYPE_KIND_FUNCTION as Integer is 3
Constant TYPE_KIND_GENERIC as Integer is 4
Constant TYPE_KIND_UNION as Integer is 5
Constant TYPE_KIND_INTERSECTION as Integer is 6
Constant TYPE_KIND_OPTIONAL as Integer is 7
Constant TYPE_KIND_ARRAY as Integer is 8
Constant TYPE_KIND_TUPLE as Integer is 9
Constant TYPE_KIND_TRAIT as Integer is 10

Constant TYPE_BASIC_INTEGER as Integer is 1
Constant TYPE_BASIC_FLOAT as Integer is 2
Constant TYPE_BASIC_STRING as Integer is 3
Constant TYPE_BASIC_BOOLEAN as Integer is 4
Constant TYPE_BASIC_CHARACTER as Integer is 5
Constant TYPE_BASIC_VOID as Integer is 6
Constant TYPE_BASIC_UNIT as Integer is 7

Constant TYPE_COMPATIBILITY_EXACT as Integer is 1
Constant TYPE_COMPATIBILITY_COERCE as Integer is 2
Constant TYPE_COMPATIBILITY_INCOMPATIBLE as Integer is 3
Constant TYPE_COMPATIBILITY_UNKNOWN as Integer is 4

Constant TYPE_INFERENCE_MODE_STRICT as Integer is 1
Constant TYPE_INFERENCE_MODE_RELAXED as Integer is 2
Constant TYPE_INFERENCE_MODE_AUTO as Integer is 3

Type called "TypeInfo":
    type_id as Integer                Note: STACK - unique type identifier
    type_kind as Integer              Note: STACK - type kind constant
    type_name as String               Note: OWNED - type name
    size_bytes as Integer             Note: STACK - type size in bytes
    alignment as Integer              Note: STACK - type alignment
    is_mutable as Integer             Note: STACK - mutability flag
    is_owned as Integer               Note: STACK - ownership flag
    is_copyable as Integer            Note: STACK - copyable flag
    is_moveable as Integer            Note: STACK - moveable flag
    is_sendable as Integer            Note: STACK - sendable flag
    is_sync as Integer                Note: STACK - sync flag
    generic_params as Integer         Note: OWNED - generic parameters
    constraints as Integer            Note: OWNED - type constraints
    methods as Integer                Note: OWNED - type methods
    fields as Integer                 Note: OWNED - type fields
    parent_types as Integer           Note: OWNED - parent type list
    trait_implementations as Integer  Note: OWNED - trait implementations
    ownership_info as Integer         Note: OWNED - ownership information
End Type

Type called "TypeChecker":
    symbol_table as Integer          Note: OWNED - symbol table reference
    scope_analyzer as Integer        Note: OWNED - scope analyzer reference
    type_registry as Integer         Note: OWNED - type registry
    type_cache as Integer            Note: OWNED - type cache
    inference_engine as Integer      Note: OWNED - type inference engine
    compatibility_matrix as Integer  Note: OWNED - type compatibility matrix
    conversion_rules as Integer      Note: OWNED - type conversion rules
    arena as Integer                 Note: OWNED - arena for temporary analysis
    inference_mode as Integer        Note: STACK - type inference mode
    strict_mode as Integer           Note: STACK - strict type checking flag
    error_count as Integer           Note: STACK - type error count
    warning_count as Integer         Note: STACK - type warning count
    type_count as Integer            Note: STACK - total type count
    inference_count as Integer       Note: STACK - inference operation count
    error_handler as Integer         Note: OWNED - error reporting system
    debug_logger as Integer          Note: OWNED - debug logging system
End Type

Type called "TypeInference":
    inference_id as Integer          Note: STACK - unique inference identifier
    target_expression as Integer     Note: OWNED - target expression AST
    inferred_type as Integer         Note: OWNED - inferred type
    confidence as Integer            Note: STACK - inference confidence level
    constraints as Integer           Note: OWNED - type constraints
    dependencies as Integer          Note: OWNED - inference dependencies
    is_resolved as Integer           Note: STACK - resolution status
    resolution_time as Integer       Note: STACK - resolution timestamp
End Type

Type called "TypeConstraint":
    constraint_id as Integer         Note: STACK - unique constraint identifier
    constraint_type as Integer       Note: STACK - constraint type constant
    left_type as Integer             Note: OWNED - left type reference
    right_type as Integer            Note: OWNED - right type reference
    constraint_value as Integer      Note: STACK - constraint value
    is_satisfied as Integer          Note: STACK - satisfaction status
    error_message as String          Note: OWNED - error message if unsatisfied
End Type

Process called "type_checker_create" takes symbol_table as Integer, scope_analyzer as Integer, arena as Integer returns Integer:
    Note:
    Creates a new type checker with proper memory management.
    
    Parameters:
    - symbol_table: OWNED SymbolTable reference
    - scope_analyzer: OWNED ScopeAnalyzer reference
    - arena: Arena for temporary type analysis (ARENA)
    
    Returns:
    - Integer: Pointer to OWNED TypeChecker structure
    
    Side Effects:
    - Allocates OWNED TypeChecker structure
    - Initializes OWNED type registry
    - Sets up OWNED type cache
    - Initializes OWNED inference engine
    
    Algorithm:
    1. Allocate OWNED TypeChecker structure (16 fields × 8 bytes = 128 bytes)
    2. Store OWNED SymbolTable and ScopeAnalyzer references
    3. Initialize all counters and references
    4. Return OWNED TypeChecker pointer
    :End Note

    If symbol_table is equal to 0:
        Return 0
    End If

    If scope_analyzer is equal to 0:
        Return 0
    End If

    Note: Allocate TypeChecker (16 fields × 8 bytes = 128 bytes)
    Let checker_size be 128
    Let checker be proc allocate from Layout with checker_size

    If checker is equal to 0:
        Return 0
    End If

    Note: Create type registry (HashTable for type storage)
    Let type_registry be proc create from HashTable with 256

    If type_registry is equal to 0:
        proc deallocate from Layout with checker
        Return 0
    End If

    Note: Initialize TypeChecker fields
    proc memory_set_qword from Memory with checker, 0, symbol_table        Note: symbol_table
    proc memory_set_qword from Memory with checker, 8, scope_analyzer      Note: scope_analyzer
    proc memory_set_qword from Memory with checker, 16, type_registry      Note: type_registry
    proc memory_set_qword from Memory with checker, 24, 0                  Note: type_cache (NULL)
    proc memory_set_qword from Memory with checker, 32, 0                  Note: inference_engine (NULL)
    proc memory_set_qword from Memory with checker, 40, 0                  Note: compatibility_matrix (NULL)
    proc memory_set_qword from Memory with checker, 48, 0                  Note: conversion_rules (NULL)
    proc memory_set_qword from Memory with checker, 56, arena              Note: arena reference
    proc memory_set_qword from Memory with checker, 64, 0                  Note: inference_mode
    proc memory_set_qword from Memory with checker, 72, 1                  Note: strict_mode (enabled)
    proc memory_set_qword from Memory with checker, 80, 0                  Note: error_count
    proc memory_set_qword from Memory with checker, 88, 0                  Note: warning_count
    proc memory_set_qword from Memory with checker, 96, 0                  Note: type_count
    proc memory_set_qword from Memory with checker, 104, 0                 Note: inference_count

    Return checker
End Process

Process called "type_checker_destroy" takes checker as Integer returns Nothing:
    Note:
    Destroys type checker and frees all owned memory.

    Parameters:
    - checker: OWNED TypeChecker to destroy

    Side Effects:
    - Frees all OWNED type data
    - Destroys OWNED type registry
    - Destroys OWNED type cache
    - Frees OWNED TypeChecker structure

    Algorithm:
    1. Validate checker
    2. Destroy type_registry
    3. Destroy optional components if allocated
    4. Free TypeChecker structure
    :End Note

    If checker is equal to 0:
        Return
    End If

    Note: Get type_registry (offset 16)
    Let type_registry be proc memory_get_qword from Memory with checker, 16

    If type_registry is not equal to 0:
        proc destroy from HashTable with type_registry
    End If

    Note: Get type_cache (offset 24)
    Let type_cache be proc memory_get_qword from Memory with checker, 24

    If type_cache is not equal to 0:
        proc deallocate from Layout with type_cache
    End If

    Note: Free TypeChecker structure
    proc deallocate from Layout with checker

    Return
End Process

Process called "type_checker_register_basic_type" takes checker as Integer, type_name as String, type_kind as Integer, size_bytes as Integer, arena as Integer returns Integer:
    Note:
    Registers a basic type in the type system using arena-based operations.

    Parameters:
    - checker: OWNED TypeChecker reference
    - type_name: Name of the type
    - type_kind: Type kind constant (STACK)
    - size_bytes: Size of the type in bytes (STACK)
    - arena: Arena for temporary type operations (ARENA)

    Returns:
    - Integer: Type ID (STACK)

    Side Effects:
    - Uses ARENA for temporary type operations
    - Creates OWNED TypeInfo
    - Adds to OWNED type registry

    Algorithm:
    1. Validate inputs
    2. Increment type_count for new type ID
    3. Allocate TypeInfo structure (18 fields × 8 bytes = 144 bytes)
    4. Initialize type properties
    5. Add to type_registry
    6. Return type ID
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If type_name is equal to 0:
        Return 0
    End If

    Note: Get type_registry (offset 16)
    Let type_registry be proc memory_get_qword from Memory with checker, 16

    If type_registry is equal to 0:
        Return 0
    End If

    Note: Increment type_count (offset 96) for new type ID
    Let type_count be proc memory_get_qword from Memory with checker, 96
    Set type_count to type_count plus 1
    proc memory_set_qword from Memory with checker, 96, type_count

    Let type_id be type_count

    Note: Allocate TypeInfo (18 fields × 8 bytes = 144 bytes)
    Let type_info_size be 144
    Let type_info be proc allocate from Layout with type_info_size

    If type_info is equal to 0:
        Return 0
    End If

    Note: Duplicate type_name for owned storage
    Let name_copy be proc string_duplicate from StringCore with type_name

    Note: Initialize TypeInfo fields (MUST match TypeInfo struct definition lines 76-95)
    proc memory_set_qword from Memory with type_info, 0, type_id            Note: type_id
    proc memory_set_qword from Memory with type_info, 8, type_kind          Note: type_kind
    proc memory_set_qword from Memory with type_info, 16, name_copy         Note: type_name (OWNED String)
    proc memory_set_qword from Memory with type_info, 24, size_bytes        Note: size_bytes
    proc memory_set_qword from Memory with type_info, 32, 8                 Note: alignment (default 8-byte)
    proc memory_set_qword from Memory with type_info, 40, 0                 Note: is_mutable (false by default)
    proc memory_set_qword from Memory with type_info, 48, 0                 Note: is_owned (false by default)
    proc memory_set_qword from Memory with type_info, 56, 1                 Note: is_copyable (true by default)
    proc memory_set_qword from Memory with type_info, 64, 1                 Note: is_moveable (true by default)
    proc memory_set_qword from Memory with type_info, 72, 0                 Note: is_sendable (false by default)
    proc memory_set_qword from Memory with type_info, 80, 0                 Note: is_sync (false by default)
    proc memory_set_qword from Memory with type_info, 88, 0                 Note: generic_params (NULL)
    proc memory_set_qword from Memory with type_info, 96, 0                 Note: constraints (NULL)
    proc memory_set_qword from Memory with type_info, 104, 0                Note: methods (NULL)
    proc memory_set_qword from Memory with type_info, 112, 0                Note: fields (NULL)
    proc memory_set_qword from Memory with type_info, 120, 0                Note: parent_types (NULL)
    proc memory_set_qword from Memory with type_info, 128, 0                Note: trait_implementations (NULL)
    proc memory_set_qword from Memory with type_info, 136, 0                Note: ownership_info (NULL)

    Note: Add to type_registry (key: type_name, value: type_info)
    proc set from HashTable with type_registry, type_name, type_info

    Return type_id
End Process

Process called "type_checker_check_types" takes checker as Integer, ast_root as Integer, arena as Integer returns Integer:
    Note:
    Performs complete type checking on an AST using arena-based operations.

    Parameters:
    - checker: OWNED TypeChecker reference
    - ast_root: Root AST node to type check (OWNED)
    - arena: Arena for temporary type analysis (ARENA)

    Returns:
    - Integer: Type checking result (STACK) - 1=success, 0=failure

    Side Effects:
    - Uses ARENA for temporary type analysis
    - Recursively traverses AST
    - Updates type information in AST nodes
    - Reports type errors

    Algorithm:
    1. Validate inputs
    2. Get node type from AST
    3. Dispatch to appropriate checker based on node type
    4. Recursively check children
    5. Return success/failure
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If ast_root is equal to 0:
        Return 0
    End If

    Note: Get node_type (offset 0)
    Let node_type be proc memory_get_qword from Memory with ast_root, 0

    Note: Check if this is a statement or expression
    Note: Statements: 2000-2999, Expressions: 1000-1999, Declarations: 3000-3999

    Note: Handle expressions (1000-1999)
    If node_type is greater than or equal to 1000:
        If node_type is less than 2000:
            Let result be proc type_checker_check_expression with checker, ast_root, arena
            Return result
        End If
    End If

    Note: Handle statements (2000-2999)
    If node_type is greater than or equal to 2000:
        If node_type is less than 3000:
            Let result be proc type_checker_check_statement with checker, ast_root, arena
            Return result
        End If
    End If

    Note: Handle declarations (3000-3999) - recursively check children
    If node_type is greater than or equal to 3000:
        If node_type is less than 4000:
            Note: For declarations, check all children
            Let child_count be proc memory_get_qword from Memory with ast_root, 32

            Let index be 0
            Loop forever:
                If index is greater than or equal to child_count:
                    Break
                End If

                Let child be proc ast_node_get_child from AST with ast_root, index

                If child is not equal to 0:
                    Let result be proc type_checker_check_types with checker, child, arena
                    If result is equal to 0:
                        Return 0  Note: Child check failed
                    End If
                End If

                Set index to index plus 1
            End Loop

            Return 1
        End If
    End If

    Note: Unknown node type - just check children
    Let child_count be proc memory_get_qword from Memory with ast_root, 32

    Let index be 0
    Loop forever:
        If index is greater than or equal to child_count:
            Break
        End If

        Let child be proc ast_node_get_child from AST with ast_root, index

        If child is not equal to 0:
            Let result be proc type_checker_check_types with checker, child, arena
            If result is equal to 0:
                Return 0
            End If
        End If

        Set index to index plus 1
    End Loop

    Return 1
End Process

Process called "type_checker_validate_types" takes checker as Integer, arena as Integer returns Integer:
    Note:
    Validates all types and reports any issues using arena-based operations.

    Parameters:
    - checker: OWNED TypeChecker reference
    - arena: Arena for temporary validation data (ARENA)

    Returns:
    - Integer: Validation result (STACK) - 1=valid, 0=has issues

    Side Effects:
    - Uses ARENA for temporary validation data
    - No permanent memory allocation
    - Updates validation statistics

    Algorithm:
    1. Validate inputs
    2. Check error_count
    3. Return validation result
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    Note: Get error_count (offset 80)
    Let error_count be proc memory_get_qword from Memory with checker, 80

    Note: If no errors, validation passed
    If error_count is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "type_checker_check_expression" takes checker as Integer, expression as Integer, arena as Integer returns Integer:
    Note:
    Performs type checking on an expression using arena-based operations.

    Parameters:
    - checker: OWNED TypeChecker reference
    - expression: Expression AST node to check (OWNED)
    - arena: Arena for temporary type analysis (ARENA)

    Returns:
    - Integer: Type checking result (STACK) - 1=success, 0=failure

    Side Effects:
    - Uses ARENA for temporary type analysis
    - Updates type information in AST
    - Reports type errors

    Algorithm:
    1. Validate inputs
    2. Get node type from expression
    3. Dispatch to appropriate handler based on expression type
    4. Check operand types recursively
    5. Validate type compatibility
    6. Perform type inference if needed
    7. Return success/failure
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If expression is equal to 0:
        Return 0
    End If

    Note: Get node_type (offset 0)
    Let node_type be proc memory_get_qword from Memory with expression, 0

    Note: Get line and column for error reporting (offsets 8, 16)
    Let line be proc memory_get_qword from Memory with expression, 8
    Let column be proc memory_get_qword from Memory with expression, 16

    Note: AST_LITERAL = 1000 - literals have inherent types
    If node_type is equal to 1000:
        Note: Infer type from literal
        Let inferred_type be proc type_checker_infer_type with checker, expression, arena
        Return 1
    End If

    Note: AST_IDENTIFIER = 1001 - look up identifier type
    If node_type is equal to 1001:
        Note: Get identifier value (offset 40)
        Let identifier_name be proc memory_get_qword from Memory with expression, 40

        Note: Look up symbol in symbol table
        Let symbol_table be proc memory_get_qword from Memory with checker, 0
        Let symbol be proc symbol_table_lookup_symbol from SymbolTable with symbol_table, identifier_name, arena

        If symbol is equal to 0:
            proc type_checker_report_type_error with checker, 1, "Undefined identifier", line, column, arena
            Return 0
        End If

        Return 1
    End If

    Note: AST_BINARY_EXPRESSION = 1002 - check both operands and result type
    If node_type is equal to 1002:
        Note: Get left and right operands (offsets 88, 96 in BinaryExpressionNode)
        Let left be proc memory_get_qword from Memory with expression, 88
        Let right be proc memory_get_qword from Memory with expression, 96

        Note: Check left operand
        If left is not equal to 0:
            Let left_result be proc type_checker_check_expression with checker, left, arena
            If left_result is equal to 0:
                Return 0
            End If
        End If

        Note: Check right operand
        If right is not equal to 0:
            Let right_result be proc type_checker_check_expression with checker, right, arena
            If right_result is equal to 0:
                Return 0
            End If
        End If

        Return 1
    End If

    Note: AST_UNARY_EXPRESSION = 1003 - check operand
    If node_type is equal to 1003:
        Note: Get operand (typically first child)
        Let child_count be proc memory_get_qword from Memory with expression, 32

        If child_count is greater than 0:
            Let operand be proc ast_node_get_child from AST with expression, 0

            If operand is not equal to 0:
                Let result be proc type_checker_check_expression with checker, operand, arena
                Return result
            End If
        End If

        Return 1
    End If

    Note: AST_CALL_EXPRESSION = 1005 - check callee and arguments
    If node_type is equal to 1005:
        Note: Get callee and arguments (offsets 80, 88, 96 in CallExpressionNode)
        Let callee be proc memory_get_qword from Memory with expression, 80
        Let arguments be proc memory_get_qword from Memory with expression, 88
        Let argument_count be proc memory_get_qword from Memory with expression, 96

        Note: Check callee
        If callee is not equal to 0:
            Let callee_result be proc type_checker_check_expression with checker, callee, arena
            If callee_result is equal to 0:
                Return 0
            End If
        End If

        Note: Check all arguments
        If arguments is not equal to 0:
            Let arg_index be 0
            Loop forever:
                If arg_index is greater than or equal to argument_count:
                    Break
                End If

                Let arg be proc list_get from List with arguments, arg_index

                If arg is not equal to 0:
                    Let arg_result be proc type_checker_check_expression with checker, arg, arena
                    If arg_result is equal to 0:
                        Return 0
                    End If
                End If

                Set arg_index to arg_index plus 1
            End Loop
        End If

        Return 1
    End If

    Note: AST_INDEX_EXPRESSION = 1006 - check object and index
    If node_type is equal to 1006:
        Note: Get object and index (offsets in IndexExpressionNode)
        Let object be proc memory_get_qword from Memory with expression, 80
        Let index be proc memory_get_qword from Memory with expression, 88

        If object is not equal to 0:
            Let obj_result be proc type_checker_check_expression with checker, object, arena
            If obj_result is equal to 0:
                Return 0
            End If
        End If

        If index is not equal to 0:
            Let idx_result be proc type_checker_check_expression with checker, index, arena
            If idx_result is equal to 0:
                Return 0
            End If
        End If

        Return 1
    End If

    Note: AST_MEMBER_EXPRESSION = 1007 - check object
    If node_type is equal to 1007:
        Note: Get object (offset 80 in MemberExpressionNode)
        Let object be proc memory_get_qword from Memory with expression, 80

        If object is not equal to 0:
            Let result be proc type_checker_check_expression with checker, object, arena
            Return result
        End If

        Return 1
    End If

    Note: For all other expression types, recursively check children
    Let child_count be proc memory_get_qword from Memory with expression, 32

    Let index be 0
    Loop forever:
        If index is greater than or equal to child_count:
            Break
        End If

        Let child be proc ast_node_get_child from AST with expression, index

        If child is not equal to 0:
            Note: Get child node type
            Let child_node_type be proc memory_get_qword from Memory with child, 0

            Note: Only check if child is also an expression
            If child_node_type is greater than or equal to 1000:
                If child_node_type is less than 2000:
                    Let result be proc type_checker_check_expression with checker, child, arena
                    If result is equal to 0:
                        Return 0
                    End If
                End If
            End If
        End If

        Set index to index plus 1
    End Loop

    Return 1
End Process

Process called "type_checker_check_statement" takes checker as Integer, statement as Integer, arena as Integer returns Integer:
    Note:
    Performs type checking on a statement using arena-based operations.

    Parameters:
    - checker: OWNED TypeChecker reference
    - statement: Statement AST node to check (OWNED)
    - arena: Arena for temporary type analysis (ARENA)

    Returns:
    - Integer: Type checking result (STACK) - 1=success, 0=failure

    Algorithm:
    1. Validate inputs
    2. Get node type from statement
    3. Dispatch to appropriate handler based on statement type
    4. Check expressions within statement
    5. Validate type constraints
    6. Recursively check nested statements
    7. Return success/failure
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If statement is equal to 0:
        Return 0
    End If

    Note: Get node_type (offset 0)
    Let node_type be proc memory_get_qword from Memory with statement, 0

    Note: AST_LET_STATEMENT = 2000 - check initialization expression
    If node_type is equal to 2000:
        Note: Check children (variable and init expression)
        Let child_count be proc memory_get_qword from Memory with statement, 32

        Let index be 0
        Loop forever:
            If index is greater than or equal to child_count:
                Break
            End If

            Let child be proc ast_node_get_child from AST with statement, index

            If child is not equal to 0:
                Let child_type be proc memory_get_qword from Memory with child, 0

                Note: If child is an expression, check it
                If child_type is greater than or equal to 1000:
                    If child_type is less than 2000:
                        Let result be proc type_checker_check_expression with checker, child, arena
                        If result is equal to 0:
                            Return 0
                        End If
                    End If
                End If
            End If

            Set index to index plus 1
        End Loop

        Return 1
    End If

    Note: AST_SET_STATEMENT = 2001 - check assignment expression
    If node_type is equal to 2001:
        Note: Check children (lvalue and rvalue)
        Let child_count be proc memory_get_qword from Memory with statement, 32

        Let index be 0
        Loop forever:
            If index is greater than or equal to child_count:
                Break
            End If

            Let child be proc ast_node_get_child from AST with statement, index

            If child is not equal to 0:
                Let child_type be proc memory_get_qword from Memory with child, 0

                If child_type is greater than or equal to 1000:
                    If child_type is less than 2000:
                        Let result be proc type_checker_check_expression with checker, child, arena
                        If result is equal to 0:
                            Return 0
                        End If
                    End If
                End If
            End If

            Set index to index plus 1
        End Loop

        Return 1
    End If

    Note: AST_IF_STATEMENT = 2003 - check condition expression and branches
    If node_type is equal to 2003:
        Note: Check all children (condition + branches)
        Let child_count be proc memory_get_qword from Memory with statement, 32

        Let index be 0
        Loop forever:
            If index is greater than or equal to child_count:
                Break
            End If

            Let child be proc ast_node_get_child from AST with statement, index

            If child is not equal to 0:
                Let child_type be proc memory_get_qword from Memory with child, 0

                Note: Check expressions
                If child_type is greater than or equal to 1000:
                    If child_type is less than 2000:
                        Let result be proc type_checker_check_expression with checker, child, arena
                        If result is equal to 0:
                            Return 0
                        End If
                    End If
                End If

                Note: Check nested statements
                If child_type is greater than or equal to 2000:
                    If child_type is less than 3000:
                        Let result be proc type_checker_check_statement with checker, child, arena
                        If result is equal to 0:
                            Return 0
                        End If
                    End If
                End If
            End If

            Set index to index plus 1
        End Loop

        Return 1
    End If

    Note: AST_FOR_STATEMENT = 2007, AST_WHILE_STATEMENT = 2008, AST_LOOP_STATEMENT = 2009
    If node_type is greater than or equal to 2007:
        If node_type is less than or equal to 2009:
            Note: Check loop condition and body
            Let child_count be proc memory_get_qword from Memory with statement, 32

            Let index be 0
            Loop forever:
                If index is greater than or equal to child_count:
                    Break
                End If

                Let child be proc ast_node_get_child from AST with statement, index

                If child is not equal to 0:
                    Let child_type be proc memory_get_qword from Memory with child, 0

                    If child_type is greater than or equal to 1000:
                        If child_type is less than 2000:
                            Let result be proc type_checker_check_expression with checker, child, arena
                            If result is equal to 0:
                                Return 0
                            End If
                        End If
                    End If

                    If child_type is greater than or equal to 2000:
                        If child_type is less than 3000:
                            Let result be proc type_checker_check_statement with checker, child, arena
                            If result is equal to 0:
                                Return 0
                            End If
                        End If
                    End If
                End If

                Set index to index plus 1
            End Loop

            Return 1
        End If
    End If

    Note: AST_RETURN_STATEMENT = 2010 - check return expression
    If node_type is equal to 2010:
        Let child_count be proc memory_get_qword from Memory with statement, 32

        If child_count is greater than 0:
            Let return_expr be proc ast_node_get_child from AST with statement, 0

            If return_expr is not equal to 0:
                Let result be proc type_checker_check_expression with checker, return_expr, arena
                Return result
            End If
        End If

        Return 1
    End If

    Note: AST_MATCH_STATEMENT = 2005 - check match expression and arms
    If node_type is equal to 2005:
        Let child_count be proc memory_get_qword from Memory with statement, 32

        Let index be 0
        Loop forever:
            If index is greater than or equal to child_count:
                Break
            End If

            Let child be proc ast_node_get_child from AST with statement, index

            If child is not equal to 0:
                Let child_type be proc memory_get_qword from Memory with child, 0

                If child_type is greater than or equal to 1000:
                    If child_type is less than 2000:
                        Let result be proc type_checker_check_expression with checker, child, arena
                        If result is equal to 0:
                            Return 0
                        End If
                    End If
                End If

                If child_type is greater than or equal to 2000:
                    If child_type is less than 3000:
                        Let result be proc type_checker_check_statement with checker, child, arena
                        If result is equal to 0:
                            Return 0
                        End If
                    End If
                End If
            End If

            Set index to index plus 1
        End Loop

        Return 1
    End If

    Note: For all other statement types, recursively check children
    Let child_count be proc memory_get_qword from Memory with statement, 32

    Let index be 0
    Loop forever:
        If index is greater than or equal to child_count:
            Break
        End If

        Let child be proc ast_node_get_child from AST with statement, index

        If child is not equal to 0:
            Let child_type be proc memory_get_qword from Memory with child, 0

            Note: Check expressions
            If child_type is greater than or equal to 1000:
                If child_type is less than 2000:
                    Let result be proc type_checker_check_expression with checker, child, arena
                    If result is equal to 0:
                        Return 0
                    End If
                End If
            End If

            Note: Check statements
            If child_type is greater than or equal to 2000:
                If child_type is less than 3000:
                    Let result be proc type_checker_check_statement with checker, child, arena
                    If result is equal to 0:
                        Return 0
                    End If
                End If
            End If
        End If

        Set index to index plus 1
    End Loop

    Return 1
End Process

Process called "type_checker_infer_type" takes checker as Integer, expression as Integer, arena as Integer returns Integer:
    Note:
    Performs type inference on an expression using arena-based operations.

    Parameters:
    - checker: OWNED TypeChecker reference
    - expression: Expression to infer type for (OWNED)
    - arena: Arena for temporary inference operations (ARENA)

    Returns:
    - Integer: OWNED inferred TypeInfo or 0 on failure

    Algorithm:
    1. Validate inputs
    2. Increment inference_count
    3. Get expression node type
    4. Infer type based on expression category:
       - Literals: Extract type from literal value
       - Binary expressions: Infer from operand types
       - Call expressions: Infer from callee return type
       - Identifier expressions: Look up symbol type
       - Member/index expressions: Infer from object type
    5. Return inferred type
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If expression is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Increment inference_count (offset 104)
    Let inference_count be proc memory_get_qword from Memory with checker, 104
    Set inference_count to inference_count plus 1
    proc memory_set_qword from Memory with checker, 104, inference_count

    Note: Get expression node type (offset 0)
    Let node_type be proc memory_get_qword from Memory with expression, 0

    Note: Get symbol_table reference (offset 8)
    Let symbol_table be proc memory_get_qword from Memory with checker, 8

    Note: Handle AST_LITERAL (1000) - infer from literal value
    If node_type is equal to 1000:
        Note: Get literal type field (offset 24)
        Let literal_type be proc memory_get_qword from Memory with expression, 24

        Note: Return the literal's type directly
        Return literal_type
    End If

    Note: Handle AST_IDENTIFIER (1001) - look up symbol type
    If node_type is equal to 1001:
        Note: Get identifier name (offset 24)
        Let identifier_name be proc memory_get_qword from Memory with expression, 24

        If identifier_name is not equal to 0:
            Note: Look up symbol in symbol table
            Let symbol be proc symbol_table_lookup from SymbolTable with symbol_table, identifier_name

            If symbol is not equal to 0:
                Note: Get symbol type_info (offset 16)
                Let symbol_type be proc memory_get_qword from Memory with symbol, 16
                Return symbol_type
            End If
        End If

        Note: Symbol not found or identifier name is NULL
        Return 0
    End If

    Note: Handle AST_BINARY_EXPRESSION (1002) - infer from operands
    If node_type is equal to 1002:
        Note: Get left operand (offset 24)
        Let left_expr be proc memory_get_qword from Memory with expression, 24

        Note: Get right operand (offset 32)
        Let right_expr be proc memory_get_qword from Memory with expression, 32

        Note: Get operator (offset 40)
        Let operator be proc memory_get_qword from Memory with expression, 40

        Note: Infer left operand type
        Let left_type be 0
        If left_expr is not equal to 0:
            Set left_type to proc type_checker_infer_type with checker, left_expr, arena
        End If

        Note: Infer right operand type
        Let right_type be 0
        If right_expr is not equal to 0:
            Set right_type to proc type_checker_infer_type with checker, right_expr, arena
        End If

        Note: If both operands have types, infer result type
        If left_type is not equal to 0:
            If right_type is not equal to 0:
                Note: Check if types are compatible
                Let compatible be proc type_checker_check_compatibility with checker, left_type, right_type, arena

                If compatible is not equal to 0:
                    Note: Return left type (both are compatible, use left)
                    Return left_type
                End If
            End If
        End If

        Note: If left type available, return it
        If left_type is not equal to 0:
            Return left_type
        End If

        Note: Otherwise return right type (may be 0)
        Return right_type
    End If

    Note: Handle AST_UNARY_EXPRESSION (1003) - infer from operand
    If node_type is equal to 1003:
        Note: Get operand (offset 24)
        Let operand_expr be proc memory_get_qword from Memory with expression, 24

        If operand_expr is not equal to 0:
            Note: Infer operand type and return it
            Let operand_type be proc type_checker_infer_type with checker, operand_expr, arena
            Return operand_type
        End If

        Return 0
    End If

    Note: Handle AST_CALL_EXPRESSION (1005) - infer from callee return type
    If node_type is equal to 1005:
        Note: Get callee expression (offset 24)
        Let callee_expr be proc memory_get_qword from Memory with expression, 24

        If callee_expr is not equal to 0:
            Note: Infer callee type
            Let callee_type be proc type_checker_infer_type with checker, callee_expr, arena

            If callee_type is not equal to 0:
                Note: Get callee type_kind (offset 8)
                Let type_kind be proc memory_get_qword from Memory with callee_type, 8

                Note: Check if it's a function type (TYPE_FUNCTION = 7)
                If type_kind is equal to 7:
                    Note: Get function return type (offset 120)
                    Let return_type be proc memory_get_qword from Memory with callee_type, 120
                    Return return_type
                End If
            End If
        End If

        Return 0
    End If

    Note: Handle AST_INDEX_EXPRESSION (1006) - infer from object element type
    If node_type is equal to 1006:
        Note: Get object expression (offset 24)
        Let object_expr be proc memory_get_qword from Memory with expression, 24

        If object_expr is not equal to 0:
            Note: Infer object type
            Let object_type be proc type_checker_infer_type with checker, object_expr, arena

            If object_type is not equal to 0:
                Note: Get object type_kind (offset 8)
                Let type_kind be proc memory_get_qword from Memory with object_type, 8

                Note: Check if it's an array type (TYPE_ARRAY = 5)
                If type_kind is equal to 5:
                    Note: Get array element type (offset 104)
                    Let element_type be proc memory_get_qword from Memory with object_type, 104
                    Return element_type
                End If

                Note: Check if it's a list type (TYPE_LIST = 9)
                If type_kind is equal to 9:
                    Note: Get list element type (offset 104)
                    Let element_type be proc memory_get_qword from Memory with object_type, 104
                    Return element_type
                End If
            End If
        End If

        Return 0
    End If

    Note: Handle AST_MEMBER_EXPRESSION (1007) - infer from field type
    If node_type is equal to 1007:
        Note: Get object expression (offset 24)
        Let object_expr be proc memory_get_qword from Memory with expression, 24

        Note: Get member name (offset 32)
        Let member_name be proc memory_get_qword from Memory with expression, 32

        If object_expr is not equal to 0:
            If member_name is not equal to 0:
                Note: Infer object type
                Let object_type be proc type_checker_infer_type with checker, object_expr, arena

                If object_type is not equal to 0:
                    Note: Get object type_kind (offset 8)
                    Let type_kind be proc memory_get_qword from Memory with object_type, 8

                    Note: Check if it's a struct type (TYPE_STRUCT = 4)
                    If type_kind is equal to 4:
                        Note: Get struct fields hashtable (offset 96)
                        Let fields_hashtable be proc memory_get_qword from Memory with object_type, 96

                        If fields_hashtable is not equal to 0:
                            Note: Search hashtable for field by name
                            Note: Get bucket count (offset 0)
                            Let bucket_count be proc memory_get_qword from Memory with fields_hashtable, 0

                            If bucket_count is greater than 0:
                                Note: Get buckets array (offset 16)
                                Let buckets be proc memory_get_qword from Memory with fields_hashtable, 16

                                If buckets is not equal to 0:
                                    Note: Compute hash of member_name using DJB2
                                    Let hash be 5381
                                    Let name_index be 0

                                    Loop forever:
                                        Let char_value be proc memory_get_byte from Memory with member_name, name_index
                                        If char_value is equal to 0:
                                            Break
                                        End If
                                        Set hash to hash multiplied by 33
                                        Set hash to hash plus char_value
                                        Set name_index to name_index plus 1
                                    End Loop

                                    Note: Find bucket index
                                    Let bucket_index be hash modulo bucket_count
                                    Let bucket_offset be bucket_index multiplied by 8
                                    Let bucket_ptr be buckets plus bucket_offset
                                    Let bucket_head be proc memory_get_qword from Memory with bucket_ptr, 0

                                    Note: Search bucket chain for field
                                    Let current_entry be bucket_head

                                    Loop forever:
                                        If current_entry is equal to 0:
                                            Break
                                        End If

                                        Note: Get entry key (offset 0)
                                        Let entry_key be proc memory_get_qword from Memory with current_entry, 0

                                        If entry_key is not equal to 0:
                                            Note: Compare entry_key with member_name
                                            Let match be 1
                                            Let cmp_index be 0

                                            Loop forever:
                                                Let key_char be proc memory_get_byte from Memory with entry_key, cmp_index
                                                Let name_char be proc memory_get_byte from Memory with member_name, cmp_index

                                                If key_char is not equal to name_char:
                                                    Set match to 0
                                                    Break
                                                End If

                                                If key_char is equal to 0:
                                                    Break
                                                End If

                                                Set cmp_index to cmp_index plus 1
                                            End Loop

                                            If match is equal to 1:
                                                Note: Found field - get field type (offset 8)
                                                Let field_type be proc memory_get_qword from Memory with current_entry, 8
                                                Return field_type
                                            End If
                                        End If

                                        Note: Move to next entry (offset 16)
                                        Set current_entry to proc memory_get_qword from Memory with current_entry, 16
                                    End Loop
                                End If
                            End If
                        End If

                        Note: Field not found in struct
                        Return 0
                    End If
                End If
            End If
        End If

        Return 0
    End If

    Note: Unknown expression type - cannot infer
    Return 0
End Process

Process called "type_checker_check_compatibility" takes checker as Integer, source_type as Integer, target_type as Integer, arena as Integer returns Integer:
    Note:
    Checks type compatibility between two types using arena-based operations.

    Parameters:
    - checker: OWNED TypeChecker reference
    - source_type: Source type (OWNED)
    - target_type: Target type (OWNED)
    - arena: Arena for temporary compatibility analysis (ARENA)

    Returns:
    - Integer: Compatibility level (STACK)
      - COMPAT_EXACT (3): Exact type match
      - COMPAT_COERCE (2): Compatible with coercion (Integer -> Float)
      - COMPAT_SUBTYPE (1): Subtype relationship
      - COMPAT_INCOMPATIBLE (0): Incompatible types

    Algorithm:
    1. Validate inputs
    2. Check exact match (compare type_id)
    3. Check numeric coercion (Integer → Float)
    4. Check union type compatibility
    5. Check optional type compatibility
    6. Check subtype relationships
    7. Return compatibility level
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If source_type is equal to 0:
        Return 0
    End If

    If target_type is equal to 0:
        Return 0
    End If

    Note: Get source type_id (offset 0)
    Let source_id be proc memory_get_qword from Memory with source_type, 0

    Note: Get target type_id (offset 0)
    Let target_id be proc memory_get_qword from Memory with target_type, 0

    Note: COMPAT_EXACT (3): Check exact type match
    If source_id is equal to target_id:
        Return 3
    End If

    Note: Get source type_kind (offset 8)
    Let source_kind be proc memory_get_qword from Memory with source_type, 8

    Note: Get target type_kind (offset 8)
    Let target_kind be proc memory_get_qword from Memory with target_type, 8

    Note: COMPAT_COERCE (2): Check numeric coercion (Integer → Float)
    If source_kind is equal to 1:
        Note: Source is Integer (TYPE_INTEGER = 1)
        If target_kind is equal to 2:
            Note: Target is Float (TYPE_FLOAT = 2)
            Note: Integer can be coerced to Float
            Return 2
        End If
    End If

    Note: Check union type compatibility
    If target_kind is equal to 11:
        Note: Target is Union type (TYPE_UNION = 11)
        Note: Get union variant count (offset 112)
        Let variant_count be proc memory_get_qword from Memory with target_type, 112

        Note: Get union variants list (offset 104)
        Let variants be proc memory_get_qword from Memory with target_type, 104

        If variants is not equal to 0:
            Note: Check if source is compatible with any variant
            Let variant_index be 0
            Loop forever:
                If variant_index is greater than or equal to variant_count:
                    Break
                End If

                Note: Get variant type (each variant is 8 bytes)
                Let variant_offset be variant_index multiplied by 8
                Let variant_ptr be variants plus variant_offset
                Let variant_type be proc memory_get_qword from Memory with variant_ptr, 0

                If variant_type is not equal to 0:
                    Note: Recursively check compatibility with variant
                    Let variant_compat be proc type_checker_check_compatibility with checker, source_type, variant_type, arena

                    If variant_compat is greater than 0:
                        Note: Source is compatible with this variant
                        Return variant_compat
                    End If
                End If

                Set variant_index to variant_index plus 1
            End Loop
        End If
    End If

    Note: Check optional type compatibility
    If target_kind is equal to 10:
        Note: Target is Optional type (TYPE_OPTIONAL = 10)
        Note: Get wrapped type (offset 104)
        Let wrapped_type be proc memory_get_qword from Memory with target_type, 104

        If wrapped_type is not equal to 0:
            Note: Check if source is compatible with wrapped type
            Let wrapped_compat be proc type_checker_check_compatibility with checker, source_type, wrapped_type, arena

            If wrapped_compat is greater than 0:
                Note: Source is compatible with wrapped type
                Return wrapped_compat
            End If
        End If
    End If

    Note: Check if source is optional and target wants the wrapped type
    If source_kind is equal to 10:
        Note: Source is Optional type (TYPE_OPTIONAL = 10)
        Note: Get wrapped type (offset 104)
        Let wrapped_type be proc memory_get_qword from Memory with source_type, 104

        If wrapped_type is not equal to 0:
            Note: Check if wrapped type is compatible with target
            Let wrapped_compat be proc type_checker_check_compatibility with checker, wrapped_type, target_type, arena

            If wrapped_compat is greater than 0:
                Note: Wrapped type is compatible (requires unwrap)
                Return wrapped_compat
            End If
        End If
    End If

    Note: Check trait implementation (subtype relationship)
    If target_kind is equal to 8:
        Note: Target is Trait type (TYPE_TRAIT = 8)
        Note: Get source trait implementations list (offset 128)
        Let source_traits be proc memory_get_qword from Memory with source_type, 128

        If source_traits is not equal to 0:
            Note: Get target trait ID (offset 0)
            Let target_trait_id be proc memory_get_qword from Memory with target_type, 0

            Note: source_traits is a list of trait IDs (count at offset 0, array at offset 8)
            Let trait_count be proc memory_get_qword from Memory with source_traits, 0

            If trait_count is greater than 0:
                Note: Get trait array pointer (offset 8)
                Let trait_array be proc memory_get_qword from Memory with source_traits, 8

                If trait_array is not equal to 0:
                    Note: Iterate through source trait list
                    Let trait_index be 0

                    Loop forever:
                        If trait_index is greater than or equal to trait_count:
                            Break
                        End If

                        Note: Get trait ID at index (each ID is 8 bytes)
                        Let trait_offset be trait_index multiplied by 8
                        Let trait_ptr be trait_array plus trait_offset
                        Let trait_id be proc memory_get_qword from Memory with trait_ptr, 0

                        Note: Check if this trait matches target
                        If trait_id is equal to target_trait_id:
                            Note: Source implements target trait (subtype relationship)
                            Return 1
                        End If

                        Set trait_index to trait_index plus 1
                    End Loop
                End If
            End If

            Note: Target trait not found in source's implemented traits
            Return 0
        End If

        Note: Source has no trait implementations
        Return 0
    End If

    Note: Check pointer/reference compatibility
    If source_kind is equal to 6:
        Note: Source is Pointer type (TYPE_POINTER = 6)
        If target_kind is equal to 6:
            Note: Both are pointers - check pointee types
            Note: Get source pointee type (offset 104)
            Let source_pointee be proc memory_get_qword from Memory with source_type, 104

            Note: Get target pointee type (offset 104)
            Let target_pointee be proc memory_get_qword from Memory with target_type, 104

            If source_pointee is not equal to 0:
                If target_pointee is not equal to 0:
                    Note: Recursively check pointee compatibility
                    Let pointee_compat be proc type_checker_check_compatibility with checker, source_pointee, target_pointee, arena

                    If pointee_compat is greater than 0:
                        Note: Pointee types are compatible
                        Return pointee_compat
                    End If
                End If
            End If
        End If
    End If

    Note: Check array/list compatibility
    If source_kind is equal to 5:
        Note: Source is Array (TYPE_ARRAY = 5)
        If target_kind is equal to 5:
            Note: Both are arrays - check element types and sizes
            Note: Get source element type (offset 104)
            Let source_element be proc memory_get_qword from Memory with source_type, 104

            Note: Get target element type (offset 104)
            Let target_element be proc memory_get_qword from Memory with target_type, 104

            Note: Get source array size (offset 112)
            Let source_size be proc memory_get_qword from Memory with source_type, 112

            Note: Get target array size (offset 112)
            Let target_size be proc memory_get_qword from Memory with target_type, 112

            Note: Arrays must have same size
            If source_size is equal to target_size:
                If source_element is not equal to 0:
                    If target_element is not equal to 0:
                        Note: Check element type compatibility
                        Let element_compat be proc type_checker_check_compatibility with checker, source_element, target_element, arena

                        If element_compat is greater than 0:
                            Return element_compat
                        End If
                    End If
                End If
            End If
        End If
    End If

    Note: Check list compatibility
    If source_kind is equal to 9:
        Note: Source is List (TYPE_LIST = 9)
        If target_kind is equal to 9:
            Note: Both are lists - check element types
            Note: Get source element type (offset 104)
            Let source_element be proc memory_get_qword from Memory with source_type, 104

            Note: Get target element type (offset 104)
            Let target_element be proc memory_get_qword from Memory with target_type, 104

            If source_element is not equal to 0:
                If target_element is not equal to 0:
                    Note: Check element type compatibility
                    Let element_compat be proc type_checker_check_compatibility with checker, source_element, target_element, arena

                    If element_compat is greater than 0:
                        Return element_compat
                    End If
                End If
            End If
        End If
    End If

    Note: COMPAT_INCOMPATIBLE (0): Types are incompatible
    Return 0
End Process

Process called "type_checker_find_conversion" takes checker as Integer, source_type as Integer, target_type as Integer, arena as Integer returns Integer:
    Note:
    Finds a conversion path between types using arena-based operations.

    Parameters:
    - checker: OWNED TypeChecker reference
    - source_type: Source type (OWNED)
    - target_type: Target type (OWNED)
    - arena: Arena for temporary conversion analysis (ARENA)

    Returns:
    - Integer: Conversion kind (STACK)
      - CONVERT_NONE (0): No conversion possible
      - CONVERT_IDENTITY (1): No conversion needed (same type)
      - CONVERT_NUMERIC (2): Numeric conversion (Integer → Float)
      - CONVERT_UNWRAP (3): Optional unwrap (Optional[T] → T)
      - CONVERT_WRAP (4): Optional wrap (T → Optional[T])
      - CONVERT_CAST (5): Explicit cast required

    Algorithm:
    1. Validate inputs
    2. Check if already compatible (no conversion needed)
    3. Check for numeric conversions (Integer → Float)
    4. Check for optional wrapping/unwrapping
    5. Check for explicit cast possibilities
    6. Return conversion kind
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If source_type is equal to 0:
        Return 0
    End If

    If target_type is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: CONVERT_IDENTITY (1): Check if types are already compatible
    Let compat be proc type_checker_check_compatibility with checker, source_type, target_type, arena
    If compat is equal to 3:
        Note: Exact match - no conversion needed
        Return 1
    End If

    Note: Get source type_kind (offset 8)
    Let source_kind be proc memory_get_qword from Memory with source_type, 8

    Note: Get target type_kind (offset 8)
    Let target_kind be proc memory_get_qword from Memory with target_type, 8

    Note: CONVERT_NUMERIC (2): Check for numeric conversions
    If source_kind is equal to 1:
        Note: Source is Integer (TYPE_INTEGER = 1)
        If target_kind is equal to 2:
            Note: Target is Float (TYPE_FLOAT = 2)
            Note: Integer → Float conversion available
            Return 2
        End If
    End If

    Note: CONVERT_UNWRAP (3): Check for optional unwrapping
    If source_kind is equal to 10:
        Note: Source is Optional (TYPE_OPTIONAL = 10)
        Note: Get wrapped type (offset 104)
        Let wrapped_type be proc memory_get_qword from Memory with source_type, 104

        If wrapped_type is not equal to 0:
            Note: Check if wrapped type matches target
            Let wrapped_compat be proc type_checker_check_compatibility with checker, wrapped_type, target_type, arena

            If wrapped_compat is greater than 0:
                Note: Optional unwrap conversion available
                Return 3
            End If
        End If
    End If

    Note: CONVERT_WRAP (4): Check for optional wrapping
    If target_kind is equal to 10:
        Note: Target is Optional (TYPE_OPTIONAL = 10)
        Note: Get wrapped type (offset 104)
        Let wrapped_type be proc memory_get_qword from Memory with target_type, 104

        If wrapped_type is not equal to 0:
            Note: Check if source matches wrapped type
            Let source_compat be proc type_checker_check_compatibility with checker, source_type, wrapped_type, arena

            If source_compat is greater than 0:
                Note: Optional wrap conversion available
                Return 4
            End If
        End If
    End If

    Note: CONVERT_CAST (5): Check for explicit cast possibilities
    Note: Check numeric casts
    If source_kind is equal to 1:
        Note: Source is Integer
        If target_kind is equal to 1:
            Note: Both Integer - different sizes, explicit cast possible
            Return 5
        End If

        If target_kind is equal to 2:
            Note: Integer → Float explicit cast
            Return 5
        End If

        If target_kind is equal to 3:
            Note: Integer → Boolean explicit cast
            Return 5
        End If
    End If

    If source_kind is equal to 2:
        Note: Source is Float
        If target_kind is equal to 1:
            Note: Float → Integer explicit cast (truncation)
            Return 5
        End If

        If target_kind is equal to 2:
            Note: Both Float - different sizes, explicit cast possible
            Return 5
        End If
    End If

    If source_kind is equal to 3:
        Note: Source is Boolean
        If target_kind is equal to 1:
            Note: Boolean → Integer explicit cast
            Return 5
        End If
    End If

    Note: Check pointer casts
    If source_kind is equal to 6:
        Note: Source is Pointer
        If target_kind is equal to 6:
            Note: Pointer → Pointer explicit cast
            Return 5
        End If
    End If

    Note: Check enum/union conversions
    If source_kind is equal to 11:
        Note: Source is Union
        If target_kind is not equal to 11:
            Note: Union → Concrete type cast (pattern match required)
            Return 5
        End If
    End If

    Note: CONVERT_NONE (0): No conversion possible
    Return 0
End Process

Process called "type_checker_validate_generic_constraints" takes checker as Integer, generic_type as Integer, type_args as Integer, arena as Integer returns Integer:
    Note:
    Validates generic type constraints using arena-based operations.

    Parameters:
    - checker: OWNED TypeChecker reference
    - generic_type: Generic type to validate (OWNED)
    - type_args: Type arguments list (OWNED list of TypeInfo pointers)
    - arena: Arena for temporary constraint analysis (ARENA)

    Returns:
    - Integer: Validation result (STACK) - 1=valid, 0=invalid

    Algorithm:
    1. Validate inputs
    2. Get generic parameter count and constraints
    3. Get type argument count
    4. Validate argument count matches parameter count
    5. For each type argument:
       a. Get corresponding parameter constraints
       b. Validate argument satisfies all constraints
    6. Return validation result
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If generic_type is equal to 0:
        Return 0
    End If

    If type_args is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Get generic type_kind (offset 8)
    Let type_kind be proc memory_get_qword from Memory with generic_type, 8

    Note: Verify this is a generic type (TYPE_GENERIC = 12)
    If type_kind is not equal to 12:
        Note: Not a generic type - no validation needed
        Return 1
    End If

    Note: Get generic parameter count (offset 112)
    Let param_count be proc memory_get_qword from Memory with generic_type, 112

    Note: Get type argument count from type_args list
    Note: type_args list structure: first qword at offset 0 contains element count
    Let arg_count be proc memory_get_qword from Memory with type_args, 0

    Note: Validate argument count matches parameter count
    If arg_count is not equal to param_count:
        Note: Argument count mismatch
        Let line be 0
        Let column be 0
        Let error_msg be "Generic type argument count mismatch"
        proc type_checker_report_type_error from TypeChecker with checker, 4, error_msg, line, column, arena
        Return 0
    End If

    Note: Get generic constraints list (offset 120)
    Let constraints be proc memory_get_qword from Memory with generic_type, 120

    Note: If no constraints, validation succeeds
    If constraints is equal to 0:
        Return 1
    End If

    Note: Validate each type argument against its constraints
    Let arg_index be 0
    Loop forever:
        If arg_index is greater than or equal to arg_count:
            Break
        End If

        Note: Get type argument at index (offset 8 + arg_index * 8)
        Let arg_offset be 8 plus arg_index multiplied by 8
        Let arg_ptr be type_args plus arg_offset
        Let type_arg be proc memory_get_qword from Memory with arg_ptr, 0

        If type_arg is equal to 0:
            Note: Invalid type argument
            Let line be 0
            Let column be 0
            Let error_msg be "Invalid generic type argument"
            proc type_checker_report_type_error from TypeChecker with checker, 4, error_msg, line, column, arena
            Return 0
        End If

        Note: Get constraint for this parameter (offset 8 + arg_index * 8)
        Let constraint_offset be 8 plus arg_index multiplied by 8
        Let constraint_ptr be constraints plus constraint_offset
        Let constraint be proc memory_get_qword from Memory with constraint_ptr, 0

        If constraint is not equal to 0:
            Note: Get constraint type_kind (offset 8)
            Let constraint_kind be proc memory_get_qword from Memory with constraint, 8

            Note: Check if constraint is a trait (TYPE_TRAIT = 8)
            If constraint_kind is equal to 8:
                Note: Type argument must implement the trait
                Note: Get type argument's implemented traits list (offset 128)
                Let arg_traits be proc memory_get_qword from Memory with type_arg, 128

                If arg_traits is equal to 0:
                    Note: Type argument implements no traits
                    Let line be 0
                    Let column be 0
                    Let error_msg be "Generic type argument must implement required trait"
                    proc type_checker_report_type_error from TypeChecker with checker, 4, error_msg, line, column, arena
                    Return 0
                End If

                Note: Get constraint trait ID (offset 0)
                Let constraint_trait_id be proc memory_get_qword from Memory with constraint, 0

                Note: arg_traits is a list of trait IDs (count at offset 0, array at offset 8)
                Let trait_count be proc memory_get_qword from Memory with arg_traits, 0
                Let trait_array be proc memory_get_qword from Memory with arg_traits, 8

                Note: Search for constraint trait in arg_traits list
                Let trait_found be 0

                If trait_array is not equal to 0:
                    Let trait_index be 0

                    Loop forever:
                        If trait_index is greater than or equal to trait_count:
                            Break
                        End If

                        Note: Get trait ID at index (each ID is 8 bytes)
                        Let trait_offset be trait_index multiplied by 8
                        Let trait_ptr be trait_array plus trait_offset
                        Let trait_id be proc memory_get_qword from Memory with trait_ptr, 0

                        If trait_id is equal to constraint_trait_id:
                            Set trait_found to 1
                            Break
                        End If

                        Set trait_index to trait_index plus 1
                    End Loop
                End If

                If trait_found is equal to 0:
                    Note: Required trait not implemented
                    Let line be 0
                    Let column be 0
                    Let error_msg be "Generic type argument does not implement required trait"
                    proc type_checker_report_type_error from TypeChecker with checker, 4, error_msg, line, column, arena
                    Return 0
                End If
            End If

            Note: Check if constraint is a type bound
            If constraint_kind is not equal to 8:
                Note: Type argument must be compatible with constraint type
                Let compat be proc type_checker_check_compatibility with checker, type_arg, constraint, arena

                If compat is equal to 0:
                    Note: Type argument doesn't satisfy constraint
                    Let line be 0
                    Let column be 0
                    Let error_msg be "Generic type argument violates constraint"
                    proc type_checker_report_type_error from TypeChecker with checker, 4, error_msg, line, column, arena
                    Return 0
                End If
            End If
        End If

        Set arg_index to arg_index plus 1
    End Loop

    Note: All constraints satisfied
    Return 1
End Process

Process called "type_checker_resolve_trait_method" takes checker as Integer, trait_type as Integer, method_name as String, arena as Integer returns Integer:
    Note:
    Resolves a trait method using arena-based operations.

    Parameters:
    - checker: OWNED TypeChecker reference
    - trait_type: Trait type (OWNED)
    - method_name: Method name to resolve
    - arena: Arena for temporary method resolution (ARENA)

    Returns:
    - Integer: OWNED method TypeInfo or 0 if not found

    Algorithm:
    1. Validate inputs
    2. Verify trait_type is actually a trait
    3. Get trait methods hashtable
    4. Compute hash of method_name
    5. Find bucket in hashtable
    6. Search bucket chain for matching method
    7. Return method TypeInfo if found
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If trait_type is equal to 0:
        Return 0
    End If

    If method_name is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Get trait type_kind (offset 8)
    Let type_kind be proc memory_get_qword from Memory with trait_type, 8

    Note: Verify this is a trait type (TYPE_TRAIT = 8)
    If type_kind is not equal to 8:
        Note: Not a trait type - cannot resolve methods
        Return 0
    End If

    Note: Get trait methods hashtable (offset 136)
    Let methods_hashtable be proc memory_get_qword from Memory with trait_type, 136

    If methods_hashtable is equal to 0:
        Note: No methods defined in trait
        Return 0
    End If

    Note: Hashtable structure (from common pattern):
    Note: Offset 0: bucket_count (Integer)
    Note: Offset 8: size (Integer)
    Note: Offset 16: buckets (Pointer to array of bucket heads)

    Note: Get bucket count (offset 0)
    Let bucket_count be proc memory_get_qword from Memory with methods_hashtable, 0

    If bucket_count is equal to 0:
        Note: Empty hashtable
        Return 0
    End If

    Note: Get buckets array (offset 16)
    Let buckets be proc memory_get_qword from Memory with methods_hashtable, 16

    If buckets is equal to 0:
        Note: No buckets allocated
        Return 0
    End If

    Note: Compute hash of method_name using DJB2 algorithm
    Let hash be 5381
    Let name_ptr be method_name
    Let name_index be 0

    Loop forever:
        Note: Get character at current position
        Let char_value be proc memory_get_byte from Memory with name_ptr, name_index

        Note: Break on null terminator
        If char_value is equal to 0:
            Break
        End If

        Note: DJB2: hash = hash * 33 + char
        Set hash to hash multiplied by 33
        Set hash to hash plus char_value
        Set name_index to name_index plus 1
    End Loop

    Note: Find bucket index (hash modulo bucket_count)
    Let bucket_index be hash modulo bucket_count

    Note: Get bucket head (each bucket pointer is 8 bytes)
    Let bucket_offset be bucket_index multiplied by 8
    Let bucket_ptr be buckets plus bucket_offset
    Let bucket_head be proc memory_get_qword from Memory with bucket_ptr, 0

    Note: Search bucket chain
    Let current_entry be bucket_head

    Loop forever:
        If current_entry is equal to 0:
            Note: End of chain - method not found
            Break
        End If

        Note: Entry structure (typical pattern):
        Note: Offset 0: key (String pointer)
        Note: Offset 8: value (TypeInfo pointer)
        Note: Offset 16: next (Entry pointer)

        Note: Get entry key (offset 0)
        Let entry_key be proc memory_get_qword from Memory with current_entry, 0

        If entry_key is not equal to 0:
            Note: Compare entry_key with method_name
            Let match be 1
            Let cmp_index be 0

            Loop forever:
                Let key_char be proc memory_get_byte from Memory with entry_key, cmp_index
                Let name_char be proc memory_get_byte from Memory with method_name, cmp_index

                If key_char is not equal to name_char:
                    Set match to 0
                    Break
                End If

                If key_char is equal to 0:
                    Note: Both strings ended - match found
                    Break
                End If

                Set cmp_index to cmp_index plus 1
            End Loop

            If match is equal to 1:
                Note: Found matching method - get value (offset 8)
                Let method_info be proc memory_get_qword from Memory with current_entry, 8
                Return method_info
            End If
        End If

        Note: Move to next entry in chain (offset 16)
        Set current_entry to proc memory_get_qword from Memory with current_entry, 16
    End Loop

    Note: Method not found in trait
    Return 0
End Process

Process called "type_checker_get_type_statistics" takes checker as Integer, arena as Integer returns Integer:
    Note:
    Gets type checking statistics using arena-based operations.

    Parameters:
    - checker: OWNED TypeChecker reference
    - arena: Arena for temporary statistics (ARENA)

    Returns:
    - Integer: ARENA pointer to statistics structure

    Algorithm:
    1. Validate inputs
    2. Allocate statistics (5 fields × 8 = 40 bytes)
    3. Populate counts
    4. Return statistics
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Allocate statistics (5 fields × 8 bytes = 40 bytes)
    Let stats_size be 40
    Let stats be proc allocate from Layout with stats_size

    If stats is equal to 0:
        Return 0
    End If

    Note: Get counts
    Let type_count be proc memory_get_qword from Memory with checker, 96
    Let inference_count be proc memory_get_qword from Memory with checker, 104
    Let error_count be proc memory_get_qword from Memory with checker, 80
    Let warning_count be proc memory_get_qword from Memory with checker, 88

    Note: Populate statistics
    proc memory_set_qword from Memory with stats, 0, type_count
    proc memory_set_qword from Memory with stats, 8, inference_count
    proc memory_set_qword from Memory with stats, 16, error_count
    proc memory_set_qword from Memory with stats, 24, warning_count
    proc memory_set_qword from Memory with stats, 32, 0

    Return stats
End Process

Process called "type_checker_report_type_error" takes checker as Integer, error_type as Integer, message as String, line as Integer, column as Integer, arena as Integer returns Nothing:
    Note:
    Reports a type error using arena-based operations.

    Parameters:
    - checker: OWNED TypeChecker reference
    - error_type: Type of error (STACK)
    - message: Error message
    - line: Error line (STACK)
    - column: Error column (STACK)
    - arena: Arena for temporary error data (ARENA)

    Side Effects:
    - Uses ARENA for temporary error data
    - Updates error statistics

    Algorithm:
    1. Validate inputs
    2. Increment error_count
    :End Note

    If checker is equal to 0:
        Return
    End If

    Note: Increment error_count (offset 80)
    Let error_count be proc memory_get_qword from Memory with checker, 80
    Set error_count to error_count plus 1
    proc memory_set_qword from Memory with checker, 80, error_count

    Return
End Process