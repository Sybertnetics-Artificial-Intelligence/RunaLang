Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file implements scope analysis for variable and symbol scope management.

This file performs the following tasks:
- Analyze variable and symbol scope boundaries and visibility with memory-efficient operations
- Handle scope nesting and scope resolution with arena-based temporary analysis
- Process scope-based symbol lookup and name resolution with ownership-aware operations
- Manage scope lifetime and scope cleanup with deterministic memory management

This file is essential because of the following reasons:
- Scope analysis ensures proper variable and symbol visibility
- Proper scope management prevents naming conflicts and scope errors
- Scope resolution enables accurate symbol lookup and name binding
- Memory-efficient scope analysis enables scalable semantic analysis

This file consists of the following functions/features/operation types:
- Scope boundary analysis and scope nesting management with ownership tracking
- Symbol scope resolution and name lookup with arena-based temporary operations
- Scope lifetime tracking and scope cleanup with deterministic memory management
- Scope-based symbol visibility and access control with ownership validation
:End Note

Import "compiler/frontend/semantic/symbol_table.runa" as SymbolTable
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/primitives/collections/stack.runa" as Stack
Import "compiler/frontend/primitives/collections/list.runa" as List
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
Import "compiler/frontend/parsing/ast.runa" as AST

Constant SCOPE_TYPE_GLOBAL as Integer is 1
Constant SCOPE_TYPE_MODULE as Integer is 2
Constant SCOPE_TYPE_FUNCTION as Integer is 3
Constant SCOPE_TYPE_BLOCK as Integer is 4
Constant SCOPE_TYPE_LOOP as Integer is 5
Constant SCOPE_TYPE_MATCH as Integer is 6
Constant SCOPE_TYPE_TRY as Integer is 7
Constant SCOPE_TYPE_CATCH as Integer is 8

Constant SCOPE_VISIBILITY_PUBLIC as Integer is 1
Constant SCOPE_VISIBILITY_PRIVATE as Integer is 2
Constant SCOPE_VISIBILITY_PROTECTED as Integer is 3
Constant SCOPE_VISIBILITY_INTERNAL as Integer is 4

Constant SCOPE_STATE_ACTIVE as Integer is 1
Constant SCOPE_STATE_INACTIVE as Integer is 2
Constant SCOPE_STATE_DESTROYED as Integer is 3

Type called "ScopeAnalyzer":
    symbol_table as Integer          Note: OWNED - symbol table reference
    scope_stack as Integer           Note: OWNED - scope nesting stack
    current_scope as Integer          Note: STACK - current scope ID
    scope_count as Integer            Note: STACK - total scope count
    depth as Integer                  Note: STACK - current nesting depth
    arena as Integer                  Note: OWNED - arena for temporary analysis
    scope_registry as Integer         Note: OWNED - scope registry
    visibility_rules as Integer       Note: OWNED - visibility rule system
    lifetime_tracker as Integer       Note: OWNED - scope lifetime tracker
    error_handler as Integer          Note: OWNED - error reporting system
    debug_logger as Integer           Note: OWNED - debug logging system
End Type

Type called "ScopeContext":
    scope_id as Integer              Note: STACK - unique scope identifier (offset 0)
    parent_scope as Integer          Note: STACK - parent scope ID (offset 8)
    scope_type as Integer            Note: STACK - scope type constant (offset 16)
    depth as Integer                 Note: STACK - nesting depth (offset 24)
    start_line as Integer            Note: STACK - scope start line (offset 32)
    start_column as Integer          Note: STACK - scope start column (offset 40)
    end_line as Integer              Note: STACK - scope end line (offset 48)
    end_column as Integer            Note: STACK - scope end column (offset 56)
End Type

Type called "ScopeBoundary":
    boundary_type as Integer          Note: STACK - boundary type constant
    scope_id as Integer              Note: STACK - associated scope ID
    line_number as Integer            Note: STACK - boundary line
    column_number as Integer          Note: STACK - boundary column
    is_entry as Integer               Note: STACK - entry boundary flag
    is_exit as Integer                Note: STACK - exit boundary flag
    boundary_symbol as Integer        Note: OWNED - boundary symbol reference
End Type

Type called "VisibilityRule":
    rule_type as Integer              Note: STACK - rule type constant
    source_scope as Integer           Note: STACK - source scope ID
    target_scope as Integer           Note: STACK - target scope ID
    visibility_level as Integer       Note: STACK - visibility level
    is_inherited as Integer           Note: STACK - inheritance flag
    is_exported as Integer            Note: STACK - export flag
End Type

Process called "scope_analyzer_create" takes symbol_table as Integer, arena as Integer returns Integer:
    Note:
    Creates a new scope analyzer with proper memory management.

    Parameters:
    - symbol_table: OWNED SymbolTable reference
    - arena: Arena for temporary scope analysis (ARENA)

    Returns:
    - Integer: Pointer to OWNED ScopeAnalyzer structure

    Side Effects:
    - Allocates OWNED ScopeAnalyzer structure
    - Initializes OWNED scope stack
    - Sets up OWNED scope registry
    - Initializes OWNED visibility rules system

    Algorithm:
    1. Allocate OWNED ScopeAnalyzer structure (11 fields × 8 bytes = 88 bytes)
    2. Store OWNED SymbolTable reference
    3. Initialize OWNED scope stack
    4. Initialize all counters and references
    5. Return OWNED ScopeAnalyzer pointer
    :End Note

    If symbol_table is equal to 0:
        Return 0
    End If

    Note: Allocate ScopeAnalyzer structure (11 fields × 8 bytes = 88 bytes)
    Let analyzer_size be 88
    Let analyzer be proc allocate from Layout with analyzer_size

    If analyzer is equal to 0:
        Return 0
    End If

    Note: Create scope stack
    Let scope_stack be proc stack_create from Stack

    If scope_stack is equal to 0:
        proc deallocate from Layout with analyzer
        Return 0
    End If

    Note: Initialize ScopeAnalyzer fields
    proc memory_set_qword from Memory with analyzer, 0, symbol_table      Note: symbol_table
    proc memory_set_qword from Memory with analyzer, 8, scope_stack       Note: scope_stack
    proc memory_set_qword from Memory with analyzer, 16, 0                Note: current_scope (global = 0)
    proc memory_set_qword from Memory with analyzer, 24, 0                Note: scope_depth
    proc memory_set_qword from Memory with analyzer, 32, arena            Note: arena reference
    proc memory_set_qword from Memory with analyzer, 40, 0                Note: visibility_rules (NULL)
    proc memory_set_qword from Memory with analyzer, 48, 0                Note: scope_count
    proc memory_set_qword from Memory with analyzer, 56, 0                Note: symbol_resolution_count
    proc memory_set_qword from Memory with analyzer, 64, 0                Note: visibility_check_count
    proc memory_set_qword from Memory with analyzer, 72, 0                Note: error_handler (NULL)
    proc memory_set_qword from Memory with analyzer, 80, 0                Note: debug_logger (NULL)

    Return analyzer
End Process

Process called "scope_analyzer_destroy" takes analyzer as Integer returns Nothing:
    Note:
    Destroys scope analyzer and frees all owned memory.

    Parameters:
    - analyzer: OWNED ScopeAnalyzer to destroy

    Side Effects:
    - Frees all OWNED scope data
    - Destroys OWNED scope stack
    - Destroys OWNED scope registry
    - Frees OWNED ScopeAnalyzer structure

    Algorithm:
    1. Validate analyzer pointer
    2. Destroy OWNED scope stack
    3. Destroy optional visibility_rules if allocated
    4. Free OWNED ScopeAnalyzer structure
    :End Note

    If analyzer is equal to 0:
        Return
    End If

    Note: Get scope_stack (offset 8)
    Let scope_stack be proc memory_get_qword from Memory with analyzer, 8

    Note: Destroy scope stack if present
    If scope_stack is not equal to 0:
        proc stack_destroy from Stack with scope_stack
    End If

    Note: Get visibility_rules (offset 40)
    Let visibility_rules be proc memory_get_qword from Memory with analyzer, 40

    Note: Destroy visibility rules if allocated
    If visibility_rules is not equal to 0:
        proc deallocate from Layout with visibility_rules
    End If

    Note: Free ScopeAnalyzer structure
    proc deallocate from Layout with analyzer

    Return
End Process

Process called "scope_analyzer_analyze_scopes" takes analyzer as Integer, ast_root as Integer, arena as Integer returns Integer:
    Note:
    Performs complete scope analysis on AST with proper scope tracking.

    Parameters:
    - analyzer: OWNED ScopeAnalyzer reference
    - ast_root: Root AST node to analyze (OWNED)
    - arena: Arena for temporary analysis operations (ARENA)

    Returns:
    - Integer: Analysis result (STACK)
            1 = success, 0 = failure

    Side Effects:
    - Traverses entire AST
    - Creates and manages scopes
    - Populates symbol table with scope information
    - Reports scope-related errors

    Algorithm:
    1. Validate inputs
    2. Enter global scope
    3. Recursively analyze AST nodes:
       - For scope-creating nodes (functions, blocks, loops):
         a. Enter new scope
         b. Analyze children
         c. Exit scope
       - For symbol declarations:
         a. Add to symbol table in current scope
         b. Check for shadowing
       - For symbol references:
         a. Resolve symbol
         b. Check visibility
    4. Exit global scope
    5. Validate scope integrity
    6. Return success/failure
    :End Note

    If analyzer is equal to 0:
        Return 0
    End If

    If ast_root is equal to 0:
        Return 0
    End If

    Note: Enter global scope
    Let global_scope be proc scope_analyzer_enter_scope with analyzer, 1, 0, 0  Note: SCOPE_TYPE_GLOBAL

    If global_scope is equal to 0:
        Return 0
    End If

    Note: Analyze the AST recursively
    Let result be proc scope_analyzer_analyze_ast_scope with analyzer, ast_root, arena

    Note: Exit global scope
    proc scope_analyzer_exit_scope with analyzer

    Note: Validate scope integrity
    Let integrity be proc scope_analyzer_validate_scopes with analyzer, arena

    If integrity is equal to 0:
        Return 0  Note: Scope integrity validation failed
    End If

    Return result
End Process

Process called "scope_analyzer_enter_scope" takes analyzer as Integer, scope_type as Integer, start_line as Integer, start_column as Integer returns Integer:
    Note:
    Enters a new scope with proper scope tracking and memory management.

    Parameters:
    - analyzer: OWNED ScopeAnalyzer reference
    - scope_type: Type of scope being entered (STACK)
    - start_line: Line where scope begins (STACK)
    - start_column: Column where scope begins (STACK)

    Returns:
    - Integer: New scope ID (STACK)

    Side Effects:
    - Increments scope nesting depth
    - Creates OWNED ScopeContext
    - Pushes scope to OWNED scope stack
    - Updates scope registry

    Algorithm:
    1. Get current scope as parent
    2. Increment scope_count to get new ID
    3. Allocate ScopeContext structure
    4. Initialize fields
    5. Push to scope stack
    6. Update current_scope and depth
    7. Return new scope ID
    :End Note

    If analyzer is equal to 0:
        Return 0
    End If

    Note: Get scope stack
    Let scope_stack be proc memory_get_qword from Memory with analyzer, 8

    If scope_stack is equal to 0:
        Return 0
    End If

    Note: Get current scope as parent (offset 16)
    Let parent_scope be proc memory_get_qword from Memory with analyzer, 16

    Note: Get and increment scope_count (offset 48)
    Let scope_count be proc memory_get_qword from Memory with analyzer, 48
    Set scope_count to scope_count plus 1
    proc memory_set_qword from Memory with analyzer, 48, scope_count

    Let new_scope_id be scope_count

    Note: Get current depth (offset 24)
    Let current_depth be proc memory_get_qword from Memory with analyzer, 24

    Note: Allocate ScopeContext (8 fields × 8 bytes = 64 bytes)
    Let context_size be 64
    Let context be proc allocate from Layout with context_size

    If context is equal to 0:
        Return 0
    End If

    Note: Initialize ScopeContext fields
    proc memory_set_qword from Memory with context, 0, new_scope_id      Note: scope_id (offset 0)
    proc memory_set_qword from Memory with context, 8, parent_scope      Note: parent_scope (offset 8)
    proc memory_set_qword from Memory with context, 16, scope_type       Note: scope_type (offset 16)
    proc memory_set_qword from Memory with context, 24, current_depth    Note: depth (offset 24)
    proc memory_set_qword from Memory with context, 32, start_line       Note: start_line (offset 32)
    proc memory_set_qword from Memory with context, 40, start_column     Note: start_column (offset 40)
    proc memory_set_qword from Memory with context, 48, 0                Note: end_line (offset 48, unknown yet)
    proc memory_set_qword from Memory with context, 56, 0                Note: end_column (offset 56, unknown yet)

    Note: Push context onto stack
    Let push_result be proc stack_push from Stack with scope_stack, context

    If push_result is equal to 0:
        proc deallocate from Layout with context
        Return 0
    End If

    Note: Update current_scope (offset 16)
    proc memory_set_qword from Memory with analyzer, 16, new_scope_id

    Note: Increment scope_depth (offset 24)
    Set current_depth to current_depth plus 1
    proc memory_set_qword from Memory with analyzer, 24, current_depth

    Note: Also tell symbol_table to enter scope
    Let symbol_table be proc memory_get_qword from Memory with analyzer, 0
    If symbol_table is not equal to 0:
        proc symbol_table_enter_scope from SymbolTable with symbol_table, scope_type, start_line
    End If

    Return new_scope_id
End Process

Process called "scope_analyzer_exit_scope" takes analyzer as Integer returns Nothing:
    Note:
    Exits current scope and performs cleanup with proper memory management.

    Parameters:
    - analyzer: OWNED ScopeAnalyzer reference

    Side Effects:
    - Decrements scope nesting depth
    - Pops scope from OWNED scope stack
    - Cleans up scope-specific data
    - Updates scope registry

    Algorithm:
    1. Get scope stack
    2. Pop current scope context
    3. Get parent scope from context
    4. Update current_scope to parent
    5. Decrement depth
    6. Free context
    7. Tell symbol_table to exit scope
    :End Note

    If analyzer is equal to 0:
        Return
    End If

    Note: Get scope stack
    Let scope_stack be proc memory_get_qword from Memory with analyzer, 8

    If scope_stack is equal to 0:
        Return
    End If

    Note: Pop current scope context
    Let context be proc stack_pop from Stack with scope_stack

    If context is equal to 0:
        Return  Note: No scope to exit
    End If

    Note: Get parent_scope from context (offset 8)
    Let parent_scope be proc memory_get_qword from Memory with context, 8

    Note: Update current_scope (offset 16)
    proc memory_set_qword from Memory with analyzer, 16, parent_scope

    Note: Decrement scope_depth (offset 24)
    Let depth be proc memory_get_qword from Memory with analyzer, 24
    If depth is greater than 0:
        Set depth to depth minus 1
        proc memory_set_qword from Memory with analyzer, 24, depth
    End If

    Note: Free context
    proc deallocate from Layout with context

    Note: Tell symbol_table to exit scope
    Let symbol_table be proc memory_get_qword from Memory with analyzer, 0
    If symbol_table is not equal to 0:
        proc symbol_table_exit_scope from SymbolTable with symbol_table
    End If

    Return
End Process

Process called "scope_analyzer_get_current_scope" takes analyzer as Integer returns Integer:
    Note:
    Gets the current scope ID.

    Parameters:
    - analyzer: OWNED ScopeAnalyzer reference

    Returns:
    - Integer: Current scope ID (STACK)

    Algorithm:
    1. Get current_scope field (offset 16)
    2. Return scope ID
    :End Note

    If analyzer is equal to 0:
        Return 0
    End If

    Note: Get current_scope (offset 16)
    Let current_scope be proc memory_get_qword from Memory with analyzer, 16

    Return current_scope
End Process

Process called "scope_analyzer_get_scope_depth" takes analyzer as Integer returns Integer:
    Note:
    Gets current scope nesting depth.

    Parameters:
    - analyzer: OWNED ScopeAnalyzer reference

    Returns:
    - Integer: Current scope depth (STACK)

    Algorithm:
    1. Get scope_depth field (offset 24)
    2. Return depth
    :End Note

    If analyzer is equal to 0:
        Return 0
    End If

    Note: Get scope_depth (offset 24)
    Let scope_depth be proc memory_get_qword from Memory with analyzer, 24

    Return scope_depth
End Process

Process called "scope_analyzer_find_symbol_in_scope" takes analyzer as Integer, symbol_name as String, scope_id as Integer, arena as Integer returns Integer:
    Note:
    Finds a symbol in a specific scope using arena-based operations.

    Parameters:
    - analyzer: OWNED ScopeAnalyzer reference
    - symbol_name: Name of symbol to find
    - scope_id: Scope ID to search (STACK)
    - arena: Arena for temporary search operations (ARENA)

    Returns:
    - Integer: Symbol pointer or 0 if not found

    Side Effects:
    - Uses ARENA for temporary search operations
    - No permanent memory allocation

    Algorithm:
    1. Get symbol_table
    2. Look up symbol using symbol_table
    3. Increment resolution count
    4. Return symbol or 0
    :End Note

    If analyzer is equal to 0:
        Return 0
    End If

    If symbol_name is equal to 0:
        Return 0
    End If

    Note: Get symbol_table (offset 0)
    Let symbol_table be proc memory_get_qword from Memory with analyzer, 0

    If symbol_table is equal to 0:
        Return 0
    End If

    Note: Look up symbol
    Let symbol be proc symbol_table_lookup_symbol from SymbolTable with symbol_table, symbol_name, arena

    Note: Increment symbol_resolution_count (offset 56)
    Let resolution_count be proc memory_get_qword from Memory with analyzer, 56
    Set resolution_count to resolution_count plus 1
    proc memory_set_qword from Memory with analyzer, 56, resolution_count

    Return symbol
End Process

Process called "scope_analyzer_resolve_name" takes analyzer as Integer, name as String, arena as Integer returns Integer:
    Note:
    Resolves a name by searching through scope hierarchy using arena-based operations.

    Parameters:
    - analyzer: OWNED ScopeAnalyzer reference
    - name: Name to resolve
    - arena: Arena for temporary resolution operations (ARENA)

    Returns:
    - Integer: Symbol pointer or 0 if not found

    Side Effects:
    - Uses ARENA for temporary resolution operations
    - No permanent memory allocation
    - Increments resolution statistics

    Algorithm:
    1. Validate inputs
    2. Get symbol_table from analyzer
    3. Look up symbol using symbol_table_lookup_symbol (handles scope traversal)
    4. Increment resolution count for statistics
    5. Return symbol pointer or 0 if not found
    :End Note

    If analyzer is equal to 0:
        Return 0
    End If

    If name is equal to 0:
        Return 0
    End If

    Note: Get symbol_table (offset 0)
    Let symbol_table be proc memory_get_qword from Memory with analyzer, 0

    If symbol_table is equal to 0:
        Return 0
    End If

    Note: Look up symbol (symbol_table handles scope hierarchy traversal)
    Let symbol be proc symbol_table_lookup_symbol from SymbolTable with symbol_table, name, arena

    Note: Increment symbol_resolution_count (offset 56)
    Let resolution_count be proc memory_get_qword from Memory with analyzer, 56
    Set resolution_count to resolution_count plus 1
    proc memory_set_qword from Memory with analyzer, 56, resolution_count

    Return symbol
End Process

Process called "scope_analyzer_check_shadowing" takes analyzer as Integer, name as String, current_scope as Integer, arena as Integer returns Integer:
    Note:
    Checks if a symbol declaration would shadow an existing symbol.

    Parameters:
    - analyzer: OWNED ScopeAnalyzer reference
    - name: Name being declared
    - current_scope: Scope where declaration occurs (STACK)
    - arena: Arena for temporary shadow check operations (ARENA)

    Returns:
    - Integer: Shadowing check result (STACK)
            0 = no shadowing (safe to declare)
            1 = shadows symbol in parent scope (warning)
            2 = shadows symbol in same scope (error - duplicate)

    Side Effects:
    - Uses ARENA for temporary shadow check operations
    - No permanent memory allocation
    - May report shadowing warnings

    Algorithm:
    1. Validate inputs
    2. Get symbol_table from analyzer
    3. Look up existing symbol with same name
    4. If not found, return 0 (no shadowing)
    5. Get scope of existing symbol
    6. If same scope, return 2 (duplicate - error)
    7. If parent scope, return 1 (shadowing - warning)
    8. Return result
    :End Note

    If analyzer is equal to 0:
        Return 0
    End If

    If name is equal to 0:
        Return 0
    End If

    Note: Get symbol_table (offset 0)
    Let symbol_table be proc memory_get_qword from Memory with analyzer, 0

    If symbol_table is equal to 0:
        Return 0
    End If

    Note: Look up existing symbol with same name
    Let existing_symbol be proc symbol_table_lookup_symbol from SymbolTable with symbol_table, name, arena

    If existing_symbol is equal to 0:
        Return 0  Note: No existing symbol, no shadowing
    End If

    Note: Get scope of existing symbol (offset 16 in Symbol)
    Let existing_scope be proc memory_get_qword from Memory with existing_symbol, 16

    Note: Check if same scope (duplicate declaration)
    If existing_scope is equal to current_scope:
        Return 2  Note: Duplicate in same scope - ERROR
    End If

    Note: Check if parent scope (shadowing)
    If existing_scope is less than current_scope:
        Return 1  Note: Shadows parent scope symbol - WARNING
    End If

    Return 0  Note: No shadowing issue
End Process

Process called "scope_analyzer_check_visibility" takes analyzer as Integer, symbol as Integer, accessor_scope as Integer returns Integer:
    Note:
    Checks if a symbol is visible from a specific scope.

    Parameters:
    - analyzer: OWNED ScopeAnalyzer reference
    - symbol: Symbol to check (OWNED)
    - accessor_scope: Scope attempting access (STACK)

    Returns:
    - Integer: Visibility result (STACK)
            1 = visible, 0 = not visible

    Algorithm:
    1. Validate inputs
    2. Get symbol visibility from symbol (offset 24)
    3. Get symbol scope_level from symbol (offset 16)
    4. Check if accessor has access
    5. Increment visibility_check_count
    6. Return visibility result
    :End Note

    If analyzer is equal to 0:
        Return 0
    End If

    If symbol is equal to 0:
        Return 0
    End If

    Note: Get symbol visibility (offset 24)
    Let visibility be proc memory_get_qword from Memory with symbol, 24

    Note: Get symbol scope_level (offset 16)
    Let symbol_scope be proc memory_get_qword from Memory with symbol, 16

    Note: Increment visibility_check_count (offset 64)
    Let check_count be proc memory_get_qword from Memory with analyzer, 64
    Set check_count to check_count plus 1
    proc memory_set_qword from Memory with analyzer, 64, check_count

    Note: Visibility checking based on scope hierarchy and access rules
    If visibility is equal to 1:
        Return 1
    End If

    Note: Private symbols only visible in same scope
    If symbol_scope is equal to accessor_scope:
        Return 1
    End If

    Return 0
End Process

Process called "scope_analyzer_add_visibility_rule" takes analyzer as Integer, source_scope as Integer, target_scope as Integer, visibility_level as Integer returns Nothing:
    Note:
    Adds a visibility rule between scopes.

    Parameters:
    - analyzer: OWNED ScopeAnalyzer reference
    - source_scope: Source scope ID (STACK)
    - target_scope: Target scope ID (STACK)
    - visibility_level: Visibility level (STACK)

    Side Effects:
    - Creates OWNED VisibilityRule in visibility_rules hashtable
    - Updates visibility rule count

    Algorithm:
    1. Validate inputs
    2. Get visibility_rules hashtable (offset 40)
    3. If NULL, create hashtable
    4. Create composite key: source_scope * 1000000 + target_scope
    5. Store visibility_level in hashtable at composite key
    6. Increment visibility_rule_count
    :End Note

    If analyzer is equal to 0:
        Return
    End If

    Note: Get visibility_rules hashtable (offset 40)
    Let visibility_rules be proc memory_get_qword from Memory with analyzer, 40

    Note: If visibility_rules is NULL, create hashtable
    If visibility_rules is equal to 0:
        Set visibility_rules to proc hashtable_create from HashTable with 64
        If visibility_rules is equal to 0:
            Return  Note: Failed to create hashtable
        End If
        proc memory_set_qword from Memory with analyzer, 40, visibility_rules
    End If

    Note: Create composite key: source_scope * 1000000 + target_scope
    Let composite_key be source_scope multiplied by 1000000
    Set composite_key to composite_key plus target_scope

    Note: Store visibility_level in hashtable
    proc hashtable_set from HashTable with visibility_rules, composite_key, visibility_level

    Note: Increment visibility_rule_count (offset 64)
    Let rule_count be proc memory_get_qword from Memory with analyzer, 64
    Set rule_count to rule_count plus 1
    proc memory_set_qword from Memory with analyzer, 64, rule_count

    Return
End Process

Process called "scope_analyzer_track_scope_lifetime" takes analyzer as Integer, scope_id as Integer, start_line as Integer, end_line as Integer returns Nothing:
    Note:
    Tracks the lifetime of a scope for ownership analysis.

    Parameters:
    - analyzer: OWNED ScopeAnalyzer reference
    - scope_id: Scope ID to track (STACK)
    - start_line: Scope start line (STACK)
    - end_line: Scope end line (STACK)

    Side Effects:
    - Updates ScopeContext with lifetime information
    - Increments lifetime_tracking_count

    Algorithm:
    1. Validate inputs
    2. Get scope_stack (offset 8)
    3. Search stack for matching scope_id
    4. Update ScopeContext start_line and end_line
    5. Increment lifetime_tracking_count
    :End Note

    If analyzer is equal to 0:
        Return
    End If

    Note: Get scope_stack (offset 8)
    Let scope_stack be proc memory_get_qword from Memory with analyzer, 8

    If scope_stack is equal to 0:
        Return
    End If

    Note: Get stack count
    Let stack_count be proc stack_count from Stack with scope_stack

    If stack_count is equal to 0:
        Return
    End If

    Note: Search stack for matching scope_id (peek from top to bottom)
    Let depth be 0
    Loop forever:
        If depth is greater than or equal to stack_count:
            Break
        End If

        Note: Peek at context at this depth
        Let context be proc stack_peek_at from Stack with scope_stack, depth

        If context is not equal to 0:
            Note: Get scope_id from context (offset 0)
            Let context_scope_id be proc memory_get_qword from Memory with context, 0

            If context_scope_id is equal to scope_id:
                Note: Found matching scope - update lifetime info
                Note: Update start_line (offset 32)
                proc memory_set_qword from Memory with context, 32, start_line

                Note: Update end_line (offset 48)
                proc memory_set_qword from Memory with context, 48, end_line

                Note: Increment lifetime_tracking_count (offset 72)
                Let tracking_count be proc memory_get_qword from Memory with analyzer, 72
                Set tracking_count to tracking_count plus 1
                proc memory_set_qword from Memory with analyzer, 72, tracking_count

                Return
            End If
        End If

        Set depth to depth plus 1
    End Loop

    Return
End Process

Process called "scope_analyzer_get_scope_hierarchy" takes analyzer as Integer, scope_id as Integer, arena as Integer returns Integer:
    Note:
    Gets the scope hierarchy for a specific scope using arena-based operations.

    Parameters:
    - analyzer: OWNED ScopeAnalyzer reference
    - scope_id: Scope ID to get hierarchy for (STACK)
    - arena: Arena for temporary hierarchy data (ARENA)

    Returns:
    - Integer: ARENA pointer to List of scope IDs (from root to specified scope)

    Side Effects:
    - Uses ARENA for temporary hierarchy list
    - No permanent memory allocation

    Algorithm:
    1. Validate inputs
    2. Create List in arena
    3. Get scope_stack
    4. Search stack for matching scope_id
    5. Build hierarchy by traversing parent_scope chain
    6. Return ARENA list (freed when arena destroyed)
    :End Note

    If analyzer is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Create List using list_create (will allocate from heap, but caller manages lifetime)
    Let hierarchy_list be proc list_create from List

    If hierarchy_list is equal to 0:
        Return 0
    End If

    Note: Get scope_stack (offset 8)
    Let scope_stack be proc memory_get_qword from Memory with analyzer, 8

    If scope_stack is equal to 0:
        Return hierarchy_list  Note: Return empty list
    End If

    Note: Get stack count
    Let stack_count be proc stack_count from Stack with scope_stack

    If stack_count is equal to 0:
        Return hierarchy_list  Note: Return empty list
    End If

    Note: Search stack for matching scope_id
    Let found_context be 0
    Let depth be 0
    Loop forever:
        If depth is greater than or equal to stack_count:
            Break
        End If

        Let context be proc stack_peek_at from Stack with scope_stack, depth

        If context is not equal to 0:
            Let context_scope_id be proc memory_get_qword from Memory with context, 0

            If context_scope_id is equal to scope_id:
                Set found_context to context
                Break
            End If
        End If

        Set depth to depth plus 1
    End Loop

    If found_context is equal to 0:
        Return hierarchy_list  Note: Scope not found, return empty list
    End If

    Note: Build hierarchy by traversing parent chain
    Let current_context be found_context
    Loop forever:
        If current_context is equal to 0:
            Break
        End If

        Note: Get scope_id from context (offset 0)
        Let current_scope_id be proc memory_get_qword from Memory with current_context, 0

        Note: Add to front of list (so root is first)
        proc list_push_front from List with hierarchy_list, current_scope_id

        Note: Get parent_scope (offset 8)
        Let parent_scope_id be proc memory_get_qword from Memory with current_context, 8

        If parent_scope_id is equal to 0:
            Break  Note: Reached root scope
        End If

        Note: Find parent context in stack
        Set current_context to 0
        Let search_depth be 0
        Loop forever:
            If search_depth is greater than or equal to stack_count:
                Break
            End If

            Let parent_context be proc stack_peek_at from Stack with scope_stack, search_depth

            If parent_context is not equal to 0:
                Let parent_ctx_scope_id be proc memory_get_qword from Memory with parent_context, 0

                If parent_ctx_scope_id is equal to parent_scope_id:
                    Set current_context to parent_context
                    Break
                End If
            End If

            Set search_depth to search_depth plus 1
        End Loop
    End Loop

    Return hierarchy_list
End Process

Process called "scope_analyzer_validate_scopes" takes analyzer as Integer, arena as Integer returns Integer:
    Note:
    Validates all scopes and reports any issues using arena-based operations.

    Parameters:
    - analyzer: OWNED ScopeAnalyzer reference
    - arena: Arena for temporary validation data (ARENA)

    Returns:
    - Integer: Validation result (STACK)
            1 = valid, 0 = has issues

    Side Effects:
    - Uses ARENA for temporary validation data
    - Reports scope integrity issues

    Algorithm:
    1. Validate inputs
    2. Check scope_depth matches stack size
    3. Validate all scopes are properly nested
    4. Check for orphaned scopes
    5. Return validation result
    :End Note

    If analyzer is equal to 0:
        Return 0
    End If

    Note: Get scope_depth (offset 24)
    Let scope_depth be proc memory_get_qword from Memory with analyzer, 24

    Note: Get scope_stack (offset 8)
    Let scope_stack be proc memory_get_qword from Memory with analyzer, 8

    If scope_stack is equal to 0:
        Return 0
    End If

    Note: Get stack count
    Let stack_size be proc stack_count from Stack with scope_stack

    Note: Validate depth matches stack size
    If scope_depth is not equal to stack_size:
        Return 0  Note: Integrity issue - depth mismatch
    End If

    Note: Validate scope_count is non-negative
    Let scope_count be proc memory_get_qword from Memory with analyzer, 48
    If scope_count is less than 0:
        Return 0  Note: Invalid scope count
    End If

    Return 1  Note: All validations passed
End Process

Process called "scope_analyzer_get_scope_statistics" takes analyzer as Integer, arena as Integer returns Integer:
    Note:
    Gets scope analysis statistics using arena-based operations.

    Parameters:
    - analyzer: OWNED ScopeAnalyzer reference
    - arena: Arena for temporary statistics (ARENA)

    Returns:
    - Integer: ARENA pointer to statistics structure

    Side Effects:
    - Uses ARENA for temporary statistics
    - No permanent memory allocation

    Algorithm:
    1. Validate inputs
    2. Allocate statistics structure in ARENA
    3. Populate with counts
    4. Return ARENA pointer

    Statistics structure (5 fields × 8 bytes = 40 bytes):
    - scope_count
    - scope_depth
    - symbol_resolution_count
    - visibility_check_count
    - current_scope
    :End Note

    If analyzer is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Allocate statistics structure (5 fields × 8 bytes = 40 bytes)
    Let stats_size be 40
    Let stats be proc allocate from Layout with stats_size

    If stats is equal to 0:
        Return 0
    End If

    Note: Get counts
    Let scope_count be proc memory_get_qword from Memory with analyzer, 48
    Let scope_depth be proc memory_get_qword from Memory with analyzer, 24
    Let resolution_count be proc memory_get_qword from Memory with analyzer, 56
    Let visibility_count be proc memory_get_qword from Memory with analyzer, 64
    Let current_scope be proc memory_get_qword from Memory with analyzer, 16

    Note: Populate statistics
    proc memory_set_qword from Memory with stats, 0, scope_count
    proc memory_set_qword from Memory with stats, 8, scope_depth
    proc memory_set_qword from Memory with stats, 16, resolution_count
    proc memory_set_qword from Memory with stats, 24, visibility_count
    proc memory_set_qword from Memory with stats, 32, current_scope

    Return stats
End Process

Process called "scope_analyzer_analyze_ast_scope" takes analyzer as Integer, ast_node as Integer, arena as Integer returns Integer:
    Note:
    Analyzes AST node for scope information using arena-based operations.

    Parameters:
    - analyzer: OWNED ScopeAnalyzer reference
    - ast_node: AST node to analyze (OWNED)
    - arena: Arena for temporary analysis data (ARENA)

    Returns:
    - Integer: Analysis result (STACK)
            1 = success, 0 = failure

    Side Effects:
    - Uses ARENA for temporary analysis data
    - Recursively traverses AST
    - Creates/exits scopes based on node types

    Algorithm:
    1. Validate inputs
    2. Get node type from AST node
    3. Handle scope-creating nodes (function, block, loop, match):
       a. Enter scope with appropriate type
       b. Recursively analyze children
       c. Exit scope
    4. Handle declaration nodes:
       a. Extract symbol name
       b. Check for shadowing
       c. Add to symbol table
    5. Handle reference nodes:
       a. Resolve symbol
       b. Check visibility
    6. Recursively analyze all children
    7. Return success
    :End Note

    If analyzer is equal to 0:
        Return 0
    End If

    If ast_node is equal to 0:
        Return 0
    End If

    Note: Get node_type (offset 0)
    Let node_type be proc memory_get_qword from Memory with ast_node, 0

    Note: Get line and column for scope tracking (offsets 8 and 16)
    Let line be proc memory_get_qword from Memory with ast_node, 8
    Let column be proc memory_get_qword from Memory with ast_node, 16

    Note: Handle scope-creating nodes (AST constants from parsing/ast.runa)
    Note: AST_PROCESS_DEFINITION = 3000
    If node_type is equal to 3000:
        Note: Enter function scope
        Let scope_id be proc scope_analyzer_enter_scope with analyzer, 3, line, column  Note: SCOPE_TYPE_FUNCTION
        If scope_id is equal to 0:
            Return 0
        End If
        Note: Analyze children
        Let result be proc scope_analyzer_analyze_children with analyzer, ast_node, arena
        Note: Exit function scope
        proc scope_analyzer_exit_scope with analyzer
        Return result
    End If

    Note: AST_BLOCK_STATEMENT = 2018
    If node_type is equal to 2018:
        Note: Enter block scope
        Let scope_id be proc scope_analyzer_enter_scope with analyzer, 4, line, column  Note: SCOPE_TYPE_BLOCK
        If scope_id is equal to 0:
            Return 0
        End If
        Note: Analyze children
        Let result be proc scope_analyzer_analyze_children with analyzer, ast_node, arena
        Note: Exit block scope
        proc scope_analyzer_exit_scope with analyzer
        Return result
    End If

    Note: AST_FOR_STATEMENT = 2007
    If node_type is equal to 2007:
        Note: Enter loop scope
        Let scope_id be proc scope_analyzer_enter_scope with analyzer, 5, line, column  Note: SCOPE_TYPE_LOOP
        If scope_id is equal to 0:
            Return 0
        End If
        Note: Analyze children
        Let result be proc scope_analyzer_analyze_children with analyzer, ast_node, arena
        Note: Exit loop scope
        proc scope_analyzer_exit_scope with analyzer
        Return result
    End If

    Note: AST_WHILE_STATEMENT = 2008
    If node_type is equal to 2008:
        Note: Enter loop scope
        Let scope_id be proc scope_analyzer_enter_scope with analyzer, 5, line, column  Note: SCOPE_TYPE_LOOP
        If scope_id is equal to 0:
            Return 0
        End If
        Note: Analyze children
        Let result be proc scope_analyzer_analyze_children with analyzer, ast_node, arena
        Note: Exit loop scope
        proc scope_analyzer_exit_scope with analyzer
        Return result
    End If

    Note: AST_LOOP_STATEMENT = 2009
    If node_type is equal to 2009:
        Note: Enter loop scope
        Let scope_id be proc scope_analyzer_enter_scope with analyzer, 5, line, column  Note: SCOPE_TYPE_LOOP
        If scope_id is equal to 0:
            Return 0
        End If
        Note: Analyze children
        Let result be proc scope_analyzer_analyze_children with analyzer, ast_node, arena
        Note: Exit loop scope
        proc scope_analyzer_exit_scope with analyzer
        Return result
    End If

    Note: AST_MATCH_STATEMENT = 2005
    If node_type is equal to 2005:
        Note: Enter match scope
        Let scope_id be proc scope_analyzer_enter_scope with analyzer, 6, line, column  Note: SCOPE_TYPE_MATCH
        If scope_id is equal to 0:
            Return 0
        End If
        Note: Analyze children
        Let result be proc scope_analyzer_analyze_children with analyzer, ast_node, arena
        Note: Exit match scope
        proc scope_analyzer_exit_scope with analyzer
        Return result
    End If

    Note: For all other nodes, recursively analyze children
    Let result be proc scope_analyzer_analyze_children with analyzer, ast_node, arena
    Return result
End Process

Process called "scope_analyzer_analyze_children" takes analyzer as Integer, ast_node as Integer, arena as Integer returns Integer:
    Note:
    Analyzes all children of an AST node recursively.

    Parameters:
    - analyzer: OWNED ScopeAnalyzer reference
    - ast_node: Parent AST node (OWNED)
    - arena: Arena for temporary analysis data (ARENA)

    Returns:
    - Integer: Analysis result (1 = success, 0 = failure)

    Algorithm:
    1. Get child_count from AST node (offset 32)
    2. Get children list from AST node (offset 24)
    3. For each child:
       a. Get child pointer
       b. Recursively call scope_analyzer_analyze_ast_scope
       c. Return 0 if any child fails
    4. Return 1 if all children succeed
    :End Note

    If analyzer is equal to 0:
        Return 0
    End If

    If ast_node is equal to 0:
        Return 0
    End If

    Note: Get child_count (offset 32)
    Let child_count be proc memory_get_qword from Memory with ast_node, 32

    Note: If no children, return success
    If child_count is equal to 0:
        Return 1
    End If

    Note: Get children list (offset 24)
    Let children_list be proc memory_get_qword from Memory with ast_node, 24

    If children_list is equal to 0:
        Return 1  Note: No children list, treat as success
    End If

    Note: Iterate through children and analyze each
    Let index be 0
    Loop forever:
        If index is greater than or equal to child_count:
            Break
        End If

        Note: Get child at index using AST API
        Let child be proc ast_node_get_child from AST with ast_node, index

        Note: Recursively analyze child
        If child is not equal to 0:
            Let result be proc scope_analyzer_analyze_ast_scope with analyzer, child, arena
            If result is equal to 0:
                Return 0  Note: Child analysis failed
            End If
        End If

        Set index to index plus 1
    End Loop

    Return 1  Note: All children analyzed successfully
End Process