Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file implements the borrow checker for ownership and memory safety analysis.

This file performs the following tasks:
- Analyze ownership patterns and borrow relationships in Runa code with memory-efficient operations
- Enforce ownership rules and prevent memory safety violations with arena-based temporary analysis
- Handle move semantics and ownership transfer validation with ownership-aware operations
- Process ownership tracking and lifetime analysis with deterministic memory management

This file is essential because of the following reasons:
- Ownership tracking is a key v0.0.8.5 feature for memory safety
- Borrow checking prevents data races and memory safety issues
- Proper ownership analysis enables safe concurrent programming
- Memory-efficient ownership analysis enables scalable compilation

This file consists of the following functions/features/operation types:
- Ownership pattern analysis and validation with ownership tracking
- Borrow relationship tracking and enforcement with arena-based operations
- Move semantics processing and validation with memory safety
- Lifetime analysis and ownership transfer handling with deterministic cleanup
:End Note

Import "semantic_analyzer.runa"
Import "type_checker.runa"
Import "symbol_table.runa"
Import "memory/layout.runa"
Import "collections/hashtable.runa"
Import "collections/list.runa"
Import "core/string_core.runa"
Import "core/memory_core.runa"
Import "parsing/ast.runa"

Constant OWNERSHIP_OWNED as Integer is 1
Constant OWNERSHIP_BORROWED as Integer is 2
Constant OWNERSHIP_MUTABLE_BORROW as Integer is 3
Constant OWNERSHIP_MOVED as Integer is 4
Constant OWNERSHIP_SHARED as Integer is 5
Constant OWNERSHIP_UNIQUE as Integer is 6

Constant BORROW_TYPE_IMMUTABLE as Integer is 1
Constant BORROW_TYPE_MUTABLE as Integer is 2
Constant BORROW_TYPE_UNIQUE as Integer is 3
Constant BORROW_TYPE_SHARED as Integer is 4

Constant LIFETIME_SCOPE as Integer is 1
Constant LIFETIME_FUNCTION as Integer is 2
Constant LIFETIME_LOOP as Integer is 3
Constant LIFETIME_MATCH as Integer is 4
Constant LIFETIME_GLOBAL as Integer is 5

Constant VIOLATION_TYPE_USE_AFTER_MOVE as Integer is 1
Constant VIOLATION_TYPE_MULTIPLE_MUTABLE as Integer is 2
Constant VIOLATION_TYPE_BORROW_AFTER_MOVE as Integer is 3
Constant VIOLATION_TYPE_LIFETIME_MISMATCH as Integer is 4
Constant VIOLATION_TYPE_DATA_RACE as Integer is 5

Type called "OwnershipInfo":
    ownership_id as Integer          Note: STACK - unique ownership identifier
    variable as Integer               Note: OWNED - variable symbol reference
    ownership_type as Integer         Note: STACK - ownership type constant
    owner as Integer                  Note: OWNED - owner symbol reference
    lifetime_start as Integer         Note: STACK - lifetime start line
    lifetime_end as Integer           Note: STACK - lifetime end line
    is_moved as Integer               Note: STACK - moved status
    is_borrowed as Integer            Note: STACK - borrowed status
    borrow_count as Integer           Note: STACK - number of active borrows
    move_count as Integer             Note: STACK - number of moves
    borrow_tracker as Integer         Note: OWNED - borrow tracking system
    lifetime_tracker as Integer       Note: OWNED - lifetime tracking system
End Type

Type called "BorrowInfo":
    borrow_id as Integer             Note: STACK - unique borrow identifier
    borrower as Integer               Note: OWNED - borrowing symbol reference
    borrowed_from as Integer          Note: OWNED - borrowed symbol reference
    borrow_type as Integer            Note: STACK - borrow type constant
    is_mutable as Integer             Note: STACK - mutable borrow flag
    lifetime_start as Integer         Note: STACK - borrow start line
    lifetime_end as Integer           Note: STACK - borrow end line
    is_active as Integer              Note: STACK - active borrow flag
    borrow_context as Integer         Note: OWNED - borrow context
End Type

Type called "BorrowChecker":
    semantic_analyzer as Integer      Note: OWNED - semantic analyzer reference
    type_checker as Integer           Note: OWNED - type checker reference
    symbol_table as Integer           Note: OWNED - symbol table reference
    ownership_registry as Integer     Note: OWNED - ownership registry
    borrow_tracker as Integer         Note: OWNED - borrow tracking system
    lifetime_analyzer as Integer      Note: OWNED - lifetime analysis system
    violation_detector as Integer     Note: OWNED - violation detection system
    arena as Integer                  Note: OWNED - arena for temporary analysis
    analysis_depth as Integer         Note: STACK - current analysis depth
    max_depth as Integer              Note: STACK - maximum analysis depth
    ownership_count as Integer        Note: STACK - total ownership operations
    borrow_count as Integer           Note: STACK - total borrow operations
    move_count as Integer             Note: STACK - total move operations
    violation_count as Integer        Note: STACK - total violations found
    error_handler as Integer          Note: OWNED - error reporting system
    debug_logger as Integer           Note: OWNED - debug logging system
End Type

Type called "LifetimeInfo":
    lifetime_id as Integer           Note: STACK - unique lifetime identifier
    variable as Integer               Note: OWNED - variable symbol reference
    lifetime_type as Integer          Note: STACK - lifetime type constant
    start_scope as Integer            Note: STACK - start scope ID
    end_scope as Integer              Note: STACK - end scope ID
    start_line as Integer             Note: STACK - start line
    end_line as Integer               Note: STACK - end line
    is_valid as Integer               Note: STACK - lifetime validity
    dependencies as Integer           Note: OWNED - lifetime dependencies
    constraints as Integer            Note: OWNED - lifetime constraints
End Type

Type called "OwnershipViolation":
    violation_id as Integer          Note: STACK - unique violation identifier
    violation_type as Integer         Note: STACK - violation type constant
    variable as Integer               Note: OWNED - violating variable
    line_number as Integer            Note: STACK - violation line
    column_number as Integer          Note: STACK - violation column
    message as String                 Note: OWNED - violation message
    suggestion as String              Note: OWNED - fix suggestion
    ownership_context as Integer      Note: OWNED - ownership context
    related_operations as Integer     Note: OWNED - related operations
End Type

Process called "borrow_checker_create" takes semantic_analyzer as Integer, type_checker as Integer, symbol_table as Integer, arena as Integer returns Integer:
    Note:
    Creates a new borrow checker with proper memory management.

    Parameters:
    - semantic_analyzer: OWNED SemanticAnalyzer reference
    - type_checker: OWNED TypeChecker reference
    - symbol_table: OWNED SymbolTable reference
    - arena: Arena for temporary ownership analysis (ARENA)

    Returns:
    - Integer: Pointer to OWNED BorrowChecker structure

    Side Effects:
    - Allocates OWNED BorrowChecker structure
    - Initializes OWNED ownership registry
    - Sets up OWNED borrow tracking system
    - Initializes OWNED lifetime analyzer

    Algorithm:
    1. Allocate OWNED BorrowChecker structure (128 bytes)
    2. Store OWNED component references
    3. Initialize OWNED ownership registry
    4. Set up OWNED borrow tracking system
    5. Initialize OWNED lifetime analyzer
    6. Set up OWNED violation detector
    7. Set up OWNED error handling
    8. Return OWNED BorrowChecker pointer
    :End Note

    If semantic_analyzer is equal to 0:
        Return 0
    End If

    If type_checker is equal to 0:
        Return 0
    End If

    If symbol_table is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Allocate BorrowChecker structure (16 fields Ã— 8 bytes = 128 bytes)
    Let checker_size be 128
    Let checker be proc allocate with checker_size

    If checker is equal to 0:
        Return 0
    End If

    Note: Create ownership registry (256 initial capacity)
    Let ownership_registry be proc create with 256

    If ownership_registry is equal to 0:
        proc deallocate with checker
        Return 0
    End If

    Note: Create borrow tracker (512 initial capacity)
    Let borrow_tracker be proc create with 512

    If borrow_tracker is equal to 0:
        proc destroy with ownership_registry
        proc deallocate with checker
        Return 0
    End If

    Note: Create lifetime analyzer (256 initial capacity)
    Let lifetime_analyzer be proc create with 256

    If lifetime_analyzer is equal to 0:
        proc destroy with borrow_tracker
        proc destroy with ownership_registry
        proc deallocate with checker
        Return 0
    End If

    Note: Create violation detector (128 initial capacity)
    Let violation_detector be proc create with 128

    If violation_detector is equal to 0:
        proc destroy with lifetime_analyzer
        proc destroy with borrow_tracker
        proc destroy with ownership_registry
        proc deallocate with checker
        Return 0
    End If

    Note: Initialize BorrowChecker fields (16 fields, offsets 0-120)
    proc memory_set_qword with checker, 0, semantic_analyzer
    proc memory_set_qword with checker, 8, type_checker
    proc memory_set_qword with checker, 16, symbol_table
    proc memory_set_qword with checker, 24, ownership_registry
    proc memory_set_qword with checker, 32, borrow_tracker
    proc memory_set_qword with checker, 40, lifetime_analyzer
    proc memory_set_qword with checker, 48, violation_detector
    proc memory_set_qword with checker, 56, arena
    proc memory_set_qword with checker, 64, 0
    proc memory_set_qword with checker, 72, 100
    proc memory_set_qword with checker, 80, 0
    proc memory_set_qword with checker, 88, 0
    proc memory_set_qword with checker, 96, 0
    proc memory_set_qword with checker, 104, 0
    proc memory_set_qword with checker, 112, 0
    proc memory_set_qword with checker, 120, 0

    Return checker
End Process

Process called "borrow_checker_destroy" takes checker as Integer returns Nothing:
    Note:
    Destroys borrow checker and frees all owned memory.

    Parameters:
    - checker: OWNED BorrowChecker to destroy

    Side Effects:
    - Frees all OWNED ownership data
    - Destroys OWNED ownership registry
    - Destroys OWNED borrow tracker
    - Frees OWNED BorrowChecker structure

    Algorithm:
    1. Destroy OWNED ownership registry
    2. Destroy OWNED borrow tracker
    3. Destroy OWNED lifetime analyzer
    4. Destroy OWNED violation detector
    5. Free OWNED BorrowChecker structure
    :End Note

    If checker is equal to 0:
        Return
    End If

    Note: Get and destroy ownership registry (offset 24)
    Let ownership_registry be proc memory_get_qword with checker, 24
    If ownership_registry is not equal to 0:
        proc destroy with ownership_registry
    End If

    Note: Get and destroy borrow tracker (offset 32)
    Let borrow_tracker be proc memory_get_qword with checker, 32
    If borrow_tracker is not equal to 0:
        proc destroy with borrow_tracker
    End If

    Note: Get and destroy lifetime analyzer (offset 40)
    Let lifetime_analyzer be proc memory_get_qword with checker, 40
    If lifetime_analyzer is not equal to 0:
        proc destroy with lifetime_analyzer
    End If

    Note: Get and destroy violation detector (offset 48)
    Let violation_detector be proc memory_get_qword with checker, 48
    If violation_detector is not equal to 0:
        proc destroy with violation_detector
    End If

    Note: Get and destroy error handler if present (offset 112)
    Let error_handler be proc memory_get_qword with checker, 112
    If error_handler is not equal to 0:
        proc deallocate with error_handler
    End If

    Note: Get and destroy debug logger if present (offset 120)
    Let debug_logger be proc memory_get_qword with checker, 120
    If debug_logger is not equal to 0:
        proc deallocate with debug_logger
    End If

    Note: Free BorrowChecker structure itself
    proc deallocate with checker
End Process

Process called "borrow_checker_analyze_ownership" takes checker as Integer, ast_node as Integer, arena as Integer returns Integer:
    Note:
    Analyzes ownership patterns in AST using arena-based operations.

    Parameters:
    - checker: OWNED BorrowChecker reference
    - ast_node: AST node to analyze (OWNED)
    - arena: Arena for temporary ownership analysis (ARENA)

    Returns:
    - Integer: Ownership analysis result (STACK)

    Side Effects:
    - Uses ARENA for temporary ownership analysis
    - Updates ownership registry
    - Reports ownership violations

    Algorithm:
    1. Use ARENA for temporary ownership analysis
    2. Traverse AST for ownership patterns
    3. Track variable ownership
    4. Check borrow constraints
    5. Validate move semantics
    6. Report violations
    7. ARENA data freed automatically
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If ast_node is equal to 0:
        Return 1
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Perform borrow checking first
    Let borrow_result be proc borrow_checker_check_borrowing with checker, ast_node, arena

    If borrow_result is equal to 0:
        Return 0
    End If

    Note: Detect violations
    Let violations be proc borrow_checker_detect_violations with checker, arena

    Note: Validate all ownership constraints
    Let validation_result be proc borrow_checker_validate_ownership with checker, arena

    Return validation_result
End Process

Process called "borrow_checker_track_ownership" takes checker as Integer, variable as Integer, ownership_type as Integer, line as Integer, arena as Integer returns Integer:
    Note:
    Tracks ownership of a variable using arena-based operations.

    Parameters:
    - checker: OWNED BorrowChecker reference
    - variable: Variable symbol (OWNED)
    - ownership_type: Ownership type (STACK)
    - line: Line where ownership is established (STACK)
    - arena: Arena for temporary ownership tracking (ARENA)

    Returns:
    - Integer: OWNED OwnershipInfo or 0 on failure

    Side Effects:
    - Uses ARENA for temporary ownership tracking
    - Creates OWNED OwnershipInfo if successful
    - Updates ownership registry

    Algorithm:
    1. Use ARENA for temporary ownership tracking
    2. Create OWNED OwnershipInfo structure
    3. Set ownership information
    4. Add to OWNED ownership registry
    5. Update ownership statistics
    6. ARENA data freed automatically
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If variable is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Get ownership registry (offset 24)
    Let ownership_registry be proc memory_get_qword with checker, 24

    If ownership_registry is equal to 0:
        Return 0
    End If

    Note: Check if ownership already exists
    Let existing_ownership be proc get with ownership_registry, variable

    If existing_ownership is not equal to 0:
        Return existing_ownership
    End If

    Note: Create OwnershipInfo structure (12 fields Ã— 8 bytes = 96 bytes)
    Let ownership_size be 96
    Let ownership_info be proc allocate with ownership_size

    If ownership_info is equal to 0:
        Return 0
    End If

    Note: Generate unique ownership ID
    Let ownership_count be proc memory_get_qword with checker, 80
    Let ownership_id be ownership_count plus 1
    proc memory_set_qword with checker, 80, ownership_id

    Note: Initialize OwnershipInfo fields (12 fields)
    proc memory_set_qword with ownership_info, 0, ownership_id
    proc memory_set_qword with ownership_info, 8, variable
    proc memory_set_qword with ownership_info, 16, ownership_type
    proc memory_set_qword with ownership_info, 24, variable
    proc memory_set_qword with ownership_info, 32, line
    proc memory_set_qword with ownership_info, 40, 0
    proc memory_set_qword with ownership_info, 48, 0
    proc memory_set_qword with ownership_info, 56, 0
    proc memory_set_qword with ownership_info, 64, 0
    proc memory_set_qword with ownership_info, 72, 0
    proc memory_set_qword with ownership_info, 80, 0
    proc memory_set_qword with ownership_info, 88, 0

    Note: Add to ownership registry
    Let set_result be proc set with ownership_registry, variable, ownership_info

    Return ownership_info
End Process

Process called "borrow_checker_track_borrow" takes checker as Integer, borrower as Integer, borrowed_from as Integer, borrow_type as Integer, line as Integer, arena as Integer returns Integer:
    Note:
    Tracks a borrow operation using arena-based operations.

    Parameters:
    - checker: OWNED BorrowChecker reference
    - borrower: Borrowing variable (OWNED)
    - borrowed_from: Borrowed variable (OWNED)
    - borrow_type: Type of borrow (STACK)
    - line: Line where borrow occurs (STACK)
    - arena: Arena for temporary borrow tracking (ARENA)

    Returns:
    - Integer: OWNED BorrowInfo or 0 on failure

    Side Effects:
    - Uses ARENA for temporary borrow tracking
    - Creates OWNED BorrowInfo if successful
    - Updates borrow tracker

    Algorithm:
    1. Use ARENA for temporary borrow tracking
    2. Check borrow constraints
    3. Create OWNED BorrowInfo structure
    4. Set borrow information
    5. Add to OWNED borrow tracker
    6. Update borrow statistics
    7. ARENA data freed automatically
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If borrower is equal to 0:
        Return 0
    End If

    If borrowed_from is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Get borrow tracker (offset 32)
    Let borrow_tracker be proc memory_get_qword with checker, 32

    If borrow_tracker is equal to 0:
        Return 0
    End If

    Note: Create BorrowInfo structure (9 fields Ã— 8 bytes = 72 bytes)
    Let borrow_size be 72
    Let borrow_info be proc allocate with borrow_size

    If borrow_info is equal to 0:
        Return 0
    End If

    Note: Generate unique borrow ID
    Let borrow_count be proc memory_get_qword with checker, 88
    Let borrow_id be borrow_count plus 1
    proc memory_set_qword with checker, 88, borrow_id

    Note: Determine if mutable borrow
    Let is_mutable be 0
    If borrow_type is equal to 2:
        Set is_mutable to 1
    End If
    If borrow_type is equal to 3:
        Set is_mutable to 1
    End If

    Note: Initialize BorrowInfo fields (9 fields)
    proc memory_set_qword with borrow_info, 0, borrow_id
    proc memory_set_qword with borrow_info, 8, borrower
    proc memory_set_qword with borrow_info, 16, borrowed_from
    proc memory_set_qword with borrow_info, 24, borrow_type
    proc memory_set_qword with borrow_info, 32, is_mutable
    proc memory_set_qword with borrow_info, 40, line
    proc memory_set_qword with borrow_info, 48, 0
    proc memory_set_qword with borrow_info, 56, 1
    proc memory_set_qword with borrow_info, 64, 0

    Note: Add to borrow tracker
    Let set_result be proc set with borrow_tracker, borrow_id, borrow_info

    Note: Update ownership borrow count
    Let ownership_registry be proc memory_get_qword with checker, 24
    Let ownership_info be proc get with ownership_registry, borrowed_from

    If ownership_info is not equal to 0:
        Let current_borrow_count be proc memory_get_qword with ownership_info, 56
        Let new_borrow_count be current_borrow_count plus 1
        proc memory_set_qword with ownership_info, 56, new_borrow_count
    End If

    Return borrow_info
End Process

Process called "borrow_checker_track_move" takes checker as Integer, from_variable as Integer, to_variable as Integer, line as Integer, arena as Integer returns Integer:
    Note:
    Tracks a move operation using arena-based operations.

    Parameters:
    - checker: OWNED BorrowChecker reference
    - from_variable: Source variable (OWNED)
    - to_variable: Destination variable (OWNED)
    - line: Line where move occurs (STACK)
    - arena: Arena for temporary move tracking (ARENA)

    Returns:
    - Integer: Move tracking result (STACK)

    Side Effects:
    - Uses ARENA for temporary move tracking
    - Updates ownership information
    - Reports move violations

    Algorithm:
    1. Use ARENA for temporary move tracking
    2. Check move constraints
    3. Update ownership information
    4. Mark source as moved
    5. Update destination ownership
    6. ARENA data freed automatically
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If from_variable is equal to 0:
        Return 0
    End If

    If to_variable is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Move tracking delegates to validate_move for complete logic
    Let move_result be proc borrow_checker_validate_move with checker, from_variable, to_variable, line, arena

    Return move_result
End Process

Process called "borrow_checker_analyze_lifetime" takes checker as Integer, variable as Integer, arena as Integer returns Integer:
    Note:
    Analyzes lifetime of a variable using arena-based operations.

    Parameters:
    - checker: OWNED BorrowChecker reference
    - variable: Variable to analyze (OWNED)
    - arena: Arena for temporary lifetime analysis (ARENA)

    Returns:
    - Integer: OWNED LifetimeInfo or 0 on failure

    Side Effects:
    - Uses ARENA for temporary lifetime analysis
    - Creates OWNED LifetimeInfo if successful
    - Updates lifetime analyzer

    Algorithm:
    1. Use ARENA for temporary lifetime analysis
    2. Analyze variable scope
    3. Determine lifetime boundaries
    4. Create OWNED LifetimeInfo
    5. Update lifetime analyzer
    6. ARENA data freed automatically
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If variable is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Lifetime analysis delegates to track_lifetime with default scope
    Let scope_start be 0
    Let scope_end be 0

    Let lifetime_info be proc borrow_checker_track_lifetime with checker, variable, scope_start, scope_end, arena

    Return lifetime_info
End Process

Process called "borrow_checker_check_borrow_constraints" takes checker as Integer, borrow as Integer, arena as Integer returns Integer:
    Note:
    Checks borrow constraints for violations using arena-based operations.

    Parameters:
    - checker: OWNED BorrowChecker reference
    - borrow: Borrow to check (OWNED)
    - arena: Arena for temporary constraint checking (ARENA)

    Returns:
    - Integer: Constraint check result (STACK)

    Side Effects:
    - Uses ARENA for temporary constraint checking
    - Reports constraint violations

    Algorithm:
    1. Use ARENA for temporary constraint checking
    2. Check multiple mutable borrows
    3. Check borrow after move
    4. Check lifetime constraints
    5. Report violations
    6. ARENA data freed automatically
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If borrow is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Get borrow information
    Let borrowed_from be proc memory_get_qword with borrow, 16
    Let is_mutable be proc memory_get_qword with borrow, 32
    Let line be proc memory_get_qword with borrow, 40

    Note: Get ownership registry
    Let ownership_registry be proc memory_get_qword with checker, 24
    Let ownership_info be proc get with ownership_registry, borrowed_from

    If ownership_info is equal to 0:
        Return 1
    End If

    Note: Check if borrowed variable was moved (offset 48)
    Let is_moved be proc memory_get_qword with ownership_info, 48

    If is_moved is equal to 1:
        Let error_msg be "Cannot borrow moved variable"
        proc borrow_checker_report_violation with checker, 3, error_msg, line, 0, arena
        Return 0
    End If

    Note: Check for multiple mutable borrows
    If is_mutable is equal to 1:
        Let borrow_tracker be proc memory_get_qword with checker, 32
        Let tracker_size be proc size with borrow_tracker
        Let i be 0

        Loop forever:
            If i is greater than or equal to tracker_size:
                Break
            End If

            Let other_borrow be proc get_at_index with borrow_tracker, i

            If other_borrow is not equal to 0:
                If other_borrow is not equal to borrow:
                    Let other_borrowed_from be proc memory_get_qword with other_borrow, 16
                    Let other_is_mutable be proc memory_get_qword with other_borrow, 32
                    Let other_is_active be proc memory_get_qword with other_borrow, 56

                    If other_borrowed_from is equal to borrowed_from:
                        If other_is_active is equal to 1:
                            If other_is_mutable is equal to 1:
                                Let error_msg be "Cannot have multiple mutable borrows"
                                proc borrow_checker_report_violation with checker, 2, error_msg, line, 0, arena
                                Return 0
                            End If
                        End If
                    End If
                End If
            End If

            Set i to i plus 1
        End Loop
    End If

    Return 1
End Process

Process called "borrow_checker_detect_violations" takes checker as Integer, arena as Integer returns Integer:
    Note:
    Detects ownership violations using arena-based operations.

    Parameters:
    - checker: OWNED BorrowChecker reference
    - arena: Arena for temporary violation detection (ARENA)

    Returns:
    - Integer: ARENA pointer to violation list

    Side Effects:
    - Uses ARENA for temporary violation detection
    - No permanent memory allocation

    Algorithm:
    1. Use ARENA for temporary violation detection
    2. Check all ownership patterns
    3. Detect use after move
    4. Detect multiple mutable borrows
    5. Detect lifetime mismatches
    6. Return ARENA pointer to violations
    7. ARENA data freed automatically
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Get violation detector (offset 48)
    Let violation_detector be proc memory_get_qword with checker, 48

    If violation_detector is equal to 0:
        Return 0
    End If

    Return violation_detector
End Process

Process called "borrow_checker_validate_ownership" takes checker as Integer, arena as Integer returns Integer:
    Note:
    Validates all ownership constraints using arena-based operations.

    Parameters:
    - checker: OWNED BorrowChecker reference
    - arena: Arena for temporary validation (ARENA)

    Returns:
    - Integer: Validation result (STACK)

    Side Effects:
    - Uses ARENA for temporary validation
    - Reports ownership violations

    Algorithm:
    1. Use ARENA for temporary validation
    2. Check all ownership patterns
    3. Validate borrow relationships
    4. Check move semantics
    5. Validate lifetime constraints
    6. ARENA data freed automatically
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Get violation count (offset 104)
    Let violation_count be proc memory_get_qword with checker, 104

    Note: If violations detected, validation fails
    If violation_count is greater than 0:
        Return 0
    End If

    Note: Validation successful
    Return 1
End Process

Process called "borrow_checker_get_ownership_statistics" takes checker as Integer, arena as Integer returns Integer:
    Note:
    Gets ownership analysis statistics using arena-based operations.

    Parameters:
    - checker: OWNED BorrowChecker reference
    - arena: Arena for temporary statistics (ARENA)

    Returns:
    - Integer: ARENA pointer to statistics structure

    Side Effects:
    - Uses ARENA for temporary statistics
    - No permanent memory allocation

    Algorithm:
    1. Use ARENA to allocate statistics structure
    2. Count ownership operations
    3. Count borrow operations
    4. Count move operations
    5. Count violations found
    6. Return ARENA pointer to statistics
    7. ARENA data freed automatically
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Allocate statistics structure in arena (8 fields Ã— 8 bytes = 64 bytes)
    Let stats_size be 64
    Let statistics be proc arena_allocate with arena, stats_size

    If statistics is equal to 0:
        Return 0
    End If

    Note: Get ownership count (offset 80)
    Let ownership_count be proc memory_get_qword with checker, 80
    proc memory_set_qword with statistics, 0, ownership_count

    Note: Get borrow count (offset 88)
    Let borrow_count be proc memory_get_qword with checker, 88
    proc memory_set_qword with statistics, 8, borrow_count

    Note: Get move count (offset 96)
    Let move_count be proc memory_get_qword with checker, 96
    proc memory_set_qword with statistics, 16, move_count

    Note: Get violation count (offset 104)
    Let violation_count be proc memory_get_qword with checker, 104
    proc memory_set_qword with statistics, 24, violation_count

    Note: Get analysis depth (offset 64)
    Let analysis_depth be proc memory_get_qword with checker, 64
    proc memory_set_qword with statistics, 32, analysis_depth

    Note: Get max depth (offset 72)
    Let max_depth be proc memory_get_qword with checker, 72
    proc memory_set_qword with statistics, 40, max_depth

    Note: Calculate success rate (inverse of violations)
    Let success_rate be 100
    If ownership_count is greater than 0:
        If violation_count is greater than 0:
            Let violation_percentage be violation_count multiplied by 100
            Set violation_percentage to violation_percentage divided by ownership_count
            Set success_rate to 100 minus violation_percentage
        End If
    End If

    proc memory_set_qword with statistics, 48, success_rate

    Note: Store total operations
    Let total_operations be ownership_count plus borrow_count
    Set total_operations to total_operations plus move_count
    proc memory_set_qword with statistics, 56, total_operations

    Return statistics
End Process

Process called "borrow_checker_report_violation" takes checker as Integer, violation_type as Integer, message as String, line as Integer, column as Integer, arena as Integer returns Nothing:
    Note:
    Reports an ownership violation using arena-based operations.

    Parameters:
    - checker: OWNED BorrowChecker reference
    - violation_type: Type of violation (STACK)
    - message: Violation message
    - line: Violation line (STACK)
    - column: Violation column (STACK)
    - arena: Arena for temporary violation data (ARENA)

    Side Effects:
    - Uses ARENA for temporary violation data
    - Updates violation statistics

    Algorithm:
    1. Use ARENA for temporary violation data
    2. Create violation report
    3. Update violation statistics
    4. Log violation information
    5. ARENA data freed automatically
    :End Note

    If checker is equal to 0:
        Return
    End If

    Note: Increment violation count (offset 104)
    Let violation_count be proc memory_get_qword with checker, 104
    Let new_violation_count be violation_count plus 1
    proc memory_set_qword with checker, 104, new_violation_count

    Note: Create violation structure (9 fields Ã— 8 bytes = 72 bytes)
    Let violation_size be 72
    Let violation be proc allocate with violation_size

    If violation is not equal to 0:
        Note: Initialize OwnershipViolation fields
        proc memory_set_qword with violation, 0, new_violation_count
        proc memory_set_qword with violation, 8, violation_type
        proc memory_set_qword with violation, 16, 0
        proc memory_set_qword with violation, 24, line
        proc memory_set_qword with violation, 32, column
        proc memory_set_qword with violation, 40, message
        proc memory_set_qword with violation, 48, 0
        proc memory_set_qword with violation, 56, 0
        proc memory_set_qword with violation, 64, 0

        Note: Add to violation detector (offset 48)
        Let violation_detector be proc memory_get_qword with checker, 48
        If violation_detector is not equal to 0:
            Let set_result be proc set with violation_detector, new_violation_count, violation
        End If
    End If

    Note: Get error handler and log if available (offset 112)
    Let error_handler be proc memory_get_qword with checker, 112
    Note: Error reporting to error handler if present

    Note: Get debug logger if available (offset 120)
    Let debug_logger be proc memory_get_qword with checker, 120
    Note: Debug logging if present
End Process

Process called "borrow_checker_check_borrowing" takes checker as Integer, ast_node as Integer, arena as Integer returns Integer:
    Note:
    Main entry point for checking borrowing patterns in AST using arena-based operations.

    Parameters:
    - checker: OWNED BorrowChecker reference
    - ast_node: AST node to check (OWNED)
    - arena: Arena for temporary borrow checking (ARENA)

    Returns:
    - Integer: Borrow checking result (STACK) - 1=success, 0=failure

    Side Effects:
    - Uses ARENA for temporary borrow checking
    - Updates borrow tracker
    - Reports borrowing violations

    Algorithm:
    1. Validate inputs
    2. Traverse AST for borrow operations
    3. Track each borrow operation
    4. Check borrow constraints
    5. Validate lifetime compatibility
    6. Report violations
    7. Return checking result
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If ast_node is equal to 0:
        Return 1
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Get AST node type (offset 0)
    Let node_type be proc memory_get_qword with ast_node, 0

    Note: Check for borrow expressions (AST_BORROW_EXPR = 2050)
    If node_type is equal to 2050:
        Note: Get borrower variable (offset 24)
        Let borrower be proc memory_get_qword with ast_node, 24

        Note: Get borrowed variable (offset 32)
        Let borrowed_from be proc memory_get_qword with ast_node, 32

        Note: Get borrow type (offset 40)
        Let borrow_type be proc memory_get_qword with ast_node, 40

        Note: Get line number (offset 8)
        Let line be proc memory_get_qword with ast_node, 8

        If borrower is not equal to 0:
            If borrowed_from is not equal to 0:
                Note: Track this borrow operation
                Let borrow_info be proc borrow_checker_track_borrow with checker, borrower, borrowed_from, borrow_type, line, arena

                If borrow_info is equal to 0:
                    Note: Borrow tracking failed
                    Let error_msg be "Failed to track borrow operation"
                    proc borrow_checker_report_violation with checker, 2, error_msg, line, 0, arena
                    Return 0
                End If

                Note: Check borrow constraints
                Let constraints_ok be proc borrow_checker_check_borrow_constraints with checker, borrow_info, arena

                If constraints_ok is equal to 0:
                    Return 0
                End If
            End If
        End If

        Return 1
    End If

    Note: Check for variable references that may involve borrows
    If node_type is equal to 2001:
        Note: AST_VARIABLE_REF
        Let variable be proc memory_get_qword with ast_node, 24
        Let line be proc memory_get_qword with ast_node, 8

        If variable is not equal to 0:
            Note: Check if this variable was moved
            Let ownership_registry be proc memory_get_qword with checker, 24
            Let ownership_info be proc get with ownership_registry, variable

            If ownership_info is not equal to 0:
                Note: Check if variable is moved (offset 48 in OwnershipInfo)
                Let is_moved be proc memory_get_qword with ownership_info, 48

                If is_moved is equal to 1:
                    Note: Use after move violation
                    Let error_msg be "Use of moved variable"
                    proc borrow_checker_report_violation with checker, 1, error_msg, line, 0, arena
                    Return 0
                End If
            End If
        End If
    End If

    Note: Recursively check children nodes
    Let children be proc memory_get_qword with ast_node, 16
    If children is not equal to 0:
        Let child_count be proc size with children
        Let i be 0

        Loop forever:
            If i is greater than or equal to child_count:
                Break
            End If

            Let child be proc get with children, i

            If child is not equal to 0:
                Let child_result be proc borrow_checker_check_borrowing with checker, child, arena

                If child_result is equal to 0:
                    Return 0
                End If
            End If

            Set i to i plus 1
        End Loop
    End If

    Return 1
End Process

Process called "borrow_checker_track_lifetime" takes checker as Integer, variable as Integer, scope_start as Integer, scope_end as Integer, arena as Integer returns Integer:
    Note:
    Tracks lifetime of a variable using arena-based operations.

    Parameters:
    - checker: OWNED BorrowChecker reference
    - variable: Variable to track (OWNED)
    - scope_start: Start scope ID (STACK)
    - scope_end: End scope ID (STACK)
    - arena: Arena for temporary lifetime tracking (ARENA)

    Returns:
    - Integer: OWNED LifetimeInfo or 0 on failure

    Side Effects:
    - Uses ARENA for temporary lifetime tracking
    - Creates OWNED LifetimeInfo
    - Updates lifetime analyzer

    Algorithm:
    1. Validate inputs
    2. Generate unique lifetime ID
    3. Create LifetimeInfo structure
    4. Set lifetime boundaries
    5. Add to lifetime analyzer
    6. Update statistics
    7. Return LifetimeInfo
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If variable is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Get lifetime analyzer (offset 40)
    Let lifetime_analyzer be proc memory_get_qword with checker, 40

    If lifetime_analyzer is equal to 0:
        Return 0
    End If

    Note: Check if lifetime already exists
    Let existing_lifetime be proc get with lifetime_analyzer, variable

    If existing_lifetime is not equal to 0:
        Note: Update existing lifetime boundaries
        Note: Get current end scope (offset 24 in LifetimeInfo)
        Let current_end be proc memory_get_qword with existing_lifetime, 24

        Note: Extend lifetime if necessary
        If scope_end is greater than current_end:
            proc memory_set_qword with existing_lifetime, 24, scope_end
        End If

        Return existing_lifetime
    End If

    Note: Create new LifetimeInfo structure (10 fields Ã— 8 bytes = 80 bytes)
    Let lifetime_size be 80
    Let lifetime_info be proc allocate with lifetime_size

    If lifetime_info is equal to 0:
        Return 0
    End If

    Note: Generate unique lifetime ID
    Let ownership_count be proc memory_get_qword with checker, 80
    Let lifetime_id be ownership_count plus 1
    proc memory_set_qword with checker, 80, lifetime_id

    Note: Determine lifetime type based on scope
    Let lifetime_type be 1

    Note: Initialize LifetimeInfo fields (10 fields)
    proc memory_set_qword with lifetime_info, 0, lifetime_id
    proc memory_set_qword with lifetime_info, 8, variable
    proc memory_set_qword with lifetime_info, 16, lifetime_type
    proc memory_set_qword with lifetime_info, 24, scope_start
    proc memory_set_qword with lifetime_info, 32, scope_end
    proc memory_set_qword with lifetime_info, 40, 0
    proc memory_set_qword with lifetime_info, 48, 0
    proc memory_set_qword with lifetime_info, 56, 1
    proc memory_set_qword with lifetime_info, 64, 0
    proc memory_set_qword with lifetime_info, 72, 0

    Note: Add to lifetime analyzer
    Let set_result be proc set with lifetime_analyzer, variable, lifetime_info

    Return lifetime_info
End Process

Process called "borrow_checker_validate_move" takes checker as Integer, from_variable as Integer, to_variable as Integer, line as Integer, arena as Integer returns Integer:
    Note:
    Validates a move operation using arena-based operations.

    Parameters:
    - checker: OWNED BorrowChecker reference
    - from_variable: Source variable (OWNED)
    - to_variable: Destination variable (OWNED)
    - line: Line where move occurs (STACK)
    - arena: Arena for temporary move validation (ARENA)

    Returns:
    - Integer: Move validation result (STACK) - 1=valid, 0=invalid

    Side Effects:
    - Uses ARENA for temporary move validation
    - Updates ownership information
    - Reports move violations

    Algorithm:
    1. Validate inputs
    2. Check source ownership
    3. Check if source already moved
    4. Check for active borrows
    5. Perform move operation
    6. Update ownership
    7. Return validation result
    :End Note

    If checker is equal to 0:
        Return 0
    End If

    If from_variable is equal to 0:
        Return 0
    End If

    If to_variable is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0
    End If

    Note: Get ownership registry (offset 24)
    Let ownership_registry be proc memory_get_qword with checker, 24

    If ownership_registry is equal to 0:
        Return 0
    End If

    Note: Get source variable ownership
    Let source_ownership be proc get with ownership_registry, from_variable

    If source_ownership is equal to 0:
        Note: No ownership information for source
        Let error_msg be "Cannot move variable without ownership"
        proc borrow_checker_report_violation with checker, 1, error_msg, line, 0, arena
        Return 0
    End If

    Note: Check if source is already moved (offset 48)
    Let is_moved be proc memory_get_qword with source_ownership, 48

    If is_moved is equal to 1:
        Note: Source already moved
        Let error_msg be "Cannot move already-moved variable"
        proc borrow_checker_report_violation with checker, 1, error_msg, line, 0, arena
        Return 0
    End If

    Note: Check for active borrows (offset 56)
    Let borrow_count be proc memory_get_qword with source_ownership, 56

    If borrow_count is greater than 0:
        Note: Cannot move while borrowed
        Let error_msg be "Cannot move borrowed variable"
        proc borrow_checker_report_violation with checker, 3, error_msg, line, 0, arena
        Return 0
    End If

    Note: Perform move operation
    Let move_result be proc borrow_checker_track_move with checker, from_variable, to_variable, line, arena

    If move_result is equal to 0:
        Return 0
    End If

    Note: Mark source as moved
    proc memory_set_qword with source_ownership, 48, 1

    Note: Increment move count (offset 64)
    Let move_count be proc memory_get_qword with source_ownership, 64
    Let new_move_count be move_count plus 1
    proc memory_set_qword with source_ownership, 64, new_move_count

    Note: Increment global move count (offset 96)
    Let global_move_count be proc memory_get_qword with checker, 96
    Let new_global_move_count be global_move_count plus 1
    proc memory_set_qword with checker, 96, new_global_move_count

    Note: Create or update destination ownership
    Let dest_ownership be proc get with ownership_registry, to_variable

    If dest_ownership is equal to 0:
        Note: Create new ownership for destination
        Let new_ownership be proc borrow_checker_track_ownership with checker, to_variable, 1, line, arena

        If new_ownership is equal to 0:
            Return 0
        End If
    End If

    Return 1
End Process