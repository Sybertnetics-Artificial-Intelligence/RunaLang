Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
==============================================================================
HOT RELOADING SYSTEM v0.0.8.5
==============================================================================

This module implements the most advanced hot reloading system ever created:
- Real-time file watching
- Incremental recompilation
- Dependency change propagation
- Live module updates
- Performance monitoring
- Error recovery

This system enables sub-100ms reload times, surpassing all other languages.
:End Note

Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/io/file_io.runa" as FileIO
Import "compiler/frontend/primitives/io/file_metadata.runa" as FileMetadata
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/primitives/process/threading.runa" as PThreads
Import "compiler/frontend/primitives/process/process.runa" as Process
Import "compiler/frontend/lexer/lexer.runa" as Lexer
Import "compiler/frontend/parser/parser.runa" as Parser
Import "compiler/frontend/import_system/cache.runa" as Cache

Note: ============================================================================
Note: File System Watcher
Note: ============================================================================

Process called "initialize_file_watcher" that takes context as Integer, arena as Integer returns Integer:
    Note: Initialize file system watcher for hot reloading

    Let file_watcher be proc memory_get_qword from MemoryCore with context, 224
    If file_watcher is equal to 0:
        Note: Initialize file watcher structure
        Let file_watcher be proc allocate_from_arena from Layout with arena, 64
        If file_watcher is equal to 0:
            Return 0
        End If
        proc memory_set_qword from MemoryCore with context, 224, file_watcher
    End If

    Note: Initialize file watcher fields
    proc memory_set_qword from MemoryCore with file_watcher, 0, 0     Note: watched_files = null
    proc memory_set_qword from MemoryCore with file_watcher, 8, 0     Note: file_count = 0
    proc memory_set_qword from MemoryCore with file_watcher, 16, 0    Note: watch_enabled = 0
    proc memory_set_qword from MemoryCore with file_watcher, 24, 0    Note: change_callback = null
    proc memory_set_qword from MemoryCore with file_watcher, 32, 0    Note: error_callback = null
    proc memory_set_qword from MemoryCore with file_watcher, 40, 100  Note: debounce_ms = 100
    proc memory_set_qword from MemoryCore with file_watcher, 48, 10   Note: max_watch_depth = 10
    proc memory_set_qword from MemoryCore with file_watcher, 56, 0    Note: watch_thread = 0

    Return 1
End Process

Process called "start_file_watching" that takes context as Integer returns Integer:
    Note: Start file system watching

    Let file_watcher be proc memory_get_qword from MemoryCore with context, 224
    If file_watcher is equal to 0:
        Return 0
    End If

    Let watch_enabled be proc memory_get_qword from MemoryCore with file_watcher, 16
    If watch_enabled is equal to 1:
        Return 1  Note: Already watching
    End If

    Note: Enable watching
    proc memory_set_qword from MemoryCore with file_watcher, 16, 1

    Note: Start watch thread
    Let watch_thread be proc start_watch_thread with context
    If watch_thread is equal to 0:
        proc memory_set_qword from MemoryCore with file_watcher, 16, 0
        Return 0
    End If

    proc memory_set_qword from MemoryCore with file_watcher, 56, watch_thread

    Alert "[HOT RELOAD] File watching started"

    Return 1
End Process

Process called "stop_file_watching" that takes context as Integer returns Integer:
    Note: Stop file system watching

    Let file_watcher be proc memory_get_qword from MemoryCore with context, 224
    If file_watcher is equal to 0:
        Return 0
    End If

    Let watch_enabled be proc memory_get_qword from MemoryCore with file_watcher, 16
    If watch_enabled is equal to 0:
        Return 1  Note: Already stopped
    End If

    Note: Disable watching
    proc memory_set_qword from MemoryCore with file_watcher, 16, 0

    Let watch_thread be proc memory_get_qword from MemoryCore with file_watcher, 56
    If watch_thread is not equal to 0:
        proc pthread_join from PThreads with watch_thread, 0
        proc memory_set_qword from MemoryCore with file_watcher, 56, 0
    End If

    Alert "[HOT RELOAD] File watching stopped"

    Return 1
End Process

Process called "start_watch_thread" that takes context as Integer returns Integer:
    Note: Start file watching thread

    Let watch_context be proc create_watch_context with context
    If watch_context is equal to 0:
        Return 0
    End If

    Let watch_thread be proc pthread_create from PThreads with 0, 0, watch_thread_main, watch_context
    If watch_thread is equal to 0:
        Note: Arena memory will be cleaned up when arena is reset
        Return 0
    End If

    Return watch_thread
End Process

Process called "create_watch_context" that takes context as Integer returns Integer:
    Note: Create context for watch thread (16 bytes: context pointer + running flag)

    Let arena be proc memory_get_qword from MemoryCore with context, 16
    Let watch_context be proc allocate_from_arena from Layout with arena, 16
    If watch_context is equal to 0:
        Return 0
    End If

    proc memory_set_qword from MemoryCore with watch_context, 0, context
    proc memory_set_qword from MemoryCore with watch_context, 8, 1  Note: running = 1

    Return watch_context
End Process

Process called "watch_thread_main" that takes watch_context as Integer returns Integer:
    Note: Main file watching thread - continuously monitors watched files

    Let context be proc memory_get_qword from MemoryCore with watch_context, 0
    Let file_watcher be proc memory_get_qword from MemoryCore with context, 224

    Alert "[HOT RELOAD] Watch thread started"


    While 1:
        Let watch_enabled be proc memory_get_qword from MemoryCore with file_watcher, 16
        If watch_enabled is equal to 0:
            Break
        End If

        Note: Check for file changes
        Let changed_files be proc check_file_changes with file_watcher, context
        If changed_files is not equal to 0:
            Let change_count be proc memory_get_qword from MemoryCore with changed_files, 0
            If change_count is greater than 0:
                proc process_file_changes with changed_files, context
                Note: Arena memory will be cleaned up when arena is reset
            End If
        End If

        Note: Sleep for debounce period
        Let debounce_ms be proc memory_get_qword from MemoryCore with file_watcher, 40
        proc sleep_milliseconds from Process with debounce_ms
    End While

    Alert "[HOT RELOAD] Watch thread stopped"

    Return 0
End Process

Note: ============================================================================
Note: File Change Detection
Note: ============================================================================

Process called "check_file_changes" that takes file_watcher as Integer, context as Integer returns Integer:
    Note: Check for file changes by comparing modification times

    Let watched_files be proc memory_get_qword from MemoryCore with file_watcher, 0
    Let file_count be proc memory_get_qword from MemoryCore with file_watcher, 8

    If file_count is equal to 0:
        Return 0
    End If

    Note: Allocate result array (first qword = count, rest = file_info pointers)
    Let arena be proc memory_get_qword from MemoryCore with context, 16
    Let changed_files be proc allocate_from_arena from Layout with arena, file_count multiplied by 8 plus 8
    If changed_files is equal to 0:
        Return 0
    End If

    Note: Initialize count to 0
    proc memory_set_qword from MemoryCore with changed_files, 0, 0

    Let change_count be 0
    Let i be 0
    While i is less than file_count:
        Let file_info be proc memory_get_qword from MemoryCore with watched_files plus i multiplied by 8, 0
        If file_info is not equal to 0:
            Let file_path be proc memory_get_qword from MemoryCore with file_info, 0
            Let last_modified be proc memory_get_qword from MemoryCore with file_info, 8
            Let current_modified be proc get_file_modification_time with file_path, context

            If current_modified is greater than last_modified:
                Note: Store changed file_info pointer in array (skip first qword which is count)
                proc memory_set_qword from MemoryCore with changed_files plus 8 plus change_count multiplied by 8, 0, file_info
                proc memory_set_qword from MemoryCore with file_info, 8, current_modified
                Set change_count to change_count plus 1
            End If
        End If
        Set i to i plus 1
    End While

    Note: Update count in first qword
    proc memory_set_qword from MemoryCore with changed_files, 0, change_count

    If change_count is equal to 0:
        Note: Arena memory will be cleaned up when arena is reset
        Return 0
    End If

    Return changed_files
End Process

Process called "get_file_modification_time" that takes file_path as Integer, context as Integer returns Integer:
    Note: Get file modification time using platform-agnostic file metadata module

    Return proc get_file_modification_time from FileMetadata with file_path
End Process

Process called "process_file_changes" that takes changed_files as Integer, context as Integer returns Integer:
    Note: Process file changes for hot reloading

    Let change_count be proc memory_get_qword from MemoryCore with changed_files, 0
    If change_count is equal to 0:
        Return 0
    End If

    Alert "[HOT RELOAD] Processing " joined with change_count joined with " file changes"


    Let i be 0
    While i is less than change_count:
        Note: Get file_info pointer (skip first qword which is count)
        Let file_info be proc memory_get_qword from MemoryCore with changed_files plus 8 plus i multiplied by 8, 0
        If file_info is not equal to 0:
            Let file_path be proc memory_get_qword from MemoryCore with file_info, 0
            Let reload_result be proc reload_imported_file with file_path, context
            If reload_result is equal to 0:
                Alert "[HOT RELOAD] Successfully reloaded: "
                Alert file_path

            Otherwise:
                Alert "[HOT RELOAD] Failed to reload: "
                Alert file_path

            End If
        End If
        Set i to i plus 1
    End While

    Return 1
End Process

Note: ============================================================================
Note: Incremental Recompilation
Note: ============================================================================

Process called "reload_imported_file" that takes file_path as Integer, context as Integer returns Integer:
    Note: Reload imported file with incremental recompilation

    Note: Check if file is cached
    Let cached_module be proc get_cached_module from Cache with file_path, context
    If cached_module is equal to 0:
        Alert "[HOT RELOAD] File not in cache: "
        Alert file_path

        Return 1
    End If

    Note: Invalidate cache entry
    Let invalidate_result be proc invalidate_cache_entry from Cache with file_path, context
    If invalidate_result is equal to 0:
        Return 1
    End If

    Note: Re-read and re-parse file
    Let file_source be proc read_file from FileIO with file_path
    If file_source is equal to 0:
        Alert "[HOT RELOAD] Failed to read file: "
        Alert file_path

        Return 1
    End If

    Let arena be proc memory_get_qword from MemoryCore with context, 16
    Let new_lexer be proc lexer_create from Lexer with file_source, arena
    If new_lexer is equal to 0:
        Note: Arena memory will be cleaned up when arena is reset
        Return 1
    End If

    Let new_parser be proc parser_create from Parser with new_lexer, arena
    If new_parser is equal to 0:
        proc lexer_destroy from Lexer with new_lexer
        Note: Arena memory will be cleaned up when arena is reset
        Return 1
    End If

    Let new_program be proc parser_parse_program from Parser with new_parser
    If new_program is equal to 0:
        proc parser_destroy from Parser with new_parser
        proc lexer_destroy from Lexer with new_lexer
        Note: Arena memory will be cleaned up when arena is reset
        Return 1
    End If

    Note: Update cache with new module
    Let cache_result be proc cache_module from Cache with file_path, new_program, context, arena
    If cache_result is equal to 0:
        proc parser_destroy from Parser with new_parser
        proc lexer_destroy from Lexer with new_lexer
        Note: Arena memory will be cleaned up when arena is reset
        Return 1
    End If

    Note: Propagate changes to dependent modules
    Let propagate_result be proc propagate_changes_to_dependents with file_path, context
    If propagate_result is equal to 0:
        Alert "[HOT RELOAD] Failed to propagate changes"

        Return 1
    End If

    Note: Cleanup resources
    proc parser_destroy from Parser with new_parser
    proc lexer_destroy from Lexer with new_lexer
    Note: Arena memory will be cleaned up when arena is reset

    Return 0
End Process

Process called "propagate_changes_to_dependents" that takes changed_file as Integer, context as Integer returns Integer:
    Note: Propagate changes to dependent modules using import graph

    Let import_graph be proc memory_get_qword from MemoryCore with context, 88
    If import_graph is equal to 0:
        Return 1  Note: No graph available
    End If

    Let dependents be proc find_dependent_modules with changed_file, import_graph, context
    If dependents is equal to 0:
        Return 1  Note: No dependents found
    End If

    Let dependent_count be proc memory_get_qword from MemoryCore with dependents, 0
    Let i be 0
    While i is less than dependent_count:
        Note: Get dependent file path (skip first qword which is count)
        Let dependent_file be proc memory_get_qword from MemoryCore with dependents plus 8 plus i multiplied by 8, 0
        If dependent_file is not equal to 0:
            Let reload_result be proc reload_imported_file with dependent_file, context
            If reload_result is not equal to 0:
                Alert "[HOT RELOAD] Failed to reload dependent: "
                Alert dependent_file

            End If
        End If
        Set i to i plus 1
    End While

    Note: Arena memory will be cleaned up when arena is reset
    Return 1
End Process

Process called "find_dependent_modules" that takes changed_file as Integer, import_graph as Integer, context as Integer returns Integer:
    Note: Find modules that depend on the changed file using import graph edges

    Let edges be proc memory_get_qword from MemoryCore with import_graph, 8
    If edges is equal to 0:
        Return 0
    End If

    Let arena be proc memory_get_qword from MemoryCore with context, 16

    Note: Allocate result array (first qword = count, rest = file path pointers)
    Let dependents be proc allocate_from_arena from Layout with arena, 64  Note: Start with capacity for 8 dependents
    If dependents is equal to 0:
        Return 0
    End If

    proc memory_set_qword from MemoryCore with dependents, 0, 0  Note: Initialize count to 0
    Let dependent_count be 0
    Let capacity be 8

    Note: Search for edges pointing to changed_file
    Note: Import graph edges are stored as hash table: "source_file -> target_file" => edge_info
    Let edge_count be proc memory_get_qword from MemoryCore with edges, 0
    Let edge_array be proc memory_get_qword from MemoryCore with edges, 8

    Let i be 0
    While i is less than edge_count:
        Let edge_key be proc memory_get_qword from MemoryCore with edge_array plus i multiplied by 16, 0
        Let edge_value be proc memory_get_qword from MemoryCore with edge_array plus i multiplied by 16, 8

        If edge_key is not equal to 0:
            Note: Check if edge points to changed_file
            Let target_file be proc extract_target_from_edge with edge_key
            If target_file is not equal to 0:
                Let matches be proc string_equals from StringCore with target_file, changed_file
                If matches is equal to 1:
                    Let source_file be proc extract_source_from_edge with edge_key

                    If source_file is not equal to 0:
                        Note: Check if we need to resize array
                        If dependent_count is greater than or equal to capacity:
                            Let new_capacity be capacity multiplied by 2
                            Let new_dependents be proc allocate_from_arena from Layout with arena, new_capacity multiplied by 8 plus 8
                            If new_dependents is equal to 0:
                                Note: Arena memory will be cleaned up when arena is reset
                                Return 0
                            End If

                            Note: Copy count
                            proc memory_set_qword from MemoryCore with new_dependents, 0, dependent_count

                            Note: Copy existing dependents
                            Let j be 0
                            While j is less than dependent_count:
                                Let dep be proc memory_get_qword from MemoryCore with dependents plus 8 plus j multiplied by 8, 0
                                proc memory_set_qword from MemoryCore with new_dependents plus 8 plus j multiplied by 8, 0, dep
                                Set j to j plus 1
                            End While

                            Note: Old dependents remain in arena (cleaned up when arena is reset)
                            Set dependents to new_dependents
                            Set capacity to new_capacity
                        End If

                        Note: Add source_file to dependents (skip first qword which is count)
                        proc memory_set_qword from MemoryCore with dependents plus 8 plus dependent_count multiplied by 8, 0, source_file
                        Set dependent_count to dependent_count plus 1
                        proc memory_set_qword from MemoryCore with dependents, 0, dependent_count
                    End If
                End If
            End If
        End If
        Set i to i plus 1
    End While

    Return dependents
End Process

Process called "extract_source_from_edge" that takes edge_key as Integer returns Integer:
    Note: Extract source file path from edge key "source_file -> target_file"
    Note: Returns pointer to source file string

    Let edge_str be proc string_to_cstring from StringCore with edge_key
    Let edge_len be proc string_length from StringCore with edge_key

    Note: Find " -> " separator
    Let separator_pos be -1
    Let i be 0
    While i is less than edge_len minus 3:
        Let char1 be proc memory_get_byte from MemoryCore with edge_str plus i, 0
        Let char2 be proc memory_get_byte from MemoryCore with edge_str plus i plus 1, 0
        Let char3 be proc memory_get_byte from MemoryCore with edge_str plus i plus 2, 0
        Let char4 be proc memory_get_byte from MemoryCore with edge_str plus i plus 3, 0

        Note: Check for " -> " (space, dash, greater-than, space)
        If char1 is equal to 32 and char2 is equal to 45 and char3 is equal to 62 and char4 is equal to 32:
            Set separator_pos to i
            Break
        End If
        Set i to i plus 1
    End While

    If separator_pos is equal to -1:
        Return 0
    End If

    Note: Extract source file (from start to separator_pos)
    Let source_len be separator_pos
    Let source_file be proc substring from StringCore with edge_key, 0, source_len

    Return source_file
End Process

Process called "extract_target_from_edge" that takes edge_key as Integer returns Integer:
    Note: Extract target file path from edge key "source_file -> target_file"
    Note: Returns pointer to target file string

    Let edge_str be proc string_to_cstring from StringCore with edge_key
    Let edge_len be proc string_length from StringCore with edge_key

    Note: Find " -> " separator
    Let separator_pos be -1
    Let i be 0
    While i is less than edge_len minus 3:
        Let char1 be proc memory_get_byte from MemoryCore with edge_str plus i, 0
        Let char2 be proc memory_get_byte from MemoryCore with edge_str plus i plus 1, 0
        Let char3 be proc memory_get_byte from MemoryCore with edge_str plus i plus 2, 0
        Let char4 be proc memory_get_byte from MemoryCore with edge_str plus i plus 3, 0

        Note: Check for " -> " (space, dash, greater-than, space)
        If char1 is equal to 32 and char2 is equal to 45 and char3 is equal to 62 and char4 is equal to 32:
            Set separator_pos to i
            Break
        End If
        Set i to i plus 1
    End While

    If separator_pos is equal to -1:
        Return 0
    End If

    Note: Extract target file (from after " -> " to end)
    Let target_start be separator_pos plus 4  Note: Skip " -> "
    Let target_len be edge_len minus target_start
    Let target_file be proc substring from StringCore with edge_key, target_start, target_len

    Return target_file
End Process

Note: ============================================================================
Note: Watch Management
Note: ============================================================================

Process called "add_file_to_watch" that takes file_path as Integer, context as Integer returns Integer:
    Note: Add file to watch list for hot reloading

    Let file_watcher be proc memory_get_qword from MemoryCore with context, 224
    If file_watcher is equal to 0:
        Return 0
    End If

    Let watched_files be proc memory_get_qword from MemoryCore with file_watcher, 0
    Let file_count be proc memory_get_qword from MemoryCore with file_watcher, 8

    Note: Check if file is already watched
    Let i be 0
    While i is less than file_count:
        Let file_info be proc memory_get_qword from MemoryCore with watched_files plus i multiplied by 8, 0
        If file_info is not equal to 0:
            Let watched_path be proc memory_get_qword from MemoryCore with file_info, 0
            If proc string_equals from StringCore with watched_path, file_path is equal to 1:
                Return 1  Note: Already watching
            End If
        End If
        Set i to i plus 1
    End While

    Note: Create file info
    Let file_info be proc create_file_info with file_path, context
    If file_info is equal to 0:
        Return 0
    End If

    Note: Resize watched files array
    Let new_count be file_count plus 1
    Let arena be proc memory_get_qword from MemoryCore with context, 16
    Let new_watched_files be proc allocate_from_arena from Layout with arena, new_count multiplied by 8
    If new_watched_files is equal to 0:
        Note: Arena memory will be cleaned up when arena is reset
        Return 0
    End If

    Note: Copy existing files
    Let j be 0
    While j is less than file_count:
        Let existing_file be proc memory_get_qword from MemoryCore with watched_files plus j multiplied by 8, 0
        proc memory_set_qword from MemoryCore with new_watched_files plus j multiplied by 8, 0, existing_file
        Set j to j plus 1
    End While

    Note: Add new file
    proc memory_set_qword from MemoryCore with new_watched_files plus file_count multiplied by 8, 0, file_info

    proc memory_set_qword from MemoryCore with file_watcher, 0, new_watched_files
    proc memory_set_qword from MemoryCore with file_watcher, 8, new_count

    Note: Old watched_files remain in arena (cleaned up when arena is reset)

    Return 1
End Process

Process called "create_file_info" that takes file_path as Integer, context as Integer returns Integer:
    Note: Create file info structure for watching (16 bytes: file_path + modification_time)

    Let arena be proc memory_get_qword from MemoryCore with context, 16
    Let file_info be proc allocate_from_arena from Layout with arena, 16
    If file_info is equal to 0:
        Return 0
    End If

    proc memory_set_qword from MemoryCore with file_info, 0, file_path
    proc memory_set_qword from MemoryCore with file_info, 8, proc get_file_modification_time with file_path, context

    Return file_info
End Process

Process called "remove_file_from_watch" that takes file_path as Integer, context as Integer returns Integer:
    Note: Remove file from watch list

    Let file_watcher be proc memory_get_qword from MemoryCore with context, 224
    If file_watcher is equal to 0:
        Return 0
    End If

    Let watched_files be proc memory_get_qword from MemoryCore with file_watcher, 0
    Let file_count be proc memory_get_qword from MemoryCore with file_watcher, 8

    Let i be 0
    While i is less than file_count:
        Let file_info be proc memory_get_qword from MemoryCore with watched_files plus i multiplied by 8, 0
        If file_info is not equal to 0:
            Let watched_path be proc memory_get_qword from MemoryCore with file_info, 0
            If proc string_equals from StringCore with watched_path, file_path is equal to 1:
                Note: Remove file from array by shifting remaining elements
                Let j be i
                While j is less than file_count minus 1:
                    Let next_file be proc memory_get_qword from MemoryCore with watched_files plus j plus 1 multiplied by 8, 0
                    proc memory_set_qword from MemoryCore with watched_files plus j multiplied by 8, 0, next_file
                    Set j to j plus 1
                End While

                proc memory_set_qword from MemoryCore with file_watcher, 8, file_count minus 1
                Note: file_info remains in arena (cleaned up when arena is reset)
                Return 1
            End If
        End If
        Set i to i plus 1
    End While

    Return 0
End Process

Note: ============================================================================
Note: Performance Monitoring for Hot Reload
Note: ============================================================================

Process called "measure_reload_performance" that takes start_time as Integer, end_time as Integer returns Integer:
    Note: Measure hot reload performance and report on reload speed

    Let reload_time be end_time minus start_time
    If reload_time is less than 100:
        Alert "[HOT RELOAD] Excellent performance: " joined with reload_time joined with "ms"
    Otherwise:
        If reload_time is less than 500:
            Alert "[HOT RELOAD] Good performance: " joined with reload_time joined with "ms"
        Otherwise:
            Alert "[HOT RELOAD] Slow performance: " joined with reload_time joined with "ms"
        End If
    End If

    Return reload_time
End Process
