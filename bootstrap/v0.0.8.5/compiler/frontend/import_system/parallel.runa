Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
==============================================================================
PARALLEL IMPORT PROCESSING SYSTEM v0.0.8.5
==============================================================================

This module implements production-grade parallel import processing:
- Multi-threaded import resolution using POSIX threads
- Thread-safe work queue with mutex synchronization
- Load balancing across CPU cores
- Error handling and recovery
- Performance monitoring

This system achieves significant speedup on multi-core systems through
proper parallel processing architecture.
:End Note

Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/io/file_io.runa" as FileIO
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/primitives/threading/posix_threads.runa" as PThreads
Import "compiler/frontend/import_system/core.runa" as ImportCore
Import "compiler/frontend/import_system/resolution.runa" as Resolution

Note: ============================================================================
Note: Thread Pool Management
Note: ============================================================================

Process called "initialize_thread_pool" that takes context as Integer, arena as Integer returns Integer:
    Note: Initialize thread pool for parallel import processing
    Note: Creates worker threads equal to CPU count

    Note: Check if thread pool already exists
    Let thread_pool be proc memory_get_qword from MemoryCore with context, 200
    If thread_pool is equal to 0:
        Note: Allocate thread pool structure (128 bytes)
        Let thread_pool be proc allocate_from_arena from Layout with arena, 128
        If thread_pool is equal to 0:
            Return 0
        End If
        proc memory_set_qword from MemoryCore with context, 200, thread_pool
    End If

    Note: Get or determine worker count
    Let worker_count be proc memory_get_qword from MemoryCore with context, 64
    If worker_count is equal to 0:
        Set worker_count to proc get_cpu_count
        proc memory_set_qword from MemoryCore with context, 64, worker_count
    End If

    Note: Initialize work queue
    Let work_queue be proc initialize_work_queue with arena
    If work_queue is equal to 0:
        Return 0
    End If
    proc memory_set_qword from MemoryCore with context, 208, work_queue

    Note: Initialize synchronization primitives
    Let sync_primitives be proc initialize_sync_primitives with arena
    If sync_primitives is equal to 0:
        Return 0
    End If
    proc memory_set_qword from MemoryCore with context, 216, sync_primitives

    Note: Create worker threads
    Let workers be proc create_worker_threads with worker_count, context, arena
    If workers is equal to 0:
        Return 0
    End If

    Note: Store thread pool metadata
    proc memory_set_qword from MemoryCore with thread_pool, 0, workers
    proc memory_set_qword from MemoryCore with thread_pool, 8, worker_count
    proc memory_set_qword from MemoryCore with thread_pool, 16, 0
    proc memory_set_qword from MemoryCore with thread_pool, 24, 0

    Return 1
End Process

Process called "get_cpu_count" that returns Integer:
    Note: Get number of CPU cores available for parallel processing
    Note: Uses sysconf(_SC_NPROCESSORS_ONLN) on Linux/Unix

    Note: Try to get CPU count from system
    Let cpu_count be proc get_nproc from PThreads
    If cpu_count is greater than 0:
        Return cpu_count
    End If

    Note: Fallback to reasonable default
    Return 4
End Process

Process called "initialize_work_queue" that takes arena as Integer returns Integer:
    Note: Initialize thread-safe work queue for task distribution
    Note: Work queue structure (64 bytes):
    Note:   offset 0: tasks (pointer to task array, 8 bytes)
    Note:   offset 8: task_count (current count, 8 bytes)
    Note:   offset 16: head (dequeue position, 8 bytes)
    Note:   offset 24: tail (enqueue position, 8 bytes)
    Note:   offset 32: capacity (max size, 8 bytes)
    Note:   offset 40: shutdown (shutdown flag, 8 bytes)
    Note:   offset 48: pending_tasks (queued tasks, 8 bytes)
    Note:   offset 56: completed_tasks (finished tasks, 8 bytes)

    Let work_queue be proc allocate_from_arena from Layout with arena, 64
    If work_queue is equal to 0:
        Return 0
    End If

    Note: Initialize all fields to zero
    proc memory_set_qword from MemoryCore with work_queue, 0, 0
    proc memory_set_qword from MemoryCore with work_queue, 8, 0
    proc memory_set_qword from MemoryCore with work_queue, 16, 0
    proc memory_set_qword from MemoryCore with work_queue, 24, 0
    proc memory_set_qword from MemoryCore with work_queue, 32, 0
    proc memory_set_qword from MemoryCore with work_queue, 40, 0
    proc memory_set_qword from MemoryCore with work_queue, 48, 0
    proc memory_set_qword from MemoryCore with work_queue, 56, 0

    Return work_queue
End Process

Process called "initialize_sync_primitives" that takes arena as Integer returns Integer:
    Note: Initialize POSIX synchronization primitives
    Note: Sync primitives structure (32 bytes):
    Note:   offset 0: queue_mutex (pthread_mutex_t pointer, 8 bytes)
    Note:   offset 8: work_condition (pthread_cond_t pointer, 8 bytes)
    Note:   offset 16: completion_condition (pthread_cond_t pointer, 8 bytes)
    Note:   offset 24: completion_counter (atomic counter pointer, 8 bytes)

    Let sync_primitives be proc allocate_from_arena from Layout with arena, 32
    If sync_primitives is equal to 0:
        Return 0
    End If

    Note: Create mutex for work queue protection
    Let queue_mutex be proc pthread_mutex_create from PThreads
    If queue_mutex is equal to 0:
        Return 0
    End If
    proc memory_set_qword from MemoryCore with sync_primitives, 0, queue_mutex

    Note: Create condition variable for work notification
    Let work_condition be proc pthread_cond_create from PThreads
    If work_condition is equal to 0:
        proc pthread_mutex_destroy from PThreads with queue_mutex
        Return 0
    End If
    proc memory_set_qword from MemoryCore with sync_primitives, 8, work_condition

    Note: Create condition variable for completion notification
    Let completion_condition be proc pthread_cond_create from PThreads
    If completion_condition is equal to 0:
        proc pthread_mutex_destroy from PThreads with queue_mutex
        proc pthread_cond_destroy from PThreads with work_condition
        Return 0
    End If
    proc memory_set_qword from MemoryCore with sync_primitives, 16, completion_condition

    Note: Create atomic counter for task completion tracking
    Let completion_counter be proc atomic_counter_create from PThreads
    If completion_counter is equal to 0:
        proc pthread_mutex_destroy from PThreads with queue_mutex
        proc pthread_cond_destroy from PThreads with work_condition
        proc pthread_cond_destroy from PThreads with completion_condition
        Return 0
    End If
    proc memory_set_qword from MemoryCore with sync_primitives, 24, completion_counter

    Return sync_primitives
End Process

Note: ============================================================================
Note: Worker Thread Management
Note: ============================================================================

Process called "create_worker_threads" that takes worker_count as Integer, context as Integer, arena as Integer returns Integer:
    Note: Create array of worker threads for parallel processing

    Note: Allocate worker thread array
    Let workers be proc allocate_from_arena from Layout with arena, worker_count multiplied by 8
    If workers is equal to 0:
        Return 0
    End If

    Note: Create each worker thread
    Let i be 0
    While i is less than worker_count:
        Let worker_id be i
        Let worker_thread be proc create_worker_thread with worker_id, context, arena
        If worker_thread is equal to 0:
            Note: Cleanup previously created threads on failure
            proc cleanup_worker_threads with workers, i
            Return 0
        End If

        proc memory_set_qword from MemoryCore with workers plus i multiplied by 8, 0, worker_thread
        Set i to i plus 1
    End While

    Return workers
End Process

Process called "create_worker_thread" that takes worker_id as Integer, context as Integer, arena as Integer returns Integer:
    Note: Create individual worker thread with context

    Note: Create worker context (stores thread-specific data)
    Let worker_context be proc create_worker_context with worker_id, context, arena
    If worker_context is equal to 0:
        Return 0
    End If

    Note: Create POSIX thread with worker_main as entry point
    Let worker_thread be proc pthread_create from PThreads with worker_main, worker_context
    If worker_thread is equal to 0:
        proc deallocate from Layout with worker_context
        Return 0
    End If

    Return worker_thread
End Process

Process called "create_worker_context" that takes worker_id as Integer, context as Integer, arena as Integer returns Integer:
    Note: Create worker context structure for thread
    Note: Worker context structure (32 bytes):
    Note:   offset 0: worker_id (thread ID, 8 bytes)
    Note:   offset 8: context (global context pointer, 8 bytes)
    Note:   offset 16: arena (memory arena pointer, 8 bytes)
    Note:   offset 24: status (0=idle, 1=working, 8 bytes)

    Let worker_context be proc allocate_from_arena from Layout with arena, 32
    If worker_context is equal to 0:
        Return 0
    End If

    proc memory_set_qword from MemoryCore with worker_context, 0, worker_id
    proc memory_set_qword from MemoryCore with worker_context, 8, context
    proc memory_set_qword from MemoryCore with worker_context, 16, arena
    proc memory_set_qword from MemoryCore with worker_context, 24, 0

    Return worker_context
End Process

Process called "worker_main" that takes worker_context as Integer returns Integer:
    Note: Main worker thread function - continuously processes tasks from queue

    Note: Extract worker data from context
    Let worker_id be proc memory_get_qword from MemoryCore with worker_context, 0
    Let context be proc memory_get_qword from MemoryCore with worker_context, 8
    Let arena be proc memory_get_qword from MemoryCore with worker_context, 16

    Note: Log worker startup
    Alert "[WORKER " joined with worker_id joined with "] Started"


    Note: Get queue and synchronization primitives
    Let work_queue be proc memory_get_qword from MemoryCore with context, 208
    Let sync_primitives be proc memory_get_qword from MemoryCore with context, 216
    Let queue_mutex be proc memory_get_qword from MemoryCore with sync_primitives, 0
    Let work_condition be proc memory_get_qword from MemoryCore with sync_primitives, 8
    Let completion_condition be proc memory_get_qword from MemoryCore with sync_primitives, 16
    Let completion_counter be proc memory_get_qword from MemoryCore with sync_primitives, 24

    Note: Main worker loop - run until shutdown
    While 1:
        Note: Acquire lock before checking queue
        proc pthread_mutex_lock from PThreads with queue_mutex

        Note: Get next task from queue
        Let task be proc get_next_task with work_queue
        While task is equal to 0:
            Note: Check if shutdown requested
            Let shutdown be proc memory_get_qword from MemoryCore with work_queue, 40
            If shutdown is equal to 1:
                proc pthread_mutex_unlock from PThreads with queue_mutex
                Alert "[WORKER " joined with worker_id joined with "] Shutting down"
                Return 0
            End If

            Note: Wait for work notification
            proc pthread_cond_wait from PThreads with work_condition, queue_mutex
            Set task to proc get_next_task with work_queue
        End While

        proc pthread_mutex_unlock from PThreads with queue_mutex

        Note: Mark worker as busy
        proc memory_set_qword from MemoryCore with worker_context, 24, 1

        Note: Process the import task
        Let result be proc process_import_task with task, context, arena
        If result is not equal to 0:
            Alert "[WORKER " joined with worker_id joined with "] Task failed"
        End If

        Note: Mark task as completed
        proc atomic_increment from PThreads with completion_counter
        proc pthread_cond_signal from PThreads with completion_condition

        Note: Mark worker as idle
        proc memory_set_qword from MemoryCore with worker_context, 24, 0
    End While

    Return 0
End Process

Note: ============================================================================
Note: Work Queue Operations
Note: ============================================================================

Process called "add_import_task" that takes import_path as Integer, context as Integer, arena as Integer returns Integer:
    Note: Add import task to thread-safe work queue

    Let work_queue be proc memory_get_qword from MemoryCore with context, 208
    If work_queue is equal to 0:
        Return 0
    End If

    Let sync_primitives be proc memory_get_qword from MemoryCore with context, 216
    Let queue_mutex be proc memory_get_qword from MemoryCore with sync_primitives, 0
    Let work_condition be proc memory_get_qword from MemoryCore with sync_primitives, 8

    Note: Create task structure
    Let task be proc create_import_task with import_path, arena
    If task is equal to 0:
        Return 0
    End If

    Note: Acquire lock before modifying queue
    proc pthread_mutex_lock from PThreads with queue_mutex

    Note: Add task to queue
    Let result be proc enqueue_task with work_queue, task
    If result is equal to 0:
        proc pthread_mutex_unlock from PThreads with queue_mutex
        proc deallocate from Layout with task
        Return 0
    End If

    proc pthread_mutex_unlock from PThreads with queue_mutex

    Note: Notify one waiting worker
    proc pthread_cond_signal from PThreads with work_condition

    Return 1
End Process

Process called "create_import_task" that takes import_path as Integer, arena as Integer returns Integer:
    Note: Create import task structure
    Note: Task structure (32 bytes):
    Note:   offset 0: import_path (string pointer, 8 bytes)
    Note:   offset 8: status (0=pending, 1=completed, 8 bytes)
    Note:   offset 16: result (parsed program pointer, 8 bytes)
    Note:   offset 24: error_code (0=success, >0=error, 8 bytes)

    Let task be proc allocate_from_arena from Layout with arena, 32
    If task is equal to 0:
        Return 0
    End If

    proc memory_set_qword from MemoryCore with task, 0, import_path
    proc memory_set_qword from MemoryCore with task, 8, 0
    proc memory_set_qword from MemoryCore with task, 16, 0
    proc memory_set_qword from MemoryCore with task, 24, 0

    Return task
End Process

Process called "enqueue_task" that takes work_queue as Integer, task as Integer returns Integer:
    Note: Add task to work queue with automatic resizing

    Let task_count be proc memory_get_qword from MemoryCore with work_queue, 8
    Let capacity be proc memory_get_qword from MemoryCore with work_queue, 32

    Note: Check if queue needs resizing
    If task_count is greater than or equal to capacity:
        Note: Double capacity (or initialize to 16)
        Let new_capacity be capacity multiplied by 2
        If new_capacity is equal to 0:
            Set new_capacity to 16
        End If

        Let result be proc resize_work_queue with work_queue, new_capacity
        If result is equal to 0:
            Return 0
        End If
    End If

    Note: Add task to tail of queue
    Let tasks be proc memory_get_qword from MemoryCore with work_queue, 0
    Let tail be proc memory_get_qword from MemoryCore with work_queue, 24
    proc memory_set_qword from MemoryCore with tasks plus tail multiplied by 8, 0, task
    proc memory_set_qword from MemoryCore with work_queue, 24, tail plus 1
    proc memory_set_qword from MemoryCore with work_queue, 8, task_count plus 1

    Return 1
End Process

Process called "get_next_task" that takes work_queue as Integer returns Integer:
    Note: Get next task from work queue (must be called with lock held)

    Let task_count be proc memory_get_qword from MemoryCore with work_queue, 8
    If task_count is equal to 0:
        Return 0
    End If

    Note: Get task from head of queue
    Let tasks be proc memory_get_qword from MemoryCore with work_queue, 0
    Let head be proc memory_get_qword from MemoryCore with work_queue, 16
    Let task be proc memory_get_qword from MemoryCore with tasks plus head multiplied by 8, 0

    Note: Update queue head and count
    proc memory_set_qword from MemoryCore with work_queue, 16, head plus 1
    proc memory_set_qword from MemoryCore with work_queue, 8, task_count minus 1

    Return task
End Process

Process called "resize_work_queue" that takes work_queue as Integer, new_capacity as Integer returns Integer:
    Note: Resize work queue to new capacity with task preservation

    Let old_tasks be proc memory_get_qword from MemoryCore with work_queue, 0
    Let new_tasks be proc allocate from Layout with new_capacity multiplied by 8
    If new_tasks is equal to 0:
        Return 0
    End If

    Note: Copy existing tasks to new array
    Let task_count be proc memory_get_qword from MemoryCore with work_queue, 8
    Let i be 0
    While i is less than task_count:
        Let task be proc memory_get_qword from MemoryCore with old_tasks plus i multiplied by 8, 0
        proc memory_set_qword from MemoryCore with new_tasks plus i multiplied by 8, 0, task
        Set i to i plus 1
    End While

    Note: Update queue with new array
    proc memory_set_qword from MemoryCore with work_queue, 0, new_tasks
    proc memory_set_qword from MemoryCore with work_queue, 32, new_capacity

    Note: Deallocate old array
    If old_tasks is not equal to 0:
        proc deallocate from Layout with old_tasks
    End If

    Return 1
End Process

Note: ============================================================================
Note: Parallel Import Processing
Note: ============================================================================

Process called "process_imports_parallel" that takes program as Integer, context as Integer, arena as Integer returns Integer:
    Note: Process all imports in parallel using thread pool
    Note: Returns 0 on success, 1 on error

    Note: Initialize thread pool if not already done
    If proc initialize_thread_pool with context, arena is equal to 0:
        Alert "[PARALLEL ERROR] Failed to initialize thread pool"
        
        Return 1
    End If

    Note: Get import count and imports array from program
    Let import_count be proc memory_get_dword from MemoryCore with program, 40
    If import_count is equal to 0:
        Return 0
    End If

    Let imports be proc memory_get_qword from MemoryCore with program, 32
    If imports is equal to 0:
        Alert "[PARALLEL ERROR] No imports array found"
        
        Return 1
    End If

    Note: Add all imports to work queue
    Let i be 0
    While i is less than import_count:
        Let ptr_size be 8
        Let import_offset be i multiplied by ptr_size
        Let import_ptr be imports plus import_offset
        Let import_stmt be proc memory_get_qword from MemoryCore with import_ptr, 0

        If import_stmt is not equal to 0:
            Let import_filename be proc memory_get_qword from MemoryCore with import_stmt, 0
            If import_filename is not equal to 0:
                Let result be proc add_import_task with import_filename, context, arena
                If result is equal to 0:
                    Alert "[PARALLEL ERROR] Failed to add import task"
                    
                    Return 1
                End If
            End If
        End If

        Set i to i plus 1
    End While

    Note: Wait for all tasks to complete
    Let result be proc wait_for_completion with context, import_count
    If result is not equal to 0:
        Alert "[PARALLEL ERROR] Some import tasks failed"
        
        Return 1
    End If

    Alert "[PARALLEL SUCCESS] Processed " joined with import_count joined with " imports in parallel"

    Return 0
End Process

Process called "wait_for_completion" that takes context as Integer, expected_tasks as Integer returns Integer:
    Note: Wait for all import tasks to complete using condition variable

    Let sync_primitives be proc memory_get_qword from MemoryCore with context, 216
    Let queue_mutex be proc memory_get_qword from MemoryCore with sync_primitives, 0
    Let completion_condition be proc memory_get_qword from MemoryCore with sync_primitives, 16
    Let completion_counter be proc memory_get_qword from MemoryCore with sync_primitives, 24

    proc pthread_mutex_lock from PThreads with queue_mutex

    Note: Wait until all expected tasks are completed
    Let completed be proc atomic_get from PThreads with completion_counter
    While completed is less than expected_tasks:
        proc pthread_cond_wait from PThreads with completion_condition, queue_mutex
        Set completed to proc atomic_get from PThreads with completion_counter
    End While

    proc pthread_mutex_unlock from PThreads with queue_mutex

    Return 0
End Process

Process called "process_import_task" that takes task as Integer, context as Integer, arena as Integer returns Integer:
    Note: Process individual import task - resolve, read, lex, parse

    Let import_path be proc memory_get_qword from MemoryCore with task, 0
    If import_path is equal to 0:
        Return 1
    End If

    Note: Resolve import path to actual file
    Let resolved_path be proc resolve_module_path from Resolution with import_path, context, arena
    If resolved_path is equal to 0:
        proc memory_set_qword from MemoryCore with task, 24, 1
        Return 1
    End If

    Note: Read the imported file
    Let import_source be proc read_file from FileIO with resolved_path
    If import_source is equal to 0:
        proc memory_set_qword from MemoryCore with task, 24, 2
        Return 1
    End If

    Note: Create lexer for imported file
    Let import_lexer be proc lexer_create from ImportCore with import_source, arena
    If import_lexer is equal to 0:
        proc memory_set_qword from MemoryCore with task, 24, 3
        proc deallocate from Layout with import_source
        Return 1
    End If

    Note: Create parser for imported file
    Let import_parser be proc parser_create from ImportCore with import_lexer, arena
    If import_parser is equal to 0:
        proc memory_set_qword from MemoryCore with task, 24, 4
        proc lexer_destroy from ImportCore with import_lexer
        proc deallocate from Layout with import_source
        Return 1
    End If

    Note: Parse the imported file
    Let import_program be proc parser_parse_program from ImportCore with import_parser
    If import_program is equal to 0:
        proc memory_set_qword from MemoryCore with task, 24, 5
        proc parser_destroy from ImportCore with import_parser
        proc lexer_destroy from ImportCore with import_lexer
        proc deallocate from Layout with import_source
        Return 1
    End If

    Note: Store parsed program in task result
    proc memory_set_qword from MemoryCore with task, 16, import_program
    proc memory_set_qword from MemoryCore with task, 8, 1

    Note: Cleanup parsing resources
    proc parser_destroy from ImportCore with import_parser
    proc lexer_destroy from ImportCore with import_lexer
    proc deallocate from Layout with import_source

    Return 0
End Process

Note: ============================================================================
Note: Thread Pool Cleanup
Note: ============================================================================

Process called "shutdown_thread_pool" that takes context as Integer returns Integer:
    Note: Gracefully shutdown thread pool - signal workers and wait for completion

    Let thread_pool be proc memory_get_qword from MemoryCore with context, 200
    If thread_pool is equal to 0:
        Return 0
    End If

    Note: Set shutdown flag in work queue
    Let work_queue be proc memory_get_qword from MemoryCore with context, 208
    If work_queue is not equal to 0:
        proc memory_set_qword from MemoryCore with work_queue, 40, 1
    End If

    Note: Broadcast to all waiting workers
    Let sync_primitives be proc memory_get_qword from MemoryCore with context, 216
    If sync_primitives is not equal to 0:
        Let work_condition be proc memory_get_qword from MemoryCore with sync_primitives, 8
        If work_condition is not equal to 0:
            proc pthread_cond_broadcast from PThreads with work_condition
        End If
    End If

    Note: Wait for all worker threads to finish
    Let worker_count be proc memory_get_qword from MemoryCore with thread_pool, 8
    Let workers be proc memory_get_qword from MemoryCore with thread_pool, 0
    If workers is not equal to 0:
        Let i be 0
        While i is less than worker_count:
            Let worker_thread be proc memory_get_qword from MemoryCore with workers plus i multiplied by 8, 0
            If worker_thread is not equal to 0:
                proc pthread_join from PThreads with worker_thread
            End If
            Set i to i plus 1
        End While
    End If

    Return 1
End Process

Process called "cleanup_worker_threads" that takes workers as Integer, count as Integer returns Integer:
    Note: Cleanup worker threads on initialization error

    Let i be 0
    While i is less than count:
        Let worker_thread be proc memory_get_qword from MemoryCore with workers plus i multiplied by 8, 0
        If worker_thread is not equal to 0:
            proc pthread_destroy from PThreads with worker_thread
        End If
        Set i to i plus 1
    End While

    Return 1
End Process
