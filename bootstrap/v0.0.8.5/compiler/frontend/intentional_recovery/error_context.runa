Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file manages error context and diagnostic information for intentional recovery.

This file performs the following tasks:
- Track error context and diagnostic information during parsing with memory-efficient operations
- Maintain error state and recovery context across parsing phases with arena-based temporary analysis
- Provide error context for intelligent recovery strategies with ownership-aware operations
- Handle error propagation and context preservation with deterministic memory management

This file is essential because of the following reasons:
- Error context enables intelligent error recovery and suggestions
- Proper error tracking improves user experience and debugging
- Context preservation allows for accurate error reporting and recovery
- Memory-efficient context management enables scalable recovery operations

This file consists of the following functions/features/operation types:
- Error context tracking and management with ownership patterns
- Diagnostic information collection and preservation with arena-based operations
- Error state management and propagation with memory safety
- Context-aware error reporting and recovery with deterministic cleanup
:End Note

Import "compiler/frontend/diagnostics/errors.runa"
Import "compiler/frontend/diagnostics/source_map.runa"
Import "compiler/frontend/diagnostics/suggestion_engine.runa"
Import "compiler/frontend/primitives/memory/layout.runa"
Import "compiler/frontend/primitives/collections/list.runa"
Import "compiler/frontend/primitives/collections/hashtable.runa"
Import "compiler/frontend/primitives/core/string_core.runa"
Import "compiler/frontend/primitives/core/memory_core.runa"

Constant CONTEXT_TYPE_LEXICAL as Integer is 1
Constant CONTEXT_TYPE_SYNTAX as Integer is 2
Constant CONTEXT_TYPE_SEMANTIC as Integer is 3
Constant CONTEXT_TYPE_TYPE as Integer is 4
Constant CONTEXT_TYPE_OWNERSHIP as Integer is 5

Constant CONTEXT_PRIORITY_HIGH as Integer is 1
Constant CONTEXT_PRIORITY_MEDIUM as Integer is 2
Constant CONTEXT_PRIORITY_LOW as Integer is 3
Constant CONTEXT_PRIORITY_CRITICAL as Integer is 4

Constant CONTEXT_STATE_ACTIVE as Integer is 1
Constant CONTEXT_STATE_PENDING as Integer is 2
Constant CONTEXT_STATE_RESOLVED as Integer is 3
Constant CONTEXT_STATE_FAILED as Integer is 4

Constant RECOVERY_STRATEGY_SKIP as Integer is 1
Constant RECOVERY_STRATEGY_INSERT as Integer is 2
Constant RECOVERY_STRATEGY_REPLACE as Integer is 3
Constant RECOVERY_STRATEGY_DELETE as Integer is 4
Constant RECOVERY_STRATEGY_REFACTOR as Integer is 5

Type called "ErrorContext":
    context_id as Integer            Note: STACK - unique context identifier
    error_info as Integer            Note: OWNED - error information reference
    source_location as Integer       Note: OWNED - source location reference
    context_type as Integer          Note: STACK - context type constant
    priority as Integer              Note: STACK - context priority
    state as Integer                 Note: STACK - context state
    surrounding_code as String       Note: OWNED - surrounding code context
    variable_scope as Integer        Note: OWNED - variable scope information
    function_context as Integer      Note: OWNED - function context
    type_context as Integer          Note: OWNED - type context
    ownership_context as Integer     Note: OWNED - ownership context
    recent_tokens as Integer         Note: OWNED - recent token list
    ast_context as Integer           Note: OWNED - AST context
    recovery_suggestions as Integer  Note: OWNED - recovery suggestions
    confidence as Integer             Note: STACK - context confidence level
    is_recoverable as Integer         Note: STACK - recovery possibility flag
    recovery_strategy as Integer      Note: STACK - suggested recovery strategy
End Type

Type called "ContextManager":
    active_contexts as Integer       Note: OWNED - active context list
    context_history as Integer        Note: OWNED - context history
    context_cache as Integer          Note: OWNED - context cache
    error_tracker as Integer         Note: OWNED - error tracker
    recovery_analyzer as Integer      Note: OWNED - recovery analyzer
    arena as Integer                  Note: OWNED - arena for temporary operations
    total_contexts as Integer         Note: STACK - total context count
    active_count as Integer           Note: STACK - active context count
    resolved_count as Integer         Note: STACK - resolved context count
    failed_count as Integer          Note: STACK - failed context count
    context_depth as Integer          Note: STACK - context nesting depth
    max_depth as Integer              Note: STACK - maximum context depth
    error_handler as Integer          Note: OWNED - error reporting system
    debug_logger as Integer           Note: OWNED - debug logging system
End Type

Type called "ContextSnapshot":
    snapshot_id as Integer           Note: STACK - unique snapshot identifier
    timestamp as Integer             Note: STACK - snapshot timestamp
    context_state as Integer          Note: OWNED - context state
    error_state as Integer            Note: OWNED - error state
    recovery_state as Integer         Note: OWNED - recovery state
    parser_state as Integer           Note: OWNED - parser state
    ast_state as Integer              Note: OWNED - AST state
    is_checkpoint as Integer          Note: STACK - checkpoint flag
    can_rollback as Integer           Note: STACK - rollback possibility
End Type

Type called "RecoveryContext":
    recovery_id as Integer           Note: STACK - unique recovery identifier
    error_context as Integer          Note: OWNED - error context reference
    recovery_strategy as Integer       Note: STACK - recovery strategy
    recovery_actions as Integer        Note: OWNED - recovery actions list
    validation_rules as Integer        Note: OWNED - validation rules
    rollback_info as Integer           Note: OWNED - rollback information
    success_criteria as Integer         Note: OWNED - success criteria
    is_automatic as Integer            Note: STACK - automatic recovery flag
    confidence as Integer              Note: STACK - recovery confidence
    estimated_time as Integer          Note: STACK - estimated recovery time
End Type

Process called "error_context_create" takes error_info as Integer, context_type as Integer, arena as Integer returns Integer:
    Note:
    Creates a new error context with proper memory management.

    Parameters:
    - error_info: Error information (OWNED)
    - context_type: Context type constant (STACK)
    - arena: Arena for temporary context operations (ARENA)

    Returns:
    - Integer: Pointer to OWNED ErrorContext structure

    Side Effects:
    - Allocates OWNED ErrorContext structure
    - Uses ARENA for temporary context operations
    - Initializes context components

    Algorithm:
    1. Use ARENA for temporary context operations
    2. Allocate OWNED ErrorContext structure (136 bytes = 17 fields × 8 bytes)
    3. Set error information reference
    4. Initialize context type and priority
    5. Set context state to ACTIVE
    6. Initialize context components
    7. ARENA data freed automatically
    :End Note

    Note: Import memory utilities
    Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

    Note: Validate inputs
    If error_info is equal to 0:
        Return 0  Note: NULL error_info
    End If

    If arena is equal to 0:
        Return 0  Note: NULL arena
    End If

    Note: Allocate OWNED ErrorContext structure (17 fields × 8 bytes = 136 bytes)
    Let context_size be 136
    Let context be proc memory_allocate from Memory with context_size

    If context is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Generate unique context_id using pointer as ID (offset 0)
    Let context_id be context
    proc memory_set_qword from Memory with context, 0, context_id

    Note: Import list utilities
    Import "compiler/frontend/primitives/collections/list.runa" as List

    Note: Set OWNED error_info reference (offset 8)
    proc memory_set_qword from Memory with context, 8, error_info

    Note: Initialize OWNED source_location to NULL (offset 16)
    proc memory_set_qword from Memory with context, 16, 0

    Note: Set context_type (offset 24)
    proc memory_set_qword from Memory with context, 24, context_type

    Note: Set default priority based on context type (offset 32)
    Let priority be CONTEXT_PRIORITY_MEDIUM
    If context_type is equal to CONTEXT_TYPE_SEMANTIC:
        Set priority to CONTEXT_PRIORITY_HIGH
    Otherwise If context_type is equal to CONTEXT_TYPE_OWNERSHIP:
        Set priority to CONTEXT_PRIORITY_CRITICAL
    End If
    proc memory_set_qword from Memory with context, 32, priority

    Note: Set state to ACTIVE (offset 40)
    proc memory_set_qword from Memory with context, 40, CONTEXT_STATE_ACTIVE

    Note: Initialize OWNED surrounding_code to NULL (offset 48)
    proc memory_set_qword from Memory with context, 48, 0

    Note: Initialize OWNED variable_scope to NULL (offset 56)
    proc memory_set_qword from Memory with context, 56, 0

    Note: Initialize OWNED function_context to NULL (offset 64)
    proc memory_set_qword from Memory with context, 64, 0

    Note: Initialize OWNED type_context to NULL (offset 72)
    proc memory_set_qword from Memory with context, 72, 0

    Note: Initialize OWNED ownership_context to NULL (offset 80)
    proc memory_set_qword from Memory with context, 80, 0

    Note: Create OWNED recent_tokens list (offset 88)
    Let recent_tokens be proc list_create from List with arena
    proc memory_set_qword from Memory with context, 88, recent_tokens

    Note: Initialize OWNED ast_context to NULL (offset 96)
    proc memory_set_qword from Memory with context, 96, 0

    Note: Create OWNED recovery_suggestions list (offset 104)
    Let recovery_suggestions be proc list_create from List with arena
    proc memory_set_qword from Memory with context, 104, recovery_suggestions

    Note: Set default confidence to 50 (offset 112)
    proc memory_set_qword from Memory with context, 112, 50

    Note: Set is_recoverable to 1 (recoverable by default) (offset 120)
    proc memory_set_qword from Memory with context, 120, 1

    Note: Set default recovery_strategy to SKIP (offset 128)
    proc memory_set_qword from Memory with context, 128, RECOVERY_STRATEGY_SKIP

    Return context
End Process

Process called "error_context_destroy" takes context as Integer returns Nothing:
    Note:
    Destroys error context and frees all owned memory.

    Parameters:
    - context: OWNED ErrorContext to destroy

    Side Effects:
    - Frees all OWNED context data
    - Destroys OWNED context components
    - Frees OWNED ErrorContext structure

    Algorithm:
    1. Free OWNED error information reference
    2. Free OWNED source location reference
    3. Free OWNED surrounding code
    4. Destroy OWNED variable scope
    5. Destroy OWNED function context
    6. Destroy OWNED type context
    7. Destroy OWNED ownership context
    8. Destroy OWNED recent tokens
    9. Destroy OWNED AST context
    10. Destroy OWNED recovery suggestions
    11. Free OWNED ErrorContext structure
    :End Note

    Note: Import memory and list utilities
    Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
    Import "compiler/frontend/primitives/collections/list.runa" as List

    Note: Validate context
    If context is equal to 0:
        Return  Note: NULL context
    End If

    Note: Free OWNED error_info if allocated (offset 8)
    Let error_info be proc memory_get_qword from Memory with context, 8
    If error_info is not equal to 0:
        proc memory_free from Memory with error_info
    End If

    Note: Free OWNED source_location if allocated (offset 16)
    Let source_location be proc memory_get_qword from Memory with context, 16
    If source_location is not equal to 0:
        proc memory_free from Memory with source_location
    End If

    Note: Free OWNED surrounding_code if allocated (offset 48)
    Let surrounding_code be proc memory_get_qword from Memory with context, 48
    If surrounding_code is not equal to 0:
        proc memory_free from Memory with surrounding_code
    End If

    Note: Destroy OWNED variable_scope if allocated (offset 56)
    Let variable_scope be proc memory_get_qword from Memory with context, 56
    If variable_scope is not equal to 0:
        proc memory_free from Memory with variable_scope
    End If

    Note: Destroy OWNED function_context if allocated (offset 64)
    Let function_context be proc memory_get_qword from Memory with context, 64
    If function_context is not equal to 0:
        proc memory_free from Memory with function_context
    End If

    Note: Destroy OWNED type_context if allocated (offset 72)
    Let type_context be proc memory_get_qword from Memory with context, 72
    If type_context is not equal to 0:
        proc memory_free from Memory with type_context
    End If

    Note: Destroy OWNED ownership_context if allocated (offset 80)
    Let ownership_context be proc memory_get_qword from Memory with context, 80
    If ownership_context is not equal to 0:
        proc memory_free from Memory with ownership_context
    End If

    Note: Destroy OWNED recent_tokens list (offset 88)
    Let recent_tokens be proc memory_get_qword from Memory with context, 88
    If recent_tokens is not equal to 0:
        proc list_destroy from List with recent_tokens
    End If

    Note: Destroy OWNED ast_context if allocated (offset 96)
    Let ast_context be proc memory_get_qword from Memory with context, 96
    If ast_context is not equal to 0:
        proc memory_free from Memory with ast_context
    End If

    Note: Destroy OWNED recovery_suggestions list (offset 104)
    Let recovery_suggestions be proc memory_get_qword from Memory with context, 104
    If recovery_suggestions is not equal to 0:
        proc list_destroy from List with recovery_suggestions
    End If

    Note: Free OWNED ErrorContext structure
    proc memory_free from Memory with context
End Process

Process called "error_context_update_state" takes context as Integer, new_state as Integer, arena as Integer returns Nothing:
    Note:
    Updates the state of an error context using arena-based operations.

    Parameters:
    - context: OWNED ErrorContext reference
    - new_state: New context state (STACK)
    - arena: Arena for temporary state operations (ARENA)

    Side Effects:
    - Uses ARENA for temporary state operations
    - Updates context state
    - Triggers state change notifications

    Algorithm:
    1. Use ARENA for temporary state operations
    2. Validate state transition
    3. Update context state
    4. Trigger state change notifications
    5. ARENA data freed automatically
    :End Note

    Note: Import memory utilities
    Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

    Note: Validate context
    If context is equal to 0:
        Return  Note: NULL context
    End If

    Note: Validate new_state
    If new_state is less than CONTEXT_STATE_ACTIVE:
        Return  Note: Invalid state
    End If

    If new_state is greater than CONTEXT_STATE_FAILED:
        Return  Note: Invalid state
    End If

    Note: Get current state (offset 40)
    Let current_state be proc memory_get_qword from Memory with context, 40

    Note: Validate state transition
    Let is_valid_transition be 1

    Note: ACTIVE can transition to PENDING, RESOLVED, or FAILED
    If current_state is equal to CONTEXT_STATE_ACTIVE:
        If new_state is equal to CONTEXT_STATE_ACTIVE:
            Set is_valid_transition to 0  Note: Cannot transition to same state
        End If
    End If

    Note: PENDING can transition to RESOLVED or FAILED
    If current_state is equal to CONTEXT_STATE_PENDING:
        If new_state is equal to CONTEXT_STATE_ACTIVE:
            Set is_valid_transition to 0  Note: Cannot go back to ACTIVE
        Otherwise If new_state is equal to CONTEXT_STATE_PENDING:
            Set is_valid_transition to 0  Note: Already PENDING
        End If
    End If

    Note: RESOLVED and FAILED are terminal states
    If current_state is equal to CONTEXT_STATE_RESOLVED:
        Set is_valid_transition to 0  Note: Terminal state
    End If

    If current_state is equal to CONTEXT_STATE_FAILED:
        Set is_valid_transition to 0  Note: Terminal state
    End If

    Note: If transition is invalid, do not update
    If is_valid_transition is equal to 0:
        Return  Note: Invalid state transition
    End If

    Note: Update context state (offset 40)
    proc memory_set_qword from Memory with context, 40, new_state

    Note: Adjust confidence based on state change
    If new_state is equal to CONTEXT_STATE_RESOLVED:
        Note: Increase confidence when resolved
        Let confidence be proc memory_get_qword from Memory with context, 112
        Let new_confidence be confidence plus 20
        If new_confidence is greater than 100:
            Set new_confidence to 100
        End If
        proc memory_set_qword from Memory with context, 112, new_confidence
    Otherwise If new_state is equal to CONTEXT_STATE_FAILED:
        Note: Decrease confidence when failed
        Let confidence be proc memory_get_qword from Memory with context, 112
        Let new_confidence be confidence minus 30
        If new_confidence is less than 0:
            Set new_confidence to 0
        End If
        proc memory_set_qword from Memory with context, 112, new_confidence
    End If
End Process

Process called "error_context_add_surrounding_code" takes context as Integer, source_code as String, line_number as Integer, arena as Integer returns Nothing:
    Note:
    Adds surrounding code context to an error context using arena-based operations.

    Parameters:
    - context: OWNED ErrorContext reference
    - source_code: Surrounding source code
    - line_number: Line number (STACK)
    - arena: Arena for temporary code operations (ARENA)

    Side Effects:
    - Uses ARENA for temporary code operations
    - Updates OWNED surrounding code
    - Analyzes code context

    Algorithm:
    1. Use ARENA for temporary code operations
    2. Analyze surrounding code
    3. Extract relevant context
    4. Update OWNED surrounding code
    5. ARENA data freed automatically
    :End Note

    Note: Import required utilities
    Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
    Import "compiler/frontend/primitives/core/string_core.runa" as StringCore

    Note: Validate context
    If context is equal to 0:
        Return  Note: NULL context
    End If

    If source_code is equal to 0:
        Return  Note: NULL source_code
    End If

    Note: Free existing surrounding_code if present (offset 48)
    Let existing_code be proc memory_get_qword from Memory with context, 48
    If existing_code is not equal to 0:
        proc memory_free from Memory with existing_code
    End If

    Note: Create OWNED copy of source_code
    Let code_copy be proc string_copy from StringCore with source_code

    Note: Set OWNED surrounding_code (offset 48)
    proc memory_set_qword from Memory with context, 48, code_copy

    Note: Increase confidence with more context
    Let confidence be proc memory_get_qword from Memory with context, 112
    Let new_confidence be confidence plus 10
    If new_confidence is greater than 100:
        Set new_confidence to 100
    End If
    proc memory_set_qword from Memory with context, 112, new_confidence
End Process

Process called "error_context_add_variable_scope" takes context as Integer, variable_scope as Integer, arena as Integer returns Nothing:
    Note:
    Adds variable scope information to an error context using arena-based operations.

    Parameters:
    - context: OWNED ErrorContext reference
    - variable_scope: Variable scope information (OWNED)
    - arena: Arena for temporary scope operations (ARENA)

    Side Effects:
    - Uses ARENA for temporary scope operations
    - Updates OWNED variable scope
    - Analyzes scope information

    Algorithm:
    1. Use ARENA for temporary scope operations
    2. Analyze variable scope
    3. Extract scope information
    4. Update OWNED variable scope
    5. ARENA data freed automatically
    :End Note

    Note: Import required utilities
    Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

    Note: Validate context
    If context is equal to 0:
        Return  Note: NULL context
    End If

    Note: Free existing variable_scope if present (offset 56)
    Let existing_scope be proc memory_get_qword from Memory with context, 56
    If existing_scope is not equal to 0:
        proc memory_free from Memory with existing_scope
    End If

    Note: Set OWNED variable_scope (offset 56)
    proc memory_set_qword from Memory with context, 56, variable_scope
End Process

Process called "error_context_add_function_context" takes context as Integer, function_context as Integer, arena as Integer returns Nothing:
    Note:
    Adds function context information to an error context using arena-based operations.

    Parameters:
    - context: OWNED ErrorContext reference
    - function_context: Function context information (OWNED)
    - arena: Arena for temporary function operations (ARENA)

    Side Effects:
    - Uses ARENA for temporary function operations
    - Updates OWNED function context
    - Analyzes function information

    Algorithm:
    1. Use ARENA for temporary function operations
    2. Analyze function context
    3. Extract function information
    4. Update OWNED function context
    5. ARENA data freed automatically
    :End Note

    Note: Import required utilities
    Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

    Note: Validate context
    If context is equal to 0:
        Return  Note: NULL context
    End If

    Note: Free existing function_context if present (offset 64)
    Let existing_function be proc memory_get_qword from Memory with context, 64
    If existing_function is not equal to 0:
        proc memory_free from Memory with existing_function
    End If

    Note: Set OWNED function_context (offset 64)
    proc memory_set_qword from Memory with context, 64, function_context
End Process

Process called "error_context_add_type_context" takes context as Integer, type_context as Integer, arena as Integer returns Nothing:
    Note:
    Adds type context information to an error context using arena-based operations.

    Parameters:
    - context: OWNED ErrorContext reference
    - type_context: Type context information (OWNED)
    - arena: Arena for temporary type operations (ARENA)

    Side Effects:
    - Uses ARENA for temporary type operations
    - Updates OWNED type context
    - Analyzes type information

    Algorithm:
    1. Use ARENA for temporary type operations
    2. Analyze type context
    3. Extract type information
    4. Update OWNED type context
    5. ARENA data freed automatically
    :End Note

    Note: Import required utilities
    Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

    Note: Validate context
    If context is equal to 0:
        Return  Note: NULL context
    End If

    Note: Free existing type_context if present (offset 72)
    Let existing_type be proc memory_get_qword from Memory with context, 72
    If existing_type is not equal to 0:
        proc memory_free from Memory with existing_type
    End If

    Note: Set OWNED type_context (offset 72)
    proc memory_set_qword from Memory with context, 72, type_context
End Process

Process called "error_context_add_ownership_context" takes context as Integer, ownership_context as Integer, arena as Integer returns Nothing:
    Note:
    Adds ownership context information to an error context using arena-based operations.

    Parameters:
    - context: OWNED ErrorContext reference
    - ownership_context: Ownership context information (OWNED)
    - arena: Arena for temporary ownership operations (ARENA)

    Side Effects:
    - Uses ARENA for temporary ownership operations
    - Updates OWNED ownership context
    - Analyzes ownership information

    Algorithm:
    1. Use ARENA for temporary ownership operations
    2. Analyze ownership context
    3. Extract ownership information
    4. Update OWNED ownership context
    5. ARENA data freed automatically
    :End Note

    Note: Import required utilities
    Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

    Note: Validate context
    If context is equal to 0:
        Return  Note: NULL context
    End If

    Note: Free existing ownership_context if present (offset 80)
    Let existing_ownership be proc memory_get_qword from Memory with context, 80
    If existing_ownership is not equal to 0:
        proc memory_free from Memory with existing_ownership
    End If

    Note: Set OWNED ownership_context (offset 80)
    proc memory_set_qword from Memory with context, 80, ownership_context
End Process

Process called "error_context_add_recent_tokens" takes context as Integer, token_list as Integer, arena as Integer returns Nothing:
    Note:
    Adds recent tokens to an error context using arena-based operations.

    Parameters:
    - context: OWNED ErrorContext reference
    - token_list: Recent token list (OWNED)
    - arena: Arena for temporary token operations (ARENA)

    Side Effects:
    - Uses ARENA for temporary token operations
    - Updates OWNED recent tokens
    - Analyzes token context

    Algorithm:
    1. Use ARENA for temporary token operations
    2. Analyze recent tokens
    3. Extract token context
    4. Update OWNED recent tokens
    5. ARENA data freed automatically
    :End Note

    Note: Import required utilities
    Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
    Import "compiler/frontend/primitives/collections/list.runa" as List

    Note: Validate context
    If context is equal to 0:
        Return  Note: NULL context
    End If

    If token_list is equal to 0:
        Return  Note: NULL token_list
    End If

    Note: Get recent_tokens list (offset 88)
    Let recent_tokens be proc memory_get_qword from Memory with context, 88

    Note: Clear existing tokens and add new ones
    proc list_clear from List with recent_tokens

    Note: Copy tokens from token_list to recent_tokens
    Let token_count be proc list_size from List with token_list
    Let index be 0

    While index is less than token_count:
        Let token be proc list_get from List with token_list, index
        proc list_add from List with recent_tokens, token
        Set index to index plus 1
    End While
End Process

Process called "error_context_add_ast_context" takes context as Integer, ast_context as Integer, arena as Integer returns Nothing:
    Note:
    Adds AST context information to an error context using arena-based operations.

    Parameters:
    - context: OWNED ErrorContext reference
    - ast_context: AST context information (OWNED)
    - arena: Arena for temporary AST operations (ARENA)

    Side Effects:
    - Uses ARENA for temporary AST operations
    - Updates OWNED AST context
    - Analyzes AST information

    Algorithm:
    1. Use ARENA for temporary AST operations
    2. Analyze AST context
    3. Extract AST information
    4. Update OWNED AST context
    5. ARENA data freed automatically
    :End Note

    Note: Import required utilities
    Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

    Note: Validate context
    If context is equal to 0:
        Return  Note: NULL context
    End If

    Note: Free existing ast_context if present (offset 96)
    Let existing_ast be proc memory_get_qword from Memory with context, 96
    If existing_ast is not equal to 0:
        proc memory_free from Memory with existing_ast
    End If

    Note: Set OWNED ast_context (offset 96)
    proc memory_set_qword from Memory with context, 96, ast_context
End Process

Process called "error_context_generate_recovery_suggestions" takes context as Integer, arena as Integer returns Integer:
    Note:
    Generates recovery suggestions for an error context using arena-based operations.

    Parameters:
    - context: OWNED ErrorContext reference
    - arena: Arena for temporary suggestion operations (ARENA)

    Returns:
    - Integer: ARENA pointer to recovery suggestions

    Side Effects:
    - Uses ARENA for temporary suggestion operations
    - No permanent memory allocation

    Algorithm:
    1. Use ARENA for temporary suggestion operations
    2. Analyze error context
    3. Generate recovery suggestions
    4. Rank suggestions by confidence
    5. Return ARENA pointer to suggestions
    6. ARENA data freed automatically
    :End Note

    Note: Import required utilities
    Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
    Import "compiler/frontend/primitives/collections/list.runa" as List
    Import "compiler/frontend/primitives/core/string_core.runa" as StringCore

    Note: Validate context
    If context is equal to 0:
        Return 0  Note: NULL context
    End If

    Note: Get recovery_suggestions list (offset 104)
    Let suggestions be proc memory_get_qword from Memory with context, 104

    Note: Get context information for suggestion generation
    Let context_type be proc memory_get_qword from Memory with context, 24
    Let confidence be proc memory_get_qword from Memory with context, 112
    Let is_recoverable be proc memory_get_qword from Memory with context, 120

    Note: If not recoverable, return empty suggestions
    If is_recoverable is equal to 0:
        Return suggestions
    End If

    Note: Generate suggestions based on context type
    If context_type is equal to CONTEXT_TYPE_LEXICAL:
        Note: Suggest token insertion/deletion/replacement
        Let suggestion_1 be proc string_copy from StringCore with "Check for missing or extra tokens"
        proc list_add from List with suggestions, suggestion_1

    Otherwise If context_type is equal to CONTEXT_TYPE_SYNTAX:
        Note: Suggest syntax corrections
        Let suggestion_2 be proc string_copy from StringCore with "Verify statement structure and delimiters"
        proc list_add from List with suggestions, suggestion_2

    Otherwise If context_type is equal to CONTEXT_TYPE_SEMANTIC:
        Note: Suggest semantic fixes
        Let suggestion_3 be proc string_copy from StringCore with "Check type compatibility and scope"
        proc list_add from List with suggestions, suggestion_3

    Otherwise If context_type is equal to CONTEXT_TYPE_TYPE:
        Note: Suggest type fixes
        Let suggestion_4 be proc string_copy from StringCore with "Verify type annotations and inference"
        proc list_add from List with suggestions, suggestion_4

    Otherwise If context_type is equal to CONTEXT_TYPE_OWNERSHIP:
        Note: Suggest ownership fixes
        Let suggestion_5 be proc string_copy from StringCore with "Review ownership transfer and borrowing"
        proc list_add from List with suggestions, suggestion_5
    End If

    Return suggestions
End Process

Process called "error_context_validate_recovery" takes context as Integer, recovery_strategy as Integer, arena as Integer returns Integer:
    Note:
    Validates a recovery strategy for an error context using arena-based operations.

    Parameters:
    - context: OWNED ErrorContext reference
    - recovery_strategy: Recovery strategy to validate (STACK)
    - arena: Arena for temporary validation (ARENA)

    Returns:
    - Integer: Validation result (STACK)

    Side Effects:
    - Uses ARENA for temporary validation
    - Reports validation issues

    Algorithm:
    1. Use ARENA for temporary validation
    2. Check recovery strategy validity
    3. Validate against context
    4. Return validation result
    5. ARENA data freed automatically
    :End Note

    Note: Import required utilities
    Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

    Note: Validate context
    If context is equal to 0:
        Return 0  Note: NULL context - validation failed
    End If

    Note: Validate recovery_strategy range
    If recovery_strategy is less than RECOVERY_STRATEGY_SKIP:
        Return 0  Note: Invalid strategy
    End If

    If recovery_strategy is greater than RECOVERY_STRATEGY_REFACTOR:
        Return 0  Note: Invalid strategy
    End If

    Note: Get context information
    Let context_type be proc memory_get_qword from Memory with context, 24
    Let is_recoverable be proc memory_get_qword from Memory with context, 120
    Let confidence be proc memory_get_qword from Memory with context, 112

    Note: If not recoverable, any strategy fails
    If is_recoverable is equal to 0:
        Return 0  Note: Context not recoverable
    End If

    Note: Validate strategy against context type
    Let is_valid be 1

    Note: SKIP strategy valid for all contexts
    If recovery_strategy is equal to RECOVERY_STRATEGY_SKIP:
        Return 1  Note: SKIP always valid
    End If

    Note: INSERT valid for lexical and syntax contexts
    If recovery_strategy is equal to RECOVERY_STRATEGY_INSERT:
        If context_type is equal to CONTEXT_TYPE_SEMANTIC:
            Set is_valid to 0  Note: Cannot insert in semantic context
        Otherwise If context_type is equal to CONTEXT_TYPE_TYPE:
            Set is_valid to 0  Note: Cannot insert in type context
        End If
    End If

    Note: DELETE valid for lexical and syntax contexts
    If recovery_strategy is equal to RECOVERY_STRATEGY_DELETE:
        If context_type is equal to CONTEXT_TYPE_SEMANTIC:
            Set is_valid to 0  Note: Cannot delete in semantic context
        Otherwise If context_type is equal to CONTEXT_TYPE_TYPE:
            Set is_valid to 0  Note: Cannot delete in type context
        End If
    End If

    Note: REPLACE valid for most contexts
    If recovery_strategy is equal to RECOVERY_STRATEGY_REPLACE:
        Note: REPLACE valid for all context types
        Set is_valid to 1
    End If

    Note: REFACTOR only valid for high-confidence contexts
    If recovery_strategy is equal to RECOVERY_STRATEGY_REFACTOR:
        If confidence is less than 70:
            Set is_valid to 0  Note: Confidence too low for refactoring
        End If
    End If

    Return is_valid
End Process

Process called "context_manager_create" takes arena as Integer returns Integer:
    Note:
    Creates a new context manager with proper memory management.

    Parameters:
    - arena: Arena for temporary manager operations (ARENA)

    Returns:
    - Integer: Pointer to OWNED ContextManager structure

    Side Effects:
    - Allocates OWNED ContextManager structure
    - Initializes OWNED context components
    - Sets up OWNED error tracking

    Algorithm:
    1. Allocate OWNED ContextManager structure (112 bytes = 14 fields × 8 bytes)
    2. Initialize OWNED active contexts list
    3. Initialize OWNED context history
    4. Initialize OWNED context cache
    5. Initialize OWNED error tracker
    6. Initialize OWNED recovery analyzer
    7. Set up OWNED error handling
    8. Return OWNED ContextManager pointer
    :End Note

    Note: Import required utilities
    Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
    Import "compiler/frontend/primitives/collections/list.runa" as List
    Import "compiler/frontend/primitives/collections/hashtable.runa" as Hashtable

    Note: Validate arena
    If arena is equal to 0:
        Return 0  Note: NULL arena
    End If

    Note: Allocate OWNED ContextManager structure (14 fields × 8 bytes = 112 bytes)
    Let manager_size be 112
    Let manager be proc memory_allocate from Memory with manager_size

    If manager is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Create OWNED active_contexts list (offset 0)
    Let active_contexts be proc list_create from List
    proc memory_set_qword from Memory with manager, 0, active_contexts

    Note: Create OWNED context_history list (offset 8)
    Let context_history be proc list_create from List
    proc memory_set_qword from Memory with manager, 8, context_history

    Note: Create OWNED context_cache hashtable (offset 16)
    Let context_cache be proc hashtable_create from Hashtable
    proc memory_set_qword from Memory with manager, 16, context_cache

    Note: Initialize OWNED error_tracker to NULL (offset 24)
    proc memory_set_qword from Memory with manager, 24, 0

    Note: Initialize OWNED recovery_analyzer to NULL (offset 32)
    proc memory_set_qword from Memory with manager, 32, 0

    Note: Store arena reference (offset 40)
    proc memory_set_qword from Memory with manager, 40, arena

    Note: Initialize total_contexts to 0 (offset 48)
    proc memory_set_qword from Memory with manager, 48, 0

    Note: Initialize active_count to 0 (offset 56)
    proc memory_set_qword from Memory with manager, 56, 0

    Note: Initialize resolved_count to 0 (offset 64)
    proc memory_set_qword from Memory with manager, 64, 0

    Note: Initialize failed_count to 0 (offset 72)
    proc memory_set_qword from Memory with manager, 72, 0

    Note: Initialize context_depth to 0 (offset 80)
    proc memory_set_qword from Memory with manager, 80, 0

    Note: Initialize max_depth to 0 (offset 88)
    proc memory_set_qword from Memory with manager, 88, 0

    Note: Initialize OWNED error_handler to NULL (offset 96)
    proc memory_set_qword from Memory with manager, 96, 0

    Note: Initialize OWNED debug_logger to NULL (offset 104)
    proc memory_set_qword from Memory with manager, 104, 0

    Return manager
End Process

Process called "context_manager_destroy" takes manager as Integer returns Nothing:
    Note:
    Destroys context manager and frees all owned memory.

    Parameters:
    - manager: OWNED ContextManager to destroy

    Side Effects:
    - Frees all OWNED manager data
    - Destroys OWNED context components
    - Frees OWNED ContextManager structure

    Algorithm:
    1. Destroy OWNED active contexts list
    2. Destroy OWNED context history
    3. Destroy OWNED context cache
    4. Destroy OWNED error tracker
    5. Destroy OWNED recovery analyzer
    6. Free OWNED ContextManager structure
    :End Note

    Note: Import required utilities
    Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
    Import "compiler/frontend/primitives/collections/list.runa" as List
    Import "compiler/frontend/primitives/collections/hashtable.runa" as Hashtable

    Note: Validate manager
    If manager is equal to 0:
        Return  Note: NULL manager
    End If

    Note: Destroy OWNED active_contexts list and all contexts (offset 0)
    Let active_contexts be proc memory_get_qword from Memory with manager, 0
    If active_contexts is not equal to 0:
        Note: Destroy each context in the list
        Let context_count be proc list_size from List with active_contexts
        Let index be 0

        While index is less than context_count:
            Let context be proc list_get from List with active_contexts, index
            If context is not equal to 0:
                proc error_context_destroy with context
            End If
            Set index to index plus 1
        End While

        proc list_destroy from List with active_contexts
    End If

    Note: Destroy OWNED context_history list (offset 8)
    Let context_history be proc memory_get_qword from Memory with manager, 8
    If context_history is not equal to 0:
        proc list_destroy from List with context_history
    End If

    Note: Destroy OWNED context_cache hashtable (offset 16)
    Let context_cache be proc memory_get_qword from Memory with manager, 16
    If context_cache is not equal to 0:
        proc hashtable_destroy from Hashtable with context_cache
    End If

    Note: Destroy OWNED error_tracker if allocated (offset 24)
    Let error_tracker be proc memory_get_qword from Memory with manager, 24
    If error_tracker is not equal to 0:
        proc memory_free from Memory with error_tracker
    End If

    Note: Destroy OWNED recovery_analyzer if allocated (offset 32)
    Let recovery_analyzer be proc memory_get_qword from Memory with manager, 32
    If recovery_analyzer is not equal to 0:
        proc memory_free from Memory with recovery_analyzer
    End If

    Note: Destroy OWNED error_handler if allocated (offset 96)
    Let error_handler be proc memory_get_qword from Memory with manager, 96
    If error_handler is not equal to 0:
        proc memory_free from Memory with error_handler
    End If

    Note: Destroy OWNED debug_logger if allocated (offset 104)
    Let debug_logger be proc memory_get_qword from Memory with manager, 104
    If debug_logger is not equal to 0:
        proc memory_free from Memory with debug_logger
    End If

    Note: Free OWNED ContextManager structure
    proc memory_free from Memory with manager
End Process

Process called "context_manager_add_context" takes manager as Integer, context as Integer, arena as Integer returns Integer:
    Note:
    Adds an error context to the manager using arena-based operations.

    Parameters:
    - manager: OWNED ContextManager reference
    - context: Error context to add (OWNED)
    - arena: Arena for temporary context operations (ARENA)

    Returns:
    - Integer: Context ID (STACK)

    Side Effects:
    - Uses ARENA for temporary context operations
    - Adds context to OWNED active contexts
    - Updates context statistics

    Algorithm:
    1. Use ARENA for temporary context operations
    2. Validate context
    3. Add to OWNED active contexts
    4. Update context statistics
    5. ARENA data freed automatically
    :End Note

    Note: Import required utilities
    Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
    Import "compiler/frontend/primitives/collections/list.runa" as List
    Import "compiler/frontend/primitives/collections/hashtable.runa" as Hashtable

    Note: Validate manager
    If manager is equal to 0:
        Return 0  Note: NULL manager
    End If

    If context is equal to 0:
        Return 0  Note: NULL context
    End If

    Note: Get context_id from context (offset 0)
    Let context_id be proc memory_get_qword from Memory with context, 0

    Note: Get active_contexts list (offset 0)
    Let active_contexts be proc memory_get_qword from Memory with manager, 0

    Note: Add context to active_contexts list
    proc list_add from List with active_contexts, context

    Note: Add context to context_cache (offset 16)
    Let context_cache be proc memory_get_qword from Memory with manager, 16
    proc hashtable_insert from Hashtable with context_cache, context_id, context

    Note: Increment total_contexts (offset 48)
    Let total_contexts be proc memory_get_qword from Memory with manager, 48
    Set total_contexts to total_contexts plus 1
    proc memory_set_qword from Memory with manager, 48, total_contexts

    Note: Increment active_count (offset 56)
    Let active_count be proc memory_get_qword from Memory with manager, 56
    Set active_count to active_count plus 1
    proc memory_set_qword from Memory with manager, 56, active_count

    Note: Update context_depth (offset 80)
    Let context_depth be proc memory_get_qword from Memory with manager, 80
    Set context_depth to context_depth plus 1
    proc memory_set_qword from Memory with manager, 80, context_depth

    Note: Update max_depth if necessary (offset 88)
    Let max_depth be proc memory_get_qword from Memory with manager, 88
    If context_depth is greater than max_depth:
        proc memory_set_qword from Memory with manager, 88, context_depth
    End If

    Return context_id
End Process

Process called "context_manager_remove_context" takes manager as Integer, context_id as Integer, arena as Integer returns Nothing:
    Note:
    Removes an error context from the manager using arena-based operations.

    Parameters:
    - manager: OWNED ContextManager reference
    - context_id: Context ID to remove (STACK)
    - arena: Arena for temporary context operations (ARENA)

    Side Effects:
    - Uses ARENA for temporary context operations
    - Removes context from OWNED active contexts
    - Updates context statistics

    Algorithm:
    1. Use ARENA for temporary context operations
    2. Find context by ID
    3. Remove from OWNED active contexts
    4. Update context statistics
    5. ARENA data freed automatically
    :End Note

    Note: Import required utilities
    Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
    Import "compiler/frontend/primitives/collections/list.runa" as List
    Import "compiler/frontend/primitives/collections/hashtable.runa" as Hashtable

    Note: Validate manager
    If manager is equal to 0:
        Return  Note: NULL manager
    End If

    Note: Get context from context_cache (offset 16)
    Let context_cache be proc memory_get_qword from Memory with manager, 16
    Let context be proc hashtable_lookup from Hashtable with context_cache, context_id

    If context is equal to 0:
        Return  Note: Context not found
    End If

    Note: Get context state to update statistics (offset 40)
    Let context_state be proc memory_get_qword from Memory with context, 40

    Note: Get active_contexts list (offset 0)
    Let active_contexts be proc memory_get_qword from Memory with manager, 0

    Note: Find and remove context from active_contexts
    Let context_count be proc list_size from List with active_contexts
    Let index be 0
    Let found_index be negative 1

    While index is less than context_count:
        Let current_context be proc list_get from List with active_contexts, index
        Let current_id be proc memory_get_qword from Memory with current_context, 0

        If current_id is equal to context_id:
            Set found_index to index
            Break
        End If

        Set index to index plus 1
    End While

    Note: Remove from list if found
    If found_index is not equal to negative 1:
        proc list_remove_at from List with active_contexts, found_index
    End If

    Note: Remove from context_cache
    proc hashtable_remove from Hashtable with context_cache, context_id

    Note: Add to context_history (offset 8)
    Let context_history be proc memory_get_qword from Memory with manager, 8
    proc list_add from List with context_history, context

    Note: Decrement active_count (offset 56)
    Let active_count be proc memory_get_qword from Memory with manager, 56
    Set active_count to active_count minus 1
    proc memory_set_qword from Memory with manager, 56, active_count

    Note: Update resolved_count or failed_count based on state
    If context_state is equal to CONTEXT_STATE_RESOLVED:
        Let resolved_count be proc memory_get_qword from Memory with manager, 64
        Set resolved_count to resolved_count plus 1
        proc memory_set_qword from Memory with manager, 64, resolved_count

    Otherwise If context_state is equal to CONTEXT_STATE_FAILED:
        Let failed_count be proc memory_get_qword from Memory with manager, 72
        Set failed_count to failed_count plus 1
        proc memory_set_qword from Memory with manager, 72, failed_count
    End If

    Note: Decrement context_depth (offset 80)
    Let context_depth be proc memory_get_qword from Memory with manager, 80
    Set context_depth to context_depth minus 1
    proc memory_set_qword from Memory with manager, 80, context_depth
End Process

Process called "context_manager_get_statistics" takes manager as Integer, arena as Integer returns Integer:
    Note:
    Gets context manager statistics using arena-based operations.

    Parameters:
    - manager: OWNED ContextManager reference
    - arena: Arena for temporary statistics (ARENA)

    Returns:
    - Integer: ARENA pointer to statistics structure

    Side Effects:
    - Uses ARENA for temporary statistics
    - No permanent memory allocation

    Algorithm:
    1. Use ARENA to allocate statistics structure
    2. Count active contexts
    3. Count resolved contexts
    4. Count failed contexts
    5. Calculate context depth
    6. Return ARENA pointer to statistics
    7. ARENA data freed automatically
    :End Note

    Note: Import required utilities
    Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
    Import "compiler/frontend/primitives/memory/arena.runa" as Arena

    Note: Validate manager
    If manager is equal to 0:
        Return 0  Note: NULL manager
    End If

    If arena is equal to 0:
        Return 0  Note: NULL arena
    End If

    Note: Allocate statistics structure in arena (8 fields × 8 bytes = 64 bytes)
    Let stats_size be 64
    Let stats be proc arena_allocate from Arena with stats_size

    If stats is equal to 0:
        Return 0  Note: Arena allocation failed
    End If

    Note: Get total_contexts (offset 48)
    Let total_contexts be proc memory_get_qword from Memory with manager, 48
    proc memory_set_qword from Memory with stats, 0, total_contexts

    Note: Get active_count (offset 56)
    Let active_count be proc memory_get_qword from Memory with manager, 56
    proc memory_set_qword from Memory with stats, 8, active_count

    Note: Get resolved_count (offset 64)
    Let resolved_count be proc memory_get_qword from Memory with manager, 64
    proc memory_set_qword from Memory with stats, 16, resolved_count

    Note: Get failed_count (offset 72)
    Let failed_count be proc memory_get_qword from Memory with manager, 72
    proc memory_set_qword from Memory with stats, 24, failed_count

    Note: Get context_depth (offset 80)
    Let context_depth be proc memory_get_qword from Memory with manager, 80
    proc memory_set_qword from Memory with stats, 32, context_depth

    Note: Get max_depth (offset 88)
    Let max_depth be proc memory_get_qword from Memory with manager, 88
    proc memory_set_qword from Memory with stats, 40, max_depth

    Note: Calculate success rate (resolved / total * 100)
    Let success_rate be 0
    If total_contexts is greater than 0:
        Set success_rate to resolved_count times 100
        Set success_rate to success_rate divided by total_contexts
    End If
    proc memory_set_qword from Memory with stats, 48, success_rate

    Note: Calculate failure rate (failed / total * 100)
    Let failure_rate be 0
    If total_contexts is greater than 0:
        Set failure_rate to failed_count times 100
        Set failure_rate to failure_rate divided by total_contexts
    End If
    proc memory_set_qword from Memory with stats, 56, failure_rate

    Return stats
End Process