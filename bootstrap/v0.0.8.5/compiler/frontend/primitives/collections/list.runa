Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
LIST - Dynamic Array Data Structure Primitive

This file implements a dynamic array (vector/ArrayList) for sequential element storage.

Architecture:
- Dynamically resizable array with capacity management
- Doubles capacity when full (amortized O(1) append)
- Stores integer elements (extensible to generic types later)
- Contiguous memory for cache-friendly access

Features:
- O(1) append (amortized), get, set
- O(n) insert, remove (requires shifting)
- Automatic memory management
- Bounds checking for safety

Use Cases:
- Token lists in lexer/parser
- AST node children
- General-purpose arrays
- Stack/queue backing storage

List Structure (24 bytes):
  offset 0:  data (pointer to element array, 8 bytes)
  offset 8:  length (number of elements, 8 bytes)
  offset 16: capacity (allocated space, 8 bytes)

Element Storage:
  Each element is 8 bytes (integer/pointer)
  Elements stored contiguously for cache efficiency
:End Note

Import "memory/layout.runa" as Layout
Import "core/memory_core.runa" as Memory

Note: ============================================================================
Note: CONSTANTS
Note: ============================================================================

Let LIST_INITIAL_CAPACITY be 8
Let LIST_ELEMENT_SIZE be 8
Let LIST_GROWTH_FACTOR be 2

Note: ============================================================================
Note: LIST CREATION AND DESTRUCTION
Note: ============================================================================

Process called "list_create" returns Integer:
    Note: Create new empty list with initial capacity
    Note: Returns pointer to List structure (24 bytes), or 0 on failure

    Note: Allocate list structure
    Let list be proc allocate from Layout with 24
    If list is equal to 0:
        Return 0
    End If

    Note: Allocate initial data array
    Let data_size be LIST_INITIAL_CAPACITY multiplied by LIST_ELEMENT_SIZE
    Let data be proc allocate from Layout with data_size
    If data is equal to 0:
        proc deallocate from Layout with list
        Return 0
    End If

    Note: Initialize list fields
    proc memory_set_int64 from Memory with list, 0, data  Note: data pointer
    proc memory_set_int64 from Memory with list, 8, 0     Note: length = 0
    proc memory_set_int64 from Memory with list, 16, LIST_INITIAL_CAPACITY  Note: capacity

    Return list
End Process

Process called "list_create_with_capacity" takes capacity as Integer returns Integer:
    Note: Create list with specified initial capacity
    Note: Useful when you know the size in advance

    If capacity is less than 1:
        Set capacity to LIST_INITIAL_CAPACITY
    End If

    Let list be proc allocate from Layout with 24
    If list is equal to 0:
        Return 0
    End If

    Let data_size be capacity multiplied by LIST_ELEMENT_SIZE
    Let data be proc allocate from Layout with data_size
    If data is equal to 0:
        proc deallocate from Layout with list
        Return 0
    End If

    proc memory_set_int64 from Memory with list, 0, data
    proc memory_set_int64 from Memory with list, 8, 0
    proc memory_set_int64 from Memory with list, 16, capacity

    Return list
End Process

Process called "list_destroy" takes list as Integer returns Integer:
    Note: Destroy list and free all memory
    Note: Returns 1 on success, 0 on failure

    If list is equal to 0:
        Return 0
    End If

    Let data be proc memory_get_int64 from Memory with list, 0
    If data is not equal to 0:
        proc deallocate from Layout with data
    End If

    proc deallocate from Layout with list
    Return 1
End Process

Note: ============================================================================
Note: LIST CAPACITY MANAGEMENT
Note: ============================================================================

Process called "list_ensure_capacity" takes list as Integer, min_capacity as Integer returns Integer:
    Note: Ensure list has at least min_capacity
    Note: Grows capacity if needed
    Note: Returns 1 on success, 0 on failure

    If list is equal to 0:
        Return 0
    End If

    Let current_capacity be proc memory_get_int64 from Memory with list, 16

    If current_capacity is greater than or equal to min_capacity:
        Return 1  Note: Already have enough capacity
    End If

    Note: Calculate new capacity (double until we exceed min_capacity)
    Let new_capacity be current_capacity
    While new_capacity is less than min_capacity:
        Set new_capacity to new_capacity multiplied by LIST_GROWTH_FACTOR
    End While

    Note: Allocate new data array
    Let new_size be new_capacity multiplied by LIST_ELEMENT_SIZE
    Let new_data be proc allocate from Layout with new_size
    If new_data is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Copy existing elements to new array
    Let old_data be proc memory_get_int64 from Memory with list, 0
    Let length be proc memory_get_int64 from Memory with list, 8
    Let copy_size be length multiplied by LIST_ELEMENT_SIZE
    proc memory_copy from Memory with new_data, old_data, copy_size

    Note: Free old array and update list
    proc deallocate from Layout with old_data
    proc memory_set_int64 from Memory with list, 0, new_data
    proc memory_set_int64 from Memory with list, 16, new_capacity

    Return 1
End Process

Note: ============================================================================
Note: LIST ELEMENT ACCESS
Note: ============================================================================

Process called "list_get" takes list as Integer, index as Integer returns Integer:
    Note: Get element at index
    Note: Returns element value, or 0 if out of bounds
    Note: WARNING: Cannot distinguish between value=0 and out of bounds

    If list is equal to 0:
        Return 0
    End If

    Let length be proc memory_get_int64 from Memory with list, 8

    If index is less than 0:
        Return 0  Note: Negative index
    End If

    If index is greater than or equal to length:
        Return 0  Note: Out of bounds
    End If

    Let data be proc memory_get_int64 from Memory with list, 0
    Let offset be index multiplied by LIST_ELEMENT_SIZE
    Let element_ptr be data plus offset

    Return proc memory_get_int64 from Memory with element_ptr, 0
End Process

Process called "list_set" takes list as Integer, index as Integer, value as Integer returns Integer:
    Note: Set element at index
    Note: Returns 1 on success, 0 if out of bounds

    If list is equal to 0:
        Return 0
    End If

    Let length be proc memory_get_int64 from Memory with list, 8

    If index is less than 0:
        Return 0
    End If

    If index is greater than or equal to length:
        Return 0
    End If

    Let data be proc memory_get_int64 from Memory with list, 0
    Let offset be index multiplied by LIST_ELEMENT_SIZE
    Let element_ptr be data plus offset

    proc memory_set_int64 from Memory with element_ptr, 0, value
    Return 1
End Process

Note: ============================================================================
Note: LIST MODIFICATION
Note: ============================================================================

Process called "list_push" takes list as Integer, value as Integer returns Integer:
    Note: Append element to end of list
    Note: Automatically grows capacity if needed
    Note: Returns 1 on success, 0 on failure

    If list is equal to 0:
        Return 0
    End If

    Let length be proc memory_get_int64 from Memory with list, 8
    Let capacity be proc memory_get_int64 from Memory with list, 16

    Note: Ensure we have capacity for one more element
    If length is greater than or equal to capacity:
        Let new_capacity be capacity multiplied by LIST_GROWTH_FACTOR
        Let result be proc list_ensure_capacity with list, new_capacity
        If result is equal to 0:
            Return 0  Note: Failed to grow
        End If
    End If

    Note: Add element at end
    Let data be proc memory_get_int64 from Memory with list, 0
    Let offset be length multiplied by LIST_ELEMENT_SIZE
    Let element_ptr be data plus offset
    proc memory_set_int64 from Memory with element_ptr, 0, value

    Note: Increment length
    Set length to length plus 1
    proc memory_set_int64 from Memory with list, 8, length

    Return 1
End Process

Process called "list_pop" takes list as Integer returns Integer:
    Note: Remove and return last element
    Note: Returns element value, or 0 if list is empty
    Note: WARNING: Cannot distinguish between value=0 and empty list

    If list is equal to 0:
        Return 0
    End If

    Let length be proc memory_get_int64 from Memory with list, 8

    If length is equal to 0:
        Return 0  Note: List is empty
    End If

    Note: Get last element
    Let new_length be length minus 1
    Let data be proc memory_get_int64 from Memory with list, 0
    Let offset be new_length multiplied by LIST_ELEMENT_SIZE
    Let element_ptr be data plus offset
    Let value be proc memory_get_int64 from Memory with element_ptr, 0

    Note: Update length
    proc memory_set_int64 from Memory with list, 8, new_length

    Return value
End Process

Process called "list_insert" takes list as Integer, index as Integer, value as Integer returns Integer:
    Note: Insert element at index, shifting later elements right
    Note: Returns 1 on success, 0 on failure
    Note: Can insert at index=length (equivalent to push)

    If list is equal to 0:
        Return 0
    End If

    Let length be proc memory_get_int64 from Memory with list, 8

    If index is less than 0:
        Return 0
    End If

    If index is greater than length:
        Return 0  Note: Can insert at length, but not beyond
    End If

    Note: Ensure capacity
    Let capacity be proc memory_get_int64 from Memory with list, 16
    If length is greater than or equal to capacity:
        Let new_capacity be capacity multiplied by LIST_GROWTH_FACTOR
        Let result be proc list_ensure_capacity with list, new_capacity
        If result is equal to 0:
            Return 0
        End If
    End If

    Let data be proc memory_get_int64 from Memory with list, 0

    Note: Shift elements right from index to end
    Let i be length
    While i is greater than index:
        Let src_offset be i minus 1
        Set src_offset to src_offset multiplied by LIST_ELEMENT_SIZE
        Let dst_offset be i multiplied by LIST_ELEMENT_SIZE
        Let src_ptr be data plus src_offset
        Let dst_ptr be data plus dst_offset
        Let elem be proc memory_get_int64 from Memory with src_ptr, 0
        proc memory_set_int64 from Memory with dst_ptr, 0, elem
        Set i to i minus 1
    End While

    Note: Insert new element
    Let insert_offset be index multiplied by LIST_ELEMENT_SIZE
    Let insert_ptr be data plus insert_offset
    proc memory_set_int64 from Memory with insert_ptr, 0, value

    Note: Increment length
    Set length to length plus 1
    proc memory_set_int64 from Memory with list, 8, length

    Return 1
End Process

Process called "list_remove" takes list as Integer, index as Integer returns Integer:
    Note: Remove element at index, shifting later elements left
    Note: Returns removed element value, or 0 if out of bounds

    If list is equal to 0:
        Return 0
    End If

    Let length be proc memory_get_int64 from Memory with list, 8

    If index is less than 0:
        Return 0
    End If

    If index is greater than or equal to length:
        Return 0
    End If

    Let data be proc memory_get_int64 from Memory with list, 0

    Note: Get element to return
    Let remove_offset be index multiplied by LIST_ELEMENT_SIZE
    Let remove_ptr be data plus remove_offset
    Let value be proc memory_get_int64 from Memory with remove_ptr, 0

    Note: Shift elements left from index+1 to end
    Let i be index
    Let last be length minus 1
    While i is less than last:
        Let src_offset be i plus 1
        Set src_offset to src_offset multiplied by LIST_ELEMENT_SIZE
        Let dst_offset be i multiplied by LIST_ELEMENT_SIZE
        Let src_ptr be data plus src_offset
        Let dst_ptr be data plus dst_offset
        Let elem be proc memory_get_int64 from Memory with src_ptr, 0
        proc memory_set_int64 from Memory with dst_ptr, 0, elem
        Set i to i plus 1
    End While

    Note: Decrement length
    Set length to length minus 1
    proc memory_set_int64 from Memory with list, 8, length

    Return value
End Process

Note: ============================================================================
Note: LIST QUERIES
Note: ============================================================================

Process called "list_length" takes list as Integer returns Integer:
    Note: Get number of elements in list
    If list is equal to 0:
        Return 0
    End If
    Return proc memory_get_int64 from Memory with list, 8
End Process

Process called "list_capacity" takes list as Integer returns Integer:
    Note: Get current capacity
    If list is equal to 0:
        Return 0
    End If
    Return proc memory_get_int64 from Memory with list, 16
End Process

Process called "list_is_empty" takes list as Integer returns Integer:
    Note: Check if list is empty
    Note: Returns 1 if empty, 0 if not
    If list is equal to 0:
        Return 1
    End If
    Let length be proc memory_get_int64 from Memory with list, 8
    If length is equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "list_clear" takes list as Integer returns Integer:
    Note: Remove all elements (keeps capacity)
    Note: Returns 1 on success
    If list is equal to 0:
        Return 0
    End If
    proc memory_set_int64 from Memory with list, 8, 0  Note: length = 0
    Return 1
End Process

Note: ============================================================================
Note: LIST SEARCH
Note: ============================================================================

Process called "list_index_of" takes list as Integer, value as Integer returns Integer:
    Note: Find first occurrence of value
    Note: Returns index if found, -1 if not found

    If list is equal to 0:
        Return -1
    End If

    Let length be proc memory_get_int64 from Memory with list, 8
    Let data be proc memory_get_int64 from Memory with list, 0

    Let i be 0
    While i is less than length:
        Let offset be i multiplied by LIST_ELEMENT_SIZE
        Let elem_ptr be data plus offset
        Let elem be proc memory_get_int64 from Memory with elem_ptr, 0
        If elem is equal to value:
            Return i
        End If
        Set i to i plus 1
    End While

    Return -1
End Process

Process called "list_contains" takes list as Integer, value as Integer returns Integer:
    Note: Check if list contains value
    Note: Returns 1 if found, 0 if not
    Let index be proc list_index_of with list, value
    If index is greater than or equal to 0:
        Return 1
    End If
    Return 0
End Process
