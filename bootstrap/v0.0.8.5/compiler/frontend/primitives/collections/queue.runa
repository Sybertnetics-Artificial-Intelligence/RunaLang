Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
QUEUE - FIFO (First In First Out) Data Structure

This file implements a queue using a circular buffer for efficient O(1) operations.

Architecture:
- Circular buffer implementation
- Fixed capacity with resize on demand
- Head and tail pointers for O(1) enqueue/dequeue
- Wraps around when reaching end of buffer

Features:
- O(1) enqueue (add to back)
- O(1) dequeue (remove from front)
- O(1) peek (view front without removing)
- Automatic resizing when full

Use Cases:
- Task queues in compiler
- BFS traversal
- Job scheduling
- Message queues

Queue Structure (32 bytes):
  offset 0:  buffer (pointer to element array, 8 bytes)
  offset 8:  capacity (buffer size, 8 bytes)
  offset 16: head (index of front element, 8 bytes)
  offset 24: tail (index after last element, 8 bytes)

Element Storage:
  Each element is 8 bytes (integer/pointer)
  Buffer is circular: tail wraps to 0 after capacity-1

Queue State:
  Empty: head == tail
  Full: (tail + 1) % capacity == head
  Count: (tail - head + capacity) % capacity
:End Note

Import "memory/layout.runa" as Layout
Import "core/memory_core.runa" as Memory

Note: ============================================================================
Note: CONSTANTS
Note: ============================================================================

Let QUEUE_INITIAL_CAPACITY be 16
Let QUEUE_ELEMENT_SIZE be 8
Let QUEUE_GROWTH_FACTOR be 2

Note: ============================================================================
Note: QUEUE CREATION AND DESTRUCTION
Note: ============================================================================

Process called "queue_create" returns Integer:
    Note: Create new empty queue
    Note: Returns pointer to Queue structure (32 bytes), or 0 on failure

    Let queue be proc allocate from Layout with 32
    If queue is equal to 0:
        Return 0
    End If

    Note: Allocate buffer
    Let buffer_size be QUEUE_INITIAL_CAPACITY multiplied by QUEUE_ELEMENT_SIZE
    Let buffer be proc allocate from Layout with buffer_size
    If buffer is equal to 0:
        proc deallocate from Layout with queue
        Return 0
    End If

    Note: Initialize queue fields
    proc memory_set_int64 from Memory with queue, 0, buffer
    proc memory_set_int64 from Memory with queue, 8, QUEUE_INITIAL_CAPACITY
    proc memory_set_int64 from Memory with queue, 16, 0  Note: head = 0
    proc memory_set_int64 from Memory with queue, 24, 0  Note: tail = 0

    Return queue
End Process

Process called "queue_create_with_capacity" takes capacity as Integer returns Integer:
    Note: Create queue with specified capacity
    Note: Capacity must be at least 2 (need 1 slot for full detection)

    If capacity is less than 2:
        Set capacity to QUEUE_INITIAL_CAPACITY
    End If

    Let queue be proc allocate from Layout with 32
    If queue is equal to 0:
        Return 0
    End If

    Let buffer_size be capacity multiplied by QUEUE_ELEMENT_SIZE
    Let buffer be proc allocate from Layout with buffer_size
    If buffer is equal to 0:
        proc deallocate from Layout with queue
        Return 0
    End If

    proc memory_set_int64 from Memory with queue, 0, buffer
    proc memory_set_int64 from Memory with queue, 8, capacity
    proc memory_set_int64 from Memory with queue, 16, 0
    proc memory_set_int64 from Memory with queue, 24, 0

    Return queue
End Process

Process called "queue_destroy" takes queue as Integer returns Integer:
    Note: Destroy queue and free memory
    Note: Returns 1 on success

    If queue is equal to 0:
        Return 0
    End If

    Let buffer be proc memory_get_int64 from Memory with queue, 0
    If buffer is not equal to 0:
        proc deallocate from Layout with buffer
    End If

    proc deallocate from Layout with queue
    Return 1
End Process

Note: ============================================================================
Note: QUEUE OPERATIONS
Note: ============================================================================

Process called "queue_is_full" takes queue as Integer returns Integer:
    Note: Check if queue is full
    Note: Returns 1 if full, 0 if not

    If queue is equal to 0:
        Return 1  Note: Treat null as full
    End If

    Let capacity be proc memory_get_int64 from Memory with queue, 8
    Let head be proc memory_get_int64 from Memory with queue, 16
    Let tail be proc memory_get_int64 from Memory with queue, 24

    Note: Full when (tail + 1) % capacity == head
    Let next_tail be tail plus 1
    Set next_tail to next_tail modulo by capacity

    If next_tail is equal to head:
        Return 1
    End If

    Return 0
End Process

Process called "queue_resize" takes queue as Integer returns Integer:
    Note: Double queue capacity
    Note: Returns 1 on success, 0 on failure

    If queue is equal to 0:
        Return 0
    End If

    Let old_buffer be proc memory_get_int64 from Memory with queue, 0
    Let old_capacity be proc memory_get_int64 from Memory with queue, 8
    Let head be proc memory_get_int64 from Memory with queue, 16
    Let tail be proc memory_get_int64 from Memory with queue, 24

    Let new_capacity be old_capacity multiplied by QUEUE_GROWTH_FACTOR
    Let new_size be new_capacity multiplied by QUEUE_ELEMENT_SIZE
    Let new_buffer be proc allocate from Layout with new_size
    If new_buffer is equal to 0:
        Return 0
    End If

    Note: Copy elements from old buffer to new buffer (linearize)
    Let i be 0
    Let current be head

    While current is not equal to tail:
        Let old_offset be current multiplied by QUEUE_ELEMENT_SIZE
        Let old_ptr be old_buffer plus old_offset
        Let value be proc memory_get_int64 from Memory with old_ptr, 0

        Let new_offset be i multiplied by QUEUE_ELEMENT_SIZE
        Let new_ptr be new_buffer plus new_offset
        proc memory_set_int64 from Memory with new_ptr, 0, value

        Set i to i plus 1
        Set current to current plus 1
        If current is greater than or equal to old_capacity:
            Set current to 0  Note: Wrap around
        End If
    End While

    Note: Update queue structure
    proc deallocate from Layout with old_buffer
    proc memory_set_int64 from Memory with queue, 0, new_buffer
    proc memory_set_int64 from Memory with queue, 8, new_capacity
    proc memory_set_int64 from Memory with queue, 16, 0  Note: head = 0
    proc memory_set_int64 from Memory with queue, 24, i  Note: tail = count

    Return 1
End Process

Process called "queue_enqueue" takes queue as Integer, value as Integer returns Integer:
    Note: Add element to back of queue
    Note: Automatically resizes if full
    Note: Returns 1 on success, 0 on failure

    If queue is equal to 0:
        Return 0
    End If

    Note: Check if full and resize if needed
    Let is_full be proc queue_is_full with queue
    If is_full is equal to 1:
        Let result be proc queue_resize with queue
        If result is equal to 0:
            Return 0  Note: Resize failed
        End If
    End If

    Let buffer be proc memory_get_int64 from Memory with queue, 0
    Let capacity be proc memory_get_int64 from Memory with queue, 8
    Let tail be proc memory_get_int64 from Memory with queue, 24

    Note: Add element at tail
    Let offset be tail multiplied by QUEUE_ELEMENT_SIZE
    Let elem_ptr be buffer plus offset
    proc memory_set_int64 from Memory with elem_ptr, 0, value

    Note: Advance tail (circular)
    Set tail to tail plus 1
    If tail is greater than or equal to capacity:
        Set tail to 0
    End If
    proc memory_set_int64 from Memory with queue, 24, tail

    Return 1
End Process

Process called "queue_dequeue" takes queue as Integer returns Integer:
    Note: Remove and return element from front of queue
    Note: Returns element value, or 0 if queue is empty
    Note: WARNING: Cannot distinguish between value=0 and empty queue

    If queue is equal to 0:
        Return 0
    End If

    Let head be proc memory_get_int64 from Memory with queue, 16
    Let tail be proc memory_get_int64 from Memory with queue, 24

    Note: Check if empty
    If head is equal to tail:
        Return 0  Note: Queue is empty
    End If

    Let buffer be proc memory_get_int64 from Memory with queue, 0
    Let capacity be proc memory_get_int64 from Memory with queue, 8

    Note: Get element at head
    Let offset be head multiplied by QUEUE_ELEMENT_SIZE
    Let elem_ptr be buffer plus offset
    Let value be proc memory_get_int64 from Memory with elem_ptr, 0

    Note: Advance head (circular)
    Set head to head plus 1
    If head is greater than or equal to capacity:
        Set head to 0
    End If
    proc memory_set_int64 from Memory with queue, 16, head

    Return value
End Process

Process called "queue_peek" takes queue as Integer returns Integer:
    Note: View front element without removing
    Note: Returns element value, or 0 if queue is empty

    If queue is equal to 0:
        Return 0
    End If

    Let head be proc memory_get_int64 from Memory with queue, 16
    Let tail be proc memory_get_int64 from Memory with queue, 24

    If head is equal to tail:
        Return 0  Note: Queue is empty
    End If

    Let buffer be proc memory_get_int64 from Memory with queue, 0
    Let offset be head multiplied by QUEUE_ELEMENT_SIZE
    Let elem_ptr be buffer plus offset

    Return proc memory_get_int64 from Memory with elem_ptr, 0
End Process

Note: ============================================================================
Note: QUEUE QUERIES
Note: ============================================================================

Process called "queue_is_empty" takes queue as Integer returns Integer:
    Note: Check if queue is empty
    Note: Returns 1 if empty, 0 if not

    If queue is equal to 0:
        Return 1
    End If

    Let head be proc memory_get_int64 from Memory with queue, 16
    Let tail be proc memory_get_int64 from Memory with queue, 24

    If head is equal to tail:
        Return 1
    End If

    Return 0
End Process

Process called "queue_count" takes queue as Integer returns Integer:
    Note: Get number of elements in queue

    If queue is equal to 0:
        Return 0
    End If

    Let capacity be proc memory_get_int64 from Memory with queue, 8
    Let head be proc memory_get_int64 from Memory with queue, 16
    Let tail be proc memory_get_int64 from Memory with queue, 24

    Note: Calculate count: (tail - head + capacity) % capacity
    Let count be tail minus head
    Set count to count plus capacity
    Set count to count modulo by capacity

    Return count
End Process

Process called "queue_capacity" takes queue as Integer returns Integer:
    Note: Get current capacity
    If queue is equal to 0:
        Return 0
    End If
    Return proc memory_get_int64 from Memory with queue, 8
End Process

Process called "queue_clear" takes queue as Integer returns Integer:
    Note: Remove all elements from queue
    Note: Returns 1 on success

    If queue is equal to 0:
        Return 0
    End If

    Note: Reset to empty state
    proc memory_set_int64 from Memory with queue, 16, 0  Note: head = 0
    proc memory_set_int64 from Memory with queue, 24, 0  Note: tail = 0

    Return 1
End Process
