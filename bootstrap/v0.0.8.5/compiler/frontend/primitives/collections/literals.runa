Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
COLLECTION LITERALS - Compiler Primitive for Literal Syntax Processing

This file handles collection literal expressions during compilation.

This is a COMPILER-SIDE primitive that processes literal syntax like:
- [1, 2, 3]           -> List literal
- {"key": "value"}    -> Dictionary literal
- {1, 2, 3}           -> Set literal
- [|1, 2, 3|]         -> Array literal (fixed-size)

Responsibilities:
- Validate literal syntax structure
- Track literal element types for type checking
- Generate AST nodes for collection literals
- Support nested literals (lists within dicts, etc.)

This does NOT execute at runtime - it's used during compilation to:
1. Parse literal syntax from source code
2. Build intermediate representation (AST)
3. Type-check literal contents
4. Generate code that constructs collections at runtime

Use Cases:
- Parser processing of collection literals
- Type inference for literal expressions
- Code generation for collection initialization
- Constant folding for literal expressions

Dependencies:
- collections/list.runa (for storing literal elements during compilation)
- collections/hashtable.runa (for dictionary literal validation)
:End Note

Import "collections/list.runa" as List
Import "collections/hashtable.runa" as Hashtable
Import "memory/layout.runa" as Layout
Import "core/memory_core.runa" as Memory

Note: ============================================================================
Note: LITERAL TYPE CONSTANTS
Note: ============================================================================

Let LITERAL_TYPE_LIST be 1
Let LITERAL_TYPE_DICT be 2
Let LITERAL_TYPE_SET be 3
Let LITERAL_TYPE_ARRAY be 4

Note: ============================================================================
Note: LITERAL STRUCTURE
Note: ============================================================================

Note: Literal Structure (32 bytes) - represents a literal expression during compilation
Note:   offset 0:  literal_type (1=list, 2=dict, 3=set, 4=array, 8 bytes)
Note:   offset 8:  elements (pointer to List of element AST nodes, 8 bytes)
Note:   offset 16: element_count (number of elements, 8 bytes)
Note:   offset 24: is_homogeneous (1 if all elements same type, 0 if mixed, 8 bytes)

Note: ============================================================================
Note: LITERAL CREATION
Note: ============================================================================

Process called "literal_create" takes literal_type as Integer returns Integer:
    Note: Create new literal structure for compilation
    Note: Returns pointer to Literal structure, or 0 on failure

    Let literal be proc allocate from Layout with 32
    If literal is equal to 0:
        Return 0
    End If

    Note: Create element list
    Let elements be proc list_create from List
    If elements is equal to 0:
        proc deallocate from Layout with literal
        Return 0
    End If

    Note: Initialize literal fields
    proc memory_set_int64 from Memory with literal, 0, literal_type
    proc memory_set_int64 from Memory with literal, 8, elements
    proc memory_set_int64 from Memory with literal, 16, 0  Note: element_count = 0
    proc memory_set_int64 from Memory with literal, 24, 1  Note: is_homogeneous = true initially

    Return literal
End Process

Process called "literal_destroy" takes literal as Integer returns Integer:
    Note: Destroy literal structure and free memory
    Note: Does NOT destroy element AST nodes (caller's responsibility)

    If literal is equal to 0:
        Return 0
    End If

    Let elements be proc memory_get_int64 from Memory with literal, 8
    If elements is not equal to 0:
        proc list_destroy from List with elements
    End If

    proc deallocate from Layout with literal
    Return 1
End Process

Note: ============================================================================
Note: ELEMENT MANAGEMENT
Note: ============================================================================

Process called "literal_add_element" takes literal as Integer, element_node as Integer returns Integer:
    Note: Add element AST node to literal
    Note: element_node is pointer to AST node for this element
    Note: Returns 1 on success, 0 on failure

    If literal is equal to 0:
        Return 0
    End If

    Let elements be proc memory_get_int64 from Memory with literal, 8
    Let result be proc list_push from List with elements, element_node
    If result is equal to 0:
        Return 0
    End If

    Note: Update element count
    Let count be proc memory_get_int64 from Memory with literal, 16
    Set count to count plus 1
    proc memory_set_int64 from Memory with literal, 16, count

    Return 1
End Process

Process called "literal_get_element" takes literal as Integer, index as Integer returns Integer:
    Note: Get element AST node at index
    Note: Returns element node pointer, or 0 if out of bounds

    If literal is equal to 0:
        Return 0
    End If

    Let elements be proc memory_get_int64 from Memory with literal, 8
    Return proc list_get from List with elements, index
End Process

Process called "literal_get_element_count" takes literal as Integer returns Integer:
    Note: Get number of elements in literal
    If literal is equal to 0:
        Return 0
    End If
    Return proc memory_get_int64 from Memory with literal, 16
End Process

Note: ============================================================================
Note: TYPE VALIDATION
Note: ============================================================================

Process called "literal_mark_heterogeneous" takes literal as Integer returns Integer:
    Note: Mark literal as having mixed element types
    Note: Called during type checking when elements have different types

    If literal is equal to 0:
        Return 0
    End If

    proc memory_set_int64 from Memory with literal, 24, 0  Note: is_homogeneous = false
    Return 1
End Process

Process called "literal_is_homogeneous" takes literal as Integer returns Integer:
    Note: Check if all elements have the same type
    Note: Returns 1 if homogeneous, 0 if mixed types

    If literal is equal to 0:
        Return 0
    End If

    Return proc memory_get_int64 from Memory with literal, 24
End Process

Note: ============================================================================
Note: LIST LITERAL HELPERS
Note: ============================================================================

Process called "list_literal_create" returns Integer:
    Note: Create list literal structure
    Note: Convenience wrapper for literal_create(LITERAL_TYPE_LIST)

    Return proc literal_create with LITERAL_TYPE_LIST
End Process

Process called "list_literal_validate" takes literal as Integer returns Integer:
    Note: Validate list literal structure
    Note: Returns 1 if valid, 0 if invalid
    Note: Lists can have any elements (including nested literals)

    If literal is equal to 0:
        Return 0
    End If

    Let literal_type be proc memory_get_int64 from Memory with literal, 0
    If literal_type is not equal to LITERAL_TYPE_LIST:
        Return 0  Note: Not a list literal
    End If

    Note: Lists are always valid (can be empty, heterogeneous, etc.)
    Return 1
End Process

Note: ============================================================================
Note: DICTIONARY LITERAL HELPERS
Note: ============================================================================

Note: Dictionary Literal Element Structure (16 bytes)
Note:   offset 0:  key_node (pointer to key AST node, 8 bytes)
Note:   offset 8:  value_node (pointer to value AST node, 8 bytes)

Process called "dict_literal_create" returns Integer:
    Note: Create dictionary literal structure
    Return proc literal_create with LITERAL_TYPE_DICT
End Process

Process called "dict_literal_create_pair" takes key_node as Integer, value_node as Integer returns Integer:
    Note: Create key-value pair structure for dict literal
    Note: Returns pointer to pair structure (16 bytes)

    Let pair be proc allocate from Layout with 16
    If pair is equal to 0:
        Return 0
    End If

    proc memory_set_int64 from Memory with pair, 0, key_node
    proc memory_set_int64 from Memory with pair, 8, value_node

    Return pair
End Process

Process called "dict_literal_add_pair" takes literal as Integer, key_node as Integer, value_node as Integer returns Integer:
    Note: Add key-value pair to dictionary literal
    Note: Returns 1 on success, 0 on failure

    If literal is equal to 0:
        Return 0
    End If

    Let literal_type be proc memory_get_int64 from Memory with literal, 0
    If literal_type is not equal to LITERAL_TYPE_DICT:
        Return 0  Note: Not a dict literal
    End If

    Note: Create pair structure
    Let pair be proc dict_literal_create_pair with key_node, value_node
    If pair is equal to 0:
        Return 0
    End If

    Note: Add pair to elements list
    Return proc literal_add_element with literal, pair
End Process

Process called "dict_literal_get_pair" takes literal as Integer, index as Integer returns Integer:
    Note: Get key-value pair at index
    Note: Returns pointer to pair structure (16 bytes), or 0 if out of bounds

    If literal is equal to 0:
        Return 0
    End If

    Let literal_type be proc memory_get_int64 from Memory with literal, 0
    If literal_type is not equal to LITERAL_TYPE_DICT:
        Return 0
    End If

    Return proc literal_get_element with literal, index
End Process

Process called "dict_literal_validate" takes literal as Integer returns Integer:
    Note: Validate dictionary literal structure
    Note: Ensures all keys are unique (no duplicates)
    Note: Returns 1 if valid, 0 if invalid

    If literal is equal to 0:
        Return 0
    End If

    Let literal_type be proc memory_get_int64 from Memory with literal, 0
    If literal_type is not equal to LITERAL_TYPE_DICT:
        Return 0
    End If

    Let count be proc literal_get_element_count with literal
    If count is equal to 0:
        Return 1  Note: Empty dict is valid
    End If

    Note: Check for duplicate keys using hashtable
    Let key_tracker be proc hashtable_create from Hashtable
    If key_tracker is equal to 0:
        Return 0
    End If

    Let i be 0
    Let is_valid be 1

    While i is less than count:
        Let pair be proc dict_literal_get_pair with literal, i
        If pair is equal to 0:
            Set is_valid to 0
            Let break be 1
        Otherwise:
            Let key_node be proc memory_get_int64 from Memory with pair, 0

            Note: Extract actual key value from AST node
            Note: AST literal string node structure: offset 8 contains pointer to string value
            Let key_value be proc memory_get_int64 from Memory with key_node, 8

            If key_value is equal to 0:
                Set is_valid to 0  Note: Invalid key node
                Let break be 1
            Otherwise:
                Note: Check if this key value already exists in the dictionary
                Let exists be proc hashtable_has from Hashtable with key_tracker, key_value
                If exists is equal to 1:
                    Set is_valid to 0  Note: Duplicate key found
                    Let break be 1
                Otherwise:
                    Note: Add key value to tracker to detect future duplicates
                    proc hashtable_set from Hashtable with key_tracker, key_value, 1
                End If
            End If
        End If

        Set i to i plus 1
    End While

    proc hashtable_destroy from Hashtable with key_tracker
    Return is_valid
End Process

Note: ============================================================================
Note: SET LITERAL HELPERS
Note: ============================================================================

Process called "set_literal_create" returns Integer:
    Note: Create set literal structure
    Return proc literal_create with LITERAL_TYPE_SET
End Process

Process called "set_literal_validate" takes literal as Integer returns Integer:
    Note: Validate set literal structure
    Note: Ensures all elements are unique (no duplicates)
    Note: Returns 1 if valid, 0 if invalid

    If literal is equal to 0:
        Return 0
    End If

    Let literal_type be proc memory_get_int64 from Memory with literal, 0
    If literal_type is not equal to LITERAL_TYPE_SET:
        Return 0
    End If

    Let count be proc literal_get_element_count with literal
    If count is equal to 0:
        Return 1  Note: Empty set is valid
    End If

    Note: Check for duplicate elements using hashtable
    Let element_tracker be proc hashtable_create from Hashtable
    If element_tracker is equal to 0:
        Return 0
    End If

    Let i be 0
    Let is_valid be 1

    While i is less than count:
        Let element_node be proc literal_get_element with literal, i
        If element_node is equal to 0:
            Set is_valid to 0
            Let break be 1
        Otherwise:
            Note: Extract actual element value from AST node
            Note: AST literal node structure: offset 8 contains pointer to value
            Let element_value be proc memory_get_int64 from Memory with element_node, 8

            If element_value is equal to 0:
                Set is_valid to 0  Note: Invalid element node
                Let break be 1
            Otherwise:
                Note: Check if this element value already exists in the set
                Let exists be proc hashtable_has from Hashtable with element_tracker, element_value
                If exists is equal to 1:
                    Set is_valid to 0  Note: Duplicate element found
                    Let break be 1
                Otherwise:
                    Note: Add element value to tracker to detect future duplicates
                    proc hashtable_set from Hashtable with element_tracker, element_value, 1
                End If
            End If
        End If

        Set i to i plus 1
    End While

    proc hashtable_destroy from Hashtable with element_tracker
    Return is_valid
End Process

Note: ============================================================================
Note: ARRAY LITERAL HELPERS
Note: ============================================================================

Process called "array_literal_create" returns Integer:
    Note: Create array literal structure (fixed-size)
    Return proc literal_create with LITERAL_TYPE_ARRAY
End Process

Process called "array_literal_validate" takes literal as Integer returns Integer:
    Note: Validate array literal structure
    Note: Arrays must be homogeneous (all elements same type)
    Note: Returns 1 if valid, 0 if invalid

    If literal is equal to 0:
        Return 0
    End If

    Let literal_type be proc memory_get_int64 from Memory with literal, 0
    If literal_type is not equal to LITERAL_TYPE_ARRAY:
        Return 0
    End If

    Note: Arrays must be homogeneous
    Let is_homogeneous be proc literal_is_homogeneous with literal
    If is_homogeneous is equal to 0:
        Return 0  Note: Heterogeneous array is invalid
    End If

    Return 1
End Process

Note: ============================================================================
Note: GENERAL VALIDATION
Note: ============================================================================

Process called "literal_validate" takes literal as Integer returns Integer:
    Note: Validate literal based on its type
    Note: Returns 1 if valid, 0 if invalid
    Note: Dispatches to type-specific validation

    If literal is equal to 0:
        Return 0
    End If

    Let literal_type be proc memory_get_int64 from Memory with literal, 0

    If literal_type is equal to LITERAL_TYPE_LIST:
        Return proc list_literal_validate with literal
    End If

    If literal_type is equal to LITERAL_TYPE_DICT:
        Return proc dict_literal_validate with literal
    End If

    If literal_type is equal to LITERAL_TYPE_SET:
        Return proc set_literal_validate with literal
    End If

    If literal_type is equal to LITERAL_TYPE_ARRAY:
        Return proc array_literal_validate with literal
    End If

    Return 0  Note: Unknown literal type
End Process

Note: ============================================================================
Note: LITERAL TYPE QUERIES
Note: ============================================================================

Process called "literal_get_type" takes literal as Integer returns Integer:
    Note: Get literal type constant
    Note: Returns LITERAL_TYPE_* constant, or 0 if invalid

    If literal is equal to 0:
        Return 0
    End If

    Return proc memory_get_int64 from Memory with literal, 0
End Process

Process called "literal_is_list" takes literal as Integer returns Integer:
    If literal is equal to 0:
        Return 0
    End If
    Let literal_type be proc memory_get_int64 from Memory with literal, 0
    If literal_type is equal to LITERAL_TYPE_LIST:
        Return 1
    End If
    Return 0
End Process

Process called "literal_is_dict" takes literal as Integer returns Integer:
    If literal is equal to 0:
        Return 0
    End If
    Let literal_type be proc memory_get_int64 from Memory with literal, 0
    If literal_type is equal to LITERAL_TYPE_DICT:
        Return 1
    End If
    Return 0
End Process

Process called "literal_is_set" takes literal as Integer returns Integer:
    If literal is equal to 0:
        Return 0
    End If
    Let literal_type be proc memory_get_int64 from Memory with literal, 0
    If literal_type is equal to LITERAL_TYPE_SET:
        Return 1
    End If
    Return 0
End Process

Process called "literal_is_array" takes literal as Integer returns Integer:
    If literal is equal to 0:
        Return 0
    End If
    Let literal_type be proc memory_get_int64 from Memory with literal, 0
    If literal_type is equal to LITERAL_TYPE_ARRAY:
        Return 1
    End If
    Return 0
End Process
