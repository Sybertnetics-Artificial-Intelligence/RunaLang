Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
STACK - LIFO (Last In First Out) Data Structure

This file implements a stack using a dynamic array for efficient O(1) operations.

Architecture:
- Dynamic array implementation
- Doubles capacity when full
- Top pointer tracks stack top
- Simple push/pop operations

Features:
- O(1) push (add to top)
- O(1) pop (remove from top)
- O(1) peek (view top without removing)
- Automatic resizing when full

Use Cases:
- Expression evaluation
- Scope tracking in parser
- Function call stack simulation
- Backtracking algorithms

Stack Structure (24 bytes):
  offset 0:  data (pointer to element array, 8 bytes)
  offset 8:  top (index of next free slot, 8 bytes)
  offset 16: capacity (buffer size, 8 bytes)

Element Storage:
  Each element is 8 bytes (integer/pointer)
  Elements stored at indices [0, top)

Stack State:
  Empty: top == 0
  Full: top == capacity
  Count: top
:End Note

Import "memory/layout.runa" as Layout
Import "core/memory_core.runa" as Memory

Note: ============================================================================
Note: CONSTANTS
Note: ============================================================================

Let STACK_INITIAL_CAPACITY be 16
Let STACK_ELEMENT_SIZE be 8
Let STACK_GROWTH_FACTOR be 2

Note: ============================================================================
Note: STACK CREATION AND DESTRUCTION
Note: ============================================================================

Process called "stack_create" returns Integer:
    Note: Create new empty stack
    Note: Returns pointer to Stack structure (24 bytes), or 0 on failure

    Let stack be proc allocate from Layout with 24
    If stack is equal to 0:
        Return 0
    End If

    Note: Allocate data array
    Let data_size be STACK_INITIAL_CAPACITY multiplied by STACK_ELEMENT_SIZE
    Let data be proc allocate from Layout with data_size
    If data is equal to 0:
        proc deallocate from Layout with stack
        Return 0
    End If

    Note: Initialize stack fields
    proc memory_set_int64 from Memory with stack, 0, data
    proc memory_set_int64 from Memory with stack, 8, 0   Note: top = 0 (empty)
    proc memory_set_int64 from Memory with stack, 16, STACK_INITIAL_CAPACITY

    Return stack
End Process

Process called "stack_create_with_capacity" takes capacity as Integer returns Integer:
    Note: Create stack with specified capacity

    If capacity is less than 1:
        Set capacity to STACK_INITIAL_CAPACITY
    End If

    Let stack be proc allocate from Layout with 24
    If stack is equal to 0:
        Return 0
    End If

    Let data_size be capacity multiplied by STACK_ELEMENT_SIZE
    Let data be proc allocate from Layout with data_size
    If data is equal to 0:
        proc deallocate from Layout with stack
        Return 0
    End If

    proc memory_set_int64 from Memory with stack, 0, data
    proc memory_set_int64 from Memory with stack, 8, 0
    proc memory_set_int64 from Memory with stack, 16, capacity

    Return stack
End Process

Process called "stack_destroy" takes stack as Integer returns Integer:
    Note: Destroy stack and free memory
    Note: Returns 1 on success

    If stack is equal to 0:
        Return 0
    End If

    Let data be proc memory_get_int64 from Memory with stack, 0
    If data is not equal to 0:
        proc deallocate from Layout with data
    End If

    proc deallocate from Layout with stack
    Return 1
End Process

Note: ============================================================================
Note: CAPACITY MANAGEMENT
Note: ============================================================================

Process called "stack_ensure_capacity" takes stack as Integer, min_capacity as Integer returns Integer:
    Note: Ensure stack has at least min_capacity
    Note: Returns 1 on success, 0 on failure

    If stack is equal to 0:
        Return 0
    End If

    Let current_capacity be proc memory_get_int64 from Memory with stack, 16

    If current_capacity is greater than or equal to min_capacity:
        Return 1
    End If

    Note: Calculate new capacity
    Let new_capacity be current_capacity
    While new_capacity is less than min_capacity:
        Set new_capacity to new_capacity multiplied by STACK_GROWTH_FACTOR
    End While

    Note: Allocate new array
    Let new_size be new_capacity multiplied by STACK_ELEMENT_SIZE
    Let new_data be proc allocate from Layout with new_size
    If new_data is equal to 0:
        Return 0
    End If

    Note: Copy existing elements
    Let old_data be proc memory_get_int64 from Memory with stack, 0
    Let top be proc memory_get_int64 from Memory with stack, 8
    Let copy_size be top multiplied by STACK_ELEMENT_SIZE
    proc memory_copy from Memory with new_data, old_data, copy_size

    Note: Free old array and update
    proc deallocate from Layout with old_data
    proc memory_set_int64 from Memory with stack, 0, new_data
    proc memory_set_int64 from Memory with stack, 16, new_capacity

    Return 1
End Process

Note: ============================================================================
Note: STACK OPERATIONS
Note: ============================================================================

Process called "stack_push" takes stack as Integer, value as Integer returns Integer:
    Note: Push element onto stack
    Note: Automatically resizes if full
    Note: Returns 1 on success, 0 on failure

    If stack is equal to 0:
        Return 0
    End If

    Let top be proc memory_get_int64 from Memory with stack, 8
    Let capacity be proc memory_get_int64 from Memory with stack, 16

    Note: Ensure capacity
    If top is greater than or equal to capacity:
        Let new_capacity be capacity multiplied by STACK_GROWTH_FACTOR
        Let result be proc stack_ensure_capacity with stack, new_capacity
        If result is equal to 0:
            Return 0
        End If
    End If

    Note: Add element at top
    Let data be proc memory_get_int64 from Memory with stack, 0
    Let offset be top multiplied by STACK_ELEMENT_SIZE
    Let elem_ptr be data plus offset
    proc memory_set_int64 from Memory with elem_ptr, 0, value

    Note: Increment top
    Set top to top plus 1
    proc memory_set_int64 from Memory with stack, 8, top

    Return 1
End Process

Process called "stack_pop" takes stack as Integer returns Integer:
    Note: Pop element from stack
    Note: Returns element value, or 0 if stack is empty
    Note: WARNING: Cannot distinguish between value=0 and empty stack

    If stack is equal to 0:
        Return 0
    End If

    Let top be proc memory_get_int64 from Memory with stack, 8

    If top is equal to 0:
        Return 0  Note: Stack is empty
    End If

    Note: Decrement top
    Set top to top minus 1
    proc memory_set_int64 from Memory with stack, 8, top

    Note: Get element
    Let data be proc memory_get_int64 from Memory with stack, 0
    Let offset be top multiplied by STACK_ELEMENT_SIZE
    Let elem_ptr be data plus offset

    Return proc memory_get_int64 from Memory with elem_ptr, 0
End Process

Process called "stack_peek" takes stack as Integer returns Integer:
    Note: View top element without removing
    Note: Returns element value, or 0 if stack is empty

    If stack is equal to 0:
        Return 0
    End If

    Let top be proc memory_get_int64 from Memory with stack, 8

    If top is equal to 0:
        Return 0  Note: Stack is empty
    End If

    Note: Get element at top-1
    Let data be proc memory_get_int64 from Memory with stack, 0
    Let index be top minus 1
    Let offset be index multiplied by STACK_ELEMENT_SIZE
    Let elem_ptr be data plus offset

    Return proc memory_get_int64 from Memory with elem_ptr, 0
End Process

Process called "stack_peek_at" takes stack as Integer, depth as Integer returns Integer:
    Note: Peek at element at given depth from top
    Note: depth=0 is same as peek() (top element)
    Note: depth=1 is second from top, etc.
    Note: Returns element value, or 0 if out of bounds

    If stack is equal to 0:
        Return 0
    End If

    If depth is less than 0:
        Return 0
    End If

    Let top be proc memory_get_int64 from Memory with stack, 8

    If depth is greater than or equal to top:
        Return 0  Note: Depth too large
    End If

    Note: Calculate index from bottom: top - depth - 1
    Let index be top minus depth
    Set index to index minus 1

    Let data be proc memory_get_int64 from Memory with stack, 0
    Let offset be index multiplied by STACK_ELEMENT_SIZE
    Let elem_ptr be data plus offset

    Return proc memory_get_int64 from Memory with elem_ptr, 0
End Process

Note: ============================================================================
Note: STACK QUERIES
Note: ============================================================================

Process called "stack_is_empty" takes stack as Integer returns Integer:
    Note: Check if stack is empty
    Note: Returns 1 if empty, 0 if not

    If stack is equal to 0:
        Return 1
    End If

    Let top be proc memory_get_int64 from Memory with stack, 8

    If top is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "stack_count" takes stack as Integer returns Integer:
    Note: Get number of elements in stack

    If stack is equal to 0:
        Return 0
    End If

    Return proc memory_get_int64 from Memory with stack, 8
End Process

Process called "stack_capacity" takes stack as Integer returns Integer:
    Note: Get current capacity

    If stack is equal to 0:
        Return 0
    End If

    Return proc memory_get_int64 from Memory with stack, 16
End Process

Process called "stack_clear" takes stack as Integer returns Integer:
    Note: Remove all elements from stack
    Note: Returns 1 on success

    If stack is equal to 0:
        Return 0
    End If

    proc memory_set_int64 from Memory with stack, 8, 0  Note: top = 0
    Return 1
End Process

Note: ============================================================================
Note: ADVANCED STACK OPERATIONS
Note: ============================================================================

Process called "stack_contains" takes stack as Integer, value as Integer returns Integer:
    Note: Check if stack contains value
    Note: Searches from bottom to top
    Note: Returns 1 if found, 0 if not

    If stack is equal to 0:
        Return 0
    End If

    Let top be proc memory_get_int64 from Memory with stack, 8
    Let data be proc memory_get_int64 from Memory with stack, 0

    Let i be 0
    While i is less than top:
        Let offset be i multiplied by STACK_ELEMENT_SIZE
        Let elem_ptr be data plus offset
        Let elem be proc memory_get_int64 from Memory with elem_ptr, 0

        If elem is equal to value:
            Return 1
        End If

        Set i to i plus 1
    End While

    Return 0
End Process

Process called "stack_search" takes stack as Integer, value as Integer returns Integer:
    Note: Search for value and return depth from top
    Note: Returns depth (0 for top element), or -1 if not found

    If stack is equal to 0:
        Return -1
    End If

    Let top be proc memory_get_int64 from Memory with stack, 8
    Let data be proc memory_get_int64 from Memory with stack, 0

    Note: Search from top to bottom
    Let depth be 0
    Let i be top minus 1

    While i is greater than or equal to 0:
        Let offset be i multiplied by STACK_ELEMENT_SIZE
        Let elem_ptr be data plus offset
        Let elem be proc memory_get_int64 from Memory with elem_ptr, 0

        If elem is equal to value:
            Return depth
        End If

        Set depth to depth plus 1
        Set i to i minus 1
    End While

    Return -1
End Process
