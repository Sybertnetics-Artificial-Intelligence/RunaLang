Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
Windows ARM64 Win32 API Implementation

STABLE ARCHITECTURAL APPROACH:
This implementation uses the stable Win32 API instead of direct syscalls.
Win32 API functions are stable across all Windows versions (7, 8, 10, 11, Server editions).

Platform-specific details:
- OS: Windows 10/11 ARM64 (all versions)
- Architecture: ARM64 (AArch64)
- Calling convention: Microsoft ARM64 (AAPCS64-based)
- Register usage: X0-X7 (first 8 args), stack (args 9+)
- Return value: X0
- Volatile registers: X0-X18, V0-V7, V16-V31
- Non-volatile registers: X19-X28, V8-V15

Win32 API vs NT API:
- Win32 API: kernel32.dll - stable, user-friendly (ReadFile, WriteFile, etc.)
- NT API: ntdll.dll - lower level, also stable but more complex
- This implementation focuses on Win32 API for maximum compatibility

IMPORTANT: This implementation is stable across ALL Windows versions.
:End Note

Note: ============================================================================
Note: WINDOWS ERROR CODES
Note: ============================================================================

Process called "ERROR_SUCCESS" returns Integer:
    Return 0
End Process

Process called "ERROR_INVALID_FUNCTION" returns Integer:
    Return 1
End Process

Process called "ERROR_FILE_NOT_FOUND" returns Integer:
    Return 2
End Process

Process called "ERROR_PATH_NOT_FOUND" returns Integer:
    Return 3
End Process

Process called "ERROR_TOO_MANY_OPEN_FILES" returns Integer:
    Return 4
End Process

Process called "ERROR_ACCESS_DENIED" returns Integer:
    Return 5
End Process

Process called "ERROR_INVALID_HANDLE" returns Integer:
    Return 6
End Process

Process called "ERROR_NOT_ENOUGH_MEMORY" returns Integer:
    Return 8
End Process

Process called "ERROR_INVALID_PARAMETER" returns Integer:
    Return 87
End Process

Process called "ERROR_INSUFFICIENT_BUFFER" returns Integer:
    Return 122
End Process

Process called "ERROR_ALREADY_EXISTS" returns Integer:
    Return 183
End Process

Process called "ERROR_IO_PENDING" returns Integer:
    Return 997
End Process

Note: ============================================================================
Note: WINDOWS CONSTANTS
Note: ============================================================================

Process called "INVALID_HANDLE_VALUE" returns Integer:
    Return -1
End Process

Process called "GENERIC_READ" returns Integer:
    Return 2147483648
End Process

Process called "GENERIC_WRITE" returns Integer:
    Return 1073741824
End Process

Process called "GENERIC_EXECUTE" returns Integer:
    Return 536870912
End Process

Process called "GENERIC_ALL" returns Integer:
    Return 268435456
End Process

Process called "FILE_SHARE_READ" returns Integer:
    Return 1
End Process

Process called "FILE_SHARE_WRITE" returns Integer:
    Return 2
End Process

Process called "FILE_SHARE_DELETE" returns Integer:
    Return 4
End Process

Process called "CREATE_NEW" returns Integer:
    Return 1
End Process

Process called "CREATE_ALWAYS" returns Integer:
    Return 2
End Process

Process called "OPEN_EXISTING" returns Integer:
    Return 3
End Process

Process called "OPEN_ALWAYS" returns Integer:
    Return 4
End Process

Process called "TRUNCATE_EXISTING" returns Integer:
    Return 5
End Process

Process called "FILE_ATTRIBUTE_NORMAL" returns Integer:
    Return 128
End Process

Process called "FILE_ATTRIBUTE_READONLY" returns Integer:
    Return 1
End Process

Process called "FILE_ATTRIBUTE_HIDDEN" returns Integer:
    Return 2
End Process

Process called "FILE_ATTRIBUTE_SYSTEM" returns Integer:
    Return 4
End Process

Process called "FILE_ATTRIBUTE_DIRECTORY" returns Integer:
    Return 16
End Process

Process called "MEM_COMMIT" returns Integer:
    Return 4096
End Process

Process called "MEM_RESERVE" returns Integer:
    Return 8192
End Process

Process called "MEM_DECOMMIT" returns Integer:
    Return 16384
End Process

Process called "MEM_RELEASE" returns Integer:
    Return 32768
End Process

Process called "PAGE_READONLY" returns Integer:
    Return 2
End Process

Process called "PAGE_READWRITE" returns Integer:
    Return 4
End Process

Process called "PAGE_EXECUTE" returns Integer:
    Return 16
End Process

Process called "PAGE_EXECUTE_READ" returns Integer:
    Return 32
End Process

Process called "PAGE_EXECUTE_READWRITE" returns Integer:
    Return 64
End Process

Process called "PAGE_NOACCESS" returns Integer:
    Return 1
End Process

Process called "STD_INPUT_HANDLE" returns Integer:
    Return -10
End Process

Process called "STD_OUTPUT_HANDLE" returns Integer:
    Return -11
End Process

Process called "STD_ERROR_HANDLE" returns Integer:
    Return -12
End Process

Note: ============================================================================
Note: WINDOWS API FUNCTION CALLS
Note: ============================================================================

Process called "api_create_file" takes filename as Integer, desired_access as Integer, share_mode as Integer, security_attributes as Integer, creation_disposition as Integer, flags_and_attributes as Integer, template_file as Integer returns Integer:
    Note: CreateFileW - Create or open file (Unicode version)
    Note: filename: pointer to wide string filename
    Note: desired_access: GENERIC_READ, GENERIC_WRITE, etc.
    Note: share_mode: FILE_SHARE_READ, FILE_SHARE_WRITE, etc.
    Note: security_attributes: pointer to SECURITY_ATTRIBUTES or 0
    Note: creation_disposition: CREATE_NEW, OPEN_EXISTING, etc.
    Note: flags_and_attributes: FILE_ATTRIBUTE_NORMAL, etc.
    Note: template_file: handle to template file or 0
    Note: Returns: file handle or INVALID_HANDLE_VALUE on error
    
    Note: Microsoft ARM64 calling convention: X0-X7, then stack
    Let result be 0
    Inline Assembly:
        # Load parameters into registers (Microsoft ARM64 calling convention)
        ldr x0, [sp, #-8]      # filename (1st parameter)
        ldr x1, [sp, #-16]     # desired_access (2nd parameter)
        ldr x2, [sp, #-24]     # share_mode (3rd parameter)
        ldr x3, [sp, #-32]     # security_attributes (4th parameter)
        ldr x4, [sp, #-40]     # creation_disposition (5th parameter)
        ldr x5, [sp, #-48]     # flags_and_attributes (6th parameter)
        ldr x6, [sp, #-56]     # template_file (7th parameter)
        
        # Call CreateFileW from kernel32.dll
        bl CreateFileW
        
        # Store result
        str x0, [sp, #-64]
    End Assembly
    Return result
End Process

Process called "api_read_file" takes file_handle as Integer, buffer as Integer, bytes_to_read as Integer, bytes_read as Integer, overlapped as Integer returns Integer:
    Note: ReadFile - Read from file handle
    Note: file_handle: handle to file
    Note: buffer: pointer to buffer to read into
    Note: bytes_to_read: number of bytes to read
    Note: bytes_read: pointer to DWORD to receive bytes read
    Note: overlapped: pointer to OVERLAPPED structure or 0
    Note: Returns: TRUE on success, FALSE on failure
    
    Let result be 0
    Inline Assembly:
        # Load parameters into registers (Microsoft ARM64 calling convention)
        ldr x0, [sp, #-8]      # file_handle (1st parameter)
        ldr x1, [sp, #-16]     # buffer (2nd parameter)
        ldr x2, [sp, #-24]     # bytes_to_read (3rd parameter)
        ldr x3, [sp, #-32]     # bytes_read (4th parameter)
        ldr x4, [sp, #-40]     # overlapped (5th parameter)
        
        # Call ReadFile from kernel32.dll
        bl ReadFile
        
        # Store result
        str x0, [sp, #-48]
    End Assembly
    Return result
End Process

Process called "api_write_file" takes file_handle as Integer, buffer as Integer, bytes_to_write as Integer, bytes_written as Integer, overlapped as Integer returns Integer:
    Note: WriteFile - Write to file handle
    Note: file_handle: handle to file
    Note: buffer: pointer to buffer to write from
    Note: bytes_to_write: number of bytes to write
    Note: bytes_written: pointer to DWORD to receive bytes written
    Note: overlapped: pointer to OVERLAPPED structure or 0
    Note: Returns: TRUE on success, FALSE on failure
    
    Let result be 0
    Inline Assembly:
        # Load parameters into registers (Microsoft ARM64 calling convention)
        ldr x0, [sp, #-8]      # file_handle (1st parameter)
        ldr x1, [sp, #-16]     # buffer (2nd parameter)
        ldr x2, [sp, #-24]     # bytes_to_write (3rd parameter)
        ldr x3, [sp, #-32]     # bytes_written (4th parameter)
        ldr x4, [sp, #-40]     # overlapped (5th parameter)
        
        # Call WriteFile from kernel32.dll
        bl WriteFile
        
        # Store result
        str x0, [sp, #-48]
    End Assembly
    Return result
End Process

Process called "api_close_handle" takes handle as Integer returns Integer:
    Note: CloseHandle - Close handle
    Note: handle: handle to close
    Note: Returns: TRUE on success, FALSE on failure
    
    Let result be 0
    Inline Assembly:
        # Load parameter into register (Microsoft ARM64 calling convention)
        ldr x0, [sp, #-8]      # handle (1st parameter)
        
        # Call CloseHandle from kernel32.dll
        bl CloseHandle
        
        # Store result
        str x0, [sp, #-16]
    End Assembly
    Return result
End Process

Process called "api_virtual_alloc" takes address as Integer, size as Integer, allocation_type as Integer, protect as Integer returns Integer:
    Note: VirtualAlloc - Allocate virtual memory
    Note: address: preferred address or 0
    Note: size: size in bytes to allocate
    Note: allocation_type: MEM_COMMIT, MEM_RESERVE, etc.
    Note: protect: PAGE_READWRITE, PAGE_EXECUTE_READWRITE, etc.
    Note: Returns: pointer to allocated memory or 0 on error
    
    Let result be 0
    Inline Assembly:
        # Load parameters into registers (Microsoft ARM64 calling convention)
        ldr x0, [sp, #-8]      # address (1st parameter)
        ldr x1, [sp, #-16]     # size (2nd parameter)
        ldr x2, [sp, #-24]     # allocation_type (3rd parameter)
        ldr x3, [sp, #-32]     # protect (4th parameter)
        
        # Call VirtualAlloc from kernel32.dll
        bl VirtualAlloc
        
        # Store result
        str x0, [sp, #-40]
    End Assembly
    Return result
End Process

Process called "api_virtual_free" takes address as Integer, size as Integer, free_type as Integer returns Integer:
    Note: VirtualFree - Free virtual memory
    Note: address: pointer to memory to free
    Note: size: size in bytes (must be 0 for MEM_RELEASE)
    Note: free_type: MEM_DECOMMIT, MEM_RELEASE
    Note: Returns: TRUE on success, FALSE on failure
    
    Let result be 0
    Inline Assembly:
        # Load parameters into registers (Microsoft ARM64 calling convention)
        ldr x0, [sp, #-8]      # address (1st parameter)
        ldr x1, [sp, #-16]     # size (2nd parameter)
        ldr x2, [sp, #-24]     # free_type (3rd parameter)
        
        # Call VirtualFree from kernel32.dll
        bl VirtualFree
        
        # Store result
        str x0, [sp, #-32]
    End Assembly
    Return result
End Process

Process called "api_virtual_protect" takes address as Integer, size as Integer, new_protect as Integer, old_protect as Integer returns Integer:
    Note: VirtualProtect - Change memory protection
    Note: address: pointer to memory
    Note: size: size in bytes
    Note: new_protect: new protection flags
    Note: old_protect: pointer to DWORD to receive old protection
    Note: Returns: TRUE on success, FALSE on failure
    
    Let result be 0
    Inline Assembly:
        # Load parameters into registers (Microsoft ARM64 calling convention)
        ldr x0, [sp, #-8]      # address (1st parameter)
        ldr x1, [sp, #-16]     # size (2nd parameter)
        ldr x2, [sp, #-24]     # new_protect (3rd parameter)
        ldr x3, [sp, #-32]     # old_protect (4th parameter)
        
        # Call VirtualProtect from kernel32.dll
        bl VirtualProtect
        
        # Store result
        str x0, [sp, #-40]
    End Assembly
    Return result
End Process

Process called "api_terminate_process" takes process_handle as Integer, exit_code as Integer returns Integer:
    Note: TerminateProcess - Terminate process
    Note: process_handle: handle to process
    Note: exit_code: exit code for process
    Note: Returns: TRUE on success, FALSE on failure
    
    Let result be 0
    Inline Assembly:
        # Load parameters into registers (Microsoft ARM64 calling convention)
        ldr x0, [sp, #-8]      # process_handle (1st parameter)
        ldr x1, [sp, #-16]     # exit_code (2nd parameter)
        
        # Call TerminateProcess from kernel32.dll
        bl TerminateProcess
        
        # Store result
        str x0, [sp, #-24]
    End Assembly
    Return result
End Process

Process called "api_get_current_process" returns Integer:
    Note: GetCurrentProcess - Get current process handle
    Note: Returns: pseudo-handle to current process
    
    Let result be 0
    Inline Assembly:
        # Call GetCurrentProcess from kernel32.dll
        bl GetCurrentProcess
        
        # Store result
        str x0, [sp, #-8]
    End Assembly
    Return result
End Process

Process called "api_get_current_process_id" returns Integer:
    Note: GetCurrentProcessId - Get current process ID
    Note: Returns: process ID
    
    Let result be 0
    Inline Assembly:
        # Call GetCurrentProcessId from kernel32.dll
        bl GetCurrentProcessId
        
        # Store result
        str x0, [sp, #-8]
    End Assembly
    Return result
End Process

Process called "api_get_current_thread_id" returns Integer:
    Note: GetCurrentThreadId - Get current thread ID
    Note: Returns: thread ID
    
    Let result be 0
    Inline Assembly:
        # Call GetCurrentThreadId from kernel32.dll
        bl GetCurrentThreadId
        
        # Store result
        str x0, [sp, #-8]
    End Assembly
    Return result
End Process

Process called "api_sleep" takes milliseconds as Integer returns Integer:
    Note: Sleep - Sleep for specified milliseconds
    Note: milliseconds: number of milliseconds to sleep
    Note: Returns: 0 (always succeeds)
    
    Let result be 0
    Inline Assembly:
        # Load parameter into register (Microsoft ARM64 calling convention)
        ldr x0, [sp, #-8]      # milliseconds (1st parameter)
        
        # Call Sleep from kernel32.dll
        bl Sleep
        
        # Store result (Sleep returns void, so we set to 0)
        mov x0, #0
        str x0, [sp, #-16]
    End Assembly
    Return result
End Process

Process called "api_get_last_error" returns Integer:
    Note: GetLastError - Get last error code
    Note: Returns: last error code
    
    Let result be 0
    Inline Assembly:
        # Call GetLastError from kernel32.dll
        bl GetLastError
        
        # Store result
        str x0, [sp, #-8]
    End Assembly
    Return result
End Process

Process called "api_set_last_error" takes error_code as Integer returns Integer:
    Note: SetLastError - Set last error code
    Note: error_code: error code to set
    Note: Returns: 0 (always succeeds)
    
    Let result be 0
    Inline Assembly:
        # Load parameter into register (Microsoft ARM64 calling convention)
        ldr x0, [sp, #-8]      # error_code (1st parameter)
        
        # Call SetLastError from kernel32.dll
        bl SetLastError
        
        # Store result (SetLastError returns void, so we set to 0)
        mov x0, #0
        str x0, [sp, #-16]
    End Assembly
    Return result
End Process

Process called "api_get_std_handle" takes handle_type as Integer returns Integer:
    Note: GetStdHandle - Get standard handle
    Note: handle_type: STD_INPUT_HANDLE, STD_OUTPUT_HANDLE, STD_ERROR_HANDLE
    Note: Returns: handle or INVALID_HANDLE_VALUE on error
    
    Let result be 0
    Inline Assembly:
        # Load parameter into register (Microsoft ARM64 calling convention)
        ldr x0, [sp, #-8]      # handle_type (1st parameter)
        
        # Call GetStdHandle from kernel32.dll
        bl GetStdHandle
        
        # Store result
        str x0, [sp, #-16]
    End Assembly
    Return result
End Process

Process called "api_create_directory" takes path as Integer, security_attributes as Integer returns Integer:
    Note: CreateDirectoryW - Create directory (Unicode version)
    Note: path: pointer to wide string path
    Note: security_attributes: pointer to SECURITY_ATTRIBUTES or 0
    Note: Returns: TRUE on success, FALSE on failure
    
    Let result be 0
    Inline Assembly:
        # Load parameters into registers (Microsoft ARM64 calling convention)
        ldr x0, [sp, #-8]      # path (1st parameter)
        ldr x1, [sp, #-16]     # security_attributes (2nd parameter)
        
        # Call CreateDirectoryW from kernel32.dll
        bl CreateDirectoryW
        
        # Store result
        str x0, [sp, #-24]
    End Assembly
    Return result
End Process

Process called "api_remove_directory" takes path as Integer returns Integer:
    Note: RemoveDirectoryW - Remove directory (Unicode version)
    Note: path: pointer to wide string path
    Note: Returns: TRUE on success, FALSE on failure
    
    Let result be 0
    Inline Assembly:
        # Load parameter into register (Microsoft ARM64 calling convention)
        ldr x0, [sp, #-8]      # path (1st parameter)
        
        # Call RemoveDirectoryW from kernel32.dll
        bl RemoveDirectoryW
        
        # Store result
        str x0, [sp, #-16]
    End Assembly
    Return result
End Process

Process called "api_delete_file" takes filename as Integer returns Integer:
    Note: DeleteFileW - Delete file (Unicode version)
    Note: filename: pointer to wide string filename
    Note: Returns: TRUE on success, FALSE on failure
    
    Let result be 0
    Inline Assembly:
        # Load parameter into register (Microsoft ARM64 calling convention)
        ldr x0, [sp, #-8]      # filename (1st parameter)
        
        # Call DeleteFileW from kernel32.dll
        bl DeleteFileW
        
        # Store result
        str x0, [sp, #-16]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: HIGH-LEVEL WRAPPER FUNCTIONS
Note: ============================================================================

Process called "syscall_read" takes fd as Integer, buffer as Integer, count as Integer returns Integer:
    Note: High-level wrapper for ReadFile
    Note: fd: file handle (Windows uses handles, not file descriptors)
    Note: buffer: pointer to buffer
    Note: count: number of bytes to read
    Note: Returns: number of bytes read, or -1 on error
    
    Let bytes_read_ptr be Memory.memory_alloc(8)
    Let result be api_read_file(fd, buffer, count, bytes_read_ptr, 0)
    
    If result is equal to 0:
        Memory.memory_free(bytes_read_ptr)
        Return -1
    End If
    
    Let bytes_read be Memory.memory_get_int32(bytes_read_ptr, 0)
    Memory.memory_free(bytes_read_ptr)
    Return bytes_read
End Process

Process called "syscall_write" takes fd as Integer, buffer as Integer, count as Integer returns Integer:
    Note: High-level wrapper for WriteFile
    Note: fd: file handle (Windows uses handles, not file descriptors)
    Note: buffer: pointer to buffer
    Note: count: number of bytes to write
    Note: Returns: number of bytes written, or -1 on error
    
    Let bytes_written_ptr be Memory.memory_alloc(8)
    Let result be api_write_file(fd, buffer, count, bytes_written_ptr, 0)
    
    If result is equal to 0:
        Memory.memory_free(bytes_written_ptr)
        Return -1
    End If
    
    Let bytes_written be Memory.memory_get_int32(bytes_written_ptr, 0)
    Memory.memory_free(bytes_written_ptr)
    Return bytes_written
End Process

Process called "syscall_open" takes filename as Integer, flags as Integer, mode as Integer returns Integer:
    Note: High-level wrapper for CreateFileW
    Note: filename: pointer to wide string filename
    Note: flags: access flags (O_RDONLY, O_WRONLY, O_RDWR)
    Note: mode: creation mode (ignored on Windows)
    Note: Returns: file handle or -1 on error
    
    Let desired_access be 0
    Let share_mode be FILE_SHARE_READ plus FILE_SHARE_WRITE
    Let creation_disposition be OPEN_EXISTING
    Let flags_and_attributes be FILE_ATTRIBUTE_NORMAL
    
    If flags is equal to 0:
        Set desired_access to GENERIC_READ
    Otherwise If flags is equal to 1:
        Set desired_access to GENERIC_WRITE
    Otherwise If flags is equal to 2:
        Set desired_access to GENERIC_READ plus GENERIC_WRITE
    End If
    
    Let handle be api_create_file(filename, desired_access, share_mode, 0, creation_disposition, flags_and_attributes, 0)
    
    If handle is equal to INVALID_HANDLE_VALUE:
        Return -1
    End If
    
    Return handle
End Process

Process called "syscall_close" takes fd as Integer returns Integer:
    Note: High-level wrapper for CloseHandle
    Note: fd: file handle
    Note: Returns: 0 on success, -1 on error
    
    Let result be api_close_handle(fd)
    
    If result is equal to 0:
        Return -1
    End If
    
    Return 0
End Process

Process called "syscall_exit" takes exit_code as Integer returns Integer:
    Note: High-level wrapper for TerminateProcess
    Note: exit_code: exit code
    Note: Returns: never returns (process terminates)
    
    Let current_process be api_get_current_process()
    Let result be api_terminate_process(current_process, exit_code)
    
    Return -1  Note: Should never reach here
End Process

Process called "syscall_mmap" takes addr as Integer, length as Integer, prot as Integer, flags as Integer, fd as Integer, offset as Integer returns Integer:
    Note: High-level wrapper for VirtualAlloc
    Note: addr: preferred address or 0
    Note: length: size in bytes
    Note: prot: protection flags
    Note: flags: allocation flags (ignored)
    Note: fd: file descriptor (ignored)
    Note: offset: file offset (ignored)
    Note: Returns: pointer to allocated memory or -1 on error
    
    Let allocation_type be MEM_COMMIT
    Let protect be PAGE_READWRITE
    
    If prot is equal to 1:
        Set protect to PAGE_READONLY
    Otherwise If prot is equal to 2:
        Set protect to PAGE_READWRITE
    Otherwise If prot is equal to 4:
        Set protect to PAGE_EXECUTE_READWRITE
    End If
    
    Let result be api_virtual_alloc(addr, length, allocation_type, protect)
    
    If result is equal to 0:
        Return -1
    End If
    
    Return result
End Process

Process called "syscall_munmap" takes addr as Integer, length as Integer returns Integer:
    Note: High-level wrapper for VirtualFree
    Note: addr: pointer to memory
    Note: length: size in bytes (ignored, must be 0 for MEM_RELEASE)
    Note: Returns: 0 on success, -1 on error
    
    Let result be api_virtual_free(addr, 0, MEM_RELEASE)
    
    If result is equal to 0:
        Return -1
    End If
    
    Return 0
End Process

Process called "syscall_mprotect" takes addr as Integer, length as Integer, prot as Integer returns Integer:
    Note: High-level wrapper for VirtualProtect
    Note: addr: pointer to memory
    Note: length: size in bytes
    Note: prot: new protection flags
    Note: Returns: 0 on success, -1 on error
    
    Let old_protect_ptr be Memory.memory_alloc(8)
    Let new_protect be PAGE_READWRITE
    
    If prot is equal to 1:
        Set new_protect to PAGE_READONLY
    Otherwise If prot is equal to 2:
        Set new_protect to PAGE_READWRITE
    Otherwise If prot is equal to 4:
        Set new_protect to PAGE_EXECUTE_READWRITE
    End If
    
    Let result be api_virtual_protect(addr, length, new_protect, old_protect_ptr)
    Memory.memory_free(old_protect_ptr)
    
    If result is equal to 0:
    Return -1
    End If

    Return 0
End Process

Process called "syscall_getpid" returns Integer:
    Note: High-level wrapper for GetCurrentProcessId
    Note: Returns: process ID
    
    Return api_get_current_process_id()
End Process

Process called "syscall_kill" takes pid as Integer, sig as Integer returns Integer:
    Note: High-level wrapper for TerminateProcess
    Note: pid: process ID
    Note: sig: signal number (ignored, always terminates)
    Note: Returns: 0 on success, -1 on error
    
    Note: On Windows, we can only terminate the current process
    Note: For other processes, we would need OpenProcess first
    If pid is not equal to api_get_current_process_id():
        Return -1
    End If
    
    Let current_process be api_get_current_process()
    Let result be api_terminate_process(current_process, sig)
    
    Return -1  Note: Should never reach here
End Process

Note: ============================================================================
Note: ERROR HANDLING HELPERS
Note: ============================================================================

Process called "is_error" takes result as Integer returns Integer:
    Note: Check if result indicates an error
    Note: result: result from Windows API call
    Note: Returns: 1 if error, 0 if success
    
    If result is equal to 0 or result is equal to INVALID_HANDLE_VALUE:
        Return 1
    End If
    
    Return 0
End Process

Process called "get_error_message" takes error_code as Integer returns String:
    Note: Get error message for error code
    Note: error_code: Windows error code
    Note: Returns: error message string
    
    If error_code is equal to ERROR_SUCCESS:
        Return "Success"
    Otherwise If error_code is equal to ERROR_FILE_NOT_FOUND:
        Return "File not found"
    Otherwise If error_code is equal to ERROR_ACCESS_DENIED:
        Return "Access denied"
    Otherwise If error_code is equal to ERROR_INVALID_HANDLE:
        Return "Invalid handle"
    Otherwise If error_code is equal to ERROR_NOT_ENOUGH_MEMORY:
        Return "Not enough memory"
    Otherwise If error_code is equal to ERROR_INVALID_PARAMETER:
        Return "Invalid parameter"
    End If
    
    Return "Unknown error"
End Process