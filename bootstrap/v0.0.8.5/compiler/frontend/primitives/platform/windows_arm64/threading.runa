Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions
Licensed under the Apache License, Version 2.0
:End Note

Note:
WINDOWS_ARM64 THREADING - Win32 API implementation
Uses NT syscalls from ntdll.dll for all threading operations
:End Note

Import "compiler/frontend/primitives/assembly/syscall.runa" as Syscall
Import "compiler/frontend/primitives/memory/layout.runa" as Memory
Import "compiler/frontend/primitives/core/atomic_core.runa" as Atomic

Note: Windows NT syscalls (syscall numbers vary by Windows version, using Windows 10 x64)
Note: NtCreateThreadEx = 0xC5, NtWaitForSingleObject = 0x04, NtClose = 0x0F
Note: NtDelayExecution = 0x34

Process called "thread_create" takes function_ptr as Integer, arg_ptr as Integer returns Integer:
    Note: NtCreateThreadEx - create new thread
    Note: Syscall 0xC5 (Windows 10 ARM64): NtCreateThreadEx
    Note:
    Note: Signature:
    Note: NTSTATUS NtCreateThreadEx(
    Note:   OUT PHANDLE ThreadHandle,
    Note:   IN ACCESS_MASK DesiredAccess,
    Note:   IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    Note:   IN HANDLE ProcessHandle,
    Note:   IN PVOID StartRoutine,
    Note:   IN PVOID Argument OPTIONAL,
    Note:   IN ULONG CreateFlags,
    Note:   IN SIZE_T ZeroBits,
    Note:   IN SIZE_T StackSize,
    Note:   IN SIZE_T MaximumStackSize,
    Note:   IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL
    Note: )

    Note: Allocate handle storage (8 bytes for HANDLE)
    Let handle_ptr be proc syscall_mmap from Syscall with 0, 8, 3, 34, -1, 0
    If handle_ptr is less than 0:
        Return 0
    End If

    Note: Initialize handle to 0
    proc memory_set_int64 from Memory with handle_ptr, 0, 0

    Note: NtCreateThreadEx parameters
    Let desired_access be 2097151  Note: THREAD_ALL_ACCESS (0x1FFFFF)
    Let object_attributes be 0  Note: NULL - no special attributes
    Let process_handle be -1  Note: -1 = NtCurrentProcess()
    Let create_flags be 0  Note: 0 = run immediately (not CREATE_SUSPENDED)
    Let zero_bits be 0  Note: No specific address requirements
    Let stack_size be 0  Note: 0 = default stack size (1MB typically)
    Let max_stack_size be 0  Note: 0 = default maximum stack size
    Let attribute_list be 0  Note: NULL - no additional attributes

    Note: Call NtCreateThreadEx (syscall 0xC5 = 197 decimal)
    Note: Windows ARM64 uses ARM64 calling convention
    Note: Parameters: x0-x7 for first 8 args, stack for remaining
    Note: We use syscall_11 for 11 parameters
    Let result be proc syscall_11 from Syscall with 197, handle_ptr, desired_access, object_attributes, process_handle, function_ptr, arg_ptr, create_flags, zero_bits, stack_size, max_stack_size, attribute_list

    Note: Check if syscall succeeded (STATUS_SUCCESS = 0)
    If result is not equal to 0:
        Note: Thread creation failed, free handle storage
        proc syscall_munmap from Syscall with handle_ptr, 8
        Return 0
    End If

    Note: Read the created thread handle
    Let thread_handle be proc memory_get_int64 from Memory with handle_ptr, 0

    Note: Free temporary handle storage and return the handle value
    proc syscall_munmap from Syscall with handle_ptr, 8
    Return thread_handle
End Process

Process called "thread_join" takes handle as Integer returns Integer:
    Note: NtWaitForSingleObject(handle, FALSE, NULL) - INFINITE wait
    Note: Syscall 0x04: NtWaitForSingleObject
    Let alertable be 0
    Let timeout_ptr be 0
    proc syscall_3 from Syscall with 4, handle, alertable, timeout_ptr
    Return 1
End Process

Process called "thread_detach" takes handle as Integer returns Integer:
    Note: NtClose(handle)
    proc syscall_1 from Syscall with 15, handle
    Return 1
End Process

Process called "thread_exit" takes exit_code as Integer returns Integer:
    Note: NtTerminateThread(NULL, exit_code) - NULL = current thread
    proc syscall_2 from Syscall with 83, 0, exit_code
    Return 0
End Process

Process called "thread_current_id" returns Integer:
    Note: Get current thread ID from TEB (Thread Environment Block)
    Note: TEB is accessed via x18 register on ARM64 Windows
    Note: ClientId.UniqueThread is at offset 0x48 in TEB
    Note:
    Note: In ARM64 assembly: ldr x0, [x18, #0x48]
    Note: We use compiler intrinsic to read TEB

    Note: Read TEB ClientId.UniqueThread (offset 0x48)
    Let tid be proc __builtin_read_teb_qword with 72  Note: 0x48 = 72 decimal
    Return tid
End Process

Process called "thread_yield" returns Integer:
    Note: NtYieldExecution (syscall 0x46)
    proc syscall_0 from Syscall with 70
    Return 1
End Process

Process called "thread_sleep" takes microseconds as Integer returns Integer:
    Note: NtDelayExecution - sleep for specified time
    Note: Syscall 0x34: NtDelayExecution(Alertable, DelayInterval)

    Let milliseconds be microseconds divided by 1000
    Let nanoseconds_100 be milliseconds times 10000  Note: Windows uses 100-nanosecond intervals
    Let negative_delay be 0 minus nanoseconds_100  Note: Negative = relative time

    Note: Allocate LARGE_INTEGER (8 bytes)
    Let delay_ptr be proc syscall_mmap from Syscall with 0, 8, 3, 34, -1, 0
    If delay_ptr is less than 0:
        Return -1
    End If

    proc memory_set_int64 from Memory with delay_ptr, 0, negative_delay

    Note: NtDelayExecution(Alertable=FALSE, DelayInterval)
    Let alertable be 0
    proc syscall_2 from Syscall with 52, alertable, delay_ptr

    proc syscall_munmap from Syscall with delay_ptr, 8
    Return 1
End Process

Process called "thread_set_name" takes name as Integer returns Integer:
    Note: SetThreadDescription() - not critical, return success
    Return 1
End Process

Process called "thread_get_name" returns Integer:
    Return 0
End Process

Note: Mutex operations (using CRITICAL_SECTION structure)

Process called "mutex_create" returns Integer:
    Note: CRITICAL_SECTION is 40 bytes on x64
    Let cs_ptr be proc syscall_mmap from Syscall with 0, 40, 3, 34, -1, 0
    If cs_ptr is less than 0:
        Return 0
    End If

    Note: Initialize CRITICAL_SECTION fields
    Note: DebugInfo = NULL, LockCount = -1, RecursionCount = 0, OwningThread = 0
    proc memory_set_int64 from Memory with cs_ptr, 0, 0   Note: DebugInfo
    proc memory_set_int32 from Memory with cs_ptr, 8, -1  Note: LockCount
    proc memory_set_int32 from Memory with cs_ptr, 12, 0  Note: RecursionCount
    proc memory_set_int64 from Memory with cs_ptr, 16, 0  Note: OwningThread
    proc memory_set_int64 from Memory with cs_ptr, 24, 0  Note: LockSemaphore
    proc memory_set_int64 from Memory with cs_ptr, 32, 0  Note: SpinCount

    Return cs_ptr
End Process

Process called "mutex_destroy" takes handle as Integer returns Integer:
    proc syscall_munmap from Syscall with handle, 40
    Return 1
End Process

Process called "mutex_lock" takes handle as Integer returns Integer:
    Note: EnterCriticalSection - acquire lock
    Note: Use atomic operations on LockCount field (offset 8)
    Let lock_count_ptr be handle plus 8

    While 1 is equal to 1:
        Let old_count be proc atomic_fetch_add from Atomic with lock_count_ptr, 1
        If old_count is equal to -1:
            Note: Lock acquired
            Let tid be thread_current_id()
            proc memory_set_int64 from Memory with handle, 16, tid  Note: Set OwningThread
            Return 1
        End If

        Note: Lock is held, wait briefly
        thread_yield()
    End While

    Return 1
End Process

Process called "mutex_unlock" takes handle as Integer returns Integer:
    Note: LeaveCriticalSection - release lock
    proc memory_set_int64 from Memory with handle, 16, 0  Note: Clear OwningThread

    Let lock_count_ptr be handle plus 8
    proc atomic_fetch_add from Atomic with lock_count_ptr, -1
    proc memory_barrier_release from Atomic

    Return 1
End Process

Process called "mutex_try_lock" takes handle as Integer returns Integer:
    Note: TryEnterCriticalSection - try to acquire without blocking
    Let lock_count_ptr be handle plus 8
    Let expected be -1
    Let success be proc atomic_compare_and_swap from Atomic with lock_count_ptr, expected, 0

    If success is equal to 1:
        Let tid be thread_current_id()
        proc memory_set_int64 from Memory with handle, 16, tid
    End If

    Return success
End Process

Note: Semaphore operations

Process called "semaphore_create" takes initial_count as Integer returns Integer:
    Note: Allocate 8 bytes: 4 for count, 4 for max_count
    Let sem_ptr be proc syscall_mmap from Syscall with 0, 8, 3, 34, -1, 0
    If sem_ptr is less than 0:
        Return 0
    End If

    proc memory_set_int32 from Memory with sem_ptr, 0, initial_count
    proc memory_set_int32 from Memory with sem_ptr, 4, 2147483647  Note: MAX_LONG

    Return sem_ptr
End Process

Process called "semaphore_destroy" takes handle as Integer returns Integer:
    proc syscall_munmap from Syscall with handle, 8
    Return 1
End Process

Process called "semaphore_wait" takes handle as Integer returns Integer:
    Note: Decrement semaphore, wait if zero
    While 1 is equal to 1:
        Let current be proc memory_get_int32 from Memory with handle, 0
        If current is greater than 0:
            Let old_val be proc atomic_fetch_add from Atomic with handle, -1
            If old_val is greater than 0:
                Return 1
            End If
            proc atomic_fetch_add from Atomic with handle, 1  Note: Restore on race
        End If
        thread_yield()
    End While

    Return 1
End Process

Process called "semaphore_signal" takes handle as Integer returns Integer:
    Note: Increment semaphore
    proc atomic_fetch_add from Atomic with handle, 1
    Return 1
End Process

Process called "semaphore_try_wait" takes handle as Integer returns Integer:
    Let current be proc memory_get_int32 from Memory with handle, 0
    If current is greater than 0:
        Let old_val be proc atomic_fetch_add from Atomic with handle, -1
        If old_val is greater than 0:
            Return 1
        End If
        proc atomic_fetch_add from Atomic with handle, 1
    End If
    Return 0
End Process

Note: Event operations (for condition variable implementation)

Process called "event_create" takes manual_reset as Integer, initial_state as Integer returns Integer:
    Note: Create Windows event object using NtCreateEvent
    Note: Syscall 0x48: NtCreateEvent
    Note: NTSTATUS NtCreateEvent(OUT PHANDLE EventHandle, IN ACCESS_MASK DesiredAccess,
    Note:                         IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    Note:                         IN EVENT_TYPE EventType, IN BOOLEAN InitialState)

    Note: Allocate handle storage
    Let handle_ptr be proc syscall_mmap from Syscall with 0, 8, 3, 34, -1, 0
    If handle_ptr is less than 0:
        Return 0
    End If

    Let desired_access be 2031619  Note: EVENT_ALL_ACCESS (0x1F0003)
    Let object_attributes be 0  Note: NULL
    Let event_type be manual_reset  Note: 0=NotificationEvent (manual), 1=SynchronizationEvent (auto)

    Note: Call NtCreateEvent
    Let result be proc syscall with 72, handle_ptr, desired_access, object_attributes, event_type, initial_state

    If result is not equal to 0:
        proc syscall_munmap from Syscall with handle_ptr, 8
        Return 0
    End If

    Let event_handle be proc memory_get_int64 from Memory with handle_ptr, 0
    proc syscall_munmap from Syscall with handle_ptr, 8

    Return event_handle
End Process

Process called "event_wait_multiple" takes event1 as Integer, event2 as Integer, timeout_ns as Integer returns Integer:
    Note: Wait for multiple events using NtWaitForMultipleObjects
    Note: Syscall 0x5A: NtWaitForMultipleObjects
    Note: Returns 0 if event1 signaled, 1 if event2 signaled, 258 if timeout

    Note: Create handle array
    Let handles_ptr be proc syscall_mmap from Syscall with 0, 16, 3, 34, -1, 0
    If handles_ptr is less than 0:
        Return 258  Note: Timeout
    End If

    proc memory_set_int64 from Memory with handles_ptr, 0, event1
    proc memory_set_int64 from Memory with handles_ptr, 8, event2

    Note: Create timeout structure (LARGE_INTEGER, 8 bytes)
    Let timeout_ptr be proc syscall_mmap from Syscall with 0, 8, 3, 34, -1, 0
    If timeout_ptr is less than 0:
        proc syscall_munmap from Syscall with handles_ptr, 16
        Return 258
    End If
    proc memory_set_int64 from Memory with timeout_ptr, 0, timeout_ns

    Note: Call NtWaitForMultipleObjects(Count=2, Handles, WaitType=WaitAny, Alertable=FALSE, Timeout)
    Let wait_type be 1  Note: WaitAny
    Let alertable be 0
    Let result be proc syscall with 90, 2, handles_ptr, wait_type, alertable, timeout_ptr

    proc syscall_munmap from Syscall with handles_ptr, 16
    proc syscall_munmap from Syscall with timeout_ptr, 8

    Return result
End Process

Process called "event_set" takes event_handle as Integer returns Integer:
    Note: Set event to signaled state using NtSetEvent
    Note: Syscall 0x0E: NtSetEvent
    Let previous_state_ptr be 0  Note: NULL - don't need previous state
    Let result be proc syscall with 14, event_handle, previous_state_ptr
    Return result
End Process

Process called "event_reset" takes event_handle as Integer returns Integer:
    Note: Reset event to non-signaled state using NtResetEvent
    Note: Syscall 0x0D: NtResetEvent
    Let previous_state_ptr be 0  Note: NULL
    Let result be proc syscall with 13, event_handle, previous_state_ptr
    Return result
End Process

Process called "event_close" takes event_handle as Integer returns Integer:
    Note: Close event handle using NtClose
    Note: Syscall 0x0F: NtClose
    Let result be proc syscall with 15, event_handle
    Return result
End Process

Note: Condition variable operations

Process called "condvar_create" returns Integer:
    Note: Condition variable structure (24 bytes):
    Note:   offset 0:  waiters_count (number of waiting threads, 8 bytes)
    Note:   offset 8:  signal_event (event handle for signaling, 8 bytes)
    Note:   offset 16: broadcast_event (event handle for broadcast, 8 bytes)

    Let cv_ptr be proc syscall_mmap from Syscall with 0, 24, 3, 34, -1, 0
    If cv_ptr is less than 0:
        Return 0
    End If

    Note: Initialize waiters count to 0
    proc memory_set_int64 from Memory with cv_ptr, 0, 0

    Note: Create manual-reset event for broadcast (initially non-signaled)
    Let broadcast_event be proc event_create with 1, 0
    If broadcast_event is equal to 0:
        proc syscall_munmap from Syscall with cv_ptr, 24
        Return 0
    End If

    Note: Create auto-reset event for signal (initially non-signaled)
    Let signal_event be proc event_create with 0, 0
    If signal_event is equal to 0:
        proc event_close with broadcast_event
        proc syscall_munmap from Syscall with cv_ptr, 24
        Return 0
    End If

    proc memory_set_int64 from Memory with cv_ptr, 8, signal_event
    proc memory_set_int64 from Memory with cv_ptr, 16, broadcast_event

    Return cv_ptr
End Process

Process called "condvar_destroy" takes handle as Integer returns Integer:
    If handle is equal to 0:
        Return 0
    End If

    Note: Close event handles
    Let signal_event be proc memory_get_int64 from Memory with handle, 8
    Let broadcast_event be proc memory_get_int64 from Memory with handle, 16

    If signal_event is not equal to 0:
        proc event_close with signal_event
    End If

    If broadcast_event is not equal to 0:
        proc event_close with broadcast_event
    End If

    Note: Free condition variable structure
    proc syscall_munmap from Syscall with handle, 24
    Return 1
End Process

Process called "condvar_wait" takes cv_handle as Integer, mutex_handle as Integer returns Integer:
    If cv_handle is equal to 0:
        Return 0
    End If

    Note: Increment waiters count atomically
    Let waiters_ptr be cv_handle
    proc atomic_fetch_add from Atomic with waiters_ptr, 1

    Note: Get event handles
    Let signal_event be proc memory_get_int64 from Memory with cv_handle, 8
    Let broadcast_event be proc memory_get_int64 from Memory with cv_handle, 16

    Note: Release mutex before waiting
    mutex_unlock(mutex_handle)

    Note: Wait for either signal or broadcast event (infinite timeout)
    Let timeout_ns be -10000000000  Note: Negative = infinite wait in NT API (100ns units)
    Let wait_result be proc event_wait_multiple with signal_event, broadcast_event, timeout_ns

    Note: Decrement waiters count atomically
    proc atomic_fetch_sub from Atomic with waiters_ptr, 1

    Note: Reacquire mutex
    mutex_lock(mutex_handle)

    Return 1
End Process

Process called "condvar_timed_wait" takes cv_handle as Integer, mutex_handle as Integer, timeout_us as Integer returns Integer:
    If cv_handle is equal to 0:
        Return 0
    End If

    Note: Increment waiters count atomically
    Let waiters_ptr be cv_handle
    proc atomic_fetch_add from Atomic with waiters_ptr, 1

    Note: Get event handles
    Let signal_event be proc memory_get_int64 from Memory with cv_handle, 8
    Let broadcast_event be proc memory_get_int64 from Memory with cv_handle, 16

    Note: Release mutex before waiting
    mutex_unlock(mutex_handle)

    Note: Convert microseconds to NT time units (100-nanosecond intervals)
    Note: Negative value indicates relative time
    Let timeout_100ns be timeout_us multiplied by 10
    Let timeout_ns be 0 minus timeout_100ns

    Note: Wait for either signal or broadcast event with timeout
    Let wait_result be proc event_wait_multiple with signal_event, broadcast_event, timeout_ns

    Note: Decrement waiters count atomically
    proc atomic_fetch_sub from Atomic with waiters_ptr, 1

    Note: Reacquire mutex
    mutex_lock(mutex_handle)

    Note: Return 1 if signaled, 0 if timeout
    If wait_result is equal to 0:
        Return 1  Note: Event was signaled
    Otherwise:
        Return 0  Note: Timeout occurred
    End If
End Process

Process called "condvar_signal" takes handle as Integer returns Integer:
    If handle is equal to 0:
        Return 0
    End If

    Note: Check if there are any waiters
    Let waiters_count be proc memory_get_int64 from Memory with handle, 0
    If waiters_count is equal to 0:
        Return 1  Note: No waiters, nothing to signal
    End If

    Note: Signal the auto-reset event to wake ONE waiter
    Let signal_event be proc memory_get_int64 from Memory with handle, 8
    proc event_set with signal_event

    Return 1
End Process

Process called "condvar_broadcast" takes handle as Integer returns Integer:
    If handle is equal to 0:
        Return 0
    End If

    Note: Check if there are any waiters
    Let waiters_count be proc memory_get_int64 from Memory with handle, 0
    If waiters_count is equal to 0:
        Return 1  Note: No waiters, nothing to broadcast
    End If

    Note: Set the manual-reset broadcast event to wake ALL waiters
    Let broadcast_event be proc memory_get_int64 from Memory with handle, 16
    proc event_set with broadcast_event

    Note: Reset the broadcast event after a brief moment (let waiters wake up)
    proc event_reset with broadcast_event

    Return 1
End Process

Note: Read-write lock operations

Process called "rwlock_create" returns Integer:
    Note: SRW_LOCK is pointer-sized (8 bytes on x64)
    Let srw_ptr be proc syscall_mmap from Syscall with 0, 8, 3, 34, -1, 0
    If srw_ptr is less than 0:
        Return 0
    End If

    proc memory_set_int64 from Memory with srw_ptr, 0, 0
    Return srw_ptr
End Process

Process called "rwlock_destroy" takes handle as Integer returns Integer:
    proc syscall_munmap from Syscall with handle, 8
    Return 1
End Process

Process called "rwlock_read_lock" takes handle as Integer returns Integer:
    Note: Acquire shared lock (increment reader count if no exclusive owner)
    While 1 is equal to 1:
        Let current be proc memory_get_int64 from Memory with handle, 0
        If current is less than 0:
            thread_yield()  Note: Exclusive lock held
        Otherwise:
            Let new_val be current plus 1
            Let old_val be proc atomic_compare_and_swap from Atomic with handle, current, new_val
            If old_val is equal to 1:
                Return 1
            End If
        End If
    End While

    Return 1
End Process

Process called "rwlock_write_lock" takes handle as Integer returns Integer:
    Note: Acquire exclusive lock
    Let exclusive_bit be -9223372036854775808  Note: 0x8000000000000000

    While 1 is equal to 1:
        Let current be proc memory_get_int64 from Memory with handle, 0
        If current is equal to 0:
            Let success be proc atomic_compare_and_swap from Atomic with handle, 0, exclusive_bit
            If success is equal to 1:
                Return 1
            End If
        End If
        thread_yield()
    End While

    Return 1
End Process

Process called "rwlock_unlock" takes handle as Integer returns Integer:
    Note: Release read or write lock
    Let current be proc memory_get_int64 from Memory with handle, 0
    If current is less than 0:
        proc memory_set_int64 from Memory with handle, 0, 0  Note: Release exclusive
    Otherwise:
        proc atomic_fetch_add from Atomic with handle, -1  Note: Decrement reader count
    End If

    proc memory_barrier_release from Atomic
    Return 1
End Process

Process called "rwlock_try_read_lock" takes handle as Integer returns Integer:
    Let current be proc memory_get_int64 from Memory with handle, 0
    If current is less than 0:
        Return 0
    End If

    Let new_val be current plus 1
    Let success be proc atomic_compare_and_swap from Atomic with handle, current, new_val
    Return success
End Process

Process called "rwlock_try_write_lock" takes handle as Integer returns Integer:
    Let exclusive_bit be -9223372036854775808
    Let success be proc atomic_compare_and_swap from Atomic with handle, 0, exclusive_bit
    Return success
End Process
