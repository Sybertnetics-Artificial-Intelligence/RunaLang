Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
Linux ARM64 Instruction Set Metadata and Helpers

This file provides instruction metadata, opcode definitions, and helper functions
for ARM64 instruction selection, validation, and optimization.

ARM64 (AArch64) Key Differences from x86_64:
- Fixed 32-bit (4-byte) instruction length (RISC architecture)
- Load/store architecture (memory access only via LDR/STR)
- Three-operand instructions (dest can differ from sources)
- Conditional execution via condition codes, not prefixes
- PC-relative addressing with larger offsets
- No flags register - condition codes stored in NZCV

This includes:
- Instruction opcode patterns
- Instruction properties (latency, throughput)
- Instruction validation helpers
- Instruction selection helpers
- Common instruction patterns
- Optimization hints

This file does NOT perform actual instruction encoding (see machine_code.runa for that).
Instead, it provides metadata and helper functions for the code generator to make
intelligent decisions about which instructions to use and how to optimize them.

Dependencies:
- registers.runa for register metadata
- calling_convention.runa for ABI constraints
:End Note

Import "compiler/frontend/primitives/platform/linux_arm64/registers.runa" as Registers

Note: ============================================================================
Note: INSTRUCTION OPCODE PATTERNS (ARM64)
Note: ============================================================================
Note: ARM64 instructions are 32-bit (4-byte) with fixed encoding
Note: These are encoding identifiers, not literal opcodes

Process called "OPCODE_MOV" returns Integer:
    Return 1  Note: MOV (register) - encoded as ORR Xd, XZR, Xm
End Process

Process called "OPCODE_MOVZ" returns Integer:
    Return 2  Note: MOVZ - Move wide with zero (for immediate loading)
End Process

Process called "OPCODE_MOVK" returns Integer:
    Return 3  Note: MOVK - Move wide with keep (for multi-part immediates)
End Process

Process called "OPCODE_ADD" returns Integer:
    Return 10  Note: ADD (register or immediate)
End Process

Process called "OPCODE_SUB" returns Integer:
    Return 11  Note: SUB (register or immediate)
End Process

Process called "OPCODE_MUL" returns Integer:
    Return 12  Note: MUL - multiply (32-bit or 64-bit)
End Process

Process called "OPCODE_SDIV" returns Integer:
    Return 13  Note: SDIV - signed divide
End Process

Process called "OPCODE_UDIV" returns Integer:
    Return 14  Note: UDIV - unsigned divide
End Process

Process called "OPCODE_CMP" returns Integer:
    Return 20  Note: CMP - compare (encoded as SUBS XZR, Xn, Xm)
End Process

Process called "OPCODE_B" returns Integer:
    Return 30  Note: B - unconditional branch
End Process

Process called "OPCODE_B_COND" returns Integer:
    Return 31  Note: B.cond - conditional branch
End Process

Process called "OPCODE_BL" returns Integer:
    Return 32  Note: BL - branch with link (function call)
End Process

Process called "OPCODE_BR" returns Integer:
    Return 33  Note: BR - branch to register
End Process

Process called "OPCODE_BLR" returns Integer:
    Return 34  Note: BLR - branch with link to register
End Process

Process called "OPCODE_RET" returns Integer:
    Return 35  Note: RET - return from subroutine
End Process

Process called "OPCODE_LDR" returns Integer:
    Return 40  Note: LDR - load register (various addressing modes)
End Process

Process called "OPCODE_STR" returns Integer:
    Return 41  Note: STR - store register (various addressing modes)
End Process

Process called "OPCODE_LDP" returns Integer:
    Return 42  Note: LDP - load pair of registers
End Process

Process called "OPCODE_STP" returns Integer:
    Return 43  Note: STP - store pair of registers
End Process

Process called "OPCODE_SVC" returns Integer:
    Return 50  Note: SVC - supervisor call (system call)
End Process

Process called "OPCODE_NOP" returns Integer:
    Return 60  Note: NOP - no operation
End Process

Process called "OPCODE_AND" returns Integer:
    Return 70  Note: AND - bitwise AND
End Process

Process called "OPCODE_ORR" returns Integer:
    Return 71  Note: ORR - bitwise OR
End Process

Process called "OPCODE_EOR" returns Integer:
    Return 72  Note: EOR - bitwise exclusive OR
End Process

Process called "OPCODE_LSL" returns Integer:
    Return 80  Note: LSL - logical shift left
End Process

Process called "OPCODE_LSR" returns Integer:
    Return 81  Note: LSR - logical shift right
End Process

Process called "OPCODE_ASR" returns Integer:
    Return 82  Note: ASR - arithmetic shift right
End Process

Note: ============================================================================
Note: INSTRUCTION PROPERTIES
Note: ============================================================================
Note: Instruction latency and throughput for optimization

Process called "get_instruction_latency" takes instruction_type as Integer returns Integer:
    Note: Get instruction latency in CPU cycles
    Note: instruction_type: 1=MOV, 10=ADD, 11=SUB, 12=MUL, 13=DIV, 20=CMP, 30=B, 32=BL, 35=RET
    Note: Returns approximate latency on modern ARM64 CPUs (Cortex-A76/A78)

    Note: MOV - register to register
    If instruction_type is equal to 1:
        Return 1  Note: 1 cycle latency
    End If

    Note: ADD/SUB - integer arithmetic
    If instruction_type is equal to 10:
        Return 1  Note: 1 cycle latency
    End If

    If instruction_type is equal to 11:
        Return 1  Note: 1 cycle latency
    End If

    Note: MUL - integer multiply
    If instruction_type is equal to 12:
        Return 3  Note: 3 cycle latency (typical)
    End If

    Note: DIV - integer divide
    If instruction_type is equal to 13:
        Return 12  Note: 12-20 cycles (data-dependent)
    End If

    If instruction_type is equal to 14:
        Return 12  Note: 12-20 cycles (data-dependent)
    End If

    Note: CMP - comparison
    If instruction_type is equal to 20:
        Return 1  Note: 1 cycle latency
    End If

    Note: B - unconditional branch
    If instruction_type is equal to 30:
        Return 0  Note: Branch predictor handles this
    End If

    Note: BL - function call
    If instruction_type is equal to 32:
        Return 1  Note: 1 cycle (link register update)
    End If

    Note: RET - function return
    If instruction_type is equal to 35:
        Return 2  Note: 2 cycles (typical with prediction)
    End If

    Note: LDR/STR - memory operations
    If instruction_type is equal to 40:
        Return 4  Note: L1 cache hit latency
    End If

    If instruction_type is equal to 41:
        Return 1  Note: Store latency (async to cache)
    End If

    Return 1  Note: Default latency
End Process

Process called "get_instruction_throughput" takes instruction_type as Integer returns Integer:
    Note: Get instruction throughput (instructions per cycle)
    Note: Returns reciprocal throughput in 10ths (e.g., 5 = 0.5 instructions/cycle)

    Note: MOV - very high throughput
    If instruction_type is equal to 1:
        Return 25  Note: 0.25 cycles per instruction (4 per cycle)
    End If

    Note: ADD/SUB - high throughput
    If instruction_type is equal to 10:
        Return 33  Note: 0.33 cycles per instruction (3 per cycle)
    End If

    If instruction_type is equal to 11:
        Return 33  Note: 0.33 cycles per instruction (3 per cycle)
    End If

    Note: MUL - moderate throughput
    If instruction_type is equal to 12:
        Return 100  Note: 1 per cycle
    End If

    Note: DIV - low throughput
    If instruction_type is equal to 13:
        Return 1200  Note: 12 cycles minimum
    End If

    If instruction_type is equal to 14:
        Return 1200  Note: 12 cycles minimum
    End If

    Note: CMP - high throughput
    If instruction_type is equal to 20:
        Return 33  Note: 0.33 cycles per instruction
    End If

    Note: Branches - throughput depends on prediction
    If instruction_type is equal to 30:
        Return 50  Note: 0.5 per cycle with good prediction
    End If

    If instruction_type is equal to 32:
        Return 100  Note: 1 per cycle
    End If

    If instruction_type is equal to 35:
        Return 100  Note: 1 per cycle
    End If

    Note: Memory operations
    If instruction_type is equal to 40:
        Return 50  Note: 0.5 per cycle (2 loads per cycle)
    End If

    If instruction_type is equal to 41:
        Return 50  Note: 0.5 per cycle (2 stores per cycle)
    End If

    Return 100  Note: Default 1 per cycle
End Process

Note: ============================================================================
Note: INSTRUCTION SIZE CALCULATION
Note: ============================================================================

Process called "get_instruction_size" takes instruction_type as Integer returns Integer:
    Note: Get instruction size in bytes
    Note: ARM64 instructions are ALWAYS 32-bit (4 bytes)
    Note: This is a RISC architecture with fixed instruction length
    Return 4  Note: All ARM64 instructions are 4 bytes
End Process

Process called "get_min_instruction_size" returns Integer:
    Note: Minimum ARM64 instruction size
    Return 4  Note: Fixed 32-bit instructions
End Process

Process called "get_max_instruction_size" returns Integer:
    Note: Maximum ARM64 instruction size
    Return 4  Note: Fixed 32-bit instructions
End Process

Note: ============================================================================
Note: INSTRUCTION VALIDATION
Note: ============================================================================

Process called "is_valid_immediate_12bit" takes value as Integer returns Integer:
    Note: Check if value fits in 12-bit unsigned immediate
    Note: Used by ADD, SUB immediate forms
    Note: Returns 1 if valid, 0 otherwise

    If value is greater than or equal to 0:
        If value is less than 4096:
            Return 1  Note: Fits in 12 bits
        End If
    End If

    Return 0
End Process

Process called "is_valid_immediate_16bit" takes value as Integer returns Integer:
    Note: Check if value fits in 16-bit immediate
    Note: Used by MOVZ, MOVK for loading constants
    Note: Returns 1 if valid, 0 otherwise

    If value is greater than or equal to 0:
        If value is less than 65536:
            Return 1  Note: Fits in 16 bits
        End If
    End If

    Return 0
End Process

Process called "can_use_short_branch" takes offset as Integer returns Integer:
    Note: Check if offset fits in conditional branch immediate
    Note: B.cond uses 19-bit signed offset (±1MB range)
    Note: offset is in bytes, must be 4-byte aligned
    Note: Returns 1 if short branch possible, 0 otherwise

    Note: Check alignment (must be 4-byte aligned)
    Let remainder be offset bitwise_and 3
    If remainder is not equal to 0:
        Return 0  Note: Not aligned
    End If

    Note: B.cond range: -1048576 to +1048572 (±1MB)
    If offset is greater than or equal to -1048576:
        If offset is less than or equal to 1048572:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "can_use_long_branch" takes offset as Integer returns Integer:
    Note: Check if offset fits in unconditional branch immediate
    Note: B uses 26-bit signed offset (±128MB range)
    Note: offset is in bytes, must be 4-byte aligned
    Note: Returns 1 if long branch possible, 0 if need indirect

    Note: Check alignment
    Let remainder be offset bitwise_and 3
    If remainder is not equal to 0:
        Return 0  Note: Not aligned
    End If

    Note: B range: -134217728 to +134217724 (±128MB)
    If offset is greater than or equal to -134217728:
        If offset is less than or equal to 134217724:
            Return 1
        End If
    End If

    Return 0
End Process

Note: ============================================================================
Note: INSTRUCTION SELECTION HELPERS
Note: ============================================================================

Process called "should_use_add_immediate" takes value as Integer returns Integer:
    Note: Check if ADD immediate form can be used
    Note: ADD immediate supports 12-bit value with optional 12-bit left shift
    Note: Returns 1 if immediate form usable, 0 if need register form

    Note: Check if fits in 12-bit immediate
    If value is greater than or equal to 0:
        If value is less than 4096:
            Return 1  Note: Fits in imm12
        End If
    End If

    Note: Check if fits in imm12 << 12 (bits 12-23)
    If value is greater than or equal to 4096:
        Let shifted_val be value divided by 4096
        If shifted_val is less than 4096:
            Let remainder be value bitwise_and 4095
            If remainder is equal to 0:
                Return 1  Note: Fits in (imm12 << 12)
            End If
        End If
    End If

    Return 0  Note: Need to load into register first
End Process

Process called "needs_multi_instruction_load" takes value as Integer returns Integer:
    Note: Check if loading constant requires multiple instructions
    Note: ARM64 can load 16-bit immediates, need MOVZ + MOVK for larger
    Note: Returns number of instructions needed (1-4)

    Note: Check if fits in 16-bit (single MOVZ)
    If value is greater than or equal to 0:
        If value is less than 65536:
            Return 1  Note: Single MOVZ
        End If
    End If

    Note: Check if fits in 32-bit (MOVZ + MOVK)
    If value is greater than or equal to 0:
        If value is less than 4294967296:
            Return 2  Note: MOVZ + MOVK
        End If
    End If

    Note: 48-bit requires MOVZ + 2 MOVK
    Note: 64-bit requires MOVZ + 3 MOVK
    Return 4  Note: Maximum 4 instructions for full 64-bit
End Process

Process called "should_inline_small_memcpy" takes size as Integer returns Integer:
    Note: Check if small memcpy should be inlined vs calling function
    Note: ARM64 has LDP/STP for efficient pair loads/stores
    Note: Returns 1 if inline recommended, 0 if call function

    Note: Inline for sizes up to 128 bytes
    Note: ARM64 can use LDP/STP for 16-byte moves
    If size is less than or equal to 128:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: OPTIMIZATION PATTERNS
Note: ============================================================================

Process called "can_eliminate_redundant_move" takes src_reg as Integer, dest_reg as Integer returns Integer:
    Note: Check if MOV can be eliminated (src == dest)
    Note: Returns 1 if redundant, 0 otherwise

    If src_reg is equal to dest_reg:
        Return 1  Note: Redundant move
    End If

    Return 0
End Process

Process called "can_use_zero_register" takes value as Integer returns Integer:
    Note: Check if XZR (zero register) can be used instead of loading 0
    Note: XZR/WZR always reads as zero, saves instruction
    Note: Returns 1 if XZR usable, 0 otherwise

    If value is equal to 0:
        Return 1  Note: Use XZR instead of MOV
    End If

    Return 0
End Process

Process called "can_fuse_compare_branch" takes has_compare as Integer, has_branch as Integer returns Integer:
    Note: Check if compare and branch can be fused
    Note: ARM64 has CBZ, CBNZ, TBZ, TBNZ for compare+branch fusion
    Note: Returns 1 if fusion possible, 0 otherwise

    If has_compare is equal to 1:
        If has_branch is equal to 1:
            Return 1  Note: Can potentially use CBZ/CBNZ
        End If
    End If

    Return 0
End Process

Process called "can_use_conditional_select" takes has_branch as Integer, is_simple_value as Integer returns Integer:
    Note: Check if branch can be replaced with conditional select (CSEL)
    Note: CSEL is branchless, better for unpredictable branches
    Note: Returns 1 if CSEL recommended, 0 if branch is better

    If has_branch is equal to 1:
        If is_simple_value is equal to 1:
            Return 1  Note: CSEL avoids branch misprediction
        End If
    End If

    Return 0
End Process

Note: ============================================================================
Note: INSTRUCTION CATEGORIES
Note: ============================================================================

Process called "INSTR_CATEGORY_DATA_MOVEMENT" returns Integer:
    Return 0  Note: MOV, LDR, STR, LDP, STP
End Process

Process called "INSTR_CATEGORY_ARITHMETIC" returns Integer:
    Return 1  Note: ADD, SUB, MUL, SDIV, UDIV
End Process

Process called "INSTR_CATEGORY_LOGICAL" returns Integer:
    Return 2  Note: AND, ORR, EOR
End Process

Process called "INSTR_CATEGORY_CONTROL_FLOW" returns Integer:
    Return 3  Note: B, B.cond, BL, BR, BLR, RET
End Process

Process called "INSTR_CATEGORY_COMPARISON" returns Integer:
    Return 4  Note: CMP, CMN, TST
End Process

Process called "INSTR_CATEGORY_MEMORY" returns Integer:
    Return 5  Note: LDR, STR, LDP, STP
End Process

Process called "INSTR_CATEGORY_SYSTEM" returns Integer:
    Return 6  Note: SVC, MRS, MSR
End Process

Note: ============================================================================
Note: INSTRUCTION FLAGS (NZCV Condition Codes)
Note: ============================================================================

Process called "instruction_modifies_flags" takes instruction_category as Integer returns Integer:
    Note: Check if instruction modifies condition flags (NZCV)
    Note: Returns 1 if modifies flags, 0 otherwise

    Note: Data movement does NOT modify flags (unless 'S' suffix)
    If instruction_category is equal to 0:
        Return 0  Note: MOV, LDR, STR
    End If

    Note: Arithmetic with 'S' suffix DOES modify flags
    Note: Plain ADD/SUB don't, but ADDS/SUBS do
    If instruction_category is equal to 1:
        Return 0  Note: Default arithmetic doesn't modify (need explicit 'S')
    End If

    Note: Logical operations with 'S' suffix modify flags
    If instruction_category is equal to 2:
        Return 0  Note: Default logical doesn't modify (need explicit 'S')
    End If

    Note: Control flow doesn't modify flags
    If instruction_category is equal to 3:
        Return 0  Note: B, BL, RET
    End If

    Note: Comparison ALWAYS modifies flags (CMP = SUBS with XZR dest)
    If instruction_category is equal to 4:
        Return 1  Note: CMP, CMN, TST
    End If

    Note: Memory operations don't modify flags
    If instruction_category is equal to 5:
        Return 0  Note: LDR, STR
    End If

    Note: System operations don't modify flags
    If instruction_category is equal to 6:
        Return 0  Note: SVC
    End If

    Return 0  Note: Default: no modification
End Process

Process called "instruction_reads_flags" takes instruction_category as Integer returns Integer:
    Note: Check if instruction reads condition flags
    Note: Returns 1 if reads flags, 0 otherwise

    Note: Conditional branches READ flags
    If instruction_category is equal to 3:
        Return 1  Note: B.cond reads NZCV
    End If

    Return 0  Note: Most instructions don't read flags
End Process

Note: ============================================================================
Note: PERFORMANCE HINTS
Note: ============================================================================

Process called "get_preferred_nop_size" takes size as Integer returns Integer:
    Note: Get optimal NOP encoding for padding
    Note: ARM64 NOPs are always 4 bytes (fixed instruction length)
    Note: size: desired padding in bytes
    Note: Returns: number of NOP instructions needed

    Note: ARM64 uses NOP instruction (0xD503201F)
    Note: Each NOP is exactly 4 bytes

    Note: Calculate number of NOPs needed
    Let num_nops be size divided by 4

    Note: If size not divisible by 4, round up
    Let remainder be size bitwise_and 3
    If remainder is not equal to 0:
        Set num_nops to num_nops plus 1
    End If

    Return num_nops  Note: Return number of 4-byte NOPs
End Process

Process called "should_align_loop_target" takes loop_size as Integer, iteration_count as Integer returns Integer:
    Note: Determine if loop should be aligned
    Note: ARM64 instruction fetch benefits from cache line alignment
    Note: loop_size: loop body size in bytes
    Note: iteration_count: expected iteration count (-1 if unknown)
    Note: Returns 1 if alignment recommended, 0 otherwise

    Note: ARM64 instructions are 4-byte aligned by nature
    Note: Additional alignment helps with cache line boundaries (64 bytes)

    Note: Don't align tiny loops (< 16 bytes)
    If loop_size is less than 16:
        Return 0  Note: Too small
    End If

    Note: If iteration count is known and high, definitely align
    If iteration_count is greater than or equal to 100:
        Return 1  Note: High iteration count
    End If

    Note: For medium loops, align if iterations unknown or >= 10
    If loop_size is less than or equal to 64:
        If iteration_count is equal to -1:
            Return 1  Note: Unknown iterations
        End If

        If iteration_count is greater than or equal to 10:
            Return 1  Note: Enough iterations
        End If

        Return 0
    End If

    Note: Large loops benefit from alignment
    Return 1
End Process

Process called "get_recommended_alignment" takes alignment_type as Integer returns Integer:
    Note: Get recommended alignment for different code structures
    Note: alignment_type: 0=function entry, 1=loop target, 2=hot path, 3=cold path
    Note: Returns: alignment in bytes

    Note: Function entry points (0)
    If alignment_type is equal to 0:
        Note: 16-byte alignment for function entry
        Note: ARM64 benefits from cache line sub-alignment
        Return 16
    End If

    Note: Loop targets (1)
    If alignment_type is equal to 1:
        Note: 16-byte alignment for loops
        Return 16
    End If

    Note: Hot path branch targets (2)
    If alignment_type is equal to 2:
        Note: 16-byte alignment for hot paths
        Return 16
    End If

    Note: Cold path branch targets (3)
    If alignment_type is equal to 3:
        Note: No special alignment for cold paths
        Return 4  Note: Natural instruction alignment
    End If

    Note: Default: 16-byte alignment
    Return 16
End Process

Process called "get_cache_line_size" returns Integer:
    Note: Get typical cache line size for ARM64
    Note: Most ARM64 cores use 64-byte cache lines
    Return 64
End Process

Process called "should_use_load_store_pair" takes num_consecutive as Integer returns Integer:
    Note: Check if LDP/STP pair operations should be used
    Note: Pair operations are more efficient than separate loads/stores
    Note: num_consecutive: number of consecutive 8-byte loads/stores
    Note: Returns 1 if pair operations recommended, 0 otherwise

    Note: Need at least 2 consecutive operations for pairing
    If num_consecutive is greater than or equal to 2:
        Return 1  Note: Use LDP/STP
    End If

    Return 0
End Process
