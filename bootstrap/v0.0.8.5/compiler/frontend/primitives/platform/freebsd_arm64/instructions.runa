Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
FreeBSD ARM64 Instruction Set Metadata and Helpers

This file provides instruction metadata, opcode definitions, and helper functions
for ARM64 instruction selection, validation, and optimization.

ARM64 (AArch64) Key Characteristics:
- Fixed 32-bit (4-byte) instruction length (RISC architecture)
- Load/store architecture (memory access only via LDR/STR)
- Three-operand instructions (dest can differ from sources)
- Conditional execution via condition codes, not prefixes
- PC-relative addressing with larger offsets
- No flags register - condition codes stored in NZCV

This includes:
- Instruction opcode patterns
- Instruction properties (latency, throughput)
- Instruction validation helpers
- Instruction selection helpers
- Common instruction patterns
- Optimization hints

IMPORTANT: ARM64 instruction set is IDENTICAL across platforms (Windows, Linux, macOS, FreeBSD).
Platform differences are in calling convention and syscalls, NOT instruction encoding.

This file does NOT perform actual instruction encoding (see machine_code.runa for that).
Instead, it provides metadata and helper functions for the code generator to make
intelligent decisions about which instructions to use and how to optimize them.

Dependencies:
- registers.runa for register metadata
- calling_convention.runa for ABI constraints
:End Note

Import "compiler/frontend/primitives/platform/freebsd_arm64/registers.runa" as Registers

Note: ============================================================================
Note: INSTRUCTION OPCODE PATTERNS (ARM64)
Note: ============================================================================
Note: ARM64 instructions are 32-bit (4-byte) with fixed encoding
Note: These are encoding identifiers, not literal opcodes

Process called "OPCODE_MOV" returns Integer:
    Return 1  Note: MOV (register) - encoded as ORR Xd, XZR, Xm
End Process

Process called "OPCODE_MOVZ" returns Integer:
    Return 2  Note: MOVZ - Move wide with zero (for immediate loading)
End Process

Process called "OPCODE_MOVK" returns Integer:
    Return 3  Note: MOVK - Move wide with keep (for multi-part immediates)
End Process

Process called "OPCODE_ADD" returns Integer:
    Return 10  Note: ADD (register or immediate)
End Process

Process called "OPCODE_SUB" returns Integer:
    Return 11  Note: SUB (register or immediate)
End Process

Process called "OPCODE_MUL" returns Integer:
    Return 12  Note: MUL - multiply (32-bit or 64-bit)
End Process

Process called "OPCODE_SDIV" returns Integer:
    Return 13  Note: SDIV - signed divide
End Process

Process called "OPCODE_UDIV" returns Integer:
    Return 14  Note: UDIV - unsigned divide
End Process

Process called "OPCODE_CMP" returns Integer:
    Return 20  Note: CMP - compare (encoded as SUBS XZR, Xn, Xm)
End Process

Process called "OPCODE_B" returns Integer:
    Return 30  Note: B - unconditional branch
End Process

Process called "OPCODE_B_COND" returns Integer:
    Return 31  Note: B.cond - conditional branch
End Process

Process called "OPCODE_BL" returns Integer:
    Return 32  Note: BL - branch with link (function call)
End Process

Process called "OPCODE_BR" returns Integer:
    Return 33  Note: BR - branch to register
End Process

Process called "OPCODE_BLR" returns Integer:
    Return 34  Note: BLR - branch with link to register
End Process

Process called "OPCODE_RET" returns Integer:
    Return 35  Note: RET - return from subroutine
End Process

Process called "OPCODE_LDR" returns Integer:
    Return 40  Note: LDR - load register (various addressing modes)
End Process

Process called "OPCODE_STR" returns Integer:
    Return 41  Note: STR - store register (various addressing modes)
End Process

Process called "OPCODE_LDP" returns Integer:
    Return 42  Note: LDP - load pair of registers
End Process

Process called "OPCODE_STP" returns Integer:
    Return 43  Note: STP - store pair of registers
End Process

Process called "OPCODE_SVC" returns Integer:
    Return 50  Note: SVC - supervisor call (system call)
End Process

Process called "OPCODE_NOP" returns Integer:
    Return 60  Note: NOP - no operation
End Process

Process called "OPCODE_AND" returns Integer:
    Return 70  Note: AND - bitwise AND
End Process

Process called "OPCODE_ORR" returns Integer:
    Return 71  Note: ORR - bitwise OR
End Process

Process called "OPCODE_EOR" returns Integer:
    Return 72  Note: EOR - bitwise exclusive OR
End Process

Process called "OPCODE_LSL" returns Integer:
    Return 80  Note: LSL - logical shift left
End Process

Process called "OPCODE_LSR" returns Integer:
    Return 81  Note: LSR - logical shift right
End Process

Process called "OPCODE_ASR" returns Integer:
    Return 82  Note: ASR - arithmetic shift right
End Process

Note: ============================================================================
Note: INSTRUCTION PROPERTIES
Note: ============================================================================
Note: Instruction latency and throughput for optimization

Process called "get_instruction_latency" takes instruction_type as Integer returns Integer:
    Note: Get instruction latency in CPU cycles
    Note: instruction_type: 1=MOV, 10=ADD, 11=SUB, 12=MUL, 13=DIV, 20=CMP, 30=B, 32=BL, 35=RET
    Note: Returns approximate latency on modern ARM64 CPUs (Cortex-A76/A78)

    Note: MOV - register to register
    If instruction_type is equal to 1:
        Return 1  Note: 1 cycle latency
    End If

    Note: ADD/SUB - integer arithmetic
    If instruction_type is equal to 10:
        Return 1  Note: 1 cycle latency
    End If

    If instruction_type is equal to 11:
        Return 1  Note: 1 cycle latency
    End If

    Note: MUL - integer multiply
    If instruction_type is equal to 12:
        Return 3  Note: 3 cycle latency (typical)
    End If

    Note: DIV - integer divide
    If instruction_type is equal to 13:
        Return 12  Note: 12-20 cycles (data-dependent)
    End If

    If instruction_type is equal to 14:
        Return 12  Note: 12-20 cycles (data-dependent)
    End If

    Note: CMP - compare
    If instruction_type is equal to 20:
        Return 1  Note: 1 cycle latency
    End If

    Note: Branch instructions
    If instruction_type is equal to 30:
        Return 1  Note: Predicted correctly
    End If

    If instruction_type is equal to 31:
        Return 1  Note: Predicted correctly
    End If

    If instruction_type is equal to 32:
        Return 1  Note: BL latency
    End If

    If instruction_type is equal to 35:
        Return 1  Note: RET latency
    End If

    Note: Load/Store instructions
    If instruction_type is equal to 40:
        Return 4  Note: L1 cache hit
    End If

    If instruction_type is equal to 41:
        Return 1  Note: Store latency
    End If

    Return 1  Note: Default conservative estimate
End Process

Process called "get_instruction_throughput" takes instruction_type as Integer returns Integer:
    Note: Get instruction throughput (instructions per cycle)
    Note: Returns reciprocal throughput in tenths (e.g., 10 = 1.0 IPC)

    Note: Most ALU operations: 2-4 per cycle
    If instruction_type is equal to 1:
        Return 5  Note: 0.5 cycles (2 per cycle)
    End If

    If instruction_type is equal to 10:
        Return 5  Note: 0.5 cycles
    End If

    If instruction_type is equal to 11:
        Return 5  Note: 0.5 cycles
    End If

    Note: Multiply: 1 per cycle
    If instruction_type is equal to 12:
        Return 10  Note: 1.0 cycle
    End If

    Note: Divide: very slow
    If instruction_type is equal to 13:
        Return 120  Note: 12 cycles
    End If

    If instruction_type is equal to 14:
        Return 120  Note: 12 cycles
    End If

    Return 10  Note: Default 1.0 cycle
End Process

Process called "get_instruction_size" returns Integer:
    Note: Get instruction size in bytes
    Note: ARM64 instructions are always 4 bytes (fixed-length RISC)
    Return 4
End Process

Note: ============================================================================
Note: INSTRUCTION VALIDATION
Note: ============================================================================

Process called "validate_immediate_size" takes immediate as Integer, bits as Integer returns Integer:
    Note: Validate that immediate value fits in specified bit width
    Note: bits: number of bits available (e.g., 12 for ADD immediate)
    Note: Returns 1 if valid, 0 if out of range

    Note: Calculate maximum positive value for bit width
    Let max_val be 1 shifted_left bits
    Set max_val to max_val minus 1

    Note: Check if immediate is in range [0, max_val]
    If immediate is less than 0:
        Return 0  Note: Negative not supported for unsigned immediate
    End If

    If immediate is greater than max_val:
        Return 0  Note: Too large
    End If

    Return 1  Note: Valid
End Process

Process called "validate_branch_offset" takes offset as Integer, is_conditional as Integer returns Integer:
    Note: Validate branch offset is within ARM64 limits
    Note: offset: byte offset from current instruction
    Note: is_conditional: 1 for B.cond (±1MB), 0 for B (±128MB)
    Note: Returns 1 if valid, 0 if out of range

    Note: ARM64 branch offsets are in 4-byte instruction units
    Let instr_offset be offset divided by 4

    Note: Conditional branches: 19-bit signed offset (±1MB)
    If is_conditional is equal to 1:
        If instr_offset is greater than 262143:
            Return 0  Note: Too far forward (> +1MB)
        End If
        If instr_offset is less than -262144:
            Return 0  Note: Too far backward (< -1MB)
        End If
        Return 1
    End If

    Note: Unconditional branches: 26-bit signed offset (±128MB)
    If instr_offset is greater than 33554431:
        Return 0  Note: Too far forward
    End If
    If instr_offset is less than -33554432:
        Return 0  Note: Too far backward
    End If

    Return 1  Note: Valid
End Process

Process called "can_use_immediate" takes immediate as Integer, instruction_type as Integer returns Integer:
    Note: Check if immediate can be encoded directly in instruction
    Note: Returns 1 if can use immediate, 0 if needs register

    Note: ADD/SUB: 12-bit unsigned immediate
    If instruction_type is equal to 10:
        Return validate_immediate_size(immediate, 12)
    End If

    If instruction_type is equal to 11:
        Return validate_immediate_size(immediate, 12)
    End If

    Note: CMP: 12-bit unsigned immediate
    If instruction_type is equal to 20:
        Return validate_immediate_size(immediate, 12)
    End If

    Note: MOVZ/MOVK: 16-bit immediate
    If instruction_type is equal to 2:
        Return validate_immediate_size(immediate, 16)
    End If

    If instruction_type is equal to 3:
        Return validate_immediate_size(immediate, 16)
    End If

    Return 0  Note: Default: cannot use immediate
End Process

Note: ============================================================================
Note: INSTRUCTION SELECTION HELPERS
Note: ============================================================================

Process called "needs_multi_instruction_load" takes immediate as Integer returns Integer:
    Note: Check if loading immediate requires multiple instructions
    Note: Returns number of instructions needed (1-4)

    Note: Check if fits in 16 bits (MOVZ only)
    If immediate is less than 65536:
        If immediate is greater than or equal to 0:
            Return 1  Note: Single MOVZ
        End If
    End If

    Note: Check if fits in 32 bits
    If immediate is less than 4294967296:
        Return 2  Note: MOVZ + MOVK
    End If

    Note: Check if fits in 48 bits
    If immediate is less than 281474976710656:
        Return 3  Note: MOVZ + MOVK + MOVK
    End If

    Return 4  Note: Full 64-bit: MOVZ + MOVK + MOVK + MOVK
End Process

Process called "should_use_load_store_pair" takes num_consecutive as Integer returns Integer:
    Note: Check if should use LDP/STP instead of individual loads/stores
    Note: num_consecutive: number of consecutive register loads/stores
    Note: Returns 1 if should use pair instructions, 0 otherwise

    If num_consecutive is greater than or equal to 2:
        Return 1  Note: Use LDP/STP for 2+ consecutive
    End If

    Return 0
End Process

Note: ============================================================================
Note: OPTIMIZATION HINTS
Note: ============================================================================

Process called "can_eliminate_redundant_move" takes src_reg as Integer, dest_reg as Integer returns Integer:
    Note: Check if MOV can be eliminated (source and dest are same)
    Note: Returns 1 if can eliminate, 0 if must emit

    If src_reg is equal to dest_reg:
        Return 1  Note: Redundant move
    End If

    Return 0
End Process

Process called "can_use_zero_register" takes value as Integer returns Integer:
    Note: Check if value is zero and can use XZR register
    Note: Returns 1 if can use XZR, 0 otherwise

    If value is equal to 0:
        Return 1  Note: Use XZR for zero
    End If

    Return 0
End Process

Process called "should_fuse_compare_branch" takes compare_type as Integer, branch_type as Integer returns Integer:
    Note: Check if compare + branch can be fused into CBZ/CBNZ
    Note: Returns 1 if can fuse, 0 if keep separate

    Note: CMP with zero followed by conditional branch can use CBZ/CBNZ
    If compare_type is equal to 20:
        If branch_type is equal to 31:
            Return 1  Note: Can potentially fuse
        End If
    End If

    Return 0
End Process

Note: ============================================================================
Note: CONDITION CODE MAPPING
Note: ============================================================================

Process called "get_condition_code" takes condition_type as Integer returns Integer:
    Note: Get ARM64 condition code for branch instruction
    Note: condition_type: 0=EQ, 1=NE, 2=LT, 3=LE, 4=GT, 5=GE
    Note: Returns ARM64 condition code (0-15)

    If condition_type is equal to 0:
        Return 0  Note: EQ (equal, Z=1)
    End If

    If condition_type is equal to 1:
        Return 1  Note: NE (not equal, Z=0)
    End If

    If condition_type is equal to 2:
        Return 11  Note: LT (signed less than, N!=V)
    End If

    If condition_type is equal to 3:
        Return 13  Note: LE (signed less than or equal, Z=1 or N!=V)
    End If

    If condition_type is equal to 4:
        Return 12  Note: GT (signed greater than, Z=0 and N=V)
    End If

    If condition_type is equal to 5:
        Return 10  Note: GE (signed greater than or equal, N=V)
    End If

    Return 14  Note: AL (always) - default
End Process

Note: ============================================================================
Note: PERFORMANCE HINTS
Note: ============================================================================

Process called "get_nop_instruction_size" returns Integer:
    Note: Get size of NOP instruction in bytes
    Return 4  Note: ARM64 NOP is 4 bytes
End Process

Process called "get_instruction_alignment" returns Integer:
    Note: Get required instruction alignment in bytes
    Return 4  Note: ARM64 instructions must be 4-byte aligned
End Process

Process called "get_loop_alignment_hint" returns Integer:
    Note: Get recommended alignment for loop entry points
    Return 16  Note: Align loops to 16 bytes for better performance
End Process

Process called "get_cache_line_size" returns Integer:
    Note: Get CPU cache line size in bytes
    Return 64  Note: ARM64 typically uses 64-byte cache lines
End Process

Process called "should_align_branch_target" takes is_loop_entry as Integer returns Integer:
    Note: Check if branch target should be aligned
    Note: Returns 1 if should align, 0 otherwise

    If is_loop_entry is equal to 1:
        Return 1  Note: Align loop entries
    End If

    Return 0  Note: Don't align other branches
End Process
