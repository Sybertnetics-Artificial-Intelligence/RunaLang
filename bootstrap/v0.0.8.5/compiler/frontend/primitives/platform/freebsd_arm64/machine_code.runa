Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
FreeBSD ARM64 Machine Code Generation

This file implements ARM64 (AArch64) machine code encoding for FreeBSD.

ARM64 Instruction Encoding:
- Fixed 32-bit (4-byte) instructions (RISC)
- Little-endian byte order
- Three-operand format: op Xd, Xn, Xm
- Load/store architecture (memory access only via LDR/STR)
- PC-relative addressing for branches

IMPORTANT: ARM64 machine code is IDENTICAL across platforms (Windows, Linux, macOS, FreeBSD).
The CPU doesn't know what OS is running - it just executes ARM64 instructions.
Platform differences are in:
1. Object file format (Mach-O for macOS vs ELF for Linux/FreeBSD vs PE/COFF for Windows)
2. Relocation types (handled by assembler/linker)
3. Symbol table format (handled by assembler/linker)

At the instruction level, a MOV instruction on FreeBSD is byte-for-byte
identical to the same MOV instruction on Linux, macOS, or Windows.

This file provides basic encoding utilities for common ARM64 instructions.
For comprehensive ARM64 instruction encoding, reference the ARM Architecture
Reference Manual for ARMv8-A.

Dependencies: memory_core.runa for buffer operations
:End Note

Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Note: ============================================================================
Note: INSTRUCTION BUFFER OPERATIONS
Note: ============================================================================

Process called "write_instruction" takes buffer_ptr as Integer, offset as Integer, instruction as Integer returns Integer:
    Note: Write 32-bit ARM64 instruction to buffer (little-endian)
    Note: ARM64 instructions are always 4 bytes
    Note: Returns offset + 4 (next write position)

    Note: Little-endian: byte 0 = bits 0-7, byte 1 = bits 8-15, etc.
    Memory.memory_set_byte(buffer_ptr, offset, instruction bitwise_and 255)
    Memory.memory_set_byte(buffer_ptr, offset plus 1, (instruction shifted_right 8) bitwise_and 255)
    Memory.memory_set_byte(buffer_ptr, offset plus 2, (instruction shifted_right 16) bitwise_and 255)
    Memory.memory_set_byte(buffer_ptr, offset plus 3, (instruction shifted_right 24) bitwise_and 255)

    Return offset plus 4
End Process

Note: ============================================================================
Note: DATA MOVEMENT INSTRUCTIONS
Note: ============================================================================

Process called "encode_mov_register" takes buffer_ptr as Integer, dest_reg as Integer, src_reg as Integer returns Integer:
    Note: Encode MOV Xd, Xm (register to register)
    Note: ARM64: MOV is encoded as ORR Xd, XZR, Xm
    Note: Encoding: sf=1, opc=01, N=0, Rm, imm6=000000, Rn=31 (XZR), Rd
    Note: 32-bit instruction: 0xAA0003E0 | (Rm << 16) | (Rd << 0)

    Note: Base encoding: ORR X0, XZR, X0 = 0xAA0003E0
    Let instruction be -1442775328  Note: 0xAA0003E0 in signed 32-bit

    Note: Insert source register at bits 16-20
    Let src_bits be src_reg shifted_left 16
    Set instruction to instruction bitwise_or src_bits

    Note: Insert destination register at bits 0-4
    Set instruction to instruction bitwise_or dest_reg

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_movz" takes buffer_ptr as Integer, dest_reg as Integer, immediate as Integer, shift as Integer returns Integer:
    Note: Encode MOVZ Xd, #imm, LSL #shift
    Note: MOVZ - Move wide with zero
    Note: shift: 0, 16, 32, or 48 (which 16-bit chunk to load)
    Note: Encoding: sf=1, opc=10, hw, imm16, Rd
    Note: Base: 0xD2800000

    Let instruction be -738230272  Note: 0xD2800000

    Note: Insert immediate (16 bits) at bits 5-20
    Let imm_bits be (immediate bitwise_and 65535) shifted_left 5
    Set instruction to instruction bitwise_or imm_bits

    Note: Insert shift selector (hw field) at bits 21-22
    Let hw be shift divided by 16
    Let hw_bits be hw shifted_left 21
    Set instruction to instruction bitwise_or hw_bits

    Note: Insert destination register at bits 0-4
    Set instruction to instruction bitwise_or dest_reg

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_movk" takes buffer_ptr as Integer, dest_reg as Integer, immediate as Integer, shift as Integer returns Integer:
    Note: Encode MOVK Xd, #imm, LSL #shift
    Note: MOVK - Move wide with keep (preserves other bits)
    Note: Used for loading multi-part 64-bit immediates
    Note: Base: 0xF2800000

    Let instruction be -218084352  Note: 0xF2800000

    Note: Insert immediate (16 bits) at bits 5-20
    Let imm_bits be (immediate bitwise_and 65535) shifted_left 5
    Set instruction to instruction bitwise_or imm_bits

    Note: Insert shift selector (hw field) at bits 21-22
    Let hw be shift divided by 16
    Let hw_bits be hw shifted_left 21
    Set instruction to instruction bitwise_or hw_bits

    Note: Insert destination register at bits 0-4
    Set instruction to instruction bitwise_or dest_reg

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Note: ============================================================================
Note: LOAD/STORE INSTRUCTIONS
Note: ============================================================================

Process called "encode_ldr_immediate" takes buffer_ptr as Integer, dest_reg as Integer, base_reg as Integer, offset as Integer returns Integer:
    Note: Encode LDR Xd, [Xn, #offset]
    Note: Load register from memory with immediate offset
    Note: offset must be 8-byte aligned for 64-bit load
    Note: Base: 0xF9400000

    Let instruction be -113033216  Note: 0xF9400000

    Note: Insert offset (divided by 8 for encoding) at bits 10-21
    Let offset_encoded be offset divided by 8
    Let offset_bits be offset_encoded shifted_left 10
    Set instruction to instruction bitwise_or offset_bits

    Note: Insert base register at bits 5-9
    Let base_bits be base_reg shifted_left 5
    Set instruction to instruction bitwise_or base_bits

    Note: Insert destination register at bits 0-4
    Set instruction to instruction bitwise_or dest_reg

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_str_immediate" takes buffer_ptr as Integer, src_reg as Integer, base_reg as Integer, offset as Integer returns Integer:
    Note: Encode STR Xd, [Xn, #offset]
    Note: Store register to memory with immediate offset
    Note: offset must be 8-byte aligned for 64-bit store
    Note: Base: 0xF9000000

    Let instruction be -117227520  Note: 0xF9000000

    Note: Insert offset (divided by 8 for encoding) at bits 10-21
    Let offset_encoded be offset divided by 8
    Let offset_bits be offset_encoded shifted_left 10
    Set instruction to instruction bitwise_or offset_bits

    Note: Insert base register at bits 5-9
    Let base_bits be base_reg shifted_left 5
    Set instruction to instruction bitwise_or base_bits

    Note: Insert source register at bits 0-4
    Set instruction to instruction bitwise_or src_reg

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_ldp" takes buffer_ptr as Integer, reg1 as Integer, reg2 as Integer, base_reg as Integer, offset as Integer returns Integer:
    Note: Encode LDP Xd1, Xd2, [Xn, #offset]
    Note: Load pair of registers (more efficient than two LDRs)
    Note: offset in range -512 to 504, must be 8-byte aligned
    Note: Base: 0xA9400000

    Let instruction be -1454956544  Note: 0xA9400000

    Note: Insert offset (divided by 8, 7-bit signed) at bits 15-21
    Let offset_encoded be offset divided by 8
    Let offset_bits be (offset_encoded bitwise_and 127) shifted_left 15
    Set instruction to instruction bitwise_or offset_bits

    Note: Insert second register at bits 10-14
    Let reg2_bits be reg2 shifted_left 10
    Set instruction to instruction bitwise_or reg2_bits

    Note: Insert base register at bits 5-9
    Let base_bits be base_reg shifted_left 5
    Set instruction to instruction bitwise_or base_bits

    Note: Insert first register at bits 0-4
    Set instruction to instruction bitwise_or reg1

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_stp" takes buffer_ptr as Integer, reg1 as Integer, reg2 as Integer, base_reg as Integer, offset as Integer returns Integer:
    Note: Encode STP Xd1, Xd2, [Xn, #offset]
    Note: Store pair of registers (more efficient than two STRs)
    Note: offset in range -512 to 504, must be 8-byte aligned
    Note: Base: 0xA9000000

    Let instruction be -1459150848  Note: 0xA9000000

    Note: Insert offset (divided by 8, 7-bit signed) at bits 15-21
    Let offset_encoded be offset divided by 8
    Let offset_bits be (offset_encoded bitwise_and 127) shifted_left 15
    Set instruction to instruction bitwise_or offset_bits

    Note: Insert second register at bits 10-14
    Let reg2_bits be reg2 shifted_left 10
    Set instruction to instruction bitwise_or reg2_bits

    Note: Insert base register at bits 5-9
    Let base_bits be base_reg shifted_left 5
    Set instruction to instruction bitwise_or base_bits

    Note: Insert first register at bits 0-4
    Set instruction to instruction bitwise_or reg1

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Note: ============================================================================
Note: ARITHMETIC INSTRUCTIONS
Note: ============================================================================

Process called "encode_add_register" takes buffer_ptr as Integer, dest_reg as Integer, src_reg1 as Integer, src_reg2 as Integer returns Integer:
    Note: Encode ADD Xd, Xn, Xm
    Note: Add two registers
    Note: Base: 0x8B000000

    Let instruction be -1962934272  Note: 0x8B000000

    Note: Insert src2 register at bits 16-20
    Let src2_bits be src_reg2 shifted_left 16
    Set instruction to instruction bitwise_or src2_bits

    Note: Insert src1 register at bits 5-9
    Let src1_bits be src_reg1 shifted_left 5
    Set instruction to instruction bitwise_or src1_bits

    Note: Insert destination register at bits 0-4
    Set instruction to instruction bitwise_or dest_reg

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_add_immediate" takes buffer_ptr as Integer, dest_reg as Integer, src_reg as Integer, immediate as Integer returns Integer:
    Note: Encode ADD Xd, Xn, #imm
    Note: Add immediate value (12-bit unsigned)
    Note: Base: 0x91000000

    Let instruction be -1862270976  Note: 0x91000000

    Note: Insert immediate (12 bits) at bits 10-21
    Let imm_bits be (immediate bitwise_and 4095) shifted_left 10
    Set instruction to instruction bitwise_or imm_bits

    Note: Insert source register at bits 5-9
    Let src_bits be src_reg shifted_left 5
    Set instruction to instruction bitwise_or src_bits

    Note: Insert destination register at bits 0-4
    Set instruction to instruction bitwise_or dest_reg

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_sub_register" takes buffer_ptr as Integer, dest_reg as Integer, src_reg1 as Integer, src_reg2 as Integer returns Integer:
    Note: Encode SUB Xd, Xn, Xm
    Note: Subtract two registers
    Note: Base: 0xCB000000

    Let instruction be -889192448  Note: 0xCB000000

    Note: Insert src2 register at bits 16-20
    Let src2_bits be src_reg2 shifted_left 16
    Set instruction to instruction bitwise_or src2_bits

    Note: Insert src1 register at bits 5-9
    Let src1_bits be src_reg1 shifted_left 5
    Set instruction to instruction bitwise_or src1_bits

    Note: Insert destination register at bits 0-4
    Set instruction to instruction bitwise_or dest_reg

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_sub_immediate" takes buffer_ptr as Integer, dest_reg as Integer, src_reg as Integer, immediate as Integer returns Integer:
    Note: Encode SUB Xd, Xn, #imm
    Note: Subtract immediate value (12-bit unsigned)
    Note: Base: 0xD1000000

    Let instruction be -788529152  Note: 0xD1000000

    Note: Insert immediate (12 bits) at bits 10-21
    Let imm_bits be (immediate bitwise_and 4095) shifted_left 10
    Set instruction to instruction bitwise_or imm_bits

    Note: Insert source register at bits 5-9
    Let src_bits be src_reg shifted_left 5
    Set instruction to instruction bitwise_or src_bits

    Note: Insert destination register at bits 0-4
    Set instruction to instruction bitwise_or dest_reg

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_mul" takes buffer_ptr as Integer, dest_reg as Integer, src_reg1 as Integer, src_reg2 as Integer returns Integer:
    Note: Encode MUL Xd, Xn, Xm
    Note: Multiply two registers
    Note: MUL is alias for MADD Xd, Xn, Xm, XZR
    Note: Base: 0x9B007C00

    Let instruction be -1694455808  Note: 0x9B007C00

    Note: Insert src2 register at bits 16-20
    Let src2_bits be src_reg2 shifted_left 16
    Set instruction to instruction bitwise_or src2_bits

    Note: Insert src1 register at bits 5-9
    Let src1_bits be src_reg1 shifted_left 5
    Set instruction to instruction bitwise_or src1_bits

    Note: Insert destination register at bits 0-4
    Set instruction to instruction bitwise_or dest_reg

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_sdiv" takes buffer_ptr as Integer, dest_reg as Integer, src_reg1 as Integer, src_reg2 as Integer returns Integer:
    Note: Encode SDIV Xd, Xn, Xm
    Note: Signed divide
    Note: Base: 0x9AC00C00

    Let instruction be -1698971648  Note: 0x9AC00C00

    Note: Insert src2 register at bits 16-20
    Let src2_bits be src_reg2 shifted_left 16
    Set instruction to instruction bitwise_or src2_bits

    Note: Insert src1 register at bits 5-9
    Let src1_bits be src_reg1 shifted_left 5
    Set instruction to instruction bitwise_or src1_bits

    Note: Insert destination register at bits 0-4
    Set instruction to instruction bitwise_or dest_reg

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_udiv" takes buffer_ptr as Integer, dest_reg as Integer, src_reg1 as Integer, src_reg2 as Integer returns Integer:
    Note: Encode UDIV Xd, Xn, Xm
    Note: Unsigned divide
    Note: Base: 0x9AC00800

    Let instruction be -1698972672  Note: 0x9AC00800

    Note: Insert src2 register at bits 16-20
    Let src2_bits be src_reg2 shifted_left 16
    Set instruction to instruction bitwise_or src2_bits

    Note: Insert src1 register at bits 5-9
    Let src1_bits be src_reg1 shifted_left 5
    Set instruction to instruction bitwise_or src1_bits

    Note: Insert destination register at bits 0-4
    Set instruction to instruction bitwise_or dest_reg

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Note: ============================================================================
Note: LOGICAL INSTRUCTIONS
Note: ============================================================================

Process called "encode_and_register" takes buffer_ptr as Integer, dest_reg as Integer, src_reg1 as Integer, src_reg2 as Integer returns Integer:
    Note: Encode AND Xd, Xn, Xm
    Note: Bitwise AND
    Note: Base: 0x8A000000

    Let instruction be -1979711488  Note: 0x8A000000

    Note: Insert src2 register at bits 16-20
    Let src2_bits be src_reg2 shifted_left 16
    Set instruction to instruction bitwise_or src2_bits

    Note: Insert src1 register at bits 5-9
    Let src1_bits be src_reg1 shifted_left 5
    Set instruction to instruction bitwise_or src1_bits

    Note: Insert destination register at bits 0-4
    Set instruction to instruction bitwise_or dest_reg

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_orr_register" takes buffer_ptr as Integer, dest_reg as Integer, src_reg1 as Integer, src_reg2 as Integer returns Integer:
    Note: Encode ORR Xd, Xn, Xm
    Note: Bitwise OR
    Note: Base: 0xAA000000

    Let instruction be -1442775040  Note: 0xAA000000

    Note: Insert src2 register at bits 16-20
    Let src2_bits be src_reg2 shifted_left 16
    Set instruction to instruction bitwise_or src2_bits

    Note: Insert src1 register at bits 5-9
    Let src1_bits be src_reg1 shifted_left 5
    Set instruction to instruction bitwise_or src1_bits

    Note: Insert destination register at bits 0-4
    Set instruction to instruction bitwise_or dest_reg

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_eor_register" takes buffer_ptr as Integer, dest_reg as Integer, src_reg1 as Integer, src_reg2 as Integer returns Integer:
    Note: Encode EOR Xd, Xn, Xm
    Note: Bitwise exclusive OR
    Note: Base: 0xCA000000

    Let instruction be -905969664  Note: 0xCA000000

    Note: Insert src2 register at bits 16-20
    Let src2_bits be src_reg2 shifted_left 16
    Set instruction to instruction bitwise_or src2_bits

    Note: Insert src1 register at bits 5-9
    Let src1_bits be src_reg1 shifted_left 5
    Set instruction to instruction bitwise_or src1_bits

    Note: Insert destination register at bits 0-4
    Set instruction to instruction bitwise_or dest_reg

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Note: ============================================================================
Note: COMPARISON INSTRUCTIONS
Note: ============================================================================

Process called "encode_cmp_register" takes buffer_ptr as Integer, reg1 as Integer, reg2 as Integer returns Integer:
    Note: Encode CMP Xn, Xm
    Note: CMP is encoded as SUBS XZR, Xn, Xm
    Note: Base: 0xEB00001F

    Let instruction be -352092129  Note: 0xEB00001F

    Note: Insert reg2 at bits 16-20
    Let reg2_bits be reg2 shifted_left 16
    Set instruction to instruction bitwise_or reg2_bits

    Note: Insert reg1 at bits 5-9
    Let reg1_bits be reg1 shifted_left 5
    Set instruction to instruction bitwise_or reg1_bits

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_cmp_immediate" takes buffer_ptr as Integer, reg as Integer, immediate as Integer returns Integer:
    Note: Encode CMP Xn, #imm
    Note: CMP is encoded as SUBS XZR, Xn, #imm
    Note: Base: 0xF100001F

    Let instruction be -251395041  Note: 0xF100001F

    Note: Insert immediate (12 bits) at bits 10-21
    Let imm_bits be (immediate bitwise_and 4095) shifted_left 10
    Set instruction to instruction bitwise_or imm_bits

    Note: Insert register at bits 5-9
    Let reg_bits be reg shifted_left 5
    Set instruction to instruction bitwise_or reg_bits

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Note: ============================================================================
Note: CONTROL FLOW INSTRUCTIONS
Note: ============================================================================

Process called "encode_b" takes buffer_ptr as Integer, offset as Integer returns Integer:
    Note: Encode B label (unconditional branch)
    Note: offset is in bytes, will be divided by 4 for instruction encoding
    Note: Range: ±128MB (26-bit signed offset)
    Note: Base: 0x14000000

    Let instruction be 335544320  Note: 0x14000000

    Note: Convert byte offset to instruction offset
    Let instr_offset be offset divided by 4

    Note: Insert 26-bit signed offset
    Let offset_bits be instr_offset bitwise_and 67108863
    Set instruction to instruction bitwise_or offset_bits

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_b_cond" takes buffer_ptr as Integer, condition as Integer, offset as Integer returns Integer:
    Note: Encode B.cond label (conditional branch)
    Note: condition: 0=EQ, 1=NE, 11=LT, 13=LE, 12=GT, 10=GE
    Note: offset is in bytes, will be divided by 4 for instruction encoding
    Note: Range: ±1MB (19-bit signed offset)
    Note: Base: 0x54000000

    Let instruction be 1409286144  Note: 0x54000000

    Note: Insert condition code at bits 0-3
    Set instruction to instruction bitwise_or condition

    Note: Convert byte offset to instruction offset
    Let instr_offset be offset divided by 4

    Note: Insert 19-bit signed offset at bits 5-23
    Let offset_bits be (instr_offset bitwise_and 524287) shifted_left 5
    Set instruction to instruction bitwise_or offset_bits

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_bl" takes buffer_ptr as Integer, offset as Integer returns Integer:
    Note: Encode BL label (branch with link, function call)
    Note: Stores return address in X30 (LR)
    Note: offset is in bytes, will be divided by 4 for instruction encoding
    Note: Range: ±128MB (26-bit signed offset)
    Note: Base: 0x94000000

    Let instruction be -1811939328  Note: 0x94000000

    Note: Convert byte offset to instruction offset
    Let instr_offset be offset divided by 4

    Note: Insert 26-bit signed offset
    Let offset_bits be instr_offset bitwise_and 67108863
    Set instruction to instruction bitwise_or offset_bits

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_br" takes buffer_ptr as Integer, reg as Integer returns Integer:
    Note: Encode BR Xn (branch to register)
    Note: Base: 0xD61F0000

    Let instruction be -698933248  Note: 0xD61F0000

    Note: Insert register at bits 5-9
    Let reg_bits be reg shifted_left 5
    Set instruction to instruction bitwise_or reg_bits

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_blr" takes buffer_ptr as Integer, reg as Integer returns Integer:
    Note: Encode BLR Xn (branch with link to register, indirect call)
    Note: Base: 0xD63F0000

    Let instruction be -699457536  Note: 0xD63F0000

    Note: Insert register at bits 5-9
    Let reg_bits be reg shifted_left 5
    Set instruction to instruction bitwise_or reg_bits

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_ret" takes buffer_ptr as Integer returns Integer:
    Note: Encode RET (return from subroutine)
    Note: Returns to address in X30 (LR)
    Note: Fixed encoding: 0xD65F03C0

    Let instruction be -699457600  Note: 0xD65F03C0

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Note: ============================================================================
Note: SHIFT INSTRUCTIONS
Note: ============================================================================

Process called "encode_lsl" takes buffer_ptr as Integer, dest_reg as Integer, src_reg as Integer, shift_amount as Integer returns Integer:
    Note: Encode LSL Xd, Xn, #shift (logical shift left)
    Note: LSL is alias for UBFM with specific parameters
    Note: Base: 0xD3400000

    Let instruction be -745193472  Note: 0xD3400000

    Note: Insert shift amount parameters
    Note: For LSL: immr = -shift_amount mod 64, imms = 63 - shift_amount
    Let immr be (0 minus shift_amount) bitwise_and 63
    Let imms be 63 minus shift_amount

    Let immr_bits be immr shifted_left 16
    Let imms_bits be imms shifted_left 10

    Set instruction to instruction bitwise_or immr_bits
    Set instruction to instruction bitwise_or imms_bits

    Note: Insert source register at bits 5-9
    Let src_bits be src_reg shifted_left 5
    Set instruction to instruction bitwise_or src_bits

    Note: Insert destination register at bits 0-4
    Set instruction to instruction bitwise_or dest_reg

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_lsr" takes buffer_ptr as Integer, dest_reg as Integer, src_reg as Integer, shift_amount as Integer returns Integer:
    Note: Encode LSR Xd, Xn, #shift (logical shift right)
    Note: LSR is alias for UBFM with specific parameters
    Note: Base: 0xD340FC00

    Let instruction be -744914944  Note: 0xD340FC00

    Note: Insert shift amount at bits 16-21 (immr field)
    Let shift_bits be shift_amount shifted_left 16
    Set instruction to instruction bitwise_or shift_bits

    Note: Insert source register at bits 5-9
    Let src_bits be src_reg shifted_left 5
    Set instruction to instruction bitwise_or src_bits

    Note: Insert destination register at bits 0-4
    Set instruction to instruction bitwise_or dest_reg

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_asr" takes buffer_ptr as Integer, dest_reg as Integer, src_reg as Integer, shift_amount as Integer returns Integer:
    Note: Encode ASR Xd, Xn, #shift (arithmetic shift right)
    Note: ASR is alias for SBFM with specific parameters
    Note: Base: 0x9340FC00

    Let instruction be -1822154752  Note: 0x9340FC00

    Note: Insert shift amount at bits 16-21 (immr field)
    Let shift_bits be shift_amount shifted_left 16
    Set instruction to instruction bitwise_or shift_bits

    Note: Insert source register at bits 5-9
    Let src_bits be src_reg shifted_left 5
    Set instruction to instruction bitwise_or src_bits

    Note: Insert destination register at bits 0-4
    Set instruction to instruction bitwise_or dest_reg

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Note: ============================================================================
Note: SYSTEM INSTRUCTIONS
Note: ============================================================================

Process called "encode_svc" takes buffer_ptr as Integer, immediate as Integer returns Integer:
    Note: Encode SVC #imm (supervisor call, system call)
    Note: immediate: 16-bit value (usually 0 for syscalls)
    Note: Base: 0xD4000001

    Let instruction be -738197503  Note: 0xD4000001

    Note: Insert immediate at bits 5-20
    Let imm_bits be (immediate bitwise_and 65535) shifted_left 5
    Set instruction to instruction bitwise_or imm_bits

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_nop" takes buffer_ptr as Integer returns Integer:
    Note: Encode NOP (no operation)
    Note: Fixed encoding: 0xD503201F

    Let instruction be -738132961  Note: 0xD503201F

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Note: ============================================================================
Note: CODE ALIGNMENT AND PADDING
Note: ============================================================================

Process called "align_code_to_boundary" takes buffer_ptr as Integer, current_offset as Integer, alignment as Integer returns Integer:
    Note: Align code pointer to specified boundary (4, 8, 16 bytes)
    Note: Fills with NOP instructions (0xD503201F)
    Note: Returns new offset after alignment

    Let remainder be current_offset bitwise_and (alignment minus 1)
    If remainder is equal to 0:
        Return current_offset  Note: Already aligned
    End If

    Note: Calculate padding needed
    Let padding_bytes be alignment minus remainder

    Note: Fill with NOP instructions (4 bytes each)
    Let offset be current_offset
    Let nops_needed be padding_bytes divided by 4

    Let i be 0
    While i is less than nops_needed:
        Set offset to encode_nop(buffer_ptr plus offset)
        Set i to i plus 1
    End While

    Return offset
End Process

Process called "get_instruction_size" returns Integer:
    Note: Get size of single ARM64 instruction
    Return 4  Note: All ARM64 instructions are 4 bytes
End Process
