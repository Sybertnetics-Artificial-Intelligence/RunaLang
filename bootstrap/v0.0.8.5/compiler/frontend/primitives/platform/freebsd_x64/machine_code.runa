Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
FreeBSD x86_64 Machine Code Generation

This file implements x86_64 machine code encoding for the Runa compiler.

Platform-specific details:
- OS: FreeBSD
- Architecture: x86_64 (AMD64)
- Instruction format: Variable-length (1-15 bytes)
- Encoding: Little-endian
- Instruction structure: [Prefixes] [REX] [Opcode] [ModR/M] [SIB] [Displacement] [Immediate]

x86_64 instruction encoding:
- Variable length: 1-15 bytes per instruction
- Byte order: Little-endian
- REX prefix: 0x40-0x4F for 64-bit operands and extended registers
- ModR/M byte: Encodes register/memory operand addressing
- SIB byte: Encodes scaled index addressing (optional)
- Displacement: 1, 2, or 4 byte offset (optional)
- Immediate: 1, 2, 4, or 8 byte constant (optional)

This implementation provides core instruction encoders for:
- Data movement (MOV, MOVQ, LEA)
- Arithmetic (ADD, SUB, IMUL, IDIV)
- Logic (AND, OR, XOR, NOT)
- Control flow (JMP, JE, JNE, CALL, RET)
- Stack operations (PUSH, POP)
- System calls (SYSCALL)

Dependencies: registers.runa for register number mappings
:End Note

Import "compiler/frontend/primitives/platform/freebsd_x64/registers.runa" as Registers
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Note: ============================================================================
Note: REX PREFIX ENCODING
Note: ============================================================================
Note: REX prefix: 0100WRXB (0x40 - 0x4F)
Note:   W bit (0x08): 1 = 64-bit operand size, 0 = default
Note:   R bit (0x04): Extension of ModR/M reg field
Note:   X bit (0x02): Extension of SIB index field
Note:   B bit (0x01): Extension of ModR/M r/m field, SIB base, or opcode reg

Process called "encode_rex" takes w as Integer, r as Integer, x as Integer, b as Integer returns Integer:
    Note: Encode REX prefix byte
    Note: w: 64-bit operand (1 for QWORD)
    Note: r: ModR/M reg extension (bit 3 of register number)
    Note: x: SIB index extension (bit 3 of index register)
    Note: b: ModR/M r/m or base extension (bit 3 of base register)

    Let rex be 64  Note: 0x40 base

    If w is equal to 1:
        Set rex to rex plus 8  Note: Set W bit
    End If

    If r is equal to 1:
        Set rex to rex plus 4  Note: Set R bit
    End If

    If x is equal to 1:
        Set rex to rex plus 2  Note: Set X bit
    End If

    If b is equal to 1:
        Set rex to rex plus 1  Note: Set B bit
    End If

    Return rex
End Process

Process called "get_rex_r_bit" takes reg_num as Integer returns Integer:
    Note: Get R bit from register number (bit 3)
    If reg_num is greater than or equal to 8:
        Return 1
    End If
    Return 0
End Process

Process called "get_rex_b_bit" takes reg_num as Integer returns Integer:
    Note: Get B bit from register number (bit 3)
    If reg_num is greater than or equal to 8:
        Return 1
    End If
    Return 0
End Process

Process called "get_low_3_bits" takes reg_num as Integer returns Integer:
    Note: Get lower 3 bits of register number for ModR/M encoding
    Return reg_num bitwise_and 7
End Process

Note: ============================================================================
Note: MODR/M BYTE ENCODING
Note: ============================================================================
Note: ModR/M byte: MMRRRMMM
Note:   MM (mod): Addressing mode (00=indirect, 01=disp8, 10=disp32, 11=register)
Note:   RRR (reg): Register or opcode extension (3 bits)
Note:   MMM (r/m): Register or memory operand (3 bits)

Process called "encode_modrm" takes mod as Integer, reg as Integer, rm as Integer returns Integer:
    Note: Encode ModR/M byte
    Note: mod: Addressing mode (0-3)
    Note: reg: Register field (0-7, lower 3 bits)
    Note: rm: R/M field (0-7, lower 3 bits)

    Let modrm be mod multiplied by 64  Note: Shift mod to bits 6-7
    Set modrm to modrm plus (reg multiplied by 8)  Note: Shift reg to bits 3-5
    Set modrm to modrm plus rm  Note: R/M in bits 0-2

    Return modrm
End Process

Note: ============================================================================
Note: INSTRUCTION BUFFER MANAGEMENT
Note: ============================================================================
Note: We allocate a buffer for encoding instructions
Note: Maximum x86_64 instruction length is 15 bytes

Process called "allocate_instruction_buffer" returns Integer:
    Note: Allocate 16-byte buffer for encoded instruction
    Let buffer_ptr be Memory.allocate(16)
    Return buffer_ptr
End Process

Process called "write_byte_to_buffer" takes buffer_ptr as Integer, offset as Integer, byte_value as Integer returns Integer:
    Note: Write byte to instruction buffer at offset
    Memory.memory_set_byte(buffer_ptr, offset, byte_value)
    Return offset plus 1  Note: Return next offset
End Process

Note: ============================================================================
Note: MOV INSTRUCTION ENCODERS
Note: ============================================================================

Process called "encode_mov_reg_to_reg_64" takes dest_reg as Integer, src_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: MOVQ src_reg, dest_reg (64-bit register to register)
    Note: Opcode: REX.W + 89 /r (MOV r/m64, r64)
    Note: Example: movq %rax, %rbx encodes as: 48 89 C3

    Let offset be 0

    Note: REX.W prefix for 64-bit operand
    Let rex_r be get_rex_r_bit(src_reg)
    Let rex_b be get_rex_b_bit(dest_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Note: Opcode: 0x89 (MOV r/m64, r64)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 137)  Note: 0x89

    Note: ModR/M byte: mod=11 (register), reg=src, r/m=dest
    Let src_low be get_low_3_bits(src_reg)
    Let dest_low be get_low_3_bits(dest_reg)
    Let modrm be encode_modrm(3, src_low, dest_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset  Note: Return instruction length
End Process

Process called "encode_mov_imm_to_reg_64" takes reg as Integer, immediate as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: MOVQ $immediate, reg (64-bit immediate to register)
    Note: Opcode: REX.W + B8+rd id (MOV r64, imm64)
    Note: Example: movq $123, %rax encodes as: 48 B8 7B 00 00 00 00 00 00 00

    Let offset be 0

    Note: REX.W prefix
    Let rex_b be get_rex_b_bit(reg)
    Let rex_byte be encode_rex(1, 0, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Note: Opcode: 0xB8 + register encoding
    Let reg_low be get_low_3_bits(reg)
    Let opcode be 184 plus reg_low  Note: 0xB8 + rd
    Set offset to write_byte_to_buffer(buffer_ptr, offset, opcode)

    Note: 8-byte immediate (little-endian)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, immediate bitwise_and 255)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, (immediate shifted right by 8) bitwise_and 255)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, (immediate shifted right by 16) bitwise_and 255)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, (immediate shifted right by 24) bitwise_and 255)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, (immediate shifted right by 32) bitwise_and 255)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, (immediate shifted right by 40) bitwise_and 255)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, (immediate shifted right by 48) bitwise_and 255)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, (immediate shifted right by 56) bitwise_and 255)

    Return offset  Note: Return instruction length (10 bytes)
End Process

Process called "encode_mov_mem_to_reg_64" takes dest_reg as Integer, base_reg as Integer, displacement as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: MOVQ displacement(base_reg), dest_reg
    Note: Opcode: REX.W + 8B /r (MOV r64, r/m64)
    Note: Example: movq 8(%rbp), %rax encodes as: 48 8B 45 08

    Let offset be 0

    Note: REX.W prefix
    Let rex_r be get_rex_r_bit(dest_reg)
    Let rex_b be get_rex_b_bit(base_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Note: Opcode: 0x8B (MOV r64, r/m64)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 139)  Note: 0x8B

    Note: ModR/M byte with 8-bit displacement
    Let dest_low be get_low_3_bits(dest_reg)
    Let base_low be get_low_3_bits(base_reg)
    Let modrm be encode_modrm(1, dest_low, base_low)  Note: mod=01 for disp8
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Note: 8-bit displacement
    Set offset to write_byte_to_buffer(buffer_ptr, offset, displacement bitwise_and 255)

    Return offset
End Process

Process called "encode_mov_reg_to_mem_64" takes src_reg as Integer, base_reg as Integer, displacement as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: MOVQ src_reg, displacement(base_reg)
    Note: Opcode: REX.W + 89 /r (MOV r/m64, r64)
    Note: Example: movq %rax, 8(%rbp) encodes as: 48 89 45 08

    Let offset be 0

    Note: REX.W prefix
    Let rex_r be get_rex_r_bit(src_reg)
    Let rex_b be get_rex_b_bit(base_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Note: Opcode: 0x89 (MOV r/m64, r64)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 137)  Note: 0x89

    Note: ModR/M byte with 8-bit displacement
    Let src_low be get_low_3_bits(src_reg)
    Let base_low be get_low_3_bits(base_reg)
    Let modrm be encode_modrm(1, src_low, base_low)  Note: mod=01 for disp8
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Note: 8-bit displacement
    Set offset to write_byte_to_buffer(buffer_ptr, offset, displacement bitwise_and 255)

    Return offset
End Process

Note: ============================================================================
Note: ARITHMETIC INSTRUCTION ENCODERS
Note: ============================================================================

Process called "encode_add_reg_to_reg_64" takes dest_reg as Integer, src_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: ADDQ src_reg, dest_reg
    Note: Opcode: REX.W + 01 /r (ADD r/m64, r64)

    Let offset be 0

    Note: REX.W prefix
    Let rex_r be get_rex_r_bit(src_reg)
    Let rex_b be get_rex_b_bit(dest_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Note: Opcode: 0x01 (ADD r/m64, r64)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 1)

    Note: ModR/M byte
    Let src_low be get_low_3_bits(src_reg)
    Let dest_low be get_low_3_bits(dest_reg)
    Let modrm be encode_modrm(3, src_low, dest_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_sub_reg_from_reg_64" takes dest_reg as Integer, src_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: SUBQ src_reg, dest_reg
    Note: Opcode: REX.W + 29 /r (SUB r/m64, r64)

    Let offset be 0

    Note: REX.W prefix
    Let rex_r be get_rex_r_bit(src_reg)
    Let rex_b be get_rex_b_bit(dest_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Note: Opcode: 0x29 (SUB r/m64, r64)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 41)  Note: 0x29

    Note: ModR/M byte
    Let src_low be get_low_3_bits(src_reg)
    Let dest_low be get_low_3_bits(dest_reg)
    Let modrm be encode_modrm(3, src_low, dest_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_imul_reg_reg_64" takes dest_reg as Integer, src_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: IMULQ src_reg, dest_reg (signed multiply)
    Note: Opcode: REX.W + 0F AF /r (IMUL r64, r/m64)

    Let offset be 0

    Note: REX.W prefix
    Let rex_r be get_rex_r_bit(dest_reg)
    Let rex_b be get_rex_b_bit(src_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Note: Two-byte opcode: 0x0F 0xAF
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 175)  Note: 0xAF

    Note: ModR/M byte
    Let dest_low be get_low_3_bits(dest_reg)
    Let src_low be get_low_3_bits(src_reg)
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Note: ============================================================================
Note: CONTROL FLOW INSTRUCTION ENCODERS
Note: ============================================================================

Process called "encode_jmp_rel8" takes rel_offset as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: JMP rel8 (short jump, -128 to +127)
    Note: Opcode: EB cb

    Let offset be 0

    Note: Opcode: 0xEB
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 235)  Note: 0xEB

    Note: Relative 8-bit offset
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rel_offset bitwise_and 255)

    Return offset
End Process

Process called "encode_jmp_rel32" takes rel_offset as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: JMP rel32 (near jump, -2GB to +2GB)
    Note: Opcode: E9 cd

    Let offset be 0

    Note: Opcode: 0xE9
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 233)  Note: 0xE9

    Note: Relative 32-bit offset (little-endian)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rel_offset bitwise_and 255)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, (rel_offset shifted right by 8) bitwise_and 255)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, (rel_offset shifted right by 16) bitwise_and 255)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, (rel_offset shifted right by 24) bitwise_and 255)

    Return offset
End Process

Process called "encode_je_rel8" takes rel_offset as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: JE rel8 (jump if equal, ZF=1)
    Note: Opcode: 74 cb

    Let offset be 0

    Note: Opcode: 0x74
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 116)  Note: 0x74

    Note: Relative 8-bit offset
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rel_offset bitwise_and 255)

    Return offset
End Process

Process called "encode_jne_rel8" takes rel_offset as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: JNE rel8 (jump if not equal, ZF=0)
    Note: Opcode: 75 cb

    Let offset be 0

    Note: Opcode: 0x75
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 117)  Note: 0x75

    Note: Relative 8-bit offset
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rel_offset bitwise_and 255)

    Return offset
End Process

Process called "encode_call_rel32" takes rel_offset as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: CALL rel32 (near call)
    Note: Opcode: E8 cd

    Let offset be 0

    Note: Opcode: 0xE8
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 232)  Note: 0xE8

    Note: Relative 32-bit offset (little-endian)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rel_offset bitwise_and 255)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, (rel_offset shifted right by 8) bitwise_and 255)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, (rel_offset shifted right by 16) bitwise_and 255)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, (rel_offset shifted right by 24) bitwise_and 255)

    Return offset
End Process

Process called "encode_ret" takes buffer_ptr as Integer returns Integer:
    Note: Encode: RET (near return)
    Note: Opcode: C3

    Let offset be 0

    Note: Opcode: 0xC3
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 195)  Note: 0xC3

    Return offset
End Process

Note: ============================================================================
Note: STACK OPERATION ENCODERS
Note: ============================================================================

Process called "encode_push_reg_64" takes reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: PUSHQ reg
    Note: Opcode: REX.W + 50+rd (PUSH r64) if reg >= 8, else just 50+rd

    Let offset be 0

    Note: REX prefix only needed for extended registers (R8-R15)
    If reg is greater than or equal to 8:
        Let rex_byte be encode_rex(0, 0, 0, 1)  Note: REX.B for extended register
        Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
    End If

    Note: Opcode: 0x50 + register encoding
    Let reg_low be get_low_3_bits(reg)
    Let opcode be 80 plus reg_low  Note: 0x50 + rd
    Set offset to write_byte_to_buffer(buffer_ptr, offset, opcode)

    Return offset
End Process

Process called "encode_pop_reg_64" takes reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: POPQ reg
    Note: Opcode: REX.W + 58+rd (POP r64) if reg >= 8, else just 58+rd

    Let offset be 0

    Note: REX prefix only needed for extended registers (R8-R15)
    If reg is greater than or equal to 8:
        Let rex_byte be encode_rex(0, 0, 0, 1)  Note: REX.B for extended register
        Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
    End If

    Note: Opcode: 0x58 + register encoding
    Let reg_low be get_low_3_bits(reg)
    Let opcode be 88 plus reg_low  Note: 0x58 + rd
    Set offset to write_byte_to_buffer(buffer_ptr, offset, opcode)

    Return offset
End Process

Note: ============================================================================
Note: SYSTEM CALL ENCODER
Note: ============================================================================

Process called "encode_syscall" takes buffer_ptr as Integer returns Integer:
    Note: Encode: SYSCALL (invoke system call)
    Note: Opcode: 0F 05
    Note: Invokes OS kernel via fast system call mechanism

    Let offset be 0

    Note: Two-byte opcode: 0x0F 0x05
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 5)  Note: 0x05

    Return offset
End Process

Note: ============================================================================
Note: MISC INSTRUCTIONS
Note: ============================================================================

Process called "encode_nop" takes buffer_ptr as Integer returns Integer:
    Note: Encode: NOP (no operation)
    Note: Opcode: 90 (one-byte NOP)

    Let offset be 0

    Note: Opcode: 0x90
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 144)  Note: 0x90

    Return offset
End Process

Process called "encode_cmp_reg_reg_64" takes reg1 as Integer, reg2 as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: CMPQ reg2, reg1 (compare and set flags)
    Note: Opcode: REX.W + 39 /r (CMP r/m64, r64)

    Let offset be 0

    Note: REX.W prefix
    Let rex_r be get_rex_r_bit(reg2)
    Let rex_b be get_rex_b_bit(reg1)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Note: Opcode: 0x39 (CMP r/m64, r64)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 57)  Note: 0x39

    Note: ModR/M byte
    Let reg2_low be get_low_3_bits(reg2)
    Let reg1_low be get_low_3_bits(reg1)
    Let modrm be encode_modrm(3, reg2_low, reg1_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Note: ============================================================================
Note: MORE ARITHMETIC OPERATIONS
Note: ============================================================================

Process called "encode_and_reg_to_reg_64" takes dest_reg as Integer, src_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: AND src_reg, dest_reg (bitwise AND)
    Note: Opcode: REX.W + 21 /r (AND r/m64, r64)

    Let offset be 0

    Let rex_r be get_rex_r_bit(src_reg)
    Let rex_b be get_rex_b_bit(dest_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 33)  Note: 0x21

    Let src_low be get_low_3_bits(src_reg)
    Let dest_low be get_low_3_bits(dest_reg)
    Let modrm be encode_modrm(3, src_low, dest_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_or_reg_to_reg_64" takes dest_reg as Integer, src_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: OR src_reg, dest_reg (bitwise OR)
    Note: Opcode: REX.W + 09 /r (OR r/m64, r64)

    Let offset be 0

    Let rex_r be get_rex_r_bit(src_reg)
    Let rex_b be get_rex_b_bit(dest_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 9)  Note: 0x09

    Let src_low be get_low_3_bits(src_reg)
    Let dest_low be get_low_3_bits(dest_reg)
    Let modrm be encode_modrm(3, src_low, dest_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_xor_reg_to_reg_64" takes dest_reg as Integer, src_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: XOR src_reg, dest_reg (bitwise XOR)
    Note: Opcode: REX.W + 31 /r (XOR r/m64, r64)
    Note: Common idiom: XOR reg, reg to zero a register (breaks dependencies)

    Let offset be 0

    Let rex_r be get_rex_r_bit(src_reg)
    Let rex_b be get_rex_b_bit(dest_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 49)  Note: 0x31

    Let src_low be get_low_3_bits(src_reg)
    Let dest_low be get_low_3_bits(dest_reg)
    Let modrm be encode_modrm(3, src_low, dest_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_not_reg_64" takes reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: NOT reg (bitwise NOT, one's complement)
    Note: Opcode: REX.W + F7 /2 (NOT r/m64)

    Let offset be 0

    Let rex_b be get_rex_b_bit(reg)
    Let rex_byte be encode_rex(1, 0, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 247)  Note: 0xF7

    Let reg_low be get_low_3_bits(reg)
    Let modrm be encode_modrm(3, 2, reg_low)  Note: /2 opcode extension
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_neg_reg_64" takes reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: NEG reg (two's complement negation)
    Note: Opcode: REX.W + F7 /3 (NEG r/m64)

    Let offset be 0

    Let rex_b be get_rex_b_bit(reg)
    Let rex_byte be encode_rex(1, 0, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 247)  Note: 0xF7

    Let reg_low be get_low_3_bits(reg)
    Let modrm be encode_modrm(3, 3, reg_low)  Note: /3 opcode extension
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_inc_reg_64" takes reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: INC reg (increment by 1)
    Note: Opcode: REX.W + FF /0 (INC r/m64)

    Let offset be 0

    Let rex_b be get_rex_b_bit(reg)
    Let rex_byte be encode_rex(1, 0, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 255)  Note: 0xFF

    Let reg_low be get_low_3_bits(reg)
    Let modrm be encode_modrm(3, 0, reg_low)  Note: /0 opcode extension
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_dec_reg_64" takes reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: DEC reg (decrement by 1)
    Note: Opcode: REX.W + FF /1 (DEC r/m64)

    Let offset be 0

    Let rex_b be get_rex_b_bit(reg)
    Let rex_byte be encode_rex(1, 0, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 255)  Note: 0xFF

    Let reg_low be get_low_3_bits(reg)
    Let modrm be encode_modrm(3, 1, reg_low)  Note: /1 opcode extension
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_mul_reg_64" takes reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: MUL reg (unsigned multiply RDX:RAX = RAX * reg)
    Note: Opcode: REX.W + F7 /4 (MUL r/m64)

    Let offset be 0

    Let rex_b be get_rex_b_bit(reg)
    Let rex_byte be encode_rex(1, 0, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 247)  Note: 0xF7

    Let reg_low be get_low_3_bits(reg)
    Let modrm be encode_modrm(3, 4, reg_low)  Note: /4 opcode extension
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_div_reg_64" takes reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: DIV reg (unsigned divide RDX:RAX / reg)
    Note: Opcode: REX.W + F7 /6 (DIV r/m64)
    Note: Result: RAX = quotient, RDX = remainder

    Let offset be 0

    Let rex_b be get_rex_b_bit(reg)
    Let rex_byte be encode_rex(1, 0, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 247)  Note: 0xF7

    Let reg_low be get_low_3_bits(reg)
    Let modrm be encode_modrm(3, 6, reg_low)  Note: /6 opcode extension
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_idiv_reg_64" takes reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: IDIV reg (signed divide RDX:RAX / reg)
    Note: Opcode: REX.W + F7 /7 (IDIV r/m64)
    Note: Result: RAX = quotient, RDX = remainder

    Let offset be 0

    Let rex_b be get_rex_b_bit(reg)
    Let rex_byte be encode_rex(1, 0, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 247)  Note: 0xF7

    Let reg_low be get_low_3_bits(reg)
    Let modrm be encode_modrm(3, 7, reg_low)  Note: /7 opcode extension
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Note: ============================================================================
Note: SHIFT AND ROTATE OPERATIONS
Note: ============================================================================

Process called "encode_shl_reg_cl_64" takes reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: SHL reg, CL (shift left by CL register)
    Note: Opcode: REX.W + D3 /4 (SHL r/m64, CL)

    Let offset be 0

    Let rex_b be get_rex_b_bit(reg)
    Let rex_byte be encode_rex(1, 0, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 211)  Note: 0xD3

    Let reg_low be get_low_3_bits(reg)
    Let modrm be encode_modrm(3, 4, reg_low)  Note: /4 opcode extension
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_shr_reg_cl_64" takes reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: SHR reg, CL (shift right logical by CL register)
    Note: Opcode: REX.W + D3 /5 (SHR r/m64, CL)

    Let offset be 0

    Let rex_b be get_rex_b_bit(reg)
    Let rex_byte be encode_rex(1, 0, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 211)  Note: 0xD3

    Let reg_low be get_low_3_bits(reg)
    Let modrm be encode_modrm(3, 5, reg_low)  Note: /5 opcode extension
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_sar_reg_cl_64" takes reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: SAR reg, CL (shift right arithmetic by CL register)
    Note: Opcode: REX.W + D3 /7 (SAR r/m64, CL)
    Note: Preserves sign bit during shift

    Let offset be 0

    Let rex_b be get_rex_b_bit(reg)
    Let rex_byte be encode_rex(1, 0, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 211)  Note: 0xD3

    Let reg_low be get_low_3_bits(reg)
    Let modrm be encode_modrm(3, 7, reg_low)  Note: /7 opcode extension
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_rol_reg_cl_64" takes reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: ROL reg, CL (rotate left by CL register)
    Note: Opcode: REX.W + D3 /0 (ROL r/m64, CL)

    Let offset be 0

    Let rex_b be get_rex_b_bit(reg)
    Let rex_byte be encode_rex(1, 0, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 211)  Note: 0xD3

    Let reg_low be get_low_3_bits(reg)
    Let modrm be encode_modrm(3, 0, reg_low)  Note: /0 opcode extension
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_ror_reg_cl_64" takes reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: ROR reg, CL (rotate right by CL register)
    Note: Opcode: REX.W + D3 /1 (ROR r/m64, CL)

    Let offset be 0

    Let rex_b be get_rex_b_bit(reg)
    Let rex_byte be encode_rex(1, 0, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 211)  Note: 0xD3

    Let reg_low be get_low_3_bits(reg)
    Let modrm be encode_modrm(3, 1, reg_low)  Note: /1 opcode extension
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Note: ============================================================================
Note: MORE CONDITIONAL JUMPS
Note: ============================================================================

Process called "encode_jl_rel8" takes rel_offset as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: JL rel8 (jump if less, SF != OF)
    Note: Opcode: 7C cb

    Let offset be 0
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 124)  Note: 0x7C
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rel_offset bitwise_and 255)
    Return offset
End Process

Process called "encode_jle_rel8" takes rel_offset as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: JLE rel8 (jump if less or equal, ZF=1 OR SF != OF)
    Note: Opcode: 7E cb

    Let offset be 0
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 126)  Note: 0x7E
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rel_offset bitwise_and 255)
    Return offset
End Process

Process called "encode_jg_rel8" takes rel_offset as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: JG rel8 (jump if greater, ZF=0 AND SF=OF)
    Note: Opcode: 7F cb

    Let offset be 0
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 127)  Note: 0x7F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rel_offset bitwise_and 255)
    Return offset
End Process

Process called "encode_jge_rel8" takes rel_offset as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: JGE rel8 (jump if greater or equal, SF=OF)
    Note: Opcode: 7D cb

    Let offset be 0
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 125)  Note: 0x7D
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rel_offset bitwise_and 255)
    Return offset
End Process

Process called "encode_ja_rel8" takes rel_offset as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: JA rel8 (jump if above, unsigned CF=0 AND ZF=0)
    Note: Opcode: 77 cb

    Let offset be 0
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 119)  Note: 0x77
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rel_offset bitwise_and 255)
    Return offset
End Process

Process called "encode_jae_rel8" takes rel_offset as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: JAE rel8 (jump if above or equal, unsigned CF=0)
    Note: Opcode: 73 cb

    Let offset be 0
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 115)  Note: 0x73
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rel_offset bitwise_and 255)
    Return offset
End Process

Process called "encode_jb_rel8" takes rel_offset as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: JB rel8 (jump if below, unsigned CF=1)
    Note: Opcode: 72 cb

    Let offset be 0
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 114)  Note: 0x72
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rel_offset bitwise_and 255)
    Return offset
End Process

Process called "encode_jbe_rel8" takes rel_offset as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: JBE rel8 (jump if below or equal, unsigned CF=1 OR ZF=1)
    Note: Opcode: 76 cb

    Let offset be 0
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 118)  Note: 0x76
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rel_offset bitwise_and 255)
    Return offset
End Process

Process called "encode_js_rel8" takes rel_offset as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: JS rel8 (jump if sign, SF=1)
    Note: Opcode: 78 cb

    Let offset be 0
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 120)  Note: 0x78
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rel_offset bitwise_and 255)
    Return offset
End Process

Process called "encode_jns_rel8" takes rel_offset as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: JNS rel8 (jump if not sign, SF=0)
    Note: Opcode: 79 cb

    Let offset be 0
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 121)  Note: 0x79
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rel_offset bitwise_and 255)
    Return offset
End Process

Process called "encode_jo_rel8" takes rel_offset as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: JO rel8 (jump if overflow, OF=1)
    Note: Opcode: 70 cb

    Let offset be 0
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 112)  Note: 0x70
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rel_offset bitwise_and 255)
    Return offset
End Process

Process called "encode_jno_rel8" takes rel_offset as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: JNO rel8 (jump if not overflow, OF=0)
    Note: Opcode: 71 cb

    Let offset be 0
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 113)  Note: 0x71
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rel_offset bitwise_and 255)
    Return offset
End Process

Note: ============================================================================
Note: LEA INSTRUCTION (Load Effective Address)
Note: ============================================================================

Process called "encode_lea_64" takes dest_reg as Integer, base_reg as Integer, displacement as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: LEA dest_reg, [base_reg + displacement]
    Note: Opcode: REX.W + 8D /r (LEA r64, m)
    Note: Computes address without memory access (used for arithmetic)

    Let offset be 0

    Let rex_r be get_rex_r_bit(dest_reg)
    Let rex_b be get_rex_b_bit(base_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 141)  Note: 0x8D

    Let dest_low be get_low_3_bits(dest_reg)
    Let base_low be get_low_3_bits(base_reg)
    Let modrm be encode_modrm(1, dest_low, base_low)  Note: mod=01 for disp8
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, displacement bitwise_and 255)

    Return offset
End Process

Note: ============================================================================
Note: MOV VARIANTS (Zero/Sign Extend)
Note: ============================================================================

Process called "encode_movzx_byte_to_reg_64" takes dest_reg as Integer, src_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: MOVZX dest_reg, src_reg_byte (zero-extend byte to 64-bit)
    Note: Opcode: REX.W + 0F B6 /r (MOVZX r64, r/m8)

    Let offset be 0

    Let rex_r be get_rex_r_bit(dest_reg)
    Let rex_b be get_rex_b_bit(src_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 182)  Note: 0xB6

    Let dest_low be get_low_3_bits(dest_reg)
    Let src_low be get_low_3_bits(src_reg)
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_movsx_byte_to_reg_64" takes dest_reg as Integer, src_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: MOVSX dest_reg, src_reg_byte (sign-extend byte to 64-bit)
    Note: Opcode: REX.W + 0F BE /r (MOVSX r64, r/m8)

    Let offset be 0

    Let rex_r be get_rex_r_bit(dest_reg)
    Let rex_b be get_rex_b_bit(src_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 190)  Note: 0xBE

    Let dest_low be get_low_3_bits(dest_reg)
    Let src_low be get_low_3_bits(src_reg)
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Note: ============================================================================
Note: ATOMIC OPERATIONS
Note: ============================================================================

Process called "encode_xchg_reg_reg_64" takes reg1 as Integer, reg2 as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: XCHG reg1, reg2 (exchange register values)
    Note: Opcode: REX.W + 87 /r (XCHG r/m64, r64)
    Note: Atomic when used with memory operand

    Let offset be 0

    Let rex_r be get_rex_r_bit(reg2)
    Let rex_b be get_rex_b_bit(reg1)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 135)  Note: 0x87

    Let reg2_low be get_low_3_bits(reg2)
    Let reg1_low be get_low_3_bits(reg1)
    Let modrm be encode_modrm(3, reg2_low, reg1_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_cmpxchg_mem_reg_64" takes base_reg as Integer, displacement as Integer, src_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: CMPXCHG [base_reg + displacement], src_reg
    Note: Opcode: REX.W + 0F B1 /r (CMPXCHG r/m64, r64)
    Note: Compare RAX with [mem], if equal set ZF and store src_reg to [mem]
    Note: LOCK prefix should be added for atomic operation

    Let offset be 0

    Let rex_r be get_rex_r_bit(src_reg)
    Let rex_b be get_rex_b_bit(base_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 177)  Note: 0xB1

    Let src_low be get_low_3_bits(src_reg)
    Let base_low be get_low_3_bits(base_reg)
    Let modrm be encode_modrm(1, src_low, base_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, displacement bitwise_and 255)

    Return offset
End Process

Process called "encode_lock_prefix" takes buffer_ptr as Integer, offset as Integer returns Integer:
    Note: Write LOCK prefix byte for atomic operations
    Note: Opcode: F0
    Note: Must be immediately before the instruction it modifies

    Memory.memory_set_byte(buffer_ptr, offset, 240)  Note: 0xF0
    Return offset plus 1
End Process

Note: ============================================================================
Note: TEST INSTRUCTION
Note: ============================================================================

Process called "encode_test_reg_reg_64" takes reg1 as Integer, reg2 as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: TEST reg1, reg2 (bitwise AND, set flags, don't store result)
    Note: Opcode: REX.W + 85 /r (TEST r/m64, r64)

    Let offset be 0

    Let rex_r be get_rex_r_bit(reg2)
    Let rex_b be get_rex_b_bit(reg1)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 133)  Note: 0x85

    Let reg2_low be get_low_3_bits(reg2)
    Let reg1_low be get_low_3_bits(reg1)
    Let modrm be encode_modrm(3, reg2_low, reg1_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Note: ============================================================================
Note: SETCC INSTRUCTIONS (Set Byte on Condition)
Note: ============================================================================

Process called "encode_sete_reg" takes reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: SETE reg (set byte if equal, ZF=1)
    Note: Opcode: 0F 94 /0 (SETE r/m8)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 148)  Note: 0x94

    Let reg_low be get_low_3_bits(reg)
    Let modrm be encode_modrm(3, 0, reg_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_setne_reg" takes reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: SETNE reg (set byte if not equal, ZF=0)
    Note: Opcode: 0F 95 /0 (SETNE r/m8)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 149)  Note: 0x95

    Let reg_low be get_low_3_bits(reg)
    Let modrm be encode_modrm(3, 0, reg_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_setl_reg" takes reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: SETL reg (set byte if less, SF != OF)
    Note: Opcode: 0F 9C /0 (SETL r/m8)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 156)  Note: 0x9C

    Let reg_low be get_low_3_bits(reg)
    Let modrm be encode_modrm(3, 0, reg_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_setg_reg" takes reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: SETG reg (set byte if greater, ZF=0 AND SF=OF)
    Note: Opcode: 0F 9F /0 (SETG r/m8)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 159)  Note: 0x9F

    Let reg_low be get_low_3_bits(reg)
    Let modrm be encode_modrm(3, 0, reg_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Note: ============================================================================
Note: SSE FLOATING-POINT INSTRUCTIONS
Note: ============================================================================

Process called "encode_movss_xmm_to_xmm" takes dest_xmm as Integer, src_xmm as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: MOVSS dest_xmm, src_xmm (move scalar single-precision float)
    Note: Opcode: F3 0F 10 /r (MOVSS xmm1, xmm2)
    Note: dest_xmm and src_xmm are 16-31 (XMM0-XMM15 encoding)

    Let offset be 0

    Note: F3 prefix for scalar single-precision
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 243)  Note: 0xF3

    Note: REX prefix if extended XMM registers used
    Let dest_actual be dest_xmm minus 16
    Let src_actual be src_xmm minus 16
    If dest_actual is greater than or equal to 8:
        Let rex_r be 1
    Otherwise:
        Let rex_r be 0
    End If
    If src_actual is greater than or equal to 8:
        Let rex_b be 1
    Otherwise:
        Let rex_b be 0
    End If
    If rex_r is equal to 1:
        Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
        Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
    Otherwise:
        If rex_b is equal to 1:
            Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
            Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
        End If
    End If

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 16)  Note: 0x10

    Let dest_low be dest_actual bitwise_and 7
    Let src_low be src_actual bitwise_and 7
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_movsd_xmm_to_xmm" takes dest_xmm as Integer, src_xmm as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: MOVSD dest_xmm, src_xmm (move scalar double-precision float)
    Note: Opcode: F2 0F 10 /r (MOVSD xmm1, xmm2)
    Note: dest_xmm and src_xmm are 16-31 (XMM0-XMM15 encoding)

    Let offset be 0

    Note: F2 prefix for scalar double-precision
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 242)  Note: 0xF2

    Note: REX prefix if extended XMM registers used
    Let dest_actual be dest_xmm minus 16
    Let src_actual be src_xmm minus 16
    If dest_actual is greater than or equal to 8:
        Let rex_r be 1
    Otherwise:
        Let rex_r be 0
    End If
    If src_actual is greater than or equal to 8:
        Let rex_b be 1
    Otherwise:
        Let rex_b be 0
    End If
    If rex_r is equal to 1:
        Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
        Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
    Otherwise:
        If rex_b is equal to 1:
            Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
            Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
        End If
    End If

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 16)  Note: 0x10

    Let dest_low be dest_actual bitwise_and 7
    Let src_low be src_actual bitwise_and 7
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_addss_xmm_xmm" takes dest_xmm as Integer, src_xmm as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: ADDSS dest_xmm, src_xmm (add scalar single-precision)
    Note: Opcode: F3 0F 58 /r (ADDSS xmm1, xmm2)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 243)  Note: 0xF3

    Let dest_actual be dest_xmm minus 16
    Let src_actual be src_xmm minus 16
    If dest_actual is greater than or equal to 8:
        Let rex_r be 1
    Otherwise:
        Let rex_r be 0
    End If
    If src_actual is greater than or equal to 8:
        Let rex_b be 1
    Otherwise:
        Let rex_b be 0
    End If
    If rex_r is equal to 1:
        Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
        Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
    Otherwise:
        If rex_b is equal to 1:
            Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
            Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
        End If
    End If

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 88)  Note: 0x58

    Let dest_low be dest_actual bitwise_and 7
    Let src_low be src_actual bitwise_and 7
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_addsd_xmm_xmm" takes dest_xmm as Integer, src_xmm as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: ADDSD dest_xmm, src_xmm (add scalar double-precision)
    Note: Opcode: F2 0F 58 /r (ADDSD xmm1, xmm2)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 242)  Note: 0xF2

    Let dest_actual be dest_xmm minus 16
    Let src_actual be src_xmm minus 16
    If dest_actual is greater than or equal to 8:
        Let rex_r be 1
    Otherwise:
        Let rex_r be 0
    End If
    If src_actual is greater than or equal to 8:
        Let rex_b be 1
    Otherwise:
        Let rex_b be 0
    End If
    If rex_r is equal to 1:
        Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
        Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
    Otherwise:
        If rex_b is equal to 1:
            Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
            Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
        End If
    End If

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 88)  Note: 0x58

    Let dest_low be dest_actual bitwise_and 7
    Let src_low be src_actual bitwise_and 7
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_subss_xmm_xmm" takes dest_xmm as Integer, src_xmm as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: SUBSS dest_xmm, src_xmm (subtract scalar single-precision)
    Note: Opcode: F3 0F 5C /r (SUBSS xmm1, xmm2)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 243)  Note: 0xF3

    Let dest_actual be dest_xmm minus 16
    Let src_actual be src_xmm minus 16
    If dest_actual is greater than or equal to 8:
        Let rex_r be 1
    Otherwise:
        Let rex_r be 0
    End If
    If src_actual is greater than or equal to 8:
        Let rex_b be 1
    Otherwise:
        Let rex_b be 0
    End If
    If rex_r is equal to 1:
        Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
        Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
    Otherwise:
        If rex_b is equal to 1:
            Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
            Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
        End If
    End If

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 92)  Note: 0x5C

    Let dest_low be dest_actual bitwise_and 7
    Let src_low be src_actual bitwise_and 7
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_subsd_xmm_xmm" takes dest_xmm as Integer, src_xmm as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: SUBSD dest_xmm, src_xmm (subtract scalar double-precision)
    Note: Opcode: F2 0F 5C /r (SUBSD xmm1, xmm2)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 242)  Note: 0xF2

    Let dest_actual be dest_xmm minus 16
    Let src_actual be src_xmm minus 16
    If dest_actual is greater than or equal to 8:
        Let rex_r be 1
    Otherwise:
        Let rex_r be 0
    End If
    If src_actual is greater than or equal to 8:
        Let rex_b be 1
    Otherwise:
        Let rex_b be 0
    End If
    If rex_r is equal to 1:
        Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
        Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
    Otherwise:
        If rex_b is equal to 1:
            Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
            Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
        End If
    End If

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 92)  Note: 0x5C

    Let dest_low be dest_actual bitwise_and 7
    Let src_low be src_actual bitwise_and 7
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_mulss_xmm_xmm" takes dest_xmm as Integer, src_xmm as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: MULSS dest_xmm, src_xmm (multiply scalar single-precision)
    Note: Opcode: F3 0F 59 /r (MULSS xmm1, xmm2)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 243)  Note: 0xF3

    Let dest_actual be dest_xmm minus 16
    Let src_actual be src_xmm minus 16
    If dest_actual is greater than or equal to 8:
        Let rex_r be 1
    Otherwise:
        Let rex_r be 0
    End If
    If src_actual is greater than or equal to 8:
        Let rex_b be 1
    Otherwise:
        Let rex_b be 0
    End If
    If rex_r is equal to 1:
        Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
        Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
    Otherwise:
        If rex_b is equal to 1:
            Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
            Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
        End If
    End If

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 89)  Note: 0x59

    Let dest_low be dest_actual bitwise_and 7
    Let src_low be src_actual bitwise_and 7
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_mulsd_xmm_xmm" takes dest_xmm as Integer, src_xmm as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: MULSD dest_xmm, src_xmm (multiply scalar double-precision)
    Note: Opcode: F2 0F 59 /r (MULSD xmm1, xmm2)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 242)  Note: 0xF2

    Let dest_actual be dest_xmm minus 16
    Let src_actual be src_xmm minus 16
    If dest_actual is greater than or equal to 8:
        Let rex_r be 1
    Otherwise:
        Let rex_r be 0
    End If
    If src_actual is greater than or equal to 8:
        Let rex_b be 1
    Otherwise:
        Let rex_b be 0
    End If
    If rex_r is equal to 1:
        Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
        Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
    Otherwise:
        If rex_b is equal to 1:
            Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
            Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
        End If
    End If

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 89)  Note: 0x59

    Let dest_low be dest_actual bitwise_and 7
    Let src_low be src_actual bitwise_and 7
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_divss_xmm_xmm" takes dest_xmm as Integer, src_xmm as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: DIVSS dest_xmm, src_xmm (divide scalar single-precision)
    Note: Opcode: F3 0F 5E /r (DIVSS xmm1, xmm2)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 243)  Note: 0xF3

    Let dest_actual be dest_xmm minus 16
    Let src_actual be src_xmm minus 16
    If dest_actual is greater than or equal to 8:
        Let rex_r be 1
    Otherwise:
        Let rex_r be 0
    End If
    If src_actual is greater than or equal to 8:
        Let rex_b be 1
    Otherwise:
        Let rex_b be 0
    End If
    If rex_r is equal to 1:
        Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
        Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
    Otherwise:
        If rex_b is equal to 1:
            Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
            Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
        End If
    End If

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 94)  Note: 0x5E

    Let dest_low be dest_actual bitwise_and 7
    Let src_low be src_actual bitwise_and 7
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_divsd_xmm_xmm" takes dest_xmm as Integer, src_xmm as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: DIVSD dest_xmm, src_xmm (divide scalar double-precision)
    Note: Opcode: F2 0F 5E /r (DIVSD xmm1, xmm2)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 242)  Note: 0xF2

    Let dest_actual be dest_xmm minus 16
    Let src_actual be src_xmm minus 16
    If dest_actual is greater than or equal to 8:
        Let rex_r be 1
    Otherwise:
        Let rex_r be 0
    End If
    If src_actual is greater than or equal to 8:
        Let rex_b be 1
    Otherwise:
        Let rex_b be 0
    End If
    If rex_r is equal to 1:
        Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
        Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
    Otherwise:
        If rex_b is equal to 1:
            Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
            Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
        End If
    End If

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 94)  Note: 0x5E

    Let dest_low be dest_actual bitwise_and 7
    Let src_low be src_actual bitwise_and 7
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_sqrtss_xmm" takes dest_xmm as Integer, src_xmm as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: SQRTSS dest_xmm, src_xmm (square root scalar single-precision)
    Note: Opcode: F3 0F 51 /r (SQRTSS xmm1, xmm2)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 243)  Note: 0xF3

    Let dest_actual be dest_xmm minus 16
    Let src_actual be src_xmm minus 16
    If dest_actual is greater than or equal to 8:
        Let rex_r be 1
    Otherwise:
        Let rex_r be 0
    End If
    If src_actual is greater than or equal to 8:
        Let rex_b be 1
    Otherwise:
        Let rex_b be 0
    End If
    If rex_r is equal to 1:
        Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
        Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
    Otherwise:
        If rex_b is equal to 1:
            Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
            Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
        End If
    End If

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 81)  Note: 0x51

    Let dest_low be dest_actual bitwise_and 7
    Let src_low be src_actual bitwise_and 7
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_sqrtsd_xmm" takes dest_xmm as Integer, src_xmm as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: SQRTSD dest_xmm, src_xmm (square root scalar double-precision)
    Note: Opcode: F2 0F 51 /r (SQRTSD xmm1, xmm2)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 242)  Note: 0xF2

    Let dest_actual be dest_xmm minus 16
    Let src_actual be src_xmm minus 16
    If dest_actual is greater than or equal to 8:
        Let rex_r be 1
    Otherwise:
        Let rex_r be 0
    End If
    If src_actual is greater than or equal to 8:
        Let rex_b be 1
    Otherwise:
        Let rex_b be 0
    End If
    If rex_r is equal to 1:
        Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
        Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
    Otherwise:
        If rex_b is equal to 1:
            Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
            Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
        End If
    End If

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 81)  Note: 0x51

    Let dest_low be dest_actual bitwise_and 7
    Let src_low be src_actual bitwise_and 7
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_cvtsi2ss_xmm_reg" takes dest_xmm as Integer, src_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: CVTSI2SS dest_xmm, src_reg (convert int64 to single-precision)
    Note: Opcode: F3 REX.W 0F 2A /r (CVTSI2SS xmm, r/m64)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 243)  Note: 0xF3

    Let dest_actual be dest_xmm minus 16
    Let rex_r be get_rex_r_bit(dest_actual)
    Let rex_b be get_rex_b_bit(src_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 42)  Note: 0x2A

    Let dest_low be dest_actual bitwise_and 7
    Let src_low be get_low_3_bits(src_reg)
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_cvtsi2sd_xmm_reg" takes dest_xmm as Integer, src_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: CVTSI2SD dest_xmm, src_reg (convert int64 to double-precision)
    Note: Opcode: F2 REX.W 0F 2A /r (CVTSI2SD xmm, r/m64)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 242)  Note: 0xF2

    Let dest_actual be dest_xmm minus 16
    Let rex_r be get_rex_r_bit(dest_actual)
    Let rex_b be get_rex_b_bit(src_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 42)  Note: 0x2A

    Let dest_low be dest_actual bitwise_and 7
    Let src_low be get_low_3_bits(src_reg)
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_cvtss2si_reg_xmm" takes dest_reg as Integer, src_xmm as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: CVTSS2SI dest_reg, src_xmm (convert single-precision to int64)
    Note: Opcode: F3 REX.W 0F 2D /r (CVTSS2SI r64, xmm/m32)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 243)  Note: 0xF3

    Let src_actual be src_xmm minus 16
    Let rex_r be get_rex_r_bit(dest_reg)
    Let rex_b be get_rex_r_bit(src_actual)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 45)  Note: 0x2D

    Let dest_low be get_low_3_bits(dest_reg)
    Let src_low be src_actual bitwise_and 7
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_cvtsd2si_reg_xmm" takes dest_reg as Integer, src_xmm as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: CVTSD2SI dest_reg, src_xmm (convert double-precision to int64)
    Note: Opcode: F2 REX.W 0F 2D /r (CVTSD2SI r64, xmm/m64)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 242)  Note: 0xF2

    Let src_actual be src_xmm minus 16
    Let rex_r be get_rex_r_bit(dest_reg)
    Let rex_b be get_rex_r_bit(src_actual)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 45)  Note: 0x2D

    Let dest_low be get_low_3_bits(dest_reg)
    Let src_low be src_actual bitwise_and 7
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_ucomiss_xmm_xmm" takes xmm1 as Integer, xmm2 as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: UCOMISS xmm1, xmm2 (unordered compare scalar single-precision)
    Note: Opcode: 0F 2E /r (UCOMISS xmm1, xmm2)
    Note: Sets flags: ZF, PF, CF (used with JE, JNE, JA, JAE, JB, JBE)

    Let offset be 0

    Let xmm1_actual be xmm1 minus 16
    Let xmm2_actual be xmm2 minus 16
    If xmm1_actual is greater than or equal to 8:
        Let rex_r be 1
    Otherwise:
        Let rex_r be 0
    End If
    If xmm2_actual is greater than or equal to 8:
        Let rex_b be 1
    Otherwise:
        Let rex_b be 0
    End If
    If rex_r is equal to 1:
        Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
        Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
    Otherwise:
        If rex_b is equal to 1:
            Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
            Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
        End If
    End If

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 46)  Note: 0x2E

    Let xmm1_low be xmm1_actual bitwise_and 7
    Let xmm2_low be xmm2_actual bitwise_and 7
    Let modrm be encode_modrm(3, xmm1_low, xmm2_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_ucomisd_xmm_xmm" takes xmm1 as Integer, xmm2 as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: UCOMISD xmm1, xmm2 (unordered compare scalar double-precision)
    Note: Opcode: 66 0F 2E /r (UCOMISD xmm1, xmm2)
    Note: Sets flags: ZF, PF, CF (used with JE, JNE, JA, JAE, JB, JBE)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 102)  Note: 0x66 prefix

    Let xmm1_actual be xmm1 minus 16
    Let xmm2_actual be xmm2 minus 16
    If xmm1_actual is greater than or equal to 8:
        Let rex_r be 1
    Otherwise:
        Let rex_r be 0
    End If
    If xmm2_actual is greater than or equal to 8:
        Let rex_b be 1
    Otherwise:
        Let rex_b be 0
    End If
    If rex_r is equal to 1:
        Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
        Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
    Otherwise:
        If rex_b is equal to 1:
            Let rex_byte be encode_rex(0, rex_r, 0, rex_b)
            Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)
        End If
    End If

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 46)  Note: 0x2E

    Let xmm1_low be xmm1_actual bitwise_and 7
    Let xmm2_low be xmm2_actual bitwise_and 7
    Let modrm be encode_modrm(3, xmm1_low, xmm2_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Note: ============================================================================
Note: BIT MANIPULATION INSTRUCTIONS
Note: ============================================================================

Process called "encode_bsf_reg_reg_64" takes dest_reg as Integer, src_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: BSF dest_reg, src_reg (bit scan forward - find first set bit)
    Note: Opcode: REX.W 0F BC /r (BSF r64, r/m64)
    Note: Sets ZF if src is zero, otherwise clears ZF and stores bit index in dest

    Let offset be 0

    Let rex_r be get_rex_r_bit(dest_reg)
    Let rex_b be get_rex_b_bit(src_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 188)  Note: 0xBC

    Let dest_low be get_low_3_bits(dest_reg)
    Let src_low be get_low_3_bits(src_reg)
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_bsr_reg_reg_64" takes dest_reg as Integer, src_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: BSR dest_reg, src_reg (bit scan reverse - find last set bit)
    Note: Opcode: REX.W 0F BD /r (BSR r64, r/m64)
    Note: Sets ZF if src is zero, otherwise clears ZF and stores bit index in dest

    Let offset be 0

    Let rex_r be get_rex_r_bit(dest_reg)
    Let rex_b be get_rex_b_bit(src_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 189)  Note: 0xBD

    Let dest_low be get_low_3_bits(dest_reg)
    Let src_low be get_low_3_bits(src_reg)
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_popcnt_reg_reg_64" takes dest_reg as Integer, src_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: POPCNT dest_reg, src_reg (population count - count set bits)
    Note: Opcode: F3 REX.W 0F B8 /r (POPCNT r64, r/m64)
    Note: Requires SSE4.2 or POPCNT CPU feature

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 243)  Note: 0xF3

    Let rex_r be get_rex_r_bit(dest_reg)
    Let rex_b be get_rex_b_bit(src_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 184)  Note: 0xB8

    Let dest_low be get_low_3_bits(dest_reg)
    Let src_low be get_low_3_bits(src_reg)
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_lzcnt_reg_reg_64" takes dest_reg as Integer, src_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: LZCNT dest_reg, src_reg (leading zero count)
    Note: Opcode: F3 REX.W 0F BD /r (LZCNT r64, r/m64)
    Note: Requires LZCNT CPU feature (Haswell+)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 243)  Note: 0xF3

    Let rex_r be get_rex_r_bit(dest_reg)
    Let rex_b be get_rex_b_bit(src_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 189)  Note: 0xBD

    Let dest_low be get_low_3_bits(dest_reg)
    Let src_low be get_low_3_bits(src_reg)
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_tzcnt_reg_reg_64" takes dest_reg as Integer, src_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: TZCNT dest_reg, src_reg (trailing zero count)
    Note: Opcode: F3 REX.W 0F BC /r (TZCNT r64, r/m64)
    Note: Requires BMI1 CPU feature (Haswell+)

    Let offset be 0

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 243)  Note: 0xF3

    Let rex_r be get_rex_r_bit(dest_reg)
    Let rex_b be get_rex_b_bit(src_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 188)  Note: 0xBC

    Let dest_low be get_low_3_bits(dest_reg)
    Let src_low be get_low_3_bits(src_reg)
    Let modrm be encode_modrm(3, dest_low, src_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_bt_reg_reg_64" takes base_reg as Integer, bit_offset_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: BT base_reg, bit_offset_reg (bit test - copy bit to CF)
    Note: Opcode: REX.W 0F A3 /r (BT r/m64, r64)
    Note: Copies bit at offset to carry flag, does not modify base_reg

    Let offset be 0

    Let rex_r be get_rex_r_bit(bit_offset_reg)
    Let rex_b be get_rex_b_bit(base_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 163)  Note: 0xA3

    Let bit_offset_low be get_low_3_bits(bit_offset_reg)
    Let base_low be get_low_3_bits(base_reg)
    Let modrm be encode_modrm(3, bit_offset_low, base_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_bts_reg_reg_64" takes base_reg as Integer, bit_offset_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: BTS base_reg, bit_offset_reg (bit test and set)
    Note: Opcode: REX.W 0F AB /r (BTS r/m64, r64)
    Note: Copies bit to CF, then sets bit to 1

    Let offset be 0

    Let rex_r be get_rex_r_bit(bit_offset_reg)
    Let rex_b be get_rex_b_bit(base_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 171)  Note: 0xAB

    Let bit_offset_low be get_low_3_bits(bit_offset_reg)
    Let base_low be get_low_3_bits(base_reg)
    Let modrm be encode_modrm(3, bit_offset_low, base_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_btr_reg_reg_64" takes base_reg as Integer, bit_offset_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: BTR base_reg, bit_offset_reg (bit test and reset)
    Note: Opcode: REX.W 0F B3 /r (BTR r/m64, r64)
    Note: Copies bit to CF, then clears bit to 0

    Let offset be 0

    Let rex_r be get_rex_r_bit(bit_offset_reg)
    Let rex_b be get_rex_b_bit(base_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 179)  Note: 0xB3

    Let bit_offset_low be get_low_3_bits(bit_offset_reg)
    Let base_low be get_low_3_bits(base_reg)
    Let modrm be encode_modrm(3, bit_offset_low, base_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Process called "encode_btc_reg_reg_64" takes base_reg as Integer, bit_offset_reg as Integer, buffer_ptr as Integer returns Integer:
    Note: Encode: BTC base_reg, bit_offset_reg (bit test and complement)
    Note: Opcode: REX.W 0F BB /r (BTC r/m64, r64)
    Note: Copies bit to CF, then toggles bit (0->1, 1->0)

    Let offset be 0

    Let rex_r be get_rex_r_bit(bit_offset_reg)
    Let rex_b be get_rex_b_bit(base_reg)
    Let rex_byte be encode_rex(1, rex_r, 0, rex_b)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 15)  Note: 0x0F
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 187)  Note: 0xBB

    Let bit_offset_low be get_low_3_bits(bit_offset_reg)
    Let base_low be get_low_3_bits(base_reg)
    Let modrm be encode_modrm(3, bit_offset_low, base_low)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, modrm)

    Return offset
End Process

Note: ============================================================================
Note: STRING AND MEMORY BLOCK OPERATIONS
Note: ============================================================================

Process called "encode_movsb" takes buffer_ptr as Integer returns Integer:
    Note: Encode: MOVSB (move byte from [RSI] to [RDI], increment both)
    Note: Opcode: A4 (MOVSB)
    Note: Typically used with REP prefix for block moves

    Let offset be 0
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 164)  Note: 0xA4
    Return offset
End Process

Process called "encode_movsq" takes buffer_ptr as Integer returns Integer:
    Note: Encode: MOVSQ (move qword from [RSI] to [RDI], increment both by 8)
    Note: Opcode: REX.W A5 (MOVSQ)
    Note: Typically used with REP prefix for block moves

    Let offset be 0

    Let rex_byte be encode_rex(1, 0, 0, 0)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 165)  Note: 0xA5
    Return offset
End Process

Process called "encode_stosb" takes buffer_ptr as Integer returns Integer:
    Note: Encode: STOSB (store AL to [RDI], increment RDI)
    Note: Opcode: AA (STOSB)
    Note: Typically used with REP prefix for memory fill operations

    Let offset be 0
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 170)  Note: 0xAA
    Return offset
End Process

Process called "encode_stosq" takes buffer_ptr as Integer returns Integer:
    Note: Encode: STOSQ (store RAX to [RDI], increment RDI by 8)
    Note: Opcode: REX.W AB (STOSQ)
    Note: Typically used with REP prefix for memory fill operations

    Let offset be 0

    Let rex_byte be encode_rex(1, 0, 0, 0)
    Set offset to write_byte_to_buffer(buffer_ptr, offset, rex_byte)

    Set offset to write_byte_to_buffer(buffer_ptr, offset, 171)  Note: 0xAB
    Return offset
End Process

Process called "encode_rep_prefix" takes buffer_ptr as Integer, offset as Integer returns Integer:
    Note: Write REP prefix byte for string operations
    Note: Opcode: F3
    Note: Repeats string operation RCX times, decrementing RCX each iteration

    Memory.memory_set_byte(buffer_ptr, offset, 243)  Note: 0xF3
    Return offset plus 1
End Process

Process called "encode_cld" takes buffer_ptr as Integer returns Integer:
    Note: Encode: CLD (clear direction flag - set string ops to increment)
    Note: Opcode: FC
    Note: Must be called before string operations to ensure forward direction

    Let offset be 0
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 252)  Note: 0xFC
    Return offset
End Process

Process called "encode_std" takes buffer_ptr as Integer returns Integer:
    Note: Encode: STD (set direction flag - set string ops to decrement)
    Note: Opcode: FD
    Note: Causes string operations to move backward through memory

    Let offset be 0
    Set offset to write_byte_to_buffer(buffer_ptr, offset, 253)  Note: 0xFD
    Return offset
End Process

Note: ============================================================================
Note: HIGH-LEVEL INSTRUCTION ENCODING INTERFACE
Note: ============================================================================

Process called "get_instruction_max_length" returns Integer:
    Note: Return maximum x86_64 instruction length
    Return 15  Note: x86_64 maximum instruction length is 15 bytes
End Process

Process called "get_nop_instruction" takes buffer_ptr as Integer returns Integer:
    Note: Encode single-byte NOP instruction
    Return encode_nop(buffer_ptr)
End Process
