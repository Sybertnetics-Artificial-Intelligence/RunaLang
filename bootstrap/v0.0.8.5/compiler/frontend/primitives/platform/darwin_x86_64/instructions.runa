Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
Darwin x86-64 Instruction Set Metadata and Helpers

This file provides instruction metadata, opcode definitions, and helper functions
for x86-64 instruction selection, validation, and optimization.

x86-64 Key Characteristics:
- Variable-length instruction encoding (1-15 bytes, CISC architecture)
- Two-operand instructions (dest is often also source)
- Rich addressing modes (register, immediate, memory with complex indexing)
- Prefix-based encoding (REX, VEX, EVEX prefixes for extended features)
- Flags register (RFLAGS) for condition codes
- Complex instruction set with specialized instructions

This includes:
- Instruction opcode identifiers
- Instruction properties (latency, throughput, encoding size)
- Instruction validation helpers
- Instruction selection helpers
- Common instruction patterns
- Optimization hints

IMPORTANT: x86-64 instruction set is IDENTICAL across platforms (Windows, Linux, macOS).
Platform differences are in calling convention and syscalls, NOT instruction encoding.

This file does NOT perform actual instruction encoding (see machine_code.runa for that).
Instead, it provides metadata and helper functions for the code generator to make
intelligent decisions about which instructions to use and how to optimize them.

Dependencies:
- registers.runa for register metadata
- calling_convention.runa for ABI constraints
:End Note

Import "compiler/frontend/primitives/platform/darwin_x86_64/registers.runa" as Registers

Note: ============================================================================
Note: INSTRUCTION OPCODE IDENTIFIERS (x86-64)
Note: ============================================================================
Note: x86-64 instructions have variable length encoding
Note: These are encoding identifiers, not literal opcodes

Process called "OPCODE_MOV" returns Integer:
    Return 1  Note: MOV - move data (register, immediate, memory)
End Process

Process called "OPCODE_MOVSX" returns Integer:
    Return 2  Note: MOVSX - move with sign extension
End Process

Process called "OPCODE_MOVZX" returns Integer:
    Return 3  Note: MOVZX - move with zero extension
End Process

Process called "OPCODE_LEA" returns Integer:
    Return 4  Note: LEA - load effective address
End Process

Process called "OPCODE_ADD" returns Integer:
    Return 10  Note: ADD - integer addition
End Process

Process called "OPCODE_SUB" returns Integer:
    Return 11  Note: SUB - integer subtraction
End Process

Process called "OPCODE_IMUL" returns Integer:
    Return 12  Note: IMUL - signed integer multiply
End Process

Process called "OPCODE_MUL" returns Integer:
    Return 13  Note: MUL - unsigned integer multiply
End Process

Process called "OPCODE_IDIV" returns Integer:
    Return 14  Note: IDIV - signed integer divide
End Process

Process called "OPCODE_DIV" returns Integer:
    Return 15  Note: DIV - unsigned integer divide
End Process

Process called "OPCODE_NEG" returns Integer:
    Return 16  Note: NEG - two's complement negation
End Process

Process called "OPCODE_INC" returns Integer:
    Return 17  Note: INC - increment by 1
End Process

Process called "OPCODE_DEC" returns Integer:
    Return 18  Note: DEC - decrement by 1
End Process

Process called "OPCODE_CMP" returns Integer:
    Return 20  Note: CMP - compare (subtract and set flags)
End Process

Process called "OPCODE_TEST" returns Integer:
    Return 21  Note: TEST - logical compare (AND and set flags)
End Process

Process called "OPCODE_JMP" returns Integer:
    Return 30  Note: JMP - unconditional jump
End Process

Process called "OPCODE_JE" returns Integer:
    Return 31  Note: JE/JZ - jump if equal/zero
End Process

Process called "OPCODE_JNE" returns Integer:
    Return 32  Note: JNE/JNZ - jump if not equal/zero
End Process

Process called "OPCODE_JL" returns Integer:
    Return 33  Note: JL/JNGE - jump if less (signed)
End Process

Process called "OPCODE_JLE" returns Integer:
    Return 34  Note: JLE/JNG - jump if less or equal (signed)
End Process

Process called "OPCODE_JG" returns Integer:
    Return 35  Note: JG/JNLE - jump if greater (signed)
End Process

Process called "OPCODE_JGE" returns Integer:
    Return 36  Note: JGE/JNL - jump if greater or equal (signed)
End Process

Process called "OPCODE_JB" returns Integer:
    Return 37  Note: JB/JNAE/JC - jump if below (unsigned)
End Process

Process called "OPCODE_JBE" returns Integer:
    Return 38  Note: JBE/JNA - jump if below or equal (unsigned)
End Process

Process called "OPCODE_JA" returns Integer:
    Return 39  Note: JA/JNBE - jump if above (unsigned)
End Process

Process called "OPCODE_JAE" returns Integer:
    Return 40  Note: JAE/JNB/JNC - jump if above or equal (unsigned)
End Process

Process called "OPCODE_CALL" returns Integer:
    Return 41  Note: CALL - call procedure
End Process

Process called "OPCODE_RET" returns Integer:
    Return 42  Note: RET - return from procedure
End Process

Process called "OPCODE_PUSH" returns Integer:
    Return 50  Note: PUSH - push onto stack
End Process

Process called "OPCODE_POP" returns Integer:
    Return 51  Note: POP - pop from stack
End Process

Process called "OPCODE_AND" returns Integer:
    Return 60  Note: AND - bitwise AND
End Process

Process called "OPCODE_OR" returns Integer:
    Return 61  Note: OR - bitwise OR
End Process

Process called "OPCODE_XOR" returns Integer:
    Return 62  Note: XOR - bitwise exclusive OR
End Process

Process called "OPCODE_NOT" returns Integer:
    Return 63  Note: NOT - bitwise NOT
End Process

Process called "OPCODE_SHL" returns Integer:
    Return 70  Note: SHL/SAL - shift left (logical/arithmetic same)
End Process

Process called "OPCODE_SHR" returns Integer:
    Return 71  Note: SHR - shift right logical
End Process

Process called "OPCODE_SAR" returns Integer:
    Return 72  Note: SAR - shift right arithmetic
End Process

Process called "OPCODE_ROL" returns Integer:
    Return 73  Note: ROL - rotate left
End Process

Process called "OPCODE_ROR" returns Integer:
    Return 74  Note: ROR - rotate right
End Process

Process called "OPCODE_SYSCALL" returns Integer:
    Return 80  Note: SYSCALL - fast system call (64-bit)
End Process

Process called "OPCODE_NOP" returns Integer:
    Return 90  Note: NOP - no operation
End Process

Process called "OPCODE_MOVSD" returns Integer:
    Return 100  Note: MOVSD - move scalar double-precision FP
End Process

Process called "OPCODE_MOVSS" returns Integer:
    Return 101  Note: MOVSS - move scalar single-precision FP
End Process

Process called "OPCODE_ADDSD" returns Integer:
    Return 102  Note: ADDSD - add scalar double-precision FP
End Process

Process called "OPCODE_SUBSD" returns Integer:
    Return 103  Note: SUBSD - subtract scalar double-precision FP
End Process

Process called "OPCODE_MULSD" returns Integer:
    Return 104  Note: MULSD - multiply scalar double-precision FP
End Process

Process called "OPCODE_DIVSD" returns Integer:
    Return 105  Note: DIVSD - divide scalar double-precision FP
End Process

Note: ============================================================================
Note: INSTRUCTION PROPERTIES
Note: ============================================================================
Note: Instruction latency and throughput for optimization

Process called "get_instruction_latency" takes instruction_type as Integer returns Integer:
    Note: Get instruction latency in CPU cycles
    Note: Returns approximate latency on modern x86-64 CPUs (Intel Skylake/AMD Zen)

    Note: MOV - register to register
    If instruction_type is equal to 1:
        Return 1  Note: 1 cycle latency
    End If

    Note: LEA - load effective address
    If instruction_type is equal to 4:
        Return 1  Note: 1 cycle latency
    End If

    Note: ADD/SUB - integer arithmetic
    If instruction_type is equal to 10:
        Return 1  Note: 1 cycle latency
    End If
    If instruction_type is equal to 11:
        Return 1  Note: 1 cycle latency
    End If

    Note: IMUL - integer multiply (64-bit)
    If instruction_type is equal to 12:
        Return 3  Note: 3 cycle latency
    End If

    Note: IDIV - integer divide (64-bit)
    If instruction_type is equal to 14:
        Return 26  Note: 26-30 cycles (data-dependent)
    End If
    If instruction_type is equal to 15:
        Return 26  Note: 26-30 cycles (data-dependent)
    End If

    Note: CMP/TEST
    If instruction_type is equal to 20:
        Return 1  Note: 1 cycle latency
    End If
    If instruction_type is equal to 21:
        Return 1  Note: 1 cycle latency
    End If

    Note: Jumps (predicted correctly)
    If instruction_type is greater than or equal to 30:
        If instruction_type is less than or equal to 42:
            Return 1  Note: Predicted correctly
        End If
    End If

    Note: FP operations
    If instruction_type is equal to 102:
        Return 4  Note: ADDSD latency
    End If
    If instruction_type is equal to 103:
        Return 4  Note: SUBSD latency
    End If
    If instruction_type is equal to 104:
        Return 4  Note: MULSD latency
    End If
    If instruction_type is equal to 105:
        Return 14  Note: DIVSD latency (13-14 cycles)
    End If

    Return 1  Note: Default conservative estimate
End Process

Process called "get_instruction_throughput" takes instruction_type as Integer returns Integer:
    Note: Get instruction throughput (reciprocal throughput in tenths)
    Note: Returns reciprocal throughput × 10 (e.g., 5 = 0.5 cycles, 10 = 1.0 cycle)

    Note: Most ALU operations: 0.25-0.5 cycles (2-4 per cycle)
    If instruction_type is equal to 1:
        Return 3  Note: 0.3 cycles (3+ per cycle)
    End If
    If instruction_type is equal to 4:
        Return 5  Note: 0.5 cycles (2 per cycle)
    End If
    If instruction_type is equal to 10:
        Return 3  Note: 0.3 cycles
    End If
    If instruction_type is equal to 11:
        Return 3  Note: 0.3 cycles
    End If

    Note: Multiply: 1 per cycle
    If instruction_type is equal to 12:
        Return 10  Note: 1.0 cycle
    End If

    Note: Divide: very slow
    If instruction_type is equal to 14:
        Return 260  Note: 26 cycles
    End If
    If instruction_type is equal to 15:
        Return 260  Note: 26 cycles
    End If

    Return 10  Note: Default 1.0 cycle
End Process

Process called "get_instruction_min_size" takes instruction_type as Integer returns Integer:
    Note: Get minimum instruction encoding size in bytes
    Note: x86-64 has variable-length encoding

    Note: Simple register operations can be 2-3 bytes
    If instruction_type is equal to 1:
        Return 2  Note: MOV r,r can be 2 bytes with REX
    End If

    Note: Most ALU operations: 3-4 bytes
    If instruction_type is greater than or equal to 10:
        If instruction_type is less than or equal to 21:
            Return 3  Note: Typical ALU instruction size
        End If
    End If

    Note: Jumps: 2 bytes (short) to 6 bytes (long)
    If instruction_type is greater than or equal to 30:
        If instruction_type is less than or equal to 42:
            Return 2  Note: Short jump encoding
        End If
    End If

    Return 3  Note: Default conservative estimate
End Process

Process called "get_instruction_max_size" takes instruction_type as Integer returns Integer:
    Note: Get maximum instruction encoding size in bytes
    Note: x86-64 instructions can be up to 15 bytes

    Note: With all prefixes and complex addressing: up to 15 bytes
    Note: But most instructions are 3-8 bytes

    Note: Simple operations
    If instruction_type is equal to 1:
        Return 10  Note: MOV with complex addressing
    End If

    Note: ALU operations
    If instruction_type is greater than or equal to 10:
        If instruction_type is less than or equal to 21:
            Return 8  Note: With REX + complex operands
        End If
    End If

    Note: Jumps
    If instruction_type is greater than or equal to 30:
        If instruction_type is less than or equal to 42:
            Return 6  Note: Long jump encoding
        End If
    End If

    Return 15  Note: Maximum possible x86-64 instruction size
End Process

Note: ============================================================================
Note: INSTRUCTION VALIDATION
Note: ============================================================================

Process called "validate_immediate_size" takes immediate as Integer, bits as Integer returns Integer:
    Note: Validate that immediate value fits in specified bit width
    Note: bits: number of bits available (8, 16, 32, 64)
    Note: Returns 1 if valid, 0 if out of range

    Note: Check for 8-bit immediate
    If bits is equal to 8:
        If immediate is greater than or equal to -128:
            If immediate is less than or equal to 127:
                Return 1
            End If
        End If
        Return 0
    End If

    Note: Check for 16-bit immediate
    If bits is equal to 16:
        If immediate is greater than or equal to -32768:
            If immediate is less than or equal to 32767:
                Return 1
            End If
        End If
        Return 0
    End If

    Note: Check for 32-bit immediate
    If bits is equal to 32:
        If immediate is greater than or equal to -2147483648:
            If immediate is less than or equal to 2147483647:
                Return 1
            End If
        End If
        Return 0
    End If

    Note: 64-bit immediates generally OK (within integer range)
    Return 1
End Process

Process called "can_use_imm8" takes immediate as Integer returns Integer:
    Note: Check if immediate can be encoded as 8-bit (common optimization)
    Return validate_immediate_size(immediate, 8)
End Process

Process called "can_use_imm32" takes immediate as Integer returns Integer:
    Note: Check if immediate can be encoded as 32-bit
    Return validate_immediate_size(immediate, 32)
End Process

Process called "validate_jump_offset" takes offset as Integer, is_short as Integer returns Integer:
    Note: Validate jump offset is within x86-64 limits
    Note: offset: byte offset from current instruction
    Note: is_short: 1 for short jump (±128 bytes), 0 for near jump (±2GB)
    Note: Returns 1 if valid, 0 if out of range

    Note: Short jumps: 8-bit signed offset
    If is_short is equal to 1:
        If offset is greater than or equal to -128:
            If offset is less than or equal to 127:
                Return 1
            End If
        End If
        Return 0
    End If

    Note: Near jumps: 32-bit signed offset (±2GB)
    If offset is greater than or equal to -2147483648:
        If offset is less than or equal to 2147483647:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "can_use_immediate" takes immediate as Integer, instruction_type as Integer returns Integer:
    Note: Check if immediate can be encoded directly in instruction
    Note: Returns 1 if can use immediate, 0 if needs register

    Note: Most ALU operations support 32-bit immediate
    If instruction_type is greater than or equal to 10:
        If instruction_type is less than or equal to 21:
            Return can_use_imm32(immediate)
        End If
    End If

    Note: MOV supports full 64-bit immediate
    If instruction_type is equal to 1:
        Return 1  Note: MOV can use 64-bit immediate
    End If

    Return 0  Note: Default: cannot use immediate
End Process

Note: ============================================================================
Note: INSTRUCTION SELECTION HELPERS
Note: ============================================================================

Process called "should_use_lea" takes is_address_calc as Integer, has_scale as Integer returns Integer:
    Note: Check if should use LEA instead of ADD/SHL
    Note: LEA is efficient for address calculations and complex arithmetic
    Note: Returns 1 if should use LEA, 0 if use ADD/SHL

    Note: LEA is good for calculations with scale/index
    If has_scale is equal to 1:
        Return 1  Note: Use LEA for scaled calculations
    End If

    Note: LEA is good for non-destructive arithmetic
    If is_address_calc is equal to 1:
        Return 1  Note: Use LEA for address calculations
    End If

    Return 0  Note: Use regular ADD/SHL
End Process

Process called "should_use_imul_form" takes operand_count as Integer returns Integer:
    Note: Check which IMUL form to use (1, 2, or 3 operand)
    Note: operand_count: number of operands (1, 2, or 3)
    Note: Returns recommended form

    Note: 3-operand form: imul r64, r64, imm
    If operand_count is equal to 3:
        Return 3  Note: Most flexible form
    End If

    Note: 2-operand form: imul r64, r64
    If operand_count is equal to 2:
        Return 2  Note: Common form
    End If

    Note: 1-operand form: imul r64 (result in RDX:RAX)
    Return 1  Note: Legacy form
End Process

Process called "should_use_test_optimization" takes immediate as Integer returns Integer:
    Note: Check if TEST can be used instead of CMP
    Note: TEST r,r is faster than CMP r,0 for zero checks
    Note: Returns 1 if should use TEST, 0 if use CMP

    If immediate is equal to 0:
        Return 1  Note: Use TEST for zero comparison
    End If

    Return 0  Note: Use CMP for non-zero comparison
End Process

Note: ============================================================================
Note: OPTIMIZATION HINTS
Note: ============================================================================

Process called "can_eliminate_redundant_move" takes src_reg as Integer, dest_reg as Integer returns Integer:
    Note: Check if MOV can be eliminated (source and dest are same)
    Note: Returns 1 if can eliminate, 0 if must emit

    If src_reg is equal to dest_reg:
        Return 1  Note: Redundant move
    End If

    Return 0
End Process

Process called "should_use_xor_for_zero" takes dest_reg as Integer returns Integer:
    Note: Check if should use XOR r,r to zero register (faster than MOV r,0)
    Note: Returns 1 if should use XOR, 0 if use MOV
    Note: XOR r,r is dependency-breaking and recognized by CPU

    Return 1  Note: Always use XOR r,r for zeroing (breaks dependency chain)
End Process

Process called "can_fuse_cmp_jump" takes cmp_type as Integer, jump_type as Integer returns Integer:
    Note: Check if compare + jump can be macro-fused by CPU
    Note: Modern x86-64 CPUs fuse CMP+Jcc into single micro-op
    Note: Returns 1 if can fuse, 0 if keep separate

    Note: CMP followed by conditional jump can be fused
    If cmp_type is equal to 20:
        If jump_type is greater than or equal to 31:
            If jump_type is less than or equal to 40:
                Return 1  Note: Can macro-fuse
            End If
        End If
    End If

    Note: TEST followed by conditional jump can be fused
    If cmp_type is equal to 21:
        If jump_type is greater than or equal to 31:
            If jump_type is less than or equal to 40:
                Return 1  Note: Can macro-fuse
            End If
        End If
    End If

    Return 0
End Process

Process called "should_use_inc_dec" takes immediate as Integer returns Integer:
    Note: Check if should use INC/DEC instead of ADD/SUB 1
    Note: On modern CPUs, INC/DEC can be slower due to partial flag updates
    Note: Returns 1 if should use INC/DEC, 0 if use ADD/SUB

    Note: On modern x86-64, prefer ADD/SUB for better performance
    Note: INC/DEC have partial flag dependencies
    Return 0  Note: Use ADD/SUB instead of INC/DEC
End Process

Note: ============================================================================
Note: CONDITION CODE MAPPING
Note: ============================================================================

Process called "get_condition_code" takes condition_type as Integer returns Integer:
    Note: Get x86-64 condition code for jump instruction
    Note: condition_type: 0=EQ, 1=NE, 2=LT, 3=LE, 4=GT, 5=GE, 6=B, 7=BE, 8=A, 9=AE
    Note: Returns instruction opcode identifier

    If condition_type is equal to 0:
        Return 31  Note: JE (equal, ZF=1)
    End If

    If condition_type is equal to 1:
        Return 32  Note: JNE (not equal, ZF=0)
    End If

    If condition_type is equal to 2:
        Return 33  Note: JL (signed less, SF!=OF)
    End If

    If condition_type is equal to 3:
        Return 34  Note: JLE (signed less or equal, ZF=1 or SF!=OF)
    End If

    If condition_type is equal to 4:
        Return 35  Note: JG (signed greater, ZF=0 and SF=OF)
    End If

    If condition_type is equal to 5:
        Return 36  Note: JGE (signed greater or equal, SF=OF)
    End If

    If condition_type is equal to 6:
        Return 37  Note: JB (unsigned below, CF=1)
    End If

    If condition_type is equal to 7:
        Return 38  Note: JBE (unsigned below or equal, CF=1 or ZF=1)
    End If

    If condition_type is equal to 8:
        Return 39  Note: JA (unsigned above, CF=0 and ZF=0)
    End If

    If condition_type is equal to 9:
        Return 40  Note: JAE (unsigned above or equal, CF=0)
    End If

    Return 30  Note: JMP (unconditional)
End Process

Note: ============================================================================
Note: PERFORMANCE HINTS
Note: ============================================================================

Process called "get_nop_instruction_size" returns Integer:
    Note: Get size of NOP instruction in bytes
    Return 1  Note: Single-byte NOP (0x90)
End Process

Process called "get_instruction_alignment" returns Integer:
    Note: Get recommended instruction alignment in bytes
    Return 1  Note: x86-64 has no strict alignment requirement
End Process

Process called "get_loop_alignment_hint" returns Integer:
    Note: Get recommended alignment for loop entry points
    Return 16  Note: Align loops to 16 bytes for better performance
End Process

Process called "get_function_alignment_hint" returns Integer:
    Note: Get recommended alignment for function entry points
    Return 16  Note: Align functions to 16 bytes
End Process

Process called "get_cache_line_size" returns Integer:
    Note: Get CPU cache line size in bytes
    Return 64  Note: x86-64 typically uses 64-byte cache lines
End Process

Process called "should_align_branch_target" takes is_loop_entry as Integer returns Integer:
    Note: Check if branch target should be aligned
    Note: Returns 1 if should align, 0 otherwise

    If is_loop_entry is equal to 1:
        Return 1  Note: Align loop entries
    End If

    Return 0  Note: Don't align other branches (increases code size)
End Process

Process called "get_multi_byte_nop_size" takes alignment_needed as Integer returns Integer:
    Note: Get optimal multi-byte NOP sequence size
    Note: x86-64 supports 1-15 byte NOPs for alignment
    Note: alignment_needed: number of bytes to pad
    Note: Returns recommended NOP sequence size

    Note: Use longest efficient NOP sequence
    If alignment_needed is greater than or equal to 9:
        Return 9  Note: 9-byte NOP is maximum efficient
    End If

    If alignment_needed is greater than or equal to 1:
        Return alignment_needed  Note: Use exact size needed
    End If

    Return 0  Note: No NOP needed
End Process

Note: ============================================================================
Note: REX PREFIX HELPERS
Note: ============================================================================

Process called "needs_rex_prefix" takes reg_num as Integer, is_64bit as Integer returns Integer:
    Note: Check if instruction needs REX prefix
    Note: REX prefix required for: 64-bit ops, R8-R15, or new 8-bit regs
    Note: Returns 1 if needs REX, 0 otherwise

    Note: 64-bit operand size requires REX.W
    If is_64bit is equal to 1:
        Return 1  Note: REX.W required for 64-bit
    End If

    Note: R8-R15 require REX prefix
    If reg_num is greater than or equal to 8:
        If reg_num is less than or equal to 15:
            Return 1  Note: REX required for extended registers
        End If
    End If

    Return 0  Note: No REX needed
End Process

Process called "get_rex_byte" takes is_64bit as Integer, reg_num as Integer, rm_num as Integer returns Integer:
    Note: Calculate REX prefix byte
    Note: REX byte: 0100WRXB
    Note: W=1 for 64-bit, R=reg extension, X=index extension, B=r/m extension
    Note: Returns REX byte value (0x40-0x4F)

    Let rex be 64  Note: Base REX prefix (0x40)

    Note: Set W bit for 64-bit operand
    If is_64bit is equal to 1:
        Set rex to rex bitwise_or 8  Note: REX.W (0x48)
    End If

    Note: Set R bit if reg >= 8
    If reg_num is greater than or equal to 8:
        Set rex to rex bitwise_or 4  Note: REX.R (0x44)
    End If

    Note: Set B bit if r/m >= 8
    If rm_num is greater than or equal to 8:
        Set rex to rex bitwise_or 1  Note: REX.B (0x41)
    End If

    Return rex
End Process
