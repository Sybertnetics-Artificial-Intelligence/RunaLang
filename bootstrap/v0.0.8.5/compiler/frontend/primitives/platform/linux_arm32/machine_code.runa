Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
Linux ARM32 Machine Code Generation

This file implements ARM32 (ARMv7) machine code encoding for Linux.

ARM32 Instruction Encoding:
- Fixed 32-bit (4-byte) instructions in ARM mode
- Little-endian byte order
- Three-operand format: op Rd, Rn, Rm
- Load/store architecture (memory access only via LDR/STR)
- PC-relative addressing for branches
- Conditional execution on all instructions

IMPORTANT: ARM32 machine code is IDENTICAL across platforms (Linux, Android, etc).
The CPU doesn't know what OS is running - it just executes ARM32 instructions.
Platform differences are in:
1. Object file format (ELF for Linux vs different for other platforms)
2. Relocation types (handled by assembler/linker)
3. Symbol table format (handled by assembler/linker)

At the instruction level, a MOV instruction on Linux is byte-for-byte
identical to the same MOV instruction on Android or other ARM32 platforms.

This file provides comprehensive encoding utilities for ARM32 instructions.
For complete ARM32 instruction encoding, reference the ARM Architecture
Reference Manual for ARMv7-A.

Dependencies: memory_core.runa for buffer operations
:End Note

Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Note: ============================================================================
Note: INSTRUCTION BUFFER OPERATIONS
Note: ============================================================================

Process called "emit_word" takes buffer as Integer, offset as Integer, value as Integer returns Integer:
    Note: Emit a 32-bit word (4 bytes) to instruction buffer
    Note: ARM32 instructions are 4 bytes in little-endian format

    Note: Write 4 bytes in little-endian order
    Let byte0 be value bitwise_and 255
    Let byte1 be (value divided by 256) bitwise_and 255
    Let byte2 be (value divided by 65536) bitwise_and 255
    Let byte3 be (value divided by 16777216) bitwise_and 255

    Memory.memory_set_byte(buffer plus offset, byte0)
    Memory.memory_set_byte(buffer plus offset plus 1, byte1)
    Memory.memory_set_byte(buffer plus offset plus 2, byte2)
    Memory.memory_set_byte(buffer plus offset plus 3, byte3)

    Return offset plus 4
End Process

Process called "emit_halfword" takes buffer as Integer, offset as Integer, value as Integer returns Integer:
    Note: Emit a 16-bit halfword (2 bytes) for Thumb mode
    Note: Little-endian format

    Let byte0 be value bitwise_and 255
    Let byte1 be (value divided by 256) bitwise_and 255

    Memory.memory_set_byte(buffer plus offset, byte0)
    Memory.memory_set_byte(buffer plus offset plus 1, byte1)

    Return offset plus 2
End Process

Note: ============================================================================
Note: ARM32 DATA MOVEMENT INSTRUCTIONS
Note: ============================================================================

Process called "emit_mov" takes buffer as Integer, offset as Integer, rd as Integer, rm as Integer, condition as Integer returns Integer:
    Note: Emit MOV instruction: MOV<cond> Rd, Rm
    Note: Encoding: cond|00|1|1101|0|0000|Rd|00000000|Rm

    Let cond_bits be condition shifted_left 28
    Let opcode_bits be 13 shifted_left 21  Note: MOV opcode
    Let rd_bits be rd shifted_left 12
    Let rm_bits be rm

    Let instruction be cond_bits bitwise_or opcode_bits bitwise_or rd_bits bitwise_or rm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_movw" takes buffer as Integer, offset as Integer, rd as Integer, immediate as Integer, condition as Integer returns Integer:
    Note: Emit MOVW (move wide) to load lower 16 bits into Rd
    Note: Encoding (ARMv7): cond|0011|00|0|100|Rd|imm4|imm12
    Note: imm16 split as imm4:imm12

    Let cond_bits be condition shifted_left 28
    Let op_base be 0x03000000  Note: MOVW opcode base (0011 0000 ...)
    Let rd_bits be rd shifted_left 12

    Let imm16 be immediate bitwise_and 65535
    Let imm4 be (imm16 shifted_right 12) bitwise_and 15
    Let imm12 be imm16 bitwise_and 4095

    Let instruction be cond_bits bitwise_or op_base bitwise_or rd_bits bitwise_or (imm4 shifted_left 16) bitwise_or imm12
    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_movt" takes buffer as Integer, offset as Integer, rd as Integer, immediate as Integer, condition as Integer returns Integer:
    Note: Emit MOVT (move top) to load upper 16 bits into Rd
    Note: Encoding (ARMv7): cond|0011|00|1|100|Rd|imm4|imm12

    Let cond_bits be condition shifted_left 28
    Let op_base be 0x03400000  Note: MOVT opcode base
    Let rd_bits be rd shifted_left 12

    Let imm16 be immediate bitwise_and 65535
    Let imm4 be (imm16 shifted_right 12) bitwise_and 15
    Let imm12 be imm16 bitwise_and 4095

    Let instruction be cond_bits bitwise_or op_base bitwise_or rd_bits bitwise_or (imm4 shifted_left 16) bitwise_or imm12
    Return emit_word(buffer, offset, instruction)
End Process

Process called "encode_arm_imm12" takes value as Integer returns Integer:
    Note: Encode an ARM data-processing immediate as imm12 (8-bit value rotated right by an even amount 0..30)
    Note: Returns imm12 encoding (bits [11:8]=rotate/2, [7:0]=imm8), or -1 if not encodable

    Let v be value bitwise_and 4294967295  Note: Treat as 32-bit

    Let rot be 0
    While rot is less than 16:
        Let rotated be (v rotated_right (rot multiplied by 2))
        Let imm8_candidate be rotated bitwise_and 255

        If rotated is equal to imm8_candidate:
            Let imm12 be (rot shifted_left 8) bitwise_or imm8_candidate
            Return imm12
        End If

        Set rot to rot plus 1
    End While

    Return -1
End Process

Process called "emit_mov_imm" takes buffer as Integer, offset as Integer, rd as Integer, immediate as Integer, condition as Integer returns Integer:
    Note: Emit MOV with immediate: MOV<cond> Rd, #immediate
    Note: Uses full ARM immediate encoding (8-bit rotated even 0..30). Falls back to MVN if ~imm encodable.

    Let cond_bits be condition shifted_left 28
    Let i_bit be 1 shifted_left 25  Note: Immediate flag
    Let opcode_mov be 13 shifted_left 21  Note: MOV opcode
    Let opcode_mvn be 15 shifted_left 21  Note: MVN opcode
    Let rd_bits be rd shifted_left 12

    Let imm12 be encode_arm_imm12(immediate)
    If imm12 is not equal to -1:
        Let instruction be cond_bits bitwise_or i_bit bitwise_or opcode_mov bitwise_or rd_bits bitwise_or imm12
        Return emit_word(buffer, offset, instruction)
    End If

    Note: Try MVN with bitwise NOT of immediate
    Let complement be immediate bitwise_xor -1
    Let imm12_mvn be encode_arm_imm12(complement)
    If imm12_mvn is not equal to -1:
        Let instruction2 be cond_bits bitwise_or i_bit bitwise_or opcode_mvn bitwise_or rd_bits bitwise_or imm12_mvn
        Return emit_word(buffer, offset, instruction2)
    End If

    Note: Fallback to MOVW/MOVT sequence for full 32-bit immediate
    Let low16 be immediate bitwise_and 65535
    Let high16 be (immediate shifted_right 16) bitwise_and 65535

    Let cur_off be offset
    Set cur_off to emit_movw(buffer, cur_off, rd, low16, condition)
    If high16 is not equal to 0:
        Set cur_off to emit_movt(buffer, cur_off, rd, high16, condition)
    End If
    Return cur_off
End Process

Process called "emit_mvn" takes buffer as Integer, offset as Integer, rd as Integer, rm as Integer, condition as Integer returns Integer:
    Note: Emit MVN instruction: MVN<cond> Rd, Rm (move NOT)
    Note: Encoding: cond|00|1|1111|0|0000|Rd|00000000|Rm

    Let cond_bits be condition shifted_left 28
    Let opcode_bits be 15 shifted_left 21  Note: MVN opcode
    Let rd_bits be rd shifted_left 12
    Let rm_bits be rm

    Let instruction be cond_bits bitwise_or opcode_bits bitwise_or rd_bits bitwise_or rm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Note: ============================================================================
Note: ARM32 ARITHMETIC INSTRUCTIONS
Note: ============================================================================

Process called "emit_add" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, rm as Integer, condition as Integer returns Integer:
    Note: Emit ADD instruction: ADD<cond> Rd, Rn, Rm

    Let cond_bits be condition shifted_left 28
    Let opcode_bits be 4 shifted_left 21  Note: ADD opcode
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let rm_bits be rm

    Let instruction be cond_bits bitwise_or opcode_bits bitwise_or rn_bits bitwise_or rd_bits bitwise_or rm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_add_imm" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, immediate as Integer, condition as Integer returns Integer:
    Note: Emit ADD with immediate: ADD<cond> Rd, Rn, #immediate

    Let cond_bits be condition shifted_left 28
    Let i_bit be 1 shifted_left 25  Note: Immediate flag
    Let opcode_bits be 4 shifted_left 21  Note: ADD opcode
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let imm_bits be immediate bitwise_and 255

    Let instruction be cond_bits bitwise_or i_bit bitwise_or opcode_bits bitwise_or rn_bits bitwise_or rd_bits bitwise_or imm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_sub" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, rm as Integer, condition as Integer returns Integer:
    Note: Emit SUB instruction: SUB<cond> Rd, Rn, Rm

    Let cond_bits be condition shifted_left 28
    Let opcode_bits be 2 shifted_left 21  Note: SUB opcode
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let rm_bits be rm

    Let instruction be cond_bits bitwise_or opcode_bits bitwise_or rn_bits bitwise_or rd_bits bitwise_or rm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_sub_imm" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, immediate as Integer, condition as Integer returns Integer:
    Note: Emit SUB with immediate: SUB<cond> Rd, Rn, #immediate

    Let cond_bits be condition shifted_left 28
    Let i_bit be 1 shifted_left 25  Note: Immediate flag
    Let opcode_bits be 2 shifted_left 21  Note: SUB opcode
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let imm_bits be immediate bitwise_and 255

    Let instruction be cond_bits bitwise_or i_bit bitwise_or opcode_bits bitwise_or rn_bits bitwise_or rd_bits bitwise_or imm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_rsb" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, rm as Integer, condition as Integer returns Integer:
    Note: Emit RSB instruction: RSB<cond> Rd, Rn, Rm (reverse subtract)

    Let cond_bits be condition shifted_left 28
    Let opcode_bits be 3 shifted_left 21  Note: RSB opcode
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let rm_bits be rm

    Let instruction be cond_bits bitwise_or opcode_bits bitwise_or rn_bits bitwise_or rd_bits bitwise_or rm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_mul" takes buffer as Integer, offset as Integer, rd as Integer, rm as Integer, rs as Integer, condition as Integer returns Integer:
    Note: Emit MUL instruction: MUL<cond> Rd, Rm, Rs

    Let cond_bits be condition shifted_left 28
    Let opcode_bits be 0 shifted_left 21  Note: MUL is in a different encoding space
    Let mul_bit be 9 shifted_left 4  Note: MUL opcode pattern
    Let rd_bits be rd shifted_left 16
    Let rs_bits be rs shifted_left 8
    Let rm_bits be rm

    Let instruction be cond_bits bitwise_or opcode_bits bitwise_or mul_bit bitwise_or rd_bits bitwise_or rs_bits bitwise_or rm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_mla" takes buffer as Integer, offset as Integer, rd as Integer, rm as Integer, rs as Integer, rn as Integer, condition as Integer returns Integer:
    Note: Emit MLA instruction: MLA<cond> Rd, Rm, Rs, Rn (multiply-accumulate)
    Note: Rd = (Rm * Rs) + Rn

    Let cond_bits be condition shifted_left 28
    Let a_bit be 1 shifted_left 21  Note: Accumulate bit
    Let mul_bit be 9 shifted_left 4  Note: MUL opcode pattern
    Let rd_bits be rd shifted_left 16
    Let rn_bits be rn shifted_left 12
    Let rs_bits be rs shifted_left 8
    Let rm_bits be rm

    Let instruction be cond_bits bitwise_or a_bit bitwise_or mul_bit bitwise_or rd_bits bitwise_or rn_bits bitwise_or rs_bits bitwise_or rm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Note: ============================================================================
Note: ARM32 LOGICAL INSTRUCTIONS
Note: ============================================================================

Process called "emit_and" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, rm as Integer, condition as Integer returns Integer:
    Note: Emit AND instruction: AND<cond> Rd, Rn, Rm

    Let cond_bits be condition shifted_left 28
    Let opcode_bits be 0 shifted_left 21  Note: AND opcode
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let rm_bits be rm

    Let instruction be cond_bits bitwise_or opcode_bits bitwise_or rn_bits bitwise_or rd_bits bitwise_or rm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_orr" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, rm as Integer, condition as Integer returns Integer:
    Note: Emit ORR instruction: ORR<cond> Rd, Rn, Rm

    Let cond_bits be condition shifted_left 28
    Let opcode_bits be 12 shifted_left 21  Note: ORR opcode
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let rm_bits be rm

    Let instruction be cond_bits bitwise_or opcode_bits bitwise_or rn_bits bitwise_or rd_bits bitwise_or rm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_eor" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, rm as Integer, condition as Integer returns Integer:
    Note: Emit EOR instruction: EOR<cond> Rd, Rn, Rm (XOR)

    Let cond_bits be condition shifted_left 28
    Let opcode_bits be 1 shifted_left 21  Note: EOR opcode
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let rm_bits be rm

    Let instruction be cond_bits bitwise_or opcode_bits bitwise_or rn_bits bitwise_or rd_bits bitwise_or rm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_bic" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, rm as Integer, condition as Integer returns Integer:
    Note: Emit BIC instruction: BIC<cond> Rd, Rn, Rm (bit clear)

    Let cond_bits be condition shifted_left 28
    Let opcode_bits be 14 shifted_left 21  Note: BIC opcode
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let rm_bits be rm

    Let instruction be cond_bits bitwise_or opcode_bits bitwise_or rn_bits bitwise_or rd_bits bitwise_or rm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Note: ============================================================================
Note: ARM32 SHIFT INSTRUCTIONS
Note: ============================================================================

Process called "emit_lsl" takes buffer as Integer, offset as Integer, rd as Integer, rm as Integer, shift_amount as Integer, condition as Integer returns Integer:
    Note: Emit LSL instruction: LSL<cond> Rd, Rm, #shift_amount (logical shift left)
    Note: LSL is encoded as MOV with shift

    Let cond_bits be condition shifted_left 28
    Let opcode_bits be 13 shifted_left 21  Note: MOV opcode
    Let rd_bits be rd shifted_left 12
    Let shift_bits be shift_amount shifted_left 7
    Let shift_type be 0 shifted_left 5  Note: LSL = 00
    Let rm_bits be rm

    Let instruction be cond_bits bitwise_or opcode_bits bitwise_or rd_bits bitwise_or shift_bits bitwise_or shift_type bitwise_or rm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_lsr" takes buffer as Integer, offset as Integer, rd as Integer, rm as Integer, shift_amount as Integer, condition as Integer returns Integer:
    Note: Emit LSR instruction: LSR<cond> Rd, Rm, #shift_amount (logical shift right)

    Let cond_bits be condition shifted_left 28
    Let opcode_bits be 13 shifted_left 21  Note: MOV opcode
    Let rd_bits be rd shifted_left 12
    Let shift_bits be shift_amount shifted_left 7
    Let shift_type be 1 shifted_left 5  Note: LSR = 01
    Let rm_bits be rm

    Let instruction be cond_bits bitwise_or opcode_bits bitwise_or rd_bits bitwise_or shift_bits bitwise_or shift_type bitwise_or rm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_asr" takes buffer as Integer, offset as Integer, rd as Integer, rm as Integer, shift_amount as Integer, condition as Integer returns Integer:
    Note: Emit ASR instruction: ASR<cond> Rd, Rm, #shift_amount (arithmetic shift right)

    Let cond_bits be condition shifted_left 28
    Let opcode_bits be 13 shifted_left 21  Note: MOV opcode
    Let rd_bits be rd shifted_left 12
    Let shift_bits be shift_amount shifted_left 7
    Let shift_type be 2 shifted_left 5  Note: ASR = 10
    Let rm_bits be rm

    Let instruction be cond_bits bitwise_or opcode_bits bitwise_or rd_bits bitwise_or shift_bits bitwise_or shift_type bitwise_or rm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_ror" takes buffer as Integer, offset as Integer, rd as Integer, rm as Integer, shift_amount as Integer, condition as Integer returns Integer:
    Note: Emit ROR instruction: ROR<cond> Rd, Rm, #shift_amount (rotate right)

    Let cond_bits be condition shifted_left 28
    Let opcode_bits be 13 shifted_left 21  Note: MOV opcode
    Let rd_bits be rd shifted_left 12
    Let shift_bits be shift_amount shifted_left 7
    Let shift_type be 3 shifted_left 5  Note: ROR = 11
    Let rm_bits be rm

    Let instruction be cond_bits bitwise_or opcode_bits bitwise_or rd_bits bitwise_or shift_bits bitwise_or shift_type bitwise_or rm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Note: ============================================================================
Note: ARM32 LOAD/STORE INSTRUCTIONS
Note: ============================================================================

Process called "emit_ldr" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, offset_imm as Integer, condition as Integer returns Integer:
    Note: Emit LDR instruction: LDR<cond> Rd, [Rn, #+/-offset]
    Note: Supports positive/negative 12-bit offset, pre-indexed, no write-back (U bit selects sign)

    Let cond_bits be condition shifted_left 28
    Let i_bit be 0 shifted_left 25  Note: Immediate offset addressing
    Let p_bit be 1 shifted_left 24  Note: Pre-indexed
    Let u_bit be 1 shifted_left 23
    Let b_bit be 0 shifted_left 22  Note: Word (not byte)
    Let w_bit be 0 shifted_left 21  Note: No write-back
    Let l_bit be 1 shifted_left 20  Note: Load
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12

    Let off be offset_imm
    Let sign_negative be 0
    If off is less than 0:
        Set sign_negative to 1
        Set off to 0 minus off
    End If

    Let off12 be off bitwise_and 4095
    If sign_negative is equal to 1:
        Set u_bit to 0 shifted_left 23  Note: Subtract offset
    End If

    Let instruction be cond_bits bitwise_or i_bit bitwise_or p_bit bitwise_or u_bit bitwise_or b_bit bitwise_or w_bit bitwise_or l_bit bitwise_or rn_bits bitwise_or rd_bits bitwise_or off12

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_ldr_post" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, offset_imm as Integer, condition as Integer returns Integer:
    Note: LDR post-indexed: LDR<cond> Rd, [Rn], #+/-offset
    Let cond_bits be condition shifted_left 28
    Let i_bit be 0 shifted_left 25
    Let p_bit be 0 shifted_left 24  Note: Post-indexed
    Let u_bit be 1 shifted_left 23
    Let b_bit be 0 shifted_left 22
    Let w_bit be 0 shifted_left 21
    Let l_bit be 1 shifted_left 20
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let off be offset_imm
    If off is less than 0:
        Set u_bit to 0 shifted_left 23
        Set off to 0 minus off
    End If
    Let off12 be off bitwise_and 4095
    Let instruction be cond_bits bitwise_or i_bit bitwise_or p_bit bitwise_or u_bit bitwise_or b_bit bitwise_or w_bit bitwise_or l_bit bitwise_or rn_bits bitwise_or rd_bits bitwise_or off12
    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_str" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, offset_imm as Integer, condition as Integer returns Integer:
    Note: Emit STR instruction: STR<cond> Rd, [Rn, #offset]

    Let cond_bits be condition shifted_left 28
    Let i_bit be 0 shifted_left 25
    Let p_bit be 1 shifted_left 24  Note: Pre-indexed
    Let u_bit be 1 shifted_left 23  Note: Add offset
    Let b_bit be 0 shifted_left 22  Note: Word (not byte)
    Let w_bit be 0 shifted_left 21  Note: No write-back
    Let l_bit be 0 shifted_left 20  Note: Store (not load)
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let offset_bits be offset_imm bitwise_and 4095

    Let instruction be cond_bits bitwise_or i_bit bitwise_or p_bit bitwise_or u_bit bitwise_or b_bit bitwise_or w_bit bitwise_or l_bit bitwise_or rn_bits bitwise_or rd_bits bitwise_or offset_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_str_post" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, offset_imm as Integer, condition as Integer returns Integer:
    Note: STR post-indexed
    Let cond_bits be condition shifted_left 28
    Let i_bit be 0 shifted_left 25
    Let p_bit be 0 shifted_left 24
    Let u_bit be 1 shifted_left 23
    Let b_bit be 0 shifted_left 22
    Let w_bit be 0 shifted_left 21
    Let l_bit be 0 shifted_left 20
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let off be offset_imm
    If off is less than 0:
        Set u_bit to 0 shifted_left 23
        Set off to 0 minus off
    End If
    Let off12 be off bitwise_and 4095
    Let instruction be cond_bits bitwise_or i_bit bitwise_or p_bit bitwise_or u_bit bitwise_or b_bit bitwise_or w_bit bitwise_or l_bit bitwise_or rn_bits bitwise_or rd_bits bitwise_or off12
    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_ldrb" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, offset_imm as Integer, condition as Integer returns Integer:
    Note: Emit LDRB instruction: LDRB<cond> Rd, [Rn, #offset] (load byte)

    Let cond_bits be condition shifted_left 28
    Let i_bit be 0 shifted_left 25
    Let p_bit be 1 shifted_left 24  Note: Pre-indexed
    Let u_bit be 1 shifted_left 23  Note: Add offset
    Let b_bit be 1 shifted_left 22  Note: Byte
    Let w_bit be 0 shifted_left 21  Note: No write-back
    Let l_bit be 1 shifted_left 20  Note: Load
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let offset_bits be offset_imm bitwise_and 4095

    Let instruction be cond_bits bitwise_or i_bit bitwise_or p_bit bitwise_or u_bit bitwise_or b_bit bitwise_or w_bit bitwise_or l_bit bitwise_or rn_bits bitwise_or rd_bits bitwise_or offset_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_strb" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, offset_imm as Integer, condition as Integer returns Integer:
    Note: Emit STRB instruction: STRB<cond> Rd, [Rn, #offset] (store byte)

    Let cond_bits be condition shifted_left 28
    Let i_bit be 0 shifted_left 25
    Let p_bit be 1 shifted_left 24  Note: Pre-indexed
    Let u_bit be 1 shifted_left 23  Note: Add offset
    Let b_bit be 1 shifted_left 22  Note: Byte
    Let w_bit be 0 shifted_left 21  Note: No write-back
    Let l_bit be 0 shifted_left 20  Note: Store
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let offset_bits be offset_imm bitwise_and 4095

    Let instruction be cond_bits bitwise_or i_bit bitwise_or p_bit bitwise_or u_bit bitwise_or b_bit bitwise_or w_bit bitwise_or l_bit bitwise_or rn_bits bitwise_or rd_bits bitwise_or offset_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_ldrh" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, offset_imm as Integer, condition as Integer returns Integer:
    Note: LDRH halfword (immediate offset)
    Let cond_bits be condition shifted_left 28
    Let op_base be 0x01B00000  Note: halfword transfer with immediate
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let off8_high be (offset_imm shifted_right 4) bitwise_and 240
    Let off8_low be offset_imm bitwise_and 15
    Let instruction be cond_bits bitwise_or op_base bitwise_or rn_bits bitwise_or rd_bits bitwise_or off8_high bitwise_or off8_low
    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_strh" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, offset_imm as Integer, condition as Integer returns Integer:
    Note: STRH halfword (immediate offset)
    Let cond_bits be condition shifted_left 28
    Let op_base be 0x01A00000
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let off8_high be (offset_imm shifted_right 4) bitwise_and 240
    Let off8_low be offset_imm bitwise_and 15
    Let instruction be cond_bits bitwise_or op_base bitwise_or rn_bits bitwise_or rd_bits bitwise_or off8_high bitwise_or off8_low
    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_ldrsb" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, operand2 as Integer, condition as Integer returns Integer:
    Note: LDRSB (register offset form)
    Let cond_bits be condition shifted_left 28
    Let op_base be 0x000D00D0  Note: sign-extend byte load base (register offset)
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let instruction be cond_bits bitwise_or op_base bitwise_or rn_bits bitwise_or rd_bits bitwise_or operand2
    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_ldrsh" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, operand2 as Integer, condition as Integer returns Integer:
    Note: LDRSH (register offset)
    Let cond_bits be condition shifted_left 28
    Let op_base be 0x000F00D0
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let instruction be cond_bits bitwise_or op_base bitwise_or rn_bits bitwise_or rd_bits bitwise_or operand2
    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_ldrt" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, offset_imm as Integer, condition as Integer returns Integer:
    Note: LDRT (privilege-ignored user mode) immediate; optional for completeness
    Let cond_bits be condition shifted_left 28
    Let base be 0x04400000
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let off12 be offset_imm bitwise_and 4095
    Let instruction be cond_bits bitwise_or base bitwise_or rn_bits bitwise_or rd_bits bitwise_or off12
    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_ldr_reg" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, operand2 as Integer, condition as Integer returns Integer:
    Note: LDR with register offset (operand2 encodes shift)
    Let cond_bits be condition shifted_left 28
    Let i_bit be 1 shifted_left 25  Note: Register offset
    Let p_bit be 1 shifted_left 24
    Let u_bit be 1 shifted_left 23
    Let b_bit be 0 shifted_left 22
    Let w_bit be 0 shifted_left 21
    Let l_bit be 1 shifted_left 20
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let instruction be cond_bits bitwise_or i_bit bitwise_or p_bit bitwise_or u_bit bitwise_or b_bit bitwise_or w_bit bitwise_or l_bit bitwise_or rn_bits bitwise_or rd_bits bitwise_or operand2
    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_str_reg" takes buffer as Integer, offset as Integer, rd as Integer, rn as Integer, operand2 as Integer, condition as Integer returns Integer:
    Note: STR with register offset
    Let cond_bits be condition shifted_left 28
    Let i_bit be 1 shifted_left 25
    Let p_bit be 1 shifted_left 24
    Let u_bit be 1 shifted_left 23
    Let b_bit be 0 shifted_left 22
    Let w_bit be 0 shifted_left 21
    Let l_bit be 0 shifted_left 20
    Let rn_bits be rn shifted_left 16
    Let rd_bits be rd shifted_left 12
    Let instruction be cond_bits bitwise_or i_bit bitwise_or p_bit bitwise_or u_bit bitwise_or b_bit bitwise_or w_bit bitwise_or l_bit bitwise_or rn_bits bitwise_or rd_bits bitwise_or operand2
    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_push" takes buffer as Integer, offset as Integer, register_list as Integer, condition as Integer returns Integer:
    Note: Emit PUSH instruction: PUSH<cond> {register_list}
    Note: PUSH is encoded as STMDB SP!, {register_list}

    Let cond_bits be condition shifted_left 28
    Let p_bit be 1 shifted_left 24  Note: Pre-decrement
    Let u_bit be 0 shifted_left 23  Note: Decrement (down)
    Let s_bit be 0 shifted_left 22
    Let w_bit be 1 shifted_left 21  Note: Write-back
    Let l_bit be 0 shifted_left 20  Note: Store
    Let rn_bits be 13 shifted_left 16  Note: SP (R13)
    Let reglist_bits be register_list bitwise_and 65535

    Let instruction be cond_bits bitwise_or p_bit bitwise_or u_bit bitwise_or s_bit bitwise_or w_bit bitwise_or l_bit bitwise_or rn_bits bitwise_or reglist_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_pop" takes buffer as Integer, offset as Integer, register_list as Integer, condition as Integer returns Integer:
    Note: Emit POP instruction: POP<cond> {register_list}
    Note: POP is encoded as LDMIA SP!, {register_list}

    Let cond_bits be condition shifted_left 28
    Let p_bit be 0 shifted_left 24  Note: Post-increment
    Let u_bit be 1 shifted_left 23  Note: Increment (up)
    Let s_bit be 0 shifted_left 22
    Let w_bit be 1 shifted_left 21  Note: Write-back
    Let l_bit be 1 shifted_left 20  Note: Load
    Let rn_bits be 13 shifted_left 16  Note: SP (R13)
    Let reglist_bits be register_list bitwise_and 65535

    Let instruction be cond_bits bitwise_or p_bit bitwise_or u_bit bitwise_or s_bit bitwise_or w_bit bitwise_or l_bit bitwise_or rn_bits bitwise_or reglist_bits

    Return emit_word(buffer, offset, instruction)
End Process

Note: ============================================================================
Note: ARM32 COMPARISON INSTRUCTIONS
Note: ============================================================================

Process called "emit_cmp" takes buffer as Integer, offset as Integer, rn as Integer, rm as Integer, condition as Integer returns Integer:
    Note: Emit CMP instruction: CMP<cond> Rn, Rm

    Let cond_bits be condition shifted_left 28
    Let opcode_bits be 10 shifted_left 21  Note: CMP opcode
    Let s_bit be 1 shifted_left 20  Note: Set condition codes
    Let rn_bits be rn shifted_left 16
    Let rm_bits be rm

    Let instruction be cond_bits bitwise_or opcode_bits bitwise_or s_bit bitwise_or rn_bits bitwise_or rm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_cmp_imm" takes buffer as Integer, offset as Integer, rn as Integer, immediate as Integer, condition as Integer returns Integer:
    Note: Emit CMP with immediate: CMP<cond> Rn, #immediate

    Let cond_bits be condition shifted_left 28
    Let i_bit be 1 shifted_left 25  Note: Immediate flag
    Let opcode_bits be 10 shifted_left 21  Note: CMP opcode
    Let s_bit be 1 shifted_left 20  Note: Set condition codes
    Let rn_bits be rn shifted_left 16
    Let imm_bits be immediate bitwise_and 255

    Let instruction be cond_bits bitwise_or i_bit bitwise_or opcode_bits bitwise_or s_bit bitwise_or rn_bits bitwise_or imm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_tst" takes buffer as Integer, offset as Integer, rn as Integer, rm as Integer, condition as Integer returns Integer:
    Note: Emit TST instruction: TST<cond> Rn, Rm (test bits)

    Let cond_bits be condition shifted_left 28
    Let opcode_bits be 8 shifted_left 21  Note: TST opcode
    Let s_bit be 1 shifted_left 20  Note: Set condition codes
    Let rn_bits be rn shifted_left 16
    Let rm_bits be rm

    Let instruction be cond_bits bitwise_or opcode_bits bitwise_or s_bit bitwise_or rn_bits bitwise_or rm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Note: ============================================================================
Note: ARM32 BRANCH INSTRUCTIONS
Note: ============================================================================

Process called "emit_b" takes buffer as Integer, offset as Integer, target as Integer, pc as Integer, condition as Integer returns Integer:
    Note: PC-relative branch. target and pc are byte addresses; ARM subtracts 8 prefetch.
    Let cond_bits be condition shifted_left 28
    Let op_base be 0x0A000000
    Let delta_bytes be target minus (pc plus 8)
    Let delta_words be delta_bytes divided by 4
    If delta_words is less than -33554432:
        Return -1
    End If
    If delta_words is greater than 33554431:
        Return -1
    End If
    Let imm24 be delta_words bitwise_and 16777215
    Let instruction be cond_bits bitwise_or op_base bitwise_or imm24
    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_bl" takes buffer as Integer, offset as Integer, target as Integer, pc as Integer, condition as Integer returns Integer:
    Let cond_bits be condition shifted_left 28
    Let op_base be 0x0B000000
    Let delta_bytes be target minus (pc plus 8)
    Let delta_words be delta_bytes divided by 4
    If delta_words is less than -33554432:
        Return -1
    End If
    If delta_words is greater than 33554431:
        Return -1
    End If
    Let imm24 be delta_words bitwise_and 16777215
    Let instruction be cond_bits bitwise_or op_base bitwise_or imm24
    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_bx" takes buffer as Integer, offset as Integer, rm as Integer, condition as Integer returns Integer:
    Note: Branch to register (BX)
    Let cond_bits be condition shifted_left 28
    Let op_base be 0x012FFF10
    Let rm_bits be rm
    Let instruction be cond_bits bitwise_or op_base bitwise_or rm_bits
    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_blx_reg" takes buffer as Integer, offset as Integer, rm as Integer, condition as Integer returns Integer:
    Note: BLX register form
    Let cond_bits be condition shifted_left 28
    Let op_base be 0x012FFF30
    Let rm_bits be rm
    Let instruction be cond_bits bitwise_or op_base bitwise_or rm_bits
    Return emit_word(buffer, offset, instruction)
End Process

Note: ============================================================================
Note: ARM32 SYSTEM INSTRUCTIONS
Note: ============================================================================

Process called "emit_swi" takes buffer as Integer, offset as Integer, syscall_number as Integer, condition as Integer returns Integer:
    Note: Emit SWI instruction: SWI<cond> #number (supervisor call/syscall)

    Let cond_bits be condition shifted_left 28
    Let opcode_bits be 15 shifted_left 24  Note: SWI opcode
    Let imm_bits be syscall_number bitwise_and 16777215

    Let instruction be cond_bits bitwise_or opcode_bits bitwise_or imm_bits

    Return emit_word(buffer, offset, instruction)
End Process

Process called "emit_nop" takes buffer as Integer, offset as Integer returns Integer:
    Note: Emit NOP instruction
    Note: NOP is typically encoded as MOV R0, R0

    Let condition be 14  Note: Always (AL)
    Return emit_mov(buffer, offset, 0, 0, condition)
End Process

Note: ============================================================================
Note: CODE ALIGNMENT AND PADDING
Note: ============================================================================

Process called "align_code" takes buffer as Integer, offset as Integer, alignment as Integer returns Integer:
    Note: Align code to specified byte boundary
    Note: Uses NOP instructions for padding

    Let remainder be offset modulo alignment
    If remainder is equal to 0:
        Return offset  Note: Already aligned
    End If

    Let padding_needed be alignment minus remainder

    Let current_offset be offset
    Let padding_remaining be padding_needed

    While padding_remaining is greater than or equal to 4:
        Set current_offset to emit_nop(buffer, current_offset)
        Set padding_remaining to padding_remaining minus 4
    End While

    Note: If less than 4 bytes padding needed, fill with zeros
    While padding_remaining is greater than 0:
        Memory.memory_set_byte(buffer plus current_offset, 0)
        Set current_offset to current_offset plus 1
        Set padding_remaining to padding_remaining minus 1
    End While

    Return current_offset
End Process

Process called "pad_to_alignment" takes buffer as Integer, offset as Integer, alignment as Integer returns Integer:
    Note: Pad code to alignment boundary
    Note: Alias for align_code
    Return align_code(buffer, offset, alignment)
End Process

Note: =========================================================================
Note: OPERAND2 SHIFTER ENCODING (REGISTER FORMS)
Note: =========================================================================

Process called "encode_shift_imm" takes shift_type as Integer, shift_amount as Integer returns Integer:
    Note: shift_type: 0=LSL, 1=LSR, 2=ASR, 3=ROR
    Let amt be shift_amount bitwise_and 31
    Return (amt shifted_left 7) bitwise_or (shift_type shifted_left 5)
End Process

Process called "operand2_register_shift_imm" takes rm as Integer, shift_type as Integer, shift_amount as Integer returns Integer:
    Let rm_bits be rm
    Let shift_bits be encode_shift_imm(shift_type, shift_amount)
    Return shift_bits bitwise_or rm_bits
End Process

Process called "operand2_register_shift_reg" takes rm as Integer, shift_type as Integer, rs as Integer returns Integer:
    Note: Register-controlled shift (bit 4 set)
    Let rm_bits be rm
    Let bit4 be 1 shifted_left 4
    Let shift_type_bits be shift_type shifted_left 5
    Let rs_bits be rs shifted_left 8
    Return rm_bits bitwise_or bit4 bitwise_or shift_type_bits bitwise_or rs_bits
End Process
