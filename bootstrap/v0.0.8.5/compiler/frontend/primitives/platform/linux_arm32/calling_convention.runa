Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
Linux ARM32 Calling Convention

This file implements the ARM32 calling convention for Linux, which follows
the AAPCS (ARM Architecture Procedure Call Standard).

Linux ARM32 Calling Convention Summary:
- Integer/pointer arguments: R0-R3 (4 registers)
- Floating-point arguments: S0-S15 or D0-D7 (VFP variant)
- Additional arguments: Pushed on stack (right-to-left)
- Return value: R0 (integer/pointer), R0:R1 (64-bit), S0/D0 (float/double)
- Stack alignment: 8-byte aligned at public interfaces (AAPCS)
- Caller-saved (volatile): R0-R3, R12 (IP), S0-S15, D0-D7
- Callee-saved (non-volatile): R4-R11, S16-S31, D8-D15
- Frame pointer: R11 (FP) - optional
- Link register: R14 (LR, stores return address)
- Stack pointer: R13 (SP)

AAPCS notes:
1. Stack must be 8-byte aligned at public interfaces
2. 64-bit values passed in R0:R1 or R2:R3 (even-odd register pairs)
3. Structures larger than 4 bytes: passed by reference or on stack
4. VFP variant uses S0-S15 for single-precision, D0-D7 for double-precision

References:
- ARM Procedure Call Standard for ARM (AAPCS)
- ARM Architecture Reference Manual for ARMv7-A

Dependencies: registers.runa for register mappings
:End Note

Import "compiler/frontend/primitives/platform/linux_arm32/registers.runa" as Registers
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Note: ============================================================================
Note: PARAMETER PASSING - INTEGER AND POINTER ARGUMENTS
Note: ============================================================================

Process called "get_integer_param_register" takes param_index as Integer returns Integer:
    Note: Get register for integer/pointer parameter
    Note: AAPCS: R0-R3 for first 4 parameters

    If param_index is equal to 0:
        Return 0  Note: R0
    End If

    If param_index is equal to 1:
        Return 1  Note: R1
    End If

    If param_index is equal to 2:
        Return 2  Note: R2
    End If

    If param_index is equal to 3:
        Return 3  Note: R3
    End If

    Return -1  Note: On stack
End Process

Process called "get_param_location" takes param_index as Integer, param_size as Integer returns Integer:
    Note: Get location for integer/pointer parameter
    Note: R0-R3 for first 4 parameters, then stack
    Note: Returns: register number (0-15) or negative for stack

    If param_index is less than 4:
        Return param_index  Note: R0-R3
    End If

    Note: On stack - return negative offset from SP
    Let stack_offset be (param_index minus 4) multiplied by 4
    Return -1 minus stack_offset
End Process

Process called "is_param_in_register" takes param_location as Integer returns Integer:
    Note: Check if parameter is in register (vs stack)

    If param_location is greater than or equal to 0:
        If param_location is less than 16:
            Return 1  Note: In register
        End If
    End If

    Return 0  Note: On stack
End Process

Process called "get_stack_param_offset" takes param_index as Integer returns Integer:
    Note: Get stack offset for parameter
    Note: param_index: 0-based parameter index
    Note: Returns: byte offset from SP

    Note: First 4 parameters are in registers
    If param_index is less than 4:
        Return -1  Note: Not on stack
    End If

    Note: Stack parameters start at SP+0
    Let stack_param_index be param_index minus 4
    Return stack_param_index multiplied by 4
End Process

Note: ============================================================================
Note: PARAMETER PASSING - FLOATING-POINT ARGUMENTS
Note: ============================================================================

Process called "get_fp_param_register" takes param_index as Integer, is_double as Integer returns Integer:
    Note: Get VFP register for floating-point parameter
    Note: is_double: 0 for single-precision (S regs), 1 for double-precision (D regs)
    Note: Returns register encoding

    If is_double is equal to 0:
        Note: Single-precision: S0-S15
        If param_index is less than 16:
            Return 16 plus param_index  Note: S0-S15 encoded as 16-31
        End If
    Otherwise:
        Note: Double-precision: D0-D7
        If param_index is less than 8:
            Return 48 plus param_index  Note: D0-D7 encoded as 48-55
        End If
    End If

    Return -1  Note: On stack
End Process

Note: ============================================================================
Note: RETURN VALUE HANDLING
Note: ============================================================================

Process called "get_return_register" returns Integer:
    Note: Get register for integer/pointer return value
    Note: AAPCS: R0 for primary return value
    Return 0  Note: R0
End Process

Process called "get_return_location" takes return_size as Integer returns Integer:
    Note: Get location for return value
    Note: R0 for 32-bit, R0:R1 for 64-bit

    If return_size is less than or equal to 4:
        Return 0  Note: R0
    End If

    If return_size is less than or equal to 8:
        Return 0  Note: R0:R1 (return R0, caller gets R1 separately)
    End If

    Note: Larger values returned via hidden pointer in R0
    Return 0
End Process

Process called "get_secondary_return_register" returns Integer:
    Note: Get secondary return register for 64-bit values
    Note: Used with R0 for returning 64-bit integers
    Return 1  Note: R1
End Process

Process called "get_fp_return_register" takes is_double as Integer returns Integer:
    Note: Get VFP register for floating-point return value
    Note: is_double: 0 for single-precision, 1 for double-precision

    If is_double is equal to 0:
        Return 16  Note: S0
    End If

    Return 48  Note: D0
End Process

Process called "uses_hidden_return_pointer" takes return_size as Integer returns Integer:
    Note: Check if return value uses hidden pointer
    Note: Structures larger than 8 bytes returned via pointer in R0
    Note: Returns 1 if hidden pointer used, 0 otherwise

    If return_size is greater than 8:
        Return 1  Note: Use hidden pointer
    End If

    Return 0
End Process

Note: ============================================================================
Note: REGISTER PRESERVATION
Note: ============================================================================

Process called "is_callee_saved_register" takes reg_num as Integer returns Integer:
    Note: Check if register must be preserved by callee
    Note: AAPCS: R4-R11, S16-S31, D8-D15 are callee-saved

    Return proc is_callee_saved from Registers with reg_num
End Process

Process called "is_caller_saved_register" takes reg_num as Integer returns Integer:
    Note: Check if register is caller-saved
    Note: AAPCS: R0-R3, R12, S0-S15, D0-D7 are caller-saved

    Return proc is_caller_saved from Registers with reg_num
End Process

Process called "get_callee_saved_registers" takes result_buffer as Integer returns Integer:
    Note: Get list of callee-saved registers
    Note: result_buffer: pointer to array to fill with register numbers
    Note: Returns: count of callee-saved registers

    Note: R4-R11 are callee-saved (8 registers)
    proc memory_set_int32 from Memory with result_buffer, 0, 4
    proc memory_set_int32 from Memory with result_buffer, 4, 5
    proc memory_set_int32 from Memory with result_buffer, 8, 6
    proc memory_set_int32 from Memory with result_buffer, 12, 7
    proc memory_set_int32 from Memory with result_buffer, 16, 8
    proc memory_set_int32 from Memory with result_buffer, 20, 9
    proc memory_set_int32 from Memory with result_buffer, 24, 10
    proc memory_set_int32 from Memory with result_buffer, 28, 11

    Return 8
End Process

Note: ============================================================================
Note: STACK FRAME MANAGEMENT
Note: ============================================================================

Process called "get_stack_alignment" returns Integer:
    Note: Get required stack alignment
    Note: AAPCS requires 8-byte alignment at public interfaces
    Return 8
End Process

Process called "get_min_stack_slot_size" returns Integer:
    Note: Get minimum stack slot size
    Note: ARM32 uses 4-byte words
    Return 4
End Process

Process called "calculate_stack_frame_size" takes local_vars_size as Integer, spilled_regs_count as Integer returns Integer:
    Note: Calculate total stack frame size
    Note: Include local variables and spilled registers, aligned to 8 bytes

    Let locals_space be local_vars_size
    Let spilled_space be spilled_regs_count multiplied by 4  Note: 4 bytes per register

    Let total_size be locals_space plus spilled_space

    Note: Align to 8-byte boundary
    Let remainder be total_size modulo 8
    If remainder is not equal to 0:
        Set total_size to total_size plus (8 minus remainder)
    End If

    Return total_size
End Process

Process called "calculate_frame_pointer_offset" takes frame_size as Integer returns Integer:
    Note: Calculate offset of frame pointer from SP
    Note: FP typically points to saved FP/LR at top of frame
    Return frame_size
End Process

Process called "needs_frame_pointer" takes has_variable_args as Integer, has_alloca as Integer, frame_size as Integer returns Integer:
    Note: Determine if frame pointer is needed
    Note: Returns 1 if FP required, 0 otherwise

    Note: Frame pointer needed for variadic functions
    If has_variable_args is not equal to 0:
        Return 1
    End If

    Note: Frame pointer needed if using alloca (variable-size stack allocation)
    If has_alloca is not equal to 0:
        Return 1
    End If

    Note: Frame pointer helpful for large frames or debugging
    If frame_size is greater than 4096:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: FUNCTION PROLOGUE/EPILOGUE
Note: ============================================================================

Process called "calculate_callee_saved_mask" takes uses_r4 as Integer, uses_r5 as Integer, uses_r6 as Integer, uses_r7 as Integer returns Integer:
    Note: Calculate bitmask of callee-saved registers to preserve
    Note: AAPCS: R4-R11 are callee-saved

    Let mask be 0

    If uses_r4 is not equal to 0:
        Set mask to mask bitwise_or 16  Note: R4 bit (1 << 4)
    End If

    If uses_r5 is not equal to 0:
        Set mask to mask bitwise_or 32  Note: R5 bit (1 << 5)
    End If

    If uses_r6 is not equal to 0:
        Set mask to mask bitwise_or 64  Note: R6 bit (1 << 6)
    End If

    If uses_r7 is not equal to 0:
        Set mask to mask bitwise_or 128  Note: R7 bit (1 << 7)
    End If

    Note: Always save LR (R14) if this is a non-leaf function
    Set mask to mask bitwise_or 16384  Note: R14 (LR) bit (1 << 14)

    Return mask
End Process

Process called "get_prologue_size_estimate" takes saves_fp as Integer, callee_saved_count as Integer returns Integer:
    Note: Estimate prologue size in bytes
    Note: saves_fp: 1 if frame pointer saved, 0 otherwise
    Note: callee_saved_count: number of callee-saved registers to preserve

    Note: PUSH {regs} = 4 bytes
    Note: SUB SP, SP, #frame_size = 4 bytes (or 8 if large frame)
    Note: MOV FP, SP = 4 bytes (if using FP)

    Let size be 4  Note: PUSH instruction

    If saves_fp is not equal to 0:
        Set size to size plus 4  Note: FP setup
    End If

    Set size to size plus 4  Note: Stack allocation

    Return size
End Process

Process called "get_epilogue_size_estimate" takes restores_fp as Integer, callee_saved_count as Integer returns Integer:
    Note: Estimate epilogue size in bytes

    Note: ADD SP, SP, #frame_size = 4 bytes (or 8 if large frame)
    Note: POP {regs, pc} = 4 bytes

    Let size be 8  Note: Stack deallocation + POP

    Return size
End Process

Process called "get_prologue_instructions" takes frame_size as Integer, callee_saved_mask as Integer, result_buffer as Integer returns Integer:
    Note: Get instructions needed for function prologue
    Note: result_buffer: pointer to array to fill with instruction info
    Note: Returns: number of instructions needed
    Note: Caller is responsible for emitting actual machine code

    Note: PUSH {callee-saved, lr}
    Note: SUB SP, SP, #frame_size (if frame_size > 0)
    Note: MOV FP, SP (if using frame pointer)

    Let instruction_count be 1  Note: PUSH instruction

    If frame_size is greater than 0:
        Set instruction_count to instruction_count plus 1  Note: SUB SP
    End If

    Note: Store instruction count in result buffer
    proc memory_set_int32 from Memory with result_buffer, 0, instruction_count
    proc memory_set_int32 from Memory with result_buffer, 4, callee_saved_mask
    proc memory_set_int32 from Memory with result_buffer, 8, frame_size

    Return instruction_count
End Process

Process called "get_epilogue_instructions" takes frame_size as Integer, callee_saved_mask as Integer, result_buffer as Integer returns Integer:
    Note: Get instructions needed for function epilogue
    Note: result_buffer: pointer to array to fill with instruction info
    Note: Returns: number of instructions needed
    Note: Caller is responsible for emitting actual machine code

    Note: ADD SP, SP, #frame_size (if frame_size > 0)
    Note: POP {callee-saved, pc}

    Let instruction_count be 1  Note: POP instruction

    If frame_size is greater than 0:
        Set instruction_count to instruction_count plus 1  Note: ADD SP
    End If

    proc memory_set_int32 from Memory with result_buffer, 0, instruction_count
    proc memory_set_int32 from Memory with result_buffer, 4, callee_saved_mask
    proc memory_set_int32 from Memory with result_buffer, 8, frame_size

    Return instruction_count
End Process

Note: ============================================================================
Note: FUNCTION CALL SETUP
Note: ============================================================================

Process called "calculate_call_stack_adjustment" takes num_stack_args as Integer returns Integer:
    Note: Calculate stack space needed for outgoing call arguments
    Note: num_stack_args: number of arguments passed on stack (beyond first 4)
    Note: Returns: stack adjustment in bytes (8-byte aligned)

    If num_stack_args is less than or equal to 0:
        Return 0  Note: No stack arguments
    End If

    Note: Each argument is 4 bytes
    Let args_size be num_stack_args multiplied by 4

    Note: Round up to 8-byte alignment
    Let remainder be args_size bitwise_and 7
    If remainder is not equal to 0:
        Let padding be 8 minus remainder
        Set args_size to args_size plus padding
    End If

    Return args_size
End Process

Process called "get_call_preserved_registers" takes result_buffer as Integer returns Integer:
    Note: Get list of registers caller must preserve
    Note: Returns list of caller-saved registers
    Note: result_buffer: pointer to array to fill
    Note: Returns: count of registers

    Note: R0-R3, R12 are caller-saved (5 registers)
    proc memory_set_int32 from Memory with result_buffer, 0, 0
    proc memory_set_int32 from Memory with result_buffer, 4, 1
    proc memory_set_int32 from Memory with result_buffer, 8, 2
    proc memory_set_int32 from Memory with result_buffer, 12, 3
    proc memory_set_int32 from Memory with result_buffer, 16, 12

    Return 5
End Process

Note: ============================================================================
Note: 64-BIT VALUE HANDLING
Note: ============================================================================

Process called "get_64bit_param_register_pair" takes param_index as Integer, result_buffer as Integer returns Integer:
    Note: Get register pair for 64-bit parameter
    Note: AAPCS: 64-bit values use even-odd register pairs (R0:R1 or R2:R3)
    Note: result_buffer: pointer to 2-integer array [low_reg, high_reg]
    Note: Returns: low register number, or -1 if on stack

    Note: Align param_index to even register
    Let aligned_index be param_index
    If aligned_index modulo 2 is not equal to 0:
        Set aligned_index to aligned_index plus 1
    End If

    If aligned_index is equal to 0:
    proc memory_set_int32 from Memory with result_buffer, 0, 0  Note: R0
    proc memory_set_int32 from Memory with result_buffer, 4, 1  Note: R1
        Return 0
    End If

    If aligned_index is equal to 2:
    proc memory_set_int32 from Memory with result_buffer, 0, 2  Note: R2
    proc memory_set_int32 from Memory with result_buffer, 4, 3  Note: R3
        Return 2
    End If

    Note: Stack-passed 64-bit values
    Return -1
End Process

Note: ============================================================================
Note: VARIADIC FUNCTION SUPPORT
Note: ============================================================================

Process called "get_variadic_gp_register_save_area_size" returns Integer:
    Note: Size of save area for general-purpose register arguments
    Note: AAPCS: 4 registers × 4 bytes = 16 bytes
    Return 16
End Process

Process called "get_variadic_fp_register_save_area_size" returns Integer:
    Note: Size of save area for floating-point register arguments
    Note: AAPCS: 16 S registers × 4 bytes = 64 bytes (or 8 D registers × 8 = 64 bytes)
    Return 64
End Process

Process called "get_variadic_total_save_area_size" returns Integer:
    Note: Total size for variadic function register save area
    Note: GP area (16) + FP area (64) = 80 bytes
    Return 80
End Process

Process called "get_variadic_reg_save_instructions" takes fixed_param_count as Integer, result_buffer as Integer returns Integer:
    Note: Get instructions needed to save variadic register arguments to stack
    Note: fixed_param_count: number of fixed parameters (variadic marker position)
    Note: result_buffer: pointer to array to fill with save info
    Note: Returns: number of register saves needed
    Note: Caller is responsible for emitting actual machine code

    Note: For ARM32 AAPCS, save remaining R0-R3 registers not used by fixed params
    Let first_variadic_reg be fixed_param_count
    Let save_count be 0

    If first_variadic_reg is less than 4:
        Set save_count to 4 minus first_variadic_reg
    End If

    Note: Store save info
    proc memory_set_int32 from Memory with result_buffer, 0, first_variadic_reg
    proc memory_set_int32 from Memory with result_buffer, 4, save_count

    Return save_count
End Process

Note: ============================================================================
Note: STRUCTURE PASSING
Note: ============================================================================

Process called "get_struct_passing_strategy" takes struct_size as Integer returns Integer:
    Note: Determine how to pass structure
    Note: Returns: 0 = in registers, 1 = on stack, 2 = by reference

    Note: Structures up to 4 bytes can be in a single register
    If struct_size is less than or equal to 4:
        Return 0  Note: In register (R0-R3)
    End If

    Note: Structures 5-8 bytes in register pair
    If struct_size is less than or equal to 8:
        Return 0  Note: In register pair (e.g., R0:R1)
    End If

    Note: Larger structures passed by reference
    Return 2  Note: By reference (pointer in register)
End Process

Note: ============================================================================
Note: HELPER FUNCTIONS FOR CODE GENERATION
Note: ============================================================================

Process called "get_parameter_location" takes param_index as Integer, param_size as Integer, result_buffer as Integer returns Integer:
    Note: Get location (register or stack offset) for parameter
    Note: param_index: parameter position (0-based)
    Note: param_size: size in bytes
    Note: result_buffer: pointer to 2-integer array [location_type, value]
    Note: location_type: 0 = register (value = reg_num), 1 = stack (value = offset)
    Note: Returns: location_type

    Let location_type be 0
    Let value be 0

    Note: Check if parameter is in register
    If param_index is less than 4:
        Set location_type to 0  Note: Register
        Set value to get_integer_param_register(param_index)
    Otherwise:
        Set location_type to 1  Note: Stack
        Set value to get_stack_param_offset(param_index)
    End If

    Note: Write results to buffer
    proc memory_set_int32 from Memory with result_buffer, 0, location_type
    proc memory_set_int32 from Memory with result_buffer, 4, value

    Return location_type
End Process

Process called "get_call_setup_info" takes num_params as Integer, result_buffer as Integer returns Integer:
    Note: Get information needed to set up a function call
    Note: num_params: total number of parameters
    Note: result_buffer: pointer to 3-integer array [reg_params, stack_params, stack_adjustment]
    Note: Returns: number of stack parameters

    Let reg_params be 4
    Let stack_params be 0
    Let stack_adjustment be 0

    If num_params is less than or equal to 4:
        Set reg_params to num_params
    Otherwise:
        Set stack_params to num_params minus 4
        Set stack_adjustment to calculate_call_stack_adjustment(stack_params)
    End If

    Note: Write results to buffer
    proc memory_set_int32 from Memory with result_buffer, 0, reg_params
    proc memory_set_int32 from Memory with result_buffer, 4, stack_params
    proc memory_set_int32 from Memory with result_buffer, 8, stack_adjustment

    Return stack_params
End Process

Process called "should_save_link_register" takes is_leaf_function as Integer returns Integer:
    Note: Determine if link register should be saved
    Note: Leaf functions don't need to save LR if they don't call others

    If is_leaf_function is equal to 0:
        Return 1  Note: Non-leaf must save LR
    End If

    Return 0  Note: Leaf functions can avoid saving LR
End Process

Note: ============================================================================
Note: CALLING CONVENTION VALIDATION AND UTILITIES
Note: ============================================================================

Process called "validate_stack_alignment" takes stack_offset as Integer returns Integer:
    Note: Check if stack offset is properly aligned
    Note: Returns 1 if aligned to 8 bytes, 0 otherwise

    Let remainder be stack_offset bitwise_and 7
    If remainder is equal to 0:
        Return 1  Note: Properly aligned
    End If

    Return 0  Note: Misaligned
End Process

Process called "get_calling_convention_name" returns String:
    Note: Return name of calling convention
    Return "ARM32 AAPCS"
End Process

Process called "get_abi_version" returns Integer:
    Note: Return ABI version identifier
    Note: Using AAPCS (ARM Architecture Procedure Call Standard) version 1
    Return 1
End Process

Process called "get_max_register_params" returns Integer:
    Note: Get maximum number of integer parameters that can be passed in registers
    Note: ARM32 AAPCS: 4 registers (R0-R3)
    Return 4
End Process

Process called "get_max_fp_register_params_single" returns Integer:
    Note: Get maximum number of single-precision FP parameters in registers
    Note: ARM32 AAPCS: 16 single-precision registers (S0-S15)
    Return 16
End Process

Process called "get_max_fp_register_params_double" returns Integer:
    Note: Get maximum number of double-precision FP parameters in registers
    Note: ARM32 AAPCS: 8 double-precision registers (D0-D7)
    Return 8
End Process

Process called "requires_register_pair_alignment" takes param_type as Integer returns Integer:
    Note: Check if parameter type requires alignment to even register pair
    Note: param_type: 0 = 32-bit, 1 = 64-bit
    Note: Returns 1 if alignment needed, 0 otherwise

    Note: 64-bit parameters use even-odd register pairs (R0:R1 or R2:R3)
    If param_type is equal to 1:
        Return 1
    End If

    Return 0
End Process
