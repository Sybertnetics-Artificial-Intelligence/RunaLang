Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
Linux ARM32 Instruction Set Metadata and Helpers

This file provides instruction metadata, opcode definitions, and helper functions
for ARM32 (ARMv7) instruction selection, validation, and optimization.

ARM32 (ARMv7) Key Characteristics:
- Fixed 32-bit (4-byte) instruction length in ARM mode
- Variable 16-bit (2-byte) in Thumb mode
- Load/store architecture (memory access only via LDR/STR)
- Three-operand instructions (dest can differ from sources)
- Conditional execution (all instructions can be conditional)
- Barrel shifter for flexible operand2

This includes:
- Instruction opcode patterns
- Instruction properties (latency, throughput)
- Instruction validation helpers
- Instruction selection helpers
- Common instruction patterns
- Optimization hints

IMPORTANT: ARM32 instruction set is IDENTICAL across platforms (Linux, Android, etc).
Platform differences are in calling convention and syscalls, NOT instruction encoding.

Dependencies:
- registers.runa for register metadata
- calling_convention.runa for ABI constraints
:End Note

Import "compiler/frontend/primitives/platform/linux_arm32/registers.runa" as Registers

Note: ============================================================================
Note: INSTRUCTION OPCODE PATTERNS (ARM32)
Note: ============================================================================

Note: ARM32 instruction opcodes for instruction selection

Process called "OP_MOV" returns Integer:
    Return 1  Note: Move register
End Process

Process called "OP_MVN" returns Integer:
    Return 2  Note: Move NOT
End Process

Process called "OP_ADD" returns Integer:
    Return 3  Note: Add
End Process

Process called "OP_ADC" returns Integer:
    Return 4  Note: Add with carry
End Process

Process called "OP_SUB" returns Integer:
    Return 5  Note: Subtract
End Process

Process called "OP_SBC" returns Integer:
    Return 6  Note: Subtract with carry
End Process

Process called "OP_RSB" returns Integer:
    Return 7  Note: Reverse subtract
End Process

Process called "OP_RSC" returns Integer:
    Return 8  Note: Reverse subtract with carry
End Process

Process called "OP_MUL" returns Integer:
    Return 9  Note: Multiply
End Process

Process called "OP_MLA" returns Integer:
    Return 10  Note: Multiply-accumulate
End Process

Process called "OP_UMULL" returns Integer:
    Return 11  Note: Unsigned multiply long
End Process

Process called "OP_SMULL" returns Integer:
    Return 12  Note: Signed multiply long
End Process

Process called "OP_SDIV" returns Integer:
    Return 13  Note: Signed divide (ARMv7-A with div extension)
End Process

Process called "OP_UDIV" returns Integer:
    Return 14  Note: Unsigned divide
End Process

Process called "OP_AND" returns Integer:
    Return 15  Note: Bitwise AND
End Process

Process called "OP_ORR" returns Integer:
    Return 16  Note: Bitwise OR
End Process

Process called "OP_EOR" returns Integer:
    Return 17  Note: Bitwise XOR
End Process

Process called "OP_BIC" returns Integer:
    Return 18  Note: Bit clear
End Process

Process called "OP_CMP" returns Integer:
    Return 19  Note: Compare
End Process

Process called "OP_CMN" returns Integer:
    Return 20  Note: Compare negative
End Process

Process called "OP_TST" returns Integer:
    Return 21  Note: Test bits
End Process

Process called "OP_TEQ" returns Integer:
    Return 22  Note: Test equivalence
End Process

Process called "OP_LDR" returns Integer:
    Return 23  Note: Load register
End Process

Process called "OP_STR" returns Integer:
    Return 24  Note: Store register
End Process

Process called "OP_LDRB" returns Integer:
    Return 25  Note: Load byte
End Process

Process called "OP_STRB" returns Integer:
    Return 26  Note: Store byte
End Process

Process called "OP_LDRH" returns Integer:
    Return 27  Note: Load halfword
End Process

Process called "OP_STRH" returns Integer:
    Return 28  Note: Store halfword
End Process

Process called "OP_LDRSB" returns Integer:
    Return 29  Note: Load signed byte
End Process

Process called "OP_LDRSH" returns Integer:
    Return 30  Note: Load signed halfword
End Process

Process called "OP_LDM" returns Integer:
    Return 31  Note: Load multiple
End Process

Process called "OP_STM" returns Integer:
    Return 32  Note: Store multiple
End Process

Process called "OP_PUSH" returns Integer:
    Return 33  Note: Push to stack
End Process

Process called "OP_POP" returns Integer:
    Return 34  Note: Pop from stack
End Process

Process called "OP_B" returns Integer:
    Return 35  Note: Branch
End Process

Process called "OP_BL" returns Integer:
    Return 36  Note: Branch with link
End Process

Process called "OP_BX" returns Integer:
    Return 37  Note: Branch and exchange
End Process

Process called "OP_BLX" returns Integer:
    Return 38  Note: Branch with link and exchange
End Process

Process called "OP_LSL" returns Integer:
    Return 39  Note: Logical shift left
End Process

Process called "OP_LSR" returns Integer:
    Return 40  Note: Logical shift right
End Process

Process called "OP_ASR" returns Integer:
    Return 41  Note: Arithmetic shift right
End Process

Process called "OP_ROR" returns Integer:
    Return 42  Note: Rotate right
End Process

Process called "OP_RRX" returns Integer:
    Return 43  Note: Rotate right with extend
End Process

Process called "OP_SWI" returns Integer:
    Return 44  Note: Software interrupt (syscall)
End Process

Process called "OP_SVC" returns Integer:
    Return 44  Note: Supervisor call (same as SWI)
End Process

Process called "OP_NOP" returns Integer:
    Return 45  Note: No operation
End Process

Process called "OP_CLZ" returns Integer:
    Return 46  Note: Count leading zeros
End Process

Process called "OP_REV" returns Integer:
    Return 47  Note: Byte reverse word
End Process

Process called "OP_REV16" returns Integer:
    Return 48  Note: Byte reverse packed halfword
End Process

Process called "OP_REVSH" returns Integer:
    Return 49  Note: Byte reverse signed halfword
End Process

Note: VFP/NEON Instructions
Process called "OP_VADD" returns Integer:
    Return 50  Note: Vector add
End Process

Process called "OP_VSUB" returns Integer:
    Return 51  Note: Vector subtract
End Process

Process called "OP_VMUL" returns Integer:
    Return 52  Note: Vector multiply
End Process

Process called "OP_VDIV" returns Integer:
    Return 53  Note: Vector divide
End Process

Process called "OP_VMOV" returns Integer:
    Return 54  Note: Vector move
End Process

Process called "OP_VLDR" returns Integer:
    Return 55  Note: Vector load
End Process

Process called "OP_VSTR" returns Integer:
    Return 56  Note: Vector store
End Process

Note: ============================================================================
Note: CONDITION CODES
Note: ============================================================================

Process called "COND_EQ" returns Integer:
    Return 0  Note: Equal (Z set)
End Process

Process called "COND_NE" returns Integer:
    Return 1  Note: Not equal (Z clear)
End Process

Process called "COND_CS" returns Integer:
    Return 2  Note: Carry set / unsigned higher or same
End Process

Process called "COND_CC" returns Integer:
    Return 3  Note: Carry clear / unsigned lower
End Process

Process called "COND_MI" returns Integer:
    Return 4  Note: Minus / negative (N set)
End Process

Process called "COND_PL" returns Integer:
    Return 5  Note: Plus / positive or zero (N clear)
End Process

Process called "COND_VS" returns Integer:
    Return 6  Note: Overflow (V set)
End Process

Process called "COND_VC" returns Integer:
    Return 7  Note: No overflow (V clear)
End Process

Process called "COND_HI" returns Integer:
    Return 8  Note: Unsigned higher
End Process

Process called "COND_LS" returns Integer:
    Return 9  Note: Unsigned lower or same
End Process

Process called "COND_GE" returns Integer:
    Return 10  Note: Signed greater than or equal
End Process

Process called "COND_LT" returns Integer:
    Return 11  Note: Signed less than
End Process

Process called "COND_GT" returns Integer:
    Return 12  Note: Signed greater than
End Process

Process called "COND_LE" returns Integer:
    Return 13  Note: Signed less than or equal
End Process

Process called "COND_AL" returns Integer:
    Return 14  Note: Always (unconditional)
End Process

Note: ============================================================================
Note: INSTRUCTION PROPERTIES
Note: ============================================================================

Process called "get_instruction_latency" takes opcode as Integer returns Integer:
    Note: Get typical latency for instruction
    Note: Based on Cortex-A9 timing (representative ARMv7 processor)

    Note: Data movement instructions
    If opcode is equal to OP_MOV():
        Return 1
    End If
    If opcode is equal to OP_MVN():
        Return 1
    End If
    If opcode is equal to OP_VMOV():
        Return 1
    End If

    Note: Arithmetic instructions
    If opcode is equal to OP_ADD():
        Return 1
    End If
    If opcode is equal to OP_ADC():
        Return 1
    End If
    If opcode is equal to OP_SUB():
        Return 1
    End If
    If opcode is equal to OP_SBC():
        Return 1
    End If
    If opcode is equal to OP_RSB():
        Return 1
    End If
    If opcode is equal to OP_MUL():
        Return 2  Note: Multiply takes 2 cycles
    End If
    If opcode is equal to OP_MLA():
        Return 2
    End If
    If opcode is equal to OP_UMULL():
        Return 3  Note: Long multiply
    End If
    If opcode is equal to OP_SMULL():
        Return 3
    End If
    If opcode is equal to OP_SDIV():
        Return 12  Note: Division is slow (3-12 cycles)
    End If
    If opcode is equal to OP_UDIV():
        Return 12
    End If

    Note: Logical instructions
    If opcode is equal to OP_AND():
        Return 1
    End If
    If opcode is equal to OP_ORR():
        Return 1
    End If
    If opcode is equal to OP_EOR():
        Return 1
    End If
    If opcode is equal to OP_BIC():
        Return 1
    End If

    Note: Shift instructions
    If opcode is equal to OP_LSL():
        Return 1
    End If
    If opcode is equal to OP_LSR():
        Return 1
    End If
    If opcode is equal to OP_ASR():
        Return 1
    End If
    If opcode is equal to OP_ROR():
        Return 1
    End If

    Note: Memory instructions
    If opcode is equal to OP_LDR():
        Return 2  Note: Cache hit
    End If
    If opcode is equal to OP_STR():
        Return 1
    End If
    If opcode is equal to OP_LDRB():
        Return 2
    End If
    If opcode is equal to OP_STRB():
        Return 1
    End If
    If opcode is equal to OP_LDRH():
        Return 2
    End If
    If opcode is equal to OP_STRH():
        Return 1
    End If
    If opcode is equal to OP_LDM():
        Return 2  Note: Base latency, more for multiple registers
    End If
    If opcode is equal to OP_STM():
        Return 1
    End If

    Note: VFP instructions
    If opcode is equal to OP_VADD():
        Return 4  Note: VFP add
    End If
    If opcode is equal to OP_VSUB():
        Return 4
    End If
    If opcode is equal to OP_VMUL():
        Return 5  Note: VFP multiply
    End If
    If opcode is equal to OP_VDIV():
        Return 15  Note: VFP divide is slow
    End If
    If opcode is equal to OP_VLDR():
        Return 2
    End If
    If opcode is equal to OP_VSTR():
        Return 1
    End If

    Note: Branch instructions
    If opcode is equal to OP_B():
        Return 1  Note: Predicted correctly
    End If
    If opcode is equal to OP_BL():
        Return 1
    End If
    If opcode is equal to OP_BX():
        Return 1
    End If
    If opcode is equal to OP_BLX():
        Return 1
    End If

    Note: Default conservative estimate
    Return 1
End Process

Process called "get_instruction_throughput" takes opcode as Integer returns Integer:
    Note: Get instruction throughput (instructions per cycle)
    Note: Based on Cortex-A9 dual-issue capability

    Note: Most simple ALU instructions can dual-issue
    If opcode is equal to OP_ADD():
        Return 2  Note: 2 per cycle
    End If
    If opcode is equal to OP_SUB():
        Return 2
    End If
    If opcode is equal to OP_AND():
        Return 2
    End If
    If opcode is equal to OP_ORR():
        Return 2
    End If
    If opcode is equal to OP_EOR():
        Return 2
    End If
    If opcode is equal to OP_MOV():
        Return 2
    End If

    Note: Multiply and divide cannot dual-issue
    If opcode is equal to OP_MUL():
        Return 1
    End If
    If opcode is equal to OP_SDIV():
        Return 1
    End If
    If opcode is equal to OP_UDIV():
        Return 1
    End If

    Note: Memory ops can dual-issue with ALU
    If opcode is equal to OP_LDR():
        Return 1
    End If
    If opcode is equal to OP_STR():
        Return 1
    End If

    Return 1  Note: Default
End Process

Process called "get_instruction_size" takes opcode as Integer returns Integer:
    Note: Get instruction size in bytes
    Note: ARM mode instructions are 4 bytes, Thumb are 2 bytes
    Note: We default to ARM mode (4 bytes)
    Return 4
End Process

Process called "is_branch_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is a branch

    If opcode is equal to OP_B():
        Return 1
    End If
    If opcode is equal to OP_BL():
        Return 1
    End If
    If opcode is equal to OP_BX():
        Return 1
    End If
    If opcode is equal to OP_BLX():
        Return 1
    End If

    Return 0
End Process

Process called "is_load_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is a load

    If opcode is equal to OP_LDR():
        Return 1
    End If
    If opcode is equal to OP_LDRB():
        Return 1
    End If
    If opcode is equal to OP_LDRH():
        Return 1
    End If
    If opcode is equal to OP_LDRSB():
        Return 1
    End If
    If opcode is equal to OP_LDRSH():
        Return 1
    End If
    If opcode is equal to OP_LDM():
        Return 1
    End If
    If opcode is equal to OP_POP():
        Return 1
    End If
    If opcode is equal to OP_VLDR():
        Return 1
    End If

    Return 0
End Process

Process called "is_store_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is a store

    If opcode is equal to OP_STR():
        Return 1
    End If
    If opcode is equal to OP_STRB():
        Return 1
    End If
    If opcode is equal to OP_STRH():
        Return 1
    End If
    If opcode is equal to OP_STM():
        Return 1
    End If
    If opcode is equal to OP_PUSH():
        Return 1
    End If
    If opcode is equal to OP_VSTR():
        Return 1
    End If

    Return 0
End Process

Process called "is_arithmetic_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is arithmetic

    If opcode is equal to OP_ADD():
        Return 1
    End If
    If opcode is equal to OP_ADC():
        Return 1
    End If
    If opcode is equal to OP_SUB():
        Return 1
    End If
    If opcode is equal to OP_SBC():
        Return 1
    End If
    If opcode is equal to OP_RSB():
        Return 1
    End If
    If opcode is equal to OP_RSC():
        Return 1
    End If
    If opcode is equal to OP_MUL():
        Return 1
    End If
    If opcode is equal to OP_MLA():
        Return 1
    End If
    If opcode is equal to OP_SDIV():
        Return 1
    End If
    If opcode is equal to OP_UDIV():
        Return 1
    End If

    Return 0
End Process

Process called "is_logical_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is logical

    If opcode is equal to OP_AND():
        Return 1
    End If
    If opcode is equal to OP_ORR():
        Return 1
    End If
    If opcode is equal to OP_EOR():
        Return 1
    End If
    If opcode is equal to OP_BIC():
        Return 1
    End If
    If opcode is equal to OP_MVN():
        Return 1
    End If

    Return 0
End Process

Process called "is_comparison_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is comparison

    If opcode is equal to OP_CMP():
        Return 1
    End If
    If opcode is equal to OP_CMN():
        Return 1
    End If
    If opcode is equal to OP_TST():
        Return 1
    End If
    If opcode is equal to OP_TEQ():
        Return 1
    End If

    Return 0
End Process

Process called "is_shift_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is a shift/rotate

    If opcode is equal to OP_LSL():
        Return 1
    End If
    If opcode is equal to OP_LSR():
        Return 1
    End If
    If opcode is equal to OP_ASR():
        Return 1
    End If
    If opcode is equal to OP_ROR():
        Return 1
    End If
    If opcode is equal to OP_RRX():
        Return 1
    End If

    Return 0
End Process

Process called "is_vfp_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is VFP/NEON

    If opcode is equal to OP_VADD():
        Return 1
    End If
    If opcode is equal to OP_VSUB():
        Return 1
    End If
    If opcode is equal to OP_VMUL():
        Return 1
    End If
    If opcode is equal to OP_VDIV():
        Return 1
    End If
    If opcode is equal to OP_VMOV():
        Return 1
    End If
    If opcode is equal to OP_VLDR():
        Return 1
    End If
    If opcode is equal to OP_VSTR():
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: IMMEDIATE VALUE VALIDATION
Note: ============================================================================

Process called "is_valid_immediate" takes value as Integer returns Integer:
    Note: Check if value can be encoded as ARM data-processing immediate (8-bit rotated by even 0..30)

    Let v be value bitwise_and 4294967295

    Let rot be 0
    While rot is less than 16:
        Let rotated be (v rotated_right (rot multiplied by 2))
        Let imm8_candidate be rotated bitwise_and 255
        If rotated is equal to imm8_candidate:
            Return 1
        End If
        Set rot to rot plus 1
    End While

    Return 0
End Process

Process called "is_valid_offset_immediate" takes offset as Integer returns Integer:
    Note: Check if offset can be encoded in LDR/STR
    Note: LDR/STR can encode 12-bit unsigned offset

    If offset is greater than or equal to 0:
        If offset is less than 4096:
            Return 1
        End If
    End If

    Note: Negative offsets also valid
    If offset is greater than or equal to -4095:
        If offset is less than 0:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "is_valid_shift_immediate" takes shift_amount as Integer returns Integer:
    Note: Check if shift amount is valid
    Note: Shifts can be 0-31 for 32-bit operations

    If shift_amount is greater than or equal to 0:
        If shift_amount is less than or equal to 31:
            Return 1
        End If
    End If

    Return 0
End Process

Note: ============================================================================
Note: INSTRUCTION SELECTION HELPERS
Note: ============================================================================

Process called "should_use_immediate" takes value as Integer returns Integer:
    Note: Determine if immediate encoding should be used vs register load
    Note: Returns 1 if immediate is better, 0 if register load is better

    Note: If it fits as an immediate, use it
    If is_valid_immediate(value) is equal to 1:
        Return 1
    End If

    Return 0
End Process

Process called "should_use_ldm_stm" takes reg_count as Integer returns Integer:
    Note: Determine if LDM/STM should be used for multiple registers
    Note: Returns 1 if LDM/STM recommended, 0 if individual loads better

    Note: LDM/STM is beneficial for 2+ registers
    If reg_count is greater than or equal to 2:
        Return 1
    End If

    Return 0
End Process

Process called "should_use_conditional_execution" takes branch_probability as Integer returns Integer:
    Note: Determine if conditional execution should be used vs branch
    Note: ARM32 supports conditional execution on all instructions
    Note: Returns 1 if conditional execution is better, 0 if branch is better
    Note: branch_probability: 0-100 (percentage)

    Note: For highly predictable branches, use branch
    If branch_probability is greater than or equal to 90:
        Return 0  Note: Use branch
    End If
    If branch_probability is less than or equal to 10:
        Return 0  Note: Use branch
    End If

    Note: For unpredictable branches, conditional execution is better
    Return 1
End Process

Process called "recommend_memcpy_strategy" takes size as Integer returns Integer:
    Note: Recommend memcpy strategy based on size
    Note: Returns: 0 = inline, 1 = call function, 2 = use LDM/STM
    Note: Returns 1 if inline recommended, 0 if call function

    Note: Inline for very small sizes
    If size is less than or equal to 16:
        Return 0  Note: Inline
    End If

    Note: Use LDM/STM for medium sizes
    If size is less than or equal to 128:
        Return 2  Note: LDM/STM
    End If

    Note: Call function for large sizes
    Return 1
End Process

Note: ============================================================================
Note: OPTIMIZATION PATTERNS
Note: ============================================================================

Process called "can_eliminate_redundant_move" takes src_reg as Integer, dest_reg as Integer returns Integer:
    Note: Check if MOV can be eliminated (src == dest)
    Note: Returns 1 if redundant, 0 otherwise

    If src_reg is equal to dest_reg:
        Return 1  Note: Redundant move
    End If

    Return 0
End Process

Process called "can_use_shift_in_operand" takes has_shift as Integer returns Integer:
    Note: Check if shift can be folded into operand2 (barrel shifter)
    Note: ARM32 supports shifted operands in most ALU instructions
    Note: Returns 1 if shift can be folded, 0 otherwise

    Note: ARM32 barrel shifter can fold shifts into most instructions
    If has_shift is equal to 1:
        Return 1
    End If

    Return 0
End Process

Process called "can_fuse_compare_branch" takes has_compare as Integer, has_branch as Integer returns Integer:
    Note: Check if compare and branch can be combined with conditional execution
    Note: Returns 1 if fusion possible, 0 otherwise

    If has_compare is equal to 1:
        If has_branch is equal to 1:
            Return 1  Note: Can use conditional branch
        End If
    End If

    Return 0
End Process

Process called "can_use_multiply_accumulate" takes has_multiply as Integer, has_add as Integer returns Integer:
    Note: Check if MLA (multiply-accumulate) can be used
    Note: Returns 1 if MLA beneficial, 0 otherwise

    If has_multiply is equal to 1:
        If has_add is equal to 1:
            Return 1  Note: Use MLA instead of MUL + ADD
        End If
    End If

    Return 0
End Process

Note: ============================================================================
Note: INSTRUCTION CATEGORIES
Note: ============================================================================

Process called "INSTR_CATEGORY_DATA_MOVEMENT" returns Integer:
    Return 0  Note: MOV, LDR, STR, LDM, STM
End Process

Process called "INSTR_CATEGORY_ARITHMETIC" returns Integer:
    Return 1  Note: ADD, SUB, MUL, DIV
End Process

Process called "INSTR_CATEGORY_LOGICAL" returns Integer:
    Return 2  Note: AND, ORR, EOR, BIC
End Process

Process called "INSTR_CATEGORY_CONTROL_FLOW" returns Integer:
    Return 3  Note: B, BL, BX, BLX
End Process

Process called "INSTR_CATEGORY_COMPARISON" returns Integer:
    Return 4  Note: CMP, CMN, TST, TEQ
End Process

Process called "INSTR_CATEGORY_MEMORY" returns Integer:
    Return 5  Note: LDR, STR, LDM, STM
End Process

Process called "INSTR_CATEGORY_SHIFT" returns Integer:
    Return 6  Note: LSL, LSR, ASR, ROR
End Process

Process called "INSTR_CATEGORY_SYSTEM" returns Integer:
    Return 7  Note: SWI, SVC
End Process

Process called "INSTR_CATEGORY_VFP" returns Integer:
    Return 8  Note: VADD, VSUB, VMUL, VDIV
End Process

Process called "get_instruction_category" takes opcode as Integer returns Integer:
    Note: Get category for instruction opcode

    If is_arithmetic_instruction(opcode) is equal to 1:
        Return INSTR_CATEGORY_ARITHMETIC()
    End If

    If is_logical_instruction(opcode) is equal to 1:
        Return INSTR_CATEGORY_LOGICAL()
    End If

    If is_comparison_instruction(opcode) is equal to 1:
        Return INSTR_CATEGORY_COMPARISON()
    End If

    If is_branch_instruction(opcode) is equal to 1:
        Return INSTR_CATEGORY_CONTROL_FLOW()
    End If

    If is_shift_instruction(opcode) is equal to 1:
        Return INSTR_CATEGORY_SHIFT()
    End If

    If is_vfp_instruction(opcode) is equal to 1:
        Return INSTR_CATEGORY_VFP()
    End If

    If is_load_instruction(opcode) is equal to 1:
        Return INSTR_CATEGORY_MEMORY()
    End If

    If is_store_instruction(opcode) is equal to 1:
        Return INSTR_CATEGORY_MEMORY()
    End If

    Note: Default to data movement
    Return INSTR_CATEGORY_DATA_MOVEMENT()
End Process

Note: ============================================================================
Note: PERFORMANCE HINTS
Note: ============================================================================

Process called "get_cache_line_size" returns Integer:
    Note: Get cache line size for alignment optimization
    Note: Most ARMv7 processors have 64-byte cache lines
    Return 64
End Process

Process called "get_preferred_alignment" returns Integer:
    Note: Get preferred alignment for memory operations
    Note: ARM32 benefits from 4-byte (word) alignment
    Return 4
End Process

Process called "get_stack_alignment" returns Integer:
    Note: Get required stack alignment
    Note: AAPCS requires 8-byte alignment
    Return 8
End Process

Process called "supports_unaligned_access" returns Integer:
    Note: Check if processor supports unaligned memory access
    Note: ARMv7 supports unaligned access but with performance penalty
    Return 1  Note: Supported but slow
End Process

Process called "get_branch_prediction_penalty" returns Integer:
    Note: Get cycle penalty for branch misprediction
    Note: Cortex-A9: ~10-13 cycles for misprediction
    Return 10
End Process
