Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions
Licensed under the Apache License, Version 2.0
:End Note

Note:
LINUX ARM32 ATOMIC OPERATIONS
ARMv7-A inline assembly with LDREX/STREX
:End Note

Process called "atomic_load_relaxed" takes ptr as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ldr r0, [fp, #-4]
        ldr r1, [r0]
        str r1, [fp, #-8]
    End Assembly
    Return result
End Process

Process called "atomic_load_acquire" takes ptr as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ldr r0, [fp, #-4]
        ldr r1, [r0]
        dmb
        str r1, [fp, #-8]
    End Assembly
    Return result
End Process

Process called "atomic_load_seq_cst" takes ptr as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ldr r0, [fp, #-4]
        ldr r1, [r0]
        dmb
        str r1, [fp, #-8]
    End Assembly
    Return result
End Process

Process called "atomic_store_relaxed" takes ptr as Integer, value as Integer returns Integer:
    Inline Assembly:
        ldr r0, [fp, #-4]
        ldr r1, [fp, #-8]
        str r1, [r0]
    End Assembly
    Return 0
End Process

Process called "atomic_store_release" takes ptr as Integer, value as Integer returns Integer:
    Inline Assembly:
        dmb
        ldr r0, [fp, #-4]
        ldr r1, [fp, #-8]
        str r1, [r0]
    End Assembly
    Return 0
End Process

Process called "atomic_store_seq_cst" takes ptr as Integer, value as Integer returns Integer:
    Inline Assembly:
        dmb
        ldr r0, [fp, #-4]
        ldr r1, [fp, #-8]
        str r1, [r0]
        dmb
    End Assembly
    Return 0
End Process

Process called "atomic_fetch_add" takes ptr as Integer, value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ldr r0, [fp, #-4]
        ldr r1, [fp, #-8]

        .retry:
        ldrex r2, [r0]
        add r3, r2, r1
        strex r4, r3, [r0]
        cmp r4, #0
        bne .retry

        str r2, [fp, #-12]
    End Assembly
    Return result
End Process

Process called "atomic_fetch_sub" takes ptr as Integer, value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ldr r0, [fp, #-4]
        ldr r1, [fp, #-8]

        .retry:
        ldrex r2, [r0]
        sub r3, r2, r1
        strex r4, r3, [r0]
        cmp r4, #0
        bne .retry

        str r2, [fp, #-12]
    End Assembly
    Return result
End Process

Process called "atomic_fetch_and" takes ptr as Integer, value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ldr r0, [fp, #-4]
        ldr r1, [fp, #-8]

        .retry:
        ldrex r2, [r0]
        and r3, r2, r1
        strex r4, r3, [r0]
        cmp r4, #0
        bne .retry

        str r2, [fp, #-12]
    End Assembly
    Return result
End Process

Process called "atomic_fetch_or" takes ptr as Integer, value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ldr r0, [fp, #-4]
        ldr r1, [fp, #-8]

        .retry:
        ldrex r2, [r0]
        orr r3, r2, r1
        strex r4, r3, [r0]
        cmp r4, #0
        bne .retry

        str r2, [fp, #-12]
    End Assembly
    Return result
End Process

Process called "atomic_fetch_xor" takes ptr as Integer, value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ldr r0, [fp, #-4]
        ldr r1, [fp, #-8]

        .retry:
        ldrex r2, [r0]
        eor r3, r2, r1
        strex r4, r3, [r0]
        cmp r4, #0
        bne .retry

        str r2, [fp, #-12]
    End Assembly
    Return result
End Process

Process called "atomic_compare_and_swap" takes ptr as Integer, expected as Integer, desired as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ldr r0, [fp, #-4]
        ldr r1, [fp, #-8]
        ldr r2, [fp, #-12]

        ldrex r3, [r0]
        cmp r3, r1
        bne .failed

        strex r4, r2, [r0]
        cmp r4, #0
        bne .failed

        mov r5, #1
        b .done

        .failed:
        clrex
        mov r5, #0

        .done:
        str r5, [fp, #-16]
    End Assembly
    Return result
End Process

Process called "atomic_compare_and_swap_weak" takes ptr as Integer, expected as Integer, desired as Integer returns Integer:
    Return atomic_compare_and_swap(ptr, expected, desired)
End Process

Process called "atomic_exchange" takes ptr as Integer, value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ldr r0, [fp, #-4]
        ldr r1, [fp, #-8]

        .retry:
        ldrex r2, [r0]
        strex r3, r1, [r0]
        cmp r3, #0
        bne .retry

        str r2, [fp, #-12]
    End Assembly
    Return result
End Process

Process called "memory_barrier_acquire" returns Integer:
    Inline Assembly:
        dmb
    End Assembly
    Return 0
End Process

Process called "memory_barrier_release" returns Integer:
    Inline Assembly:
        dmb
    End Assembly
    Return 0
End Process

Process called "memory_barrier_full" returns Integer:
    Inline Assembly:
        dmb
    End Assembly
    Return 0
End Process

Process called "memory_barrier_seq_cst" returns Integer:
    Inline Assembly:
        dmb
    End Assembly
    Return 0
End Process
