Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
DSP Register Architecture

This file implements register primitives for DSP (Digital Signal Processor) platforms.

DSP Register Architecture (based on TI C6x/C7x and similar architectures):
- General-purpose registers (GPRs): R0-R31
- Accumulator registers (ACCs): A0-A7 (40-bit or 64-bit for MAC operations)
- Address registers (ARs): AR0-AR7 (for circular buffers and bit-reverse)
- Control registers: AMR (addressing mode), CSR (control/status)
- MAC units: Multiply-accumulate hardware units

Key DSP features:
- Accumulator registers for multi-cycle MAC operations
- Circular buffer addressing via address registers
- Bit-reversed addressing for FFT
- Zero-overhead looping
- Parallel execution units
:End Note

Note: ============================================================================
Note: GENERAL-PURPOSE REGISTERS (R0-R31)
Note: ============================================================================

Process called "GPR_R0" returns Integer:
    Note: General-purpose register 0
    Return 0
End Process

Process called "GPR_R1" returns Integer:
    Return 1
End Process

Process called "GPR_R2" returns Integer:
    Return 2
End Process

Process called "GPR_R3" returns Integer:
    Return 3
End Process

Process called "GPR_R4" returns Integer:
    Return 4
End Process

Process called "GPR_R5" returns Integer:
    Return 5
End Process

Process called "GPR_R6" returns Integer:
    Return 6
End Process

Process called "GPR_R7" returns Integer:
    Return 7
End Process

Process called "GPR_R8" returns Integer:
    Return 8
End Process

Process called "GPR_R9" returns Integer:
    Return 9
End Process

Process called "GPR_R10" returns Integer:
    Return 10
End Process

Process called "GPR_R11" returns Integer:
    Return 11
End Process

Process called "GPR_R12" returns Integer:
    Return 12
End Process

Process called "GPR_R13" returns Integer:
    Return 13
End Process

Process called "GPR_R14" returns Integer:
    Return 14
End Process

Process called "GPR_R15" returns Integer:
    Return 15
End Process

Process called "get_gpr_count" returns Integer:
    Note: Get total number of general-purpose registers
    Return 32  Note: R0-R31
End Process

Note: ============================================================================
Note: ACCUMULATOR REGISTERS (A0-A7)
Note: ============================================================================

Process called "ACC_A0" returns Integer:
    Note: Accumulator register 0 (40-bit or 64-bit)
    Return 32
End Process

Process called "ACC_A1" returns Integer:
    Return 33
End Process

Process called "ACC_A2" returns Integer:
    Return 34
End Process

Process called "ACC_A3" returns Integer:
    Return 35
End Process

Process called "ACC_A4" returns Integer:
    Return 36
End Process

Process called "ACC_A5" returns Integer:
    Return 37
End Process

Process called "ACC_A6" returns Integer:
    Return 38
End Process

Process called "ACC_A7" returns Integer:
    Return 39
End Process

Process called "get_accumulator_width_bits" returns Integer:
    Note: Get accumulator width in bits
    Return 40  Note: 40-bit accumulators (extendable to 64)
End Process

Process called "get_accumulator_count" returns Integer:
    Note: Get number of accumulator registers
    Return 8  Note: A0-A7
End Process

Note: ============================================================================
Note: ADDRESS REGISTERS (AR0-AR7)
Note: ============================================================================

Process called "AR_AR0" returns Integer:
    Note: Address register 0 (for circular buffers)
    Return 40
End Process

Process called "AR_AR1" returns Integer:
    Return 41
End Process

Process called "AR_AR2" returns Integer:
    Return 42
End Process

Process called "AR_AR3" returns Integer:
    Return 43
End Process

Process called "AR_AR4" returns Integer:
    Return 44
End Process

Process called "AR_AR5" returns Integer:
    Return 45
End Process

Process called "AR_AR6" returns Integer:
    Return 46
End Process

Process called "AR_AR7" returns Integer:
    Return 47
End Process

Process called "get_address_register_count" returns Integer:
    Note: Get number of address registers
    Return 8  Note: AR0-AR7
End Process

Note: ============================================================================
Note: CONTROL AND STATUS REGISTERS
Note: ============================================================================

Process called "CTRL_AMR" returns Integer:
    Note: Addressing Mode Register (circular buffer config)
    Return 48
End Process

Process called "CTRL_CSR" returns Integer:
    Note: Control/Status Register
    Return 49
End Process

Process called "CTRL_IER" returns Integer:
    Note: Interrupt Enable Register
    Return 50
End Process

Process called "CTRL_IFR" returns Integer:
    Note: Interrupt Flag Register
    Return 51
End Process

Process called "CTRL_ISR" returns Integer:
    Note: Interrupt Set Register
    Return 52
End Process

Process called "CTRL_ICR" returns Integer:
    Note: Interrupt Clear Register
    Return 53
End Process

Note: ============================================================================
Note: CALLING CONVENTION REGISTERS
Note: ============================================================================

Process called "get_param_register" takes param_index as Integer returns Integer:
    Note: Get register number for function parameter
    Note: param_index: Parameter index (0, 1, 2, ...)
    Note: Returns: Register number, or -1 if passed on stack

    Note: Parameters passed in R4-R11 (8 registers)
    If param_index is equal to 0:
        Return 4  Note: R4
    End If

    If param_index is equal to 1:
        Return 5  Note: R5
    End If

    If param_index is equal to 2:
        Return 6  Note: R6
    End If

    If param_index is equal to 3:
        Return 7  Note: R7
    End If

    If param_index is equal to 4:
        Return 8  Note: R8
    End If

    If param_index is equal to 5:
        Return 9  Note: R9
    End If

    If param_index is equal to 6:
        Return 10  Note: R10
    End If

    If param_index is equal to 7:
        Return 11  Note: R11
    End If

    Return -1  Note: Parameters 8+ passed on stack
End Process

Process called "get_return_register" returns Integer:
    Note: Get register number for return value
    Return 4  Note: R4
End Process

Process called "get_stack_pointer_register" returns Integer:
    Note: Get stack pointer register
    Return 15  Note: R15 (SP)
End Process

Process called "get_frame_pointer_register" returns Integer:
    Note: Get frame pointer register
    Return 14  Note: R14 (FP)
End Process

Process called "get_link_register" returns Integer:
    Note: Get link register (return address)
    Return 3  Note: R3 (LR)
End Process

Process called "get_max_register_params" returns Integer:
    Note: Get maximum number of parameters passed in registers
    Return 8  Note: R4-R11
End Process

Note: ============================================================================
Note: REGISTER PROPERTIES
Note: ============================================================================

Process called "is_accumulator_register" takes reg_num as Integer returns Integer:
    Note: Check if register is an accumulator
    Note: reg_num: Register number
    Note: Returns: 1 if accumulator, 0 otherwise

    If reg_num is greater than or equal to 32:
        If reg_num is less than or equal to 39:
            Return 1  Note: A0-A7
        End If
    End If

    Return 0
End Process

Process called "is_address_register" takes reg_num as Integer returns Integer:
    Note: Check if register is an address register
    Note: reg_num: Register number
    Note: Returns: 1 if address register, 0 otherwise

    If reg_num is greater than or equal to 40:
        If reg_num is less than or equal to 47:
            Return 1  Note: AR0-AR7
        End If
    End If

    Return 0
End Process

Process called "is_callee_saved" takes reg_num as Integer returns Integer:
    Note: Check if register must be preserved by callee
    Note: reg_num: Register number
    Note: Returns: 1 if callee-saved, 0 if caller-saved

    Note: Callee-saved GPRs: R12-R15
    If reg_num is greater than or equal to 12:
        If reg_num is less than or equal to 15:
            Return 1  Note: Callee-saved
        End If
    End If

    Return 0  Note: Caller-saved
End Process

Note: ============================================================================
Note: CIRCULAR BUFFER ADDRESSING
Note: ============================================================================

Process called "configure_circular_buffer" takes ar_num as Integer, buffer_start as Integer, buffer_size as Integer returns Integer:
    Note: Configure address register for circular buffer
    Note: ar_num: Address register number (0-7)
    Note: buffer_start: Buffer start address
    Note: buffer_size: Buffer size in bytes (power of 2)
    Note: Returns: AMR register value

    Note: AMR encoding: bits [ar_num*4+3:ar_num*4] = log2(size)
    Let size_log2 be 0
    Let size be buffer_size

    While size is greater than 1:
        Set size to size shifted_right 1
        Set size_log2 to size_log2 plus 1
    End While

    Note: Shift size_log2 to correct position for this AR
    Let ar_shift be ar_num multiplied by 4
    Let amr_value be size_log2 shifted_left ar_shift

    Return amr_value
End Process

Process called "calculate_circular_address" takes current_addr as Integer, offset as Integer, buffer_start as Integer, buffer_size as Integer returns Integer:
    Note: Calculate next address in circular buffer
    Note: current_addr: Current address
    Note: offset: Offset to add
    Note: buffer_start: Buffer start address
    Note: buffer_size: Buffer size in bytes
    Note: Returns: Next address (wrapped if necessary)

    Let next_addr be current_addr plus offset
    Let buffer_end be buffer_start plus buffer_size

    Note: Wrap around if exceeded buffer
    While next_addr is greater than or equal to buffer_end:
        Set next_addr to next_addr minus buffer_size
    End While

    While next_addr is less than buffer_start:
        Set next_addr to next_addr plus buffer_size
    End While

    Return next_addr
End Process

Note: ============================================================================
Note: BIT-REVERSED ADDRESSING (FOR FFT)
Note: ============================================================================

Process called "reverse_bits" takes value as Integer, bit_count as Integer returns Integer:
    Note: Reverse bits in value (for bit-reversed addressing)
    Note: value: Input value
    Note: bit_count: Number of bits to reverse
    Note: Returns: Bit-reversed value

    Let reversed be 0
    Let i be 0

    While i is less than bit_count:
        Let bit be value bitwise_and 1
        Set reversed to reversed shifted_left 1
        Set reversed to reversed bitwise_or bit
        Set value to value shifted_right 1
        Set i to i plus 1
    End While

    Return reversed
End Process

Process called "calculate_bit_reversed_index" takes index as Integer, total_points as Integer returns Integer:
    Note: Calculate bit-reversed index for FFT
    Note: index: Original index
    Note: total_points: Total FFT points (power of 2)
    Note: Returns: Bit-reversed index

    Note: Calculate log2(total_points)
    Let bit_count be 0
    Let size be total_points

    While size is greater than 1:
        Set size to size shifted_right 1
        Set bit_count to bit_count plus 1
    End While

    Let reversed_index be reverse_bits(index, bit_count)
    Return reversed_index
End Process

Note: ============================================================================
Note: MAC UNIT RESOURCE TRACKING
Note: ============================================================================

Process called "get_mac_unit_count" returns Integer:
    Note: Get number of MAC units available
    Return 8  Note: 8 parallel MAC units
End Process

Process called "calculate_mac_latency_cycles" takes operation_type as Integer returns Integer:
    Note: Get MAC operation latency
    Note: operation_type: 0=multiply, 1=multiply-add, 2=multiply-accumulate
    Note: Returns: Latency in cycles

    If operation_type is equal to 0:
        Return 1  Note: Single-cycle multiply
    End If

    If operation_type is equal to 1:
        Return 1  Note: Single-cycle multiply-add
    End If

    If operation_type is equal to 2:
        Return 1  Note: Single-cycle MAC
    End If

    Return 1
End Process

Process called "calculate_mac_throughput" takes clock_freq_mhz as Integer returns Integer:
    Note: Calculate MAC throughput
    Note: clock_freq_mhz: Clock frequency in MHz
    Note: Returns: Million MACs per second (MMACS)

    Let mac_units be get_mac_unit_count()
    Let mmacs be clock_freq_mhz multiplied by mac_units
    Return mmacs
End Process

Note: ============================================================================
Note: REGISTER NAMING
Note: ============================================================================

Process called "register_name" takes reg_num as Integer returns String:
    Note: Get register name string
    Note: reg_num: Register number
    Note: Returns: Register name

    Note: General-purpose registers (0-31)
    If reg_num is less than 32:
        Return "R"
    End If

    Note: Accumulator registers (32-39)
    If reg_num is less than 40:
        Return "A"
    End If

    Note: Address registers (40-47)
    If reg_num is less than 48:
        Return "AR"
    End If

    Return "UNKNOWN"
End Process
