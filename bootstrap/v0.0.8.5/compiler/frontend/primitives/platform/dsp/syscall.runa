Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
DSP System Interface and Runtime Services

This file implements system interface for DSP platforms.

DSP system interface (embedded/real-time environment):
- No traditional OS syscalls
- Direct hardware control
- Memory-mapped peripherals
- DMA operations
- Interrupt handling
- Real-time scheduling

System services:
1. DMA: Direct memory access for high-speed data transfer
2. Interrupt management: Real-time event handling
3. Timer/counter: Precise timing and profiling
4. Cache control: Cache coherency and performance
5. Memory management: Static allocation and region control
6. Peripheral access: UART, SPI, I2C, etc.
:End Note

Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Note: ============================================================================
Note: DMA (DIRECT MEMORY ACCESS) OPERATIONS
Note: ============================================================================

Process called "DMA_CHANNEL_0" returns Integer:
    Return 0
End Process

Process called "DMA_CHANNEL_1" returns Integer:
    Return 1
End Process

Process called "DMA_CHANNEL_2" returns Integer:
    Return 2
End Process

Process called "DMA_CHANNEL_3" returns Integer:
    Return 3
End Process

Process called "dma_configure" takes channel as Integer, src_addr as Integer, dest_addr as Integer, transfer_size as Integer returns Integer:
    Note: Configure DMA channel for transfer
    Note: channel: DMA channel number (0-3)
    Note: src_addr: Source address
    Note: dest_addr: Destination address
    Note: transfer_size: Number of bytes to transfer
    Note: Returns: 0 on success, -1 on error

    If channel is less than 0:
        Return -1  Note: Invalid channel
    End If

    If channel is greater than 3:
        Return -1  Note: Invalid channel
    End If

    Note: Configure DMA hardware registers (memory-mapped)
    Let dma_base be 0x01C00000  Note: DMA controller base address
    Let channel_offset be channel multiplied by 64  Note: 64 bytes per channel
    Let channel_base be dma_base plus channel_offset

    Note: Set source address register
    Memory.memory_set_int32(channel_base, 0, src_addr)

    Note: Set destination address register
    Memory.memory_set_int32(channel_base, 4, dest_addr)

    Note: Set transfer size register
    Memory.memory_set_int32(channel_base, 8, transfer_size)

    Return 0
End Process

Process called "dma_start" takes channel as Integer returns Integer:
    Note: Start DMA transfer on channel
    Note: channel: DMA channel number
    Note: Returns: 0 on success

    Let dma_base be 0x01C00000
    Let channel_offset be channel multiplied by 64
    Let channel_base be dma_base plus channel_offset

    Note: Set control register bit 0 (enable)
    Let control_offset be 12
    Memory.memory_set_int32(channel_base, control_offset, 1)

    Return 0
End Process

Process called "dma_wait" takes channel as Integer returns Integer:
    Note: Wait for DMA transfer to complete
    Note: channel: DMA channel number
    Note: Returns: 0 when complete

    Let dma_base be 0x01C00000
    Let channel_offset be channel multiplied by 64
    Let channel_base be dma_base plus channel_offset

    Note: Poll status register bit 0 (transfer complete)
    Let status_offset be 16
    Let complete be 0

    While complete is equal to 0:
        Let status be Memory.memory_get_int32(channel_base, status_offset)
        Let complete_bit be status bitwise_and 1
        If complete_bit is not equal to 0:
            Set complete to 1
        End If
    End While

    Return 0
End Process

Process called "dma_abort" takes channel as Integer returns Integer:
    Note: Abort DMA transfer on channel
    Note: channel: DMA channel number
    Note: Returns: 0 on success

    Let dma_base be 0x01C00000
    Let channel_offset be channel multiplied by 64
    Let channel_base be dma_base plus channel_offset

    Note: Clear control register bit 0 (disable)
    Let control_offset be 12
    Memory.memory_set_int32(channel_base, control_offset, 0)

    Return 0
End Process

Note: ============================================================================
Note: INTERRUPT MANAGEMENT
Note: ============================================================================

Process called "INT_TIMER0" returns Integer:
    Note: Timer 0 interrupt ID
    Return 4
End Process

Process called "INT_TIMER1" returns Integer:
    Note: Timer 1 interrupt ID
    Return 5
End Process

Process called "INT_DMA0" returns Integer:
    Note: DMA channel 0 interrupt ID
    Return 8
End Process

Process called "INT_DMA1" returns Integer:
    Note: DMA channel 1 interrupt ID
    Return 9
End Process

Process called "INT_UART" returns Integer:
    Note: UART interrupt ID
    Return 12
End Process

Process called "interrupt_enable" takes interrupt_id as Integer returns Integer:
    Note: Enable specific interrupt
    Note: interrupt_id: Interrupt identifier
    Note: Returns: 0 on success

    Let intc_base be 0x01800000  Note: Interrupt controller base
    Let enable_reg_offset be 0

    Note: Set bit in interrupt enable register
    Let current_mask be Memory.memory_get_int32(intc_base, enable_reg_offset)
    Let new_bit be 1 shifted_left interrupt_id
    Let new_mask be current_mask bitwise_or new_bit
    Memory.memory_set_int32(intc_base, enable_reg_offset, new_mask)

    Return 0
End Process

Process called "interrupt_disable" takes interrupt_id as Integer returns Integer:
    Note: Disable specific interrupt
    Note: interrupt_id: Interrupt identifier
    Note: Returns: 0 on success

    Let intc_base be 0x01800000
    Let enable_reg_offset be 0

    Note: Clear bit in interrupt enable register
    Let current_mask be Memory.memory_get_int32(intc_base, enable_reg_offset)
    Let clear_bit be 1 shifted_left interrupt_id
    Let inverted_bit be 0 minus clear_bit
    Set inverted_bit to inverted_bit minus 1
    Set inverted_bit to inverted_bit bitwise_xor clear_bit
    Let new_mask be current_mask bitwise_and inverted_bit
    Memory.memory_set_int32(intc_base, enable_reg_offset, new_mask)

    Return 0
End Process

Process called "interrupt_clear" takes interrupt_id as Integer returns Integer:
    Note: Clear pending interrupt
    Note: interrupt_id: Interrupt identifier
    Note: Returns: 0 on success

    Let intc_base be 0x01800000
    Let clear_reg_offset be 8

    Note: Write 1 to clear bit
    Let clear_bit be 1 shifted_left interrupt_id
    Memory.memory_set_int32(intc_base, clear_reg_offset, clear_bit)

    Return 0
End Process

Process called "interrupt_get_pending" returns Integer:
    Note: Get pending interrupt mask
    Note: Returns: Bitmask of pending interrupts

    Let intc_base be 0x01800000
    Let pending_reg_offset be 4

    Let pending_mask be Memory.memory_get_int32(intc_base, pending_reg_offset)
    Return pending_mask
End Process

Note: ============================================================================
Note: TIMER/COUNTER OPERATIONS
Note: ============================================================================

Process called "timer_init" takes timer_id as Integer, period_cycles as Integer returns Integer:
    Note: Initialize timer with period
    Note: timer_id: Timer identifier (0, 1)
    Note: period_cycles: Timer period in clock cycles
    Note: Returns: 0 on success

    Let timer_base be 0x01C20000  Note: Timer 0 base
    If timer_id is equal to 1:
        Set timer_base to 0x01C21000  Note: Timer 1 base
    End If

    Note: Set period register
    Memory.memory_set_int32(timer_base, 4, period_cycles)

    Note: Set control register (enable, continuous mode)
    Memory.memory_set_int32(timer_base, 0, 3)  Note: Bits 0=enable, 1=continuous

    Return 0
End Process

Process called "timer_start" takes timer_id as Integer returns Integer:
    Note: Start timer counting
    Note: timer_id: Timer identifier
    Note: Returns: 0 on success

    Let timer_base be 0x01C20000
    If timer_id is equal to 1:
        Set timer_base to 0x01C21000
    End If

    Note: Set enable bit in control register
    Let control be Memory.memory_get_int32(timer_base, 0)
    Let new_control be control bitwise_or 1
    Memory.memory_set_int32(timer_base, 0, new_control)

    Return 0
End Process

Process called "timer_stop" takes timer_id as Integer returns Integer:
    Note: Stop timer counting
    Note: timer_id: Timer identifier
    Note: Returns: 0 on success

    Let timer_base be 0x01C20000
    If timer_id is equal to 1:
        Set timer_base to 0x01C21000
    End If

    Note: Clear enable bit in control register
    Let control be Memory.memory_get_int32(timer_base, 0)
    Let mask be -2  Note: ~1
    Let new_control be control bitwise_and mask
    Memory.memory_set_int32(timer_base, 0, new_control)

    Return 0
End Process

Process called "timer_read" takes timer_id as Integer returns Integer:
    Note: Read current timer count
    Note: timer_id: Timer identifier
    Note: Returns: Current count value

    Let timer_base be 0x01C20000
    If timer_id is equal to 1:
        Set timer_base to 0x01C21000
    End If

    Note: Read count register
    Let count be Memory.memory_get_int32(timer_base, 8)
    Return count
End Process

Note: ============================================================================
Note: CACHE CONTROL OPERATIONS
Note: ============================================================================

Process called "cache_invalidate_l1d" returns Integer:
    Note: Invalidate L1 data cache
    Note: Returns: 0 on completion

    Note: L1D cache control register
    Let cache_ctrl_base be 0x01840000
    Let invalidate_cmd be 1

    Memory.memory_set_int32(cache_ctrl_base, 0, invalidate_cmd)

    Note: Wait for completion (poll status bit)
    Let complete be 0
    While complete is equal to 0:
        Let status be Memory.memory_get_int32(cache_ctrl_base, 4)
        Let status_bit be status bitwise_and 1
        If status_bit is equal to 0:
            Set complete to 1  Note: Bit 0 clear = complete
        End If
    End While

    Return 0
End Process

Process called "cache_writeback_l1d" returns Integer:
    Note: Write back L1 data cache
    Note: Returns: 0 on completion

    Let cache_ctrl_base be 0x01840000
    Let writeback_cmd be 2

    Memory.memory_set_int32(cache_ctrl_base, 0, writeback_cmd)

    Let complete be 0
    While complete is equal to 0:
        Let status be Memory.memory_get_int32(cache_ctrl_base, 4)
        Let status_bit be status bitwise_and 1
        If status_bit is equal to 0:
            Set complete to 1
        End If
    End While

    Return 0
End Process

Process called "cache_writeback_invalidate_l1d" returns Integer:
    Note: Write back and invalidate L1 data cache
    Note: Returns: 0 on completion

    Let cache_ctrl_base be 0x01840000
    Let wb_inv_cmd be 3

    Memory.memory_set_int32(cache_ctrl_base, 0, wb_inv_cmd)

    Let complete be 0
    While complete is equal to 0:
        Let status be Memory.memory_get_int32(cache_ctrl_base, 4)
        Let status_bit be status bitwise_and 1
        If status_bit is equal to 0:
            Set complete to 1
        End If
    End While

    Return 0
End Process

Note: ============================================================================
Note: MEMORY BARRIER OPERATIONS
Note: ============================================================================

Process called "memory_barrier" returns Integer:
    Note: Full memory barrier (ensure all memory ops complete)
    Note: Returns: 0

    Note: On DSP, implemented via special instruction or NOP sequence
    Note: Compiler intrinsic would emit appropriate barrier instruction

    Return 0
End Process

Process called "data_sync_barrier" returns Integer:
    Note: Data synchronization barrier
    Note: Returns: 0

    Return 0
End Process

Process called "instruction_sync_barrier" returns Integer:
    Note: Instruction synchronization barrier
    Note: Returns: 0

    Return 0
End Process

Note: ============================================================================
Note: CIRCULAR BUFFER CONFIGURATION
Note: ============================================================================

Process called "configure_circular_buffer" takes ar_num as Integer, buffer_base as Integer, buffer_size as Integer returns Integer:
    Note: Configure address register for circular buffer
    Note: ar_num: Address register number (0-7)
    Note: buffer_base: Buffer base address
    Note: buffer_size: Buffer size in bytes (power of 2)
    Note: Returns: 0 on success

    Note: Set address register base
    Let ar_base be 0x01850000  Note: Address register file base
    Let ar_offset be ar_num multiplied by 4
    Memory.memory_set_int32(ar_base, ar_offset, buffer_base)

    Note: Calculate and set buffer size encoding (log2)
    Let size_log2 be 0
    Let size be buffer_size

    While size is greater than 1:
        Set size to size shifted_right 1
        Set size_log2 to size_log2 plus 1
    End While

    Note: Set AMR (Addressing Mode Register) for this AR
    Let amr_base be 0x01850100
    Let current_amr be Memory.memory_get_int32(amr_base, 0)

    Note: Clear bits for this AR (4 bits per AR)
    Let ar_shift be ar_num multiplied by 4
    Let clear_mask be 15 shifted_left ar_shift  Note: 0xF
    Let inv_mask be 0 minus clear_mask
    Set inv_mask to inv_mask minus 1
    Set inv_mask to inv_mask bitwise_xor clear_mask
    Let cleared_amr be current_amr bitwise_and inv_mask

    Note: Set new size bits
    Let size_bits be size_log2 shifted_left ar_shift
    Let new_amr be cleared_amr bitwise_or size_bits
    Memory.memory_set_int32(amr_base, 0, new_amr)

    Return 0
End Process

Note: ============================================================================
Note: PROFILING AND PERFORMANCE COUNTERS
Note: ============================================================================

Process called "perf_counter_start" takes counter_id as Integer, event_type as Integer returns Integer:
    Note: Start performance counter
    Note: counter_id: Counter identifier (0-3)
    Note: event_type: Event to count (cycles, stalls, cache misses, etc.)
    Note: Returns: 0 on success

    Let perf_base be 0x01860000
    Let counter_offset be counter_id multiplied by 16

    Note: Set event type
    Memory.memory_set_int32(perf_base, counter_offset, event_type)

    Note: Reset counter to 0
    Memory.memory_set_int32(perf_base, counter_offset plus 4, 0)

    Note: Enable counter
    Memory.memory_set_int32(perf_base, counter_offset plus 8, 1)

    Return 0
End Process

Process called "perf_counter_read" takes counter_id as Integer returns Integer:
    Note: Read performance counter value
    Note: counter_id: Counter identifier
    Note: Returns: Counter value

    Let perf_base be 0x01860000
    Let counter_offset be counter_id multiplied by 16

    Let value be Memory.memory_get_int32(perf_base, counter_offset plus 4)
    Return value
End Process

Process called "perf_counter_stop" takes counter_id as Integer returns Integer:
    Note: Stop performance counter
    Note: counter_id: Counter identifier
    Note: Returns: Final counter value

    Let perf_base be 0x01860000
    Let counter_offset be counter_id multiplied by 16

    Note: Disable counter
    Memory.memory_set_int32(perf_base, counter_offset plus 8, 0)

    Note: Read final value
    Let value be Memory.memory_get_int32(perf_base, counter_offset plus 4)
    Return value
End Process

Note: ============================================================================
Note: REAL-TIME CLOCK / TIMESTAMP
Note: ============================================================================

Process called "get_timestamp" returns Integer:
    Note: Get current timestamp (cycle count)
    Note: Returns: 64-bit timestamp (low 32 bits)

    Let timestamp_base be 0x01870000
    Let timestamp_low be Memory.memory_get_int32(timestamp_base, 0)

    Return timestamp_low
End Process

Process called "get_timestamp_high" returns Integer:
    Note: Get high 32 bits of timestamp
    Note: Returns: High 32 bits

    Let timestamp_base be 0x01870000
    Let timestamp_high be Memory.memory_get_int32(timestamp_base, 4)

    Return timestamp_high
End Process

Process called "calculate_elapsed_cycles" takes start_time as Integer, end_time as Integer returns Integer:
    Note: Calculate elapsed cycles between two timestamps
    Note: start_time: Start timestamp
    Note: end_time: End timestamp
    Note: Returns: Elapsed cycles

    Let elapsed be end_time minus start_time
    Return elapsed
End Process

Process called "cycles_to_microseconds" takes cycles as Integer, clock_freq_mhz as Integer returns Integer:
    Note: Convert cycles to microseconds
    Note: cycles: Number of cycles
    Note: clock_freq_mhz: Clock frequency in MHz
    Note: Returns: Time in microseconds

    Let microseconds be cycles divided by clock_freq_mhz
    Return microseconds
End Process

Note: ============================================================================
Note: POWER MANAGEMENT
Note: ============================================================================

Process called "enter_low_power_mode" takes mode as Integer returns Integer:
    Note: Enter low-power mode
    Note: mode: 0=idle, 1=standby, 2=deep sleep
    Note: Returns: 0 on wake

    Let power_ctrl_base be 0x01880000

    Note: Set power mode register
    Memory.memory_set_int32(power_ctrl_base, 0, mode)

    Note: Execute wait-for-interrupt or equivalent
    Note: Processor will resume on next interrupt

    Return 0
End Process

Process called "set_clock_divider" takes divider as Integer returns Integer:
    Note: Set CPU clock divider
    Note: divider: Clock divider (1, 2, 4, 8)
    Note: Returns: 0 on success

    Let clock_ctrl_base be 0x01890000

    Note: Set divider register
    Memory.memory_set_int32(clock_ctrl_base, 0, divider)

    Return 0
End Process

Note: ============================================================================
Note: UART OPERATIONS
Note: ============================================================================

Process called "UART0_BASE" returns Integer:
    Note: UART0 base address
    Return 0x018A0000
End Process

Process called "UART1_BASE" returns Integer:
    Note: UART1 base address
    Return 0x018A1000
End Process

Process called "uart_init" takes uart_id as Integer, baud_rate as Integer returns Integer:
    Note: Initialize UART peripheral
    Note: uart_id: UART identifier (0, 1)
    Note: baud_rate: Baud rate (9600, 115200, etc.)
    Note: Returns: 0 on success

    Let uart_base be UART0_BASE()
    If uart_id is equal to 1:
        Set uart_base to UART1_BASE()
    End If

    Note: Calculate baud divisor (assuming 150MHz peripheral clock)
    Let periph_clock be 150000000
    Let divisor be periph_clock divided by baud_rate
    Let divisor2 be divisor divided by 16  Note: 16x oversampling

    Note: Set baud rate divisor register
    Memory.memory_set_int32(uart_base, 12, divisor2)

    Note: Set control register (8N1, enable TX/RX)
    Let control_value be 3  Note: Bit 0=RX enable, bit 1=TX enable
    Memory.memory_set_int32(uart_base, 8, control_value)

    Return 0
End Process

Process called "uart_transmit_byte" takes uart_id as Integer, data_byte as Integer returns Integer:
    Note: Transmit single byte via UART
    Note: uart_id: UART identifier
    Note: data_byte: Byte to transmit (0-255)
    Note: Returns: 0 on success

    Let uart_base be UART0_BASE()
    If uart_id is equal to 1:
        Set uart_base to UART1_BASE()
    End If

    Note: Wait for TX FIFO ready (bit 1 of status register)
    Let status_offset be 4
    Let tx_ready_bit be 2

    Let ready be 0
    While ready is equal to 0:
        Let status be Memory.memory_get_int32(uart_base, status_offset)
        Let status_check be status bitwise_and tx_ready_bit
        If status_check is not equal to 0:
            Set ready to 1
        End If
    End While

    Note: Write data to TX register
    Memory.memory_set_int32(uart_base, 0, data_byte)

    Return 0
End Process

Process called "uart_receive_byte" takes uart_id as Integer returns Integer:
    Note: Receive single byte from UART
    Note: uart_id: UART identifier
    Note: Returns: Received byte (0-255), or -1 if no data

    Let uart_base be UART0_BASE()
    If uart_id is equal to 1:
        Set uart_base to UART1_BASE()
    End If

    Note: Check RX FIFO ready (bit 0 of status register)
    Let status_offset be 4
    Let rx_ready_bit be 1

    Let status be Memory.memory_get_int32(uart_base, status_offset)
    Let status_check be status bitwise_and rx_ready_bit

    If status_check is equal to 0:
        Return -1  Note: No data available
    End If

    Note: Read data from RX register
    Let data be Memory.memory_get_int32(uart_base, 0)
    Let data_byte be data bitwise_and 255

    Return data_byte
End Process

Process called "uart_transmit_ready" takes uart_id as Integer returns Integer:
    Note: Check if UART transmit buffer is ready
    Note: uart_id: UART identifier
    Note: Returns: 1 if ready, 0 if busy

    Let uart_base be UART0_BASE()
    If uart_id is equal to 1:
        Set uart_base to UART1_BASE()
    End If

    Let status_offset be 4
    Let tx_ready_bit be 2

    Let status be Memory.memory_get_int32(uart_base, status_offset)
    Let status_check be status bitwise_and tx_ready_bit

    If status_check is not equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "uart_receive_ready" takes uart_id as Integer returns Integer:
    Note: Check if UART has received data available
    Note: uart_id: UART identifier
    Note: Returns: 1 if data available, 0 if empty

    Let uart_base be UART0_BASE()
    If uart_id is equal to 1:
        Set uart_base to UART1_BASE()
    End If

    Let status_offset be 4
    Let rx_ready_bit be 1

    Let status be Memory.memory_get_int32(uart_base, status_offset)
    Let status_check be status bitwise_and rx_ready_bit

    If status_check is not equal to 0:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: SPI OPERATIONS
Note: ============================================================================

Process called "SPI0_BASE" returns Integer:
    Note: SPI0 base address
    Return 0x018B0000
End Process

Process called "spi_init" takes spi_id as Integer, clock_divider as Integer returns Integer:
    Note: Initialize SPI peripheral
    Note: spi_id: SPI identifier (0)
    Note: clock_divider: Clock divider (peripheral_clock / (2 * divider))
    Note: Returns: 0 on success

    Let spi_base be SPI0_BASE()

    Note: Set clock divider register
    Memory.memory_set_int32(spi_base, 12, clock_divider)

    Note: Set control register (master mode, CPOL=0, CPHA=0, enable)
    Let control_value be 3  Note: Bit 0=enable, bit 1=master
    Memory.memory_set_int32(spi_base, 4, control_value)

    Return 0
End Process

Process called "spi_set_chip_select" takes spi_id as Integer, cs_pin as Integer, active as Integer returns Integer:
    Note: Set chip select pin state
    Note: spi_id: SPI identifier
    Note: cs_pin: Chip select pin number (0-3)
    Note: active: 1 to activate (assert CS), 0 to deactivate
    Note: Returns: 0 on success

    Let spi_base be SPI0_BASE()
    Let cs_offset be 16

    If active is equal to 1:
        Note: Assert CS (active low, clear bit)
        Let cs_mask be 1 shifted_left cs_pin
        Let current_cs be Memory.memory_get_int32(spi_base, cs_offset)
        Let inverted_mask be 0 minus cs_mask
        Set inverted_mask to inverted_mask minus 1
        Set inverted_mask to inverted_mask bitwise_xor cs_mask
        Let new_cs be current_cs bitwise_and inverted_mask
        Memory.memory_set_int32(spi_base, cs_offset, new_cs)
    Otherwise:
        Note: Deassert CS (set bit)
        Let cs_mask be 1 shifted_left cs_pin
        Let current_cs be Memory.memory_get_int32(spi_base, cs_offset)
        Let new_cs be current_cs bitwise_or cs_mask
        Memory.memory_set_int32(spi_base, cs_offset, new_cs)
    End If

    Return 0
End Process

Process called "spi_transfer_byte" takes spi_id as Integer, data_byte as Integer returns Integer:
    Note: Transfer single byte via SPI (full-duplex)
    Note: spi_id: SPI identifier
    Note: data_byte: Byte to transmit
    Note: Returns: Received byte

    Let spi_base be SPI0_BASE()

    Note: Wait for TX ready (bit 1 of status register)
    Let status_offset be 8
    Let tx_ready_bit be 2

    Let ready be 0
    While ready is equal to 0:
        Let status be Memory.memory_get_int32(spi_base, status_offset)
        Let status_check be status bitwise_and tx_ready_bit
        If status_check is not equal to 0:
            Set ready to 1
        End If
    End While

    Note: Write TX data
    Memory.memory_set_int32(spi_base, 0, data_byte)

    Note: Wait for RX ready (bit 2 of status register)
    Let rx_ready_bit be 4
    Set ready to 0

    While ready is equal to 0:
        Let status be Memory.memory_get_int32(spi_base, status_offset)
        Let status_check be status bitwise_and rx_ready_bit
        If status_check is not equal to 0:
            Set ready to 1
        End If
    End While

    Note: Read RX data
    Let rx_data be Memory.memory_get_int32(spi_base, 0)
    Let rx_byte be rx_data bitwise_and 255

    Return rx_byte
End Process

Process called "spi_transfer_block" takes spi_id as Integer, tx_buffer as Integer, rx_buffer as Integer, length as Integer returns Integer:
    Note: Transfer block of data via SPI
    Note: spi_id: SPI identifier
    Note: tx_buffer: Pointer to transmit buffer
    Note: rx_buffer: Pointer to receive buffer
    Note: length: Number of bytes to transfer
    Note: Returns: Number of bytes transferred

    Let i be 0

    While i is less than length:
        Let tx_byte be Memory.memory_get_byte(tx_buffer, i)
        Let rx_byte be spi_transfer_byte(spi_id, tx_byte)
        Memory.memory_set_byte(rx_buffer, i, rx_byte)
        Set i to i plus 1
    End While

    Return length
End Process

Note: ============================================================================
Note: I2C OPERATIONS
Note: ============================================================================

Process called "I2C0_BASE" returns Integer:
    Note: I2C0 base address
    Return 0x018C0000
End Process

Process called "i2c_init" takes i2c_id as Integer, clock_divider as Integer returns Integer:
    Note: Initialize I2C peripheral
    Note: i2c_id: I2C identifier (0)
    Note: clock_divider: Clock divider for I2C clock rate
    Note: Returns: 0 on success

    Let i2c_base be I2C0_BASE()

    Note: Set clock divider (for 100kHz or 400kHz I2C)
    Memory.memory_set_int32(i2c_base, 16, clock_divider)

    Note: Enable I2C
    Memory.memory_set_int32(i2c_base, 4, 1)

    Return 0
End Process

Process called "i2c_start" takes i2c_id as Integer, slave_addr as Integer, write_mode as Integer returns Integer:
    Note: Generate I2C START and send address
    Note: i2c_id: I2C identifier
    Note: slave_addr: 7-bit slave address
    Note: write_mode: 1 for write, 0 for read
    Note: Returns: 0 if ACK, -1 if NACK

    Let i2c_base be I2C0_BASE()

    Note: Set slave address with R/W bit
    Let addr_with_rw be slave_addr shifted_left 1
    If write_mode is equal to 0:
        Set addr_with_rw to addr_with_rw bitwise_or 1
    End If

    Memory.memory_set_int32(i2c_base, 12, addr_with_rw)

    Note: Generate START condition (set bit 1 in control)
    Let control_value be 3  Note: Bit 0=enable, bit 1=start
    Memory.memory_set_int32(i2c_base, 4, control_value)

    Note: Wait for transfer complete (bit 2 of status)
    Let status_offset be 8
    Let complete_bit be 4

    Let complete be 0
    While complete is equal to 0:
        Let status be Memory.memory_get_int32(i2c_base, status_offset)
        Let status_check be status bitwise_and complete_bit
        If status_check is not equal to 0:
            Set complete to 1
        End If
    End While

    Note: Check for ACK (bit 1 of status)
    Let rxack_bit be 2
    Let status be Memory.memory_get_int32(i2c_base, status_offset)
    Let ack_check be status bitwise_and rxack_bit

    If ack_check is equal to 0:
        Return -1  Note: NACK
    End If

    Return 0  Note: ACK
End Process

Process called "i2c_stop" takes i2c_id as Integer returns Integer:
    Note: Generate I2C STOP condition
    Note: i2c_id: I2C identifier
    Note: Returns: 0 on success

    Let i2c_base be I2C0_BASE()

    Note: Generate STOP (set bit 2 in control)
    Let control_value be 5  Note: Bit 0=enable, bit 2=stop
    Memory.memory_set_int32(i2c_base, 4, control_value)

    Return 0
End Process

Process called "i2c_write_byte" takes i2c_id as Integer, data_byte as Integer returns Integer:
    Note: Write single byte to I2C bus
    Note: i2c_id: I2C identifier
    Note: data_byte: Byte to write
    Note: Returns: 0 if ACK, -1 if NACK

    Let i2c_base be I2C0_BASE()

    Note: Write data
    Memory.memory_set_int32(i2c_base, 0, data_byte)

    Note: Wait for transfer complete
    Let status_offset be 8
    Let complete_bit be 4

    Let complete be 0
    While complete is equal to 0:
        Let status be Memory.memory_get_int32(i2c_base, status_offset)
        Let status_check be status bitwise_and complete_bit
        If status_check is not equal to 0:
            Set complete to 1
        End If
    End While

    Note: Check for ACK
    Let rxack_bit be 2
    Let status be Memory.memory_get_int32(i2c_base, status_offset)
    Let ack_check be status bitwise_and rxack_bit

    If ack_check is equal to 0:
        Return -1  Note: NACK
    End If

    Return 0  Note: ACK
End Process

Process called "i2c_read_byte" takes i2c_id as Integer, send_ack as Integer returns Integer:
    Note: Read single byte from I2C bus
    Note: i2c_id: I2C identifier
    Note: send_ack: 1 to send ACK, 0 to send NACK
    Note: Returns: Received byte

    Let i2c_base be I2C0_BASE()

    Note: Set ACK/NACK bit in control
    Let control_value be 1  Note: Enable
    If send_ack is equal to 1:
        Set control_value to control_value bitwise_or 8  Note: Bit 3=ACK
    Otherwise:
        Set control_value to control_value bitwise_or 16  Note: Bit 4=NACK
    End If

    Memory.memory_set_int32(i2c_base, 4, control_value)

    Note: Wait for transfer complete
    Let status_offset be 8
    Let complete_bit be 4

    Let complete be 0
    While complete is equal to 0:
        Let status be Memory.memory_get_int32(i2c_base, status_offset)
        Let status_check be status bitwise_and complete_bit
        If status_check is not equal to 0:
            Set complete to 1
        End If
    End While

    Note: Read data
    Let data be Memory.memory_get_int32(i2c_base, 0)
    Let data_byte be data bitwise_and 255

    Return data_byte
End Process

Process called "i2c_write_block" takes i2c_id as Integer, slave_addr as Integer, buffer as Integer, length as Integer returns Integer:
    Note: Write block of data to I2C slave
    Note: i2c_id: I2C identifier
    Note: slave_addr: 7-bit slave address
    Note: buffer: Pointer to data buffer
    Note: length: Number of bytes to write
    Note: Returns: Bytes written, or -1 on error

    Let result be i2c_start(i2c_id, slave_addr, 1)
    If result is not equal to 0:
        Let stop_result be i2c_stop(i2c_id)
        Return -1
    End If

    Let i be 0
    While i is less than length:
        Let data_byte be Memory.memory_get_byte(buffer, i)
        Let write_result be i2c_write_byte(i2c_id, data_byte)

        If write_result is not equal to 0:
            Let stop_result be i2c_stop(i2c_id)
            Return i
        End If

        Set i to i plus 1
    End While

    Let stop_result be i2c_stop(i2c_id)
    Return length
End Process

Process called "i2c_read_block" takes i2c_id as Integer, slave_addr as Integer, buffer as Integer, length as Integer returns Integer:
    Note: Read block of data from I2C slave
    Note: i2c_id: I2C identifier
    Note: slave_addr: 7-bit slave address
    Note: buffer: Pointer to receive buffer
    Note: length: Number of bytes to read
    Note: Returns: Bytes read, or -1 on error

    Let result be i2c_start(i2c_id, slave_addr, 0)
    If result is not equal to 0:
        Let stop_result be i2c_stop(i2c_id)
        Return -1
    End If

    Let i be 0
    While i is less than length:
        Let send_ack be 1
        Let last_byte be length minus 1
        If i is equal to last_byte:
            Set send_ack to 0
        End If

        Let data_byte be i2c_read_byte(i2c_id, send_ack)
        Memory.memory_set_byte(buffer, i, data_byte)

        Set i to i plus 1
    End While

    Let stop_result be i2c_stop(i2c_id)
    Return length
End Process
