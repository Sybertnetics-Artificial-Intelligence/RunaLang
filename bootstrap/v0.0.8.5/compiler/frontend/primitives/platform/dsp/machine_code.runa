Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
DSP Machine Code Generation

This file implements DSP assembly code encoding for DSP platforms.

DSP instruction encoding (32-bit fixed-length instructions):
- Opcode field: bits 27-31 (5 bits)
- Destination register: bits 23-27 (5 bits)
- Source register 1: bits 18-22 (5 bits)
- Source register 2: bits 13-17 (5 bits)
- Immediate/offset: bits 0-12 (13 bits signed)
- Addressing mode: bits 8-10 (3 bits)

Parallel execution packets:
- Multiple instructions can execute in parallel
- Packet delimiter bit indicates last instruction in packet

Dependencies: memory_core.runa for buffer operations
:End Note

Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Note: ============================================================================
Note: INSTRUCTION ENCODING
Note: ============================================================================

Process called "write_instruction" takes buffer_ptr as Integer, offset as Integer, instruction as Integer returns Integer:
    Note: Write 32-bit DSP instruction to buffer
    Note: buffer_ptr: Pointer to output buffer
    Note: offset: Current write offset
    Note: instruction: Encoded 32-bit instruction
    Note: Returns: New offset (offset + 4)

    Note: Little-endian encoding
    Memory.memory_set_byte(buffer_ptr, offset, instruction bitwise_and 255)
    Memory.memory_set_byte(buffer_ptr, offset plus 1, (instruction shifted_right 8) bitwise_and 255)
    Memory.memory_set_byte(buffer_ptr, offset plus 2, (instruction shifted_right 16) bitwise_and 255)
    Memory.memory_set_byte(buffer_ptr, offset plus 3, (instruction shifted_right 24) bitwise_and 255)

    Return offset plus 4
End Process

Note: ============================================================================
Note: DATA MOVEMENT INSTRUCTIONS
Note: ============================================================================

Process called "encode_mov" takes buffer_ptr as Integer, dest_reg as Integer, src_reg as Integer returns Integer:
    Note: Encode MOV instruction (Rd = Rs)
    Note: buffer_ptr: Output buffer pointer
    Note: dest_reg: Destination register number
    Note: src_reg: Source register number
    Note: Returns: New offset

    Note: MOV opcode: 0x01 (bits 27-31)
    Let instruction be 33554432  Note: 0x01 << 27 = 0x02000000

    Note: Insert destination register (bits 23-27)
    Let dest_bits be dest_reg shifted_left 23
    Set instruction to instruction bitwise_or dest_bits

    Note: Insert source register (bits 18-22)
    Let src_bits be src_reg shifted_left 18
    Set instruction to instruction bitwise_or src_bits

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_load" takes buffer_ptr as Integer, dest_reg as Integer, base_reg as Integer, offset as Integer returns Integer:
    Note: Encode LD instruction (Rd = [Rs + offset])
    Note: buffer_ptr: Output buffer pointer
    Note: dest_reg: Destination register number
    Note: base_reg: Base address register number
    Note: offset: Offset in bytes (signed 13-bit)
    Note: Returns: New offset

    Note: LD opcode: 0x02
    Let instruction be 67108864  Note: 0x02 << 27 = 0x04000000

    Note: Insert destination register
    Let dest_bits be dest_reg shifted_left 23
    Set instruction to instruction bitwise_or dest_bits

    Note: Insert base register
    Let base_bits be base_reg shifted_left 18
    Set instruction to instruction bitwise_or base_bits

    Note: Insert offset (13-bit signed, bits 0-12)
    Let offset_masked be offset bitwise_and 8191  Note: 0x1FFF (13 bits)
    Set instruction to instruction bitwise_or offset_masked

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_store" takes buffer_ptr as Integer, src_reg as Integer, base_reg as Integer, offset as Integer returns Integer:
    Note: Encode ST instruction ([Rd + offset] = Rs)
    Note: buffer_ptr: Output buffer pointer
    Note: src_reg: Source register number
    Note: base_reg: Base address register number
    Note: offset: Offset in bytes (signed 13-bit)
    Note: Returns: New offset

    Note: ST opcode: 0x03
    Let instruction be 100663296  Note: 0x03 << 27 = 0x06000000

    Note: Insert source register
    Let src_bits be src_reg shifted_left 23
    Set instruction to instruction bitwise_or src_bits

    Note: Insert base register
    Let base_bits be base_reg shifted_left 18
    Set instruction to instruction bitwise_or base_bits

    Note: Insert offset
    Let offset_masked be offset bitwise_and 8191
    Set instruction to instruction bitwise_or offset_masked

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Note: ============================================================================
Note: ARITHMETIC INSTRUCTIONS
Note: ============================================================================

Process called "encode_add" takes buffer_ptr as Integer, dest_reg as Integer, src1_reg as Integer, src2_reg as Integer returns Integer:
    Note: Encode ADD instruction (Rd = Rs1 + Rs2)
    Note: buffer_ptr: Output buffer pointer
    Note: dest_reg: Destination register
    Note: src1_reg: Source register 1
    Note: src2_reg: Source register 2
    Note: Returns: New offset

    Note: ADD opcode: 0x08
    Let instruction be 268435456  Note: 0x08 << 27 = 0x10000000

    Let dest_bits be dest_reg shifted_left 23
    Set instruction to instruction bitwise_or dest_bits

    Let src1_bits be src1_reg shifted_left 18
    Set instruction to instruction bitwise_or src1_bits

    Let src2_bits be src2_reg shifted_left 13
    Set instruction to instruction bitwise_or src2_bits

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_sub" takes buffer_ptr as Integer, dest_reg as Integer, src1_reg as Integer, src2_reg as Integer returns Integer:
    Note: Encode SUB instruction (Rd = Rs1 - Rs2)
    Note: buffer_ptr: Output buffer pointer
    Note: dest_reg: Destination register
    Note: src1_reg: Source register 1
    Note: src2_reg: Source register 2
    Note: Returns: New offset

    Note: SUB opcode: 0x09
    Let instruction be 301989888  Note: 0x09 << 27

    Let dest_bits be dest_reg shifted_left 23
    Set instruction to instruction bitwise_or dest_bits

    Let src1_bits be src1_reg shifted_left 18
    Set instruction to instruction bitwise_or src1_bits

    Let src2_bits be src2_reg shifted_left 13
    Set instruction to instruction bitwise_or src2_bits

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Note: ============================================================================
Note: MAC (MULTIPLY-ACCUMULATE) INSTRUCTIONS
Note: ============================================================================

Process called "encode_mpy" takes buffer_ptr as Integer, dest_reg as Integer, src1_reg as Integer, src2_reg as Integer returns Integer:
    Note: Encode MPY instruction (Rd = Rs1 * Rs2)
    Note: buffer_ptr: Output buffer pointer
    Note: dest_reg: Destination register
    Note: src1_reg: Source register 1
    Note: src2_reg: Source register 2
    Note: Returns: New offset

    Note: MPY opcode: 0x0A
    Let instruction be 335544320  Note: 0x0A << 27

    Let dest_bits be dest_reg shifted_left 23
    Set instruction to instruction bitwise_or dest_bits

    Let src1_bits be src1_reg shifted_left 18
    Set instruction to instruction bitwise_or src1_bits

    Let src2_bits be src2_reg shifted_left 13
    Set instruction to instruction bitwise_or src2_bits

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_mac" takes buffer_ptr as Integer, acc_reg as Integer, src1_reg as Integer, src2_reg as Integer returns Integer:
    Note: Encode MAC instruction (Acc = Acc + Rs1 * Rs2)
    Note: buffer_ptr: Output buffer pointer
    Note: acc_reg: Accumulator register number
    Note: src1_reg: Source register 1
    Note: src2_reg: Source register 2
    Note: Returns: New offset

    Note: MAC opcode: 0x0B
    Let instruction be 369098752  Note: 0x0B << 27

    Let acc_bits be acc_reg shifted_left 23
    Set instruction to instruction bitwise_or acc_bits

    Let src1_bits be src1_reg shifted_left 18
    Set instruction to instruction bitwise_or src1_bits

    Let src2_bits be src2_reg shifted_left 13
    Set instruction to instruction bitwise_or src2_bits

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_mas" takes buffer_ptr as Integer, acc_reg as Integer, src1_reg as Integer, src2_reg as Integer returns Integer:
    Note: Encode MAS instruction (Acc = Acc - Rs1 * Rs2)
    Note: buffer_ptr: Output buffer pointer
    Note: acc_reg: Accumulator register number
    Note: src1_reg: Source register 1
    Note: src2_reg: Source register 2
    Note: Returns: New offset

    Note: MAS opcode: 0x0C
    Let instruction be 402653184  Note: 0x0C << 27

    Let acc_bits be acc_reg shifted_left 23
    Set instruction to instruction bitwise_or acc_bits

    Let src1_bits be src1_reg shifted_left 18
    Set instruction to instruction bitwise_or src1_bits

    Let src2_bits be src2_reg shifted_left 13
    Set instruction to instruction bitwise_or src2_bits

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Note: ============================================================================
Note: LOGICAL INSTRUCTIONS
Note: ============================================================================

Process called "encode_and" takes buffer_ptr as Integer, dest_reg as Integer, src1_reg as Integer, src2_reg as Integer returns Integer:
    Note: Encode AND instruction (Rd = Rs1 & Rs2)
    Let instruction be 536870912  Note: 0x10 << 27

    Let dest_bits be dest_reg shifted_left 23
    Set instruction to instruction bitwise_or dest_bits

    Let src1_bits be src1_reg shifted_left 18
    Set instruction to instruction bitwise_or src1_bits

    Let src2_bits be src2_reg shifted_left 13
    Set instruction to instruction bitwise_or src2_bits

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_or" takes buffer_ptr as Integer, dest_reg as Integer, src1_reg as Integer, src2_reg as Integer returns Integer:
    Note: Encode OR instruction (Rd = Rs1 | Rs2)
    Let instruction be 570425344  Note: 0x11 << 27

    Let dest_bits be dest_reg shifted_left 23
    Set instruction to instruction bitwise_or dest_bits

    Let src1_bits be src1_reg shifted_left 18
    Set instruction to instruction bitwise_or src1_bits

    Let src2_bits be src2_reg shifted_left 13
    Set instruction to instruction bitwise_or src2_bits

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_xor" takes buffer_ptr as Integer, dest_reg as Integer, src1_reg as Integer, src2_reg as Integer returns Integer:
    Note: Encode XOR instruction (Rd = Rs1 ^ Rs2)
    Let instruction be 603979776  Note: 0x12 << 27

    Let dest_bits be dest_reg shifted_left 23
    Set instruction to instruction bitwise_or dest_bits

    Let src1_bits be src1_reg shifted_left 18
    Set instruction to instruction bitwise_or src1_bits

    Let src2_bits be src2_reg shifted_left 13
    Set instruction to instruction bitwise_or src2_bits

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Note: ============================================================================
Note: SHIFT INSTRUCTIONS
Note: ============================================================================

Process called "encode_shl" takes buffer_ptr as Integer, dest_reg as Integer, src_reg as Integer, shift_amount as Integer returns Integer:
    Note: Encode SHL instruction (Rd = Rs << amount)
    Let instruction be 671088640  Note: 0x14 << 27

    Let dest_bits be dest_reg shifted_left 23
    Set instruction to instruction bitwise_or dest_bits

    Let src_bits be src_reg shifted_left 18
    Set instruction to instruction bitwise_or src_bits

    Note: Shift amount in bits 0-5
    Let shift_masked be shift_amount bitwise_and 63
    Set instruction to instruction bitwise_or shift_masked

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_shr" takes buffer_ptr as Integer, dest_reg as Integer, src_reg as Integer, shift_amount as Integer returns Integer:
    Note: Encode SHR instruction (Rd = Rs >> amount)
    Let instruction be 704643072  Note: 0x15 << 27

    Let dest_bits be dest_reg shifted_left 23
    Set instruction to instruction bitwise_or dest_bits

    Let src_bits be src_reg shifted_left 18
    Set instruction to instruction bitwise_or src_bits

    Let shift_masked be shift_amount bitwise_and 63
    Set instruction to instruction bitwise_or shift_masked

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Note: ============================================================================
Note: CONTROL FLOW INSTRUCTIONS
Note: ============================================================================

Process called "encode_branch" takes buffer_ptr as Integer, offset as Integer returns Integer:
    Note: Encode BR instruction (unconditional branch)
    Note: offset: PC-relative offset in bytes (signed 23-bit)
    Let instruction be 1073741824  Note: 0x20 << 27

    Note: Offset in bits 0-22 (23-bit signed)
    Let offset_masked be offset bitwise_and 8388607  Note: 0x7FFFFF
    Set instruction to instruction bitwise_or offset_masked

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_call" takes buffer_ptr as Integer, offset as Integer returns Integer:
    Note: Encode CALL instruction (branch with link)
    Note: offset: PC-relative offset in bytes
    Let instruction be 1107296256  Note: 0x21 << 27

    Let offset_masked be offset bitwise_and 8388607
    Set instruction to instruction bitwise_or offset_masked

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "encode_return" takes buffer_ptr as Integer returns Integer:
    Note: Encode RET instruction (return from subroutine)
    Let instruction be 1140850688  Note: 0x22 << 27

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Note: ============================================================================
Note: NOP AND ALIGNMENT
Note: ============================================================================

Process called "encode_nop" takes buffer_ptr as Integer returns Integer:
    Note: Encode NOP instruction (no operation)
    Let instruction be 0

    Return write_instruction(buffer_ptr, 0, instruction)
End Process

Process called "align_code" takes buffer_ptr as Integer, offset as Integer, alignment as Integer returns Integer:
    Note: Align code to specified boundary with NOPs
    Note: buffer_ptr: Output buffer pointer
    Note: offset: Current offset
    Note: alignment: Alignment requirement in bytes
    Note: Returns: New aligned offset

    Let current_offset be offset

    Let remainder be current_offset modulo alignment
    While remainder is not equal to 0:
        Set current_offset to encode_nop(buffer_ptr)
        Set remainder to current_offset modulo alignment
    End While

    Return current_offset
End Process
