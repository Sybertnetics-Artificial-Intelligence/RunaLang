Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
DSP Calling Convention

This file implements calling convention for DSP platforms.

DSP Calling Convention (based on TI C6x/C7x ABI):
- Parameters passed in R4-R11 (8 registers)
- Return value in R4
- Stack pointer: R15 (SP)
- Frame pointer: R14 (FP)
- Link register: R3 (LR - return address)
- Callee-saved: R12-R15
- Caller-saved: R0-R11

Stack frame structure (grows downward):
  [High addresses]
  Previous frame
  Saved registers (R12-R15 if used)
  Local variables
  Spilled arguments (args 8+)
  SP -> [Low addresses]

Register usage:
- R0-R2: Scratch/temporary
- R3: Link register (return address)
- R4-R11: Parameter/scratch
- R12-R13: Callee-saved
- R14: Frame pointer
- R15: Stack pointer
- A0-A7: Accumulator registers (not preserved)
- AR0-AR7: Address registers (caller-saved)
:End Note

Note: ============================================================================
Note: PARAMETER PASSING
Note: ============================================================================

Process called "get_parameter_location" takes param_index as Integer, param_size as Integer returns Integer:
    Note: Get parameter location (register number or stack offset)
    Note: param_index: Parameter index (0, 1, 2, ...)
    Note: param_size: Parameter size in bytes
    Note: Returns: Register number (0-31) or negative stack offset

    Note: First 8 parameters in R4-R11
    If param_index is less than 8:
        Let reg_num be 4 plus param_index
        Return reg_num
    End If

    Note: Parameters 8+ on stack (16-byte aligned)
    Let stack_param_index be param_index minus 8
    Let stack_offset be stack_param_index multiplied by 8
    Let negative_offset be 0 minus stack_offset
    Return negative_offset
End Process

Process called "get_return_value_location" takes return_size as Integer returns Integer:
    Note: Get return value location
    Note: return_size: Return value size in bytes
    Note: Returns: Register number

    Note: Return value in R4
    Return 4
End Process

Process called "calculate_stack_frame_size" takes local_size as Integer, spill_size as Integer, alignment as Integer returns Integer:
    Note: Calculate total stack frame size
    Note: local_size: Size of local variables in bytes
    Note: spill_size: Size of spilled arguments in bytes
    Note: alignment: Stack alignment requirement (typically 8 or 16)
    Note: Returns: Aligned stack frame size

    Let total_size be local_size plus spill_size

    Note: Round up to alignment
    Let remainder be total_size modulo alignment
    If remainder is not equal to 0:
        Let padding be alignment minus remainder
        Set total_size to total_size plus padding
    End If

    Return total_size
End Process

Note: ============================================================================
Note: REGISTER PRESERVATION
Note: ============================================================================

Process called "get_callee_saved_registers" returns Integer:
    Note: Get bitmask of callee-saved registers
    Note: Returns: Bitmask where bit N = 1 if register N is callee-saved

    Note: Callee-saved: R12, R13, R14 (FP), R15 (SP)
    Note: Bitmask: bits 12, 13, 14, 15
    Let mask be 0
    Set mask to mask bitwise_or (1 shifted_left 12)
    Set mask to mask bitwise_or (1 shifted_left 13)
    Set mask to mask bitwise_or (1 shifted_left 14)
    Set mask to mask bitwise_or (1 shifted_left 15)

    Return mask
End Process

Process called "calculate_register_save_size" takes used_registers as Integer returns Integer:
    Note: Calculate size needed to save registers
    Note: used_registers: Bitmask of used callee-saved registers
    Note: Returns: Size in bytes (8 bytes per register)

    Let callee_saved be get_callee_saved_registers()
    Let to_save be used_registers bitwise_and callee_saved

    Note: Count bits set in to_save
    Let count be 0
    Let i be 0

    While i is less than 32:
        Let bit be to_save bitwise_and 1
        If bit is not equal to 0:
            Set count to count plus 1
        End If
        Set to_save to to_save shifted_right 1
        Set i to i plus 1
    End While

    Let size be count multiplied by 8  Note: 8 bytes per register
    Return size
End Process

Note: ============================================================================
Note: STACK MANAGEMENT
Note: ============================================================================

Process called "get_stack_alignment" returns Integer:
    Note: Get required stack alignment in bytes
    Return 16  Note: 16-byte alignment for DSP
End Process

Process called "calculate_argument_stack_size" takes arg_count as Integer returns Integer:
    Note: Calculate stack space needed for arguments 8+
    Note: arg_count: Total argument count
    Note: Returns: Stack size in bytes (16-byte aligned)

    If arg_count is less than or equal to 8:
        Return 0  Note: All in registers
    End If

    Let stack_args be arg_count minus 8
    Let size be stack_args multiplied by 8  Note: 8 bytes per arg

    Note: Align to 16 bytes
    Let alignment be get_stack_alignment()
    Let remainder be size modulo alignment
    If remainder is not equal to 0:
        Let padding be alignment minus remainder
        Set size to size plus padding
    End If

    Return size
End Process

Process called "get_stack_red_zone_size" returns Integer:
    Note: Get red zone size (area beyond SP that can be used without adjusting SP)
    Return 0  Note: No red zone on DSP platforms
End Process

Note: ============================================================================
Note: FUNCTION PROLOGUE/EPILOGUE
Note: ============================================================================

Process called "calculate_prologue_size_bytes" takes frame_size as Integer, saves_lr as Integer, saved_reg_count as Integer returns Integer:
    Note: Calculate prologue code size
    Note: frame_size: Stack frame size
    Note: saves_lr: 1 if LR needs saving, 0 otherwise
    Note: saved_reg_count: Number of callee-saved registers to save
    Note: Returns: Approximate prologue size in bytes

    Note: Each instruction is 4 bytes on DSP
    Let instruction_count be 0

    Note: SP adjustment (1-2 instructions)
    Set instruction_count to instruction_count plus 2

    Note: Save LR if needed (1 instruction)
    If saves_lr is equal to 1:
        Set instruction_count to instruction_count plus 1
    End If

    Note: Save callee-saved registers (1 instruction each)
    Set instruction_count to instruction_count plus saved_reg_count

    Let byte_size be instruction_count multiplied by 4
    Return byte_size
End Process

Process called "calculate_epilogue_size_bytes" takes frame_size as Integer, restores_lr as Integer, saved_reg_count as Integer returns Integer:
    Note: Calculate epilogue code size
    Note: frame_size: Stack frame size
    Note: restores_lr: 1 if LR needs restoring, 0 otherwise
    Note: saved_reg_count: Number of callee-saved registers to restore
    Note: Returns: Approximate epilogue size in bytes

    Let instruction_count be 0

    Note: Restore callee-saved registers (1 instruction each)
    Set instruction_count to instruction_count plus saved_reg_count

    Note: Restore LR if needed (1 instruction)
    If restores_lr is equal to 1:
        Set instruction_count to instruction_count plus 1
    End If

    Note: SP adjustment (1-2 instructions)
    Set instruction_count to instruction_count plus 2

    Note: Return instruction (1 instruction)
    Set instruction_count to instruction_count plus 1

    Let byte_size be instruction_count multiplied by 4
    Return byte_size
End Process

Note: ============================================================================
Note: ACCUMULATOR REGISTER HANDLING
Note: ============================================================================

Process called "requires_accumulator_save" takes uses_mac as Integer returns Integer:
    Note: Check if accumulator registers need to be saved/restored
    Note: uses_mac: 1 if function uses MAC operations, 0 otherwise
    Note: Returns: 1 if accumulator save needed, 0 otherwise

    Note: Accumulators are caller-saved, so callees don't save them
    Return 0
End Process

Process called "get_accumulator_save_size" returns Integer:
    Note: Get size needed to save all accumulator registers
    Note: Returns: Size in bytes

    Note: 8 accumulators × 8 bytes each
    Return 64
End Process

Note: ============================================================================
Note: CIRCULAR BUFFER CONTEXT
Note: ============================================================================

Process called "requires_amr_save" takes uses_circular_buffers as Integer returns Integer:
    Note: Check if AMR (Addressing Mode Register) needs saving
    Note: uses_circular_buffers: 1 if function uses circular buffers, 0 otherwise
    Note: Returns: 1 if AMR save needed, 0 otherwise

    If uses_circular_buffers is equal to 1:
        Return 1  Note: Must save/restore AMR
    End If

    Return 0
End Process

Process called "get_addressing_register_save_size" returns Integer:
    Note: Get size needed to save address registers (AR0-AR7) and AMR
    Note: Returns: Size in bytes

    Note: 8 ARs × 4 bytes + 1 AMR × 4 bytes
    Let ar_size be 8 multiplied by 4
    Let amr_size be 4
    Let total_size be ar_size plus amr_size

    Return total_size
End Process

Note: ============================================================================
Note: LEAF FUNCTION OPTIMIZATION
Note: ============================================================================

Process called "is_leaf_function" takes makes_calls as Integer returns Integer:
    Note: Check if function is a leaf (makes no calls)
    Note: makes_calls: 1 if function makes calls, 0 otherwise
    Note: Returns: 1 if leaf function, 0 otherwise

    If makes_calls is equal to 0:
        Return 1  Note: Leaf function
    End If

    Return 0
End Process

Process called "leaf_function_needs_frame" takes local_size as Integer, spill_count as Integer returns Integer:
    Note: Check if leaf function needs stack frame
    Note: local_size: Size of local variables
    Note: spill_count: Number of spilled values
    Note: Returns: 1 if frame needed, 0 otherwise

    If local_size is greater than 0:
        Return 1  Note: Needs frame for locals
    End If

    If spill_count is greater than 0:
        Return 1  Note: Needs frame for spills
    End If

    Return 0  Note: No frame needed
End Process

Note: ============================================================================
Note: VARIADIC FUNCTIONS
Note: ============================================================================

Process called "handle_variadic_args" takes fixed_arg_count as Integer returns Integer:
    Note: Get location for variadic argument handling
    Note: fixed_arg_count: Number of fixed parameters
    Note: Returns: Stack offset for variadic args

    Note: Variadic args start after fixed args
    If fixed_arg_count is less than 8:
        Note: Some fixed args in registers, varargs start on stack
        Return 0  Note: Start at stack base
    End If

    Note: All fixed args already on stack
    Let stack_args be fixed_arg_count minus 8
    Let offset be stack_args multiplied by 8
    Return offset
End Process

Note: ============================================================================
Note: ALIGNMENT AND PADDING
Note: ============================================================================

Process called "align_stack_offset" takes offset as Integer, alignment as Integer returns Integer:
    Note: Align stack offset to specified alignment
    Note: offset: Current offset
    Note: alignment: Alignment requirement (power of 2)
    Note: Returns: Aligned offset

    Let remainder be offset modulo alignment
    If remainder is equal to 0:
        Return offset  Note: Already aligned
    End If

    Let padding be alignment minus remainder
    Let aligned_offset be offset plus padding
    Return aligned_offset
End Process

Process called "calculate_struct_padding" takes current_offset as Integer, next_field_size as Integer, next_field_alignment as Integer returns Integer:
    Note: Calculate padding needed before next struct field
    Note: current_offset: Current offset in struct
    Note: next_field_size: Size of next field
    Note: next_field_alignment: Alignment of next field
    Note: Returns: Padding bytes needed

    Let aligned_offset be align_stack_offset(current_offset, next_field_alignment)
    Let padding be aligned_offset minus current_offset
    Return padding
End Process
