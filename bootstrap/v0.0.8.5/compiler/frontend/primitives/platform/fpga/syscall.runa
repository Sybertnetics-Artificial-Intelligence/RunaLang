Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
FPGA Hardware I/O and Peripheral Interface Implementation

This file implements memory-mapped I/O operations for FPGA platforms.

Platform-specific details:
- Platform: FPGA (Field-Programmable Gate Array)
- Interface Model: Memory-mapped hardware registers
- Address Space: 32-bit memory-mapped I/O
- Base Address: 0x40000000 (peripheral space)

FPGA peripheral memory map:
- 0x40000000-0x400003FF: GPIO controller
- 0x40000400-0x400007FF: UART0
- 0x40000800-0x40000BFF: UART1
- 0x40000C00-0x40000FFF: SPI0
- 0x40001000-0x400013FF: I2C0
- 0x40001400-0x400017FF: Timer0
- 0x40001800-0x40001BFF: Timer1
- 0x40001C00-0x40001FFF: DMA controller
- 0x40002000-0x400023FF: Interrupt controller

Register access uses memory module for actual reads/writes.
:End Note

Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Note: ============================================================================
Note: PERIPHERAL BASE ADDRESSES
Note: ============================================================================

Process called "PERIPH_BASE" returns Integer:
    Note: Peripheral base address
    Return 1073741824  Note: 0x40000000
End Process

Process called "GPIO_BASE" returns Integer:
    Note: GPIO controller base address
    Let base be PERIPH_BASE()
    Return base  Note: 0x40000000
End Process

Process called "UART0_BASE" returns Integer:
    Note: UART0 base address
    Let base be PERIPH_BASE()
    Return base plus 1024  Note: 0x40000400
End Process

Process called "UART1_BASE" returns Integer:
    Note: UART1 base address
    Let base be PERIPH_BASE()
    Return base plus 2048  Note: 0x40000800
End Process

Process called "SPI0_BASE" returns Integer:
    Note: SPI0 base address
    Let base be PERIPH_BASE()
    Return base plus 3072  Note: 0x40000C00
End Process

Process called "I2C0_BASE" returns Integer:
    Note: I2C0 base address
    Let base be PERIPH_BASE()
    Return base plus 4096  Note: 0x40001000
End Process

Process called "TIMER0_BASE" returns Integer:
    Note: Timer0 base address
    Let base be PERIPH_BASE()
    Return base plus 5120  Note: 0x40001400
End Process

Process called "TIMER1_BASE" returns Integer:
    Note: Timer1 base address
    Let base be PERIPH_BASE()
    Return base plus 6144  Note: 0x40001800
End Process

Process called "DMA_BASE" returns Integer:
    Note: DMA controller base address
    Let base be PERIPH_BASE()
    Return base plus 7168  Note: 0x40001C00
End Process

Process called "INTC_BASE" returns Integer:
    Note: Interrupt controller base address
    Let base be PERIPH_BASE()
    Return base plus 8192  Note: 0x40002000
End Process

Note: ============================================================================
Note: GPIO REGISTER OFFSETS
Note: ============================================================================

Process called "GPIO_DATA_OFFSET" returns Integer:
    Return 0  Note: Data register
End Process

Process called "GPIO_DIR_OFFSET" returns Integer:
    Return 4  Note: Direction register
End Process

Process called "GPIO_SET_OFFSET" returns Integer:
    Return 8  Note: Set bits register
End Process

Process called "GPIO_CLEAR_OFFSET" returns Integer:
    Return 12  Note: Clear bits register
End Process

Process called "GPIO_TOGGLE_OFFSET" returns Integer:
    Return 16  Note: Toggle bits register
End Process

Note: ============================================================================
Note: UART REGISTER OFFSETS
Note: ============================================================================

Process called "UART_DATA_OFFSET" returns Integer:
    Return 0  Note: Data register (TX/RX)
End Process

Process called "UART_STATUS_OFFSET" returns Integer:
    Return 4  Note: Status register
End Process

Process called "UART_CONTROL_OFFSET" returns Integer:
    Return 8  Note: Control register
End Process

Process called "UART_BAUD_OFFSET" returns Integer:
    Return 12  Note: Baud rate divisor
End Process

Note: UART status bits
Process called "UART_STATUS_RXREADY" returns Integer:
    Return 1  Note: Bit 0: RX data ready
End Process

Process called "UART_STATUS_TXREADY" returns Integer:
    Return 2  Note: Bit 1: TX buffer ready
End Process

Note: ============================================================================
Note: MEMORY-MAPPED I/O OPERATIONS
Note: ============================================================================

Process called "mmio_read_32" takes address as Integer returns Integer:
    Note: Read 32-bit value from memory-mapped I/O address
    Note: address: Memory-mapped address
    Note: Returns: 32-bit value read from address

    Let value be Memory.memory_get_int32(address, 0)
    Return value
End Process

Process called "mmio_write_32" takes address as Integer, value as Integer returns Integer:
    Note: Write 32-bit value to memory-mapped I/O address
    Note: address: Memory-mapped address
    Note: value: 32-bit value to write
    Note: Returns: 0 on success

    Memory.memory_set_int32(address, 0, value)
    Return 0
End Process

Process called "mmio_set_bits" takes address as Integer, bit_mask as Integer returns Integer:
    Note: Set specific bits in memory-mapped register (atomic)
    Note: address: Memory-mapped address
    Note: bit_mask: Bits to set (1 = set, 0 = unchanged)
    Note: Returns: Original value before modification

    Let value be mmio_read_32(address)
    Let new_value be value bitwise_or bit_mask
    Let result be mmio_write_32(address, new_value)

    Return value
End Process

Process called "mmio_clear_bits" takes address as Integer, bit_mask as Integer returns Integer:
    Note: Clear specific bits in memory-mapped register (atomic)
    Note: address: Memory-mapped address
    Note: bit_mask: Bits to clear (1 = clear, 0 = unchanged)
    Note: Returns: Original value before modification

    Let value be mmio_read_32(address)
    Let inverted_mask be 0 minus bit_mask
    Set inverted_mask to inverted_mask minus 1
    Set inverted_mask to inverted_mask bitwise_xor bit_mask
    Let new_value be value bitwise_and inverted_mask
    Let result be mmio_write_32(address, new_value)

    Return value
End Process

Note: ============================================================================
Note: GPIO OPERATIONS
Note: ============================================================================

Process called "gpio_set_pin" takes pin_number as Integer returns Integer:
    Note: Set GPIO pin to high (1)
    Note: pin_number: GPIO pin number (0-31)
    Note: Returns: 0 on success

    Let gpio_base be GPIO_BASE()
    Let set_reg be gpio_base plus GPIO_SET_OFFSET()
    Let pin_mask be 1 shifted_left pin_number

    Let result be mmio_write_32(set_reg, pin_mask)
    Return result
End Process

Process called "gpio_clear_pin" takes pin_number as Integer returns Integer:
    Note: Set GPIO pin to low (0)
    Note: pin_number: GPIO pin number (0-31)
    Note: Returns: 0 on success

    Let gpio_base be GPIO_BASE()
    Let clear_reg be gpio_base plus GPIO_CLEAR_OFFSET()
    Let pin_mask be 1 shifted_left pin_number

    Let result be mmio_write_32(clear_reg, pin_mask)
    Return result
End Process

Process called "gpio_toggle_pin" takes pin_number as Integer returns Integer:
    Note: Toggle GPIO pin state
    Note: pin_number: GPIO pin number (0-31)
    Note: Returns: 0 on success

    Let gpio_base be GPIO_BASE()
    Let toggle_reg be gpio_base plus GPIO_TOGGLE_OFFSET()
    Let pin_mask be 1 shifted_left pin_number

    Let result be mmio_write_32(toggle_reg, pin_mask)
    Return result
End Process

Process called "gpio_read_pin" takes pin_number as Integer returns Integer:
    Note: Read GPIO pin state
    Note: pin_number: GPIO pin number (0-31)
    Note: Returns: Pin state (0 or 1)

    Let gpio_base be GPIO_BASE()
    Let data_reg be gpio_base plus GPIO_DATA_OFFSET()

    Let value be mmio_read_32(data_reg)
    Let pin_mask be 1 shifted_left pin_number
    Let pin_value be value bitwise_and pin_mask

    If pin_value is not equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "gpio_set_direction" takes pin_number as Integer, direction as Integer returns Integer:
    Note: Set GPIO pin direction
    Note: pin_number: GPIO pin number (0-31)
    Note: direction: 0=input, 1=output
    Note: Returns: 0 on success

    Let gpio_base be GPIO_BASE()
    Let dir_reg be gpio_base plus GPIO_DIR_OFFSET()
    Let pin_mask be 1 shifted_left pin_number

    If direction is equal to 1:
        Note: Set bit for output
        Let result be mmio_set_bits(dir_reg, pin_mask)
    Otherwise:
        Note: Clear bit for input
        Let result be mmio_clear_bits(dir_reg, pin_mask)
    End If

    Return 0
End Process

Process called "gpio_write_port" takes port_number as Integer, value as Integer returns Integer:
    Note: Write entire GPIO port (32 pins at once)
    Note: port_number: GPIO port number (0 = pins 0-31, 1 = pins 32-63)
    Note: value: Value to write to port
    Note: Returns: 0 on success

    Let gpio_base be GPIO_BASE()
    Let port_offset be port_number multiplied by 32
    Let data_reg be gpio_base plus GPIO_DATA_OFFSET()
    Set data_reg to data_reg plus port_offset

    Let result be mmio_write_32(data_reg, value)
    Return result
End Process

Process called "gpio_read_port" takes port_number as Integer returns Integer:
    Note: Read entire GPIO port
    Note: port_number: GPIO port number
    Note: Returns: Port value

    Let gpio_base be GPIO_BASE()
    Let port_offset be port_number multiplied by 32
    Let data_reg be gpio_base plus GPIO_DATA_OFFSET()
    Set data_reg to data_reg plus port_offset

    Let value be mmio_read_32(data_reg)
    Return value
End Process

Note: ============================================================================
Note: UART OPERATIONS
Note: ============================================================================

Process called "uart_init" takes uart_id as Integer, baud_rate as Integer returns Integer:
    Note: Initialize UART peripheral
    Note: uart_id: UART peripheral identifier (0, 1)
    Note: baud_rate: Baud rate (9600, 115200, etc.)
    Note: Returns: 0 on success

    Let uart_base be UART0_BASE()
    If uart_id is equal to 1:
        Set uart_base to UART1_BASE()
    End If

    Note: Calculate baud divisor (assuming 50MHz system clock)
    Let sys_clock be 50000000
    Let divisor be sys_clock divided by baud_rate

    Let baud_reg be uart_base plus UART_BAUD_OFFSET()
    Let result be mmio_write_32(baud_reg, divisor)

    Note: Enable UART in control register (bit 0 = enable)
    Let ctrl_reg be uart_base plus UART_CONTROL_OFFSET()
    Let result2 be mmio_write_32(ctrl_reg, 1)

    Return 0
End Process

Process called "uart_transmit_byte" takes uart_id as Integer, data_byte as Integer returns Integer:
    Note: Transmit single byte via UART
    Note: uart_id: UART peripheral identifier
    Note: data_byte: Byte to transmit (0-255)
    Note: Returns: 0 on success

    Let uart_base be UART0_BASE()
    If uart_id is equal to 1:
        Set uart_base to UART1_BASE()
    End If

    Note: Wait for TX ready
    Let status_reg be uart_base plus UART_STATUS_OFFSET()
    Let tx_ready be UART_STATUS_TXREADY()

    Let ready be 0
    While ready is equal to 0:
        Let status be mmio_read_32(status_reg)
        Let status_bit be status bitwise_and tx_ready
        If status_bit is not equal to 0:
            Set ready to 1
        End If
    End While

    Note: Write data
    Let data_reg be uart_base plus UART_DATA_OFFSET()
    Let result be mmio_write_32(data_reg, data_byte)

    Return 0
End Process

Process called "uart_receive_byte" takes uart_id as Integer returns Integer:
    Note: Receive single byte from UART
    Note: uart_id: UART peripheral identifier
    Note: Returns: Received byte (0-255), or -1 if no data available

    Let uart_base be UART0_BASE()
    If uart_id is equal to 1:
        Set uart_base to UART1_BASE()
    End If

    Note: Check if RX ready
    Let status_reg be uart_base plus UART_STATUS_OFFSET()
    Let status be mmio_read_32(status_reg)
    Let rx_ready be UART_STATUS_RXREADY()
    Let status_bit be status bitwise_and rx_ready

    If status_bit is equal to 0:
        Return -1  Note: No data available
    End If

    Note: Read data
    Let data_reg be uart_base plus UART_DATA_OFFSET()
    Let data_byte be mmio_read_32(data_reg)

    Note: Mask to 8 bits
    Let result be data_byte bitwise_and 255

    Return result
End Process

Process called "uart_transmit_ready" takes uart_id as Integer returns Integer:
    Note: Check if UART transmit buffer is ready
    Note: uart_id: UART peripheral identifier
    Note: Returns: 1 if ready to transmit, 0 if busy

    Let uart_base be UART0_BASE()
    If uart_id is equal to 1:
        Set uart_base to UART1_BASE()
    End If

    Let status_reg be uart_base plus UART_STATUS_OFFSET()
    Let status be mmio_read_32(status_reg)
    Let tx_ready be UART_STATUS_TXREADY()
    Let status_bit be status bitwise_and tx_ready

    If status_bit is not equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "uart_receive_ready" takes uart_id as Integer returns Integer:
    Note: Check if UART has received data available
    Note: uart_id: UART peripheral identifier
    Note: Returns: 1 if data available, 0 if empty

    Let uart_base be UART0_BASE()
    If uart_id is equal to 1:
        Set uart_base to UART1_BASE()
    End If

    Let status_reg be uart_base plus UART_STATUS_OFFSET()
    Let status be mmio_read_32(status_reg)
    Let rx_ready be UART_STATUS_RXREADY()
    Let status_bit be status bitwise_and rx_ready

    If status_bit is not equal to 0:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: SPI OPERATIONS
Note: ============================================================================

Process called "SPI_DATA_OFFSET" returns Integer:
    Return 0  Note: Data register (TX/RX)
End Process

Process called "SPI_CONTROL_OFFSET" returns Integer:
    Return 4  Note: Control register
End Process

Process called "SPI_STATUS_OFFSET" returns Integer:
    Return 8  Note: Status register
End Process

Process called "SPI_CLOCK_DIV_OFFSET" returns Integer:
    Return 12  Note: Clock divider register
End Process

Process called "SPI_CS_OFFSET" returns Integer:
    Return 16  Note: Chip select register
End Process

Note: SPI status bits
Process called "SPI_STATUS_BUSY" returns Integer:
    Return 1  Note: Bit 0: Transfer in progress
End Process

Process called "SPI_STATUS_TXREADY" returns Integer:
    Return 2  Note: Bit 1: TX buffer ready
End Process

Process called "SPI_STATUS_RXREADY" returns Integer:
    Return 4  Note: Bit 2: RX data available
End Process

Process called "spi_init" takes spi_id as Integer, clock_divider as Integer returns Integer:
    Note: Initialize SPI peripheral
    Note: spi_id: SPI peripheral identifier (0 = SPI0)
    Note: clock_divider: Clock divider (sys_clock / (2 * divider))
    Note: Returns: 0 on success

    Let spi_base be SPI0_BASE()

    Note: Set clock divider
    Let div_reg be spi_base plus SPI_CLOCK_DIV_OFFSET()
    Let result be mmio_write_32(div_reg, clock_divider)

    Note: Enable SPI in control register (bit 0 = enable, bit 1 = master mode)
    Let ctrl_reg be spi_base plus SPI_CONTROL_OFFSET()
    Let result2 be mmio_write_32(ctrl_reg, 3)  Note: Enable + Master

    Return 0
End Process

Process called "spi_set_chip_select" takes spi_id as Integer, cs_pin as Integer, active as Integer returns Integer:
    Note: Set chip select pin state
    Note: spi_id: SPI peripheral identifier
    Note: cs_pin: Chip select pin number (0-3)
    Note: active: 1 to activate (assert CS), 0 to deactivate
    Note: Returns: 0 on success

    Let spi_base be SPI0_BASE()
    Let cs_reg be spi_base plus SPI_CS_OFFSET()

    If active is equal to 1:
        Note: Set CS bit (active low, so clear the bit)
        Let cs_mask be 1 shifted_left cs_pin
        Let inverted_mask be 0 minus cs_mask
        Set inverted_mask to inverted_mask minus 1
        Set inverted_mask to inverted_mask bitwise_xor cs_mask
        Let current_cs be mmio_read_32(cs_reg)
        Let new_cs be current_cs bitwise_and inverted_mask
        Let result be mmio_write_32(cs_reg, new_cs)
    Otherwise:
        Note: Clear CS bit (inactive)
        Let cs_mask be 1 shifted_left cs_pin
        Let result be mmio_set_bits(cs_reg, cs_mask)
    End If

    Return 0
End Process

Process called "spi_transfer_byte" takes spi_id as Integer, data_byte as Integer returns Integer:
    Note: Transfer single byte via SPI (full-duplex)
    Note: spi_id: SPI peripheral identifier
    Note: data_byte: Byte to transmit
    Note: Returns: Received byte

    Let spi_base be SPI0_BASE()

    Note: Wait for TX ready
    Let status_reg be spi_base plus SPI_STATUS_OFFSET()
    Let tx_ready_bit be SPI_STATUS_TXREADY()

    Let ready be 0
    While ready is equal to 0:
        Let status be mmio_read_32(status_reg)
        Let status_check be status bitwise_and tx_ready_bit
        If status_check is not equal to 0:
            Set ready to 1
        End If
    End While

    Note: Write data to TX register
    Let data_reg be spi_base plus SPI_DATA_OFFSET()
    Let result be mmio_write_32(data_reg, data_byte)

    Note: Wait for RX ready
    Let rx_ready_bit be SPI_STATUS_RXREADY()
    Set ready to 0

    While ready is equal to 0:
        Let status be mmio_read_32(status_reg)
        Let status_check be status bitwise_and rx_ready_bit
        If status_check is not equal to 0:
            Set ready to 1
        End If
    End While

    Note: Read received data
    Let rx_data be mmio_read_32(data_reg)
    Let rx_byte be rx_data bitwise_and 255

    Return rx_byte
End Process

Process called "spi_transfer_block" takes spi_id as Integer, tx_buffer as Integer, rx_buffer as Integer, length as Integer returns Integer:
    Note: Transfer block of data via SPI
    Note: spi_id: SPI peripheral identifier
    Note: tx_buffer: Pointer to transmit buffer
    Note: rx_buffer: Pointer to receive buffer
    Note: length: Number of bytes to transfer
    Note: Returns: Number of bytes transferred

    Let i be 0

    While i is less than length:
        Note: Get TX byte
        Let tx_byte be Memory.memory_get_byte(tx_buffer, i)

        Note: Transfer byte
        Let rx_byte be spi_transfer_byte(spi_id, tx_byte)

        Note: Store RX byte
        Memory.memory_set_byte(rx_buffer, i, rx_byte)

        Set i to i plus 1
    End While

    Return length
End Process

Note: ============================================================================
Note: I2C OPERATIONS
Note: ============================================================================

Process called "I2C_DATA_OFFSET" returns Integer:
    Return 0  Note: Data register
End Process

Process called "I2C_CONTROL_OFFSET" returns Integer:
    Return 4  Note: Control register
End Process

Process called "I2C_STATUS_OFFSET" returns Integer:
    Return 8  Note: Status register
End Process

Process called "I2C_ADDR_OFFSET" returns Integer:
    Return 12  Note: Slave address register
End Process

Process called "I2C_CLOCK_DIV_OFFSET" returns Integer:
    Return 16  Note: Clock divider register
End Process

Note: I2C control bits
Process called "I2C_CTRL_ENABLE" returns Integer:
    Return 1  Note: Bit 0: Enable I2C
End Process

Process called "I2C_CTRL_START" returns Integer:
    Return 2  Note: Bit 1: Generate START condition
End Process

Process called "I2C_CTRL_STOP" returns Integer:
    Return 4  Note: Bit 2: Generate STOP condition
End Process

Process called "I2C_CTRL_ACK" returns Integer:
    Return 8  Note: Bit 3: Send ACK
End Process

Process called "I2C_CTRL_NACK" returns Integer:
    Return 16  Note: Bit 4: Send NACK
End Process

Note: I2C status bits
Process called "I2C_STATUS_BUSY" returns Integer:
    Return 1  Note: Bit 0: Bus busy
End Process

Process called "I2C_STATUS_RXACK" returns Integer:
    Return 2  Note: Bit 1: Received ACK from slave
End Process

Process called "I2C_STATUS_COMPLETE" returns Integer:
    Return 4  Note: Bit 2: Transfer complete
End Process

Process called "i2c_init" takes i2c_id as Integer, clock_divider as Integer returns Integer:
    Note: Initialize I2C peripheral
    Note: i2c_id: I2C peripheral identifier (0 = I2C0)
    Note: clock_divider: Clock divider for I2C clock rate
    Note: Returns: 0 on success

    Let i2c_base be I2C0_BASE()

    Note: Set clock divider (for 100kHz or 400kHz I2C clock)
    Let div_reg be i2c_base plus I2C_CLOCK_DIV_OFFSET()
    Let result be mmio_write_32(div_reg, clock_divider)

    Note: Enable I2C in control register
    Let ctrl_reg be i2c_base plus I2C_CONTROL_OFFSET()
    Let enable_bit be I2C_CTRL_ENABLE()
    Let result2 be mmio_write_32(ctrl_reg, enable_bit)

    Return 0
End Process

Process called "i2c_start" takes i2c_id as Integer, slave_addr as Integer, write_mode as Integer returns Integer:
    Note: Generate I2C START condition and send address
    Note: i2c_id: I2C peripheral identifier
    Note: slave_addr: 7-bit slave address
    Note: write_mode: 1 for write, 0 for read
    Note: Returns: 0 if ACK received, -1 if NACK

    Let i2c_base be I2C0_BASE()

    Note: Set slave address with R/W bit
    Let addr_with_rw be slave_addr shifted_left 1
    If write_mode is equal to 0:
        Set addr_with_rw to addr_with_rw bitwise_or 1  Note: Read bit
    End If

    Let addr_reg be i2c_base plus I2C_ADDR_OFFSET()
    Let result be mmio_write_32(addr_reg, addr_with_rw)

    Note: Generate START condition
    Let ctrl_reg be i2c_base plus I2C_CONTROL_OFFSET()
    Let start_bit be I2C_CTRL_START()
    Let enable_bit be I2C_CTRL_ENABLE()
    Let ctrl_value be enable_bit bitwise_or start_bit
    Let result2 be mmio_write_32(ctrl_reg, ctrl_value)

    Note: Wait for address transfer complete
    Let status_reg be i2c_base plus I2C_STATUS_OFFSET()
    Let complete_bit be I2C_STATUS_COMPLETE()

    Let complete be 0
    While complete is equal to 0:
        Let status be mmio_read_32(status_reg)
        Let status_check be status bitwise_and complete_bit
        If status_check is not equal to 0:
            Set complete to 1
        End If
    End While

    Note: Check for ACK
    Let rxack_bit be I2C_STATUS_RXACK()
    Let status be mmio_read_32(status_reg)
    Let ack_check be status bitwise_and rxack_bit

    If ack_check is equal to 0:
        Return -1  Note: NACK received
    End If

    Return 0  Note: ACK received
End Process

Process called "i2c_stop" takes i2c_id as Integer returns Integer:
    Note: Generate I2C STOP condition
    Note: i2c_id: I2C peripheral identifier
    Note: Returns: 0 on success

    Let i2c_base be I2C0_BASE()

    Note: Generate STOP condition
    Let ctrl_reg be i2c_base plus I2C_CONTROL_OFFSET()
    Let stop_bit be I2C_CTRL_STOP()
    Let enable_bit be I2C_CTRL_ENABLE()
    Let ctrl_value be enable_bit bitwise_or stop_bit
    Let result be mmio_write_32(ctrl_reg, ctrl_value)

    Return 0
End Process

Process called "i2c_write_byte" takes i2c_id as Integer, data_byte as Integer returns Integer:
    Note: Write single byte to I2C bus
    Note: i2c_id: I2C peripheral identifier
    Note: data_byte: Byte to write
    Note: Returns: 0 if ACK received, -1 if NACK

    Let i2c_base be I2C0_BASE()

    Note: Write data
    Let data_reg be i2c_base plus I2C_DATA_OFFSET()
    Let result be mmio_write_32(data_reg, data_byte)

    Note: Wait for transfer complete
    Let status_reg be i2c_base plus I2C_STATUS_OFFSET()
    Let complete_bit be I2C_STATUS_COMPLETE()

    Let complete be 0
    While complete is equal to 0:
        Let status be mmio_read_32(status_reg)
        Let status_check be status bitwise_and complete_bit
        If status_check is not equal to 0:
            Set complete to 1
        End If
    End While

    Note: Check for ACK
    Let rxack_bit be I2C_STATUS_RXACK()
    Let status be mmio_read_32(status_reg)
    Let ack_check be status bitwise_and rxack_bit

    If ack_check is equal to 0:
        Return -1  Note: NACK received
    End If

    Return 0  Note: ACK received
End Process

Process called "i2c_read_byte" takes i2c_id as Integer, send_ack as Integer returns Integer:
    Note: Read single byte from I2C bus
    Note: i2c_id: I2C peripheral identifier
    Note: send_ack: 1 to send ACK after read, 0 to send NACK
    Note: Returns: Received byte (0-255)

    Let i2c_base be I2C0_BASE()

    Note: Set ACK/NACK bit in control register
    Let ctrl_reg be i2c_base plus I2C_CONTROL_OFFSET()
    Let enable_bit be I2C_CTRL_ENABLE()
    Let ctrl_value be enable_bit

    If send_ack is equal to 1:
        Let ack_bit be I2C_CTRL_ACK()
        Set ctrl_value to ctrl_value bitwise_or ack_bit
    Otherwise:
        Let nack_bit be I2C_CTRL_NACK()
        Set ctrl_value to ctrl_value bitwise_or nack_bit
    End If

    Let result be mmio_write_32(ctrl_reg, ctrl_value)

    Note: Wait for transfer complete
    Let status_reg be i2c_base plus I2C_STATUS_OFFSET()
    Let complete_bit be I2C_STATUS_COMPLETE()

    Let complete be 0
    While complete is equal to 0:
        Let status be mmio_read_32(status_reg)
        Let status_check be status bitwise_and complete_bit
        If status_check is not equal to 0:
            Set complete to 1
        End If
    End While

    Note: Read data
    Let data_reg be i2c_base plus I2C_DATA_OFFSET()
    Let data be mmio_read_32(data_reg)
    Let data_byte be data bitwise_and 255

    Return data_byte
End Process

Process called "i2c_write_block" takes i2c_id as Integer, slave_addr as Integer, buffer as Integer, length as Integer returns Integer:
    Note: Write block of data to I2C slave
    Note: i2c_id: I2C peripheral identifier
    Note: slave_addr: 7-bit slave address
    Note: buffer: Pointer to data buffer
    Note: length: Number of bytes to write
    Note: Returns: Number of bytes written, or -1 on error

    Note: Generate START and address
    Let result be i2c_start(i2c_id, slave_addr, 1)
    If result is not equal to 0:
        Let stop_result be i2c_stop(i2c_id)
        Return -1  Note: Address NACK
    End If

    Note: Write each byte
    Let i be 0
    While i is less than length:
        Let data_byte be Memory.memory_get_byte(buffer, i)
        Let write_result be i2c_write_byte(i2c_id, data_byte)

        If write_result is not equal to 0:
            Let stop_result be i2c_stop(i2c_id)
            Return i  Note: Partial write
        End If

        Set i to i plus 1
    End While

    Note: Generate STOP
    Let stop_result be i2c_stop(i2c_id)

    Return length
End Process

Process called "i2c_read_block" takes i2c_id as Integer, slave_addr as Integer, buffer as Integer, length as Integer returns Integer:
    Note: Read block of data from I2C slave
    Note: i2c_id: I2C peripheral identifier
    Note: slave_addr: 7-bit slave address
    Note: buffer: Pointer to receive buffer
    Note: length: Number of bytes to read
    Note: Returns: Number of bytes read, or -1 on error

    Note: Generate START and address
    Let result be i2c_start(i2c_id, slave_addr, 0)
    If result is not equal to 0:
        Let stop_result be i2c_stop(i2c_id)
        Return -1  Note: Address NACK
    End If

    Note: Read each byte
    Let i be 0
    While i is less than length:
        Note: Send ACK for all bytes except last
        Let send_ack be 1
        Let last_byte be length minus 1
        If i is equal to last_byte:
            Set send_ack to 0  Note: NACK on last byte
        End If

        Let data_byte be i2c_read_byte(i2c_id, send_ack)
        Memory.memory_set_byte(buffer, i, data_byte)

        Set i to i plus 1
    End While

    Note: Generate STOP
    Let stop_result be i2c_stop(i2c_id)

    Return length
End Process

Note: ============================================================================
Note: TIMER OPERATIONS
Note: ============================================================================

Process called "TIMER_CTRL_OFFSET" returns Integer:
    Return 0  Note: Control register
End Process

Process called "TIMER_COUNT_OFFSET" returns Integer:
    Return 4  Note: Count register
End Process

Process called "TIMER_RELOAD_OFFSET" returns Integer:
    Return 8  Note: Reload value register
End Process

Process called "TIMER_STATUS_OFFSET" returns Integer:
    Return 12  Note: Status register
End Process

Process called "timer_init" takes timer_id as Integer, period_us as Integer returns Integer:
    Note: Initialize timer with specified period
    Note: timer_id: Timer peripheral identifier (0, 1)
    Note: period_us: Timer period in microseconds
    Note: Returns: 0 on success

    Let timer_base be TIMER0_BASE()
    If timer_id is equal to 1:
        Set timer_base to TIMER1_BASE()
    End If

    Note: Calculate reload value (assuming 50MHz clock)
    Let sys_clock be 50000000
    Let clock_mhz be sys_clock divided by 1000000
    Let reload_value be period_us multiplied by clock_mhz

    Let reload_reg be timer_base plus TIMER_RELOAD_OFFSET()
    Let result be mmio_write_32(reload_reg, reload_value)

    Return 0
End Process

Process called "timer_start" takes timer_id as Integer returns Integer:
    Note: Start timer counting
    Note: timer_id: Timer peripheral identifier
    Note: Returns: 0 on success

    Let timer_base be TIMER0_BASE()
    If timer_id is equal to 1:
        Set timer_base to TIMER1_BASE()
    End If

    Let ctrl_reg be timer_base plus TIMER_CTRL_OFFSET()
    Let result be mmio_write_32(ctrl_reg, 1)  Note: Bit 0 = enable

    Return 0
End Process

Process called "timer_stop" takes timer_id as Integer returns Integer:
    Note: Stop timer counting
    Note: timer_id: Timer peripheral identifier
    Note: Returns: 0 on success

    Let timer_base be TIMER0_BASE()
    If timer_id is equal to 1:
        Set timer_base to TIMER1_BASE()
    End If

    Let ctrl_reg be timer_base plus TIMER_CTRL_OFFSET()
    Let result be mmio_write_32(ctrl_reg, 0)  Note: Disable

    Return 0
End Process

Process called "timer_read_count" takes timer_id as Integer returns Integer:
    Note: Read current timer count value
    Note: timer_id: Timer peripheral identifier
    Note: Returns: Current count value

    Let timer_base be TIMER0_BASE()
    If timer_id is equal to 1:
        Set timer_base to TIMER1_BASE()
    End If

    Let count_reg be timer_base plus TIMER_COUNT_OFFSET()
    Let count be mmio_read_32(count_reg)

    Return count
End Process

Process called "timer_reset" takes timer_id as Integer returns Integer:
    Note: Reset timer count to zero
    Note: timer_id: Timer peripheral identifier
    Note: Returns: 0 on success

    Let timer_base be TIMER0_BASE()
    If timer_id is equal to 1:
        Set timer_base to TIMER1_BASE()
    End If

    Let count_reg be timer_base plus TIMER_COUNT_OFFSET()
    Let result be mmio_write_32(count_reg, 0)

    Return 0
End Process

Note: ============================================================================
Note: INTERRUPT CONTROLLER OPERATIONS
Note: ============================================================================

Process called "INTC_ENABLE_OFFSET" returns Integer:
    Return 0  Note: Interrupt enable register
End Process

Process called "INTC_PENDING_OFFSET" returns Integer:
    Return 4  Note: Interrupt pending register
End Process

Process called "INTC_CLEAR_OFFSET" returns Integer:
    Return 8  Note: Interrupt clear register
End Process

Process called "interrupt_enable" takes interrupt_id as Integer returns Integer:
    Note: Enable specific interrupt
    Note: interrupt_id: Interrupt identifier/number (0-31)
    Note: Returns: 0 on success

    Let intc_base be INTC_BASE()
    Let enable_reg be intc_base plus INTC_ENABLE_OFFSET()
    Let int_mask be 1 shifted_left interrupt_id

    Let result be mmio_set_bits(enable_reg, int_mask)
    Return 0
End Process

Process called "interrupt_disable" takes interrupt_id as Integer returns Integer:
    Note: Disable specific interrupt
    Note: interrupt_id: Interrupt identifier/number (0-31)
    Note: Returns: 0 on success

    Let intc_base be INTC_BASE()
    Let enable_reg be intc_base plus INTC_ENABLE_OFFSET()
    Let int_mask be 1 shifted_left interrupt_id

    Let result be mmio_clear_bits(enable_reg, int_mask)
    Return 0
End Process

Process called "interrupt_pending" takes interrupt_id as Integer returns Integer:
    Note: Check if interrupt is pending
    Note: interrupt_id: Interrupt identifier/number (0-31)
    Note: Returns: 1 if pending, 0 otherwise

    Let intc_base be INTC_BASE()
    Let pending_reg be intc_base plus INTC_PENDING_OFFSET()
    Let int_mask be 1 shifted_left interrupt_id

    Let pending be mmio_read_32(pending_reg)
    Let int_status be pending bitwise_and int_mask

    If int_status is not equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "interrupt_clear" takes interrupt_id as Integer returns Integer:
    Note: Clear pending interrupt
    Note: interrupt_id: Interrupt identifier/number (0-31)
    Note: Returns: 0 on success

    Let intc_base be INTC_BASE()
    Let clear_reg be intc_base plus INTC_CLEAR_OFFSET()
    Let int_mask be 1 shifted_left interrupt_id

    Let result be mmio_write_32(clear_reg, int_mask)
    Return 0
End Process

Note: ============================================================================
Note: DELAY FUNCTIONS
Note: ============================================================================

Process called "delay_cycles" takes cycle_count as Integer returns Integer:
    Note: Delay for specified number of clock cycles
    Note: cycle_count: Number of cycles to delay
    Note: Returns: 0 when delay complete

    Note: Busy-wait loop
    Let i be 0
    While i is less than cycle_count:
        Set i to i plus 1
    End While

    Return 0
End Process

Process called "delay_microseconds" takes microseconds as Integer, clock_freq_mhz as Integer returns Integer:
    Note: Delay for specified microseconds
    Note: microseconds: Delay duration in microseconds
    Note: clock_freq_mhz: System clock frequency in MHz
    Note: Returns: 0 when delay complete

    Let cycle_count be microseconds multiplied by clock_freq_mhz
    Return delay_cycles(cycle_count)
End Process
