Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
FPGA Module Interface and Calling Convention

This file implements module interface conventions for FPGA platforms.

Unlike traditional calling conventions (stack/registers), FPGA "calls"
are hardware module instantiations with port connections.

FPGA interface model:
1. Modules have input/output ports
2. Data flows through wires/registers between modules
3. Clocking is explicit (clock/reset ports)
4. Handshaking protocols for data transfer (valid/ready)
5. No implicit stack or call frames

Port types:
- Input: Data flows into module
- Output: Data flows out of module
- Inout: Bidirectional data (tri-state)

Handshaking protocols:
- Valid-ready: Sender asserts valid, receiver asserts ready
- Request-acknowledge: Requestor asserts request, provider asserts ack
- FIFO interface: write_enable, read_enable, full, empty flags
:End Note

Note: ============================================================================
Note: PORT DIRECTION IDENTIFIERS
Note: ============================================================================

Process called "PORT_INPUT" returns Integer:
    Note: Input port (data flows into module)
    Return 0
End Process

Process called "PORT_OUTPUT" returns Integer:
    Note: Output port (data flows out of module)
    Return 1
End Process

Process called "PORT_INOUT" returns Integer:
    Note: Inout port (bidirectional, tri-state)
    Return 2
End Process

Note: ============================================================================
Note: SIGNAL TYPE IDENTIFIERS
Note: ============================================================================

Process called "SIGNAL_CLOCK" returns Integer:
    Note: Clock signal
    Return 0
End Process

Process called "SIGNAL_RESET" returns Integer:
    Note: Reset signal (active high or low)
    Return 1
End Process

Process called "SIGNAL_ENABLE" returns Integer:
    Note: Enable signal
    Return 2
End Process

Process called "SIGNAL_DATA" returns Integer:
    Note: Data signal
    Return 3
End Process

Process called "SIGNAL_VALID" returns Integer:
    Note: Valid signal (data is valid)
    Return 4
End Process

Process called "SIGNAL_READY" returns Integer:
    Note: Ready signal (ready to accept data)
    Return 5
End Process

Note: ============================================================================
Note: PARAMETER PASSING (PORT MAPPING)
Note: ============================================================================

Process called "get_parameter_port_name" takes param_index as Integer returns String:
    Note: Get port name for parameter
    Note: param_index: Parameter index (0, 1, 2, ...)
    Note: Returns: Port name string

    If param_index is equal to 0:
        Return "data_in_0"
    End If

    If param_index is equal to 1:
        Return "data_in_1"
    End If

    If param_index is equal to 2:
        Return "data_in_2"
    End If

    If param_index is equal to 3:
        Return "data_in_3"
    End If

    Return "data_in"
End Process

Process called "get_return_port_name" returns String:
    Note: Get port name for return value
    Note: Returns: Port name string

    Return "data_out"
End Process

Process called "calculate_port_offset" takes port_index as Integer, port_width as Integer returns Integer:
    Note: Calculate byte offset for port in memory map
    Note: port_index: Port index number
    Note: port_width: Width in bits
    Note: Returns: Byte offset

    Note: Ports aligned to 4-byte boundaries
    Let bytes_per_port be port_width divided by 8
    If bytes_per_port is less than 4:
        Set bytes_per_port to 4  Note: Minimum 4-byte alignment
    End If

    Let offset be port_index multiplied by bytes_per_port
    Return offset
End Process

Note: ============================================================================
Note: HANDSHAKING PROTOCOL
Note: ============================================================================

Process called "requires_handshake" takes data_width as Integer returns Integer:
    Note: Determine if port requires handshaking protocol
    Note: data_width: Data width in bits
    Note: Returns: 1 if handshake needed, 0 otherwise

    Note: Wide data transfers (>32 bits) typically use handshaking
    If data_width is greater than 32:
        Return 1
    End If

    Return 0
End Process

Process called "get_handshake_signal_count" takes protocol_type as Integer returns Integer:
    Note: Get number of handshake signals for protocol
    Note: protocol_type: 0=none, 1=valid/ready, 2=req/ack, 3=FIFO
    Note: Returns: Number of handshake signals

    If protocol_type is equal to 0:
        Return 0  Note: No handshake
    End If

    If protocol_type is equal to 1:
        Return 2  Note: Valid + ready
    End If

    If protocol_type is equal to 2:
        Return 2  Note: Request + acknowledge
    End If

    If protocol_type is equal to 3:
        Return 4  Note: write_en, read_en, full, empty
    End If

    Return 2  Note: Default: 2 signals
End Process

Note: ============================================================================
Note: CLOCK DOMAIN CROSSING
Note: ============================================================================

Process called "needs_clock_domain_crossing" takes src_clock_domain as Integer, dest_clock_domain as Integer returns Integer:
    Note: Check if clock domain crossing logic is needed
    Note: src_clock_domain: Source clock domain ID
    Note: dest_clock_domain: Destination clock domain ID
    Note: Returns: 1 if CDC needed, 0 otherwise

    If src_clock_domain is not equal to dest_clock_domain:
        Return 1  Note: Different clock domains
    End If

    Return 0
End Process

Process called "get_cdc_synchronizer_stages" returns Integer:
    Note: Get number of synchronizer flip-flop stages for CDC
    Note: Returns: Number of FF stages (typically 2-3)

    Return 2  Note: 2-FF synchronizer is standard
End Process

Process called "calculate_cdc_metastability_mtbf" takes clock_freq_mhz as Integer, ff_stages as Integer returns Integer:
    Note: Calculate mean time between failures for CDC
    Note: clock_freq_mhz: Clock frequency in MHz
    Note: ff_stages: Number of synchronizer stages
    Note: Returns: MTBF in years (simplified calculation)

    Note: MTBF increases exponentially with FF stages
    Note: Simplified: MTBF â‰ˆ 10^(3*stages) / freq_MHz years

    If ff_stages is equal to 2:
        Let mtbf be 1000000 divided by clock_freq_mhz
        Return mtbf  Note: ~1M years @ 1MHz, ~1K years @ 1GHz
    End If

    If ff_stages is equal to 3:
        Let mtbf be 1000000000 divided by clock_freq_mhz
        Return mtbf  Note: ~1B years @ 1MHz
    End If

    Return 100  Note: Conservative estimate
End Process

Note: ============================================================================
Note: PIPELINE INTERFACE
Note: ============================================================================

Process called "calculate_pipeline_latency" takes stage_count as Integer, clock_period_ns as Integer returns Integer:
    Note: Calculate total pipeline latency
    Note: stage_count: Number of pipeline stages
    Note: clock_period_ns: Clock period in nanoseconds
    Note: Returns: Total latency in nanoseconds

    Let latency_ns be stage_count multiplied by clock_period_ns
    Return latency_ns
End Process

Process called "calculate_pipeline_throughput" takes clock_freq_mhz as Integer, data_width as Integer returns Integer:
    Note: Calculate pipeline throughput
    Note: clock_freq_mhz: Clock frequency in MHz
    Note: data_width: Data width in bits
    Note: Returns: Throughput in Mbps

    Let throughput_mbps be clock_freq_mhz multiplied by data_width
    Return throughput_mbps
End Process

Process called "needs_pipeline_register" takes combinational_delay_ps as Integer, clock_period_ps as Integer returns Integer:
    Note: Determine if pipeline register needed for timing
    Note: combinational_delay_ps: Combinational path delay in picoseconds
    Note: clock_period_ps: Clock period in picoseconds
    Note: Returns: 1 if pipeline register needed, 0 otherwise

    Note: Add 20% timing margin
    Let margin_ps be clock_period_ps divided by 5
    Let target_delay be clock_period_ps minus margin_ps

    If combinational_delay_ps is greater than target_delay:
        Return 1  Note: Timing violation, needs pipelining
    End If

    Return 0
End Process

Note: ============================================================================
Note: MEMORY INTERFACE
Note: ============================================================================

Process called "calculate_memory_address_bits" takes memory_depth as Integer returns Integer:
    Note: Calculate address bus width for memory depth
    Note: memory_depth: Number of memory locations
    Note: Returns: Address width in bits

    Note: Address width = ceil(log2(depth))
    Let addr_bits be 0
    Let size be memory_depth

    While size is greater than 0:
        Set size to size shifted_right 1
        Set addr_bits to addr_bits plus 1
    End While

    Return addr_bits
End Process

Process called "calculate_memory_bandwidth" takes clock_freq_mhz as Integer, data_width as Integer, access_per_cycle as Integer returns Integer:
    Note: Calculate memory bandwidth
    Note: clock_freq_mhz: Clock frequency in MHz
    Note: data_width: Data bus width in bits
    Note: access_per_cycle: Number of accesses per cycle (1 for single-port, 2 for dual-port)
    Note: Returns: Bandwidth in Mbps

    Let bandwidth be clock_freq_mhz multiplied by data_width
    Set bandwidth to bandwidth multiplied by access_per_cycle
    Return bandwidth
End Process

Note: ============================================================================
Note: BUS PROTOCOL
Note: ============================================================================

Process called "BUS_PROTOCOL_SIMPLE" returns Integer:
    Note: Simple bus (no protocol)
    Return 0
End Process

Process called "BUS_PROTOCOL_AXI4" returns Integer:
    Note: AMBA AXI4 protocol
    Return 1
End Process

Process called "BUS_PROTOCOL_AXI4_LITE" returns Integer:
    Note: AMBA AXI4-Lite protocol (simplified)
    Return 2
End Process

Process called "BUS_PROTOCOL_WISHBONE" returns Integer:
    Note: Wishbone bus protocol
    Return 3
End Process

Process called "BUS_PROTOCOL_AVALON" returns Integer:
    Note: Intel/Altera Avalon protocol
    Return 4
End Process

Process called "get_bus_signal_count" takes protocol as Integer returns Integer:
    Note: Get number of signals for bus protocol
    Note: protocol: Bus protocol identifier
    Note: Returns: Number of signals

    Let axi4 be BUS_PROTOCOL_AXI4()
    Let axi4_lite be BUS_PROTOCOL_AXI4_LITE()
    Let wishbone be BUS_PROTOCOL_WISHBONE()
    Let avalon be BUS_PROTOCOL_AVALON()

    If protocol is equal to axi4:
        Return 20  Note: AXI4 has ~20 signals (read/write channels)
    End If

    If protocol is equal to axi4_lite:
        Return 12  Note: AXI4-Lite has ~12 signals
    End If

    If protocol is equal to wishbone:
        Return 8  Note: Wishbone basic has ~8 signals
    End If

    If protocol is equal to avalon:
        Return 10  Note: Avalon MM has ~10 signals
    End If

    Return 4  Note: Simple bus: addr, data, wr, rd
End Process

Note: ============================================================================
Note: RESET STRATEGY
Note: ============================================================================

Process called "RESET_ACTIVE_HIGH" returns Integer:
    Note: Reset active when signal is high (1)
    Return 0
End Process

Process called "RESET_ACTIVE_LOW" returns Integer:
    Note: Reset active when signal is low (0)
    Return 1
End Process

Process called "RESET_SYNC" returns Integer:
    Note: Synchronous reset (triggered by clock edge)
    Return 0
End Process

Process called "RESET_ASYNC" returns Integer:
    Note: Asynchronous reset (immediate, no clock)
    Return 1
End Process

Process called "get_reset_assertion_cycles" takes clock_freq_mhz as Integer returns Integer:
    Note: Get minimum reset assertion duration in cycles
    Note: clock_freq_mhz: Clock frequency in MHz
    Note: Returns: Number of clock cycles

    Note: Typical reset: 100ns minimum
    Let reset_ns be 100
    Let period_ns be 1000 divided by clock_freq_mhz
    Let cycles be reset_ns divided by period_ns

    If cycles is less than 4:
        Set cycles to 4  Note: Minimum 4 cycles
    End If

    Return cycles
End Process

Note: ============================================================================
Note: INTERFACE TIMING CALCULATIONS
Note: ============================================================================

Process called "calculate_setup_time_ps" takes clock_period_ps as Integer returns Integer:
    Note: Calculate required setup time
    Note: clock_period_ps: Clock period in picoseconds
    Note: Returns: Setup time in picoseconds

    Note: Typical setup time: 10-20% of clock period
    Let setup_ps be clock_period_ps divided by 10
    Return setup_ps
End Process

Process called "calculate_hold_time_ps" returns Integer:
    Note: Get typical hold time requirement
    Note: Returns: Hold time in picoseconds

    Return 500  Note: Typical 500ps hold time
End Process

Process called "calculate_clock_to_output_ps" takes ff_delay_ps as Integer, routing_delay_ps as Integer returns Integer:
    Note: Calculate clock-to-output delay
    Note: ff_delay_ps: Flip-flop clock-to-Q delay
    Note: routing_delay_ps: Routing delay
    Note: Returns: Total clock-to-output in picoseconds

    Let total_delay be ff_delay_ps plus routing_delay_ps
    Return total_delay
End Process
