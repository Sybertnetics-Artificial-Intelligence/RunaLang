Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
FPGA Register and Resource Management

This file implements register/resource primitives for FPGA platforms.

Unlike traditional CPUs with fixed register files, FPGAs have:
- Configurable logic blocks (CLBs)
- Block RAM (BRAM)
- DSP slices
- I/O blocks
- LUTs (lookup tables)
- Flip-flops

This file models FPGA resources as "registers" for the compiler to track
resource usage during HDL generation.

Based on Xilinx 7-series FPGA architecture (can be adapted to other vendors).
:End Note

Note: ============================================================================
Note: RESOURCE TYPE IDENTIFIERS
Note: ============================================================================

Process called "RESOURCE_TYPE_LUT" returns Integer:
    Note: Lookup table (combinational logic)
    Return 0
End Process

Process called "RESOURCE_TYPE_FF" returns Integer:
    Note: Flip-flop (sequential storage element)
    Return 1
End Process

Process called "RESOURCE_TYPE_BRAM" returns Integer:
    Note: Block RAM (memory storage)
    Return 2
End Process

Process called "RESOURCE_TYPE_DSP" returns Integer:
    Note: DSP slice (multiply-accumulate hardware)
    Return 3
End Process

Process called "RESOURCE_TYPE_IO" returns Integer:
    Note: I/O block (external pin interface)
    Return 4
End Process

Process called "RESOURCE_TYPE_WIRE" returns Integer:
    Note: Wire connection (routing resource)
    Return 5
End Process

Note: ============================================================================
Note: REGISTER WIDTH CONSTANTS
Note: ============================================================================

Process called "REGISTER_WIDTH_1" returns Integer:
    Note: 1-bit signal
    Return 1
End Process

Process called "REGISTER_WIDTH_8" returns Integer:
    Note: 8-bit signal (byte)
    Return 8
End Process

Process called "REGISTER_WIDTH_16" returns Integer:
    Note: 16-bit signal (half-word)
    Return 16
End Process

Process called "REGISTER_WIDTH_32" returns Integer:
    Note: 32-bit signal (word)
    Return 32
End Process

Process called "REGISTER_WIDTH_64" returns Integer:
    Note: 64-bit signal (double-word)
    Return 64
End Process

Note: ============================================================================
Note: VIRTUAL REGISTER ALLOCATION
Note: ============================================================================

Process called "allocate_register" takes width as Integer, resource_type as Integer returns Integer:
    Note: Allocate virtual register with specified width and type
    Note: width: Bit width (1, 8, 16, 32, 64, etc.)
    Note: resource_type: Type of FPGA resource to use
    Note: Returns: Virtual register ID

    Note: Simple incrementing allocator (compiler should track actual usage)
    Note: Register IDs start at 1000 to distinguish from constants
    Let register_id be 1000

    Note: Encode width and type in upper bits for tracking
    Let width_bits be width shifted_left 16
    Let type_bits be resource_type shifted_left 24
    Set register_id to register_id bitwise_or width_bits
    Set register_id to register_id bitwise_or type_bits

    Return register_id
End Process

Process called "get_register_width" takes register_id as Integer returns Integer:
    Note: Extract register width from register ID
    Note: register_id: Virtual register identifier
    Note: Returns: Bit width

    Let width_mask be 16711680  Note: 0x00FF0000
    Let width_bits be register_id bitwise_and width_mask
    Let width be width_bits shifted_right 16

    Return width
End Process

Process called "get_register_type" takes register_id as Integer returns Integer:
    Note: Extract resource type from register ID
    Note: register_id: Virtual register identifier
    Note: Returns: Resource type identifier

    Let type_mask be -16777216  Note: 0xFF000000 (signed)
    Let type_bits be register_id bitwise_and type_mask
    Let resource_type be type_bits shifted_right 24

    Return resource_type
End Process

Process called "is_flip_flop" takes register_id as Integer returns Integer:
    Note: Check if register is implemented as flip-flop
    Note: register_id: Virtual register identifier
    Note: Returns: 1 if flip-flop, 0 otherwise

    Let resource_type be get_register_type(register_id)
    Let ff_type be RESOURCE_TYPE_FF()

    If resource_type is equal to ff_type:
        Return 1
    End If

    Return 0
End Process

Process called "is_bram" takes register_id as Integer returns Integer:
    Note: Check if register is implemented in block RAM
    Note: register_id: Virtual register identifier
    Note: Returns: 1 if BRAM, 0 otherwise

    Let resource_type be get_register_type(register_id)
    Let bram_type be RESOURCE_TYPE_BRAM()

    If resource_type is equal to bram_type:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: PARAMETER REGISTER ALLOCATION
Note: ============================================================================

Process called "parameter_register" takes index as Integer returns Integer:
    Note: Get virtual register for function parameter
    Note: index: Parameter index (0, 1, 2, ...)
    Note: Returns: Virtual register ID

    Note: Parameters are passed as wires/registers
    Note: Base ID 2000 + index
    Let reg_id be 2000 plus index

    Note: Parameters are typically wires
    Let wire_type be RESOURCE_TYPE_WIRE()
    Let type_bits be wire_type shifted_left 24
    Set reg_id to reg_id bitwise_or type_bits

    Note: Default 32-bit width
    Let width be 32
    Let width_bits be width shifted_left 16
    Set reg_id to reg_id bitwise_or width_bits

    Return reg_id
End Process

Process called "return_register" returns Integer:
    Note: Get virtual register for return value
    Note: Returns: Virtual register ID

    Note: Return value register
    Let reg_id be 3000

    Note: Return as wire
    Let wire_type be RESOURCE_TYPE_WIRE()
    Let type_bits be wire_type shifted_left 24
    Set reg_id to reg_id bitwise_or type_bits

    Note: Default 32-bit width
    Let width be 32
    Let width_bits be width shifted_left 16
    Set reg_id to reg_id bitwise_or width_bits

    Return reg_id
End Process

Note: ============================================================================
Note: SPECIAL REGISTERS
Note: ============================================================================

Process called "clock_signal" returns Integer:
    Note: Clock signal register
    Note: Returns: Clock register ID

    Let reg_id be 4000

    Note: Clock is I/O type
    Let io_type be RESOURCE_TYPE_IO()
    Let type_bits be io_type shifted_left 24
    Set reg_id to reg_id bitwise_or type_bits

    Note: 1-bit signal
    Let width be 1
    Let width_bits be width shifted_left 16
    Set reg_id to reg_id bitwise_or width_bits

    Return reg_id
End Process

Process called "reset_signal" returns Integer:
    Note: Reset signal register
    Note: Returns: Reset register ID

    Let reg_id be 4001

    Note: Reset is I/O type
    Let io_type be RESOURCE_TYPE_IO()
    Let type_bits be io_type shifted_left 24
    Set reg_id to reg_id bitwise_or type_bits

    Note: 1-bit signal
    Let width be 1
    Let width_bits be width shifted_left 16
    Set reg_id to reg_id bitwise_or width_bits

    Return reg_id
End Process

Process called "enable_signal" returns Integer:
    Note: Enable signal register
    Note: Returns: Enable register ID

    Let reg_id be 4002

    Note: Enable is wire type
    Let wire_type be RESOURCE_TYPE_WIRE()
    Let type_bits be wire_type shifted_left 24
    Set reg_id to reg_id bitwise_or type_bits

    Note: 1-bit signal
    Let width be 1
    Let width_bits be width shifted_left 16
    Set reg_id to reg_id bitwise_or width_bits

    Return reg_id
End Process

Note: ============================================================================
Note: RESOURCE ESTIMATION
Note: ============================================================================

Process called "estimate_lut_count" takes operation as Integer, width as Integer returns Integer:
    Note: Estimate LUT usage for operation
    Note: operation: Operation type (0=logic, 1=arithmetic, 2=comparison)
    Note: width: Operand width in bits
    Note: Returns: Estimated LUT count

    Let lut_count be 0

    If operation is equal to 0:
        Note: Logic operations (AND, OR, XOR): ~1 LUT per bit
        Set lut_count to width
    End If

    If operation is equal to 1:
        Note: Arithmetic (ADD, SUB): ~1 LUT per bit for carry chain
        Set lut_count to width
    End If

    If operation is equal to 2:
        Note: Comparison: ~2 LUTs per bit
        Set lut_count to width multiplied by 2
    End If

    Return lut_count
End Process

Process called "estimate_ff_count" takes width as Integer returns Integer:
    Note: Estimate flip-flop usage for register
    Note: width: Register width in bits
    Note: Returns: Flip-flop count (1:1 with bits)

    Return width
End Process

Process called "estimate_bram_count" takes depth as Integer, width as Integer returns Integer:
    Note: Estimate BRAM usage for memory
    Note: depth: Memory depth (number of entries)
    Note: width: Memory width (bits per entry)
    Note: Returns: Number of 18Kb BRAM blocks needed

    Note: Xilinx 7-series BRAM: 18Kb (2048 bytes) or 36Kb (4096 bytes)
    Let bits_needed be depth multiplied by width
    Let bram_18k_bits be 18432  Note: 18 * 1024 bits

    Note: Calculate number of 18Kb blocks (round up)
    Let bram_count be bits_needed divided by bram_18k_bits

    Note: Round up if remainder
    Let remainder be bits_needed modulo bram_18k_bits
    If remainder is greater than 0:
        Set bram_count to bram_count plus 1
    End If

    Return bram_count
End Process

Process called "estimate_dsp_count" takes operation as Integer returns Integer:
    Note: Estimate DSP slice usage
    Note: operation: 0=multiply, 1=multiply-add, 2=multiply-accumulate
    Note: Returns: Number of DSP slices

    Note: Each DSP48E1 can do one operation
    If operation is equal to 0:
        Return 1  Note: Simple multiply
    End If

    If operation is equal to 1:
        Return 1  Note: Multiply-add in single DSP
    End If

    If operation is equal to 2:
        Return 1  Note: Multiply-accumulate in single DSP
    End If

    Return 1
End Process

Note: ============================================================================
Note: REGISTER NAMING
Note: ============================================================================

Process called "register_name" takes register_id as Integer returns String:
    Note: Generate Verilog identifier for register
    Note: register_id: Virtual register identifier
    Note: Returns: Register name string

    Let resource_type be get_register_type(register_id)
    Let lut_type be RESOURCE_TYPE_LUT()
    Let ff_type be RESOURCE_TYPE_FF()
    Let bram_type be RESOURCE_TYPE_BRAM()
    Let dsp_type be RESOURCE_TYPE_DSP()
    Let io_type be RESOURCE_TYPE_IO()
    Let wire_type be RESOURCE_TYPE_WIRE()

    If resource_type is equal to lut_type:
        Return "lut_"
    End If

    If resource_type is equal to ff_type:
        Return "reg_"
    End If

    If resource_type is equal to bram_type:
        Return "mem_"
    End If

    If resource_type is equal to dsp_type:
        Return "dsp_"
    End If

    If resource_type is equal to io_type:
        Return "io_"
    End If

    If resource_type is equal to wire_type:
        Return "wire_"
    End If

    Return "unknown_"
End Process

Note: ============================================================================
Note: CLOCK DOMAIN TRACKING
Note: ============================================================================

Process called "assign_clock_domain" takes register_id as Integer, clock_domain as Integer returns Integer:
    Note: Assign register to clock domain (for multi-clock designs)
    Note: register_id: Virtual register identifier
    Note: clock_domain: Clock domain ID (0, 1, 2, ...)
    Note: Returns: Updated register ID with clock domain

    Note: Clock domain encoded in bits 8-15
    Let domain_bits be clock_domain shifted_left 8
    Let domain_mask be 65280  Note: 0x0000FF00
    Let inv_mask be 0 minus domain_mask
    Set inv_mask to inv_mask minus 1
    Set inv_mask to inv_mask bitwise_xor domain_mask

    Let cleared_id be register_id bitwise_and inv_mask
    Let new_id be cleared_id bitwise_or domain_bits

    Return new_id
End Process

Process called "get_clock_domain" takes register_id as Integer returns Integer:
    Note: Get clock domain for register
    Note: register_id: Virtual register identifier
    Note: Returns: Clock domain ID

    Let domain_mask be 65280  Note: 0x0000FF00
    Let domain_bits be register_id bitwise_and domain_mask
    Let domain be domain_bits shifted_right 8

    Return domain
End Process

Note: ============================================================================
Note: PIPELINE STAGE MANAGEMENT
Note: ============================================================================

Process called "get_pipeline_depth" takes operation as Integer returns Integer:
    Note: Get pipeline depth for operation
    Note: operation: 0=combinational, 1=single-stage, 2=multiply, 3=divide
    Note: Returns: Number of pipeline stages

    If operation is equal to 0:
        Return 0  Note: Combinational logic (no pipeline)
    End If

    If operation is equal to 1:
        Return 1  Note: Single register stage
    End If

    If operation is equal to 2:
        Return 3  Note: Multiply typically 3-stage pipeline
    End If

    If operation is equal to 3:
        Return 8  Note: Divide typically 8+ stage pipeline
    End If

    Return 1
End Process

Process called "calculate_timing_slack" takes path_delay_ps as Integer, clock_period_ps as Integer returns Integer:
    Note: Calculate timing slack for path
    Note: path_delay_ps: Path delay in picoseconds
    Note: clock_period_ps: Clock period in picoseconds
    Note: Returns: Slack in picoseconds (negative = timing violation)

    Let slack be clock_period_ps minus path_delay_ps
    Return slack
End Process

Process called "needs_pipelining" takes path_delay_ps as Integer, clock_period_ps as Integer returns Integer:
    Note: Check if path needs pipelining to meet timing
    Note: path_delay_ps: Path delay in picoseconds
    Note: clock_period_ps: Clock period in picoseconds
    Note: Returns: 1 if pipelining needed, 0 otherwise

    Let slack be calculate_timing_slack(path_delay_ps, clock_period_ps)

    If slack is less than 0:
        Return 1  Note: Negative slack = timing violation
    End If

    Return 0
End Process
