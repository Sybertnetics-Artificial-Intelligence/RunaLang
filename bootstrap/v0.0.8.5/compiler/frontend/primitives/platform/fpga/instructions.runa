Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
FPGA HDL Operation Set

This file implements operation primitives for FPGA platforms.

Unlike traditional instruction sets, FPGA operations map to Verilog/VHDL
constructs that synthesize to hardware logic.

Operation Categories:
1. Data Movement: assign, register transfer
2. Arithmetic: add, sub, mul, div
3. Logical: and, or, xor, not
4. Shift: shl, shr, rotate
5. Comparison: eq, ne, lt, gt, le, ge
6. Control: if, case, always
7. Memory: read, write, burst
8. Synchronization: barrier, fence
:End Note

Note: ============================================================================
Note: OPERATION OPCODE IDENTIFIERS
Note: ============================================================================

Note: Data Movement Operations
Process called "HDL_ASSIGN" returns Integer:
    Note: Continuous assignment (assign statement)
    Return 0
End Process

Process called "HDL_REG_TRANSFER" returns Integer:
    Note: Register transfer (blocking or non-blocking)
    Return 1
End Process

Process called "HDL_MOVE" returns Integer:
    Note: Move data (wire or register)
    Return 2
End Process

Note: Arithmetic Operations
Process called "HDL_ADD" returns Integer:
    Note: Addition (synthesizes to adder)
    Return 10
End Process

Process called "HDL_SUB" returns Integer:
    Note: Subtraction (synthesizes to subtractor)
    Return 11
End Process

Process called "HDL_MUL" returns Integer:
    Note: Multiplication (synthesizes to multiplier, may use DSP)
    Return 12
End Process

Process called "HDL_DIV" returns Integer:
    Note: Division (synthesizes to divider, resource-intensive)
    Return 13
End Process

Process called "HDL_MOD" returns Integer:
    Note: Modulo (remainder)
    Return 14
End Process

Process called "HDL_INC" returns Integer:
    Note: Increment (optimized add)
    Return 15
End Process

Process called "HDL_DEC" returns Integer:
    Note: Decrement (optimized subtract)
    Return 16
End Process

Note: Logical Operations
Process called "HDL_AND" returns Integer:
    Note: Bitwise AND
    Return 20
End Process

Process called "HDL_OR" returns Integer:
    Note: Bitwise OR
    Return 21
End Process

Process called "HDL_XOR" returns Integer:
    Note: Bitwise XOR
    Return 22
End Process

Process called "HDL_NOT" returns Integer:
    Note: Bitwise NOT (inversion)
    Return 23
End Process

Process called "HDL_NAND" returns Integer:
    Note: Bitwise NAND
    Return 24
End Process

Process called "HDL_NOR" returns Integer:
    Note: Bitwise NOR
    Return 25
End Process

Note: Shift and Rotate Operations
Process called "HDL_SHL" returns Integer:
    Note: Shift left logical
    Return 30
End Process

Process called "HDL_SHR" returns Integer:
    Note: Shift right logical
    Return 31
End Process

Process called "HDL_SAR" returns Integer:
    Note: Shift arithmetic right (sign extend)
    Return 32
End Process

Process called "HDL_ROL" returns Integer:
    Note: Rotate left
    Return 33
End Process

Process called "HDL_ROR" returns Integer:
    Note: Rotate right
    Return 34
End Process

Note: Comparison Operations
Process called "HDL_EQ" returns Integer:
    Note: Equal (==)
    Return 40
End Process

Process called "HDL_NE" returns Integer:
    Note: Not equal (!=)
    Return 41
End Process

Process called "HDL_LT" returns Integer:
    Note: Less than (<)
    Return 42
End Process

Process called "HDL_LE" returns Integer:
    Note: Less than or equal (<=)
    Return 43
End Process

Process called "HDL_GT" returns Integer:
    Note: Greater than (>)
    Return 44
End Process

Process called "HDL_GE" returns Integer:
    Note: Greater than or equal (>=)
    Return 45
End Process

Note: Control Flow Operations
Process called "HDL_IF" returns Integer:
    Note: If statement (if/else)
    Return 50
End Process

Process called "HDL_CASE" returns Integer:
    Note: Case statement (case/endcase)
    Return 51
End Process

Process called "HDL_ALWAYS" returns Integer:
    Note: Always block (@posedge/@negedge)
    Return 52
End Process

Process called "HDL_ALWAYS_COMB" returns Integer:
    Note: Combinational always block (@*)
    Return 53
End Process

Note: Memory Operations
Process called "HDL_MEM_READ" returns Integer:
    Note: Memory read operation
    Return 60
End Process

Process called "HDL_MEM_WRITE" returns Integer:
    Note: Memory write operation
    Return 61
End Process

Process called "HDL_MEM_BURST_READ" returns Integer:
    Note: Burst read (multiple sequential reads)
    Return 62
End Process

Process called "HDL_MEM_BURST_WRITE" returns Integer:
    Note: Burst write (multiple sequential writes)
    Return 63
End Process

Note: Synchronization Operations
Process called "HDL_BARRIER" returns Integer:
    Note: Synchronization barrier (wait for all)
    Return 70
End Process

Process called "HDL_FENCE" returns Integer:
    Note: Memory fence (ensure ordering)
    Return 71
End Process

Note: ============================================================================
Note: TYPE MODIFIERS
Note: ============================================================================

Process called "TYPE_WIRE" returns Integer:
    Note: Wire (combinational signal)
    Return 0
End Process

Process called "TYPE_REG" returns Integer:
    Note: Register (sequential storage)
    Return 1
End Process

Process called "TYPE_LOGIC" returns Integer:
    Note: Logic (Verilog-2001/SystemVerilog)
    Return 2
End Process

Process called "TYPE_SIGNED" returns Integer:
    Note: Signed integer
    Return 10
End Process

Process called "TYPE_UNSIGNED" returns Integer:
    Note: Unsigned integer
    Return 11
End Process

Note: ============================================================================
Note: OPERATION PROPERTIES
Note: ============================================================================

Process called "get_operation_latency_ns" takes operation as Integer, width as Integer returns Integer:
    Note: Get operation latency in nanoseconds (at 100MHz)
    Note: operation: Operation opcode identifier
    Note: width: Operand width in bits
    Note: Returns: Latency in nanoseconds

    Note: Clock period = 10ns @ 100MHz
    Let clock_period_ns be 10

    Let add_op be HDL_ADD()
    Let sub_op be HDL_SUB()
    Let mul_op be HDL_MUL()
    Let div_op be HDL_DIV()

    If operation is equal to add_op:
        Return clock_period_ns  Note: 1 cycle for add
    End If

    If operation is equal to sub_op:
        Return clock_period_ns  Note: 1 cycle for sub
    End If

    If operation is equal to mul_op:
        Note: Multiply: 3-5 cycles depending on width
        If width is less than or equal to 16:
            Return clock_period_ns multiplied by 3
        End If
        If width is less than or equal to 32:
            Return clock_period_ns multiplied by 4
        End If
        Return clock_period_ns multiplied by 5
    End If

    If operation is equal to div_op:
        Note: Division: typically width cycles
        Return clock_period_ns multiplied by width
    End If

    Return clock_period_ns  Note: Default 1 cycle
End Process

Process called "get_operation_lut_cost" takes operation as Integer, width as Integer returns Integer:
    Note: Get LUT cost for operation
    Note: operation: Operation opcode identifier
    Note: width: Operand width in bits
    Note: Returns: Estimated LUT count

    Let add_op be HDL_ADD()
    Let sub_op be HDL_SUB()
    Let mul_op be HDL_MUL()
    Let div_op be HDL_DIV()
    Let and_op be HDL_AND()
    Let or_op be HDL_OR()
    Let xor_op be HDL_XOR()

    If operation is equal to add_op:
        Return width  Note: ~1 LUT per bit for adder
    End If

    If operation is equal to sub_op:
        Return width  Note: ~1 LUT per bit for subtractor
    End If

    If operation is equal to mul_op:
        Note: Multiplier: width^2 / 4 LUTs (if not using DSP)
        Let lut_count be width multiplied by width
        Set lut_count to lut_count divided by 4
        Return lut_count
    End If

    If operation is equal to div_op:
        Note: Divider: expensive, ~3*width LUTs
        Let lut_count be width multiplied by 3
        Return lut_count
    End If

    If operation is equal to and_op:
        Return width  Note: 1 LUT per bit
    End If

    If operation is equal to or_op:
        Return width  Note: 1 LUT per bit
    End If

    If operation is equal to xor_op:
        Return width  Note: 1 LUT per bit
    End If

    Return width  Note: Default estimate
End Process

Process called "can_use_dsp_slice" takes operation as Integer returns Integer:
    Note: Check if operation can use DSP slice
    Note: operation: Operation opcode identifier
    Note: Returns: 1 if DSP can be used, 0 otherwise

    Let mul_op be HDL_MUL()
    Let add_op be HDL_ADD()

    If operation is equal to mul_op:
        Return 1  Note: DSP slices have multipliers
    End If

    If operation is equal to add_op:
        Return 1  Note: DSP slices have post-add
    End If

    Return 0
End Process

Process called "get_dsp_slice_count" takes operation as Integer, width as Integer returns Integer:
    Note: Get DSP slice count needed for operation
    Note: operation: Operation opcode identifier
    Note: width: Operand width in bits
    Note: Returns: Number of DSP slices needed

    Let can_use_dsp be can_use_dsp_slice(operation)
    If can_use_dsp is equal to 0:
        Return 0  Note: Cannot use DSP
    End If

    Note: DSP48E1 supports up to 25x18 multiplication
    Let mul_op be HDL_MUL()

    If operation is equal to mul_op:
        Note: Calculate slices needed based on width
        If width is less than or equal to 18:
            Return 1  Note: Single DSP slice
        End If
        If width is less than or equal to 36:
            Return 4  Note: 4 DSPs for 36x36
        End If
        If width is less than or equal to 64:
            Return 16  Note: 16 DSPs for 64x64
        End If
    End If

    Return 1
End Process

Note: ============================================================================
Note: OPERATION CATEGORIES
Note: ============================================================================

Process called "is_arithmetic_operation" takes operation as Integer returns Integer:
    Note: Check if operation is arithmetic
    Note: operation: Operation opcode identifier
    Note: Returns: 1 if arithmetic, 0 otherwise

    If operation is greater than or equal to 10:
        If operation is less than or equal to 19:
            Return 1  Note: Arithmetic ops are 10-19
        End If
    End If

    Return 0
End Process

Process called "is_logical_operation" takes operation as Integer returns Integer:
    Note: Check if operation is logical
    Note: operation: Operation opcode identifier
    Note: Returns: 1 if logical, 0 otherwise

    If operation is greater than or equal to 20:
        If operation is less than or equal to 29:
            Return 1  Note: Logical ops are 20-29
        End If
    End If

    Return 0
End Process

Process called "is_comparison_operation" takes operation as Integer returns Integer:
    Note: Check if operation is comparison
    Note: operation: Operation opcode identifier
    Note: Returns: 1 if comparison, 0 otherwise

    If operation is greater than or equal to 40:
        If operation is less than or equal to 49:
            Return 1  Note: Comparison ops are 40-49
        End If
    End If

    Return 0
End Process

Process called "is_memory_operation" takes operation as Integer returns Integer:
    Note: Check if operation is memory access
    Note: operation: Operation opcode identifier
    Note: Returns: 1 if memory operation, 0 otherwise

    If operation is greater than or equal to 60:
        If operation is less than or equal to 69:
            Return 1  Note: Memory ops are 60-69
        End If
    End If

    Return 0
End Process

Note: ============================================================================
Note: SYNTHESIS OPTIMIZATION HINTS
Note: ============================================================================

Process called "should_pipeline_operation" takes operation as Integer, width as Integer, target_frequency_mhz as Integer returns Integer:
    Note: Determine if operation should be pipelined for target frequency
    Note: operation: Operation opcode identifier
    Note: width: Operand width in bits
    Note: target_frequency_mhz: Target clock frequency in MHz
    Note: Returns: 1 if should pipeline, 0 otherwise

    Let latency_ns be get_operation_latency_ns(operation, width)
    Let period_ns be 1000 divided by target_frequency_mhz

    If latency_ns is greater than period_ns:
        Return 1  Note: Needs pipelining to meet timing
    End If

    Return 0
End Process

Process called "get_recommended_pipeline_stages" takes operation as Integer, width as Integer, target_frequency_mhz as Integer returns Integer:
    Note: Get recommended pipeline stage count
    Note: operation: Operation opcode identifier
    Note: width: Operand width in bits
    Note: target_frequency_mhz: Target clock frequency in MHz
    Note: Returns: Number of pipeline stages

    Let latency_ns be get_operation_latency_ns(operation, width)
    Let period_ns be 1000 divided by target_frequency_mhz

    Let stages be latency_ns divided by period_ns
    If stages is equal to 0:
        Set stages to 1
    End If

    Return stages
End Process

Process called "should_use_block_ram" takes array_size as Integer, element_width as Integer returns Integer:
    Note: Determine if array should use block RAM vs distributed RAM
    Note: array_size: Number of array elements
    Note: element_width: Bits per element
    Note: Returns: 1 if should use BRAM, 0 if distributed RAM

    Note: BRAM threshold: ~2KB (16,384 bits)
    Let total_bits be array_size multiplied by element_width
    Let bram_threshold be 16384

    If total_bits is greater than bram_threshold:
        Return 1  Note: Use BRAM for large arrays
    End If

    Return 0  Note: Use distributed RAM for small arrays
End Process

Process called "get_operation_name" takes operation as Integer returns String:
    Note: Get operation name for HDL generation
    Note: operation: Operation opcode identifier
    Note: Returns: Operation name string

    Let add_op be HDL_ADD()
    Let sub_op be HDL_SUB()
    Let mul_op be HDL_MUL()
    Let div_op be HDL_DIV()
    Let and_op be HDL_AND()
    Let or_op be HDL_OR()
    Let xor_op be HDL_XOR()
    Let not_op be HDL_NOT()

    If operation is equal to add_op:
        Return "+"
    End If

    If operation is equal to sub_op:
        Return "-"
    End If

    If operation is equal to mul_op:
        Return "*"
    End If

    If operation is equal to div_op:
        Return "/"
    End If

    If operation is equal to and_op:
        Return "&"
    End If

    If operation is equal to or_op:
        Return "|"
    End If

    If operation is equal to xor_op:
        Return "^"
    End If

    If operation is equal to not_op:
        Return "~"
    End If

    Return "unknown"
End Process
