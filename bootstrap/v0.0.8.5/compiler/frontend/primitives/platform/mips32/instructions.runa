Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
MIPS32 Instruction Set Metadata and Helpers

This file provides instruction metadata, opcode definitions, and helper functions
for MIPS32 instruction selection, validation, and optimization.

MIPS32 (MIPS-I/II/32) Key Characteristics:
- Fixed 32-bit (4-byte) instruction length
- Big-endian or little-endian (Linux typically little-endian)
- Load/store architecture
- Three-operand instructions
- Delayed branch slots
- No condition codes (compare produces register result)

MIPS32 Instruction Formats:
- R-type: Register operations (opcode + rs + rt + rd + shamt + funct)
- I-type: Immediate operations (opcode + rs + rt + immediate)
- J-type: Jump operations (opcode + address)

Dependencies:
- registers.runa for register metadata
:End Note

Import "compiler/frontend/primitives/platform/mips32/registers.runa" as Registers

Note: ============================================================================
Note: INSTRUCTION OPCODE CONSTANTS
Note: ============================================================================

Note: R-type instructions (opcode = 0, function code determines operation)
Process called "OP_ADD" returns Integer:
    Return 1  Note: Add
End Process

Process called "OP_ADDU" returns Integer:
    Return 2  Note: Add unsigned (no overflow trap)
End Process

Process called "OP_SUB" returns Integer:
    Return 3  Note: Subtract
End Process

Process called "OP_SUBU" returns Integer:
    Return 4  Note: Subtract unsigned
End Process

Process called "OP_AND" returns Integer:
    Return 5  Note: Bitwise AND
End Process

Process called "OP_OR" returns Integer:
    Return 6  Note: Bitwise OR
End Process

Process called "OP_XOR" returns Integer:
    Return 7  Note: Bitwise XOR
End Process

Process called "OP_NOR" returns Integer:
    Return 8  Note: Bitwise NOR
End Process

Process called "OP_SLT" returns Integer:
    Return 9  Note: Set on less than
End Process

Process called "OP_SLTU" returns Integer:
    Return 10  Note: Set on less than unsigned
End Process

Process called "OP_SLL" returns Integer:
    Return 11  Note: Shift left logical
End Process

Process called "OP_SRL" returns Integer:
    Return 12  Note: Shift right logical
End Process

Process called "OP_SRA" returns Integer:
    Return 13  Note: Shift right arithmetic
End Process

Process called "OP_SLLV" returns Integer:
    Return 14  Note: Shift left logical variable
End Process

Process called "OP_SRLV" returns Integer:
    Return 15  Note: Shift right logical variable
End Process

Process called "OP_SRAV" returns Integer:
    Return 16  Note: Shift right arithmetic variable
End Process

Process called "OP_JR" returns Integer:
    Return 17  Note: Jump register
End Process

Process called "OP_JALR" returns Integer:
    Return 18  Note: Jump and link register
End Process

Process called "OP_MULT" returns Integer:
    Return 19  Note: Multiply
End Process

Process called "OP_MULTU" returns Integer:
    Return 20  Note: Multiply unsigned
End Process

Process called "OP_DIV" returns Integer:
    Return 21  Note: Divide
End Process

Process called "OP_DIVU" returns Integer:
    Return 22  Note: Divide unsigned
End Process

Process called "OP_MFHI" returns Integer:
    Return 23  Note: Move from HI
End Process

Process called "OP_MFLO" returns Integer:
    Return 24  Note: Move from LO
End Process

Process called "OP_MTHI" returns Integer:
    Return 25  Note: Move to HI
End Process

Process called "OP_MTLO" returns Integer:
    Return 26  Note: Move to LO
End Process

Process called "OP_SYSCALL" returns Integer:
    Return 27  Note: System call
End Process

Process called "OP_BREAK" returns Integer:
    Return 28  Note: Breakpoint
End Process

Note: I-type instructions
Process called "OP_ADDI" returns Integer:
    Return 29  Note: Add immediate
End Process

Process called "OP_ADDIU" returns Integer:
    Return 30  Note: Add immediate unsigned
End Process

Process called "OP_SLTI" returns Integer:
    Return 31  Note: Set on less than immediate
End Process

Process called "OP_SLTIU" returns Integer:
    Return 32  Note: Set on less than immediate unsigned
End Process

Process called "OP_ANDI" returns Integer:
    Return 33  Note: AND immediate
End Process

Process called "OP_ORI" returns Integer:
    Return 34  Note: OR immediate
End Process

Process called "OP_XORI" returns Integer:
    Return 35  Note: XOR immediate
End Process

Process called "OP_LUI" returns Integer:
    Return 36  Note: Load upper immediate
End Process

Process called "OP_LW" returns Integer:
    Return 37  Note: Load word
End Process

Process called "OP_LH" returns Integer:
    Return 38  Note: Load halfword
End Process

Process called "OP_LHU" returns Integer:
    Return 39  Note: Load halfword unsigned
End Process

Process called "OP_LB" returns Integer:
    Return 40  Note: Load byte
End Process

Process called "OP_LBU" returns Integer:
    Return 41  Note: Load byte unsigned
End Process

Process called "OP_SW" returns Integer:
    Return 42  Note: Store word
End Process

Process called "OP_SH" returns Integer:
    Return 43  Note: Store halfword
End Process

Process called "OP_SB" returns Integer:
    Return 44  Note: Store byte
End Process

Process called "OP_BEQ" returns Integer:
    Return 45  Note: Branch on equal
End Process

Process called "OP_BNE" returns Integer:
    Return 46  Note: Branch on not equal
End Process

Process called "OP_BLEZ" returns Integer:
    Return 47  Note: Branch on less than or equal to zero
End Process

Process called "OP_BGTZ" returns Integer:
    Return 48  Note: Branch on greater than zero
End Process

Note: J-type instructions
Process called "OP_J" returns Integer:
    Return 49  Note: Jump
End Process

Process called "OP_JAL" returns Integer:
    Return 50  Note: Jump and link
End Process

Note: MIPS32 II+ instructions
Process called "OP_MUL" returns Integer:
    Return 51  Note: Multiply (to GPR, MIPS32)
End Process

Note: Floating-point instructions
Process called "OP_LWC1" returns Integer:
    Return 52  Note: Load word to FPU coprocessor
End Process

Process called "OP_SWC1" returns Integer:
    Return 53  Note: Store word from FPU coprocessor
End Process

Process called "OP_ADD_S" returns Integer:
    Return 54  Note: FP add single
End Process

Process called "OP_ADD_D" returns Integer:
    Return 55  Note: FP add double
End Process

Process called "OP_SUB_S" returns Integer:
    Return 56  Note: FP subtract single
End Process

Process called "OP_SUB_D" returns Integer:
    Return 57  Note: FP subtract double
End Process

Process called "OP_MUL_S" returns Integer:
    Return 58  Note: FP multiply single
End Process

Process called "OP_MUL_D" returns Integer:
    Return 59  Note: FP multiply double
End Process

Process called "OP_DIV_S" returns Integer:
    Return 60  Note: FP divide single
End Process

Process called "OP_DIV_D" returns Integer:
    Return 61  Note: FP divide double
End Process

Note: Pseudo-instructions (expanded by assembler)
Process called "OP_MOVE" returns Integer:
    Return 62  Note: Move (pseudo: ADDU rd, rs, $zero)
End Process

Process called "OP_LI" returns Integer:
    Return 63  Note: Load immediate (pseudo: LUI + ORI)
End Process

Process called "OP_LA" returns Integer:
    Return 64  Note: Load address (pseudo)
End Process

Process called "OP_NOP" returns Integer:
    Return 65  Note: No operation (pseudo: SLL $zero, $zero, 0)
End Process

Note: ============================================================================
Note: INSTRUCTION PROPERTIES
Note: ============================================================================

Process called "get_instruction_latency" takes opcode as Integer returns Integer:
    Note: Get typical latency for instruction
    Note: Based on MIPS R4000 timing (representative MIPS32 processor)

    Note: ALU operations
    If opcode is equal to OP_ADD():
        Return 1
    End If
    If opcode is equal to OP_ADDU():
        Return 1
    End If
    If opcode is equal to OP_SUB():
        Return 1
    End If
    If opcode is equal to OP_SUBU():
        Return 1
    End If
    If opcode is equal to OP_AND():
        Return 1
    End If
    If opcode is equal to OP_OR():
        Return 1
    End If
    If opcode is equal to OP_XOR():
        Return 1
    End If
    If opcode is equal to OP_NOR():
        Return 1
    End If

    Note: Multiply/divide
    If opcode is equal to OP_MULT():
        Return 10  Note: 10 cycles for 32x32â†’64 multiply
    End If
    If opcode is equal to OP_MULTU():
        Return 10
    End If
    If opcode is equal to OP_DIV():
        Return 35  Note: 35 cycles for divide
    End If
    If opcode is equal to OP_DIVU():
        Return 35
    End If
    If opcode is equal to OP_MUL():
        Return 5  Note: MIPS32 MUL to GPR
    End If

    Note: Load/store
    If opcode is equal to OP_LW():
        Return 2  Note: Cache hit
    End If
    If opcode is equal to OP_SW():
        Return 1
    End If
    If opcode is equal to OP_LH():
        Return 2
    End If
    If opcode is equal to OP_LB():
        Return 2
    End If

    Note: Branches (predicted correctly)
    If opcode is equal to OP_BEQ():
        Return 1  Note: Plus delay slot
    End If
    If opcode is equal to OP_BNE():
        Return 1
    End If
    If opcode is equal to OP_J():
        Return 1
    End If

    Note: FPU operations
    If opcode is equal to OP_ADD_S():
        Return 3
    End If
    If opcode is equal to OP_ADD_D():
        Return 3
    End If
    If opcode is equal to OP_MUL_S():
        Return 5
    End If
    If opcode is equal to OP_MUL_D():
        Return 8
    End If
    If opcode is equal to OP_DIV_S():
        Return 17
    End If
    If opcode is equal to OP_DIV_D():
        Return 32
    End If

    Return 1  Note: Default
End Process

Process called "get_instruction_size" returns Integer:
    Note: Get instruction size in bytes
    Note: All MIPS instructions are 4 bytes
    Return 4
End Process

Process called "has_delay_slot" takes opcode as Integer returns Integer:
    Note: Check if instruction has delay slot
    Note: MIPS branches and jumps have delay slots

    If opcode is equal to OP_BEQ():
        Return 1
    End If
    If opcode is equal to OP_BNE():
        Return 1
    End If
    If opcode is equal to OP_BLEZ():
        Return 1
    End If
    If opcode is equal to OP_BGTZ():
        Return 1
    End If
    If opcode is equal to OP_J():
        Return 1
    End If
    If opcode is equal to OP_JAL():
        Return 1
    End If
    If opcode is equal to OP_JR():
        Return 1
    End If
    If opcode is equal to OP_JALR():
        Return 1
    End If

    Return 0
End Process

Process called "is_branch_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is a branch

    If opcode is equal to OP_BEQ():
        Return 1
    End If
    If opcode is equal to OP_BNE():
        Return 1
    End If
    If opcode is equal to OP_BLEZ():
        Return 1
    End If
    If opcode is equal to OP_BGTZ():
        Return 1
    End If

    Return 0
End Process

Process called "is_jump_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is a jump

    If opcode is equal to OP_J():
        Return 1
    End If
    If opcode is equal to OP_JAL():
        Return 1
    End If
    If opcode is equal to OP_JR():
        Return 1
    End If
    If opcode is equal to OP_JALR():
        Return 1
    End If

    Return 0
End Process

Process called "is_load_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is a load

    If opcode is equal to OP_LW():
        Return 1
    End If
    If opcode is equal to OP_LH():
        Return 1
    End If
    If opcode is equal to OP_LHU():
        Return 1
    End If
    If opcode is equal to OP_LB():
        Return 1
    End If
    If opcode is equal to OP_LBU():
        Return 1
    End If
    If opcode is equal to OP_LWC1():
        Return 1
    End If

    Return 0
End Process

Process called "is_store_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is a store

    If opcode is equal to OP_SW():
        Return 1
    End If
    If opcode is equal to OP_SH():
        Return 1
    End If
    If opcode is equal to OP_SB():
        Return 1
    End If
    If opcode is equal to OP_SWC1():
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: IMMEDIATE VALUE VALIDATION
Note: ============================================================================

Process called "is_valid_16bit_immediate" takes value as Integer returns Integer:
    Note: Check if value fits in 16-bit signed immediate
    Note: Range: -32768 to 32767

    If value is greater than or equal to -32768:
        If value is less than or equal to 32767:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "is_valid_unsigned_immediate" takes value as Integer returns Integer:
    Note: Check if value fits in 16-bit unsigned immediate
    Note: Range: 0 to 65535

    If value is greater than or equal to 0:
        If value is less than or equal to 65535:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "is_valid_branch_offset" takes offset as Integer returns Integer:
    Note: Check if branch offset is valid
    Note: 16-bit signed offset in words
    Note: Range: -131072 to 131068 bytes (-32768 to 32767 words)

    Let word_offset be offset divided by 4

    If word_offset is greater than or equal to -32768:
        If word_offset is less than or equal to 32767:
            Return 1
        End If
    End If

    Return 0
End Process

Note: ============================================================================
Note: INSTRUCTION SELECTION HELPERS
Note: ============================================================================

Process called "should_use_immediate" takes value as Integer returns Integer:
    Note: Determine if immediate encoding should be used vs register load

    If is_valid_16bit_immediate(value) is equal to 1:
        Return 1  Note: Use immediate
    End If

    Return 0
End Process

Process called "requires_load_upper_immediate" takes value as Integer returns Integer:
    Note: Check if value requires LUI+ORI sequence
    Note: Values outside 16-bit range need LUI

    If value is greater than 32767:
        Return 1
    End If

    If value is less than -32768:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: OPTIMIZATION PATTERNS
Note: ============================================================================

Process called "can_eliminate_nop_in_delay_slot" takes next_instruction as Integer returns Integer:
    Note: Check if NOP in delay slot can be eliminated
    Note: If next instruction is safe to move, place it in delay slot
    Note: Returns 1 if safe to fill delay slot, 0 otherwise

    Note: Cannot move loads/stores or branches into delay slots
    If is_load_instruction(next_instruction) is equal to 1:
        Return 0
    End If

    If is_store_instruction(next_instruction) is equal to 1:
        Return 0
    End If

    If is_branch_instruction(next_instruction) is equal to 1:
        Return 0
    End If

    If is_jump_instruction(next_instruction) is equal to 1:
        Return 0
    End If

    Return 1  Note: Safe to fill delay slot
End Process

Process called "can_use_zero_register" takes value as Integer returns Integer:
    Note: Check if $zero register can be used instead of loading 0

    If value is equal to 0:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: INSTRUCTION CATEGORIES
Note: ============================================================================

Process called "INSTR_CATEGORY_ALU" returns Integer:
    Return 0  Note: ADD, SUB, AND, OR, XOR
End Process

Process called "INSTR_CATEGORY_MULTIPLY_DIVIDE" returns Integer:
    Return 1  Note: MULT, DIV, MFHI, MFLO
End Process

Process called "INSTR_CATEGORY_LOAD_STORE" returns Integer:
    Return 2  Note: LW, SW, LH, SH, LB, SB
End Process

Process called "INSTR_CATEGORY_BRANCH" returns Integer:
    Return 3  Note: BEQ, BNE, BLEZ, BGTZ
End Process

Process called "INSTR_CATEGORY_JUMP" returns Integer:
    Return 4  Note: J, JAL, JR, JALR
End Process

Process called "INSTR_CATEGORY_SHIFT" returns Integer:
    Return 5  Note: SLL, SRL, SRA
End Process

Process called "INSTR_CATEGORY_COMPARE" returns Integer:
    Return 6  Note: SLT, SLTU
End Process

Process called "INSTR_CATEGORY_FPU" returns Integer:
    Return 7  Note: ADD.S, MUL.D, etc.
End Process

Note: ============================================================================
Note: PERFORMANCE HINTS
Note: ============================================================================

Process called "get_cache_line_size" returns Integer:
    Note: Get cache line size for alignment optimization
    Note: MIPS32 typically has 32-byte cache lines
    Return 32
End Process

Process called "get_preferred_alignment" returns Integer:
    Note: Get preferred alignment for memory operations
    Note: MIPS32 requires 4-byte alignment for words
    Return 4
End Process

Process called "get_branch_prediction_penalty" returns Integer:
    Note: Get cycle penalty for branch misprediction
    Note: MIPS R4000: ~3 cycles for misprediction (plus delay slot)
    Return 3
End Process

Process called "supports_unaligned_access" returns Integer:
    Note: Check if processor supports unaligned memory access
    Note: MIPS32 requires aligned access (trap on misalignment)
    Return 0  Note: Not supported
End Process

Process called "get_delay_slot_count" returns Integer:
    Note: Get number of delay slots after branches/jumps
    Note: MIPS has 1 delay slot
    Return 1
End Process

