Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions
Licensed under the Apache License, Version 2.0
:End Note

Note:
MIPS32 ATOMIC OPERATIONS
Uses LL/SC (load-linked/store-conditional) instructions
:End Note

Process called "atomic_load_relaxed" takes ptr as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        lw $t0, -8($fp)
        lw $t1, 0($t0)
        sw $t1, -16($fp)
    End Assembly
    Return result
End Process

Process called "atomic_load_acquire" takes ptr as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        lw $t0, -8($fp)
        lw $t1, 0($t0)
        sync
        sw $t1, -16($fp)
    End Assembly
    Return result
End Process

Process called "atomic_load_seq_cst" takes ptr as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        lw $t0, -8($fp)
        sync
        lw $t1, 0($t0)
        sync
        sw $t1, -16($fp)
    End Assembly
    Return result
End Process

Process called "atomic_store_relaxed" takes ptr as Integer, value as Integer returns Integer:
    Inline Assembly:
        lw $t0, -8($fp)
        lw $t1, -16($fp)
        sw $t1, 0($t0)
    End Assembly
    Return 0
End Process

Process called "atomic_store_release" takes ptr as Integer, value as Integer returns Integer:
    Inline Assembly:
        lw $t0, -8($fp)
        lw $t1, -16($fp)
        sync
        sw $t1, 0($t0)
    End Assembly
    Return 0
End Process

Process called "atomic_store_seq_cst" takes ptr as Integer, value as Integer returns Integer:
    Inline Assembly:
        lw $t0, -8($fp)
        lw $t1, -16($fp)
        sync
        sw $t1, 0($t0)
        sync
    End Assembly
    Return 0
End Process

Process called "atomic_fetch_add" takes ptr as Integer, value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        lw $t0, -8($fp)
        lw $t1, -16($fp)

        .retry:
        ll $t2, 0($t0)
        addu $t3, $t2, $t1
        sc $t3, 0($t0)
        beqz $t3, .retry

        sw $t2, -24($fp)
    End Assembly
    Return result
End Process

Process called "atomic_fetch_sub" takes ptr as Integer, value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        lw $t0, -8($fp)
        lw $t1, -16($fp)

        .retry:
        ll $t2, 0($t0)
        subu $t3, $t2, $t1
        sc $t3, 0($t0)
        beqz $t3, .retry

        sw $t2, -24($fp)
    End Assembly
    Return result
End Process

Process called "atomic_fetch_and" takes ptr as Integer, value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        lw $t0, -8($fp)
        lw $t1, -16($fp)

        .retry:
        ll $t2, 0($t0)
        and $t3, $t2, $t1
        sc $t3, 0($t0)
        beqz $t3, .retry

        sw $t2, -24($fp)
    End Assembly
    Return result
End Process

Process called "atomic_fetch_or" takes ptr as Integer, value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        lw $t0, -8($fp)
        lw $t1, -16($fp)

        .retry:
        ll $t2, 0($t0)
        or $t3, $t2, $t1
        sc $t3, 0($t0)
        beqz $t3, .retry

        sw $t2, -24($fp)
    End Assembly
    Return result
End Process

Process called "atomic_fetch_xor" takes ptr as Integer, value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        lw $t0, -8($fp)
        lw $t1, -16($fp)

        .retry:
        ll $t2, 0($t0)
        xor $t3, $t2, $t1
        sc $t3, 0($t0)
        beqz $t3, .retry

        sw $t2, -24($fp)
    End Assembly
    Return result
End Process

Process called "atomic_compare_and_swap" takes ptr as Integer, expected as Integer, desired as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        lw $t0, -8($fp)
        lw $t1, -16($fp)
        lw $t2, -24($fp)

        .retry:
        ll $t3, 0($t0)
        bne $t3, $t1, .failed
        move $t4, $t2
        sc $t4, 0($t0)
        beqz $t4, .retry

        li $t5, 1
        b .done

        .failed:
        li $t5, 0

        .done:
        sw $t5, -32($fp)
    End Assembly
    Return result
End Process

Process called "atomic_compare_and_swap_weak" takes ptr as Integer, expected as Integer, desired as Integer returns Integer:
    Return atomic_compare_and_swap(ptr, expected, desired)
End Process

Process called "atomic_exchange" takes ptr as Integer, value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        lw $t0, -8($fp)
        lw $t1, -16($fp)

        .retry:
        ll $t2, 0($t0)
        move $t3, $t1
        sc $t3, 0($t0)
        beqz $t3, .retry

        sw $t2, -24($fp)
    End Assembly
    Return result
End Process

Process called "memory_barrier_acquire" returns Integer:
    Inline Assembly:
        sync
    End Assembly
    Return 0
End Process

Process called "memory_barrier_release" returns Integer:
    Inline Assembly:
        sync
    End Assembly
    Return 0
End Process

Process called "memory_barrier_full" returns Integer:
    Inline Assembly:
        sync
    End Assembly
    Return 0
End Process

Process called "memory_barrier_seq_cst" returns Integer:
    Inline Assembly:
        sync
    End Assembly
    Return 0
End Process
