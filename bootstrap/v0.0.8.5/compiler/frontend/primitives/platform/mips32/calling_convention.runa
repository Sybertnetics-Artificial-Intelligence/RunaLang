Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
MIPS32 Calling Convention (o32 ABI)

This file implements MIPS32 o32 ABI calling conventions for the Runa compiler.

Platform-specific details:
- Platform: Linux MIPS32
- ABI: o32 (original 32-bit ABI)
- Stack alignment: 8 bytes
- Parameter passing: Register + stack hybrid

MIPS32 o32 ABI calling convention:
- Arguments: $a0-$a3 (first 4 integer args), rest on stack
- FP arguments: $f12, $f14 (if no preceding int args), else $a0-$a3
- Return values: $v0-$v1 (integers), $f0-$f1 (floats)
- Stack growth: Downward (decreasing addresses)
- Frame pointer: $fp ($30) optional
- Stack pointer: $sp ($29) always valid

Caller-saved registers: $t0-$t9, $a0-$a3, $v0-$v1, $at
Callee-saved registers: $s0-$s7, $fp, $ra, $gp

Structure passing:
- Structs <= 16 bytes: Passed by value in registers/stack
- Structs > 16 bytes: Passed by reference

Dependencies: compiler/frontend/primitives/platform/mips32/registers.runa, compiler/frontend/primitives/core/memory_core.runa
:End Note

Import "compiler/frontend/primitives/platform/mips32/registers.runa" as Registers
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Process called "get_integer_param_register" takes param_index as Integer returns Integer:
    If param_index is less than 4:
        Return 4 plus param_index  Note: $a0-$a3
    End If
    Return -1
End Process

Process called "get_param_location" takes param_index as Integer, param_size as Integer returns Integer:
    If param_index is less than 4:
        Return 4 plus param_index
    End If
    Let stack_offset be (param_index minus 4) multiplied by 4
    Return -1 minus stack_offset
End Process

Process called "get_stack_param_offset" takes param_index as Integer returns Integer:
    If param_index is less than 4:
        Return -1
    End If
    Return (param_index minus 4) multiplied by 4
End Process

Process called "get_return_register" returns Integer:
    Return 2  Note: $v0
End Process

Process called "get_secondary_return_register" returns Integer:
    Return 3  Note: $v1
End Process

Process called "get_stack_alignment" returns Integer:
    Return 8
End Process

Process called "calculate_stack_frame_size" takes local_vars_size as Integer, spilled_regs_count as Integer returns Integer:
    Let locals_space be local_vars_size
    Let spilled_space be spilled_regs_count multiplied by 4
    Let total_size be locals_space plus spilled_space
    Let remainder be total_size modulo 8
    If remainder is not equal to 0:
        Set total_size to total_size plus (8 minus remainder)
    End If
    Return total_size
End Process

Process called "calculate_callee_saved_mask" takes uses_s0 as Integer, uses_s1 as Integer, uses_s2 as Integer, uses_s3 as Integer returns Integer:
    Let mask be 0
    If uses_s0 is not equal to 0:
        Set mask to mask bitwise_or 65536  Note: $s0 bit
    End If
    If uses_s1 is not equal to 0:
        Set mask to mask bitwise_or 131072  Note: $s1 bit
    End If
    Set mask to mask bitwise_or 2147483648  Note: $ra bit
    Return mask
End Process

Process called "get_prologue_instructions" takes frame_size as Integer, callee_saved_mask as Integer, result_buffer as Integer returns Integer:
    Let instruction_count be 1  Note: SW instructions for saved regs
    If frame_size is greater than 0:
        Set instruction_count to instruction_count plus 1
    End If
    proc memory_set_int32 from Memory with result_buffer, 0, instruction_count
    proc memory_set_int32 from Memory with result_buffer, 4, callee_saved_mask
    proc memory_set_int32 from Memory with result_buffer, 8, frame_size
    Return instruction_count
End Process

Process called "get_epilogue_instructions" takes frame_size as Integer, callee_saved_mask as Integer, result_buffer as Integer returns Integer:
    Let instruction_count be 2  Note: LW + JR $ra
    proc memory_set_int32 from Memory with result_buffer, 0, instruction_count
    proc memory_set_int32 from Memory with result_buffer, 4, callee_saved_mask
    proc memory_set_int32 from Memory with result_buffer, 8, frame_size
    Return instruction_count
End Process

Process called "calculate_call_stack_adjustment" takes num_stack_args as Integer returns Integer:
    If num_stack_args is less than or equal to 0:
        Return 0
    End If
    Let args_size be num_stack_args multiplied by 4
    Let remainder be args_size bitwise_and 7
    If remainder is not equal to 0:
        Let padding be 8 minus remainder
        Set args_size to args_size plus padding
    End If
    Return args_size
End Process

Process called "get_callee_saved_registers" takes result_buffer as Integer returns Integer:
    proc memory_set_int32 from Memory with result_buffer, 0, 16   Note: $s0
    proc memory_set_int32 from Memory with result_buffer, 4, 17   Note: $s1
    proc memory_set_int32 from Memory with result_buffer, 8, 18   Note: $s2
    proc memory_set_int32 from Memory with result_buffer, 12, 19  Note: $s3
    proc memory_set_int32 from Memory with result_buffer, 16, 20  Note: $s4
    proc memory_set_int32 from Memory with result_buffer, 20, 21  Note: $s5
    proc memory_set_int32 from Memory with result_buffer, 24, 22  Note: $s6
    proc memory_set_int32 from Memory with result_buffer, 28, 23  Note: $s7
    proc memory_set_int32 from Memory with result_buffer, 32, 30  Note: $fp
    proc memory_set_int32 from Memory with result_buffer, 36, 31  Note: $ra
    Return 10
End Process

Process called "validate_stack_alignment" takes stack_offset as Integer returns Integer:
    Let remainder be stack_offset bitwise_and 7
    If remainder is equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "get_calling_convention_name" returns String:
    Return "MIPS32 o32 ABI"
End Process

Process called "get_abi_version" returns Integer:
    Return 1
End Process

Process called "get_max_register_params" returns Integer:
    Return 4
End Process

Process called "should_save_return_address" takes is_leaf_function as Integer returns Integer:
    If is_leaf_function is equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "get_parameter_location" takes param_index as Integer, param_size as Integer, result_buffer as Integer returns Integer:
    Let location_type be 0
    Let value be 0
    If param_index is less than 4:
        Set location_type to 0
        Set value to 4 plus param_index
    Otherwise:
        Set location_type to 1
        Set value to (param_index minus 4) multiplied by 4
    End If
    proc memory_set_int32 from Memory with result_buffer, 0, location_type
    proc memory_set_int32 from Memory with result_buffer, 4, value
    Return location_type
End Process

Process called "get_call_setup_info" takes num_params as Integer, result_buffer as Integer returns Integer:
    Let reg_params be 4
    Let stack_params be 0
    Let stack_adjustment be 0
    If num_params is less than or equal to 4:
        Set reg_params to num_params
    Otherwise:
        Set stack_params to num_params minus 4
        Set stack_adjustment to calculate_call_stack_adjustment(stack_params)
    End If
    proc memory_set_int32 from Memory with result_buffer, 0, reg_params
    proc memory_set_int32 from Memory with result_buffer, 4, stack_params
    proc memory_set_int32 from Memory with result_buffer, 8, stack_adjustment
    Return stack_params
End Process

Process called "get_float_param_register" takes param_index as Integer returns Integer:
    Note: In o32 ABI, FP args use $f12, $f14 for first 2 floats if no preceding int args
    Note: With preceding int args, floats go in $a0-$a3 or stack
    Note: This returns -1 for simplicity; caller handles FP in integer regs
    Return -1
End Process

Process called "get_float_return_register" returns Integer:
    Note: Float return value in $f0
    Return 0  Note: FPU register $f0
End Process

Process called "should_pass_struct_by_reference" takes struct_size as Integer returns Integer:
    Note: MIPS o32 passes structs by value if <= 16 bytes, otherwise by reference
    If struct_size is greater than 16:
        Return 1
    End If
    Return 0
End Process

Process called "calculate_struct_param_slots" takes struct_size as Integer returns Integer:
    Note: Struct passed by value consumes (size+3)/4 register/stack slots
    Let slots be (struct_size plus 3) divided by 4
    Return slots
End Process

Process called "is_variadic_supported" returns Integer:
    Note: MIPS o32 supports variadic functions
    Return 1
End Process

Process called "get_variadic_reg_save_area_size" returns Integer:
    Note: Save area for $a0-$a3 = 16 bytes
    Return 16
End Process

Process called "get_variadic_save_registers" takes result_buffer as Integer returns Integer:
    Note: Save all argument registers for va_arg access
    proc memory_set_int32 from Memory with result_buffer, 0, 4   Note: $a0
    proc memory_set_int32 from Memory with result_buffer, 4, 5   Note: $a1
    proc memory_set_int32 from Memory with result_buffer, 8, 6   Note: $a2
    proc memory_set_int32 from Memory with result_buffer, 12, 7  Note: $a3
    Return 4
End Process

Process called "align_struct_field" takes current_offset as Integer, field_size as Integer, field_alignment as Integer returns Integer:
    Let alignment be field_alignment
    If field_size is equal to 8:
        Set alignment to 8
    End If
    Let remainder be current_offset bitwise_and (alignment minus 1)
    If remainder is not equal to 0:
        Let padding be alignment minus remainder
        Return current_offset plus padding
    End If
    Return current_offset
End Process

Process called "get_natural_alignment" takes type_size as Integer returns Integer:
    Note: MIPS o32 natural alignment is min(type_size, 4) for most types
    If type_size is greater than or equal to 8:
        Return 8
    End If
    If type_size is greater than or equal to 4:
        Return 4
    End If
    If type_size is equal to 2:
        Return 2
    End If
    Return 1
End Process

Process called "calculate_return_value_location" takes return_size as Integer, result_buffer as Integer returns Integer:
    Note: Returns 0 for register, 1 for memory return
    Note: o32 returns <= 8 bytes in $v0/$v1, larger via hidden pointer in $a0
    If return_size is less than or equal to 8:
        proc memory_set_int32 from Memory with result_buffer, 0, 0  Note: Location type: register
        proc memory_set_int32 from Memory with result_buffer, 4, 2  Note: $v0
        Return 0
    Otherwise:
        proc memory_set_int32 from Memory with result_buffer, 0, 1  Note: Location type: memory
        proc memory_set_int32 from Memory with result_buffer, 4, 4  Note: $a0 holds pointer
        Return 1
    End If
End Process

Process called "get_frame_pointer_register" returns Integer:
    Return 30  Note: $fp
End Process

Process called "get_stack_pointer_register" returns Integer:
    Return 29  Note: $sp
End Process

Process called "get_return_address_register" returns Integer:
    Return 31  Note: $ra
End Process

Process called "is_leaf_function_optimizable" takes makes_calls as Integer returns Integer:
    Note: Leaf functions that don't call others can skip saving $ra
    If makes_calls is equal to 0:
        Return 1
    End If
    Return 0
End Process

