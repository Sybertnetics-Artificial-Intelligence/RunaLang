Note:
RISC-V 64-bit Calling Convention (RISC-V ABI)

This file implements the calling convention for RISC-V 64-bit architecture
following the RISC-V ABI specification.

Platform-specific details:
- Architecture: RISC-V 64-bit (RV64I)
- ABI: RISC-V ABI
- Endianness: Little-endian
- Register size: 64-bit
- Stack alignment: 16-byte aligned
- Red zone: None (RISC-V doesn't use red zone)

Register usage:
- a0-a7: Argument/return registers (a0-a7 for arguments, a0-a1 for return values)
- ra: Return address register
- sp: Stack pointer
- gp: Global pointer
- tp: Thread pointer
- t0-t6: Temporary registers
- s0-s11: Saved registers
- a0-a1: Return value registers
- fa0-fa7: Floating-point argument/return registers
- fa0-fa1: Floating-point return value registers
- ft0-ft11: Temporary floating-point registers
- fs0-fs11: Saved floating-point registers

Calling convention details:
- Parameters passed in a0-a7 (up to 8 parameters)
- Additional parameters passed on stack
- Return values in a0-a1 (or fa0-fa1 for floating-point)
- Caller-saved: ra, t0-t6, a0-a7, ft0-ft11, fa0-fa7
- Callee-saved: sp, gp, tp, s0-s11, fs0-fs11
- Stack grows downward
- 16-byte stack alignment required
- Return address stored in ra register
:End Note

Import "compiler/frontend/primitives/platform/riscv64/registers.runa" as Registers
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Note: ============================================================================
Note: PARAMETER PASSING - INTEGER AND POINTER ARGUMENTS
Note: ============================================================================

Process called "get_integer_param_register" takes param_index as Integer returns Integer:
    Note: Get register number for integer/pointer parameter
    Note: RISC-V ABI: a0-a7 (indices 0-7)
    Note: Returns register number (10-17), or -1 if passed on stack

    If param_index is equal to 0:
        Return 10  Note: a0
    End If

    If param_index is equal to 1:
        Return 11  Note: a1
    End If

    If param_index is equal to 2:
        Return 12  Note: a2
    End If

    If param_index is equal to 3:
        Return 13  Note: a3
    End If

    If param_index is equal to 4:
        Return 14  Note: a4
    End If

    If param_index is equal to 5:
        Return 15  Note: a5
    End If

    If param_index is equal to 6:
        Return 16  Note: a6
    End If

    If param_index is equal to 7:
        Return 17  Note: a7
    End If

    Note: Parameters 8+ are passed on stack
    Return -1
End Process

Process called "get_max_integer_register_params" returns Integer:
    Note: Maximum number of integer/pointer parameters passed in registers
    Return 8
End Process

Process called "is_param_in_register" takes param_index as Integer returns Integer:
    Note: Check if parameter is passed in register (vs stack)
    Note: Returns 1 if in register, 0 if on stack

    If param_index is less than 8:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Process called "get_stack_param_offset" takes param_index as Integer returns Integer:
    Note: Get stack offset for parameter (when not in register)
    Note: RISC-V: parameters 8+ start at offset 0 (no reserved space)
    Note: Each parameter is 8 bytes (64-bit)

    If param_index is less than 8:
        Return -1  Note: Parameter is in register
    Otherwise:
        Let stack_index be param_index minus 8
        Return stack_index multiplied by 8
    End If
End Process

Note: ============================================================================
Note: PARAMETER PASSING - FLOATING-POINT ARGUMENTS
Note: ============================================================================

Process called "get_float_param_register" takes param_index as Integer returns Integer:
    Note: Get register number for floating-point parameter
    Note: RISC-V ABI: fa0-fa7 (indices 0-7)
    Note: Returns register number (20-27), or -1 if passed on stack

    If param_index is equal to 0:
        Return 20  Note: fa0
    End If

    If param_index is equal to 1:
        Return 21  Note: fa1
    End If

    If param_index is equal to 2:
        Return 22  Note: fa2
    End If

    If param_index is equal to 3:
        Return 23  Note: fa3
    End If

    If param_index is equal to 4:
        Return 24  Note: fa4
    End If

    If param_index is equal to 5:
        Return 25  Note: fa5
    End If

    If param_index is equal to 6:
        Return 26  Note: fa6
    End If

    If param_index is equal to 7:
        Return 27  Note: fa7
    End If

    Note: Parameters 8+ are passed on stack
    Return -1
End Process

Process called "get_max_float_register_params" returns Integer:
    Note: Maximum number of floating-point parameters passed in registers
    Return 8
End Process

Process called "is_float_param_in_register" takes param_index as Integer returns Integer:
    Note: Check if floating-point parameter is passed in register (vs stack)
    Note: Returns 1 if in register, 0 if on stack

    If param_index is less than 8:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Note: ============================================================================
Note: RETURN VALUES
Note: ============================================================================

Process called "get_return_value_register" returns Integer:
    Note: Get register number for integer/pointer return value
    Note: RISC-V ABI: a0
    Return 10
End Process

Process called "get_float_return_register" returns Integer:
    Note: Get register number for floating-point return value
    Note: RISC-V ABI: fa0
    Return 20
End Process

Process called "is_return_via_memory" takes return_size as Integer returns Integer:
    Note: Check if return value is passed via memory (vs register)
    Note: RISC-V: values > 16 bytes passed via memory
    Note: Returns 1 if via memory, 0 if via register

    If return_size is greater than 16:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Note: ============================================================================
Note: REGISTER PRESERVATION
Note: ============================================================================

Process called "is_caller_saved_register" takes reg_num as Integer returns Integer:
    Note: Check if register is caller-saved (volatile)
    Note: Returns 1 if caller-saved, 0 if callee-saved

    Note: Caller-saved registers: ra, t0-t6, a0-a7, ft0-ft11, fa0-fa7
    If reg_num is equal to 1:
        Return 1  Note: ra
    End If

    If reg_num is greater than or equal to 5 and reg_num is less than or equal to 11:
        Return 1  Note: t0-t6
    End If

    If reg_num is greater than or equal to 10 and reg_num is less than or equal to 17:
        Return 1  Note: a0-a7
    End If

    If reg_num is greater than or equal to 20 and reg_num is less than or equal to 27:
        Return 1  Note: fa0-fa7
    End If

    If reg_num is greater than or equal to 28 and reg_num is less than or equal to 39:
        Return 1  Note: ft0-ft11
    End If

    Return 0  Note: Callee-saved or unknown
End Process

Process called "is_callee_saved_register" takes reg_num as Integer returns Integer:
    Note: Check if register is callee-saved (non-volatile)
    Note: Returns 1 if callee-saved, 0 if caller-saved

    Note: Callee-saved registers: sp, gp, tp, s0-s11, fs0-fs11
    If reg_num is equal to 2:
        Return 1  Note: sp
    End If

    If reg_num is equal to 3:
        Return 1  Note: gp
    End If

    If reg_num is equal to 4:
        Return 1  Note: tp
    End If

    If reg_num is greater than or equal to 8 and reg_num is less than or equal to 9:
        Return 1  Note: s0-s1
    End If

    If reg_num is greater than or equal to 18 and reg_num is less than or equal to 19:
        Return 1  Note: s2-s3
    End If

    If reg_num is greater than or equal to 40 and reg_num is less than or equal to 51:
        Return 1  Note: fs0-fs11
    End If

    Return 0  Note: Caller-saved or unknown
End Process

Process called "get_callee_saved_register_list" takes buffer_ptr as Integer returns Integer:
    Note: Fill buffer with list of callee-saved register numbers
    Note: buffer_ptr: pointer to array of at least 19 integers
    Note: Returns: count of callee-saved registers

    Let offset be 0

    Note: Store register numbers in buffer (8 bytes per integer for 64-bit)
    Note: sp, gp, tp
    proc memory_set_int64 from Memory with buffer_ptr, offset, 2  Note: sp
    Set offset to offset plus 8
    proc memory_set_int64 from Memory with buffer_ptr, offset, 3  Note: gp
    Set offset to offset plus 8
    proc memory_set_int64 from Memory with buffer_ptr, offset, 4  Note: tp
    Set offset to offset plus 8

    Note: s0-s11 (12 registers)
    Let reg_num be 8
    While reg_num is less than or equal to 9:
        proc memory_set_int64 from Memory with buffer_ptr, offset, reg_num
        Set offset to offset plus 8
        Set reg_num to reg_num plus 1
    End While

    Set reg_num to 18
    While reg_num is less than or equal to 19:
        proc memory_set_int64 from Memory with buffer_ptr, offset, reg_num
        Set offset to offset plus 8
        Set reg_num to reg_num plus 1
    End While

    Note: fs0-fs11 (12 registers)
    Set reg_num to 40
    While reg_num is less than or equal to 51:
        proc memory_set_int64 from Memory with buffer_ptr, offset, reg_num
        Set offset to offset plus 8
        Set reg_num to reg_num plus 1
    End While

    Return 19  Note: 3 + 4 + 12 = 19 registers
End Process

Note: ============================================================================
Note: STACK FRAME MANAGEMENT
Note: ============================================================================

Process called "get_stack_alignment" returns Integer:
    Note: Get required stack alignment in bytes
    Note: RISC-V ABI: 16-byte alignment
    Return 16
End Process

Process called "calculate_stack_frame_size" takes local_vars_size as Integer, num_callee_saved_regs as Integer returns Integer:
    Note: Calculate total stack frame size
    Note: Includes: local variables, callee-saved registers, return address
    Note: RISC-V: 8 bytes for return address, 8 bytes per saved register

    Let frame_size be 8  Note: Return address
    Set frame_size to frame_size plus (num_callee_saved_regs multiplied by 8)
    Set frame_size to frame_size plus local_vars_size

    Note: Align to 16-byte boundary
    Let remainder be frame_size Modulo by 16
    If remainder is not equal to 0:
        Set frame_size to frame_size plus (16 minus remainder)
    End If

    Return frame_size
End Process

Process called "get_frame_pointer_register" returns Integer:
    Note: Get frame pointer register number
    Note: RISC-V: s0 (x8) often used as frame pointer
    Return 8
End Process

Process called "get_stack_pointer_register" returns Integer:
    Note: Get stack pointer register number
    Note: RISC-V: sp (x2)
    Return 2
End Process

Process called "get_red_zone_size" returns Integer:
    Note: Get red zone size in bytes
    Note: RISC-V: no red zone
    Return 0
End Process

Process called "can_use_red_zone" takes is_leaf_function as Integer returns Integer:
    Note: Check if red zone can be used
    Note: RISC-V: no red zone
    Return 0
End Process

Process called "needs_frame_pointer" takes has_variable_sized_locals as Integer, has_alloca as Integer returns Integer:
    Note: Check if frame pointer is needed
    Note: RISC-V: frame pointer needed for variable-sized locals or alloca
    If has_variable_sized_locals is equal to 1 or has_alloca is equal to 1:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Process called "calculate_call_stack_adjustment" takes num_stack_args as Integer returns Integer:
    Note: Calculate stack adjustment needed for function call
    Note: RISC-V: 8 bytes per stack argument, plus alignment
    Note: Stack must be 16-byte aligned

    Let adjustment be num_stack_args multiplied by 8
    Let remainder be adjustment Modulo by 16
    If remainder is not equal to 0:
        Set adjustment to adjustment plus (16 minus remainder)
    End If

    Return adjustment
End Process

Note: ============================================================================
Note: VARIADIC FUNCTIONS
Note: ============================================================================

Process called "get_variadic_gp_register_save_area_size" returns Integer:
    Note: Get size of general-purpose register save area for variadic functions
    Note: RISC-V: save a0-a7 (8 registers * 8 bytes = 64 bytes)
    Return 64
End Process

Process called "get_variadic_fp_register_save_area_size" returns Integer:
    Note: Get size of floating-point register save area for variadic functions
    Note: RISC-V: save fa0-fa7 (8 registers * 8 bytes = 64 bytes)
    Return 64
End Process

Process called "get_variadic_total_save_area_size" returns Integer:
    Note: Get total size of register save areas for variadic functions
    Let gp_size be get_variadic_gp_register_save_area_size()
    Let fp_size be get_variadic_fp_register_save_area_size()
    Return gp_size plus fp_size
End Process

Note: ============================================================================
Note: HELPER FUNCTIONS FOR CODE GENERATION
Note: ============================================================================

Process called "get_parameter_location" takes param_index as Integer, param_size as Integer, result_buffer as Integer returns Integer:
    Note: Get location (register or stack offset) for parameter
    Note: param_index: parameter position (0-based)
    Note: param_size: size in bytes (for future struct handling)
    Note: result_buffer: pointer to 2-integer array [location_type, value]
    Note: location_type: 0 = register (value = reg_num), 1 = stack (value = offset)
    Note: Returns: location_type

    Let location_type be 0
    Let value be 0

    Note: Check if parameter is in register
    If param_index is less than 8:
        Set location_type to 0  Note: Register
        Set value to get_integer_param_register(param_index)
    Otherwise:
        Set location_type to 1  Note: Stack
        Set value to get_stack_param_offset(param_index)
    End If

    Note: Write results to buffer
    proc memory_set_int64 from Memory with result_buffer, 0, location_type
    proc memory_set_int64 from Memory with result_buffer, 8, value

    Return location_type
End Process

Process called "get_call_setup_info" takes num_params as Integer, result_buffer as Integer returns Integer:
    Note: Get information needed to set up a function call
    Note: num_params: total number of parameters
    Note: result_buffer: pointer to 3-integer array [reg_params, stack_params, stack_adjustment]
    Note: Returns: number of stack parameters

    Let reg_params be 8
    Let stack_params be 0
    Let stack_adjustment be 0

    If num_params is less than or equal to 8:
        Set reg_params to num_params
    Otherwise:
        Set stack_params to num_params minus 8
        Set stack_adjustment to calculate_call_stack_adjustment(stack_params)
    End If

    Note: Write results to buffer
    proc memory_set_int64 from Memory with result_buffer, 0, reg_params
    proc memory_set_int64 from Memory with result_buffer, 8, stack_params
    proc memory_set_int64 from Memory with result_buffer, 16, stack_adjustment

    Return stack_params
End Process

Process called "validate_stack_alignment" takes stack_offset as Integer returns Integer:
    Note: Validate that stack is properly aligned
    Note: Returns 1 if aligned, 0 if not aligned

    Let remainder be stack_offset Modulo by 16
    If remainder is equal to 0:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Note: ============================================================================
Note: CONVENTION INFORMATION
Note: ============================================================================

Process called "get_calling_convention_name" returns String:
    Return "RISC-V 64-bit"
End Process

Process called "get_abi_version" returns Integer:
    Note: Return ABI version number
    Return 1
End Process