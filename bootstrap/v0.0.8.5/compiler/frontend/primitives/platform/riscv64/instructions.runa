Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
RISC-V 64-bit Instruction Set Metadata and Helpers

This file provides instruction metadata, opcode definitions, and helper functions
for RISC-V 64-bit instruction selection, validation, and optimization.

RISC-V 64-bit Key Characteristics:
- Fixed 32-bit (4-byte) instruction length (RISC architecture)
- Load/store architecture (memory access only via LW/SW, LD/SD)
- Three-operand instructions (dest can differ from sources)
- No condition codes (compare produces register result)
- Compressed instruction support (16-bit instructions)
- 64-bit register operations with 32-bit compatibility

RISC-V 64-bit Instruction Formats:
- R-type: Register operations (funct7 + rs2 + rs1 + funct3 + rd + opcode)
- I-type: Immediate operations (imm[11:0] + rs1 + funct3 + rd + opcode)
- S-type: Store operations (imm[11:5] + rs2 + rs1 + funct3 + imm[4:0] + opcode)
- B-type: Branch operations (imm[12|10:5] + rs2 + rs1 + funct3 + imm[4:1|11] + opcode)
- U-type: Upper immediate (imm[31:12] + rd + opcode)
- J-type: Jump operations (imm[20|10:1|11|19:12] + rd + opcode)

This includes:
- Instruction opcode patterns
- Instruction properties (latency, throughput)
- Instruction validation helpers
- Instruction selection helpers
- Common instruction patterns
- Optimization hints

IMPORTANT: RISC-V 64-bit instruction set is IDENTICAL across platforms (Linux, FreeRTOS, etc).
Platform differences are in calling convention and syscalls, NOT instruction encoding.

This file does NOT perform actual instruction encoding (see machine_code.runa for that).
Instead, it provides metadata and helper functions for the code generator to make
intelligent decisions about which instructions to use and how to optimize them.

Dependencies:
- registers.runa for register metadata
- calling_convention.runa for ABI constraints
:End Note

Import "compiler/frontend/primitives/platform/riscv64/registers.runa" as Registers

Note: ============================================================================
Note: INSTRUCTION OPCODE PATTERNS (RISC-V 64-bit)
Note: ============================================================================

Note: Primary opcodes for RISC-V 64-bit instructions
Process called "OPCODE_LUI" returns Integer:
    Return 55  Note: 0x37 - LUI (Load Upper Immediate)
End Process

Process called "OPCODE_AUIPC" returns Integer:
    Return 23  Note: 0x17 - AUIPC (Add Upper Immediate to PC)
End Process

Process called "OPCODE_JAL" returns Integer:
    Return 111  Note: 0x6F - JAL (Jump and Link)
End Process

Process called "OPCODE_JALR" returns Integer:
    Return 103  Note: 0x67 - JALR (Jump and Link Register)
End Process

Process called "OPCODE_BEQ" returns Integer:
    Return 99  Note: 0x63 - BEQ (Branch if Equal)
End Process

Process called "OPCODE_BNE" returns Integer:
    Return 99  Note: 0x63 - BNE (Branch if Not Equal)
End Process

Process called "OPCODE_BLT" returns Integer:
    Return 99  Note: 0x63 - BLT (Branch if Less Than)
End Process

Process called "OPCODE_BGE" returns Integer:
    Return 99  Note: 0x63 - BGE (Branch if Greater or Equal)
End Process

Process called "OPCODE_BLTU" returns Integer:
    Return 99  Note: 0x63 - BLTU (Branch if Less Than Unsigned)
End Process

Process called "OPCODE_BGEU" returns Integer:
    Return 99  Note: 0x63 - BGEU (Branch if Greater or Equal Unsigned)
End Process

Process called "OPCODE_LB" returns Integer:
    Return 3  Note: 0x03 - LB (Load Byte)
End Process

Process called "OPCODE_LH" returns Integer:
    Return 3  Note: 0x03 - LH (Load Halfword)
End Process

Process called "OPCODE_LW" returns Integer:
    Return 3  Note: 0x03 - LW (Load Word)
End Process

Process called "OPCODE_LD" returns Integer:
    Return 3  Note: 0x03 - LD (Load Doubleword)
End Process

Process called "OPCODE_LBU" returns Integer:
    Return 3  Note: 0x03 - LBU (Load Byte Unsigned)
End Process

Process called "OPCODE_LHU" returns Integer:
    Return 3  Note: 0x03 - LHU (Load Halfword Unsigned)
End Process

Process called "OPCODE_LWU" returns Integer:
    Return 3  Note: 0x03 - LWU (Load Word Unsigned)
End Process

Process called "OPCODE_SB" returns Integer:
    Return 35  Note: 0x23 - SB (Store Byte)
End Process

Process called "OPCODE_SH" returns Integer:
    Return 35  Note: 0x23 - SH (Store Halfword)
End Process

Process called "OPCODE_SW" returns Integer:
    Return 35  Note: 0x23 - SW (Store Word)
End Process

Process called "OPCODE_SD" returns Integer:
    Return 35  Note: 0x23 - SD (Store Doubleword)
End Process

Process called "OPCODE_ADDI" returns Integer:
    Return 19  Note: 0x13 - ADDI (Add Immediate)
End Process

Process called "OPCODE_SLTI" returns Integer:
    Return 19  Note: 0x13 - SLTI (Set Less Than Immediate)
End Process

Process called "OPCODE_SLTIU" returns Integer:
    Return 19  Note: 0x13 - SLTIU (Set Less Than Immediate Unsigned)
End Process

Process called "OPCODE_XORI" returns Integer:
    Return 19  Note: 0x13 - XORI (XOR Immediate)
End Process

Process called "OPCODE_ORI" returns Integer:
    Return 19  Note: 0x13 - ORI (OR Immediate)
End Process

Process called "OPCODE_ANDI" returns Integer:
    Return 19  Note: 0x13 - ANDI (AND Immediate)
End Process

Process called "OPCODE_SLLI" returns Integer:
    Return 19  Note: 0x13 - SLLI (Shift Left Logical Immediate)
End Process

Process called "OPCODE_SRLI" returns Integer:
    Return 19  Note: 0x13 - SRLI (Shift Right Logical Immediate)
End Process

Process called "OPCODE_SRAI" returns Integer:
    Return 19  Note: 0x13 - SRAI (Shift Right Arithmetic Immediate)
End Process

Process called "OPCODE_ADD" returns Integer:
    Return 51  Note: 0x33 - ADD (Add)
End Process

Process called "OPCODE_SUB" returns Integer:
    Return 51  Note: 0x33 - SUB (Subtract)
End Process

Process called "OPCODE_SLL" returns Integer:
    Return 51  Note: 0x33 - SLL (Shift Left Logical)
End Process

Process called "OPCODE_SLT" returns Integer:
    Return 51  Note: 0x33 - SLT (Set Less Than)
End Process

Process called "OPCODE_SLTU" returns Integer:
    Return 51  Note: 0x33 - SLTU (Set Less Than Unsigned)
End Process

Process called "OPCODE_XOR" returns Integer:
    Return 51  Note: 0x33 - XOR (XOR)
End Process

Process called "OPCODE_SRL" returns Integer:
    Return 51  Note: 0x33 - SRL (Shift Right Logical)
End Process

Process called "OPCODE_SRA" returns Integer:
    Return 51  Note: 0x33 - SRA (Shift Right Arithmetic)
End Process

Process called "OPCODE_OR" returns Integer:
    Return 51  Note: 0x33 - OR (OR)
End Process

Process called "OPCODE_AND" returns Integer:
    Return 51  Note: 0x33 - AND (AND)
End Process

Process called "OPCODE_ADDIW" returns Integer:
    Return 27  Note: 0x1B - ADDIW (Add Immediate Word)
End Process

Process called "OPCODE_SLLIW" returns Integer:
    Return 27  Note: 0x1B - SLLIW (Shift Left Logical Immediate Word)
End Process

Process called "OPCODE_SRLIW" returns Integer:
    Return 27  Note: 0x1B - SRLIW (Shift Right Logical Immediate Word)
End Process

Process called "OPCODE_SRAIW" returns Integer:
    Return 27  Note: 0x1B - SRAIW (Shift Right Arithmetic Immediate Word)
End Process

Process called "OPCODE_ADDW" returns Integer:
    Return 59  Note: 0x3B - ADDW (Add Word)
End Process

Process called "OPCODE_SUBW" returns Integer:
    Return 59  Note: 0x3B - SUBW (Subtract Word)
End Process

Process called "OPCODE_SLLW" returns Integer:
    Return 59  Note: 0x3B - SLLW (Shift Left Logical Word)
End Process

Process called "OPCODE_SRLW" returns Integer:
    Return 59  Note: 0x3B - SRLW (Shift Right Logical Word)
End Process

Process called "OPCODE_SRAW" returns Integer:
    Return 59  Note: 0x3B - SRAW (Shift Right Arithmetic Word)
End Process

Process called "OPCODE_FENCE" returns Integer:
    Return 15  Note: 0x0F - FENCE (Fence)
End Process

Process called "OPCODE_ECALL" returns Integer:
    Return 115  Note: 0x73 - ECALL (Environment Call)
End Process

Process called "OPCODE_EBREAK" returns Integer:
    Return 115  Note: 0x73 - EBREAK (Environment Break)
End Process

Note: ============================================================================
Note: INSTRUCTION FUNCTION CODES (funct3 and funct7 fields)
Note: ============================================================================

Process called "FUNCT3_BEQ" returns Integer:
    Return 0  Note: 0x0 - BEQ
End Process

Process called "FUNCT3_BNE" returns Integer:
    Return 1  Note: 0x1 - BNE
End Process

Process called "FUNCT3_BLT" returns Integer:
    Return 4  Note: 0x4 - BLT
End Process

Process called "FUNCT3_BGE" returns Integer:
    Return 5  Note: 0x5 - BGE
End Process

Process called "FUNCT3_BLTU" returns Integer:
    Return 6  Note: 0x6 - BLTU
End Process

Process called "FUNCT3_BGEU" returns Integer:
    Return 7  Note: 0x7 - BGEU
End Process

Process called "FUNCT3_LB" returns Integer:
    Return 0  Note: 0x0 - LB
End Process

Process called "FUNCT3_LH" returns Integer:
    Return 1  Note: 0x1 - LH
End Process

Process called "FUNCT3_LW" returns Integer:
    Return 2  Note: 0x2 - LW
End Process

Process called "FUNCT3_LD" returns Integer:
    Return 3  Note: 0x3 - LD
End Process

Process called "FUNCT3_LBU" returns Integer:
    Return 4  Note: 0x4 - LBU
End Process

Process called "FUNCT3_LHU" returns Integer:
    Return 5  Note: 0x5 - LHU
End Process

Process called "FUNCT3_LWU" returns Integer:
    Return 6  Note: 0x6 - LWU
End Process

Process called "FUNCT3_SB" returns Integer:
    Return 0  Note: 0x0 - SB
End Process

Process called "FUNCT3_SH" returns Integer:
    Return 1  Note: 0x1 - SH
End Process

Process called "FUNCT3_SW" returns Integer:
    Return 2  Note: 0x2 - SW
End Process

Process called "FUNCT3_SD" returns Integer:
    Return 3  Note: 0x3 - SD
End Process

Process called "FUNCT3_ADDI" returns Integer:
    Return 0  Note: 0x0 - ADDI
End Process

Process called "FUNCT3_SLTI" returns Integer:
    Return 2  Note: 0x2 - SLTI
End Process

Process called "FUNCT3_SLTIU" returns Integer:
    Return 3  Note: 0x3 - SLTIU
End Process

Process called "FUNCT3_XORI" returns Integer:
    Return 4  Note: 0x4 - XORI
End Process

Process called "FUNCT3_ORI" returns Integer:
    Return 6  Note: 0x6 - ORI
End Process

Process called "FUNCT3_ANDI" returns Integer:
    Return 7  Note: 0x7 - ANDI
End Process

Process called "FUNCT3_SLLI" returns Integer:
    Return 1  Note: 0x1 - SLLI
End Process

Process called "FUNCT3_SRLI" returns Integer:
    Return 5  Note: 0x5 - SRLI
End Process

Process called "FUNCT3_SRAI" returns Integer:
    Return 5  Note: 0x5 - SRAI
End Process

Process called "FUNCT3_ADD" returns Integer:
    Return 0  Note: 0x0 - ADD
End Process

Process called "FUNCT3_SUB" returns Integer:
    Return 0  Note: 0x0 - SUB
End Process

Process called "FUNCT3_SLL" returns Integer:
    Return 1  Note: 0x1 - SLL
End Process

Process called "FUNCT3_SLT" returns Integer:
    Return 2  Note: 0x2 - SLT
End Process

Process called "FUNCT3_SLTU" returns Integer:
    Return 3  Note: 0x3 - SLTU
End Process

Process called "FUNCT3_XOR" returns Integer:
    Return 4  Note: 0x4 - XOR
End Process

Process called "FUNCT3_SRL" returns Integer:
    Return 5  Note: 0x5 - SRL
End Process

Process called "FUNCT3_SRA" returns Integer:
    Return 5  Note: 0x5 - SRA
End Process

Process called "FUNCT3_OR" returns Integer:
    Return 6  Note: 0x6 - OR
End Process

Process called "FUNCT3_AND" returns Integer:
    Return 7  Note: 0x7 - AND
End Process

Process called "FUNCT3_ADDIW" returns Integer:
    Return 0  Note: 0x0 - ADDIW
End Process

Process called "FUNCT3_SLLIW" returns Integer:
    Return 1  Note: 0x1 - SLLIW
End Process

Process called "FUNCT3_SRLIW" returns Integer:
    Return 5  Note: 0x5 - SRLIW
End Process

Process called "FUNCT3_SRAIW" returns Integer:
    Return 5  Note: 0x5 - SRAIW
End Process

Process called "FUNCT3_ADDW" returns Integer:
    Return 0  Note: 0x0 - ADDW
End Process

Process called "FUNCT3_SUBW" returns Integer:
    Return 0  Note: 0x0 - SUBW
End Process

Process called "FUNCT3_SLLW" returns Integer:
    Return 1  Note: 0x1 - SLLW
End Process

Process called "FUNCT3_SRLW" returns Integer:
    Return 5  Note: 0x5 - SRLW
End Process

Process called "FUNCT3_SRAW" returns Integer:
    Return 5  Note: 0x5 - SRAW
End Process

Process called "FUNCT7_ADD" returns Integer:
    Return 0  Note: 0x00 - ADD
End Process

Process called "FUNCT7_SUB" returns Integer:
    Return 32  Note: 0x20 - SUB
End Process

Process called "FUNCT7_SLL" returns Integer:
    Return 0  Note: 0x00 - SLL
End Process

Process called "FUNCT7_SLT" returns Integer:
    Return 0  Note: 0x00 - SLT
End Process

Process called "FUNCT7_SLTU" returns Integer:
    Return 0  Note: 0x00 - SLTU
End Process

Process called "FUNCT7_XOR" returns Integer:
    Return 0  Note: 0x00 - XOR
End Process

Process called "FUNCT7_SRL" returns Integer:
    Return 0  Note: 0x00 - SRL
End Process

Process called "FUNCT7_SRA" returns Integer:
    Return 32  Note: 0x20 - SRA
End Process

Process called "FUNCT7_OR" returns Integer:
    Return 0  Note: 0x00 - OR
End Process

Process called "FUNCT7_AND" returns Integer:
    Return 0  Note: 0x00 - AND
End Process

Process called "FUNCT7_SLLIW" returns Integer:
    Return 0  Note: 0x00 - SLLIW
End Process

Process called "FUNCT7_SRLIW" returns Integer:
    Return 0  Note: 0x00 - SRLIW
End Process

Process called "FUNCT7_SRAIW" returns Integer:
    Return 32  Note: 0x20 - SRAIW
End Process

Process called "FUNCT7_ADDW" returns Integer:
    Return 0  Note: 0x00 - ADDW
End Process

Process called "FUNCT7_SUBW" returns Integer:
    Return 32  Note: 0x20 - SUBW
End Process

Process called "FUNCT7_SLLW" returns Integer:
    Return 0  Note: 0x00 - SLLW
End Process

Process called "FUNCT7_SRLW" returns Integer:
    Return 0  Note: 0x00 - SRLW
End Process

Process called "FUNCT7_SRAW" returns Integer:
    Return 32  Note: 0x20 - SRAW
End Process

Note: ============================================================================
Note: INSTRUCTION PROPERTIES
Note: ============================================================================

Process called "get_instruction_length" takes opcode as Integer returns Integer:
    Note: All RISC-V 64-bit instructions are 32 bits (4 bytes)
    Return 4
End Process

Process called "get_instruction_latency" takes opcode as Integer returns Integer:
    Note: Get typical instruction latency in cycles
    Note: Simplified latency model for RISC-V 64-bit
    
    If opcode is equal to 19 or opcode is equal to 27:
        Return 1  Note: I-type arithmetic/logical - 1 cycle
    End If
    
    If opcode is equal to 51 or opcode is equal to 59:
        Return 1  Note: R-type arithmetic/logical - 1 cycle
    End If
    
    If opcode is equal to 3:
        Return 3  Note: Load instructions - 3 cycles
    End If
    
    If opcode is equal to 35:
        Return 1  Note: Store instructions - 1 cycle
    End If
    
    If opcode is equal to 99:
        Return 2  Note: Branch instructions - 2 cycles (predicted)
    End If
    
    If opcode is equal to 111 or opcode is equal to 103:
        Return 2  Note: Jump instructions - 2 cycles
    End If
    
    If opcode is equal to 55:
        Return 1  Note: LUI - 1 cycle
    End If
    
    If opcode is equal to 23:
        Return 1  Note: AUIPC - 1 cycle
    End If
    
    Return 1  Note: Default latency
End Process

Process called "get_instruction_throughput" takes opcode as Integer returns Integer:
    Note: Get instruction throughput (instructions per cycle)
    Note: Simplified throughput model for RISC-V 64-bit
    
    If opcode is equal to 19 or opcode is equal to 27 or opcode is equal to 51 or opcode is equal to 59:
        Return 2  Note: Arithmetic/logical - 2 per cycle
    End If
    
    If opcode is equal to 3:
        Return 1  Note: Load instructions - 1 per cycle
    End If
    
    If opcode is equal to 35:
        Return 1  Note: Store instructions - 1 per cycle
    End If
    
    If opcode is equal to 99:
        Return 1  Note: Branch instructions - 1 per cycle
    End If
    
    If opcode is equal to 111 or opcode is equal to 103:
        Return 1  Note: Jump instructions - 1 per cycle
    End If
    
    Return 2  Note: Default throughput
End Process

Process called "is_load_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is a load operation
    Note: Returns 1 if load, 0 otherwise
    
    If opcode is equal to 3:
        Return 1  Note: Load instructions (LB, LH, LW, LD, LBU, LHU, LWU)
    End If
    
    Return 0
End Process

Process called "is_store_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is a store operation
    Note: Returns 1 if store, 0 otherwise
    
    If opcode is equal to 35:
        Return 1  Note: Store instructions (SB, SH, SW, SD)
    End If
    
    Return 0
End Process

Process called "is_branch_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is a branch operation
    Note: Returns 1 if branch, 0 otherwise
    
    If opcode is equal to 99:
        Return 1  Note: Branch instructions (BEQ, BNE, BLT, BGE, BLTU, BGEU)
    End If
    
    Return 0
End Process

Process called "is_jump_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is a jump operation
    Note: Returns 1 if jump, 0 otherwise
    
    If opcode is equal to 111 or opcode is equal to 103:
        Return 1  Note: Jump instructions (JAL, JALR)
    End If
    
    Return 0
End Process

Process called "is_arithmetic_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is an arithmetic operation
    Note: Returns 1 if arithmetic, 0 otherwise
    
    If opcode is equal to 19 or opcode is equal to 27 or opcode is equal to 51 or opcode is equal to 59:
        Return 1  Note: Arithmetic instructions (ADD, SUB, ADDI, ADDW, etc.)
    End If
    
    Return 0
End Process

Process called "is_logical_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is a logical operation
    Note: Returns 1 if logical, 0 otherwise
    
    If opcode is equal to 19 or opcode is equal to 27 or opcode is equal to 51 or opcode is equal to 59:
        Return 1  Note: Logical instructions (AND, OR, XOR, etc.)
    End If
    
    Return 0
End Process

Process called "is_shift_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is a shift operation
    Note: Returns 1 if shift, 0 otherwise
    
    If opcode is equal to 19 or opcode is equal to 27 or opcode is equal to 51 or opcode is equal to 59:
        Return 1  Note: Shift instructions (SLL, SRL, SRA, SLLW, SRLW, SRAW, etc.)
    End If
    
    Return 0
End Process

Process called "is_64bit_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction operates on 64-bit values
    Note: Returns 1 if 64-bit, 0 if 32-bit
    
    If opcode is equal to 27 or opcode is equal to 59:
        Return 0  Note: W-type instructions are 32-bit
    End If
    
    If opcode is equal to 19 or opcode is equal to 51:
        Return 1  Note: Standard instructions are 64-bit
    End If
    
    Return 1  Note: Default to 64-bit
End Process

Note: ============================================================================
Note: INSTRUCTION VALIDATION HELPERS
Note: ============================================================================

Process called "validate_register_number" takes reg_num as Integer returns Integer:
    Note: Validate RISC-V register number (0-31)
    Note: Returns 1 if valid, 0 if invalid
    
    If reg_num is greater than or equal to 0 and reg_num is less than or equal to 31:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Process called "validate_immediate_value" takes immediate as Integer, instruction_type as Integer returns Integer:
    Note: Validate immediate value for instruction type
    Note: Returns 1 if valid, 0 if invalid
    
    If instruction_type is equal to 1:
        Note: I-type instruction (12-bit signed immediate)
        If immediate is greater than or equal to -2048 and immediate is less than or equal to 2047:
            Return 1
        Otherwise:
            Return 0
        End If
    End If
    
    If instruction_type is equal to 2:
        Note: S-type instruction (12-bit signed immediate)
        If immediate is greater than or equal to -2048 and immediate is less than or equal to 2047:
            Return 1
        Otherwise:
            Return 0
        End If
    End If
    
    If instruction_type is equal to 3:
        Note: B-type instruction (13-bit signed immediate, 2-byte aligned)
        If immediate is greater than or equal to -4096 and immediate is less than or equal to 4094 and (immediate Modulo by 2) is equal to 0:
            Return 1
        Otherwise:
            Return 0
        End If
    End If
    
    If instruction_type is equal to 4:
        Note: U-type instruction (20-bit immediate)
        If immediate is greater than or equal to 0 and immediate is less than or equal to 1048575:
            Return 1
        Otherwise:
            Return 0
        End If
    End If
    
    If instruction_type is equal to 5:
        Note: J-type instruction (21-bit signed immediate, 2-byte aligned)
        If immediate is greater than or equal to -1048576 and immediate is less than or equal to 1048574 and (immediate Modulo by 2) is equal to 0:
            Return 1
        Otherwise:
            Return 0
        End If
    End If
    
    Return 0
End Process

Process called "validate_shift_amount" takes shift_amount as Integer, is_64bit as Integer returns Integer:
    Note: Validate shift amount for shift instructions
    Note: Returns 1 if valid, 0 if invalid
    
    If is_64bit is equal to 1:
        Note: 64-bit shift (0-63)
        If shift_amount is greater than or equal to 0 and shift_amount is less than or equal to 63:
            Return 1
        Otherwise:
            Return 0
        End If
    Otherwise:
        Note: 32-bit shift (0-31)
        If shift_amount is greater than or equal to 0 and shift_amount is less than or equal to 31:
            Return 1
        Otherwise:
            Return 0
        End If
    End If
End Process

Note: ============================================================================
Note: INSTRUCTION SELECTION HELPERS
Note: ============================================================================

Process called "select_add_instruction" takes has_immediate as Integer, is_64bit as Integer returns Integer:
    Note: Select appropriate ADD instruction variant
    Note: Returns opcode for selected instruction
    
    If has_immediate is equal to 1:
        If is_64bit is equal to 1:
            Return 19  Note: ADDI
        Otherwise:
            Return 27  Note: ADDIW
        End If
    Otherwise:
        If is_64bit is equal to 1:
            Return 51  Note: ADD
        Otherwise:
            Return 59  Note: ADDW
        End If
    End If
End Process

Process called "select_load_instruction" takes load_size as Integer returns Integer:
    Note: Select appropriate load instruction based on size
    Note: Returns opcode for selected instruction
    
    If load_size is equal to 1:
        Return 3  Note: LB or LBU
    End If
    
    If load_size is equal to 2:
        Return 3  Note: LH or LHU
    End If
    
    If load_size is equal to 4:
        Return 3  Note: LW or LWU
    End If
    
    If load_size is equal to 8:
        Return 3  Note: LD
    End If
    
    Return 3  Note: Default to LD
End Process

Process called "select_store_instruction" takes store_size as Integer returns Integer:
    Note: Select appropriate store instruction based on size
    Note: Returns opcode for selected instruction
    
    If store_size is equal to 1:
        Return 35  Note: SB
    End If
    
    If store_size is equal to 2:
        Return 35  Note: SH
    End If
    
    If store_size is equal to 4:
        Return 35  Note: SW
    End If
    
    If store_size is equal to 8:
        Return 35  Note: SD
    End If
    
    Return 35  Note: Default to SD
End Process

Process called "select_branch_instruction" takes condition as Integer returns Integer:
    Note: Select appropriate branch instruction based on condition
    Note: Returns opcode for selected instruction
    
    Return 99  Note: All branch instructions use same opcode (funct3 differs)
End Process

Process called "select_shift_instruction" takes has_immediate as Integer, is_64bit as Integer returns Integer:
    Note: Select appropriate shift instruction variant
    Note: Returns opcode for selected instruction
    
    If has_immediate is equal to 1:
        If is_64bit is equal to 1:
            Return 19  Note: SLLI, SRLI, SRAI
        Otherwise:
            Return 27  Note: SLLIW, SRLIW, SRAIW
        End If
    Otherwise:
        If is_64bit is equal to 1:
            Return 51  Note: SLL, SRL, SRA
        Otherwise:
            Return 59  Note: SLLW, SRLW, SRAW
        End If
    End If
End Process

Note: ============================================================================
Note: COMMON INSTRUCTION PATTERNS
Note: ============================================================================

Process called "get_move_instruction" returns Integer:
    Note: Get instruction for register-to-register move
    Note: ADDI with immediate 0
    Return 19  Note: ADDI
End Process

Process called "get_compare_instruction" takes has_immediate as Integer returns Integer:
    Note: Get instruction for comparison
    Note: Returns opcode for selected instruction
    
    If has_immediate is equal to 1:
        Return 19  Note: SLTI, SLTIU
    Otherwise:
        Return 51  Note: SLT, SLTU
    End If
End Process

Process called "get_logical_and_instruction" takes has_immediate as Integer returns Integer:
    Note: Get instruction for logical AND
    Note: Returns opcode for selected instruction
    
    If has_immediate is equal to 1:
        Return 19  Note: ANDI
    Otherwise:
        Return 51  Note: AND
    End If
End Process

Process called "get_logical_or_instruction" takes has_immediate as Integer returns Integer:
    Note: Get instruction for logical OR
    Note: Returns opcode for selected instruction
    
    If has_immediate is equal to 1:
        Return 19  Note: ORI
    Otherwise:
        Return 51  Note: OR
    End If
End Process

Process called "get_logical_xor_instruction" takes has_immediate as Integer returns Integer:
    Note: Get instruction for logical XOR
    Note: Returns opcode for selected instruction
    
    If has_immediate is equal to 1:
        Return 19  Note: XORI
    Otherwise:
        Return 51  Note: XOR
    End If
End Process

Process called "get_constant_load_instruction" returns Integer:
    Note: Get instruction for loading large constants
    Note: LUI for upper 20 bits
    Return 55  Note: LUI
End Process

Process called "get_word_instruction" takes base_opcode as Integer returns Integer:
    Note: Get 32-bit word variant of instruction
    Note: Returns opcode for word instruction
    
    If base_opcode is equal to 19:
        Return 27  Note: I-type to IW-type
    End If
    
    If base_opcode is equal to 51:
        Return 59  Note: R-type to RW-type
    End If
    
    Return base_opcode  Note: No word variant available
End Process

Note: ============================================================================
Note: OPTIMIZATION HINTS
Note: ============================================================================

Process called "can_fuse_with_next" takes opcode as Integer returns Integer:
    Note: Check if instruction can be fused with next instruction
    Note: Returns 1 if fusible, 0 otherwise
    
    If opcode is equal to 19 or opcode is equal to 27:
        Return 1  Note: I-type instructions can fuse with load/store
    End If
    
    If opcode is equal to 55:
        Return 1  Note: LUI can fuse with ADDI/ADDIW
    End If
    
    Return 0
End Process

Process called "prefer_immediate_form" takes opcode as Integer, immediate_value as Integer returns Integer:
    Note: Check if immediate form should be preferred
    Note: Returns 1 if immediate form preferred, 0 otherwise
    
    If opcode is equal to 51 or opcode is equal to 59:
        Note: R-type instruction - check if immediate form exists and is better
        If immediate_value is greater than or equal to -2048 and immediate_value is less than or equal to 2047:
            Return 1  Note: Use immediate form
        Otherwise:
            Return 0  Note: Use register form
        End If
    End If
    
    Return 0
End Process

Process called "get_instruction_category" takes opcode as Integer returns Integer:
    Note: Get instruction category for optimization
    Note: Returns category number
    
    If is_arithmetic_instruction(opcode) is equal to 1:
        Return 1  Note: Arithmetic
    End If
    
    If is_logical_instruction(opcode) is equal to 1:
        Return 2  Note: Logical
    End If
    
    If is_shift_instruction(opcode) is equal to 1:
        Return 3  Note: Shift
    End If
    
    If is_load_instruction(opcode) is equal to 1:
        Return 4  Note: Load
    End If
    
    If is_store_instruction(opcode) is equal to 1:
        Return 5  Note: Store
    End If
    
    If is_branch_instruction(opcode) is equal to 1:
        Return 6  Note: Branch
    End If
    
    If is_jump_instruction(opcode) is equal to 1:
        Return 7  Note: Jump
    End If
    
    Return 0  Note: Other
End Process

Process called "get_instruction_priority" takes opcode as Integer returns Integer:
    Note: Get instruction scheduling priority (higher = more important)
    Note: Returns priority value
    
    If is_load_instruction(opcode) is equal to 1:
        Return 10  Note: High priority for loads
    End If
    
    If is_branch_instruction(opcode) is equal to 1 or is_jump_instruction(opcode) is equal to 1:
        Return 8  Note: High priority for branches and jumps
    End If
    
    If is_arithmetic_instruction(opcode) is equal to 1:
        Return 5  Note: Medium priority for arithmetic
    End If
    
    If is_logical_instruction(opcode) is equal to 1 or is_shift_instruction(opcode) is equal to 1:
        Return 3  Note: Low priority for logical and shift
    End If
    
    If is_store_instruction(opcode) is equal to 1:
        Return 2  Note: Low priority for stores
    End If
    
    Return 1  Note: Default priority
End Process