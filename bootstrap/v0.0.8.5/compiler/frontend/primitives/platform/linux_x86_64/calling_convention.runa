Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
Linux x86_64 Calling Convention (System V ABI)

This file implements the System V x86_64 calling convention used on Linux, BSD, macOS,
and other Unix-like systems. This convention defines how functions receive parameters,
return values, manage the stack, and preserve registers.

System V x86_64 Calling Convention Summary:
- Integer/pointer arguments: RDI, RSI, RDX, RCX, R8, R9 (6 registers)
- Floating-point arguments: XMM0-XMM7 (8 registers)
- Additional arguments: Pushed on stack (right-to-left)
- Return value: RAX (integer/pointer), XMM0 (float)
- Stack alignment: 16-byte aligned before CALL instruction
- Caller-saved (volatile): RAX, RCX, RDX, RSI, RDI, R8-R11
- Callee-saved (non-volatile): RBX, RBP, R12-R15
- Frame pointer: RBP (optional)
- Stack pointer: RSP
- Red zone: 128 bytes below RSP (leaf functions can use without adjusting RSP)

Key rules:
1. Stack must be 16-byte aligned before every CALL instruction
2. Caller cleans up stack arguments after function returns
3. Callee must preserve RBX, RBP, R12-R15
4. Return values larger than 16 bytes: passed via hidden pointer in RDI

References:
- System V ABI x86_64 specification
- AMD64 Architecture Programmer's Manual
- Intel 64 and IA-32 Architectures Software Developer's Manual

Dependencies: registers.runa for register mappings
:End Note

Import "compiler/frontend/primitives/platform/linux_x86_64/registers.runa" as Registers
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Note: ============================================================================
Note: PARAMETER PASSING - INTEGER AND POINTER ARGUMENTS
Note: ============================================================================

Process called "get_integer_param_register" takes param_index as Integer returns Integer:
    Note: Get register number for integer/pointer parameter
    Note: System V ABI: RDI, RSI, RDX, RCX, R8, R9 (indices 0-5)
    Note: Returns register number (0-15), or -1 if passed on stack

    If param_index is equal to 0:
        Return 7  Note: RDI
    End If

    If param_index is equal to 1:
        Return 6  Note: RSI
    End If

    If param_index is equal to 2:
        Return 2  Note: RDX
    End If

    If param_index is equal to 3:
        Return 1  Note: RCX
    End If

    If param_index is equal to 4:
        Return 8  Note: R8
    End If

    If param_index is equal to 5:
        Return 9  Note: R9
    End If

    Note: Parameters 6+ are passed on stack
    Return -1
End Process

Process called "get_max_integer_register_params" returns Integer:
    Note: Maximum number of integer/pointer parameters passed in registers
    Return 6
End Process

Process called "is_param_in_register" takes param_index as Integer returns Integer:
    Note: Check if parameter is passed in register (vs stack)
    Note: Returns 1 if in register, 0 if on stack

    If param_index is less than 6:
        Return 1
    End If

    Return 0
End Process

Process called "get_stack_param_offset" takes param_index as Integer returns Integer:
    Note: Get stack offset for parameter passed on stack
    Note: Stack parameters start at [RSP + 8] (return address at [RSP])
    Note: param_index must be >= 6 (first 6 are in registers)

    If param_index is less than 6:
        Return 0  Note: Not a stack parameter
    End If

    Note: Calculate offset: 8 bytes per parameter, starting after return address
    Let stack_param_num be param_index minus 6
    Let offset be 8 plus (stack_param_num multiplied by 8)

    Return offset
End Process

Note: ============================================================================
Note: PARAMETER PASSING - FLOATING-POINT ARGUMENTS
Note: ============================================================================

Process called "get_float_param_register" takes param_index as Integer returns Integer:
    Note: Get XMM register number for floating-point parameter
    Note: System V ABI: XMM0-XMM7 (indices 0-7)
    Note: Returns XMM register number (16-31), or -1 if passed on stack

    If param_index is less than 8:
        Return proc get_xmm_param_register from Registers with param_index
    End If

    Note: Parameters 8+ are passed on stack
    Return -1
End Process

Process called "get_max_float_register_params" returns Integer:
    Note: Maximum number of floating-point parameters passed in XMM registers
    Return proc get_max_xmm_register_params from Registers  Note: Returns 8
End Process

Process called "is_float_param_in_register" takes param_index as Integer returns Integer:
    Note: Check if floating-point parameter is passed in register (vs stack)
    Note: Returns 1 if in register, 0 if on stack

    If param_index is less than 8:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: RETURN VALUE HANDLING
Note: ============================================================================

Process called "get_return_value_register" returns Integer:
    Note: Get register number for return value
    Note: Integer/pointer returns: RAX
    Return 0  Note: RAX
End Process

Process called "get_float_return_register" returns Integer:
    Note: Get register number for floating-point return value
    Note: Float/double returns: XMM0
    Return proc get_xmm_return_register from Registers  Note: Returns 16 (XMM0)
End Process

Process called "is_return_via_memory" takes return_size as Integer returns Integer:
    Note: Check if return value is passed via memory (hidden pointer)
    Note: Returns 1 if return via memory, 0 if in registers
    Note: System V ABI: Structures > 16 bytes returned via hidden pointer in RDI

    If return_size is greater than 16:
        Return 1  Note: Large structures returned via memory
    End If

    Return 0  Note: Return in registers
End Process

Note: ============================================================================
Note: REGISTER PRESERVATION (CALLER-SAVED vs CALLEE-SAVED)
Note: ============================================================================

Process called "is_caller_saved_register" takes reg_num as Integer returns Integer:
    Note: Check if register is caller-saved (volatile)
    Note: Caller-saved: RAX, RCX, RDX, RSI, RDI, R8-R11
    Note: Returns 1 if caller-saved, 0 if callee-saved

    Note: RAX (0)
    If reg_num is equal to 0:
        Return 1
    End If

    Note: RCX (1)
    If reg_num is equal to 1:
        Return 1
    End If

    Note: RDX (2)
    If reg_num is equal to 2:
        Return 1
    End If

    Note: RSI (6)
    If reg_num is equal to 6:
        Return 1
    End If

    Note: RDI (7)
    If reg_num is equal to 7:
        Return 1
    End If

    Note: R8 (8)
    If reg_num is equal to 8:
        Return 1
    End If

    Note: R9 (9)
    If reg_num is equal to 9:
        Return 1
    End If

    Note: R10 (10)
    If reg_num is equal to 10:
        Return 1
    End If

    Note: R11 (11)
    If reg_num is equal to 11:
        Return 1
    End If

    Return 0  Note: Callee-saved or special register
End Process

Process called "is_callee_saved_register" takes reg_num as Integer returns Integer:
    Note: Check if register is callee-saved (non-volatile)
    Note: Callee-saved: RBX, RBP, R12-R15
    Note: Returns 1 if callee-saved, 0 if caller-saved

    Note: RBX (3)
    If reg_num is equal to 3:
        Return 1
    End If

    Note: RBP (5)
    If reg_num is equal to 5:
        Return 1
    End If

    Note: R12 (12)
    If reg_num is equal to 12:
        Return 1
    End If

    Note: R13 (13)
    If reg_num is equal to 13:
        Return 1
    End If

    Note: R14 (14)
    If reg_num is equal to 14:
        Return 1
    End If

    Note: R15 (15)
    If reg_num is equal to 15:
        Return 1
    End If

    Return 0  Note: Caller-saved or special register
End Process

Process called "get_callee_saved_register_list" takes buffer_ptr as Integer returns Integer:
    Note: Fill buffer with list of callee-saved register numbers
    Note: buffer_ptr: pointer to array of at least 6 integers
    Note: Returns: count of callee-saved registers (6)

    Let offset be 0

    Note: Store register numbers in buffer (8 bytes per integer)
    Note: RBX (3)
    proc memory_set_int64 from Memory with buffer_ptr, offset, 3
    Set offset to offset plus 8

    Note: RBP (5)
    proc memory_set_int64 from Memory with buffer_ptr, offset, 5
    Set offset to offset plus 8

    Note: R12 (12)
    proc memory_set_int64 from Memory with buffer_ptr, offset, 12
    Set offset to offset plus 8

    Note: R13 (13)
    proc memory_set_int64 from Memory with buffer_ptr, offset, 13
    Set offset to offset plus 8

    Note: R14 (14)
    proc memory_set_int64 from Memory with buffer_ptr, offset, 14
    Set offset to offset plus 8

    Note: R15 (15)
    proc memory_set_int64 from Memory with buffer_ptr, offset, 15

    Return 6  Note: 6 callee-saved registers
End Process

Note: ============================================================================
Note: STACK FRAME MANAGEMENT
Note: ============================================================================

Process called "get_stack_alignment" returns Integer:
    Note: Get required stack alignment in bytes
    Note: System V ABI: 16-byte alignment before CALL
    Return 16
End Process

Process called "calculate_stack_frame_size" takes local_vars_size as Integer, num_callee_saved_regs as Integer returns Integer:
    Note: Calculate total stack frame size with proper alignment
    Note: local_vars_size: size of local variables in bytes
    Note: num_callee_saved_regs: number of callee-saved registers to preserve
    Note: Returns: total frame size (16-byte aligned)

    Note: Saved registers: 8 bytes each
    Let saved_regs_size be num_callee_saved_regs multiplied by 8

    Note: Total size before alignment
    Let total_size be local_vars_size plus saved_regs_size

    Note: Round up to 16-byte alignment
    Let remainder be total_size bitwise_and 15
    If remainder is not equal to 0:
        Let padding be 16 minus remainder
        Set total_size to total_size plus padding
    End If

    Return total_size
End Process

Process called "get_frame_pointer_register" returns Integer:
    Note: Get frame pointer register number
    Note: System V ABI: RBP (optional but recommended)
    Return 5  Note: RBP
End Process

Process called "get_stack_pointer_register" returns Integer:
    Note: Get stack pointer register number
    Note: System V ABI: RSP
    Return 4  Note: RSP
End Process

Process called "get_red_zone_size" returns Integer:
    Note: Get red zone size in bytes
    Note: System V ABI: 128 bytes below RSP can be used by leaf functions
    Note: Red zone cannot be used if function calls other functions
    Return 128
End Process

Process called "can_use_red_zone" takes is_leaf_function as Integer returns Integer:
    Note: Check if function can use red zone optimization
    Note: is_leaf_function: 1 if function makes no calls, 0 otherwise
    Note: Returns 1 if red zone can be used, 0 otherwise

    Note: Only leaf functions can use red zone
    If is_leaf_function is equal to 1:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: FUNCTION PROLOGUE AND EPILOGUE HELPERS
Note: ============================================================================

Process called "needs_frame_pointer" takes has_variable_sized_locals as Integer, has_alloca as Integer returns Integer:
    Note: Determine if function needs frame pointer
    Note: Frame pointer required for variable-sized locals or alloca
    Note: Returns 1 if frame pointer needed, 0 if can use RSP directly

    If has_variable_sized_locals is equal to 1:
        Return 1
    End If

    If has_alloca is equal to 1:
        Return 1
    End If

    Note: Frame pointer optional for fixed-size frames
    Note: Recommended for debugging, but not required
    Return 0
End Process

Process called "calculate_call_stack_adjustment" takes num_stack_args as Integer returns Integer:
    Note: Calculate stack space needed for outgoing call arguments
    Note: num_stack_args: number of arguments passed on stack (beyond first 6)
    Note: Returns: stack adjustment in bytes (16-byte aligned)

    If num_stack_args is less than or equal to 0:
        Return 0  Note: No stack arguments
    End If

    Note: Each argument is 8 bytes
    Let args_size be num_stack_args multiplied by 8

    Note: Round up to 16-byte alignment
    Let remainder be args_size bitwise_and 15
    If remainder is not equal to 0:
        Let padding be 16 minus remainder
        Set args_size to args_size plus padding
    End If

    Return args_size
End Process

Note: ============================================================================
Note: VARIADIC FUNCTION SUPPORT
Note: ============================================================================

Process called "get_variadic_gp_register_save_area_size" returns Integer:
    Note: Size of save area for general-purpose register arguments
    Note: System V ABI: 6 registers × 8 bytes = 48 bytes
    Return 48
End Process

Process called "get_variadic_fp_register_save_area_size" returns Integer:
    Note: Size of save area for floating-point register arguments
    Note: System V ABI: 8 XMM registers × 16 bytes = 128 bytes
    Return 128
End Process

Process called "get_variadic_total_save_area_size" returns Integer:
    Note: Total size for variadic function register save area
    Note: GP area (48) + FP area (128) = 176 bytes
    Return 176
End Process

Note: ============================================================================
Note: HELPER FUNCTIONS FOR CODE GENERATION
Note: ============================================================================

Process called "get_parameter_location" takes param_index as Integer, param_size as Integer, result_buffer as Integer returns Integer:
    Note: Get location (register or stack offset) for parameter
    Note: param_index: parameter position (0-based)
    Note: param_size: size in bytes (for future struct handling)
    Note: result_buffer: pointer to 2-integer array [location_type, value]
    Note: location_type: 0 = register (value = reg_num), 1 = stack (value = offset)
    Note: Returns: location_type

    Let location_type be 0
    Let value be 0

    Note: Check if parameter is in register
    If param_index is less than 6:
        Set location_type to 0  Note: Register
        Set value to get_integer_param_register(param_index)
    Otherwise:
        Set location_type to 1  Note: Stack
        Set value to get_stack_param_offset(param_index)
    End If

    Note: Write results to buffer
    proc memory_set_int64 from Memory with result_buffer, 0, location_type
    proc memory_set_int64 from Memory with result_buffer, 8, value

    Return location_type
End Process

Process called "get_call_setup_info" takes num_params as Integer, result_buffer as Integer returns Integer:
    Note: Get information needed to set up a function call
    Note: num_params: total number of parameters
    Note: result_buffer: pointer to 3-integer array [reg_params, stack_params, stack_adjustment]
    Note: Returns: number of stack parameters

    Let reg_params be 6
    Let stack_params be 0
    Let stack_adjustment be 0

    If num_params is less than or equal to 6:
        Set reg_params to num_params
    Otherwise:
        Set stack_params to num_params minus 6
        Set stack_adjustment to calculate_call_stack_adjustment(stack_params)
    End If

    Note: Write results to buffer
    proc memory_set_int64 from Memory with result_buffer, 0, reg_params
    proc memory_set_int64 from Memory with result_buffer, 8, stack_params
    proc memory_set_int64 from Memory with result_buffer, 16, stack_adjustment

    Return stack_params
End Process

Note: ============================================================================
Note: CALLING CONVENTION VALIDATION AND UTILITIES
Note: ============================================================================

Process called "validate_stack_alignment" takes stack_offset as Integer returns Integer:
    Note: Check if stack offset is properly aligned
    Note: Returns 1 if aligned to 16 bytes, 0 otherwise

    Let remainder be stack_offset bitwise_and 15
    If remainder is equal to 0:
        Return 1  Note: Properly aligned
    End If

    Return 0  Note: Misaligned
End Process

Process called "get_calling_convention_name" returns String:
    Note: Return name of calling convention
    Return "System V AMD64 ABI"
End Process

Process called "get_abi_version" returns Integer:
    Note: Return ABI version identifier
    Note: Using System V ABI version 1
    Return 1
End Process
