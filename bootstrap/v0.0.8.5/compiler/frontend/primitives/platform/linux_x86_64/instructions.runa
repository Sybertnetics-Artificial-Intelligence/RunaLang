Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
Linux x86_64 Instruction Set Metadata and Helpers

This file provides instruction metadata, opcode definitions, and helper functions
for x86_64 instruction selection, validation, and optimization.

This includes:
- Instruction opcode constants
- Instruction properties (length, latency, throughput)
- Instruction validation helpers
- Instruction selection helpers
- Common instruction patterns
- Optimization hints

This file does NOT perform actual instruction encoding (see machine_code.runa for that).
Instead, it provides metadata and helper functions for the code generator to make
intelligent decisions about which instructions to use and how to optimize them.

Dependencies:
- registers.runa for register metadata
- calling_convention.runa for ABI constraints
:End Note

Import "compiler/frontend/primitives/platform/linux_x86_64/registers.runa" as Registers

Note: ============================================================================
Note: INSTRUCTION OPCODE CONSTANTS
Note: ============================================================================
Note: Primary opcodes for common x86_64 instructions
Note: These are used by machine_code.runa for encoding

Process called "OPCODE_MOV" returns Integer:
    Return 137  Note: 0x89 - MOV r/m64, r64
End Process

Process called "OPCODE_MOVQ_IMM" returns Integer:
    Return 184  Note: 0xB8 - MOV r64, imm64 (base, add register)
End Process

Process called "OPCODE_ADD" returns Integer:
    Return 1  Note: 0x01 - ADD r/m64, r64
End Process

Process called "OPCODE_SUB" returns Integer:
    Return 41  Note: 0x29 - SUB r/m64, r64
End Process

Process called "OPCODE_IMUL_PREFIX" returns Integer:
    Return 15  Note: 0x0F - Two-byte opcode prefix
End Process

Process called "OPCODE_IMUL" returns Integer:
    Return 175  Note: 0xAF - IMUL r64, r/m64 (after 0x0F)
End Process

Process called "OPCODE_CMP" returns Integer:
    Return 57  Note: 0x39 - CMP r/m64, r64
End Process

Process called "OPCODE_JMP_REL8" returns Integer:
    Return 235  Note: 0xEB - JMP rel8
End Process

Process called "OPCODE_JMP_REL32" returns Integer:
    Return 233  Note: 0xE9 - JMP rel32
End Process

Process called "OPCODE_JE" returns Integer:
    Return 116  Note: 0x74 - JE rel8
End Process

Process called "OPCODE_JNE" returns Integer:
    Return 117  Note: 0x75 - JNE rel8
End Process

Process called "OPCODE_CALL" returns Integer:
    Return 232  Note: 0xE8 - CALL rel32
End Process

Process called "OPCODE_RET" returns Integer:
    Return 195  Note: 0xC3 - RET
End Process

Process called "OPCODE_PUSH" returns Integer:
    Return 80  Note: 0x50 - PUSH r64 (base, add register)
End Process

Process called "OPCODE_POP" returns Integer:
    Return 88  Note: 0x58 - POP r64 (base, add register)
End Process

Process called "OPCODE_SYSCALL_PREFIX" returns Integer:
    Return 15  Note: 0x0F - Two-byte opcode prefix
End Process

Process called "OPCODE_SYSCALL" returns Integer:
    Return 5  Note: 0x05 - SYSCALL (after 0x0F)
End Process

Process called "OPCODE_NOP" returns Integer:
    Return 144  Note: 0x90 - NOP
End Process

Note: ============================================================================
Note: INSTRUCTION PROPERTIES
Note: ============================================================================
Note: Instruction latency and throughput for optimization

Process called "get_instruction_latency" takes instruction_type as Integer returns Integer:
    Note: Get instruction latency in CPU cycles
    Note: instruction_type: 0=MOV, 1=ADD, 2=SUB, 3=IMUL, 4=CMP, 5=JMP, 6=CALL, 7=RET
    Note: Returns approximate latency on modern x86_64 CPUs

    Note: MOV - register to register
    If instruction_type is equal to 0:
        Return 1  Note: 1 cycle latency
    End If

    Note: ADD/SUB - integer arithmetic
    If instruction_type is equal to 1:
        Return 1  Note: 1 cycle latency
    End If

    If instruction_type is equal to 2:
        Return 1  Note: 1 cycle latency
    End If

    Note: IMUL - integer multiply
    If instruction_type is equal to 3:
        Return 3  Note: 3 cycle latency (modern CPUs)
    End If

    Note: CMP - comparison
    If instruction_type is equal to 4:
        Return 1  Note: 1 cycle latency
    End If

    Note: JMP - unconditional jump
    If instruction_type is equal to 5:
        Return 0  Note: Branch predictor handles this
    End If

    Note: CALL - function call
    If instruction_type is equal to 6:
        Return 2  Note: 2 cycles (push return address + jump)
    End If

    Note: RET - function return
    If instruction_type is equal to 7:
        Return 2  Note: 2 cycles (pop return address + jump)
    End If

    Return 1  Note: Default latency
End Process

Process called "get_instruction_throughput" takes instruction_type as Integer returns Integer:
    Note: Get instruction throughput (instructions per cycle)
    Note: Returns reciprocal throughput in 10ths (e.g., 5 = 0.5 instructions/cycle)
    Note: instruction_type: 0=MOV, 1=ADD, 2=SUB, 3=IMUL, 4=CMP, 5=JMP, 6=CALL, 7=RET

    Note: MOV - very high throughput (4 per cycle)
    If instruction_type is equal to 0:
        Return 25  Note: 0.25 cycles per instruction (4 per cycle)
    End If

    Note: ADD/SUB - high throughput (3-4 per cycle)
    If instruction_type is equal to 1:
        Return 33  Note: 0.33 cycles per instruction (3 per cycle)
    End If

    If instruction_type is equal to 2:
        Return 33  Note: 0.33 cycles per instruction (3 per cycle)
    End If

    Note: IMUL - moderate throughput (1 per cycle)
    If instruction_type is equal to 3:
        Return 100  Note: 1 cycle per instruction
    End If

    Note: CMP - high throughput (3 per cycle)
    If instruction_type is equal to 4:
        Return 33  Note: 0.33 cycles per instruction
    End If

    Note: JMP/CALL/RET - branch throughput
    If instruction_type is equal to 5:
        Return 100  Note: 1 per cycle (with good prediction)
    End If

    If instruction_type is equal to 6:
        Return 100  Note: 1 per cycle
    End If

    If instruction_type is equal to 7:
        Return 100  Note: 1 per cycle
    End If

    Return 100  Note: Default 1 per cycle
End Process

Note: ============================================================================
Note: INSTRUCTION SIZE CALCULATION
Note: ============================================================================

Process called "estimate_instruction_size" takes instruction_type as Integer, has_rex as Integer, has_modrm as Integer, has_displacement as Integer, has_immediate as Integer, opcode_bytes as Integer returns Integer:
    Note: Estimate encoded instruction size in bytes
    Note: instruction_type: instruction category
    Note: has_rex: 1 if REX prefix needed, 0 otherwise
    Note: has_modrm: 1 if ModR/M byte needed, 0 otherwise
    Note: has_displacement: displacement size (0, 1, 4 bytes)
    Note: has_immediate: immediate size (0, 1, 2, 4, 8 bytes)
    Note: opcode_bytes: opcode size (1 for single-byte, 2 for 0F prefix, 3 for 0F 38/0F 3A)
    Note: Returns: estimated size in bytes

    Let size be 0

    Note: REX prefix (1 byte)
    If has_rex is equal to 1:
        Set size to size plus 1
    End If

    Note: Opcode (1-3 bytes depending on instruction)
    Note: 1-byte opcodes: MOV (89h), ADD (01h), SUB (29h), PUSH (50h), POP (58h), RET (C3h)
    Note: 2-byte opcodes: IMUL (0F AFh), SYSCALL (0F 05h), conditional moves
    Note: 3-byte opcodes: Some SSE/AVX instructions (0F 38 xx, 0F 3A xx)
    Set size to size plus opcode_bytes

    Note: ModR/M byte (1 byte)
    If has_modrm is equal to 1:
        Set size to size plus 1
    End If

    Note: Displacement
    Set size to size plus has_displacement

    Note: Immediate
    Set size to size plus has_immediate

    Return size
End Process

Process called "get_opcode_size" takes instruction_type as Integer returns Integer:
    Note: Get opcode size for instruction type
    Note: instruction_type: 0=MOV, 1=ADD, 2=SUB, 3=IMUL, 4=CMP, 5=JMP, 6=CALL, 7=RET
    Note: Returns: opcode size in bytes

    Note: MOV - 1-byte opcode (89h for r/m64, r64)
    If instruction_type is equal to 0:
        Return 1
    End If

    Note: ADD - 1-byte opcode (01h)
    If instruction_type is equal to 1:
        Return 1
    End If

    Note: SUB - 1-byte opcode (29h)
    If instruction_type is equal to 2:
        Return 1
    End If

    Note: IMUL - 2-byte opcode (0F AFh)
    If instruction_type is equal to 3:
        Return 2
    End If

    Note: CMP - 1-byte opcode (39h)
    If instruction_type is equal to 4:
        Return 1
    End If

    Note: JMP - 1-byte opcode (EBh for rel8, E9h for rel32)
    If instruction_type is equal to 5:
        Return 1
    End If

    Note: CALL - 1-byte opcode (E8h)
    If instruction_type is equal to 6:
        Return 1
    End If

    Note: RET - 1-byte opcode (C3h)
    If instruction_type is equal to 7:
        Return 1
    End If

    Note: Default: 1-byte opcode
    Return 1
End Process

Process called "get_min_instruction_size" returns Integer:
    Note: Minimum x86_64 instruction size
    Return 1  Note: Single-byte instructions exist (e.g., RET, NOP)
End Process

Process called "get_max_instruction_size" returns Integer:
    Note: Maximum x86_64 instruction size
    Return 15  Note: x86_64 maximum instruction length
End Process

Note: ============================================================================
Note: INSTRUCTION VALIDATION
Note: ============================================================================

Process called "is_valid_immediate_size" takes size as Integer returns Integer:
    Note: Check if immediate size is valid
    Note: Valid sizes: 1, 2, 4, 8 bytes
    Note: Returns 1 if valid, 0 otherwise

    If size is equal to 1:
        Return 1
    End If

    If size is equal to 2:
        Return 1
    End If

    If size is equal to 4:
        Return 1
    End If

    If size is equal to 8:
        Return 1
    End If

    Return 0
End Process

Process called "is_valid_displacement_size" takes size as Integer returns Integer:
    Note: Check if displacement size is valid
    Note: Valid sizes: 0, 1, 4 bytes
    Note: Returns 1 if valid, 0 otherwise

    If size is equal to 0:
        Return 1  Note: No displacement
    End If

    If size is equal to 1:
        Return 1  Note: 8-bit displacement
    End If

    If size is equal to 4:
        Return 1  Note: 32-bit displacement
    End If

    Return 0
End Process

Process called "can_use_short_jump" takes offset as Integer returns Integer:
    Note: Check if offset fits in 8-bit relative jump (rel8)
    Note: Range: -128 to +127
    Note: Returns 1 if short jump possible, 0 if need rel32

    If offset is greater than or equal to -128:
        If offset is less than or equal to 127:
            Return 1
        End If
    End If

    Return 0
End Process

Note: ============================================================================
Note: INSTRUCTION SELECTION HELPERS
Note: ============================================================================

Process called "should_use_lea_for_addition" takes base_reg as Integer, offset as Integer, needs_flags as Integer returns Integer:
    Note: Check if LEA is better than ADD for address calculation
    Note: LEA advantages: Doesn't modify flags, can compute in one instruction
    Note: ADD advantages: Shorter encoding (no displacement), modifies in-place
    Note: base_reg: base register number
    Note: offset: constant offset to add
    Note: needs_flags: 1 if caller needs flags preserved, 0 otherwise
    Note: Returns 1 if LEA recommended, 0 if ADD is better

    Note: If offset is zero, no operation needed
    If offset is equal to 0:
        Return 0  Note: No instruction needed
    End If

    Note: If flags must be preserved, LEA is required
    If needs_flags is equal to 1:
        Return 1  Note: LEA doesn't modify flags
    End If

    Note: For small offsets (1-8), ADD with immediate is shorter
    Note: ADD r64, imm8 is 4 bytes: REX + opcode + ModR/M + imm8
    Note: LEA r64, [r64 + disp8] is 4 bytes: REX + opcode + ModR/M + disp8
    Note: So encoding size is equal for disp8 range

    Note: Check if offset fits in 8-bit signed displacement
    If offset is greater than or equal to -128:
        If offset is less than or equal to 127:
            Note: Fits in disp8 - LEA and ADD are same size
            Note: LEA is preferred because it doesn't clobber flags
            Note: and allows result in different register
            Return 1
        End If
    End If

    Note: For larger offsets, need 32-bit displacement
    Note: ADD r64, imm32 is 7 bytes: REX + opcode + ModR/M + imm32
    Note: LEA r64, [r64 + disp32] is 7 bytes: REX + opcode + ModR/M + disp32
    Note: Both are same size, but LEA preserves flags
    Return 1  Note: LEA preferred for flag preservation
End Process

Process called "should_use_imul_immediate" takes multiplier as Integer returns Integer:
    Note: Check if immediate form of IMUL is beneficial
    Note: IMUL with immediate is 3-operand: IMUL r64, r/m64, imm
    Note: Returns 1 if immediate form recommended, 0 otherwise

    Note: Small multipliers benefit from immediate form
    If multiplier is greater than or equal to -128:
        If multiplier is less than or equal to 127:
            Return 1  Note: Fits in imm8
        End If
    End If

    If multiplier is greater than or equal to -32768:
        If multiplier is less than or equal to 32767:
            Return 1  Note: Fits in imm16
        End If
    End If

    Return 0
End Process

Process called "should_inline_small_memcpy" takes size as Integer returns Integer:
    Note: Check if small memcpy should be inlined vs calling function
    Note: Inline is better for small, fixed-size copies
    Note: Returns 1 if inline recommended, 0 if call function

    Note: Inline for sizes up to 64 bytes
    If size is less than or equal to 64:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: OPTIMIZATION PATTERNS
Note: ============================================================================

Process called "can_eliminate_redundant_move" takes src_reg as Integer, dest_reg as Integer returns Integer:
    Note: Check if MOV can be eliminated (src == dest)
    Note: Returns 1 if redundant, 0 otherwise

    If src_reg is equal to dest_reg:
        Return 1  Note: Redundant move
    End If

    Return 0
End Process

Process called "can_use_xor_for_zero" takes value as Integer returns Integer:
    Note: Check if XOR reg, reg is better than MOV reg, 0
    Note: XOR is shorter and breaks dependency chains
    Note: Returns 1 if XOR recommended, 0 otherwise

    If value is equal to 0:
        Return 1  Note: XOR is better for zeroing
    End If

    Return 0
End Process

Process called "can_combine_shifts" takes shift1 as Integer, shift2 as Integer returns Integer:
    Note: Check if two consecutive shifts can be combined
    Note: Returns 1 if combinable, 0 otherwise

    Note: Same direction shifts can be combined
    Note: shift1 and shift2 are shift amounts
    Let total_shift be shift1 plus shift2

    Note: Check if combined shift is valid (< 64 bits)
    If total_shift is less than 64:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: INSTRUCTION CATEGORIES
Note: ============================================================================

Process called "INSTR_CATEGORY_DATA_MOVEMENT" returns Integer:
    Return 0  Note: MOV, LEA, PUSH, POP
End Process

Process called "INSTR_CATEGORY_ARITHMETIC" returns Integer:
    Return 1  Note: ADD, SUB, IMUL, IDIV
End Process

Process called "INSTR_CATEGORY_LOGICAL" returns Integer:
    Return 2  Note: AND, OR, XOR, NOT
End Process

Process called "INSTR_CATEGORY_CONTROL_FLOW" returns Integer:
    Return 3  Note: JMP, JCC, CALL, RET
End Process

Process called "INSTR_CATEGORY_COMPARISON" returns Integer:
    Return 4  Note: CMP, TEST
End Process

Process called "INSTR_CATEGORY_STACK" returns Integer:
    Return 5  Note: PUSH, POP
End Process

Process called "INSTR_CATEGORY_SYSTEM" returns Integer:
    Return 6  Note: SYSCALL, SYSRET
End Process

Note: ============================================================================
Note: INSTRUCTION FLAGS
Note: ============================================================================

Process called "instruction_modifies_flags" takes instruction_category as Integer returns Integer:
    Note: Check if instruction modifies CPU flags (ZF, SF, OF, CF, etc.)
    Note: Returns 1 if modifies flags, 0 otherwise

    Note: Data movement does NOT modify flags
    If instruction_category is equal to 0:
        Return 0  Note: MOV, LEA, PUSH, POP
    End If

    Note: Arithmetic DOES modify flags
    If instruction_category is equal to 1:
        Return 1  Note: ADD, SUB, IMUL, etc.
    End If

    Note: Logical operations DO modify flags
    If instruction_category is equal to 2:
        Return 1  Note: AND, OR, XOR
    End If

    Note: Control flow uses flags but doesn't modify (JCC reads flags)
    If instruction_category is equal to 3:
        Return 0  Note: JMP, CALL, RET
    End If

    Note: Comparison DOES modify flags
    If instruction_category is equal to 4:
        Return 1  Note: CMP, TEST
    End If

    Note: Stack operations do NOT modify flags
    If instruction_category is equal to 5:
        Return 0  Note: PUSH, POP
    End If

    Note: System operations do NOT modify flags
    If instruction_category is equal to 6:
        Return 0  Note: SYSCALL
    End If

    Return 0  Note: Default: no modification
End Process

Process called "instruction_reads_flags" takes instruction_category as Integer returns Integer:
    Note: Check if instruction reads CPU flags
    Note: Returns 1 if reads flags, 0 otherwise

    Note: Conditional jumps READ flags
    If instruction_category is equal to 3:
        Return 1  Note: JCC (conditional jumps)
    End If

    Return 0  Note: Most instructions don't read flags
End Process

Note: ============================================================================
Note: PERFORMANCE HINTS
Note: ============================================================================

Process called "get_preferred_nop_size" takes size as Integer returns Integer:
    Note: Get optimal multi-byte NOP encoding for padding
    Note: Modern x86_64 CPUs decode multi-byte NOPs efficiently
    Note: Intel recommends specific multi-byte NOP sequences
    Note: size: desired padding in bytes (1-15)
    Note: Returns: recommended NOP encoding size for this iteration

    Note: x86_64 supports NOPs from 1-15 bytes
    Note: Use largest possible NOP to minimize instruction count

    Note: Validate input range
    If size is less than 1:
        Return 1  Note: Minimum 1-byte NOP
    End If

    If size is greater than 15:
        Return 15  Note: Maximum 15-byte NOP
    End If

    Note: Return exact size requested - use multi-byte NOP
    Note: 1-byte: 90 (NOP)
    Note: 2-byte: 66 90 (data16 NOP)
    Note: 3-byte: 0F 1F 00 (NOP DWORD ptr [EAX])
    Note: 4-byte: 0F 1F 40 00 (NOP DWORD ptr [EAX + 0])
    Note: 5-byte: 0F 1F 44 00 00 (NOP DWORD ptr [EAX + EAX*1 + 0])
    Note: 6-byte: 66 0F 1F 44 00 00 (data16 NOP DWORD ptr [EAX + EAX*1 + 0])
    Note: 7-byte: 0F 1F 80 00 00 00 00 (NOP DWORD ptr [EAX + 0x00000000])
    Note: 8-byte: 0F 1F 84 00 00 00 00 00 (NOP DWORD ptr [EAX + EAX*1 + 0x00000000])
    Note: 9-byte: 66 0F 1F 84 00 00 00 00 00 (data16 NOP DWORD ptr [EAX + EAX*1 + 0x00000000])
    Note: 10-byte: 66 66 0F 1F 84 00 00 00 00 00 (two data16 prefixes)
    Note: 11-byte: 66 66 66 0F 1F 84 00 00 00 00 00 (three data16 prefixes)
    Note: 12-byte: 66 66 66 66 0F 1F 84 00 00 00 00 00 (four data16 prefixes)
    Note: 13-byte: 66 66 66 66 66 0F 1F 84 00 00 00 00 00 (five data16 prefixes)
    Note: 14-byte: 66 66 66 66 66 66 0F 1F 84 00 00 00 00 00 (six data16 prefixes)
    Note: 15-byte: 66 66 66 66 66 66 66 0F 1F 84 00 00 00 00 00 (seven data16 prefixes)

    Return size  Note: Use exact size requested with appropriate multi-byte NOP
End Process

Process called "should_align_loop_target" takes loop_size as Integer, iteration_count as Integer returns Integer:
    Note: Determine if loop should be aligned based on size and iteration count
    Note: Loop alignment improves instruction fetch and branch prediction
    Note: But adds code size overhead from padding
    Note: loop_size: loop body size in bytes
    Note: iteration_count: expected iteration count (-1 if unknown)
    Note: Returns 1 if alignment recommended, 0 otherwise

    Note: Cost-benefit analysis for alignment:
    Note: Benefit: Improved fetch/decode, better branch prediction
    Note: Cost: Code size increase from padding (up to 15 bytes)

    Note: Don't align tiny loops (< 8 bytes) - alignment overhead too high
    If loop_size is less than 8:
        Return 0  Note: Too small to benefit
    End If

    Note: If iteration count is known and high, definitely align
    If iteration_count is greater than or equal to 100:
        Return 1  Note: High iteration count justifies alignment cost
    End If

    Note: For medium-sized loops (8-32 bytes), align if iterations unknown or >= 10
    If loop_size is less than or equal to 32:
        If iteration_count is equal to -1:
            Return 1  Note: Unknown iterations, assume benefit
        End If

        If iteration_count is greater than or equal to 10:
            Return 1  Note: Enough iterations to amortize cost
        End If

        Return 0  Note: Too few iterations
    End If

    Note: For large loops (> 32 bytes), always align
    Note: Large loops benefit from alignment regardless of iteration count
    Return 1  Note: Large loop bodies benefit from fetch optimization
End Process

Process called "get_recommended_alignment" takes alignment_type as Integer returns Integer:
    Note: Get recommended alignment for different code structures
    Note: alignment_type: 0=function entry, 1=loop target, 2=hot path, 3=cold path
    Note: Returns: alignment in bytes

    Note: Function entry points (0)
    If alignment_type is equal to 0:
        Note: 16-byte alignment for function entry
        Note: Benefits: Better instruction fetch, cache line alignment
        Note: Intel/AMD recommend 16-byte alignment for functions
        Return 16
    End If

    Note: Loop targets (1)
    If alignment_type is equal to 1:
        Note: 16-byte alignment for loop targets
        Note: Critical for performance - loop entry is hot path
        Note: Ensures loop doesn't span cache lines unnecessarily
        Return 16
    End If

    Note: Hot path branch targets (2)
    If alignment_type is equal to 2:
        Note: 16-byte alignment for frequently executed branches
        Note: Similar benefits to loop alignment
        Return 16
    End If

    Note: Cold path branch targets (3)
    If alignment_type is equal to 3:
        Note: No alignment for cold paths
        Note: Save code size - these rarely execute
        Return 1  Note: No alignment
    End If

    Note: Default: 16-byte alignment
    Return 16
End Process
