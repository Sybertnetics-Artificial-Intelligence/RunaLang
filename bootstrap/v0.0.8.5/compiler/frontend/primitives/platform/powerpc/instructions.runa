Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
PowerPC 64-bit Instruction Set Metadata and Helpers

This file provides instruction metadata, opcode definitions, and helper functions
for PowerPC 64-bit instruction selection, validation, and optimization.

PowerPC 64-bit Key Characteristics:
- Fixed 32-bit (4-byte) instruction length (RISC architecture)
- Load/store architecture (memory access only via LWZ/STW, LD/STD)
- Three-operand instructions (dest can differ from sources)
- Condition register (CR) for condition codes
- Branch prediction hints
- 64-bit register operations with 32-bit compatibility

PowerPC 64-bit Instruction Formats:
- I-type: Immediate operations (opcode + rs + rd + immediate)
- B-type: Branch operations (opcode + BO + BI + BD/AA/LK)
- D-type: Load/store with displacement (opcode + rs + rd + displacement)
- X-type: Register operations (opcode + rs + rt + rd + XO + Rc)
- A-type: Arithmetic/logical with immediate (opcode + rs + rd + immediate + OE + Rc)

This includes:
- Instruction opcode patterns
- Instruction properties (latency, throughput)
- Instruction validation helpers
- Instruction selection helpers
- Common instruction patterns
- Optimization hints

IMPORTANT: PowerPC 64-bit instruction set is IDENTICAL across platforms (Linux, AIX, etc).
Platform differences are in calling convention and syscalls, NOT instruction encoding.

This file does NOT perform actual instruction encoding (see machine_code.runa for that).
Instead, it provides metadata and helper functions for the code generator to make
intelligent decisions about which instructions to use and how to optimize them.

Dependencies:
- registers.runa for register metadata
- calling_convention.runa for ABI constraints
:End Note

Import "compiler/frontend/primitives/platform/powerpc/registers.runa" as Registers

Note: ============================================================================
Note: INSTRUCTION OPCODE PATTERNS (PowerPC 64-bit)
Note: ============================================================================

Note: Primary opcodes for PowerPC 64-bit instructions
Process called "OPCODE_ADD" returns Integer:
    Return 31  Note: X-form instruction
End Process

Process called "OPCODE_ADDI" returns Integer:
    Return 14  Note: D-form instruction
End Process

Process called "OPCODE_ADDIS" returns Integer:
    Return 15  Note: D-form instruction
End Process

Process called "OPCODE_AND" returns Integer:
    Return 31  Note: X-form instruction
End Process

Process called "OPCODE_ANDI" returns Integer:
    Return 28  Note: D-form instruction
End Process

Process called "OPCODE_ANDIS" returns Integer:
    Return 29  Note: D-form instruction
End Process

Process called "OPCODE_B" returns Integer:
    Return 18  Note: I-form instruction
End Process

Process called "OPCODE_BC" returns Integer:
    Return 16  Note: B-form instruction
End Process

Process called "OPCODE_CMP" returns Integer:
    Return 31  Note: X-form instruction
End Process

Process called "OPCODE_CMPI" returns Integer:
    Return 11  Note: D-form instruction
End Process

Process called "OPCODE_LD" returns Integer:
    Return 58  Note: DS-form instruction (64-bit load)
End Process

Process called "OPCODE_LWZ" returns Integer:
    Return 32  Note: D-form instruction (32-bit load)
End Process

Process called "OPCODE_MR" returns Integer:
    Return 31  Note: X-form instruction (OR with r0)
End Process

Process called "OPCODE_OR" returns Integer:
    Return 31  Note: X-form instruction
End Process

Process called "OPCODE_ORI" returns Integer:
    Return 24  Note: D-form instruction
End Process

Process called "OPCODE_ORIS" returns Integer:
    Return 25  Note: D-form instruction
End Process

Process called "OPCODE_STD" returns Integer:
    Return 62  Note: DS-form instruction (64-bit store)
End Process

Process called "OPCODE_STW" returns Integer:
    Return 36  Note: D-form instruction (32-bit store)
End Process

Process called "OPCODE_SUB" returns Integer:
    Return 31  Note: X-form instruction
End Process

Process called "OPCODE_XOR" returns Integer:
    Return 31  Note: X-form instruction
End Process

Process called "OPCODE_XORI" returns Integer:
    Return 26  Note: D-form instruction
End Process

Note: ============================================================================
Note: INSTRUCTION EXTENDED OPCODES (XO field for X-form instructions)
Note: ============================================================================

Process called "XO_ADD" returns Integer:
    Return 266  Note: 0x10A - ADD instruction
End Process

Process called "XO_ADD_DOT" returns Integer:
    Return 266  Note: 0x10A - ADD. instruction (with Rc=1)
End Process

Process called "XO_AND" returns Integer:
    Return 28  Note: 0x1C - AND instruction
End Process

Process called "XO_AND_DOT" returns Integer:
    Return 28  Note: 0x1C - AND. instruction (with Rc=1)
End Process

Process called "XO_CMP" returns Integer:
    Return 0  Note: 0x00 - CMP instruction
End Process

Process called "XO_MR" returns Integer:
    Return 444  Note: 0x1BC - OR instruction (MR is OR with r0)
End Process

Process called "XO_OR" returns Integer:
    Return 444  Note: 0x1BC - OR instruction
End Process

Process called "XO_OR_DOT" returns Integer:
    Return 444  Note: 0x1BC - OR. instruction (with Rc=1)
End Process

Process called "XO_SUB" returns Integer:
    Return 40  Note: 0x28 - SUB instruction
End Process

Process called "XO_SUB_DOT" returns Integer:
    Return 40  Note: 0x28 - SUB. instruction (with Rc=1)
End Process

Process called "XO_XOR" returns Integer:
    Return 316  Note: 0x13C - XOR instruction
End Process

Process called "XO_XOR_DOT" returns Integer:
    Return 316  Note: 0x13C - XOR. instruction (with Rc=1)
End Process

Note: ============================================================================
Note: INSTRUCTION PROPERTIES
Note: ============================================================================

Process called "get_instruction_length" takes opcode as Integer returns Integer:
    Note: All PowerPC instructions are 32 bits (4 bytes)
    Return 4
End Process

Process called "get_instruction_latency" takes opcode as Integer returns Integer:
    Note: Get typical instruction latency in cycles
    Note: Simplified latency model for PowerPC 64-bit
    
    If opcode is equal to 14 or opcode is equal to 15:
        Return 1  Note: ADDI, ADDIS - 1 cycle
    End If
    
    If opcode is equal to 18:
        Return 1  Note: B - 1 cycle (predicted)
    End If
    
    If opcode is equal to 16:
        Return 2  Note: BC - 2 cycles (conditional)
    End If
    
    If opcode is equal to 32 or opcode is equal to 36:
        Return 3  Note: LWZ, STW - 3 cycles
    End If
    
    If opcode is equal to 58 or opcode is equal to 62:
        Return 3  Note: LD, STD - 3 cycles
    End If
    
    If opcode is equal to 31:
        Return 1  Note: X-form arithmetic/logical - 1 cycle
    End If
    
    Return 2  Note: Default latency
End Process

Process called "get_instruction_throughput" takes opcode as Integer returns Integer:
    Note: Get instruction throughput (instructions per cycle)
    Note: Simplified throughput model for PowerPC 64-bit
    
    If opcode is equal to 14 or opcode is equal to 15:
        Return 2  Note: ADDI, ADDIS - 2 per cycle
    End If
    
    If opcode is equal to 18:
        Return 1  Note: B - 1 per cycle
    End If
    
    If opcode is equal to 16:
        Return 1  Note: BC - 1 per cycle
    End If
    
    If opcode is equal to 32 or opcode is equal to 36:
        Return 1  Note: LWZ, STW - 1 per cycle
    End If
    
    If opcode is equal to 58 or opcode is equal to 62:
        Return 1  Note: LD, STD - 1 per cycle
    End If
    
    If opcode is equal to 31:
        Return 2  Note: X-form arithmetic/logical - 2 per cycle
    End If
    
    Return 1  Note: Default throughput
End Process

Process called "is_load_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is a load operation
    Note: Returns 1 if load, 0 otherwise
    
    If opcode is equal to 32 or opcode is equal to 58:
        Return 1  Note: LWZ, LD
    End If
    
    Return 0
End Process

Process called "is_store_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is a store operation
    Note: Returns 1 if store, 0 otherwise
    
    If opcode is equal to 36 or opcode is equal to 62:
        Return 1  Note: STW, STD
    End If
    
    Return 0
End Process

Process called "is_branch_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is a branch operation
    Note: Returns 1 if branch, 0 otherwise
    
    If opcode is equal to 18 or opcode is equal to 16:
        Return 1  Note: B, BC
    End If
    
    Return 0
End Process

Process called "is_arithmetic_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is an arithmetic operation
    Note: Returns 1 if arithmetic, 0 otherwise
    
    If opcode is equal to 14 or opcode is equal to 15 or opcode is equal to 31:
        Return 1  Note: ADDI, ADDIS, X-form arithmetic
    End If
    
    Return 0
End Process

Process called "is_logical_instruction" takes opcode as Integer returns Integer:
    Note: Check if instruction is a logical operation
    Note: Returns 1 if logical, 0 otherwise
    
    If opcode is equal to 24 or opcode is equal to 25 or opcode is equal to 26 or opcode is equal to 28 or opcode is equal to 29 or opcode is equal to 31:
        Return 1  Note: ORI, ORIS, XORI, ANDI, ANDIS, X-form logical
    End If
    
    Return 0
End Process

Note: ============================================================================
Note: INSTRUCTION VALIDATION HELPERS
Note: ============================================================================

Process called "validate_register_number" takes reg_num as Integer returns Integer:
    Note: Validate PowerPC register number (0-31)
    Note: Returns 1 if valid, 0 if invalid
    
    If reg_num is greater than or equal to 0 and reg_num is less than or equal to 31:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Process called "validate_immediate_value" takes immediate as Integer, instruction_type as Integer returns Integer:
    Note: Validate immediate value for instruction type
    Note: Returns 1 if valid, 0 if invalid
    
    If instruction_type is equal to 1:
        Note: D-form instruction (16-bit signed immediate)
        If immediate is greater than or equal to -32768 and immediate is less than or equal to 32767:
            Return 1
        Otherwise:
            Return 0
        End If
    End If
    
    If instruction_type is equal to 2:
        Note: I-form instruction (24-bit signed immediate)
        If immediate is greater than or equal to -8388608 and immediate is less than or equal to 8388607:
            Return 1
        Otherwise:
            Return 0
        End If
    End If
    
    Return 0
End Process

Process called "validate_displacement" takes displacement as Integer returns Integer:
    Note: Validate displacement for load/store instructions
    Note: Returns 1 if valid, 0 if invalid
    
    Note: D-form: 16-bit signed displacement
    If displacement is greater than or equal to -32768 and displacement is less than or equal to 32767:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Process called "validate_condition_register" takes cr_num as Integer returns Integer:
    Note: Validate condition register number (0-7)
    Note: Returns 1 if valid, 0 if invalid
    
    If cr_num is greater than or equal to 0 and cr_num is less than or equal to 7:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Note: ============================================================================
Note: INSTRUCTION SELECTION HELPERS
Note: ============================================================================

Process called "select_add_instruction" takes has_immediate as Integer, immediate_value as Integer returns Integer:
    Note: Select appropriate ADD instruction variant
    Note: Returns opcode for selected instruction
    
    If has_immediate is equal to 1:
        If immediate_value is greater than or equal to -32768 and immediate_value is less than or equal to 32767:
            Return 14  Note: ADDI
        Otherwise:
            Return 15  Note: ADDIS (for high 16 bits)
        End If
    Otherwise:
        Return 31  Note: ADD (X-form)
    End If
End Process

Process called "select_load_instruction" takes is_64bit as Integer returns Integer:
    Note: Select appropriate load instruction
    Note: Returns opcode for selected instruction
    
    If is_64bit is equal to 1:
        Return 58  Note: LD (64-bit)
    Otherwise:
        Return 32  Note: LWZ (32-bit)
    End If
End Process

Process called "select_store_instruction" takes is_64bit as Integer returns Integer:
    Note: Select appropriate store instruction
    Note: Returns opcode for selected instruction
    
    If is_64bit is equal to 1:
        Return 62  Note: STD (64-bit)
    Otherwise:
        Return 36  Note: STW (32-bit)
    End If
End Process

Process called "select_branch_instruction" takes is_conditional as Integer returns Integer:
    Note: Select appropriate branch instruction
    Note: Returns opcode for selected instruction
    
    If is_conditional is equal to 1:
        Return 16  Note: BC (conditional branch)
    Otherwise:
        Return 18  Note: B (unconditional branch)
    End If
End Process

Note: ============================================================================
Note: COMMON INSTRUCTION PATTERNS
Note: ============================================================================

Process called "get_move_instruction" returns Integer:
    Note: Get instruction for register-to-register move
    Note: MR is implemented as OR with r0
    Return 31  Note: X-form with OR operation
End Process

Process called "get_compare_instruction" takes has_immediate as Integer returns Integer:
    Note: Get instruction for comparison
    Note: Returns opcode for selected instruction
    
    If has_immediate is equal to 1:
        Return 11  Note: CMPI
    Otherwise:
        Return 31  Note: CMP (X-form)
    End If
End Process

Process called "get_logical_and_instruction" takes has_immediate as Integer returns Integer:
    Note: Get instruction for logical AND
    Note: Returns opcode for selected instruction
    
    If has_immediate is equal to 1:
        Return 28  Note: ANDI
    Otherwise:
        Return 31  Note: AND (X-form)
    End If
End Process

Process called "get_logical_or_instruction" takes has_immediate as Integer returns Integer:
    Note: Get instruction for logical OR
    Note: Returns opcode for selected instruction
    
    If has_immediate is equal to 1:
        Return 24  Note: ORI
    Otherwise:
        Return 31  Note: OR (X-form)
    End If
End Process

Process called "get_logical_xor_instruction" takes has_immediate as Integer returns Integer:
    Note: Get instruction for logical XOR
    Note: Returns opcode for selected instruction
    
    If has_immediate is equal to 1:
        Return 26  Note: XORI
    Otherwise:
        Return 31  Note: XOR (X-form)
    End If
End Process

Note: ============================================================================
Note: OPTIMIZATION HINTS
Note: ============================================================================

Process called "can_fuse_with_next" takes opcode as Integer returns Integer:
    Note: Check if instruction can be fused with next instruction
    Note: Returns 1 if fusible, 0 otherwise
    
    If opcode is equal to 14 or opcode is equal to 15:
        Return 1  Note: ADDI, ADDIS can fuse with load/store
    End If
    
    If opcode is equal to 24 or opcode is equal to 25:
        Return 1  Note: ORI, ORIS can fuse with load/store
    End If
    
    Return 0
End Process

Process called "prefer_immediate_form" takes opcode as Integer, immediate_value as Integer returns Integer:
    Note: Check if immediate form should be preferred
    Note: Returns 1 if immediate form preferred, 0 otherwise
    
    If opcode is equal to 31:
        Note: X-form instruction - check if immediate form exists and is better
        If immediate_value is greater than or equal to -32768 and immediate_value is less than or equal to 32767:
            Return 1  Note: Use immediate form
        Otherwise:
            Return 0  Note: Use register form
        End If
    End If
    
    Return 0
End Process

Process called "get_instruction_category" takes opcode as Integer returns Integer:
    Note: Get instruction category for optimization
    Note: Returns category number
    
    If is_arithmetic_instruction(opcode) is equal to 1:
        Return 1  Note: Arithmetic
    End If
    
    If is_logical_instruction(opcode) is equal to 1:
        Return 2  Note: Logical
    End If
    
    If is_load_instruction(opcode) is equal to 1:
        Return 3  Note: Load
    End If
    
    If is_store_instruction(opcode) is equal to 1:
        Return 4  Note: Store
    End If
    
    If is_branch_instruction(opcode) is equal to 1:
        Return 5  Note: Branch
    End If
    
    Return 0  Note: Other
End Process

Process called "get_instruction_priority" takes opcode as Integer returns Integer:
    Note: Get instruction scheduling priority (higher = more important)
    Note: Returns priority value
    
    If is_load_instruction(opcode) is equal to 1:
        Return 10  Note: High priority for loads
    End If
    
    If is_branch_instruction(opcode) is equal to 1:
        Return 8  Note: High priority for branches
    End If
    
    If is_arithmetic_instruction(opcode) is equal to 1:
        Return 5  Note: Medium priority for arithmetic
    End If
    
    If is_logical_instruction(opcode) is equal to 1:
        Return 3  Note: Low priority for logical
    End If
    
    If is_store_instruction(opcode) is equal to 1:
        Return 2  Note: Low priority for stores
    End If
    
    Return 1  Note: Default priority
End Process