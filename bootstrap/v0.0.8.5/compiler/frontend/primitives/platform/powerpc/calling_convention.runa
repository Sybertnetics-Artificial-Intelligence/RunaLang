Note:
PowerPC 64-bit Calling Convention (System V ABI)

This file implements the calling convention for PowerPC 64-bit architecture
following the System V ABI specification.

Platform-specific details:
- Architecture: PowerPC 64-bit (ppc64le)
- ABI: System V ABI for PowerPC
- Endianness: Little-endian (ppc64le)
- Register size: 64-bit
- Stack alignment: 16-byte aligned
- Red zone: None (PowerPC doesn't use red zone)

Register usage:
- r3-r10: Parameter/return registers (r3-r10 for parameters, r3 for return value)
- r1: Stack pointer
- r2: TOC pointer (Table of Contents)
- r11-r12: Volatile registers
- r13-r31: Non-volatile registers
- f1-f13: Floating-point parameter/return registers
- f1: Floating-point return value
- f14-f31: Non-volatile floating-point registers

Calling convention details:
- Parameters passed in r3-r10 (up to 8 parameters)
- Additional parameters passed on stack
- Return value in r3 (or f1 for floating-point)
- Caller-saved: r0, r3-r12, f0-f13, CR0-CR1, CR5-CR7, XER, LR, CTR
- Callee-saved: r13-r31, f14-f31, CR2-CR4
- Stack grows downward
- 16-byte stack alignment required
- TOC pointer (r2) must be preserved across calls
:End Note

Import "compiler/frontend/primitives/platform/powerpc/registers.runa" as Registers
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Note: ============================================================================
Note: PARAMETER PASSING - INTEGER AND POINTER ARGUMENTS
Note: ============================================================================

Process called "get_integer_param_register" takes param_index as Integer returns Integer:
    Note: Get register number for integer/pointer parameter
    Note: PowerPC ABI: r3-r10 (indices 0-7)
    Note: Returns register number (3-10), or -1 if passed on stack

    If param_index is equal to 0:
        Return 3  Note: r3
    End If

    If param_index is equal to 1:
        Return 4  Note: r4
    End If

    If param_index is equal to 2:
        Return 5  Note: r5
    End If

    If param_index is equal to 3:
        Return 6  Note: r6
    End If

    If param_index is equal to 4:
        Return 7  Note: r7
    End If

    If param_index is equal to 5:
        Return 8  Note: r8
    End If

    If param_index is equal to 6:
        Return 9  Note: r9
    End If

    If param_index is equal to 7:
        Return 10  Note: r10
    End If

    Note: Parameters 8+ are passed on stack
    Return -1
End Process

Process called "get_max_integer_register_params" returns Integer:
    Note: Maximum number of integer/pointer parameters passed in registers
    Return 8
End Process

Process called "is_param_in_register" takes param_index as Integer returns Integer:
    Note: Check if parameter is passed in register (vs stack)
    Note: Returns 1 if in register, 0 if on stack

    If param_index is less than 8:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Process called "get_stack_param_offset" takes param_index as Integer returns Integer:
    Note: Get stack offset for parameter (when not in register)
    Note: PowerPC: parameters 8+ start at offset 48 (6*8 bytes for r3-r10 + 8 bytes for TOC)
    Note: Each parameter is 8 bytes (64-bit)

    If param_index is less than 8:
        Return -1  Note: Parameter is in register
    Otherwise:
        Let stack_index be param_index minus 8
        Return 48 plus (stack_index multiplied by 8)
    End If
End Process

Note: ============================================================================
Note: PARAMETER PASSING - FLOATING-POINT ARGUMENTS
Note: ============================================================================

Process called "get_float_param_register" takes param_index as Integer returns Integer:
    Note: Get register number for floating-point parameter
    Note: PowerPC ABI: f1-f13 (indices 0-12)
    Note: Returns register number (1-13), or -1 if passed on stack

    If param_index is equal to 0:
        Return 1  Note: f1
    End If

    If param_index is equal to 1:
        Return 2  Note: f2
    End If

    If param_index is equal to 2:
        Return 3  Note: f3
    End If

    If param_index is equal to 3:
        Return 4  Note: f4
    End If

    If param_index is equal to 4:
        Return 5  Note: f5
    End If

    If param_index is equal to 5:
        Return 6  Note: f6
    End If

    If param_index is equal to 6:
        Return 7  Note: f7
    End If

    If param_index is equal to 7:
        Return 8  Note: f8
    End If

    If param_index is equal to 8:
        Return 9  Note: f9
    End If

    If param_index is equal to 9:
        Return 10  Note: f10
    End If

    If param_index is equal to 10:
        Return 11  Note: f11
    End If

    If param_index is equal to 11:
        Return 12  Note: f12
    End If

    If param_index is equal to 12:
        Return 13  Note: f13
    End If

    Note: Parameters 13+ are passed on stack
    Return -1
End Process

Process called "get_max_float_register_params" returns Integer:
    Note: Maximum number of floating-point parameters passed in registers
    Return 13
End Process

Process called "is_float_param_in_register" takes param_index as Integer returns Integer:
    Note: Check if floating-point parameter is passed in register (vs stack)
    Note: Returns 1 if in register, 0 if on stack

    If param_index is less than 13:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Note: ============================================================================
Note: RETURN VALUES
Note: ============================================================================

Process called "get_return_value_register" returns Integer:
    Note: Get register number for integer/pointer return value
    Note: PowerPC ABI: r3
    Return 3
End Process

Process called "get_float_return_register" returns Integer:
    Note: Get register number for floating-point return value
    Note: PowerPC ABI: f1
    Return 1
End Process

Process called "is_return_via_memory" takes return_size as Integer returns Integer:
    Note: Check if return value is passed via memory (vs register)
    Note: PowerPC: values > 8 bytes passed via memory
    Note: Returns 1 if via memory, 0 if via register

    If return_size is greater than 8:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Note: ============================================================================
Note: REGISTER PRESERVATION
Note: ============================================================================

Process called "is_caller_saved_register" takes reg_num as Integer returns Integer:
    Note: Check if register is caller-saved (volatile)
    Note: Returns 1 if caller-saved, 0 if callee-saved

    Note: Caller-saved registers: r0, r3-r12, f0-f13, CR0-CR1, CR5-CR7, XER, LR, CTR
    If reg_num is equal to 0:
        Return 1  Note: r0
    End If

    If reg_num is greater than or equal to 3 and reg_num is less than or equal to 12:
        Return 1  Note: r3-r12
    End If

    If reg_num is greater than or equal to 0 and reg_num is less than or equal to 13:
        Return 1  Note: f0-f13
    End If

    Note: Special registers (simplified - in real implementation would check CR, XER, LR, CTR)
    If reg_num is equal to 100:  Note: LR
        Return 1
    End If

    If reg_num is equal to 101:  Note: CTR
        Return 1
    End If

    Return 0  Note: Callee-saved or unknown
End Process

Process called "is_callee_saved_register" takes reg_num as Integer returns Integer:
    Note: Check if register is callee-saved (non-volatile)
    Note: Returns 1 if callee-saved, 0 if caller-saved

    Note: Callee-saved registers: r13-r31, f14-f31, CR2-CR4
    If reg_num is greater than or equal to 13 and reg_num is less than or equal to 31:
        Return 1  Note: r13-r31
    End If

    If reg_num is greater than or equal to 14 and reg_num is less than or equal to 31:
        Return 1  Note: f14-f31
    End If

    Note: Special registers (simplified)
    If reg_num is equal to 1:
        Return 1  Note: r1 (SP)
    End If

    If reg_num is equal to 2:
        Return 1  Note: r2 (TOC)
    End If

    Return 0  Note: Caller-saved or unknown
End Process

Process called "get_callee_saved_register_list" takes buffer_ptr as Integer returns Integer:
    Note: Fill buffer with list of callee-saved register numbers
    Note: buffer_ptr: pointer to array of at least 19 integers
    Note: Returns: count of callee-saved registers

    Let offset be 0

    Note: Store register numbers in buffer (8 bytes per integer)
    Note: r13-r31 (19 registers)
    Let reg_num be 13
    While reg_num is less than or equal to 31:
        proc memory_set_int64 from Memory with buffer_ptr, offset, reg_num
        Set offset to offset plus 8
        Set reg_num to reg_num plus 1
    End While

    Note: f14-f31 (18 registers)
    Set reg_num to 14
    While reg_num is less than or equal to 31:
        proc memory_set_int64 from Memory with buffer_ptr, offset, reg_num
        Set offset to offset plus 8
        Set reg_num to reg_num plus 1
    End While

    Note: Special registers
    proc memory_set_int64 from Memory with buffer_ptr, offset, 1  Note: r1 (SP)
    Set offset to offset plus 8
    proc memory_set_int64 from Memory with buffer_ptr, offset, 2  Note: r2 (TOC)

    Return 40  Note: 19 + 18 + 2 = 39 registers
End Process

Note: ============================================================================
Note: STACK FRAME MANAGEMENT
Note: ============================================================================

Process called "get_stack_alignment" returns Integer:
    Note: Get required stack alignment in bytes
    Note: PowerPC ABI: 16-byte alignment
    Return 16
End Process

Process called "calculate_stack_frame_size" takes local_vars_size as Integer, num_callee_saved_regs as Integer returns Integer:
    Note: Calculate total stack frame size
    Note: Includes: local variables, callee-saved registers, return address, TOC
    Note: PowerPC: 8 bytes for return address, 8 bytes for TOC, 8 bytes per saved register

    Let frame_size be 16  Note: Return address + TOC
    Set frame_size to frame_size plus (num_callee_saved_regs multiplied by 8)
    Set frame_size to frame_size plus local_vars_size

    Note: Align to 16-byte boundary
    Let remainder be frame_size modulo 16
    If remainder is not equal to 0:
        Set frame_size to frame_size plus (16 minus remainder)
    End If

    Return frame_size
End Process

Process called "get_frame_pointer_register" returns Integer:
    Note: Get frame pointer register number
    Note: PowerPC: r1 (SP) serves as frame pointer
    Return 1
End Process

Process called "get_stack_pointer_register" returns Integer:
    Note: Get stack pointer register number
    Note: PowerPC: r1
    Return 1
End Process

Process called "get_red_zone_size" returns Integer:
    Note: Get red zone size in bytes
    Note: PowerPC: no red zone
    Return 0
End Process

Process called "can_use_red_zone" takes is_leaf_function as Integer returns Integer:
    Note: Check if red zone can be used
    Note: PowerPC: no red zone
    Return 0
End Process

Process called "needs_frame_pointer" takes has_variable_sized_locals as Integer, has_alloca as Integer returns Integer:
    Note: Check if frame pointer is needed
    Note: PowerPC: frame pointer always needed for proper stack management
    Return 1
End Process

Process called "calculate_call_stack_adjustment" takes num_stack_args as Integer returns Integer:
    Note: Calculate stack adjustment needed for function call
    Note: PowerPC: 8 bytes per stack argument, plus alignment
    Note: Stack must be 16-byte aligned

    Let adjustment be num_stack_args multiplied by 8
    Let remainder be adjustment modulo 16
    If remainder is not equal to 0:
        Set adjustment to adjustment plus (16 minus remainder)
    End If

    Return adjustment
End Process

Note: ============================================================================
Note: VARIADIC FUNCTIONS
Note: ============================================================================

Process called "get_variadic_gp_register_save_area_size" returns Integer:
    Note: Get size of general-purpose register save area for variadic functions
    Note: PowerPC: save r3-r10 (8 registers * 8 bytes = 64 bytes)
    Return 64
End Process

Process called "get_variadic_fp_register_save_area_size" returns Integer:
    Note: Get size of floating-point register save area for variadic functions
    Note: PowerPC: save f1-f13 (13 registers * 8 bytes = 104 bytes)
    Return 104
End Process

Process called "get_variadic_total_save_area_size" returns Integer:
    Note: Get total size of register save areas for variadic functions
    Let gp_size be get_variadic_gp_register_save_area_size()
    Let fp_size be get_variadic_fp_register_save_area_size()
    Return gp_size plus fp_size
End Process

Note: ============================================================================
Note: HELPER FUNCTIONS FOR CODE GENERATION
Note: ============================================================================

Process called "get_parameter_location" takes param_index as Integer, param_size as Integer, result_buffer as Integer returns Integer:
    Note: Get location (register or stack offset) for parameter
    Note: param_index: parameter position (0-based)
    Note: param_size: size in bytes (for future struct handling)
    Note: result_buffer: pointer to 2-integer array [location_type, value]
    Note: location_type: 0 = register (value = reg_num), 1 = stack (value = offset)
    Note: Returns: location_type

    Let location_type be 0
    Let value be 0

    Note: Check if parameter is in register
    If param_index is less than 8:
        Set location_type to 0  Note: Register
        Set value to get_integer_param_register(param_index)
    Otherwise:
        Set location_type to 1  Note: Stack
        Set value to get_stack_param_offset(param_index)
    End If

    Note: Write results to buffer
    proc memory_set_int64 from Memory with result_buffer, 0, location_type
    proc memory_set_int64 from Memory with result_buffer, 8, value

    Return location_type
End Process

Process called "get_call_setup_info" takes num_params as Integer, result_buffer as Integer returns Integer:
    Note: Get information needed to set up a function call
    Note: num_params: total number of parameters
    Note: result_buffer: pointer to 3-integer array [reg_params, stack_params, stack_adjustment]
    Note: Returns: number of stack parameters

    Let reg_params be 8
    Let stack_params be 0
    Let stack_adjustment be 0

    If num_params is less than or equal to 8:
        Set reg_params to num_params
    Otherwise:
        Set stack_params to num_params minus 8
        Set stack_adjustment to calculate_call_stack_adjustment(stack_params)
    End If

    Note: Write results to buffer
    proc memory_set_int64 from Memory with result_buffer, 0, reg_params
    proc memory_set_int64 from Memory with result_buffer, 8, stack_params
    proc memory_set_int64 from Memory with result_buffer, 16, stack_adjustment

    Return stack_params
End Process

Process called "validate_stack_alignment" takes stack_offset as Integer returns Integer:
    Note: Validate that stack is properly aligned
    Note: Returns 1 if aligned, 0 if not aligned

    Let remainder be stack_offset modulo 16
    If remainder is equal to 0:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Note: ============================================================================
Note: CONVENTION INFORMATION
Note: ============================================================================

Process called "get_calling_convention_name" returns String:
    Return "PowerPC 64-bit"
End Process

Process called "get_abi_version" returns Integer:
    Note: Return ABI version number
    Return 1
End Process