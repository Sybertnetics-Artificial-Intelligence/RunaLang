Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles platform selection and platform-specific code generation.

This file performs the following tasks:
- Process platform detection and platform selection
- Handle platform-specific code generation and platform optimization
- Manage platform abstraction and platform-independent code generation
- Process platform configuration and platform-specific feature selection

This file is essential because of the following reasons:
- Platform selection enables cross-platform Runa compilation
- Proper platform handling ensures correct code generation for target platforms
- Platform abstraction supports portable Runa applications

This file consists of the following functions/features/operation types:
- Platform detection and platform selection
- Platform-specific code generation and platform optimization
- Platform abstraction and platform-independent code generation
- Platform configuration and platform-specific feature selection
:End Note

Note: =========================================================================
Note: PLATFORM SELECTOR - PRODUCTION IMPLEMENTATION
Note: =========================================================================

Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
Import "compiler/internal/string_utils.runa" as StringUtils

Note:
This selector normalizes (os, arch) into a canonical platform key and returns
fully-qualified module paths for the 4 core components (calling_convention,
instructions, machine_code, registers) and the syscall module when applicable.
Unsupported targets return an empty string.
:End Note

Process called "normalize_os" takes os_name as String returns String:
    Note: Normalize common OS identifiers
    Let lower be proc string_to_lower from StringUtils with os_name, 0
    If lower is equal to "linux":
        Return "linux"
    End If
    If lower is equal to "darwin" or lower is equal to "macos" or lower is equal to "macosx":
        Return "darwin"
    End If
    If lower is equal to "freebsd":
        Return "freebsd"
    End If
    If lower is equal to "netbsd":
        Return "netbsd"
    End If
    If lower is equal to "openbsd":
        Return "openbsd"
    End If
    If lower is equal to "windows" or lower is equal to "win32" or lower is equal to "win64":
        Return "windows"
    End If
    Return lower
End Process

Process called "normalize_arch" takes arch_name as String returns String:
    Note: Normalize common architecture identifiers
    Let lower be proc string_to_lower from StringUtils with arch_name, 0
    If lower is equal to "x86_64" or lower is equal to "amd64":
        Return "x86_64"
    End If
    If lower is equal to "arm64" or lower is equal to "aarch64":
        Return "arm64"
    End If
    If lower is equal to "arm" or lower is equal to "arm32" or lower is equal to "armv7":
        Return "arm32"
    End If
    If lower is equal to "mips" or lower is equal to "mips32":
        Return "mips32"
    End If
    If lower is equal to "mips64":
        Return "mips64"
    End If
    If lower is equal to "ppc64" or lower is equal to "powerpc64" or lower is equal to "powerpc64le" or lower is equal to "ppc64le":
        Return "powerpc"
    End If
    If lower is equal to "riscv" or lower is equal to "riscv32":
        Return "riscv32"
    End If
    If lower is equal to "riscv64":
        Return "riscv64"
    End If
    Return lower
End Process

Process called "get_platform_key" takes os_name as String, arch_name as String returns String:
    Note: Map (os, arch) â†’ canonical platform directory key
    Let os be normalize_os(os_name)
    Let arch be normalize_arch(arch_name)

    If os is equal to "linux" and arch is equal to "x86_64":
        Return "linux_x86_64"
    End If
    If os is equal to "linux" and arch is equal to "arm64":
        Return "linux_arm64"
    End If
    If os is equal to "linux" and arch is equal to "arm32":
        Return "linux_arm32"
    End If
    If os is equal to "mips" and arch is equal to "mips32":
        Return "mips32"
    End If
    If os is equal to "mips" and arch is equal to "mips64":
        Return "mips64"
    End If
    If os is equal to "darwin" and arch is equal to "x86_64":
        Return "darwin_x86_64"
    End If
    If os is equal to "darwin" and arch is equal to "arm64":
        Return "darwin_arm64"
    End If
    If os is equal to "freebsd" and arch is equal to "x86_64":
        Return "freebsd_x64"
    End If
    If os is equal to "freebsd" and arch is equal to "arm64":
        Return "freebsd_arm64"
    End If
    If os is equal to "netbsd" and arch is equal to "x86_64":
        Return "netbsd_x64"
    End If
    If os is equal to "netbsd" and arch is equal to "arm64":
        Return "netbsd_arm64"
    End If
    If os is equal to "openbsd" and arch is equal to "x86_64":
        Return "openbsd_x64"
    End If
    If os is equal to "openbsd" and arch is equal to "arm64":
        Return "openbsd_arm64"
    End If
    If os is equal to "windows" and arch is equal to "x86_64":
        Return "windows_x86_64"
    End If
    If os is equal to "windows" and arch is equal to "arm64":
        Return "windows_arm64"
    End If
    If os is equal to "linux" and arch is equal to "powerpc":
        Return "powerpc"
    End If
    If os is equal to "linux" and arch is equal to "riscv32":
        Return "riscv32"
    End If
    If os is equal to "linux" and arch is equal to "riscv64":
        Return "riscv64"
    End If
    Return ""
End Process

Process called "compose_path" takes platform_key as String, component as String returns String:
    Note: Compose module path for a given component
    If platform_key is equal to "":
        Return ""
    End If
    Return "compiler/frontend/primitives/platform/" joined with platform_key joined with "/" joined with component joined with ".runa"
End Process

Process called "get_calling_convention_path" takes os_name as String, arch_name as String returns String:
    Let key be get_platform_key(os_name, arch_name)
    Return compose_path(key, "calling_convention")
End Process

Process called "get_instructions_path" takes os_name as String, arch_name as String returns String:
    Let key be get_platform_key(os_name, arch_name)
    Return compose_path(key, "instructions")
End Process

Process called "get_machine_code_path" takes os_name as String, arch_name as String returns String:
    Let key be get_platform_key(os_name, arch_name)
    Return compose_path(key, "machine_code")
End Process

Process called "get_registers_path" takes os_name as String, arch_name as String returns String:
    Let key be get_platform_key(os_name, arch_name)
    Return compose_path(key, "registers")
End Process

Process called "get_syscall_path" takes os_name as String, arch_name as String returns String:
    Note: Only CPU/OS platforms have syscalls; accelerators are excluded
    Let key be get_platform_key(os_name, arch_name)
    If key is equal to "":
        Return ""
    End If
    Return compose_path(key, "syscall")
End Process

Process called "is_supported_platform" takes os_name as String, arch_name as String returns Integer:
    If get_platform_key(os_name, arch_name) is equal to "":
        Return 0
    End If
    Return 1
End Process

Process called "write_supported_platform_keys" takes buffer_ptr as Integer returns Integer:
    Note: Write NUL-terminated platform key strings separated by '\n' into buffer
    Note: Returns total bytes written
    Let keys be a list containing "linux_x86_64", "linux_arm64", "linux_arm32", "mips32", "mips64", "darwin_x86_64", "darwin_arm64", "freebsd_x64", "freebsd_arm64", "netbsd_x64", "netbsd_arm64", "openbsd_x64", "openbsd_arm64", "windows_x86_64", "windows_arm64", "powerpc", "riscv32", "riscv64"
    Let i be 0
    Let offset be 0
    While i is less than length of keys:
        Let s be keys at i
        Let j be 0
        While j is less than length of s:
            proc memory_set_byte from Memory with buffer_ptr, offset, s at j
            Set offset to offset plus 1
            Set j to j plus 1
        End While
        proc memory_set_byte from Memory with buffer_ptr, offset, 10  Note: '\n'
        Set offset to offset plus 1
        Set i to i plus 1
    End While
    proc memory_set_byte from Memory with buffer_ptr, offset, 0
    Set offset to offset plus 1
    Return offset
End Process
