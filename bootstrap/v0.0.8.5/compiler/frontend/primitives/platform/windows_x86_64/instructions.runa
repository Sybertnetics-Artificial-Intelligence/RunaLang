Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
Windows x86_64 Instruction Set

IMPORTANT ARCHITECTURAL NOTE:
Windows x86_64 and Linux x86_64 use the IDENTICAL instruction set.
The x86_64 architecture is platform-independent at the instruction level.

The ONLY differences between Windows and Linux x86_64 are:
1. Calling convention (Microsoft x64 vs System V ABI) - handled in calling_convention.runa
2. System calls (Windows NT API vs Linux syscalls) - handled in syscall.runa
3. Binary format (PE vs ELF) - handled by linker/assembler

The instruction encoding, instruction set, and machine code are IDENTICAL.

For Windows x86_64 instruction metadata and encoding information:
- Use the SAME instruction definitions as Linux x86_64
- Reference: linux_x86_64/instructions.runa
- Reference: Intel 64 and IA-32 Architectures Software Developer's Manual

This file provides Windows-specific wrappers and convenience functions that
delegate to the shared x86_64 instruction implementation.
:End Note

Note: ============================================================================
Note: SHARED X86_64 INSTRUCTION SET
Note: ============================================================================
Note: x86_64 is a platform-independent ISA
Note: Same instruction encodings work on Windows, Linux, macOS, BSD, etc.

Process called "get_instruction_size" takes instruction_type as Integer returns Integer:
    Note: Get size in bytes for instruction type
    Note: x86_64 instructions are variable length (1-15 bytes)
    Note: instruction_type: identifier for instruction (MOV, ADD, CALL, etc.)

    Note: This is platform-independent - same on Windows and Linux
    Note: Common sizes:
    Note: - Simple register operations: 2-3 bytes
    Note: - Register-memory operations: 3-7 bytes
    Note: - Immediate operations: 3-10 bytes
    Note: - CALL/JMP with 32-bit offset: 5 bytes
    Note: - REX prefix adds 1 byte for 64-bit operands

    Note: Instruction size depends on operands, addressing mode, prefixes
    Note: This is a simplified estimate for common cases
    Note: Actual encoding requires full operand information

    Note: For precise sizing, use machine_code.runa encoders
    Return 5  Note: Conservative estimate for planning
End Process

Process called "is_two_operand_instruction" takes instruction_type as Integer returns Integer:
    Note: Check if instruction uses two-operand form
    Note: x86_64 typically uses: DEST = DEST op SRC
    Note: Returns 1 if two-operand, 0 if three-operand or other

    Note: Most x86_64 instructions are two-operand (dest is also source)
    Note: Examples: ADD rax, rbx means rax = rax + rbx

    Return 1  Note: Most x86_64 instructions are two-operand
End Process

Process called "supports_immediate_operand" takes instruction_type as Integer returns Integer:
    Note: Check if instruction supports immediate (constant) operands
    Note: Returns 1 if immediate supported, 0 otherwise

    Note: Most x86_64 instructions support immediate operands
    Note: Examples: MOV rax, 42; ADD rbx, 10; CMP rcx, 0

    Return 1  Note: Most x86_64 instructions support immediates
End Process

Process called "supports_memory_operand" takes instruction_type as Integer returns Integer:
    Note: Check if instruction supports memory operands
    Note: Returns 1 if memory supported, 0 otherwise

    Note: Most x86_64 instructions support one memory operand
    Note: Examples: MOV rax, [rbx]; ADD [rsp+8], 10

    Return 1  Note: Most x86_64 instructions support memory operands
End Process

Process called "requires_rex_prefix" takes operand_size as Integer, uses_extended_register as Integer returns Integer:
    Note: Check if instruction requires REX prefix
    Note: operand_size: size in bytes (8 for 64-bit)
    Note: uses_extended_register: 1 if using R8-R15 or XMM8-XMM15
    Note: Returns 1 if REX prefix required, 0 otherwise

    Note: REX prefix required for:
    Note: - 64-bit operand size
    Note: - Extended registers (R8-R15, XMM8-XMM15)
    Note: - Accessing byte registers (SIL, DIL, BPL, SPL)

    If operand_size is equal to 8:
        Return 1  Note: 64-bit operand requires REX.W
    End If

    If uses_extended_register is equal to 1:
        Return 1  Note: Extended register requires REX
    End If

    Return 0
End Process

Process called "get_modrm_encoding" takes mod as Integer, reg as Integer, rm as Integer returns Integer:
    Note: Encode ModR/M byte for x86_64 instruction
    Note: mod: addressing mode (0-3)
    Note: reg: register field (0-7)
    Note: rm: register/memory field (0-7)
    Note: Returns: encoded ModR/M byte

    Note: ModR/M format: [mod:2][reg:3][rm:3]
    Note: Platform-independent encoding

    Let modrm be mod shifted_left 6
    Set modrm to modrm bitwise_or (reg shifted_left 3)
    Set modrm to modrm bitwise_or rm

    Return modrm
End Process

Process called "get_sib_encoding" takes scale as Integer, index as Integer, base as Integer returns Integer:
    Note: Encode SIB (Scale-Index-Base) byte for x86_64 instruction
    Note: scale: scale factor (0=1, 1=2, 2=4, 3=8)
    Note: index: index register (0-7)
    Note: base: base register (0-7)
    Note: Returns: encoded SIB byte

    Note: SIB format: [scale:2][index:3][base:3]
    Note: Used for complex addressing modes like [base + index*scale]

    Let sib be scale shifted_left 6
    Set sib to sib bitwise_or (index shifted_left 3)
    Set sib to sib bitwise_or base

    Return sib
End Process

Process called "get_instruction_latency" takes instruction_type as Integer returns Integer:
    Note: Get typical instruction latency in CPU cycles
    Note: instruction_type: identifier for instruction
    Note: Returns: estimated latency in cycles

    Note: This is platform-independent (same CPU microarchitecture)
    Note: Latencies vary by CPU model, but general estimates:
    Note: - MOV reg, reg: 1 cycle
    Note: - ADD/SUB reg, reg: 1 cycle
    Note: - MUL: 3-4 cycles
    Note: - DIV: 20-40 cycles
    Note: - Memory load: 4-5 cycles (cache hit)
    Note: - Memory store: 1 cycle (store buffer)

    Return 1  Note: Conservative estimate for register operations
End Process

Process called "can_be_fused" takes instruction1_type as Integer, instruction2_type as Integer returns Integer:
    Note: Check if two instructions can be macro-fused by CPU
    Note: Macro-fusion combines two instructions into one micro-op
    Note: Returns 1 if can be fused, 0 otherwise

    Note: Common fusion patterns:
    Note: - CMP followed by JMP/Jcc
    Note: - TEST followed by JMP/Jcc
    Note: - DEC/INC followed by JMP/Jcc

    Note: Platform-independent (CPU microarchitecture feature)

    Return 0  Note: Conservative - fusion detection requires detailed analysis
End Process

Process called "is_branch_instruction" takes instruction_type as Integer returns Integer:
    Note: Check if instruction is a branch (JMP, JCC, CALL, RET)
    Note: Returns 1 if branch, 0 otherwise

    Return 0  Note: Conservative - requires instruction_type enum
End Process

Process called "is_memory_access" takes instruction_type as Integer returns Integer:
    Note: Check if instruction accesses memory
    Note: Returns 1 if memory access, 0 otherwise

    Return 0  Note: Conservative - requires operand analysis
End Process

Process called "get_rex_prefix" takes w as Integer, r as Integer, x as Integer, b as Integer returns Integer:
    Note: Encode REX prefix byte for 64-bit x86_64 instruction
    Note: w: 64-bit operand size (REX.W)
    Note: r: register extension (REX.R)
    Note: x: index extension (REX.X)
    Note: b: base extension (REX.B)
    Note: Returns: REX prefix byte (0x40-0x4F)

    Note: REX format: 0100WRXB
    Note: Platform-independent encoding

    Let rex be 64  Note: 0x40 base
    If w is equal to 1:
        Set rex to rex bitwise_or 8  Note: REX.W
    End If
    If r is equal to 1:
        Set rex to rex bitwise_or 4  Note: REX.R
    End If
    If x is equal to 1:
        Set rex to rex bitwise_or 2  Note: REX.X
    End If
    If b is equal to 1:
        Set rex to rex bitwise_or 1  Note: REX.B
    End If

    Return rex
End Process

Note: ============================================================================
Note: INSTRUCTION VALIDATION
Note: ============================================================================

Process called "validate_register_number" takes reg_num as Integer returns Integer:
    Note: Validate register number is in valid range
    Note: x86_64: 0-15 for GPRs, 16-31 for XMM
    Note: Returns 1 if valid, 0 if invalid

    If reg_num is less than 0:
        Return 0
    End If

    If reg_num is greater than 31:
        Return 0
    End If

    Return 1
End Process

Process called "validate_immediate_size" takes immediate as Integer, size_bytes as Integer returns Integer:
    Note: Validate immediate value fits in specified size
    Note: size_bytes: 1, 2, 4, or 8
    Note: Returns 1 if fits, 0 if too large

    Note: Check common sizes
    If size_bytes is equal to 1:
        If immediate is greater than 127:
            If immediate is less than -128:
                Return 0
            End If
        End If
        Return 1
    End If

    If size_bytes is equal to 4:
        If immediate is greater than 2147483647:
            If immediate is less than -2147483648:
                Return 0
            End If
        End If
        Return 1
    End If

    Return 1  Note: Conservative - assume fits
End Process

Note: ============================================================================
Note: PLATFORM NOTE
Note: ============================================================================
Note: This file provides a minimal x86_64 instruction interface.
Note: For full instruction encoding, use machine_code.runa
Note: For calling convention specifics, use calling_convention.runa
Note: For Windows-specific syscalls, use syscall.runa

Note: The x86_64 instruction set is IDENTICAL across platforms.
Note: Platform differences are in ABI, not instruction encoding.
