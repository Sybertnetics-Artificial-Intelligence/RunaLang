Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
Windows x86_64 Machine Code Generation

IMPORTANT ARCHITECTURAL NOTE:
Windows x86_64 and Linux x86_64 use the IDENTICAL instruction encoding.
The x86_64 machine code is platform-independent.

Machine code encoding is IDENTICAL:
- Instruction format: x86_64 (variable length, 1-15 bytes)
- Byte order: Little-endian
- Prefixes: REX, VEX, EVEX (same on all platforms)
- Encoding: Intel/AMD x86_64 specification

The ONLY platform-specific differences are:
1. Object file format (PE/COFF for Windows vs ELF for Linux)
2. Relocation types (handled by assembler/linker)
3. Symbol table format (handled by assembler/linker)

At the instruction level, a MOV instruction on Windows is byte-for-byte
identical to the same MOV instruction on Linux. The CPU doesn't know or care
what OS is running - it just executes x86_64 machine code.

For full x86_64 instruction encoding:
- Reference: linux_x86_64/machine_code.runa (identical encodings)
- Reference: Intel 64 and IA-32 Architectures Software Developer's Manual
- Reference: AMD64 Architecture Programmer's Manual

This file provides basic encoding utilities that work identically on all
x86_64 platforms.
:End Note

Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Note: ============================================================================
Note: SHARED X86_64 MACHINE CODE ENCODING
Note: ============================================================================

Process called "write_byte_to_buffer" takes buffer_ptr as Integer, offset as Integer, byte_value as Integer returns Integer:
    Note: Write single byte to code buffer
    Note: Returns offset + 1 (next write position)

    Memory.memory_set_byte(buffer_ptr, offset, byte_value)
    Return offset plus 1
End Process

Process called "write_bytes_to_buffer" takes buffer_ptr as Integer, offset as Integer, bytes_ptr as Integer, count as Integer returns Integer:
    Note: Write multiple bytes to code buffer
    Note: Returns offset + count (next write position)

    Let i be 0
    While i is less than count:
        Let byte_val be Memory.memory_get_byte(bytes_ptr, i)
        Memory.memory_set_byte(buffer_ptr, offset plus i, byte_val)
        Set i to i plus 1
    End While

    Return offset plus count
End Process

Process called "encode_register_number" takes reg_num as Integer returns Integer:
    Note: Encode register number for x86_64 instruction
    Note: Returns 3-bit register field (0-7)
    Note: For extended registers (R8-R15), use REX prefix

    Return reg_num bitwise_and 7  Note: Low 3 bits
End Process

Process called "needs_rex_for_register" takes reg_num as Integer returns Integer:
    Note: Check if register number requires REX prefix
    Note: R8-R15 require REX prefix (reg_num >= 8)

    If reg_num is greater than or equal to 8:
        If reg_num is less than or equal to 15:
            Return 1
        End If
    End If

    Return 0
End Process

Note: ============================================================================
Note: BASIC X86_64 INSTRUCTION ENCODERS
Note: ============================================================================
Note: These are simplified encoders for common instructions
Note: For complete x86_64 encoding, reference linux_x86_64/machine_code.runa

Process called "encode_nop" takes buffer_ptr as Integer returns Integer:
    Note: Encode NOP instruction (0x90)
    Note: Platform-independent encoding

    Memory.memory_set_byte(buffer_ptr, 0, 144)  Note: 0x90 = NOP
    Return 1  Note: 1 byte written
End Process

Process called "encode_ret" takes buffer_ptr as Integer returns Integer:
    Note: Encode RET instruction (0xC3)
    Note: Platform-independent encoding

    Memory.memory_set_byte(buffer_ptr, 0, 195)  Note: 0xC3 = RET
    Return 1  Note: 1 byte written
End Process

Process called "encode_push_reg" takes buffer_ptr as Integer, reg_num as Integer returns Integer:
    Note: Encode PUSH register instruction
    Note: Opcode: 0x50 + register number
    Note: For R8-R15, need REX prefix: 0x41 + 0x50 + (reg & 7)

    Let bytes_written be 0

    Note: Check if need REX prefix for extended register
    If reg_num is greater than or equal to 8:
        Memory.memory_set_byte(buffer_ptr, 0, 65)  Note: 0x41 = REX.B
        Set bytes_written to 1
    End If

    Note: Encode PUSH opcode + register
    Let reg_field be reg_num bitwise_and 7
    Let opcode be 80 plus reg_field  Note: 0x50 + reg
    Memory.memory_set_byte(buffer_ptr, bytes_written, opcode)
    Set bytes_written to bytes_written plus 1

    Return bytes_written
End Process

Process called "encode_pop_reg" takes buffer_ptr as Integer, reg_num as Integer returns Integer:
    Note: Encode POP register instruction
    Note: Opcode: 0x58 + register number
    Note: For R8-R15, need REX prefix

    Let bytes_written be 0

    Note: Check if need REX prefix for extended register
    If reg_num is greater than or equal to 8:
        Memory.memory_set_byte(buffer_ptr, 0, 65)  Note: 0x41 = REX.B
        Set bytes_written to 1
    End If

    Note: Encode POP opcode + register
    Let reg_field be reg_num bitwise_and 7
    Let opcode be 88 plus reg_field  Note: 0x58 + reg
    Memory.memory_set_byte(buffer_ptr, bytes_written, opcode)
    Set bytes_written to bytes_written plus 1

    Return bytes_written
End Process

Process called "encode_mov_reg_to_reg_64" takes buffer_ptr as Integer, dest_reg as Integer, src_reg as Integer returns Integer:
    Note: Encode MOV dest_reg, src_reg (64-bit)
    Note: Opcode: REX.W + 0x89 + ModR/M
    Note: REX.W = 0x48 base + extensions

    Let bytes_written be 0

    Note: Encode REX prefix (REX.W = 1, check for extended regs)
    Let rex be 72  Note: 0x48 = REX.W base

    Note: Check if src_reg is extended (R8-R15)
    If src_reg is greater than or equal to 8:
        Set rex to rex bitwise_or 4  Note: REX.R
    End If

    Note: Check if dest_reg is extended (R8-R15)
    If dest_reg is greater than or equal to 8:
        Set rex to rex bitwise_or 1  Note: REX.B
    End If

    Memory.memory_set_byte(buffer_ptr, 0, rex)
    Set bytes_written to 1

    Note: MOV opcode
    Memory.memory_set_byte(buffer_ptr, 1, 137)  Note: 0x89
    Set bytes_written to 2

    Note: ModR/M byte: mod=11 (register-register), reg=src, rm=dest
    Let src_field be src_reg bitwise_and 7
    Let dest_field be dest_reg bitwise_and 7
    Let modrm be 192 bitwise_or (src_field shifted left by 3) bitwise_or dest_field
    Memory.memory_set_byte(buffer_ptr, 2, modrm)
    Set bytes_written to 3

    Return bytes_written
End Process

Process called "encode_mov_imm_to_reg_64" takes buffer_ptr as Integer, dest_reg as Integer, immediate as Integer returns Integer:
    Note: Encode MOV dest_reg, immediate (64-bit)
    Note: Opcode: REX.W + 0xB8 + reg + imm64

    Let bytes_written be 0

    Note: Encode REX prefix
    Let rex be 72  Note: 0x48 = REX.W
    If dest_reg is greater than or equal to 8:
        Set rex to rex bitwise_or 1  Note: REX.B
    End If

    Memory.memory_set_byte(buffer_ptr, 0, rex)
    Set bytes_written to 1

    Note: MOV immediate opcode + register
    Let reg_field be dest_reg bitwise_and 7
    Let opcode be 184 plus reg_field  Note: 0xB8 + reg
    Memory.memory_set_byte(buffer_ptr, 1, opcode)
    Set bytes_written to 2

    Note: Write 64-bit immediate (little-endian)
    Memory.memory_set_int64(buffer_ptr, 2, immediate)
    Set bytes_written to 10  Note: 2 + 8 bytes

    Return bytes_written
End Process

Process called "encode_add_reg_reg_64" takes buffer_ptr as Integer, dest_reg as Integer, src_reg as Integer returns Integer:
    Note: Encode ADD dest_reg, src_reg (64-bit)
    Note: Opcode: REX.W + 0x01 + ModR/M

    Let bytes_written be 0

    Note: Encode REX prefix
    Let rex be 72  Note: 0x48 = REX.W
    If src_reg is greater than or equal to 8:
        Set rex to rex bitwise_or 4  Note: REX.R
    End If
    If dest_reg is greater than or equal to 8:
        Set rex to rex bitwise_or 1  Note: REX.B
    End If

    Memory.memory_set_byte(buffer_ptr, 0, rex)
    Set bytes_written to 1

    Note: ADD opcode
    Memory.memory_set_byte(buffer_ptr, 1, 1)  Note: 0x01
    Set bytes_written to 2

    Note: ModR/M byte
    Let src_field be src_reg bitwise_and 7
    Let dest_field be dest_reg bitwise_and 7
    Let modrm be 192 bitwise_or (src_field shifted left by 3) bitwise_or dest_field
    Memory.memory_set_byte(buffer_ptr, 2, modrm)
    Set bytes_written to 3

    Return bytes_written
End Process

Process called "encode_sub_reg_reg_64" takes buffer_ptr as Integer, dest_reg as Integer, src_reg as Integer returns Integer:
    Note: Encode SUB dest_reg, src_reg (64-bit)
    Note: Opcode: REX.W + 0x29 + ModR/M

    Let bytes_written be 0

    Note: Encode REX prefix
    Let rex be 72  Note: 0x48 = REX.W
    If src_reg is greater than or equal to 8:
        Set rex to rex bitwise_or 4  Note: REX.R
    End If
    If dest_reg is greater than or equal to 8:
        Set rex to rex bitwise_or 1  Note: REX.B
    End If

    Memory.memory_set_byte(buffer_ptr, 0, rex)
    Set bytes_written to 1

    Note: SUB opcode
    Memory.memory_set_byte(buffer_ptr, 1, 41)  Note: 0x29
    Set bytes_written to 2

    Note: ModR/M byte
    Let src_field be src_reg bitwise_and 7
    Let dest_field be dest_reg bitwise_and 7
    Let modrm be 192 bitwise_or (src_field shifted left by 3) bitwise_or dest_field
    Memory.memory_set_byte(buffer_ptr, 2, modrm)
    Set bytes_written to 3

    Return bytes_written
End Process

Process called "encode_call_relative" takes buffer_ptr as Integer, relative_offset as Integer returns Integer:
    Note: Encode CALL with 32-bit relative offset
    Note: Opcode: 0xE8 + rel32
    Note: Platform-independent encoding

    Memory.memory_set_byte(buffer_ptr, 0, 232)  Note: 0xE8 = CALL rel32

    Note: Write 32-bit relative offset (little-endian)
    Memory.memory_set_byte(buffer_ptr, 1, relative_offset bitwise_and 255)
    Memory.memory_set_byte(buffer_ptr, 2, (relative_offset shifted right by 8) bitwise_and 255)
    Memory.memory_set_byte(buffer_ptr, 3, (relative_offset shifted right by 16) bitwise_and 255)
    Memory.memory_set_byte(buffer_ptr, 4, (relative_offset shifted right by 24) bitwise_and 255)

    Return 5  Note: 5 bytes total
End Process

Process called "encode_jmp_relative" takes buffer_ptr as Integer, relative_offset as Integer returns Integer:
    Note: Encode JMP with 32-bit relative offset
    Note: Opcode: 0xE9 + rel32
    Note: Platform-independent encoding

    Memory.memory_set_byte(buffer_ptr, 0, 233)  Note: 0xE9 = JMP rel32

    Note: Write 32-bit relative offset (little-endian)
    Memory.memory_set_byte(buffer_ptr, 1, relative_offset bitwise_and 255)
    Memory.memory_set_byte(buffer_ptr, 2, (relative_offset shifted right by 8) bitwise_and 255)
    Memory.memory_set_byte(buffer_ptr, 3, (relative_offset shifted right by 16) bitwise_and 255)
    Memory.memory_set_byte(buffer_ptr, 4, (relative_offset shifted right by 24) bitwise_and 255)

    Return 5  Note: 5 bytes total
End Process

Note: ============================================================================
Note: CODE ALIGNMENT AND PADDING
Note: ============================================================================

Process called "align_code_to_boundary" takes buffer_ptr as Integer, current_offset as Integer, alignment as Integer returns Integer:
    Note: Align code pointer to specified boundary (4, 8, 16 bytes)
    Note: Fills with NOP instructions (0x90)
    Note: Returns new offset after alignment

    Let remainder be current_offset bitwise_and (alignment minus 1)
    If remainder is equal to 0:
        Return current_offset  Note: Already aligned
    End If

    Note: Calculate padding needed
    Let padding_bytes be alignment minus remainder

    Note: Fill with NOP instructions
    Let i be 0
    While i is less than padding_bytes:
        Memory.memory_set_byte(buffer_ptr, current_offset plus i, 144)  Note: 0x90 = NOP
        Set i to i plus 1
    End While

    Return current_offset plus padding_bytes
End Process

Process called "get_nop_instruction_bytes" takes buffer_ptr as Integer, count as Integer returns Integer:
    Note: Fill buffer with NOP instructions
    Note: count: number of NOP bytes to generate
    Note: Returns count

    Let i be 0
    While i is less than count:
        Memory.memory_set_byte(buffer_ptr, i, 144)  Note: 0x90 = NOP
        Set i to i plus 1
    End While

    Return count
End Process

Note: ============================================================================
Note: PLATFORM NOTE
Note: ============================================================================
Note: This file provides basic x86_64 machine code encoding utilities.
Note: These encodings are IDENTICAL on Windows, Linux, macOS, and all x86_64 platforms.
Note:
Note: For comprehensive x86_64 instruction encoding, see linux_x86_64/machine_code.runa
Note: The encodings are byte-for-byte identical - only the object file format differs.
Note:
Note: Platform-specific aspects handled elsewhere:
Note: - Calling convention: calling_convention.runa (Microsoft x64)
Note: - System calls: syscall.runa (Windows NT API)
Note: - Object file format: Assembler/linker (PE/COFF format)
