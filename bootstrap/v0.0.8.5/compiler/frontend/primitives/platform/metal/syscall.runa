Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
Metal Device API Implementation

This file implements Metal device API calls for GPU kernel execution.

Platform-specific details:
- Platform: Metal (Apple GPU)
- Architecture: Metal Shading Language (MSL)
- API Convention: Metal Framework API
- Execution Model: Compute kernels with threadgroups

Metal uses device APIs rather than traditional OS syscalls:
1. Device management (MTLCreateSystemDefaultDevice, device properties)
2. Command queue and buffer management
3. Compute pipeline state creation
4. Kernel execution (command encoders)
5. Resource management (buffers, textures)
6. Synchronization primitives

This implementation provides low-level bindings to Metal Framework APIs.
:End Note

Note: ============================================================================
Note: METAL API RETURN CODES
Note: ============================================================================

Process called "METAL_SUCCESS" returns Integer:
    Note: Operation completed successfully
    Return 0
End Process

Process called "METAL_ERROR_INVALID_ARGUMENT" returns Integer:
    Note: Invalid argument passed to API
    Return 1
End Process

Process called "METAL_ERROR_OUT_OF_MEMORY" returns Integer:
    Note: Out of device memory
    Return 2
End Process

Process called "METAL_ERROR_NO_DEVICE" returns Integer:
    Note: No Metal-capable device found
    Return 3
End Process

Process called "METAL_ERROR_LIBRARY_NOT_FOUND" returns Integer:
    Note: Metal library file not found
    Return 4
End Process

Process called "METAL_ERROR_FUNCTION_NOT_FOUND" returns Integer:
    Note: Kernel function not found in library
    Return 5
End Process

Note: ============================================================================
Note: METAL RESOURCE OPTIONS
Note: ============================================================================

Process called "MTLResourceStorageModeShared" returns Integer:
    Note: CPU and GPU can access this resource
    Return 0
End Process

Process called "MTLResourceStorageModeManaged" returns Integer:
    Note: Explicit synchronization between CPU and GPU
    Return 1
End Process

Process called "MTLResourceStorageModePrivate" returns Integer:
    Note: GPU-only access (fastest for GPU)
    Return 2
End Process

Process called "MTLResourceStorageModeMemoryless" returns Integer:
    Note: Tile memory only (iOS/tvOS)
    Return 3
End Process

Process called "MTLResourceCPUCacheModeDefaultCache" returns Integer:
    Note: Default CPU cache mode
    Return 0
End Process

Process called "MTLResourceCPUCacheModeWriteCombined" returns Integer:
    Note: Write-combined CPU cache mode
    Return 1
End Process

Note: ============================================================================
Note: METAL DEVICE MANAGEMENT
Note: ============================================================================

Process called "metal_create_system_default_device" takes device_ptr as Integer returns Integer:
    Note: Create system default Metal device
    Note: device_ptr: Pointer to receive device handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: MTLCreateSystemDefaultDevice()
        // This creates the default GPU device
    End Assembly
    Return result
End Process

Process called "metal_device_get_name" takes device as Integer, name_buffer as Integer returns Integer:
    Note: Get device name
    Note: device: Device handle
    Note: name_buffer: Buffer to receive device name string
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device name]
    End Assembly
    Return result
End Process

Process called "metal_device_supports_feature_set" takes device as Integer, feature_set as Integer returns Integer:
    Note: Check if device supports feature set
    Note: device: Device handle
    Note: feature_set: MTLFeatureSet value
    Note: Returns: 1 if supported, 0 otherwise
    Let result be 0
    Inline Assembly:
        // Objective-C: [device supportsFeatureSet:featureSet]
    End Assembly
    Return result
End Process

Process called "metal_device_get_max_threads_per_threadgroup" takes device as Integer returns Integer:
    Note: Get maximum threads per threadgroup
    Note: device: Device handle
    Note: Returns: Maximum threads per threadgroup
    Let result be 1024  Note: Typical value
    Inline Assembly:
        // Objective-C: device.maxThreadsPerThreadgroup.width
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL COMMAND QUEUE
Note: ============================================================================

Process called "metal_new_command_queue" takes device as Integer, queue_ptr as Integer returns Integer:
    Note: Create new command queue
    Note: device: Device handle
    Note: queue_ptr: Pointer to receive queue handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newCommandQueue]
    End Assembly
    Return result
End Process

Process called "metal_command_queue_command_buffer" takes queue as Integer, buffer_ptr as Integer returns Integer:
    Note: Create command buffer from queue
    Note: queue: Command queue handle
    Note: buffer_ptr: Pointer to receive command buffer
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [commandQueue commandBuffer]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL BUFFER MANAGEMENT
Note: ============================================================================

Process called "metal_new_buffer" takes device as Integer, length as Integer, options as Integer, buffer_ptr as Integer returns Integer:
    Note: Create new buffer
    Note: device: Device handle
    Note: length: Buffer size in bytes
    Note: options: Resource options (storage mode, cache mode)
    Note: buffer_ptr: Pointer to receive buffer handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newBufferWithLength:length options:options]
    End Assembly
    Return result
End Process

Process called "metal_new_buffer_with_bytes" takes device as Integer, bytes as Integer, length as Integer, options as Integer, buffer_ptr as Integer returns Integer:
    Note: Create buffer with initial data
    Note: device: Device handle
    Note: bytes: Pointer to initial data
    Note: length: Buffer size in bytes
    Note: options: Resource options
    Note: buffer_ptr: Pointer to receive buffer handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newBufferWithBytes:bytes length:length options:options]
    End Assembly
    Return result
End Process

Process called "metal_buffer_get_contents" takes buffer as Integer returns Integer:
    Note: Get CPU-accessible pointer to buffer contents
    Note: buffer: Buffer handle
    Note: Returns: Pointer to buffer contents
    Let result be 0
    Inline Assembly:
        // Objective-C: [buffer contents]
    End Assembly
    Return result
End Process

Process called "metal_buffer_get_length" takes buffer as Integer returns Integer:
    Note: Get buffer length
    Note: buffer: Buffer handle
    Note: Returns: Buffer size in bytes
    Let result be 0
    Inline Assembly:
        // Objective-C: [buffer length]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL LIBRARY AND FUNCTION
Note: ============================================================================

Process called "metal_new_default_library" takes device as Integer, library_ptr as Integer returns Integer:
    Note: Create library from default metallib in app bundle
    Note: device: Device handle
    Note: library_ptr: Pointer to receive library handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newDefaultLibrary]
    End Assembly
    Return result
End Process

Process called "metal_new_library_with_source" takes device as Integer, source as Integer, options as Integer, library_ptr as Integer returns Integer:
    Note: Create library from Metal source code
    Note: device: Device handle
    Note: source: MSL source code string
    Note: options: Compile options
    Note: library_ptr: Pointer to receive library handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newLibraryWithSource:source options:options error:&error]
    End Assembly
    Return result
End Process

Process called "metal_library_new_function_with_name" takes library as Integer, name as Integer, function_ptr as Integer returns Integer:
    Note: Get function from library by name
    Note: library: Library handle
    Note: name: Function name string
    Note: function_ptr: Pointer to receive function handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [library newFunctionWithName:name]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL COMPUTE PIPELINE STATE
Note: ============================================================================

Process called "metal_new_compute_pipeline_state" takes device as Integer, function as Integer, pipeline_ptr as Integer returns Integer:
    Note: Create compute pipeline state from function
    Note: device: Device handle
    Note: function: Kernel function handle
    Note: pipeline_ptr: Pointer to receive pipeline state
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newComputePipelineStateWithFunction:function error:&error]
    End Assembly
    Return result
End Process

Process called "metal_pipeline_get_max_total_threads_per_threadgroup" takes pipeline as Integer returns Integer:
    Note: Get maximum total threads per threadgroup for pipeline
    Note: pipeline: Pipeline state handle
    Note: Returns: Maximum threads per threadgroup
    Let result be 0
    Inline Assembly:
        // Objective-C: [pipelineState maxTotalThreadsPerThreadgroup]
    End Assembly
    Return result
End Process

Process called "metal_pipeline_get_threadgroup_memory_length" takes pipeline as Integer returns Integer:
    Note: Get threadgroup memory length
    Note: pipeline: Pipeline state handle
    Note: Returns: Threadgroup memory size in bytes
    Let result be 0
    Inline Assembly:
        // Objective-C: [pipelineState threadExecutionWidth]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL COMPUTE COMMAND ENCODER
Note: ============================================================================

Process called "metal_command_buffer_compute_encoder" takes command_buffer as Integer, encoder_ptr as Integer returns Integer:
    Note: Create compute command encoder
    Note: command_buffer: Command buffer handle
    Note: encoder_ptr: Pointer to receive encoder handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [commandBuffer computeCommandEncoder]
    End Assembly
    Return result
End Process

Process called "metal_encoder_set_compute_pipeline_state" takes encoder as Integer, pipeline as Integer returns Integer:
    Note: Set compute pipeline state
    Note: encoder: Compute command encoder handle
    Note: pipeline: Pipeline state handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [computeEncoder setComputePipelineState:pipelineState]
    End Assembly
    Return result
End Process

Process called "metal_encoder_set_buffer" takes encoder as Integer, buffer as Integer, offset as Integer, index as Integer returns Integer:
    Note: Set buffer argument
    Note: encoder: Compute command encoder handle
    Note: buffer: Buffer handle
    Note: offset: Offset into buffer
    Note: index: Argument index
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [computeEncoder setBuffer:buffer offset:offset atIndex:index]
    End Assembly
    Return result
End Process

Process called "metal_encoder_set_bytes" takes encoder as Integer, bytes as Integer, length as Integer, index as Integer returns Integer:
    Note: Set bytes argument (small data)
    Note: encoder: Compute command encoder handle
    Note: bytes: Pointer to data
    Note: length: Data size in bytes
    Note: index: Argument index
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [computeEncoder setBytes:bytes length:length atIndex:index]
    End Assembly
    Return result
End Process

Process called "metal_encoder_dispatch_threadgroups" takes encoder as Integer, threadgroups_x as Integer, threadgroups_y as Integer, threadgroups_z as Integer, threads_x as Integer, threads_y as Integer, threads_z as Integer returns Integer:
    Note: Dispatch threadgroups
    Note: encoder: Compute command encoder handle
    Note: threadgroups_x/y/z: Number of threadgroups in each dimension
    Note: threads_x/y/z: Threads per threadgroup in each dimension
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [computeEncoder dispatchThreadgroups:MTLSizeMake(threadgroups_x, threadgroups_y, threadgroups_z)
        //                       threadsPerThreadgroup:MTLSizeMake(threads_x, threads_y, threads_z)]
    End Assembly
    Return result
End Process

Process called "metal_encoder_dispatch_threads" takes encoder as Integer, threads_x as Integer, threads_y as Integer, threads_z as Integer, threadgroup_x as Integer, threadgroup_y as Integer, threadgroup_z as Integer returns Integer:
    Note: Dispatch threads directly (Metal 2.0+)
    Note: encoder: Compute command encoder handle
    Note: threads_x/y/z: Total threads in each dimension
    Note: threadgroup_x/y/z: Threads per threadgroup in each dimension
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [computeEncoder dispatchThreads:MTLSizeMake(threads_x, threads_y, threads_z)
        //                       threadsPerThreadgroup:MTLSizeMake(threadgroup_x, threadgroup_y, threadgroup_z)]
    End Assembly
    Return result
End Process

Process called "metal_encoder_end_encoding" takes encoder as Integer returns Integer:
    Note: End encoding commands
    Note: encoder: Command encoder handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [encoder endEncoding]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL COMMAND BUFFER EXECUTION
Note: ============================================================================

Process called "metal_command_buffer_commit" takes command_buffer as Integer returns Integer:
    Note: Commit command buffer for execution
    Note: command_buffer: Command buffer handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [commandBuffer commit]
    End Assembly
    Return result
End Process

Process called "metal_command_buffer_wait_until_completed" takes command_buffer as Integer returns Integer:
    Note: Wait for command buffer to complete
    Note: command_buffer: Command buffer handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [commandBuffer waitUntilCompleted]
    End Assembly
    Return result
End Process

Process called "metal_command_buffer_add_completed_handler" takes command_buffer as Integer, handler as Integer returns Integer:
    Note: Add completion handler callback
    Note: command_buffer: Command buffer handle
    Note: handler: Function pointer for completion callback
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [commandBuffer addCompletedHandler:^(id<MTLCommandBuffer> buffer){ handler(buffer); }]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL TEXTURE MANAGEMENT
Note: ============================================================================

Process called "metal_new_texture" takes device as Integer, descriptor as Integer, texture_ptr as Integer returns Integer:
    Note: Create new texture
    Note: device: Device handle
    Note: descriptor: Texture descriptor
    Note: texture_ptr: Pointer to receive texture handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newTextureWithDescriptor:descriptor]
    End Assembly
    Return result
End Process

Process called "metal_texture_get_width" takes texture as Integer returns Integer:
    Note: Get texture width
    Note: texture: Texture handle
    Note: Returns: Texture width in pixels
    Let result be 0
    Inline Assembly:
        // Objective-C: [texture width]
    End Assembly
    Return result
End Process

Process called "metal_texture_get_height" takes texture as Integer returns Integer:
    Note: Get texture height
    Note: texture: Texture handle
    Note: Returns: Texture height in pixels
    Let result be 0
    Inline Assembly:
        // Objective-C: [texture height]
    End Assembly
    Return result
End Process

Process called "metal_texture_replace_region" takes texture as Integer, region_x as Integer, region_y as Integer, region_width as Integer, region_height as Integer, level as Integer, bytes as Integer returns Integer:
    Note: Replace texture region with new data
    Note: texture: Texture handle
    Note: region_x/y: Region origin
    Note: region_width/height: Region size
    Note: level: Mipmap level
    Note: bytes: Pointer to pixel data
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [texture replaceRegion:MTLRegionMake2D(region_x, region_y, region_width, region_height)
        //                       mipmapLevel:level withBytes:bytes bytesPerRow:bytesPerRow]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL SYNCHRONIZATION
Note: ============================================================================

Process called "metal_encoder_use_resource" takes encoder as Integer, resource as Integer, usage as Integer returns Integer:
    Note: Declare resource usage for synchronization
    Note: encoder: Command encoder handle
    Note: resource: Resource handle (buffer or texture)
    Note: usage: Resource usage flags
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [encoder useResource:resource usage:usage]
    End Assembly
    Return result
End Process

Process called "metal_encoder_memory_barrier" takes encoder as Integer, scope as Integer returns Integer:
    Note: Insert memory barrier
    Note: encoder: Command encoder handle
    Note: scope: Barrier scope
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [encoder memoryBarrierWithScope:scope]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL PERFORMANCE AND PROFILING
Note: ============================================================================

Process called "metal_command_buffer_get_gpu_start_time" takes command_buffer as Integer returns Integer:
    Note: Get GPU start time
    Note: command_buffer: Command buffer handle
    Note: Returns: GPU start time in seconds (as fixed-point)
    Let result be 0
    Inline Assembly:
        // Objective-C: [commandBuffer GPUStartTime]
    End Assembly
    Return result
End Process

Process called "metal_command_buffer_get_gpu_end_time" takes command_buffer as Integer returns Integer:
    Note: Get GPU end time
    Note: command_buffer: Command buffer handle
    Note: Returns: GPU end time in seconds (as fixed-point)
    Let result be 0
    Inline Assembly:
        // Objective-C: [commandBuffer GPUEndTime]
    End Assembly
    Return result
End Process

Process called "metal_encoder_push_debug_group" takes encoder as Integer, label as Integer returns Integer:
    Note: Push debug group (for profiling tools)
    Note: encoder: Command encoder handle
    Note: label: Debug group label string
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [encoder pushDebugGroup:label]
    End Assembly
    Return result
End Process

Process called "metal_encoder_pop_debug_group" takes encoder as Integer returns Integer:
    Note: Pop debug group
    Note: encoder: Command encoder handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [encoder popDebugGroup]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL ARGUMENT BUFFERS (Metal 2.0+)
Note: ============================================================================

Process called "metal_new_argument_encoder" takes function as Integer, index as Integer, encoder_ptr as Integer returns Integer:
    Note: Create argument encoder for argument buffer
    Note: function: Function handle
    Note: index: Argument buffer index
    Note: encoder_ptr: Pointer to receive argument encoder
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [function newArgumentEncoderWithBufferIndex:index]
    End Assembly
    Return result
End Process

Process called "metal_argument_encoder_set_buffer" takes encoder as Integer, buffer as Integer, offset as Integer, index as Integer returns Integer:
    Note: Set buffer in argument buffer
    Note: encoder: Argument encoder handle
    Note: buffer: Buffer handle
    Note: offset: Offset into buffer
    Note: index: Argument index
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [argumentEncoder setBuffer:buffer offset:offset atIndex:index]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL EXTENDED DEVICE MANAGEMENT
Note: ============================================================================

Process called "metal_copy_all_devices" takes devices_ptr as Integer, count_ptr as Integer returns Integer:
    Note: Get array of all Metal devices
    Note: devices_ptr: Pointer to receive device array
    Note: count_ptr: Pointer to receive device count
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: MTLCopyAllDevices()
    End Assembly
    Return result
End Process

Process called "metal_device_supports_family" takes device as Integer, family as Integer returns Integer:
    Note: Check if device supports GPU family
    Note: device: Device handle
    Note: family: MTLGPUFamily value
    Note: Returns: 1 if supported, 0 otherwise
    Let result be 0
    Inline Assembly:
        // Objective-C: [device supportsFamily:family]
    End Assembly
    Return result
End Process

Process called "metal_device_get_recommended_max_working_set_size" takes device as Integer returns Integer:
    Note: Get recommended maximum working set size
    Note: device: Device handle
    Note: Returns: Recommended working set size in bytes
    Let result be 0
    Inline Assembly:
        // Objective-C: [device recommendedMaxWorkingSetSize]
    End Assembly
    Return result
End Process

Process called "metal_device_get_max_buffer_length" takes device as Integer returns Integer:
    Note: Get maximum buffer length
    Note: device: Device handle
    Note: Returns: Maximum buffer size in bytes
    Let result be 0
    Inline Assembly:
        // Objective-C: [device maxBufferLength]
    End Assembly
    Return result
End Process

Process called "metal_device_is_low_power" takes device as Integer returns Integer:
    Note: Check if device is low-power (integrated GPU)
    Note: device: Device handle
    Note: Returns: 1 if low-power, 0 otherwise
    Let result be 0
    Inline Assembly:
        // Objective-C: [device isLowPower]
    End Assembly
    Return result
End Process

Process called "metal_device_is_headless" takes device as Integer returns Integer:
    Note: Check if device is headless (no display)
    Note: device: Device handle
    Note: Returns: 1 if headless, 0 otherwise
    Let result be 0
    Inline Assembly:
        // Objective-C: [device isHeadless]
    End Assembly
    Return result
End Process

Process called "metal_device_is_removable" takes device as Integer returns Integer:
    Note: Check if device is removable (eGPU)
    Note: device: Device handle
    Note: Returns: 1 if removable, 0 otherwise
    Let result be 0
    Inline Assembly:
        // Objective-C: [device isRemovable]
    End Assembly
    Return result
End Process

Process called "metal_device_get_registry_id" takes device as Integer returns Integer:
    Note: Get device registry ID
    Note: device: Device handle
    Note: Returns: Registry ID
    Let result be 0
    Inline Assembly:
        // Objective-C: [device registryID]
    End Assembly
    Return result
End Process

Process called "metal_device_get_current_allocated_size" takes device as Integer returns Integer:
    Note: Get currently allocated memory size
    Note: device: Device handle
    Note: Returns: Allocated size in bytes
    Let result be 0
    Inline Assembly:
        // Objective-C: [device currentAllocatedSize]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL EXTENDED COMMAND QUEUE
Note: ============================================================================

Process called "metal_new_command_queue_with_max_command_buffers" takes device as Integer, max_buffers as Integer, queue_ptr as Integer returns Integer:
    Note: Create command queue with max command buffers
    Note: device: Device handle
    Note: max_buffers: Maximum command buffers
    Note: queue_ptr: Pointer to receive queue handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newCommandQueueWithMaxCommandBufferCount:maxBuffers]
    End Assembly
    Return result
End Process

Process called "metal_command_queue_command_buffer_with_unretained_references" takes queue as Integer, buffer_ptr as Integer returns Integer:
    Note: Create command buffer with unretained references
    Note: queue: Command queue handle
    Note: buffer_ptr: Pointer to receive command buffer
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [commandQueue commandBufferWithUnretainedReferences]
    End Assembly
    Return result
End Process

Process called "metal_command_queue_set_label" takes queue as Integer, label as Integer returns Integer:
    Note: Set command queue label
    Note: queue: Command queue handle
    Note: label: Label string
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [commandQueue setLabel:label]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL EXTENDED BUFFER MANAGEMENT
Note: ============================================================================

Process called "metal_new_buffer_with_bytes_no_copy" takes device as Integer, bytes as Integer, length as Integer, options as Integer, deallocator as Integer, buffer_ptr as Integer returns Integer:
    Note: Create buffer with no-copy bytes
    Note: device: Device handle
    Note: bytes: Pointer to existing data
    Note: length: Buffer size in bytes
    Note: options: Resource options
    Note: deallocator: Deallocator callback (or null)
    Note: buffer_ptr: Pointer to receive buffer handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newBufferWithBytesNoCopy:bytes length:length options:options deallocator:deallocator]
    End Assembly
    Return result
End Process

Process called "metal_buffer_did_modify_range" takes buffer as Integer, range_location as Integer, range_length as Integer returns Integer:
    Note: Notify buffer of modified range (for managed storage)
    Note: buffer: Buffer handle
    Note: range_location: Start of modified range
    Note: range_length: Length of modified range
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [buffer didModifyRange:NSMakeRange(range_location, range_length)]
    End Assembly
    Return result
End Process

Process called "metal_buffer_add_debug_marker" takes buffer as Integer, marker as Integer, range_location as Integer, range_length as Integer returns Integer:
    Note: Add debug marker to buffer range
    Note: buffer: Buffer handle
    Note: marker: Marker string
    Note: range_location: Start of range
    Note: range_length: Length of range
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [buffer addDebugMarker:marker range:NSMakeRange(range_location, range_length)]
    End Assembly
    Return result
End Process

Process called "metal_buffer_remove_all_debug_markers" takes buffer as Integer returns Integer:
    Note: Remove all debug markers from buffer
    Note: buffer: Buffer handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [buffer removeAllDebugMarkers]
    End Assembly
    Return result
End Process

Process called "metal_buffer_get_gpu_address" takes buffer as Integer returns Integer:
    Note: Get GPU virtual address of buffer (Metal 3.0+)
    Note: buffer: Buffer handle
    Note: Returns: GPU address
    Let result be 0
    Inline Assembly:
        // Objective-C: [buffer gpuAddress]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL EXTENDED LIBRARY AND FUNCTION
Note: ============================================================================

Process called "metal_new_library_with_file" takes device as Integer, file_path as Integer, library_ptr as Integer returns Integer:
    Note: Create library from metallib file
    Note: device: Device handle
    Note: file_path: Path to .metallib file
    Note: library_ptr: Pointer to receive library handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newLibraryWithFile:filePath error:&error]
    End Assembly
    Return result
End Process

Process called "metal_new_library_with_data" takes device as Integer, data as Integer, library_ptr as Integer returns Integer:
    Note: Create library from binary data
    Note: device: Device handle
    Note: data: Binary library data
    Note: library_ptr: Pointer to receive library handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newLibraryWithData:data error:&error]
    End Assembly
    Return result
End Process

Process called "metal_library_new_function_with_descriptor" takes library as Integer, descriptor as Integer, function_ptr as Integer returns Integer:
    Note: Create function with descriptor
    Note: library: Library handle
    Note: descriptor: Function descriptor
    Note: function_ptr: Pointer to receive function handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [library newFunctionWithDescriptor:descriptor error:&error]
    End Assembly
    Return result
End Process

Process called "metal_library_get_function_names" takes library as Integer, names_ptr as Integer, count_ptr as Integer returns Integer:
    Note: Get array of function names in library
    Note: library: Library handle
    Note: names_ptr: Pointer to receive string array
    Note: count_ptr: Pointer to receive count
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [library functionNames]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL EXTENDED COMPUTE PIPELINE STATE
Note: ============================================================================

Process called "metal_new_compute_pipeline_state_with_descriptor" takes device as Integer, descriptor as Integer, pipeline_ptr as Integer returns Integer:
    Note: Create compute pipeline state with descriptor
    Note: device: Device handle
    Note: descriptor: Pipeline descriptor
    Note: pipeline_ptr: Pointer to receive pipeline state
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newComputePipelineStateWithDescriptor:descriptor options:0 reflection:nil error:&error]
    End Assembly
    Return result
End Process

Process called "metal_pipeline_get_thread_execution_width" takes pipeline as Integer returns Integer:
    Note: Get thread execution width (SIMD width)
    Note: pipeline: Pipeline state handle
    Note: Returns: Thread execution width
    Let result be 0
    Inline Assembly:
        // Objective-C: [pipelineState threadExecutionWidth]
    End Assembly
    Return result
End Process

Process called "metal_pipeline_get_support_indirect_command_buffers" takes pipeline as Integer returns Integer:
    Note: Check if pipeline supports indirect command buffers
    Note: pipeline: Pipeline state handle
    Note: Returns: 1 if supported, 0 otherwise
    Let result be 0
    Inline Assembly:
        // Objective-C: [pipelineState supportIndirectCommandBuffers]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL EXTENDED COMPUTE COMMAND ENCODER
Note: ============================================================================

Process called "metal_command_buffer_compute_encoder_with_descriptor" takes command_buffer as Integer, descriptor as Integer, encoder_ptr as Integer returns Integer:
    Note: Create compute command encoder with descriptor
    Note: command_buffer: Command buffer handle
    Note: descriptor: Encoder descriptor
    Note: encoder_ptr: Pointer to receive encoder handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [commandBuffer computeCommandEncoderWithDescriptor:descriptor]
    End Assembly
    Return result
End Process

Process called "metal_encoder_set_buffers" takes encoder as Integer, buffers as Integer, offsets as Integer, start_index as Integer, count as Integer returns Integer:
    Note: Set multiple buffers at once
    Note: encoder: Compute command encoder handle
    Note: buffers: Array of buffer handles
    Note: offsets: Array of offsets
    Note: start_index: Starting argument index
    Note: count: Number of buffers
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [computeEncoder setBuffers:buffers offsets:offsets withRange:NSMakeRange(start_index, count)]
    End Assembly
    Return result
End Process

Process called "metal_encoder_set_texture" takes encoder as Integer, texture as Integer, index as Integer returns Integer:
    Note: Set texture argument
    Note: encoder: Compute command encoder handle
    Note: texture: Texture handle
    Note: index: Argument index
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [computeEncoder setTexture:texture atIndex:index]
    End Assembly
    Return result
End Process

Process called "metal_encoder_set_textures" takes encoder as Integer, textures as Integer, start_index as Integer, count as Integer returns Integer:
    Note: Set multiple textures at once
    Note: encoder: Compute command encoder handle
    Note: textures: Array of texture handles
    Note: start_index: Starting argument index
    Note: count: Number of textures
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [computeEncoder setTextures:textures withRange:NSMakeRange(start_index, count)]
    End Assembly
    Return result
End Process

Process called "metal_encoder_set_sampler_state" takes encoder as Integer, sampler as Integer, index as Integer returns Integer:
    Note: Set sampler state argument
    Note: encoder: Compute command encoder handle
    Note: sampler: Sampler state handle
    Note: index: Argument index
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [computeEncoder setSamplerState:sampler atIndex:index]
    End Assembly
    Return result
End Process

Process called "metal_encoder_set_sampler_states" takes encoder as Integer, samplers as Integer, start_index as Integer, count as Integer returns Integer:
    Note: Set multiple sampler states at once
    Note: encoder: Compute command encoder handle
    Note: samplers: Array of sampler handles
    Note: start_index: Starting argument index
    Note: count: Number of samplers
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [computeEncoder setSamplerStates:samplers withRange:NSMakeRange(start_index, count)]
    End Assembly
    Return result
End Process

Process called "metal_encoder_set_threadgroup_memory_length" takes encoder as Integer, length as Integer, index as Integer returns Integer:
    Note: Set threadgroup memory length
    Note: encoder: Compute command encoder handle
    Note: length: Memory size in bytes
    Note: index: Binding index
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [computeEncoder setThreadgroupMemoryLength:length atIndex:index]
    End Assembly
    Return result
End Process

Process called "metal_encoder_set_stage_in_region" takes encoder as Integer, region_x as Integer, region_y as Integer, region_z as Integer returns Integer:
    Note: Set stage-in region
    Note: encoder: Compute command encoder handle
    Note: region_x/y/z: Region origin
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [computeEncoder setStageInRegion:MTLRegionMake3D(region_x, region_y, region_z, 1, 1, 1)]
    End Assembly
    Return result
End Process

Process called "metal_encoder_dispatch_threadgroups_indirect" takes encoder as Integer, indirect_buffer as Integer, indirect_offset as Integer, threads_x as Integer, threads_y as Integer, threads_z as Integer returns Integer:
    Note: Dispatch threadgroups with indirect buffer
    Note: encoder: Compute command encoder handle
    Note: indirect_buffer: Buffer containing dispatch parameters
    Note: indirect_offset: Offset into indirect buffer
    Note: threads_x/y/z: Threads per threadgroup
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [computeEncoder dispatchThreadgroupsWithIndirectBuffer:indirect_buffer
        //                       indirectBufferOffset:indirect_offset
        //                       threadsPerThreadgroup:MTLSizeMake(threads_x, threads_y, threads_z)]
    End Assembly
    Return result
End Process

Process called "metal_encoder_dispatch_threads_indirect" takes encoder as Integer, indirect_buffer as Integer, indirect_offset as Integer returns Integer:
    Note: Dispatch threads with indirect buffer (Metal 2.0+)
    Note: encoder: Compute command encoder handle
    Note: indirect_buffer: Buffer containing dispatch parameters
    Note: indirect_offset: Offset into indirect buffer
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [computeEncoder dispatchThreadsWithIndirectBuffer:indirect_buffer indirectBufferOffset:indirect_offset]
    End Assembly
    Return result
End Process

Process called "metal_encoder_update_fence" takes encoder as Integer, fence as Integer returns Integer:
    Note: Update fence after commands
    Note: encoder: Compute command encoder handle
    Note: fence: Fence handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [computeEncoder updateFence:fence]
    End Assembly
    Return result
End Process

Process called "metal_encoder_wait_for_fence" takes encoder as Integer, fence as Integer returns Integer:
    Note: Wait for fence before commands
    Note: encoder: Compute command encoder handle
    Note: fence: Fence handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [computeEncoder waitForFence:fence]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL EXTENDED COMMAND BUFFER EXECUTION
Note: ============================================================================

Process called "metal_command_buffer_wait_until_scheduled" takes command_buffer as Integer returns Integer:
    Note: Wait until command buffer is scheduled
    Note: command_buffer: Command buffer handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [commandBuffer waitUntilScheduled]
    End Assembly
    Return result
End Process

Process called "metal_command_buffer_get_status" takes command_buffer as Integer returns Integer:
    Note: Get command buffer status
    Note: command_buffer: Command buffer handle
    Note: Returns: Status code
    Let result be 0
    Inline Assembly:
        // Objective-C: [commandBuffer status]
    End Assembly
    Return result
End Process

Process called "metal_command_buffer_get_error" takes command_buffer as Integer, error_ptr as Integer returns Integer:
    Note: Get command buffer error
    Note: command_buffer: Command buffer handle
    Note: error_ptr: Pointer to receive error
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [commandBuffer error]
    End Assembly
    Return result
End Process

Process called "metal_command_buffer_add_scheduled_handler" takes command_buffer as Integer, handler as Integer returns Integer:
    Note: Add scheduled handler callback
    Note: command_buffer: Command buffer handle
    Note: handler: Function pointer for scheduled callback
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [commandBuffer addScheduledHandler:^(id<MTLCommandBuffer> buffer){ handler(buffer); }]
    End Assembly
    Return result
End Process

Process called "metal_command_buffer_present_drawable" takes command_buffer as Integer, drawable as Integer returns Integer:
    Note: Present drawable when command buffer completes
    Note: command_buffer: Command buffer handle
    Note: drawable: Drawable handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [commandBuffer presentDrawable:drawable]
    End Assembly
    Return result
End Process

Process called "metal_command_buffer_enqueue" takes command_buffer as Integer returns Integer:
    Note: Enqueue command buffer without committing
    Note: command_buffer: Command buffer handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [commandBuffer enqueue]
    End Assembly
    Return result
End Process

Process called "metal_command_buffer_get_kernel_start_time" takes command_buffer as Integer returns Integer:
    Note: Get kernel start time
    Note: command_buffer: Command buffer handle
    Note: Returns: Kernel start time
    Let result be 0
    Inline Assembly:
        // Objective-C: [commandBuffer kernelStartTime]
    End Assembly
    Return result
End Process

Process called "metal_command_buffer_get_kernel_end_time" takes command_buffer as Integer returns Integer:
    Note: Get kernel end time
    Note: command_buffer: Command buffer handle
    Note: Returns: Kernel end time
    Let result be 0
    Inline Assembly:
        // Objective-C: [commandBuffer kernelEndTime]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL EXTENDED TEXTURE MANAGEMENT
Note: ============================================================================

Process called "metal_new_texture_with_iosurface" takes device as Integer, descriptor as Integer, iosurface as Integer, plane as Integer, texture_ptr as Integer returns Integer:
    Note: Create texture from IOSurface
    Note: device: Device handle
    Note: descriptor: Texture descriptor
    Note: iosurface: IOSurface handle
    Note: plane: Plane index
    Note: texture_ptr: Pointer to receive texture handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newTextureWithDescriptor:descriptor iosurface:iosurface plane:plane]
    End Assembly
    Return result
End Process

Process called "metal_texture_get_depth" takes texture as Integer returns Integer:
    Note: Get texture depth
    Note: texture: Texture handle
    Note: Returns: Texture depth
    Let result be 0
    Inline Assembly:
        // Objective-C: [texture depth]
    End Assembly
    Return result
End Process

Process called "metal_texture_get_array_length" takes texture as Integer returns Integer:
    Note: Get texture array length
    Note: texture: Texture handle
    Note: Returns: Array length
    Let result be 0
    Inline Assembly:
        // Objective-C: [texture arrayLength]
    End Assembly
    Return result
End Process

Process called "metal_texture_get_mipmap_level_count" takes texture as Integer returns Integer:
    Note: Get number of mipmap levels
    Note: texture: Texture handle
    Note: Returns: Mipmap level count
    Let result be 0
    Inline Assembly:
        // Objective-C: [texture mipmapLevelCount]
    End Assembly
    Return result
End Process

Process called "metal_texture_get_sample_count" takes texture as Integer returns Integer:
    Note: Get texture sample count (for MSAA)
    Note: texture: Texture handle
    Note: Returns: Sample count
    Let result be 0
    Inline Assembly:
        // Objective-C: [texture sampleCount]
    End Assembly
    Return result
End Process

Process called "metal_texture_get_texture_type" takes texture as Integer returns Integer:
    Note: Get texture type
    Note: texture: Texture handle
    Note: Returns: Texture type enum
    Let result be 0
    Inline Assembly:
        // Objective-C: [texture textureType]
    End Assembly
    Return result
End Process

Process called "metal_texture_get_pixel_format" takes texture as Integer returns Integer:
    Note: Get pixel format
    Note: texture: Texture handle
    Note: Returns: Pixel format enum
    Let result be 0
    Inline Assembly:
        // Objective-C: [texture pixelFormat]
    End Assembly
    Return result
End Process

Process called "metal_texture_replace_region_3d" takes texture as Integer, region_x as Integer, region_y as Integer, region_z as Integer, region_width as Integer, region_height as Integer, region_depth as Integer, level as Integer, slice as Integer, bytes as Integer returns Integer:
    Note: Replace 3D texture region with new data
    Note: texture: Texture handle
    Note: region_x/y/z: Region origin
    Note: region_width/height/depth: Region size
    Note: level: Mipmap level
    Note: slice: Array slice
    Note: bytes: Pointer to pixel data
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [texture replaceRegion:MTLRegionMake3D(...) mipmapLevel:level slice:slice
        //                       withBytes:bytes bytesPerRow:bytesPerRow bytesPerImage:bytesPerImage]
    End Assembly
    Return result
End Process

Process called "metal_texture_get_bytes" takes texture as Integer, bytes as Integer, bytes_per_row as Integer, region_x as Integer, region_y as Integer, region_width as Integer, region_height as Integer, level as Integer returns Integer:
    Note: Get texture bytes
    Note: texture: Texture handle
    Note: bytes: Buffer to receive pixel data
    Note: bytes_per_row: Bytes per row
    Note: region_x/y: Region origin
    Note: region_width/height: Region size
    Note: level: Mipmap level
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [texture getBytes:bytes bytesPerRow:bytes_per_row
        //                       fromRegion:MTLRegionMake2D(region_x, region_y, region_width, region_height)
        //                       mipmapLevel:level]
    End Assembly
    Return result
End Process

Process called "metal_texture_new_texture_view" takes texture as Integer, pixel_format as Integer, texture_type as Integer, level_start as Integer, level_count as Integer, slice_start as Integer, slice_count as Integer, view_ptr as Integer returns Integer:
    Note: Create texture view
    Note: texture: Source texture handle
    Note: pixel_format: View pixel format
    Note: texture_type: View texture type
    Note: level_start/count: Mipmap level range
    Note: slice_start/count: Array slice range
    Note: view_ptr: Pointer to receive view handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [texture newTextureViewWithPixelFormat:pixel_format textureType:texture_type
        //                       levels:NSMakeRange(level_start, level_count)
        //                       slices:NSMakeRange(slice_start, slice_count)]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL SAMPLER STATE
Note: ============================================================================

Process called "metal_new_sampler_state" takes device as Integer, descriptor as Integer, sampler_ptr as Integer returns Integer:
    Note: Create sampler state
    Note: device: Device handle
    Note: descriptor: Sampler descriptor
    Note: sampler_ptr: Pointer to receive sampler handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newSamplerStateWithDescriptor:descriptor]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL EXTENDED SYNCHRONIZATION
Note: ============================================================================

Process called "metal_new_fence" takes device as Integer, fence_ptr as Integer returns Integer:
    Note: Create fence
    Note: device: Device handle
    Note: fence_ptr: Pointer to receive fence handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newFence]
    End Assembly
    Return result
End Process

Process called "metal_encoder_use_resources" takes encoder as Integer, resources as Integer, count as Integer, usage as Integer returns Integer:
    Note: Declare multiple resource usage
    Note: encoder: Command encoder handle
    Note: resources: Array of resource handles
    Note: count: Number of resources
    Note: usage: Resource usage flags
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [encoder useResources:resources count:count usage:usage]
    End Assembly
    Return result
End Process

Process called "metal_encoder_use_heap" takes encoder as Integer, heap as Integer returns Integer:
    Note: Declare heap usage for synchronization
    Note: encoder: Command encoder handle
    Note: heap: Heap handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [encoder useHeap:heap]
    End Assembly
    Return result
End Process

Process called "metal_encoder_memory_barrier_with_resources" takes encoder as Integer, resources as Integer, count as Integer returns Integer:
    Note: Insert memory barrier with specific resources
    Note: encoder: Command encoder handle
    Note: resources: Array of resource handles
    Note: count: Number of resources
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [encoder memoryBarrierWithResources:resources count:count]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL HEAPS
Note: ============================================================================

Process called "metal_new_heap" takes device as Integer, descriptor as Integer, heap_ptr as Integer returns Integer:
    Note: Create heap
    Note: device: Device handle
    Note: descriptor: Heap descriptor
    Note: heap_ptr: Pointer to receive heap handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newHeapWithDescriptor:descriptor]
    End Assembly
    Return result
End Process

Process called "metal_heap_new_buffer" takes heap as Integer, length as Integer, options as Integer, buffer_ptr as Integer returns Integer:
    Note: Create buffer from heap
    Note: heap: Heap handle
    Note: length: Buffer size in bytes
    Note: options: Resource options
    Note: buffer_ptr: Pointer to receive buffer handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [heap newBufferWithLength:length options:options]
    End Assembly
    Return result
End Process

Process called "metal_heap_new_texture" takes heap as Integer, descriptor as Integer, texture_ptr as Integer returns Integer:
    Note: Create texture from heap
    Note: heap: Heap handle
    Note: descriptor: Texture descriptor
    Note: texture_ptr: Pointer to receive texture handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [heap newTextureWithDescriptor:descriptor]
    End Assembly
    Return result
End Process

Process called "metal_heap_get_size" takes heap as Integer returns Integer:
    Note: Get heap size
    Note: heap: Heap handle
    Note: Returns: Heap size in bytes
    Let result be 0
    Inline Assembly:
        // Objective-C: [heap size]
    End Assembly
    Return result
End Process

Process called "metal_heap_get_used_size" takes heap as Integer returns Integer:
    Note: Get used heap size
    Note: heap: Heap handle
    Note: Returns: Used size in bytes
    Let result be 0
    Inline Assembly:
        // Objective-C: [heap usedSize]
    End Assembly
    Return result
End Process

Process called "metal_heap_get_current_allocated_size" takes heap as Integer returns Integer:
    Note: Get current allocated size
    Note: heap: Heap handle
    Note: Returns: Allocated size in bytes
    Let result be 0
    Inline Assembly:
        // Objective-C: [heap currentAllocatedSize]
    End Assembly
    Return result
End Process

Process called "metal_heap_max_available_size" takes heap as Integer, alignment as Integer returns Integer:
    Note: Get max available size with alignment
    Note: heap: Heap handle
    Note: alignment: Alignment requirement
    Note: Returns: Max available size in bytes
    Let result be 0
    Inline Assembly:
        // Objective-C: [heap maxAvailableSizeWithAlignment:alignment]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL EXTENDED PROFILING AND DEBUG
Note: ============================================================================

Process called "metal_encoder_insert_debug_signpost" takes encoder as Integer, label as Integer returns Integer:
    Note: Insert debug signpost
    Note: encoder: Command encoder handle
    Note: label: Signpost label string
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [encoder insertDebugSignpost:label]
    End Assembly
    Return result
End Process

Process called "metal_encoder_set_label" takes encoder as Integer, label as Integer returns Integer:
    Note: Set encoder label
    Note: encoder: Command encoder handle
    Note: label: Label string
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [encoder setLabel:label]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL EXTENDED ARGUMENT BUFFERS (Metal 2.0+)
Note: ============================================================================

Process called "metal_argument_encoder_set_buffers" takes encoder as Integer, buffers as Integer, offsets as Integer, start_index as Integer, count as Integer returns Integer:
    Note: Set multiple buffers in argument buffer
    Note: encoder: Argument encoder handle
    Note: buffers: Array of buffer handles
    Note: offsets: Array of offsets
    Note: start_index: Starting index
    Note: count: Number of buffers
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [argumentEncoder setBuffers:buffers offsets:offsets withRange:NSMakeRange(start_index, count)]
    End Assembly
    Return result
End Process

Process called "metal_argument_encoder_set_texture" takes encoder as Integer, texture as Integer, index as Integer returns Integer:
    Note: Set texture in argument buffer
    Note: encoder: Argument encoder handle
    Note: texture: Texture handle
    Note: index: Argument index
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [argumentEncoder setTexture:texture atIndex:index]
    End Assembly
    Return result
End Process

Process called "metal_argument_encoder_set_textures" takes encoder as Integer, textures as Integer, start_index as Integer, count as Integer returns Integer:
    Note: Set multiple textures in argument buffer
    Note: encoder: Argument encoder handle
    Note: textures: Array of texture handles
    Note: start_index: Starting index
    Note: count: Number of textures
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [argumentEncoder setTextures:textures withRange:NSMakeRange(start_index, count)]
    End Assembly
    Return result
End Process

Process called "metal_argument_encoder_set_sampler_state" takes encoder as Integer, sampler as Integer, index as Integer returns Integer:
    Note: Set sampler state in argument buffer
    Note: encoder: Argument encoder handle
    Note: sampler: Sampler state handle
    Note: index: Argument index
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [argumentEncoder setSamplerState:sampler atIndex:index]
    End Assembly
    Return result
End Process

Process called "metal_argument_encoder_set_sampler_states" takes encoder as Integer, samplers as Integer, start_index as Integer, count as Integer returns Integer:
    Note: Set multiple sampler states in argument buffer
    Note: encoder: Argument encoder handle
    Note: samplers: Array of sampler handles
    Note: start_index: Starting index
    Note: count: Number of samplers
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [argumentEncoder setSamplerStates:samplers withRange:NSMakeRange(start_index, count)]
    End Assembly
    Return result
End Process

Process called "metal_argument_encoder_constant_data" takes encoder as Integer, index as Integer returns Integer:
    Note: Get pointer to constant data in argument buffer
    Note: encoder: Argument encoder handle
    Note: index: Argument index
    Note: Returns: Pointer to constant data
    Let result be 0
    Inline Assembly:
        // Objective-C: [argumentEncoder constantDataAtIndex:index]
    End Assembly
    Return result
End Process

Process called "metal_argument_encoder_get_encoded_length" takes encoder as Integer returns Integer:
    Note: Get encoded length of argument buffer
    Note: encoder: Argument encoder handle
    Note: Returns: Encoded length in bytes
    Let result be 0
    Inline Assembly:
        // Objective-C: [argumentEncoder encodedLength]
    End Assembly
    Return result
End Process

Process called "metal_argument_encoder_get_alignment" takes encoder as Integer returns Integer:
    Note: Get alignment requirement of argument buffer
    Note: encoder: Argument encoder handle
    Note: Returns: Alignment in bytes
    Let result be 0
    Inline Assembly:
        // Objective-C: [argumentEncoder alignment]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL INDIRECT COMMAND BUFFERS (Metal 2.0+)
Note: ============================================================================

Process called "metal_new_indirect_command_buffer" takes device as Integer, descriptor as Integer, max_count as Integer, options as Integer, buffer_ptr as Integer returns Integer:
    Note: Create indirect command buffer
    Note: device: Device handle
    Note: descriptor: Indirect command buffer descriptor
    Note: max_count: Maximum command count
    Note: options: Options
    Note: buffer_ptr: Pointer to receive buffer handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newIndirectCommandBufferWithDescriptor:descriptor maxCommandCount:max_count options:options]
    End Assembly
    Return result
End Process

Process called "metal_indirect_command_buffer_reset_range" takes buffer as Integer, start as Integer, count as Integer returns Integer:
    Note: Reset range of indirect commands
    Note: buffer: Indirect command buffer handle
    Note: start: Starting index
    Note: count: Number of commands
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [buffer resetWithRange:NSMakeRange(start, count)]
    End Assembly
    Return result
End Process

Process called "metal_indirect_command_buffer_get_size" takes buffer as Integer returns Integer:
    Note: Get indirect command buffer size
    Note: buffer: Indirect command buffer handle
    Note: Returns: Size in bytes
    Let result be 0
    Inline Assembly:
        // Objective-C: [buffer size]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL EVENT SYNCHRONIZATION (Metal 2.1+)
Note: ============================================================================

Process called "metal_new_event" takes device as Integer, event_ptr as Integer returns Integer:
    Note: Create event
    Note: device: Device handle
    Note: event_ptr: Pointer to receive event handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newEvent]
    End Assembly
    Return result
End Process

Process called "metal_new_shared_event" takes device as Integer, event_ptr as Integer returns Integer:
    Note: Create shared event (cross-process)
    Note: device: Device handle
    Note: event_ptr: Pointer to receive event handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newSharedEvent]
    End Assembly
    Return result
End Process

Process called "metal_encoder_wait_for_event" takes encoder as Integer, event as Integer, value as Integer returns Integer:
    Note: Wait for event value
    Note: encoder: Command encoder handle
    Note: event: Event handle
    Note: value: Event value to wait for
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [encoder waitForEvent:event value:value]
    End Assembly
    Return result
End Process

Process called "metal_encoder_signal_event" takes encoder as Integer, event as Integer, value as Integer returns Integer:
    Note: Signal event with value
    Note: encoder: Command encoder handle
    Note: event: Event handle
    Note: value: Event value to signal
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [encoder signalEvent:event value:value]
    End Assembly
    Return result
End Process

Process called "metal_event_get_signaled_value" takes event as Integer returns Integer:
    Note: Get current signaled value of event
    Note: event: Event handle
    Note: Returns: Signaled value
    Let result be 0
    Inline Assembly:
        // Objective-C: [event signaledValue]
    End Assembly
    Return result
End Process

Process called "metal_event_set_signaled_value" takes event as Integer, value as Integer returns Integer:
    Note: Set signaled value of event
    Note: event: Event handle
    Note: value: Value to set
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [event setSignaledValue:value]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL RESOURCE STATE TRACKING (Metal 2.2+)
Note: ============================================================================

Process called "metal_resource_set_purgeability_state" takes resource as Integer, state as Integer returns Integer:
    Note: Set resource purgeability state
    Note: resource: Resource handle
    Note: state: Purgeability state
    Note: Returns: Previous state
    Let result be 0
    Inline Assembly:
        // Objective-C: [resource setPurgeableState:state]
    End Assembly
    Return result
End Process

Process called "metal_buffer_make_aliasable" takes buffer as Integer returns Integer:
    Note: Make buffer aliasable
    Note: buffer: Buffer handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [buffer makeAliasable]
    End Assembly
    Return result
End Process

Process called "metal_texture_make_aliasable" takes texture as Integer returns Integer:
    Note: Make texture aliasable
    Note: texture: Texture handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [texture makeAliasable]
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: METAL BINARY ARCHIVES (Metal 3.0+)
Note: ============================================================================

Process called "metal_new_binary_archive" takes device as Integer, descriptor as Integer, archive_ptr as Integer returns Integer:
    Note: Create binary archive
    Note: device: Device handle
    Note: descriptor: Archive descriptor
    Note: archive_ptr: Pointer to receive archive handle
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [device newBinaryArchiveWithDescriptor:descriptor error:&error]
    End Assembly
    Return result
End Process

Process called "metal_binary_archive_add_compute_pipeline_functions" takes archive as Integer, descriptor as Integer returns Integer:
    Note: Add compute pipeline functions to archive
    Note: archive: Binary archive handle
    Note: descriptor: Pipeline descriptor
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [archive addComputePipelineFunctionsWithDescriptor:descriptor error:&error]
    End Assembly
    Return result
End Process

Process called "metal_binary_archive_serialize_to_url" takes archive as Integer, url as Integer returns Integer:
    Note: Serialize binary archive to file
    Note: archive: Binary archive handle
    Note: url: File URL
    Note: Returns: METAL_SUCCESS or error code
    Let result be 0
    Inline Assembly:
        // Objective-C: [archive serializeToURL:url error:&error]
    End Assembly
    Return result
End Process
