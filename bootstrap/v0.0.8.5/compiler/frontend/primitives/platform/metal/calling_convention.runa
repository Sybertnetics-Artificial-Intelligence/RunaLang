Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file implements Metal calling convention primitives for Apple GPU execution in the Runa compiler frontend.

This file performs the following tasks:
- Process Metal kernel calling convention definitions and Apple GPU parameter passing mechanisms
- Handle Metal thread group and thread configuration with Apple GPU memory space specifications
- Manage Metal kernel launch parameters and execution configuration with Apple GPU optimization
- Process Metal memory hierarchy and addressing modes with thread group memory coordination
- Handle Metal thread group execution and synchronization primitives with Apple GPU optimization
- Process integration with Runa's dual syntax system and mathematical symbol optimization
- Handle Metal debugging support and performance monitoring primitives
- Process Metal target architecture support and Apple GPU optimization level management

This file is essential because of the following reasons:
- calling_convention enables comprehensive Metal kernel calling convention support and Apple GPU execution primitives
- Proper Metal calling convention ensures correct kernel parameter passing and Apple GPU execution configuration
- calling_convention support enables Runa compiler for advanced Metal Apple GPU programming workflows

This file consists of the following functions/features/operation types:
- Metal kernel calling convention definitions and Apple GPU parameter passing mechanisms
- Metal thread group and thread configuration with Apple GPU memory space specifications
- Metal kernel launch parameters and execution configuration with Apple GPU optimization
- Metal memory hierarchy and addressing modes with thread group memory coordination
- Metal thread group execution and synchronization primitives with Apple GPU optimization
- Integration with Runa's dual syntax system and mathematical symbol optimization
- Metal debugging support and performance monitoring primitives
- Metal target architecture support and Apple GPU optimization level management
:End Note

Import "compiler/frontend/primitives/platform/metal/registers.runa" as Registers

Note: ============================================================================
Note: METAL KERNEL PARAMETER PASSING
Note: ============================================================================

Process called "get_buffer_parameter_index" takes param_index as Integer returns Integer:
    Note: Get buffer binding index for kernel parameter
    Note: param_index: Zero-based parameter position
    Note: Returns: Buffer binding index (0-29)

    Return Registers.get_kernel_arg_buffer_index(param_index)
End Process

Process called "get_max_kernel_parameters" returns Integer:
    Note: Maximum number of kernel buffer parameters
    Note: Metal supports 31 buffer bindings, reserve 30 for user
    Return Registers.get_max_kernel_buffers()
End Process

Process called "is_parameter_in_buffer" takes param_index as Integer returns Integer:
    Note: Check if parameter is passed via buffer binding
    Note: Metal always uses buffer bindings for pointer arguments
    Note: Returns: 1 (always true for Metal)

    Return 1
End Process

Note: ============================================================================
Note: METAL THREAD HIERARCHY
Note: ============================================================================

Process called "get_global_thread_id" takes dimension as Integer returns Integer:
    Note: Get global thread ID for specified dimension
    Note: dimension: 0=X, 1=Y, 2=Z
    Note: Returns: Built-in variable index for thread_position_in_grid

    If dimension is less than 3:
        Return Registers.get_thread_id_x_register()
    End If

    Return -1
End Process

Process called "get_local_thread_id" takes dimension as Integer returns Integer:
    Note: Get local thread ID within threadgroup
    Note: dimension: 0=X, 1=Y, 2=Z
    Note: Returns: Built-in variable index for thread_position_in_threadgroup

    If dimension is less than 3:
        Return Registers.get_local_thread_id_x_register()
    End If

    Return -1
End Process

Process called "get_threadgroup_id" takes dimension as Integer returns Integer:
    Note: Get threadgroup ID for specified dimension
    Note: dimension: 0=X, 1=Y, 2=Z
    Note: Returns: Built-in variable index for threadgroup_position_in_grid

    If dimension is less than 3:
        Return Registers.get_threadgroup_id_x_register()
    End If

    Return -1
End Process

Process called "get_threadgroup_size" takes dimension as Integer returns Integer:
    Note: Get threadgroup size for specified dimension
    Note: dimension: 0=X, 1=Y, 2=Z
    Note: Returns: Built-in variable index for threads_per_threadgroup

    If dimension is less than 3:
        Return 4
    End If

    Return -1
End Process

Process called "get_local_thread_index" returns Integer:
    Note: Get flattened local thread index
    Note: Returns: Built-in variable index for thread_index_in_threadgroup
    Return Registers.get_local_thread_index_register()
End Process

Note: ============================================================================
Note: METAL THREADGROUP CONFIGURATION
Note: ============================================================================

Process called "calculate_threadgroup_size" takes total_threads as Integer, preferred_size as Integer returns Integer:
    Note: Calculate optimal threadgroup size
    Note: total_threads: Total number of threads needed
    Note: preferred_size: Preferred threadgroup size (0 for auto)
    Note: Returns: Optimal threadgroup size

    Let max_size be Registers.get_max_threadgroup_size()

    If preferred_size is greater than 0:
        If preferred_size is less than or equal to max_size:
            Return preferred_size
        End If
        Return max_size
    End If

    Let simd_size be Registers.get_simd_group_size()
    Let optimal_size be 256

    If total_threads is less than optimal_size:
        Let remainder be total_threads modulo simd_size
        If remainder is not equal to 0:
            Let size be total_threads plus simd_size minus remainder
            If size is less than or equal to max_size:
                Return size
            End If
        End If
        Return total_threads
    End If

    Return optimal_size
End Process

Process called "calculate_threadgroup_count" takes total_threads as Integer, threads_per_threadgroup as Integer returns Integer:
    Note: Calculate number of threadgroups needed
    Note: total_threads: Total number of threads
    Note: threads_per_threadgroup: Threads per threadgroup
    Note: Returns: Number of threadgroups (rounded up)

    Let threadgroups be total_threads divided by threads_per_threadgroup
    Let remainder be total_threads modulo threads_per_threadgroup

    If remainder is not equal to 0:
        Set threadgroups to threadgroups plus 1
    End If

    Return threadgroups
End Process

Process called "validate_threadgroup_dimensions" takes threads_x as Integer, threads_y as Integer, threads_z as Integer returns Integer:
    Note: Validate threadgroup dimensions
    Note: Returns: 1 if valid, 0 if invalid

    Let total_threads be threads_x multiplied by threads_y
    Set total_threads to total_threads multiplied by threads_z

    Let max_threads be Registers.get_max_threadgroup_size()
    If total_threads is greater than max_threads:
        Return 0
    End If

    If threads_x is less than 1:
        Return 0
    End If
    If threads_y is less than 1:
        Return 0
    End If
    If threads_z is less than 1:
        Return 0
    End If

    Return 1
End Process

Note: ============================================================================
Note: METAL THREADGROUP MEMORY MANAGEMENT
Note: ============================================================================

Process called "allocate_threadgroup_memory" takes size as Integer returns Integer:
    Note: Allocate threadgroup (shared) memory
    Note: size: Size in bytes
    Note: Returns: Memory index for threadgroup memory

    Let max_size be Registers.get_max_threadgroup_memory_size()
    If size is greater than max_size:
        Return -1
    End If

    Let alignment be Registers.get_threadgroup_memory_alignment()
    Let remainder be size bitwise_and 15
    If remainder is not equal to 0:
        Let padding be alignment minus remainder
        Set size to size plus padding
    End If

    Return Registers.get_threadgroup_memory_index(0)
End Process

Process called "get_threadgroup_memory_size_limit" returns Integer:
    Note: Get maximum threadgroup memory size
    Return Registers.get_max_threadgroup_memory_size()
End Process

Process called "calculate_threadgroup_memory_usage" takes num_elements as Integer, element_size as Integer returns Integer:
    Note: Calculate threadgroup memory usage
    Note: num_elements: Number of elements
    Note: element_size: Size of each element in bytes
    Note: Returns: Total memory required (aligned)

    Let total_size be num_elements multiplied by element_size

    Let alignment be Registers.get_threadgroup_memory_alignment()
    Let remainder be total_size bitwise_and 15
    If remainder is not equal to 0:
        Let padding be alignment minus remainder
        Set total_size to total_size plus padding
    End If

    Return total_size
End Process

Note: ============================================================================
Note: METAL SIMD GROUP OPERATIONS
Note: ============================================================================

Process called "get_simd_group_size" returns Integer:
    Note: Get SIMD group size (threads per SIMD group)
    Note: Metal: 32 threads per SIMD group
    Return Registers.get_simd_group_size()
End Process

Process called "get_simd_lane_id" returns Integer:
    Note: Get SIMD lane ID (thread index within SIMD group)
    Note: Returns: Built-in variable index for thread_index_in_simdgroup
    Return Registers.get_simd_lane_id_register()
End Process

Process called "get_simd_group_index" returns Integer:
    Note: Get SIMD group index within threadgroup
    Note: Returns: Built-in variable index for simdgroup_index_in_threadgroup
    Return Registers.get_simd_group_index_register()
End Process

Process called "calculate_simd_groups_per_threadgroup" takes threads_per_threadgroup as Integer returns Integer:
    Note: Calculate number of SIMD groups per threadgroup
    Note: threads_per_threadgroup: Total threads per threadgroup
    Note: Returns: Number of SIMD groups

    Let simd_size be get_simd_group_size()
    Let num_simd_groups be threads_per_threadgroup divided by simd_size
    Let remainder be threads_per_threadgroup modulo simd_size

    If remainder is not equal to 0:
        Set num_simd_groups to num_simd_groups plus 1
    End If

    Return num_simd_groups
End Process

Note: ============================================================================
Note: METAL DISPATCH CONFIGURATION
Note: ============================================================================

Process called "configure_1d_dispatch" takes total_threads as Integer, result_buffer as Integer returns Integer:
    Note: Configure 1D dispatch (single dimension)
    Note: total_threads: Total number of threads needed
    Note: result_buffer: Pointer to 6-integer array [tg_x, tg_y, tg_z, threads_x, threads_y, threads_z]
    Note: Returns: Number of threadgroups

    Let threads_per_tg be calculate_threadgroup_size(total_threads, 0)
    Let num_threadgroups be calculate_threadgroup_count(total_threads, threads_per_tg)

    Return Registers.calculate_threadgroup_dimensions(total_threads, threads_per_tg, result_buffer)
End Process

Process called "configure_2d_dispatch" takes threads_x as Integer, threads_y as Integer, result_buffer as Integer returns Integer:
    Note: Configure 2D dispatch
    Note: threads_x: Threads in X dimension
    Note: threads_y: Threads in Y dimension
    Note: result_buffer: Pointer to 6-integer array [tg_x, tg_y, tg_z, threads_x, threads_y, threads_z]
    Note: Returns: Total number of threadgroups

    Let threads_per_tg_x be 16
    Let threads_per_tg_y be 16

    Let tg_count_x be calculate_threadgroup_count(threads_x, threads_per_tg_x)
    Let tg_count_y be calculate_threadgroup_count(threads_y, threads_per_tg_y)

    Let total_threadgroups be tg_count_x multiplied by tg_count_y
    Return total_threadgroups
End Process

Process called "configure_3d_dispatch" takes threads_x as Integer, threads_y as Integer, threads_z as Integer, result_buffer as Integer returns Integer:
    Note: Configure 3D dispatch
    Note: threads_x/y/z: Threads in each dimension
    Note: result_buffer: Pointer to 6-integer array [tg_x, tg_y, tg_z, threads_x, threads_y, threads_z]
    Note: Returns: Total number of threadgroups

    Let threads_per_tg_x be 8
    Let threads_per_tg_y be 8
    Let threads_per_tg_z be 4

    Let tg_count_x be calculate_threadgroup_count(threads_x, threads_per_tg_x)
    Let tg_count_y be calculate_threadgroup_count(threads_y, threads_per_tg_y)
    Let tg_count_z be calculate_threadgroup_count(threads_z, threads_per_tg_z)

    Let total_threadgroups be tg_count_x multiplied by tg_count_y
    Set total_threadgroups to total_threadgroups multiplied by tg_count_z

    Return total_threadgroups
End Process

Note: ============================================================================
Note: METAL TEXTURE AND SAMPLER CONFIGURATION
Note: ============================================================================

Process called "get_texture_binding_index" takes texture_index as Integer returns Integer:
    Note: Get texture binding index
    Note: texture_index: Texture parameter index
    Note: Returns: Texture binding index (0-127)

    Return Registers.get_texture_binding_index(texture_index)
End Process

Process called "get_sampler_binding_index" takes sampler_index as Integer returns Integer:
    Note: Get sampler binding index
    Note: sampler_index: Sampler parameter index
    Note: Returns: Sampler binding index (0-15)

    Return Registers.get_sampler_binding_index(sampler_index)
End Process

Process called "get_max_textures" returns Integer:
    Note: Get maximum number of texture bindings
    Return Registers.get_max_texture_bindings()
End Process

Process called "get_max_samplers" returns Integer:
    Note: Get maximum number of sampler bindings
    Return Registers.get_max_sampler_bindings()
End Process

Note: ============================================================================
Note: METAL ADDRESS SPACE HELPERS
Note: ============================================================================

Process called "get_address_space_for_parameter" takes is_constant as Integer, is_shared as Integer returns Integer:
    Note: Determine address space for kernel parameter
    Note: is_constant: 1 if read-only constant data
    Note: is_shared: 1 if threadgroup-shared memory
    Note: Returns: Address space identifier

    If is_shared is equal to 1:
        Return 2
    End If

    If is_constant is equal to 1:
        Return 1
    End If

    Return 0
End Process

Process called "get_address_space_qualifier_string" takes address_space as Integer returns String:
    Note: Get MSL address space qualifier string
    Note: address_space: Address space identifier
    Note: Returns: MSL keyword ("device", "constant", "threadgroup", "thread")

    Return Registers.get_address_space_qualifier(address_space)
End Process

Note: ============================================================================
Note: METAL KERNEL ATTRIBUTE GENERATION
Note: ============================================================================

Process called "generate_buffer_attribute" takes buffer_index as Integer returns String:
    Note: Generate MSL buffer attribute
    Note: buffer_index: Buffer binding index
    Note: Returns: MSL attribute string "[[buffer(N)]]"

    Return Registers.get_buffer_attribute_name(buffer_index)
End Process

Process called "generate_texture_attribute" takes texture_index as Integer returns String:
    Note: Generate MSL texture attribute
    Note: texture_index: Texture binding index
    Note: Returns: MSL attribute string "[[texture(N)]]"

    Return Registers.get_texture_attribute_name(texture_index)
End Process

Process called "generate_threadgroup_attribute" returns String:
    Note: Generate MSL threadgroup memory attribute
    Note: Returns: MSL attribute string "[[threadgroup(0)]]"
    Return Registers.get_threadgroup_attribute_name()
End Process

Process called "generate_thread_position_attribute" returns String:
    Note: Generate thread position attribute
    Note: Returns: MSL attribute string "[[thread_position_in_grid]]"
    Return "[[thread_position_in_grid]]"
End Process

Process called "generate_threadgroup_position_attribute" returns String:
    Note: Generate threadgroup position attribute
    Note: Returns: MSL attribute string "[[threadgroup_position_in_grid]]"
    Return "[[threadgroup_position_in_grid]]"
End Process

Process called "generate_local_thread_position_attribute" returns String:
    Note: Generate local thread position attribute
    Note: Returns: MSL attribute string "[[thread_position_in_threadgroup]]"
    Return "[[thread_position_in_threadgroup]]"
End Process

Note: ============================================================================
Note: METAL EXECUTION MODEL VALIDATION
Note: ============================================================================

Process called "validate_kernel_configuration" takes buffers as Integer, textures as Integer, samplers as Integer returns Integer:
    Note: Validate kernel resource configuration
    Note: buffers: Number of buffer bindings
    Note: textures: Number of texture bindings
    Note: samplers: Number of sampler bindings
    Note: Returns: 1 if valid, 0 if invalid

    Let max_buffers be get_max_kernel_parameters()
    If buffers is greater than max_buffers:
        Return 0
    End If

    Let max_textures be get_max_textures()
    If textures is greater than max_textures:
        Return 0
    End If

    Let max_samplers be get_max_samplers()
    If samplers is greater than max_samplers:
        Return 0
    End If

    Return 1
End Process

Process called "get_calling_convention_name" returns String:
    Note: Get calling convention name
    Return "Metal Shading Language (MSL)"
End Process

Process called "get_execution_model_version" returns Integer:
    Note: Get Metal execution model version
    Note: Metal 3.0 (macOS 13+, iOS 16+)
    Return 3
End Process
