Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
MIPS64 Calling Convention (n64 ABI)

This file implements MIPS64 n64 ABI calling conventions for the Runa compiler.

Platform-specific details:
- Platform: Linux MIPS64
- ABI: n64 (native 64-bit ABI)
- Stack alignment: 16 bytes
- Parameter passing: Register + stack hybrid

MIPS64 n64 ABI calling convention:
- Arguments: $a0-$a7 (first 8 integer args), rest on stack
- FP arguments: $f12-$f19 (8 FP argument registers)
- Return values: $v0-$v1 (integers), $f0-$f1 (floats)
- Stack growth: Downward (decreasing addresses)
- Frame pointer: $fp ($30) optional
- Stack pointer: $sp ($29) always valid

Caller-saved registers: $t0-$t9, $a0-$a7, $v0-$v1, $at, $f0-$f19
Callee-saved registers: $s0-$s7, $fp, $ra, $gp, $f20-$f31

Structure passing:
- Structs <= 16 bytes: Passed by value in registers/stack
- Structs > 16 bytes: Passed by reference

Key differences from o32 ABI:
- 8 argument registers (not 4)
- 16-byte stack alignment (not 8)
- 8 FP argument registers (not 2)
- 64-bit register operations native

Dependencies: compiler/frontend/primitives/platform/mips64/registers.runa, compiler/frontend/primitives/core/memory_core.runa
:End Note

Import "compiler/frontend/primitives/platform/mips64/registers.runa" as Registers
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Process called "get_integer_param_register" takes param_index as Integer returns Integer:
    If param_index is less than 8:
        Return 4 plus param_index  Note: $a0-$a7
    End If
    Return -1
End Process

Process called "get_param_location" takes param_index as Integer, param_size as Integer returns Integer:
    If param_index is less than 8:
        Return 4 plus param_index
    End If
    Let stack_offset be (param_index minus 8) multiplied by 8
    Return -1 minus stack_offset
End Process

Process called "get_stack_param_offset" takes param_index as Integer returns Integer:
    If param_index is less than 8:
        Return -1
    End If
    Return (param_index minus 8) multiplied by 8
End Process

Process called "get_return_register" returns Integer:
    Return 2  Note: $v0
End Process

Process called "get_secondary_return_register" returns Integer:
    Return 3  Note: $v1
End Process

Process called "get_stack_alignment" returns Integer:
    Return 16  Note: n64 ABI requires 16-byte alignment
End Process

Process called "calculate_stack_frame_size" takes local_vars_size as Integer, spilled_regs_count as Integer returns Integer:
    Let locals_space be local_vars_size
    Let spilled_space be spilled_regs_count multiplied by 8
    Let total_size be locals_space plus spilled_space
    Let remainder be total_size modulo 16
    If remainder is not equal to 0:
        Set total_size to total_size plus (16 minus remainder)
    End If
    Return total_size
End Process

Process called "calculate_callee_saved_mask" takes uses_s0 as Integer, uses_s1 as Integer, uses_s2 as Integer, uses_s3 as Integer returns Integer:
    Let mask be 0
    If uses_s0 is not equal to 0:
        Set mask to mask bitwise_or 65536  Note: $s0 bit
    End If
    If uses_s1 is not equal to 0:
        Set mask to mask bitwise_or 131072  Note: $s1 bit
    End If
    Set mask to mask bitwise_or 2147483648  Note: $ra bit
    Return mask
End Process

Process called "get_prologue_instructions" takes frame_size as Integer, callee_saved_mask as Integer, result_buffer as Integer returns Integer:
    Let instruction_count be 1  Note: SD instructions for saved regs
    If frame_size is greater than 0:
        Set instruction_count to instruction_count plus 1
    End If
    Memory.memory_set_int32(result_buffer, 0, instruction_count)
    Memory.memory_set_int32(result_buffer, 4, callee_saved_mask)
    Memory.memory_set_int32(result_buffer, 8, frame_size)
    Return instruction_count
End Process

Process called "get_epilogue_instructions" takes frame_size as Integer, callee_saved_mask as Integer, result_buffer as Integer returns Integer:
    Let instruction_count be 2  Note: LD + JR $ra
    Memory.memory_set_int32(result_buffer, 0, instruction_count)
    Memory.memory_set_int32(result_buffer, 4, callee_saved_mask)
    Memory.memory_set_int32(result_buffer, 8, frame_size)
    Return instruction_count
End Process

Process called "calculate_call_stack_adjustment" takes num_stack_args as Integer returns Integer:
    If num_stack_args is less than or equal to 0:
        Return 0
    End If
    Let args_size be num_stack_args multiplied by 8
    Let remainder be args_size bitwise_and 15
    If remainder is not equal to 0:
        Let padding be 16 minus remainder
        Set args_size to args_size plus padding
    End If
    Return args_size
End Process

Process called "get_callee_saved_registers" takes result_buffer as Integer returns Integer:
    Memory.memory_set_int32(result_buffer, 0, 16)   Note: $s0
    Memory.memory_set_int32(result_buffer, 4, 17)   Note: $s1
    Memory.memory_set_int32(result_buffer, 8, 18)   Note: $s2
    Memory.memory_set_int32(result_buffer, 12, 19)  Note: $s3
    Memory.memory_set_int32(result_buffer, 16, 20)  Note: $s4
    Memory.memory_set_int32(result_buffer, 20, 21)  Note: $s5
    Memory.memory_set_int32(result_buffer, 24, 22)  Note: $s6
    Memory.memory_set_int32(result_buffer, 28, 23)  Note: $s7
    Memory.memory_set_int32(result_buffer, 32, 28)  Note: $gp
    Memory.memory_set_int32(result_buffer, 36, 30)  Note: $fp
    Memory.memory_set_int32(result_buffer, 40, 31)  Note: $ra
    Return 11
End Process

Process called "validate_stack_alignment" takes stack_offset as Integer returns Integer:
    Let remainder be stack_offset bitwise_and 15
    If remainder is equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "get_calling_convention_name" returns String:
    Return "MIPS64 n64 ABI"
End Process

Process called "get_abi_version" returns Integer:
    Return 1
End Process

Process called "get_max_register_params" returns Integer:
    Return 8  Note: n64 ABI has 8 argument registers
End Process

Process called "should_save_return_address" takes is_leaf_function as Integer returns Integer:
    If is_leaf_function is equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "get_parameter_location" takes param_index as Integer, param_size as Integer, result_buffer as Integer returns Integer:
    Let location_type be 0
    Let value be 0
    If param_index is less than 8:
        Set location_type to 0
        Set value to 4 plus param_index
    Otherwise:
        Set location_type to 1
        Set value to (param_index minus 8) multiplied by 8
    End If
    Memory.memory_set_int32(result_buffer, 0, location_type)
    Memory.memory_set_int32(result_buffer, 4, value)
    Return location_type
End Process

Process called "get_call_setup_info" takes num_params as Integer, result_buffer as Integer returns Integer:
    Let reg_params be 8
    Let stack_params be 0
    Let stack_adjustment be 0
    If num_params is less than or equal to 8:
        Set reg_params to num_params
    Otherwise:
        Set stack_params to num_params minus 8
        Set stack_adjustment to calculate_call_stack_adjustment(stack_params)
    End If
    Memory.memory_set_int32(result_buffer, 0, reg_params)
    Memory.memory_set_int32(result_buffer, 4, stack_params)
    Memory.memory_set_int32(result_buffer, 8, stack_adjustment)
    Return stack_params
End Process

Process called "get_float_param_register" takes param_index as Integer returns Integer:
    Note: n64 ABI uses $f12-$f19 for FP arguments
    If param_index is less than 8:
        Return 12 plus param_index
    End If
    Return -1
End Process

Process called "get_float_return_register" returns Integer:
    Note: Float return value in $f0
    Return 0  Note: FPU register $f0
End Process

Process called "should_pass_struct_by_reference" takes struct_size as Integer returns Integer:
    Note: n64 passes structs by value if <= 16 bytes, otherwise by reference
    If struct_size is greater than 16:
        Return 1
    End If
    Return 0
End Process

Process called "calculate_struct_param_slots" takes struct_size as Integer returns Integer:
    Note: Struct passed by value consumes (size+7)/8 register/stack slots
    Let slots be (struct_size plus 7) divided by 8
    Return slots
End Process

Process called "is_variadic_supported" returns Integer:
    Note: n64 ABI supports variadic functions
    Return 1
End Process

Process called "get_variadic_reg_save_area_size" returns Integer:
    Note: Save area for $a0-$a7 = 64 bytes
    Return 64
End Process

Process called "get_variadic_save_registers" takes result_buffer as Integer returns Integer:
    Note: Save all argument registers for va_arg access
    Memory.memory_set_int32(result_buffer, 0, 4)   Note: $a0
    Memory.memory_set_int32(result_buffer, 4, 5)   Note: $a1
    Memory.memory_set_int32(result_buffer, 8, 6)   Note: $a2
    Memory.memory_set_int32(result_buffer, 12, 7)  Note: $a3
    Memory.memory_set_int32(result_buffer, 16, 8)  Note: $a4
    Memory.memory_set_int32(result_buffer, 20, 9)  Note: $a5
    Memory.memory_set_int32(result_buffer, 24, 10) Note: $a6
    Memory.memory_set_int32(result_buffer, 28, 11) Note: $a7
    Return 8
End Process

Process called "align_struct_field" takes current_offset as Integer, field_size as Integer, field_alignment as Integer returns Integer:
    Let alignment be field_alignment
    If field_size is greater than or equal to 8:
        Set alignment to 8
    End If
    Let remainder be current_offset bitwise_and (alignment minus 1)
    If remainder is not equal to 0:
        Let padding be alignment minus remainder
        Return current_offset plus padding
    End If
    Return current_offset
End Process

Process called "get_natural_alignment" takes type_size as Integer returns Integer:
    Note: n64 natural alignment is min(type_size, 8) for most types
    If type_size is greater than or equal to 8:
        Return 8
    End If
    If type_size is greater than or equal to 4:
        Return 4
    End If
    If type_size is equal to 2:
        Return 2
    End If
    Return 1
End Process

Process called "calculate_return_value_location" takes return_size as Integer, result_buffer as Integer returns Integer:
    Note: Returns 0 for register, 1 for memory return
    Note: n64 returns <= 16 bytes in $v0/$v1, larger via hidden pointer in $a0
    If return_size is less than or equal to 16:
        Memory.memory_set_int32(result_buffer, 0, 0)  Note: Location type: register
        Memory.memory_set_int32(result_buffer, 4, 2)  Note: $v0
        Return 0
    Otherwise:
        Memory.memory_set_int32(result_buffer, 0, 1)  Note: Location type: memory
        Memory.memory_set_int32(result_buffer, 4, 4)  Note: $a0 holds pointer
        Return 1
    End If
End Process

Process called "get_frame_pointer_register" returns Integer:
    Return 30  Note: $fp
End Process

Process called "get_stack_pointer_register" returns Integer:
    Return 29  Note: $sp
End Process

Process called "get_return_address_register" returns Integer:
    Return 31  Note: $ra
End Process

Process called "is_leaf_function_optimizable" takes makes_calls as Integer returns Integer:
    Note: Leaf functions that don't call others can skip saving $ra
    If makes_calls is equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "get_register_save_area_offset" takes param_count as Integer returns Integer:
    Note: Register save area starts after parameter space (if needed)
    If param_count is less than or equal to 8:
        Return 0
    End If
    Return (param_count minus 8) multiplied by 8
End Process

Process called "calculate_parameter_alignment" takes param_size as Integer returns Integer:
    Note: n64 aligns parameters to 8-byte boundaries
    Return 8
End Process

Process called "should_use_shadow_space" returns Integer:
    Note: n64 does not require shadow space for register parameters
    Return 0
End Process
