Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
MIPS64 Instruction Set (n64 ABI)

This file implements MIPS64 instruction definitions for the Runa compiler.

Platform-specific details:
- Platform: Linux MIPS64
- Instruction set: MIPS III/IV/64
- Instruction format: 32-bit fixed-length (even for 64-bit ops!)
- Instruction types: R-type, I-type, J-type

MIPS64 instruction encoding:
- All instructions are still 32 bits (4 bytes)
- R-type: opcode(6) | rs(5) | rt(5) | rd(5) | shamt(5) | funct(6)
- I-type: opcode(6) | rs(5) | rt(5) | immediate(16)
- J-type: opcode(6) | address(26)

MIPS64-specific instructions:
- Doubleword operations: DADD, DADDU, DSUB, DSUBU
- 64-bit shifts: DSLL, DSRL, DSRA, DSLL32, DSRL32, DSRA32
- 64-bit multiply/divide: DMULT, DMULTU, DDIV, DDIVU
- 64-bit loads/stores: LD, SD, LDL, LDR, SDL, SDR
- 64-bit immediate: DADDI, DADDIU

Dependencies: None
:End Note

Note: Instruction categories
Process called "CATEGORY_ARITHMETIC" returns Integer:
    Return 1
End Process

Process called "CATEGORY_LOGICAL" returns Integer:
    Return 2
End Process

Process called "CATEGORY_SHIFT" returns Integer:
    Return 3
End Process

Process called "CATEGORY_LOAD" returns Integer:
    Return 4
End Process

Process called "CATEGORY_STORE" returns Integer:
    Return 5
End Process

Process called "CATEGORY_BRANCH" returns Integer:
    Return 6
End Process

Process called "CATEGORY_JUMP" returns Integer:
    Return 7
End Process

Process called "CATEGORY_COMPARE" returns Integer:
    Return 8
End Process

Process called "CATEGORY_SYSTEM" returns Integer:
    Return 9
End Process

Note: R-type instructions (opcode=0)
Process called "FUNCT_ADD" returns Integer:
    Return 32  Note: ADD (trap on overflow)
End Process

Process called "FUNCT_ADDU" returns Integer:
    Return 33  Note: ADDU (no overflow)
End Process

Process called "FUNCT_SUB" returns Integer:
    Return 34
End Process

Process called "FUNCT_SUBU" returns Integer:
    Return 35
End Process

Process called "FUNCT_AND" returns Integer:
    Return 36
End Process

Process called "FUNCT_OR" returns Integer:
    Return 37
End Process

Process called "FUNCT_XOR" returns Integer:
    Return 38
End Process

Process called "FUNCT_NOR" returns Integer:
    Return 39
End Process

Process called "FUNCT_SLT" returns Integer:
    Return 42  Note: Set less than
End Process

Process called "FUNCT_SLTU" returns Integer:
    Return 43  Note: Set less than unsigned
End Process

Process called "FUNCT_SLL" returns Integer:
    Return 0  Note: Shift left logical
End Process

Process called "FUNCT_SRL" returns Integer:
    Return 2  Note: Shift right logical
End Process

Process called "FUNCT_SRA" returns Integer:
    Return 3  Note: Shift right arithmetic
End Process

Process called "FUNCT_SLLV" returns Integer:
    Return 4  Note: Shift left logical variable
End Process

Process called "FUNCT_SRLV" returns Integer:
    Return 6  Note: Shift right logical variable
End Process

Process called "FUNCT_SRAV" returns Integer:
    Return 7  Note: Shift right arithmetic variable
End Process

Process called "FUNCT_JR" returns Integer:
    Return 8  Note: Jump register
End Process

Process called "FUNCT_JALR" returns Integer:
    Return 9  Note: Jump and link register
End Process

Process called "FUNCT_SYSCALL" returns Integer:
    Return 12
End Process

Process called "FUNCT_BREAK" returns Integer:
    Return 13
End Process

Process called "FUNCT_MFHI" returns Integer:
    Return 16  Note: Move from HI
End Process

Process called "FUNCT_MTHI" returns Integer:
    Return 17  Note: Move to HI
End Process

Process called "FUNCT_MFLO" returns Integer:
    Return 18  Note: Move from LO
End Process

Process called "FUNCT_MTLO" returns Integer:
    Return 19  Note: Move to LO
End Process

Process called "FUNCT_MULT" returns Integer:
    Return 24  Note: Multiply
End Process

Process called "FUNCT_MULTU" returns Integer:
    Return 25  Note: Multiply unsigned
End Process

Process called "FUNCT_DIV" returns Integer:
    Return 26  Note: Divide
End Process

Process called "FUNCT_DIVU" returns Integer:
    Return 27  Note: Divide unsigned
End Process

Note: 64-bit R-type instructions
Process called "FUNCT_DADD" returns Integer:
    Return 44  Note: Doubleword add
End Process

Process called "FUNCT_DADDU" returns Integer:
    Return 45  Note: Doubleword add unsigned
End Process

Process called "FUNCT_DSUB" returns Integer:
    Return 46  Note: Doubleword subtract
End Process

Process called "FUNCT_DSUBU" returns Integer:
    Return 47  Note: Doubleword subtract unsigned
End Process

Process called "FUNCT_DSLL" returns Integer:
    Return 56  Note: Doubleword shift left logical
End Process

Process called "FUNCT_DSRL" returns Integer:
    Return 58  Note: Doubleword shift right logical
End Process

Process called "FUNCT_DSRA" returns Integer:
    Return 59  Note: Doubleword shift right arithmetic
End Process

Process called "FUNCT_DSLL32" returns Integer:
    Return 60  Note: Doubleword shift left logical + 32
End Process

Process called "FUNCT_DSRL32" returns Integer:
    Return 62  Note: Doubleword shift right logical + 32
End Process

Process called "FUNCT_DSRA32" returns Integer:
    Return 63  Note: Doubleword shift right arithmetic + 32
End Process

Process called "FUNCT_DSLLV" returns Integer:
    Return 20  Note: Doubleword shift left logical variable
End Process

Process called "FUNCT_DSRLV" returns Integer:
    Return 22  Note: Doubleword shift right logical variable
End Process

Process called "FUNCT_DSRAV" returns Integer:
    Return 23  Note: Doubleword shift right arithmetic variable
End Process

Process called "FUNCT_DMULT" returns Integer:
    Return 28  Note: Doubleword multiply
End Process

Process called "FUNCT_DMULTU" returns Integer:
    Return 29  Note: Doubleword multiply unsigned
End Process

Process called "FUNCT_DDIV" returns Integer:
    Return 30  Note: Doubleword divide
End Process

Process called "FUNCT_DDIVU" returns Integer:
    Return 31  Note: Doubleword divide unsigned
End Process

Note: I-type opcodes
Process called "OPCODE_ADDI" returns Integer:
    Return 8  Note: Add immediate
End Process

Process called "OPCODE_ADDIU" returns Integer:
    Return 9  Note: Add immediate unsigned
End Process

Process called "OPCODE_SLTI" returns Integer:
    Return 10  Note: Set less than immediate
End Process

Process called "OPCODE_SLTIU" returns Integer:
    Return 11  Note: Set less than immediate unsigned
End Process

Process called "OPCODE_ANDI" returns Integer:
    Return 12  Note: AND immediate
End Process

Process called "OPCODE_ORI" returns Integer:
    Return 13  Note: OR immediate
End Process

Process called "OPCODE_XORI" returns Integer:
    Return 14  Note: XOR immediate
End Process

Process called "OPCODE_LUI" returns Integer:
    Return 15  Note: Load upper immediate
End Process

Process called "OPCODE_LB" returns Integer:
    Return 32  Note: Load byte
End Process

Process called "OPCODE_LH" returns Integer:
    Return 33  Note: Load halfword
End Process

Process called "OPCODE_LW" returns Integer:
    Return 35  Note: Load word
End Process

Process called "OPCODE_LBU" returns Integer:
    Return 36  Note: Load byte unsigned
End Process

Process called "OPCODE_LHU" returns Integer:
    Return 37  Note: Load halfword unsigned
End Process

Process called "OPCODE_LWU" returns Integer:
    Return 39  Note: Load word unsigned (MIPS64)
End Process

Process called "OPCODE_SB" returns Integer:
    Return 40  Note: Store byte
End Process

Process called "OPCODE_SH" returns Integer:
    Return 41  Note: Store halfword
End Process

Process called "OPCODE_SW" returns Integer:
    Return 43  Note: Store word
End Process

Process called "OPCODE_BEQ" returns Integer:
    Return 4  Note: Branch on equal
End Process

Process called "OPCODE_BNE" returns Integer:
    Return 5  Note: Branch on not equal
End Process

Process called "OPCODE_BLEZ" returns Integer:
    Return 6  Note: Branch on less than or equal to zero
End Process

Process called "OPCODE_BGTZ" returns Integer:
    Return 7  Note: Branch on greater than zero
End Process

Process called "OPCODE_REGIMM" returns Integer:
    Return 1  Note: For BLTZ, BGEZ, etc.
End Process

Note: 64-bit I-type opcodes
Process called "OPCODE_DADDI" returns Integer:
    Return 24  Note: Doubleword add immediate
End Process

Process called "OPCODE_DADDIU" returns Integer:
    Return 25  Note: Doubleword add immediate unsigned
End Process

Process called "OPCODE_LD" returns Integer:
    Return 55  Note: Load doubleword
End Process

Process called "OPCODE_SD" returns Integer:
    Return 63  Note: Store doubleword
End Process

Process called "OPCODE_LDL" returns Integer:
    Return 26  Note: Load doubleword left
End Process

Process called "OPCODE_LDR" returns Integer:
    Return 27  Note: Load doubleword right
End Process

Process called "OPCODE_SDL" returns Integer:
    Return 44  Note: Store doubleword left
End Process

Process called "OPCODE_SDR" returns Integer:
    Return 45  Note: Store doubleword right
End Process

Note: J-type opcodes
Process called "OPCODE_J" returns Integer:
    Return 2  Note: Jump
End Process

Process called "OPCODE_JAL" returns Integer:
    Return 3  Note: Jump and link
End Process

Note: Instruction query helpers
Process called "get_instruction_category" takes opcode as Integer, funct as Integer returns Integer:
    If opcode is equal to 0:
        If (funct is greater than or equal to 32) and (funct is less than or equal to 47):
            Return CATEGORY_ARITHMETIC()
        End If
        If (funct is greater than or equal to 36) and (funct is less than or equal to 39):
            Return CATEGORY_LOGICAL()
        End If
        If (funct is less than or equal to 7) or ((funct is greater than or equal to 20) and (funct is less than or equal to 23)):
            Return CATEGORY_SHIFT()
        End If
        If (funct is equal to 8) or (funct is equal to 9):
            Return CATEGORY_JUMP()
        End If
        If funct is equal to 12:
            Return CATEGORY_SYSTEM()
        End If
    End If
    If (opcode is greater than or equal to 8) and (opcode is less than or equal to 15):
        Return CATEGORY_ARITHMETIC()
    End If
    If (opcode is greater than or equal to 32) and (opcode is less than or equal to 39):
        Return CATEGORY_LOAD()
    End If
    If (opcode is greater than or equal to 40) and (opcode is less than or equal to 43):
        Return CATEGORY_STORE()
    End If
    If (opcode is greater than or equal to 4) and (opcode is less than or equal to 7):
        Return CATEGORY_BRANCH()
    End If
    If (opcode is equal to 2) or (opcode is equal to 3):
        Return CATEGORY_JUMP()
    End If
    Return 0
End Process

Process called "is_branch_instruction" takes opcode as Integer returns Integer:
    If (opcode is greater than or equal to 4) and (opcode is less than or equal to 7):
        Return 1
    End If
    If opcode is equal to 1:
        Return 1  Note: REGIMM (BLTZ, BGEZ, etc.)
    End If
    Return 0
End Process

Process called "is_jump_instruction" takes opcode as Integer, funct as Integer returns Integer:
    If (opcode is equal to 2) or (opcode is equal to 3):
        Return 1
    End If
    If opcode is equal to 0:
        If (funct is equal to 8) or (funct is equal to 9):
            Return 1
        End If
    End If
    Return 0
End Process

Process called "is_memory_instruction" takes opcode as Integer returns Integer:
    If (opcode is greater than or equal to 32) and (opcode is less than or equal to 43):
        Return 1
    End If
    If (opcode is equal to 55) or (opcode is equal to 63):
        Return 1  Note: LD, SD
    End If
    Return 0
End Process

Process called "get_instruction_latency" takes opcode as Integer, funct as Integer returns Integer:
    Note: Estimated latency in cycles (conservative)
    Let category be get_instruction_category(opcode, funct)
    If category is equal to CATEGORY_LOAD():
        Return 3
    End If
    If category is equal to CATEGORY_STORE():
        Return 1
    End If
    If category is equal to CATEGORY_BRANCH():
        Return 1
    End If
    If category is equal to CATEGORY_JUMP():
        Return 1
    End If
    If opcode is equal to 0:
        If (funct is equal to 24) or (funct is equal to 25) or (funct is equal to 28) or (funct is equal to 29):
            Return 10  Note: MULT, MULTU, DMULT, DMULTU
        End If
        If (funct is equal to 26) or (funct is equal to 27) or (funct is equal to 30) or (funct is equal to 31):
            Return 35  Note: DIV, DIVU, DDIV, DDIVU
        End If
    End If
    Return 1  Note: Most ALU operations
End Process

Process called "supports_delay_slot" takes opcode as Integer, funct as Integer returns Integer:
    Note: MIPS has delay slots for branches and jumps
    If is_branch_instruction(opcode) is not equal to 0:
        Return 1
    End If
    If is_jump_instruction(opcode, funct) is not equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "get_instruction_size" returns Integer:
    Return 4  Note: Fixed 4-byte instructions
End Process

Process called "is_64bit_operation" takes opcode as Integer, funct as Integer returns Integer:
    Note: Check if instruction operates on 64-bit data
    If opcode is equal to 0:
        If (funct is greater than or equal to 44) and (funct is less than or equal to 47):
            Return 1  Note: DADD, DADDU, DSUB, DSUBU
        End If
        If (funct is greater than or equal to 20) and (funct is less than or equal to 23):
            Return 1  Note: DSLLV, DSRLV, DSRAV
        End If
        If (funct is greater than or equal to 28) and (funct is less than or equal to 31):
            Return 1  Note: DMULT, DMULTU, DDIV, DDIVU
        End If
        If (funct is greater than or equal to 56) and (funct is less than or equal to 63):
            Return 1  Note: DSLL, DSRL, DSRA, DSLL32, DSRL32, DSRA32
        End If
    End If
    If (opcode is equal to 24) or (opcode is equal to 25):
        Return 1  Note: DADDI, DADDIU
    End If
    If (opcode is equal to 55) or (opcode is equal to 63):
        Return 1  Note: LD, SD
    End If
    If (opcode is greater than or equal to 26) and (opcode is less than or equal to 27):
        Return 1  Note: LDL, LDR
    End If
    If (opcode is greater than or equal to 44) and (opcode is less than or equal to 45):
        Return 1  Note: SDL, SDR
    End If
    Return 0
End Process

Process called "can_fuse_with_next" takes opcode as Integer, funct as Integer returns Integer:
    Note: Conservative fusion support (e.g., LUI + ORI for constant loading)
    If opcode is equal to 15:
        Return 1  Note: LUI can fuse with ORI
    End If
    Return 0
End Process
