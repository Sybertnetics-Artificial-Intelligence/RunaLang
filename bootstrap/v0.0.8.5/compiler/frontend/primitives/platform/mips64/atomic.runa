Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions
Licensed under the Apache License, Version 2.0
:End Note

Note:
MIPS64 ATOMIC OPERATIONS
Uses LL/SC (load-linked/store-conditional) instructions
:End Note

Process called "atomic_load_relaxed" takes ptr as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ld $t0, -8($fp)
        ld $t1, 0($t0)
        sd $t1, -16($fp)
    End Assembly
    Return result
End Process

Process called "atomic_load_acquire" takes ptr as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ld $t0, -8($fp)
        ld $t1, 0($t0)
        sync
        sd $t1, -16($fp)
    End Assembly
    Return result
End Process

Process called "atomic_load_seq_cst" takes ptr as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ld $t0, -8($fp)
        sync
        ld $t1, 0($t0)
        sync
        sd $t1, -16($fp)
    End Assembly
    Return result
End Process

Process called "atomic_store_relaxed" takes ptr as Integer, value as Integer returns Integer:
    Inline Assembly:
        ld $t0, -8($fp)
        ld $t1, -16($fp)
        sd $t1, 0($t0)
    End Assembly
    Return 0
End Process

Process called "atomic_store_release" takes ptr as Integer, value as Integer returns Integer:
    Inline Assembly:
        ld $t0, -8($fp)
        ld $t1, -16($fp)
        sync
        sd $t1, 0($t0)
    End Assembly
    Return 0
End Process

Process called "atomic_store_seq_cst" takes ptr as Integer, value as Integer returns Integer:
    Inline Assembly:
        ld $t0, -8($fp)
        ld $t1, -16($fp)
        sync
        sd $t1, 0($t0)
        sync
    End Assembly
    Return 0
End Process

Process called "atomic_fetch_add" takes ptr as Integer, value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ld $t0, -8($fp)
        ld $t1, -16($fp)

        .retry:
        lld $t2, 0($t0)
        daddu $t3, $t2, $t1
        scd $t3, 0($t0)
        beqz $t3, .retry

        sd $t2, -24($fp)
    End Assembly
    Return result
End Process

Process called "atomic_fetch_sub" takes ptr as Integer, value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ld $t0, -8($fp)
        ld $t1, -16($fp)

        .retry:
        lld $t2, 0($t0)
        dsubu $t3, $t2, $t1
        scd $t3, 0($t0)
        beqz $t3, .retry

        sd $t2, -24($fp)
    End Assembly
    Return result
End Process

Process called "atomic_fetch_and" takes ptr as Integer, value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ld $t0, -8($fp)
        ld $t1, -16($fp)

        .retry:
        lld $t2, 0($t0)
        and $t3, $t2, $t1
        scd $t3, 0($t0)
        beqz $t3, .retry

        sd $t2, -24($fp)
    End Assembly
    Return result
End Process

Process called "atomic_fetch_or" takes ptr as Integer, value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ld $t0, -8($fp)
        ld $t1, -16($fp)

        .retry:
        lld $t2, 0($t0)
        or $t3, $t2, $t1
        scd $t3, 0($t0)
        beqz $t3, .retry

        sd $t2, -24($fp)
    End Assembly
    Return result
End Process

Process called "atomic_fetch_xor" takes ptr as Integer, value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ld $t0, -8($fp)
        ld $t1, -16($fp)

        .retry:
        lld $t2, 0($t0)
        xor $t3, $t2, $t1
        scd $t3, 0($t0)
        beqz $t3, .retry

        sd $t2, -24($fp)
    End Assembly
    Return result
End Process

Process called "atomic_compare_and_swap" takes ptr as Integer, expected as Integer, desired as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ld $t0, -8($fp)
        ld $t1, -16($fp)
        ld $t2, -24($fp)

        .retry:
        lld $t3, 0($t0)
        bne $t3, $t1, .failed
        move $t4, $t2
        scd $t4, 0($t0)
        beqz $t4, .retry

        li $t5, 1
        b .done

        .failed:
        li $t5, 0

        .done:
        sd $t5, -32($fp)
    End Assembly
    Return result
End Process

Process called "atomic_compare_and_swap_weak" takes ptr as Integer, expected as Integer, desired as Integer returns Integer:
    Return atomic_compare_and_swap(ptr, expected, desired)
End Process

Process called "atomic_exchange" takes ptr as Integer, value as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        ld $t0, -8($fp)
        ld $t1, -16($fp)

        .retry:
        lld $t2, 0($t0)
        move $t3, $t1
        scd $t3, 0($t0)
        beqz $t3, .retry

        sd $t2, -24($fp)
    End Assembly
    Return result
End Process

Process called "memory_barrier_acquire" returns Integer:
    Inline Assembly:
        sync
    End Assembly
    Return 0
End Process

Process called "memory_barrier_release" returns Integer:
    Inline Assembly:
        sync
    End Assembly
    Return 0
End Process

Process called "memory_barrier_full" returns Integer:
    Inline Assembly:
        sync
    End Assembly
    Return 0
End Process

Process called "memory_barrier_seq_cst" returns Integer:
    Inline Assembly:
        sync
    End Assembly
    Return 0
End Process
