Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
Darwin ARM64 Calling Convention

This file implements the Darwin (macOS) ARM64 calling convention, which is based
on AAPCS64 (ARM64 Procedure Call Standard).

Darwin ARM64 Calling Convention Summary:
- Integer/pointer arguments: X0-X7 (8 registers)
- Floating-point arguments: V0-V7 (8 registers, also called D0-D7, S0-S7, Q0-Q7)
- Additional arguments: Pushed on stack (right-to-left)
- Return value: X0 (integer/pointer), V0/D0 (float/double)
- Stack alignment: 16-byte aligned at public interfaces
- Caller-saved (volatile): X0-X15, V0-V7, V16-V31
- Callee-saved (non-volatile): X19-X28, V8-V15 (lower 64 bits)
- Frame pointer: X29 (FP)
- Link register: X30 (LR, stores return address)
- Stack pointer: SP (dedicated register, not part of X0-X30)
- Platform register: X18 (reserved on Darwin)

Darwin-specific notes:
1. X18 is reserved as platform register (may be used for TLS)
2. Stack must be 16-byte aligned at public interfaces (same as AAPCS64)
3. No red zone (unlike x86_64 which has 128-byte red zone)
4. Return values larger than 16 bytes: passed via hidden pointer in X8

References:
- ARM Procedure Call Standard for ARM64 (AAPCS64)
- Apple ARM64 ABI Documentation
- ARM Architecture Reference Manual for ARMv8-A

Dependencies: registers.runa for register mappings
:End Note

Import "compiler/frontend/primitives/platform/darwin_arm64/registers.runa" as Registers
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Note: ============================================================================
Note: PARAMETER PASSING - INTEGER AND POINTER ARGUMENTS
Note: ============================================================================

Process called "get_integer_param_register" takes param_index as Integer returns Integer:
    Note: Get register number for integer/pointer parameter
    Note: Darwin ARM64: X0-X7 (indices 0-7)
    Note: Returns register number (0-30), or -1 if passed on stack

    If param_index is equal to 0:
        Return 0  Note: X0
    End If

    If param_index is equal to 1:
        Return 1  Note: X1
    End If

    If param_index is equal to 2:
        Return 2  Note: X2
    End If

    If param_index is equal to 3:
        Return 3  Note: X3
    End If

    If param_index is equal to 4:
        Return 4  Note: X4
    End If

    If param_index is equal to 5:
        Return 5  Note: X5
    End If

    If param_index is equal to 6:
        Return 6  Note: X6
    End If

    If param_index is equal to 7:
        Return 7  Note: X7
    End If

    Note: Parameters 8+ are passed on stack
    Return -1
End Process

Process called "get_max_integer_register_params" returns Integer:
    Note: Maximum number of integer/pointer parameters passed in registers
    Return 8
End Process

Process called "is_param_in_register" takes param_index as Integer returns Integer:
    Note: Check if parameter is passed in register (vs stack)
    Note: Returns 1 if in register, 0 if on stack

    If param_index is less than 8:
        Return 1
    End If

    Return 0
End Process

Process called "get_stack_param_offset" takes param_index as Integer returns Integer:
    Note: Get stack offset for parameter passed on stack
    Note: Stack parameters start at [SP + 0] (ARM64 pushes args before call)
    Note: param_index must be >= 8 (first 8 are in registers)

    If param_index is less than 8:
        Return 0  Note: Not a stack parameter
    End If

    Note: Calculate offset: 8 bytes per parameter
    Let stack_param_num be param_index minus 8
    Let offset be stack_param_num multiplied by 8

    Return offset
End Process

Note: ============================================================================
Note: PARAMETER PASSING - FLOATING-POINT ARGUMENTS
Note: ============================================================================

Process called "get_float_param_register" takes param_index as Integer returns Integer:
    Note: Get V register number for floating-point parameter
    Note: Darwin ARM64: V0-V7 (indices 0-7), also known as D0-D7 or S0-S7
    Note: Returns V register number (32-63 in our encoding), or -1 if passed on stack

    If param_index is less than 8:
        Return proc get_fp_param_register from Registers with param_index
    End If

    Note: Parameters 8+ are passed on stack
    Return -1
End Process

Process called "get_max_float_register_params" returns Integer:
    Note: Maximum number of floating-point parameters passed in V registers
    Return 8  Note: V0-V7
End Process

Process called "is_float_param_in_register" takes param_index as Integer returns Integer:
    Note: Check if floating-point parameter is passed in register (vs stack)
    Note: Returns 1 if in register, 0 if on stack

    If param_index is less than 8:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: RETURN VALUE HANDLING
Note: ============================================================================

Process called "get_return_value_register" returns Integer:
    Note: Get register number for return value
    Note: Integer/pointer returns: X0
    Return 0  Note: X0
End Process

Process called "get_float_return_register" returns Integer:
    Note: Get register number for floating-point return value
    Note: Float/double returns: V0 (also called D0 or S0)
    Return proc get_fp_return_register from Registers  Note: Returns 32 (V0)
End Process

Process called "is_return_via_memory" takes return_size as Integer returns Integer:
    Note: Check if return value is passed via memory (hidden pointer)
    Note: Returns 1 if return via memory, 0 if in registers
    Note: Darwin ARM64: Structures > 16 bytes returned via hidden pointer in X8

    If return_size is greater than 16:
        Return 1  Note: Large structures returned via memory
    End If

    Return 0  Note: Return in registers
End Process

Process called "get_return_pointer_register" returns Integer:
    Note: Get register for hidden return pointer (for large structs)
    Note: Darwin ARM64: X8 holds address where large return values are written
    Return 8  Note: X8
End Process

Note: ============================================================================
Note: REGISTER PRESERVATION (CALLER-SAVED vs CALLEE-SAVED)
Note: ============================================================================

Process called "is_caller_saved_register" takes reg_num as Integer returns Integer:
    Note: Check if register is caller-saved (volatile)
    Note: Caller-saved: X0-X15, V0-V7, V16-V31
    Note: Returns 1 if caller-saved, 0 if callee-saved

    Note: X0-X15 are caller-saved
    If reg_num is less than or equal to 15:
        Return 1
    End If

    Note: V0-V7 (encoded as 32-39) are caller-saved
    If reg_num is greater than or equal to 32:
        If reg_num is less than or equal to 39:
            Return 1
        End If
    End If

    Note: V16-V31 (encoded as 48-63) are caller-saved
    If reg_num is greater than or equal to 48:
        If reg_num is less than or equal to 63:
            Return 1
        End If
    End If

    Return 0  Note: Callee-saved or special register
End Process

Process called "is_callee_saved_register" takes reg_num as Integer returns Integer:
    Note: Check if register is callee-saved (non-volatile)
    Note: Callee-saved: X19-X28, V8-V15 (lower 64 bits)
    Note: Returns 1 if callee-saved, 0 if caller-saved

    Note: X19-X28 are callee-saved
    If reg_num is greater than or equal to 19:
        If reg_num is less than or equal to 28:
            Return 1
        End If
    End If

    Note: V8-V15 (encoded as 40-47) are callee-saved (lower 64 bits)
    If reg_num is greater than or equal to 40:
        If reg_num is less than or equal to 47:
            Return 1
        End If
    End If

    Return 0  Note: Caller-saved or special register
End Process

Process called "get_callee_saved_register_list" takes buffer_ptr as Integer returns Integer:
    Note: Fill buffer with list of callee-saved register numbers
    Note: buffer_ptr: pointer to array of at least 10 integers
    Note: Returns: count of callee-saved registers (10)

    Let offset be 0

    Note: Store register numbers in buffer (8 bytes per integer)
    Note: X19 (19)
    proc memory_set_int64 from Memory with buffer_ptr, offset, 19
    Set offset to offset plus 8

    Note: X20 (20)
    proc memory_set_int64 from Memory with buffer_ptr, offset, 20
    Set offset to offset plus 8

    Note: X21 (21)
    proc memory_set_int64 from Memory with buffer_ptr, offset, 21
    Set offset to offset plus 8

    Note: X22 (22)
    proc memory_set_int64 from Memory with buffer_ptr, offset, 22
    Set offset to offset plus 8

    Note: X23 (23)
    proc memory_set_int64 from Memory with buffer_ptr, offset, 23
    Set offset to offset plus 8

    Note: X24 (24)
    proc memory_set_int64 from Memory with buffer_ptr, offset, 24
    Set offset to offset plus 8

    Note: X25 (25)
    proc memory_set_int64 from Memory with buffer_ptr, offset, 25
    Set offset to offset plus 8

    Note: X26 (26)
    proc memory_set_int64 from Memory with buffer_ptr, offset, 26
    Set offset to offset plus 8

    Note: X27 (27)
    proc memory_set_int64 from Memory with buffer_ptr, offset, 27
    Set offset to offset plus 8

    Note: X28 (28)
    proc memory_set_int64 from Memory with buffer_ptr, offset, 28

    Return 10  Note: 10 callee-saved integer registers
End Process

Note: ============================================================================
Note: STACK FRAME MANAGEMENT
Note: ============================================================================

Process called "get_stack_alignment" returns Integer:
    Note: Get required stack alignment in bytes
    Note: Darwin ARM64: 16-byte alignment at public interfaces
    Return 16
End Process

Process called "calculate_stack_frame_size" takes local_vars_size as Integer, num_callee_saved_regs as Integer returns Integer:
    Note: Calculate total stack frame size with proper alignment
    Note: local_vars_size: size of local variables in bytes
    Note: num_callee_saved_regs: number of callee-saved registers to preserve
    Note: Returns: total frame size (16-byte aligned)

    Note: Saved registers: 8 bytes each
    Let saved_regs_size be num_callee_saved_regs multiplied by 8

    Note: Must also save FP (X29) and LR (X30) for non-leaf functions
    Note: This adds 16 bytes (2 registers)
    Let frame_record_size be 16

    Note: Total size before alignment
    Let total_size be local_vars_size plus saved_regs_size plus frame_record_size

    Note: Round up to 16-byte alignment
    Let remainder be total_size bitwise_and 15
    If remainder is not equal to 0:
        Let padding be 16 minus remainder
        Set total_size to total_size plus padding
    End If

    Return total_size
End Process

Process called "get_frame_pointer_register" returns Integer:
    Note: Get frame pointer register number
    Note: Darwin ARM64: X29 (FP)
    Return 29  Note: X29/FP
End Process

Process called "get_link_register" returns Integer:
    Note: Get link register number
    Note: Darwin ARM64: X30 (LR, stores return address)
    Return 30  Note: X30/LR
End Process

Process called "get_stack_pointer_register" returns Integer:
    Note: Get stack pointer register number
    Note: Darwin ARM64: SP (dedicated register, encoded as 31)
    Return 31  Note: SP
End Process

Process called "get_red_zone_size" returns Integer:
    Note: Get red zone size in bytes
    Note: ARM64 DOES NOT have a red zone like x86_64
    Note: Functions must not access memory below SP
    Return 0
End Process

Process called "can_use_red_zone" takes is_leaf_function as Integer returns Integer:
    Note: Check if function can use red zone optimization
    Note: ARM64 does not have a red zone, always return 0
    Return 0
End Process

Note: ============================================================================
Note: FUNCTION PROLOGUE AND EPILOGUE HELPERS
Note: ============================================================================

Process called "needs_frame_pointer" takes has_variable_sized_locals as Integer, has_alloca as Integer returns Integer:
    Note: Determine if function needs frame pointer
    Note: Frame pointer required for variable-sized locals or alloca
    Note: Returns 1 if frame pointer needed, 0 if can use SP directly

    If has_variable_sized_locals is equal to 1:
        Return 1
    End If

    If has_alloca is equal to 1:
        Return 1
    End If

    Note: Darwin ARM64 convention: FP (X29) typically always used
    Return 0
End Process

Process called "must_save_link_register" takes is_leaf_function as Integer returns Integer:
    Note: Check if function must save link register (X30/LR)
    Note: Non-leaf functions MUST save LR since they call other functions
    Note: Returns 1 if LR must be saved, 0 if not needed

    If is_leaf_function is equal to 0:
        Return 1  Note: Non-leaf must save LR
    End If

    Return 0  Note: Leaf functions can avoid saving LR
End Process

Process called "calculate_call_stack_adjustment" takes num_stack_args as Integer returns Integer:
    Note: Calculate stack space needed for outgoing call arguments
    Note: num_stack_args: number of arguments passed on stack (beyond first 8)
    Note: Returns: stack adjustment in bytes (16-byte aligned)

    If num_stack_args is less than or equal to 0:
        Return 0  Note: No stack arguments
    End If

    Note: Each argument is 8 bytes
    Let args_size be num_stack_args multiplied by 8

    Note: Round up to 16-byte alignment
    Let remainder be args_size bitwise_and 15
    If remainder is not equal to 0:
        Let padding be 16 minus remainder
        Set args_size to args_size plus padding
    End If

    Return args_size
End Process

Note: ============================================================================
Note: VARIADIC FUNCTION SUPPORT
Note: ============================================================================

Process called "get_variadic_gp_register_save_area_size" returns Integer:
    Note: Size of save area for general-purpose register arguments
    Note: Darwin ARM64: 8 registers × 8 bytes = 64 bytes
    Return 64
End Process

Process called "get_variadic_fp_register_save_area_size" returns Integer:
    Note: Size of save area for floating-point register arguments
    Note: Darwin ARM64: 8 V registers × 16 bytes = 128 bytes
    Return 128
End Process

Process called "get_variadic_total_save_area_size" returns Integer:
    Note: Total size for variadic function register save area
    Note: GP area (64) + FP area (128) = 192 bytes
    Return 192
End Process

Note: ============================================================================
Note: HELPER FUNCTIONS FOR CODE GENERATION
Note: ============================================================================

Process called "get_parameter_location" takes param_index as Integer, param_size as Integer, result_buffer as Integer returns Integer:
    Note: Get location (register or stack offset) for parameter
    Note: param_index: parameter position (0-based)
    Note: param_size: size in bytes (for future struct handling)
    Note: result_buffer: pointer to 2-integer array [location_type, value]
    Note: location_type: 0 = register (value = reg_num), 1 = stack (value = offset)
    Note: Returns: location_type

    Let location_type be 0
    Let value be 0

    Note: Check if parameter is in register
    If param_index is less than 8:
        Set location_type to 0  Note: Register
        Set value to get_integer_param_register(param_index)
    Otherwise:
        Set location_type to 1  Note: Stack
        Set value to get_stack_param_offset(param_index)
    End If

    Note: Write results to buffer
    proc memory_set_int64 from Memory with result_buffer, 0, location_type
    proc memory_set_int64 from Memory with result_buffer, 8, value

    Return location_type
End Process

Process called "get_call_setup_info" takes num_params as Integer, result_buffer as Integer returns Integer:
    Note: Get information needed to set up a function call
    Note: num_params: total number of parameters
    Note: result_buffer: pointer to 3-integer array [reg_params, stack_params, stack_adjustment]
    Note: Returns: number of stack parameters

    Let reg_params be 8
    Let stack_params be 0
    Let stack_adjustment be 0

    If num_params is less than or equal to 8:
        Set reg_params to num_params
    Otherwise:
        Set stack_params to num_params minus 8
        Set stack_adjustment to calculate_call_stack_adjustment(stack_params)
    End If

    Note: Write results to buffer
    proc memory_set_int64 from Memory with result_buffer, 0, reg_params
    proc memory_set_int64 from Memory with result_buffer, 8, stack_params
    proc memory_set_int64 from Memory with result_buffer, 16, stack_adjustment

    Return stack_params
End Process

Note: ============================================================================
Note: CALLING CONVENTION VALIDATION AND UTILITIES
Note: ============================================================================

Process called "validate_stack_alignment" takes stack_offset as Integer returns Integer:
    Note: Check if stack offset is properly aligned
    Note: Returns 1 if aligned to 16 bytes, 0 otherwise

    Let remainder be stack_offset bitwise_and 15
    If remainder is equal to 0:
        Return 1  Note: Properly aligned
    End If

    Return 0  Note: Misaligned
End Process

Process called "get_calling_convention_name" returns String:
    Note: Return name of calling convention
    Return "Darwin ARM64"
End Process

Process called "get_abi_version" returns Integer:
    Note: Return ABI version identifier
    Note: Using Darwin ARM64 ABI version 1 (AAPCS64-based)
    Return 1
End Process
