Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file provides the typeof intrinsic - returns type information at compile time.

The typeof intrinsic allows querying type information for variables, expressions,
and type names. This is essential for:
- Generic programming and templates
- Type introspection and reflection
- Compile-time type checking
- Metaprogramming

Type IDs are compile-time constants that uniquely identify each type.
Type names are string representations of types.

Depends on:
- string_core.runa (for string operations)
:End Note

Import "compiler/frontend/primitives/core/string_core.runa" as StringCore

Note: ============================================================================
Note: Type ID Constants
Note: ============================================================================

Note: Type IDs are unique integers identifying each type

Process called "TYPE_ID_VOID" returns Integer:
    Return 0
End Process

Process called "TYPE_ID_BOOLEAN" returns Integer:
    Return 1
End Process

Process called "TYPE_ID_CHARACTER" returns Integer:
    Return 2
End Process

Process called "TYPE_ID_INT8" returns Integer:
    Return 3
End Process

Process called "TYPE_ID_INT16" returns Integer:
    Return 4
End Process

Process called "TYPE_ID_INT32" returns Integer:
    Return 5
End Process

Process called "TYPE_ID_INT64" returns Integer:
    Return 6
End Process

Process called "TYPE_ID_INT128" returns Integer:
    Return 7
End Process

Process called "TYPE_ID_INT256" returns Integer:
    Return 8
End Process

Process called "TYPE_ID_INT512" returns Integer:
    Return 9
End Process

Process called "TYPE_ID_FLOAT16" returns Integer:
    Return 10
End Process

Process called "TYPE_ID_FLOAT32" returns Integer:
    Return 11
End Process

Process called "TYPE_ID_FLOAT64" returns Integer:
    Return 12
End Process

Process called "TYPE_ID_FLOAT80" returns Integer:
    Return 13
End Process

Process called "TYPE_ID_FLOAT128" returns Integer:
    Return 14
End Process

Process called "TYPE_ID_POINTER" returns Integer:
    Return 15
End Process

Process called "TYPE_ID_STRING" returns Integer:
    Return 16
End Process

Process called "TYPE_ID_ARRAY" returns Integer:
    Return 17
End Process

Process called "TYPE_ID_STRUCT" returns Integer:
    Return 18
End Process

Process called "TYPE_ID_UNION" returns Integer:
    Return 19
End Process

Process called "TYPE_ID_FUNCTION" returns Integer:
    Return 20
End Process

Process called "TYPE_ID_ADT" returns Integer:
    Note: Algebraic Data Type
    Return 21
End Process

Note: ============================================================================
Note: Type Name to Type ID Mapping
Note: ============================================================================

Process called "get_type_id_from_name" takes type_name as String returns Integer:
    Note: Convert type name string to type ID
    Note: Returns type ID or -1 if unknown

    If string equals from StringCore with type_name, "void" is equal to 1:
        Return TYPE_ID_VOID()
    End If

    If string equals from StringCore with type_name, "Boolean" is equal to 1:
        Return TYPE_ID_BOOLEAN()
    End If

    If string equals from StringCore with type_name, "Character" is equal to 1:
        Return TYPE_ID_CHARACTER()
    End If

    If string equals from StringCore with type_name, "Int8" is equal to 1:
        Return TYPE_ID_INT8()
    End If

    If string equals from StringCore with type_name, "Byte" is equal to 1:
        Return TYPE_ID_INT8()  Note: Byte is alias for Int8
    End If

    If string equals from StringCore with type_name, "Int16" is equal to 1:
        Return TYPE_ID_INT16()
    End If

    If string equals from StringCore with type_name, "Short" is equal to 1:
        Return TYPE_ID_INT16()  Note: Short is alias for Int16
    End If

    If string equals from StringCore with type_name, "Int32" is equal to 1:
        Return TYPE_ID_INT32()
    End If

    If string equals from StringCore with type_name, "Int64" is equal to 1:
        Return TYPE_ID_INT64()
    End If

    If string equals from StringCore with type_name, "Integer" is equal to 1:
        Return TYPE_ID_INT64()  Note: Integer is alias for Int64
    End If

    If string equals from StringCore with type_name, "Long" is equal to 1:
        Return TYPE_ID_INT64()  Note: Long is alias for Int64
    End If

    If string equals from StringCore with type_name, "Int128" is equal to 1:
        Return TYPE_ID_INT128()
    End If

    If string equals from StringCore with type_name, "Int256" is equal to 1:
        Return TYPE_ID_INT256()
    End If

    If string equals from StringCore with type_name, "Int512" is equal to 1:
        Return TYPE_ID_INT512()
    End If

    If string equals from StringCore with type_name, "Float16" is equal to 1:
        Return TYPE_ID_FLOAT16()
    End If

    If string equals from StringCore with type_name, "Float" is equal to 1:
        Return TYPE_ID_FLOAT32()  Note: Float is alias for Float32
    End If

    If string equals from StringCore with type_name, "Float32" is equal to 1:
        Return TYPE_ID_FLOAT32()
    End If

    If string equals from StringCore with type_name, "Double" is equal to 1:
        Return TYPE_ID_FLOAT64()  Note: Double is alias for Float64
    End If

    If string equals from StringCore with type_name, "Float64" is equal to 1:
        Return TYPE_ID_FLOAT64()
    End If

    If string equals from StringCore with type_name, "Float80" is equal to 1:
        Return TYPE_ID_FLOAT80()
    End If

    If string equals from StringCore with type_name, "Float128" is equal to 1:
        Return TYPE_ID_FLOAT128()
    End If

    If string equals from StringCore with type_name, "Pointer" is equal to 1:
        Return TYPE_ID_POINTER()
    End If

    If string equals from StringCore with type_name, "String" is equal to 1:
        Return TYPE_ID_STRING()
    End If

    Return -1  Note: Unknown type
End Process

Note: ============================================================================
Note: Type ID to Type Name Mapping
Note: ============================================================================

Process called "get_type_name_from_id" takes type_id as Integer returns String:
    Note: Convert type ID to type name string
    Note: Returns type name or "Unknown" if invalid

    If type_id is equal to TYPE_ID_VOID():
        Return "void"
    End If

    If type_id is equal to TYPE_ID_BOOLEAN():
        Return "Boolean"
    End If

    If type_id is equal to TYPE_ID_CHARACTER():
        Return "Character"
    End If

    If type_id is equal to TYPE_ID_INT8():
        Return "Int8"
    End If

    If type_id is equal to TYPE_ID_INT16():
        Return "Int16"
    End If

    If type_id is equal to TYPE_ID_INT32():
        Return "Int32"
    End If

    If type_id is equal to TYPE_ID_INT64():
        Return "Int64"
    End If

    If type_id is equal to TYPE_ID_INT128():
        Return "Int128"
    End If

    If type_id is equal to TYPE_ID_INT256():
        Return "Int256"
    End If

    If type_id is equal to TYPE_ID_INT512():
        Return "Int512"
    End If

    If type_id is equal to TYPE_ID_FLOAT16():
        Return "Float16"
    End If

    If type_id is equal to TYPE_ID_FLOAT32():
        Return "Float32"
    End If

    If type_id is equal to TYPE_ID_FLOAT64():
        Return "Float64"
    End If

    If type_id is equal to TYPE_ID_FLOAT80():
        Return "Float80"
    End If

    If type_id is equal to TYPE_ID_FLOAT128():
        Return "Float128"
    End If

    If type_id is equal to TYPE_ID_POINTER():
        Return "Pointer"
    End If

    If type_id is equal to TYPE_ID_STRING():
        Return "String"
    End If

    If type_id is equal to TYPE_ID_ARRAY():
        Return "Array"
    End If

    If type_id is equal to TYPE_ID_STRUCT():
        Return "Struct"
    End If

    If type_id is equal to TYPE_ID_UNION():
        Return "Union"
    End If

    If type_id is equal to TYPE_ID_FUNCTION():
        Return "Function"
    End If

    If type_id is equal to TYPE_ID_ADT():
        Return "ADT"
    End If

    Return "Unknown"
End Process

Note: ============================================================================
Note: Type Category Queries
Note: ============================================================================

Process called "is_integer_type" takes type_id as Integer returns Integer:
    Note: Check if type ID represents an integer type
    Note: Returns 1 if integer, 0 otherwise

    If type_id is greater than or equal to TYPE_ID_INT8():
        If type_id is less than or equal to TYPE_ID_INT512():
            Return 1
        End If
    End If

    Return 0
End Process

Process called "is_float_type" takes type_id as Integer returns Integer:
    Note: Check if type ID represents a floating point type
    Note: Returns 1 if float, 0 otherwise

    If type_id is greater than or equal to TYPE_ID_FLOAT16():
        If type_id is less than or equal to TYPE_ID_FLOAT128():
            Return 1
        End If
    End If

    Return 0
End Process

Process called "is_numeric_type" takes type_id as Integer returns Integer:
    Note: Check if type ID represents a numeric type (integer or float)
    Note: Returns 1 if numeric, 0 otherwise

    Let is_int be proc is_integer_type with type_id
    If is_int is equal to 1:
        Return 1
    End If

    Let is_float be proc is_float_type with type_id
    Return is_float
End Process

Process called "is_pointer_type" takes type_id as Integer returns Integer:
    Note: Check if type ID represents a pointer type
    Note: Returns 1 if pointer, 0 otherwise

    If type_id is equal to TYPE_ID_POINTER():
        Return 1
    End If

    If type_id is equal to TYPE_ID_STRING():
        Return 1  Note: String is a pointer type
    End If

    Return 0
End Process

Process called "is_primitive_type" takes type_id as Integer returns Integer:
    Note: Check if type ID represents a primitive type
    Note: Primitive = numeric, boolean, character, pointer
    Note: Returns 1 if primitive, 0 otherwise

    If type_id is equal to TYPE_ID_BOOLEAN():
        Return 1
    End If

    If type_id is equal to TYPE_ID_CHARACTER():
        Return 1
    End If

    Let is_num be proc is_numeric_type with type_id
    If is_num is equal to 1:
        Return 1
    End If

    Let is_ptr be proc is_pointer_type with type_id
    Return is_ptr
End Process

Process called "is_composite_type" takes type_id as Integer returns Integer:
    Note: Check if type ID represents a composite type
    Note: Composite = array, struct, union, ADT
    Note: Returns 1 if composite, 0 otherwise

    If type_id is equal to TYPE_ID_ARRAY():
        Return 1
    End If

    If type_id is equal to TYPE_ID_STRUCT():
        Return 1
    End If

    If type_id is equal to TYPE_ID_UNION():
        Return 1
    End If

    If type_id is equal to TYPE_ID_ADT():
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Type Size Queries
Note: ============================================================================

Process called "get_type_size_bits" takes type_id as Integer returns Integer:
    Note: Get size in bits for a type ID
    Note: Returns size in bits or -1 if unknown/variable

    If type_id is equal to TYPE_ID_BOOLEAN():
        Return 8  Note: 1 byte = 8 bits
    End If

    If type_id is equal to TYPE_ID_CHARACTER():
        Return 8
    End If

    If type_id is equal to TYPE_ID_INT8():
        Return 8
    End If

    If type_id is equal to TYPE_ID_INT16():
        Return 16
    End If

    If type_id is equal to TYPE_ID_INT32():
        Return 32
    End If

    If type_id is equal to TYPE_ID_INT64():
        Return 64
    End If

    If type_id is equal to TYPE_ID_INT128():
        Return 128
    End If

    If type_id is equal to TYPE_ID_INT256():
        Return 256
    End If

    If type_id is equal to TYPE_ID_INT512():
        Return 512
    End If

    If type_id is equal to TYPE_ID_FLOAT16():
        Return 16
    End If

    If type_id is equal to TYPE_ID_FLOAT32():
        Return 32
    End If

    If type_id is equal to TYPE_ID_FLOAT64():
        Return 64
    End If

    If type_id is equal to TYPE_ID_FLOAT80():
        Return 80  Note: Actual data size (stored in 128 bits with padding)
    End If

    If type_id is equal to TYPE_ID_FLOAT128():
        Return 128
    End If

    If type_id is equal to TYPE_ID_POINTER():
        Return 64  Note: x86_64 pointers are 64 bits
    End If

    If type_id is equal to TYPE_ID_STRING():
        Return 64  Note: String is a pointer
    End If

    Return -1  Note: Variable or unknown size
End Process

Note: ============================================================================
Note: Type Comparison
Note: ============================================================================

Process called "types_are_equal" takes type_id1 as Integer, type_id2 as Integer returns Integer:
    Note: Check if two type IDs are equal
    Note: Returns 1 if equal, 0 otherwise

    If type_id1 is equal to type_id2:
        Return 1
    End If

    Return 0
End Process

Process called "types_are_compatible" takes type_id1 as Integer, type_id2 as Integer returns Integer:
    Note: Check if two types are compatible for operations
    Note: Handles implicit conversions between compatible types
    Note: Returns 1 if compatible, 0 otherwise

    Note: Exact match is always compatible
    If types_are_equal(type_id1, type_id2) is equal to 1:
        Return 1
    End If

    Note: All integer types are compatible with each other (with potential narrowing/widening)
    Let is_int1 be proc is_integer_type with type_id1
    Let is_int2 be proc is_integer_type with type_id2
    If is_int1 is equal to 1:
        If is_int2 is equal to 1:
            Return 1  Note: Integer types are mutually compatible
        End If
    End If

    Note: All float types are compatible with each other
    Let is_float1 be proc is_float_type with type_id1
    Let is_float2 be proc is_float_type with type_id2
    If is_float1 is equal to 1:
        If is_float2 is equal to 1:
            Return 1  Note: Float types are mutually compatible
        End If
    End If

    Note: Integers can be implicitly converted to floats
    If is_int1 is equal to 1:
        If is_float2 is equal to 1:
            Return 1  Note: Int → Float conversion allowed
        End If
    End If

    Note: Pointer and String are compatible (String is a pointer)
    If type_id1 is equal to TYPE_ID_POINTER():
        If type_id2 is equal to TYPE_ID_STRING():
            Return 1
        End If
    End If

    If type_id1 is equal to TYPE_ID_STRING():
        If type_id2 is equal to TYPE_ID_POINTER():
            Return 1
        End If
    End If

    Return 0  Note: Types are not compatible
End Process

Process called "can_cast_to" takes from_type as Integer, to_type as Integer returns Integer:
    Note: Check if from_type can be explicitly cast to to_type
    Note: This is more permissive than types_are_compatible
    Note: Returns 1 if cast is allowed, 0 otherwise

    Note: Identity cast always works
    If from_type is equal to to_type:
        Return 1
    End If

    Note: Any numeric type can be cast to any other numeric type
    Let is_num_from be proc is_numeric_type with from_type
    Let is_num_to be proc is_numeric_type with to_type
    If is_num_from is equal to 1:
        If is_num_to is equal to 1:
            Return 1
        End If
    End If

    Note: Pointers can be cast to integers and vice versa
    Let is_ptr_from be proc is_pointer_type with from_type
    Let is_ptr_to be proc is_pointer_type with to_type

    If is_ptr_from is equal to 1:
        If is_num_to is equal to 1:
            Return 1  Note: Pointer → Integer cast (for pointer arithmetic)
        End If
    End If

    If is_num_from is equal to 1:
        If is_ptr_to is equal to 1:
            Return 1  Note: Integer → Pointer cast (unsafe but allowed)
        End If
    End If

    Note: Pointers can be cast to other pointer types
    If is_ptr_from is equal to 1:
        If is_ptr_to is equal to 1:
            Return 1  Note: Pointer type casting
        End If
    End If

    Note: Boolean can be cast to/from integers
    If from_type is equal to TYPE_ID_BOOLEAN():
        Let is_int_to be proc is_integer_type with to_type
        If is_int_to is equal to 1:
            Return 1
        End If
    End If

    If to_type is equal to TYPE_ID_BOOLEAN():
        Let is_int_from be proc is_integer_type with from_type
        If is_int_from is equal to 1:
            Return 1
        End If
    End If

    Return 0  Note: Cast not allowed
End Process

Process called "requires_explicit_cast" takes from_type as Integer, to_type as Integer returns Integer:
    Note: Check if conversion requires an explicit cast
    Note: Returns 1 if explicit cast needed, 0 if implicit conversion works
    Note: Returns 0 if types are not convertible at all

    Note: If types are compatible, no explicit cast needed
    Let are_compat be proc types_are_compatible with from_type, to_type
    If are_compat is equal to 1:
        Return 0  Note: Implicit conversion works
    End If

    Note: If cast is possible but not implicit, explicit cast is required
    Let can_cast be proc can_cast_to with from_type, to_type
    If can_cast is equal to 1:
        Return 1  Note: Explicit cast required
    End If

    Return 0  Note: Not convertible at all
End Process
