Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles the offsetof intrinsic for field offset queries.

This file performs the following tasks:
- Process offsetof intrinsic calls and field offset queries
- Handle offset calculation and field offset information retrieval
- Manage offset optimization and offset-aware code generation
- Process offset validation and offset constraint checking

This file is essential because of the following reasons:
- offsetof intrinsic enables compile-time field offset queries and optimization
- Proper offset handling ensures correct memory layout and field access
- Offset intrinsics support low-level programming and memory management

This file consists of the following functions/features/operation types:
- offsetof intrinsic processing and field offset queries
- Offset calculation and field offset information retrieval
- Offset optimization and offset-aware code generation
- Offset validation and offset constraint checking
:End Note

Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/intrinsics/sizeof.runa" as SizeOf
Import "compiler/frontend/primitives/core/alignment_core.runa" as Alignment

Note: ============================================================================
Note: Field Offset Calculation
Note: ============================================================================

Process called "calculate_field_offset" takes field_sizes as Integer, field_alignments as Integer, field_index as Integer returns Integer:
    Note: Calculate offset of a specific field in a struct
    Note: field_sizes: pointer to array of field sizes (8 bytes each)
    Note: field_alignments: pointer to array of field alignments (8 bytes each)
    Note: field_index: which field to get offset for (0-based)
    Note: Returns: byte offset of the field

    If field_index is less than 0:
        Return 0  Note: Invalid index
    End If

    Let current_offset be 0
    Let i be 0

    Note: Calculate offset by iterating through previous fields
    While i is less than field_index:
        Let offset be i multiplied by 8

        Let field_size be memory_get_int64(field_sizes, offset)
        Let field_alignment be memory_get_int64(field_alignments, offset)

        Note: Align current offset to field alignment
        Let aligned_offset be align_struct_field(current_offset, field_alignment)

        Note: Add field size
        Set current_offset to aligned_offset plus field_size

        Set i to i plus 1
    End While

    Note: Align to target field's alignment
    If field_index is greater than 0:
        Let target_offset be field_index multiplied by 8
        Let target_alignment be memory_get_int64(field_alignments, target_offset)
        Set current_offset to align_struct_field(current_offset, target_alignment)
    End If

    Return current_offset
End Process

Note: ============================================================================
Note: Simple Field Offset (No Padding)
Note: ============================================================================

Process called "calculate_field_offset_simple" takes field_sizes as Integer, field_index as Integer returns Integer:
    Note: Calculate offset assuming no padding (tightly packed)
    Note: This is useful for packed structs or when alignment is 1
    Note: field_sizes: pointer to array of field sizes
    Note: field_index: which field to get offset for

    If field_index is less than or equal to 0:
        Return 0  Note: First field or invalid
    End If

    Let total_offset be 0
    Let i be 0

    Note: Sum sizes of all previous fields
    While i is less than field_index:
        Let offset be i multiplied by 8
        Let field_size be memory_get_int64(field_sizes, offset)
        Set total_offset to total_offset plus field_size
        Set i to i plus 1
    End While

    Return total_offset
End Process

Note: ============================================================================
Note: Named Field Offset Lookup
Note: ============================================================================

Process called "find_field_index" takes field_names as Integer, field_count as Integer, target_name as String returns Integer:
    Note: Find index of a named field
    Note: field_names: pointer to array of string pointers
    Note: field_count: number of fields
    Note: target_name: field name to search for
    Note: Returns: field index or -1 if not found

    Let i be 0
    While i is less than field_count:
        Let name_offset be i multiplied by 8
        Let field_name be memory_get_pointer(field_names, name_offset)

        If string_equals(field_name, target_name) is equal to 1:
            Return i
        End If

        Set i to i plus 1
    End While

    Return -1  Note: Field not found
End Process

Process called "calculate_named_field_offset" takes field_names as Integer, field_sizes as Integer, field_alignments as Integer, field_count as Integer, field_name as String returns Integer:
    Note: Calculate offset of a named field
    Note: This is the high-level offsetof interface
    Note: Returns offset in bytes, or -1 if field not found

    Let field_index be find_field_index(field_names, field_count, field_name)

    If field_index is equal to -1:
        Return -1  Note: Field not found
    End If

    Return calculate_field_offset(field_sizes, field_alignments, field_index)
End Process

Note: ============================================================================
Note: Array Element Offset
Note: ============================================================================

Process called "calculate_array_element_offset" takes element_size as Integer, element_index as Integer returns Integer:
    Note: Calculate offset of an array element
    Note: Arrays have no padding between elements (tightly packed)
    Note: offset = element_size * element_index

    Let offset be element_size multiplied by element_index
    Return offset
End Process

Process called "calculate_array_element_offset_with_stride" takes stride as Integer, element_index as Integer returns Integer:
    Note: Calculate offset with custom stride
    Note: Useful for strided arrays or multi-dimensional arrays
    Note: offset = stride * element_index

    Let offset be stride multiplied by element_index
    Return offset
End Process

Note: ============================================================================
Note: Offset Validation
Note: ============================================================================

Process called "is_valid_offset" takes offset as Integer, struct_size as Integer returns Integer:
    Note: Check if offset is within struct bounds
    Note: Returns 1 if valid, 0 if out of bounds

    If offset is less than 0:
        Return 0  Note: Negative offset invalid
    End If

    If offset is greater than or equal to struct_size:
        Return 0  Note: Beyond struct bounds
    End If

    Return 1  Note: Valid offset
End Process

Process called "offset_is_aligned" takes offset as Integer, required_alignment as Integer returns Integer:
    Note: Check if offset meets alignment requirement
    Note: Returns 1 if aligned, 0 if not aligned

    Return is_aligned(offset, required_alignment)
End Process

Note: ============================================================================
Note: Common Offset Calculations
Note: ============================================================================

Process called "offset_of_second_field_int64" returns Integer:
    Note: Common case: offset of second Integer field
    Note: First Integer is 8 bytes at offset 0
    Note: Second Integer starts at offset 8
    Return 8
End Process

Process called "offset_of_third_field_int64" returns Integer:
    Note: Common case: offset of third Integer field
    Note: Two Integers = 16 bytes
    Note: Third Integer starts at offset 16
    Return 16
End Process

Process called "offset_of_second_field_int32" returns Integer:
    Note: Common case: offset of second Int32 field
    Note: First Int32 is 4 bytes at offset 0
    Note: Second Int32 starts at offset 4
    Return 4
End Process
