Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles the offsetof intrinsic for field offset queries.

This file performs the following tasks:
- Process offsetof intrinsic calls and field offset queries
- Handle offset calculation and field offset information retrieval
- Manage offset optimization and offset-aware code generation
- Process offset validation and offset constraint checking

This file is essential because of the following reasons:
- offsetof intrinsic enables compile-time field offset queries and optimization
- Proper offset handling ensures correct memory layout and field access
- Offset intrinsics support low-level programming and memory management

This file consists of the following functions/features/operation types:
- offsetof intrinsic processing and field offset queries
- Offset calculation and field offset information retrieval
- Offset optimization and offset-aware code generation
- Offset validation and offset constraint checking
:End Note

Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/core/alignment_core.runa" as Alignment
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Note: ============================================================================
Note: Field Offset Calculation
Note: ============================================================================

Process called "calculate_field_offset" takes field_sizes as Integer, field_alignments as Integer, field_index as Integer returns Integer:
    Note: Calculate offset of a specific field in a struct
    Note: field_sizes: pointer to array of field sizes (8 bytes each)
    Note: field_alignments: pointer to array of field alignments (8 bytes each)
    Note: field_index: which field to get offset for (0-based)
    Note: Returns: byte offset of the field

    If field_index is less than 0:
        Return 0  Note: Invalid index
    End If

    Let current_offset be 0
    Let i be 0

    Note: Calculate offset by iterating through previous fields
    While i is less than field_index:
        Let offset be i multiplied by 8

        Let field_size be memory get int64 from Memory with field_sizes, offset
        Let field_alignment be memory get int64 from Memory with field_alignments, offset

        Note: Align current offset to field alignment
        Let aligned_offset be align struct field from Alignment with current_offset, field_alignment

        Note: Add field size
        Set current_offset to aligned_offset plus field_size

        Set i to i plus 1
    End While

    Note: Align to target field's alignment
    If field_index is greater than 0:
        Let target_offset be field_index multiplied by 8
        Let target_alignment be memory get int64 from Memory with field_alignments, target_offset
        Set current_offset to align struct field from Alignment with current_offset, target_alignment
    End If

    Return current_offset
End Process

Note: ============================================================================
Note: Simple Field Offset (No Padding)
Note: ============================================================================

Process called "calculate_field_offset_simple" takes field_sizes as Integer, field_index as Integer returns Integer:
    Note: Calculate offset assuming no padding (tightly packed)
    Note: This is useful for packed structs or when alignment is 1
    Note: field_sizes: pointer to array of field sizes
    Note: field_index: which field to get offset for

    If field_index is less than or equal to 0:
        Return 0  Note: First field or invalid
    End If

    Let total_offset be 0
    Let i be 0

    Note: Sum sizes of all previous fields
    While i is less than field_index:
        Let offset be i multiplied by 8
        Let field_size be memory get int64 from Memory with field_sizes, offset
        Set total_offset to total_offset plus field_size
        Set i to i plus 1
    End While

    Return total_offset
End Process

Note: ============================================================================
Note: Named Field Offset Lookup
Note: ============================================================================

Process called "find_field_index" takes field_names as Integer, field_count as Integer, target_name as String returns Integer:
    Note: Find index of a named field
    Note: field_names: pointer to array of string pointers
    Note: field_count: number of fields
    Note: target_name: field name to search for
    Note: Returns: field index or -1 if not found

    Let i be 0
    While i is less than field_count:
        Let name_offset be i multiplied by 8
        Let field_name be memory get pointer from Memory with field_names, name_offset

        If string equals from StringCore with field_name, target_name is equal to 1:
            Return i
        End If

        Set i to i plus 1
    End While

    Return -1  Note: Field not found
End Process

Process called "calculate_named_field_offset" takes field_names as Integer, field_sizes as Integer, field_alignments as Integer, field_count as Integer, field_name as String returns Integer:
    Note: Calculate offset of a named field
    Note: This is the high-level offsetof interface
    Note: Returns offset in bytes, or -1 if field not found

    Let field_index be proc find_field_index with field_names, field_count, field_name

    If field_index is equal to -1:
        Return -1  Note: Field not found
    End If

    Return calculate_field_offset(field_sizes, field_alignments, field_index)
End Process

Note: ============================================================================
Note: Array Element Offset
Note: ============================================================================

Process called "calculate_array_element_offset" takes element_size as Integer, element_index as Integer returns Integer:
    Note: Calculate offset of an array element
    Note: Arrays have no padding between elements (tightly packed)
    Note: offset = element_size * element_index

    Let offset be element_size multiplied by element_index
    Return offset
End Process

Process called "calculate_array_element_offset_with_stride" takes stride as Integer, element_index as Integer returns Integer:
    Note: Calculate offset with custom stride
    Note: Useful for strided arrays or multi-dimensional arrays
    Note: offset = stride * element_index

    Let offset be stride multiplied by element_index
    Return offset
End Process

Note: ============================================================================
Note: Offset Validation
Note: ============================================================================

Process called "is_valid_offset" takes offset as Integer, struct_size as Integer returns Integer:
    Note: Check if offset is within struct bounds
    Note: Returns 1 if valid, 0 if out of bounds

    If offset is less than 0:
        Return 0  Note: Negative offset invalid
    End If

    If offset is greater than or equal to struct_size:
        Return 0  Note: Beyond struct bounds
    End If

    Return 1  Note: Valid offset
End Process

Process called "offset_is_aligned" takes offset as Integer, required_alignment as Integer returns Integer:
    Note: Check if offset meets alignment requirement
    Note: Returns 1 if aligned, 0 if not aligned

    Return is aligned from Alignment with offset, required_alignment
End Process

Note: ============================================================================
Note: Common Offset Calculations
Note: ============================================================================

Process called "offset_of_second_field_int64" returns Integer:
    Note: Common case: offset of second Integer field
    Note: First Integer is 8 bytes at offset 0
    Note: Second Integer starts at offset 8
    Return 8
End Process

Process called "offset_of_third_field_int64" returns Integer:
    Note: Common case: offset of third Integer field
    Note: Two Integers = 16 bytes
    Note: Third Integer starts at offset 16
    Return 16
End Process

Process called "offset_of_second_field_int32" returns Integer:
    Note: Common case: offset of second Int32 field
    Note: First Int32 is 4 bytes at offset 0
    Note: Second Int32 starts at offset 4
    Return 4
End Process

Process called "offset_of_second_field_int16" returns Integer:
    Note: Common case: offset of second Int16 field
    Note: First Int16 is 2 bytes at offset 0
    Note: Second Int16 starts at offset 2
    Return 2
End Process

Process called "offset_of_second_field_int8" returns Integer:
    Note: Common case: offset of second Int8/Byte field
    Note: First Int8 is 1 byte at offset 0
    Note: Second Int8 starts at offset 1
    Return 1
End Process

Process called "offset_of_second_field_int128" returns Integer:
    Note: Common case: offset of second Int128 field
    Note: First Int128 is 16 bytes at offset 0
    Note: Second Int128 starts at offset 16
    Return 16
End Process

Process called "offset_of_third_field_int128" returns Integer:
    Note: Common case: offset of third Int128 field
    Note: Two Int128s = 32 bytes
    Note: Third Int128 starts at offset 32
    Return 32
End Process

Process called "offset_of_second_field_int256" returns Integer:
    Note: Common case: offset of second Int256 field
    Note: First Int256 is 32 bytes at offset 0
    Note: Second Int256 starts at offset 32
    Return 32
End Process

Process called "offset_of_third_field_int256" returns Integer:
    Note: Common case: offset of third Int256 field
    Note: Two Int256s = 64 bytes
    Note: Third Int256 starts at offset 64
    Return 64
End Process

Process called "offset_of_second_field_int512" returns Integer:
    Note: Common case: offset of second Int512 field
    Note: First Int512 is 64 bytes at offset 0
    Note: Second Int512 starts at offset 64
    Return 64
End Process

Process called "offset_of_third_field_int512" returns Integer:
    Note: Common case: offset of third Int512 field
    Note: Two Int512s = 128 bytes
    Note: Third Int512 starts at offset 128
    Return 128
End Process

Process called "offset_of_second_field_float" returns Integer:
    Note: Common case: offset of second Float/Float32 field
    Note: First Float is 4 bytes at offset 0
    Note: Second Float starts at offset 4
    Return 4
End Process

Process called "offset_of_second_field_double" returns Integer:
    Note: Common case: offset of second Double/Float64 field
    Note: First Double is 8 bytes at offset 0
    Note: Second Double starts at offset 8
    Return 8
End Process

Process called "offset_of_second_field_float16" returns Integer:
    Note: Common case: offset of second Float16 field
    Note: First Float16 is 2 bytes at offset 0
    Note: Second Float16 starts at offset 2
    Return 2
End Process

Process called "offset_of_second_field_float80" returns Integer:
    Note: Common case: offset of second Float80 field (x87 extended precision)
    Note: First Float80 is 16 bytes at offset 0 (10 bytes + 6 bytes padding)
    Note: Second Float80 starts at offset 16
    Return 16
End Process

Process called "offset_of_second_field_float128" returns Integer:
    Note: Common case: offset of second Float128 field
    Note: First Float128 is 16 bytes at offset 0
    Note: Second Float128 starts at offset 16
    Return 16
End Process

Process called "offset_of_second_field_pointer" returns Integer:
    Note: Common case: offset of second Pointer field
    Note: First Pointer is 8 bytes at offset 0 (x86_64)
    Note: Second Pointer starts at offset 8
    Return 8
End Process

Process called "offset_of_second_field_boolean" returns Integer:
    Note: Common case: offset of second Boolean field
    Note: First Boolean is 1 byte at offset 0
    Note: Second Boolean starts at offset 1
    Return 1
End Process

Process called "offset_of_second_field_character" returns Integer:
    Note: Common case: offset of second Character field
    Note: First Character is 1 byte at offset 0
    Note: Second Character starts at offset 1
    Return 1
End Process
