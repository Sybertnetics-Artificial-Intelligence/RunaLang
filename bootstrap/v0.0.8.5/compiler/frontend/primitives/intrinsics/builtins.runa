Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
COMPILER INTRINSICS (Runtime Builtins)

This file declares compiler intrinsics - special functions that the compiler
recognizes and replaces with platform-specific machine code during code generation.

Intrinsics enable pure Runa code to perform low-level operations without inline
assembly, making primitives truly platform-agnostic.

Key Points:
- Intrinsics are NOT implemented as normal functions
- The compiler backend emits platform-specific code for each intrinsic
- Zero overhead - intrinsics compile to optimal machine code inline
- Same primitive code works on all platforms (x86_64, ARM64, MIPS, RISC-V, etc.)

Intrinsic Naming Convention:
All intrinsics use the prefix "__builtin_" to distinguish them from regular functions.

Backend Responsibility:
The compiler backend must recognize these function names and emit appropriate
platform-specific machine code instead of generating function calls.

See: INTRINSICS_SPECIFICATION.md for detailed documentation
:End Note

Note: ============================================================================
Note: MEMORY OPERATIONS
Note: ============================================================================

Process called "__builtin_memory_load_byte" takes ptr as Integer, offset as Integer returns Integer:
    Note: Load single byte from memory at ptr + offset
    Note: Backend emits platform-specific load instruction
    Note: x86_64: MOV AL, [ptr + offset] with zero-extend
    Note: ARM64: LDRB Wd, [Xn, Xm]
    Note: COMPILER INTRINSIC - No implementation, backend handles this
    Return 0  Note: Placeholder for type checker
End Process

Process called "__builtin_memory_load_int32" takes ptr as Integer, offset as Integer returns Integer:
    Note: Load 32-bit integer from memory at ptr + offset
    Note: Backend emits platform-specific 32-bit load
    Note: x86_64: MOV EAX, [ptr + offset]
    Note: ARM64: LDR Wd, [Xn, #offset]
    Return 0
End Process

Process called "__builtin_memory_load_int64" takes ptr as Integer, offset as Integer returns Integer:
    Note: Load 64-bit integer from memory at ptr + offset
    Note: Backend emits platform-specific 64-bit load
    Note: x86_64: MOV RAX, [ptr + offset]
    Note: ARM64: LDR Xd, [Xn, #offset]
    Return 0
End Process

Process called "__builtin_memory_store_byte" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Note: Store single byte to memory at ptr + offset
    Note: Backend emits platform-specific store instruction
    Note: x86_64: MOV [ptr + offset], AL
    Note: ARM64: STRB Ws, [Xn, Xm]
    Return 0
End Process

Process called "__builtin_memory_store_int32" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Note: Store 32-bit integer to memory at ptr + offset
    Note: Backend emits platform-specific 32-bit store
    Note: x86_64: MOV [ptr + offset], EAX
    Note: ARM64: STR Wd, [Xn, #offset]
    Return 0
End Process

Process called "__builtin_memory_store_int64" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Note: Store 64-bit integer to memory at ptr + offset
    Note: Backend emits platform-specific 64-bit store
    Note: x86_64: MOV [ptr + offset], RAX
    Note: ARM64: STR Xd, [Xn, #offset]
    Return 0
End Process

Note: ============================================================================
Note: SYSTEM CALL OPERATIONS
Note: ============================================================================

Process called "__builtin_syscall_0" takes syscall_number as Integer returns Integer:
    Note: Invoke system call with 0 arguments
    Note: Backend emits platform-specific syscall instruction
    Note: Linux x86_64: syscall (RAX = syscall_number)
    Note: Linux ARM64: svc #0 (X8 = syscall_number)
    Note: Windows: Calls Win32 API instead
    Return 0
End Process

Process called "__builtin_syscall_1" takes syscall_number as Integer, arg1 as Integer returns Integer:
    Note: Invoke system call with 1 argument
    Note: Linux x86_64: RDI = arg1
    Note: Linux ARM64: X0 = arg1
    Return 0
End Process

Process called "__builtin_syscall_2" takes syscall_number as Integer, arg1 as Integer, arg2 as Integer returns Integer:
    Note: Invoke system call with 2 arguments
    Note: Linux x86_64: RDI = arg1, RSI = arg2
    Note: Linux ARM64: X0 = arg1, X1 = arg2
    Return 0
End Process

Process called "__builtin_syscall_3" takes syscall_number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer returns Integer:
    Note: Invoke system call with 3 arguments
    Note: Linux x86_64: RDI = arg1, RSI = arg2, RDX = arg3
    Note: Linux ARM64: X0 = arg1, X1 = arg2, X2 = arg3
    Return 0
End Process

Process called "__builtin_syscall_4" takes syscall_number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer, arg4 as Integer returns Integer:
    Note: Invoke system call with 4 arguments
    Note: Linux x86_64: RDI = arg1, RSI = arg2, RDX = arg3, R10 = arg4
    Note: Linux ARM64: X0-X3 = args
    Return 0
End Process

Process called "__builtin_syscall_5" takes syscall_number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer, arg4 as Integer, arg5 as Integer returns Integer:
    Note: Invoke system call with 5 arguments
    Note: Linux x86_64: RDI, RSI, RDX, R10, R8
    Note: Linux ARM64: X0-X4
    Return 0
End Process

Process called "__builtin_syscall_6" takes syscall_number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer, arg4 as Integer, arg5 as Integer, arg6 as Integer returns Integer:
    Note: Invoke system call with 6 arguments
    Note: Linux x86_64: RDI, RSI, RDX, R10, R8, R9
    Note: Linux ARM64: X0-X5
    Return 0
End Process

Note: ============================================================================
Note: ATOMIC OPERATIONS
Note: ============================================================================

Process called "__builtin_atomic_load" takes ptr as Integer returns Integer:
    Note: Atomic load from memory
    Note: x86_64: MOV with implied lock semantics on x86
    Note: ARM64: LDAR (load-acquire)
    Return 0
End Process

Process called "__builtin_atomic_store" takes ptr as Integer, value as Integer returns Integer:
    Note: Atomic store to memory
    Note: x86_64: MOV (naturally atomic on x86 for aligned addresses)
    Note: ARM64: STLR (store-release)
    Return 0
End Process

Process called "__builtin_atomic_add" takes ptr as Integer, value as Integer returns Integer:
    Note: Atomic add and return old value
    Note: x86_64: LOCK XADD
    Note: ARM64: LDADD or LDXR/STXR loop
    Return 0
End Process

Process called "__builtin_atomic_compare_exchange" takes ptr as Integer, expected as Integer, desired as Integer returns Integer:
    Note: Atomic compare-and-swap
    Note: x86_64: LOCK CMPXCHG
    Note: ARM64: LDXR/STXR
    Note: Returns 1 if successful, 0 if failed
    Return 0
End Process

Note: ============================================================================
Note: FLOATING POINT OPERATIONS
Note: ============================================================================

Process called "__builtin_float_sqrt" takes value as Float returns Float:
    Note: Square root
    Note: x86_64: SQRTSD
    Note: ARM64: FSQRT
    Return 0.0
End Process

Process called "__builtin_float_abs" takes value as Float returns Float:
    Note: Absolute value
    Note: x86_64: ANDPD (clear sign bit)
    Note: ARM64: FABS
    Return 0.0
End Process

Note: ============================================================================
Note: BIT MANIPULATION OPERATIONS
Note: ============================================================================

Process called "__builtin_count_leading_zeros" takes value as Integer returns Integer:
    Note: Count leading zero bits
    Note: x86_64: LZCNT or BSR
    Note: ARM64: CLZ
    Return 0
End Process

Process called "__builtin_count_trailing_zeros" takes value as Integer returns Integer:
    Note: Count trailing zero bits
    Note: x86_64: TZCNT or BSF
    Note: ARM64: CTZ (or emulate with RBIT + CLZ)
    Return 0
End Process

Process called "__builtin_popcount" takes value as Integer returns Integer:
    Note: Count set bits (population count)
    Note: x86_64: POPCNT
    Note: ARM64: CNT (for vectors) or software fallback
    Return 0
End Process

Note: ============================================================================
Note: OVERFLOW DETECTION
Note: ============================================================================

Process called "__builtin_add_overflow" takes a as Integer, b as Integer, result_ptr as Integer returns Integer:
    Note: Add with overflow detection
    Note: Stores result in result_ptr, returns 1 if overflow occurred, 0 otherwise
    Note: x86_64: ADD + JO (check overflow flag)
    Note: ARM64: ADDS + check overflow condition
    Return 0
End Process

Process called "__builtin_sub_overflow" takes a as Integer, b as Integer, result_ptr as Integer returns Integer:
    Note: Subtract with overflow detection
    Return 0
End Process

Process called "__builtin_mul_overflow" takes a as Integer, b as Integer, result_ptr as Integer returns Integer:
    Note: Multiply with overflow detection
    Note: x86_64: IMUL + JO
    Note: ARM64: SMULH to check high bits
    Return 0
End Process

Note: ============================================================================
Note: USAGE NOTES FOR BACKEND IMPLEMENTERS
Note: ============================================================================
Note:
Note: When the compiler encounters a call to any function starting with "__builtin_",
Note: it must:
Note:
Note: 1. Recognize it as a compiler intrinsic
Note: 2. Skip normal function call codegen
Note: 3. Emit platform-specific inline code instead
Note: 4. Optimize aggressively (these are performance-critical)
Note:
Note: For unsupported intrinsics on a platform:
Note: - Emit compile-time error with helpful message
Note: - Or provide software fallback if possible
Note:
Note: Example backend pseudo-code:
Note:
Note: if function_name.starts_with("__builtin_"):
Note:     handle_intrinsic(function_name, args, target_platform)
Note: else:
Note:     generate_normal_function_call()
Note:
Note: See INTRINSICS_SPECIFICATION.md for complete details
Note: ============================================================================
