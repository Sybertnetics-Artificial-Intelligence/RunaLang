Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
COMPILER INTRINSICS (Runtime Builtins)

This file declares compiler intrinsics - special functions that the compiler
recognizes and replaces with platform-specific machine code during code generation.

Intrinsics enable pure Runa code to perform low-level operations without inline
assembly, making primitives truly platform-agnostic.

Key Points:
- Intrinsics are NOT implemented as normal functions
- The compiler backend emits platform-specific code for each intrinsic
- Zero overhead - intrinsics compile to optimal machine code inline
- Same primitive code works on all platforms (x86_64, ARM64, MIPS, RISC-V, etc.)

Intrinsic Naming Convention:
All intrinsics use the prefix "__builtin_" to distinguish them from regular functions.

Backend Responsibility:
The compiler backend must recognize these function names and emit appropriate
platform-specific machine code instead of generating function calls.

See: INTRINSICS_SPECIFICATION.md for detailed documentation
:End Note

Note: ============================================================================
Note: MEMORY OPERATIONS
Note: ============================================================================

Process called "__builtin_memory_load_byte" takes ptr as Integer, offset as Integer returns Integer:
    Note: Load single byte from memory at ptr + offset
    Note: Backend emits platform-specific load instruction
    Note: x86_64: MOV AL, [ptr + offset] with zero-extend
    Note: ARM64: LDRB Wd, [Xn, Xm]
    Note: COMPILER INTRINSIC - No implementation, backend handles this
    Return 0  Note: Placeholder for type checker
End Process

Process called "__builtin_memory_load_int16" takes ptr as Integer, offset as Integer returns Integer:
    Note: Load 16-bit integer from memory at ptr + offset (sign-extended to 64-bit)
    Note: Backend emits platform-specific 16-bit load
    Note: x86_64: MOVSX RAX, WORD PTR [ptr + offset]
    Note: ARM64: LDRSH Xd, [Xn, #offset]
    Return 0
End Process

Process called "__builtin_memory_load_int32" takes ptr as Integer, offset as Integer returns Integer:
    Note: Load 32-bit integer from memory at ptr + offset
    Note: Backend emits platform-specific 32-bit load
    Note: x86_64: MOV EAX, [ptr + offset]
    Note: ARM64: LDR Wd, [Xn, #offset]
    Return 0
End Process

Process called "__builtin_memory_load_int64" takes ptr as Integer, offset as Integer returns Integer:
    Note: Load 64-bit integer from memory at ptr + offset
    Note: Backend emits platform-specific 64-bit load
    Note: x86_64: MOV RAX, [ptr + offset]
    Note: ARM64: LDR Xd, [Xn, #offset]
    Return 0
End Process

Process called "__builtin_memory_store_byte" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Note: Store single byte to memory at ptr + offset
    Note: Backend emits platform-specific store instruction
    Note: x86_64: MOV [ptr + offset], AL
    Note: ARM64: STRB Ws, [Xn, Xm]
    Return 0
End Process

Process called "__builtin_memory_store_int16" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Note: Store 16-bit integer to memory at ptr + offset
    Note: Backend emits platform-specific 16-bit store
    Note: x86_64: MOV WORD PTR [ptr + offset], AX
    Note: ARM64: STRH Wd, [Xn, #offset]
    Return 0
End Process

Process called "__builtin_memory_store_int32" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Note: Store 32-bit integer to memory at ptr + offset
    Note: Backend emits platform-specific 32-bit store
    Note: x86_64: MOV [ptr + offset], EAX
    Note: ARM64: STR Wd, [Xn, #offset]
    Return 0
End Process

Process called "__builtin_memory_store_int64" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Note: Store 64-bit integer to memory at ptr + offset
    Note: Backend emits platform-specific 64-bit store
    Note: x86_64: MOV [ptr + offset], RAX
    Note: ARM64: STR Xd, [Xn, #offset]
    Return 0
End Process

Process called "__builtin_memory_copy" takes dest as Integer, src as Integer, size as Integer returns Integer:
    Note: Copy memory from src to dest (non-overlapping regions)
    Note: Backend emits optimized memory copy (memcpy semantics)
    Note: x86_64: REP MOVSB or vectorized copy (SSE/AVX)
    Note: ARM64: LDP/STP loop or NEON vectorized copy
    Note: RISC-V: Load/store loop optimized by backend
    Return 0
End Process

Process called "__builtin_memory_move" takes dest as Integer, src as Integer, size as Integer returns Integer:
    Note: Copy memory from src to dest (handles overlapping regions safely)
    Note: Backend emits safe memory move (memmove semantics)
    Note: Checks for overlap and copies in correct direction
    Note: x86_64: REP MOVSB with direction flag handling
    Note: ARM64: Conditional LDP/STP with direction handling
    Return 0
End Process

Process called "__builtin_memory_set" takes ptr as Integer, value as Integer, size as Integer returns Integer:
    Note: Fill memory with byte value (memset semantics)
    Note: Backend emits optimized memory fill
    Note: x86_64: REP STOSB or vectorized fill (SSE/AVX)
    Note: ARM64: STP loop with duplicated value or NEON fill
    Return 0
End Process

Process called "__builtin_memory_compare" takes ptr1 as Integer, ptr2 as Integer, size as Integer returns Integer:
    Note: Compare two memory regions (memcmp semantics)
    Note: Returns 0 if equal, <0 if ptr1 < ptr2, >0 if ptr1 > ptr2
    Note: Backend emits optimized memory comparison
    Note: x86_64: REP CMPSB or vectorized compare
    Note: ARM64: LDP + CMP loop or NEON compare
    Return 0
End Process

Process called "__builtin_memory_fence" returns Integer:
    Note: Full memory fence (mfence/dmb semantics)
    Note: Ensures all prior memory operations complete before subsequent operations
    Note: x86_64: MFENCE
    Note: ARM64: DMB ISH (data memory barrier, inner shareable)
    Note: RISC-V: FENCE
    Return 0
End Process

Process called "__builtin_memory_fence_acquire" returns Integer:
    Note: Acquire memory fence
    Note: Prevents reordering of loads/stores after this point to before
    Note: x86_64: Implied by x86 memory model (no instruction needed)
    Note: ARM64: DMB ISHLD (load-load, load-store barrier)
    Return 0
End Process

Process called "__builtin_memory_fence_release" returns Integer:
    Note: Release memory fence
    Note: Prevents reordering of loads/stores before this point to after
    Note: x86_64: Implied by x86 memory model (no instruction needed)
    Note: ARM64: DMB ISH (store-store, load-store barrier)
    Return 0
End Process

Note: ============================================================================
Note: SYSTEM CALL OPERATIONS
Note: ============================================================================

Process called "__builtin_syscall_0" takes syscall_number as Integer returns Integer:
    Note: Invoke system call with 0 arguments
    Note: Backend emits platform-specific syscall instruction
    Note: Linux x86_64: syscall (RAX = syscall_number)
    Note: Linux ARM64: svc #0 (X8 = syscall_number)
    Note: Windows: Calls Win32 API instead
    Return 0
End Process

Process called "__builtin_syscall_1" takes syscall_number as Integer, arg1 as Integer returns Integer:
    Note: Invoke system call with 1 argument
    Note: Linux x86_64: RDI = arg1
    Note: Linux ARM64: X0 = arg1
    Return 0
End Process

Process called "__builtin_syscall_2" takes syscall_number as Integer, arg1 as Integer, arg2 as Integer returns Integer:
    Note: Invoke system call with 2 arguments
    Note: Linux x86_64: RDI = arg1, RSI = arg2
    Note: Linux ARM64: X0 = arg1, X1 = arg2
    Return 0
End Process

Process called "__builtin_syscall_3" takes syscall_number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer returns Integer:
    Note: Invoke system call with 3 arguments
    Note: Linux x86_64: RDI = arg1, RSI = arg2, RDX = arg3
    Note: Linux ARM64: X0 = arg1, X1 = arg2, X2 = arg3
    Return 0
End Process

Process called "__builtin_syscall_4" takes syscall_number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer, arg4 as Integer returns Integer:
    Note: Invoke system call with 4 arguments
    Note: Linux x86_64: RDI = arg1, RSI = arg2, RDX = arg3, R10 = arg4
    Note: Linux ARM64: X0-X3 = args
    Return 0
End Process

Process called "__builtin_syscall_5" takes syscall_number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer, arg4 as Integer, arg5 as Integer returns Integer:
    Note: Invoke system call with 5 arguments
    Note: Linux x86_64: RDI, RSI, RDX, R10, R8
    Note: Linux ARM64: X0-X4
    Return 0
End Process

Process called "__builtin_syscall_6" takes syscall_number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer, arg4 as Integer, arg5 as Integer, arg6 as Integer returns Integer:
    Note: Invoke system call with 6 arguments
    Note: Linux x86_64: RDI, RSI, RDX, R10, R8, R9
    Note: Linux ARM64: X0-X5
    Return 0
End Process

Note: ============================================================================
Note: ATOMIC OPERATIONS
Note: ============================================================================

Process called "__builtin_atomic_load" takes ptr as Integer returns Integer:
    Note: Atomic load from memory
    Note: x86_64: MOV with implied lock semantics on x86
    Note: ARM64: LDAR (load-acquire)
    Return 0
End Process

Process called "__builtin_atomic_store" takes ptr as Integer, value as Integer returns Integer:
    Note: Atomic store to memory
    Note: x86_64: MOV (naturally atomic on x86 for aligned addresses)
    Note: ARM64: STLR (store-release)
    Return 0
End Process

Process called "__builtin_atomic_add" takes ptr as Integer, value as Integer returns Integer:
    Note: Atomic add and return old value
    Note: x86_64: LOCK XADD
    Note: ARM64: LDADD or LDXR/STXR loop
    Return 0
End Process

Process called "__builtin_atomic_compare_exchange" takes ptr as Integer, expected as Integer, desired as Integer returns Integer:
    Note: Atomic compare-and-swap
    Note: x86_64: LOCK CMPXCHG
    Note: ARM64: LDXR/STXR
    Note: Returns 1 if successful, 0 if failed
    Return 0
End Process

Process called "__builtin_atomic_exchange" takes ptr as Integer, value as Integer returns Integer:
    Note: Atomic exchange (swap) - returns old value
    Note: x86_64: XCHG (implicitly locked)
    Note: ARM64: SWP or LDXR/STXR loop
    Return 0
End Process

Process called "__builtin_atomic_fetch_add" takes ptr as Integer, value as Integer returns Integer:
    Note: Atomically add value to *ptr and return old value
    Note: x86_64: LOCK XADD
    Note: ARM64: LDADD (ARMv8.1+) or LDXR/STXR loop
    Return 0
End Process

Process called "__builtin_atomic_fetch_sub" takes ptr as Integer, value as Integer returns Integer:
    Note: Atomically subtract value from *ptr and return old value
    Note: x86_64: LOCK XADD with negated value
    Note: ARM64: LDXR/STXR loop
    Return 0
End Process

Process called "__builtin_atomic_fetch_and" takes ptr as Integer, value as Integer returns Integer:
    Note: Atomically AND value with *ptr and return old value
    Note: x86_64: LOCK AND (if supported) or LOCK CMPXCHG loop
    Note: ARM64: LDCLR or LDXR/STXR loop
    Return 0
End Process

Process called "__builtin_atomic_fetch_or" takes ptr as Integer, value as Integer returns Integer:
    Note: Atomically OR value with *ptr and return old value
    Note: x86_64: LOCK OR (if supported) or LOCK CMPXCHG loop
    Note: ARM64: LDSET or LDXR/STXR loop
    Return 0
End Process

Process called "__builtin_atomic_fetch_xor" takes ptr as Integer, value as Integer returns Integer:
    Note: Atomically XOR value with *ptr and return old value
    Note: x86_64: LOCK XOR (if supported) or LOCK CMPXCHG loop
    Note: ARM64: LDEOR or LDXR/STXR loop
    Return 0
End Process

Process called "__builtin_atomic_fence" takes ordering as Integer returns Integer:
    Note: Atomic memory fence with specified ordering
    Note: ordering: 0=relaxed, 1=acquire, 2=release, 3=acq_rel, 4=seq_cst
    Note: x86_64: MFENCE (for seq_cst), compiler barrier otherwise
    Note: ARM64: DMB with appropriate ordering (ISHLD/ISH/ISHST)
    Return 0
End Process

Note: ============================================================================
Note: FLOATING POINT OPERATIONS
Note: ============================================================================

Process called "__builtin_float_sqrt" takes value as Float returns Float:
    Note: Square root
    Note: x86_64: SQRTSD
    Note: ARM64: FSQRT
    Return 0.0
End Process

Process called "__builtin_float_abs" takes value as Float returns Float:
    Note: Absolute value
    Note: x86_64: ANDPD (clear sign bit)
    Note: ARM64: FABS
    Return 0.0
End Process

Process called "__builtin_float_add" takes a as Float, b as Float returns Float:
    Note: Floating point addition
    Note: x86_64: ADDSD
    Note: ARM64: FADD
    Return 0.0
End Process

Process called "__builtin_float_sub" takes a as Float, b as Float returns Float:
    Note: Floating point subtraction
    Note: x86_64: SUBSD
    Note: ARM64: FSUB
    Return 0.0
End Process

Process called "__builtin_float_mul" takes a as Float, b as Float returns Float:
    Note: Floating point multiplication
    Note: x86_64: MULSD
    Note: ARM64: FMUL
    Return 0.0
End Process

Process called "__builtin_float_div" takes a as Float, b as Float returns Float:
    Note: Floating point division
    Note: x86_64: DIVSD
    Note: ARM64: FDIV
    Return 0.0
End Process

Process called "__builtin_float_fma" takes a as Float, b as Float, c as Float returns Float:
    Note: Fused multiply-add: (a * b) + c
    Note: Single rounding, more accurate than separate operations
    Note: x86_64: VFMADD213SD (FMA3) or software fallback
    Note: ARM64: FMADD
    Return 0.0
End Process

Process called "__builtin_float_min" takes a as Float, b as Float returns Float:
    Note: Minimum of two floats (IEEE 754 semantics)
    Note: x86_64: MINSD
    Note: ARM64: FMIN
    Return 0.0
End Process

Process called "__builtin_float_max" takes a as Float, b as Float returns Float:
    Note: Maximum of two floats (IEEE 754 semantics)
    Note: x86_64: MAXSD
    Note: ARM64: FMAX
    Return 0.0
End Process

Process called "__builtin_float_ceil" takes value as Float returns Float:
    Note: Round up to nearest integer
    Note: x86_64: ROUNDSD with mode 0b10 (round up)
    Note: ARM64: FRINTP
    Return 0.0
End Process

Process called "__builtin_float_floor" takes value as Float returns Float:
    Note: Round down to nearest integer
    Note: x86_64: ROUNDSD with mode 0b01 (round down)
    Note: ARM64: FRINTM
    Return 0.0
End Process

Process called "__builtin_float_round" takes value as Float returns Float:
    Note: Round to nearest integer (ties to even)
    Note: x86_64: ROUNDSD with mode 0b00 (nearest)
    Note: ARM64: FRINTN
    Return 0.0
End Process

Process called "__builtin_float_trunc" takes value as Float returns Float:
    Note: Round towards zero (truncate)
    Note: x86_64: ROUNDSD with mode 0b11 (truncate)
    Note: ARM64: FRINTZ
    Return 0.0
End Process

Note: ============================================================================
Note: BIT MANIPULATION OPERATIONS
Note: ============================================================================

Process called "__builtin_count_leading_zeros" takes value as Integer returns Integer:
    Note: Count leading zero bits
    Note: x86_64: LZCNT or BSR
    Note: ARM64: CLZ
    Return 0
End Process

Process called "__builtin_count_trailing_zeros" takes value as Integer returns Integer:
    Note: Count trailing zero bits
    Note: x86_64: TZCNT or BSF
    Note: ARM64: CTZ (or emulate with RBIT + CLZ)
    Return 0
End Process

Process called "__builtin_popcount" takes value as Integer returns Integer:
    Note: Count set bits (population count)
    Note: x86_64: POPCNT
    Note: ARM64: CNT (for vectors) or software fallback
    Return 0
End Process

Process called "__builtin_bswap16" takes value as Integer returns Integer:
    Note: Byte swap 16-bit value (reverse byte order)
    Note: Converts between little-endian and big-endian
    Note: x86_64: ROL/ROR or BSWAP with masking
    Note: ARM64: REV16
    Return 0
End Process

Process called "__builtin_bswap32" takes value as Integer returns Integer:
    Note: Byte swap 32-bit value (reverse byte order)
    Note: x86_64: BSWAP EAX
    Note: ARM64: REV32
    Return 0
End Process

Process called "__builtin_bswap64" takes value as Integer returns Integer:
    Note: Byte swap 64-bit value (reverse byte order)
    Note: x86_64: BSWAP RAX
    Note: ARM64: REV
    Return 0
End Process

Process called "__builtin_rotl32" takes value as Integer, shift as Integer returns Integer:
    Note: Rotate left 32-bit (circular left shift)
    Note: x86_64: ROL
    Note: ARM64: ROR with negated shift (or explicit rotate)
    Return 0
End Process

Process called "__builtin_rotr32" takes value as Integer, shift as Integer returns Integer:
    Note: Rotate right 32-bit (circular right shift)
    Note: x86_64: ROR
    Note: ARM64: ROR
    Return 0
End Process

Process called "__builtin_rotl64" takes value as Integer, shift as Integer returns Integer:
    Note: Rotate left 64-bit (circular left shift)
    Note: x86_64: ROL
    Note: ARM64: ROR with negated shift
    Return 0
End Process

Process called "__builtin_rotr64" takes value as Integer, shift as Integer returns Integer:
    Note: Rotate right 64-bit (circular right shift)
    Note: x86_64: ROR
    Note: ARM64: ROR
    Return 0
End Process

Note: ============================================================================
Note: OVERFLOW DETECTION
Note: ============================================================================

Process called "__builtin_add_overflow" takes a as Integer, b as Integer, result_ptr as Integer returns Integer:
    Note: Add with overflow detection
    Note: Stores result in result_ptr, returns 1 if overflow occurred, 0 otherwise
    Note: x86_64: ADD + JO (check overflow flag)
    Note: ARM64: ADDS + check overflow condition
    Return 0
End Process

Process called "__builtin_sub_overflow" takes a as Integer, b as Integer, result_ptr as Integer returns Integer:
    Note: Subtract with overflow detection
    Return 0
End Process

Process called "__builtin_mul_overflow" takes a as Integer, b as Integer, result_ptr as Integer returns Integer:
    Note: Multiply with overflow detection
    Note: x86_64: IMUL + JO
    Note: ARM64: SMULH to check high bits
    Return 0
End Process

Note: ============================================================================
Note: STACK INTROSPECTION
Note: ============================================================================

Process called "__builtin_get_frame_pointer" returns Integer:
    Note: Get current CPU frame pointer register value
    Note: Returns the base address of the current stack frame
    Note: x86_64: Returns RBP register value
    Note: ARM64: Returns X29 register value (frame pointer)
    Note: RISC-V: Returns S0/FP register value
    Note: MIPS: Returns FP/$30 register value
    Note: PowerPC: Returns R31 (if used as frame pointer)
    Note: WASM: Returns 0 (no hardware frame pointer concept)
    Note: COMPILER INTRINSIC - Backend emits platform-specific register read
    Return 0  Note: Placeholder for type checker
End Process

Process called "__builtin_get_return_address" takes frame_ptr as Integer returns Integer:
    Note: Get return address from a stack frame
    Note: Reads the return address stored in the frame at frame_ptr
    Note: Return address location is platform-specific:
    Note: x86_64: [frame_ptr + 8] - stored above saved RBP
    Note: ARM64: [frame_ptr + 8] - stored in frame record
    Note: RISC-V: [frame_ptr + 8] - stored above saved FP
    Note: MIPS: [frame_ptr + 4] or [frame_ptr + 8] depending on ABI
    Note: Backend emits: MOV RAX, [frame_ptr + 8] or equivalent load
    Note: COMPILER INTRINSIC - Backend handles platform-specific offset
    Return 0  Note: Placeholder for type checker
End Process

Process called "__builtin_get_previous_frame" takes frame_ptr as Integer returns Integer:
    Note: Get previous frame pointer from current frame
    Note: Walks back one frame in the call stack
    Note: Previous frame pointer stored at base of current frame:
    Note: x86_64: [frame_ptr + 0] - saved RBP at frame base
    Note: ARM64: [frame_ptr + 0] - saved X29 in frame record
    Note: RISC-V: [frame_ptr + 0] - saved FP at frame base
    Note: MIPS: [frame_ptr + 0] - saved FP
    Note: Returns 0 when reaching bottom of stack (main frame)
    Note: Backend emits: MOV RAX, [frame_ptr] or equivalent load
    Note: COMPILER INTRINSIC - Backend handles platform-specific layout
    Return 0  Note: Placeholder for type checker
End Process

Note: ============================================================================
Note: INDIRECT FUNCTION CALLS (Function Pointers)
Note: ============================================================================

Process called "__builtin_call_indirect_1" takes func_ptr as Integer, arg1 as Integer returns Integer:
    Note: Call function pointer with 1 argument
    Note: func_ptr is address of function to call
    Note: Backend emits indirect call through register
    Note: x86_64: MOV RAX, func_ptr; CALL RAX with arg1 in RDI
    Note: ARM64: MOV X9, func_ptr; BLR X9 with arg1 in X0
    Note: RISC-V: Call through register with arg1 in A0
    Note: COMPILER INTRINSIC - Backend emits EXPR_INDIRECT_CALL
    Return 0  Note: Placeholder for type checker
End Process

Process called "__builtin_call_indirect_2" takes func_ptr as Integer, arg1 as Integer, arg2 as Integer returns Integer:
    Note: Call function pointer with 2 arguments
    Note: func_ptr is address of function to call
    Note: Backend emits indirect call through register
    Note: x86_64: Arguments in RDI, RSI; call through RAX
    Note: ARM64: Arguments in X0, X1; BLR through X9
    Note: RISC-V: Arguments in A0, A1; call through register
    Note: COMPILER INTRINSIC - Backend emits EXPR_INDIRECT_CALL
    Return 0  Note: Placeholder for type checker
End Process

Process called "__builtin_call_indirect_3" takes func_ptr as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer returns Integer:
    Note: Call function pointer with 3 arguments
    Note: Backend emits indirect call with 3 arguments
    Note: x86_64: RDI, RSI, RDX
    Note: ARM64: X0, X1, X2
    Return 0
End Process

Process called "__builtin_call_indirect_4" takes func_ptr as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer, arg4 as Integer returns Integer:
    Note: Call function pointer with 4 arguments
    Note: Backend emits indirect call with 4 arguments
    Note: x86_64: RDI, RSI, RDX, RCX
    Note: ARM64: X0, X1, X2, X3
    Return 0
End Process

Note: ============================================================================
Note: USAGE NOTES FOR BACKEND IMPLEMENTERS
Note: ============================================================================

Note: When the compiler encounters a call to any function starting with "__builtin_",
Note: it must:

Note: 1. Recognize it as a compiler intrinsic
Note: 2. Skip normal function call codegen
Note: 3. Emit platform-specific inline code instead
Note: 4. Optimize aggressively (these are performance-critical)

Note: For unsupported intrinsics on a platform:
Note: - Emit compile-time error with helpful message
Note: - Or provide software fallback if possible

Note: Example backend pseudo-code:

Note: if function_name.starts_with("__builtin_"):
Note:     handle_intrinsic(function_name, args, target_platform)
Note: else:
Note:     generate_normal_function_call()

Note: See INTRINSICS_SPECIFICATION.md for complete details
Note: ============================================================================
