Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles compiler internal types and compiler-specific type operations.

This file performs the following tasks:
- Process compiler internal types and compiler-specific type handling
- Handle compiler type metadata and compiler type information
- Manage compiler type optimization and compiler type processing
- Process compiler type validation and compiler type checking

This file is essential because of the following reasons:
- Compiler internal types are fundamental to compiler operation and type system
- Proper compiler type handling ensures correct compiler operation and type processing
- Compiler types support advanced compiler features and optimizations

This file consists of the following functions/features/operation types:
- Compiler internal type processing and compiler-specific type handling
- Compiler type metadata and compiler type information management
- Compiler type optimization and compiler type processing
- Compiler type validation and compiler type checking

Dependencies:
- Imports core/memory_core.runa for memory operations
:End Note

Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Note: ============================================================================
Note: Type Size and Layout Computation
Note: ============================================================================

Process called "compute_range_size" takes min as Integer, max as Integer returns Integer:
    Note: Compute optimal size in bytes for an integer range
    Note: Returns 1, 2, 4, or 8 bytes

    If min is less than 0:
        Note: Signed range
        If min is greater than or equal to -128:
            If max is less than or equal to 127:
                Return 1
            End If
        End If

        If min is greater than or equal to -32768:
            If max is less than or equal to 32767:
                Return 2
            End If
        End If

        If min is greater than or equal to -2147483648:
            If max is less than or equal to 2147483647:
                Return 4
            End If
        End If

        Return 8
    Otherwise:
        Note: Unsigned range
        If max is less than or equal to 255:
            Return 1
        End If

        If max is less than or equal to 65535:
            Return 2
        End If

        If max is less than or equal to 4294967295:
            Return 4
        End If

        Return 8
    End If
End Process

Process called "compute_range_signedness" takes min as Integer, max as Integer returns Integer:
    Note: Returns 1 if signed, 0 if unsigned

    If min is less than 0:
        Return 1
    End If
    Return 0
End Process

Process called "get_type_size_basic" takes type_id as Integer returns Integer:
    Note: Get size for basic types

    If type_id is equal to 1:
        Return 8  Note: TYPE_INTEGER
    End If

    If type_id is equal to 2:
        Return 8  Note: TYPE_POINTER
    End If

    If type_id is equal to 3:
        Return 8  Note: TYPE_STRING
    End If

    If type_id is equal to 10:
        Return 1  Note: TYPE_INTEGER8
    End If

    If type_id is equal to 11:
        Return 2  Note: TYPE_INTEGER16
    End If

    If type_id is equal to 12:
        Return 4  Note: TYPE_INTEGER32
    End If

    If type_id is equal to 20:
        Return 4  Note: TYPE_FLOAT
    End If

    If type_id is equal to 21:
        Return 8  Note: TYPE_FLOAT64
    End If

    If type_id is equal to 13:
        Return 16  Note: TYPE_INTEGER128
    End If

    If type_id is equal to 14:
        Return 16  Note: TYPE_UINTEGER128
    End If

    If type_id is equal to 15:
        Return 32  Note: TYPE_INTEGER256
    End If

    If type_id is equal to 16:
        Return 32  Note: TYPE_UINTEGER256
    End If

    If type_id is equal to 17:
        Return 64  Note: TYPE_INTEGER512
    End If

    If type_id is equal to 18:
        Return 64  Note: TYPE_UINTEGER512
    End If

    If type_id is equal to 19:
        Return 1  Note: TYPE_UINTEGER8
    End If

    If type_id is equal to 22:
        Return 2  Note: TYPE_UINTEGER16
    End If

    If type_id is equal to 23:
        Return 4  Note: TYPE_UINTEGER32
    End If

    If type_id is equal to 24:
        Return 8  Note: TYPE_UINTEGER64
    End If

    If type_id is equal to 25:
        Return 2  Note: TYPE_FLOAT16
    End If

    If type_id is equal to 26:
        Return 4  Note: TYPE_FLOAT32 (same as TYPE_FLOAT)
    End If

    If type_id is equal to 27:
        Return 10  Note: TYPE_FLOAT80 (x87 extended precision, 80 bits = 10 bytes)
    End If

    If type_id is equal to 28:
        Return 16  Note: TYPE_FLOAT128
    End If

    If type_id is equal to 40:
        Return 8  Note: TYPE_DECIMAL64
    End If

    If type_id is equal to 41:
        Return 16  Note: TYPE_DECIMAL128
    End If

    Return 8
End Process

Process called "get_type_alignment_basic" takes type_id as Integer returns Integer:
    Let size be proc get_type_size_basic with type_id
    Return size
End Process

Process called "compute_aligned_offset" takes offset as Integer, alignment as Integer returns Integer:
    Let remainder be offset modulo by alignment
    If remainder is equal to 0:
        Return offset
    End If

    Let padding be alignment minus remainder
    Return offset plus padding
End Process

Process called "compute_variable_offsets" takes var_sizes as Integer, var_aligns as Integer, var_count as Integer, output_offsets as Integer returns Integer:
    Let current_offset be 0
    Let i be 0

    While i is less than var_count:
        Let size be proc memory_get_int64 from Memory with var_sizes, i multiplied by 8
        Let align be proc memory_get_int64 from Memory with var_aligns, i multiplied by 8

        Set current_offset to proc compute_aligned_offset with current_offset, align
        proc memory_set_int64 from Memory with output_offsets, i multiplied by 8, current_offset
        Set current_offset to current_offset plus size

        Set i to i plus 1
    End While

    Set current_offset to proc compute_aligned_offset with current_offset, 16
    Return current_offset
End Process

Let TYPE_INTEGER be 1
Let TYPE_POINTER be 2
Let TYPE_STRING be 3
Let TYPE_INTEGER8 be 10
Let TYPE_INTEGER16 be 11
Let TYPE_INTEGER32 be 12
Let TYPE_INTEGER128 be 13
Let TYPE_UINTEGER128 be 14
Let TYPE_INTEGER256 be 15
Let TYPE_UINTEGER256 be 16
Let TYPE_INTEGER512 be 17
Let TYPE_UINTEGER512 be 18
Let TYPE_UINTEGER8 be 19
Let TYPE_UINTEGER16 be 22
Let TYPE_UINTEGER32 be 23
Let TYPE_UINTEGER64 be 24
Let TYPE_FLOAT be 20
Let TYPE_FLOAT64 be 21
Let TYPE_FLOAT16 be 25
Let TYPE_FLOAT32 be 26
Let TYPE_FLOAT80 be 27
Let TYPE_FLOAT128 be 28
Let TYPE_DECIMAL64 be 40
Let TYPE_DECIMAL128 be 41
Let TYPE_RANGED_INTEGER be 30

Note: ============================================================================
Note: 128-bit Integer Support
Note: ============================================================================

Note: Integer128 and UInteger128 provide extended precision arithmetic.
Note: Uses two 64-bit integers (high and low words) on x86-64.

Note: Memory layout (16 bytes):
Note:   offset 0: low word (64 bits)
Note:   offset 8: high word (64 bits)

Note: Alignment: 16 bytes (for optimal SIMD performance)

Note: Use cases:
Note: - Cryptography (256-bit operations using pairs of 128-bit values)
Note: - High-precision timestamps (nanosecond Unix time + counter)
Note: - Large integer math (factorial, combinatorics)
Note: - Financial calculations (high-precision decimal)

Note: ============================================================================

Note: ============================================================================
Note: 128-bit Arithmetic Operations
Note: ============================================================================
Note: These operations work on 128-bit integers stored as two 64-bit words.
Note: Parameters and return values use memory pointers to 16-byte buffers.
Note: Layout: [low 64 bits][high 64 bits]

Process called "int128_add" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Add two 128-bit integers: result = a + b
    Note: Each parameter points to a 16-byte buffer

    Let a_low be proc memory_get_int64 from Memory with a_ptr, 0
    Let a_high be proc memory_get_int64 from Memory with a_ptr, 8
    Let b_low be proc memory_get_int64 from Memory with b_ptr, 0
    Let b_high be proc memory_get_int64 from Memory with b_ptr, 8

    Note: Add low words
    Let result_low be a_low plus b_low

    Note: Detect carry (unsigned overflow)
    Let carry be 0
    If result_low is less than a_low:
        Set carry to 1
    End If

    Note: Add high words with carry
    Let result_high be a_high plus b_high
    Set result_high to result_high plus carry

    proc memory_set_int64 from Memory with result_ptr, 0, result_low
    proc memory_set_int64 from Memory with result_ptr, 8, result_high
End Process

Process called "int128_subtract" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Subtract two 128-bit integers: result = a - b

    Let a_low be proc memory_get_int64 from Memory with a_ptr, 0
    Let a_high be proc memory_get_int64 from Memory with a_ptr, 8
    Let b_low be proc memory_get_int64 from Memory with b_ptr, 0
    Let b_high be proc memory_get_int64 from Memory with b_ptr, 8

    Note: Subtract low words
    Let result_low be a_low minus b_low

    Note: Detect borrow (underflow)
    Let borrow be 0
    If a_low is less than b_low:
        Set borrow to 1
    End If

    Note: Subtract high words with borrow
    Let result_high be a_high minus b_high
    Set result_high to result_high minus borrow

    proc memory_set_int64 from Memory with result_ptr, 0, result_low
    proc memory_set_int64 from Memory with result_ptr, 8, result_high
End Process

Process called "int128_compare" takes a_ptr as Integer, b_ptr as Integer returns Integer:
    Note: Compare two 128-bit integers
    Note: Returns: -1 if a < b, 0 if a == b, 1 if a > b

    Let a_high be proc memory_get_int64 from Memory with a_ptr, 8
    Let b_high be proc memory_get_int64 from Memory with b_ptr, 8

    Note: Compare high words first (signed comparison)
    If a_high is less than b_high:
        Return -1
    End If
    If a_high is greater than b_high:
        Return 1
    End If

    Note: High words equal, compare low words (unsigned comparison)
    Let a_low be proc memory_get_int64 from Memory with a_ptr, 0
    Let b_low be proc memory_get_int64 from Memory with b_ptr, 0

    If a_low is less than b_low:
        Return -1
    End If
    If a_low is greater than b_low:
        Return 1
    End If

    Return 0
End Process

Process called "int128_is_zero" takes a_ptr as Integer returns Integer:
    Note: Check if 128-bit integer is zero
    Note: Returns 1 if zero, 0 otherwise

    Let a_low be proc memory_get_int64 from Memory with a_ptr, 0
    Let a_high be proc memory_get_int64 from Memory with a_ptr, 8

    If a_low is equal to 0:
        If a_high is equal to 0:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "int128_from_int64" takes value as Integer, result_ptr as Integer:
    Note: Convert 64-bit integer to 128-bit
    Note: Sign-extends the high word

    proc memory_set_int64 from Memory with result_ptr, 0, value

    Note: Sign-extend: if value is negative, high word is -1 (0xFFFFFFFFFFFFFFFF)
    If value is less than 0:
        proc memory_set_int64 from Memory with result_ptr, 8, -1
    Otherwise:
        proc memory_set_int64 from Memory with result_ptr, 8, 0
    End If
End Process

Process called "int128_to_int64" takes a_ptr as Integer returns Integer:
    Note: Convert 128-bit integer to 64-bit (truncates high word)
    Note: WARNING: May lose data if value doesn't fit in 64 bits

    Let result be proc memory_get_int64 from Memory with a_ptr, 0
    Return result
End Process

Note: ============================================================================
Note: 128-bit Multiplication (Production Quality - Platform Independent)
Note: ============================================================================

Process called "mul64x64_to_128" takes a as Integer, b as Integer, result_low_ptr as Integer, result_high_ptr as Integer:
    Note: Multiply two 64-bit integers to produce 128-bit result
    Note: Platform independent - works on all architectures
    Note: This is a helper for 128-bit multiplication
    Note: Algorithm: Split into 32-bit chunks and use multi-precision multiplication

    Note: Split a and b into high and low 32-bit parts
    Let a_low be a bitwise and 0xFFFFFFFF
    Let a_high be a shifted right by 32
    Let b_low be b bitwise and 0xFFFFFFFF
    Let b_high be b shifted right by 32

    Note: Compute partial products (all fit in 64 bits)
    Let low_low be a_low multiplied by b_low
    Let low_high be a_low multiplied by b_high
    Let high_low be a_high multiplied by b_low
    Let high_high be a_high multiplied by b_high

    Note: Assemble 128-bit result
    Note: low_low contributes directly to low 64 bits
    Let result_low be low_low

    Note: low_high and high_low contribute to middle 64 bits (overlapping low and high)
    Let middle1 be low_high bitwise and 0xFFFFFFFF
    Let middle2 be high_low bitwise and 0xFFFFFFFF
    Let middle_sum be middle1 plus middle2

    Note: Add middle sum to result_low (shifted left by 32)
    Let middle_contribution be middle_sum shifted left by 32
    Let new_result_low be result_low plus middle_contribution

    Note: Check for overflow in low word
    Let carry be 0
    If new_result_low is less than result_low:
        Set carry to 1
    End If
    Set result_low to new_result_low

    Note: Compute high word
    Let result_high be high_high
    Set result_high to result_high plus (low_high shifted right by 32)
    Set result_high to result_high plus (high_low shifted right by 32)
    Set result_high to result_high plus (middle_sum shifted right by 32)
    Set result_high to result_high plus carry

    Note: Store results
    Let dummy1 be proc memory_set_int64 from Memory with result_low_ptr, 0, result_low
    Let dummy2 be proc memory_set_int64 from Memory with result_high_ptr, 0, result_high
End Process

Process called "int128_multiply" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, arena as Integer:
    Note: Multiply two 128-bit integers: result = a * b
    Note: Uses optimized 64x64→128 multiplication with pure Runa
    Note: Algorithm: (a_high * 2^64 + a_low) * (b_high * 2^64 + b_low)
    Note: WARNING: Result may overflow (uses only low 128 bits)
    Note: ARCHITECTURE: Uses TIER 2 (Arena) for temporary allocations

    Let a_low be proc memory_get_int64 from Memory with a_ptr, 0
    Let a_high be proc memory_get_int64 from Memory with a_ptr, 8
    Let b_low be proc memory_get_int64 from Memory with b_ptr, 0
    Let b_high be proc memory_get_int64 from Memory with b_ptr, 8

    Note: Allocate temporary storage from arena (TIER 2: Arena for temps)
    Let temp_low be proc arena_allocate with arena, 8
    Let temp_high be proc arena_allocate with arena, 8

    Note: Step 1: a_low * b_low → full 128-bit result
    proc mul64x64_to_128 with a_low, b_low, temp_low, temp_high
    Let result_low be proc memory_get_int64 from Memory with temp_low, 0
    Let result_high be proc memory_get_int64 from Memory with temp_high, 0

    Note: Step 2: a_low * b_high → contributes to high word
    proc mul64x64_to_128 with a_low, b_high, temp_low, temp_high
    Let partial1_low be proc memory_get_int64 from Memory with temp_low, 0
    Set result_high to result_high plus partial1_low

    Note: Step 3: a_high * b_low → contributes to high word
    proc mul64x64_to_128 with a_high, b_low, temp_low, temp_high
    Let partial2_low be proc memory_get_int64 from Memory with temp_low, 0
    Set result_high to result_high plus partial2_low

    Note: Step 4: a_high * b_high → would contribute to bits 128-255 (discarded for 128-bit result)

    Note: No deallocate needed - arena handles bulk free (O(1) cleanup)

    proc memory_set_int64 from Memory with result_ptr, 0, result_low
    proc memory_set_int64 from Memory with result_ptr, 8, result_high
End Process

Note: ============================================================================
Note: 128-bit Division (Binary Long Division Algorithm - Production Quality)
Note: ============================================================================

Process called "int128_count_leading_zeros" takes a_ptr as Integer returns Integer:
    Note: Count leading zero bits in 128-bit integer
    Note: Returns 128 if value is zero
    Note: Used for normalization in division algorithm
    Note: Platform independent - uses binary search algorithm

    Let a_high be proc memory_get_int64 from Memory with a_ptr, 8
    Let a_low be proc memory_get_int64 from Memory with a_ptr, 0

    Note: Check high word first
    If a_high is not equal to 0:
        Note: Count leading zeros in high word using binary search
        Let value be a_high
        Let count be 0

        Note: Binary search for highest set bit
        If (value bitwise and 0xFFFFFFFF00000000) is equal to 0:
            Set count to count plus 32
            Set value to value shifted left by 32
        End If
        If (value bitwise and 0xFFFF000000000000) is equal to 0:
            Set count to count plus 16
            Set value to value shifted left by 16
        End If
        If (value bitwise and 0xFF00000000000000) is equal to 0:
            Set count to count plus 8
            Set value to value shifted left by 8
        End If
        If (value bitwise and 0xF000000000000000) is equal to 0:
            Set count to count plus 4
            Set value to value shifted left by 4
        End If
        If (value bitwise and 0xC000000000000000) is equal to 0:
            Set count to count plus 2
            Set value to value shifted left by 2
        End If
        If (value bitwise and 0x8000000000000000) is equal to 0:
            Set count to count plus 1
        End If

        Return count
    End If

    Note: High word is zero, check low word
    If a_low is not equal to 0:
        Note: Count leading zeros in low word using binary search
        Let value be a_low
        Let count be 64

        Note: Binary search for highest set bit
        If (value bitwise and 0xFFFFFFFF00000000) is equal to 0:
            Set count to count plus 32
            Set value to value shifted left by 32
        End If
        If (value bitwise and 0xFFFF000000000000) is equal to 0:
            Set count to count plus 16
            Set value to value shifted left by 16
        End If
        If (value bitwise and 0xFF00000000000000) is equal to 0:
            Set count to count plus 8
            Set value to value shifted left by 8
        End If
        If (value bitwise and 0xF000000000000000) is equal to 0:
            Set count to count plus 4
            Set value to value shifted left by 4
        End If
        If (value bitwise and 0xC000000000000000) is equal to 0:
            Set count to count plus 2
            Set value to value shifted left by 2
        End If
        If (value bitwise and 0x8000000000000000) is equal to 0:
            Set count to count plus 1
        End If

        Return count
    End If

    Note: Both words are zero
    Return 128
End Process

Process called "int128_divide" takes a_ptr as Integer, b_ptr as Integer, quotient_ptr as Integer, remainder_ptr as Integer, arena as Integer:
    Note: Divide two 128-bit integers: quotient = a / b, remainder = a % b
    Note: Uses binary long division algorithm (same as grade school, but base 2)
    Note: WARNING: Division by zero returns quotient=0, remainder=a
    Note: Time complexity: O(128) iterations worst case
    Note: ARCHITECTURE: Uses TIER 2 (Arena) for temporary allocations

    Note: Check for division by zero
    If proc int128_is_zero with b_ptr is equal to 1:
        proc memory_set_int64 from Memory with quotient_ptr, 0, 0
        proc memory_set_int64 from Memory with quotient_ptr, 8, 0
        proc memory_set_int64 from Memory with remainder_ptr, 0, proc memory_get_int64 from Memory with a_ptr, 0
        proc memory_set_int64 from Memory with remainder_ptr, 8, proc memory_get_int64 from Memory with a_ptr, 8
        Return
    End If

    Note: Fast path: if dividend < divisor, quotient=0, remainder=dividend
    Let cmp be proc int128_compare with a_ptr, b_ptr
    If cmp is less than 0:
        proc memory_set_int64 from Memory with quotient_ptr, 0, 0
        proc memory_set_int64 from Memory with quotient_ptr, 8, 0
        proc memory_set_int64 from Memory with remainder_ptr, 0, proc memory_get_int64 from Memory with a_ptr, 0
        proc memory_set_int64 from Memory with remainder_ptr, 8, proc memory_get_int64 from Memory with a_ptr, 8
        Return
    End If

    Note: Fast path: if dividend == divisor, quotient=1, remainder=0
    If cmp is equal to 0:
        proc memory_set_int64 from Memory with quotient_ptr, 0, 1
        proc memory_set_int64 from Memory with quotient_ptr, 8, 0
        proc memory_set_int64 from Memory with remainder_ptr, 0, 0
        proc memory_set_int64 from Memory with remainder_ptr, 8, 0
        Return
    End If

    Note: Allocate working space from arena (TIER 2: Arena for temps)
    Let quotient_temp be proc arena_allocate with arena, 16
    Let remainder_temp be proc arena_allocate with arena, 16
    Let divisor_temp be proc arena_allocate with arena, 16

    Note: Initialize: quotient = 0, remainder = 0
    proc memory_set_int64 from Memory with quotient_temp, 0, 0
    proc memory_set_int64 from Memory with quotient_temp, 8, 0
    proc memory_set_int64 from Memory with remainder_temp, 0, 0
    proc memory_set_int64 from Memory with remainder_temp, 8, 0

    Note: Copy divisor for normalization
    proc memory_set_int64 from Memory with divisor_temp, 0, proc memory_get_int64 from Memory with b_ptr, 0
    proc memory_set_int64 from Memory with divisor_temp, 8, proc memory_get_int64 from Memory with b_ptr, 8

    Note: Normalize: shift divisor left until MSB aligns with dividend MSB
    Let dividend_clz be proc int128_count_leading_zeros with a_ptr
    Let divisor_clz be proc int128_count_leading_zeros with divisor_temp
    Let shift_amount be divisor_clz minus dividend_clz

    Note: Shift divisor to align with dividend
    If shift_amount is greater than 0:
        proc int128_shift_left with divisor_temp, shift_amount, divisor_temp
    End If

    Note: Binary long division loop
    Let i be shift_amount
    While i is greater than or equal to 0:
        Note: Shift remainder left by 1 bit (multiply by 2)
        proc int128_shift_left with remainder_temp, 1, remainder_temp

        Note: Shift quotient left by 1 bit
        proc int128_shift_left with quotient_temp, 1, quotient_temp

        Note: Bring down next bit from dividend
        Let bit_pos be 127 minus dividend_clz minus i
        Let word_idx be bit_pos divided by 64
        Let bit_offset be bit_pos modulo by 64
        Let word_value be proc memory_get_int64 from Memory with a_ptr, word_idx multiplied by 8
        Let bit_mask be 1 left_shift bit_offset
        Let bit_value be word_value bitwise_and bit_mask

        If bit_value is not equal to 0:
            Note: Set LSB of remainder
            Let rem_low be proc memory_get_int64 from Memory with remainder_temp, 0
            Set rem_low to rem_low bitwise_or 1
            proc memory_set_int64 from Memory with remainder_temp, 0, rem_low
        End If

        Note: If remainder >= divisor, subtract and set quotient bit
        Let rem_cmp be proc int128_compare with remainder_temp, divisor_temp
        If rem_cmp is greater than or equal to 0:
            proc int128_subtract with remainder_temp, divisor_temp, remainder_temp
            Let quot_low be proc memory_get_int64 from Memory with quotient_temp, 0
            Set quot_low to quot_low bitwise_or 1
            proc memory_set_int64 from Memory with quotient_temp, 0, quot_low
        End If

        Note: Shift divisor right by 1 bit for next iteration
        proc int128_shift_right with divisor_temp, 1, divisor_temp

        Set i to i minus 1
    End While

    Note: Copy results
    proc memory_set_int64 from Memory with quotient_ptr, 0, proc memory_get_int64 from Memory with quotient_temp, 0
    proc memory_set_int64 from Memory with quotient_ptr, 8, proc memory_get_int64 from Memory with quotient_temp, 8
    proc memory_set_int64 from Memory with remainder_ptr, 0, proc memory_get_int64 from Memory with remainder_temp, 0
    proc memory_set_int64 from Memory with remainder_ptr, 8, proc memory_get_int64 from Memory with remainder_temp, 8

    Note: No deallocate needed - arena handles bulk free (O(1) cleanup)
End Process

Note: ============================================================================
Note: 128-bit Shift Operations
Note: ============================================================================

Process called "int128_shift_left" takes a_ptr as Integer, shift_amount as Integer, result_ptr as Integer:
    Note: Shift 128-bit integer left by shift_amount bits

    If shift_amount is equal to 0:
        proc memory_set_int64 from Memory with result_ptr, 0, proc memory_get_int64 from Memory with a_ptr, 0
        proc memory_set_int64 from Memory with result_ptr, 8, proc memory_get_int64 from Memory with a_ptr, 8
        Return
    End If

    If shift_amount is greater than or equal to 128:
        proc memory_set_int64 from Memory with result_ptr, 0, 0
        proc memory_set_int64 from Memory with result_ptr, 8, 0
        Return
    End If

    Let a_low be proc memory_get_int64 from Memory with a_ptr, 0
    Let a_high be proc memory_get_int64 from Memory with a_ptr, 8

    If shift_amount is greater than or equal to 64:
        Note: Shift by 64+ moves low word to high word
        Let shift_remainder be shift_amount minus 64
        Let result_high be a_low shifted left by shift_remainder
        proc memory_set_int64 from Memory with result_ptr, 0, 0
        proc memory_set_int64 from Memory with result_ptr, 8, result_high
    Otherwise:
        Note: Shift by <64 bits
        Let result_low be a_low shifted left by shift_amount
        Let overflow_bits be a_low shifted right by 64 minus shift_amount
        Let result_high be a_high shifted left by shift_amount
        Set result_high to result_high plus overflow_bits
        proc memory_set_int64 from Memory with result_ptr, 0, result_low
        proc memory_set_int64 from Memory with result_ptr, 8, result_high
    End If
End Process

Process called "int128_shift_right" takes a_ptr as Integer, shift_amount as Integer, result_ptr as Integer:
    Note: Arithmetic shift right (sign-extends)

    If shift_amount is equal to 0:
        proc memory_set_int64 from Memory with result_ptr, 0, proc memory_get_int64 from Memory with a_ptr, 0
        proc memory_set_int64 from Memory with result_ptr, 8, proc memory_get_int64 from Memory with a_ptr, 8
        Return
    End If

    Let a_low be proc memory_get_int64 from Memory with a_ptr, 0
    Let a_high be proc memory_get_int64 from Memory with a_ptr, 8

    Note: Determine sign bit
    Let sign_extend be 0
    If a_high is less than 0:
        Set sign_extend to -1
    End If

    If shift_amount is greater than or equal to 128:
        proc memory_set_int64 from Memory with result_ptr, 0, sign_extend
        proc memory_set_int64 from Memory with result_ptr, 8, sign_extend
        Return
    End If

    If shift_amount is greater than or equal to 64:
        Let shift_remainder be shift_amount minus 64
        Let result_low be a_high shifted right by shift_remainder
        proc memory_set_int64 from Memory with result_ptr, 0, result_low
        proc memory_set_int64 from Memory with result_ptr, 8, sign_extend
    Otherwise:
        Let result_high be a_high shifted right by shift_amount
        Let underflow_bits be a_high shifted left by 64 minus shift_amount
        Let result_low be a_low shifted right by shift_amount
        Set result_low to result_low plus underflow_bits
        proc memory_set_int64 from Memory with result_ptr, 0, result_low
        proc memory_set_int64 from Memory with result_ptr, 8, result_high
    End If
End Process

Note: ============================================================================
Note: 128-bit Bitwise Operations
Note: ============================================================================

Process called "int128_bitwise_and" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Bitwise AND of two 128-bit integers

    Let a_low be proc memory_get_int64 from Memory with a_ptr, 0
    Let a_high be proc memory_get_int64 from Memory with a_ptr, 8
    Let b_low be proc memory_get_int64 from Memory with b_ptr, 0
    Let b_high be proc memory_get_int64 from Memory with b_ptr, 8

    Let result_low be a_low bitwise and b_low
    Let result_high be a_high bitwise and b_high

    proc memory_set_int64 from Memory with result_ptr, 0, result_low
    proc memory_set_int64 from Memory with result_ptr, 8, result_high
End Process

Process called "int128_bitwise_or" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Bitwise OR of two 128-bit integers

    Let a_low be proc memory_get_int64 from Memory with a_ptr, 0
    Let a_high be proc memory_get_int64 from Memory with a_ptr, 8
    Let b_low be proc memory_get_int64 from Memory with b_ptr, 0
    Let b_high be proc memory_get_int64 from Memory with b_ptr, 8

    Let result_low be a_low bitwise or b_low
    Let result_high be a_high bitwise or b_high

    proc memory_set_int64 from Memory with result_ptr, 0, result_low
    proc memory_set_int64 from Memory with result_ptr, 8, result_high
End Process

Process called "int128_bitwise_xor" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Bitwise XOR of two 128-bit integers

    Let a_low be proc memory_get_int64 from Memory with a_ptr, 0
    Let a_high be proc memory_get_int64 from Memory with a_ptr, 8
    Let b_low be proc memory_get_int64 from Memory with b_ptr, 0
    Let b_high be proc memory_get_int64 from Memory with b_ptr, 8

    Let result_low be a_low bitwise xor b_low
    Let result_high be a_high bitwise xor b_high

    proc memory_set_int64 from Memory with result_ptr, 0, result_low
    proc memory_set_int64 from Memory with result_ptr, 8, result_high
End Process

Process called "int128_bitwise_not" takes a_ptr as Integer, result_ptr as Integer:
    Note: Bitwise NOT of 128-bit integer

    Let a_low be proc memory_get_int64 from Memory with a_ptr, 0
    Let a_high be proc memory_get_int64 from Memory with a_ptr, 8

    Let result_low be bitwise not a_low
    Let result_high be bitwise not a_high

    proc memory_set_int64 from Memory with result_ptr, 0, result_low
    proc memory_set_int64 from Memory with result_ptr, 8, result_high
End Process

Note: ============================================================================
Note: 256-bit Integer Support (FOR BLOCKCHAIN & CRYPTOGRAPHY)
Note: ============================================================================

Note: Integer256 for: SHA-256, ECC (secp256k1, P-256), AES-256, Ethereum
Note: Memory layout (32 bytes): [word0][word1][word2][word3], Alignment: 32 bytes

Process called "int256_add" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Scratch space required: 16 bytes
    proc int128_add with a_ptr, b_ptr, result_ptr
    Let carry be 0
    If proc memory_get_int64 from Memory with result_ptr, 0 is less than proc memory_get_int64 from Memory with a_ptr, 0:
        Set carry to 1
    End If
    proc int128_add with a_ptr plus 16, b_ptr plus 16, result_ptr plus 16
    If carry is equal to 1:
        Let t be scratch_ptr
        proc memory_set_int64 from Memory with t, 0, 1
        proc memory_set_int64 from Memory with t, 8, 0
        proc int128_add with result_ptr plus 16, t, result_ptr plus 16
    End If
End Process

Process called "int256_compare" takes a_ptr as Integer, b_ptr as Integer returns Integer:
    Let i be 3
    While i is greater than or equal to 0:
        Let a be proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
        Let b be proc memory_get_int64 from Memory with b_ptr, i multiplied by 8
        If a is less than b:
            Return -1
        End If
        If a is greater than b:
            Return 1
        End If
        Set i to i minus 1
    End While
    Return 0
End Process

Process called "int256_subtract" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Subtract two 256-bit integers: result = a - b
    Note: Uses 128-bit operations with borrow propagation
    Note: Scratch space required: 16 bytes

    Note: Subtract low 128 bits
    proc int128_subtract with a_ptr, b_ptr, result_ptr

    Note: Detect borrow
    Let borrow be 0
    Let cmp be proc int128_compare with a_ptr, b_ptr
    If cmp is less than 0:
        Set borrow to 1
    End If

    Note: Subtract high 128 bits with borrow
    proc int128_subtract with a_ptr plus 16, b_ptr plus 16, result_ptr plus 16
    If borrow is equal to 1:
        Let t be scratch_ptr
        proc memory_set_int64 from Memory with t, 0, 1
        proc memory_set_int64 from Memory with t, 8, 0
        proc int128_subtract with result_ptr plus 16, t, result_ptr plus 16
    End If
End Process

Process called "int256_multiply" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, arena as Integer:
    Note: Multiply two 256-bit integers: result = a * b
    Note: Uses Karatsuba-style 128x128→256 multiplication
    Note: Essential for Ethereum smart contracts and elliptic curve cryptography
    Note: WARNING: Result may overflow (uses only low 256 bits)
    Note: ARCHITECTURE: Uses TIER 2 (Arena) for temporary allocations

    Note: Allocate temporary buffers from arena
    Let temp1 be proc arena_allocate with arena, 32
    Let temp2 be proc arena_allocate with arena, 32

    Note: Split into 128-bit halves: a = a_high * 2^128 + a_low, b = b_high * 2^128 + b_low
    Note: a * b = a_low*b_low + (a_low*b_high + a_high*b_low)*2^128 + a_high*b_high*2^256
    Note: We only keep low 256 bits, so a_high*b_high*2^256 is discarded

    Note: Step 1: a_low * b_low → result[0..255]
    proc int128_multiply with a_ptr, b_ptr, result_ptr, arena
    proc memory_set_int64 from Memory with result_ptr, 16, 0
    proc memory_set_int64 from Memory with result_ptr, 24, 0

    Note: Step 2: a_low * b_high → contributes to result[128..255]
    proc int128_multiply with a_ptr, b_ptr plus 16, temp1, arena
    proc memory_set_int64 from Memory with temp1, 16, 0
    proc memory_set_int64 from Memory with temp1, 24, 0
    Note: Shift left by 128 bits (move to high half)
    proc memory_set_int64 from Memory with temp2, 0, 0
    proc memory_set_int64 from Memory with temp2, 8, 0
    proc memory_set_int64 from Memory with temp2, 16, proc memory_get_int64 from Memory with temp1, 0
    proc memory_set_int64 from Memory with temp2, 24, proc memory_get_int64 from Memory with temp1, 8
    Let scratch_256_1 be proc arena_allocate with arena, 16
    proc int256_add with result_ptr, temp2, result_ptr, scratch_256_1

    Note: Step 3: a_high * b_low → contributes to result[128..255]
    proc int128_multiply with a_ptr plus 16, b_ptr, temp1, arena
    proc memory_set_int64 from Memory with temp1, 16, 0
    proc memory_set_int64 from Memory with temp1, 24, 0
    Note: Shift left by 128 bits
    proc memory_set_int64 from Memory with temp2, 0, 0
    proc memory_set_int64 from Memory with temp2, 8, 0
    proc memory_set_int64 from Memory with temp2, 16, proc memory_get_int64 from Memory with temp1, 0
    proc memory_set_int64 from Memory with temp2, 24, proc memory_get_int64 from Memory with temp1, 8
    Let scratch_256_2 be proc arena_allocate with arena, 16
    proc int256_add with result_ptr, temp2, result_ptr, scratch_256_2

    Note: Step 4: a_high * b_high → would contribute to bits 256-511 (discarded)

    Note: No deallocate needed - arena handles bulk free (O(1) cleanup)
End Process

Process called "int256_is_zero" takes a_ptr as Integer returns Integer:
    Note: Check if 256-bit integer is zero
    Note: Returns 1 if zero, 0 otherwise

    Let i be 0
    While i is less than 4:
        Let word be proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
        If word is not equal to 0:
            Return 0
        End If
        Set i to i plus 1
    End While
    Return 1
End Process

Process called "int256_count_leading_zeros" takes a_ptr as Integer returns Integer:
    Note: Count leading zero bits in 256-bit integer
    Note: Returns 256 if value is zero
    Note: Used for normalization in division algorithm
    Note: Platform independent - uses binary search algorithm

    Note: Check words from high to low
    Let i be 3
    While i is greater than or equal to 0:
        Let word be proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
        If word is not equal to 0:
            Note: Found non-zero word, count leading zeros using binary search
            Let value be word
            Let count be 0

            Note: Binary search for highest set bit
            If (value bitwise and 0xFFFFFFFF00000000) is equal to 0:
                Set count to count plus 32
                Set value to value shifted left by 32
            End If
            If (value bitwise and 0xFFFF000000000000) is equal to 0:
                Set count to count plus 16
                Set value to value shifted left by 16
            End If
            If (value bitwise and 0xFF00000000000000) is equal to 0:
                Set count to count plus 8
                Set value to value shifted left by 8
            End If
            If (value bitwise and 0xF000000000000000) is equal to 0:
                Set count to count plus 4
                Set value to value shifted left by 4
            End If
            If (value bitwise and 0xC000000000000000) is equal to 0:
                Set count to count plus 2
                Set value to value shifted left by 2
            End If
            If (value bitwise and 0x8000000000000000) is equal to 0:
                Set count to count plus 1
            End If

            Note: Add leading zeros from higher words
            Let word_offset be 3 minus i
            Let additional_zeros be word_offset multiplied by 64
            Return count plus additional_zeros
        End If
        Set i to i minus 1
    End While

    Note: All words are zero
    Return 256
End Process

Process called "int256_divide" takes a_ptr as Integer, b_ptr as Integer, quotient_ptr as Integer, remainder_ptr as Integer, arena as Integer:
    Note: Divide two 256-bit integers using binary long division
    Note: Critical for Ethereum gas calculations and token amounts
    Note: WARNING: Division by zero returns quotient=0, remainder=a
    Note: Time complexity: O(256) iterations worst case
    Note: ARCHITECTURE: Uses TIER 2 (Arena) for temporary allocations

    Note: Check for division by zero
    If proc int256_is_zero with b_ptr is equal to 1:
        proc memory_set_int64 from Memory with quotient_ptr, 0, 0
        proc memory_set_int64 from Memory with quotient_ptr, 8, 0
        proc memory_set_int64 from Memory with quotient_ptr, 16, 0
        proc memory_set_int64 from Memory with quotient_ptr, 24, 0
        Let i be 0
        While i is less than 4:
            proc memory_set_int64 from Memory with remainder_ptr, i multiplied by 8, proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
            Set i to i plus 1
        End While
        Return
    End If

    Note: Fast path: if dividend < divisor, quotient=0, remainder=dividend
    Let cmp be proc int256_compare with a_ptr, b_ptr
    If cmp is less than 0:
        proc memory_set_int64 from Memory with quotient_ptr, 0, 0
        proc memory_set_int64 from Memory with quotient_ptr, 8, 0
        proc memory_set_int64 from Memory with quotient_ptr, 16, 0
        proc memory_set_int64 from Memory with quotient_ptr, 24, 0
        Let i be 0
        While i is less than 4:
            proc memory_set_int64 from Memory with remainder_ptr, i multiplied by 8, proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
            Set i to i plus 1
        End While
        Return
    End If

    Note: Fast path: if dividend == divisor, quotient=1, remainder=0
    If cmp is equal to 0:
        proc memory_set_int64 from Memory with quotient_ptr, 0, 1
        proc memory_set_int64 from Memory with quotient_ptr, 8, 0
        proc memory_set_int64 from Memory with quotient_ptr, 16, 0
        proc memory_set_int64 from Memory with quotient_ptr, 24, 0
        proc memory_set_int64 from Memory with remainder_ptr, 0, 0
        proc memory_set_int64 from Memory with remainder_ptr, 8, 0
        proc memory_set_int64 from Memory with remainder_ptr, 16, 0
        proc memory_set_int64 from Memory with remainder_ptr, 24, 0
        Return
    End If

    Note: Allocate working space from arena (TIER 2: Arena for temps)
    Let quotient_temp be proc arena_allocate with arena, 32
    Let remainder_temp be proc arena_allocate with arena, 32
    Let divisor_temp be proc arena_allocate with arena, 32

    Note: Initialize: quotient = 0, remainder = 0
    Let j be 0
    While j is less than 4:
        proc memory_set_int64 from Memory with quotient_temp, j multiplied by 8, 0
        proc memory_set_int64 from Memory with remainder_temp, j multiplied by 8, 0
        Set j to j plus 1
    End While

    Note: Copy divisor for normalization
    Set j to 0
    While j is less than 4:
        proc memory_set_int64 from Memory with divisor_temp, j multiplied by 8, proc memory_get_int64 from Memory with b_ptr, j multiplied by 8
        Set j to j plus 1
    End While

    Note: Normalize: shift divisor left until MSB aligns with dividend MSB
    Let dividend_clz be proc int256_count_leading_zeros with a_ptr
    Let divisor_clz be proc int256_count_leading_zeros with divisor_temp
    Let shift_amount be divisor_clz minus dividend_clz

    Note: Shift divisor to align with dividend
    If shift_amount is greater than 0:
        proc int256_shift_left with divisor_temp, shift_amount, divisor_temp, arena
    End If

    Note: Binary long division loop
    Let loop_i be shift_amount
    While loop_i is greater than or equal to 0:
        Note: Shift remainder left by 1 bit
        proc int256_shift_left with remainder_temp, 1, remainder_temp, arena

        Note: Shift quotient left by 1 bit
        proc int256_shift_left with quotient_temp, 1, quotient_temp, arena

        Note: Bring down next bit from dividend
        Let bit_pos be 255 minus dividend_clz minus loop_i
        Let word_idx be bit_pos divided by 64
        Let bit_offset be bit_pos modulo by 64
        Let word_value be proc memory_get_int64 from Memory with a_ptr, word_idx multiplied by 8
        Let bit_mask be 1 left_shift bit_offset
        Let bit_value be word_value bitwise_and bit_mask

        If bit_value is not equal to 0:
            Note: Set LSB of remainder
            Let rem_low be proc memory_get_int64 from Memory with remainder_temp, 0
            Set rem_low to rem_low bitwise_or 1
            proc memory_set_int64 from Memory with remainder_temp, 0, rem_low
        End If

        Note: If remainder >= divisor, subtract and set quotient bit
        Let rem_cmp be proc int256_compare with remainder_temp, divisor_temp
        If rem_cmp is greater than or equal to 0:
            Let scratch_sub be proc arena_allocate with arena, 16
            proc int256_subtract with remainder_temp, divisor_temp, remainder_temp, scratch_sub
            Let quot_low be proc memory_get_int64 from Memory with quotient_temp, 0
            Set quot_low to quot_low bitwise_or 1
            proc memory_set_int64 from Memory with quotient_temp, 0, quot_low
        End If

        Note: Shift divisor right by 1 bit for next iteration
        proc int256_shift_right with divisor_temp, 1, divisor_temp, arena

        Set loop_i to loop_i minus 1
    End While

    Note: Copy results
    Set j to 0
    While j is less than 4:
        proc memory_set_int64 from Memory with quotient_ptr, j multiplied by 8, proc memory_get_int64 from Memory with quotient_temp, j multiplied by 8
        proc memory_set_int64 from Memory with remainder_ptr, j multiplied by 8, proc memory_get_int64 from Memory with remainder_temp, j multiplied by 8
        Set j to j plus 1
    End While

    Note: No deallocate needed - arena handles bulk free (O(1) cleanup)
End Process

Process called "int256_shift_left" takes a_ptr as Integer, shift_amount as Integer, result_ptr as Integer, arena as Integer:
    Note: Shift 256-bit integer left by shift_amount bits
    Note: ARCHITECTURE: Uses TIER 2 (Arena) for temporary allocations

    If shift_amount is equal to 0:
        Let i be 0
        While i is less than 4:
            proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
            Set i to i plus 1
        End While
        Return
    End If

    If shift_amount is greater than or equal to 256:
        proc memory_set_int64 from Memory with result_ptr, 0, 0
        proc memory_set_int64 from Memory with result_ptr, 8, 0
        proc memory_set_int64 from Memory with result_ptr, 16, 0
        proc memory_set_int64 from Memory with result_ptr, 24, 0
        Return
    End If

    If shift_amount is greater than or equal to 128:
        Note: Shift by 128+ moves low half to high half
        Let shift_remainder be shift_amount minus 128
        Let temp be proc arena_allocate with arena, 16
        proc memory_set_int64 from Memory with temp, 0, proc memory_get_int64 from Memory with a_ptr, 0
        proc memory_set_int64 from Memory with temp, 8, proc memory_get_int64 from Memory with a_ptr, 8
        proc int128_shift_left with temp, shift_remainder, temp
        proc memory_set_int64 from Memory with result_ptr, 0, 0
        proc memory_set_int64 from Memory with result_ptr, 8, 0
        proc memory_set_int64 from Memory with result_ptr, 16, proc memory_get_int64 from Memory with temp, 0
        proc memory_set_int64 from Memory with result_ptr, 24, proc memory_get_int64 from Memory with temp, 8
    Otherwise:
        Note: Use 128-bit operations
        Let temp_low be proc arena_allocate with arena, 16
        Let temp_high be proc arena_allocate with arena, 16
        proc memory_set_int64 from Memory with temp_low, 0, proc memory_get_int64 from Memory with a_ptr, 0
        proc memory_set_int64 from Memory with temp_low, 8, proc memory_get_int64 from Memory with a_ptr, 8
        proc memory_set_int64 from Memory with temp_high, 0, proc memory_get_int64 from Memory with a_ptr, 16
        proc memory_set_int64 from Memory with temp_high, 8, proc memory_get_int64 from Memory with a_ptr, 24

        proc int128_shift_left with temp_low, shift_amount, temp_low
        proc int128_shift_left with temp_high, shift_amount, temp_high

        Note: Move overflow bits from low to high
        Let temp_overflow be proc arena_allocate with arena, 16
        proc memory_set_int64 from Memory with temp_overflow, 0, proc memory_get_int64 from Memory with a_ptr, 0
        proc memory_set_int64 from Memory with temp_overflow, 8, proc memory_get_int64 from Memory with a_ptr, 8
        Let overflow_shift be 128 minus shift_amount
        proc int128_shift_right with temp_overflow, overflow_shift, temp_overflow

        proc memory_set_int64 from Memory with result_ptr, 0, proc memory_get_int64 from Memory with temp_low, 0
        proc memory_set_int64 from Memory with result_ptr, 8, proc memory_get_int64 from Memory with temp_low, 8
        proc memory_set_int64 from Memory with result_ptr, 16, proc memory_get_int64 from Memory with temp_high, 0 plus proc memory_get_int64 from Memory with temp_overflow, 0
        proc memory_set_int64 from Memory with result_ptr, 24, proc memory_get_int64 from Memory with temp_high, 8 plus proc memory_get_int64 from Memory with temp_overflow, 8

        Note: No deallocate needed - arena handles bulk free (O(1) cleanup)
    End If
End Process

Process called "int256_shift_right" takes a_ptr as Integer, shift_amount as Integer, result_ptr as Integer, arena as Integer:
    Note: Arithmetic shift right (sign-extends)
    Note: ARCHITECTURE: Uses TIER 2 (Arena) for temporary allocations

    If shift_amount is equal to 0:
        Let i be 0
        While i is less than 4:
            proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
            Set i to i plus 1
        End While
        Return
    End If

    Note: Determine sign
    Let sign_extend be 0
    Let a_high be proc memory_get_int64 from Memory with a_ptr, 24
    If a_high is less than 0:
        Set sign_extend to -1
    End If

    If shift_amount is greater than or equal to 256:
        proc memory_set_int64 from Memory with result_ptr, 0, sign_extend
        proc memory_set_int64 from Memory with result_ptr, 8, sign_extend
        proc memory_set_int64 from Memory with result_ptr, 16, sign_extend
        proc memory_set_int64 from Memory with result_ptr, 24, sign_extend
        Return
    End If

    If shift_amount is greater than or equal to 128:
        Let shift_remainder be shift_amount minus 128
        Let temp be proc arena_allocate with arena, 16
        proc memory_set_int64 from Memory with temp, 0, proc memory_get_int64 from Memory with a_ptr, 16
        proc memory_set_int64 from Memory with temp, 8, proc memory_get_int64 from Memory with a_ptr, 24
        proc int128_shift_right with temp, shift_remainder, temp
        proc memory_set_int64 from Memory with result_ptr, 0, proc memory_get_int64 from Memory with temp, 0
        proc memory_set_int64 from Memory with result_ptr, 8, proc memory_get_int64 from Memory with temp, 8
        proc memory_set_int64 from Memory with result_ptr, 16, sign_extend
        proc memory_set_int64 from Memory with result_ptr, 24, sign_extend
    Otherwise:
        Note: Similar to shift left but reversed
        Let temp_low be proc arena_allocate with arena, 16
        Let temp_high be proc arena_allocate with arena, 16
        proc memory_set_int64 from Memory with temp_low, 0, proc memory_get_int64 from Memory with a_ptr, 0
        proc memory_set_int64 from Memory with temp_low, 8, proc memory_get_int64 from Memory with a_ptr, 8
        proc memory_set_int64 from Memory with temp_high, 0, proc memory_get_int64 from Memory with a_ptr, 16
        proc memory_set_int64 from Memory with temp_high, 8, proc memory_get_int64 from Memory with a_ptr, 24

        proc int128_shift_right with temp_low, shift_amount, temp_low
        proc int128_shift_right with temp_high, shift_amount, temp_high

        proc memory_set_int64 from Memory with result_ptr, 0, proc memory_get_int64 from Memory with temp_low, 0
        proc memory_set_int64 from Memory with result_ptr, 8, proc memory_get_int64 from Memory with temp_low, 8
        proc memory_set_int64 from Memory with result_ptr, 16, proc memory_get_int64 from Memory with temp_high, 0
        proc memory_set_int64 from Memory with result_ptr, 24, proc memory_get_int64 from Memory with temp_high, 8

        Note: No deallocate needed - arena handles bulk free (O(1) cleanup)
    End If
End Process

Note: ============================================================================
Note: 256-bit Bitwise Operations
Note: ============================================================================

Process called "int256_bitwise_and" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Bitwise AND of two 256-bit integers
    Note: Essential for Ethereum smart contract bit masking operations

    Let i be 0
    While i is less than 4:
        Let a_word be proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
        Let b_word be proc memory_get_int64 from Memory with b_ptr, i multiplied by 8
        Let result_word be a_word bitwise and b_word
        proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, result_word
        Set i to i plus 1
    End While
End Process

Process called "int256_bitwise_or" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Bitwise OR of two 256-bit integers
    Note: Essential for Ethereum smart contract bit operations

    Let i be 0
    While i is less than 4:
        Let a_word be proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
        Let b_word be proc memory_get_int64 from Memory with b_ptr, i multiplied by 8
        Let result_word be a_word bitwise or b_word
        proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, result_word
        Set i to i plus 1
    End While
End Process

Process called "int256_bitwise_xor" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Bitwise XOR of two 256-bit integers
    Note: Essential for cryptographic operations

    Let i be 0
    While i is less than 4:
        Let a_word be proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
        Let b_word be proc memory_get_int64 from Memory with b_ptr, i multiplied by 8
        Let result_word be a_word bitwise xor b_word
        proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, result_word
        Set i to i plus 1
    End While
End Process

Process called "int256_bitwise_not" takes a_ptr as Integer, result_ptr as Integer:
    Note: Bitwise NOT of 256-bit integer
    Note: One's complement operation

    Let i be 0
    While i is less than 4:
        Let a_word be proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
        Let result_word be bitwise not a_word
        proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, result_word
        Set i to i plus 1
    End While
End Process

Note: ============================================================================
Note: 512-bit Integer Support (FOR ADVANCED CRYPTOGRAPHY)
Note: ============================================================================

Note: Integer512 for: RSA-4096, SHA-512, P-521 curves
Note: Memory layout (64 bytes): [word0]...[word7], Alignment: 64 bytes

Process called "int512_add" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Scratch space required: 48 bytes (32 for temp + 16 for nested int256_add)
    Let scratch_256 be scratch_ptr plus 32
    proc int256_add with a_ptr, b_ptr, result_ptr, scratch_256
    Let carry be 0
    If proc memory_get_int64 from Memory with result_ptr, 0 is less than proc memory_get_int64 from Memory with a_ptr, 0:
        Set carry to 1
    End If
    proc int256_add with a_ptr plus 32, b_ptr plus 32, result_ptr plus 32, scratch_256
    If carry is equal to 1:
        Let t be scratch_ptr
        proc memory_set_int64 from Memory with t, 0, 1
        proc memory_set_int64 from Memory with t, 8, 0
        proc memory_set_int64 from Memory with t, 16, 0
        proc memory_set_int64 from Memory with t, 24, 0
        proc int256_add with result_ptr plus 32, t, result_ptr plus 32, scratch_256
    End If
End Process

Process called "int512_compare" takes a_ptr as Integer, b_ptr as Integer returns Integer:
    Let i be 7
    While i is greater than or equal to 0:
        Let a be proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
        Let b be proc memory_get_int64 from Memory with b_ptr, i multiplied by 8
        If a is less than b:
            Return -1
        End If
        If a is greater than b:
            Return 1
        End If
        Set i to i minus 1
    End While
    Return 0
End Process

Process called "int512_subtract" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Subtract two 512-bit integers: result = a - b
    Note: Uses 256-bit operations with borrow propagation
    Note: Scratch space required: 48 bytes (32 for temp + 16 for nested int256_subtract)

    Let scratch_256 be scratch_ptr plus 32
    proc int256_subtract with a_ptr, b_ptr, result_ptr, scratch_256

    Let borrow be 0
    Let cmp be proc int256_compare with a_ptr, b_ptr
    If cmp is less than 0:
        Set borrow to 1
    End If

    proc int256_subtract with a_ptr plus 32, b_ptr plus 32, result_ptr plus 32, scratch_256
    If borrow is equal to 1:
        Let t be scratch_ptr
        proc memory_set_int64 from Memory with t, 0, 1
        proc memory_set_int64 from Memory with t, 8, 0
        proc memory_set_int64 from Memory with t, 16, 0
        proc memory_set_int64 from Memory with t, 24, 0
        proc int256_subtract with result_ptr plus 32, t, result_ptr plus 32, scratch_256
    End If
End Process

Process called "int512_multiply" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, arena as Integer:
    Note: Multiply two 512-bit integers: result = a * b
    Note: Uses 256x256→512 multiplication for RSA-4096
    Note: WARNING: Result may overflow (uses only low 512 bits)
    Note: ARCHITECTURE: Uses TIER 2 (Arena) for temporary allocations

    Let temp1 be proc arena_allocate with arena, 64
    Let temp2 be proc arena_allocate with arena, 64

    Note: Step 1: a_low * b_low → result[0..511]
    proc int256_multiply with a_ptr, b_ptr, result_ptr, arena
    Let i be 4
    While i is less than 8:
        proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, 0
        Set i to i plus 1
    End While

    Note: Step 2: a_low * b_high → contributes to result[256..511]
    proc int256_multiply with a_ptr, b_ptr plus 32, temp1, arena
    Set i to 4
    While i is less than 8:
        proc memory_set_int64 from Memory with temp1, i multiplied by 8, 0
        Set i to i plus 1
    End While
    Note: Shift left by 256 bits
    Set i to 0
    While i is less than 4:
        proc memory_set_int64 from Memory with temp2, i multiplied by 8, 0
        Set i to i plus 1
    End While
    Set i to 0
    While i is less than 4:
        proc memory_set_int64 from Memory with temp2, i plus 4 multiplied by 8, proc memory_get_int64 from Memory with temp1, i multiplied by 8
        Set i to i plus 1
    End While
    Let scratch_512_1 be proc arena_allocate with arena, 48
    proc int512_add with result_ptr, temp2, result_ptr, scratch_512_1

    Note: Step 3: a_high * b_low → contributes to result[256..511]
    proc int256_multiply with a_ptr plus 32, b_ptr, temp1, arena
    Set i to 4
    While i is less than 8:
        proc memory_set_int64 from Memory with temp1, i multiplied by 8, 0
        Set i to i plus 1
    End While
    Set i to 0
    While i is less than 4:
        proc memory_set_int64 from Memory with temp2, i multiplied by 8, 0
        Set i to i plus 1
    End While
    Set i to 0
    While i is less than 4:
        proc memory_set_int64 from Memory with temp2, i plus 4 multiplied by 8, proc memory_get_int64 from Memory with temp1, i multiplied by 8
        Set i to i plus 1
    End While
    Let scratch_512_2 be proc arena_allocate with arena, 48
    proc int512_add with result_ptr, temp2, result_ptr, scratch_512_2

    Note: No deallocate needed - arena handles bulk free (O(1) cleanup)
End Process

Process called "int512_is_zero" takes a_ptr as Integer returns Integer:
    Note: Check if 512-bit integer is zero
    Note: Returns 1 if zero, 0 otherwise

    Let i be 0
    While i is less than 8:
        Let word be proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
        If word is not equal to 0:
            Return 0
        End If
        Set i to i plus 1
    End While
    Return 1
End Process

Process called "int512_count_leading_zeros" takes a_ptr as Integer returns Integer:
    Note: Count leading zero bits in 512-bit integer
    Note: Returns 512 if value is zero
    Note: Used for normalization in division algorithm
    Note: Platform independent - uses binary search algorithm

    Note: Check words from high to low
    Let i be 7
    While i is greater than or equal to 0:
        Let word be proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
        If word is not equal to 0:
            Note: Found non-zero word, count leading zeros using binary search
            Let value be word
            Let count be 0

            Note: Binary search for highest set bit
            If (value bitwise and 0xFFFFFFFF00000000) is equal to 0:
                Set count to count plus 32
                Set value to value shifted left by 32
            End If
            If (value bitwise and 0xFFFF000000000000) is equal to 0:
                Set count to count plus 16
                Set value to value shifted left by 16
            End If
            If (value bitwise and 0xFF00000000000000) is equal to 0:
                Set count to count plus 8
                Set value to value shifted left by 8
            End If
            If (value bitwise and 0xF000000000000000) is equal to 0:
                Set count to count plus 4
                Set value to value shifted left by 4
            End If
            If (value bitwise and 0xC000000000000000) is equal to 0:
                Set count to count plus 2
                Set value to value shifted left by 2
            End If
            If (value bitwise and 0x8000000000000000) is equal to 0:
                Set count to count plus 1
            End If

            Note: Add leading zeros from higher words
            Let word_offset be 7 minus i
            Let additional_zeros be word_offset multiplied by 64
            Return count plus additional_zeros
        End If
        Set i to i minus 1
    End While

    Note: All words are zero
    Return 512
End Process

Process called "int512_divide" takes a_ptr as Integer, b_ptr as Integer, quotient_ptr as Integer, remainder_ptr as Integer, arena as Integer:
    Note: Divide two 512-bit integers for RSA-4096 operations
    Note: Uses binary long division algorithm for full 512-bit precision
    Note: WARNING: Division by zero returns quotient=0, remainder=a
    Note: Time complexity: O(512) iterations worst case
    Note: ARCHITECTURE: Uses TIER 2 (Arena) for temporary allocations

    Note: Check for division by zero
    If proc int512_is_zero with b_ptr is equal to 1:
        Let i be 0
        While i is less than 8:
            proc memory_set_int64 from Memory with quotient_ptr, i multiplied by 8, 0
            Set i to i plus 1
        End While
        Set i to 0
        While i is less than 8:
            proc memory_set_int64 from Memory with remainder_ptr, i multiplied by 8, proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
            Set i to i plus 1
        End While
        Return
    End If

    Note: Fast path: if dividend < divisor, quotient=0, remainder=dividend
    Let cmp be proc int512_compare with a_ptr, b_ptr
    If cmp is less than 0:
        Let i be 0
        While i is less than 8:
            proc memory_set_int64 from Memory with quotient_ptr, i multiplied by 8, 0
            Set i to i plus 1
        End While
        Set i to 0
        While i is less than 8:
            proc memory_set_int64 from Memory with remainder_ptr, i multiplied by 8, proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
            Set i to i plus 1
        End While
        Return
    End If

    Note: Fast path: if dividend == divisor, quotient=1, remainder=0
    If cmp is equal to 0:
        proc memory_set_int64 from Memory with quotient_ptr, 0, 1
        Let i be 1
        While i is less than 8:
            proc memory_set_int64 from Memory with quotient_ptr, i multiplied by 8, 0
            Set i to i plus 1
        End While
        Set i to 0
        While i is less than 8:
            proc memory_set_int64 from Memory with remainder_ptr, i multiplied by 8, 0
            Set i to i plus 1
        End While
        Return
    End If

    Note: Allocate working space from arena (TIER 2: Arena for temps)
    Let quotient_temp be proc arena_allocate with arena, 64
    Let remainder_temp be proc arena_allocate with arena, 64
    Let divisor_temp be proc arena_allocate with arena, 64

    Note: Initialize: quotient = 0, remainder = 0
    Let j be 0
    While j is less than 8:
        proc memory_set_int64 from Memory with quotient_temp, j multiplied by 8, 0
        proc memory_set_int64 from Memory with remainder_temp, j multiplied by 8, 0
        Set j to j plus 1
    End While

    Note: Copy divisor for normalization
    Set j to 0
    While j is less than 8:
        proc memory_set_int64 from Memory with divisor_temp, j multiplied by 8, proc memory_get_int64 from Memory with b_ptr, j multiplied by 8
        Set j to j plus 1
    End While

    Note: Normalize: shift divisor left until MSB aligns with dividend MSB
    Let dividend_clz be proc int512_count_leading_zeros with a_ptr
    Let divisor_clz be proc int512_count_leading_zeros with divisor_temp
    Let shift_amount be divisor_clz minus dividend_clz

    Note: Shift divisor to align with dividend
    If shift_amount is greater than 0:
        proc int512_shift_left with divisor_temp, shift_amount, divisor_temp, arena
    End If

    Note: Binary long division loop
    Let loop_i be shift_amount
    While loop_i is greater than or equal to 0:
        Note: Shift remainder left by 1 bit
        proc int512_shift_left with remainder_temp, 1, remainder_temp, arena

        Note: Shift quotient left by 1 bit
        proc int512_shift_left with quotient_temp, 1, quotient_temp, arena

        Note: Bring down next bit from dividend
        Let bit_pos be 511 minus dividend_clz minus loop_i
        Let word_idx be bit_pos divided by 64
        Let bit_offset be bit_pos modulo by 64
        Let word_value be proc memory_get_int64 from Memory with a_ptr, word_idx multiplied by 8
        Let bit_mask be 1 left_shift bit_offset
        Let bit_value be word_value bitwise_and bit_mask

        If bit_value is not equal to 0:
            Note: Set LSB of remainder
            Let rem_low be proc memory_get_int64 from Memory with remainder_temp, 0
            Set rem_low to rem_low bitwise_or 1
            proc memory_set_int64 from Memory with remainder_temp, 0, rem_low
        End If

        Note: If remainder >= divisor, subtract and set quotient bit
        Let rem_cmp be proc int512_compare with remainder_temp, divisor_temp
        If rem_cmp is greater than or equal to 0:
            Let scratch_sub be proc arena_allocate with arena, 48
            proc int512_subtract with remainder_temp, divisor_temp, remainder_temp, scratch_sub
            Let quot_low be proc memory_get_int64 from Memory with quotient_temp, 0
            Set quot_low to quot_low bitwise_or 1
            proc memory_set_int64 from Memory with quotient_temp, 0, quot_low
        End If

        Note: Shift divisor right by 1 bit for next iteration
        proc int512_shift_right with divisor_temp, 1, divisor_temp, arena

        Set loop_i to loop_i minus 1
    End While

    Note: Copy results
    Set j to 0
    While j is less than 8:
        proc memory_set_int64 from Memory with quotient_ptr, j multiplied by 8, proc memory_get_int64 from Memory with quotient_temp, j multiplied by 8
        proc memory_set_int64 from Memory with remainder_ptr, j multiplied by 8, proc memory_get_int64 from Memory with remainder_temp, j multiplied by 8
        Set j to j plus 1
    End While

    Note: No deallocate needed - arena handles bulk free (O(1) cleanup)
End Process

Process called "int512_shift_left" takes a_ptr as Integer, shift_amount as Integer, result_ptr as Integer, arena as Integer:
    Note: Shift 512-bit integer left by shift_amount bits
    Note: ARCHITECTURE: Uses TIER 2 (Arena) for temporary allocations

    If shift_amount is equal to 0:
        Let i be 0
        While i is less than 8:
            proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
            Set i to i plus 1
        End While
        Return
    End If

    If shift_amount is greater than or equal to 512:
        Let i be 0
        While i is less than 8:
            proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, 0
            Set i to i plus 1
        End While
        Return
    End If

    If shift_amount is greater than or equal to 256:
        Let shift_remainder be shift_amount minus 256
        Let temp be proc arena_allocate with arena, 32
        Let i be 0
        While i is less than 4:
            proc memory_set_int64 from Memory with temp, i multiplied by 8, proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
            Set i to i plus 1
        End While
        proc int256_shift_left with temp, shift_remainder, temp, arena
        Set i to 0
        While i is less than 4:
            proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, 0
            Set i to i plus 1
        End While
        Set i to 0
        While i is less than 4:
            proc memory_set_int64 from Memory with result_ptr, i plus 4 multiplied by 8, proc memory_get_int64 from Memory with temp, i multiplied by 8
            Set i to i plus 1
        End While
    Otherwise:
        Let temp_low be proc arena_allocate with arena, 32
        Let temp_high be proc arena_allocate with arena, 32
        Let i be 0
        While i is less than 4:
            proc memory_set_int64 from Memory with temp_low, i multiplied by 8, proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
            proc memory_set_int64 from Memory with temp_high, i multiplied by 8, proc memory_get_int64 from Memory with a_ptr, i plus 4 multiplied by 8
            Set i to i plus 1
        End While

        proc int256_shift_left with temp_low, shift_amount, temp_low, arena
        proc int256_shift_left with temp_high, shift_amount, temp_high, arena

        Set i to 0
        While i is less than 4:
            proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, proc memory_get_int64 from Memory with temp_low, i multiplied by 8
            proc memory_set_int64 from Memory with result_ptr, i plus 4 multiplied by 8, proc memory_get_int64 from Memory with temp_high, i multiplied by 8
            Set i to i plus 1
        End While
    End If
End Process

Process called "int512_shift_right" takes a_ptr as Integer, shift_amount as Integer, result_ptr as Integer, arena as Integer:
    Note: Arithmetic shift right (sign-extends)
    Note: ARCHITECTURE: Uses TIER 2 (Arena) for temporary allocations

    If shift_amount is equal to 0:
        Let i be 0
        While i is less than 8:
            proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
            Set i to i plus 1
        End While
        Return
    End If

    Let sign_extend be 0
    Let a_high be proc memory_get_int64 from Memory with a_ptr, 56
    If a_high is less than 0:
        Set sign_extend to -1
    End If

    If shift_amount is greater than or equal to 512:
        Let i be 0
        While i is less than 8:
            proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, sign_extend
            Set i to i plus 1
        End While
        Return
    End If

    If shift_amount is greater than or equal to 256:
        Let shift_remainder be shift_amount minus 256
        Let temp be proc arena_allocate with arena, 32
        Let i be 0
        While i is less than 4:
            proc memory_set_int64 from Memory with temp, i multiplied by 8, proc memory_get_int64 from Memory with a_ptr, i plus 4 multiplied by 8
            Set i to i plus 1
        End While
        proc int256_shift_right with temp, shift_remainder, temp, arena
        Set i to 0
        While i is less than 4:
            proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, proc memory_get_int64 from Memory with temp, i multiplied by 8
            Set i to i plus 1
        End While
        Set i to 4
        While i is less than 8:
            proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, sign_extend
            Set i to i plus 1
        End While
    Otherwise:
        Let temp_low be proc arena_allocate with arena, 32
        Let temp_high be proc arena_allocate with arena, 32
        Let i be 0
        While i is less than 4:
            proc memory_set_int64 from Memory with temp_low, i multiplied by 8, proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
            proc memory_set_int64 from Memory with temp_high, i multiplied by 8, proc memory_get_int64 from Memory with a_ptr, i plus 4 multiplied by 8
            Set i to i plus 1
        End While

        proc int256_shift_right with temp_low, shift_amount, temp_low, arena
        proc int256_shift_right with temp_high, shift_amount, temp_high, arena

        Set i to 0
        While i is less than 4:
            proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, proc memory_get_int64 from Memory with temp_low, i multiplied by 8
            proc memory_set_int64 from Memory with result_ptr, i plus 4 multiplied by 8, proc memory_get_int64 from Memory with temp_high, i multiplied by 8
            Set i to i plus 1
        End While
    End If
End Process

Note: ============================================================================
Note: 512-bit Bitwise Operations
Note: ============================================================================

Process called "int512_bitwise_and" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Bitwise AND of two 512-bit integers

    Let i be 0
    While i is less than 8:
        Let a_word be proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
        Let b_word be proc memory_get_int64 from Memory with b_ptr, i multiplied by 8
        Let result_word be a_word bitwise and b_word
        proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, result_word
        Set i to i plus 1
    End While
End Process

Process called "int512_bitwise_or" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Bitwise OR of two 512-bit integers

    Let i be 0
    While i is less than 8:
        Let a_word be proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
        Let b_word be proc memory_get_int64 from Memory with b_ptr, i multiplied by 8
        Let result_word be a_word bitwise or b_word
        proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, result_word
        Set i to i plus 1
    End While
End Process

Process called "int512_bitwise_xor" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Bitwise XOR of two 512-bit integers

    Let i be 0
    While i is less than 8:
        Let a_word be proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
        Let b_word be proc memory_get_int64 from Memory with b_ptr, i multiplied by 8
        Let result_word be a_word bitwise xor b_word
        proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, result_word
        Set i to i plus 1
    End While
End Process

Process called "int512_bitwise_not" takes a_ptr as Integer, result_ptr as Integer:
    Note: Bitwise NOT of 512-bit integer

    Let i be 0
    While i is less than 8:
        Let a_word be proc memory_get_int64 from Memory with a_ptr, i multiplied by 8
        Let result_word be bitwise not a_word
        proc memory_set_int64 from Memory with result_ptr, i multiplied by 8, result_word
        Set i to i plus 1
    End While
End Process

Note: ============================================================================
Note: Multi-Precision Conversions
Note: ============================================================================

Process called "int256_from_int128" takes v as Integer, r as Integer:
    proc memory_set_int64 from Memory with r, 0, proc memory_get_int64 from Memory with v, 0
    proc memory_set_int64 from Memory with r, 8, proc memory_get_int64 from Memory with v, 8
    proc memory_set_int64 from Memory with r, 16, 0
    proc memory_set_int64 from Memory with r, 24, 0
End Process

Process called "int256_to_int128" takes v as Integer, r as Integer:
    proc memory_set_int64 from Memory with r, 0, proc memory_get_int64 from Memory with v, 0
    proc memory_set_int64 from Memory with r, 8, proc memory_get_int64 from Memory with v, 8
End Process

Process called "int512_from_int256" takes v as Integer, r as Integer:
    Let i be 0
    While i is less than 4:
        proc memory_set_int64 from Memory with r, i multiplied by 8, proc memory_get_int64 from Memory with v, i multiplied by 8
        Set i to i plus 1
    End While
    While i is less than 8:
        proc memory_set_int64 from Memory with r, i multiplied by 8, 0
        Set i to i plus 1
    End While
End Process

Process called "int512_to_int256" takes v as Integer, r as Integer:
    Let i be 0
    While i is less than 4:
        proc memory_set_int64 from Memory with r, i multiplied by 8, proc memory_get_int64 from Memory with v, i multiplied by 8
        Set i to i plus 1
    End While
End Process
