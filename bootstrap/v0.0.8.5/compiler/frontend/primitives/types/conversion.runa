Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles type conversions and casts.

This file performs the following tasks:
- Convert between integer types (int8, int16, int32, int64, int128, int256, int512)
- Cast between compatible types
- Handle sign extension and zero extension
- Handle truncation for all integer sizes
- Widen integers to larger precision (up to 512-bit)

This file is essential because of the following reasons:
- Enables implicit and explicit type conversions
- Ensures type safety during conversions
- Handles size changes properly (truncation/extension)
- Supports cryptographic and blockchain integer sizes (256/512-bit)

Dependencies:
- types/validation.runa (type compatibility checking)
- core/bitwise_core.runa (for masking/truncation)
- memory/layout.runa (for multi-precision memory access)
:End Note

Import "compiler/frontend/primitives/types/validation.runa" as TypeValidation
Import "compiler/frontend/primitives/core/bitwise_core.runa" as BitwiseCore
Import "compiler/frontend/primitives/memory/layout.runa" as MemoryLayout

Note: ============================================================================
Note: Integer Type Conversions
Note: ============================================================================

Process called "truncate_to_int8" takes value as Integer returns Integer:
    Note: Truncate 64-bit value to 8-bit signed integer
    Note: Returns value in range -128 to 127

    Note: Mask to 8 bits
    Let result be bitwise_and(value, 255)

    Note: Sign extend if negative (bit 7 is set)
    If result is greater than or equal to 128:
        Let result be result minus 256
    End If

    Return result
End Process

Process called "truncate_to_int16" takes value as Integer returns Integer:
    Note: Truncate 64-bit value to 16-bit signed integer
    Note: Returns value in range -32768 to 32767

    Note: Mask to 16 bits
    Let result be bitwise_and(value, 65535)

    Note: Sign extend if negative (bit 15 is set)
    If result is greater than or equal to 32768:
        Let result be result minus 65536
    End If

    Return result
End Process

Process called "truncate_to_int32" takes value as Integer returns Integer:
    Note: Truncate 64-bit value to 32-bit signed integer
    Note: Returns value in range -2147483648 to 2147483647

    Note: Mask to 32 bits
    Let result be bitwise_and(value, 4294967295)

    Note: Sign extend if negative (bit 31 is set)
    If result is greater than or equal to 2147483648:
        Let result be result minus 4294967296
    End If

    Return result
End Process

Process called "truncate_to_int64" takes value_ptr as Integer returns Integer:
    Note: Truncate larger multi-precision value to 64-bit signed integer
    Note: value_ptr points to 128/256/512-bit value (reads low word only)
    Note: Returns value in 64-bit signed range

    Note: For multi-precision values, just return the low 64 bits
    Let result be memory_get_int64(value_ptr, 0)
    Return result
End Process

Process called "truncate_to_int128" takes value_ptr as Integer, result_ptr as Integer:
    Note: Truncate 256/512-bit value to 128-bit signed integer
    Note: value_ptr points to source, result_ptr points to 128-bit destination
    Note: Copies low 128 bits (first two 64-bit words)

    Let low_word be memory_get_int64(value_ptr, 0)
    Let high_word be memory_get_int64(value_ptr, 8)

    memory_set_int64(result_ptr, 0, low_word)
    memory_set_int64(result_ptr, 8, high_word)
End Process

Process called "truncate_to_int256" takes value_ptr as Integer, result_ptr as Integer:
    Note: Truncate 512-bit value to 256-bit signed integer
    Note: value_ptr points to source, result_ptr points to 256-bit destination
    Note: Copies low 256 bits (first four 64-bit words)

    Let word0 be memory_get_int64(value_ptr, 0)
    Let word1 be memory_get_int64(value_ptr, 8)
    Let word2 be memory_get_int64(value_ptr, 16)
    Let word3 be memory_get_int64(value_ptr, 24)

    memory_set_int64(result_ptr, 0, word0)
    memory_set_int64(result_ptr, 8, word1)
    memory_set_int64(result_ptr, 16, word2)
    memory_set_int64(result_ptr, 24, word3)
End Process
Note: ============================================================================
Note: Unsigned Integer Truncation
Note: ============================================================================

Process called "truncate_to_uint8" takes value as Integer returns Integer:
    Note: Truncate 64-bit value to 8-bit unsigned integer
    Note: Returns value in range 0 to 255

    Note: Mask to 8 bits (no sign extension for unsigned)
    Return bitwise_and(value, 255)
End Process

Process called "truncate_to_uint16" takes value as Integer returns Integer:
    Note: Truncate 64-bit value to 16-bit unsigned integer
    Note: Returns value in range 0 to 65535

    Note: Mask to 16 bits
    Return bitwise_and(value, 65535)
End Process

Process called "truncate_to_uint32" takes value as Integer returns Integer:
    Note: Truncate 64-bit value to 32-bit unsigned integer
    Note: Returns value in range 0 to 4294967295

    Note: Mask to 32 bits
    Return bitwise_and(value, 4294967295)
End Process

Process called "truncate_to_uint64" takes value_ptr as Integer returns Integer:
    Note: Truncate larger multi-precision value to 64-bit unsigned integer
    Note: Same as truncate_to_int64 but semantically unsigned

    Let result be memory_get_int64(value_ptr, 0)
    Return result
End Process

Process called "truncate_to_uint128" takes value_ptr as Integer, result_ptr as Integer:
    Note: Truncate 256/512-bit value to 128-bit unsigned integer
    Note: value_ptr points to source, result_ptr points to 128-bit destination
    Note: Copies low 128 bits (first two 64-bit words)

    Let low_word be memory_get_int64(value_ptr, 0)
    Let high_word be memory_get_int64(value_ptr, 8)

    memory_set_int64(result_ptr, 0, low_word)
    memory_set_int64(result_ptr, 8, high_word)
End Process

Process called "truncate_to_uint256" takes value_ptr as Integer, result_ptr as Integer:
    Note: Truncate 512-bit value to 256-bit unsigned integer
    Note: value_ptr points to source, result_ptr points to 256-bit destination
    Note: Copies low 256 bits (first four 64-bit words)

    Let word0 be memory_get_int64(value_ptr, 0)
    Let word1 be memory_get_int64(value_ptr, 8)
    Let word2 be memory_get_int64(value_ptr, 16)
    Let word3 be memory_get_int64(value_ptr, 24)

    memory_set_int64(result_ptr, 0, word0)
    memory_set_int64(result_ptr, 8, word1)
    memory_set_int64(result_ptr, 16, word2)
    memory_set_int64(result_ptr, 24, word3)
End Process

Process called "zero_extend_to_int64" takes value as Integer, bits as Integer returns Integer:
    Note: Zero-extend a value to 64 bits
    Note: bits specifies the source bit width (8, 16, 32)

    If bits is equal to 8:
        Return bitwise_and(value, 255)
    End If

    If bits is equal to 16:
        Return bitwise_and(value, 65535)
    End If

    If bits is equal to 32:
        Return bitwise_and(value, 4294967295)
    End If

    Note: Already 64-bit
    Return value
End Process

Process called "sign_extend_to_int64" takes value as Integer, bits as Integer returns Integer:
    Note: Sign-extend a value to 64 bits
    Note: bits specifies the source bit width (8, 16, 32)

    If bits is equal to 8:
        Return truncate_to_int8(value)
    End If

    If bits is equal to 16:
        Return truncate_to_int16(value)
    End If

    If bits is equal to 32:
        Return truncate_to_int32(value)
    End If

    Note: Already 64-bit
    Return value
End Process

Note: ============================================================================
Note: Multi-Precision Widening (128/256/512-bit)
Note: ============================================================================

Process called "widen_to_int128_signed" takes value as Integer, result_ptr as Integer:
    Note: Sign-extend 64-bit value to 128-bit
    Note: result_ptr points to 128-bit destination (two 64-bit words)

    Note: Store low word
    memory_set_int64(result_ptr, 0, value)

    Note: Sign-extend high word (all 1s if negative, all 0s if positive)
    If value is less than 0:
        memory_set_int64(result_ptr, 8, -1)
    End If
    If value is greater than or equal to 0:
        memory_set_int64(result_ptr, 8, 0)
    End If
End Process

Process called "widen_to_int128_unsigned" takes value as Integer, result_ptr as Integer:
    Note: Zero-extend 64-bit value to 128-bit
    Note: result_ptr points to 128-bit destination (two 64-bit words)

    Note: Store low word
    memory_set_int64(result_ptr, 0, value)

    Note: Zero high word
    memory_set_int64(result_ptr, 8, 0)
End Process

Process called "widen_to_int256_signed" takes value_ptr as Integer, result_ptr as Integer, source_bits as Integer:
    Note: Sign-extend 64/128-bit value to 256-bit
    Note: source_bits = 64 or 128
    Note: result_ptr points to 256-bit destination (four 64-bit words)

    If source_bits is equal to 64:
        Note: Widen from 64-bit
        Let value be memory_get_int64(value_ptr, 0)
        memory_set_int64(result_ptr, 0, value)

        Note: Sign-extend remaining words
        If value is less than 0:
            memory_set_int64(result_ptr, 8, -1)
            memory_set_int64(result_ptr, 16, -1)
            memory_set_int64(result_ptr, 24, -1)
        End If
        If value is greater than or equal to 0:
            memory_set_int64(result_ptr, 8, 0)
            memory_set_int64(result_ptr, 16, 0)
            memory_set_int64(result_ptr, 24, 0)
        End If
    End If

    If source_bits is equal to 128:
        Note: Widen from 128-bit
        Let low_word be memory_get_int64(value_ptr, 0)
        Let high_word be memory_get_int64(value_ptr, 8)

        memory_set_int64(result_ptr, 0, low_word)
        memory_set_int64(result_ptr, 8, high_word)

        Note: Sign-extend remaining words based on sign of high word
        If high_word is less than 0:
            memory_set_int64(result_ptr, 16, -1)
            memory_set_int64(result_ptr, 24, -1)
        End If
        If high_word is greater than or equal to 0:
            memory_set_int64(result_ptr, 16, 0)
            memory_set_int64(result_ptr, 24, 0)
        End If
    End If
End Process

Process called "widen_to_int256_unsigned" takes value_ptr as Integer, result_ptr as Integer, source_bits as Integer:
    Note: Zero-extend 64/128-bit value to 256-bit
    Note: source_bits = 64 or 128
    Note: result_ptr points to 256-bit destination (four 64-bit words)

    If source_bits is equal to 64:
        Note: Widen from 64-bit
        Let value be memory_get_int64(value_ptr, 0)
        memory_set_int64(result_ptr, 0, value)
        memory_set_int64(result_ptr, 8, 0)
        memory_set_int64(result_ptr, 16, 0)
        memory_set_int64(result_ptr, 24, 0)
    End If

    If source_bits is equal to 128:
        Note: Widen from 128-bit
        Let low_word be memory_get_int64(value_ptr, 0)
        Let high_word be memory_get_int64(value_ptr, 8)

        memory_set_int64(result_ptr, 0, low_word)
        memory_set_int64(result_ptr, 8, high_word)
        memory_set_int64(result_ptr, 16, 0)
        memory_set_int64(result_ptr, 24, 0)
    End If
End Process

Process called "widen_to_int512_signed" takes value_ptr as Integer, result_ptr as Integer, source_bits as Integer:
    Note: Sign-extend 64/128/256-bit value to 512-bit
    Note: source_bits = 64, 128, or 256
    Note: result_ptr points to 512-bit destination (eight 64-bit words)

    If source_bits is equal to 64:
        Note: Widen from 64-bit
        Let value be memory_get_int64(value_ptr, 0)
        memory_set_int64(result_ptr, 0, value)

        Note: Sign-extend remaining words
        Let sign_word be 0
        If value is less than 0:
            Set sign_word to -1
        End If

        Let i be 1
        While i is less than 8:
            memory_set_int64(result_ptr, i multiplied by 8, sign_word)
            Set i to i plus 1
        End While
    End If

    If source_bits is equal to 128:
        Note: Widen from 128-bit
        Let low_word be memory_get_int64(value_ptr, 0)
        Let high_word be memory_get_int64(value_ptr, 8)

        memory_set_int64(result_ptr, 0, low_word)
        memory_set_int64(result_ptr, 8, high_word)

        Note: Sign-extend remaining words based on sign of high word
        Let sign_word be 0
        If high_word is less than 0:
            Set sign_word to -1
        End If

        Let i be 2
        While i is less than 8:
            memory_set_int64(result_ptr, i multiplied by 8, sign_word)
            Set i to i plus 1
        End While
    End If

    If source_bits is equal to 256:
        Note: Widen from 256-bit
        Let i be 0
        While i is less than 4:
            Let word be memory_get_int64(value_ptr, i multiplied by 8)
            memory_set_int64(result_ptr, i multiplied by 8, word)
            Set i to i plus 1
        End While

        Note: Sign-extend remaining words based on sign of word 3
        Let sign_word be 0
        Let high_word be memory_get_int64(value_ptr, 24)
        If high_word is less than 0:
            Set sign_word to -1
        End If

        Set i to 4
        While i is less than 8:
            memory_set_int64(result_ptr, i multiplied by 8, sign_word)
            Set i to i plus 1
        End While
    End If
End Process

Process called "widen_to_int512_unsigned" takes value_ptr as Integer, result_ptr as Integer, source_bits as Integer:
    Note: Zero-extend 64/128/256-bit value to 512-bit
    Note: source_bits = 64, 128, or 256
    Note: result_ptr points to 512-bit destination (eight 64-bit words)

    If source_bits is equal to 64:
        Note: Widen from 64-bit
        Let value be memory_get_int64(value_ptr, 0)
        memory_set_int64(result_ptr, 0, value)

        Let i be 1
        While i is less than 8:
            memory_set_int64(result_ptr, i multiplied by 8, 0)
            Set i to i plus 1
        End While
    End If

    If source_bits is equal to 128:
        Note: Widen from 128-bit
        Let low_word be memory_get_int64(value_ptr, 0)
        Let high_word be memory_get_int64(value_ptr, 8)

        memory_set_int64(result_ptr, 0, low_word)
        memory_set_int64(result_ptr, 8, high_word)

        Let i be 2
        While i is less than 8:
            memory_set_int64(result_ptr, i multiplied by 8, 0)
            Set i to i plus 1
        End While
    End If

    If source_bits is equal to 256:
        Note: Widen from 256-bit
        Let i be 0
        While i is less than 4:
            Let word be memory_get_int64(value_ptr, i multiplied by 8)
            memory_set_int64(result_ptr, i multiplied by 8, word)
            Set i to i plus 1
        End While

        Set i to 4
        While i is less than 8:
            memory_set_int64(result_ptr, i multiplied by 8, 0)
            Set i to i plus 1
        End While
    End If
End Process

Note: ============================================================================
Note: Type Casting Functions
Note: ============================================================================

Process called "cast_integer_to_type" takes value as Integer, target_type as Integer returns Integer:
    Note: Cast an integer value to a target integer type
    Note: target_type is type name string ("Integer8", "Integer16", etc.)

    If string_equals(target_type, "Integer8") is equal to 1:
        Return truncate_to_int8(value)
    End If

    If string_equals(target_type, "Integer16") is equal to 1:
        Return truncate_to_int16(value)
    End If

    If string_equals(target_type, "Integer32") is equal to 1:
        Return truncate_to_int32(value)
    End If

    Note: Integer, Integer128, or unknown - return as-is
    Return value
End Process

Process called "can_convert_lossless" takes from_type as Integer, to_type as Integer returns Integer:
    Note: Check if conversion is lossless (no data loss)
    Note: Returns 1 if lossless, 0 if lossy

    Note: Same type is always lossless
    If string_equals(from_type, to_type) is equal to 1:
        Return 1
    End If

    Note: int8 -> int16/int32/int64/int128 is lossless
    If string_equals(from_type, "Integer8") is equal to 1:
        If string_equals(to_type, "Integer16") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "Integer32") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "Integer") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "Integer128") is equal to 1:
            Return 1
        End If
    End If

    Note: int16 -> int32/int64/int128 is lossless
    If string_equals(from_type, "Integer16") is equal to 1:
        If string_equals(to_type, "Integer32") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "Integer") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "Integer128") is equal to 1:
            Return 1
        End If
    End If

    Note: int32 -> int64/int128 is lossless
    If string_equals(from_type, "Integer32") is equal to 1:
        If string_equals(to_type, "Integer") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "Integer128") is equal to 1:
            Return 1
        End If
    End If

    Note: int64 -> int128/int256/int512 is lossless
    If string_equals(from_type, "Integer") is equal to 1:
        If string_equals(to_type, "Integer128") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "Integer256") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "Integer512") is equal to 1:
            Return 1
        End If
    End If

    Note: int128 -> int256/int512 is lossless
    If string_equals(from_type, "Integer128") is equal to 1:
        If string_equals(to_type, "Integer256") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "Integer512") is equal to 1:
            Return 1
        End If
    End If

    Note: int256 -> int512 is lossless
    If string_equals(from_type, "Integer256") is equal to 1:
        If string_equals(to_type, "Integer512") is equal to 1:
            Return 1
        End If
    End If

    Note: Unsigned variants follow same rules
    If string_equals(from_type, "UInteger8") is equal to 1:
        If string_equals(to_type, "UInteger16") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "UInteger32") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "UInteger64") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "UInteger128") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "UInteger256") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "UInteger512") is equal to 1:
            Return 1
        End If
    End If

    If string_equals(from_type, "UInteger16") is equal to 1:
        If string_equals(to_type, "UInteger32") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "UInteger64") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "UInteger128") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "UInteger256") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "UInteger512") is equal to 1:
            Return 1
        End If
    End If

    If string_equals(from_type, "UInteger32") is equal to 1:
        If string_equals(to_type, "UInteger64") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "UInteger128") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "UInteger256") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "UInteger512") is equal to 1:
            Return 1
        End If
    End If

    If string_equals(from_type, "UInteger64") is equal to 1:
        If string_equals(to_type, "UInteger128") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "UInteger256") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "UInteger512") is equal to 1:
            Return 1
        End If
    End If

    If string_equals(from_type, "UInteger128") is equal to 1:
        If string_equals(to_type, "UInteger256") is equal to 1:
            Return 1
        End If
        If string_equals(to_type, "UInteger512") is equal to 1:
            Return 1
        End If
    End If

    If string_equals(from_type, "UInteger256") is equal to 1:
        If string_equals(to_type, "UInteger512") is equal to 1:
            Return 1
        End If
    End If

    Note: Float -> Float64 is lossless
    If string_equals(from_type, "Float") is equal to 1:
        If string_equals(to_type, "Float64") is equal to 1:
            Return 1
        End If
    End If

    Note: All other conversions are lossy
    Return 0
End Process

Note: ============================================================================
Note: Boolean/Integer Conversions
Note: ============================================================================

Process called "integer_to_boolean" takes value as Integer returns Integer:
    Note: Convert integer to boolean (0 -> false, non-zero -> true)

    If value is equal to 0:
        Return 0
    End If
    Return 1
End Process

Process called "boolean_to_integer" takes value as Integer returns Integer:
    Note: Convert boolean to integer (already 0 or 1)
    Return value
End Process

Note: ============================================================================
Note: String Conversion Functions
Note: ============================================================================

Note: Integer to String Conversion
Note: ============================================================================

Process called "integer_to_string" takes value as Integer, base as Integer returns Integer:
    Note: Convert integer to string in given base (2-36)
    Note: Returns pointer to allocated string (caller must free)
    Note: Supports bases 2 (binary), 8 (octal), 10 (decimal), 16 (hex), etc.

    If base is less than 2:
        Return 0
    End If
    If base is greater than 36:
        Return 0
    End If

    Note: Handle zero specially
    If value is equal to 0:
        Let result be allocate(2)
        memory_set_byte(result, 0, 48)
        memory_set_byte(result, 1, 0)
        Return result
    End If

    Note: Handle negative numbers
    Let is_negative be 0
    Let abs_value be value
    If value is less than 0:
        Set is_negative to 1
        Set abs_value to 0 minus value
    End If

    Note: Count digits needed
    Let temp be abs_value
    Let digit_count be 0
    While temp is greater than 0:
        Set temp to temp divided by base
        Set digit_count to digit_count plus 1
    End While

    Note: Allocate: digits + sign + null terminator
    Let total_length be digit_count
    If is_negative is equal to 1:
        Set total_length to total_length plus 1
    End If
    Set total_length to total_length plus 1

    Let result be allocate(total_length)
    If result is equal to 0:
        Return 0
    End If

    Note: Build string backwards
    Let pos be total_length minus 2
    Set temp to abs_value
    While temp is greater than 0:
        Let digit be temp modulo by base
        Let ch be integer_to_digit(digit)
        memory_set_byte(result, pos, ch)
        Set temp to temp divided by base
        Set pos to pos minus 1
    End While

    Note: Add negative sign if needed
    If is_negative is equal to 1:
        memory_set_byte(result, 0, 45)
    End If

    Note: Null terminate
    memory_set_byte(result, total_length minus 1, 0)

    Return result
End Process

Process called "string_to_integer" takes str as Integer, base as Integer returns Integer:
    Note: Parse string to integer in given base
    Note: Supports optional leading minus sign
    Note: Stops at first non-digit character

    If base is less than 2:
        Return 0
    End If
    If base is greater than 36:
        Return 0
    End If

    Let length be string_length(str)
    If length is equal to 0:
        Return 0
    End If

    Let result be 0
    Let pos be 0
    Let is_negative be 0

    Note: Check for negative sign
    Let first_ch be string_char_at(str, 0)
    If first_ch is equal to 45:
        Set is_negative to 1
        Set pos to 1
    End If

    Note: Parse digits
    While pos is less than length:
        Let ch be string_char_at(str, pos)
        Let digit be digit_to_integer(ch)

        Note: Check if valid digit for base
        If digit is less than 0:
            Note: Invalid digit, stop parsing
            Set pos to length
        Otherwise:
            If digit is greater than or equal to base:
                Note: Digit too large for base, stop parsing
                Set pos to length
            Otherwise:
                Set result to result multiplied by base
                Set result to result plus digit
                Set pos to pos plus 1
            End If
        End If
    End While

    Note: Apply sign
    If is_negative is equal to 1:
        Set result to 0 minus result
    End If

    Return result
End Process

Note: ============================================================================
Note: Hex String Conversions (for Cryptography)
Note: ============================================================================

Process called "bytes_to_hex_string" takes bytes_ptr as Integer, length as Integer returns Integer:
    Note: Convert byte array to hex string
    Note: Example: [0xDE, 0xAD, 0xBE, 0xEF] to "DEADBEEF"
    Note: Returns allocated string (caller must free)

    Let result_length be length multiplied by 2
    Set result_length to result_length plus 1
    Let result be allocate(result_length)
    If result is equal to 0:
        Return 0
    End If

    Let i be 0
    While i is less than length:
        Let byte_value be memory_get_byte(bytes_ptr, i)
        
        Note: High nibble
        Let high_nibble be byte_value divided by 16
        Let high_ch be integer_to_hex_digit(high_nibble)
        memory_set_byte(result, i multiplied by 2, high_ch)

        Note: Low nibble
        Let low_nibble be byte_value modulo by 16
        Let low_ch be integer_to_hex_digit(low_nibble)
        memory_set_byte(result, i multiplied by 2 plus 1, low_ch)

        Set i to i plus 1
    End While

    Note: Null terminate
    memory_set_byte(result, result_length minus 1, 0)

    Return result
End Process

Process called "hex_string_to_bytes" takes hex_str as Integer, out_ptr as Integer returns Integer:
    Note: Parse hex string to byte array
    Note: Example: "DEADBEEF" to [0xDE, 0xAD, 0xBE, 0xEF]
    Note: Returns number of bytes written, or -1 on error

    Let hex_length be string_length(hex_str)
    If hex_length modulo by 2 is not equal to 0:
        Note: Hex string must have even length
        Return -1
    End If

    Let byte_count be hex_length divided by 2
    Let i be 0
    While i is less than byte_count:
        Let high_ch be string_char_at(hex_str, i multiplied by 2)
        Let low_ch be string_char_at(hex_str, i multiplied by 2 plus 1)

        Let high_nibble be hex_digit_to_integer(high_ch)
        Let low_nibble be hex_digit_to_integer(low_ch)

        If high_nibble is less than 0:
            Return -1
        End If
        If low_nibble is less than 0:
            Return -1
        End If

        Let byte_value be high_nibble multiplied by 16
        Set byte_value to byte_value plus low_nibble

        memory_set_byte(out_ptr, i, byte_value)
        Set i to i plus 1
    End While

    Return byte_count
End Process

Note: ============================================================================
Note: Float to String Conversion (IEEE 754)
Note: ============================================================================

Process called "float_to_string" takes value_ptr as Integer, precision as Integer returns Integer:
    Note: Convert float64 to string with specified decimal places
    Note: value_ptr points to 8-byte float64 value
    Note: precision specifies number of decimal places (0-15)
    Note: Returns allocated string (caller must free)
    Note: Uses Dragon4-inspired algorithm for accurate binary-to-decimal conversion

    Note: Extract IEEE 754 components
    Let bits be memory_get_int64(value_ptr, 0)
    
    Note: Extract sign bit (bit 63)
    Let sign_bit be bits right_shift 63
    Let is_negative be sign_bit bitwise_and 1

    Note: Extract exponent (bits 52-62, 11 bits)
    Let exponent_bits be bits right_shift 52
    Set exponent_bits to exponent_bits bitwise_and 2047
    
    Note: Extract mantissa (bits 0-51, 52 bits)
    Let mantissa_bits be bits bitwise_and 4503599627370495

    Note: Check for special values
    If exponent_bits is equal to 2047:
        If mantissa_bits is equal to 0:
            Note: Infinity
            If is_negative is equal to 1:
                Let result be allocate(10)
                memory_set_byte(result, 0, 45)
                memory_set_byte(result, 1, 73)
                memory_set_byte(result, 2, 110)
                memory_set_byte(result, 3, 102)
                memory_set_byte(result, 4, 105)
                memory_set_byte(result, 5, 110)
                memory_set_byte(result, 6, 105)
                memory_set_byte(result, 7, 116)
                memory_set_byte(result, 8, 121)
                memory_set_byte(result, 9, 0)
                Return result
            Otherwise:
                Let result be allocate(9)
                memory_set_byte(result, 0, 73)
                memory_set_byte(result, 1, 110)
                memory_set_byte(result, 2, 102)
                memory_set_byte(result, 3, 105)
                memory_set_byte(result, 4, 110)
                memory_set_byte(result, 5, 105)
                memory_set_byte(result, 6, 116)
                memory_set_byte(result, 7, 121)
                memory_set_byte(result, 8, 0)
                Return result
            End If
        Otherwise:
            Note: NaN
            Let result be allocate(4)
            memory_set_byte(result, 0, 78)
            memory_set_byte(result, 1, 97)
            memory_set_byte(result, 2, 78)
            memory_set_byte(result, 3, 0)
            Return result
        End If
    End If

    Note: Check for zero
    If exponent_bits is equal to 0:
        If mantissa_bits is equal to 0:
            Let result be allocate(4)
            memory_set_byte(result, 0, 48)
            memory_set_byte(result, 1, 46)
            memory_set_byte(result, 2, 48)
            memory_set_byte(result, 3, 0)
            Return result
        End If
    End If

    Note: Calculate actual exponent (biased by 1023)
    Let actual_exponent be exponent_bits minus 1023

    Note: Allocate buffer for result (sign + digits + dot + precision + null)
    Let buffer_size be 64
    Let result be allocate(buffer_size)
    If result is equal to 0:
        Return 0
    End If

    Note: Dragon4 algorithm for IEEE 754 binary to decimal conversion
    Note: Value = (-1)^sign * 2^exponent * (1.mantissa)
    Note: Convert to decimal by computing scaled significand

    Note: Get the full 53-bit significand (implicit 1 + 52-bit mantissa)
    Let significand be 4503599627370496
    Set significand to significand plus mantissa_bits

    Note: Adjust exponent for the implicit bit position (2^52)
    Let binary_exponent be actual_exponent minus 52

    Note: Start writing to buffer
    Let pos be 0

    Note: Write sign if negative
    If is_negative is equal to 1:
        memory_set_byte(result, pos, 45)
        Set pos to pos plus 1
    End If

    Note: Convert binary to decimal using power scaling
    Note: We need to compute: significand * 2^binary_exponent in decimal
    Note: Strategy: Scale to fixed-point then extract digits

    Note: For positive exponents, multiply by 2^exp
    Note: For negative exponents, divide by 2^|exp| (multiply by 5^|exp| and shift decimal)

    Let decimal_value be significand
    Let decimal_exponent be 0

    If binary_exponent is greater than or equal to 0:
        Note: Multiply by 2^binary_exponent
        Let shift_count be binary_exponent
        While shift_count is greater than 0:
            Set decimal_value to decimal_value multiplied by 2
            Set shift_count to shift_count minus 1

            Note: Prevent overflow by scaling down
            While decimal_value is greater than 100000000000000:
                Set decimal_value to decimal_value divided by 10
                Set decimal_exponent to decimal_exponent plus 1
            End While
        End While
    Otherwise:
        Note: Divide by 2^|binary_exponent|
        Note: Use multiplication by 5 and decimal shifting
        Let abs_exp be 0 minus binary_exponent
        Let pow5_count be abs_exp

        While pow5_count is greater than 0:
            Set decimal_value to decimal_value multiplied by 5
            Set pow5_count to pow5_count minus 1

            Note: Prevent overflow
            While decimal_value is greater than 100000000000000:
                Set decimal_value to decimal_value divided by 10
                Set decimal_exponent to decimal_exponent plus 1
            End While
        End While

        Note: Account for the 2^|exp| division with decimal shift
        Set decimal_exponent to decimal_exponent minus abs_exp
    End If

    Note: Now decimal_value * 10^decimal_exponent represents our number
    Note: Extract integer and fractional parts

    Note: Adjust decimal point position
    Let integer_part be decimal_value
    Let fractional_part be 0

    Note: Apply decimal exponent shifting
    If decimal_exponent is greater than 0:
        Note: Shift left (multiply by 10^decimal_exponent)
        Let shift_count be decimal_exponent
        While shift_count is greater than 0:
            Set integer_part to integer_part multiplied by 10
            Set shift_count to shift_count minus 1
        End While
    Otherwise:
        If decimal_exponent is less than 0:
            Note: Shift right (need to extract fractional digits)
            Let abs_dec_exp be 0 minus decimal_exponent
            Let power_of_10 be 1

            Let shift_count be abs_dec_exp
            While shift_count is greater than 0:
                Set power_of_10 to power_of_10 multiplied by 10
                Set shift_count to shift_count minus 1
            End While

            Set fractional_part to integer_part modulo by power_of_10
            Set integer_part to integer_part divided by power_of_10
        End If
    End If

    Note: Write integer part
    If integer_part is equal to 0:
        memory_set_byte(result, pos, 48)
        Set pos to pos plus 1
    Otherwise:
        Note: Count digits
        Let temp_int be integer_part
        Let digit_count be 0
        While temp_int is greater than 0:
            Set temp_int to temp_int divided by 10
            Set digit_count to digit_count plus 1
        End While

        Note: Write digits in correct order
        Let digit_pos be pos plus digit_count minus 1
        Set temp_int to integer_part
        While temp_int is greater than 0:
            Let digit be temp_int modulo by 10
            Let ch be digit plus 48
            memory_set_byte(result, digit_pos, ch)
            Set digit_pos to digit_pos minus 1
            Set temp_int to temp_int divided by 10
        End While
        Set pos to pos plus digit_count
    End If

    Note: Write decimal point
    memory_set_byte(result, pos, 46)
    Set pos to pos plus 1

    Note: Write fractional part up to precision
    Let frac_digits be 0
    Let temp_frac be fractional_part

    While frac_digits is less than precision:
        Note: Extract next decimal digit
        Set temp_frac to temp_frac multiplied by 10

        Note: Get power of 10 for current decimal position
        Let current_power be 1
        If decimal_exponent is less than 0:
            Let abs_dec_exp be 0 minus decimal_exponent
            Let shift_count be abs_dec_exp
            While shift_count is greater than 0:
                Set current_power to current_power multiplied by 10
                Set shift_count to shift_count minus 1
            End While
        End If

        Let digit be temp_frac divided by current_power
        Set digit to digit modulo by 10
        Let ch be digit plus 48
        memory_set_byte(result, pos, ch)
        Set pos to pos plus 1

        Set temp_frac to temp_frac modulo by current_power
        Set frac_digits to frac_digits plus 1
    End While

    Note: Null terminate
    memory_set_byte(result, pos, 0)

    Return result
End Process

Process called "string_to_float" takes str as Integer, result_ptr as Integer returns Integer:
    Note: Parse string to float64 (IEEE 754 double precision)
    Note: Supports formats: "3.14", "-2.5", "1.23e-4", "NaN", "Infinity"
    Note: result_ptr points to 8-byte float64 destination
    Note: Returns 1 on success, 0 on failure
    Note: Uses Ryu-like algorithm for accurate decimal-to-binary conversion

    Let length be string_length(str)
    If length is equal to 0:
        Return 0
    End If

    Note: Check for special values
    If string_equals(str, "NaN") is equal to 1:
        Note: Set to NaN (exponent all 1s, mantissa non-zero)
        Let nan_bits be 9221120237041090560
        memory_set_int64(result_ptr, 0, nan_bits)
        Return 1
    End If

    If string_equals(str, "Infinity") is equal to 1:
        Note: Positive infinity (sign=0, exp=2047, mantissa=0)
        Let inf_bits be 9218868437227405312
        memory_set_int64(result_ptr, 0, inf_bits)
        Return 1
    End If

    If string_equals(str, "-Infinity") is equal to 1:
        Note: Negative infinity (sign=1, exp=2047, mantissa=0)
        Let neg_inf_bits be -4503599627370496
        memory_set_int64(result_ptr, 0, neg_inf_bits)
        Return 1
    End If

    Note: Parse sign
    Let pos be 0
    Let is_negative be 0
    Let first_ch be string_char_at(str, 0)
    If first_ch is equal to 45:
        Set is_negative to 1
        Set pos to 1
    End If

    Note: Parse integer part
    Let integer_part be 0
    Let has_integer be 0
    While pos is less than length:
        Let ch be string_char_at(str, pos)
        If ch is equal to 46:
            Note: Decimal point, break
            Set pos to length
        Otherwise:
            If ch is equal to 101:
                Note: Exponent marker 'e', break
                Set pos to length
            Otherwise:
                If ch is equal to 69:
                    Note: Exponent marker 'E', break
                    Set pos to length
                Otherwise:
                    If is_digit(ch) is equal to 1:
                        Set has_integer to 1
                        Let digit be digit_to_integer(ch)

                        Note: Check for overflow (integer_part > 10^15)
                        If integer_part is greater than 100000000000000:
                            Note: Too large, use scientific notation handling
                            Return 0
                        End If

                        Set integer_part to integer_part multiplied by 10
                        Set integer_part to integer_part plus digit
                        Set pos to pos plus 1
                    Otherwise:
                        Note: Invalid character
                        Return 0
                    End If
                End If
            End If
        End If
    End While

    Note: Find decimal point position
    Let decimal_start be 0
    Let i be 0
    If is_negative is equal to 1:
        Set i to 1
    End If
    While i is less than length:
        Let ch be string_char_at(str, i)
        If ch is equal to 46:
            Set decimal_start to i plus 1
            Set i to length
        Otherwise:
            Set i to i plus 1
        End If
    End While

    Note: Parse fractional part
    Let fractional_part be 0
    Let fractional_digits be 0
    If decimal_start is greater than 0:
        Set pos to decimal_start
        While pos is less than length:
            Let ch be string_char_at(str, pos)
            If ch is equal to 101:
                Note: Exponent marker, break
                Set pos to length
            Otherwise:
                If ch is equal to 69:
                    Note: Exponent marker, break
                    Set pos to length
                Otherwise:
                    If is_digit(ch) is equal to 1:
                        Let digit be digit_to_integer(ch)

                        Note: Limit fractional precision to 17 digits
                        If fractional_digits is less than 17:
                            Set fractional_part to fractional_part multiplied by 10
                            Set fractional_part to fractional_part plus digit
                            Set fractional_digits to fractional_digits plus 1
                        End If

                        Set pos to pos plus 1
                    Otherwise:
                        Note: Invalid character
                        Return 0
                    End If
                End If
            End If
        End While
    End If

    Note: Find exponent marker position
    Let exp_start be 0
    Set i to 0
    If is_negative is equal to 1:
        Set i to 1
    End If
    While i is less than length:
        Let ch be string_char_at(str, i)
        If ch is equal to 101:
            Set exp_start to i plus 1
            Set i to length
        Otherwise:
            If ch is equal to 69:
                Set exp_start to i plus 1
                Set i to length
            Otherwise:
                Set i to i plus 1
            End If
        End If
    End While

    Note: Parse exponent part
    Let exponent_value be 0
    Let exponent_negative be 0
    If exp_start is greater than 0:
        Set pos to exp_start

        Note: Check for exponent sign
        If pos is less than length:
            Let ch be string_char_at(str, pos)
            If ch is equal to 45:
                Set exponent_negative to 1
                Set pos to pos plus 1
            Otherwise:
                If ch is equal to 43:
                    Set pos to pos plus 1
                End If
            End If
        End If

        Note: Parse exponent digits
        While pos is less than length:
            Let ch be string_char_at(str, pos)
            If is_digit(ch) is equal to 1:
                Let digit be digit_to_integer(ch)
                Set exponent_value to exponent_value multiplied by 10
                Set exponent_value to exponent_value plus digit
                Set pos to pos plus 1
            Otherwise:
                Note: Invalid character in exponent
                Return 0
            End If
        End While
    End If

    Note: Apply exponent sign
    If exponent_negative is equal to 1:
        Set exponent_value to 0 minus exponent_value
    End If

    Note: Adjust exponent for fractional digits
    Set exponent_value to exponent_value minus fractional_digits

    Note: Handle zero case
    If integer_part is equal to 0:
        If fractional_part is equal to 0:
            Note: Result is zero (sign bit may be set)
            Let zero_bits be 0
            If is_negative is equal to 1:
                Set zero_bits to -9223372036854775808
            End If
            memory_set_int64(result_ptr, 0, zero_bits)
            Return 1
        End If
    End If

    Note: Combine integer and fractional parts into significand
    Note: significand = integer_part * 10^fractional_digits + fractional_part
    Let significand be integer_part
    Let temp_frac_digits be fractional_digits
    While temp_frac_digits is greater than 0:
        Set significand to significand multiplied by 10
        Set temp_frac_digits to temp_frac_digits minus 1
    End While
    Set significand to significand plus fractional_part

    Note: Now we have: value = significand * 10^exponent_value
    Note: Convert to binary: value = significand * 10^exp = significand * 2^e2 * 5^e5
    Note: where 10^exp = 2^exp * 5^exp

    Note: Count leading zeros in significand to normalize
    Let sig_bits be 0
    Let temp_sig be significand
    While temp_sig is greater than 0:
        Set temp_sig to temp_sig divided by 2
        Set sig_bits to sig_bits plus 1
    End While

    Note: Apply powers of 10 by converting to powers of 2 and 5
    Note: 10^exp = 2^exp * 5^exp
    Let binary_exponent be exponent_value

    Note: Multiply significand by 5^|exponent_value| if needed
    If exponent_value is greater than 0:
        Note: Multiply by 10^exponent = 2^exp * 5^exp
        Let pow5_count be exponent_value
        While pow5_count is greater than 0:
            Set significand to significand multiplied by 5
            Set pow5_count to pow5_count minus 1

            Note: Prevent overflow by normalizing
            While significand is greater than 9007199254740992:
                Set significand to significand divided by 2
                Set binary_exponent to binary_exponent plus 1
            End While
        End While
    Otherwise:
        If exponent_value is less than 0:
            Note: Divide by 10^|exponent| = multiply by (1/10)^|exp| = 2^(-exp) * 5^(-exp)
            Let pow10_count be 0 minus exponent_value
            While pow10_count is greater than 0:
                Set significand to significand multiplied by 10
                Set binary_exponent to binary_exponent minus 1
                Set pow10_count to pow10_count minus 1

                Note: Normalize to prevent overflow
                While significand is greater than 9007199254740992:
                    Set significand to significand divided by 2
                    Set binary_exponent to binary_exponent plus 1
                End While
            End While
        End If
    End If

    Note: Normalize significand to 53 bits (1.mantissa form)
    While significand is greater than 9007199254740991:
        Set significand to significand divided by 2
        Set binary_exponent to binary_exponent plus 1
    End While

    While significand is less than 4503599627370496:
        If significand is equal to 0:
            Note: Underflow to zero
            memory_set_int64(result_ptr, 0, 0)
            Return 1
        End If
        Set significand to significand multiplied by 2
        Set binary_exponent to binary_exponent minus 1
    End While

    Note: IEEE 754 exponent bias is 1023
    Let ieee_exponent be binary_exponent plus 1023

    Note: Check for overflow
    If ieee_exponent is greater than or equal to 2047:
        Note: Overflow to infinity
        Let inf_bits be 9218868437227405312
        If is_negative is equal to 1:
            Set inf_bits to -4503599627370496
        End If
        memory_set_int64(result_ptr, 0, inf_bits)
        Return 1
    End If

    Note: Check for underflow
    If ieee_exponent is less than or equal to 0:
        Note: Denormalized number or underflow to zero
        memory_set_int64(result_ptr, 0, 0)
        Return 1
    End If

    Note: Remove implicit leading 1 from mantissa
    Let mantissa be significand minus 4503599627370496

    Note: Construct IEEE 754 bits: sign(1) | exponent(11) | mantissa(52)
    Let sign_bit be 0
    If is_negative is equal to 1:
        Set sign_bit to 1
    End If

    Note: Assemble final IEEE 754 value
    Let result_bits be sign_bit left_shift 63
    Let exp_shifted be ieee_exponent left_shift 52
    Set result_bits to result_bits bitwise_or exp_shifted
    Set result_bits to result_bits bitwise_or mantissa

    memory_set_int64(result_ptr, 0, result_bits)
    Return 1
End Process

Note: ============================================================================
Note: Base64 Encoding (for Cryptography, Certificates, JWT)
Note: ============================================================================

Process called "base64_char" takes value as Integer returns Integer:
    Note: Convert 6-bit value (0-63) to Base64 character
    Note: Base64 alphabet: A-Z, a-z, 0-9, +, /

    If value is less than 0:
        Return 0
    End If
    If value is greater than 63:
        Return 0
    End If

    Note: A-Z (0-25)
    If value is less than 26:
        Return value plus 65
    End If

    Note: a-z (26-51)
    If value is less than 52:
        Return value minus 26 plus 97
    End If

    Note: 0-9 (52-61)
    If value is less than 62:
        Return value minus 52 plus 48
    End If

    Note: + (62)
    If value is equal to 62:
        Return 43
    End If

    Note: / (63)
    Return 47
End Process

Process called "base64_value" takes ch as Integer returns Integer:
    Note: Convert Base64 character to 6-bit value
    Note: Returns -1 if invalid character

    Note: A-Z (0-25)
    If ch is greater than or equal to 65:
        If ch is less than or equal to 90:
            Return ch minus 65
        End If
    End If

    Note: a-z (26-51)
    If ch is greater than or equal to 97:
        If ch is less than or equal to 122:
            Return ch minus 97 plus 26
        End If
    End If

    Note: 0-9 (52-61)
    If ch is greater than or equal to 48:
        If ch is less than or equal to 57:
            Return ch minus 48 plus 52
        End If
    End If

    Note: + (62)
    If ch is equal to 43:
        Return 62
    End If

    Note: / (63)
    If ch is equal to 47:
        Return 63
    End If

    Note: Invalid character
    Return -1
End Process

Process called "base64_encode" takes data_ptr as Integer, data_length as Integer returns Integer:
    Note: Encode binary data to Base64 string
    Note: Returns allocated Base64 string (caller must free)
    Note: Example: [0x12, 0x34, 0x56] to "EjRW"

    If data_length is equal to 0:
        Let result be allocate(1)
        memory_set_byte(result, 0, 0)
        Return result
    End If

    Note: Calculate output length: (input_bytes / 3) * 4, rounded up
    Note: Add padding to make length multiple of 4
    Let output_length be data_length multiplied by 4
    Set output_length to output_length divided by 3
    Set output_length to output_length plus 4
    Let result be allocate(output_length)
    If result is equal to 0:
        Return 0
    End If

    Let input_pos be 0
    Let output_pos be 0

    Note: Process input in 3-byte chunks (produces 4 base64 characters)
    While input_pos is less than data_length:
        Let byte1 be memory_get_byte(data_ptr, input_pos)
        Set input_pos to input_pos plus 1

        Let byte2 be 0
        Let byte3 be 0
        Let bytes_remaining be data_length minus input_pos

        If bytes_remaining is greater than or equal to 1:
            Set byte2 to memory_get_byte(data_ptr, input_pos)
            Set input_pos to input_pos plus 1
        End If

        If bytes_remaining is greater than or equal to 2:
            Set byte3 to memory_get_byte(data_ptr, input_pos)
            Set input_pos to input_pos plus 1
        End If

        Note: Convert 3 bytes (24 bits) to 4 base64 characters (6 bits each)
        Let val1 be byte1 right_shift 2
        Let val2 be byte1 bitwise_and 3
        Set val2 to val2 left_shift 4
        Let temp be byte2 right_shift 4
        Set val2 to val2 bitwise_or temp

        Let val3 be byte2 bitwise_and 15
        Set val3 to val3 left_shift 2
        Set temp to byte3 right_shift 6
        Set val3 to val3 bitwise_or temp

        Let val4 be byte3 bitwise_and 63

        Note: Convert values to base64 characters
        Let ch1 be base64_char(val1)
        Let ch2 be base64_char(val2)
        memory_set_byte(result, output_pos, ch1)
        Set output_pos to output_pos plus 1
        memory_set_byte(result, output_pos, ch2)
        Set output_pos to output_pos plus 1

        Note: Handle padding for last chunk
        If bytes_remaining is greater than or equal to 1:
            Let ch3 be base64_char(val3)
            memory_set_byte(result, output_pos, ch3)
        Otherwise:
            memory_set_byte(result, output_pos, 61)
        End If
        Set output_pos to output_pos plus 1

        If bytes_remaining is greater than or equal to 2:
            Let ch4 be base64_char(val4)
            memory_set_byte(result, output_pos, ch4)
        Otherwise:
            memory_set_byte(result, output_pos, 61)
        End If
        Set output_pos to output_pos plus 1
    End While

    Note: Null terminate
    memory_set_byte(result, output_pos, 0)

    Return result
End Process

Process called "base64_decode" takes base64_str as Integer, out_ptr as Integer returns Integer:
    Note: Decode Base64 string to binary data
    Note: Returns number of bytes decoded, or -1 on error
    Note: Example: "EjRW" to [0x12, 0x34, 0x56]

    Let length be string_length(base64_str)
    If length is equal to 0:
        Return 0
    End If

    Note: Base64 length must be multiple of 4
    If length modulo by 4 is not equal to 0:
        Return -1
    End If

    Let input_pos be 0
    Let output_pos be 0

    Note: Process input in 4-character chunks (produces 3 bytes)
    While input_pos is less than length:
        Let ch1 be string_char_at(base64_str, input_pos)
        Set input_pos to input_pos plus 1
        Let ch2 be string_char_at(base64_str, input_pos)
        Set input_pos to input_pos plus 1
        Let ch3 be string_char_at(base64_str, input_pos)
        Set input_pos to input_pos plus 1
        Let ch4 be string_char_at(base64_str, input_pos)
        Set input_pos to input_pos plus 1

        Note: Convert characters to 6-bit values
        Let val1 be base64_value(ch1)
        Let val2 be base64_value(ch2)

        If val1 is less than 0:
            Return -1
        End If
        If val2 is less than 0:
            Return -1
        End If

        Note: First byte
        Let byte1 be val1 left_shift 2
        Let temp be val2 right_shift 4
        Set byte1 to byte1 bitwise_or temp
        memory_set_byte(out_ptr, output_pos, byte1)
        Set output_pos to output_pos plus 1

        Note: Check for padding
        If ch3 is not equal to 61:
            Let val3 be base64_value(ch3)
            If val3 is less than 0:
                Return -1
            End If

            Note: Second byte
            Let byte2 be val2 bitwise_and 15
            Set byte2 to byte2 left_shift 4
            Set temp to val3 right_shift 2
            Set byte2 to byte2 bitwise_or temp
            memory_set_byte(out_ptr, output_pos, byte2)
            Set output_pos to output_pos plus 1

            Note: Check for second padding
            If ch4 is not equal to 61:
                Let val4 be base64_value(ch4)
                If val4 is less than 0:
                    Return -1
                End If

                Note: Third byte
                Let byte3 be val3 bitwise_and 3
                Set byte3 to byte3 left_shift 6
                Set byte3 to byte3 bitwise_or val4
                memory_set_byte(out_ptr, output_pos, byte3)
                Set output_pos to output_pos plus 1
            End If
        End If
    End While

    Return output_pos
End Process

Note: ============================================================================
Note: Base58 Encoding (for Bitcoin/Cryptocurrency Addresses)
Note: ============================================================================

Process called "base58_char" takes value as Integer returns Integer:
    Note: Convert value (0-57) to Base58 character
    Note: Base58 alphabet: 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
    Note: Excludes: 0, O, I, l (to avoid confusion)

    If value is less than 0:
        Return 0
    End If
    If value is greater than 57:
        Return 0
    End If

    Note: Use lookup table for Base58 alphabet
    Note: 1-9 (0-8)
    If value is less than 9:
        Return value plus 49
    End If

    Note: A-H (9-16)
    If value is less than 17:
        Return value minus 9 plus 65
    End If

    Note: J-N (17-21)
    If value is less than 22:
        Return value minus 17 plus 74
    End If

    Note: P-Z (22-32)
    If value is less than 33:
        Return value minus 22 plus 80
    End If

    Note: a-k (33-43)
    If value is less than 44:
        Return value minus 33 plus 97
    End If

    Note: m-z (44-57)
    Return value minus 44 plus 109
End Process

Process called "base58_encode" takes data_ptr as Integer, data_length as Integer returns Integer:
    Note: Encode binary data to Base58 string (Bitcoin alphabet)
    Note: Returns allocated Base58 string (caller must free)
    Note: Uses arbitrary-precision division algorithm for complete Base58 encoding

    If data_length is equal to 0:
        Let result be allocate(1)
        memory_set_byte(result, 0, 0)
        Return result
    End If

    Note: Estimate output length (worst case: length * 138 / 100)
    Let estimated_length be data_length multiplied by 138
    Set estimated_length to estimated_length divided by 100
    Set estimated_length to estimated_length plus 2

    Let result be allocate(estimated_length)
    If result is equal to 0:
        Return 0
    End If

    Note: Full Base58 encoding using arbitrary-precision division
    Note: Treat input bytes as a big-endian big integer
    Note: Repeatedly divide by 58 and collect remainders

    Note: Copy input data to working buffer (we'll modify it)
    Let working_buffer be allocate(data_length)
    If working_buffer is equal to 0:
        deallocate(result)
        Return 0
    End If

    Let i be 0
    While i is less than data_length:
        Let b be memory_get_byte(data_ptr, i)
        memory_set_byte(working_buffer, i, b)
        Set i to i plus 1
    End While

    Note: Build result string backwards by repeatedly dividing by 58
    Let output_pos be estimated_length minus 1

    Note: Check if number is zero
    Let is_zero be 1
    Set i to 0
    While i is less than data_length:
        If memory_get_byte(working_buffer, i) is not equal to 0:
            Set is_zero to 0
        End If
        Set i to i plus 1
    End While

    While is_zero is equal to 0:
        Note: Divide working_buffer by 58, get remainder
        Let remainder be 0
        Set i to 0
        While i is less than data_length:
            Let current_byte be memory_get_byte(working_buffer, i)
            Let temp be remainder multiplied by 256
            Set temp to temp plus current_byte
            Let quotient_byte be temp divided by 58
            Set remainder to temp modulo by 58
            memory_set_byte(working_buffer, i, quotient_byte)
            Set i to i plus 1
        End While

        Note: Convert remainder to Base58 character
        Let ch be base58_char(remainder)
        memory_set_byte(result, output_pos, ch)
        Set output_pos to output_pos minus 1

        Note: Check if quotient is zero
        Set is_zero to 1
        Set i to 0
        While i is less than data_length:
            If memory_get_byte(working_buffer, i) is not equal to 0:
                Set is_zero to 0
            End If
            Set i to i plus 1
        End While
    End While

    Note: Count leading zeros in input (should be represented as '1' in Base58)
    Let leading_zeros be 0
    Set i to 0
    While i is less than data_length:
        If memory_get_byte(data_ptr, i) is equal to 0:
            Set leading_zeros to leading_zeros plus 1
            Set i to i plus 1
        Otherwise:
            Set i to data_length
        End If
    End While

    Note: Add leading '1's for leading zero bytes
    While leading_zeros is greater than 0:
        memory_set_byte(result, output_pos, 49)
        Set output_pos to output_pos minus 1
        Set leading_zeros to leading_zeros minus 1
    End While

    Note: Shift result to beginning of buffer
    Set output_pos to output_pos plus 1
    Let result_length be estimated_length minus output_pos
    Set i to 0
    While i is less than result_length:
        Let ch be memory_get_byte(result, output_pos plus i)
        memory_set_byte(result, i, ch)
        Set i to i plus 1
    End While

    Note: Null terminate
    memory_set_byte(result, result_length, 0)

    Note: Clean up working buffer
    deallocate(working_buffer)

    Return result
End Process

Note: ============================================================================
Note: String Literal Validation
Note: ============================================================================

Process called "validate_integer_literal" takes str as Integer returns Integer:
    Note: Validate integer literal format
    Note: Supports decimal, hex (0x), binary (0b), octal (0o)
    Note: Returns 1 if valid, 0 if invalid

    Let length be string_length(str)
    If length is equal to 0:
        Return 0
    End If

    Let pos be 0

    Note: Check for optional minus sign
    Let first_ch be string_char_at(str, pos)
    If first_ch is equal to 45:
        Set pos to pos plus 1
    End If

    If pos is greater than or equal to length:
        Return 0
    End If

    Note: Check for prefix (0x, 0b, 0o)
    Let ch be string_char_at(str, pos)
    If ch is equal to 48:
        If pos plus 1 is less than length:
            Let next_ch be string_char_at(str, pos plus 1)

            Note: Hex prefix
            If next_ch is equal to 120:
                Set pos to pos plus 2
                Note: Rest must be hex digits
                While pos is less than length:
                    Set ch to string_char_at(str, pos)
                    If hex_digit_to_integer(ch) is less than 0:
                        Return 0
                    End If
                    Set pos to pos plus 1
                End While
                Return 1
            End If

            Note: Binary prefix
            If next_ch is equal to 98:
                Set pos to pos plus 2
                Note: Rest must be 0 or 1
                While pos is less than length:
                    Set ch to string_char_at(str, pos)
                    If ch is not equal to 48:
                        If ch is not equal to 49:
                            Return 0
                        End If
                    End If
                    Set pos to pos plus 1
                End While
                Return 1
            End If

            Note: Octal prefix
            If next_ch is equal to 111:
                Set pos to pos plus 2
                Note: Rest must be 0-7
                While pos is less than length:
                    Set ch to string_char_at(str, pos)
                    If ch is less than 48:
                        Return 0
                    End If
                    If ch is greater than 55:
                        Return 0
                    End If
                    Set pos to pos plus 1
                End While
                Return 1
            End If
        End If
    End If

    Note: Decimal literal - all digits
    While pos is less than length:
        Set ch to string_char_at(str, pos)
        If is_digit(ch) is equal to 0:
            Return 0
        End If
        Set pos to pos plus 1
    End While

    Return 1
End Process

Process called "validate_hex_string" takes str as Integer returns Integer:
    Note: Validate hex string format (for crypto hashes, addresses)
    Note: Returns 1 if valid, 0 if invalid

    Let length be string_length(str)
    If length is equal to 0:
        Return 0
    End If

    Note: Hex string should have even length
    If length modulo by 2 is not equal to 0:
        Return 0
    End If

    Note: Check if all characters are hex digits
    Let i be 0
    While i is less than length:
        Let ch be string_char_at(str, i)
        If hex_digit_to_integer(ch) is less than 0:
            Return 0
        End If
        Set i to i plus 1
    End While

    Return 1
End Process
