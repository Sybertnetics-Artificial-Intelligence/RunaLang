Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles type conversions and casts.

This file performs the following tasks:
- Convert between integer types (int8, int16, int32, int64, int128, int256, int512)
- Cast between compatible types
- Handle sign extension and zero extension
- Handle truncation for all integer sizes
- Widen integers to larger precision (up to 512-bit)

This file is essential because of the following reasons:
- Enables implicit and explicit type conversions
- Ensures type safety during conversions
- Handles size changes properly (truncation/extension)
- Supports cryptographic and blockchain integer sizes (256/512-bit)

Dependencies:
- types/validation.runa (type compatibility checking)
- core/bitwise_core.runa (for masking/truncation)
- memory/layout.runa (for multi-precision memory access)
:End Note

Import "compiler/frontend/primitives/types/validation.runa" as TypeValidation
Import "compiler/frontend/primitives/core/bitwise_core.runa" as BitwiseCore
Import "compiler/frontend/primitives/memory/layout.runa" as MemoryLayout

Note: ============================================================================
Note: Integer Type Conversions
Note: ============================================================================

Process called "truncate_to_int8" takes value as Integer returns Integer:
    Note: Truncate 64-bit value to 8-bit signed integer
    Note: Returns value in range -128 to 127

    Note: Mask to 8 bits
    Let result be proc bitwise_and from BitwiseCore with value, 255

    Note: Sign extend if negative (bit 7 is set)
    If result is greater than or equal to 128:
        Let result be result minus 256
    End If

    Return result
End Process

Process called "truncate_to_int16" takes value as Integer returns Integer:
    Note: Truncate 64-bit value to 16-bit signed integer
    Note: Returns value in range -32768 to 32767

    Note: Mask to 16 bits
    Let result be proc bitwise_and from BitwiseCore with value, 65535

    Note: Sign extend if negative (bit 15 is set)
    If result is greater than or equal to 32768:
        Let result be result minus 65536
    End If

    Return result
End Process

Process called "truncate_to_int32" takes value as Integer returns Integer:
    Note: Truncate 64-bit value to 32-bit signed integer
    Note: Returns value in range -2147483648 to 2147483647

    Note: Mask to 32 bits
    Let result be proc bitwise_and from BitwiseCore with value, 4294967295

    Note: Sign extend if negative (bit 31 is set)
    If result is greater than or equal to 2147483648:
        Let result be result minus 4294967296
    End If

    Return result
End Process

Process called "truncate_to_int64" takes value_ptr as Integer returns Integer:
    Note: Truncate larger multi-precision value to 64-bit signed integer
    Note: value_ptr points to 128/256/512-bit value (reads low word only)
    Note: Returns value in 64-bit signed range

    Note: For multi-precision values, just return the low 64 bits
    Let result be proc memory_get_int64 from MemoryLayout with value_ptr, 0
    Return result
End Process

Process called "truncate_to_int128" takes value_ptr as Integer, result_ptr as Integer:
    Note: Truncate 256/512-bit value to 128-bit signed integer
    Note: value_ptr points to source, result_ptr points to 128-bit destination
    Note: Copies low 128 bits (first two 64-bit words)

    Let low_word be proc memory_get_int64 from MemoryLayout with value_ptr, 0
    Let high_word be proc memory_get_int64 from MemoryLayout with value_ptr, 8

    proc memory_set_int64 from MemoryLayout with result_ptr, 0, low_word
    proc memory_set_int64 from MemoryLayout with result_ptr, 8, high_word
End Process

Process called "truncate_to_int256" takes value_ptr as Integer, result_ptr as Integer:
    Note: Truncate 512-bit value to 256-bit signed integer
    Note: value_ptr points to source, result_ptr points to 256-bit destination
    Note: Copies low 256 bits (first four 64-bit words)

    Let word0 be proc memory_get_int64 from MemoryLayout with value_ptr, 0
    Let word1 be proc memory_get_int64 from MemoryLayout with value_ptr, 8
    Let word2 be proc memory_get_int64 from MemoryLayout with value_ptr, 16
    Let word3 be proc memory_get_int64 from MemoryLayout with value_ptr, 24

    proc memory_set_int64 from MemoryLayout with result_ptr, 0, word0
    proc memory_set_int64 from MemoryLayout with result_ptr, 8, word1
    proc memory_set_int64 from MemoryLayout with result_ptr, 16, word2
    proc memory_set_int64 from MemoryLayout with result_ptr, 24, word3
End Process
Note: ============================================================================
Note: Unsigned Integer Truncation
Note: ============================================================================

Process called "truncate_to_uint8" takes value as Integer returns Integer:
    Note: Truncate 64-bit value to 8-bit unsigned integer
    Note: Returns value in range 0 to 255

    Note: Mask to 8 bits (no sign extension for unsigned)
    Return proc bitwise_and from BitwiseCore with value, 255
End Process

Process called "truncate_to_uint16" takes value as Integer returns Integer:
    Note: Truncate 64-bit value to 16-bit unsigned integer
    Note: Returns value in range 0 to 65535

    Note: Mask to 16 bits
    Return proc bitwise_and from BitwiseCore with value, 65535
End Process

Process called "truncate_to_uint32" takes value as Integer returns Integer:
    Note: Truncate 64-bit value to 32-bit unsigned integer
    Note: Returns value in range 0 to 4294967295

    Note: Mask to 32 bits
    Return proc bitwise_and from BitwiseCore with value, 4294967295
End Process

Process called "truncate_to_uint64" takes value_ptr as Integer returns Integer:
    Note: Truncate larger multi-precision value to 64-bit unsigned integer
    Note: Same as truncate_to_int64 but semantically unsigned

    Let result be proc memory_get_int64 from MemoryLayout with value_ptr, 0
    Return result
End Process

Process called "truncate_to_uint128" takes value_ptr as Integer, result_ptr as Integer:
    Note: Truncate 256/512-bit value to 128-bit unsigned integer
    Note: value_ptr points to source, result_ptr points to 128-bit destination
    Note: Copies low 128 bits (first two 64-bit words)

    Let low_word be proc memory_get_int64 from MemoryLayout with value_ptr, 0
    Let high_word be proc memory_get_int64 from MemoryLayout with value_ptr, 8

    proc memory_set_int64 from MemoryLayout with result_ptr, 0, low_word
    proc memory_set_int64 from MemoryLayout with result_ptr, 8, high_word
End Process

Process called "truncate_to_uint256" takes value_ptr as Integer, result_ptr as Integer:
    Note: Truncate 512-bit value to 256-bit unsigned integer
    Note: value_ptr points to source, result_ptr points to 256-bit destination
    Note: Copies low 256 bits (first four 64-bit words)

    Let word0 be proc memory_get_int64 from MemoryLayout with value_ptr, 0
    Let word1 be proc memory_get_int64 from MemoryLayout with value_ptr, 8
    Let word2 be proc memory_get_int64 from MemoryLayout with value_ptr, 16
    Let word3 be proc memory_get_int64 from MemoryLayout with value_ptr, 24

    proc memory_set_int64 from MemoryLayout with result_ptr, 0, word0
    proc memory_set_int64 from MemoryLayout with result_ptr, 8, word1
    proc memory_set_int64 from MemoryLayout with result_ptr, 16, word2
    proc memory_set_int64 from MemoryLayout with result_ptr, 24, word3
End Process

Process called "zero_extend_to_int64" takes value as Integer, bits as Integer returns Integer:
    Note: Zero-extend a value to 64 bits
    Note: bits specifies the source bit width (8, 16, 32)

    If bits is equal to 8:
        Return proc bitwise_and from BitwiseCore with value, 255
    End If

    If bits is equal to 16:
        Return proc bitwise_and from BitwiseCore with value, 65535
    End If

    If bits is equal to 32:
        Return proc bitwise_and from BitwiseCore with value, 4294967295
    End If

    Note: Already 64-bit
    Return value
End Process

Process called "sign_extend_to_int64" takes value as Integer, bits as Integer returns Integer:
    Note: Sign-extend a value to 64 bits
    Note: bits specifies the source bit width (8, 16, 32)

    If bits is equal to 8:
        Return proc truncate_to_int8 with value
    End If

    If bits is equal to 16:
        Return proc truncate_to_int16 with value
    End If

    If bits is equal to 32:
        Return proc truncate_to_int32 with value
    End If

    Note: Already 64-bit
    Return value
End Process

Note: ============================================================================
Note: Multi-Precision Widening (128/256/512-bit)
Note: ============================================================================

Process called "widen_to_int128_signed" takes value as Integer, result_ptr as Integer:
    Note: Sign-extend 64-bit value to 128-bit
    Note: result_ptr points to 128-bit destination (two 64-bit words)

    Note: Store low word
    proc memory_set_int64 from MemoryLayout with result_ptr, 0, value

    Note: Sign-extend high word (all 1s if negative, all 0s if positive)
    If value is less than 0:
        proc memory_set_int64 from MemoryLayout with result_ptr, 8, -1
    End If
    If value is greater than or equal to 0:
        proc memory_set_int64 from MemoryLayout with result_ptr, 8, 0
    End If
End Process

Process called "widen_to_int128_unsigned" takes value as Integer, result_ptr as Integer:
    Note: Zero-extend 64-bit value to 128-bit
    Note: result_ptr points to 128-bit destination (two 64-bit words)

    Note: Store low word
    proc memory_set_int64 from MemoryLayout with result_ptr, 0, value

    Note: Zero high word
    proc memory_set_int64 from MemoryLayout with result_ptr, 8, 0
End Process

Process called "widen_to_int256_signed" takes value_ptr as Integer, result_ptr as Integer, source_bits as Integer:
    Note: Sign-extend 64/128-bit value to 256-bit
    Note: source_bits = 64 or 128
    Note: result_ptr points to 256-bit destination (four 64-bit words)

    If source_bits is equal to 64:
        Note: Widen from 64-bit
        Let value be proc memory_get_int64 from MemoryLayout with value_ptr, 0
        proc memory_set_int64 from MemoryLayout with result_ptr, 0, value

        Note: Sign-extend remaining words
        If value is less than 0:
            proc memory_set_int64 from MemoryLayout with result_ptr, 8, -1
            proc memory_set_int64 from MemoryLayout with result_ptr, 16, -1
            proc memory_set_int64 from MemoryLayout with result_ptr, 24, -1
        End If
        If value is greater than or equal to 0:
            proc memory_set_int64 from MemoryLayout with result_ptr, 8, 0
            proc memory_set_int64 from MemoryLayout with result_ptr, 16, 0
            proc memory_set_int64 from MemoryLayout with result_ptr, 24, 0
        End If
    End If

    If source_bits is equal to 128:
        Note: Widen from 128-bit
        Let low_word be proc memory_get_int64 from MemoryLayout with value_ptr, 0
        Let high_word be proc memory_get_int64 from MemoryLayout with value_ptr, 8

        proc memory_set_int64 from MemoryLayout with result_ptr, 0, low_word
        proc memory_set_int64 from MemoryLayout with result_ptr, 8, high_word

        Note: Sign-extend remaining words based on sign of high word
        If high_word is less than 0:
            proc memory_set_int64 from MemoryLayout with result_ptr, 16, -1
            proc memory_set_int64 from MemoryLayout with result_ptr, 24, -1
        End If
        If high_word is greater than or equal to 0:
            proc memory_set_int64 from MemoryLayout with result_ptr, 16, 0
            proc memory_set_int64 from MemoryLayout with result_ptr, 24, 0
        End If
    End If
End Process

Process called "widen_to_int256_unsigned" takes value_ptr as Integer, result_ptr as Integer, source_bits as Integer:
    Note: Zero-extend 64/128-bit value to 256-bit
    Note: source_bits = 64 or 128
    Note: result_ptr points to 256-bit destination (four 64-bit words)

    If source_bits is equal to 64:
        Note: Widen from 64-bit
        Let value be proc memory_get_int64 from MemoryLayout with value_ptr, 0
        proc memory_set_int64 from MemoryLayout with result_ptr, 0, value
        proc memory_set_int64 from MemoryLayout with result_ptr, 8, 0
        proc memory_set_int64 from MemoryLayout with result_ptr, 16, 0
        proc memory_set_int64 from MemoryLayout with result_ptr, 24, 0
    End If

    If source_bits is equal to 128:
        Note: Widen from 128-bit
        Let low_word be proc memory_get_int64 from MemoryLayout with value_ptr, 0
        Let high_word be proc memory_get_int64 from MemoryLayout with value_ptr, 8

        proc memory_set_int64 from MemoryLayout with result_ptr, 0, low_word
        proc memory_set_int64 from MemoryLayout with result_ptr, 8, high_word
        proc memory_set_int64 from MemoryLayout with result_ptr, 16, 0
        proc memory_set_int64 from MemoryLayout with result_ptr, 24, 0
    End If
End Process

Process called "widen_to_int512_signed" takes value_ptr as Integer, result_ptr as Integer, source_bits as Integer:
    Note: Sign-extend 64/128/256-bit value to 512-bit
    Note: source_bits = 64, 128, or 256
    Note: result_ptr points to 512-bit destination (eight 64-bit words)

    If source_bits is equal to 64:
        Note: Widen from 64-bit
        Let value be proc memory_get_int64 from MemoryLayout with value_ptr, 0
        proc memory_set_int64 from MemoryLayout with result_ptr, 0, value

        Note: Sign-extend remaining words
        Let sign_word be 0
        If value is less than 0:
            Set sign_word to -1
        End If

        Let i be 1
        While i is less than 8:
            proc memory_set_int64 from MemoryLayout with result_ptr, i multiplied by 8, sign_word
            Set i to i plus 1
        End While
    End If

    If source_bits is equal to 128:
        Note: Widen from 128-bit
        Let low_word be proc memory_get_int64 from MemoryLayout with value_ptr, 0
        Let high_word be proc memory_get_int64 from MemoryLayout with value_ptr, 8

        proc memory_set_int64 from MemoryLayout with result_ptr, 0, low_word
        proc memory_set_int64 from MemoryLayout with result_ptr, 8, high_word

        Note: Sign-extend remaining words based on sign of high word
        Let sign_word be 0
        If high_word is less than 0:
            Set sign_word to -1
        End If

        Let i be 2
        While i is less than 8:
            proc memory_set_int64 from MemoryLayout with result_ptr, i multiplied by 8, sign_word
            Set i to i plus 1
        End While
    End If

    If source_bits is equal to 256:
        Note: Widen from 256-bit
        Let i be 0
        While i is less than 4:
            Let word be proc memory_get_int64 from MemoryLayout with value_ptr, i multiplied by 8
            proc memory_set_int64 from MemoryLayout with result_ptr, i multiplied by 8, word
            Set i to i plus 1
        End While

        Note: Sign-extend remaining words based on sign of word 3
        Let sign_word be 0
        Let high_word be proc memory_get_int64 from MemoryLayout with value_ptr, 24
        If high_word is less than 0:
            Set sign_word to -1
        End If

        Set i to 4
        While i is less than 8:
            proc memory_set_int64 from MemoryLayout with result_ptr, i multiplied by 8, sign_word
            Set i to i plus 1
        End While
    End If
End Process

Process called "widen_to_int512_unsigned" takes value_ptr as Integer, result_ptr as Integer, source_bits as Integer:
    Note: Zero-extend 64/128/256-bit value to 512-bit
    Note: source_bits = 64, 128, or 256
    Note: result_ptr points to 512-bit destination (eight 64-bit words)

    If source_bits is equal to 64:
        Note: Widen from 64-bit
        Let value be proc memory_get_int64 from MemoryLayout with value_ptr, 0
        proc memory_set_int64 from MemoryLayout with result_ptr, 0, value

        Let i be 1
        While i is less than 8:
            proc memory_set_int64 from MemoryLayout with result_ptr, i multiplied by 8, 0
            Set i to i plus 1
        End While
    End If

    If source_bits is equal to 128:
        Note: Widen from 128-bit
        Let low_word be proc memory_get_int64 from MemoryLayout with value_ptr, 0
        Let high_word be proc memory_get_int64 from MemoryLayout with value_ptr, 8

        proc memory_set_int64 from MemoryLayout with result_ptr, 0, low_word
        proc memory_set_int64 from MemoryLayout with result_ptr, 8, high_word

        Let i be 2
        While i is less than 8:
            proc memory_set_int64 from MemoryLayout with result_ptr, i multiplied by 8, 0
            Set i to i plus 1
        End While
    End If

    If source_bits is equal to 256:
        Note: Widen from 256-bit
        Let i be 0
        While i is less than 4:
            Let word be proc memory_get_int64 from MemoryLayout with value_ptr, i multiplied by 8
            proc memory_set_int64 from MemoryLayout with result_ptr, i multiplied by 8, word
            Set i to i plus 1
        End While

        Set i to 4
        While i is less than 8:
            proc memory_set_int64 from MemoryLayout with result_ptr, i multiplied by 8, 0
            Set i to i plus 1
        End While
    End If
End Process

Note: ============================================================================
Note: Type Casting Functions
Note: ============================================================================

Process called "cast_integer_to_type" takes value as Integer, target_type as Integer returns Integer:
    Note: Cast an integer value to a target integer type
    Note: target_type is type name string ("Integer8", "Integer16", etc.)

    If proc string_equals with target_type, "Integer8" is equal to 1:
        Return proc truncate_to_int8 with value
    End If

    If proc string_equals with target_type, "Integer16" is equal to 1:
        Return proc truncate_to_int16 with value
    End If

    If proc string_equals with target_type, "Integer32" is equal to 1:
        Return proc truncate_to_int32 with value
    End If

    Note: Integer, Integer128, or unknown - return as-is
    Return value
End Process

Process called "can_convert_lossless" takes from_type as Integer, to_type as Integer returns Integer:
    Note: Check if conversion is lossless (no data loss)
    Note: Returns 1 if lossless, 0 if lossy

    Note: Same type is always lossless
    If proc string_equals with from_type, to_type is equal to 1:
        Return 1
    End If

    Note: int8 -> int16/int32/int64/int128 is lossless
    If proc string_equals with from_type, "Integer8" is equal to 1:
        If proc string_equals with to_type, "Integer16" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "Integer32" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "Integer" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "Integer128" is equal to 1:
            Return 1
        End If
    End If

    Note: int16 -> int32/int64/int128 is lossless
    If proc string_equals with from_type, "Integer16" is equal to 1:
        If proc string_equals with to_type, "Integer32" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "Integer" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "Integer128" is equal to 1:
            Return 1
        End If
    End If

    Note: int32 -> int64/int128 is lossless
    If proc string_equals with from_type, "Integer32" is equal to 1:
        If proc string_equals with to_type, "Integer" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "Integer128" is equal to 1:
            Return 1
        End If
    End If

    Note: int64 -> int128/int256/int512 is lossless
    If proc string_equals with from_type, "Integer" is equal to 1:
        If proc string_equals with to_type, "Integer128" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "Integer256" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "Integer512" is equal to 1:
            Return 1
        End If
    End If

    Note: int128 -> int256/int512 is lossless
    If proc string_equals with from_type, "Integer128" is equal to 1:
        If proc string_equals with to_type, "Integer256" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "Integer512" is equal to 1:
            Return 1
        End If
    End If

    Note: int256 -> int512 is lossless
    If proc string_equals with from_type, "Integer256" is equal to 1:
        If proc string_equals with to_type, "Integer512" is equal to 1:
            Return 1
        End If
    End If

    Note: Unsigned variants follow same rules
    If proc string_equals with from_type, "UInteger8" is equal to 1:
        If proc string_equals with to_type, "UInteger16" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "UInteger32" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "UInteger64" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "UInteger128" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "UInteger256" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "UInteger512" is equal to 1:
            Return 1
        End If
    End If

    If proc string_equals with from_type, "UInteger16" is equal to 1:
        If proc string_equals with to_type, "UInteger32" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "UInteger64" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "UInteger128" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "UInteger256" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "UInteger512" is equal to 1:
            Return 1
        End If
    End If

    If proc string_equals with from_type, "UInteger32" is equal to 1:
        If proc string_equals with to_type, "UInteger64" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "UInteger128" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "UInteger256" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "UInteger512" is equal to 1:
            Return 1
        End If
    End If

    If proc string_equals with from_type, "UInteger64" is equal to 1:
        If proc string_equals with to_type, "UInteger128" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "UInteger256" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "UInteger512" is equal to 1:
            Return 1
        End If
    End If

    If proc string_equals with from_type, "UInteger128" is equal to 1:
        If proc string_equals with to_type, "UInteger256" is equal to 1:
            Return 1
        End If
        If proc string_equals with to_type, "UInteger512" is equal to 1:
            Return 1
        End If
    End If

    If proc string_equals with from_type, "UInteger256" is equal to 1:
        If proc string_equals with to_type, "UInteger512" is equal to 1:
            Return 1
        End If
    End If

    Note: Float -> Float64 is lossless
    If proc string_equals with from_type, "Float" is equal to 1:
        If proc string_equals with to_type, "Float64" is equal to 1:
            Return 1
        End If
    End If

    Note: All other conversions are lossy
    Return 0
End Process

Note: ============================================================================
Note: Boolean/Integer Conversions
Note: ============================================================================

Process called "integer_to_boolean" takes value as Integer returns Integer:
    Note: Convert integer to boolean (0 -> false, non-zero -> true)

    If value is equal to 0:
        Return 0
    End If
    Return 1
End Process

Process called "boolean_to_integer" takes value as Integer returns Integer:
    Note: Convert boolean to integer (already 0 or 1)
    Return value
End Process
