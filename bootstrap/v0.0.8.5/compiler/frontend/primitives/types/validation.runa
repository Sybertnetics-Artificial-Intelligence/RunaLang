Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles type validation and type checking operations.

This file performs the following tasks:
- Validate type names and type compatibility
- Check expression types
- Verify type safety for operations
- Validate advanced types (generics, structs, arrays, function pointers)
- Support 256/512-bit integer types for cryptography

This file is essential because of the following reasons:
- Type validation ensures type safety at compile time
- Prevents type mismatches and invalid operations
- Foundation for semantic analysis
- Enables advanced type system features (generics, function pointers)

Dependencies:
- core/string_core.runa (string comparison, string_char_at, string_length)
- memory/layout.runa (memory allocation for type parsing)
- types/ascii_conversion.runa (character validation functions)
- core/memory_core.runa (memory_set_byte for string operations)
:End Note

Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/memory/layout.runa" as MemoryLayout
Import "compiler/frontend/primitives/types/ascii_conversion.runa" as AsciiConv
Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore

Note: ============================================================================
Note: Wrapper Functions for Imported Dependencies
Note: ============================================================================

Process called "string_equals" takes str1 as Integer, str2 as Integer returns Integer:
    Return StringCore.string_equals(str1, str2)
End Process

Process called "string_length" takes str as Integer returns Integer:
    Return StringCore.string_length(str)
End Process

Process called "string_char_at" takes str as Integer, index as Integer returns Integer:
    Return StringCore.string_char_at(str, index)
End Process

Process called "is_alpha_upper" takes ch as Integer returns Integer:
    Return AsciiConv.is_alpha_upper(ch)
End Process

Process called "is_alphanumeric" takes ch as Integer returns Integer:
    Return AsciiConv.is_alphanumeric(ch)
End Process

Process called "is_digit" takes ch as Integer returns Integer:
    Return AsciiConv.is_digit(ch)
End Process

Process called "memory_set_byte" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Return MemoryCore.memory_set_byte(ptr, offset, value)
End Process

Process called "allocate" takes size as Integer returns Integer:
    Return MemoryLayout.allocate(size)
End Process

Note: ============================================================================
Note: Basic Type Names (Type System Constants)
Note: ============================================================================

Note: Fundamental types
Let TYPE_INTEGER_NAME be "Integer"
Let TYPE_POINTER_NAME be "Pointer"
Let TYPE_STRING_NAME be "String"
Let TYPE_VOID_NAME be "Void"
Let TYPE_BOOLEAN_NAME be "Boolean"

Note: Sized integer types
Let TYPE_INTEGER8_NAME be "Integer8"
Let TYPE_INTEGER16_NAME be "Integer16"
Let TYPE_INTEGER32_NAME be "Integer32"
Let TYPE_INTEGER128_NAME be "Integer128"
Let TYPE_INTEGER256_NAME be "Integer256"
Let TYPE_INTEGER512_NAME be "Integer512"

Note: Unsigned integer types
Let TYPE_UINTEGER8_NAME be "UInteger8"
Let TYPE_UINTEGER16_NAME be "UInteger16"
Let TYPE_UINTEGER32_NAME be "UInteger32"
Let TYPE_UINTEGER64_NAME be "UInteger64"
Let TYPE_UINTEGER128_NAME be "UInteger128"
Let TYPE_UINTEGER256_NAME be "UInteger256"
Let TYPE_UINTEGER512_NAME be "UInteger512"

Note: Floating point types
Let TYPE_FLOAT_NAME be "Float"
Let TYPE_FLOAT16_NAME be "Float16"
Let TYPE_FLOAT32_NAME be "Float32"
Let TYPE_FLOAT64_NAME be "Float64"
Let TYPE_FLOAT80_NAME be "Float80"
Let TYPE_FLOAT128_NAME be "Float128"

Note: Decimal types for financial math
Let TYPE_DECIMAL64_NAME be "Decimal64"
Let TYPE_DECIMAL128_NAME be "Decimal128"

Note: ============================================================================
Note: Type Validation Functions
Note: ============================================================================

Process called "validate_type" takes type_name as Integer returns Integer:
    Note: Check if a type name is valid
    Note: Returns 1 if valid, 0 if invalid

    If string_equals(type_name, "Integer") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "Pointer") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "String") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "Void") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "Boolean") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "Integer8") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "Integer16") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "Integer32") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "Integer128") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "Integer256") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "Integer512") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "UInteger8") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "UInteger16") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "UInteger32") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "UInteger64") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "UInteger128") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "UInteger256") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "UInteger512") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "Float") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "Float16") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "Float32") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "Float64") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "Float80") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "Float128") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "Decimal64") is equal to 1:
        Return 1
    End If

    If string_equals(type_name, "Decimal128") is equal to 1:
        Return 1
    End If

    Note: Check for generic/struct/array/function pointer types
    If validate_generic_type(type_name) is equal to 1:
        Return 1
    End If

    If validate_struct_type(type_name) is equal to 1:
        Return 1
    End If

    If validate_array_type(type_name) is equal to 1:
        Return 1
    End If

    If validate_function_pointer_type(type_name) is equal to 1:
        Return 1
    End If

    Return 0
End Process

Process called "types_compatible" takes type1 as Integer, type2 as Integer returns Integer:
    Note: Check if two types are compatible for assignment/operations
    Note: Returns 1 if compatible, 0 if incompatible

    Note: Exact match
    If string_equals(type1, type2) is equal to 1:
        Return 1
    End If

    Note: All integer types are compatible with each other (implicit conversion)
    Let is_type1_integer be 0
    Let is_type2_integer be 0

    If string_equals(type1, "Integer") is equal to 1:
        Set is_type1_integer to 1
    End If
    If string_equals(type1, "Integer8") is equal to 1:
        Set is_type1_integer to 1
    End If
    If string_equals(type1, "Integer16") is equal to 1:
        Set is_type1_integer to 1
    End If
    If string_equals(type1, "Integer32") is equal to 1:
        Set is_type1_integer to 1
    End If
    If string_equals(type1, "Integer128") is equal to 1:
        Set is_type1_integer to 1
    End If
    If string_equals(type1, "Integer256") is equal to 1:
        Set is_type1_integer to 1
    End If
    If string_equals(type1, "Integer512") is equal to 1:
        Set is_type1_integer to 1
    End If
    If string_equals(type1, "UInteger8") is equal to 1:
        Set is_type1_integer to 1
    End If
    If string_equals(type1, "UInteger16") is equal to 1:
        Set is_type1_integer to 1
    End If
    If string_equals(type1, "UInteger32") is equal to 1:
        Set is_type1_integer to 1
    End If
    If string_equals(type1, "UInteger64") is equal to 1:
        Set is_type1_integer to 1
    End If
    If string_equals(type1, "UInteger128") is equal to 1:
        Set is_type1_integer to 1
    End If
    If string_equals(type1, "UInteger256") is equal to 1:
        Set is_type1_integer to 1
    End If
    If string_equals(type1, "UInteger512") is equal to 1:
        Set is_type1_integer to 1
    End If

    If string_equals(type2, "Integer") is equal to 1:
        Set is_type2_integer to 1
    End If
    If string_equals(type2, "Integer8") is equal to 1:
        Set is_type2_integer to 1
    End If
    If string_equals(type2, "Integer16") is equal to 1:
        Set is_type2_integer to 1
    End If
    If string_equals(type2, "Integer32") is equal to 1:
        Set is_type2_integer to 1
    End If
    If string_equals(type2, "Integer128") is equal to 1:
        Set is_type2_integer to 1
    End If
    If string_equals(type2, "Integer256") is equal to 1:
        Set is_type2_integer to 1
    End If
    If string_equals(type2, "Integer512") is equal to 1:
        Set is_type2_integer to 1
    End If
    If string_equals(type2, "UInteger8") is equal to 1:
        Set is_type2_integer to 1
    End If
    If string_equals(type2, "UInteger16") is equal to 1:
        Set is_type2_integer to 1
    End If
    If string_equals(type2, "UInteger32") is equal to 1:
        Set is_type2_integer to 1
    End If
    If string_equals(type2, "UInteger64") is equal to 1:
        Set is_type2_integer to 1
    End If
    If string_equals(type2, "UInteger128") is equal to 1:
        Set is_type2_integer to 1
    End If
    If string_equals(type2, "UInteger256") is equal to 1:
        Set is_type2_integer to 1
    End If
    If string_equals(type2, "UInteger512") is equal to 1:
        Set is_type2_integer to 1
    End If

    If is_type1_integer is equal to 1:
        If is_type2_integer is equal to 1:
            Return 1
        End If
    End If

    Note: Float types are compatible with each other
    If string_equals(type1, "Float") is equal to 1:
        If string_equals(type2, "Float64") is equal to 1:
            Return 1
        End If
    End If
    If string_equals(type1, "Float64") is equal to 1:
        If string_equals(type2, "Float") is equal to 1:
            Return 1
        End If
    End If

    Note: Incompatible
    Return 0
End Process

Process called "is_numeric_type" takes type_name as Integer returns Integer:
    Note: Check if type is numeric (Integer or Float)
    Note: Returns 1 if numeric, 0 otherwise

    If string_equals(type_name, "Integer") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Integer8") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Integer16") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Integer32") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Integer128") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Integer256") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Integer512") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "UInteger8") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "UInteger16") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "UInteger32") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "UInteger64") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "UInteger128") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "UInteger256") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "UInteger512") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Float") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Float16") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Float32") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Float64") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Float80") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Float128") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Decimal64") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Decimal128") is equal to 1:
        Return 1
    End If

    Return 0
End Process

Process called "is_integer_type" takes type_name as Integer returns Integer:
    Note: Check if type is an integer type
    Note: Returns 1 if integer type, 0 otherwise

    If string_equals(type_name, "Integer") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Integer8") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Integer16") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Integer32") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Integer128") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Integer256") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Integer512") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "UInteger8") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "UInteger16") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "UInteger32") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "UInteger64") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "UInteger128") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "UInteger256") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "UInteger512") is equal to 1:
        Return 1
    End If

    Return 0
End Process

Process called "is_float_type" takes type_name as Integer returns Integer:
    Note: Check if type is a floating point type
    Note: Returns 1 if float type, 0 otherwise

    If string_equals(type_name, "Float") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Float16") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Float32") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Float64") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Float80") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Float128") is equal to 1:
        Return 1
    End If

    Return 0
End Process

Process called "is_decimal_type" takes type_name as Integer returns Integer:
    Note: Check if type is a decimal type (for financial math)
    Note: Returns 1 if decimal type, 0 otherwise

    If string_equals(type_name, "Decimal64") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Decimal128") is equal to 1:
        Return 1
    End If

    Return 0
End Process

Process called "is_pointer_type" takes type_name as Integer returns Integer:
    Note: Check if type is a pointer type
    Note: Returns 1 if pointer type, 0 otherwise

    If string_equals(type_name, "Pointer") is equal to 1:
        Return 1
    End If

    Note: Check for struct pointers (StructName*)
    If string_ends_with(type_name, "*") is equal to 1:
        Return 1
    End If

    Note: Check for array pointers (Array<Type>)
    If string_starts_with(type_name, "Array<") is equal to 1:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Advanced Type Validation (Generics, Structs, Arrays, Function Pointers)
Note: ============================================================================

Process called "validate_generic_type" takes type_name as Integer returns Integer:
    Note: Validate generic type like Array<Integer> or Map<String, Integer>
    Note: Returns 1 if valid generic type, 0 otherwise

    Note: Check if contains angle brackets
    Let open_bracket_pos be string_index_of(type_name, "<")
    If open_bracket_pos is equal to -1:
        Return 0
    End If

    Let close_bracket_pos be string_index_of(type_name, ">")
    If close_bracket_pos is equal to -1:
        Return 0
    End If

    Note: Must have opening before closing
    If open_bracket_pos is greater than or equal to close_bracket_pos:
        Return 0
    End If

    Note: Extract base type (e.g., "Array" from "Array<Integer>")
    Let base_type be string_substring(type_name, 0, open_bracket_pos)

    Note: Validate known generic base types
    If string_equals(base_type, "Array") is equal to 1:
        Return 1
    End If
    If string_equals(base_type, "List") is equal to 1:
        Return 1
    End If
    If string_equals(base_type, "Map") is equal to 1:
        Return 1
    End If
    If string_equals(base_type, "Set") is equal to 1:
        Return 1
    End If
    If string_equals(base_type, "Optional") is equal to 1:
        Return 1
    End If

    Note: Unknown generic type
    Return 0
End Process

Process called "validate_struct_type" takes type_name as Integer returns Integer:
    Note: Validate struct type (user-defined or built-in structs)
    Note: Returns 1 if valid struct type, 0 otherwise
    Note: Structs must start with uppercase letter and contain only alphanumeric characters

    Let length be string_length(type_name)
    If length is equal to 0:
        Return 0
    End If

    Note: First character must be uppercase letter
    Let first_char be string_char_at(type_name, 0)
    If is_alpha_upper(first_char) is equal to 0:
        Return 0
    End If

    Note: Remaining characters must be alphanumeric
    Let i be 1
    While i is less than length:
        Let ch be string_char_at(type_name, i)
        If is_alphanumeric(ch) is equal to 0:
            Note: Not alphanumeric - check if it's a pointer (*)
            If ch is equal to 42:
                Note: Asterisk (*) for pointer is valid
                Return 1
            End If
            Return 0
        End If
        Set i to i plus 1
    End While

    Note: Valid struct name format
    Return 1
End Process

Process called "validate_array_type" takes type_name as Integer returns Integer:
    Note: Validate array type (either generic Array<T> or fixed-size [N]T)
    Note: Returns 1 if valid array type, 0 otherwise

    Note: Check for generic array (Array<...>)
    If string_starts_with(type_name, "Array<") is equal to 1:
        Return validate_generic_type(type_name)
    End If

    Note: Check for fixed-size array [N]Type
    If string_starts_with(type_name, "[") is equal to 1:
        Let close_bracket_pos be string_index_of(type_name, "]")
        If close_bracket_pos is greater than 0:
            Note: Extract size between brackets
            Let size_str be string_substring(type_name, 1, close_bracket_pos)
            Note: Size must be numeric
            Let size_length be string_length(size_str)
            Let i be 0
            While i is less than size_length:
                Let ch be string_char_at(size_str, i)
                If is_digit(ch) is equal to 0:
                    Return 0
                End If
                Set i to i plus 1
            End While
            Note: Valid fixed-size array
            Return 1
        End If
    End If

    Return 0
End Process

Process called "validate_function_pointer_type" takes type_name as Integer returns Integer:
    Note: Validate function pointer type like fn(Integer, String) -> Integer
    Note: Returns 1 if valid function pointer type, 0 otherwise

    Note: Must start with "fn"
    If string_starts_with(type_name, "fn") is equal to 0:
        Return 0
    End If

    Note: Must contain parentheses
    Let open_paren_pos be string_index_of(type_name, "(")
    If open_paren_pos is equal to -1:
        Return 0
    End If

    Let close_paren_pos be string_index_of(type_name, ")")
    If close_paren_pos is equal to -1:
        Return 0
    End If

    Note: Open paren must come before close paren
    If open_paren_pos is greater than or equal to close_paren_pos:
        Return 0
    End If

    Note: Check for return type arrow
    Let arrow_pos be string_index_of(type_name, "->")
    If arrow_pos is greater than 0:
        Note: Return type must exist after arrow
        Let type_name_length be string_length(type_name)
        If arrow_pos plus 2 is greater than or equal to type_name_length:
            Return 0
        End If
    End If

    Note: Valid function pointer type
    Return 1
End Process

Note: ============================================================================
Note: Helper String Functions (used by validation)
Note: ============================================================================

Process called "string_starts_with" takes str as Integer, prefix as Integer returns Integer:
    Note: Check if string starts with prefix
    Note: Returns 1 if starts with prefix, 0 otherwise

    Let str_length be string_length(str)
    Let prefix_length be string_length(prefix)

    If prefix_length is greater than str_length:
        Return 0
    End If

    Let i be 0
    While i is less than prefix_length:
        Let str_ch be string_char_at(str, i)
        Let prefix_ch be string_char_at(prefix, i)
        If str_ch is not equal to prefix_ch:
            Return 0
        End If
        Set i to i plus 1
    End While

    Return 1
End Process

Process called "string_ends_with" takes str as Integer, suffix as Integer returns Integer:
    Note: Check if string ends with suffix
    Note: Returns 1 if ends with suffix, 0 otherwise

    Let str_length be string_length(str)
    Let suffix_length be string_length(suffix)

    If suffix_length is greater than str_length:
        Return 0
    End If

    Let str_offset be str_length minus suffix_length
    Let i be 0
    While i is less than suffix_length:
        Let str_ch be string_char_at(str, str_offset plus i)
        Let suffix_ch be string_char_at(suffix, i)
        If str_ch is not equal to suffix_ch:
            Return 0
        End If
        Set i to i plus 1
    End While

    Return 1
End Process

Process called "string_index_of" takes str as Integer, search_str as Integer returns Integer:
    Note: Find index of first occurrence of search_str in str
    Note: Returns index if found, -1 if not found

    Let str_length be string_length(str)
    Let search_length be string_length(search_str)

    If search_length is greater than str_length:
        Return -1
    End If

    Let max_index be str_length minus search_length
    Let i be 0
    While i is less than or equal to max_index:
        Let match be 1
        Let j be 0
        While j is less than search_length:
            Let str_ch be string_char_at(str, i plus j)
            Let search_ch be string_char_at(search_str, j)
            If str_ch is not equal to search_ch:
                Set match to 0
            End If
            Set j to j plus 1
        End While

        If match is equal to 1:
            Return i
        End If

        Set i to i plus 1
    End While

    Return -1
End Process

Process called "string_substring" takes str as Integer, start as Integer, end_pos as Integer returns Integer:
    Note: Extract substring from str[start:end]
    Note: Returns pointer to new substring (caller must manage memory)
    Note: Uses allocate() from memory/layout.runa

    Let length be end_pos minus start
    If length is less than or equal to 0:
        Note: Return empty string
        Let empty be allocate(1)
        memory_set_byte(empty, 0, 0)
        Return empty
    End If

    Note: Allocate space for substring + null terminator
    Let result be allocate(length plus 1)
    If result is equal to 0:
        Return 0
    End If

    Let i be 0
    While i is less than length:
        Let ch be string_char_at(str, start plus i)
        memory_set_byte(result, i, ch)
        Set i to i plus 1
    End While

    Note: Null terminate
    memory_set_byte(result, length, 0)

    Return result
End Process
