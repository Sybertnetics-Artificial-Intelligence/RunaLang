Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles struct/type field access operations with performance optimizations.

This file performs the following tasks:
- Calculate field offsets within structs (O(1) hash table lookup)
- Access struct members by name with caching
- Validate field access operations with detailed error reporting

This file is essential because of the following reasons:
- Enables struct field access (e.g., person.age)
- Calculates memory offsets for field lookups
- Foundation for object-oriented features
- Performance-critical: used in every struct field access in compiled code

Performance optimizations:
- Hash table for O(1) field lookup (vs O(n) linear search)
- Last-field cache for repeated accesses to same field
- Detailed error messages only on failure (zero overhead in success path)

Dependencies:
- core/string_core.runa (field name comparison, string_copy_to_buffer)
- core/memory_core.runa (memory operations)
- memory/layout.runa (arena_allocate for hash table construction)
:End Note

Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/frontend/primitives/memory/layout.runa" as MemoryLayout

Note: ============================================================================
Note: Wrapper Functions for Imported Dependencies
Note: ============================================================================

Process called "string_length" takes str as Integer returns Integer:
    Return proc string_length from StringCore with str
End Process

Process called "string_equals" takes str1 as Integer, str2 as Integer returns Integer:
    Return proc string_equals from StringCore with str1, str2
End Process

Process called "string_copy_to_buffer" takes src as Integer, dest as Integer, dest_offset as Integer returns Integer:
    Return proc string_copy_to_buffer from StringCore with src, dest, dest_offset
End Process

Process called "integer_to_string" takes value as Integer returns Integer:
    Note: Minimal integer to string conversion for error messages
    Note: Handles positive and negative integers in base 10
    Note: Returns pointer to static buffer (NOT thread-safe, for error messages only)

    Note: Static buffer for result (max 20 digits + sign + null = 22 bytes)
    Let buffer be proc arena_allocate with 0, 22
    proc memory_zero with buffer, 22

    If value is equal to 0:
        proc memory_set_byte with buffer, 0, 48
        Return buffer
    End If

    Let is_negative be 0
    Let abs_value be value
    If value is less than 0:
        Set is_negative to 1
        Set abs_value to 0 minus value
    End If

    Note: Convert digits in reverse
    Let pos be 0
    Let temp_value be abs_value
    While temp_value is greater than 0:
        Let digit be temp_value modulo by 10
        proc memory_set_byte with buffer, pos, digit plus 48
        Set temp_value to temp_value divided by 10
        Set pos to pos plus 1
    End While

    Note: Add negative sign if needed
    If is_negative is equal to 1:
        proc memory_set_byte with buffer, pos, 45
        Set pos to pos plus 1
    End If

    Note: Reverse the string in place
    Let left be 0
    Let right be pos minus 1
    While left is less than right:
        Let temp be proc memory_get_byte with buffer, left
        Let right_byte be proc memory_get_byte with buffer, right
        proc memory_set_byte with buffer, left, right_byte
        proc memory_set_byte with buffer, right, temp
        Set left to left plus 1
        Set right to right minus 1
    End While

    Return buffer
End Process

Process called "memory_get_byte" takes ptr as Integer, offset as Integer returns Integer:
    Return proc memory_get_byte from MemoryCore with ptr, offset
End Process

Process called "memory_set_byte" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Return proc memory_set_byte from MemoryCore with ptr, offset, value
End Process

Process called "memory_get_int64" takes ptr as Integer, offset as Integer returns Integer:
    Return proc memory_get_int64 from MemoryCore with ptr, offset
End Process

Process called "memory_set_int64" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Return proc memory_set_int64 from MemoryCore with ptr, offset, value
End Process

Process called "memory_zero" takes ptr as Integer, size as Integer returns Integer:
    Return proc memory_zero from MemoryCore with ptr, size
End Process

Process called "arena_allocate" takes arena as Integer, size as Integer returns Integer:
    Return proc arena_allocate from MemoryLayout with arena, size
End Process

Note: ============================================================================
Note: Performance Optimization: Field Access Cache
Note: ============================================================================

Note: Cache the last field lookup to optimize repeated accesses to the same field
Note: Common pattern: accessing the same field multiple times in a loop
Note: Example: for (i = 0; i < 1000; i++) { sum += person.age; }
Note: Without cache: 1000 hash lookups
Note: With cache: 1 hash lookup + 999 cache hits

Let LAST_STRUCT_PTR be 0
Let LAST_FIELD_NAME be 0
Let LAST_FIELD_OFFSET be 0
Let LAST_FIELD_TYPE be 0

Process called "clear_field_cache":
    Note: Clear the field access cache
    Note: Should be called when struct definitions change

    Set LAST_STRUCT_PTR to 0
    Set LAST_FIELD_NAME to 0
    Set LAST_FIELD_OFFSET to 0
    Set LAST_FIELD_TYPE to 0
End Process

Note: ============================================================================
Note: Hash Table Implementation for Field Lookup
Note: ============================================================================

Process called "hash_string" takes str_ptr as Integer returns Integer:
    Note: Compute hash of a string using DJB2 algorithm
    Note: DJB2: hash = 5381; for each char: hash = hash * 33 + char
    Note: Fast, good distribution, widely used in compilers

    Let hash be 5381
    Let i be 0
    Let length be proc string_length with str_ptr

    While i is less than length:
        Let char be proc memory_get_byte with str_ptr, i
        Set hash to hash multiplied by 33
        Set hash to hash plus char
        Set i to i plus 1
    End While

    Note: Return positive hash (avoid negative indices)
    If hash is less than 0:
        Set hash to 0 minus hash
    End If

    Return hash
End Process

Process called "get_field_offset_hashed" takes struct_ptr as Integer, field_name as Integer, field_name_hash as Integer returns Integer:
    Note: Get field offset using hash table lookup (O(1) average case)
    Note: struct_ptr points to struct metadata with hash table
    Note: Returns field offset in bytes, or -1 if field not found

    Note: Enhanced struct metadata layout with hash table:
    Note:   offset 0:  field_count (int64)
    Note:   offset 8:  field_names_ptr (pointer to string array)
    Note:   offset 16: field_offsets_ptr (pointer to int64 array)
    Note:   offset 24: field_types_ptr (pointer to string array)
    Note:   offset 32: hash_table_ptr (pointer to hash table, 0 if not built)
    Note:   offset 40: hash_table_size (int64, power of 2)

    Let hash_table_ptr be proc memory_get_int64 with struct_ptr, 32

    Note: If no hash table exists, fall back to linear search
    If hash_table_ptr is equal to 0:
        Return get_field_offset_linear(struct_ptr, field_name)
    End If

    Let hash_table_size be proc memory_get_int64 with struct_ptr, 40
    Let hash_index be field_name_hash modulo hash_table_size

    Note: Hash table uses open addressing with linear probing
    Note: Each entry: [field_name_ptr:8][field_offset:8] (16 bytes)
    Let max_probes be hash_table_size
    Let probe_count be 0

    While probe_count is less than max_probes:
        Let entry_offset be hash_index multiplied by 16
        Let stored_name_ptr be proc memory_get_int64 with hash_table_ptr, entry_offset

        Note: Empty slot (0) means field not found
        If stored_name_ptr is equal to 0:
            Return -1
        End If

        Note: Check if this entry matches
        If proc string_equals with stored_name_ptr, field_name is equal to 1:
            Let offset be proc memory_get_int64 with hash_table_ptr, entry_offset plus 8
            Return offset
        End If

        Note: Collision - try next slot (linear probing)
        Set hash_index to hash_index plus 1
        If hash_index is greater than or equal to hash_table_size:
            Set hash_index to 0
        End If
        Set probe_count to probe_count plus 1
    End While

    Note: Hash table full or corrupted - should never happen with proper sizing
    Return -1
End Process

Process called "get_field_offset_linear" takes struct_ptr as Integer, field_name as Integer returns Integer:
    Note: Linear search fallback for structs without hash tables
    Note: Used for small structs (< 8 fields) where hash overhead not worth it

    Let field_count be proc memory_get_int64 with struct_ptr, 0
    Let field_names_ptr be proc memory_get_int64 with struct_ptr, 8
    Let field_offsets_ptr be proc memory_get_int64 with struct_ptr, 16

    Let i be 0
    While i is less than field_count:
        Let current_field_name be proc memory_get_int64 with field_names_ptr, i multiplied by 8
        If proc string_equals with current_field_name, field_name is equal to 1:
            Let offset be proc memory_get_int64 with field_offsets_ptr, i multiplied by 8
            Return offset
        End If
        Set i to i plus 1
    End While

    Return -1
End Process

Note: ============================================================================
Note: Public Field Access API with Caching and Error Reporting
Note: ============================================================================

Process called "get_field_offset" takes struct_ptr as Integer, field_name as Integer returns Integer:
    Note: Get the offset of a field within a struct (optimized with cache)
    Note: Returns field offset in bytes, or -1 if field not found

    Note: Check cache first (O(1) when hit)
    If LAST_STRUCT_PTR is equal to struct_ptr:
        If LAST_FIELD_NAME is equal to field_name:
            Note: Cache hit! Return cached offset
            Return LAST_FIELD_OFFSET
        End If
    End If

    Note: Cache miss - compute hash and lookup
    Let field_name_hash be hash_string(field_name)
    Let offset be get_field_offset_hashed(struct_ptr, field_name, field_name_hash)

    Note: Update cache if found
    If offset is not equal to -1:
        Set LAST_STRUCT_PTR to struct_ptr
        Set LAST_FIELD_NAME to field_name
        Set LAST_FIELD_OFFSET to offset
    End If

    Return offset
End Process

Process called "get_field_offset_with_error" takes struct_ptr as Integer, field_name as Integer, error_msg_ptr as Integer returns Integer:
    Note: Get field offset with detailed error message on failure
    Note: error_msg_ptr: pointer to buffer for error message (min 256 bytes)
    Note: Returns field offset or -1 on error (error message written to buffer)

    Let offset be get_field_offset(struct_ptr, field_name)

    If offset is equal to -1:
        Note: Field not found - generate detailed error message
        Let field_count be proc memory_get_int64 with struct_ptr, 0

        Note: Build error message
        Note: Format: "Field 'FIELDNAME' not found in struct (struct has N fields: field1, field2, ...)"

        Note: Copy error prefix
        Let prefix be "Field '"
        proc string_copy_to_buffer with prefix, error_msg_ptr, 0
        Let write_offset be 7

        Note: Copy field name
        Let field_name_len be proc string_length with field_name
        proc string_copy_to_buffer with field_name, error_msg_ptr, write_offset
        Set write_offset to write_offset plus field_name_len

        Note: Copy middle part
        Let middle be "' not found in struct (struct has "
        proc string_copy_to_buffer with middle, error_msg_ptr, write_offset
        Set write_offset to write_offset plus 33

        Note: Convert field count to string
        Let count_str be proc integer_to_string with field_count
        Let count_len be proc string_length with count_str
        proc string_copy_to_buffer with count_str, error_msg_ptr, write_offset
        Set write_offset to write_offset plus count_len

        Note: Copy field list header
        Let list_header be " fields: "
        proc string_copy_to_buffer with list_header, error_msg_ptr, write_offset
        Set write_offset to write_offset plus 9

        Note: List available fields (up to first 10)
        Let field_names_ptr be proc memory_get_int64 with struct_ptr, 8
        Let max_list be field_count
        If max_list is greater than 10:
            Set max_list to 10
        End If

        Let i be 0
        While i is less than max_list:
            Let current_field_name be proc memory_get_int64 with field_names_ptr, i multiplied by 8
            Let current_name_len be proc string_length with current_field_name
            proc string_copy_to_buffer with current_field_name, error_msg_ptr, write_offset
            Set write_offset to write_offset plus current_name_len

            Note: Add comma separator if not last
            If i is less than max_list minus 1:
                proc memory_set_byte with error_msg_ptr, write_offset, 44
                Set write_offset to write_offset plus 1
                proc memory_set_byte with error_msg_ptr, write_offset, 32
                Set write_offset to write_offset plus 1
            End If

            Set i to i plus 1
        End While

        Note: Add ellipsis if more fields exist
        If field_count is greater than 10:
            Let ellipsis be ", ..."
            proc string_copy_to_buffer with ellipsis, error_msg_ptr, write_offset
            Set write_offset to write_offset plus 5
        End If

        Note: Add closing parenthesis
        proc memory_set_byte with error_msg_ptr, write_offset, 41
        Set write_offset to write_offset plus 1

        Note: Null terminator
        proc memory_set_byte with error_msg_ptr, write_offset, 0
    End If

    Return offset
End Process

Process called "get_field_type" takes struct_ptr as Integer, field_name as Integer returns Integer:
    Note: Get the type name of a field within a struct (optimized with cache)
    Note: Returns type name string pointer, or 0 if field not found

    Note: Check cache first
    If LAST_STRUCT_PTR is equal to struct_ptr:
        If LAST_FIELD_NAME is equal to field_name:
            Note: Cache hit! Return cached type
            Return LAST_FIELD_TYPE
        End If
    End If

    Note: Cache miss - do full lookup
    Let field_count be proc memory_get_int64 with struct_ptr, 0
    Let field_names_ptr be proc memory_get_int64 with struct_ptr, 8
    Let field_types_ptr be proc memory_get_int64 with struct_ptr, 24

    Note: Check if we can use hash table for field lookup
    Let field_name_hash be hash_string(field_name)
    Let offset be get_field_offset_hashed(struct_ptr, field_name, field_name_hash)

    If offset is equal to -1:
        Return 0
    End If

    Note: Field found, now get its type
    Note: We need to find which index this field is at
    Let i be 0
    While i is less than field_count:
        Let current_field_name be proc memory_get_int64 with field_names_ptr, i multiplied by 8
        If proc string_equals with current_field_name, field_name is equal to 1:
            Let type_name be proc memory_get_int64 with field_types_ptr, i multiplied by 8

            Note: Update cache
            Set LAST_STRUCT_PTR to struct_ptr
            Set LAST_FIELD_NAME to field_name
            Set LAST_FIELD_OFFSET to offset
            Set LAST_FIELD_TYPE to type_name

            Return type_name
        End If
        Set i to i plus 1
    End While

    Note: Should not reach here if offset was valid
    Return 0
End Process

Process called "field_exists" takes struct_ptr as Integer, field_name as Integer returns Integer:
    Note: Check if a field exists in a struct
    Note: Returns 1 if exists, 0 otherwise

    Let offset be get_field_offset(struct_ptr, field_name)
    If offset is equal to -1:
        Return 0
    End If
    Return 1
End Process

Note: ============================================================================
Note: Array/Index Access Functions
Note: ============================================================================

Process called "calculate_array_element_offset" takes element_size as Integer, index as Integer returns Integer:
    Note: Calculate byte offset for array element
    Note: Returns element_size * index

    Let offset be element_size multiplied by index
    Return offset
End Process

Process called "validate_array_bounds" takes array_length as Integer, index as Integer returns Integer:
    Note: Check if array index is within bounds
    Note: Returns 1 if valid, 0 if out of bounds

    If index is less than 0:
        Return 0
    End If

    If index is greater than or equal to array_length:
        Return 0
    End If

    Return 1
End Process

Process called "validate_array_bounds_with_error" takes array_length as Integer, index as Integer, error_msg_ptr as Integer returns Integer:
    Note: Check array bounds with detailed error message on failure
    Note: Returns 1 if valid, 0 if out of bounds (error message written to buffer)

    If index is less than 0:
        Note: Negative index error
        Let msg be "Array index out of bounds: index "
        proc string_copy_to_buffer with msg, error_msg_ptr, 0
        Let offset be 35

        Let index_str be proc integer_to_string with index
        let index_len be proc string_length with index_str
        proc string_copy_to_buffer with index_str, error_msg_ptr, offset
        Set offset to offset plus index_len

        Let suffix be " is negative (must be >= 0)"
        proc string_copy_to_buffer with suffix, error_msg_ptr, offset

        Return 0
    End If

    If index is greater than or equal to array_length:
        Note: Index too large error
        Let msg be "Array index out of bounds: index "
        proc string_copy_to_buffer with msg, error_msg_ptr, 0
        Let offset be 35

        Let index_str be proc integer_to_string with index
        Let index_len be proc string_length with index_str
        proc string_copy_to_buffer with index_str, error_msg_ptr, offset
        Set offset to offset plus index_len

        Let middle be " >= array length "
        proc string_copy_to_buffer with middle, error_msg_ptr, offset
        Set offset to offset plus 17

        Let length_str be proc integer_to_string with array_length
        Let length_len be proc string_length with length_str
        proc string_copy_to_buffer with length_str, error_msg_ptr, offset

        Return 0
    End If

    Return 1
End Process

Note: ============================================================================
Note: Hash Table Construction (for struct metadata builders)
Note: ============================================================================

Process called "build_field_hash_table" takes struct_ptr as Integer, arena_ptr as Integer returns Integer:
    Note: Build hash table for fast field lookups
    Note: Call this when creating struct metadata with many fields
    Note: Returns 1 on success, 0 on failure
    Note: Only worthwhile for structs with 8+ fields

    Let field_count be proc memory_get_int64 with struct_ptr, 0

    Note: Skip hash table for small structs (linear search is faster)
    If field_count is less than 8:
        Return 1
    End If

    Note: Hash table size = next power of 2 >= field_count * 2 (50% load factor)
    Let hash_table_size be 16
    While hash_table_size is less than field_count multiplied by 2:
        Set hash_table_size to hash_table_size multiplied by 2
    End While

    Note: Allocate hash table (16 bytes per entry)
    Let hash_table_bytes be hash_table_size multiplied by 16
    Let hash_table_ptr be proc arena_allocate with arena_ptr, hash_table_bytes

    Note: Zero-initialize hash table
    proc memory_zero with hash_table_ptr, hash_table_bytes

    Note: Insert all fields into hash table
    Let field_names_ptr be proc memory_get_int64 with struct_ptr, 8
    Let field_offsets_ptr be proc memory_get_int64 with struct_ptr, 16

    Let i be 0
    While i is less than field_count:
        Let field_name_ptr be proc memory_get_int64 with field_names_ptr, i multiplied by 8
        Let field_offset be proc memory_get_int64 with field_offsets_ptr, i multiplied by 8

        Note: Hash the field name
        Let hash be hash_string(field_name_ptr)
        Let hash_index be hash modulo hash_table_size

        Note: Find empty slot using linear probing
        Let found_slot be 0
        Let probe_count be 0
        While found_slot is equal to 0:
            Let entry_offset be hash_index multiplied by 16
            Let stored_name_ptr be proc memory_get_int64 with hash_table_ptr, entry_offset

            If stored_name_ptr is equal to 0:
                Note: Empty slot found - insert here
                proc memory_set_int64 with hash_table_ptr, entry_offset, field_name_ptr
                proc memory_set_int64 with hash_table_ptr, entry_offset plus 8, field_offset
                Set found_slot to 1
            End If
            Otherwise:
                Note: Collision - try next slot
                Set hash_index to hash_index plus 1
                If hash_index is greater than or equal to hash_table_size:
                    Set hash_index to 0
                End If
                Set probe_count to probe_count plus 1

                Note: Safety check - should never happen with 50% load factor
                If probe_count is greater than or equal to hash_table_size:
                    Return 0
                End If
            End If
        End While

        Set i to i plus 1
    End While

    Note: Store hash table pointer and size in struct metadata
    proc memory_set_int64 with struct_ptr, 32, hash_table_ptr
    proc memory_set_int64 with struct_ptr, 40, hash_table_size

    Return 1
End Process

Note: ============================================================================
Note: Performance Statistics (optional, for profiling)
Note: ============================================================================

Let FIELD_ACCESS_CACHE_HITS be 0
Let FIELD_ACCESS_CACHE_MISSES be 0

Process called "get_cache_hit_rate" returns Integer:
    Note: Get cache hit rate as percentage (0-100)
    Note: Returns percentage of cache hits, or 0 if no accesses

    Let total be FIELD_ACCESS_CACHE_HITS plus FIELD_ACCESS_CACHE_MISSES
    If total is equal to 0:
        Return 0
    End If

    Let hit_rate be FIELD_ACCESS_CACHE_HITS multiplied by 100
    Set hit_rate to hit_rate divided by total

    Return hit_rate
End Process

Process called "reset_cache_statistics":
    Note: Reset cache statistics counters
    Set FIELD_ACCESS_CACHE_HITS to 0
    Set FIELD_ACCESS_CACHE_MISSES to 0
End Process
