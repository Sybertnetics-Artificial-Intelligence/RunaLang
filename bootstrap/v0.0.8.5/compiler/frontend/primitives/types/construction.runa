Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles type instance construction.

This file performs the following tasks:
- Construct struct/type instances
- Initialize struct fields
- Create arrays and collections

This file is essential because of the following reasons:
- Enables creating struct instances
- Manages memory allocation for types
- Initializes type instances properly

Dependencies:
- memory/layout.runa (allocation)
- intrinsics/sizeof.runa (type sizes)
- types/compiler_internals.runa (alignment)
- core/memory_core.runa (memory operations)
:End Note

Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/frontend/primitives/memory/layout.runa" as MemoryLayout

Note: ============================================================================
Note: Struct Construction Functions
Note: ============================================================================

Process called "create_struct_instance" takes size as Integer returns Integer:
    Note: Allocate memory for a struct instance
    Note: Returns pointer to allocated struct, or 0 on failure

    Let instance_ptr be proc allocate from MemoryLayout with size
    Return instance_ptr
End Process

Process called "initialize_struct_field" takes struct_ptr as Integer, field_offset as Integer, value as Integer, field_size as Integer:
    Note: Initialize a struct field with a value
    Note: field_size determines how many bytes to write (1, 2, 4, 8, 16)

    If field_size is equal to 1:
        proc memory_set_byte from MemoryCore with struct_ptr, field_offset, value
    End If

    If field_size is equal to 2:
        proc memory_set_int16 from MemoryCore with struct_ptr, field_offset, value
    End If

    If field_size is equal to 4:
        proc memory_set_int32 from MemoryCore with struct_ptr, field_offset, value
    End If

    If field_size is equal to 8:
        proc memory_set_int64 from MemoryCore with struct_ptr, field_offset, value
    End If

    If field_size is equal to 16:
        Note: 128-bit value - value parameter is pointer to 16-byte buffer
        Let low be proc memory_get_int64 from MemoryCore with value, 0
        Let high be proc memory_get_int64 from MemoryCore with value, 8
        proc memory_set_int64 from MemoryCore with struct_ptr, field_offset, low
        proc memory_set_int64 from MemoryCore with struct_ptr, field_offset plus 8, high
    End If
End Process

Process called "zero_initialize_struct" takes struct_ptr as Integer, size as Integer:
    Note: Zero-initialize all bytes in a struct
    Note: Uses optimized memory_zero from memory_core for performance

    proc memory_zero from MemoryCore with struct_ptr, size
End Process

Note: ============================================================================
Note: Array Construction Functions
Note: ============================================================================

Process called "create_array" takes element_size as Integer, element_count as Integer returns Integer:
    Note: Allocate memory for an array
    Note: Returns pointer to array, or 0 on failure

    Let total_size be element_size multiplied by element_count
    Let array_ptr be proc allocate from MemoryLayout with total_size
    Return array_ptr
End Process

Process called "initialize_array_element" takes array_ptr as Integer, element_index as Integer, element_size as Integer, value as Integer:
    Note: Initialize an array element
    Note: Calculates offset and writes value

    Let offset be element_index multiplied by element_size
    proc initialize_struct_field with array_ptr, offset, value, element_size
End Process

Process called "zero_initialize_array" takes array_ptr as Integer, element_size as Integer, element_count as Integer:
    Note: Zero-initialize entire array

    Let total_size be element_size multiplied by element_count
    proc zero_initialize_struct with array_ptr, total_size
End Process

Note: ============================================================================
Note: Copy Construction and Destruction
Note: ============================================================================

Process called "copy_struct_shallow" takes src_ptr as Integer, size as Integer returns Integer:
    Note: Shallow copy - copies bytes but not pointed-to data
    Note: Returns pointer to new struct, or 0 on failure
    Note: Uses optimized memory_copy from memory_core for performance

    Let dest_ptr be proc allocate from MemoryLayout with size
    If dest_ptr is equal to 0:
        Return 0
    End If

    proc memory_copy from MemoryCore with dest_ptr, src_ptr, size

    Return dest_ptr
End Process

Process called "copy_struct_deep" takes src_ptr as Integer, field_offsets as Integer, field_sizes as Integer, field_is_pointer as Integer, field_count as Integer, total_size as Integer returns Integer:
    Note: Deep copy - recursively copies pointed-to data
    Note: field_offsets: array of field offsets
    Note: field_sizes: array of field sizes
    Note: field_is_pointer: array of flags (1=pointer field, 0=value field)
    Note: Returns pointer to new struct, or 0 on failure
    Note: Uses optimized memory_copy from memory_core for performance

    Let dest_ptr be proc allocate from MemoryLayout with total_size
    If dest_ptr is equal to 0:
        Return 0
    End If

    Note: First do shallow copy using optimized memory_copy
    proc memory_copy from MemoryCore with dest_ptr, src_ptr, total_size

    Note: Then deep-copy pointer fields
    Let i be 0
    While i is less than field_count:
        Let is_ptr be proc memory_get_int64 from MemoryCore with field_is_pointer, i multiplied by 8
        If is_ptr is equal to 1:
            Let offset be proc memory_get_int64 from MemoryCore with field_offsets, i multiplied by 8
            Let size be proc memory_get_int64 from MemoryCore with field_sizes, i multiplied by 8
            Let ptr_value be proc memory_get_int64 from MemoryCore with src_ptr, offset

            If ptr_value is not equal to 0:
                Note: Recursively copy pointed-to data
                Let copied_ptr be proc copy_struct_shallow with ptr_value, size
                proc memory_set_int64 from MemoryCore with dest_ptr, offset, copied_ptr
            End If
        End If
        Set i to i plus 1
    End While

    Return dest_ptr
End Process

Process called "destroy_struct" takes struct_ptr as Integer:
    Note: Destroy a struct instance (calls deallocate)

    If struct_ptr is not equal to 0:
        proc deallocate from MemoryLayout with struct_ptr
    End If
End Process

Process called "destroy_struct_deep" takes struct_ptr as Integer, field_offsets as Integer, field_is_pointer as Integer, field_count as Integer:
    Note: Deep destroy - recursively destroys pointed-to data
    Note: field_offsets: array of field offsets
    Note: field_is_pointer: array of flags (1=pointer field, 0=value field)

    If struct_ptr is equal to 0:
        Return
    End If

    Note: First destroy pointer fields
    Let i be 0
    While i is less than field_count:
        Let is_ptr be proc memory_get_int64 from MemoryCore with field_is_pointer, i multiplied by 8
        If is_ptr is equal to 1:
            Let offset be proc memory_get_int64 from MemoryCore with field_offsets, i multiplied by 8
            Let ptr_value be proc memory_get_int64 from MemoryCore with struct_ptr, offset

            If ptr_value is not equal to 0:
                Note: Recursively destroy pointed-to data
                proc deallocate from MemoryLayout with ptr_value
            End If
        End If
        Set i to i plus 1
    End While

    Note: Finally destroy the struct itself
    proc deallocate from MemoryLayout with struct_ptr
End Process

Note: ============================================================================
Note: Generic Type Construction
Note: ============================================================================

Process called "create_generic_array" takes element_size as Integer, capacity as Integer returns Integer:
    Note: Create generic array with metadata header
    Note: Layout: [capacity][count][elements...]
    Note: Returns pointer to array header, or 0 on failure

    Let header_size be 16
    Let elements_size be element_size multiplied by capacity
    Let total_size be header_size plus elements_size

    Let array_ptr be proc allocate from MemoryLayout with total_size
    If array_ptr is equal to 0:
        Return 0
    End If

    proc memory_set_int64 from MemoryCore with array_ptr, 0, capacity
    proc memory_set_int64 from MemoryCore with array_ptr, 8, 0

    Return array_ptr
End Process

Process called "generic_array_get_capacity" takes array_ptr as Integer returns Integer:
    Note: Get array capacity

    Return proc memory_get_int64 from MemoryCore with array_ptr, 0
End Process

Process called "generic_array_get_count" takes array_ptr as Integer returns Integer:
    Note: Get current array element count

    Return proc memory_get_int64 from MemoryCore with array_ptr, 8
End Process

Process called "generic_array_set_count" takes array_ptr as Integer, count as Integer:
    Note: Set current array element count

    proc memory_set_int64 from MemoryCore with array_ptr, 8, count
End Process

Process called "generic_array_get_element_ptr" takes array_ptr as Integer, element_size as Integer, index as Integer returns Integer:
    Note: Get pointer to array element at index
    Note: Returns pointer to element, or 0 if index out of bounds

    Let capacity be proc generic_array_get_capacity with array_ptr
    If index is less than 0:
        Return 0
    End If
    If index is greater than or equal to capacity:
        Return 0
    End If

    Let header_size be 16
    Let offset be header_size plus (index multiplied by element_size)
    Let element_ptr be array_ptr plus offset

    Return element_ptr
End Process

Note: ============================================================================
Note: Type Descriptor Construction
Note: ============================================================================

Process called "create_type_descriptor" takes type_name as Integer, size as Integer, alignment as Integer returns Integer:
    Note: Create a type descriptor for runtime type information
    Note: Type descriptor layout:
    Note:   offset 0: type_name (string pointer)
    Note:   offset 8: size (int64)
    Note:   offset 16: alignment (int64)

    Let descriptor_ptr be proc allocate from MemoryLayout with 24

    If descriptor_ptr is not equal to 0:
        proc memory_set_int64 from MemoryCore with descriptor_ptr, 0, type_name
        proc memory_set_int64 from MemoryCore with descriptor_ptr, 8, size
        proc memory_set_int64 from MemoryCore with descriptor_ptr, 16, alignment
    End If

    Return descriptor_ptr
End Process
