Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles string primitive type and string operations.

This file performs the following tasks:
- Process string values and string type handling
- Handle string operations and string manipulation
- Manage string interpolation and string formatting - v0.0.8.5 feature
- Process string optimization and string constant folding

This file is essential because of the following reasons:
- String primitives are fundamental to text processing and string manipulation
- String interpolation is a key v0.0.8.5 feature requirement
- Proper string handling ensures correct text processing and string operations

This file consists of the following functions/features/operation types:
- String value processing and string type handling
- String operations and string manipulation
- String interpolation and string formatting processing
- String optimization and string constant folding

Dependencies:
- Imports core/string_core.runa (Layer 0 basic string functions)
- Imports core/memory_core.runa (Layer 0 memory operations)
- Imports memory/layout.runa (Layer 1 allocate/deallocate with free list)
:End Note

Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
Import "compiler/frontend/primitives/memory/layout.runa" as Layout

Note: ============================================================================
Note: Higher-Level String Operations (Layer 2)
Note: ============================================================================

Note: This file provides Layer 2 string operations that depend on memory
Note: allocation. Layer 0 string_core.runa provides basic operations like
Note: string_equals, string_length that don't require allocation.

Note: Layer 2 adds:
Note: - string_concat (allocates result)
Note: - string_duplicate (allocates copy)
Note: - string_substring (allocates substring)
Note: - string_interpolate (formatted strings)
Note: - integer_to_string (conversion)
Note: ============================================================================

Process called "string_concat" takes str1 as Integer, str2 as Integer returns Integer:
    Note: Concatenate two strings into a new allocated string
    Note: Returns pointer to new string, or 0 on failure
    Note: Caller is responsible for deallocating result

    Note: Handle NULL inputs
    If str1 is equal to 0:
        If str2 is equal to 0:
            Return 0  Note: Both NULL
        End If
        Return proc string_duplicate with str2  Note: Return copy of str2
    End If

    If str2 is equal to 0:
        Return proc string_duplicate with str1  Note: Return copy of str1
    End If

    Note: Calculate lengths
    Let len1 be proc string_length from StringCore with str1
    Let len2 be proc string_length from StringCore with str2
    Let total_len be len1 plus len2

    Note: Allocate buffer (length + null terminator)
    Let result be proc allocate from Layout with total_len plus 1
    If result is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Copy first string
    Let i be 0
    While i is less than len1:
        Let byte be proc memory_get_byte from Memory with str1, i
        proc memory_set_byte from Memory with result, i, byte
        Set i to i plus 1
    End While

    Note: Copy second string
    Set i to 0
    While i is less than len2:
        Let byte be proc memory_get_byte from Memory with str2, i
        Let offset be len1 plus i
        proc memory_set_byte from Memory with result, offset, byte
        Set i to i plus 1
    End While

    Note: Add null terminator
    proc memory_set_byte from Memory with result, total_len, 0

    Return result
End Process

Process called "string_duplicate" takes str as Integer returns Integer:
    Note: Create a duplicate copy of a string
    Note: Returns pointer to new string, or 0 on failure
    Note: Caller is responsible for deallocating result

    If str is equal to 0:
        Return 0  Note: NULL input
    End If

    Let len be proc string_length from StringCore with str
    Let result be proc allocate from Layout with len plus 1
    If result is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Copy all bytes including null terminator
    Let i be 0
    While i is less than or equal to len:
        Let byte be proc memory_get_byte from Memory with str, i
        proc memory_set_byte from Memory with result, i, byte
        Set i to i plus 1
    End While

    Return result
End Process

Process called "string_substring" takes str as Integer, start as Integer, length as Integer returns Integer:
    Note: Extract a substring from a string
    Note: Returns pointer to new string, or 0 on failure
    Note: Caller is responsible for deallocating result

    If str is equal to 0:
        Return 0  Note: NULL input
    End If

    If start is less than 0:
        Return 0  Note: Invalid start
    End If

    If length is less than 0:
        Return 0  Note: Invalid length
    End If

    Let str_len be proc string_length from StringCore with str

    Note: Clamp start to valid range
    If start is greater than str_len:
        Set start to str_len
    End If

    Note: Clamp length to available characters
    Let available be str_len minus start
    If length is greater than available:
        Set length to available
    End If

    Note: Allocate result
    Let result be proc allocate from Layout with length plus 1
    If result is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Copy substring
    Let i be 0
    While i is less than length:
        Let src_offset be start plus i
        Let byte be proc memory_get_byte from Memory with str, src_offset
        proc memory_set_byte from Memory with result, i, byte
        Set i to i plus 1
    End While

    Note: Add null terminator
    proc memory_set_byte from Memory with result, length, 0

    Return result
End Process

Note: ============================================================================
Note: String Conversion Functions
Note: ============================================================================

Process called "integer_to_string" takes value as Integer returns Integer:
    Note: Convert integer to string representation
    Note: Returns pointer to new string, or 0 on failure
    Note: Supports negative numbers

    Note: Handle zero special case
    If value is equal to 0:
        Let result be proc allocate from Layout with 2  Note: "0" + null
        If result is equal to 0:
            Return 0
        End If
        proc memory_set_byte from Memory with result, 0, 48  Note: ASCII '0'
        proc memory_set_byte from Memory with result, 1, 0   Note: Null terminator
        Return result
    End If

    Note: Handle negative numbers
    Let is_negative be 0
    If value is less than 0:
        Set is_negative to 1
        Set value to 0 minus value  Note: Make positive
    End If

    Note: Count digits
    Let temp be value
    Let digit_count be 0
    While temp is greater than 0:
        Set digit_count to digit_count plus 1
        Set temp to temp divided by 10
    End While

    Note: Calculate total length (digits + optional minus + null)
    Let total_len be digit_count plus is_negative plus 1

    Note: Allocate buffer
    Let result be proc allocate from Layout with total_len
    If result is equal to 0:
        Return 0
    End If

    Note: Add minus sign if negative
    Let write_pos be 0
    If is_negative is equal to 1:
        proc memory_set_byte from Memory with result, 0, 45  Note: ASCII '-'
        Set write_pos to 1
    End If

    Note: Convert digits (write from end to beginning)
    Let pos be total_len minus 2  Note: Start before null terminator
    Set temp to value

    While temp is greater than 0:
        Let digit be temp modulo by 10
        Let ascii_digit be digit plus 48  Note: ASCII '0' is 48
        proc memory_set_byte from Memory with result, pos, ascii_digit
        Set temp to temp divided by 10
        Set pos to pos minus 1
    End While

    Note: Add null terminator
    proc memory_set_byte from Memory with result, total_len minus 1, 0

    Return result
End Process

Process called "string_to_integer" takes str as Integer returns Integer:
    Note: Convert string to integer
    Note: Returns integer value, or 0 if invalid
    Note: WARNING: Cannot distinguish between "0" and invalid input

    If str is equal to 0:
        Return 0
    End If

    Let len be proc string_length from StringCore with str
    If len is equal to 0:
        Return 0
    End If

    Note: Check for negative sign
    Let is_negative be 0
    Let start_pos be 0
    Let first_char be proc memory_get_byte from Memory with str, 0
    If first_char is equal to 45:  Note: ASCII '-'
        Set is_negative to 1
        Set start_pos to 1
    End If

    Note: Convert digits
    Let result be 0
    Let i be start_pos

    While i is less than len:
        Let ch be proc memory_get_byte from Memory with str, i

        Note: Check if valid digit (ASCII 48-57 for '0'-'9')
        If ch is less than 48:
            Return 0  Note: Invalid character
        End If
        If ch is greater than 57:
            Return 0  Note: Invalid character
        End If

        Let digit be ch minus 48
        Set result to result multiplied by 10
        Set result to result plus digit
        Set i to i plus 1
    End While

    Note: Apply negative sign
    If is_negative is equal to 1:
        Set result to 0 minus result
    End If

    Return result
End Process

Note: ============================================================================
Note: String Literal Table Management (for codegen)
Note: ============================================================================

Note: These functions are used by codegen to manage string literals
Note: in the generated assembly. Each string literal gets a unique label.

Note: StringLiteral structure (16 bytes):
Note:   offset 0: value (pointer to string, 8 bytes)
Note:   offset 8: label_id (integer ID for .STR<id>, 8 bytes)

Process called "string_literal_create" takes value as Integer, label_id as Integer returns Integer:
    Note: Create a StringLiteral structure
    Note: Returns pointer to structure, or 0 on failure

    Let literal be proc allocate from Layout with 16
    If literal is equal to 0:
        Return 0  Note: Allocation failed
    End If

    proc memory_set_int64 from Memory with literal, 0, value
    proc memory_set_int64 from Memory with literal, 8, label_id

    Return literal
End Process

Process called "string_literal_get_value" takes literal as Integer returns Integer:
    Note: Get the string value from a StringLiteral

    If literal is equal to 0:
        Return 0
    End If

    Return proc memory_get_int64 from Memory with literal, 0
End Process

Process called "string_literal_get_label_id" takes literal as Integer returns Integer:
    Note: Get the label ID from a StringLiteral

    If literal is equal to 0:
        Return 0
    End If

    Return proc memory_get_int64 from Memory with literal, 8
End Process

Note: ============================================================================
Note: String Comparison and Search
Note: ============================================================================

Process called "string_starts_with" takes str as Integer, prefix as Integer returns Integer:
    Note: Check if string starts with prefix
    Note: Returns 1 if true, 0 if false

    If str is equal to 0:
        Return 0
    End If
    If prefix is equal to 0:
        Return 0
    End If

    Let str_len be proc string_length from StringCore with str
    Let prefix_len be proc string_length from StringCore with prefix

    If prefix_len is greater than str_len:
        Return 0  Note: Prefix longer than string
    End If

    Let i be 0
    While i is less than prefix_len:
        Let str_byte be proc memory_get_byte from Memory with str, i
        Let prefix_byte be proc memory_get_byte from Memory with prefix, i
        If str_byte is not equal to prefix_byte:
            Return 0  Note: Mismatch
        End If
        Set i to i plus 1
    End While

    Return 1  Note: Match
End Process

Process called "string_ends_with" takes str as Integer, suffix as Integer returns Integer:
    Note: Check if string ends with suffix
    Note: Returns 1 if true, 0 if false

    If str is equal to 0:
        Return 0
    End If
    If suffix is equal to 0:
        Return 0
    End If

    Let str_len be proc string_length from StringCore with str
    Let suffix_len be proc string_length from StringCore with suffix

    If suffix_len is greater than str_len:
        Return 0  Note: Suffix longer than string
    End If

    Let start_offset be str_len minus suffix_len
    Let i be 0

    While i is less than suffix_len:
        Let str_pos be start_offset plus i
        Let str_byte be proc memory_get_byte from Memory with str, str_pos
        Let suffix_byte be proc memory_get_byte from Memory with suffix, i
        If str_byte is not equal to suffix_byte:
            Return 0  Note: Mismatch
        End If
        Set i to i plus 1
    End While

    Return 1  Note: Match
End Process

Process called "string_index_of" takes str as Integer, substring as Integer returns Integer:
    Note: Find first occurrence of substring in string
    Note: Returns index of first match, or -1 if not found

    If str is equal to 0:
        Return -1
    End If
    If substring is equal to 0:
        Return -1
    End If

    Let str_len be proc string_length from StringCore with str
    Let sub_len be proc string_length from StringCore with substring

    If sub_len is greater than str_len:
        Return -1  Note: Substring longer than string
    End If

    If sub_len is equal to 0:
        Return 0  Note: Empty substring matches at start
    End If

    Let search_end be str_len minus sub_len
    Let i be 0

    While i is less than or equal to search_end:
        Note: Check if substring matches at position i
        Let matches be 1
        Let j be 0

        While j is less than sub_len:
            Let str_pos be i plus j
            Let str_byte be proc memory_get_byte from Memory with str, str_pos
            Let sub_byte be proc memory_get_byte from Memory with substring, j
            If str_byte is not equal to sub_byte:
                Set matches to 0
                Set j to sub_len  Note: Break inner loop
            End If
            Set j to j plus 1
        End While

        If matches is equal to 1:
            Return i  Note: Found at position i
        End If

        Set i to i plus 1
    End While

    Return -1  Note: Not found
End Process

Note: ============================================================================
Note: String Interpolation Support (v0.0.8.5 feature)
Note: ============================================================================

Note: InterpolationPart structure (24 bytes):
Note:   offset 0:  is_literal (1 if literal string, 0 if expression, 8 bytes)
Note:   offset 8:  value (pointer to string or expression result, 8 bytes)
Note:   offset 16: next (pointer to next part, or 0 if last, 8 bytes)

Process called "interpolation_part_create" takes is_literal as Integer, value as Integer returns Integer:
    Note: Create interpolation part for building formatted string
    Note: Used internally by string interpolation

    Let part be proc allocate from Layout with 24
    If part is equal to 0:
        Return 0
    End If

    proc memory_set_int64 from Memory with part, 0, is_literal
    proc memory_set_int64 from Memory with part, 8, value
    proc memory_set_int64 from Memory with part, 16, 0  Note: next = NULL

    Return part
End Process

Process called "string_interpolate" takes parts as Integer returns Integer:
    Note: Build string from interpolation parts (linked list)
    Note: parts: linked list of InterpolationPart structures
    Note: Returns pointer to final string, or 0 on failure
    Note: Caller is responsible for deallocating result

    If parts is equal to 0:
        Note: Empty interpolation - return empty string
        Let result be proc allocate from Layout with 1
        If result is equal to 0:
            Return 0
        End If
        proc memory_set_byte from Memory with result, 0, 0
        Return result
    End If

    Note: First pass: calculate total length
    Let total_len be 0
    Let current be parts

    While current is not equal to 0:
        Let value be proc memory_get_int64 from Memory with current, 8
        If value is not equal to 0:
            Let part_len be proc string_length from StringCore with value
            Set total_len to total_len plus part_len
        End If
        Set current to proc memory_get_int64 from Memory with current, 16  Note: next
    End While

    Note: Allocate result buffer
    Let result be proc allocate from Layout with total_len plus 1
    If result is equal to 0:
        Return 0
    End If

    Note: Second pass: concatenate all parts
    Let write_pos be 0
    Set current to parts

    While current is not equal to 0:
        Let value be proc memory_get_int64 from Memory with current, 8
        If value is not equal to 0:
            Let part_len be proc string_length from StringCore with value
            Let i be 0

            While i is less than part_len:
                Let byte be proc memory_get_byte from Memory with value, i
                proc memory_set_byte from Memory with result, write_pos, byte
                Set write_pos to write_pos plus 1
                Set i to i plus 1
            End While
        End If

        Set current to proc memory_get_int64 from Memory with current, 16  Note: next
    End While

    Note: Add null terminator
    proc memory_set_byte from Memory with result, total_len, 0

    Return result
End Process
