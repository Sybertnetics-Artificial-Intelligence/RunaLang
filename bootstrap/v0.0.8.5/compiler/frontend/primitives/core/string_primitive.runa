Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles string primitive type and string operations.

This file performs the following tasks:
- Process string values and string type handling
- Handle string operations and string manipulation
- Manage string interpolation and string formatting - v0.0.8.5 feature
- Process string optimization and string constant folding

This file is essential because of the following reasons:
- String primitives are fundamental to text processing and string manipulation
- String interpolation is a key v0.0.8.5 feature requirement
- Proper string handling ensures correct text processing and string operations

This file consists of the following functions/features/operation types:
- String value processing and string type handling
- String operations and string manipulation
- String interpolation and string formatting processing
- String optimization and string constant folding

Dependencies:
- Imports core/string_core.runa (Layer 0 basic string functions)
- Imports core/memory_core.runa (Layer 0 memory operations)
- Imports memory/layout.runa (Layer 1 allocate/deallocate with free list)
:End Note

Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
Import "compiler/frontend/primitives/memory/layout.runa" as Layout

Note: ============================================================================
Note: Higher-Level String Operations (Layer 2)
Note: ============================================================================

Note: This file provides Layer 2 string operations that depend on memory
Note: allocation. Layer 0 string_core.runa provides basic operations like
Note: string_equals, string_length that don't require allocation.

Note: Layer 2 adds:
Note: - string_concat (allocates result)
Note: - string_duplicate (allocates copy)
Note: - string_substring (allocates substring)
Note: - Future: string interpolation/formatting
Note: ============================================================================

Process called "string_concat" takes str1 as Integer, str2 as Integer returns Integer:
    Note: Concatenate two strings into a new allocated string
    Note: Returns pointer to new string, or 0 on failure
    Note: Caller is responsible for deallocating result

    Note: Handle NULL inputs
    If str1 is equal to 0:
        If str2 is equal to 0:
            Return 0  Note: Both NULL
        End If
        Return string_duplicate(str2)  Note: Return copy of str2
    End If

    If str2 is equal to 0:
        Return string_duplicate(str1)  Note: Return copy of str1
    End If

    Note: Calculate lengths
    Let len1 be string_length(str1)
    Let len2 be string_length(str2)
    Let total_len be len1 plus len2

    Note: Allocate buffer (length + null terminator)
    Let result be allocate(total_len plus 1)
    If result is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Copy first string
    Let i be 0
    While i is less than len1:
        Let byte be memory_get_byte(str1, i)
        memory_set_byte(result, i, byte)
        Set i to i plus 1
    End While

    Note: Copy second string
    Set i to 0
    While i is less than len2:
        Let byte be memory_get_byte(str2, i)
        Let offset be len1 plus i
        memory_set_byte(result, offset, byte)
        Set i to i plus 1
    End While

    Note: Add null terminator
    memory_set_byte(result, total_len, 0)

    Return result
End Process

Process called "string_duplicate" takes str as Integer returns Integer:
    Note: Create a duplicate copy of a string
    Note: Returns pointer to new string, or 0 on failure
    Note: Caller is responsible for deallocating result

    If str is equal to 0:
        Return 0  Note: NULL input
    End If

    Let len be string_length(str)
    Let result be allocate(len plus 1)
    If result is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Copy all bytes including null terminator
    Let i be 0
    While i is less than or equal to len:
        Let byte be memory_get_byte(str, i)
        memory_set_byte(result, i, byte)
        Set i to i plus 1
    End While

    Return result
End Process

Process called "string_substring" takes str as Integer, start as Integer, length as Integer returns Integer:
    Note: Extract a substring from a string
    Note: Returns pointer to new string, or 0 on failure
    Note: Caller is responsible for deallocating result

    If str is equal to 0:
        Return 0  Note: NULL input
    End If

    If start is less than 0:
        Return 0  Note: Invalid start
    End If

    If length is less than 0:
        Return 0  Note: Invalid length
    End If

    Let str_len be string_length(str)

    Note: Clamp start to valid range
    If start is greater than str_len:
        Set start to str_len
    End If

    Note: Clamp length to available characters
    Let available be str_len minus start
    If length is greater than available:
        Set length to available
    End If

    Note: Allocate result
    Let result be allocate(length plus 1)
    If result is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Copy substring
    Let i be 0
    While i is less than length:
        Let src_offset be start plus i
        Let byte be memory_get_byte(str, src_offset)
        memory_set_byte(result, i, byte)
        Set i to i plus 1
    End While

    Note: Add null terminator
    memory_set_byte(result, length, 0)

    Return result
End Process

Note: ============================================================================
Note: String Literal Table Management (for codegen)
Note: ============================================================================

Note: These functions will be used by codegen to manage string literals
Note: in the generated assembly. Each string literal gets a unique label.
Note: ============================================================================

Note: StringLiteral structure (16 bytes):
Note:   offset 0: value (pointer to string, 8 bytes)
Note:   offset 8: label_id (integer ID for .STR<id>, 8 bytes)

Process called "string_literal_create" takes value as Integer, label_id as Integer returns Integer:
    Note: Create a StringLiteral structure
    Note: Returns pointer to structure, or 0 on failure

    Let literal be allocate(16)
    If literal is equal to 0:
        Return 0  Note: Allocation failed
    End If

    memory_set_pointer(literal, 0, value)
    memory_set_int64(literal, 8, label_id)

    Return literal
End Process

Process called "string_literal_get_value" takes literal as Integer returns Integer:
    Note: Get the string value from a StringLiteral

    If literal is equal to 0:
        Return 0
    End If

    Return memory_get_pointer(literal, 0)
End Process

Process called "string_literal_get_label_id" takes literal as Integer returns Integer:
    Note: Get the label ID from a StringLiteral

    If literal is equal to 0:
        Return 0
    End If

    Return memory_get_int64(literal, 8)
End Process

Note: ============================================================================
Note: Future: String Interpolation Support (v0.0.8.5 feature)
Note: ============================================================================

Note: String interpolation will allow: f"Hello {name}, you are {age} years old"
Note: This will be implemented in a later phase of v0.0.8.5 development.

Note: Planned functions:
Note: - string_interpolate(format_str, values_array, count) -> new_string
Note: - string_format_int(value) -> string representation
Note: - string_format_float(value) -> string representation
Note: ============================================================================
