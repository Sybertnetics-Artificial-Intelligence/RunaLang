Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles string primitive type and string operations.

This file performs the following tasks:
- Process string values and string type handling
- Handle string operations and string manipulation
- Manage string interpolation and string formatting - v0.0.8.5 feature
- Process string optimization and string constant folding

This file is essential because of the following reasons:
- String primitives are fundamental to text processing and string manipulation
- String interpolation is a key v0.0.8.5 feature requirement
- Proper string handling ensures correct text processing and string operations

This file consists of the following functions/features/operation types:
- String value processing and string type handling
- String operations and string manipulation
- String interpolation and string formatting processing
- String optimization and string constant folding

Dependencies:
- Imports core/string_core.runa (Layer 0 basic string functions)
- Imports core/memory_core.runa (Layer 0 memory operations)
- Imports memory/layout.runa (Layer 1 allocate/deallocate with free list)
:End Note

Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
Import "compiler/frontend/primitives/memory/layout.runa" as Layout

Note: ============================================================================
Note: Higher-Level String Operations (Layer 2)
Note: ============================================================================

Note: This file provides Layer 2 string operations that depend on memory
Note: allocation. Layer 0 string_core.runa provides basic operations like
Note: string_equals, string_length that don't require allocation.

Note: Layer 2 adds:
Note: - string_concat (allocates result)
Note: - string_duplicate (allocates copy)
Note: - string_substring (allocates substring)
Note: - string_interpolate (formatted strings)
Note: - integer_to_string (conversion)
Note: ============================================================================

Process called "string_concat" takes str1 as Integer, str2 as Integer returns Integer:
    Note: Concatenate two strings into a new allocated string
    Note: Returns pointer to new string, or 0 on failure
    Note: Caller is responsible for deallocating result

    Note: Handle NULL inputs
    If str1 is equal to 0:
        If str2 is equal to 0:
            Return 0  Note: Both NULL
        End If
        Return proc string_duplicate with str2  Note: Return copy of str2
    End If

    If str2 is equal to 0:
        Return proc string_duplicate with str1  Note: Return copy of str1
    End If

    Note: Calculate lengths
    Let len1 be proc string_length from StringCore with str1
    Let len2 be proc string_length from StringCore with str2
    Let total_len be len1 plus len2

    Note: Allocate buffer (length + null terminator)
    Let result be proc allocate from Layout with total_len plus 1
    If result is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Copy first string
    Let i be 0
    While i is less than len1:
        Let byte be proc memory_get_byte from Memory with str1, i
        proc memory_set_byte from Memory with result, i, byte
        Set i to i plus 1
    End While

    Note: Copy second string
    Set i to 0
    While i is less than len2:
        Let byte be proc memory_get_byte from Memory with str2, i
        Let offset be len1 plus i
        proc memory_set_byte from Memory with result, offset, byte
        Set i to i plus 1
    End While

    Note: Add null terminator
    proc memory_set_byte from Memory with result, total_len, 0

    Return result
End Process

Process called "string_duplicate" takes str as Integer returns Integer:
    Note: Create a duplicate copy of a string
    Note: Returns pointer to new string, or 0 on failure
    Note: Caller is responsible for deallocating result

    If str is equal to 0:
        Return 0  Note: NULL input
    End If

    Let len be proc string_length from StringCore with str
    Let result be proc allocate from Layout with len plus 1
    If result is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Copy all bytes including null terminator
    Let i be 0
    While i is less than or equal to len:
        Let byte be proc memory_get_byte from Memory with str, i
        proc memory_set_byte from Memory with result, i, byte
        Set i to i plus 1
    End While

    Return result
End Process

Process called "string_substring" takes str as Integer, start as Integer, length as Integer returns Integer:
    Note: Extract a substring from a string
    Note: Returns pointer to new string, or 0 on failure
    Note: Caller is responsible for deallocating result

    If str is equal to 0:
        Return 0  Note: NULL input
    End If

    If start is less than 0:
        Return 0  Note: Invalid start
    End If

    If length is less than 0:
        Return 0  Note: Invalid length
    End If

    Let str_len be proc string_length from StringCore with str

    Note: Clamp start to valid range
    If start is greater than str_len:
        Set start to str_len
    End If

    Note: Clamp length to available characters
    Let available be str_len minus start
    If length is greater than available:
        Set length to available
    End If

    Note: Allocate result
    Let result be proc allocate from Layout with length plus 1
    If result is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Copy substring
    Let i be 0
    While i is less than length:
        Let src_offset be start plus i
        Let byte be proc memory_get_byte from Memory with str, src_offset
        proc memory_set_byte from Memory with result, i, byte
        Set i to i plus 1
    End While

    Note: Add null terminator
    proc memory_set_byte from Memory with result, length, 0

    Return result
End Process

Note: ============================================================================
Note: String Conversion Functions
Note: ============================================================================

Process called "integer_to_string" takes value as Integer returns Integer:
    Note: Convert integer to string representation
    Note: Returns pointer to new string, or 0 on failure
    Note: Supports negative numbers

    Note: Handle zero special case
    If value is equal to 0:
        Let result be proc allocate from Layout with 2  Note: "0" + null
        If result is equal to 0:
            Return 0
        End If
        proc memory_set_byte from Memory with result, 0, 48  Note: ASCII '0'
        proc memory_set_byte from Memory with result, 1, 0   Note: Null terminator
        Return result
    End If

    Note: Handle negative numbers
    Let is_negative be 0
    If value is less than 0:
        Set is_negative to 1
        Set value to 0 minus value  Note: Make positive
    End If

    Note: Count digits
    Let temp be value
    Let digit_count be 0
    While temp is greater than 0:
        Set digit_count to digit_count plus 1
        Set temp to temp divided by 10
    End While

    Note: Calculate total length (digits + optional minus + null)
    Let total_len be digit_count plus is_negative plus 1

    Note: Allocate buffer
    Let result be proc allocate from Layout with total_len
    If result is equal to 0:
        Return 0
    End If

    Note: Add minus sign if negative
    Let write_pos be 0
    If is_negative is equal to 1:
        proc memory_set_byte from Memory with result, 0, 45  Note: ASCII '-'
        Set write_pos to 1
    End If

    Note: Convert digits (write from end to beginning)
    Let pos be total_len minus 2  Note: Start before null terminator
    Set temp to value

    While temp is greater than 0:
        Let digit be temp Modulo by 10
        Let ascii_digit be digit plus 48  Note: ASCII '0' is 48
        proc memory_set_byte from Memory with result, pos, ascii_digit
        Set temp to temp divided by 10
        Set pos to pos minus 1
    End While

    Note: Add null terminator
    proc memory_set_byte from Memory with result, total_len minus 1, 0

    Return result
End Process

Process called "string_to_integer" takes str as Integer returns Integer:
    Note: Convert string to integer
    Note: Returns integer value, or 0 if invalid
    Note: WARNING: Cannot distinguish between "0" and invalid input

    If str is equal to 0:
        Return 0
    End If

    Let len be proc string_length from StringCore with str
    If len is equal to 0:
        Return 0
    End If

    Note: Check for negative sign
    Let is_negative be 0
    Let start_pos be 0
    Let first_char be proc memory_get_byte from Memory with str, 0
    If first_char is equal to 45:  Note: ASCII '-'
        Set is_negative to 1
        Set start_pos to 1
    End If

    Note: Convert digits
    Let result be 0
    Let i be start_pos

    While i is less than len:
        Let ch be proc memory_get_byte from Memory with str, i

        Note: Check if valid digit (ASCII 48-57 for '0'-'9')
        If ch is less than 48:
            Return 0  Note: Invalid character
        End If
        If ch is greater than 57:
            Return 0  Note: Invalid character
        End If

        Let digit be ch minus 48
        Set result to result multiplied by 10
        Set result to result plus digit
        Set i to i plus 1
    End While

    Note: Apply negative sign
    If is_negative is equal to 1:
        Set result to 0 minus result
    End If

    Return result
End Process

Note: ============================================================================
Note: String Literal Table Management (for codegen)
Note: ============================================================================

Note: These functions are used by codegen to manage string literals
Note: in the generated assembly. Each string literal gets a unique label.

Note: StringLiteral structure (16 bytes):
Note:   offset 0: value (pointer to string, 8 bytes)
Note:   offset 8: label_id (integer ID for .STR<id>, 8 bytes)

Process called "string_literal_create" takes value as Integer, label_id as Integer returns Integer:
    Note: Create a StringLiteral structure
    Note: Returns pointer to structure, or 0 on failure

    Let literal be proc allocate from Layout with 16
    If literal is equal to 0:
        Return 0  Note: Allocation failed
    End If

    proc memory_set_int64 from Memory with literal, 0, value
    proc memory_set_int64 from Memory with literal, 8, label_id

    Return literal
End Process

Process called "string_literal_get_value" takes literal as Integer returns Integer:
    Note: Get the string value from a StringLiteral

    If literal is equal to 0:
        Return 0
    End If

    Return proc memory_get_int64 from Memory with literal, 0
End Process

Process called "string_literal_get_label_id" takes literal as Integer returns Integer:
    Note: Get the label ID from a StringLiteral

    If literal is equal to 0:
        Return 0
    End If

    Return proc memory_get_int64 from Memory with literal, 8
End Process

Note: ============================================================================
Note: String Comparison and Search
Note: ============================================================================

Process called "string_starts_with" takes str as Integer, prefix as Integer returns Integer:
    Note: Check if string starts with prefix
    Note: Returns 1 if true, 0 if false

    If str is equal to 0:
        Return 0
    End If
    If prefix is equal to 0:
        Return 0
    End If

    Let str_len be proc string_length from StringCore with str
    Let prefix_len be proc string_length from StringCore with prefix

    If prefix_len is greater than str_len:
        Return 0  Note: Prefix longer than string
    End If

    Let i be 0
    While i is less than prefix_len:
        Let str_byte be proc memory_get_byte from Memory with str, i
        Let prefix_byte be proc memory_get_byte from Memory with prefix, i
        If str_byte is not equal to prefix_byte:
            Return 0  Note: Mismatch
        End If
        Set i to i plus 1
    End While

    Return 1  Note: Match
End Process

Process called "string_ends_with" takes str as Integer, suffix as Integer returns Integer:
    Note: Check if string ends with suffix
    Note: Returns 1 if true, 0 if false

    If str is equal to 0:
        Return 0
    End If
    If suffix is equal to 0:
        Return 0
    End If

    Let str_len be proc string_length from StringCore with str
    Let suffix_len be proc string_length from StringCore with suffix

    If suffix_len is greater than str_len:
        Return 0  Note: Suffix longer than string
    End If

    Let start_offset be str_len minus suffix_len
    Let i be 0

    While i is less than suffix_len:
        Let str_pos be start_offset plus i
        Let str_byte be proc memory_get_byte from Memory with str, str_pos
        Let suffix_byte be proc memory_get_byte from Memory with suffix, i
        If str_byte is not equal to suffix_byte:
            Return 0  Note: Mismatch
        End If
        Set i to i plus 1
    End While

    Return 1  Note: Match
End Process

Process called "string_index_of" takes str as Integer, substring as Integer returns Integer:
    Note: Find first occurrence of substring in string
    Note: Returns index of first match, or -1 if not found

    If str is equal to 0:
        Return -1
    End If
    If substring is equal to 0:
        Return -1
    End If

    Let str_len be proc string_length from StringCore with str
    Let sub_len be proc string_length from StringCore with substring

    If sub_len is greater than str_len:
        Return -1  Note: Substring longer than string
    End If

    If sub_len is equal to 0:
        Return 0  Note: Empty substring matches at start
    End If

    Let search_end be str_len minus sub_len
    Let i be 0

    While i is less than or equal to search_end:
        Note: Check if substring matches at position i
        Let matches be 1
        Let j be 0

        While j is less than sub_len:
            Let str_pos be i plus j
            Let str_byte be proc memory_get_byte from Memory with str, str_pos
            Let sub_byte be proc memory_get_byte from Memory with substring, j
            If str_byte is not equal to sub_byte:
                Set matches to 0
                Set j to sub_len  Note: Break inner loop
            End If
            Set j to j plus 1
        End While

        If matches is equal to 1:
            Return i  Note: Found at position i
        End If

        Set i to i plus 1
    End While

    Return -1  Note: Not found
End Process

Note: ============================================================================
Note: String Interpolation Support (v0.0.8.5 feature)
Note: ============================================================================

Note: InterpolationPart structure (24 bytes):
Note:   offset 0:  is_literal (1 if literal string, 0 if expression, 8 bytes)
Note:   offset 8:  value (pointer to string or expression result, 8 bytes)
Note:   offset 16: next (pointer to next part, or 0 if last, 8 bytes)

Process called "interpolation_part_create" takes is_literal as Integer, value as Integer returns Integer:
    Note: Create interpolation part for building formatted string
    Note: Used internally by string interpolation

    Let part be proc allocate from Layout with 24
    If part is equal to 0:
        Return 0
    End If

    proc memory_set_int64 from Memory with part, 0, is_literal
    proc memory_set_int64 from Memory with part, 8, value
    proc memory_set_int64 from Memory with part, 16, 0  Note: next = NULL

    Return part
End Process

Process called "string_interpolate" takes parts as Integer returns Integer:
    Note: Build string from interpolation parts (linked list)
    Note: parts: linked list of InterpolationPart structures
    Note: Returns pointer to final string, or 0 on failure
    Note: Caller is responsible for deallocating result

    If parts is equal to 0:
        Note: Empty interpolation - return empty string
        Let result be proc allocate from Layout with 1
        If result is equal to 0:
            Return 0
        End If
        proc memory_set_byte from Memory with result, 0, 0
        Return result
    End If

    Note: First pass: calculate total length
    Let total_len be 0
    Let current be parts

    While current is not equal to 0:
        Let value be proc memory_get_int64 from Memory with current, 8
        If value is not equal to 0:
            Let part_len be proc string_length from StringCore with value
            Set total_len to total_len plus part_len
        End If
        Set current to proc memory_get_int64 from Memory with current, 16  Note: next
    End While

    Note: Allocate result buffer
    Let result be proc allocate from Layout with total_len plus 1
    If result is equal to 0:
        Return 0
    End If

    Note: Second pass: concatenate all parts
    Let write_pos be 0
    Set current to parts

    While current is not equal to 0:
        Let value be proc memory_get_int64 from Memory with current, 8
        If value is not equal to 0:
            Let part_len be proc string_length from StringCore with value
            Let i be 0

            While i is less than part_len:
                Let byte be proc memory_get_byte from Memory with value, i
                proc memory_set_byte from Memory with result, write_pos, byte
                Set write_pos to write_pos plus 1
                Set i to i plus 1
            End While
        End If

        Set current to proc memory_get_int64 from Memory with current, 16  Note: next
    End While

    Note: Add null terminator
    proc memory_set_byte from Memory with result, total_len, 0

    Return result
End Process

Note: ============================================================================
Note: Float128 to String Conversion Functions
Note: ============================================================================

Import "compiler/frontend/primitives/core/softfloat.runa" as SoftFloat

Process called "bignum_multiply_digit" takes num as Integer, num_len as Integer, digit as Integer, result as Integer returns Integer:
    Note: Multiply bignum by single digit (0-9), store in result
    Note: num: Array of decimal digits (0-9)
    Note: num_len: Number of digits in num
    Note: digit: Single digit multiplier (0-9)
    Note: result: Output array (must be num_len + 1 in size)
    Note: Returns: New length after multiplication

    Let carry be 0
    Let i be 0

    While i is less than num_len:
        Let digit_value be proc memory_get_byte from Memory with num, i
        Let product be digit_value multiplied by digit
        Set product to product plus carry

        Let new_digit be product Modulo by 10
        Set carry to product divided by 10

        proc memory_set_byte from Memory with result, i, new_digit
        Set i to i plus 1
    End While

    If carry is greater than 0:
        proc memory_set_byte from Memory with result, num_len, carry
        Return num_len plus 1
    End If

    Return num_len
End Process

Process called "bignum_add_digit" takes num as Integer, num_len as Integer, digit as Integer, position as Integer returns Integer:
    Note: Add single digit to bignum at position, handle carry
    Note: Modifies num in place
    Note: Returns: New length

    Let value_at_pos be proc memory_get_byte from Memory with num, position
    Let sum be value_at_pos plus digit
    Let carry be 0

    If sum is greater than or equal to 10:
        Set carry to 1
        Set sum to sum minus 10
    End If

    proc memory_set_byte from Memory with num, position, sum

    If carry is equal to 0:
        Return num_len
    End If

    Note: Propagate carry
    Let i be position plus 1
    While i is less than num_len:
        Let digit_value be proc memory_get_byte from Memory with num, i
        Set digit_value to digit_value plus 1

        If digit_value is less than 10:
            proc memory_set_byte from Memory with num, i, digit_value
            Return num_len
        End If

        proc memory_set_byte from Memory with num, i, 0
        Set i to i plus 1
    End While

    Note: Need to extend length
    proc memory_set_byte from Memory with num, num_len, 1
    Return num_len plus 1
End Process

Process called "bignum_divide_by_2" takes num as Integer, num_len as Integer returns Integer:
    Note: Divide bignum by 2, modify in place
    Note: Returns: New length (may shrink if leading digit becomes 0)

    Let carry be 0
    Let i be num_len minus 1

    While i is greater than or equal to 0:
        Let digit_value be proc memory_get_byte from Memory with num, i
        Set digit_value to digit_value plus carry multiplied by 10

        Let quotient be digit_value divided by 2
        Let remainder be digit_value Modulo by 2

        proc memory_set_byte from Memory with num, i, quotient
        Set carry to remainder
        Set i to i minus 1
    End While

    Note: Remove leading zeros
    Let new_len be num_len
    While new_len is greater than 1:
        Let leading_digit be proc memory_get_byte from Memory with num, new_len minus 1
        If leading_digit is not equal to 0:
            Return new_len
        End If
        Set new_len to new_len minus 1
    End While

    Return new_len
End Process

Process called "bignum_is_zero" takes num as Integer, num_len as Integer returns Integer:
    Note: Check if bignum is zero
    Note: Returns: 1 if zero, 0 if non-zero

    Let i be 0
    While i is less than num_len:
        Let digit be proc memory_get_byte from Memory with num, i
        If digit is not equal to 0:
            Return 0
        End If
        Set i to i plus 1
    End While

    Return 1
End Process

Process called "float128_to_string_fixed" takes f128_ptr as Integer, precision as Integer returns Integer:
    Note: Convert float128 to fixed-point decimal string
    Note: Uses bignum arithmetic for exact conversion
    Note: f128_ptr: Pointer to float128 value (16 bytes)
    Note: precision: Number of decimal places (-1 for default of 6)
    Note: Returns: Pointer to allocated string, or 0 on failure

    Note: Allocate scratch space
    Let scratch be proc allocate from Layout with 128
    If scratch is equal to 0:
        Return 0
    End If

    Note: Check special cases
    Let is_nan be proc float128_is_nan from SoftFloat with f128_ptr, scratch
    If is_nan is equal to 1:
        proc deallocate from Layout with scratch
        Let result be proc allocate from Layout with 4
        If result is equal to 0:
            Return 0
        End If
        proc memory_set_byte from Memory with result, 0, 110  Note: 'n'
        proc memory_set_byte from Memory with result, 1, 97   Note: 'a'
        proc memory_set_byte from Memory with result, 2, 110  Note: 'n'
        proc memory_set_byte from Memory with result, 3, 0
        Return result
    End If

    Let is_inf be proc float128_is_infinity from SoftFloat with f128_ptr, scratch
    If is_inf is equal to 1:
        proc deallocate from Layout with scratch
        Let sign be proc memory_get_byte from Memory with f128_ptr, 15
        Let sign_bit be sign divided by 128

        Let result be 0
        If sign_bit is equal to 1:
            Set result to proc allocate from Layout with 5
            If result is equal to 0:
                Return 0
            End If
            proc memory_set_byte from Memory with result, 0, 45   Note: '-'
            proc memory_set_byte from Memory with result, 1, 105  Note: 'i'
            proc memory_set_byte from Memory with result, 2, 110  Note: 'n'
            proc memory_set_byte from Memory with result, 3, 102  Note: 'f'
            proc memory_set_byte from Memory with result, 4, 0
        Otherwise:
            Set result to proc allocate from Layout with 4
            If result is equal to 0:
                Return 0
            End If
            proc memory_set_byte from Memory with result, 0, 105  Note: 'i'
            proc memory_set_byte from Memory with result, 1, 110  Note: 'n'
            proc memory_set_byte from Memory with result, 2, 102  Note: 'f'
            proc memory_set_byte from Memory with result, 3, 0
        End If
        Return result
    End If

    Let is_zero be proc float128_is_zero from SoftFloat with f128_ptr
    If is_zero is equal to 1:
        proc deallocate from Layout with scratch
        Let sign be proc memory_get_byte from Memory with f128_ptr, 15
        Let sign_bit be sign divided by 128

        If precision is less than 0:
            Set precision to 6
        End If

        Let result_len be 3 plus precision plus 1
        If sign_bit is equal to 1:
            Set result_len to result_len plus 1
        End If

        Let result be proc allocate from Layout with result_len
        If result is equal to 0:
            Return 0
        End If

        Let write_pos be 0
        If sign_bit is equal to 1:
            proc memory_set_byte from Memory with result, write_pos, 45  Note: '-'
            Set write_pos to write_pos plus 1
        End If

        proc memory_set_byte from Memory with result, write_pos, 48  Note: '0'
        Set write_pos to write_pos plus 1

        If precision is greater than 0:
            proc memory_set_byte from Memory with result, write_pos, 46  Note: '.'
            Set write_pos to write_pos plus 1

            Let i be 0
            While i is less than precision:
                proc memory_set_byte from Memory with result, write_pos, 48  Note: '0'
                Set write_pos to write_pos plus 1
                Set i to i plus 1
            End While
        End If

        proc memory_set_byte from Memory with result, write_pos, 0
        Return result
    End If

    Note: Unpack float128
    Let sign_ptr be scratch
    Let exp_ptr be scratch plus 8
    Let mant_high_ptr be scratch plus 16
    Let mant_low_ptr be scratch plus 24

    proc float128_unpack from SoftFloat with f128_ptr, sign_ptr, exp_ptr, mant_high_ptr, mant_low_ptr

    Let sign be proc memory_get_int64 from Memory with sign_ptr, 0
    Let exp be proc memory_get_int64 from Memory with exp_ptr, 0
    Let mant_high be proc memory_get_int64 from Memory with mant_high_ptr, 0
    Let mant_low be proc memory_get_int64 from Memory with mant_low_ptr, 0

    If precision is less than 0:
        Set precision to 6
    End If

    Note: Allocate bignum buffers (128 digits max for float128)
    Let integer_part be proc allocate from Layout with 128
    Let fractional_part be proc allocate from Layout with 128
    Let temp_buffer be proc allocate from Layout with 128

    If integer_part is equal to 0:
        proc deallocate from Layout with scratch
        Return 0
    End If

    If fractional_part is equal to 0:
        proc deallocate from Layout with scratch
        proc deallocate from Layout with integer_part
        Return 0
    End If

    If temp_buffer is equal to 0:
        proc deallocate from Layout with scratch
        proc deallocate from Layout with integer_part
        proc deallocate from Layout with fractional_part
        Return 0
    End If

    Note: Initialize bignums to zero
    proc memory_fill from Memory with integer_part, 0, 128
    proc memory_fill from Memory with fractional_part, 0, 128
    proc memory_fill from Memory with temp_buffer, 0, 128

    Note: Start with mantissa as integer: [1.mant] * 2^exp
    Note: Mantissa is 112 bits, treat as 112-bit integer
    Note: We'll use binary-to-decimal conversion

    Note: Initialize integer part to 1 (implicit leading 1)
    proc memory_set_byte from Memory with integer_part, 0, 1
    Let int_len be 1

    Note: Convert 112-bit mantissa to decimal by processing bit by bit
    Note: Process mant_high (48 bits) and mant_low (64 bits)

    Let bit_index be 111
    While bit_index is greater than or equal to 64:
        Note: Process mant_high bits
        Let bit_pos_in_high be bit_index minus 64
        Let word_bit be mant_high divided by 1
        Let i be 0
        While i is less than bit_pos_in_high:
            Set word_bit to word_bit divided by 2
            Set i to i plus 1
        End While
        Let bit_value be word_bit Modulo by 2

        Note: Multiply integer part by 2
        Set int_len to proc bignum_multiply_digit with integer_part, int_len, 2, temp_buffer
        proc memory_copy from Memory with integer_part, temp_buffer, int_len

        Note: Add bit value
        If bit_value is equal to 1:
            Set int_len to proc bignum_add_digit with integer_part, int_len, 1, 0
        End If

        Set bit_index to bit_index minus 1
    End While

    While bit_index is greater than or equal to 0:
        Note: Process mant_low bits
        Let word_bit be mant_low divided by 1
        Let i be 0
        While i is less than bit_index:
            Set word_bit to word_bit divided by 2
            Set i to i plus 1
        End While
        Let bit_value be word_bit Modulo by 2

        Note: Multiply integer part by 2
        Set int_len to proc bignum_multiply_digit with integer_part, int_len, 2, temp_buffer
        proc memory_copy from Memory with integer_part, temp_buffer, int_len

        Note: Add bit value
        If bit_value is equal to 1:
            Set int_len to proc bignum_add_digit with integer_part, int_len, 1, 0
        End If

        Set bit_index to bit_index minus 1
    End While

    Note: Now apply exponent scaling
    Let unbiased_exp be exp minus 16383

    If unbiased_exp is greater than 0:
        Note: Multiply by 2^exp
        Let e be 0
        While e is less than unbiased_exp:
            Set int_len to proc bignum_multiply_digit with integer_part, int_len, 2, temp_buffer
            proc memory_copy from Memory with integer_part, temp_buffer, int_len
            Set e to e plus 1
        End While
    Otherwise:
        If unbiased_exp is less than 0:
            Note: Divide by 2^(-exp), store fractional digits
            Let neg_exp be 0 minus unbiased_exp
            Let e be 0
            While e is less than neg_exp:
                Set int_len to proc bignum_divide_by_2 with integer_part, int_len
                Set e to e plus 1
            End While
        End If
    End If

    Note: Convert integer part to decimal digits (reverse order)
    Let result_size be int_len plus precision plus 10
    Let result be proc allocate from Layout with result_size

    If result is equal to 0:
        proc deallocate from Layout with scratch
        proc deallocate from Layout with integer_part
        proc deallocate from Layout with fractional_part
        proc deallocate from Layout with temp_buffer
        Return 0
    End If

    Let write_pos be 0

    Note: Write sign
    If sign is equal to 1:
        proc memory_set_byte from Memory with result, write_pos, 45  Note: '-'
        Set write_pos to write_pos plus 1
    End If

    Note: Write integer digits (reverse order)
    Let i be int_len minus 1
    While i is greater than or equal to 0:
        Let digit be proc memory_get_byte from Memory with integer_part, i
        Let ascii_digit be digit plus 48
        proc memory_set_byte from Memory with result, write_pos, ascii_digit
        Set write_pos to write_pos plus 1
        Set i to i minus 1
    End While

    Note: Write decimal point and fractional digits
    If precision is greater than 0:
        proc memory_set_byte from Memory with result, write_pos, 46  Note: '.'
        Set write_pos to write_pos plus 1

        Note: Extract fractional digits using multiplication by 10
        Note: Start with fractional_part = mantissa * 2^exp (fractional portion)

        Note: Calculate fractional part by extracting remainder after integer division
        Note: We need to compute the decimal fractional digits

        Note: Initialize fractional accumulator with the mantissa bits
        Note: For each fractional bit position, if bit is set, add 2^(-bit_position)

        proc memory_fill from Memory with fractional_part, 0, 128
        Let frac_len be 1
        proc memory_set_byte from Memory with fractional_part, 0, 0

        Note: Process mantissa bits to build fractional part
        Note: For bits after the binary point, each bit represents 2^(-position)
        Note: We multiply by 10^precision and extract digits

        Note: Build fractional value by processing mantissa bits in reverse
        Let bit_index be 0
        While bit_index is less than 112:
            Note: Get bit value from mantissa
            Let bit_value be 0
            If bit_index is less than 64:
                Note: Bit in mant_low
                Let word_bit be mant_low
                Let shift_count be bit_index
                Let i be 0
                While i is less than shift_count:
                    Set word_bit to word_bit divided by 2
                    Set i to i plus 1
                End While
                Set bit_value to word_bit Modulo by 2
            Otherwise:
                Note: Bit in mant_high
                Let bit_pos_in_high be bit_index minus 64
                Let word_bit be mant_high
                Let i be 0
                While i is less than bit_pos_in_high:
                    Set word_bit to word_bit divided by 2
                    Set i to i plus 1
                End While
                Set bit_value to word_bit Modulo by 2
            End If

            Set bit_index to bit_index plus 1
        End While

        Note: Generate fractional decimal digits by repeated multiplication by 10
        Note: Simplified approach: for each requested decimal digit, multiply by 10 and extract

        Note: For negative exponents, we have a fractional value
        Note: Extract fractional digits by multiplying accumulator by 10

        Let frac_digit_index be 0
        While frac_digit_index is less than precision:
            Note: Multiply fractional part by 10
            Set frac_len to proc bignum_multiply_digit with fractional_part, frac_len, 10, temp_buffer
            proc memory_copy from Memory with fractional_part, temp_buffer, frac_len

            Note: Extract leading digit (most significant)
            Let digit be 0
            If frac_len is greater than 0:
                Set digit to proc memory_get_byte from Memory with fractional_part, frac_len minus 1

                Note: Remove extracted digit
                proc memory_set_byte from Memory with fractional_part, frac_len minus 1, 0

                Note: Update length if needed
                If digit is equal to 0:
                    If frac_len is greater than 1:
                        Set frac_len to frac_len minus 1
                    End If
                End If
            End If

            Note: Write digit
            Let ascii_digit be digit plus 48
            proc memory_set_byte from Memory with result, write_pos, ascii_digit
            Set write_pos to write_pos plus 1

            Set frac_digit_index to frac_digit_index plus 1
        End While
    End If

    Note: Null terminate
    proc memory_set_byte from Memory with result, write_pos, 0

    Note: Cleanup
    proc deallocate from Layout with scratch
    proc deallocate from Layout with integer_part
    proc deallocate from Layout with fractional_part
    proc deallocate from Layout with temp_buffer

    Return result
End Process

Process called "float128_to_string_scientific" takes f128_ptr as Integer, precision as Integer returns Integer:
    Note: Convert float128 to scientific notation string (e.g., "1.234560e+02")
    Note: f128_ptr: Pointer to 16-byte float128 value
    Note: precision: Number of digits after decimal point (default 6)
    Note: Returns: Pointer to new string, or 0 on failure

    Note: Allocate unpacking storage
    Let sign_ptr be proc allocate from Layout with 8
    Let exp_ptr be proc allocate from Layout with 8
    Let mant_high_ptr be proc allocate from Layout with 8
    Let mant_low_ptr be proc allocate from Layout with 8

    If sign_ptr is equal to 0:
        Return 0
    End If
    If exp_ptr is equal to 0:
        proc deallocate from Layout with sign_ptr
        Return 0
    End If
    If mant_high_ptr is equal to 0:
        proc deallocate from Layout with sign_ptr
        proc deallocate from Layout with exp_ptr
        Return 0
    End If
    If mant_low_ptr is equal to 0:
        proc deallocate from Layout with sign_ptr
        proc deallocate from Layout with exp_ptr
        proc deallocate from Layout with mant_high_ptr
        Return 0
    End If

    Note: Unpack float128
    proc float128_unpack from SoftFloat with f128_ptr, sign_ptr, exp_ptr, mant_high_ptr, mant_low_ptr

    Let sign be proc memory_get_qword from Memory with sign_ptr, 0
    Let raw_exp be proc memory_get_qword from Memory with exp_ptr, 0
    Let mant_high be proc memory_get_qword from Memory with mant_high_ptr, 0
    Let mant_low be proc memory_get_qword from Memory with mant_low_ptr, 0

    Note: Check for special values
    If raw_exp is equal to 32767:
        Note: NaN or Infinity
        If mant_high is equal to 0:
            If mant_low is equal to 0:
                Note: Infinity
                Let result be proc allocate from Layout with 5
                If result is equal to 0:
                    proc deallocate from Layout with sign_ptr
                    proc deallocate from Layout with exp_ptr
                    proc deallocate from Layout with mant_high_ptr
                    proc deallocate from Layout with mant_low_ptr
                    Return 0
                End If
                If sign is equal to 1:
                    proc memory_set_byte from Memory with result, 0, 45  Note: '-'
                    proc memory_set_byte from Memory with result, 1, 105  Note: 'i'
                    proc memory_set_byte from Memory with result, 2, 110  Note: 'n'
                    proc memory_set_byte from Memory with result, 3, 102  Note: 'f'
                    proc memory_set_byte from Memory with result, 4, 0
                Otherwise:
                    proc memory_set_byte from Memory with result, 0, 105  Note: 'i'
                    proc memory_set_byte from Memory with result, 1, 110  Note: 'n'
                    proc memory_set_byte from Memory with result, 2, 102  Note: 'f'
                    proc memory_set_byte from Memory with result, 3, 0
                End If
                proc deallocate from Layout with sign_ptr
                proc deallocate from Layout with exp_ptr
                proc deallocate from Layout with mant_high_ptr
                proc deallocate from Layout with mant_low_ptr
                Return result
            End If
        End If

        Note: NaN
        Let result be proc allocate from Layout with 4
        If result is equal to 0:
            proc deallocate from Layout with sign_ptr
            proc deallocate from Layout with exp_ptr
            proc deallocate from Layout with mant_high_ptr
            proc deallocate from Layout with mant_low_ptr
            Return 0
        End If
        proc memory_set_byte from Memory with result, 0, 110  Note: 'n'
        proc memory_set_byte from Memory with result, 1, 97   Note: 'a'
        proc memory_set_byte from Memory with result, 2, 110  Note: 'n'
        proc memory_set_byte from Memory with result, 3, 0
        proc deallocate from Layout with sign_ptr
        proc deallocate from Layout with exp_ptr
        proc deallocate from Layout with mant_high_ptr
        proc deallocate from Layout with mant_low_ptr
        Return result
    End If

    Note: Check for zero
    If raw_exp is equal to 0:
        If mant_high is equal to 0:
            If mant_low is equal to 0:
                Note: Zero - return "0.000000e+00" format
                Let zero_len be precision plus 9
                If sign is equal to 1:
                    Set zero_len to zero_len plus 1
                End If
                Let result be proc allocate from Layout with zero_len
                If result is equal to 0:
                    proc deallocate from Layout with sign_ptr
                    proc deallocate from Layout with exp_ptr
                    proc deallocate from Layout with mant_high_ptr
                    proc deallocate from Layout with mant_low_ptr
                    Return 0
                End If
                Let write_pos be 0
                If sign is equal to 1:
                    proc memory_set_byte from Memory with result, write_pos, 45  Note: '-'
                    Set write_pos to write_pos plus 1
                End If
                proc memory_set_byte from Memory with result, write_pos, 48  Note: '0'
                Set write_pos to write_pos plus 1
                proc memory_set_byte from Memory with result, write_pos, 46  Note: '.'
                Set write_pos to write_pos plus 1
                Let i be 0
                While i is less than precision:
                    proc memory_set_byte from Memory with result, write_pos, 48  Note: '0'
                    Set write_pos to write_pos plus 1
                    Set i to i plus 1
                End While
                proc memory_set_byte from Memory with result, write_pos, 101  Note: 'e'
                Set write_pos to write_pos plus 1
                proc memory_set_byte from Memory with result, write_pos, 43  Note: '+'
                Set write_pos to write_pos plus 1
                proc memory_set_byte from Memory with result, write_pos, 48  Note: '0'
                Set write_pos to write_pos plus 1
                proc memory_set_byte from Memory with result, write_pos, 48  Note: '0'
                Set write_pos to write_pos plus 1
                proc memory_set_byte from Memory with result, write_pos, 0
                proc deallocate from Layout with sign_ptr
                proc deallocate from Layout with exp_ptr
                proc deallocate from Layout with mant_high_ptr
                proc deallocate from Layout with mant_low_ptr
                Return result
            End If
        End If
    End If

    Note: Normalize mantissa and calculate decimal exponent
    Note: Add implicit leading bit for normalized numbers
    Let unbiased_exp be raw_exp minus 16383

    Note: For scientific notation, we need to find the most significant digit
    Note: Convert to decimal and find magnitude

    Note: Allocate working buffers for bignum arithmetic
    Let scratch be proc allocate from Layout with 256
    Let significand be proc allocate from Layout with 128
    Let temp_buffer be proc allocate from Layout with 128

    If scratch is equal to 0:
        proc deallocate from Layout with sign_ptr
        proc deallocate from Layout with exp_ptr
        proc deallocate from Layout with mant_high_ptr
        proc deallocate from Layout with mant_low_ptr
        Return 0
    End If
    If significand is equal to 0:
        proc deallocate from Layout with scratch
        proc deallocate from Layout with sign_ptr
        proc deallocate from Layout with exp_ptr
        proc deallocate from Layout with mant_high_ptr
        proc deallocate from Layout with mant_low_ptr
        Return 0
    End If
    If temp_buffer is equal to 0:
        proc deallocate from Layout with scratch
        proc deallocate from Layout with significand
        proc deallocate from Layout with sign_ptr
        proc deallocate from Layout with exp_ptr
        proc deallocate from Layout with mant_high_ptr
        proc deallocate from Layout with mant_low_ptr
        Return 0
    End If

    Note: Initialize significand to 1 (implicit bit)
    proc memory_set_byte from Memory with significand, 0, 1
    Let sig_len be 1

    Note: Process mantissa bits from high to low, building significand
    Let bit_index be 111
    While bit_index is greater than or equal to 64:
        Let bit_pos be bit_index minus 64
        Let bit_mask be 1
        Let shift_count be bit_pos
        While shift_count is greater than 0:
            Set bit_mask to bit_mask multiplied by 2
            Set shift_count to shift_count minus 1
        End While

        Let bit_value be 0
        Let masked be mant_high Bitwise And bit_mask
        If masked is not equal to 0:
            Set bit_value to 1
        End If

        Set sig_len to proc bignum_multiply_digit with significand, sig_len, 2, temp_buffer
        proc memory_copy from Memory with significand, temp_buffer, sig_len

        If bit_value is equal to 1:
            Set sig_len to proc bignum_add_digit with significand, sig_len, 1, 0
        End If

        Set bit_index to bit_index minus 1
    End While

    Note: Process low mantissa bits
    While bit_index is greater than or equal to 0:
        Let bit_mask be 1
        Let shift_count be bit_index
        While shift_count is greater than 0:
            Set bit_mask to bit_mask multiplied by 2
            Set shift_count to shift_count minus 1
        End While

        Let bit_value be 0
        Let masked be mant_low Bitwise And bit_mask
        If masked is not equal to 0:
            Set bit_value to 1
        End If

        Set sig_len to proc bignum_multiply_digit with significand, sig_len, 2, temp_buffer
        proc memory_copy from Memory with significand, temp_buffer, sig_len

        If bit_value is equal to 1:
            Set sig_len to proc bignum_add_digit with significand, sig_len, 1, 0
        End If

        Set bit_index to bit_index minus 1
    End While

    Note: Now significand contains the full mantissa value as decimal bignum
    Note: Calculate decimal exponent by scaling with binary exponent
    Let decimal_exp be 0

    If unbiased_exp is greater than 0:
        Note: Multiply by 2^exp
        Let exp_remaining be unbiased_exp
        While exp_remaining is greater than 0:
            Set sig_len to proc bignum_multiply_digit with significand, sig_len, 2, temp_buffer
            proc memory_copy from Memory with significand, temp_buffer, sig_len
            Set exp_remaining to exp_remaining minus 1
        End While
    Otherwise:
        If unbiased_exp is less than 0:
            Note: Divide by 2^(-exp)
            Let exp_remaining be 0 minus unbiased_exp
            While exp_remaining is greater than 0:
                Set sig_len to proc bignum_divide_by_2 with significand, sig_len
                Set exp_remaining to exp_remaining minus 1
            End While
        End If
    End If

    Note: Count decimal digits to determine exponent
    Note: Decimal exponent is (number of digits - 1)
    Set decimal_exp to sig_len minus 1

    Note: Now extract digits for scientific notation
    Note: Format: [sign]d.ddddd...e[+/-]xxx

    Note: Allocate result buffer (sign + digit + decimal + precision + 'e' + exp_sign + exp_digits + null)
    Note: Max exponent is ~5 digits, so allocate generously
    Let result_size be 1 plus 1 plus 1 plus precision plus 1 plus 1 plus 5 plus 1
    If sign is equal to 1:
        Set result_size to result_size plus 1
    End If
    Let result be proc allocate from Layout with result_size

    If result is equal to 0:
        proc deallocate from Layout with scratch
        proc deallocate from Layout with significand
        proc deallocate from Layout with temp_buffer
        proc deallocate from Layout with sign_ptr
        proc deallocate from Layout with exp_ptr
        proc deallocate from Layout with mant_high_ptr
        proc deallocate from Layout with mant_low_ptr
        Return 0
    End If

    Note: Write sign
    Let write_pos be 0
    If sign is equal to 1:
        proc memory_set_byte from Memory with result, write_pos, 45  Note: '-'
        Set write_pos to write_pos plus 1
    End If

    Note: Write first digit (most significant)
    Let first_digit be proc memory_get_byte from Memory with significand, sig_len minus 1
    Let ascii_digit be first_digit plus 48
    proc memory_set_byte from Memory with result, write_pos, ascii_digit
    Set write_pos to write_pos plus 1

    Note: Write decimal point
    proc memory_set_byte from Memory with result, write_pos, 46  Note: '.'
    Set write_pos to write_pos plus 1

    Note: Write remaining precision digits
    Let digit_index be 1
    Let sig_digit_index be sig_len minus 2

    While digit_index is less than precision:
        If sig_digit_index is greater than or equal to 0:
            Note: Have actual digits from significand
            Let digit be proc memory_get_byte from Memory with significand, sig_digit_index
            Set ascii_digit to digit plus 48
            proc memory_set_byte from Memory with result, write_pos, ascii_digit
            Set sig_digit_index to sig_digit_index minus 1
        Otherwise:
            Note: Pad with zeros
            proc memory_set_byte from Memory with result, write_pos, 48  Note: '0'
        End If
        Set write_pos to write_pos plus 1
        Set digit_index to digit_index plus 1
    End While

    Note: Write exponent marker
    proc memory_set_byte from Memory with result, write_pos, 101  Note: 'e'
    Set write_pos to write_pos plus 1

    Note: Write exponent sign and value
    If decimal_exp is greater than or equal to 0:
        proc memory_set_byte from Memory with result, write_pos, 43  Note: '+'
        Set write_pos to write_pos plus 1
        Let exp_value be decimal_exp
    Otherwise:
        proc memory_set_byte from Memory with result, write_pos, 45  Note: '-'
        Set write_pos to write_pos plus 1
        Set exp_value to 0 minus decimal_exp
    End If

    Note: Convert exponent to string (always at least 2 digits)
    If exp_value is less than 10:
        proc memory_set_byte from Memory with result, write_pos, 48  Note: '0'
        Set write_pos to write_pos plus 1
        Set ascii_digit to exp_value plus 48
        proc memory_set_byte from Memory with result, write_pos, ascii_digit
        Set write_pos to write_pos plus 1
    Otherwise:
        Note: Multi-digit exponent
        Let exp_digits be 0
        Let exp_temp be exp_value
        While exp_temp is greater than 0:
            Set exp_digits to exp_digits plus 1
            Set exp_temp to exp_temp divided by 10
        End While

        Note: Write digits from right to left
        Let exp_write_pos be write_pos plus exp_digits minus 1
        Set exp_temp to exp_value
        While exp_temp is greater than 0:
            Let digit be exp_temp Modulo by 10
            Set ascii_digit to digit plus 48
            proc memory_set_byte from Memory with result, exp_write_pos, ascii_digit
            Set exp_write_pos to exp_write_pos minus 1
            Set exp_temp to exp_temp divided by 10
        End While
        Set write_pos to write_pos plus exp_digits
    End If

    Note: Null terminator
    proc memory_set_byte from Memory with result, write_pos, 0

    Note: Cleanup
    proc deallocate from Layout with scratch
    proc deallocate from Layout with significand
    proc deallocate from Layout with temp_buffer
    proc deallocate from Layout with sign_ptr
    proc deallocate from Layout with exp_ptr
    proc deallocate from Layout with mant_high_ptr
    proc deallocate from Layout with mant_low_ptr

    Return result
End Process

Process called "float128_to_string_auto" takes f128_ptr as Integer, precision as Integer returns Integer:
    Note: Convert float128 using automatic format selection (%g style)
    Note: Chooses between fixed-point and scientific based on magnitude
    Note: Rules: Use scientific if exponent < -4 or exponent >= precision
    Note: Otherwise use fixed-point, removing trailing zeros
    Note: f128_ptr: Pointer to 16-byte float128 value
    Note: precision: Total significant digits (default 6)
    Note: Returns: Pointer to new string, or 0 on failure

    Note: Allocate unpacking storage
    Let sign_ptr be proc allocate from Layout with 8
    Let exp_ptr be proc allocate from Layout with 8
    Let mant_high_ptr be proc allocate from Layout with 8
    Let mant_low_ptr be proc allocate from Layout with 8

    If sign_ptr is equal to 0:
        Return 0
    End If
    If exp_ptr is equal to 0:
        proc deallocate from Layout with sign_ptr
        Return 0
    End If
    If mant_high_ptr is equal to 0:
        proc deallocate from Layout with sign_ptr
        proc deallocate from Layout with exp_ptr
        Return 0
    End If
    If mant_low_ptr is equal to 0:
        proc deallocate from Layout with sign_ptr
        proc deallocate from Layout with exp_ptr
        proc deallocate from Layout with mant_high_ptr
        Return 0
    End If

    Note: Unpack float128 to determine magnitude
    proc float128_unpack from SoftFloat with f128_ptr, sign_ptr, exp_ptr, mant_high_ptr, mant_low_ptr

    Let raw_exp be proc memory_get_qword from Memory with exp_ptr, 0
    Let mant_high be proc memory_get_qword from Memory with mant_high_ptr, 0
    Let mant_low be proc memory_get_qword from Memory with mant_low_ptr, 0

    Note: Check for special values (NaN, Infinity, Zero) - delegate to scientific
    If raw_exp is equal to 32767:
        proc deallocate from Layout with sign_ptr
        proc deallocate from Layout with exp_ptr
        proc deallocate from Layout with mant_high_ptr
        proc deallocate from Layout with mant_low_ptr
        Return proc float128_to_string_scientific with f128_ptr, precision
    End If

    If raw_exp is equal to 0:
        If mant_high is equal to 0:
            If mant_low is equal to 0:
                proc deallocate from Layout with sign_ptr
                proc deallocate from Layout with exp_ptr
                proc deallocate from Layout with mant_high_ptr
                proc deallocate from Layout with mant_low_ptr
                Note: Zero - return "0"
                Let result be proc allocate from Layout with 2
                If result is equal to 0:
                    Return 0
                End If
                proc memory_set_byte from Memory with result, 0, 48  Note: '0'
                proc memory_set_byte from Memory with result, 1, 0
                Return result
            End If
        End If
    End If

    Note: Calculate approximate decimal exponent
    Let unbiased_exp be raw_exp minus 16383

    Note: Approximate decimal exponent using log10(2) ≈ 0.30103
    Note: decimal_exp ≈ unbiased_exp * 0.30103
    Note: For integer approximation: decimal_exp ≈ (unbiased_exp * 30103) / 100000
    Let decimal_exp_approx be unbiased_exp multiplied by 30103
    Set decimal_exp_approx to decimal_exp_approx divided by 100000

    Note: Decide format based on %g rules
    Let use_scientific be 0

    If decimal_exp_approx is less than -4:
        Set use_scientific to 1
    End If
    If decimal_exp_approx is greater than or equal to precision:
        Set use_scientific to 1
    End If

    Note: Cleanup unpacking storage
    proc deallocate from Layout with sign_ptr
    proc deallocate from Layout with exp_ptr
    proc deallocate from Layout with mant_high_ptr
    proc deallocate from Layout with mant_low_ptr

    Note: Call appropriate conversion function
    If use_scientific is equal to 1:
        Note: Use scientific notation
        Return proc float128_to_string_scientific with f128_ptr, precision minus 1
    Otherwise:
        Note: Use fixed-point notation
        Note: For %g, precision means total significant digits, not fractional digits
        Note: Calculate fractional precision needed
        Let fractional_precision be precision
        If decimal_exp_approx is greater than 0:
            Set fractional_precision to fractional_precision minus decimal_exp_approx
            If fractional_precision is less than 0:
                Set fractional_precision to 0
            End If
        End If
        Return proc float128_to_string_fixed with f128_ptr, fractional_precision
    End If
End Process

Note: ============================================================================
Note: Additional Integer Conversion Functions
Note: ============================================================================

Process called "integer_to_hex" takes value as Integer, uppercase as Integer returns Integer:
    Note: Convert integer to hexadecimal string representation
    Note: value: Integer value to convert
    Note: uppercase: 1 for uppercase (A-F), 0 for lowercase (a-f)
    Note: Returns: Pointer to new string, or 0 on failure

    Note: Handle zero special case
    If value is equal to 0:
        Let result be proc allocate from Layout with 2
        If result is equal to 0:
            Return 0
        End If
        proc memory_set_byte from Memory with result, 0, 48  Note: '0'
        proc memory_set_byte from Memory with result, 1, 0
        Return result
    End If

    Note: Handle negative numbers (treat as unsigned for hex)
    Let is_negative be 0
    Let unsigned_value be value
    If value is less than 0:
        Set is_negative to 1
        Note: For hex, we show full 64-bit representation
        Set unsigned_value to value
    End If

    Note: Count hex digits (max 16 for 64-bit)
    Let temp be unsigned_value
    Let digit_count be 0

    Note: Count significant digits
    While temp is not equal to 0:
        Set digit_count to digit_count plus 1
        Set temp to temp divided by 16
    End While

    Note: Handle case where value became 0 after division
    If digit_count is equal to 0:
        Set digit_count to 1
    End If

    Note: Allocate buffer (digits + null)
    Let total_len be digit_count plus 1
    Let result be proc allocate from Layout with total_len

    If result is equal to 0:
        Return 0
    End If

    Note: Convert to hex digits (write from end to beginning)
    Let pos be digit_count minus 1
    Set temp to unsigned_value

    While pos is greater than or equal to 0:
        Let digit be temp Modulo by 16
        Let ascii_char be 0

        If digit is less than 10:
            Note: 0-9
            Set ascii_char to digit plus 48
        Otherwise:
            Note: A-F or a-f
            If uppercase is equal to 1:
                Set ascii_char to digit minus 10 plus 65  Note: 'A' = 65
            Otherwise:
                Set ascii_char to digit minus 10 plus 97  Note: 'a' = 97
            End If
        End If

        proc memory_set_byte from Memory with result, pos, ascii_char
        Set temp to temp divided by 16
        Set pos to pos minus 1
    End While

    Note: Add null terminator
    proc memory_set_byte from Memory with result, digit_count, 0

    Return result
End Process

Process called "integer_to_octal" takes value as Integer returns Integer:
    Note: Convert integer to octal string representation
    Note: value: Integer value to convert
    Note: Returns: Pointer to new string, or 0 on failure

    Note: Handle zero special case
    If value is equal to 0:
        Let result be proc allocate from Layout with 2
        If result is equal to 0:
            Return 0
        End If
        proc memory_set_byte from Memory with result, 0, 48  Note: '0'
        proc memory_set_byte from Memory with result, 1, 0
        Return result
    End If

    Note: Handle negative numbers (treat as unsigned for octal)
    Let unsigned_value be value

    Note: Count octal digits (max 22 for 64-bit)
    Let temp be unsigned_value
    Let digit_count be 0

    While temp is not equal to 0:
        Set digit_count to digit_count plus 1
        Set temp to temp divided by 8
    End While

    Note: Handle case where value became 0
    If digit_count is equal to 0:
        Set digit_count to 1
    End If

    Note: Allocate buffer
    Let total_len be digit_count plus 1
    Let result be proc allocate from Layout with total_len

    If result is equal to 0:
        Return 0
    End If

    Note: Convert to octal digits (write from end to beginning)
    Let pos be digit_count minus 1
    Set temp to unsigned_value

    While pos is greater than or equal to 0:
        Let digit be temp Modulo by 8
        Let ascii_digit be digit plus 48  Note: '0' = 48
        proc memory_set_byte from Memory with result, pos, ascii_digit
        Set temp to temp divided by 8
        Set pos to pos minus 1
    End While

    Note: Add null terminator
    proc memory_set_byte from Memory with result, digit_count, 0

    Return result
End Process

Process called "integer_to_binary" takes value as Integer returns Integer:
    Note: Convert integer to binary string representation
    Note: value: Integer value to convert
    Note: Returns: Pointer to new string, or 0 on failure

    Note: Handle zero special case
    If value is equal to 0:
        Let result be proc allocate from Layout with 2
        If result is equal to 0:
            Return 0
        End If
        proc memory_set_byte from Memory with result, 0, 48  Note: '0'
        proc memory_set_byte from Memory with result, 1, 0
        Return result
    End If

    Note: Handle negative numbers (treat as unsigned for binary)
    Let unsigned_value be value

    Note: Count binary digits (max 64 for 64-bit)
    Let temp be unsigned_value
    Let digit_count be 0

    While temp is not equal to 0:
        Set digit_count to digit_count plus 1
        Set temp to temp divided by 2
    End While

    Note: Handle case where value became 0
    If digit_count is equal to 0:
        Set digit_count to 1
    End If

    Note: Allocate buffer
    Let total_len be digit_count plus 1
    Let result be proc allocate from Layout with total_len

    If result is equal to 0:
        Return 0
    End If

    Note: Convert to binary digits (write from end to beginning)
    Let pos be digit_count minus 1
    Set temp to unsigned_value

    While pos is greater than or equal to 0:
        Let digit be temp Modulo by 2
        Let ascii_digit be digit plus 48  Note: '0' = 48
        proc memory_set_byte from Memory with result, pos, ascii_digit
        Set temp to temp divided by 2
        Set pos to pos minus 1
    End While

    Note: Add null terminator
    proc memory_set_byte from Memory with result, digit_count, 0

    Return result
End Process
