Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
ATOMIC OPERATIONS - Platform-Independent Lock-Free Programming Primitives

This file provides atomic operations with proper memory ordering semantics.
All operations are thread-safe and can be used for lock-free programming.

Memory Ordering Models (from weakest to strongest):
- RELAXED: No synchronization, only atomicity guaranteed
- ACQUIRE: Prevents reordering of subsequent reads/writes before this operation
- RELEASE: Prevents reordering of previous reads/writes after this operation
- SEQ_CST: Sequentially consistent (total global ordering)

Platform Implementations:
- x86_64: lock prefix, mfence, xadd, cmpxchg
- ARM64: ldaxr/stlxr, dmb, dsb
- RISC-V: lr.w/sc.w, fence
- PowerPC: lwarx/stwcx, sync, lwsync
- MIPS: ll/sc, sync

Dependencies:
- Delegates to platform/{platform}/atomic.runa for inline assembly implementations
:End Note

Import "compiler/frontend/primitives/assembly/atomic.runa" as AtomicImpl

Note: ============================================================================
Note: Atomic Load Operations
Note: ============================================================================

Process called "atomic_load_relaxed" takes ptr as Integer returns Integer:
    Note: Atomically load 64-bit value with relaxed memory ordering
    Note: No synchronization guarantees, only atomicity
    Note: Use for: counters, statistics where ordering doesn't matter
    Return proc atomic_load_relaxed from AtomicImpl with ptr
End Process

Process called "atomic_load_acquire" takes ptr as Integer returns Integer:
    Note: Atomically load 64-bit value with acquire semantics
    Note: Prevents reordering of subsequent operations before this load
    Note: Use for: reading shared state, acquiring lock ownership
    Return proc atomic_load_acquire from AtomicImpl with ptr
End Process

Process called "atomic_load_seq_cst" takes ptr as Integer returns Integer:
    Note: Atomically load 64-bit value with sequential consistency
    Note: Strongest ordering - total global order of all seq_cst operations
    Note: Use for: critical sections requiring strict ordering
    Return proc atomic_load_seq_cst from AtomicImpl with ptr
End Process

Note: ============================================================================
Note: Atomic Store Operations
Note: ============================================================================

Process called "atomic_store_relaxed" takes ptr as Integer, value as Integer returns Integer:
    Note: Atomically store 64-bit value with relaxed memory ordering
    Note: No synchronization guarantees, only atomicity
    Note: Use for: updating counters, statistics
    Return proc atomic_store_relaxed from AtomicImpl with ptr, value
End Process

Process called "atomic_store_release" takes ptr as Integer, value as Integer returns Integer:
    Note: Atomically store 64-bit value with release semantics
    Note: Prevents reordering of previous operations after this store
    Note: Use for: publishing shared state, releasing lock
    Return proc atomic_store_release from AtomicImpl with ptr, value
End Process

Process called "atomic_store_seq_cst" takes ptr as Integer, value as Integer returns Integer:
    Note: Atomically store 64-bit value with sequential consistency
    Note: Strongest ordering - total global order
    Note: Use for: critical state updates requiring strict ordering
    Return proc atomic_store_seq_cst from AtomicImpl with ptr, value
End Process

Note: ============================================================================
Note: Atomic Fetch-and-Modify Operations
Note: ============================================================================

Process called "atomic_fetch_add" takes ptr as Integer, value as Integer returns Integer:
    Note: Atomically add value to *ptr and return OLD value
    Note: Memory ordering: seq_cst
    Note: Use for: reference counting, allocation counters
    Return proc atomic_fetch_add from AtomicImpl with ptr, value
End Process

Process called "atomic_fetch_sub" takes ptr as Integer, value as Integer returns Integer:
    Note: Atomically subtract value from *ptr and return OLD value
    Note: Memory ordering: seq_cst
    Note: Use for: reference counting (decrement)
    Return proc atomic_fetch_sub from AtomicImpl with ptr, value
End Process

Process called "atomic_increment" takes ptr as Integer returns Integer:
    Note: Atomically increment *ptr and return NEW value
    Note: Equivalent to: fetch_add(ptr, 1) + 1
    Note: Memory ordering: seq_cst
    Let old_value be proc atomic_fetch_add with ptr, 1
    Let new_value be old_value plus 1
    Return new_value
End Process

Process called "atomic_decrement" takes ptr as Integer returns Integer:
    Note: Atomically decrement *ptr and return NEW value
    Note: Equivalent to: fetch_sub(ptr, 1) - 1
    Note: Memory ordering: seq_cst
    Let old_value be proc atomic_fetch_sub with ptr, 1
    Let new_value be old_value minus 1
    Return new_value
End Process

Process called "atomic_fetch_and" takes ptr as Integer, value as Integer returns Integer:
    Note: Atomically perform *ptr &= value and return OLD value
    Note: Memory ordering: seq_cst
    Note: Use for: clearing bit flags atomically
    Return proc atomic_fetch_and from AtomicImpl with ptr, value
End Process

Process called "atomic_fetch_or" takes ptr as Integer, value as Integer returns Integer:
    Note: Atomically perform *ptr |= value and return OLD value
    Note: Memory ordering: seq_cst
    Note: Use for: setting bit flags atomically
    Return proc atomic_fetch_or from AtomicImpl with ptr, value
End Process

Process called "atomic_fetch_xor" takes ptr as Integer, value as Integer returns Integer:
    Note: Atomically perform *ptr ^= value and return OLD value
    Note: Memory ordering: seq_cst
    Note: Use for: toggling bit flags atomically
    Return proc atomic_fetch_xor from AtomicImpl with ptr, value
End Process

Note: ============================================================================
Note: Compare-and-Swap (CAS) Operations
Note: ============================================================================

Process called "atomic_compare_and_swap" takes ptr as Integer, expected as Integer, desired as Integer returns Integer:
    Note: Strong CAS: atomically compare *ptr with expected, if equal set to desired
    Note: Returns 1 if swap occurred, 0 if comparison failed
    Note: Memory ordering: seq_cst
    Note: Use for: lock-free data structures, optimistic updates
    Note: IMPORTANT: This is STRONG CAS (never spuriously fails)
    Return proc atomic_compare_and_swap from AtomicImpl with ptr, expected, desired
End Process

Process called "atomic_compare_and_swap_weak" takes ptr as Integer, expected as Integer, desired as Integer returns Integer:
    Note: Weak CAS: may spuriously fail even when *ptr == expected
    Note: Returns 1 if swap occurred, 0 if comparison failed OR spurious failure
    Note: Memory ordering: seq_cst
    Note: Use for: loops where retry is cheap (LL/SC architectures)
    Note: IMPORTANT: Always use in a loop, may fail spuriously!
    Return proc atomic_compare_and_swap_weak from AtomicImpl with ptr, expected, desired
End Process

Process called "atomic_exchange" takes ptr as Integer, value as Integer returns Integer:
    Note: Atomically set *ptr to value and return OLD value
    Note: Unconditional swap (always succeeds unlike CAS)
    Note: Memory ordering: seq_cst
    Note: Use for: unconditional updates, swap operations
    Return proc atomic_exchange from AtomicImpl with ptr, value
End Process

Note: ============================================================================
Note: Memory Barrier Operations
Note: ============================================================================

Process called "memory_barrier_acquire" returns Integer:
    Note: Acquire fence: prevents reordering of subsequent loads/stores before fence
    Note: Use after acquiring a lock or loading shared state
    Note: Ensures visibility of writes from other threads
    Return proc memory_barrier_acquire from AtomicImpl
End Process

Process called "memory_barrier_release" returns Integer:
    Note: Release fence: prevents reordering of previous loads/stores after fence
    Note: Use before releasing a lock or publishing shared state
    Note: Ensures writes are visible to other threads
    Return proc memory_barrier_release from AtomicImpl
End Process

Process called "memory_barrier_full" returns Integer:
    Note: Full memory fence: prevents all reorderings across the fence
    Note: Equivalent to both acquire and release
    Note: Use for: critical sections requiring strict ordering
    Return proc memory_barrier_full from AtomicImpl
End Process

Process called "memory_barrier_seq_cst" returns Integer:
    Note: Sequentially consistent fence
    Note: Strongest fence - establishes total global ordering
    Note: Use for: rare cases requiring global synchronization
    Return proc memory_barrier_seq_cst from AtomicImpl
End Process

Note: ============================================================================
Note: Atomic Helper Functions
Note: ============================================================================

Process called "atomic_test_and_set" takes ptr as Integer returns Integer:
    Note: Atomically set bit 0 to 1 and return OLD bit 0 value
    Note: Returns 1 if bit was already set, 0 if it was clear
    Note: Use for: spinlocks, simple flags
    Let old_value be atomic_fetch_or(ptr, 1)
    Let old_bit be old_value bitwise and 1
    Return old_bit
End Process

Process called "atomic_clear" takes ptr as Integer returns Integer:
    Note: Atomically set value to 0
    Note: Equivalent to proc atomic_store_release with ptr, 0
    Return proc atomic_store_release with ptr, 0
End Process

Process called "atomic_flag_test_and_set" takes ptr as Integer returns Integer:
    Note: Test-and-set for lock-free flag (0 or 1)
    Note: Returns 1 if flag was already set (lock taken)
    Note: Returns 0 if flag was clear (lock acquired)
    Note: Use for: spinlock implementation
    Let expected be 0
    Let desired be 1
    Let success be proc atomic_compare_and_swap with ptr, expected, desired
    If success is equal to 1:
        Return 0  Note: Lock acquired (was 0, now 1)
    End If
    Return 1  Note: Lock already held (was 1)
End Process

Note: ============================================================================
Note: Atomic Operation Guidelines
Note: ============================================================================

Note:
WHEN TO USE WHICH OPERATION:

1. RELAXED (fastest, no ordering):
   - Counters that don't affect control flow
   - Statistics, metrics
   - When you don't care about ordering

2. ACQUIRE (moderate cost):
   - Loading shared state
   - Reading after acquiring a lock
   - Checking if data is ready

3. RELEASE (moderate cost):
   - Storing shared state
   - Writing before releasing a lock
   - Publishing data as ready

4. SEQ_CST (slowest, strongest):
   - When you need total global ordering
   - Critical sections with multiple synchronization points
   - When in doubt (safer default)

MEMORY MODEL GUARANTEES:

x86_64:
- All loads/stores are acquire/release by default (TSO model)
- Only need explicit fences for seq_cst
- Very strong memory model

ARM64/RISC-V/PowerPC:
- Weaker memory models (can reorder aggressively)
- Need explicit acquire/release semantics
- Fences are critical for correctness

COMMON PATTERNS:

Producer-Consumer (acquire/release):
  Producer:
    store data
    proc atomic_store_release with flag, 1  // Publish
  Consumer:
    while atomic_load_acquire(flag) == 0: spin
    load data

Spinlock (test-and-set):
  Lock:
    while atomic_flag_test_and_set(lock) == 1: spin
  Unlock:
    atomic_clear(lock)

Reference Counting (fetch_add/fetch_sub):
  Retain:
    proc atomic_fetch_add with refcount, 1
  Release:
    if proc atomic_fetch_sub with refcount, 1 == 1:
      free object

Lock-Free Stack (CAS):
  Push:
    loop:
      old_head = atomic_load_relaxed(head)
      node.next = old_head
      if proc atomic_compare_and_swap with head, old_head, node:
        break
:End Note
