Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
STACK CORE - Stack Management Primitives

This file provides low-level stack operations for function calls, local variables,
and stack frame management. These are compiler primitives used for code generation.

Stack Layout (grows downward, high addresses to low addresses):
    High Address
    +------------------+
    | Caller's Frame   |
    +------------------+
    | Return Address   | <- Pushed by CALL instruction
    +------------------+
    | Saved RBP (FP)   | <- Frame Pointer (previous frame's base)
    +------------------+ <- RBP/Frame Pointer (current frame base)
    | Local Variables  |
    | ...              |
    +------------------+ <- RSP/Stack Pointer (current top of stack)
    Low Address

Stack Operations:
- Push/Pop: Add/remove values from stack
- Frame Management: Setup/teardown function stack frames
- Bounds Checking: Detect stack overflow/underflow

Platform ABIs:
- x86_64 System V: 16-byte stack alignment, RBP frame pointer, RSP stack pointer
- x86_64 Windows: 16-byte stack alignment, shadow space (32 bytes)
- ARM64: 16-byte stack alignment, X29 frame pointer, SP stack pointer
- RISC-V: 16-byte stack alignment, FP/S0 frame pointer, SP stack pointer

Dependencies:
- memory_core.runa: For memory read/write operations
:End Note

Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore

Note: ============================================================================
Note: Stack Pointer Management
Note: ============================================================================

Note: Stack state (maintained by compiler/runtime)
Note: These are typically stored in registers, but can be saved/restored
Let STACK_POINTER be 0          Note: Current top of stack (RSP/SP register)
Let FRAME_POINTER be 0          Note: Current frame base (RBP/FP register)
Let STACK_BASE be 0             Note: Bottom of stack (high address)
Let STACK_LIMIT be 0            Note: Stack overflow limit (low address)

Process called "stack_get_pointer" returns Integer:
    Note: Get current stack pointer (top of stack)
    Note: Returns address of current stack top
    Return STACK_POINTER
End Process

Process called "stack_set_pointer" takes sp as Integer:
    Note: Set stack pointer to new value
    Note: WARNING: Use with caution - can corrupt stack if misused
    Set STACK_POINTER to sp
End Process

Process called "stack_get_frame_pointer" returns Integer:
    Note: Get current frame pointer (base of current frame)
    Note: Returns address of current frame base
    Return FRAME_POINTER
End Process

Process called "stack_set_frame_pointer" takes fp as Integer:
    Note: Set frame pointer to new value
    Note: Used during function prologue/epilogue
    Set FRAME_POINTER to fp
End Process

Process called "stack_initialize" takes stack_base_addr as Integer, stack_size as Integer:
    Note: Initialize stack with base address and size
    Note: stack_base_addr: High address (bottom of stack)
    Note: stack_size: Total stack size in bytes
    Note: Stack grows downward from base_addr
    Set STACK_BASE to stack_base_addr
    Set STACK_POINTER to stack_base_addr
    Set FRAME_POINTER to stack_base_addr
    Set STACK_LIMIT to stack_base_addr minus stack_size
End Process

Note: ============================================================================
Note: Stack Push Operations (64-bit, 32-bit, 16-bit, 8-bit)
Note: ============================================================================

Process called "stack_push_int64" takes value as Integer:
    Note: Push 64-bit value onto stack
    Note: Decrements stack pointer by 8, then writes value
    Set STACK_POINTER to STACK_POINTER minus 8
    proc memory_set_int64 from MemoryCore with STACK_POINTER, 0, value
End Process

Process called "stack_push_int32" takes value as Integer:
    Note: Push 32-bit value onto stack
    Note: Decrements stack pointer by 4, then writes value
    Set STACK_POINTER to STACK_POINTER minus 4
    proc memory_set_int32 from MemoryCore with STACK_POINTER, 0, value
End Process

Process called "stack_push_int16" takes value as Integer:
    Note: Push 16-bit value onto stack
    Note: Decrements stack pointer by 2, then writes value
    Set STACK_POINTER to STACK_POINTER minus 2
    proc memory_set_int16 from MemoryCore with STACK_POINTER, 0, value
End Process

Process called "stack_push_int8" takes value as Integer:
    Note: Push 8-bit value onto stack
    Note: Decrements stack pointer by 1, then writes value
    Set STACK_POINTER to STACK_POINTER minus 1
    proc memory_set_int8 from MemoryCore with STACK_POINTER, 0, value
End Process

Note: ============================================================================
Note: Stack Pop Operations (64-bit, 32-bit, 16-bit, 8-bit)
Note: ============================================================================

Process called "stack_pop_int64" returns Integer:
    Note: Pop 64-bit value from stack
    Note: Reads value, then increments stack pointer by 8
    Let value be proc memory_get_int64 from MemoryCore with STACK_POINTER, 0
    Set STACK_POINTER to STACK_POINTER plus 8
    Return value
End Process

Process called "stack_pop_int32" returns Integer:
    Note: Pop 32-bit value from stack
    Note: Reads value, then increments stack pointer by 4
    Let value be proc memory_get_int32 from MemoryCore with STACK_POINTER, 0
    Set STACK_POINTER to STACK_POINTER plus 4
    Return value
End Process

Process called "stack_pop_int16" returns Integer:
    Note: Pop 16-bit value from stack
    Note: Reads value, then increments stack pointer by 2
    Let value be proc memory_get_int16 from MemoryCore with STACK_POINTER, 0
    Set STACK_POINTER to STACK_POINTER plus 2
    Return value
End Process

Process called "stack_pop_int8" returns Integer:
    Note: Pop 8-bit value from stack
    Note: Reads value, then increments stack pointer by 1
    Let value be proc memory_get_int8 from MemoryCore with STACK_POINTER, 0
    Set STACK_POINTER to STACK_POINTER plus 1
    Return value
End Process

Note: ============================================================================
Note: Stack Frame Operations
Note: ============================================================================

Process called "stack_allocate_frame" takes frame_size as Integer:
    Note: Allocate new stack frame for function
    Note: Typical function prologue:
    Note:   1. Push old frame pointer
    Note:   2. Set frame pointer to current stack pointer
    Note:   3. Allocate space for locals by decrementing stack pointer

    Note: Save old frame pointer
    proc stack_push_int64 with FRAME_POINTER

    Note: Set new frame pointer to current stack pointer
    Set FRAME_POINTER to STACK_POINTER

    Note: Allocate space for local variables
    Set STACK_POINTER to STACK_POINTER minus frame_size
End Process

Process called "stack_deallocate_frame":
    Note: Deallocate current stack frame (function epilogue)
    Note: Typical function epilogue:
    Note:   1. Restore stack pointer to frame pointer
    Note:   2. Pop old frame pointer

    Note: Restore stack pointer to frame base
    Set STACK_POINTER to FRAME_POINTER

    Note: Restore old frame pointer
    Set FRAME_POINTER to proc stack_pop_int64
End Process

Process called "stack_save_frame" returns Integer:
    Note: Save current frame pointer (for setjmp/longjmp or coroutines)
    Note: Returns current frame pointer value
    Return FRAME_POINTER
End Process

Process called "stack_restore_frame" takes saved_fp as Integer:
    Note: Restore frame pointer to saved value
    Note: Used for non-local control flow (longjmp, exception unwinding)
    Set FRAME_POINTER to saved_fp
End Process

Note: ============================================================================
Note: Stack Bounds Checking and Safety
Note: ============================================================================

Process called "stack_check_overflow" returns Integer:
    Note: Check if stack pointer has exceeded stack limit
    Note: Returns 1 if stack overflow detected, 0 if OK
    Note: Stack grows downward, so overflow means SP < STACK_LIMIT
    If STACK_POINTER is less than STACK_LIMIT:
        Return 1
    End If
    Return 0
End Process

Process called "stack_check_underflow" returns Integer:
    Note: Check if stack pointer has gone above stack base
    Note: Returns 1 if stack underflow detected, 0 if OK
    Note: Underflow means popping more than was pushed
    If STACK_POINTER is greater than STACK_BASE:
        Return 1
    End If
    Return 0
End Process

Process called "stack_get_used_size" returns Integer:
    Note: Get number of bytes currently used on stack
    Note: Used size = STACK_BASE - STACK_POINTER
    Let used be STACK_BASE minus STACK_POINTER
    Return used
End Process

Process called "stack_get_available_size" returns Integer:
    Note: Get number of bytes available before stack overflow
    Note: Available = STACK_POINTER - STACK_LIMIT
    Let available be STACK_POINTER minus STACK_LIMIT
    Return available
End Process

Note: ============================================================================
Note: Stack Alignment Operations
Note: ============================================================================

Process called "stack_align" takes alignment as Integer:
    Note: Align stack pointer to specified boundary (typically 16 bytes)
    Note: alignment must be power of 2 (8, 16, 32, etc.)
    Note: Rounds stack pointer DOWN to nearest aligned address
    Note: Formula: SP = SP & ~(alignment - 1)

    Let mask be alignment minus 1
    Let inverted_mask be mask bitwise xor 18446744073709551615
    Set STACK_POINTER to STACK_POINTER bitwise and inverted_mask
End Process

Process called "stack_is_aligned" takes alignment as Integer returns Integer:
    Note: Check if stack pointer is aligned to specified boundary
    Note: Returns 1 if aligned, 0 if not aligned
    Let mask be alignment minus 1
    Let remainder be STACK_POINTER bitwise and mask
    If remainder is equal to 0:
        Return 1
    End If
    Return 0
End Process

Note: ============================================================================
Note: Bulk Stack Operations
Note: ============================================================================

Process called "stack_push_bytes" takes src_ptr as Integer, num_bytes as Integer:
    Note: Push multiple bytes onto stack from memory buffer
    Note: Decrements stack pointer, then copies bytes
    Set STACK_POINTER to STACK_POINTER minus num_bytes

    Note: Copy bytes from source to stack
    Let i be 0
    While i is less than num_bytes:
        Let byte_value be proc memory_get_int8 from MemoryCore with src_ptr, i
        proc memory_set_int8 from MemoryCore with STACK_POINTER, i, byte_value
        Set i to i plus 1
    End While
End Process

Process called "stack_pop_bytes" takes dest_ptr as Integer, num_bytes as Integer:
    Note: Pop multiple bytes from stack into memory buffer
    Note: Copies bytes, then increments stack pointer

    Note: Copy bytes from stack to destination
    Let i be 0
    While i is less than num_bytes:
        Let byte_value be proc memory_get_int8 from MemoryCore with STACK_POINTER, i
        proc memory_set_int8 from MemoryCore with dest_ptr, i, byte_value
        Set i to i plus 1
    End While

    Set STACK_POINTER to STACK_POINTER plus num_bytes
End Process

Process called "stack_peek_int64" takes offset as Integer returns Integer:
    Note: Read 64-bit value at offset from stack pointer WITHOUT popping
    Note: offset 0 = top of stack, offset 8 = next value, etc.
    Let addr be STACK_POINTER plus offset
    Let value be proc memory_get_int64 from MemoryCore with addr, 0
    Return value
End Process

Process called "stack_clear" takes num_bytes as Integer:
    Note: Clear (zero out) num_bytes on top of stack
    Note: Useful for zeroing local variables for security
    Let i be 0
    While i is less than num_bytes:
        proc memory_set_int8 from MemoryCore with STACK_POINTER, i, 0
        Set i to i plus 1
    End While
End Process
