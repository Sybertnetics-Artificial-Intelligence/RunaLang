Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles comparison operations and comparison instruction processing.

This file performs the following tasks:
- Process comparison operations (equal, not equal, less than, greater than, etc.)
- Handle comparison optimization and comparison constant folding
- Manage comparison type handling and comparison conversion
- Process comparison result processing and comparison optimization

This file is essential because of the following reasons:
- Comparison operations are fundamental to conditional logic and decision making
- Proper comparison handling ensures correct relational computation
- Comparison optimization improves performance for conditional operations

This file consists of the following functions/features/operation types:
- Comparison operation processing and comparison instruction handling
- Comparison optimization and comparison constant folding
- Comparison type handling and comparison conversion processing
- Comparison result processing and comparison optimization

Dependencies:
- Imports core/string_core.runa (Layer 0 string functions for string comparisons)
- Imports core/bitwise_core.runa (Layer 2 bitwise operations for unsigned comparison)
- Imports core/arithmetic_core.runa (Layer 2 float arithmetic for epsilon comparison)
:End Note

Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/core/bitwise_core.runa" as BitwiseCore
Import "compiler/frontend/primitives/core/arithmetic_core.runa" as ArithmeticCore

Note: ============================================================================
Note: Core Comparison Operations (Layer 2)
Note: ============================================================================

Note: These primitives provide basic comparison operations. The Runa compiler
Note: already supports these natively with operators like "is equal to",
Note: "is not equal to", "is less than", etc.

Note: These wrapper functions serve several purposes:
Note: 1. Provide named functions for higher-level primitives
Note: 2. Enable type-aware comparisons (string, float, pointer variants included)
Note: 3. Support potential optimization passes
Note: 4. Document the comparison operation interface

Note: Return values: 1 for true, 0 for false
Note: ============================================================================

Process called "equals" takes a as Integer, b as Integer returns Integer:
    Note: Test if a equals b
    Note: Returns 1 if equal, 0 otherwise
    If a is equal to b:
        Return 1
    End If
    Return 0
End Process

Process called "not_equals" takes a as Integer, b as Integer returns Integer:
    Note: Test if a is not equal to b
    Note: Returns 1 if not equal, 0 otherwise
    If a is not equal to b:
        Return 1
    End If
    Return 0
End Process

Process called "less_than" takes a as Integer, b as Integer returns Integer:
    Note: Test if a is less than b
    Note: Returns 1 if true, 0 otherwise
    If a is less than b:
        Return 1
    End If
    Return 0
End Process

Process called "greater_than" takes a as Integer, b as Integer returns Integer:
    Note: Test if a is greater than b
    Note: Returns 1 if true, 0 otherwise
    If a is greater than b:
        Return 1
    End If
    Return 0
End Process

Process called "less_or_equal" takes a as Integer, b as Integer returns Integer:
    Note: Test if a is less than or equal to b
    Note: Returns 1 if true, 0 otherwise
    If a is less than or equal to b:
        Return 1
    End If
    Return 0
End Process

Process called "greater_or_equal" takes a as Integer, b as Integer returns Integer:
    Note: Test if a is greater than or equal to b
    Note: Returns 1 if true, 0 otherwise
    If a is greater than or equal to b:
        Return 1
    End If
    Return 0
End Process

Note: ============================================================================
Note: Utility Comparison Functions
Note: ============================================================================

Process called "is_zero" takes a as Integer returns Integer:
    Note: Test if value is zero
    Note: Returns 1 if zero, 0 otherwise
    If a is equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "is_positive" takes a as Integer returns Integer:
    Note: Test if value is positive (> 0)
    Note: Returns 1 if positive, 0 otherwise
    If a is greater than 0:
        Return 1
    End If
    Return 0
End Process

Process called "is_negative" takes a as Integer returns Integer:
    Note: Test if value is negative (< 0)
    Note: Returns 1 if negative, 0 otherwise
    If a is less than 0:
        Return 1
    End If
    Return 0
End Process

Process called "is_non_zero" takes a as Integer returns Integer:
    Note: Test if value is non-zero
    Note: Returns 1 if non-zero, 0 otherwise
    If a is not equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "compare" takes a as Integer, b as Integer returns Integer:
    Note: Three-way comparison
    Note: Returns: -1 if a < b, 0 if a == b, 1 if a > b
    If a is less than b:
        Return -1
    End If
    If a is greater than b:
        Return 1
    End If
    Return 0
End Process

Note: ============================================================================
Note: Type-Aware Comparisons
Note: ============================================================================

Process called "equals_string" takes a as Integer, b as Integer returns Integer:
    Note: Compare two strings for equality
    Note: Uses string_equals from string_core (Layer 0)
    Note: Returns 1 if equal, 0 otherwise
    Return proc string_equals from StringCore with a, b
End Process

Process called "compare_string" takes a as Integer, b as Integer returns Integer:
    Note: Three-way string comparison
    Note: Uses string_compare from string_core (Layer 0)
    Note: Returns: -1 if a < b, 0 if a == b, 1 if a > b
    Return proc string_compare from StringCore with a, b
End Process

Process called "equals_pointer" takes a as Integer, b as Integer returns Integer:
    Note: Compare two pointers for equality
    Note: Explicit pointer comparison (semantically clearer than generic equals)
    Note: Returns 1 if equal, 0 otherwise
    If a is equal to b:
        Return 1
    End If
    Return 0
End Process

Process called "equals_float_approximate" takes a as Integer, b as Integer, epsilon as Integer returns Integer:
    Note: Compare two INTEGER values with epsilon tolerance
    Note: This is for integer-based approximate comparison, NOT float comparison
    Note: For IEEE 754 float comparison, use equals_float() instead
    Note: epsilon is the maximum allowed difference
    Note: Returns 1 if |a - b| <= epsilon, 0 otherwise

    Let diff be a minus b
    If diff is less than 0:
        Set diff to -diff  Note: Absolute value
    End If

    If diff is less than or equal to epsilon:
        Return 1
    End If
    Return 0
End Process

Process called "compare_unsigned" takes a as Integer, b as Integer returns Integer:
    Note: Three-way comparison treating values as unsigned
    Note: Proper unsigned comparison using bit pattern reinterpretation
    Note: Returns: -1 if a < b (unsigned), 0 if a == b, 1 if a > b (unsigned)

    Note: Algorithm: For unsigned comparison of 64-bit values:
    Note: 1. If a == b, return 0
    Note: 2. Extract sign bits (bit 63) of both values
    Note: 3. If sign bits differ:
    Note:    - Negative (in signed) is actually LARGER in unsigned (0x8000... > 0x7FFF...)
    Note:    - If a is negative and b is positive, a > b (unsigned)
    Note:    - If a is positive and b is negative, a < b (unsigned)
    Note: 4. If sign bits are same, signed comparison gives correct unsigned result

    Note: Fast path: equality check
    If a is equal to b:
        Return 0
    End If

    Note: Extract sign bits using arithmetic right shift
    Note: After shifting 63 bits, we get -1 (all 1s) for negative, 0 for non-negative
    Let a_sign be proc right_shift from BitwiseCore with a, 63
    Let b_sign be proc right_shift from BitwiseCore with b, 63

    Note: Check if signs differ
    Note: a_sign and b_sign are now either 0 (positive) or -1 (negative in signed = 0xFFFFFFFFFFFFFFFF)
    If a_sign is not equal to b_sign:
        Note: Signs differ - negative (in signed) is larger (in unsigned)
        If a_sign is less than 0:
            Note: a is negative (signed) = large positive (unsigned), so a > b (unsigned)
            Return 1
        Otherwise:
            Note: b is negative (signed) = large positive (unsigned), so a < b (unsigned)
            Return -1
        End If
    End If

    Note: Signs are the same - regular signed comparison works for unsigned
    Note: This is because when both have same sign bit, relative ordering is preserved
    If a is less than b:
        Return -1
    End If
    Return 1
End Process

Process called "is_null" takes ptr as Integer returns Integer:
    Note: Test if pointer is NULL (0)
    Note: Semantically clearer than is_zero for pointer contexts
    Note: Returns 1 if NULL, 0 otherwise
    If ptr is equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "is_not_null" takes ptr as Integer returns Integer:
    Note: Test if pointer is not NULL (non-zero)
    Note: Semantically clearer than is_non_zero for pointer contexts
    Note: Returns 1 if not NULL, 0 otherwise
    If ptr is not equal to 0:
        Return 1
    End If
    Return 0
End Process

Note: ============================================================================
Note: IEEE 754 Float Support (Float64)
Note: ============================================================================

Process called "is_nan" takes float_ptr as Integer returns Integer:
    Note: Test if float64 value is NaN
    Note: float_ptr points to 8-byte float64 value
    Note: Returns 1 if NaN, 0 otherwise

    Note: IEEE 754 NaN: exponent = 0x7FF (all 1s), mantissa != 0

    Let bits be proc memory_get_int64 from BitwiseCore with float_ptr, 0

    Note: Extract exponent (bits 52-62, 11 bits)
    Let exponent_mask be 9218868437227405312
    Let exponent_bits be proc bitwise_and from BitwiseCore with bits, exponent_mask
    Let exponent_shifted be proc right_shift from BitwiseCore with exponent_bits, 52

    Note: Extract mantissa (bits 0-51, 52 bits)
    Let mantissa_mask be 4503599627370495
    Let mantissa_bits be proc bitwise_and from BitwiseCore with bits, mantissa_mask

    Note: NaN: exponent = 0x7FF AND mantissa != 0
    If exponent_shifted is equal to 2047:
        If mantissa_bits is not equal to 0:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "is_infinity" takes float_ptr as Integer returns Integer:
    Note: Test if float64 value is infinity (positive or negative)
    Note: float_ptr points to 8-byte float64 value
    Note: Returns 1 if infinity, 0 otherwise

    Note: IEEE 754 Infinity: exponent = 0x7FF (all 1s), mantissa = 0

    Let bits be proc memory_get_int64 from BitwiseCore with float_ptr, 0

    Note: Extract exponent (bits 52-62, 11 bits)
    Let exponent_mask be 9218868437227405312
    Let exponent_bits be proc bitwise_and from BitwiseCore with bits, exponent_mask
    Let exponent_shifted be proc right_shift from BitwiseCore with exponent_bits, 52

    Note: Extract mantissa (bits 0-51, 52 bits)
    Let mantissa_mask be 4503599627370495
    Let mantissa_bits be proc bitwise_and from BitwiseCore with bits, mantissa_mask

    Note: Infinity: exponent = 0x7FF AND mantissa = 0
    If exponent_shifted is equal to 2047:
        If mantissa_bits is equal to 0:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "is_positive_infinity" takes float_ptr as Integer returns Integer:
    Note: Test if float64 value is positive infinity
    Note: Returns 1 if +Infinity, 0 otherwise

    Let bits be proc memory_get_int64 from BitwiseCore with float_ptr, 0

    Note: Check if infinity first
    If proc is_infinity with float_ptr is equal to 0:
        Return 0
    End If

    Note: Check sign bit (bit 63): 0 = positive, 1 = negative
    Let sign_mask be -9223372036854775808
    Let sign_bit be proc bitwise_and from BitwiseCore with bits, sign_mask

    If sign_bit is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "is_negative_infinity" takes float_ptr as Integer returns Integer:
    Note: Test if float64 value is negative infinity
    Note: Returns 1 if -Infinity, 0 otherwise

    Let bits be proc memory_get_int64 from BitwiseCore with float_ptr, 0

    Note: Check if infinity first
    If proc is_infinity with float_ptr is equal to 0:
        Return 0
    End If

    Note: Check sign bit (bit 63): 0 = positive, 1 = negative
    Let sign_mask be -9223372036854775808
    Let sign_bit be proc bitwise_and from BitwiseCore with bits, sign_mask

    If sign_bit is not equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "is_float_zero" takes float_ptr as Integer returns Integer:
    Note: Test if float64 value is zero (positive or negative zero)
    Note: Returns 1 if ±0.0, 0 otherwise

    Note: IEEE 754: ±0.0 has exponent = 0, mantissa = 0 (sign can be 0 or 1)

    Let bits be proc memory_get_int64 from BitwiseCore with float_ptr, 0

    Note: Mask out sign bit and check if remaining bits are zero
    Let magnitude_mask be 9223372036854775807
    Let magnitude_bits be proc bitwise_and from BitwiseCore with bits, magnitude_mask

    If magnitude_bits is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "equals_float" takes a_ptr as Integer, b_ptr as Integer, epsilon_ptr as Integer, scratch_ptr as Integer returns Integer:
    Note: Compare two float64 values with epsilon tolerance
    Note: All pointers point to 8-byte float64 values
    Note: Returns 1 if |a - b| <= epsilon, 0 otherwise
    Note: SCRATCH SPACE REQUIRED: 40 bytes (8 bytes diff + 8 bytes float_subtract scratch + 24 bytes for less_or_equal_float)

    Note: Special cases:
    Note: - NaN != NaN (IEEE 754 standard)
    Note: - +Inf == +Inf, -Inf == -Inf
    Note: - +0.0 == -0.0

    Note: Check for NaN (NaN != anything, including itself)
    If proc is_nan with a_ptr is equal to 1:
        Return 0
    End If
    If proc is_nan with b_ptr is equal to 1:
        Return 0
    End If

    Note: Check for infinities
    If proc is_infinity with a_ptr is equal to 1:
        If proc is_infinity with b_ptr is equal to 1:
            Note: Both infinity - check if same sign
            Let a_bits be proc memory_get_int64 from BitwiseCore with a_ptr, 0
            Let b_bits be proc memory_get_int64 from BitwiseCore with b_ptr, 0
            If a_bits is equal to b_bits:
                Return 1
            End If
        End If
        Return 0
    End If
    If proc is_infinity with b_ptr is equal to 1:
        Return 0
    End If

    Note: Check for ±0.0 (should be considered equal)
    If proc is_float_zero with a_ptr is equal to 1:
        If proc is_float_zero with b_ptr is equal to 1:
            Return 1
        End If
    End If

    Note: Exact bit equality check (fast path)
    Let a_bits be proc memory_get_int64 from BitwiseCore with a_ptr, 0
    Let b_bits be proc memory_get_int64 from BitwiseCore with b_ptr, 0
    If a_bits is equal to b_bits:
        Return 1
    End If

    Note: Epsilon-based comparison using float arithmetic primitives
    Note: Algorithm: |a - b| <= epsilon

    Note: Use scratch buffer for difference calculation
    Let diff_ptr be scratch_ptr
    Let subtract_scratch be scratch_ptr plus 8
    Let compare_scratch be scratch_ptr plus 16

    Note: Compute a - b
    proc float_subtract from ArithmeticCore with a_ptr, b_ptr, diff_ptr, subtract_scratch

    Note: Compute |a - b|
    proc float_abs from ArithmeticCore with diff_ptr, diff_ptr

    Note: Compare |diff| <= epsilon
    Let result be proc less_or_equal_float with diff_ptr, epsilon_ptr, compare_scratch

    Return result
End Process

Process called "less_than_float" takes a_ptr as Integer, b_ptr as Integer returns Integer:
    Note: Compare two float64 values: a < b
    Note: Returns 1 if a < b, 0 otherwise

    Note: Special cases:
    Note: - NaN comparisons always return false
    Note: - -Inf < any finite value < +Inf
    Note: - +0.0 == -0.0 (not less than)

    Note: NaN comparisons always return false
    If proc is_nan with a_ptr is equal to 1:
        Return 0
    End If
    If proc is_nan with b_ptr is equal to 1:
        Return 0
    End If

    Note: Handle infinities
    If proc is_negative_infinity with a_ptr is equal to 1:
        Note: -Inf < anything except -Inf
        If proc is_negative_infinity with b_ptr is equal to 1:
            Return 0
        End If
        Return 1
    End If

    If proc is_positive_infinity with a_ptr is equal to 1:
        Note: +Inf is not less than anything
        Return 0
    End If

    If proc is_negative_infinity with b_ptr is equal to 1:
        Note: finite value not less than -Inf
        Return 0
    End If

    If proc is_positive_infinity with b_ptr is equal to 1:
        Note: any finite value < +Inf
        Return 1
    End If

    Note: Both are finite - compare using IEEE 754 bit representation
    Let a_bits be proc memory_get_int64 from BitwiseCore with a_ptr, 0
    Let b_bits be proc memory_get_int64 from BitwiseCore with b_ptr, 0

    Note: Extract sign bits
    Let a_sign be proc right_shift from BitwiseCore with a_bits, 63
    Let b_sign be proc right_shift from BitwiseCore with b_bits, 63

    Note: Check for ±0.0 (equal)
    If proc is_float_zero with a_ptr is equal to 1:
        If proc is_float_zero with b_ptr is equal to 1:
            Return 0
        End If
    End If

    Note: If signs differ, negative < positive
    If a_sign is not equal to b_sign:
        If a_sign is less than 0:
            Return 1
        End If
        Return 0
    End If

    Note: Same sign - use magnitude comparison
    Note: For negative numbers, smaller magnitude means larger value
    Let magnitude_mask be 9223372036854775807
    Let a_magnitude be proc bitwise_and from BitwiseCore with a_bits, magnitude_mask
    Let b_magnitude be proc bitwise_and from BitwiseCore with b_bits, magnitude_mask

    If a_sign is less than 0:
        Note: Both negative - smaller magnitude is larger value
        If a_magnitude is greater than b_magnitude:
            Return 1
        End If
    Otherwise:
        Note: Both positive - smaller magnitude is smaller value
        If a_magnitude is less than b_magnitude:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "greater_than_float" takes a_ptr as Integer, b_ptr as Integer returns Integer:
    Note: Compare two float64 values: a > b
    Note: Returns 1 if a > b, 0 otherwise
    Note: Implemented as b < a

    Return proc less_than_float with b_ptr, a_ptr
End Process

Process called "less_or_equal_float" takes a_ptr as Integer, b_ptr as Integer, scratch_ptr as Integer returns Integer:
    Note: Compare two float64 values: a <= b
    Note: Returns 1 if a <= b, 0 otherwise
    Note: SCRATCH SPACE REQUIRED: 24 bytes (8 bytes for epsilon + 16 bytes for equals_float scratch)

    If proc less_than_float with a_ptr, b_ptr is equal to 1:
        Return 1
    End If

    Note: Check equality (using epsilon approach from equals_float)
    Let epsilon_ptr be scratch_ptr
    Let equals_scratch be scratch_ptr plus 8
    proc memory_set_int64 from BitwiseCore with epsilon_ptr, 0, 0
    Let result be proc equals_float with a_ptr, b_ptr, epsilon_ptr, equals_scratch

    Return result
End Process

Process called "greater_or_equal_float" takes a_ptr as Integer, b_ptr as Integer, scratch_ptr as Integer returns Integer:
    Note: Compare two float64 values: a >= b
    Note: Returns 1 if a >= b, 0 otherwise
    Note: Implemented as b <= a
    Note: SCRATCH SPACE REQUIRED: 24 bytes (passed through to less_or_equal_float)

    Return proc less_or_equal_float with b_ptr, a_ptr, scratch_ptr
End Process

Note: ============================================================================
Note: Float Comparison Notes
Note: ============================================================================

Note: The above functions provide complete IEEE 754 float64 comparison support:
Note: - NaN handling (NaN != NaN, all comparisons with NaN return false)
Note: - Infinity handling (±Inf comparisons work correctly)
Note: - Signed zero handling (+0.0 == -0.0)
Note: - Proper bit-level comparison for finite values

Note: All functions take pointers to 8-byte float64 values in memory.
Note: ============================================================================
