Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file provides low-level memory operations using inline assembly.

These functions replace the C runtime memory functions:
- memory_get_byte/int32/int64/integer/pointer - read from memory
- memory_set_byte/int32/int64/integer/pointer - write to memory
- memory_copy - replaces memcpy
- memory_fill - replaces memset (renamed from memory_set)
- memory_compare - replaces memcmp

All operations use direct memory access through inline assembly.
This is a foundation primitive with NO dependencies.
:End Note

Note: ============================================================================
Note: Memory Read Operations
Note: ============================================================================

Process called "memory_get_byte" takes ptr as Integer, offset as Integer returns Integer:
    Note: Read a single byte from memory at ptr + offset
    Note: Returns the byte value (0-255)

    Let result be 0
    Inline Assembly:
        # Calculate address: ptr + offset
        movq -8(%rbp), %rax      # Load ptr
        movq -16(%rbp), %rbx     # Load offset
        addq %rbx, %rax          # rax = ptr + offset

        # Read byte and zero-extend to 64-bit
        movzbq (%rax), %rax      # Load byte, zero-extend

        # Store result
        movq %rax, -24(%rbp)
    End Assembly
    Return result
End Process

Process called "memory_get_int32" takes ptr as Integer, offset as Integer returns Integer:
    Note: Read a 32-bit integer from memory at ptr + offset
    Note: Returns the int32 value (sign-extended to 64-bit)

    Let result be 0
    Inline Assembly:
        # Calculate address: ptr + offset
        movq -8(%rbp), %rax      # Load ptr
        movq -16(%rbp), %rbx     # Load offset
        addq %rbx, %rax          # rax = ptr + offset

        # Read int32 and sign-extend to 64-bit
        movslq (%rax), %rax      # Load int32, sign-extend

        # Store result
        movq %rax, -24(%rbp)
    End Assembly
    Return result
End Process

Process called "memory_get_int64" takes ptr as Integer, offset as Integer returns Integer:
    Note: Read a 64-bit integer from memory at ptr + offset
    Note: Returns the int64 value

    Let result be 0
    Inline Assembly:
        # Calculate address: ptr + offset
        movq -8(%rbp), %rax      # Load ptr
        movq -16(%rbp), %rbx     # Load offset
        addq %rbx, %rax          # rax = ptr + offset

        # Read int64
        movq (%rax), %rax        # Load 64-bit value

        # Store result
        movq %rax, -24(%rbp)
    End Assembly
    Return result
End Process

Process called "memory_get_integer" takes ptr as Integer, offset as Integer returns Integer:
    Note: Alias for memory_get_int64 (Integer is 64-bit in Runa)
    Return memory_get_int64(ptr, offset)
End Process

Process called "memory_get_pointer" takes ptr as Integer, offset as Integer returns Integer:
    Note: Read a pointer (64-bit address) from memory at ptr + offset
    Note: Alias for memory_get_int64
    Return memory_get_int64(ptr, offset)
End Process

Note: ============================================================================
Note: Memory Write Operations
Note: ============================================================================

Process called "memory_set_byte" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Note: Write a single byte to memory at ptr + offset
    Note: Only the lowest 8 bits of value are written
    Note: Returns 0

    Let dummy be 0
    Inline Assembly:
        # Calculate address: ptr + offset
        movq -8(%rbp), %rax      # Load ptr
        movq -16(%rbp), %rbx     # Load offset
        addq %rbx, %rax          # rax = ptr + offset

        # Write byte
        movq -24(%rbp), %rcx     # Load value
        movb %cl, (%rax)         # Store low byte
    End Assembly
    Return 0
End Process

Process called "memory_set_int32" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Note: Write a 32-bit integer to memory at ptr + offset
    Note: Only the lowest 32 bits of value are written
    Note: Returns 0

    Let dummy be 0
    Inline Assembly:
        # Calculate address: ptr + offset
        movq -8(%rbp), %rax      # Load ptr
        movq -16(%rbp), %rbx     # Load offset
        addq %rbx, %rax          # rax = ptr + offset

        # Write int32
        movq -24(%rbp), %rcx     # Load value
        movl %ecx, (%rax)        # Store 32-bit value
    End Assembly
    Return 0
End Process

Process called "memory_set_int64" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Note: Write a 64-bit integer to memory at ptr + offset
    Note: Returns 0

    Let dummy be 0
    Inline Assembly:
        # Calculate address: ptr + offset
        movq -8(%rbp), %rax      # Load ptr
        movq -16(%rbp), %rbx     # Load offset
        addq %rbx, %rax          # rax = ptr + offset

        # Write int64
        movq -24(%rbp), %rcx     # Load value
        movq %rcx, (%rax)        # Store 64-bit value
    End Assembly
    Return 0
End Process

Process called "memory_set_integer" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Note: Alias for memory_set_int64 (Integer is 64-bit in Runa)
    Return memory_set_int64(ptr, offset, value)
End Process

Process called "memory_set_pointer" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Note: Write a pointer (64-bit address) to memory at ptr + offset
    Note: Alias for memory_set_int64
    Return memory_set_int64(ptr, offset, value)
End Process

Note: ============================================================================
Note: Bulk Memory Operations
Note: ============================================================================

Process called "memory_copy" takes dest as Integer, src as Integer, length as Integer returns Integer:
    Note: Copy length bytes from src to dest
    Note: Uses rep movsb for efficient copying
    Note: Returns 0

    Let dummy be 0
    Inline Assembly:
        # Load parameters
        movq -8(%rbp), %rdi      # dest
        movq -16(%rbp), %rsi     # src
        movq -24(%rbp), %rcx     # length

        # Copy bytes using rep movsb
        # This repeats movsb (copy byte from RSI to RDI) RCX times
        rep movsb
    End Assembly
    Return 0
End Process

Process called "memory_fill" takes dest as Integer, value as Integer, length as Integer returns Integer:
    Note: Set length bytes at dest to value (only low 8 bits of value)
    Note: Uses rep stosb for efficient filling
    Note: Returns 0
    Note: Renamed from memory_set to avoid confusion with memory_set_* functions

    Let dummy be 0
    Inline Assembly:
        # Load parameters
        movq -8(%rbp), %rdi      # dest
        movq -16(%rbp), %rax     # value (low byte will be used)
        movq -24(%rbp), %rcx     # length

        # Fill bytes using rep stosb
        # This repeats stosb (store AL to RDI) RCX times
        rep stosb
    End Assembly
    Return 0
End Process

Process called "memory_compare" takes ptr1 as Integer, ptr2 as Integer, length as Integer returns Integer:
    Note: Compare length bytes at ptr1 and ptr2
    Note: Returns 0 if equal, non-zero if different
    Note: Uses rep cmpsb for efficient comparison

    Let result be 0
    Inline Assembly:
        # Load parameters
        movq -8(%rbp), %rsi      # ptr1
        movq -16(%rbp), %rdi     # ptr2
        movq -24(%rbp), %rcx     # length

        # Compare bytes using rep cmpsb
        # This repeats cmpsb (compare byte at RSI with RDI) RCX times
        # Zero flag is set if all bytes match
        repe cmpsb

        # Set result based on zero flag
        # If ZF=1 (equal), result = 0
        # If ZF=0 (not equal), result = 1
        setnz %al                # AL = 1 if not zero (not equal)
        movzbq %al, %rax         # Zero-extend to 64-bit
        movq %rax, -32(%rbp)
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: Memory Allocation Helpers
Note: ============================================================================

Process called "memory_zero" takes ptr as Integer, length as Integer returns Integer:
    Note: Zero out length bytes at ptr
    Note: Convenience wrapper for memory_fill(ptr, 0, length)
    Return memory_fill(ptr, 0, length)
End Process
