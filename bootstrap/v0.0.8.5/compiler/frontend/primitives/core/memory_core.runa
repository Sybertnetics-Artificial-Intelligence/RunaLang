Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file provides low-level memory operations as compiler intrinsics.

These functions replace the C runtime memory functions:
- memory_get_byte/int32/int64/integer/pointer - read from memory
- memory_set_byte/int32/int64/integer/pointer - write to memory
- memory_copy - replaces memcpy
- memory_fill - replaces memset (renamed from memory_set)
- memory_compare - replaces memcmp

All operations are platform-independent compiler intrinsics.
The compiler lowers these to appropriate platform-specific instructions:
- x86_64: mov, rep movsb/stosb/cmpsb
- ARM64: ldr, str, ldp, stp, memory copy loops
- RISC-V: lb, sb, lw, sw, ld, sd, memory loops
- PowerPC: lbz, stb, lwz, stw, ld, std, memory loops
- MIPS: lb, sb, lw, sw, ld, sd, memory loops

This is a foundation primitive with NO dependencies.
:End Note

Note: ============================================================================
Note: Memory Read Operations
Note: ============================================================================

Process called "memory_get_byte" takes ptr as Integer, offset as Integer returns Integer:
    Note: Read a single byte from memory at ptr + offset
    Note: Returns the byte value (0-255)
    Note: Compiler intrinsic - platform independent
    Note: Lowers to: movzbq (x86_64), ldrb (ARM64), lbu (RISC-V), lbz (PowerPC), lbu (MIPS)

    Let address be ptr plus offset
    Let result be load_byte_unsigned(address)
    Return result
End Process

Process called "memory_get_int32" takes ptr as Integer, offset as Integer returns Integer:
    Note: Read a 32-bit integer from memory at ptr + offset
    Note: Returns the int32 value (sign-extended to 64-bit)
    Note: Compiler intrinsic - platform independent
    Note: Lowers to: movslq (x86_64), ldrsw (ARM64), lw (RISC-V), lwa (PowerPC), lw (MIPS)

    Let address be ptr plus offset
    Let result be load_int32_signed(address)
    Return result
End Process

Process called "memory_get_int64" takes ptr as Integer, offset as Integer returns Integer:
    Note: Read a 64-bit integer from memory at ptr + offset
    Note: Returns the int64 value
    Note: Compiler intrinsic - platform independent
    Note: Lowers to: movq (x86_64), ldr (ARM64), ld (RISC-V), ld (PowerPC), ld (MIPS)

    Let address be ptr plus offset
    Let result be load_int64(address)
    Return result
End Process

Process called "memory_get_integer" takes ptr as Integer, offset as Integer returns Integer:
    Note: Alias for memory_get_int64 (Integer is 64-bit in Runa)
    Return memory_get_int64(ptr, offset)
End Process

Process called "memory_get_pointer" takes ptr as Integer, offset as Integer returns Integer:
    Note: Read a pointer (64-bit address) from memory at ptr + offset
    Note: Alias for memory_get_int64
    Return memory_get_int64(ptr, offset)
End Process

Note: ============================================================================
Note: Memory Write Operations
Note: ============================================================================

Process called "memory_set_byte" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Note: Write a single byte to memory at ptr + offset
    Note: Only the lowest 8 bits of value are written
    Note: Returns 0
    Note: Compiler intrinsic - platform independent
    Note: Lowers to: movb (x86_64), strb (ARM64), sb (RISC-V), stb (PowerPC), sb (MIPS)

    Let address be ptr plus offset
    Let dummy be store_byte(address, value)
    Return 0
End Process

Process called "memory_set_int32" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Note: Write a 32-bit integer to memory at ptr + offset
    Note: Only the lowest 32 bits of value are written
    Note: Returns 0
    Note: Compiler intrinsic - platform independent
    Note: Lowers to: movl (x86_64), str (ARM64 w-reg), sw (RISC-V), stw (PowerPC), sw (MIPS)

    Let address be ptr plus offset
    Let dummy be store_int32(address, value)
    Return 0
End Process

Process called "memory_set_int64" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Note: Write a 64-bit integer to memory at ptr + offset
    Note: Returns 0
    Note: Compiler intrinsic - platform independent
    Note: Lowers to: movq (x86_64), str (ARM64 x-reg), sd (RISC-V), std (PowerPC), sd (MIPS)

    Let address be ptr plus offset
    Let dummy be store_int64(address, value)
    Return 0
End Process

Process called "memory_set_integer" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Note: Alias for memory_set_int64 (Integer is 64-bit in Runa)
    Return memory_set_int64(ptr, offset, value)
End Process

Process called "memory_set_pointer" takes ptr as Integer, offset as Integer, value as Integer returns Integer:
    Note: Write a pointer (64-bit address) to memory at ptr + offset
    Note: Alias for memory_set_int64
    Return memory_set_int64(ptr, offset, value)
End Process

Note: ============================================================================
Note: Bulk Memory Operations
Note: ============================================================================

Process called "memory_copy" takes dest as Integer, src as Integer, length as Integer returns Integer:
    Note: Copy length bytes from src to dest
    Note: Platform independent - compiler generates optimal code
    Note: Lowers to: rep movsb (x86_64), ldp/stp loop (ARM64), word-aligned loop (RISC-V/PowerPC/MIPS)
    Note: Returns 0

    Note: Byte-by-byte copy loop (compiler will optimize to bulk operations)
    Let i be 0
    While i is less than length:
        Let byte_value be memory_get_byte(src, i)
        Let dummy be memory_set_byte(dest, i, byte_value)
        Set i to i plus 1
    End While

    Return 0
End Process

Process called "memory_fill" takes dest as Integer, value as Integer, length as Integer returns Integer:
    Note: Set length bytes at dest to value (only low 8 bits of value)
    Note: Platform independent - compiler generates optimal code
    Note: Lowers to: rep stosb (x86_64), stp loop (ARM64), word-aligned loop (RISC-V/PowerPC/MIPS)
    Note: Returns 0
    Note: Renamed from memory_set to avoid confusion with memory_set_* functions

    Note: Byte-by-byte fill loop (compiler will optimize to bulk operations)
    Let i be 0
    While i is less than length:
        Let dummy be memory_set_byte(dest, i, value)
        Set i to i plus 1
    End While

    Return 0
End Process

Process called "memory_compare" takes ptr1 as Integer, ptr2 as Integer, length as Integer returns Integer:
    Note: Compare length bytes at ptr1 and ptr2
    Note: Returns 0 if equal, non-zero (1) if different
    Note: Platform independent - compiler generates optimal code
    Note: Lowers to: rep cmpsb (x86_64), ldp comparison loop (ARM64), word-aligned comparison (RISC-V/PowerPC/MIPS)

    Note: Byte-by-byte comparison loop (compiler will optimize to bulk operations)
    Let i be 0
    While i is less than length:
        Let byte1 be memory_get_byte(ptr1, i)
        Let byte2 be memory_get_byte(ptr2, i)

        If byte1 is not equal to byte2:
            Return 1  Note: Bytes differ
        End If

        Set i to i plus 1
    End While

    Return 0  Note: All bytes match
End Process

Note: ============================================================================
Note: Memory Allocation Helpers
Note: ============================================================================

Process called "memory_zero" takes ptr as Integer, length as Integer returns Integer:
    Note: Zero out length bytes at ptr
    Note: Convenience wrapper for memory_fill(ptr, 0, length)
    Return memory_fill(ptr, 0, length)
End Process
