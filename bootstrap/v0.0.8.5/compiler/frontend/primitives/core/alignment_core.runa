Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file provides memory alignment operations.

Memory alignment is critical for:
- CPU performance (aligned loads/stores are faster)
- Hardware requirements (some CPUs require aligned access)
- Data structure layout (struct padding)

Functions:
- align_up/align_down - round size/address to alignment boundary
- is_aligned - check if value is aligned
- calculate_padding - how many bytes needed to reach alignment

Depends on: pointer_primitive.runa (Layer 0)
:End Note

Import "compiler/frontend/primitives/core/pointer_primitive.runa" as Pointer

Note: ============================================================================
Note: Alignment Operations
Note: ============================================================================

Process called "align_up" takes value as Integer, alignment as Integer returns Integer:
    Note: Round value up to next alignment boundary
    Note: alignment must be power of 2 (1, 2, 4, 8, 16, etc.)
    Note: If already aligned, returns value unchanged
    Note: Examples:
    Note:   align_up(13, 4) = 16
    Note:   align_up(16, 4) = 16
    Note:   align_up(17, 4) = 20

    Return pointer_align_up(value, alignment)
End Process

Process called "align_down" takes value as Integer, alignment as Integer returns Integer:
    Note: Round value down to previous alignment boundary
    Note: alignment must be power of 2
    Note: If already aligned, returns value unchanged
    Note: Examples:
    Note:   align_down(13, 4) = 12
    Note:   align_down(16, 4) = 16
    Note:   align_down(17, 4) = 16

    Return pointer_align_down(value, alignment)
End Process

Process called "is_aligned" takes value as Integer, alignment as Integer returns Integer:
    Note: Check if value is aligned to alignment boundary
    Note: Returns 1 if aligned, 0 if not aligned
    Note: Examples:
    Note:   is_aligned(16, 4) = 1
    Note:   is_aligned(17, 4) = 0

    Return pointer_is_aligned(value, alignment)
End Process

Note: ============================================================================
Note: Padding Calculations
Note: ============================================================================

Process called "calculate_padding" takes value as Integer, alignment as Integer returns Integer:
    Note: Calculate how many bytes needed to align value
    Note: Returns 0 if already aligned
    Note: Examples:
    Note:   calculate_padding(13, 4) = 3  (13 + 3 = 16)
    Note:   calculate_padding(16, 4) = 0  (already aligned)

    Let remainder be value Modulo by alignment

    If remainder is equal to 0:
        Return 0  Note: Already aligned
    End If

    Let padding be alignment minus remainder
    Return padding
End Process

Process called "calculate_padding_with_header" takes value as Integer, alignment as Integer, header_size as Integer returns Integer:
    Note: Calculate padding needed after a header
    Note: Useful for struct layouts where you have a header followed by aligned data
    Note: Returns total padding needed
    Note: Example: If at offset 10, need 8-byte alignment, and have 4-byte header:
    Note:   Current: 10, after header: 14, next aligned: 16, padding: 2

    Let offset_after_header be value plus header_size
    Let padding be calculate_padding(offset_after_header, alignment)
    Return padding
End Process

Note: ============================================================================
Note: Struct Layout Helpers
Note: ============================================================================

Process called "align_struct_field" takes current_offset as Integer, field_alignment as Integer returns Integer:
    Note: Calculate offset for next struct field with proper alignment
    Note: Returns aligned offset where field should be placed
    Note: Example: If current offset is 13 and field needs 4-byte alignment:
    Note:   Returns 16 (rounded up from 13)

    Return align_up(current_offset, field_alignment)
End Process

Process called "align_struct_size" takes size as Integer, struct_alignment as Integer returns Integer:
    Note: Calculate total struct size with padding at end
    Note: Structs must be sized so that arrays of them are properly aligned
    Note: Example: Struct with 13 bytes and 4-byte alignment needs to be 16 bytes

    Return align_up(size, struct_alignment)
End Process

Note: ============================================================================
Note: Common Alignment Constants
Note: ============================================================================

Process called "ALIGN_BYTE" returns Integer:
    Note: 1-byte alignment (no alignment)
    Return 1
End Process

Process called "ALIGN_WORD" returns Integer:
    Note: 2-byte alignment (16-bit word)
    Return 2
End Process

Process called "ALIGN_DWORD" returns Integer:
    Note: 4-byte alignment (32-bit double word)
    Return 4
End Process

Process called "ALIGN_QWORD" returns Integer:
    Note: 8-byte alignment (64-bit quad word)
    Return 8
End Process

Process called "ALIGN_PARAGRAPH" returns Integer:
    Note: 16-byte alignment (128-bit, SIMD, cache line sub-block)
    Return 16
End Process

Process called "ALIGN_CACHE_LINE" returns Integer:
    Note: 64-byte alignment (typical CPU cache line)
    Return 64
End Process

Process called "ALIGN_PAGE" returns Integer:
    Note: 4KB alignment (typical memory page size)
    Return 4096
End Process

Note: ============================================================================
Note: Alignment Validation
Note: ============================================================================

Process called "is_power_of_two" takes value as Integer returns Integer:
    Note: Check if value is a power of 2
    Note: Valid alignments must be powers of 2
    Note: Returns 1 if power of 2, 0 otherwise

    If value is less than or equal to 0:
        Return 0
    End If

    Note: Power of 2 has exactly one bit set
    Note: value & (value - 1) == 0 for powers of 2
    Let value_minus_one be value minus 1
    Let bitwise_and be value bit_and value_minus_one

    If bitwise_and is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "validate_alignment" takes alignment as Integer returns Integer:
    Note: Validate that alignment is a positive power of 2
    Note: Returns 1 if valid, 0 if invalid

    Return is_power_of_two(alignment)
End Process
