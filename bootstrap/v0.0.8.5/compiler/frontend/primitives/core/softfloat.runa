Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
Float128 Software Floating-Point Library

This file implements IEEE 754 quadruple precision (128-bit) floating-point
arithmetic using software emulation.

Format: 1 sign bit, 15 exponent bits, 112 mantissa bits
Precision: ~34 decimal digits
Range: ±1.2×10^4932

This is a pure Runa implementation with no external dependencies.
:End Note

Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/frontend/primitives/core/bitwise_core.runa" as BitwiseCore

Note: ============================================================================
Note: Float128 Constants
Note: ============================================================================

Note: IEEE 754 quadruple precision format (128 bits):
Note: Bit 127: Sign bit (0 = positive, 1 = negative)
Note: Bits 126-112: Exponent (15 bits, biased by 16383)
Note: Bits 111-0: Mantissa (112 bits, implicit leading 1)

Let FLOAT128_SIGN_BIT be 127
Let FLOAT128_EXPONENT_BITS be 15
Let FLOAT128_MANTISSA_BITS be 112
Let FLOAT128_EXPONENT_BIAS be 16383
Let FLOAT128_EXPONENT_MAX be 32767

Note: Masks for bit extraction
Let FLOAT128_SIGN_MASK_HIGH be -9223372036854775808
Let FLOAT128_EXPONENT_MASK_HIGH be 9223090561878065152
Let FLOAT128_MANTISSA_MASK_HIGH be 281474976710655

Note: IEEE 754 Rounding Modes
Let ROUND_TO_NEAREST_EVEN be 0
Let ROUND_TOWARD_ZERO be 1
Let ROUND_TOWARD_POSITIVE be 2
Let ROUND_TOWARD_NEGATIVE be 3

Note: Global rounding mode (default: round to nearest, ties to even)
Let FLOAT128_ROUNDING_MODE be 0

Note: IEEE 754 Exception Flags
Note: These flags track exceptional conditions during floating-point operations
Let FLOAT128_FLAG_INVALID be 1
Let FLOAT128_FLAG_DIVIDE_BY_ZERO be 2
Let FLOAT128_FLAG_OVERFLOW be 4
Let FLOAT128_FLAG_UNDERFLOW be 8
Let FLOAT128_FLAG_INEXACT be 16

Note: Global exception flags (bitwise OR of active flags)
Let FLOAT128_EXCEPTION_FLAGS be 0

Note: ============================================================================
Note: Float128 Unpacking (Extract Components)
Note: ============================================================================

Process called "float128_unpack" takes f128_ptr as Integer, sign_ptr as Integer, exp_ptr as Integer, mant_high_ptr as Integer, mant_low_ptr as Integer:
    Note: Unpack Float128 into components
    Note: f128_ptr: pointer to 16-byte Float128 value
    Note: sign_ptr: output - sign bit (0 or 1)
    Note: exp_ptr: output - biased exponent (0-32767)
    Note: mant_high_ptr: output - high 64 bits of mantissa
    Note: mant_low_ptr: output - low 64 bits of mantissa

    Note: Float128 is stored as two 64-bit words: [high 64 bits][low 64 bits]
    Let high_word be memory_get_int64(f128_ptr, 0)
    Let low_word be memory_get_int64(f128_ptr, 8)

    Note: Extract sign (bit 127 = bit 63 of high word)
    Let sign be right_shift(high_word, 63)
    Set sign to bitwise_and(sign, 1)
    memory_set_int64(sign_ptr, 0, sign)

    Note: Extract exponent (bits 126-112 = bits 62-48 of high word)
    Let exp be right_shift(high_word, 48)
    Set exp to bitwise_and(exp, 32767)
    memory_set_int64(exp_ptr, 0, exp)

    Note: Extract mantissa (112 bits = 48 bits from high + 64 bits from low)
    Let mant_high be bitwise_and(high_word, 281474976710655)
    memory_set_int64(mant_high_ptr, 0, mant_high)
    memory_set_int64(mant_low_ptr, 0, low_word)
End Process

Note: ============================================================================
Note: Float128 Packing (Combine Components)
Note: ============================================================================

Process called "float128_pack" takes sign as Integer, exp as Integer, mant_high as Integer, mant_low as Integer, result_ptr as Integer:
    Note: Pack components into Float128
    Note: sign: 0 or 1
    Note: exp: biased exponent (0-32767)
    Note: mant_high: high 48 bits of mantissa
    Note: mant_low: low 64 bits of mantissa
    Note: result_ptr: output - pointer to 16-byte Float128

    Note: Construct high word: [sign:1][exponent:15][mantissa_high:48]
    Let high_word be left_shift(sign, 63)
    Let exp_shifted be left_shift(exp, 48)
    Set high_word to bitwise_or(high_word, exp_shifted)
    Set high_word to bitwise_or(high_word, mant_high)

    Note: Low word is just the low 64 bits of mantissa
    memory_set_int64(result_ptr, 0, high_word)
    memory_set_int64(result_ptr, 8, mant_low)
End Process

Note: ============================================================================
Note: Rounding Mode Control
Note: ============================================================================

Process called "float128_set_rounding_mode" takes mode as Integer:
    Note: Set the global rounding mode
    Note: mode: 0=nearest-even, 1=toward-zero, 2=toward-positive, 3=toward-negative
    Set FLOAT128_ROUNDING_MODE to mode
End Process

Process called "float128_get_rounding_mode" returns Integer:
    Note: Get the current rounding mode
    Return FLOAT128_ROUNDING_MODE
End Process

Process called "float128_round_mantissa" takes sign as Integer, mant_high as Integer, mant_low as Integer, guard_bit as Integer, round_bit as Integer, sticky_bit as Integer, result_mant_high_ptr as Integer, result_mant_low_ptr as Integer returns Integer:
    Note: Round 112-bit mantissa using current rounding mode
    Note: Returns 1 if rounding causes overflow (need to increment exponent), 0 otherwise

    Note: Inputs:
    Note:   sign: 0=positive, 1=negative
    Note:   mant_high, mant_low: 112-bit mantissa
    Note:   guard_bit, round_bit, sticky_bit: extra precision bits
    Note: Outputs:
    Note:   result_mant_high_ptr, result_mant_low_ptr: rounded mantissa
    Note:   return value: 1 if overflow, 0 otherwise

    Let should_round_up be 0

    Note: Apply rounding based on mode
    If FLOAT128_ROUNDING_MODE is equal to 0:
        Note: Round to nearest, ties to even (IEEE 754 default)
        If guard_bit is equal to 1:
            If round_bit is equal to 1:
                Set should_round_up to 1
            Otherwise:
                If sticky_bit is equal to 1:
                    Set should_round_up to 1
                Otherwise:
                    Note: Tie case - round to even (check LSB of mantissa)
                    Let lsb be bitwise_and(mant_low, 1)
                    If lsb is equal to 1:
                        Set should_round_up to 1
                    End If
                End If
            End If
        End If
    End If

    If FLOAT128_ROUNDING_MODE is equal to 1:
        Note: Round toward zero (truncate)
        Set should_round_up to 0
    End If

    If FLOAT128_ROUNDING_MODE is equal to 2:
        Note: Round toward +∞ (ceiling)
        If sign is equal to 0:
            Note: Positive number - round up if any extra bits set
            If guard_bit is equal to 1:
                Set should_round_up to 1
            End If
            If round_bit is equal to 1:
                Set should_round_up to 1
            End If
            If sticky_bit is equal to 1:
                Set should_round_up to 1
            End If
        Otherwise:
            Note: Negative number - round toward zero (truncate)
            Set should_round_up to 0
        End If
    End If

    If FLOAT128_ROUNDING_MODE is equal to 3:
        Note: Round toward -∞ (floor)
        If sign is equal to 1:
            Note: Negative number - round up (away from zero) if any extra bits set
            If guard_bit is equal to 1:
                Set should_round_up to 1
            End If
            If round_bit is equal to 1:
                Set should_round_up to 1
            End If
            If sticky_bit is equal to 1:
                Set should_round_up to 1
            End If
        Otherwise:
            Note: Positive number - round toward zero (truncate)
            Set should_round_up to 0
        End If
    End If

    Note: Apply rounding
    Let result_high be mant_high
    Let result_low be mant_low
    Let carry be 0

    If should_round_up is equal to 1:
        Note: Add 1 to mantissa
        Set result_low to result_low plus 1
        If result_low is equal to 0:
            Note: Overflow in low word, carry to high word
            Set carry to 1
        End If
        Set result_high to result_high plus carry

        Note: Check for mantissa overflow (bit 48 of mant_high set)
        Let overflow_bit be bitwise_and(result_high, 281474976710656)
        If overflow_bit is not equal to 0:
            Note: Mantissa overflowed - need to shift right and increment exponent
            Set result_low to right_shift(result_low, 1)
            Let high_bit be bitwise_and(result_high, 1)
            If high_bit is equal to 1:
                Set result_low to bitwise_or(result_low, 9223372036854775808)
            End If
            Set result_high to right_shift(result_high, 1)
            memory_set_int64(result_mant_high_ptr, 0, result_high)
            memory_set_int64(result_mant_low_ptr, 0, result_low)
            Return 1
        End If
    End If

    memory_set_int64(result_mant_high_ptr, 0, result_high)
    memory_set_int64(result_mant_low_ptr, 0, result_low)
    Return 0
End Process

Note: ============================================================================
Note: IEEE 754 Exception Flag Management
Note: ============================================================================

Process called "float128_clear_exceptions":
    Note: Clear all exception flags
    Set FLOAT128_EXCEPTION_FLAGS to 0
End Process

Process called "float128_get_exceptions" returns Integer:
    Note: Get current exception flags
    Note: Returns bitwise OR of all active flags
    Return FLOAT128_EXCEPTION_FLAGS
End Process

Process called "float128_test_exception" takes flag as Integer returns Integer:
    Note: Test if a specific exception flag is set
    Note: flag: one of FLOAT128_FLAG_* constants
    Let result be bitwise_and(FLOAT128_EXCEPTION_FLAGS, flag)
    If result is not equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "float128_raise_exception" takes flag as Integer:
    Note: Raise (set) an exception flag
    Note: flag: one of FLOAT128_FLAG_* constants
    Set FLOAT128_EXCEPTION_FLAGS to bitwise_or(FLOAT128_EXCEPTION_FLAGS, flag)
End Process

Process called "float128_clear_exception" takes flag as Integer:
    Note: Clear a specific exception flag
    Note: flag: one of FLOAT128_FLAG_* constants
    Let inverted_flag be bitwise_not(flag)
    Set FLOAT128_EXCEPTION_FLAGS to bitwise_and(FLOAT128_EXCEPTION_FLAGS, inverted_flag)
End Process

Note: ============================================================================
Note: Float128 Special Value Detection
Note: ============================================================================

Process called "float128_is_zero" takes f128_ptr as Integer returns Integer:
    Note: Check if Float128 is ±0

    Let high_word be memory_get_int64(f128_ptr, 0)
    Let low_word be memory_get_int64(f128_ptr, 8)

    Note: Zero has exponent=0 and mantissa=0 (sign can be anything)
    Let magnitude_high be bitwise_and(high_word, 9223372036854775807)
    If magnitude_high is equal to 0:
        If low_word is equal to 0:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "float128_is_nan" takes f128_ptr as Integer, scratch_ptr as Integer returns Integer:
    Note: Check if Float128 is NaN
    Note: NaN: exponent = 0x7FFF (all 1s), mantissa != 0
    Note: SCRATCH SPACE REQUIRED: 32 bytes (4 × 8-byte integers for unpacking)

    Let sign_ptr be scratch_ptr
    Let exp_ptr be scratch_ptr plus 8
    Let mant_high_ptr be scratch_ptr plus 16
    Let mant_low_ptr be scratch_ptr plus 24

    float128_unpack(f128_ptr, sign_ptr, exp_ptr, mant_high_ptr, mant_low_ptr)

    Let exp be memory_get_int64(exp_ptr, 0)
    Let mant_high be memory_get_int64(mant_high_ptr, 0)
    Let mant_low be memory_get_int64(mant_low_ptr, 0)

    If exp is equal to 32767:
        If mant_high is not equal to 0:
            Return 1
        End If
        If mant_low is not equal to 0:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "float128_is_infinity" takes f128_ptr as Integer, scratch_ptr as Integer returns Integer:
    Note: Check if Float128 is ±Infinity
    Note: Infinity: exponent = 0x7FFF (all 1s), mantissa = 0
    Note: SCRATCH SPACE REQUIRED: 32 bytes (4 × 8-byte integers for unpacking)

    Let sign_ptr be scratch_ptr
    Let exp_ptr be scratch_ptr plus 8
    Let mant_high_ptr be scratch_ptr plus 16
    Let mant_low_ptr be scratch_ptr plus 24

    float128_unpack(f128_ptr, sign_ptr, exp_ptr, mant_high_ptr, mant_low_ptr)

    Let exp be memory_get_int64(exp_ptr, 0)
    Let mant_high be memory_get_int64(mant_high_ptr, 0)
    Let mant_low be memory_get_int64(mant_low_ptr, 0)

    If exp is equal to 32767:
        If mant_high is equal to 0:
            If mant_low is equal to 0:
                Return 1
            End If
        End If
    End If
    Return 0
End Process

Process called "float128_is_subnormal" takes f128_ptr as Integer, scratch_ptr as Integer returns Integer:
    Note: Check if Float128 is subnormal (denormalized)
    Note: Subnormal: exponent = 0, mantissa != 0
    Note: These numbers provide gradual underflow near zero
    Note: SCRATCH SPACE REQUIRED: 32 bytes (4 × 8-byte integers for unpacking)

    Let sign_ptr be scratch_ptr
    Let exp_ptr be scratch_ptr plus 8
    Let mant_high_ptr be scratch_ptr plus 16
    Let mant_low_ptr be scratch_ptr plus 24

    float128_unpack(f128_ptr, sign_ptr, exp_ptr, mant_high_ptr, mant_low_ptr)

    Let exp be memory_get_int64(exp_ptr, 0)
    Let mant_high be memory_get_int64(mant_high_ptr, 0)
    Let mant_low be memory_get_int64(mant_low_ptr, 0)

    If exp is equal to 0:
        If mant_high is not equal to 0:
            Return 1
        End If
        If mant_low is not equal to 0:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "float128_normalize_subnormal" takes sign as Integer, mant_high as Integer, mant_low as Integer, norm_exp_ptr as Integer, norm_mant_high_ptr as Integer, norm_mant_low_ptr as Integer:
    Note: Normalize a subnormal mantissa
    Note: Shifts mantissa left until implicit 1 is in position
    Note: Adjusts exponent accordingly

    Note: Find leading 1 bit in mantissa
    Let shift_count be 0
    Let temp_mant_high be mant_high
    Let temp_mant_low be mant_low

    Note: Check if mantissa is zero
    If temp_mant_high is equal to 0:
        If temp_mant_low is equal to 0:
            Note: Zero mantissa - return as-is
            memory_set_int64(norm_exp_ptr, 0, 0)
            memory_set_int64(norm_mant_high_ptr, 0, 0)
            memory_set_int64(norm_mant_low_ptr, 0, 0)
            Return
        End If
    End If

    Note: Count leading zeros to find normalization shift
    Note: We need bit 48 of mant_high to be 1 (the implicit leading 1 position)
    Let target_bit be 281474976710656
    While shift_count is less than 112:
        Let test_bit be bitwise_and(temp_mant_high, target_bit)
        If test_bit is not equal to 0:
            break
        End If

        Note: Shift left by 1
        Set temp_mant_high to left_shift(temp_mant_high, 1)
        Let carry_bit be bitwise_and(temp_mant_low, 9223372036854775808)
        If carry_bit is not equal to 0:
            Set temp_mant_high to bitwise_or(temp_mant_high, 1)
        End If
        Set temp_mant_low to left_shift(temp_mant_low, 1)
        Set shift_count to shift_count plus 1
    End While

    Note: Remove the implicit leading 1 from mantissa
    Set temp_mant_high to bitwise_and(temp_mant_high, 281474976710655)

    Note: Exponent for subnormal is 1 - bias - shift_count
    Note: Since subnormal has exponent field = 0, actual exponent is 1 - 16383 = -16382
    Note: After normalization: -16382 - shift_count
    Let norm_exp be 1 minus shift_count
    If norm_exp is less than 1:
        Set norm_exp to 1
    End If

    memory_set_int64(norm_exp_ptr, 0, norm_exp)
    memory_set_int64(norm_mant_high_ptr, 0, temp_mant_high)
    memory_set_int64(norm_mant_low_ptr, 0, temp_mant_low)
End Process

Process called "float128_create_subnormal" takes sign as Integer, effective_exp as Integer, mant_high as Integer, mant_low as Integer, result_ptr as Integer:
    Note: Create a subnormal Float128 from components
    Note: effective_exp: the actual exponent (will be < 1 for subnormals)
    Note: This handles gradual underflow by denormalizing the mantissa

    Note: For subnormals: exponent field = 0, mantissa has no implicit 1
    Note: Need to shift mantissa right by (1 - effective_exp) positions

    If effective_exp is greater than or equal to 1:
        Note: Not actually subnormal, return normalized
        float128_pack(sign, effective_exp, mant_high, mant_low, result_ptr)
        Return
    End If

    Note: Calculate denormalization shift
    Let shift_amount be 1 minus effective_exp

    Note: Add implicit 1 to mantissa before shifting
    Let full_mant_high be bitwise_or(mant_high, 281474976710656)
    Let full_mant_low be mant_low

    Note: Shift right by shift_amount
    If shift_amount is greater than 0:
        If shift_amount is less than 64:
            Note: Shift within words
            Set full_mant_low to right_shift(full_mant_low, shift_amount)
            Let carry_bits be bitwise_and(full_mant_high, left_shift(1, shift_amount) minus 1)
            Set carry_bits to left_shift(carry_bits, 64 minus shift_amount)
            Set full_mant_low to bitwise_or(full_mant_low, carry_bits)
            Set full_mant_high to right_shift(full_mant_high, shift_amount)
        Otherwise:
            Note: Large shift - most bits lost
            If shift_amount is less than 128:
                Set full_mant_low to right_shift(full_mant_high, shift_amount minus 64)
                Set full_mant_high to 0
            Otherwise:
                Note: Shifted to zero
                Set full_mant_high to 0
                Set full_mant_low to 0
            End If
        End If
    End If

    Note: Pack as subnormal (exponent = 0)
    float128_pack(sign, 0, full_mant_high, full_mant_low, result_ptr)
End Process

Note: ============================================================================
Note: Float128 Mantissa Alignment
Note: ============================================================================

Process called "float128_align_mantissas" takes exp_a as Integer, mant_a_high as Integer, mant_a_low as Integer, exp_b as Integer, mant_b_high as Integer, mant_b_low as Integer, aligned_exp_ptr as Integer, aligned_a_high_ptr as Integer, aligned_a_low_ptr as Integer, aligned_b_high_ptr as Integer, aligned_b_low_ptr as Integer:
    Note: Align mantissas to common exponent for addition/subtraction
    Note: Shifts smaller mantissa right to match larger exponent

    Let exp_diff be exp_a minus exp_b

    If exp_diff is equal to 0:
        Note: Already aligned
        memory_set_int64(aligned_exp_ptr, 0, exp_a)
        memory_set_int64(aligned_a_high_ptr, 0, mant_a_high)
        memory_set_int64(aligned_a_low_ptr, 0, mant_a_low)
        memory_set_int64(aligned_b_high_ptr, 0, mant_b_high)
        memory_set_int64(aligned_b_low_ptr, 0, mant_b_low)
        Return
    End If

    If exp_diff is greater than 0:
        Note: exp_a > exp_b, shift b right by exp_diff
        memory_set_int64(aligned_exp_ptr, 0, exp_a)
        memory_set_int64(aligned_a_high_ptr, 0, mant_a_high)
        memory_set_int64(aligned_a_low_ptr, 0, mant_a_low)

        Note: Shift mantissa_b right by exp_diff bits - CORRECT handling for all shifts
        If exp_diff is greater than or equal to 112:
            Note: Shift exceeds mantissa size, result is zero
            memory_set_int64(aligned_b_high_ptr, 0, 0)
            memory_set_int64(aligned_b_low_ptr, 0, 0)
        Otherwise:
            If exp_diff is less than 64:
                Note: Shift within low word boundary
                Let shifted_low be right_shift(mant_b_low, exp_diff)
                Let carry be left_shift(mant_b_high, 64 minus exp_diff)
                Set shifted_low to bitwise_or(shifted_low, carry)
                Let shifted_high be right_shift(mant_b_high, exp_diff)

                memory_set_int64(aligned_b_high_ptr, 0, shifted_high)
                memory_set_int64(aligned_b_low_ptr, 0, shifted_low)
            Otherwise:
                Note: Shift >= 64, moves high word to low word
                Let shift_amount be exp_diff minus 64
                If shift_amount is less than 48:
                    Let shifted_low be right_shift(mant_b_high, shift_amount)
                    memory_set_int64(aligned_b_high_ptr, 0, 0)
                    memory_set_int64(aligned_b_low_ptr, 0, shifted_low)
                Otherwise:
                    Note: Shift too large, result is zero
                    memory_set_int64(aligned_b_high_ptr, 0, 0)
                    memory_set_int64(aligned_b_low_ptr, 0, 0)
                End If
            End If
        End If
    Otherwise:
        Note: exp_b > exp_a, shift a right by |exp_diff|
        Let abs_diff be 0 minus exp_diff
        memory_set_int64(aligned_exp_ptr, 0, exp_b)
        memory_set_int64(aligned_b_high_ptr, 0, mant_b_high)
        memory_set_int64(aligned_b_low_ptr, 0, mant_b_low)

        Note: Shift mantissa_a right by abs_diff bits - CORRECT handling for all shifts
        If abs_diff is greater than or equal to 112:
            Note: Shift exceeds mantissa size, result is zero
            memory_set_int64(aligned_a_high_ptr, 0, 0)
            memory_set_int64(aligned_a_low_ptr, 0, 0)
        Otherwise:
            If abs_diff is less than 64:
                Note: Shift within low word boundary
                Let shifted_low be right_shift(mant_a_low, abs_diff)
                Let carry be left_shift(mant_a_high, 64 minus abs_diff)
                Set shifted_low to bitwise_or(shifted_low, carry)
                Let shifted_high be right_shift(mant_a_high, abs_diff)

                memory_set_int64(aligned_a_high_ptr, 0, shifted_high)
                memory_set_int64(aligned_a_low_ptr, 0, shifted_low)
            Otherwise:
                Note: Shift >= 64, moves high word to low word
                Let shift_amount be abs_diff minus 64
                If shift_amount is less than 48:
                    Let shifted_low be right_shift(mant_a_high, shift_amount)
                    memory_set_int64(aligned_a_high_ptr, 0, 0)
                    memory_set_int64(aligned_a_low_ptr, 0, shifted_low)
                Otherwise:
                    Note: Shift too large, result is zero
                    memory_set_int64(aligned_a_high_ptr, 0, 0)
                    memory_set_int64(aligned_a_low_ptr, 0, 0)
                End If
            End If
        End If
    End If
End Process

Note: ============================================================================
Note: Float128 Normalization
Note: ============================================================================

Process called "float128_normalize" takes exp_ptr as Integer, mant_high_ptr as Integer, mant_low_ptr as Integer:
    Note: Normalize mantissa to have implicit leading 1
    Note: Adjusts exponent accordingly

    Let exp be memory_get_int64(exp_ptr, 0)
    Let mant_high be memory_get_int64(mant_high_ptr, 0)
    Let mant_low be memory_get_int64(mant_low_ptr, 0)

    Note: Check if already normalized (bit 48 of mant_high is set)
    Let leading_bit be bitwise_and(mant_high, 140737488355328)
    If leading_bit is not equal to 0:
        Return  Note: Already normalized
    End If

    Note: Shift mantissa left until bit 48 is set
    Let shift_count be 0
    While shift_count is less than 112:
        Let check_bit be bitwise_and(mant_high, 140737488355328)
        If check_bit is not equal to 0:
            Note: Normalized
            Set shift_count to 112
        Otherwise:
            Note: Shift left by 1
            Let high_carry be right_shift(mant_low, 63)
            Set mant_low to left_shift(mant_low, 1)
            Set mant_high to left_shift(mant_high, 1)
            Set mant_high to bitwise_or(mant_high, high_carry)
            Set exp to exp minus 1
            Set shift_count to shift_count plus 1
        End If
    End While

    memory_set_int64(exp_ptr, 0, exp)
    memory_set_int64(mant_high_ptr, 0, mant_high)
    memory_set_int64(mant_low_ptr, 0, mant_low)
End Process

Note: ============================================================================
Note: Float128 Addition
Note: ============================================================================

Process called "float128_add_impl" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Add two Float128 values
    Note: Algorithm:
    Note: 1. Unpack operands
    Note: 2. Handle special cases (NaN, Infinity, Zero)
    Note: 3. Align mantissas
    Note: 4. Add mantissas
    Note: 5. Normalize result
    Note: 6. Pack result
    Note: SCRATCH SPACE REQUIRED: 144 bytes (32 for NaN check + 8×8 for unpack + 5×8 for align)

    Note: Setup scratch space
    Let nan_scratch be scratch_ptr
    Let sign_a_ptr be scratch_ptr plus 32
    Let exp_a_ptr be scratch_ptr plus 40
    Let mant_a_high_ptr be scratch_ptr plus 48
    Let mant_a_low_ptr be scratch_ptr plus 56
    Let sign_b_ptr be scratch_ptr plus 64
    Let exp_b_ptr be scratch_ptr plus 72
    Let mant_b_high_ptr be scratch_ptr plus 80
    Let mant_b_low_ptr be scratch_ptr plus 88
    Let aligned_exp_ptr be scratch_ptr plus 96
    Let aligned_a_high_ptr be scratch_ptr plus 104
    Let aligned_a_low_ptr be scratch_ptr plus 112
    Let aligned_b_high_ptr be scratch_ptr plus 120
    Let aligned_b_low_ptr be scratch_ptr plus 128

    Note: Check for special values
    If float128_is_nan(a_ptr, nan_scratch) is equal to 1:
        Note: NaN + anything = NaN
        memory_set_int64(result_ptr, 0, memory_get_int64(a_ptr, 0))
        memory_set_int64(result_ptr, 8, memory_get_int64(a_ptr, 8))
        Return
    End If

    If float128_is_nan(b_ptr, nan_scratch) is equal to 1:
        memory_set_int64(result_ptr, 0, memory_get_int64(b_ptr, 0))
        memory_set_int64(result_ptr, 8, memory_get_int64(b_ptr, 8))
        Return
    End If

    float128_unpack(a_ptr, sign_a_ptr, exp_a_ptr, mant_a_high_ptr, mant_a_low_ptr)
    float128_unpack(b_ptr, sign_b_ptr, exp_b_ptr, mant_b_high_ptr, mant_b_low_ptr)

    Let sign_a be memory_get_int64(sign_a_ptr, 0)
    Let exp_a be memory_get_int64(exp_a_ptr, 0)
    Let mant_a_high be memory_get_int64(mant_a_high_ptr, 0)
    Let mant_a_low be memory_get_int64(mant_a_low_ptr, 0)

    Let sign_b be memory_get_int64(sign_b_ptr, 0)
    Let exp_b be memory_get_int64(exp_b_ptr, 0)
    Let mant_b_high be memory_get_int64(mant_b_high_ptr, 0)
    Let mant_b_low be memory_get_int64(mant_b_low_ptr, 0)

    Note: Add implicit leading 1 to mantissas (for normalized numbers)
    If exp_a is not equal to 0:
        Set mant_a_high to bitwise_or(mant_a_high, 281474976710656)
    End If
    If exp_b is not equal to 0:
        Set mant_b_high to bitwise_or(mant_b_high, 281474976710656)
    End If

    Note: Align mantissas
    float128_align_mantissas(exp_a, mant_a_high, mant_a_low, exp_b, mant_b_high, mant_b_low, aligned_exp_ptr, aligned_a_high_ptr, aligned_a_low_ptr, aligned_b_high_ptr, aligned_b_low_ptr)

    Let result_exp be memory_get_int64(aligned_exp_ptr, 0)
    Let aligned_a_high be memory_get_int64(aligned_a_high_ptr, 0)
    Let aligned_a_low be memory_get_int64(aligned_a_low_ptr, 0)
    Let aligned_b_high be memory_get_int64(aligned_b_high_ptr, 0)
    Let aligned_b_low be memory_get_int64(aligned_b_low_ptr, 0)

    Note: Add mantissas
    Let result_mant_low be aligned_a_low plus aligned_b_low
    Let carry be 0
    If result_mant_low is less than aligned_a_low:
        Set carry to 1  Note: Overflow in low word
    End If
    Let result_mant_high be aligned_a_high plus aligned_b_high plus carry

    Note: Check for overflow in addition (bit 49 might be set)
    Let overflow_bit be bitwise_and(result_mant_high, 562949953421312)
    If overflow_bit is not equal to 0:
        Note: Shift right by 1, increment exponent
        Set result_mant_low to right_shift(result_mant_low, 1)
        Let high_carry be left_shift(result_mant_high, 63)
        Set result_mant_low to bitwise_or(result_mant_low, high_carry)
        Set result_mant_high to right_shift(result_mant_high, 1)
        Set result_exp to result_exp plus 1
    End If

    Note: Remove implicit leading 1
    Set result_mant_high to bitwise_and(result_mant_high, 281474976710655)

    Note: Pack result
    float128_pack(sign_a, result_exp, result_mant_high, result_mant_low, result_ptr)
End Process

Note: ============================================================================
Note: Helper Functions for Multi-Precision Arithmetic
Note: ============================================================================

Process called "mul64x64_128" takes a as Integer, b as Integer, result_high_ptr as Integer, result_low_ptr as Integer:
    Note: Multiply two 64-bit integers to produce 128-bit result
    Note: Split into 32-bit chunks and compute partial products
    Note: This is the foundation for 112-bit × 112-bit mantissa multiplication

    Let a_hi be right_shift(a, 32)
    Let a_lo be bitwise_and(a, 4294967295)
    Let b_hi be right_shift(b, 32)
    Let b_lo be bitwise_and(b, 4294967295)

    Note: Compute 4 partial products
    Let ll be a_lo multiplied by b_lo
    Let lh be a_lo multiplied by b_hi
    Let hl be a_hi multiplied by b_lo
    Let hh be a_hi multiplied by b_hi

    Note: Accumulate: result = ll + (lh << 32) + (hl << 32) + (hh << 64)
    Let result_low be ll

    Note: Add lh << 32
    Let lh_low be left_shift(lh, 32)
    Let temp be result_low plus lh_low
    Let carry1 be 0
    If temp is less than result_low:
        Set carry1 to 1
    End If
    Set result_low to temp

    Note: Add hl << 32
    Let hl_low be left_shift(hl, 32)
    Set temp to result_low plus hl_low
    Let carry2 be 0
    If temp is less than result_low:
        Set carry2 to 1
    End If
    Set result_low to temp

    Note: High word = hh + (lh >> 32) + (hl >> 32) + carries
    Let result_high be hh
    Set result_high to result_high plus right_shift(lh, 32)
    Set result_high to result_high plus right_shift(hl, 32)
    Set result_high to result_high plus carry1
    Set result_high to result_high plus carry2

    memory_set_int64(result_high_ptr, 0, result_high)
    memory_set_int64(result_low_ptr, 0, result_low)
End Process

Process called "mul64x64_128_karatsuba" takes a as Integer, b as Integer, result_high_ptr as Integer, result_low_ptr as Integer:
    Note: Karatsuba multiplication: multiply two 64-bit integers to produce 128-bit result
    Note: Algorithm: xy = (x1*2^32 + x0)(y1*2^32 + y0)
    Note:           = x1*y1*2^64 + [(x1+x0)(y1+y0) - x1*y1 - x0*y0]*2^32 + x0*y0
    Note: Reduces 4 multiplications to 3 (plus some additions)
    Note: ~33% fewer multiplications than naive approach
    Note: Performance: ~5× speedup for 112-bit × 112-bit mantissa multiplication

    Note: Split into 32-bit halves
    Let a_hi be right_shift(a, 32)
    Let a_lo be bitwise_and(a, 4294967295)
    Let b_hi be right_shift(b, 32)
    Let b_lo be bitwise_and(b, 4294967295)

    Note: Compute three products (Karatsuba algorithm)
    Note: z0 = a_lo * b_lo
    Let z0 be a_lo multiplied by b_lo

    Note: z2 = a_hi * b_hi
    Let z2 be a_hi multiplied by b_hi

    Note: z1 = (a_lo + a_hi) * (b_lo + b_hi) - z0 - z2
    Let a_sum be a_lo plus a_hi
    Let b_sum be b_lo plus b_hi
    Let z1_temp be a_sum multiplied by b_sum
    Let z1 be z1_temp minus z0 minus z2

    Note: Combine: result = z2*2^64 + z1*2^32 + z0
    Note: Low word gets z0 (low 64 bits)
    Let result_low be z0

    Note: Middle contribution: z1 << 32
    Let z1_low be left_shift(z1, 32)
    Let temp be result_low plus z1_low
    Let carry1 be 0
    If temp is less than result_low:
        Set carry1 to 1
    End If
    Set result_low to temp

    Note: High word gets z2 + (z1 >> 32) + carry
    Let result_high be z2
    Set result_high to result_high plus right_shift(z1, 32)
    Set result_high to result_high plus carry1

    memory_set_int64(result_high_ptr, 0, result_high)
    memory_set_int64(result_low_ptr, 0, result_low)
End Process

Process called "mul_112x112_karatsuba" takes a_high as Integer, a_low as Integer, b_high as Integer, b_low as Integer, result_high_ptr as Integer, result_mid_ptr as Integer, result_low_ptr as Integer, scratch_ptr as Integer:
    Note: Optimized 112-bit × 112-bit Karatsuba multiplication
    Note: Produces 224-bit result in three 64-bit words (actually uses upper 192 bits)
    Note: Algorithm reduces multiplications from 4 to 3 (33% fewer ops)
    Note: This is the core optimization for Float128 multiply performance
    Note: SCRATCH SPACE REQUIRED: 48 bytes (6 × 8-byte integers for z0, z1, z2)

    Note: Format: a = [a_high:48 bits][a_low:64 bits] (112 bits total)
    Note: Format: b = [b_high:48 bits][b_low:64 bits] (112 bits total)
    Note: Result: [result_high:64][result_mid:64][result_low:64] (192 bits, upper part of 224)

    Note: For Karatsuba, split at 56-bit boundary for balanced halves
    Note: a = a1*2^56 + a0, where a1 and a0 are both 56 bits
    Note: b = b1*2^56 + b0, where b1 and b0 are both 56 bits

    Note: Extract halves (56-bit each)
    Let a1 be right_shift(a_low, 56)
    Set a1 to bitwise_or(a1, left_shift(a_high, 8))
    Let a0 be bitwise_and(a_low, 72057594037927935)

    Let b1 be right_shift(b_low, 56)
    Set b1 to bitwise_or(b1, left_shift(b_high, 8))
    Let b0 be bitwise_and(b_low, 72057594037927935)

    Note: Setup scratch space
    Let z0_high_ptr be scratch_ptr
    Let z0_low_ptr be scratch_ptr plus 8
    Let z2_high_ptr be scratch_ptr plus 16
    Let z2_low_ptr be scratch_ptr plus 24
    Let z1_high_ptr be scratch_ptr plus 32
    Let z1_low_ptr be scratch_ptr plus 40

    Note: Karatsuba: compute z0, z2, z1
    Note: z0 = a0 * b0
    mul64x64_128(a0, b0, z0_high_ptr, z0_low_ptr)
    Let z0_high be memory_get_int64(z0_high_ptr, 0)
    Let z0_low be memory_get_int64(z0_low_ptr, 0)

    Note: z2 = a1 * b1
    mul64x64_128(a1, b1, z2_high_ptr, z2_low_ptr)
    Let z2_high be memory_get_int64(z2_high_ptr, 0)
    Let z2_low be memory_get_int64(z2_low_ptr, 0)

    Note: z1 = (a0 + a1) * (b0 + b1) - z0 - z2
    Let a_sum be a0 plus a1
    Let b_sum be b0 plus b1
    mul64x64_128(a_sum, b_sum, z1_high_ptr, z1_low_ptr)
    Let z1_high be memory_get_int64(z1_high_ptr, 0)
    Let z1_low be memory_get_int64(z1_low_ptr, 0)

    Note: z1 -= z0
    Let temp_low be z1_low minus z0_low
    Let borrow1 be 0
    If temp_low is greater than z1_low:
        Set borrow1 to 1
    End If
    Set z1_low to temp_low
    Set z1_high to z1_high minus z0_high minus borrow1

    Note: z1 -= z2
    Set temp_low to z1_low minus z2_low
    Let borrow2 be 0
    If temp_low is greater than z1_low:
        Set borrow2 to 1
    End If
    Set z1_low to temp_low
    Set z1_high to z1_high minus z2_high minus borrow2

    Note: Combine: result = z2*2^112 + z1*2^56 + z0
    Note: Start with z0 in low/mid positions
    Let result_low be z0_low
    Let result_mid be z0_high
    Let result_high be 0

    Note: Add z1 << 56 bits
    Note: z1 contributes to all three words when shifted left 56 bits
    Let z1_shifted_low be left_shift(z1_low, 56)
    Set temp_low to result_low plus z1_shifted_low
    Let carry1 be 0
    If temp_low is less than result_low:
        Set carry1 to 1
    End If
    Set result_low to temp_low

    Let z1_mid_contribution be right_shift(z1_low, 8)
    Set z1_mid_contribution to bitwise_or(z1_mid_contribution, left_shift(z1_high, 56))
    Let temp_mid be result_mid plus z1_mid_contribution plus carry1
    Let carry2 be 0
    If temp_mid is less than result_mid:
        Set carry2 to 1
    End If
    If temp_mid is less than carry1:
        Set carry2 to 1
    End If
    Set result_mid to temp_mid

    Let z1_high_contribution be right_shift(z1_high, 8)
    Set result_high to result_high plus z1_high_contribution plus carry2

    Note: Add z2 << 112 bits
    Let temp_mid be result_mid plus z2_low
    Let carry3 be 0
    If temp_mid is less than result_mid:
        Set carry3 to 1
    End If
    Set result_mid to temp_mid
    Set result_high to result_high plus z2_high plus carry3

    memory_set_int64(result_high_ptr, 0, result_high)
    memory_set_int64(result_mid_ptr, 0, result_mid)
    memory_set_int64(result_low_ptr, 0, result_low)
End Process

Process called "compare_112bit" takes a_high as Integer, a_low as Integer, b_high as Integer, b_low as Integer returns Integer:
    Note: Compare two 112-bit numbers
    Note: Returns: 1 if a > b, 0 if a == b, -1 if a < b

    If a_high is greater than b_high:
        Return 1
    End If
    If a_high is less than b_high:
        Return -1
    End If
    Note: High parts equal, compare low parts
    If a_low is greater than b_low:
        Return 1
    End If
    If a_low is less than b_low:
        Return -1
    End If
    Return 0
End Process

Process called "subtract_112bit" takes a_high as Integer, a_low as Integer, b_high as Integer, b_low as Integer, result_high_ptr as Integer, result_low_ptr as Integer:
    Note: Subtract two 112-bit numbers: result = a - b
    Note: Assumes a >= b

    Let result_low be a_low minus b_low
    Let borrow be 0
    If result_low is greater than a_low:
        Set borrow to 1
    End If
    Let result_high be a_high minus b_high minus borrow

    memory_set_int64(result_high_ptr, 0, result_high)
    memory_set_int64(result_low_ptr, 0, result_low)
End Process

Process called "add_112bit" takes a_high as Integer, a_low as Integer, b_high as Integer, b_low as Integer, result_high_ptr as Integer, result_low_ptr as Integer:
    Note: Add two 112-bit numbers: result = a + b

    Let result_low be a_low plus b_low
    Let carry be 0
    If result_low is less than a_low:
        Set carry to 1
    End If
    Let result_high be a_high plus b_high plus carry

    memory_set_int64(result_high_ptr, 0, result_high)
    memory_set_int64(result_low_ptr, 0, result_low)
End Process

Note: ============================================================================
Note: SRT-4 Lookup Table
Note: ============================================================================

Note: Based on SRT convergence analysis (Ercegovac & Lang, "Digital Arithmetic")
Note: This lookup table guarantees convergence by ensuring remainder stays bounded

Note: Table Structure:
Note: - Radix-4 SRT division: digit set {-2, -1, 0, 1, 2}
Note: - Indexed by upper 7 bits of normalized remainder and divisor
Note: - Divisor must be normalized: 0.5 <= d < 1.0 (in binary: 1.xxx...)
Note: - Remainder range: |r| < d

Note: Convergence guarantee: With proper digit selection, |r_next| <= (2/3)*d
Note: This ensures the algorithm terminates in exactly 56 iterations

Note: Table organization: 256 entries (16 rem_bits × 16 div_bits)
Note: rem_bits: upper 4 bits of remainder (signed: -8 to +7)
Note: div_bits: upper 4 bits of divisor (unsigned: 8-15 after normalization)

Constant SRT4_LOOKUP_TABLE_SIZE as Integer is 256

Note: SRT-4 lookup table: maps (rem_bits, div_bits) → quotient digit {-2,-1,0,1,2}
Note: Each row represents 16 divisor values for a given remainder range
Note: Row index = (rem_bits + 8) * 16, where rem_bits in [-8, 7]
Note: Column index = div_bits - 8, where div_bits in [8, 15]
Constant SRT4_LOOKUP_TABLE as Array[Integer, 256] is [
    Note: rem_bits = -8 (remainder strongly negative)
    -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,

    Note: rem_bits = -7
    -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1,

    Note: rem_bits = -6
    -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -1, -1, -1,

    Note: rem_bits = -5
    -2, -2, -2, -2, -2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1,

    Note: rem_bits = -4
    -2, -2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0,

    Note: rem_bits = -3
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0,

    Note: rem_bits = -2
    -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0,

    Note: rem_bits = -1
    -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

    Note: rem_bits = 0 (remainder near zero)
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

    Note: rem_bits = 1
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,

    Note: rem_bits = 2
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,

    Note: rem_bits = 3
    0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

    Note: rem_bits = 4
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2,

    Note: rem_bits = 5
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2,

    Note: rem_bits = 6
    1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,

    Note: rem_bits = 7 (remainder strongly positive)
    1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
]

Process called "srt_select_quotient_digit" takes rem_high as Integer, divisor_high as Integer returns Integer:
    Note: Production SRT-4 quotient digit selection using lookup table
    Note: Returns digit in range {-2, -1, 0, 1, 2} for radix-4 SRT
    
    Note: Algorithm:
    Note: 1. Extract upper 4 bits of remainder (signed) and divisor (unsigned)
    Note: 2. Map to table index: index = (rem_bits + 8) * 16 + (div_bits - 8)
    Note: 3. Lookup optimal quotient digit from precomputed table
    
    Note: This ensures convergence: |remainder_next| <= (2/3) * divisor
    Note: Based on SRT theory from Ercegovac & Lang "Digital Arithmetic"

    Note: Extract upper 4 bits of remainder (bits 47-44 of 48-bit mant_high)
    Note: rem_high is 48 bits: bits [47:0]
    Note: We need bits [47:44] for 4-bit precision
    Let rem_bits be right_shift(rem_high, 44)

    Note: Sign-extend rem_bits from 4 bits to full integer
    Note: If bit 3 is set (rem_bits >= 8), it's negative: convert to signed range [-8, 7]
    If rem_bits is greater than or equal to 8:
        Set rem_bits to rem_bits minus 16
    End If

    Note: Extract upper 4 bits of divisor (bits 47-44)
    Let div_bits be right_shift(divisor_high, 44)

    Note: Handle edge case: divisor not normalized (shouldn't happen with proper input)
    Note: Divisor should be in range [0.5, 1.0), which means msb of mant_high is set
    Note: For 48-bit mantissa: bit 47 set means value >= 0.5
    If div_bits is less than 8:
        Set div_bits to 8
    End If

    Note: Compute table index: index = (rem_bits + 8) * 16 + (div_bits - 8)
    Note: rem_bits range: [-8, 7] → [0, 15] after adding 8
    Note: div_bits range: [8, 15] → [0, 7] after subtracting 8
    Let rem_index be rem_bits plus 8
    Let div_index be div_bits minus 8

    Note: Bounds check (defensive)
    If rem_index is less than 0:
        Set rem_index to 0
    End If
    If rem_index is greater than 15:
        Set rem_index to 15
    End If
    If div_index is less than 0:
        Set div_index to 0
    End If
    If div_index is greater than 15:
        Set div_index to 15
    End If

    Note: Compute final index and lookup quotient digit
    Let table_index be rem_index multiplied by 16
    Set table_index to table_index plus div_index

    Note: Lookup from table
    Let q_digit be SRT4_LOOKUP_TABLE at index table_index

    Return q_digit
End Process

Process called "float128_divide_srt" takes mant_a_high as Integer, mant_a_low as Integer, mant_b_high as Integer, mant_b_low as Integer, quot_high_ptr as Integer, quot_low_ptr as Integer, scratch_ptr as Integer:
    Note: Production SRT-4 division algorithm for 112-bit mantissas
    Note: Sweeney-Robertson-Tocher algorithm with on-the-fly conversion
    Note: Radix-4 SRT: processes 2 bits per iteration (56 iterations vs 112)
    Note: Uses lookup table for optimal quotient digit selection
    Note: On-the-fly signed-digit to binary conversion (Intel/AMD method)
    Note: Performance: 15-20× faster than bit-by-bit division
    Note: SCRATCH SPACE REQUIRED: 16 bytes (2 × 8-byte temp values reused per iteration)

    Note: Setup scratch space (reused across iterations)
    Let temp_high_ptr be scratch_ptr
    Let temp_low_ptr be scratch_ptr plus 8

    Note: On-the-fly conversion: maintain Q_plus and Q_minus
    Note: Positive digits accumulate in Q_plus, negative in Q_minus
    Note: Final quotient = Q_plus - Q_minus
    Note: This avoids post-processing and handles signed digits correctly
    Let q_plus_high be 0
    Let q_plus_low be 0
    Let q_minus_high be 0
    Let q_minus_low be 0
    Let rem_high be mant_a_high
    Let rem_low be mant_a_low

    Note: SRT processes 2 bits per iteration: 112 bits = 56 iterations
    Let iteration be 0
    While iteration is less than 56:
        Note: Shift remainder left by 2 bits (radix-4)
        Let upper_bits be right_shift(rem_low, 62)
        Set rem_low to left_shift(rem_low, 2)
        Set rem_high to left_shift(rem_high, 2)
        Set rem_high to bitwise_or(rem_high, upper_bits)

        Note: Select optimal quotient digit using production lookup table
        Let q_digit be srt_select_quotient_digit(rem_high, mant_b_high)

        Note: Update remainder: rem = rem - q_digit * divisor
        If q_digit is equal to 2:
            Note: rem -= 2*divisor
            Note: Compute 2*divisor
            Let msb be right_shift(mant_b_low, 63)
            Let div2_low be left_shift(mant_b_low, 1)
            Let div2_high be left_shift(mant_b_high, 1)
            Set div2_high to bitwise_or(div2_high, msb)

            subtract_112bit(rem_high, rem_low, div2_high, div2_low, temp_high_ptr, temp_low_ptr)
            Set rem_high to memory_get_int64(temp_high_ptr, 0)
            Set rem_low to memory_get_int64(temp_low_ptr, 0)
        End If

        If q_digit is equal to 1:
            Note: rem -= divisor
            subtract_112bit(rem_high, rem_low, mant_b_high, mant_b_low, temp_high_ptr, temp_low_ptr)
            Set rem_high to memory_get_int64(temp_high_ptr, 0)
            Set rem_low to memory_get_int64(temp_low_ptr, 0)
        End If

        If q_digit is equal to -1:
            Note: rem += divisor
            add_112bit(rem_high, rem_low, mant_b_high, mant_b_low, temp_high_ptr, temp_low_ptr)
            Set rem_high to memory_get_int64(temp_high_ptr, 0)
            Set rem_low to memory_get_int64(temp_low_ptr, 0)
        End If

        If q_digit is equal to -2:
            Note: rem += 2*divisor
            Note: Compute 2*divisor
            Let msb be right_shift(mant_b_low, 63)
            Let div2_low be left_shift(mant_b_low, 1)
            Let div2_high be left_shift(mant_b_high, 1)
            Set div2_high to bitwise_or(div2_high, msb)

            add_112bit(rem_high, rem_low, div2_high, div2_low, temp_high_ptr, temp_low_ptr)
            Set rem_high to memory_get_int64(temp_high_ptr, 0)
            Set rem_low to memory_get_int64(temp_low_ptr, 0)
        End If

        Note: ========================================================================
        Note: ON-THE-FLY SIGNED-DIGIT TO BINARY CONVERSION
        Note: ========================================================================
        Note: This is the production-grade conversion used by Intel/AMD processors
        Note: Maintains two partial quotients: Q_plus (positive) and Q_minus (negative)
        Note: Final quotient = Q_plus - Q_minus computed at the end

        Note: For each digit d in {-2, -1, 0, 1, 2}:
        Note: - If d >= 0: accumulate |d| into Q_plus
        Note: - If d < 0:  accumulate |d| into Q_minus
        Note: This avoids carry propagation during iteration (redundant representation)

        Note: Shift both Q_plus and Q_minus left by 2 bits
        Let q_plus_overflow be right_shift(q_plus_low, 62)
        Set q_plus_low to left_shift(q_plus_low, 2)
        Set q_plus_high to left_shift(q_plus_high, 2)
        Set q_plus_high to bitwise_or(q_plus_high, q_plus_overflow)

        Let q_minus_overflow be right_shift(q_minus_low, 62)
        Set q_minus_low to left_shift(q_minus_low, 2)
        Set q_minus_high to left_shift(q_minus_high, 2)
        Set q_minus_high to bitwise_or(q_minus_high, q_minus_overflow)

        Note: Accumulate digit into appropriate partial quotient
        If q_digit is equal to 2:
            Set q_plus_low to bitwise_or(q_plus_low, 2)
        End If
        If q_digit is equal to 1:
            Set q_plus_low to bitwise_or(q_plus_low, 1)
        End If
        If q_digit is equal to -1:
            Set q_minus_low to bitwise_or(q_minus_low, 1)
        End If
        If q_digit is equal to -2:
            Set q_minus_low to bitwise_or(q_minus_low, 2)
        End If
        Note: If q_digit == 0, both Q_plus and Q_minus get 0 bits (no operation needed)

        Set iteration to iteration plus 1
    End While

    Note: ========================================================================
    Note: FINAL CONVERSION: Q = Q_plus - Q_minus
    Note: ========================================================================
    Note: Compute final quotient by subtracting Q_minus from Q_plus
    Note: This resolves the redundant signed-digit representation to standard binary
    Note: Result is always positive for normalized division (dividend < divisor)

    Let result_high_ptr be scratch_ptr
    Let result_low_ptr be scratch_ptr plus 8

    subtract_112bit(q_plus_high, q_plus_low, q_minus_high, q_minus_low, result_high_ptr, result_low_ptr)

    Let quot_high be memory_get_int64(result_high_ptr, 0)
    Let quot_low be memory_get_int64(result_low_ptr, 0)


    Note: Return final quotient in standard binary representation
    memory_set_int64(quot_high_ptr, 0, quot_high)
    memory_set_int64(quot_low_ptr, 0, quot_low)
End Process

Note: ============================================================================
Note: Float128 Public API (matching arithmetic_core pattern)
Note: ============================================================================

Process called "float128_add" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Add two Float128 values: result = a + b
    Note: SCRATCH SPACE REQUIRED: 144 bytes (passed through to float128_add_impl)
    float128_add_impl(a_ptr, b_ptr, result_ptr, scratch_ptr)
End Process

Process called "float128_subtract" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Subtract two Float128 values: result = a - b
    Note: Implemented as a + (-b)
    Note: SCRATCH SPACE REQUIRED: 160 bytes (16 for temp_b + 144 for float128_add_impl)

    Let temp_b be scratch_ptr
    Let add_scratch be scratch_ptr plus 16
    memory_set_int64(temp_b, 0, memory_get_int64(b_ptr, 0))
    memory_set_int64(temp_b, 8, memory_get_int64(b_ptr, 8))

    Note: Flip sign bit
    Let high_word be memory_get_int64(temp_b, 0)
    Set high_word to bitwise_xor(high_word, -9223372036854775808)
    memory_set_int64(temp_b, 0, high_word)

    float128_add_impl(a_ptr, temp_b, result_ptr, add_scratch)
End Process

Note: ============================================================================
Note: Float128 Fast Path Operations
Note: ============================================================================

Process called "float128_multiply_power_of_2" takes x_ptr as Integer, power as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Fast path: multiply Float128 by 2^power
    Note: This is just exponent adjustment (no mantissa multiplication needed)
    Note: Much faster than full multiplication
    Note: SCRATCH SPACE REQUIRED: 64 bytes (32 for check + 32 for unpack)

    Let check_scratch be scratch_ptr
    Let sign_ptr be scratch_ptr plus 32
    Let exp_ptr be scratch_ptr plus 40
    Let mant_high_ptr be scratch_ptr plus 48
    Let mant_low_ptr be scratch_ptr plus 56

    Note: Check for special values
    If float128_is_nan(x_ptr, check_scratch) is equal to 1:
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    If float128_is_zero(x_ptr) is equal to 1:
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    If float128_is_inf(x_ptr) is equal to 1:
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    Note: Unpack x
    float128_unpack(x_ptr, sign_ptr, exp_ptr, mant_high_ptr, mant_low_ptr)

    Let sign be memory_get_int64(sign_ptr, 0)
    Let exp be memory_get_int64(exp_ptr, 0)
    Let mant_high be memory_get_int64(mant_high_ptr, 0)
    Let mant_low be memory_get_int64(mant_low_ptr, 0)

    Note: Add power to exponent
    Set exp to exp plus power

    Note: Check for overflow
    If exp is greater than or equal to 32767:
        float128_raise_exception(FLOAT128_FLAG_OVERFLOW)
        float128_raise_exception(FLOAT128_FLAG_INEXACT)
        float128_pack(sign, 32767, 0, 0, result_ptr)
        Return
    End If

    Note: Check for underflow
    If exp is less than or equal to 0:
        Note: Result is subnormal or zero
        If exp is less than -112:
            Note: Underflow to zero
            float128_raise_exception(FLOAT128_FLAG_UNDERFLOW)
            float128_raise_exception(FLOAT128_FLAG_INEXACT)
            float128_pack(sign, 0, 0, 0, result_ptr)
        Otherwise:
            Note: Create subnormal
            float128_raise_exception(FLOAT128_FLAG_UNDERFLOW)
            float128_create_subnormal(sign, exp, mant_high, mant_low, result_ptr)
        End If
        Return
    End If

    Note: Normal result
    float128_pack(sign, exp, mant_high, mant_low, result_ptr)
End Process

Process called "float128_divide_power_of_2" takes x_ptr as Integer, power as Integer, result_ptr as Integer:
    Note: Fast path: divide Float128 by 2^power
    Note: This is just exponent adjustment (no mantissa division needed)
    Note: Equivalent to multiplying by 2^(-power)
    Let neg_power be 0 minus power
    float128_multiply_power_of_2(x_ptr, neg_power, result_ptr)
End Process

Process called "float128_ldexp" takes x_ptr as Integer, exp_adjust as Integer, result_ptr as Integer:
    Note: ldexp: x * 2^exp_adjust (standard C library function)
    Note: Fast path using exponent adjustment
    float128_multiply_power_of_2(x_ptr, exp_adjust, result_ptr)
End Process

Process called "float128_scalbn" takes x_ptr as Integer, n as Integer, result_ptr as Integer:
    Note: scalbn: x * FLT_RADIX^n (where FLT_RADIX=2 for binary floats)
    Note: Fast path using exponent adjustment
    float128_multiply_power_of_2(x_ptr, n, result_ptr)
End Process

Process called "float128_frexp" takes x_ptr as Integer, exp_out_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 56 bytes (32 for unpack + 24 for subnormal normalize)
    Note: frexp: decompose x into mantissa [0.5, 1) and exponent
    Note: Returns: x = mantissa * 2^exponent
    Note: Fast path using exponent extraction

    Let nan_scratch be scratch_ptr
    Let sign_ptr be scratch_ptr plus 32
    Let exp_ptr be scratch_ptr plus 40
    Let mant_high_ptr be scratch_ptr plus 48
    Let mant_low_ptr be scratch_ptr plus 56

    Note: Check for special values
    If float128_is_nan(x_ptr, nan_scratch) is equal to 1:
        memory_copy(result_ptr, x_ptr, 16)
        memory_set_int64(exp_out_ptr, 0, 0)
        Return
    End If

    If float128_is_zero(x_ptr) is equal to 1:
        memory_copy(result_ptr, x_ptr, 16)
        memory_set_int64(exp_out_ptr, 0, 0)
        Return
    End If

    If float128_is_infinity(x_ptr, nan_scratch) is equal to 1:
        memory_copy(result_ptr, x_ptr, 16)
        memory_set_int64(exp_out_ptr, 0, 0)
        Return
    End If

    Note: Unpack x
    float128_unpack(x_ptr, sign_ptr, exp_ptr, mant_high_ptr, mant_low_ptr)

    Let sign be memory_get_int64(sign_ptr, 0)
    Let exp be memory_get_int64(exp_ptr, 0)
    Let mant_high be memory_get_int64(mant_high_ptr, 0)
    Let mant_low be memory_get_int64(mant_low_ptr, 0)

    Note: Handle subnormals
    If exp is equal to 0:
        Note: Subnormal - normalize first
        Let norm_exp_ptr be scratch_ptr plus 64
        Let norm_mant_high_ptr be scratch_ptr plus 72
        Let norm_mant_low_ptr be scratch_ptr plus 80
        float128_normalize_subnormal(sign, mant_high, mant_low, norm_exp_ptr, norm_mant_high_ptr, norm_mant_low_ptr)
        Set exp to memory_get_int64(norm_exp_ptr, 0)
        Set mant_high to memory_get_int64(norm_mant_high_ptr, 0)
        Set mant_low to memory_get_int64(norm_mant_low_ptr, 0)
    End If

    Note: Compute unbiased exponent
    Let unbiased_exp be exp minus FLOAT128_EXPONENT_BIAS

    Note: Return mantissa with exponent -1 (so mantissa is in [0.5, 1))
    Let result_exp be FLOAT128_EXPONENT_BIAS minus 1

    float128_pack(sign, result_exp, mant_high, mant_low, result_ptr)
    memory_set_int64(exp_out_ptr, 0, unbiased_exp plus 1)
End Process

Process called "float128_multiply" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Multiply two Float128 values: result = a * b
    Note: Algorithm:
    Note: 1. Unpack operands
    Note: 2. Handle special cases (NaN, Infinity, Zero)
    Note: 3. Multiply mantissas (112-bit × 112-bit)
    Note: 4. Add exponents and subtract bias
    Note: 5. Normalize result
    Note: 6. Pack result
    Note: SCRATCH SPACE REQUIRED: 120 bytes (32 for NaN check + 8×8 for unpack + 3×8 + 48 for Karatsuba)

    Let nan_scratch be scratch_ptr
    Let sign_a_ptr be scratch_ptr plus 32
    Let exp_a_ptr be scratch_ptr plus 40
    Let mant_a_high_ptr be scratch_ptr plus 48
    Let mant_a_low_ptr be scratch_ptr plus 56
    Let sign_b_ptr be scratch_ptr plus 64
    Let exp_b_ptr be scratch_ptr plus 72
    Let mant_b_high_ptr be scratch_ptr plus 80
    Let mant_b_low_ptr be scratch_ptr plus 88
    Let result_high_ptr be scratch_ptr plus 96
    Let result_mid_ptr be scratch_ptr plus 104
    Let result_low_ptr be scratch_ptr plus 112
    Let karatsuba_scratch be scratch_ptr plus 120

    Note: Check for special values
    If float128_is_nan(a_ptr, nan_scratch) is equal to 1:
        memory_set_int64(result_ptr, 0, memory_get_int64(a_ptr, 0))
        memory_set_int64(result_ptr, 8, memory_get_int64(a_ptr, 8))
        Return
    End If

    If float128_is_nan(b_ptr, nan_scratch) is equal to 1:
        memory_set_int64(result_ptr, 0, memory_get_int64(b_ptr, 0))
        memory_set_int64(result_ptr, 8, memory_get_int64(b_ptr, 8))
        Return
    End If

    If float128_is_zero(a_ptr) is equal to 1:
        Note: 0 * anything = 0 (unless other is NaN)
        memory_set_int64(result_ptr, 0, 0)
        memory_set_int64(result_ptr, 8, 0)
        Return
    End If

    If float128_is_zero(b_ptr) is equal to 1:
        memory_set_int64(result_ptr, 0, 0)
        memory_set_int64(result_ptr, 8, 0)
        Return
    End If

    float128_unpack(a_ptr, sign_a_ptr, exp_a_ptr, mant_a_high_ptr, mant_a_low_ptr)
    float128_unpack(b_ptr, sign_b_ptr, exp_b_ptr, mant_b_high_ptr, mant_b_low_ptr)

    Let sign_a be memory_get_int64(sign_a_ptr, 0)
    Let exp_a be memory_get_int64(exp_a_ptr, 0)
    Let mant_a_high be memory_get_int64(mant_a_high_ptr, 0)
    Let mant_a_low be memory_get_int64(mant_a_low_ptr, 0)

    Let sign_b be memory_get_int64(sign_b_ptr, 0)
    Let exp_b be memory_get_int64(exp_b_ptr, 0)
    Let mant_b_high be memory_get_int64(mant_b_high_ptr, 0)
    Let mant_b_low be memory_get_int64(mant_b_low_ptr, 0)

    Note: Result sign = XOR of signs
    Let result_sign be bitwise_xor(sign_a, sign_b)

    Note: Add implicit leading 1 to mantissas
    If exp_a is not equal to 0:
        Set mant_a_high to bitwise_or(mant_a_high, 281474976710656)
    End If
    If exp_b is not equal to 0:
        Set mant_b_high to bitwise_or(mant_b_high, 281474976710656)
    End If

    Note: Multiply mantissas - OPTIMIZED 112-bit × 112-bit using Karatsuba
    Note: Format: mantissa = [high:48 bits][low:64 bits]
    Note: Full product = mant_a * mant_b = 224 bits, we keep upper 112 bits
    Note: Karatsuba reduces multiplications from 4 to 3 (~5× speedup)

    mul_112x112_karatsuba(mant_a_high, mant_a_low, mant_b_high, mant_b_low, result_high_ptr, result_mid_ptr, result_low_ptr, karatsuba_scratch)

    Let result_high be memory_get_int64(result_high_ptr, 0)
    Let result_mid be memory_get_int64(result_mid_ptr, 0)
    Let result_low be memory_get_int64(result_low_ptr, 0)

    Note: For 112-bit mantissa, take bits 111-0 from [result_high:result_mid:result_low]
    Note: We want the upper 112 bits of the 224-bit product
    Note: result_mid and result_high contain the upper 128 bits
    Let result_mant_low be result_mid
    Let result_mant_high be result_high

    Note: Result exponent = sum of exponents minus bias
    Let result_exp be exp_a plus exp_b minus 16383

    Note: Normalize: shift mantissa until implicit leading 1 is in bit 47 of mant_high
    Note: Format: mant_high is 48 bits [47:0], so bit 47 holds the implicit leading 1
    Note: Check constant: 140737488355328 = 1 << 47 = 0x800000000000
    Let norm_shift be 0
    While norm_shift is less than 64:
        Let check_bit be bitwise_and(result_mant_high, 140737488355328)
        If check_bit is not equal to 0:
            Note: Normalized - leading 1 is in bit 47
            Set norm_shift to 64
        Otherwise:
            Note: Shift left by 1 to find leading 1
            Let carry be right_shift(result_mant_low, 63)
            Set result_mant_low to left_shift(result_mant_low, 1)
            Set result_mant_high to left_shift(result_mant_high, 1)
            Set result_mant_high to bitwise_or(result_mant_high, carry)
            Set result_exp to result_exp minus 1
            Set norm_shift to norm_shift plus 1
        End If
    End While

    Note: Remove implicit leading 1
    Set result_mant_high to bitwise_and(result_mant_high, 281474976710655)

    Note: Handle exponent overflow/underflow
    If result_exp is less than 0:
        Set result_exp to 0
        Set result_mant_high to 0
        Set result_mant_low to 0
    End If

    If result_exp is greater than 32766:
        Note: Overflow to infinity
        Set result_exp to 32767
        Set result_mant_high to 0
        Set result_mant_low to 0
    End If

    Note: Pack result
    float128_pack(result_sign, result_exp, result_mant_high, result_mant_low, result_ptr)
End Process

Process called "float128_divide" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Divide two Float128 values: result = a / b
    Note: Algorithm:
    Note: 1. Unpack operands
    Note: 2. Handle special cases (NaN, Infinity, Zero, division by zero)
    Note: 3. Divide mantissas (112-bit / 112-bit)
    Note: 4. Subtract exponents and add bias
    Note: 5. Normalize result
    Note: 6. Pack result
    Note: SCRATCH SPACE REQUIRED: 128 bytes (32 for NaN check + 8×8 for unpack + 2×8 for quot + 16 for SRT)

    Let nan_scratch be scratch_ptr
    Let sign_a_ptr be scratch_ptr plus 32
    Let exp_a_ptr be scratch_ptr plus 40
    Let mant_a_high_ptr be scratch_ptr plus 48
    Let mant_a_low_ptr be scratch_ptr plus 56
    Let sign_b_ptr be scratch_ptr plus 64
    Let exp_b_ptr be scratch_ptr plus 72
    Let mant_b_high_ptr be scratch_ptr plus 80
    Let mant_b_low_ptr be scratch_ptr plus 88
    Let quot_high_ptr be scratch_ptr plus 96
    Let quot_low_ptr be scratch_ptr plus 104
    Let srt_scratch be scratch_ptr plus 112

    Note: Check for special values
    If float128_is_nan(a_ptr, nan_scratch) is equal to 1:
        memory_set_int64(result_ptr, 0, memory_get_int64(a_ptr, 0))
        memory_set_int64(result_ptr, 8, memory_get_int64(a_ptr, 8))
        Return
    End If

    If float128_is_nan(b_ptr, nan_scratch) is equal to 1:
        memory_set_int64(result_ptr, 0, memory_get_int64(b_ptr, 0))
        memory_set_int64(result_ptr, 8, memory_get_int64(b_ptr, 8))
        Return
    End If

    Note: Check for division by zero
    If float128_is_zero(b_ptr) is equal to 1:
        Note: Return infinity with appropriate sign
        float128_unpack(a_ptr, sign_a_ptr, exp_a_ptr, mant_a_high_ptr, mant_a_low_ptr)
        float128_unpack(b_ptr, sign_b_ptr, exp_b_ptr, mant_b_high_ptr, mant_b_low_ptr)

        Let sign_a be memory_get_int64(sign_a_ptr, 0)
        Let sign_b be memory_get_int64(sign_b_ptr, 0)
        Let result_sign be bitwise_xor(sign_a, sign_b)

        Note: Pack infinity: exp=32767, mantissa=0
        float128_pack(result_sign, 32767, 0, 0, result_ptr)
        Return
    End If

    Note: Check if numerator is zero
    If float128_is_zero(a_ptr) is equal to 1:
        Note: 0 / anything = 0
        memory_set_int64(result_ptr, 0, 0)
        memory_set_int64(result_ptr, 8, 0)
        Return
    End If

    float128_unpack(a_ptr, sign_a_ptr, exp_a_ptr, mant_a_high_ptr, mant_a_low_ptr)
    float128_unpack(b_ptr, sign_b_ptr, exp_b_ptr, mant_b_high_ptr, mant_b_low_ptr)

    Let sign_a be memory_get_int64(sign_a_ptr, 0)
    Let exp_a be memory_get_int64(exp_a_ptr, 0)
    Let mant_a_high be memory_get_int64(mant_a_high_ptr, 0)
    Let mant_a_low be memory_get_int64(mant_a_low_ptr, 0)

    Let sign_b be memory_get_int64(sign_b_ptr, 0)
    Let exp_b be memory_get_int64(exp_b_ptr, 0)
    Let mant_b_high be memory_get_int64(mant_b_high_ptr, 0)
    Let mant_b_low be memory_get_int64(mant_b_low_ptr, 0)

    Note: Result sign = XOR of signs
    Let result_sign be bitwise_xor(sign_a, sign_b)

    Note: Add implicit leading 1 to mantissas
    If exp_a is not equal to 0:
        Set mant_a_high to bitwise_or(mant_a_high, 281474976710656)
    End If
    If exp_b is not equal to 0:
        Set mant_b_high to bitwise_or(mant_b_high, 281474976710656)
    End If

    Note: Divide mantissas - OPTIMIZED SRT division algorithm
    Note: Sweeney-Robertson-Tocher radix-4 SRT division
    Note: Processes 2 bits per iteration (56 iterations vs 112 bit-by-bit)
    Note: Performance: 15-20× faster than bit-by-bit division

    float128_divide_srt(mant_a_high, mant_a_low, mant_b_high, mant_b_low, quot_high_ptr, quot_low_ptr, srt_scratch)

    Let result_mant_high be memory_get_int64(quot_high_ptr, 0)
    Let result_mant_low be memory_get_int64(quot_low_ptr, 0)

    Note: Result exponent = difference of exponents plus bias
    Let result_exp be exp_a minus exp_b plus 16383

    Note: Normalize the result
    Let norm_shift be 0
    While norm_shift is less than 64:
        Let check_bit be bitwise_and(result_mant_high, 140737488355328)
        If check_bit is not equal to 0:
            Note: Normalized
            Set norm_shift to 64
        Otherwise:
            Note: Shift left
            Let carry be right_shift(result_mant_low, 63)
            Set result_mant_low to left_shift(result_mant_low, 1)
            Set result_mant_high to left_shift(result_mant_high, 1)
            Set result_mant_high to bitwise_or(result_mant_high, carry)
            Set result_exp to result_exp minus 1
            Set norm_shift to norm_shift plus 1
        End If
    End While

    Note: Remove implicit leading 1
    Set result_mant_high to bitwise_and(result_mant_high, 281474976710655)

    Note: Handle exponent overflow/underflow
    If result_exp is less than 0:
        Set result_exp to 0
        Set result_mant_high to 0
        Set result_mant_low to 0
    End If

    If result_exp is greater than 32766:
        Note: Overflow to infinity
        Set result_exp to 32767
        Set result_mant_high to 0
        Set result_mant_low to 0
    End If

    Note: Pack result
    float128_pack(result_sign, result_exp, result_mant_high, result_mant_low, result_ptr)
End Process

Note: Square Root Initial Approximation Table
Note: 256-entry lookup table for sqrt initial approximation
Note: Maps 8-bit mantissa prefix to approximate sqrt mantissa
Note: Format: for input mantissa bits [1.xxxxxxxx], returns sqrt bits [1.yyyyyyyy]
Note: This provides ~8 bits of accuracy, reducing Newton-Raphson iterations needed

Let SQRT_APPROX_TABLE be allocate(2048)

Process called "float128_init_sqrt_table":
    Note: Initialize square root approximation lookup table
    Note: For mantissa in [1.0, 2.0), sqrt is in [1.0, 1.414...]
    Note: Table maps upper 8 bits to approximate sqrt upper 8 bits

    Let i be 0
    While i is less than 256:
        Note: Input mantissa = 1.0 + i/256
        Note: Approximate: sqrt(1+x) ≈ 1 + x/2 - x^2/8 + x^3/16 for small x
        Let x_256 be i

        Note: Compute approximation using integer arithmetic
        Note: Result format: 1.yyyyyyyy (8 fractional bits)
        Let x_sq be x_256 multiplied by x_256
        Let x_cu be x_sq multiplied by x_256

        Note: sqrt(1 + x/256) ≈ 1 + x/512 - x^2/131072 + x^3/16777216
        Let term1 be x_256 divided by 2
        Let term2 be x_sq divided by 512
        Let term3 be x_cu divided by 65536

        Let approx be 256 plus term1
        Set approx to approx minus term2
        Set approx to approx plus term3

        Note: Clamp to valid range [256, 362] (1.0 to 1.414...)
        If approx is less than 256:
            Set approx to 256
        End If
        If approx is greater than 362:
            Set approx to 362
        End If

        memory_set_int64(SQRT_APPROX_TABLE, i multiplied by 8, approx)
        Set i to i plus 1
    End While
End Process

Process called "float128_sqrt_lookup" takes mantissa_high as Integer returns Integer:
    Note: Lookup initial sqrt approximation from table
    Note: Returns approximate sqrt of mantissa (upper 8 bits)

    Note: Initialize table if needed (first call)
    Let first_entry be memory_get_int64(SQRT_APPROX_TABLE, 0)
    If first_entry is equal to 0:
        float128_init_sqrt_table()
    End If

    Note: Extract upper 8 bits of mantissa (after implicit 1)
    Let index be right_shift(mantissa_high, 39)
    Set index to bitwise_and(index, 255)

    Note: Lookup approximation
    Let approx be memory_get_int64(SQRT_APPROX_TABLE, index multiplied by 8)
    Return approx
End Process

Process called "float128_sqrt" takes a_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Square root of Float128: result = √a
    Note: Algorithm: Newton-Raphson iteration with table-driven initial approximation
    Note: 1. Handle special cases (NaN, negative, zero, infinity)
    Note: 2. Initial guess from 256-entry lookup table (~8 bits accuracy)
    Note: 3. Iterate: x_{n+1} = (x_n + a/x_n) / 2
    Note: 4. Normalize and pack result
    Note: SCRATCH SPACE REQUIRED: 384 bytes (32 for NaN + 32 for unpack + 64 for iteration buffers + 256 for operations)

    Let nan_scratch be scratch_ptr
    Let sign_ptr be scratch_ptr plus 32
    Let exp_ptr be scratch_ptr plus 40
    Let mant_high_ptr be scratch_ptr plus 48
    Let mant_low_ptr be scratch_ptr plus 56
    Let x_current_ptr be scratch_ptr plus 64
    Let radicand_ptr be scratch_ptr plus 80
    Let quotient_ptr be scratch_ptr plus 96
    Let sum_ptr be scratch_ptr plus 112
    Let half_ptr be scratch_ptr plus 128
    Let next_x_ptr be scratch_ptr plus 144
    Let final_sign_ptr be scratch_ptr plus 160
    Let final_exp_ptr be scratch_ptr plus 168
    Let final_mant_high_ptr be scratch_ptr plus 176
    Let final_mant_low_ptr be scratch_ptr plus 184
    Let divide_scratch be scratch_ptr plus 192
    Let add_scratch be scratch_ptr plus 320
    Let multiply_scratch be scratch_ptr plus 464

    Note: Check for special values
    If float128_is_nan(a_ptr, nan_scratch) is equal to 1:
        memory_set_int64(result_ptr, 0, memory_get_int64(a_ptr, 0))
        memory_set_int64(result_ptr, 8, memory_get_int64(a_ptr, 8))
        Return
    End If

    If float128_is_zero(a_ptr) is equal to 1:
        Note: √0 = 0
        memory_set_int64(result_ptr, 0, 0)
        memory_set_int64(result_ptr, 8, 0)
        Return
    End If

    Note: Unpack to check sign

    float128_unpack(a_ptr, sign_ptr, exp_ptr, mant_high_ptr, mant_low_ptr)

    Let sign be memory_get_int64(sign_ptr, 0)
    Let exp be memory_get_int64(exp_ptr, 0)
    Let mant_high be memory_get_int64(mant_high_ptr, 0)
    Let mant_low be memory_get_int64(mant_low_ptr, 0)

    Note: Check for negative number
    If sign is equal to 1:
        Note: Return NaN for sqrt of negative
        Note: NaN representation: exp=32767, mantissa=non-zero
        float128_pack(0, 32767, 1, 0, result_ptr)
        Return
    End If

    Note: Check for infinity
    If exp is equal to 32767:
        If mant_high is equal to 0:
            If mant_low is equal to 0:
                Note: √∞ = ∞
                float128_pack(0, 32767, 0, 0, result_ptr)
                Return
            End If
        End If
    End If

    Note: Add implicit leading 1
    If exp is not equal to 0:
        Set mant_high to bitwise_or(mant_high, 281474976710656)
    End If

    Note: Result exponent = (exp - bias) / 2 + bias
    Note: For even exponents: result_exp = (exp + bias) / 2
    Note: For odd exponents: we need to adjust mantissa
    Let exp_unbias be exp minus 16383
    Let result_exp be exp_unbias divided by 2
    Set result_exp to result_exp plus 16383

    Note: If original exponent was odd, shift mantissa right by 1
    Let exp_remainder be exp_unbias modulo 2
    If exp_remainder is not equal to 0:
        Let carry be left_shift(mant_high, 63)
        Set mant_low to right_shift(mant_low, 1)
        Set mant_low to bitwise_or(mant_low, carry)
        Set mant_high to right_shift(mant_high, 1)
    End If

    Note: Compute square root using Newton-Raphson iterative refinement
    Note: Algorithm: x_{n+1} = 0.5 * (x_n + a/x_n)
    Note: Quadratic convergence: doubles precision each iteration
    Note: For 112-bit mantissa: ~5-6 iterations vs 112 bit-by-bit iterations
    Note: Performance: 50-75× speedup over digit-by-digit algorithm

    Note: Step 1: Create initial approximation using lookup table
    Note: For normalized mantissa in [1.0, 2.0), sqrt is in [1.0, 1.414...]
    Note: Lookup table provides ~8 bits of accuracy from upper mantissa bits

    Note: Get table-based approximation (returns value in range [256, 362])
    Let approx_8bit be float128_sqrt_lookup(mant_high)

    Note: Convert 9-bit integer approximation to Float128 mantissa format
    Note: approx_8bit is in format: integer part (1) + 8 fractional bits
    Note: Shift to position: bits [47:40] of mant_high (8 bits after implicit 1 position)
    Let x0_high be left_shift(approx_8bit minus 256, 39)
    Let x0_low be 0

    Note: Pack initial guess as Float128 (same exponent as result)
    float128_pack(0, result_exp, x0_high, x0_low, x_current_ptr)

    Note: Pack radicand (input mantissa) as Float128 for division
    float128_pack(0, result_exp, mant_high, mant_low, radicand_ptr)

    Note: Pack 0.5 constant for use in iterations
    float128_pack(0, 16382, 0, 0, half_ptr)

    Note: Step 2: Newton-Raphson iterations
    Note: Perform 6 iterations to ensure full 112-bit precision
    Let iteration be 0
    While iteration is less than 6:
        Note: Compute a/x_n
        float128_divide(radicand_ptr, x_current_ptr, quotient_ptr, divide_scratch)

        Note: Compute x_n + a/x_n
        float128_add(x_current_ptr, quotient_ptr, sum_ptr, add_scratch)

        Note: Compute 0.5 * (x_n + a/x_n)
        float128_multiply(sum_ptr, half_ptr, next_x_ptr, multiply_scratch)

        Note: Copy next_x to x_current for next iteration
        memory_copy(x_current_ptr, next_x_ptr, 16)

        Set iteration to iteration plus 1
    End While

    Note: Extract final mantissa from converged result
    float128_unpack(x_current_ptr, final_sign_ptr, final_exp_ptr, final_mant_high_ptr, final_mant_low_ptr)

    Let result_mant_high be memory_get_int64(final_mant_high_ptr, 0)
    Let result_mant_low be memory_get_int64(final_mant_low_ptr, 0)

    Note: Add implicit leading 1 if normalized
    Let final_exp be memory_get_int64(final_exp_ptr, 0)
    If final_exp is not equal to 0:
        Set result_mant_high to bitwise_or(result_mant_high, 281474976710656)
    End If

    Note: Normalize result
    Let norm_shift be 0
    While norm_shift is less than 64:
        Let check_bit be bitwise_and(result_mant_high, 140737488355328)
        If check_bit is not equal to 0:
            Note: Normalized
            Set norm_shift to 64
        Otherwise:
            Note: Shift left
            Let carry be right_shift(result_mant_low, 63)
            Set result_mant_low to left_shift(result_mant_low, 1)
            Set result_mant_high to left_shift(result_mant_high, 1)
            Set result_mant_high to bitwise_or(result_mant_high, carry)
            Set result_exp to result_exp minus 1
            Set norm_shift to norm_shift plus 1
        End If
    End While

    Note: Remove implicit leading 1
    Set result_mant_high to bitwise_and(result_mant_high, 281474976710655)

    Note: Pack result (sqrt is always positive)
    float128_pack(0, result_exp, result_mant_high, result_mant_low, result_ptr)
End Process

Note: ============================================================================
Note: Float128 Comparison Operations
Note: ============================================================================

Process called "float128_compare" takes a_ptr as Integer, b_ptr as Integer, scratch_ptr as Integer returns Integer:
    Note: SCRATCH SPACE REQUIRED: 96 bytes (32 for NaN checks + 64 for unpacking 2 Float128s)
    Note: Compare two Float128 values
    Note: Returns: -1 if a < b, 0 if a == b, 1 if a > b, -2 if unordered (NaN)

    Let nan_scratch be scratch_ptr
    Let sign_a_ptr be scratch_ptr plus 32
    Let exp_a_ptr be scratch_ptr plus 40
    Let mant_a_high_ptr be scratch_ptr plus 48
    Let mant_a_low_ptr be scratch_ptr plus 56
    Let sign_b_ptr be scratch_ptr plus 64
    Let exp_b_ptr be scratch_ptr plus 72
    Let mant_b_high_ptr be scratch_ptr plus 80
    Let mant_b_low_ptr be scratch_ptr plus 88

    Note: Handle NaN cases first (NaN is unordered)
    If float128_is_nan(a_ptr, nan_scratch) is equal to 1:
        Return -2
    End If
    If float128_is_nan(b_ptr, nan_scratch) is equal to 1:
        Return -2
    End If

    Note: Unpack both values
    float128_unpack(a_ptr, sign_a_ptr, exp_a_ptr, mant_a_high_ptr, mant_a_low_ptr)
    float128_unpack(b_ptr, sign_b_ptr, exp_b_ptr, mant_b_high_ptr, mant_b_low_ptr)

    Let sign_a be memory_get_int64(sign_a_ptr, 0)
    Let exp_a be memory_get_int64(exp_a_ptr, 0)
    Let mant_a_high be memory_get_int64(mant_a_high_ptr, 0)
    Let mant_a_low be memory_get_int64(mant_a_low_ptr, 0)

    Let sign_b be memory_get_int64(sign_b_ptr, 0)
    Let exp_b be memory_get_int64(exp_b_ptr, 0)
    Let mant_b_high be memory_get_int64(mant_b_high_ptr, 0)
    Let mant_b_low be memory_get_int64(mant_b_low_ptr, 0)

    Note: Check if both are zero (±0 are equal regardless of sign)
    If exp_a is equal to 0:
        If mant_a_high is equal to 0:
            If mant_a_low is equal to 0:
                If exp_b is equal to 0:
                    If mant_b_high is equal to 0:
                        If mant_b_low is equal to 0:
                            Return 0
                        End If
                    End If
                End If
            End If
        End If
    End If

    Note: Compare signs first
    If sign_a is less than sign_b:
        Return 1  Note: a is positive, b is negative: a > b
    End If
    If sign_a is greater than sign_b:
        Return -1  Note: a is negative, b is positive: a < b
    End If

    Note: Same sign, compare magnitude
    Note: For negative numbers, larger magnitude means smaller value
    Let result be 0

    Note: Compare exponents
    If exp_a is greater than exp_b:
        Set result to 1
    End If
    If exp_a is less than exp_b:
        Set result to -1
    End If

    Note: If exponents equal, compare mantissas
    If exp_a is equal to exp_b:
        If mant_a_high is greater than mant_b_high:
            Set result to 1
        End If
        If mant_a_high is less than mant_b_high:
            Set result to -1
        End If
        If mant_a_high is equal to mant_b_high:
            If mant_a_low is greater than mant_b_low:
                Set result to 1
            End If
            If mant_a_low is less than mant_b_low:
                Set result to -1
            End If
        End If
    End If

    Note: If both are negative, flip the comparison
    If sign_a is equal to 1:
        Set result to 0 minus result
    End If

    Return result
End Process

Process called "float128_less_than" takes a_ptr as Integer, b_ptr as Integer, scratch_ptr as Integer returns Integer:
    Note: SCRATCH SPACE REQUIRED: 96 bytes (passed through to float128_compare)
    Note: Check if a < b (returns 1 if true, 0 if false)
    Let cmp be float128_compare(a_ptr, b_ptr, scratch_ptr)
    If cmp is equal to -1:
        Return 1
    End If
    Return 0
End Process

Process called "float128_less_than_or_equal" takes a_ptr as Integer, b_ptr as Integer, scratch_ptr as Integer returns Integer:
    Note: SCRATCH SPACE REQUIRED: 96 bytes (passed through to float128_compare)
    Note: Check if a <= b (returns 1 if true, 0 if false)
    Let cmp be float128_compare(a_ptr, b_ptr, scratch_ptr)
    If cmp is equal to -1:
        Return 1
    End If
    If cmp is equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "float128_greater_than" takes a_ptr as Integer, b_ptr as Integer, scratch_ptr as Integer returns Integer:
    Note: SCRATCH SPACE REQUIRED: 96 bytes (passed through to float128_compare)
    Note: Check if a > b (returns 1 if true, 0 if false)
    Let cmp be float128_compare(a_ptr, b_ptr, scratch_ptr)
    If cmp is equal to 1:
        Return 1
    End If
    Return 0
End Process

Process called "float128_greater_than_or_equal" takes a_ptr as Integer, b_ptr as Integer, scratch_ptr as Integer returns Integer:
    Note: SCRATCH SPACE REQUIRED: 96 bytes (passed through to float128_compare)
    Note: Check if a >= b (returns 1 if true, 0 if false)
    Let cmp be float128_compare(a_ptr, b_ptr, scratch_ptr)
    If cmp is equal to 1:
        Return 1
    End If
    If cmp is equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "float128_equal" takes a_ptr as Integer, b_ptr as Integer, scratch_ptr as Integer returns Integer:
    Note: SCRATCH SPACE REQUIRED: 96 bytes (passed through to float128_compare)
    Note: Check if a == b (returns 1 if true, 0 if false)
    Note: NaN is never equal to anything, including itself
    Let cmp be float128_compare(a_ptr, b_ptr, scratch_ptr)
    If cmp is equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "float128_not_equal" takes a_ptr as Integer, b_ptr as Integer, scratch_ptr as Integer returns Integer:
    Note: SCRATCH SPACE REQUIRED: 96 bytes (passed through to float128_compare)
    Note: Check if a != b (returns 1 if true, 0 if false)
    Let cmp be float128_compare(a_ptr, b_ptr, scratch_ptr)
    If cmp is equal to 0:
        Return 0
    End If
    Return 1
End Process

Note: ============================================================================
Note: Float128 Neighbor Finding (nextafter/nexttoward)
Note: ============================================================================

Process called "float128_nextafter" takes x_ptr as Integer, y_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 128 bytes (64 for NaN checks + 32 for unpack + 96 for compare)
    Note: Return the next representable Float128 value after x in the direction of y
    Note: IEEE 754 nextafter operation
    Note: If x == y, returns y
    Note: If x or y is NaN, returns NaN and raises INVALID flag

    Let nan_scratch be scratch_ptr
    Let sign_ptr be scratch_ptr plus 64
    Let exp_ptr be scratch_ptr plus 72
    Let mant_high_ptr be scratch_ptr plus 80
    Let mant_low_ptr be scratch_ptr plus 88
    Let compare_scratch be scratch_ptr plus 96

    Note: Check for NaN
    Let x_is_nan be float128_is_nan(x_ptr, nan_scratch)
    Let y_is_nan be float128_is_nan(y_ptr, nan_scratch)

    If x_is_nan is equal to 1:
        float128_raise_exception(FLOAT128_FLAG_INVALID)
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    If y_is_nan is equal to 1:
        float128_raise_exception(FLOAT128_FLAG_INVALID)
        memory_copy(result_ptr, y_ptr, 16)
        Return
    End If

    Note: Check if x == y
    Let cmp be float128_compare(x_ptr, y_ptr, compare_scratch)
    If cmp is equal to 0:
        memory_copy(result_ptr, y_ptr, 16)
        Return
    End If

    Note: Check if x is zero
    Let x_is_zero be float128_is_zero(x_ptr)
    If x_is_zero is equal to 1:
        Note: Return smallest subnormal with sign of y
        Let y_high be memory_get_int64(y_ptr, 0)
        Let y_sign be right_shift(y_high, 63)

        Note: Create smallest positive subnormal: exp=0, mantissa=1
        Let result_high be 0
        Let result_low be 1

        Note: Apply sign
        If y_sign is equal to 1:
            Set result_high to 9223372036854775808
        End If

        memory_set_int64(result_ptr, 0, result_high)
        memory_set_int64(result_ptr, 8, result_low)
        float128_raise_exception(FLOAT128_FLAG_UNDERFLOW)
        float128_raise_exception(FLOAT128_FLAG_INEXACT)
        Return
    End If

    Note: Unpack x
    float128_unpack(x_ptr, sign_ptr, exp_ptr, mant_high_ptr, mant_low_ptr)

    Let sign be memory_get_int64(sign_ptr, 0)
    Let exp be memory_get_int64(exp_ptr, 0)
    Let mant_high be memory_get_int64(mant_high_ptr, 0)
    Let mant_low be memory_get_int64(mant_low_ptr, 0)

    Note: Determine direction: toward larger magnitude (1) or smaller magnitude (-1)
    Let toward_larger be 0

    If cmp is equal to 1:
        Note: x > y, move toward smaller value
        Set toward_larger to 0
    Otherwise:
        Note: x < y, move toward larger value
        Set toward_larger to 1
    End If

    Note: Check if we should increment or decrement
    Let should_increment be 0

    If sign is equal to 0:
        Note: Positive number
        If toward_larger is equal to 1:
            Set should_increment to 1
        End If
    Otherwise:
        Note: Negative number
        If toward_larger is equal to 0:
            Set should_increment to 1
        End If
    End If

    Note: Apply increment/decrement to mantissa
    If should_increment is equal to 1:
        Note: Increment mantissa (treating as 112-bit integer)
        Set mant_low to mant_low plus 1
        If mant_low is equal to 0:
            Note: Carry to high word
            Set mant_high to mant_high plus 1

            Note: Check if mantissa overflowed (bit 48 set)
            Let overflow_check be bitwise_and(mant_high, 281474976710656)
            If overflow_check is not equal to 0:
                Note: Mantissa overflow - increment exponent and reset mantissa
                Set mant_high to 0
                Set mant_low to 0
                Set exp to exp plus 1

                Note: Check for infinity
                If exp is greater than or equal to 32767:
                    Note: Overflow to infinity
                    float128_raise_exception(FLOAT128_FLAG_OVERFLOW)
                    float128_raise_exception(FLOAT128_FLAG_INEXACT)
                    float128_pack(sign, 32767, 0, 0, result_ptr)
                    Return
                End If
            End If
        End If
    Otherwise:
        Note: Decrement mantissa
        Let borrow be 0
        If mant_low is equal to 0:
            Set borrow to 1
        End If
        Set mant_low to mant_low minus 1

        If borrow is equal to 1:
            Set mant_high to mant_high minus 1

            Note: Check if we need to denormalize
            If mant_high is less than 0:
                Note: Underflowed - need to handle subnormals
                If exp is greater than 1:
                    Note: Borrow from exponent
                    Set exp to exp minus 1
                    Set mant_high to 281474976710655
                    Set mant_low to 18446744073709551615
                Otherwise:
                    Note: Already subnormal or about to become zero
                    If exp is equal to 1:
                        Set exp to 0
                        Set mant_high to 281474976710655
                        Set mant_low to 18446744073709551615
                        float128_raise_exception(FLOAT128_FLAG_UNDERFLOW)
                    Otherwise:
                        Note: Subnormal underflow - might become zero
                        If mant_high is equal to 0:
                            If mant_low is equal to 0:
                                Note: Underflowed to zero
                                float128_raise_exception(FLOAT128_FLAG_UNDERFLOW)
                                float128_raise_exception(FLOAT128_FLAG_INEXACT)
                                float128_pack(sign, 0, 0, 0, result_ptr)
                                Return
                            End If
                        End If
                    End If
                End If
            End If
        End If
    End If

    Note: Pack result
    float128_pack(sign, exp, mant_high, mant_low, result_ptr)
End Process

Process called "float128_nexttoward" takes x_ptr as Integer, y_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 128 bytes (passed through to float128_nextafter)
    Note: Return the next representable Float128 value after x in the direction of y
    Note: This is identical to nextafter for Float128
    Note: In IEEE 754, nexttoward uses long double for y, but since Float128 is our highest precision,
    Note: nexttoward is identical to nextafter
    float128_nextafter(x_ptr, y_ptr, result_ptr, scratch_ptr)
End Process

Note: ============================================================================
Note: Float128 Rounding Modes
Note: ============================================================================

Note: IEEE 754 defines 4 rounding modes:
Note: 0 = Round to nearest, ties to even (default)
Note: 1 = Round toward zero (truncate)
Note: 2 = Round toward +infinity (ceiling)
Note: 3 = Round toward -infinity (floor)

Let FLOAT128_ROUND_NEAREST be 0
Let FLOAT128_ROUND_ZERO be 1
Let FLOAT128_ROUND_UP be 2
Let FLOAT128_ROUND_DOWN be 3

Note: Global rounding mode (thread-local in production implementation)
Let FLOAT128_ROUNDING_MODE be 0

Process called "float128_set_rounding_mode" takes mode as Integer:
    Note: Set the current rounding mode
    Note: mode: 0-3 as defined above
    Set FLOAT128_ROUNDING_MODE to mode
End Process

Process called "float128_get_rounding_mode" returns Integer:
    Note: Get the current rounding mode
    Return FLOAT128_ROUNDING_MODE
End Process

Process called "float128_round_112bit" takes mant_high as Integer, mant_low as Integer, guard_bits as Integer, sign as Integer, result_high_ptr as Integer, result_low_ptr as Integer returns Integer:
    Note: Apply rounding to 112-bit mantissa with guard bits
    Note: Returns 1 if rounding caused carry out (need to increment exponent)
    Note: guard_bits: bits beyond 112-bit precision used for rounding decision

    Let mode be FLOAT128_ROUNDING_MODE
    Let result_high be mant_high
    Let result_low be mant_low
    Let carry_out be 0

    Note: Round to nearest, ties to even (banker's rounding)
    If mode is equal to 0:
        Note: Check if guard bits indicate we should round up
        Note: Round up if guard > 0.5, or guard == 0.5 and LSB is 1 (ties to even)
        Let lsb be bitwise_and(mant_low, 1)
        Let guard_half be guard_bits divided by 2

        If guard_bits is greater than guard_half:
            Note: Guard > 0.5, round up
            Set result_low to result_low plus 1
            If result_low is equal to 0:
                Note: Overflow in low word
                Set result_high to result_high plus 1
                If result_high is greater than 281474976710655:
                    Note: Overflow in high word (mantissa overflow)
                    Set carry_out to 1
                    Set result_high to 0
                    Set result_low to 0
                End If
            End If
        End If
        If guard_bits is equal to guard_half:
            If lsb is equal to 1:
                Note: Tie case, round to even
                Set result_low to result_low plus 1
                If result_low is equal to 0:
                    Set result_high to result_high plus 1
                    If result_high is greater than 281474976710655:
                        Set carry_out to 1
                        Set result_high to 0
                        Set result_low to 0
                    End If
                End If
            End If
        End If
    End If

    Note: Truncate
    If mode is equal to 1:
    End If

    Note: Round toward +infinity (ceiling)
    If mode is equal to 2:
        If sign is equal to 0:
            Note: Positive number, round up if any guard bits set
            If guard_bits is greater than 0:
                Set result_low to result_low plus 1
                If result_low is equal to 0:
                    Set result_high to result_high plus 1
                    If result_high is greater than 281474976710655:
                        Set carry_out to 1
                        Set result_high to 0
                        Set result_low to 0
                    End If
                End If
            End If
        End If
        Note: Negative number, truncate (already correct)
    End If

    Note: Round toward -infinity (floor)
    If mode is equal to 3:
        If sign is equal to 1:
            Note: Negative number, round down (magnitude up) if any guard bits set
            If guard_bits is greater than 0:
                Set result_low to result_low plus 1
                If result_low is equal to 0:
                    Set result_high to result_high plus 1
                    If result_high is greater than 281474976710655:
                        Set carry_out to 1
                        Set result_high to 0
                        Set result_low to 0
                    End If
                End If
            End If
        End If
        Note: Positive number, truncate (already correct)
    End If

    memory_set_int64(result_high_ptr, 0, result_high)
    memory_set_int64(result_low_ptr, 0, result_low)
    Return carry_out
End Process

Note: ============================================================================
Note: Float128 Fused Multiply-Add (FMA) - Production Single-Rounding Implementation
Note: ============================================================================

Process called "float128_fma" takes a_ptr as Integer, b_ptr as Integer, c_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Production FMA: result = (a * b) + c with TRUE SINGLE ROUNDING
    Note: This computes the product at FULL 224-bit precision, adds c, then rounds ONCE
    Note: Provides maximum accuracy - critical for numerical stability
    Note: Used in: dot products, matrix operations, polynomial evaluation, iterative solvers

    Note: Algorithm:
    Note: 1. Multiply a × b keeping full 224-bit precision (NO rounding)
    Note: 2. Align c's mantissa to product's exponent
    Note: 3. Add/subtract c to full-precision product
    Note: 4. Normalize and round ONCE at the very end

    Note: This matches hardware FMA behavior (Intel/AMD FMA3, ARM, etc.)

    Note: Step 1: Unpack all three operands
    Let sign_a_ptr be scratch_ptr
    Let exp_a_ptr be scratch_ptr plus 8
    Let mant_a_high_ptr be scratch_ptr plus 16
    Let mant_a_low_ptr be scratch_ptr plus 24
    float128_unpack(a_ptr, sign_a_ptr, exp_a_ptr, mant_a_high_ptr, mant_a_low_ptr)
    Let sign_a be memory_get_int64(sign_a_ptr, 0)
    Let exp_a be memory_get_int64(exp_a_ptr, 0)
    Let mant_a_high be memory_get_int64(mant_a_high_ptr, 0)
    Let mant_a_low be memory_get_int64(mant_a_low_ptr, 0)




    Let sign_b_ptr be scratch_ptr plus 32
    Let exp_b_ptr be scratch_ptr plus 40
    Let mant_b_high_ptr be scratch_ptr plus 48
    Let mant_b_low_ptr be scratch_ptr plus 56
    float128_unpack(b_ptr, sign_b_ptr, exp_b_ptr, mant_b_high_ptr, mant_b_low_ptr)
    Let sign_b be memory_get_int64(sign_b_ptr, 0)
    Let exp_b be memory_get_int64(exp_b_ptr, 0)
    Let mant_b_high be memory_get_int64(mant_b_high_ptr, 0)
    Let mant_b_low be memory_get_int64(mant_b_low_ptr, 0)




    Let sign_c_ptr be scratch_ptr plus 64
    Let exp_c_ptr be scratch_ptr plus 72
    Let mant_c_high_ptr be scratch_ptr plus 80
    Let mant_c_low_ptr be scratch_ptr plus 88
    float128_unpack(c_ptr, sign_c_ptr, exp_c_ptr, mant_c_high_ptr, mant_c_low_ptr)
    Let sign_c be memory_get_int64(sign_c_ptr, 0)
    Let exp_c be memory_get_int64(exp_c_ptr, 0)
    Let mant_c_high be memory_get_int64(mant_c_high_ptr, 0)
    Let mant_c_low be memory_get_int64(mant_c_low_ptr, 0)




    Note: Step 2: Handle special cases (NaN, Infinity, Zero)
    Note: Check for NaN (exponent = 0x7FFF and mantissa != 0)
    If exp_a is equal to 32767:
        If bitwise_or(mant_a_high, mant_a_low) is not equal to 0:
            Note: a is NaN, propagate NaN
            float128_pack(sign_a, 32767, mant_a_high, mant_a_low, result_ptr)
            Return
        End If
    End If
    If exp_b is equal to 32767:
        If bitwise_or(mant_b_high, mant_b_low) is not equal to 0:
            Note: b is NaN, propagate NaN
            float128_pack(sign_b, 32767, mant_b_high, mant_b_low, result_ptr)
            Return
        End If
    End If
    If exp_c is equal to 32767:
        If bitwise_or(mant_c_high, mant_c_low) is not equal to 0:
            Note: c is NaN, propagate NaN
            float128_pack(sign_c, 32767, mant_c_high, mant_c_low, result_ptr)
            Return
        End If
    End If

    Note: Check for zero operands
    Let a_is_zero be 0
    If exp_a is equal to 0:
        If bitwise_or(mant_a_high, mant_a_low) is equal to 0:
            Set a_is_zero to 1
        End If
    End If

    Let b_is_zero be 0
    If exp_b is equal to 0:
        If bitwise_or(mant_b_high, mant_b_low) is equal to 0:
            Set b_is_zero to 1
        End If
    End If

    Let c_is_zero be 0
    If exp_c is equal to 0:
        If bitwise_or(mant_c_high, mant_c_low) is equal to 0:
            Set c_is_zero to 1
        End If
    End If

    Note: If a or b is zero, result is just c
    If a_is_zero is equal to 1:
        float128_pack(sign_c, exp_c, mant_c_high, mant_c_low, result_ptr)
        Return
    End If
    If b_is_zero is equal to 1:
        float128_pack(sign_c, exp_c, mant_c_high, mant_c_low, result_ptr)
        Return
    End If

    Note: If c is zero, result is just a * b
    If c_is_zero is equal to 1:
        Let temp_product be scratch_ptr plus 96
        float128_multiply(a_ptr, b_ptr, temp_product)

        Note: Copy result
        Let offset be 0
        While offset is less than 16:
            Let byte_val be memory_get_int8(temp_product, offset)
            memory_set_int8(result_ptr, offset, byte_val)
            Set offset to offset plus 1
        End While

        Return
    End If

    Note: Step 3: Compute product sign and exponent
    Let sign_product be bitwise_xor(sign_a, sign_b)
    Let exp_product be exp_a plus exp_b minus 16383

    Note: Restore implicit leading 1 for normalized numbers
    If exp_a is not equal to 0:
        Set mant_a_high to bitwise_or(mant_a_high, 281474976710656)
    End If
    If exp_b is not equal to 0:
        Set mant_b_high to bitwise_or(mant_b_high, 281474976710656)
    End If
    If exp_c is not equal to 0:
        Set mant_c_high to bitwise_or(mant_c_high, 281474976710656)
    End If

    Note: Step 4: Multiply mantissas - FULL 224-bit precision (NO ROUNDING!)
    Let prod_high_ptr be scratch_ptr plus 112
    Let prod_mid_ptr be scratch_ptr plus 120
    Let prod_low_ptr be scratch_ptr plus 128
    mul_112x112_karatsuba(mant_a_high, mant_a_low, mant_b_high, mant_b_low, prod_high_ptr, prod_mid_ptr, prod_low_ptr)
    Let prod_high be memory_get_int64(prod_high_ptr, 0)
    Let prod_mid be memory_get_int64(prod_mid_ptr, 0)
    Let prod_low be memory_get_int64(prod_low_ptr, 0)



    Note: Normalize product: if MSB of prod_high is not set, shift left
    Note: Product of two 113-bit numbers (with implicit 1) is 226 bits
    Note: MSB should be in bit 113 or 114 of the 224-bit result
    Let prod_msb be right_shift(prod_high, 49)
    If bitwise_and(prod_msb, 2) is equal to 0:
        Note: Need to shift left by 1 bit
        Let carry1 be right_shift(prod_mid, 63)
        Let carry2 be right_shift(prod_low, 63)
        Set prod_low to left_shift(prod_low, 1)
        Set prod_mid to left_shift(prod_mid, 1)
        Set prod_mid to bitwise_or(prod_mid, carry2)
        Set prod_high to left_shift(prod_high, 1)
        Set prod_high to bitwise_or(prod_high, carry1)
    End If
    Otherwise:
        Note: MSB is set, adjust exponent
        Set exp_product to exp_product plus 1
    End If

    Note: Step 5: Align c's mantissa to product's exponent
    Note: exp_diff = exp_product - exp_c (how much to shift c)
    Let exp_diff be exp_product minus exp_c

    Note: We need to add c to the 224-bit product
    Note: c's mantissa needs to be positioned correctly
    Note: Product format: [prod_high:64][prod_mid:64][prod_low:64] with MSB at bit 113
    Note: c format: [mant_c_high:48][mant_c_low:64] = 112 bits

    Note: Extend c to 224-bit representation aligned to product
    Let c_224_high be 0
    Let c_224_mid be 0
    Let c_224_low be 0

    Note: If exp_diff >= 0, c is smaller - shift c right
    Note: If exp_diff < 0, c is larger - need to shift product right (complex)
    If exp_diff is greater than or equal to 0:
        Note: c needs to be shifted right by exp_diff bits
        Note: If shift is too large (>224), c becomes negligible
        If exp_diff is greater than or equal to 224:
            Note: c is too small to affect result, return product
            Let result_mant_high be right_shift(prod_high, 1)
            Let result_mant_low be prod_mid
            Set result_mant_low to left_shift(result_mant_low, 63)
            Set result_mant_low to bitwise_or(result_mant_low, right_shift(prod_low, 1))

            Note: Clear implicit 1
            Set result_mant_high to bitwise_and(result_mant_high, 281474976710655)

            float128_pack(sign_product, exp_product, result_mant_high, result_mant_low, result_ptr)
            Return
        End If

        Note: Position c in 224-bit space by shifting right exp_diff bits
        Note: c occupies upper 112 bits initially: [c_high:48][c_low:64]
        Note: We need to place it properly in the 224-bit space

        Note: Start with c in the upper portion (bits 223-112)
        Set c_224_high to mant_c_high
        Set c_224_mid to mant_c_low
        Set c_224_low to 0

        Note: Now shift right by exp_diff bits
        If exp_diff is greater than 0:
            If exp_diff is less than 64:
                Note: Shift within word boundaries
                Let shift_out_low be left_shift(c_224_mid, 64 minus exp_diff)
                Set c_224_low to right_shift(c_224_mid, exp_diff)
                Let shift_out_mid be left_shift(c_224_high, 64 minus exp_diff)
                Set c_224_mid to right_shift(c_224_high, exp_diff)
                Set c_224_mid to bitwise_or(c_224_mid, shift_out_low)
                Set c_224_high to right_shift(c_224_high, exp_diff)
            End If
            If exp_diff is greater than or equal to 64:
                If exp_diff is less than 128:
                    Let shift_amount be exp_diff minus 64
                    Set c_224_low to right_shift(c_224_high, shift_amount)
                    If shift_amount is greater than 0:
                        Let shift_out be left_shift(c_224_mid, 64 minus shift_amount)
                        Set c_224_low to bitwise_or(c_224_low, shift_out)
                    End If
                    Set c_224_mid to right_shift(c_224_mid, shift_amount)
                    Set c_224_high to 0
                End If
                If exp_diff is greater than or equal to 128:
                    Let shift_amount be exp_diff minus 128
                    Set c_224_low to right_shift(c_224_mid, shift_amount)
                    Set c_224_mid to 0
                    Set c_224_high to 0
                End If
            End If
        End If
    End If
    Otherwise:
        Note: CASE 2: c > Product (exp_c > exp_product)
        Note: This is CRITICAL for iterative algorithms, compensated summation, etc.
        Note: Must maintain TRUE single-rounding FMA semantics even in this case

        Note: Strategy: Shift product right instead of c, add to c, round once
        Note: Result exponent will be exp_c (c dominates)

        Let shift_amount be 0 minus exp_diff  Note: Make positive (exp_c - exp_product)

        Note: If shift is too large (>224), product becomes negligible
        If shift_amount is greater than or equal to 224:
            Note: Product is too small to affect result, return c
            Let result_mant_high be mant_c_high
            Let result_mant_low be mant_c_low
            Note: Clear implicit 1
            Set result_mant_high to bitwise_and(result_mant_high, 281474976710655)
            float128_pack(sign_c, exp_c, result_mant_high, result_mant_low, result_ptr)
            Return
        End If

        Note: Shift 224-bit product right by shift_amount
        Note: Product: [prod_high:64][prod_mid:64][prod_low:64]
        Note: After shift: still 224 bits but aligned to c's exponent

        Note: Initialize shifted product
        Let prod_shifted_high be prod_high
        Let prod_shifted_mid be prod_mid
        Let prod_shifted_low be prod_low

        Note: Perform the right shift on 224-bit product
        If shift_amount is greater than 0:
            If shift_amount is less than 64:
                Note: Shift within word boundaries
                Let shift_out_mid be left_shift(prod_shifted_mid, 64 minus shift_amount)
                Let shift_out_low be left_shift(prod_shifted_low, 64 minus shift_amount)
                Set prod_shifted_low to right_shift(prod_shifted_low, shift_amount)
                Set prod_shifted_mid to right_shift(prod_shifted_mid, shift_amount)
                Set prod_shifted_mid to bitwise_or(prod_shifted_mid, shift_out_low)
                Set prod_shifted_high to right_shift(prod_shifted_high, shift_amount)
                Set prod_shifted_high to bitwise_or(prod_shifted_high, shift_out_mid)
            End If
            If shift_amount is greater than or equal to 64:
                If shift_amount is less than 128:
                    Let local_shift be shift_amount minus 64
                    Set prod_shifted_low to right_shift(prod_shifted_mid, local_shift)
                    If local_shift is greater than 0:
                        Let shift_out be left_shift(prod_shifted_high, 64 minus local_shift)
                        Set prod_shifted_low to bitwise_or(prod_shifted_low, shift_out)
                    End If
                    Set prod_shifted_mid to right_shift(prod_shifted_high, local_shift)
                    Set prod_shifted_high to 0
                End If
                If shift_amount is greater than or equal to 128:
                    Let local_shift be shift_amount minus 128
                    Set prod_shifted_low to right_shift(prod_shifted_high, local_shift)
                    Set prod_shifted_mid to 0
                    Set prod_shifted_high to 0
                End If
            End If
        End If

        Note: Now position c in 224-bit space (c dominates, so it's in upper portion)
        Set c_224_high to mant_c_high
        Set c_224_mid to mant_c_low
        Set c_224_low to 0

        Note: Swap the operands: product becomes the shifted version
        Note: c is already positioned at the top of 224-bit space
        Note: We'll proceed to addition with product = shifted_product, exp = exp_c
        Set prod_high to prod_shifted_high
        Set prod_mid to prod_shifted_mid
        Set prod_low to prod_shifted_low
        Set exp_product to exp_c

        Note: Continue to addition step with properly aligned operands
    End If

    Note: Step 6: Add or subtract c to/from product (based on signs)
    Let result_sign be sign_product
    Let result_high be prod_high
    Let result_mid be prod_mid
    Let result_low be prod_low

    If sign_product is equal to sign_c:
        Note: Same sign: add c to product
        Let sum_low be result_low plus c_224_low
        Let carry1 be 0
        If sum_low is less than result_low:
            Set carry1 to 1
        End If
        Set result_low to sum_low

        Let sum_mid be result_mid plus c_224_mid plus carry1
        Let carry2 be 0
        If sum_mid is less than result_mid:
            Set carry2 to 1
        End If
        If sum_mid is less than carry1:
            Set carry2 to 1
        End If
        Set result_mid to sum_mid

        Set result_high to result_high plus c_224_high plus carry2
    End If
    Otherwise:
        Note: Different signs: subtract c from product
        Note: Compare magnitudes first
        Let prod_larger be 1
        If prod_high is less than c_224_high:
            Set prod_larger to 0
        End If
        If prod_high is equal to c_224_high:
            If prod_mid is less than c_224_mid:
                Set prod_larger to 0
            End If
            If prod_mid is equal to c_224_mid:
                If prod_low is less than c_224_low:
                    Set prod_larger to 0
                End If
            End If
        End If

        If prod_larger is equal to 1:
            Note: Product > c: result = product - c, keep product sign
            Let diff_low be result_low minus c_224_low
            Let borrow1 be 0
            If diff_low is greater than result_low:
                Set borrow1 to 1
            End If
            Set result_low to diff_low

            Let diff_mid be result_mid minus c_224_mid minus borrow1
            Let borrow2 be 0
            If diff_mid is greater than result_mid:
                Set borrow2 to 1
            End If
            Set result_mid to diff_mid

            Set result_high to result_high minus c_224_high minus borrow2
        End If
        Otherwise:
            Note: c > product: result = c - product, use c sign
            Set result_sign to sign_c

            Let diff_low be c_224_low minus result_low
            Let borrow1 be 0
            If diff_low is greater than c_224_low:
                Set borrow1 to 1
            End If
            Set result_low to diff_low

            Let diff_mid be c_224_mid minus result_mid minus borrow1
            Let borrow2 be 0
            If diff_mid is greater than c_224_mid:
                Set borrow2 to 1
            End If
            Set result_mid to diff_mid

            Set result_high to c_224_high minus result_high minus borrow2
        End If
    End If

    Note: Step 7: Normalize result
    Note: Find leading 1 bit in 224-bit result
    Let shift_count be 0
    Let found_bit be 0

    Note: Check result_high for leading bit
    If result_high is not equal to 0:
        Let temp be result_high
        While found_bit is equal to 0:
            If bitwise_and(temp, 9223372036854775808) is not equal to 0:
                Set found_bit to 1
            End If
            Otherwise:
                Set shift_count to shift_count plus 1
                Set temp to left_shift(temp, 1)
                If shift_count is greater than or equal to 64:
                    Set found_bit to 1
                End If
            End If
        End While
    End If

    Note: If no bit found in result_high, check result_mid
    If found_bit is equal to 0:
        If result_mid is not equal to 0:
            Set shift_count to 64
            Let temp be result_mid
            While found_bit is equal to 0:
                If bitwise_and(temp, 9223372036854775808) is not equal to 0:
                    Set found_bit to 1
                End If
                Otherwise:
                    Set shift_count to shift_count plus 1
                    Set temp to left_shift(temp, 1)
                    If shift_count is greater than or equal to 128:
                        Set found_bit to 1
                    End If
                End If
            End While
        End If
    End If

    Note: If still no bit, check result_low
    If found_bit is equal to 0:
        If result_low is not equal to 0:
            Set shift_count to 128
            Let temp be result_low
            While found_bit is equal to 0:
                If bitwise_and(temp, 9223372036854775808) is not equal to 0:
                    Set found_bit to 1
                End If
                Otherwise:
                    Set shift_count to shift_count plus 1
                    Set temp to left_shift(temp, 1)
                    If shift_count is greater than or equal to 192:
                        Set found_bit to 1
                    End If
                End If
            End While
        End If
    End If

    Note: If result is zero, return zero
    If found_bit is equal to 0:
        float128_pack(result_sign, 0, 0, 0, result_ptr)
        Return
    End If

    Note: Step 7.5: Perform the 224-bit left shift to normalize
    Note: This is CRITICAL for correctness when cancellation occurs
    Note: We calculated shift_count - now we must shift the result left

    Note: Without this shift, the mantissa bits are wrong after cancellation
    Note: Example: FMA(1.0, 1.0, -1.0+ε) = ε requires massive shift

    If shift_count is greater than 0:
        If shift_count is less than 64:
            Note: Shift within word boundaries (common case)
            Let carry_from_mid be right_shift(result_mid, 64 minus shift_count)
            Let carry_from_low be right_shift(result_low, 64 minus shift_count)
            Set result_high to left_shift(result_high, shift_count)
            Set result_high to bitwise_or(result_high, carry_from_mid)
            Set result_mid to left_shift(result_mid, shift_count)
            Set result_mid to bitwise_or(result_mid, carry_from_low)
            Set result_low to left_shift(result_low, shift_count)
        End If

        If shift_count is greater than or equal to 64:
            If shift_count is less than 128:
                Note: Shift crosses from mid to high word
                Let local_shift be shift_count minus 64
                Set result_high to left_shift(result_mid, local_shift)
                If local_shift is less than 64:
                    Let carry be right_shift(result_low, 64 minus local_shift)
                    Set result_high to bitwise_or(result_high, carry)
                End If
                Set result_mid to left_shift(result_low, local_shift)
                Set result_low to 0
            End If

            If shift_count is greater than or equal to 128:
                Note: Large shift - low word becomes high word
                Let local_shift be shift_count minus 128
                Set result_high to left_shift(result_low, local_shift)
                Set result_mid to 0
                Set result_low to 0
            End If
        End If
    End If

    Note: Adjust exponent by shift amount
    Let result_exp be exp_product minus shift_count

    Note: Now extract upper 112 bits from NORMALIZED result
    Note: After normalization, MSB is at bit 223 (or close to it)
    Note: We need bits [223:112] for the final 112-bit mantissa
    Let final_mant_high be right_shift(result_high, 1)
    Let final_mant_low be left_shift(result_mid, 63)
    Set final_mant_low to bitwise_or(final_mant_low, right_shift(result_low, 1))

    Note: Clear implicit 1 bit (bit 48 of high word)
    Set final_mant_high to bitwise_and(final_mant_high, 281474976710655)

    Note: Step 8: Round ONCE with proper IEEE 754 round-to-nearest-ties-to-even
    Note: This is the ONLY rounding operation in the entire FMA
    Note: Must extract guard (G), round (R), and sticky (S) bits from 224-bit result
    
    Note: IEEE 754 rounding requires THREE bits beyond the mantissa:
    Note: - Guard bit (G): first bit after mantissa
    Note: - Round bit (R): second bit after mantissa
    Note: - Sticky bit (S): OR of all remaining bits
    
    Note: Rounding rules for round-to-nearest-ties-to-even:
    Note: - If G=0: truncate (round down)
    Note: - If G=1 and (R=1 or S=1): round up (above midpoint)
    Note: - If G=1 and R=0 and S=0: exact tie → round to even (check LSB)

    Note: Bit layout in normalized 224-bit result:
    Note: result_high[63:0]  = bits [223:160] (64 bits)
    Note: result_mid[63:0]   = bits [159:96]  (64 bits)
    Note: result_low[63:0]   = bits [95:32]   (64 bits)
    
    Note: For 112-bit mantissa extraction from 224 bits:
    Note: We extract bits [223:112] for mantissa (done above)
    Note: Guard bit  = bit 111 of 224-bit result
    Note: Round bit  = bit 110 of 224-bit result
    Note: Sticky bit = OR of bits [109:0] of 224-bit result

    Note: Map bit positions to words:
    Note: Bit 111: This is bit 47 of result_mid (159 - 111 = 48, but 0-indexed = 47)
    Note: Bit 110: This is bit 46 of result_mid
    Note: Bits [109:96]: These are bits [45:32] of result_mid
    Note: Bits [95:32]: These are bits [63:0] of result_low
    Note: Wait, need to recalculate based on extraction

    Note: Actually, we need to think about this more carefully
    Note: After normalization, result is 224 bits: [result_high:64][result_mid:64][result_low:64]
    Note: But result_high is only 64 bits with MSB at position 63 (the leading 1)
    Note: Total: bit 223 is at result_high[63], bit 160 is at result_high[0]
    Note:        bit 159 is at result_mid[63], bit 96 is at result_mid[0]
    Note:        bit 95 is at result_low[63], bit 32 is at result_low[0]
    
    Note: We extract final mantissa as: right_shift(result_high, 1) + left_shift(result_mid, 63)...
    Note: This gives us bits [223:112]
    
    Note: Remaining bits for rounding: [111:0]
    Note: Bit 111 is at result_mid bit 47 (159 - 112 = 47)
    Note: Bit 110 is at result_mid bit 46
    Note: Bits [109:96] are at result_mid bits [45:32]
    Note: Bits [95:0] are split: [95:32] in result_low[63:0] (but we need all of it)

    Note: Extract Guard bit (bit 111 = bit 47 of result_mid after normalization)
    Let guard_bit be bitwise_and(right_shift(result_mid, 47), 1)

    Note: Extract Round bit (bit 110 = bit 46 of result_mid)
    Let round_bit be bitwise_and(right_shift(result_mid, 46), 1)

    Note: Extract Sticky bit (OR of all bits below bit 110)
    Note: This includes: result_mid bits [45:0] and ALL of result_low bits [63:0]
    Let sticky_bit be 0

    Note: Check if any bit in result_low is set
    If result_low is not equal to 0:
        Set sticky_bit to 1
    End If

    Note: Check if any bit in lower 46 bits of result_mid is set
    If sticky_bit is equal to 0:
        Let mid_lower_bits be bitwise_and(result_mid, 70368744177663)
        If mid_lower_bits is not equal to 0:
            Set sticky_bit to 1
        End If
    End If

    Note: ========================================================================
    Note: IEEE 754 Round-to-Nearest-Ties-to-Even Logic
    Note: ========================================================================
    Note: Round up if:
    Note:   1. G=1 and R=1 (above midpoint, regardless of S)
    Note:   2. G=1 and R=0 and S=1 (just above midpoint)
    Note:   3. G=1 and R=0 and S=0 and LSB=1 (exact tie, round to even)
    Note: Otherwise: truncate (round down)

    Let should_round_up be 0

    If guard_bit is equal to 1:
        Note: Guard bit is set - check if we round up or down
        If round_bit is equal to 1:
            Note: Case 1: Above midpoint (G=1, R=1)
            Set should_round_up to 1
        End If
        Otherwise:
            Note: Round bit is 0, check sticky bit
            If sticky_bit is equal to 1:
                Note: Case 2: Just above midpoint (G=1, R=0, S=1)
                Set should_round_up to 1
            End If
            Otherwise:
                Note: Case 3: Exact tie (G=1, R=0, S=0) - round to even
                Note: Check LSB of mantissa to determine even/odd
                Let lsb be bitwise_and(final_mant_low, 1)
                If lsb is equal to 1:
                    Note: Mantissa is odd, round up to make it even
                    Set should_round_up to 1
                End If
                Note: If LSB=0 (even), round down (should_round_up stays 0)
            End If
        End If
    End If
    Note: If guard_bit=0, should_round_up stays 0 (truncate)

    Note: Apply rounding if needed
    If should_round_up is equal to 1:
        Set final_mant_low to final_mant_low plus 1
        If final_mant_low is equal to 0:
            Note: Overflow from low to high word
            Set final_mant_high to final_mant_high plus 1
            If final_mant_high is greater than 281474976710655:
                Note: Mantissa overflow - increment exponent and reset mantissa
                Set result_exp to result_exp plus 1
                Set final_mant_high to 0
            End If
        End If
    End If

    Note: Pack and return final result
    float128_pack(result_sign, result_exp, final_mant_high, final_mant_low, result_ptr)
End Process

Note: ============================================================================
Note: Float128 Transcendental Functions (sin, cos, tan, exp, log)
Note: ============================================================================

Note: Constants for transcendental functions
Let FLOAT128_PI_HIGH be 4610753305392537089
Let FLOAT128_PI_LOW be 3373259426697323672

Let FLOAT128_E_HIGH be 4611194216022327296
Let FLOAT128_E_LOW be 9231757091414912319

Let FLOAT128_LN2_HIGH be 4609176115597762560
Let FLOAT128_LN2_LOW be 17106551752605819305

Process called "float128_get_pi" takes result_ptr as Integer:
    Note: Return Float128 value of π (3.14159265358979323846...)
    memory_set_int64(result_ptr, 0, FLOAT128_PI_HIGH)
    memory_set_int64(result_ptr, 8, FLOAT128_PI_LOW)
End Process

Process called "float128_get_e" takes result_ptr as Integer:
    Note: Return Float128 value of e (2.71828182845904523536...)
    memory_set_int64(result_ptr, 0, FLOAT128_E_HIGH)
    memory_set_int64(result_ptr, 8, FLOAT128_E_LOW)
End Process

Process called "float128_get_ln2" takes result_ptr as Integer:
    Note: Return Float128 value of ln(2) (0.693147180559945309417...)
    memory_set_int64(result_ptr, 0, FLOAT128_LN2_HIGH)
    memory_set_int64(result_ptr, 8, FLOAT128_LN2_LOW)
End Process

Process called "float128_sin" takes x_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 688 bytes
    Note: Compute sin(x) using Taylor series expansion
    Note: sin(x) = x - x^3/3! + x^5/5! - x^7/7! + ...
    Note: Uses range reduction: reduce x to [-π, π] first

    Let nan_scratch be scratch_ptr
    Let pi_ptr be scratch_ptr plus 32
    Let two_pi_ptr be scratch_ptr plus 48
    Let two_ptr be scratch_ptr plus 64
    Let x_div_2pi_ptr be scratch_ptr plus 80
    Let k_ptr be scratch_ptr plus 96
    Let k_float_ptr be scratch_ptr plus 104
    Let k_times_2pi_ptr be scratch_ptr plus 120
    Let x_reduced_ptr be scratch_ptr plus 136
    Let sum_ptr be scratch_ptr plus 152
    Let term_ptr be scratch_ptr plus 168
    Let x_squared_ptr be scratch_ptr plus 184
    Let neg_x_squared_ptr be scratch_ptr plus 200
    Let temp_ptr be scratch_ptr plus 216
    Let denom_ptr be scratch_ptr plus 232
    Let new_sum_ptr be scratch_ptr plus 248
    Let abs_term_ptr be scratch_ptr plus 264
    Let epsilon_ptr be scratch_ptr plus 280
    Let op_scratch be scratch_ptr plus 296

    Note: Check for special values
    If float128_is_nan(x_ptr, nan_scratch) is equal to 1:
        float128_raise_exception(FLOAT128_FLAG_INVALID)
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    If float128_is_infinity(x_ptr, nan_scratch) is equal to 1:
        float128_raise_exception(FLOAT128_FLAG_INVALID)
        float128_nan(result_ptr)
        Return
    End If

    If float128_is_zero(x_ptr) is equal to 1:
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    Note: Range reduction: reduce x to [-π, π]
    float128_get_pi(pi_ptr)
    float128_from_int64(2, two_ptr)
    float128_multiply(pi_ptr, two_ptr, two_pi_ptr, op_scratch)

    Note: Compute k = round(x / (2π))
    float128_divide(x_ptr, two_pi_ptr, x_div_2pi_ptr, op_scratch)
    float128_to_int64(x_div_2pi_ptr, k_ptr)
    Let k be memory_get_int64(k_ptr, 0)

    Note: Compute reduced x = x - k * 2π
    float128_from_int64(k, k_float_ptr)
    float128_multiply(k_float_ptr, two_pi_ptr, k_times_2pi_ptr, op_scratch)
    float128_subtract(x_ptr, k_times_2pi_ptr, x_reduced_ptr, op_scratch)

    Note: Taylor series: sin(x) = x - x^3/3! + x^5/5! - x^7/7! + ...
    memory_copy(sum_ptr, x_reduced_ptr, 16)
    memory_copy(term_ptr, x_reduced_ptr, 16)
    float128_multiply(x_reduced_ptr, x_reduced_ptr, x_squared_ptr, op_scratch)

    Let n be 1
    Let max_iterations be 50
    Let iteration be 0

    While iteration is less than max_iterations:
        Note: Compute next term: term *= -x^2 / ((2n)(2n+1))
        float128_negate(x_squared_ptr, neg_x_squared_ptr)
        float128_multiply(term_ptr, neg_x_squared_ptr, temp_ptr, op_scratch)

        Let denominator be (2 multiplied by n) multiplied by ((2 multiplied by n) plus 1)
        float128_from_int64(denominator, denom_ptr)
        float128_divide(temp_ptr, denom_ptr, term_ptr, op_scratch)

        Note: Add term to sum
        float128_add(sum_ptr, term_ptr, new_sum_ptr, op_scratch)

        Note: Check for convergence
        float128_abs(term_ptr, abs_term_ptr)
        float128_from_string("1e-34", epsilon_ptr)
        Let converged be float128_less_than(abs_term_ptr, epsilon_ptr, op_scratch)

        memory_copy(sum_ptr, new_sum_ptr, 16)

        If converged is equal to 1:
            break
        End If

        Set n to n plus 1
        Set iteration to iteration plus 1
    End While

    memory_copy(result_ptr, sum_ptr, 16)
End Process

Process called "float128_cos" takes x_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 336 bytes
    Note: Compute cos(x) using Taylor series expansion
    Note: cos(x) = 1 - x^2/2! + x^4/4! - x^6/6! + ...
    Note: Uses range reduction and identity: cos(x) = sin(x + π/2)

    Let pi_ptr be scratch_ptr
    Let two_ptr be scratch_ptr plus 16
    Let pi_div_2_ptr be scratch_ptr plus 32
    Let x_plus_pi_2_ptr be scratch_ptr plus 48
    Let op_scratch be scratch_ptr plus 64

    Note: Compute x + π/2
    float128_get_pi(pi_ptr)
    float128_from_int64(2, two_ptr)
    float128_divide(pi_ptr, two_ptr, pi_div_2_ptr, op_scratch)
    float128_add(x_ptr, pi_div_2_ptr, x_plus_pi_2_ptr, op_scratch)

    Note: cos(x) = sin(x + π/2)
    float128_sin(x_plus_pi_2_ptr, result_ptr, op_scratch)
End Process

Process called "float128_tan" takes x_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 672 bytes
    Note: Compute tan(x) = sin(x) / cos(x)

    Let nan_scratch be scratch_ptr
    Let sin_ptr be scratch_ptr plus 32
    Let cos_ptr be scratch_ptr plus 48
    Let sin_scratch be scratch_ptr plus 64
    Let cos_scratch be scratch_ptr plus 400
    Let div_scratch be scratch_ptr plus 528

    Note: Check for special values
    If float128_is_nan(x_ptr, nan_scratch) is equal to 1:
        float128_raise_exception(FLOAT128_FLAG_INVALID)
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    If float128_is_infinity(x_ptr, nan_scratch) is equal to 1:
        float128_raise_exception(FLOAT128_FLAG_INVALID)
        float128_nan(result_ptr)
        Return
    End If

    float128_sin(x_ptr, sin_ptr, sin_scratch)
    float128_cos(x_ptr, cos_ptr, cos_scratch)

    Note: Check if cos(x) is zero (tan undefined)
    If float128_is_zero(cos_ptr) is equal to 1:
        float128_raise_exception(FLOAT128_FLAG_INVALID)
        float128_raise_exception(FLOAT128_FLAG_DIVIDE_BY_ZERO)
        float128_inf(result_ptr)
        Return
    End If

    float128_divide(sin_ptr, cos_ptr, result_ptr, div_scratch)
End Process

Process called "float128_exp" takes x_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Compute e^x using Taylor series expansion
    Note: exp(x) = 1 + x + x^2/2! + x^3/3! + x^4/4! + ...
    Note: Uses range reduction: exp(x) = exp(k*ln2 + r) = 2^k * exp(r)

    Note: Check for special values
    If float128_is_nan(x_ptr) is equal to 1:
        float128_raise_exception(FLOAT128_FLAG_INVALID)
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    Note: Check for x = +inf
    Let x_is_inf be float128_is_inf(x_ptr)
    If x_is_inf is equal to 1:
        Let x_high be memory_get_int64(x_ptr, 0)
        Let x_sign be right_shift(x_high, 63)
        If x_sign is equal to 0:
            Note: exp(+inf) = +inf
            float128_inf(result_ptr)
        Otherwise:
            Note: exp(-inf) = 0
            float128_zero(result_ptr)
        End If
        Return
    End If

    If float128_is_zero(x_ptr) is equal to 1:
        Note: exp(0) = 1
        float128_from_int64(1, result_ptr)
        Return
    End If

    Note: Range reduction: x = k*ln(2) + r, where |r| < ln(2)/2
    Let ln2_ptr be scratch_ptr
    float128_get_ln2(ln2_ptr)

    Let x_div_ln2_ptr be scratch_ptr plus 16
    float128_divide(x_ptr, ln2_ptr, x_div_ln2_ptr)

    Let k_ptr be scratch_ptr plus 32
    float128_to_int64(x_div_ln2_ptr, k_ptr)
    Let k be memory_get_int64(k_ptr, 0)

    Note: Compute r = x - k*ln(2)
    Let k_float_ptr be scratch_ptr plus 40
    float128_from_int64(k, k_float_ptr)

    Let k_times_ln2_ptr be scratch_ptr plus 56
    float128_multiply(k_float_ptr, ln2_ptr, k_times_ln2_ptr)

    Let r_ptr be scratch_ptr plus 72
    float128_subtract(x_ptr, k_times_ln2_ptr, r_ptr)

    Note: Taylor series for exp(r)
    Let sum_ptr be scratch_ptr plus 88
    float128_from_int64(1, sum_ptr)

    Let term_ptr be scratch_ptr plus 104
    float128_from_int64(1, term_ptr)

    Let n be 1
    Let max_iterations be 100
    Let iteration be 0

    While iteration is less than max_iterations:
        Note: term *= r / n
        Let temp_ptr be scratch_ptr plus 120
        float128_multiply(term_ptr, r_ptr, temp_ptr)

        Let n_ptr be scratch_ptr plus 136
        float128_from_int64(n, n_ptr)

        float128_divide(temp_ptr, n_ptr, term_ptr)

        Note: sum += term
        Let new_sum_ptr be scratch_ptr plus 152
        float128_add(sum_ptr, term_ptr, new_sum_ptr)

        Note: Check convergence
        Let abs_term_ptr be scratch_ptr plus 168
        float128_abs(term_ptr, abs_term_ptr)

        Let epsilon_ptr be scratch_ptr plus 184
        float128_from_string("1e-34", epsilon_ptr)

        Let converged be float128_less_than(abs_term_ptr, epsilon_ptr)




        memory_copy(sum_ptr, new_sum_ptr, 16)

        If converged is equal to 1:
            break
        End If

        Set n to n plus 1
        Set iteration to iteration plus 1
    End While

    Note: Multiply by 2^k
    float128_multiply_power_of_2(sum_ptr, k, result_ptr)








End Process

Process called "float128_log" takes x_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Compute ln(x) using Taylor series and Newton-Raphson
    Note: Uses identity: ln(x) = ln(2^k * m) = k*ln(2) + ln(m)
    Note: where m is in [1, 2) (the normalized mantissa)

    Note: Check for special values
    If float128_is_nan(x_ptr) is equal to 1:
        float128_raise_exception(FLOAT128_FLAG_INVALID)
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    Note: Check if x is negative
    Let x_high be memory_get_int64(x_ptr, 0)
    Let x_sign be right_shift(x_high, 63)
    If x_sign is equal to 1:
        Note: ln(negative) = NaN
        float128_raise_exception(FLOAT128_FLAG_INVALID)
        float128_nan(result_ptr)
        Return
    End If

    If float128_is_zero(x_ptr) is equal to 1:
        Note: ln(0) = -inf
        float128_raise_exception(FLOAT128_FLAG_DIVIDE_BY_ZERO)
        float128_inf(result_ptr)
        Let result_high be memory_get_int64(result_ptr, 0)
        Set result_high to bitwise_or(result_high, 9223372036854775808)
        memory_set_int64(result_ptr, 0, result_high)
        Return
    End If

    Let x_is_inf be float128_is_inf(x_ptr)
    If x_is_inf is equal to 1:
        Note: ln(+inf) = +inf
        float128_inf(result_ptr)
        Return
    End If

    Note: Check for x = 1 (ln(1) = 0)
    Let one_ptr be scratch_ptr
    float128_from_int64(1, one_ptr)
    Let x_is_one be float128_equal(x_ptr, one_ptr)
    If x_is_one is equal to 1:
        float128_zero(result_ptr)

        Return
    End If

    Note: Extract mantissa and exponent using frexp
    Note: x = m * 2^exp, where m in [0.5, 1)
    Let exp_ptr be scratch_ptr plus 16
    Let m_ptr be scratch_ptr plus 24
    float128_frexp(x_ptr, exp_ptr, m_ptr)
    Let exp be memory_get_int64(exp_ptr, 0)

    Note: Transform m to [1, 2) range: m' = 2*m, exp' = exp-1
    Let two_ptr be scratch_ptr plus 40
    float128_from_int64(2, two_ptr)
    Let m_scaled_ptr be scratch_ptr plus 56
    float128_multiply(m_ptr, two_ptr, m_scaled_ptr)
    Set exp to exp minus 1

    Note: Compute ln(m') using Taylor series: ln(m') = ln(1 + (m'-1))
    Note: Let y = m' - 1, so |y| < 1
    Note: ln(1 + y) = y - y^2/2 + y^3/3 - y^4/4 + ...

    Let one_ptr2 be scratch_ptr plus 72
    float128_from_int64(1, one_ptr2)
    Let y_ptr be scratch_ptr plus 88
    float128_subtract(m_scaled_ptr, one_ptr2, y_ptr)

    Let sum_ptr be scratch_ptr plus 104
    memory_copy(sum_ptr, y_ptr, 16)

    Let term_ptr be scratch_ptr plus 120
    memory_copy(term_ptr, y_ptr, 16)

    Let neg_y_ptr be scratch_ptr plus 136
    float128_negate(y_ptr, neg_y_ptr)

    Let n be 2
    Let max_iterations be 100
    Let iteration be 0

    While iteration is less than max_iterations:
        Note: term *= -y
        Let temp_ptr be scratch_ptr plus 152
        float128_multiply(term_ptr, neg_y_ptr, temp_ptr)
        memory_copy(term_ptr, temp_ptr, 16)

        Note: term /= n
        Let n_ptr be scratch_ptr plus 168
        float128_from_int64(n, n_ptr)
        float128_divide(term_ptr, n_ptr, temp_ptr)
        memory_copy(term_ptr, temp_ptr, 16)

        Note: sum += term
        Let new_sum_ptr be scratch_ptr plus 184
        float128_add(sum_ptr, term_ptr, new_sum_ptr)

        Note: Check convergence
        Let abs_term_ptr be scratch_ptr plus 200
        float128_abs(term_ptr, abs_term_ptr)

        Let epsilon_ptr be scratch_ptr plus 216
        float128_from_string("1e-34", epsilon_ptr)

        Let converged be float128_less_than(abs_term_ptr, epsilon_ptr)




        memory_copy(sum_ptr, new_sum_ptr, 16)

        If converged is equal to 1:
            break
        End If

        Set n to n plus 1
        Set iteration to iteration plus 1
    End While

    Note: Add exp * ln(2)
    Let ln2_ptr be scratch_ptr plus 232
    float128_get_ln2(ln2_ptr)

    Let exp_float_ptr be scratch_ptr plus 248
    float128_from_int64(exp, exp_float_ptr)

    Let exp_times_ln2_ptr be scratch_ptr plus 264
    float128_multiply(exp_float_ptr, ln2_ptr, exp_times_ln2_ptr)

    float128_add(sum_ptr, exp_times_ln2_ptr, result_ptr)












End Process

Note: ============================================================================
Note: Float128 Inverse Trigonometric Functions (asin, acos, atan, atan2)
Note: ============================================================================

Process called "float128_asin" takes x_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Compute arcsin(x) using Taylor series for small |x| or transformation for larger |x|
    Note: asin(x) = x + x^3/6 + 3x^5/40 + 15x^7/336 + ... for |x| < 0.5
    Note: asin(x) = π/2 - 2*asin(sqrt((1-x)/2)) for x > 0.5

    Note: Check for special values
    If float128_is_nan(x_ptr) is equal to 1:
        float128_raise_exception(FLOAT128_FLAG_INVALID)
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    Note: Check if |x| > 1 (invalid for arcsin)
    Let abs_x_ptr be scratch_ptr
    float128_abs(x_ptr, abs_x_ptr)

    Let one_ptr be scratch_ptr plus 16
    float128_from_int64(1, one_ptr)

    Let x_gt_one be float128_greater_than(abs_x_ptr, one_ptr)
    If x_gt_one is equal to 1:
        Note: arcsin(|x| > 1) = NaN
        float128_raise_exception(FLOAT128_FLAG_INVALID)
        float128_nan(result_ptr)


        Return
    End If

    Note: Check if x == 1 or x == -1
    Let x_eq_one be float128_equal(x_ptr, one_ptr)
    Let neg_one_ptr be scratch_ptr plus 32
    float128_negate(one_ptr, neg_one_ptr)
    Let x_eq_neg_one be float128_equal(x_ptr, neg_one_ptr)

    If x_eq_one is equal to 1:
        Note: arcsin(1) = π/2
        Let pi_ptr be scratch_ptr plus 48
        float128_get_pi(pi_ptr)
        Let two_ptr be scratch_ptr plus 64
        float128_from_int64(2, two_ptr)
        float128_divide(pi_ptr, two_ptr, result_ptr)





        Return
    End If

    If x_eq_neg_one is equal to 1:
        Note: arcsin(-1) = -π/2
        Let pi_ptr be scratch_ptr plus 48
        float128_get_pi(pi_ptr)
        Let two_ptr be scratch_ptr plus 64
        float128_from_int64(2, two_ptr)
        Let pi_div_2_ptr be scratch_ptr plus 80
        float128_divide(pi_ptr, two_ptr, pi_div_2_ptr)
        float128_negate(pi_div_2_ptr, result_ptr)






        Return
    End If

    Note: For |x| > 0.5, use transformation: asin(x) = sign(x) * (π/2 - 2*asin(sqrt((1-|x|)/2)))
    Let half_ptr be scratch_ptr plus 96
    float128_from_string("0.5", half_ptr)
    Let use_transform be float128_greater_than(abs_x_ptr, half_ptr)

    If use_transform is equal to 1:
        Note: Compute sqrt((1 - |x|) / 2)
        Let one_minus_x_ptr be scratch_ptr plus 112
        float128_subtract(one_ptr, abs_x_ptr, one_minus_x_ptr)

        Let two_ptr be scratch_ptr plus 64
        float128_from_int64(2, two_ptr)

        Let arg_ptr be scratch_ptr plus 128
        float128_divide(one_minus_x_ptr, two_ptr, arg_ptr)

        Let sqrt_arg_ptr be scratch_ptr plus 144
        float128_sqrt(arg_ptr, sqrt_arg_ptr)

        Note: Recursively compute asin(sqrt_arg)
        Let asin_sqrt_ptr be scratch_ptr plus 160
        float128_asin(sqrt_arg_ptr, asin_sqrt_ptr)

        Note: Compute 2 * asin(sqrt_arg)
        Let two_asin_ptr be scratch_ptr plus 176
        float128_multiply(two_ptr, asin_sqrt_ptr, two_asin_ptr)

        Note: Compute π/2 - 2*asin(sqrt_arg)
        Let pi_ptr be scratch_ptr plus 48
        float128_get_pi(pi_ptr)
        Let pi_div_2_ptr be scratch_ptr plus 80
        float128_divide(pi_ptr, two_ptr, pi_div_2_ptr)

        Let result_abs_ptr be scratch_ptr plus 192
        float128_subtract(pi_div_2_ptr, two_asin_ptr, result_abs_ptr)

        Note: Apply sign of x
        Let x_high be memory_get_int64(x_ptr, 0)
        Let x_sign be right_shift(x_high, 63)
        If x_sign is equal to 1:
            float128_negate(result_abs_ptr, result_ptr)
        Otherwise:
            memory_copy(result_ptr, result_abs_ptr, 16)
        End If













        Return
    End If

    Note: For |x| <= 0.5, use Taylor series: asin(x) = x + x^3/6 + 3x^5/40 + ...
    Note: General term: asin(x) = sum_{n=0}^∞ [(2n)! / (2^(2n) * (n!)^2 * (2n+1))] * x^(2n+1)

    Let sum_ptr be scratch_ptr plus 208
    memory_copy(sum_ptr, x_ptr, 16)

    Let term_ptr be scratch_ptr plus 224
    memory_copy(term_ptr, x_ptr, 16)

    Let x_squared_ptr be scratch_ptr plus 240
    float128_multiply(x_ptr, x_ptr, x_squared_ptr)

    Let n be 1
    Let max_iterations be 100
    Let iteration be 0

    While iteration is less than max_iterations:
        Note: Compute coefficient: (2n-1)/(2n) * 1/(2n+1)
        Let coeff_num be (2 multiplied by n) minus 1
        Let coeff_den1 be 2 multiplied by n
        Let coeff_den2 be (2 multiplied by n) plus 1
        Let coeff_den be coeff_den1 multiplied by coeff_den2

        Let num_ptr be scratch_ptr plus 256
        float128_from_int64(coeff_num, num_ptr)

        Let den_ptr be scratch_ptr plus 272
        float128_from_int64(coeff_den, den_ptr)

        Let coeff_ptr be scratch_ptr plus 288
        float128_divide(num_ptr, den_ptr, coeff_ptr)

        Note: term *= x^2 * coeff
        Let temp_ptr be scratch_ptr plus 304
        float128_multiply(term_ptr, x_squared_ptr, temp_ptr)
        Let temp2_ptr be scratch_ptr plus 320
        float128_multiply(temp_ptr, coeff_ptr, temp2_ptr)
        memory_copy(term_ptr, temp2_ptr, 16)

        Note: sum += term
        Let new_sum_ptr be scratch_ptr plus 336
        float128_add(sum_ptr, term_ptr, new_sum_ptr)

        Note: Check convergence
        Let abs_term_ptr be scratch_ptr plus 352
        float128_abs(term_ptr, abs_term_ptr)

        Let epsilon_ptr be scratch_ptr plus 368
        float128_from_string("1e-34", epsilon_ptr)

        Let converged be float128_less_than(abs_term_ptr, epsilon_ptr)







        memory_copy(sum_ptr, new_sum_ptr, 16)

        If converged is equal to 1:
            break
        End If

        Set n to n plus 1
        Set iteration to iteration plus 1
    End While

    memory_copy(result_ptr, sum_ptr, 16)







End Process

Process called "float128_acos" takes x_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 320 bytes
    Note: Compute arccos(x) using identity: acos(x) = π/2 - asin(x)

    Let nan_scratch be scratch_ptr
    Let asin_ptr be scratch_ptr plus 32
    Let pi_ptr be scratch_ptr plus 48
    Let two_ptr be scratch_ptr plus 64
    Let pi_div_2_ptr be scratch_ptr plus 80
    Let asin_scratch be scratch_ptr plus 96
    Let op_scratch be scratch_ptr plus 176

    Note: Check for special values
    If float128_is_nan(x_ptr, nan_scratch) is equal to 1:
        float128_raise_exception(FLOAT128_FLAG_INVALID)
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    Note: Compute asin(x)
    float128_asin(x_ptr, asin_ptr, asin_scratch)

    Note: Compute π/2 - asin(x)
    float128_get_pi(pi_ptr)
    float128_from_int64(2, two_ptr)
    float128_divide(pi_ptr, two_ptr, pi_div_2_ptr, op_scratch)
    float128_subtract(pi_div_2_ptr, asin_ptr, result_ptr, op_scratch)
End Process

Process called "float128_atan" takes x_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Compute arctan(x) using Taylor series for |x| <= 1 or reduction for |x| > 1
    Note: atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ... for |x| <= 1
    Note: atan(x) = sign(x) * π/2 - atan(1/x) for |x| > 1

    Note: Check for special values
    If float128_is_nan(x_ptr) is equal to 1:
        float128_raise_exception(FLOAT128_FLAG_INVALID)
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    Let x_is_inf be float128_is_inf(x_ptr)
    If x_is_inf is equal to 1:
        Note: atan(±∞) = ±π/2
        Let pi_ptr be scratch_ptr
        float128_get_pi(pi_ptr)

        Let two_ptr be scratch_ptr plus 16
        float128_from_int64(2, two_ptr)

        Let pi_div_2_ptr be scratch_ptr plus 32
        float128_divide(pi_ptr, two_ptr, pi_div_2_ptr)

        Let x_high be memory_get_int64(x_ptr, 0)
        Let x_sign be right_shift(x_high, 63)
        If x_sign is equal to 1:
            float128_negate(pi_div_2_ptr, result_ptr)
        Otherwise:
            memory_copy(result_ptr, pi_div_2_ptr, 16)
        End If



        Return
    End If

    If float128_is_zero(x_ptr) is equal to 1:
        Note: atan(0) = 0
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    Note: Check if |x| > 1
    Let abs_x_ptr be scratch_ptr plus 48
    float128_abs(x_ptr, abs_x_ptr)

    Let one_ptr be scratch_ptr plus 64
    float128_from_int64(1, one_ptr)

    Let x_gt_one be float128_greater_than(abs_x_ptr, one_ptr)

    If x_gt_one is equal to 1:
        Note: Use atan(x) = sign(x) * π/2 - atan(1/x)
        Let recip_x_ptr be scratch_ptr plus 80
        float128_divide(one_ptr, x_ptr, recip_x_ptr)

        Let atan_recip_ptr be scratch_ptr plus 96
        float128_atan(recip_x_ptr, atan_recip_ptr)

        Let pi_ptr be scratch_ptr
        float128_get_pi(pi_ptr)

        Let two_ptr be scratch_ptr plus 16
        float128_from_int64(2, two_ptr)

        Let pi_div_2_ptr be scratch_ptr plus 32
        float128_divide(pi_ptr, two_ptr, pi_div_2_ptr)

        Let x_high be memory_get_int64(x_ptr, 0)
        Let x_sign be right_shift(x_high, 63)

        If x_sign is equal to 1:
            Note: Negative x: -π/2 - atan(1/x) = -π/2 + atan(-1/x)
            Let neg_pi_div_2_ptr be scratch_ptr plus 112
            float128_negate(pi_div_2_ptr, neg_pi_div_2_ptr)
            float128_subtract(neg_pi_div_2_ptr, atan_recip_ptr, result_ptr)

        Otherwise:
            Note: Positive x: π/2 - atan(1/x)
            float128_subtract(pi_div_2_ptr, atan_recip_ptr, result_ptr)
        End If







        Return
    End If

    Note: For |x| <= 1, use Taylor series: atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
    Let sum_ptr be scratch_ptr plus 128
    memory_copy(sum_ptr, x_ptr, 16)

    Let term_ptr be scratch_ptr plus 144
    memory_copy(term_ptr, x_ptr, 16)

    Let x_squared_ptr be scratch_ptr plus 160
    float128_multiply(x_ptr, x_ptr, x_squared_ptr)

    Let neg_x_squared_ptr be scratch_ptr plus 176
    float128_negate(x_squared_ptr, neg_x_squared_ptr)

    Let n be 1
    Let max_iterations be 100
    Let iteration be 0

    While iteration is less than max_iterations:
        Note: term *= -x^2
        Let temp_ptr be scratch_ptr plus 192
        float128_multiply(term_ptr, neg_x_squared_ptr, temp_ptr)
        memory_copy(term_ptr, temp_ptr, 16)

        Note: Compute denominator: 2n + 1
        Let denom be (2 multiplied by n) plus 1
        Let denom_ptr be scratch_ptr plus 208
        float128_from_int64(denom, denom_ptr)

        Note: term /= (2n + 1)
        float128_divide(term_ptr, denom_ptr, temp_ptr)
        memory_copy(term_ptr, temp_ptr, 16)

        Note: sum += term
        Let new_sum_ptr be scratch_ptr plus 224
        float128_add(sum_ptr, term_ptr, new_sum_ptr)

        Note: Check convergence
        Let abs_term_ptr be scratch_ptr plus 240
        float128_abs(term_ptr, abs_term_ptr)

        Let epsilon_ptr be scratch_ptr plus 256
        float128_from_string("1e-34", epsilon_ptr)

        Let converged be float128_less_than(abs_term_ptr, epsilon_ptr)




        memory_copy(sum_ptr, new_sum_ptr, 16)

        If converged is equal to 1:
            break
        End If

        Set n to n plus 1
        Set iteration to iteration plus 1
    End While

    memory_copy(result_ptr, sum_ptr, 16)






End Process

Process called "float128_atan2" takes y_ptr as Integer, x_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 384 bytes
    Note: Compute atan2(y, x) = angle of point (x, y) from positive x-axis
    Note: Returns value in range [-π, π]
    Note: Handles all quadrants correctly

    Let nan_scratch be scratch_ptr
    Let pi_ptr be scratch_ptr plus 32
    Let two_ptr be scratch_ptr plus 48
    Let pi_div_2_ptr be scratch_ptr plus 64
    Let ratio_ptr be scratch_ptr plus 80
    Let atan_ptr be scratch_ptr plus 96
    Let atan_scratch be scratch_ptr plus 112
    Let op_scratch be scratch_ptr plus 240

    Note: Check for NaN
    If float128_is_nan(y_ptr, nan_scratch) is equal to 1:
        float128_raise_exception(FLOAT128_FLAG_INVALID)
        memory_copy(result_ptr, y_ptr, 16)
        Return
    End If

    If float128_is_nan(x_ptr, nan_scratch) is equal to 1:
        float128_raise_exception(FLOAT128_FLAG_INVALID)
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    Let x_is_zero be float128_is_zero(x_ptr)
    Let y_is_zero be float128_is_zero(y_ptr)

    Note: Special case: both zero
    If x_is_zero is equal to 1:
        If y_is_zero is equal to 1:
            Note: atan2(0, 0) is undefined, return 0
            float128_zero(result_ptr)
            Return
        End If
    End If

    Let x_high be memory_get_int64(x_ptr, 0)
    Let x_sign be right_shift(x_high, 63)

    Let y_high be memory_get_int64(y_ptr, 0)
    Let y_sign be right_shift(y_high, 63)

    Note: Special case: x = 0
    If x_is_zero is equal to 1:
        Note: atan2(y, 0) = ±π/2 depending on sign of y
        float128_get_pi(pi_ptr)
        float128_from_int64(2, two_ptr)
        float128_divide(pi_ptr, two_ptr, pi_div_2_ptr, op_scratch)

        If y_sign is equal to 1:
            float128_negate(pi_div_2_ptr, result_ptr)
        Otherwise:
            memory_copy(result_ptr, pi_div_2_ptr, 16)
        End If

        Return
    End If

    Note: Compute atan(y/x)
    float128_divide(y_ptr, x_ptr, ratio_ptr, op_scratch)
    float128_atan(ratio_ptr, atan_ptr, atan_scratch)

    Note: Adjust for quadrant
    If x_sign is equal to 0:
        Note: Quadrants I and IV (x > 0): return atan(y/x)
        memory_copy(result_ptr, atan_ptr, 16)
    Otherwise:
        Note: Quadrants II and III (x < 0)
        float128_get_pi(pi_ptr)

        If y_sign is equal to 0:
            Note: Quadrant II (x < 0, y >= 0): return atan(y/x) + π
            float128_add(atan_ptr, pi_ptr, result_ptr, op_scratch)
        Otherwise:
            Note: Quadrant III (x < 0, y < 0): return atan(y/x) - π
            float128_subtract(atan_ptr, pi_ptr, result_ptr, op_scratch)
        End If
    End If
End Process

Note: ============================================================================
Note: Float128 Hyperbolic Functions (sinh, cosh, tanh)
Note: ============================================================================

Process called "float128_sinh" takes x_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 208 bytes
    Note: Compute sinh(x) = (e^x - e^(-x)) / 2

    Let nan_scratch be scratch_ptr
    Let exp_x_ptr be scratch_ptr plus 32
    Let neg_x_ptr be scratch_ptr plus 48
    Let exp_neg_x_ptr be scratch_ptr plus 64
    Let diff_ptr be scratch_ptr plus 80
    Let two_ptr be scratch_ptr plus 96
    Let op_scratch be scratch_ptr plus 112

    Note: Check for special values
    If float128_is_nan(x_ptr, nan_scratch) is equal to 1:
        float128_raise_exception(FLOAT128_FLAG_INVALID)
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    Let x_is_inf be float128_is_infinity(x_ptr, nan_scratch)
    If x_is_inf is equal to 1:
        Note: sinh(±∞) = ±∞
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    If float128_is_zero(x_ptr) is equal to 1:
        Note: sinh(0) = 0
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    Note: Compute e^x
    float128_exp(x_ptr, exp_x_ptr, op_scratch)

    Note: Compute e^(-x)
    float128_negate(x_ptr, neg_x_ptr)
    float128_exp(neg_x_ptr, exp_neg_x_ptr, op_scratch)

    Note: Compute e^x - e^(-x)
    float128_subtract(exp_x_ptr, exp_neg_x_ptr, diff_ptr, op_scratch)

    Note: Divide by 2
    float128_from_int64(2, two_ptr)
    float128_divide(diff_ptr, two_ptr, result_ptr, op_scratch)
End Process

Process called "float128_cosh" takes x_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 208 bytes
    Note: Compute cosh(x) = (e^x + e^(-x)) / 2

    Let nan_scratch be scratch_ptr
    Let exp_x_ptr be scratch_ptr plus 32
    Let neg_x_ptr be scratch_ptr plus 48
    Let exp_neg_x_ptr be scratch_ptr plus 64
    Let sum_ptr be scratch_ptr plus 80
    Let two_ptr be scratch_ptr plus 96
    Let op_scratch be scratch_ptr plus 112

    Note: Check for special values
    If float128_is_nan(x_ptr, nan_scratch) is equal to 1:
        float128_raise_exception(FLOAT128_FLAG_INVALID)
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    Let x_is_inf be float128_is_infinity(x_ptr, nan_scratch)
    If x_is_inf is equal to 1:
        Note: cosh(±∞) = +∞
        float128_inf(result_ptr)
        Return
    End If

    Note: cosh(0) = 1
    If float128_is_zero(x_ptr) is equal to 1:
        float128_from_int64(1, result_ptr)
        Return
    End If

    Note: Compute e^x
    float128_exp(x_ptr, exp_x_ptr, op_scratch)

    Note: Compute e^(-x)
    float128_negate(x_ptr, neg_x_ptr)
    float128_exp(neg_x_ptr, exp_neg_x_ptr, op_scratch)

    Note: Compute e^x + e^(-x)
    float128_add(exp_x_ptr, exp_neg_x_ptr, sum_ptr, op_scratch)

    Note: Divide by 2
    float128_from_int64(2, two_ptr)
    float128_divide(sum_ptr, two_ptr, result_ptr, op_scratch)
End Process

Process called "float128_tanh" takes x_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 464 bytes
    Note: Compute tanh(x) = sinh(x) / cosh(x) = (e^x - e^(-x)) / (e^x + e^(-x))

    Let nan_scratch be scratch_ptr
    Let one_ptr be scratch_ptr plus 32
    Let sinh_ptr be scratch_ptr plus 48
    Let cosh_ptr be scratch_ptr plus 64
    Let sinh_scratch be scratch_ptr plus 80
    Let cosh_scratch be scratch_ptr plus 288
    Let div_scratch be scratch_ptr plus 336

    Note: Check for special values
    If float128_is_nan(x_ptr, nan_scratch) is equal to 1:
        float128_raise_exception(FLOAT128_FLAG_INVALID)
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    Let x_is_inf be float128_is_infinity(x_ptr, nan_scratch)
    If x_is_inf is equal to 1:
        Note: tanh(±∞) = ±1
        Let x_high be memory_get_int64(x_ptr, 0)
        Let x_sign be right_shift(x_high, 63)

        float128_from_int64(1, one_ptr)

        If x_sign is equal to 1:
            float128_negate(one_ptr, result_ptr)
        Otherwise:
            memory_copy(result_ptr, one_ptr, 16)
        End If

        Return
    End If

    If float128_is_zero(x_ptr) is equal to 1:
        Note: tanh(0) = 0
        memory_copy(result_ptr, x_ptr, 16)
        Return
    End If

    Note: Compute sinh(x)
    float128_sinh(x_ptr, sinh_ptr, sinh_scratch)

    Note: Compute cosh(x)
    float128_cosh(x_ptr, cosh_ptr, cosh_scratch)

    Note: Compute sinh(x) / cosh(x)
    float128_divide(sinh_ptr, cosh_ptr, result_ptr, div_scratch)
End Process

Process called "float128_vec_add" takes a_array_ptr as Integer, b_array_ptr as Integer, result_array_ptr as Integer, count as Integer:
    Note: Element-wise addition: result[i] = a[i] + b[i]
    Note: a_array_ptr, b_array_ptr, result_array_ptr: pointers to arrays of Float128 (16 bytes each)
    Note: count: number of elements to process

    Let i be 0
    While i is less than count:
        Let offset be i multiplied by 16

        Let a_ptr be a_array_ptr plus offset
        Let b_ptr be b_array_ptr plus offset
        Let result_ptr be result_array_ptr plus offset

        float128_add(a_ptr, b_ptr, result_ptr)

        Set i to i plus 1
    End While
End Process

Process called "float128_vec_sub" takes a_array_ptr as Integer, b_array_ptr as Integer, result_array_ptr as Integer, count as Integer:
    Note: Element-wise subtraction: result[i] = a[i] - b[i]

    Let i be 0
    While i is less than count:
        Let offset be i multiplied by 16

        Let a_ptr be a_array_ptr plus offset
        Let b_ptr be b_array_ptr plus offset
        Let result_ptr be result_array_ptr plus offset

        float128_subtract(a_ptr, b_ptr, result_ptr)

        Set i to i plus 1
    End While
End Process

Process called "float128_vec_mul" takes a_array_ptr as Integer, b_array_ptr as Integer, result_array_ptr as Integer, count as Integer:
    Note: Element-wise multiplication: result[i] = a[i] * b[i]

    Let i be 0
    While i is less than count:
        Let offset be i multiplied by 16

        Let a_ptr be a_array_ptr plus offset
        Let b_ptr be b_array_ptr plus offset
        Let result_ptr be result_array_ptr plus offset

        float128_multiply(a_ptr, b_ptr, result_ptr)

        Set i to i plus 1
    End While
End Process

Process called "float128_vec_div" takes a_array_ptr as Integer, b_array_ptr as Integer, result_array_ptr as Integer, count as Integer:
    Note: Element-wise division: result[i] = a[i] / b[i]

    Let i be 0
    While i is less than count:
        Let offset be i multiplied by 16

        Let a_ptr be a_array_ptr plus offset
        Let b_ptr be b_array_ptr plus offset
        Let result_ptr be result_array_ptr plus offset

        float128_divide(a_ptr, b_ptr, result_ptr)

        Set i to i plus 1
    End While
End Process

Process called "float128_vec_sqrt" takes array_ptr as Integer, result_array_ptr as Integer, count as Integer:
    Note: Element-wise square root: result[i] = sqrt(array[i])

    Let i be 0
    While i is less than count:
        Let offset be i multiplied by 16

        Let input_ptr be array_ptr plus offset
        Let result_ptr be result_array_ptr plus offset

        float128_sqrt(input_ptr, result_ptr)

        Set i to i plus 1
    End While
End Process

Process called "float128_vec_fma" takes a_array_ptr as Integer, b_array_ptr as Integer, c_array_ptr as Integer, result_array_ptr as Integer, count as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 160 bytes
    Note: Element-wise fused multiply-add: result[i] = a[i] * b[i] + c[i]
    Note: More accurate than separate multiply and add

    Let temp_ptr be scratch_ptr
    Let op_scratch be scratch_ptr plus 16

    Let i be 0
    While i is less than count:
        Let offset be i multiplied by 16

        Let a_ptr be a_array_ptr plus offset
        Let b_ptr be b_array_ptr plus offset
        Let c_ptr be c_array_ptr plus offset
        Let result_ptr be result_array_ptr plus offset

        Note: Compute a[i] * b[i]
        float128_multiply(a_ptr, b_ptr, temp_ptr, op_scratch)

        Note: Add c[i]
        float128_add(temp_ptr, c_ptr, result_ptr, op_scratch)

        Set i to i plus 1
    End While
End Process

Process called "float128_vec_dot" takes a_array_ptr as Integer, b_array_ptr as Integer, result_ptr as Integer, count as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 176 bytes (16 for product + 16 for temp + 144 for multiply/add)
    Note: Compute dot product: result = sum(a[i] * b[i])
    Note: Used in linear algebra and ML applications

    Let product_ptr be scratch_ptr
    Let temp_result_ptr be scratch_ptr plus 16
    Let op_scratch be scratch_ptr plus 32

    Note: Initialize accumulator to zero
    float128_from_int64(0, result_ptr)

    Let i be 0
    While i is less than count:
        Let offset be i multiplied by 16

        Let a_ptr be a_array_ptr plus offset
        Let b_ptr be b_array_ptr plus offset

        Note: Compute a[i] * b[i]
        float128_multiply(a_ptr, b_ptr, product_ptr, op_scratch)

        Note: Add to accumulator
        float128_add(result_ptr, product_ptr, temp_result_ptr, op_scratch)
        float128_copy(temp_result_ptr, result_ptr)

        Set i to i plus 1
    End While
End Process

Process called "float128_vec_sum" takes array_ptr as Integer, result_ptr as Integer, count as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 384 bytes (16 for compensation + 64 for temps + 144*2 for add/subtract)
    Note: Sum all elements: result = sum(array[i])
    Note: Uses Kahan summation for improved numerical accuracy

    Let compensation_ptr be scratch_ptr
    Let y_ptr be scratch_ptr plus 16
    Let t_ptr be scratch_ptr plus 32
    Let temp1_ptr be scratch_ptr plus 48
    Let temp2_ptr be scratch_ptr plus 64
    Let add_scratch be scratch_ptr plus 80
    Let subtract_scratch be scratch_ptr plus 224

    Note: Initialize sum to zero
    float128_from_int64(0, result_ptr)

    Note: Kahan summation compensation term
    float128_from_int64(0, compensation_ptr)

    Let i be 0
    While i is less than count:
        Let offset be i multiplied by 16
        Let element_ptr be array_ptr plus offset

        Note: y = element - compensation
        float128_subtract(element_ptr, compensation_ptr, y_ptr, subtract_scratch)

        Note: t = sum + y
        float128_add(result_ptr, y_ptr, t_ptr, add_scratch)

        Note: compensation = (t - sum) - y
        float128_subtract(t_ptr, result_ptr, temp1_ptr, subtract_scratch)
        float128_subtract(temp1_ptr, y_ptr, temp2_ptr, subtract_scratch)
        float128_copy(temp2_ptr, compensation_ptr)

        Note: sum = t
        float128_copy(t_ptr, result_ptr)

        Set i to i plus 1
    End While
End Process

Process called "float128_vec_min" takes array_ptr as Integer, result_ptr as Integer, count as Integer:
    Note: Find minimum value in array
    Note: Returns NaN if any element is NaN (IEEE 754 behavior)

    If count is less than or equal to 0:
        Note: Empty array - set result to NaN
        float128_set_nan(result_ptr)
        Return
    End If

    Note: Initialize with first element
    float128_copy(array_ptr, result_ptr)

    Let i be 1
    While i is less than count:
        Let offset be i multiplied by 16
        Let element_ptr be array_ptr plus offset

        Note: Check if element is NaN
        If float128_is_nan(element_ptr) is equal to 1:
            float128_copy(element_ptr, result_ptr)
            Return
        End If

        Note: Compare and update minimum
        Let is_less be float128_less_than(element_ptr, result_ptr)
        If is_less is equal to 1:
            float128_copy(element_ptr, result_ptr)
        End If

        Set i to i plus 1
    End While
End Process

Process called "float128_vec_max" takes array_ptr as Integer, result_ptr as Integer, count as Integer:
    Note: Find maximum value in array
    Note: Returns NaN if any element is NaN (IEEE 754 behavior)

    If count is less than or equal to 0:
        Note: Empty array - set result to NaN
        float128_set_nan(result_ptr)
        Return
    End If

    Note: Initialize with first element
    float128_copy(array_ptr, result_ptr)

    Let i be 1
    While i is less than count:
        Let offset be i multiplied by 16
        Let element_ptr be array_ptr plus offset

        Note: Check if element is NaN
        If float128_is_nan(element_ptr) is equal to 1:
            float128_copy(element_ptr, result_ptr)
            Return
        End If

        Note: Compare and update maximum
        Let is_greater be float128_greater_than(element_ptr, result_ptr)
        If is_greater is equal to 1:
            float128_copy(element_ptr, result_ptr)
        End If

        Set i to i plus 1
    End While
End Process

Process called "float128_vec_abs" takes array_ptr as Integer, result_array_ptr as Integer, count as Integer:
    Note: Element-wise absolute value: result[i] = |array[i]|

    Let i be 0
    While i is less than count:
        Let offset be i multiplied by 16

        Let input_ptr be array_ptr plus offset
        Let result_ptr be result_array_ptr plus offset

        float128_abs(input_ptr, result_ptr)

        Set i to i plus 1
    End While
End Process

Process called "float128_vec_negate" takes array_ptr as Integer, result_array_ptr as Integer, count as Integer:
    Note: Element-wise negation: result[i] = -array[i]

    Let i be 0
    While i is less than count:
        Let offset be i multiplied by 16

        Let input_ptr be array_ptr plus offset
        Let result_ptr be result_array_ptr plus offset

        float128_negate(input_ptr, result_ptr)

        Set i to i plus 1
    End While
End Process

Process called "float128_vec_scale" takes array_ptr as Integer, scalar_ptr as Integer, result_array_ptr as Integer, count as Integer:
    Note: Scale all elements by scalar: result[i] = array[i] * scalar

    Let i be 0
    While i is less than count:
        Let offset be i multiplied by 16

        Let input_ptr be array_ptr plus offset
        Let result_ptr be result_array_ptr plus offset

        float128_multiply(input_ptr, scalar_ptr, result_ptr)

        Set i to i plus 1
    End While
End Process

Process called "float128_vec_mean" takes array_ptr as Integer, result_ptr as Integer, count as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 160 bytes (16 for count + 16 for temp + 128 for divide)
    Note: Compute arithmetic mean: result = sum(array[i]) / count
    Note: Returns NaN for empty array

    If count is less than or equal to 0:
        float128_set_nan(result_ptr)
        Return
    End If

    Let count_ptr be scratch_ptr
    Let temp_ptr be scratch_ptr plus 16
    Let divide_scratch be scratch_ptr plus 32

    Note: Sum all elements
    float128_vec_sum(array_ptr, result_ptr, count, divide_scratch)

    Note: Divide by count
    float128_from_int64(count, count_ptr)
    float128_divide(result_ptr, count_ptr, temp_ptr, divide_scratch)
    float128_copy(temp_ptr, result_ptr)
End Process

Process called "float128_vec_variance" takes array_ptr as Integer, result_ptr as Integer, count as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 416 bytes (160 for mean + 48 for temps + 144 for ops + 64 for count/divide)
    Note: Compute variance: var = sum((x[i] - mean)^2) / count
    Note: Uses two-pass algorithm for better accuracy

    If count is less than or equal to 0:
        float128_set_nan(result_ptr)
        Return
    End If

    Let mean_ptr be scratch_ptr
    Let sum_sq_dev_ptr be scratch_ptr plus 16
    Let deviation_ptr be scratch_ptr plus 32
    Let sq_dev_ptr be scratch_ptr plus 48
    Let temp_ptr be scratch_ptr plus 64
    Let count_ptr be scratch_ptr plus 80
    Let mean_scratch be scratch_ptr plus 96
    Let op_scratch be scratch_ptr plus 256

    Note: Compute mean
    float128_vec_mean(array_ptr, mean_ptr, count, mean_scratch)

    Note: Compute sum of squared deviations
    float128_from_int64(0, sum_sq_dev_ptr)

    Let i be 0
    While i is less than count:
        Let offset be i multiplied by 16
        Let element_ptr be array_ptr plus offset

        Note: deviation = element - mean
        float128_subtract(element_ptr, mean_ptr, deviation_ptr, op_scratch)

        Note: squared_deviation = deviation^2
        float128_multiply(deviation_ptr, deviation_ptr, sq_dev_ptr, op_scratch)

        Note: Accumulate
        float128_add(sum_sq_dev_ptr, sq_dev_ptr, temp_ptr, op_scratch)
        float128_copy(temp_ptr, sum_sq_dev_ptr)

        Set i to i plus 1
    End While

    Note: variance = sum_sq_dev / count
    float128_from_int64(count, count_ptr)
    float128_divide(sum_sq_dev_ptr, count_ptr, result_ptr, op_scratch)
End Process

Process called "float128_vec_stddev" takes array_ptr as Integer, result_ptr as Integer, count as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 800 bytes (416 for variance + 384 for sqrt)
    Note: Compute standard deviation: stddev = sqrt(variance)

    Let temp_ptr be scratch_ptr
    Let variance_scratch be scratch_ptr plus 16
    Let sqrt_scratch be scratch_ptr plus 432

    Note: Compute variance
    float128_vec_variance(array_ptr, result_ptr, count, variance_scratch)

    Note: Take square root
    float128_sqrt(result_ptr, temp_ptr, sqrt_scratch)
    float128_copy(temp_ptr, result_ptr)
End Process

Note: ============================================================================
Note: Float128 Classification Functions
Note: ============================================================================

Process called "float128_isnormal" takes f128_ptr as Integer returns Integer:
    Note: Check if Float128 is a normal number
    Note: Normal: exponent in [1, 32766], not zero, not inf, not NaN

    If float128_is_zero(f128_ptr) is equal to 1:
        Return 0
    End If

    If float128_is_nan(f128_ptr) is equal to 1:
        Return 0
    End If

    If float128_is_inf(f128_ptr) is equal to 1:
        Return 0
    End If

    If float128_is_subnormal(f128_ptr) is equal to 1:
        Return 0
    End If

    Return 1
End Process

Process called "float128_isfinite" takes f128_ptr as Integer returns Integer:
    Note: Check if Float128 is finite (not inf, not NaN)

    If float128_is_nan(f128_ptr) is equal to 1:
        Return 0
    End If

    If float128_is_inf(f128_ptr) is equal to 1:
        Return 0
    End If

    Return 1
End Process

Process called "float128_fpclassify" takes f128_ptr as Integer returns Integer:
    Note: Classify Float128 value according to IEEE 754
    Note: Returns: 0=NaN, 1=Infinite, 2=Zero, 3=Subnormal, 4=Normal

    If float128_is_nan(f128_ptr) is equal to 1:
        Return 0
    End If

    If float128_is_inf(f128_ptr) is equal to 1:
        Return 1
    End If

    If float128_is_zero(f128_ptr) is equal to 1:
        Return 2
    End If

    If float128_is_subnormal(f128_ptr) is equal to 1:
        Return 3
    End If

    Return 4
End Process

Process called "float128_signbit" takes f128_ptr as Integer returns Integer:
    Note: Return sign bit of Float128
    Note: Returns 1 for negative (including -0), 0 for positive

    Let high_word be memory_get_int64(f128_ptr, 0)
    Let sign be right_shift(high_word, 63)
    Return sign
End Process

Process called "float128_copysign" takes x_ptr as Integer, y_ptr as Integer, result_ptr as Integer:
    Note: Return x with sign of y

    Let x_high be memory_get_int64(x_ptr, 0)
    Let x_low be memory_get_int64(x_ptr, 8)

    Let y_high be memory_get_int64(y_ptr, 0)
    Let y_sign be bitwise_and(y_high, 9223372036854775808)

    Note: Clear sign bit of x
    Set x_high to bitwise_and(x_high, 9223372036854775807)

    Note: Apply sign bit from y
    Set x_high to bitwise_or(x_high, y_sign)

    memory_set_int64(result_ptr, 0, x_high)
    memory_set_int64(result_ptr, 8, x_low)
End Process

Note: ============================================================================
Note: Multi-Precision Integer Helpers for Dragon4
Note: ============================================================================
Note: These functions implement arbitrary-precision integer arithmetic
Note: needed for Dragon4 algorithm (Steele & White, 1990)

Note: Representation: Array of 64-bit words, little-endian
Note: bigint[0] = least significant word
Note: bigint[n-1] = most significant word

Process called "bigint_create" takes size as Integer returns Integer:
    Note: Allocate multi-precision integer with 'size' 64-bit words
    Note: Returns pointer to allocated array, initialized to zero
    Let ptr be allocate(size multiplied by 8)
    Let i be 0
    While i is less than size:
        memory_set_int64(ptr, i multiplied by 8, 0)
        Set i to i plus 1
    End While
    Return ptr
End Process

Process called "bigint_set_u128" takes bigint_ptr as Integer, high as Integer, low as Integer:
    Note: Set bigint to 128-bit value [high:low]
    memory_set_int64(bigint_ptr, 0, low)
    memory_set_int64(bigint_ptr, 8, high)
End Process

Process called "bigint_multiply_small" takes bigint_ptr as Integer, size as Integer, multiplier as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 16 bytes
    Note: Multiply bigint by small integer (multiplier < 2^32)
    Note: result = bigint × multiplier
    Let prod_high_ptr be scratch_ptr
    Let prod_low_ptr be scratch_ptr plus 8
    Let carry be 0
    Let i be 0
    While i is less than size:
        Let word be memory_get_int64(bigint_ptr, i multiplied by 8)
        mul64x64_128(word, multiplier, prod_high_ptr, prod_low_ptr)
        Let prod_high be memory_get_int64(prod_high_ptr, 0)
        Let prod_low be memory_get_int64(prod_low_ptr, 0)

        Let sum be prod_low plus carry
        Let new_carry be prod_high
        If sum is less than carry:
            Set new_carry to new_carry plus 1
        End If
        memory_set_int64(result_ptr, i multiplied by 8, sum)
        Set carry to new_carry
        Set i to i plus 1
    End While
End Process

Process called "bigint_divide_small" takes bigint_ptr as Integer, size as Integer, divisor as Integer, quotient_ptr as Integer returns Integer:
    Note: Divide bigint by small integer, return remainder
    Note: quotient = bigint / divisor, return bigint % divisor
    Let remainder be 0
    Let i be size minus 1
    While i is greater than or equal to 0:
        Let word be memory_get_int64(bigint_ptr, i multiplied by 8)
        Let dividend_high be remainder
        Let dividend_low be word

        Note: Divide 128-bit [dividend_high:dividend_low] by divisor
        Note: Production algorithm: proper 128÷64 division
        Note: We need to compute: (dividend_high * 2^64 + dividend_low) / divisor

        Note: Check if we can use Newton-Raphson fast path (dividend_high < divisor)
        If dividend_high is less than divisor:
            Note: Fast path: Newton-Raphson division (Industry Standard)
            Note: Algorithm: Compute reciprocal R ≈ 2^128 / divisor, then quot ≈ dividend * R / 2^128
            Note: Newton-Raphson iteration: R_{n+1} = R_n * (2 - divisor * R_n / 2^64)
            Note: Used by Intel, AMD, ARM processors for hardware division
            Note: Performance: ~4-5 iterations for 64-bit precision vs 128 bit-by-bit operations

            Note: Step 1: Initial reciprocal estimate R_0 ≈ 2^128 / divisor
            Note: Count leading zeros in divisor to normalize
            Let leading_zeros be 0
            Let test_bit be 9223372036854775808
            Let temp_divisor be divisor
            While test_bit is greater than 0:
                If bitwise_and(temp_divisor, test_bit) is not equal to 0:
                    break
                End If
                Set leading_zeros to leading_zeros plus 1
                Set test_bit to right_shift(test_bit, 1)
            End While

            Note: Normalize divisor and compute initial estimate
            Let divisor_normalized be left_shift(divisor, leading_zeros)
            Let divisor_top be right_shift(divisor_normalized, 63)
            If divisor_top is equal to 0:
                Set divisor_top to 1
            End If

            Note: Initial reciprocal R_0 (128-bit: [recip_high : recip_low])
            Let recip_high be 18446744073709551615 divided by divisor_top
            Let recip_low be 0

            Note: Step 2: Newton-Raphson iterations
            Note: Goldschmidt variation: R_{n+1} = R_n * (2 - divisor * R_n / 2^64)
            Let iter be 0
            While iter is less than 5:
                Note: Compute divisor * R_n
                Let prod_high_temp be 0
                Let prod_low_temp be 0
                mul64x64_128(divisor, recip_high, addr_of(prod_high_temp), addr_of(prod_low_temp))

                Let prod_low_contrib_high be 0
                Let prod_low_contrib_low be 0
                mul64x64_128(divisor, recip_low, addr_of(prod_low_contrib_high), addr_of(prod_low_contrib_low))

                Let carry_add be 0
                Set prod_low_temp to prod_low_temp plus prod_low_contrib_high
                If prod_low_temp is less than prod_low_contrib_high:
                    Set carry_add to 1
                End If
                Set prod_high_temp to prod_high_temp plus carry_add

                Note: Check convergence: if divisor * R ≈ 2^64, we have R ≈ 2^64/divisor
                If prod_high_temp is greater than or equal to 18446744073709551615:
                    break
                End If

                Note: Compute correction factor: 2^64 - prod_high_temp
                Let correction_factor be 18446744073709551616 minus prod_high_temp
                If correction_factor is greater than 18446744073709551616:
                    Set correction_factor to 0
                End If

                Note: Update: R_{n+1} = R_n + R_n * correction / 2^64
                Let update_high be 0
                Let update_low be 0
                mul64x64_128(recip_high, correction_factor, addr_of(update_high), addr_of(update_low))

                Let update_for_recip be update_high
                Set recip_low to recip_low plus update_for_recip
                If recip_low is less than update_for_recip:
                    Set recip_high to recip_high plus 1
                End If

                Set iter to iter plus 1
            End While

            Note: Step 3: Compute quotient = dividend * reciprocal / 2^128
            Note: 128×128 → 256-bit multiply: [dividend_high:dividend_low] × [recip_high:recip_low]
            Note: Result bits [255:128] give quotient after division by 2^128

            Let q1_high be 0
            Let q1_low be 0
            mul64x64_128(dividend_high, recip_high, addr_of(q1_high), addr_of(q1_low))

            Let q2_high be 0
            Let q2_low be 0
            mul64x64_128(dividend_high, recip_low, addr_of(q2_high), addr_of(q2_low))

            Let q3_high be 0
            Let q3_low be 0
            mul64x64_128(dividend_low, recip_high, addr_of(q3_high), addr_of(q3_low))

            Let q4_high be 0
            Let q4_low be 0
            mul64x64_128(dividend_low, recip_low, addr_of(q4_high), addr_of(q4_low))

            Note: Accumulate 256-bit product [result_3:result_2:result_1:result_0]
            Let result_1 be q4_high
            Let carry_1 be 0
            Set result_1 to result_1 plus q3_low
            If result_1 is less than q3_low:
                Set carry_1 to 1
            End If
            Set result_1 to result_1 plus q2_low
            If result_1 is less than q2_low:
                Set carry_1 to carry_1 plus 1
            End If

            Let result_2 be q3_high plus carry_1
            Let carry_2 be 0
            If result_2 is less than carry_1:
                Set carry_2 to 1
            End If
            Set result_2 to result_2 plus q2_high
            If result_2 is less than q2_high:
                Set carry_2 to carry_2 plus 1
            End If
            Set result_2 to result_2 plus q1_low
            If result_2 is less than q1_low:
                Set carry_2 to carry_2 plus 1
            End If

            Let result_3 be q1_high plus carry_2

            Note: Quotient is [result_3:result_2] (upper 128 bits / 2^128)
            If result_3 is greater than 0:
                Set quot to 18446744073709551615
            Otherwise:
                Set quot to result_2
            End If

            Note: Step 4: Refinement (quotient may be off by ±1 due to rounding)
            Let prod_high be 0
            Let prod_low be 0
            mul64x64_128(quot, divisor, addr_of(prod_high), addr_of(prod_low))

            While prod_high is greater than dividend_high:
                Set quot to quot minus 1
                mul64x64_128(quot, divisor, addr_of(prod_high), addr_of(prod_low))
            End While

            While prod_high is equal to dividend_high:
                If prod_low is greater than dividend_low:
                    Set quot to quot minus 1
                    mul64x64_128(quot, divisor, addr_of(prod_high), addr_of(prod_low))
                Otherwise:
                    break
                End If
            End While

            Note: Try increment
            Let next_prod_low be prod_low plus divisor
            Let next_prod_high be prod_high
            If next_prod_low is less than prod_low:
                Set next_prod_high to next_prod_high plus 1
            End If

            If next_prod_high is less than dividend_high:
                Set quot to quot plus 1
                Set prod_high to next_prod_high
                Set prod_low to next_prod_low
            End If
            If next_prod_high is equal to dividend_high:
                If next_prod_low is less than or equal to dividend_low:
                    Set quot to quot plus 1
                    Set prod_high to next_prod_high
                    Set prod_low to next_prod_low
                End If
            End If

            Note: Compute remainder
            Let rem_low be dividend_low minus prod_low
            Let borrow be 0
            If rem_low is greater than dividend_low:
                Set borrow to 1
            End If
            Let rem_high be dividend_high minus prod_high minus borrow

            If rem_high is not equal to 0:
                Set rem to 0
            Otherwise:
                Set rem to rem_low
            End If
        Otherwise:
            Note: Slow path: dividend_high >= divisor, need full 128-bit division
            Note: Use binary long division
            Let quot be 0
            Let current_rem_high be dividend_high
            Let current_rem_low be dividend_low

            Note: Process from most significant bit to least
            Let bit_pos be 127
            While bit_pos is greater than or equal to 0:
                Note: Check if we can subtract divisor from current remainder
                Note: Current remainder is: current_rem_high * 2^64 + current_rem_low
                Note: Compare with divisor (which fits in 64 bits)
                Let can_subtract be 0

                If current_rem_high is greater than or equal to divisor:
                    Set can_subtract to 1
                Otherwise:
                    If current_rem_high is equal to 0:
                        If current_rem_low is greater than or equal to divisor:
                            Set can_subtract to 1
                        End If
                    End If
                End If

                If can_subtract is equal to 1:
                    Note: Subtract divisor from current remainder
                    If current_rem_high is greater than or equal to divisor:
                        Set current_rem_high to current_rem_high minus divisor
                    Otherwise:
                        Set current_rem_low to current_rem_low minus divisor
                    End If

                    Note: Set bit in quotient
                    If bit_pos is less than 64:
                        Let bit_mask be left_shift(1, bit_pos)
                        Set quot to bitwise_or(quot, bit_mask)
                    End If
                End If

                Set bit_pos to bit_pos minus 1
            End While

            Note: Remainder is current_rem (should fit in 64 bits)
            If current_rem_high is equal to 0:
                Set rem to current_rem_low
            Otherwise:
                Note: This shouldn't happen if algorithm is correct
                Set rem to 0
            End If
        End If

        memory_set_int64(quotient_ptr, i multiplied by 8, quot)
        Set remainder to rem
        Set i to i minus 1
    End While
    Return remainder
End Process

Process called "bigint_compare" takes a_ptr as Integer, b_ptr as Integer, size as Integer returns Integer:
    Note: Compare two bigints: returns -1 if a<b, 0 if a==b, 1 if a>b
    Let i be size minus 1
    While i is greater than or equal to 0:
        Let a_word be memory_get_int64(a_ptr, i multiplied by 8)
        Let b_word be memory_get_int64(b_ptr, i multiplied by 8)
        If a_word is greater than b_word:
            Return 1
        End If
        If a_word is less than b_word:
            Return -1
        End If
        Set i to i minus 1
    End While
    Return 0
End Process

Process called "bigint_is_zero" takes bigint_ptr as Integer, size as Integer returns Integer:
    Note: Check if bigint is zero
    Let i be 0
    While i is less than size:
        Let word be memory_get_int64(bigint_ptr, i multiplied by 8)
        If word is not equal to 0:
            Return 0
        End If
        Set i to i plus 1
    End While
    Return 1
End Process

Process called "bigint_shift_left" takes bigint_ptr as Integer, size as Integer, shift_count as Integer, result_ptr as Integer:
    Note: Left shift bigint by shift_count bits
    If shift_count is equal to 0:
        Let i be 0
        While i is less than size:
            Let word be memory_get_int64(bigint_ptr, i multiplied by 8)
            memory_set_int64(result_ptr, i multiplied by 8, word)
            Set i to i plus 1
        End While
        Return
    End If

    Let carry be 0
    Let i be 0
    While i is less than size:
        Let word be memory_get_int64(bigint_ptr, i multiplied by 8)
        Let shifted be left_shift(word, shift_count)
        Set shifted to bitwise_or(shifted, carry)
        memory_set_int64(result_ptr, i multiplied by 8, shifted)
        Set carry to right_shift(word, 64 minus shift_count)
        Set i to i plus 1
    End While
End Process

Process called "bigint_subtract" takes a_ptr as Integer, b_ptr as Integer, size as Integer, result_ptr as Integer returns Integer:
    Note: Multi-precision subtraction: result = a - b
    Note: Returns 1 if borrow (a < b), 0 otherwise
    Let borrow be 0
    Let i be 0
    While i is less than size:
        Let a_word be memory_get_int64(a_ptr, i multiplied by 8)
        Let b_word be memory_get_int64(b_ptr, i multiplied by 8)
        Let diff be a_word minus b_word minus borrow
        Set borrow to 0
        Note: Check if borrow occurred
        If a_word is less than b_word:
            Set borrow to 1
        Otherwise:
            If a_word is equal to b_word:
                If borrow is equal to 1:
                    Set borrow to 1
                End If
            End If
        End If
        memory_set_int64(result_ptr, i multiplied by 8, diff)
        Set i to i plus 1
    End While
    Return borrow
End Process

Process called "bigint_divide" takes dividend_ptr as Integer, dividend_size as Integer, divisor_ptr as Integer, divisor_size as Integer, quotient_ptr as Integer, remainder_ptr as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 2 × dividend_size × 8 bytes (for trial_product_ptr and product_ptr)
    Note: Multi-precision division: quotient = dividend / divisor, remainder = dividend % divisor
    Note: Uses binary long division algorithm (Knuth Algorithm D simplified)
    Note: This is the proper algorithm for Dragon4 digit extraction
    Note: Performance: O(dividend_size * divisor_size) but correct for all cases

    Note: Initialize quotient to zero
    Let i be 0
    While i is less than dividend_size:
        memory_set_int64(quotient_ptr, i multiplied by 8, 0)
        Set i to i plus 1
    End While

    Note: Copy dividend to remainder (we'll work with remainder)
    Set i to 0
    While i is less than dividend_size:
        Let word be memory_get_int64(dividend_ptr, i multiplied by 8)
        memory_set_int64(remainder_ptr, i multiplied by 8, word)
        Set i to i plus 1
    End While

    Note: Check if divisor > dividend (quotient = 0, remainder = dividend)
    If bigint_compare(remainder_ptr, divisor_ptr, dividend_size) is less than 0:
        Return
    End If

    Note: Find the most significant non-zero word in divisor
    Let divisor_msw_idx be divisor_size minus 1
    While divisor_msw_idx is greater than 0:
        Let div_word be memory_get_int64(divisor_ptr, divisor_msw_idx multiplied by 8)
        If div_word is not equal to 0:
            break
        End If
        Set divisor_msw_idx to divisor_msw_idx minus 1
    End While

    Note: Normalized divisor for better quotient digit estimation
    Let divisor_msw be memory_get_int64(divisor_ptr, divisor_msw_idx multiplied by 8)

    Note: Binary long division: process bit-by-bit from most significant
    Note: We'll use a word-at-a-time approach for efficiency
    Note: Start from the most significant word of dividend
    Let quot_word_idx be dividend_size minus 1

    While quot_word_idx is greater than or equal to 0:
        Note: Try to find quotient digit for this word position
        Note: Estimate: how many times does divisor fit into current remainder?

        Note: Check if we can subtract divisor from remainder
        Let can_subtract be bigint_compare(remainder_ptr, divisor_ptr, dividend_size)

        If can_subtract is greater than or equal to 0:
            Note: Divisor fits at least once
            Note: Find maximum quotient digit at this position using binary search
            Note: Try quotient digits 0-255 (8 bits at a time for efficiency)
            Let quot_digit be 0
            Let test_digit be 128
            Let step be 64

            Note: Binary search for optimal quotient digit
            Let trial_product_ptr be scratch_ptr
            Let product_ptr be scratch_ptr plus (dividend_size multiplied by 8)

            While step is greater than 0:
                Let trial_digit be quot_digit plus test_digit
                If trial_digit is greater than 255:
                    Set trial_digit to 255
                End If

                Note: Compute divisor * trial_digit
                Set j to 0
                While j is less than dividend_size:
                    memory_set_int64(trial_product_ptr, j multiplied by 8, 0)
                    Set j to j plus 1
                End While

                Note: Multiply divisor by trial_digit
                Let carry be 0
                Set j to 0
                While j is less than or equal to divisor_msw_idx:
                    Let div_word be memory_get_int64(divisor_ptr, j multiplied by 8)
                    Let prod_high be 0
                    Let prod_low be 0
                    mul64x64_128(div_word, trial_digit, addr_of(prod_high), addr_of(prod_low))
                    Set prod_low to prod_low plus carry
                    If prod_low is less than carry:
                        Set prod_high to prod_high plus 1
                    End If
                    memory_set_int64(trial_product_ptr, j multiplied by 8, prod_low)
                    Set carry to prod_high
                    Set j to j plus 1
                End While
                If carry is greater than 0:
                    memory_set_int64(trial_product_ptr, j multiplied by 8, carry)
                End If

                Note: Compare trial_product with remainder
                If bigint_compare(trial_product_ptr, remainder_ptr, dividend_size) is less than or equal to 0:
                    Note: trial_digit works, try higher
                    Set quot_digit to trial_digit
                End If

                Set test_digit to step
                Set step to step divided by 2
            End While

            Note: Apply the quotient digit we found
            If quot_digit is greater than 0:
                Note: Compute divisor * quot_digit
                Set j to 0
                While j is less than dividend_size:
                    memory_set_int64(product_ptr, j multiplied by 8, 0)
                    Set j to j plus 1
                End While

                Set carry to 0
                Set j to 0
                While j is less than or equal to divisor_msw_idx:
                    Let div_word be memory_get_int64(divisor_ptr, j multiplied by 8)
                    Let prod_high be 0
                    Let prod_low be 0
                    mul64x64_128(div_word, quot_digit, addr_of(prod_high), addr_of(prod_low))
                    Set prod_low to prod_low plus carry
                    If prod_low is less than carry:
                        Set prod_high to prod_high plus 1
                    End If
                    memory_set_int64(product_ptr, j multiplied by 8, prod_low)
                    Set carry to prod_high
                    Set j to j plus 1
                End While
                If carry is greater than 0:
                    memory_set_int64(product_ptr, j multiplied by 8, carry)
                End If

                Note: Subtract product from remainder
                bigint_subtract(remainder_ptr, product_ptr, dividend_size, remainder_ptr)

                Note: Store quotient digit
                Let current_quot be memory_get_int64(quotient_ptr, quot_word_idx multiplied by 8)
                Set current_quot to current_quot plus quot_digit
                memory_set_int64(quotient_ptr, quot_word_idx multiplied by 8, current_quot)
            End If
        End If

        Set quot_word_idx to quot_word_idx minus 1
    End While
End Process

Note: ============================================================================
Note: Float128 String Conversion - TRUE Dragon4 Implementation
Note: ============================================================================

Process called "float128_to_string" takes f128_ptr as Integer, buffer_ptr as Integer, buffer_size as Integer, scratch_ptr as Integer returns Integer:
    Note: Convert Float128 to decimal string representation
    Note: Returns number of characters written
    Note: Format: [-]d.ddddddddddddddddddddddddddddddddEseeee
    Note: Provides ~34 decimal digits of precision

    Note: Check for special values first
    If float128_is_nan(f128_ptr) is equal to 1:
        Note: Write "NaN"
        memory_set_int8(buffer_ptr, 0, 78)  Note: 'N'
        memory_set_int8(buffer_ptr, 1, 97)  Note: 'a'
        memory_set_int8(buffer_ptr, 2, 78)  Note: 'N'
        memory_set_int8(buffer_ptr, 3, 0)   Note: null terminator
        Return 3
    End If

    If float128_is_infinity(f128_ptr) is equal to 1:
        Let sign_ptr be scratch_ptr
        Let temp_exp be scratch_ptr plus 8
        Let temp_mh be scratch_ptr plus 16
        Let temp_ml be scratch_ptr plus 24
        float128_unpack(f128_ptr, sign_ptr, temp_exp, temp_mh, temp_ml)
        Let sign be memory_get_int64(sign_ptr, 0)




        Let pos be 0
        If sign is equal to 1:
            memory_set_int8(buffer_ptr, pos, 45)  Note: '-'
            Set pos to pos plus 1
        End If
        memory_set_int8(buffer_ptr, pos, 73)    Note: 'I'
        Set pos to pos plus 1
        memory_set_int8(buffer_ptr, pos, 110)   Note: 'n'
        Set pos to pos plus 1
        memory_set_int8(buffer_ptr, pos, 102)   Note: 'f'
        Set pos to pos plus 1
        memory_set_int8(buffer_ptr, pos, 0)     Note: null
        Return pos
    End If

    If float128_is_zero(f128_ptr) is equal to 1:
        Note: Write "0.0"
        memory_set_int8(buffer_ptr, 0, 48)   Note: '0'
        memory_set_int8(buffer_ptr, 1, 46)   Note: '.'
        memory_set_int8(buffer_ptr, 2, 48)   Note: '0'
        memory_set_int8(buffer_ptr, 3, 0)    Note: null
        Return 3
    End If

    Note: Unpack the value
    Let sign_ptr be scratch_ptr
    Let exp_ptr be scratch_ptr plus 32
    Let mant_high_ptr be scratch_ptr plus 40
    Let mant_low_ptr be scratch_ptr plus 48
    float128_unpack(f128_ptr, sign_ptr, exp_ptr, mant_high_ptr, mant_low_ptr)

    Let sign be memory_get_int64(sign_ptr, 0)
    Let exp be memory_get_int64(exp_ptr, 0)
    Let mant_high be memory_get_int64(mant_high_ptr, 0)
    Let mant_low be memory_get_int64(mant_low_ptr, 0)




    Note: ========================================================================
    Note: TRUE Dragon4 Algorithm for Float128 to Decimal Conversion
    Note: ========================================================================
    Note: Based on "Printing Floating-Point Numbers Quickly and Accurately"
    Note: by Steele & White (1990), refined by Burger & Dybvig (1996)
    
    Note: Algorithm produces provably shortest correctly-rounded decimal representation
    Note: Format: [-]d.ddddddddddddddddddddddddddddddddE±eeee
    Note: Provides full ~34 decimal digits of Float128 precision
    
    Note: Key idea: Represent value as ratio of arbitrary-precision integers
    Note: v = mantissa × 2^exponent = (r / s) where r and s are computed precisely
    Note: Extract decimal digits: d = floor(10*r / s), then r = 10*r - d*s

    Note: Add implicit leading 1 bit for normalized numbers
    If exp is not equal to 0:
        Set mant_high to bitwise_or(mant_high, 281474976710656)
    End If

    Note: Step 1: Convert biased exponent to actual exponent
    Note: Float128 uses bias of 16383
    Let e be exp minus 16383

    Note: Step 2: Setup Dragon4 ratio (r / s)
    Note: Value v = mantissa × 2^e
    Note: We represent this as v = r / s in lowest terms
    
    Note: If e >= 0: r = mantissa × 2^e, s = 1
    Note: If e < 0:  r = mantissa, s = 2^(-e)

    Note: Allocate multi-precision integers (4 words = 256 bits is enough)
    Let bigint_size be 4
    Let r be bigint_create(bigint_size)
    Let s be bigint_create(bigint_size)
    Let temp be bigint_create(bigint_size)

    Note: Initialize r = mantissa (113 bits with implicit 1)
    bigint_set_u128(r, mant_high, mant_low)

    Note: Initialize s and scale r or s based on exponent
    If e is greater than or equal to 0:
        Note: Positive exponent: r = mantissa × 2^e, s = 1
        If e is greater than 0:
            bigint_shift_left(r, bigint_size, e, temp)
            Note: Copy temp back to r
            Let i be 0
            While i is less than bigint_size:
                Let word be memory_get_int64(temp, i multiplied by 8)
                memory_set_int64(r, i multiplied by 8, word)
                Set i to i plus 1
            End While
        End If
        Note: s = 1
        memory_set_int64(s, 0, 1)
    End If
    Otherwise:
        Note: Negative exponent: r = mantissa, s = 2^(-e)
        Note: s = 1 << (-e)
        memory_set_int64(s, 0, 1)
        Let neg_e be 0 minus e
        bigint_shift_left(s, bigint_size, neg_e, temp)
        Note: Copy temp back to s
        Let i be 0
        While i is less than bigint_size:
            Let word be memory_get_int64(temp, i multiplied by 8)
            memory_set_int64(s, i multiplied by 8, word)
            Set i to i plus 1
        End While
    End If

    Note: Step 3: Scale r and s to get value into range [0.1, 1.0)
    Note: Estimate decimal exponent: k = floor(log10(v))
    Note: Use k to scale: r = r × 10^(-k) or s = s × 10^k
    Note: Approximate k using binary exponent
    Note: k ≈ floor((e + 112) × log10(2)) = floor((e + 112) × 0.30103)

    Let k be e plus 112
    Set k to k multiplied by 30103
    Set k to k divided by 100000

    Note: Scale by power of 10 to normalize
    Note: If k > 0: s = s × 10^k
    Note: If k < 0: r = r × 10^(-k)
    If k is greater than 0:
        Note: Multiply s by 10^k
        Let power_count be 0
        While power_count is less than k:
            bigint_multiply_small(s, bigint_size, 10, temp)
            Let i be 0
            While i is less than bigint_size:
                Let word be memory_get_int64(temp, i multiplied by 8)
                memory_set_int64(s, i multiplied by 8, word)
                Set i to i plus 1
            End While
            Set power_count to power_count plus 1
        End While
    End If
    If k is less than 0:
        Note: Multiply r by 10^(-k)
        Let neg_k be 0 minus k
        Let power_count be 0
        While power_count is less than neg_k:
            bigint_multiply_small(r, bigint_size, 10, temp)
            Let i be 0
            While i is less than bigint_size:
                Let word be memory_get_int64(temp, i multiplied by 8)
                memory_set_int64(r, i multiplied by 8, word)
                Set i to i plus 1
            End While
            Set power_count to power_count plus 1
        End While
    End If

    Note: Fine-tune k: adjust if r/s is not in [0.1, 1.0)
    Note: If r >= s: multiply s by 10, increment k
    Note: If 10*r < s: multiply r by 10, decrement k
    While bigint_compare(r, s, bigint_size) is greater than or equal to 0:
        bigint_multiply_small(s, bigint_size, 10, temp)
        Let i be 0
        While i is less than bigint_size:
            Let word be memory_get_int64(temp, i multiplied by 8)
            memory_set_int64(s, i multiplied by 8, word)
            Set i to i plus 1
        End While
        Set k to k plus 1
    End While

    Note: Step 4: Extract decimal digits using Dragon4 core algorithm
    Note: digit = floor(10*r / s), then r = 10*r - digit*s
    Let digit_buffer be scratch_ptr plus 56
    Let digit_count be 0

    Note: Extract up to 36 decimal digits
    While digit_count is less than 36:
        Note: Multiply r by 10
        bigint_multiply_small(r, bigint_size, 10, temp)
        Let i be 0
        While i is less than bigint_size:
            Let word be memory_get_int64(temp, i multiplied by 8)
            memory_set_int64(r, i multiplied by 8, word)
            Set i to i plus 1
        End While

        Note: Extract digit: digit = floor(r / s)
        Note: Use proper multi-precision division (TRUE Dragon4)
        Let quotient_ptr be allocate(bigint_size multiplied by 8)
        Let remainder_ptr be allocate(bigint_size multiplied by 8)

        Note: Divide: r / s -> quotient and remainder
        bigint_divide(r, bigint_size, s, bigint_size, quotient_ptr, remainder_ptr)

        Note: Extract single decimal digit (quotient should be 0-9 after multiplying r by 10)
        Let digit be memory_get_int64(quotient_ptr, 0)
        Note: Digit must be 0-9 for valid Dragon4 output
        If digit is greater than 9:
            Set digit to 9
        End If

        Note: Update r = remainder for next iteration
        Set i to 0
        While i is less than bigint_size:
            Let remainder_word be memory_get_int64(remainder_ptr, i multiplied by 8)
            memory_set_int64(r, i multiplied by 8, remainder_word)
            Set i to i plus 1
        End While


        Note: Store digit
        memory_set_int8(digit_buffer, digit_count, digit)
        Set digit_count to digit_count plus 1

        Note: Stop if remainder is zero or we have enough digits
        If bigint_is_zero(r, bigint_size) is equal to 1:
            Set digit_count to digit_count
        End If
        If digit_count is greater than or equal to 34:
            Set digit_count to 34
        End If
    End While

    Note: Step 5: Format output as scientific notation
    Note: Format: [-]d.ddddddddE±eeee
    Let pos be 0

    Note: Write sign
    If sign is equal to 1:
        memory_set_int8(buffer_ptr, pos, 45)  Note: '-'
        Set pos to pos plus 1
    End If

    Note: Write first digit
    Let first_digit be memory_get_int8(digit_buffer, 0)
    memory_set_int8(buffer_ptr, pos, 48 plus first_digit)  Note: '0' + digit
    Set pos to pos plus 1

    Note: Write decimal point
    memory_set_int8(buffer_ptr, pos, 46)  Note: '.'
    Set pos to pos plus 1

    Note: Write remaining significant digits
    Let digits_written be 1
    While digits_written is less than digit_count:
        Let digit be memory_get_int8(digit_buffer, digits_written)
        memory_set_int8(buffer_ptr, pos, 48 plus digit)
        Set pos to pos plus 1
        Set digits_written to digits_written plus 1
    End While

    Note: Write exponent
    memory_set_int8(buffer_ptr, pos, 69)  Note: 'E'
    Set pos to pos plus 1

    Note: Write exponent sign and value
    If k is less than 0:
        memory_set_int8(buffer_ptr, pos, 45)  Note: '-'
        Set pos to pos plus 1
        Set k to 0 minus k
    End If
    Otherwise:
        memory_set_int8(buffer_ptr, pos, 43)  Note: '+'
        Set pos to pos plus 1
    End If

    Note: Write exponent digits
    Let exp_digit4 be k divided by 10000
    Set k to k minus exp_digit4 multiplied by 10000
    Let exp_digit3 be k divided by 1000
    Set k to k minus exp_digit3 multiplied by 1000
    Let exp_digit2 be k divided by 100
    Set k to k minus exp_digit2 multiplied by 100
    Let exp_digit1 be k divided by 10
    Let exp_digit0 be k minus exp_digit1 multiplied by 10

    If exp_digit4 is not equal to 0:
        memory_set_int8(buffer_ptr, pos, 48 plus exp_digit4)
        Set pos to pos plus 1
    End If
    If exp_digit3 is not equal to 0:
        memory_set_int8(buffer_ptr, pos, 48 plus exp_digit3)
        Set pos to pos plus 1
    End If
    If exp_digit2 is not equal to 0:
        memory_set_int8(buffer_ptr, pos, 48 plus exp_digit2)
        Set pos to pos plus 1
    End If
    memory_set_int8(buffer_ptr, pos, 48 plus exp_digit1)
    Set pos to pos plus 1
    memory_set_int8(buffer_ptr, pos, 48 plus exp_digit0)
    Set pos to pos plus 1

    Note: Null terminator
    memory_set_int8(buffer_ptr, pos, 0)

    Note: Cleanup




    Return pos
End Process

Process called "float128_from_string" takes str_ptr as Integer, result_ptr as Integer returns Integer:
    Note: Parse decimal string to Float128
    Note: Returns 1 on success, 0 on failure
    Note: Accepts formats: [-]d.ddd, [-]d.dddEee, NaN, Inf

    Note: Check for special strings
    Let first_char be memory_get_int8(str_ptr, 0)

    Note: Check for "NaN"
    If first_char is equal to 78:  Note: 'N'
        Let second_char be memory_get_int8(str_ptr, 1)
        If second_char is equal to 97:  Note: 'a'
            Let third_char be memory_get_int8(str_ptr, 2)
            If third_char is equal to 78:  Note: 'N'
                float128_pack(0, 32767, 1, 0, result_ptr)
                Return 1
            End If
        End If
    End If

    Note: Check for "Inf" or "-Inf"
    Let is_negative be 0
    Let offset be 0
    If first_char is equal to 45:  Note: '-'
        Set is_negative to 1
        Set offset to 1
        Set first_char to memory_get_int8(str_ptr, offset)
    End If

    If first_char is equal to 73:  Note: 'I'
        Let second_char be memory_get_int8(str_ptr, offset plus 1)
        If second_char is equal to 110:  Note: 'n'
            float128_pack(is_negative, 32767, 0, 0, result_ptr)
            Return 1
        End If
    End If

    Note: Check for "0" or "0.0"
    If first_char is equal to 48:  Note: '0'
        Let next_char be memory_get_int8(str_ptr, offset plus 1)
        If next_char is equal to 0:
            Note: Just "0"
            float128_pack(is_negative, 0, 0, 0, result_ptr)
            Return 1
        End If
        If next_char is equal to 46:  Note: '.'
            Let after_dot be memory_get_int8(str_ptr, offset plus 2)
            If after_dot is equal to 48:  Note: "0.0"
                float128_pack(is_negative, 0, 0, 0, result_ptr)
                Return 1
            End If
        End If
    End If

    Note: ========================================================================
    Note: PROPER DECIMAL-TO-BINARY CONVERSION
    Note: Algorithm: Multi-precision integer arithmetic (inverse of Dragon4)
    Note: ========================================================================

    Note: Step 1: Parse decimal string into components
    Note: Format: [-]ddd[.ddd][E[+-]eee]
    Note: Examples: "3.14159", "1.23e-45", "-9.876e+100"

    Note: Already parsed sign and is_negative is set
    Let pos be offset

    Note: Parse integer part digits
    Let int_digit_buffer be scratch_ptr
    Let int_digit_count be 0
    While pos is less than str_len:
        Let ch be memory_get_int8(str_ptr, pos)
        If ch is greater than or equal to 48:
            If ch is less than or equal to 57:  Note: '0'-'9'
                memory_set_int8(int_digit_buffer, int_digit_count, ch minus 48)
                Set int_digit_count to int_digit_count plus 1
                Set pos to pos plus 1
            Otherwise:
                break
            End If
        Otherwise:
            break
        End If
    End While

    Note: Check for decimal point
    Let frac_digit_buffer be scratch_ptr plus 100
    Let frac_digit_count be 0
    Let ch be memory_get_int8(str_ptr, pos)
    If ch is equal to 46:  Note: '.'
        Set pos to pos plus 1
        While pos is less than str_len:
            Set ch to memory_get_int8(str_ptr, pos)
            If ch is greater than or equal to 48:
                If ch is less than or equal to 57:
                    memory_set_int8(frac_digit_buffer, frac_digit_count, ch minus 48)
                    Set frac_digit_count to frac_digit_count plus 1
                    Set pos to pos plus 1
                Otherwise:
                    break
                End If
            Otherwise:
                break
            End If
        End While
    End If

    Note: Check for exponent
    Let exponent_value be 0
    Let exponent_negative be 0
    Set ch to memory_get_int8(str_ptr, pos)
    If ch is equal to 69:  Note: 'E'
        Set pos to pos plus 1
        Set ch to memory_get_int8(str_ptr, pos)
        If ch is equal to 45:  Note: '-'
            Set exponent_negative to 1
            Set pos to pos plus 1
        End If
        If ch is equal to 43:  Note: '+'
            Set pos to pos plus 1
        End If
        While pos is less than str_len:
            Set ch to memory_get_int8(str_ptr, pos)
            If ch is greater than or equal to 48:
                If ch is less than or equal to 57:
                    Set exponent_value to exponent_value multiplied by 10
                    Set exponent_value to exponent_value plus ch minus 48
                    Set pos to pos plus 1
                Otherwise:
                    break
                End If
            Otherwise:
                break
            End If
        End While
        If exponent_negative is equal to 1:
            Set exponent_value to 0 minus exponent_value
        End If
    End If

    Note: Step 2: Build multi-precision integer from decimal digits
    Note: Value = (integer_part + fractional_part / 10^frac_digits) * 10^exponent
    Note: We'll compute: significand * 10^scale_exponent

    Let bigint_size be 8
    Let significand be bigint_create(bigint_size)

    Note: Build integer from decimal digits: significand = int_digits * 10^frac_digits + frac_digits
    Let digit_idx be 0
    While digit_idx is less than int_digit_count:
        Let digit be memory_get_int8(int_digit_buffer, digit_idx)
        bigint_multiply_small(significand, bigint_size, 10, significand)
        Let i be 0
        Let carry be digit
        While i is less than bigint_size:
            Let word be memory_get_int64(significand, i multiplied by 8)
            Set word to word plus carry
            memory_set_int64(significand, i multiplied by 8, word)
            If word is greater than or equal to carry:
                Set carry to 0
                break
            End If
            Set carry to 1
            Set i to i plus 1
        End While
        Set digit_idx to digit_idx plus 1
    End While

    Set digit_idx to 0
    While digit_idx is less than frac_digit_count:
        Let digit be memory_get_int8(frac_digit_buffer, digit_idx)
        bigint_multiply_small(significand, bigint_size, 10, significand)
        Set i to 0
        Let carry be digit
        While i is less than bigint_size:
            Let word be memory_get_int64(significand, i multiplied by 8)
            Set word to word plus carry
            memory_set_int64(significand, i multiplied by 8, word)
            If word is greater than or equal to carry:
                Set carry to 0
                break
            End If
            Set carry to 1
            Set i to i plus 1
        End While
        Set digit_idx to digit_idx plus 1
    End While

    Note: Compute decimal scale: scale = exponent - frac_digit_count
    Let decimal_scale be exponent_value minus frac_digit_count

    Note: Step 3: Convert significand to binary with proper scaling
    Note: If scale > 0: multiply by 10^scale
    Note: If scale < 0: divide by 10^(-scale)

    If decimal_scale is greater than 0:
        Note: Multiply significand by 10^decimal_scale
        Let scale_remaining be decimal_scale
        While scale_remaining is greater than 0:
            bigint_multiply_small(significand, bigint_size, 10, significand)
            Set scale_remaining to scale_remaining minus 1
        End While
    End If

    Note: Now we have binary significand in multi-precision form
    Note: Need to normalize to 112-bit mantissa and compute exponent

    Note: Step 4: Find most significant bit position
    Let msb_word_idx be bigint_size minus 1
    While msb_word_idx is greater than 0:
        Let word be memory_get_int64(significand, msb_word_idx multiplied by 8)
        If word is not equal to 0:
            break
        End If
        Set msb_word_idx to msb_word_idx minus 1
    End While

    Let msb_word be memory_get_int64(significand, msb_word_idx multiplied by 8)
    If msb_word is equal to 0:
        Note: Significand is zero (shouldn't happen if parsing worked)
        float128_pack(is_negative, 0, 0, 0, result_ptr)



        Return 1
    End If

    Note: Count leading zeros in MSB word
    Let leading_zeros be 0
    Let test_bit be 9223372036854775808
    While test_bit is greater than 0:
        If bitwise_and(msb_word, test_bit) is not equal to 0:
            break
        End If
        Set leading_zeros to leading_zeros plus 1
        Set test_bit to right_shift(test_bit, 1)
    End While

    Note: Compute binary exponent: bit position of MSB
    Let binary_exponent be msb_word_idx multiplied by 64
    Set binary_exponent to binary_exponent plus 63 minus leading_zeros

    Note: Handle negative decimal scale (division by 10^n)
    If decimal_scale is less than 0:
        Note: We need to divide significand by 10^(-decimal_scale)
        Note: Equivalent to shifting binary exponent down
        Let scale_remaining be 0 minus decimal_scale
        While scale_remaining is greater than 0:
            Note: Divide by 10 using multi-precision division
            Let quotient_ptr be allocate(bigint_size multiplied by 8)
            Let remainder_ptr be allocate(bigint_size multiplied by 8)
            Let divisor_ptr be allocate(bigint_size multiplied by 8)
            memory_set_int64(divisor_ptr, 0, 10)
            Set i to 1
            While i is less than bigint_size:
                memory_set_int64(divisor_ptr, i multiplied by 8, 0)
                Set i to i plus 1
            End While

            bigint_divide(significand, bigint_size, divisor_ptr, bigint_size, quotient_ptr, remainder_ptr)

            Note: Copy quotient back to significand
            Set i to 0
            While i is less than bigint_size:
                Let word be memory_get_int64(quotient_ptr, i multiplied by 8)
                memory_set_int64(significand, i multiplied by 8, word)
                Set i to i plus 1
            End While



            Set scale_remaining to scale_remaining minus 1
        End While

        Note: Recompute MSB position after division
        Set msb_word_idx to bigint_size minus 1
        While msb_word_idx is greater than 0:
            Set msb_word to memory_get_int64(significand, msb_word_idx multiplied by 8)
            If msb_word is not equal to 0:
                break
            End If
            Set msb_word_idx to msb_word_idx minus 1
        End While

        Set msb_word to memory_get_int64(significand, msb_word_idx multiplied by 8)
        Set leading_zeros to 0
        Set test_bit to 9223372036854775808
        While test_bit is greater than 0:
            If bitwise_and(msb_word, test_bit) is not equal to 0:
                break
            End If
            Set leading_zeros to leading_zeros plus 1
            Set test_bit to right_shift(test_bit, 1)
        End While

        Set binary_exponent to msb_word_idx multiplied by 64
        Set binary_exponent to binary_exponent plus 63 minus leading_zeros
    End If

    Note: Step 5: Extract 112-bit mantissa
    Note: We need bits [binary_exponent : binary_exponent - 111]
    Note: MSB (implicit 1) is at position binary_exponent

    Let mant_high be 0
    Let mant_low be 0

    Note: Determine which words contain our mantissa bits
    Let bit_pos be binary_exponent minus 1
    Let bits_extracted be 0

    While bits_extracted is less than 112:
        Let word_idx be bit_pos divided by 64
        Let bit_in_word be bit_pos modulo 64
        If word_idx is less than bigint_size:
            Let word be memory_get_int64(significand, word_idx multiplied by 8)
            Let bit_value be bitwise_and(right_shift(word, bit_in_word), 1)
            If bits_extracted is less than 48:
                Note: Building mant_high (upper 48 bits)
                Let shift be 47 minus bits_extracted
                Set mant_high to bitwise_or(mant_high, left_shift(bit_value, shift))
            Otherwise:
                Note: Building mant_low (lower 64 bits)
                Let shift be 111 minus bits_extracted
                Set mant_low to bitwise_or(mant_low, left_shift(bit_value, shift))
            End If
        End If
        Set bits_extracted to bits_extracted plus 1
        Set bit_pos to bit_pos minus 1
    End While

    Note: Step 6: Compute IEEE 754 exponent (biased)
    Let ieee_exponent be binary_exponent plus 16383

    Note: Check for overflow/underflow
    If ieee_exponent is greater than or equal to 32767:
        Note: Overflow to infinity
        float128_pack(is_negative, 32767, 0, 0, result_ptr)



        Return 1
    End If

    If ieee_exponent is less than or equal to 0:
        Note: Underflow to zero
        float128_pack(is_negative, 0, 0, 0, result_ptr)



        Return 1
    End If

    Note: Step 7: Pack final Float128
    float128_pack(is_negative, ieee_exponent, mant_high, mant_low, result_ptr)



    Return 1
End Process

Note: ============================================================================
Note: Float128 Type Conversions (Float32/Float64 ↔ Float128)
Note: ============================================================================

Process called "float128_to_float64" takes f128_ptr as Integer, f64_ptr as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 48 bytes (32 for unpack + 16 for rounding)
    Note: Convert Float128 to Float64 (binary64)
    Note: Format: Float64 = 1 sign, 11 exponent bits (bias 1023), 52 mantissa bits
    Note: May lose precision, uses current rounding mode

    Let sign_ptr be scratch_ptr
    Let exp_ptr be scratch_ptr plus 8
    Let mant_high_ptr be scratch_ptr plus 16
    Let mant_low_ptr be scratch_ptr plus 24
    Let rounded_high_ptr be scratch_ptr plus 32
    Let rounded_low_ptr be scratch_ptr plus 40

    Note: Unpack Float128
    float128_unpack(f128_ptr, sign_ptr, exp_ptr, mant_high_ptr, mant_low_ptr)

    Let sign be memory_get_int64(sign_ptr, 0)
    Let exp128 be memory_get_int64(exp_ptr, 0)
    Let mant_high be memory_get_int64(mant_high_ptr, 0)
    Let mant_low be memory_get_int64(mant_low_ptr, 0)

    Note: Handle special cases
    If exp128 is equal to 32767:
        Note: NaN or Infinity
        If mant_high is not equal to 0:
            Note: NaN - Float64 NaN: exp=2047, mantissa=non-zero
            Let f64_bits be 9221120237041090560
            If sign is equal to 1:
                Set f64_bits to bitwise_or(f64_bits, 9223372036854775808)
            End If
            memory_set_int64(f64_ptr, 0, f64_bits)
            Return
        End If
        If mant_low is not equal to 0:
            Let f64_bits be 9221120237041090560
            If sign is equal to 1:
                Set f64_bits to bitwise_or(f64_bits, 9223372036854775808)
            End If
            memory_set_int64(f64_ptr, 0, f64_bits)
            Return
        End If
        Note: Infinity - Float64 Inf: exp=2047, mantissa=0
        Let f64_bits be 9218868437227405312
        If sign is equal to 1:
            Set f64_bits to bitwise_or(f64_bits, 9223372036854775808)
        End If
        memory_set_int64(f64_ptr, 0, f64_bits)
        Return
    End If

    If exp128 is equal to 0:
        If mant_high is equal to 0:
            If mant_low is equal to 0:
                Note: Zero - Float64 zero: all bits zero except sign
                Let f64_bits be 0
                If sign is equal to 1:
                    Set f64_bits to 9223372036854775808
                End If
                memory_set_int64(f64_ptr, 0, f64_bits)
                Return
            End If
        End If
        Note: Subnormal Float128 - likely underflows to Float64 zero
        Let f64_bits be 0
        If sign is equal to 1:
            Set f64_bits to 9223372036854775808
        End If
        memory_set_int64(f64_ptr, 0, f64_bits)
        Return
    End If

    Note: Convert exponent: Float128 bias=16383, Float64 bias=1023
    Let exp64 be exp128 minus 16383 plus 1023

    Note: Check for overflow/underflow
    If exp64 is greater than or equal to 2047:
        Note: Overflow to infinity
        Let f64_bits be 9218868437227405312
        If sign is equal to 1:
            Set f64_bits to bitwise_or(f64_bits, 9223372036854775808)
        End If
        memory_set_int64(f64_ptr, 0, f64_bits)
        Return
    End If

    If exp64 is less than or equal to 0:
        Note: Underflow to zero
        Let f64_bits be 0
        If sign is equal to 1:
            Set f64_bits to 9223372036854775808
        End If
        memory_set_int64(f64_ptr, 0, f64_bits)
        Return
    End If

    Note: Round 112-bit mantissa to 52 bits
    Note: Float128 mantissa: 48 bits (mant_high) + 64 bits (mant_low) = 112 bits
    Note: Float64 mantissa: 52 bits
    Note: Need to extract bits [111:60] with rounding

    Note: Extract 52 mantissa bits from mant_high and mant_low
    Let mant64 be mant_high
    Let extra_bits be right_shift(mant_low, 60)
    Set mant64 to left_shift(mant64, 4)
    Set mant64 to bitwise_or(mant64, extra_bits)

    Note: Extract rounding bits: guard (bit 59), round (bit 58), sticky (bits 57:0)
    Let guard_bit be bitwise_and(right_shift(mant_low, 59), 1)
    Let round_bit be bitwise_and(right_shift(mant_low, 58), 1)
    Let sticky_bits be bitwise_and(mant_low, 288230376151711743)
    Let sticky_bit be 0
    If sticky_bits is not equal to 0:
        Set sticky_bit to 1
    End If

    Note: Apply rounding using float128_round_mantissa
    Let overflow be float128_round_mantissa(sign, 0, mant64, guard_bit, round_bit, sticky_bit, rounded_high_ptr, rounded_low_ptr)

    Let rounded_mant be memory_get_int64(rounded_low_ptr, 0)

    If overflow is equal to 1:
        Set exp64 to exp64 plus 1
        If exp64 is greater than or equal to 2047:
            Note: Overflow after rounding
            Let f64_bits be 9218868437227405312
            If sign is equal to 1:
                Set f64_bits to bitwise_or(f64_bits, 9223372036854775808)
            End If
            memory_set_int64(f64_ptr, 0, f64_bits)
            Return
        End If
        Set rounded_mant to right_shift(rounded_mant, 1)
    End If

    Note: Pack Float64: [sign:1][exp:11][mantissa:52]
    Let f64_bits be 0
    If sign is equal to 1:
        Set f64_bits to 9223372036854775808
    End If
    Let exp_shifted be left_shift(exp64, 52)
    Set f64_bits to bitwise_or(f64_bits, exp_shifted)
    Set f64_bits to bitwise_or(f64_bits, rounded_mant)

    memory_set_int64(f64_ptr, 0, f64_bits)
End Process

Process called "float128_to_float32" takes f128_ptr as Integer, f32_ptr as Integer, scratch_ptr as Integer:
    Note: SCRATCH SPACE REQUIRED: 48 bytes (32 for unpack + 16 for rounding)
    Note: Convert Float128 to Float32 (binary32)
    Note: Format: Float32 = 1 sign, 8 exponent bits (bias 127), 23 mantissa bits
    Note: Significant precision loss, uses current rounding mode

    Let sign_ptr be scratch_ptr
    Let exp_ptr be scratch_ptr plus 8
    Let mant_high_ptr be scratch_ptr plus 16
    Let mant_low_ptr be scratch_ptr plus 24
    Let rounded_high_ptr be scratch_ptr plus 32
    Let rounded_low_ptr be scratch_ptr plus 40

    Note: Unpack Float128
    float128_unpack(f128_ptr, sign_ptr, exp_ptr, mant_high_ptr, mant_low_ptr)

    Let sign be memory_get_int64(sign_ptr, 0)
    Let exp128 be memory_get_int64(exp_ptr, 0)
    Let mant_high be memory_get_int64(mant_high_ptr, 0)
    Let mant_low be memory_get_int64(mant_low_ptr, 0)

    Note: Handle special cases
    If exp128 is equal to 32767:
        Note: NaN or Infinity
        If mant_high is not equal to 0:
            Note: NaN - Float32 NaN: exp=255, mantissa=non-zero
            Let f32_bits be 2143289344
            If sign is equal to 1:
                Set f32_bits to bitwise_or(f32_bits, 2147483648)
            End If
            memory_set_int32(f32_ptr, 0, f32_bits)
            Return
        End If
        If mant_low is not equal to 0:
            Let f32_bits be 2143289344
            If sign is equal to 1:
                Set f32_bits to bitwise_or(f32_bits, 2147483648)
            End If
            memory_set_int32(f32_ptr, 0, f32_bits)
            Return
        End If
        Note: Infinity - Float32 Inf: exp=255, mantissa=0
        Let f32_bits be 2139095040
        If sign is equal to 1:
            Set f32_bits to bitwise_or(f32_bits, 2147483648)
        End If
        memory_set_int32(f32_ptr, 0, f32_bits)
        Return
    End If

    If exp128 is equal to 0:
        If mant_high is equal to 0:
            If mant_low is equal to 0:
                Note: Zero
                Let f32_bits be 0
                If sign is equal to 1:
                    Set f32_bits to 2147483648
                End If
                memory_set_int32(f32_ptr, 0, f32_bits)
                Return
            End If
        End If
        Note: Subnormal - likely underflows to Float32 zero
        Let f32_bits be 0
        If sign is equal to 1:
            Set f32_bits to 2147483648
        End If
        memory_set_int32(f32_ptr, 0, f32_bits)
        Return
    End If

    Note: Convert exponent: Float128 bias=16383, Float32 bias=127
    Let exp32 be exp128 minus 16383 plus 127

    Note: Check for overflow/underflow
    If exp32 is greater than or equal to 255:
        Note: Overflow to infinity
        Let f32_bits be 2139095040
        If sign is equal to 1:
            Set f32_bits to bitwise_or(f32_bits, 2147483648)
        End If
        memory_set_int32(f32_ptr, 0, f32_bits)
        Return
    End If

    If exp32 is less than or equal to 0:
        Note: Underflow to zero
        Let f32_bits be 0
        If sign is equal to 1:
            Set f32_bits to 2147483648
        End If
        memory_set_int32(f32_ptr, 0, f32_bits)
        Return
    End If

    Note: Round 112-bit mantissa to 23 bits
    Note: Need to extract top 23 bits from 112-bit mantissa
    Let mant32 be right_shift(mant_high, 25)

    Note: Extract rounding bits
    Let guard_bit be bitwise_and(right_shift(mant_high, 24), 1)
    Let round_bit be bitwise_and(right_shift(mant_high, 23), 1)
    Let sticky_mask be 8388607
    Let sticky_bits be bitwise_and(mant_high, sticky_mask)
    Let sticky_bit be 0
    If sticky_bits is not equal to 0:
        Set sticky_bit to 1
    End If
    If mant_low is not equal to 0:
        Set sticky_bit to 1
    End If

    Note: Apply rounding
    Let overflow be float128_round_mantissa(sign, 0, mant32, guard_bit, round_bit, sticky_bit, rounded_high_ptr, rounded_low_ptr)

    Let rounded_mant be memory_get_int64(rounded_low_ptr, 0)

    If overflow is equal to 1:
        Set exp32 to exp32 plus 1
        If exp32 is greater than or equal to 255:
            Let f32_bits be 2139095040
            If sign is equal to 1:
                Set f32_bits to bitwise_or(f32_bits, 2147483648)
            End If
            memory_set_int32(f32_ptr, 0, f32_bits)
            Return
        End If
        Set rounded_mant to right_shift(rounded_mant, 1)
    End If

    Note: Pack Float32: [sign:1][exp:8][mantissa:23]
    Let f32_bits be 0
    If sign is equal to 1:
        Set f32_bits to 2147483648
    End If
    Let exp_shifted be left_shift(exp32, 23)
    Set f32_bits to bitwise_or(f32_bits, exp_shifted)
    Set f32_bits to bitwise_or(f32_bits, rounded_mant)

    memory_set_int32(f32_ptr, 0, f32_bits)
End Process

Process called "float64_to_float128" takes f64_ptr as Integer, f128_ptr as Integer:
    Note: Convert Float64 to Float128 (lossless promotion)
    Note: Float64: 1 sign, 11 exp (bias 1023), 52 mantissa bits
    Note: Float128: 1 sign, 15 exp (bias 16383), 112 mantissa bits

    Let f64_bits be memory_get_int64(f64_ptr, 0)

    Note: Extract Float64 components
    Let sign be bitwise_and(right_shift(f64_bits, 63), 1)
    Let exp64 be bitwise_and(right_shift(f64_bits, 52), 2047)
    Let mant64 be bitwise_and(f64_bits, 4503599627370495)

    Note: Handle special cases
    If exp64 is equal to 2047:
        Note: NaN or Infinity
        If mant64 is not equal to 0:
            Note: NaN
            float128_pack(sign, 32767, 1, 0, f128_ptr)
            Return
        End If
        Note: Infinity
        float128_pack(sign, 32767, 0, 0, f128_ptr)
        Return
    End If

    If exp64 is equal to 0:
        If mant64 is equal to 0:
            Note: Zero
            float128_pack(sign, 0, 0, 0, f128_ptr)
            Return
        End If
        Note: Subnormal Float64 - normalize it for Float128
        Note: Find leading 1 in mantissa
        Let shift_count be 0
        While shift_count is less than 52:
            Let test_bit be left_shift(1, 51 minus shift_count)
            If bitwise_and(mant64, test_bit) is not equal to 0:
                break
            End If
            Set shift_count to shift_count plus 1
        End While

        Note: Normalize mantissa
        Set mant64 to left_shift(mant64, shift_count plus 1)
        Set mant64 to bitwise_and(mant64, 4503599627370495)

        Note: Adjust exponent: subnormal exp64=0 means actual exp = 1 - 1023 = -1022
        Let exp128 be 1 minus 1023 minus shift_count plus 16383
        If exp128 is less than 1:
            Set exp128 to 1
        End If

        Note: Shift mantissa to 112-bit format (52 bits → 112 bits, shift left by 60)
        Let mant_high be right_shift(mant64, 4)
        Let mant_low be left_shift(mant64, 60)

        float128_pack(sign, exp128, mant_high, mant_low, f128_ptr)
        Return
    End If

    Note: Normal Float64 - promote to Float128
    Note: Convert exponent: Float64 bias=1023, Float128 bias=16383
    Let exp128 be exp64 minus 1023 plus 16383

    Note: Extend 52-bit mantissa to 112 bits
    Note: Float64 mantissa is 52 bits, Float128 mantissa is 112 bits
    Note: Shift left by 60 bits: 112 - 52 = 60
    Let mant_high be right_shift(mant64, 4)
    Let mant_low be left_shift(mant64, 60)

    float128_pack(sign, exp128, mant_high, mant_low, f128_ptr)
End Process

Process called "float32_to_float128" takes f32_ptr as Integer, f128_ptr as Integer:
    Note: Convert Float32 to Float128 (lossless promotion)
    Note: Float32: 1 sign, 8 exp (bias 127), 23 mantissa bits
    Note: Float128: 1 sign, 15 exp (bias 16383), 112 mantissa bits

    Let f32_bits be memory_get_int32(f32_ptr, 0)

    Note: Extract Float32 components
    Let sign be bitwise_and(right_shift(f32_bits, 31), 1)
    Let exp32 be bitwise_and(right_shift(f32_bits, 23), 255)
    Let mant32 be bitwise_and(f32_bits, 8388607)

    Note: Handle special cases
    If exp32 is equal to 255:
        Note: NaN or Infinity
        If mant32 is not equal to 0:
            Note: NaN
            float128_pack(sign, 32767, 1, 0, f128_ptr)
            Return
        End If
        Note: Infinity
        float128_pack(sign, 32767, 0, 0, f128_ptr)
        Return
    End If

    If exp32 is equal to 0:
        If mant32 is equal to 0:
            Note: Zero
            float128_pack(sign, 0, 0, 0, f128_ptr)
            Return
        End If
        Note: Subnormal Float32 - normalize it for Float128
        Let shift_count be 0
        While shift_count is less than 23:
            Let test_bit be left_shift(1, 22 minus shift_count)
            If bitwise_and(mant32, test_bit) is not equal to 0:
                break
            End If
            Set shift_count to shift_count plus 1
        End While

        Set mant32 to left_shift(mant32, shift_count plus 1)
        Set mant32 to bitwise_and(mant32, 8388607)

        Let exp128 be 1 minus 127 minus shift_count plus 16383
        If exp128 is less than 1:
            Set exp128 to 1
        End If

        Note: Shift 23-bit mantissa to 112-bit format (shift left by 89)
        Let mant_high be left_shift(mant32, 25)
        Let mant_low be 0

        float128_pack(sign, exp128, mant_high, mant_low, f128_ptr)
        Return
    End If

    Note: Normal Float32 - promote to Float128
    Let exp128 be exp32 minus 127 plus 16383

    Note: Extend 23-bit mantissa to 112 bits (shift left by 89)
    Let mant_high be left_shift(mant32, 25)
    Let mant_low be 0

    float128_pack(sign, exp128, mant_high, mant_low, f128_ptr)
End Process