Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles bitwise operations and bit manipulation primitives.

This file performs the following tasks:
- Process bitwise operations (AND, OR, XOR, NOT, shift operations)
- Handle bit manipulation and bit field operations
- Manage bitwise optimization and bitwise constant folding
- Process bitwise type handling and bitwise conversion

This file is essential because of the following reasons:
- Bitwise operations are fundamental to low-level programming and system operations
- Proper bitwise handling enables efficient bit manipulation and system programming
- Bitwise optimization improves performance for bit-level operations

This file consists of the following functions/features/operation types:
- Bitwise operation processing and bit manipulation handling
- Bit field operations and bit manipulation primitives
- Bitwise optimization and bitwise constant folding
- Bitwise type handling and bitwise conversion processing

Dependencies:
- memory/layout.runa (for bit array allocation)
:End Note

Import "compiler/frontend/primitives/memory/layout.runa" as MemoryLayout

Note: ============================================================================
Note: Core Bitwise Operations (Layer 2) - Platform Independent
Note: ============================================================================

Note: These primitives use Canon syntax operators that work on ALL platforms.
Note: The compiler lowers these to appropriate platform-specific instructions:
Note: - x86_64: andq, orq, xorq, notq, shlq, sarq, shrq
Note: - ARM64: and, orr, eor, mvn, lsl, asr, lsr
Note: - RISC-V: and, or, xor, not, sll, sra, srl
Note: - PowerPC: and, or, xor, nor, slw, sraw, srw
Note: - MIPS: and, or, xor, nor, sll, sra, srl
Note: ============================================================================

Process called "bitwise_and" takes a as Integer, b as Integer returns Integer:
    Note: Bitwise AND operation
    Note: Canon syntax: a bitwise and b
    Note: Developer syntax: a & b
    Note: Platform independent - works on all architectures
    Return a bitwise and b
End Process

Process called "bitwise_or" takes a as Integer, b as Integer returns Integer:
    Note: Bitwise OR operation
    Note: Canon syntax: a bitwise or b
    Note: Developer syntax: a | b
    Note: Platform independent - works on all architectures
    Return a bitwise or b
End Process

Process called "bitwise_xor" takes a as Integer, b as Integer returns Integer:
    Note: Bitwise XOR operation
    Note: Canon syntax: a bitwise xor b
    Note: Developer syntax: a ^ b
    Note: Platform independent - works on all architectures
    Return a bitwise xor b
End Process

Process called "bitwise_not" takes a as Integer returns Integer:
    Note: Bitwise NOT operation (one's complement)
    Note: Canon syntax: bitwise not a
    Note: Developer syntax: ~a
    Note: Platform independent - works on all architectures
    Return bitwise not a
End Process

Process called "left_shift" takes a as Integer, count as Integer returns Integer:
    Note: Left shift operation
    Note: Canon syntax: a shifted left by count
    Note: Developer syntax: a << count
    Note: Platform independent - works on all architectures
    Return a shifted left by count
End Process

Process called "right_shift" takes a as Integer, count as Integer returns Integer:
    Note: Arithmetic right shift operation (sign-extended)
    Note: Canon syntax: a shifted right by count
    Note: Developer syntax: a >> count
    Note: Platform independent - works on all architectures
    Return a shifted right by count
End Process

Process called "right_shift_logical" takes a as Integer, count as Integer returns Integer:
    Note: Logical right shift operation (zero-filled)
    Note: Canon syntax: a shifted right logical by count
    Note: Developer syntax: a >>> count (when supported)
    Note: Platform independent - works on all architectures
    Return a shifted right logical by count
End Process

Note: ============================================================================
Note: Bit Manipulation Utilities
Note: ============================================================================

Process called "get_bit" takes value as Integer, bit_index as Integer returns Integer:
    Note: Get the value of a specific bit (0 or 1)
    Note: Returns (value >> bit_index) & 1
    Note: Platform independent - uses Canon syntax

    Let shifted be value shifted right by bit_index
    Let result be shifted bitwise and 1
    Return result
End Process

Process called "set_bit" takes value as Integer, bit_index as Integer returns Integer:
    Note: Set a specific bit to 1
    Note: Returns value | (1 << bit_index)
    Note: Platform independent - uses Canon syntax

    Let mask be 1 shifted left by bit_index
    Let result be value bitwise or mask
    Return result
End Process

Process called "clear_bit" takes value as Integer, bit_index as Integer returns Integer:
    Note: Clear a specific bit (set to 0)
    Note: Returns value & ~(1 << bit_index)
    Note: Platform independent - uses Canon syntax

    Let mask be 1 shifted left by bit_index
    Let inverted_mask be bitwise not mask
    Let result be value bitwise and inverted_mask
    Return result
End Process

Process called "toggle_bit" takes value as Integer, bit_index as Integer returns Integer:
    Note: Toggle a specific bit (flip 0â†”1)
    Note: Returns value ^ (1 << bit_index)
    Note: Platform independent - uses Canon syntax

    Let mask be 1 shifted left by bit_index
    Let result be value bitwise xor mask
    Return result
End Process

Process called "count_ones" takes value as Integer returns Integer:
    Note: Count the number of 1 bits (population count / popcount)
    Note: Returns number of 1 bits in value
    Note: Compiler intrinsic - maps to platform-specific instruction:
    Note: - x86_64: popcnt (SSE4.2+)
    Note: - ARM64: cnt + addv
    Note: - RISC-V: cpop (Zbb extension) or software loop
    Note: - PowerPC: popcntd
    Note: Platform independent - compiler emits optimal code

    Note: Software fallback if hardware instruction not available
    If value is equal to 0:
        Return 0
    End If

    Let count be 0
    Let temp be value

    Note: Brian Kernighan's algorithm: clears rightmost 1-bit each iteration
    While temp is not equal to 0:
        Set temp to temp bitwise and (temp minus 1)
        Set count to count plus 1
    End While

    Return count
End Process

Process called "count_leading_zeros" takes value as Integer returns Integer:
    Note: Count leading zero bits
    Note: Returns number of 0 bits before first 1 bit (0-63 for 64-bit)
    Note: Compiler intrinsic - maps to platform-specific instruction:
    Note: - x86_64: lzcnt (ABM/BMI) or bsr fallback
    Note: - ARM64: clz
    Note: - RISC-V: clz (Zbb extension)
    Note: - PowerPC: cntlzd
    Note: Platform independent - compiler emits optimal code

    If value is equal to 0:
        Return 64
    End If

    Let count be 0
    Let temp be value

    Note: Binary search algorithm to find first 1-bit
    Let mask be 0xFFFFFFFF00000000
    If (temp bitwise and mask) is equal to 0:
        Set count to count plus 32
        Set temp to temp shifted left by 32
    End If

    Set mask to 0xFFFF000000000000
    If (temp bitwise and mask) is equal to 0:
        Set count to count plus 16
        Set temp to temp shifted left by 16
    End If

    Set mask to 0xFF00000000000000
    If (temp bitwise and mask) is equal to 0:
        Set count to count plus 8
        Set temp to temp shifted left by 8
    End If

    Set mask to 0xF000000000000000
    If (temp bitwise and mask) is equal to 0:
        Set count to count plus 4
        Set temp to temp shifted left by 4
    End If

    Set mask to 0xC000000000000000
    If (temp bitwise and mask) is equal to 0:
        Set count to count plus 2
        Set temp to temp shifted left by 2
    End If

    Set mask to 0x8000000000000000
    If (temp bitwise and mask) is equal to 0:
        Set count to count plus 1
    End If

    Return count
End Process

Process called "count_trailing_zeros" takes value as Integer returns Integer:
    Note: Count trailing zero bits
    Note: Returns number of 0 bits after last 1 bit (0-63 for 64-bit)
    Note: Compiler intrinsic - maps to platform-specific instruction:
    Note: - x86_64: tzcnt (BMI) or bsf fallback
    Note: - ARM64: rbit + clz (reverse bits then count leading zeros)
    Note: - RISC-V: ctz (Zbb extension)
    Note: - PowerPC: cnttzd
    Note: Platform independent - compiler emits optimal code

    If value is equal to 0:
        Return 64
    End If

    Note: Use bit trick: isolate rightmost 1-bit and count leading zeros
    Let isolated be value bitwise and (bitwise not (value minus 1))
    Let leading_zeros be proc count_leading_zeros with isolated
    Return 63 minus leading_zeros
End Process


Note: ============================================================================
Note: Bit Field Operations
Note: ============================================================================

Process called "extract_bit_field" takes value as Integer, start_bit as Integer, bit_count as Integer returns Integer:
    Note: Extract a bit field from value
    Note: Returns bits [start_bit : start_bit+bit_count-1]
    Note: Example: extract_bit_field(0xABCD, 4, 8) extracts middle byte = 0xBC
    Note: Platform independent - uses Canon syntax

    Note: Shift value right to align field at bit 0
    Let shifted be value shifted right by start_bit

    Note: Create mask: (1 << bit_count) - 1
    Let mask_base be 1 shifted left by bit_count
    Let mask be mask_base minus 1

    Note: Apply mask to extract only the field bits
    Let result be shifted bitwise and mask
    Return result
End Process

Process called "insert_bit_field" takes value as Integer, field as Integer, start_bit as Integer, bit_count as Integer returns Integer:
    Note: Insert a bit field into value
    Note: Clears bits [start_bit : start_bit+bit_count-1] and inserts field
    Note: Example: insert_bit_field(0xAB00, 0xCD, 4, 8) = 0xABCD0
    Note: Platform independent - uses Canon syntax

    Note: Step 1: Create mask for the field
    Let mask_base be 1 shifted left by bit_count
    Let mask be mask_base minus 1

    Note: Step 2: Shift mask to position
    Let positioned_mask be mask shifted left by start_bit

    Note: Step 3: Clear bits in value at the target position
    Let inverted_mask be bitwise not positioned_mask
    Let cleared_value be value bitwise and inverted_mask

    Note: Step 4: Shift field to position
    Let positioned_field be field shifted left by start_bit

    Note: Step 5: Insert field into cleared value
    Let result be cleared_value bitwise or positioned_field
    Return result
End Process
