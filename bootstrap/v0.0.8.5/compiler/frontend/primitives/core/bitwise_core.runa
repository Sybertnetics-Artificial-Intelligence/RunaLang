Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles bitwise operations and bit manipulation primitives.

This file performs the following tasks:
- Process bitwise operations (AND, OR, XOR, NOT, shift operations)
- Handle bit manipulation and bit field operations
- Manage bitwise optimization and bitwise constant folding
- Process bitwise type handling and bitwise conversion

This file is essential because of the following reasons:
- Bitwise operations are fundamental to low-level programming and system operations
- Proper bitwise handling enables efficient bit manipulation and system programming
- Bitwise optimization improves performance for bit-level operations

This file consists of the following functions/features/operation types:
- Bitwise operation processing and bit manipulation handling
- Bit field operations and bit manipulation primitives
- Bitwise optimization and bitwise constant folding
- Bitwise type handling and bitwise conversion processing

Dependencies:
- memory/layout.runa (for bit array allocation)
:End Note

Import "compiler/frontend/primitives/memory/layout.runa" as MemoryLayout

Note: ============================================================================
Note: Core Bitwise Operations (Layer 2)
Note: ============================================================================

Note: These primitives provide bitwise operations using inline assembly.
Note: Future: Native operators (a & b, a | b, a ^ b, ~a, a << n, a >> n)
Note: ============================================================================

Process called "bitwise_and" takes a as Integer, b as Integer returns Integer:
    Note: Bitwise AND operation
    Note: Returns a & b

    Let result be 0
    Inline Assembly:
        movq -8(%rbp), %rax      # Load a
        movq -16(%rbp), %rbx     # Load b
        andq %rbx, %rax          # rax = a & b
        movq %rax, -24(%rbp)     # Store result
    End Assembly
    Return result
End Process

Process called "bitwise_or" takes a as Integer, b as Integer returns Integer:
    Note: Bitwise OR operation
    Note: Returns a | b

    Let result be 0
    Inline Assembly:
        movq -8(%rbp), %rax      # Load a
        movq -16(%rbp), %rbx     # Load b
        orq %rbx, %rax           # rax = a | b
        movq %rax, -24(%rbp)     # Store result
    End Assembly
    Return result
End Process

Process called "bitwise_xor" takes a as Integer, b as Integer returns Integer:
    Note: Bitwise XOR operation
    Note: Returns a ^ b

    Let result be 0
    Inline Assembly:
        movq -8(%rbp), %rax      # Load a
        movq -16(%rbp), %rbx     # Load b
        xorq %rbx, %rax          # rax = a ^ b
        movq %rax, -24(%rbp)     # Store result
    End Assembly
    Return result
End Process

Process called "bitwise_not" takes a as Integer returns Integer:
    Note: Bitwise NOT operation
    Note: Returns ~a (one's complement)

    Let result be 0
    Inline Assembly:
        movq -8(%rbp), %rax      # Load a
        notq %rax                # rax = ~a
        movq %rax, -16(%rbp)     # Store result
    End Assembly
    Return result
End Process

Process called "left_shift" takes a as Integer, count as Integer returns Integer:
    Note: Left shift operation
    Note: Returns a << count

    Let result be 0
    Inline Assembly:
        movq -8(%rbp), %rax      # Load a
        movq -16(%rbp), %rcx     # Load count (shift uses CL register)
        shlq %cl, %rax           # rax = a << count
        movq %rax, -24(%rbp)     # Store result
    End Assembly
    Return result
End Process

Process called "right_shift" takes a as Integer, count as Integer returns Integer:
    Note: Arithmetic right shift operation
    Note: Returns a >> count (sign-extended)

    Let result be 0
    Inline Assembly:
        movq -8(%rbp), %rax      # Load a
        movq -16(%rbp), %rcx     # Load count (shift uses CL register)
        sarq %cl, %rax           # rax = a >> count (arithmetic)
        movq %rax, -24(%rbp)     # Store result
    End Assembly
    Return result
End Process

Process called "right_shift_logical" takes a as Integer, count as Integer returns Integer:
    Note: Logical right shift operation
    Note: Returns a >>> count (zero-filled)

    Let result be 0
    Inline Assembly:
        movq -8(%rbp), %rax      # Load a
        movq -16(%rbp), %rcx     # Load count (shift uses CL register)
        shrq %cl, %rax           # rax = a >>> count (logical)
        movq %rax, -24(%rbp)     # Store result
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: Bit Manipulation Utilities
Note: ============================================================================

Process called "get_bit" takes value as Integer, bit_index as Integer returns Integer:
    Note: Get the value of a specific bit (0 or 1)
    Note: Returns (value >> bit_index) & 1

    Let result be 0
    Inline Assembly:
        movq -8(%rbp), %rax      # Load value
        movq -16(%rbp), %rcx     # Load bit_index into CL
        shrq %cl, %rax           # Shift right by bit_index
        andq $1, %rax            # Mask to get only bit 0
        movq %rax, -24(%rbp)     # Store result
    End Assembly
    Return result
End Process

Process called "set_bit" takes value as Integer, bit_index as Integer returns Integer:
    Note: Set a specific bit to 1
    Note: Returns value | (1 << bit_index)

    Let result be 0
    Inline Assembly:
        movq -8(%rbp), %rax      # Load value
        movq -16(%rbp), %rcx     # Load bit_index
        movq $1, %rbx            # rbx = 1
        shlq %cl, %rbx           # rbx = 1 << bit_index
        orq %rbx, %rax           # rax = value | (1 << bit_index)
        movq %rax, -24(%rbp)     # Store result
    End Assembly
    Return result
End Process

Process called "clear_bit" takes value as Integer, bit_index as Integer returns Integer:
    Note: Clear a specific bit (set to 0)
    Note: Returns value & ~(1 << bit_index)

    Let result be 0
    Inline Assembly:
        movq -8(%rbp), %rax      # Load value
        movq -16(%rbp), %rcx     # Load bit_index
        movq $1, %rbx            # rbx = 1
        shlq %cl, %rbx           # rbx = 1 << bit_index
        notq %rbx                # rbx = ~(1 << bit_index)
        andq %rbx, %rax          # rax = value & ~(1 << bit_index)
        movq %rax, -24(%rbp)     # Store result
    End Assembly
    Return result
End Process

Process called "toggle_bit" takes value as Integer, bit_index as Integer returns Integer:
    Note: Toggle a specific bit (flip 0â†”1)
    Note: Returns value ^ (1 << bit_index)

    Let result be 0
    Inline Assembly:
        movq -8(%rbp), %rax      # Load value
        movq -16(%rbp), %rcx     # Load bit_index
        movq $1, %rbx            # rbx = 1
        shlq %cl, %rbx           # rbx = 1 << bit_index
        xorq %rbx, %rax          # rax = value ^ (1 << bit_index)
        movq %rax, -24(%rbp)     # Store result
    End Assembly
    Return result
End Process

Process called "count_ones" takes value as Integer returns Integer:
    Note: Count the number of 1 bits (population count / popcount)
    Note: Returns number of 1 bits in value
    Note: Uses popcnt instruction (requires SSE4.2)

    Let result be 0
    Inline Assembly:
        movq -8(%rbp), %rax      # Load value
        popcnt %rax, %rax        # Count set bits
        movq %rax, -16(%rbp)     # Store result
    End Assembly
    Return result
End Process

Process called "count_leading_zeros" takes value as Integer returns Integer:
    Note: Count leading zero bits
    Note: Returns number of 0 bits before first 1 bit
    Note: Uses lzcnt instruction if available, otherwise bsr fallback

    Let result be 0
    Inline Assembly:
        movq -8(%rbp), %rax      # Load value
        testq %rax, %rax         # Test if zero
        je .Lclz_zero            # If zero, return 64
        lzcnt %rax, %rax         # Count leading zeros
        jmp .Lclz_done
    .Lclz_zero:
        movq $64, %rax           # Value is zero, all 64 bits are leading zeros
    .Lclz_done:
        movq %rax, -16(%rbp)     # Store result
    End Assembly
    Return result
End Process

Process called "count_trailing_zeros" takes value as Integer returns Integer:
    Note: Count trailing zero bits
    Note: Returns number of 0 bits after last 1 bit
    Note: Uses tzcnt instruction if available, otherwise bsf fallback

    Let result be 0
    Inline Assembly:
        movq -8(%rbp), %rax      # Load value
        testq %rax, %rax         # Test if zero
        je .Lctz_zero            # If zero, return 64
        tzcnt %rax, %rax         # Count trailing zeros
        jmp .Lctz_done
    .Lctz_zero:
        movq $64, %rax           # Value is zero, all 64 bits are trailing zeros
    .Lctz_done:
        movq %rax, -16(%rbp)     # Store result
    End Assembly
    Return result
End Process


Note: ============================================================================
Note: Bit Field Operations
Note: ============================================================================

Process called "extract_bit_field" takes value as Integer, start_bit as Integer, bit_count as Integer returns Integer:
    Note: Extract a bit field from value
    Note: Returns bits [start_bit : start_bit+bit_count-1]
    Note: Example: extract_bit_field(0xABCD, 4, 8) extracts middle byte = 0xBC

    Let result be 0
    Inline Assembly:
        movq -8(%rbp), %rax      # Load value
        movq -16(%rbp), %rcx     # Load start_bit
        shrq %cl, %rax           # Shift right by start_bit
        
        # Create mask: (1 << bit_count) - 1
        movq -24(%rbp), %rcx     # Load bit_count
        movq $1, %rbx
        shlq %cl, %rbx           # rbx = 1 << bit_count
        subq $1, %rbx            # rbx = (1 << bit_count) - 1
        
        andq %rbx, %rax          # rax = shifted_value & mask
        movq %rax, -32(%rbp)     # Store result
    End Assembly
    Return result
End Process

Process called "insert_bit_field" takes value as Integer, field as Integer, start_bit as Integer, bit_count as Integer returns Integer:
    Note: Insert a bit field into value
    Note: Clears bits [start_bit : start_bit+bit_count-1] and inserts field
    Note: Example: insert_bit_field(0xAB00, 0xCD, 4, 8) = 0xABCD0

    Let result be 0
    Inline Assembly:
        # Create mask: (1 << bit_count) - 1
        movq -24(%rbp), %rcx     # Load bit_count
        movq $1, %rbx
        shlq %cl, %rbx           # rbx = 1 << bit_count
        subq $1, %rbx            # rbx = mask = (1 << bit_count) - 1
        
        # Shift mask to position
        movq -16(%rbp), %rcx     # Load start_bit
        shlq %cl, %rbx           # rbx = mask << start_bit
        
        # Clear bits in value
        movq -8(%rbp), %rax      # Load value
        notq %rbx                # rbx = ~(mask << start_bit)
        andq %rbx, %rax          # rax = value & ~(mask << start_bit)
        
        # Insert field
        movq -16(%rbp), %rdx     # Load field
        movq -24(%rbp), %rcx     # Load start_bit
        shlq %cl, %rdx           # rdx = field << start_bit
        orq %rdx, %rax           # rax = cleared_value | (field << start_bit)
        
        movq %rax, -32(%rbp)     # Store result
    End Assembly
    Return result
End Process
