Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles arithmetic operations and arithmetic instruction processing.

This file performs the following tasks:
- Process arithmetic operations (addition, subtraction, multiplication, division)
- Handle arithmetic overflow and underflow detection
- Manage arithmetic optimization and arithmetic constant folding
- Process arithmetic type promotion and arithmetic conversion

This file is essential because of the following reasons:
- Arithmetic operations are fundamental to computational programming
- Proper arithmetic handling ensures correct mathematical computation
- Arithmetic optimization improves runtime performance and reduces computation overhead

This file consists of the following functions/features/operation types:
- Arithmetic operation processing and arithmetic instruction handling
- Arithmetic overflow and underflow detection and handling
- Arithmetic optimization and arithmetic constant folding
- Arithmetic type promotion and arithmetic conversion processing

Dependencies:
- NONE (arithmetic operations use native compiler operators)
- Float128 operations use float128_softfloat.runa (custom soft-float library)
:End Note

Import "compiler/frontend/primitives/core/softfloat.runa" as SoftFloat
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
Import "compiler/frontend/primitives/core/bitwise_core.runa" as Bitwise

Note: ============================================================================
Note: Core Arithmetic Operations (Layer 2)
Note: ============================================================================

Note: These primitives provide basic arithmetic operations. The Runa compiler
Note: already supports these natively with operators like "plus", "minus",
Note: "multiplied by", "divided by", and "Modulo by ".

Note: These wrapper functions serve several purposes:
Note: 1. Provide named functions for higher-level primitives
Note: 2. Enable arithmetic overflow/underflow detection (via *_checked variants)
Note: 3. Support potential optimization passes
Note: 4. Document the arithmetic operation interface
Note: ============================================================================

Process called "add" takes a as Integer, b as Integer returns Integer:
    Note: Add two integers
    Note: Returns a + b
    Return a plus b
End Process

Process called "subtract" takes a as Integer, b as Integer returns Integer:
    Note: Subtract b from a
    Note: Returns a - b
    Return a minus b
End Process

Process called "multiply" takes a as Integer, b as Integer returns Integer:
    Note: Multiply two integers
    Note: Returns a * b
    Return a multiplied by b
End Process

Process called "divide" takes a as Integer, b as Integer returns Integer:
    Note: Divide a by b (integer division)
    Note: Returns a / b
    Note: WARNING: Division by zero will cause runtime error
    Return a divided by b
End Process

Process called "Modulo by " takes a as Integer, b as Integer returns Integer:
    Note: Calculate a Modulo by b
    Note: Returns the remainder of a / b
    Note: WARNING: Modulo by zero will cause runtime error
    Return a Modulo by b
End Process

Process called "negate" takes a as Integer returns Integer:
    Note: Negate an integer
    Note: Returns -a
    Return -a
End Process

Process called "absolute" takes a as Integer returns Integer:
    Note: Get absolute value of an integer
    Note: Returns |a|
    If a is less than 0:
        Return -a
    End If
    Return a
End Process

Process called "min" takes a as Integer, b as Integer returns Integer:
    Note: Return minimum of two integers
    If a is less than b:
        Return a
    End If
    Return b
End Process

Process called "max" takes a as Integer, b as Integer returns Integer:
    Note: Return maximum of two integers
    If a is greater than b:
        Return a
    End If
    Return b
End Process

Process called "clamp" takes value as Integer, min_val as Integer, max_val as Integer returns Integer:
    Note: Clamp value between min_val and max_val
    If value is less than min_val:
        Return min_val
    End If
    If value is greater than max_val:
        Return max_val
    End If
    Return value
End Process

Note: ============================================================================
Note: Checked Arithmetic Operations
Note: ============================================================================

Note: These operations detect overflow/underflow and set a flag pointer.
Note: For signed 64-bit integers (INT64_MIN = -2^63, INT64_MAX = 2^63-1):
Note: - Addition overflow: result has different sign than both operands
Note: - Subtraction overflow: result has unexpected sign relative to operands
Note: - Multiplication overflow: check if result/a != b (division reversal)
Note: ============================================================================

Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Process called "add_checked" takes a as Integer, b as Integer, overflow_ptr as Integer returns Integer:
    Note: Add with overflow detection
    Note: Sets overflow_ptr to 1 if overflow occurred, 0 otherwise
    Note: Returns a + b (even if overflow occurred)

    Let result be a plus b

    Note: Overflow detection for signed addition:
    Note: - If both positive and result negative -> overflow
    Note: - If both negative and result positive -> underflow
    Let overflow be 0

    If a is greater than 0:
        If b is greater than 0:
            If result is less than 0:
                Set overflow to 1  Note: Positive + Positive = Negative (overflow)
            End If
        End If
    Otherwise If a is less than 0:
        If b is less than 0:
            If result is greater than 0:
                Set overflow to 1  Note: Negative + Negative = Positive (underflow)
            End If
        End If
    End If

    proc memory_set_int64 from Memory with overflow_ptr, 0, overflow
    Return result
End Process

Process called "subtract_checked" takes a as Integer, b as Integer, overflow_ptr as Integer returns Integer:
    Note: Subtract with overflow detection
    Note: Sets overflow_ptr to 1 if overflow occurred, 0 otherwise
    Note: Returns a - b (even if overflow occurred)

    Let result be a minus b

    Note: Overflow detection for signed subtraction:
    Note: - Positive - Negative = Negative (overflow)
    Note: - Negative - Positive = Positive (underflow)
    Let overflow be 0

    If a is greater than 0:
        If b is less than 0:
            If result is less than 0:
                Set overflow to 1  Note: Positive - Negative = Negative (overflow)
            End If
        End If
    Otherwise If a is less than 0:
        If b is greater than 0:
            If result is greater than 0:
                Set overflow to 1  Note: Negative - Positive = Positive (underflow)
            End If
        End If
    End If

    proc memory_set_int64 from Memory with overflow_ptr, 0, overflow
    Return result
End Process

Process called "multiply_checked" takes a as Integer, b as Integer, overflow_ptr as Integer returns Integer:
    Note: Multiply with overflow detection
    Note: Sets overflow_ptr to 1 if overflow occurred, 0 otherwise
    Note: Returns a * b (even if overflow occurred)

    Let result be a multiplied by b

    Note: Overflow detection for signed multiplication:
    Note: If a != 0, check if result / a == b
    Note: Special case: avoid division by zero
    Let overflow be 0

    If a is not equal to 0:
        Let quotient be result divided by a
        If quotient is not equal to b:
            Set overflow to 1  Note: Multiplication overflow detected
        End If
    End If

    Note: Also check for special case: INT64_MIN * -1 = overflow
    Note: Since we can't represent INT64_MIN exactly, check for sign anomaly
    If a is equal to -1:
        If b is less than 0:
            If result is less than 0:
                Set overflow to 1  Note: -1 * large_negative = overflow
            End If
        End If
    Otherwise If b is equal to -1:
        If a is less than 0:
            If result is less than 0:
                Set overflow to 1  Note: large_negative * -1 = overflow
            End If
        End If
    End If

    proc memory_set_int64 from Memory with overflow_ptr, 0, overflow
    Return result
End Process

Process called "divide_checked" takes a as Integer, b as Integer, error_ptr as Integer returns Integer:
    Note: Divide with error detection
    Note: Sets error_ptr to 1 if division by zero, 0 otherwise
    Note: Returns a / b (or 0 if division by zero)

    If b is equal to 0:
        proc memory_set_int64 from Memory with error_ptr, 0, 1
        Return 0  Note: Division by zero
    End If

    proc memory_set_int64 from Memory with error_ptr, 0, 0
    Return a divided by b
End Process

Process called "Modulo by _checked" takes a as Integer, b as Integer, error_ptr as Integer returns Integer:
    Note: Modulo by with error detection
    Note: Sets error_ptr to 1 if Modulo by zero, 0 otherwise
    Note: Returns a % b (or 0 if Modulo by zero)

    If b is equal to 0:
        proc memory_set_int64 from Memory with error_ptr, 0, 1
        Return 0  Note: Modulo by zero
    End If

    proc memory_set_int64 from Memory with error_ptr, 0, 0
    Return a Modulo by b
End Process

Note: ============================================================================
Note: Float64 Arithmetic Operations (IEEE 754) - Pure Runa Implementation
Note: ============================================================================

Note: These operations work with 8-byte float64 values stored in memory.
Note: Pure Runa soft-float implementation - NO C runtime dependency
Note: Format: [sign:1][exponent:11][mantissa:52]
Note: Exponent bias: 1023, Range: ±1.8×10^308, Precision: ~15-17 decimal digits

Note: Float64 Constants
Let FLOAT64_SIGN_MASK be -9223372036854775808
Let FLOAT64_EXPONENT_MASK be 9218868437227405312
Let FLOAT64_MANTISSA_MASK be 4503599627370495
Let FLOAT64_IMPLIED_BIT be 4503599627370496

Process called "float64_is_nan" takes f64_ptr as Integer returns Integer:
    Note: Check if Float64 is NaN (exponent=2047, mantissa!=0)
    Let bits be proc memory_get_int64 from Memory with f64_ptr, 0
    Let exp be proc right_shift from Bitwise with proc bitwise_and from Bitwise with bits, FLOAT64_EXPONENT_MASK, 52
    If exp is equal to 2047:
        Let mant be proc bitwise_and from Bitwise with bits, FLOAT64_MANTISSA_MASK
        If mant is not equal to 0:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "float64_is_zero" takes f64_ptr as Integer returns Integer:
    Note: Check if Float64 is ±0 (ignore sign bit)
    Let bits be proc memory_get_int64 from Memory with f64_ptr, 0
    Let without_sign be proc bitwise_and from Bitwise with bits, 9223372036854775807
    If without_sign is equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "float_add" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Add two float64 values: result = a + b
    Note: Pure Runa soft-float implementation - NO C runtime dependency

    Note: Check for NaN
    If proc float64_is_nan with a_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, a_ptr, 8
        Return
    End If
    If proc float64_is_nan with b_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, b_ptr, 8
        Return
    End If

    Note: Unpack operands
    Let bits_a be proc memory_get_int64 from Memory with a_ptr, 0
    Let bits_b be proc memory_get_int64 from Memory with b_ptr, 0

    Let sign_a be proc right_shift from Bitwise with bits_a, 63
    Let exp_a be proc right_shift from Bitwise with proc bitwise_and from Bitwise with bits_a, FLOAT64_EXPONENT_MASK, 52
    Let mant_a be proc bitwise_and from Bitwise with bits_a, FLOAT64_MANTISSA_MASK

    Let sign_b be proc right_shift from Bitwise with bits_b, 63
    Let exp_b be proc right_shift from Bitwise with proc bitwise_and from Bitwise with bits_b, FLOAT64_EXPONENT_MASK, 52
    Let mant_b be proc bitwise_and from Bitwise with bits_b, FLOAT64_MANTISSA_MASK

    Note: Handle infinity
    If exp_a is equal to 2047:
        If mant_a is equal to 0:
            If exp_b is equal to 2047:
                If mant_b is equal to 0:
                    If sign_a is not equal to sign_b:
                        Note: Inf + (-Inf) = NaN
                        proc memory_set_int64 from Memory with result_ptr, 0, 9221120237041090561
                        Return
                    End If
                End If
            End If
            proc memory_copy from Memory with result_ptr, a_ptr, 8
            Return
        End If
    End If

    If exp_b is equal to 2047:
        If mant_b is equal to 0:
            proc memory_copy from Memory with result_ptr, b_ptr, 8
            Return
        End If
    End If

    Note: Handle zero
    If proc float64_is_zero with a_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, b_ptr, 8
        Return
    End If
    If proc float64_is_zero with b_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, a_ptr, 8
        Return
    End If

    Note: Add implicit leading 1 for normal numbers
    If exp_a is not equal to 0:
        Set mant_a to proc bitwise_or from Bitwise with mant_a, FLOAT64_IMPLIED_BIT
    End If
    If exp_b is not equal to 0:
        Set mant_b to proc bitwise_or from Bitwise with mant_b, FLOAT64_IMPLIED_BIT
    End If

    Note: Align exponents
    If exp_a is greater than exp_b:
        Let diff be exp_a minus exp_b
        If diff is greater than 53:
            Set mant_b to 0
        Otherwise:
            Set mant_b to proc right_shift from Bitwise with mant_b, diff
        End If
    Otherwise If exp_b is greater than exp_a:
        Let diff be exp_b minus exp_a
        If diff is greater than 53:
            Set mant_a to 0
        Otherwise:
            Set mant_a to proc right_shift from Bitwise with mant_a, diff
        End If
        Set exp_a to exp_b
    End If

    Note: Add or subtract based on signs
    Let result_sign be sign_a
    Let result_mant be 0

    If sign_a is equal to sign_b:
        Set result_mant to mant_a plus mant_b
        Let overflow be proc bitwise_and from Bitwise with result_mant, 9007199254740992
        If overflow is not equal to 0:
            Set result_mant to proc right_shift from Bitwise with result_mant, 1
            Set exp_a to exp_a plus 1
        End If
    Otherwise:
        If mant_a is greater than or equal to mant_b:
            Set result_mant to mant_a minus mant_b
            Set result_sign to sign_a
        Otherwise:
            Set result_mant to mant_b minus mant_a
            Set result_sign to sign_b
        End If

        If result_mant is equal to 0:
            proc memory_set_int64 from Memory with result_ptr, 0, 0
            Return
        End If

        Note: Normalize
        While exp_a is greater than 0:
            Let bit_52 be proc bitwise_and from Bitwise with result_mant, FLOAT64_IMPLIED_BIT
            If bit_52 is not equal to 0:
                break
            End If
            Set result_mant to proc left_shift from Bitwise with result_mant, 1
            Set exp_a to exp_a minus 1
        End While
    End If

    Note: Remove implicit bit
    Set result_mant to proc bitwise_and from Bitwise with result_mant, FLOAT64_MANTISSA_MASK

    Note: Check overflow
    If exp_a is greater than or equal to 2047:
        Let inf_bits be proc left_shift from Bitwise with result_sign, 63
        Set inf_bits to proc bitwise_or from Bitwise with inf_bits, 9218868437227405312
        proc memory_set_int64 from Memory with result_ptr, 0, inf_bits
        Return
    End If

    Note: Pack result
    Let result_bits be proc left_shift from Bitwise with result_sign, 63
    Let exp_shifted be proc left_shift from Bitwise with exp_a, 52
    Set result_bits to proc bitwise_or from Bitwise with result_bits, exp_shifted
    Set result_bits to proc bitwise_or from Bitwise with result_bits, result_mant
    proc memory_set_int64 from Memory with result_ptr, 0, result_bits
End Process

Process called "float_subtract" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Subtract two float64 values: result = a - b
    Note: Implemented as a + (-b) using scratch buffer
    Note: SCRATCH SPACE REQUIRED: 8 bytes (1 × 8-byte float)

    Let b_negated_ptr be scratch_ptr
    Let b_bits be proc memory_get_int64 from Memory with b_ptr, 0
    Let b_negated be proc bitwise_xor from Bitwise with b_bits, FLOAT64_SIGN_MASK
    proc memory_set_int64 from Memory with b_negated_ptr, 0, b_negated
    proc float_add with a_ptr, b_negated_ptr, result_ptr
End Process

Process called "float_multiply" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Multiply two float64 values: result = a * b
    Note: Pure Runa soft-float multiplication

    Note: Check NaN
    If proc float64_is_nan with a_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, a_ptr, 8
        Return
    End If
    If proc float64_is_nan with b_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, b_ptr, 8
        Return
    End If

    Note: Unpack
    Let bits_a be proc memory_get_int64 from Memory with a_ptr, 0
    Let bits_b be proc memory_get_int64 from Memory with b_ptr, 0
    Let sign_a be proc right_shift from Bitwise with bits_a, 63
    Let exp_a be proc right_shift from Bitwise with proc bitwise_and from Bitwise with bits_a, FLOAT64_EXPONENT_MASK, 52
    Let mant_a be proc bitwise_and from Bitwise with bits_a, FLOAT64_MANTISSA_MASK
    Let sign_b be proc right_shift from Bitwise with bits_b, 63
    Let exp_b be proc right_shift from Bitwise with proc bitwise_and from Bitwise with bits_b, FLOAT64_EXPONENT_MASK, 52
    Let mant_b be proc bitwise_and from Bitwise with bits_b, FLOAT64_MANTISSA_MASK

    Note: Result sign
    Let result_sign be 0
    If sign_a is not equal to sign_b:
        Set result_sign to 1
    End If

    Note: Handle special cases
    If exp_a is equal to 2047:
        If mant_a is equal to 0:
            If proc float64_is_zero with b_ptr is equal to 1:
                proc memory_set_int64 from Memory with result_ptr, 0, 9221120237041090561
                Return
            End If
            Let inf_bits be proc left_shift from Bitwise with result_sign, 63
            Set inf_bits to proc bitwise_or from Bitwise with inf_bits, 9218868437227405312
            proc memory_set_int64 from Memory with result_ptr, 0, inf_bits
            Return
        End If
    End If

    If exp_b is equal to 2047:
        If mant_b is equal to 0:
            If proc float64_is_zero with a_ptr is equal to 1:
                proc memory_set_int64 from Memory with result_ptr, 0, 9221120237041090561
                Return
            End If
            Let inf_bits be proc left_shift from Bitwise with result_sign, 63
            Set inf_bits to proc bitwise_or from Bitwise with inf_bits, 9218868437227405312
            proc memory_set_int64 from Memory with result_ptr, 0, inf_bits
            Return
        End If
    End If

    If proc float64_is_zero with a_ptr is equal to 1:
        Let zero_bits be proc left_shift from Bitwise with result_sign, 63
        proc memory_set_int64 from Memory with result_ptr, 0, zero_bits
        Return
    End If
    If proc float64_is_zero with b_ptr is equal to 1:
        Let zero_bits be proc left_shift from Bitwise with result_sign, 63
        proc memory_set_int64 from Memory with result_ptr, 0, zero_bits
        Return
    End If

    Note: Add implicit bit
    If exp_a is not equal to 0:
        Set mant_a to proc bitwise_or from Bitwise with mant_a, FLOAT64_IMPLIED_BIT
    Otherwise:
        Set exp_a to 1
    End If
    If exp_b is not equal to 0:
        Set mant_b to proc bitwise_or from Bitwise with mant_b, FLOAT64_IMPLIED_BIT
    Otherwise:
        Set exp_b to 1
    End If

    Note: Multiply mantissas (simplified - split into high/low)
    Let a_high be proc right_shift from Bitwise with mant_a, 26
    Let a_low be proc bitwise_and from Bitwise with mant_a, 67108863
    Let b_high be proc right_shift from Bitwise with mant_b, 26
    Let b_low be proc bitwise_and from Bitwise with mant_b, 67108863

    Let hh be a_high multiplied by b_high
    Let hl be a_high multiplied by b_low
    Let lh be a_low multiplied by b_high
    Let ll be a_low multiplied by b_low

    Let mid be hl plus lh
    Let mid_high be proc right_shift from Bitwise with mid, 26
    Let mid_low be proc bitwise_and from Bitwise with mid, 67108863

    Let result_mant be proc left_shift from Bitwise with hh, 52
    Set result_mant to result_mant plus proc left_shift from Bitwise with mid_high, 52
    Set result_mant to result_mant plus proc left_shift from Bitwise with mid_low, 26
    Set result_mant to result_mant plus ll

    Note: Compute result exponent
    Let result_exp be exp_a plus exp_b minus 1023

    Note: Normalize
    Let bit_53 be proc right_shift from Bitwise with result_mant, 53
    If bit_53 is not equal to 0:
        Set result_mant to proc right_shift from Bitwise with result_mant, 1
        Set result_exp to result_exp plus 1
    End If

    Set result_mant to proc bitwise_and from Bitwise with result_mant, FLOAT64_MANTISSA_MASK

    If result_exp is greater than or equal to 2047:
        Let inf_bits be proc left_shift from Bitwise with result_sign, 63
        Set inf_bits to proc bitwise_or from Bitwise with inf_bits, 9218868437227405312
        proc memory_set_int64 from Memory with result_ptr, 0, inf_bits
        Return
    End If
    If result_exp is less than or equal to 0:
        Let zero_bits be proc left_shift from Bitwise with result_sign, 63
        proc memory_set_int64 from Memory with result_ptr, 0, zero_bits
        Return
    End If

    Let result_bits be proc left_shift from Bitwise with result_sign, 63
    Let exp_shifted be proc left_shift from Bitwise with result_exp, 52
    Set result_bits to proc bitwise_or from Bitwise with result_bits, exp_shifted
    Set result_bits to proc bitwise_or from Bitwise with result_bits, result_mant
    proc memory_set_int64 from Memory with result_ptr, 0, result_bits
End Process

Process called "float_divide" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Divide two float64 values: result = a / b
    Note: Division by zero produces ±Infinity (IEEE 754 behavior)

    Note: Check NaN
    If proc float64_is_nan with a_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, a_ptr, 8
        Return
    End If
    If proc float64_is_nan with b_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, b_ptr, 8
        Return
    End If

    Note: Unpack
    Let bits_a be proc memory_get_int64 from Memory with a_ptr, 0
    Let bits_b be proc memory_get_int64 from Memory with b_ptr, 0
    Let sign_a be proc right_shift from Bitwise with bits_a, 63
    Let exp_a be proc right_shift from Bitwise with proc bitwise_and from Bitwise with bits_a, FLOAT64_EXPONENT_MASK, 52
    Let mant_a be proc bitwise_and from Bitwise with bits_a, FLOAT64_MANTISSA_MASK
    Let sign_b be proc right_shift from Bitwise with bits_b, 63
    Let exp_b be proc right_shift from Bitwise with proc bitwise_and from Bitwise with bits_b, FLOAT64_EXPONENT_MASK, 52
    Let mant_b be proc bitwise_and from Bitwise with bits_b, FLOAT64_MANTISSA_MASK

    Let result_sign be 0
    If sign_a is not equal to sign_b:
        Set result_sign to 1
    End If

    Note: Handle division by zero
    If proc float64_is_zero with b_ptr is equal to 1:
        If proc float64_is_zero with a_ptr is equal to 1:
            proc memory_set_int64 from Memory with result_ptr, 0, 9221120237041090561
        Otherwise:
            Let inf_bits be proc left_shift from Bitwise with result_sign, 63
            Set inf_bits to proc bitwise_or from Bitwise with inf_bits, 9218868437227405312
            proc memory_set_int64 from Memory with result_ptr, 0, inf_bits
        End If
        Return
    End If

    Note: Handle infinity
    If exp_a is equal to 2047:
        If mant_a is equal to 0:
            If exp_b is equal to 2047:
                proc memory_set_int64 from Memory with result_ptr, 0, 9221120237041090561
                Return
            End If
            Let inf_bits be proc left_shift from Bitwise with result_sign, 63
            Set inf_bits to proc bitwise_or from Bitwise with inf_bits, 9218868437227405312
            proc memory_set_int64 from Memory with result_ptr, 0, inf_bits
            Return
        End If
    End If

    If exp_b is equal to 2047:
        Let zero_bits be proc left_shift from Bitwise with result_sign, 63
        proc memory_set_int64 from Memory with result_ptr, 0, zero_bits
        Return
    End If

    If proc float64_is_zero with a_ptr is equal to 1:
        Let zero_bits be proc left_shift from Bitwise with result_sign, 63
        proc memory_set_int64 from Memory with result_ptr, 0, zero_bits
        Return
    End If

    Note: Add implicit bit
    If exp_a is not equal to 0:
        Set mant_a to proc bitwise_or from Bitwise with mant_a, FLOAT64_IMPLIED_BIT
    Otherwise:
        Set exp_a to 1
    End If
    If exp_b is not equal to 0:
        Set mant_b to proc bitwise_or from Bitwise with mant_b, FLOAT64_IMPLIED_BIT
    Otherwise:
        Set exp_b to 1
    End If

    Note: Divide mantissas using bit-by-bit division
    Let quotient be 0
    Let remainder be mant_a
    Let i be 0
    While i is less than 54:
        Set remainder to proc left_shift from Bitwise with remainder, 1
        Set quotient to proc left_shift from Bitwise with quotient, 1
        If remainder is greater than or equal to mant_b:
            Set remainder to remainder minus mant_b
            Set quotient to quotient plus 1
        End If
        Set i to i plus 1
    End While

    Let result_exp be exp_a minus exp_b plus 1023
    Let bit_53 be proc bitwise_and from Bitwise with quotient, 9007199254740992
    If bit_53 is not equal to 0:
        Set quotient to proc right_shift from Bitwise with quotient, 1
        Set result_exp to result_exp plus 1
    End If

    Set quotient to proc bitwise_and from Bitwise with quotient, FLOAT64_MANTISSA_MASK

    If result_exp is greater than or equal to 2047:
        Let inf_bits be proc left_shift from Bitwise with result_sign, 63
        Set inf_bits to proc bitwise_or from Bitwise with inf_bits, 9218868437227405312
        proc memory_set_int64 from Memory with result_ptr, 0, inf_bits
        Return
    End If
    If result_exp is less than or equal to 0:
        Let zero_bits be proc left_shift from Bitwise with result_sign, 63
        proc memory_set_int64 from Memory with result_ptr, 0, zero_bits
        Return
    End If

    Let result_bits be proc left_shift from Bitwise with result_sign, 63
    Let exp_shifted be proc left_shift from Bitwise with result_exp, 52
    Set result_bits to proc bitwise_or from Bitwise with result_bits, exp_shifted
    Set result_bits to proc bitwise_or from Bitwise with result_bits, quotient
    proc memory_set_int64 from Memory with result_ptr, 0, result_bits
End Process

Process called "float_negate" takes a_ptr as Integer, result_ptr as Integer:
    Note: Negate a float64 value: result = -a
    Note: Pure Runa implementation using XOR with sign bit mask

    Let bits be proc memory_get_int64 from Memory with a_ptr, 0
    Let negated be proc bitwise_xor from Bitwise with bits, FLOAT64_SIGN_MASK
    proc memory_set_int64 from Memory with result_ptr, 0, negated
End Process

Process called "float_abs" takes a_ptr as Integer, result_ptr as Integer:
    Note: Get absolute value of float64: result = |a|
    Note: Pure Runa implementation using AND with magnitude mask (clears sign bit)

    Let bits be proc memory_get_int64 from Memory with a_ptr, 0
    Let magnitude_mask be 9223372036854775807
    Let abs_bits be proc bitwise_and from Bitwise with bits, magnitude_mask
    proc memory_set_int64 from Memory with result_ptr, 0, abs_bits
End Process

Process called "float_sqrt" takes a_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Compute square root of float64: result = √a
    Note: Pure Runa implementation using Newton-Raphson iteration
    Note: sqrt(negative) produces NaN (IEEE 754 behavior)
    Note: SCRATCH SPACE REQUIRED: 40 bytes (5 × 8-byte floats)
    Note:   scratch_ptr+0:  guess (8 bytes)
    Note:   scratch_ptr+8:  temp1 (8 bytes)
    Note:   scratch_ptr+16: temp2 (8 bytes)
    Note:   scratch_ptr+24: temp3 (8 bytes)
    Note:   scratch_ptr+32: half constant (8 bytes)

    Note: Check for special cases
    If proc float64_is_nan with a_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, a_ptr, 8
        Return
    End If

    Let bits be proc memory_get_int64 from Memory with a_ptr, 0
    Let sign be proc right_shift from Bitwise with bits, 63

    Note: Negative input (except -0) produces NaN
    If sign is equal to 1:
        If proc float64_is_zero with a_ptr is equal to 0:
            proc memory_set_int64 from Memory with result_ptr, 0, 9221120237041090561
            Return
        Otherwise:
            proc memory_copy from Memory with result_ptr, a_ptr, 8
            Return
        End If
    End If

    Note: Handle zero and infinity
    If proc float64_is_zero with a_ptr is equal to 1:
        proc memory_set_int64 from Memory with result_ptr, 0, 0
        Return
    End If

    Let exp be proc right_shift from Bitwise with proc bitwise_and from Bitwise with bits, FLOAT64_EXPONENT_MASK, 52
    If exp is equal to 2047:
        proc memory_copy from Memory with result_ptr, a_ptr, 8
        Return
    End If

    Note: Newton-Raphson iteration: x_new = 0.5 * (x + a/x)
    Note: Start with initial guess using exponent halving
    Let result_exp be proc right_shift from Bitwise with exp plus 1023, 1
    Let initial_guess be proc left_shift from Bitwise with result_exp, 52

    Note: Setup scratch space pointers (TIER 1: STACK-BASED)
    Let guess_ptr be scratch_ptr
    Let temp1_ptr be scratch_ptr plus 8
    Let temp2_ptr be scratch_ptr plus 16
    Let temp3_ptr be scratch_ptr plus 24
    Let half_ptr be scratch_ptr plus 32

    proc memory_set_int64 from Memory with guess_ptr, 0, initial_guess
    proc memory_set_int64 from Memory with half_ptr, 0, 4602678819172646912

    Note: Iterate 10 times for convergence
    Let i be 0
    While i is less than 10:
        proc float_divide with a_ptr, guess_ptr, temp1_ptr
        proc float_add with guess_ptr, temp1_ptr, temp2_ptr
        proc float_multiply with temp2_ptr, half_ptr, temp3_ptr
        proc memory_copy from Memory with guess_ptr, temp3_ptr, 8

        Set i to i plus 1
    End While

    proc memory_copy from Memory with result_ptr, guess_ptr, 8
End Process

Process called "float_min" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Return minimum of two float64 values
    Note: Pure Runa implementation
    Note: Handles NaN according to IEEE 754 (NaN propagates)

    Note: NaN propagation
    If proc float64_is_nan with a_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, a_ptr, 8
        Return
    End If
    If proc float64_is_nan with b_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, b_ptr, 8
        Return
    End If

    Note: Compare by unpacking and comparing sign, exponent, mantissa
    Let bits_a be proc memory_get_int64 from Memory with a_ptr, 0
    Let bits_b be proc memory_get_int64 from Memory with b_ptr, 0
    Let sign_a be proc right_shift from Bitwise with bits_a, 63
    Let sign_b be proc right_shift from Bitwise with bits_b, 63

    Note: If different signs, negative is smaller
    If sign_a is not equal to sign_b:
        If sign_a is equal to 1:
            proc memory_copy from Memory with result_ptr, a_ptr, 8
        Otherwise:
            proc memory_copy from Memory with result_ptr, b_ptr, 8
        End If
        Return
    End If

    Note: Same sign - compare magnitude
    Let mag_a be proc bitwise_and from Bitwise with bits_a, 9223372036854775807
    Let mag_b be proc bitwise_and from Bitwise with bits_b, 9223372036854775807

    If sign_a is equal to 0:
        Note: Both positive - smaller magnitude is smaller
        If mag_a is less than or equal to mag_b:
            proc memory_copy from Memory with result_ptr, a_ptr, 8
        Otherwise:
            proc memory_copy from Memory with result_ptr, b_ptr, 8
        End If
    Otherwise:
        Note: Both negative - larger magnitude is smaller
        If mag_a is greater than or equal to mag_b:
            proc memory_copy from Memory with result_ptr, a_ptr, 8
        Otherwise:
            proc memory_copy from Memory with result_ptr, b_ptr, 8
        End If
    End If
End Process

Process called "float_max" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Return maximum of two float64 values
    Note: Pure Runa implementation
    Note: Handles NaN according to IEEE 754 (NaN propagates)

    Note: NaN propagation
    If proc float64_is_nan with a_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, a_ptr, 8
        Return
    End If
    If proc float64_is_nan with b_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, b_ptr, 8
        Return
    End If

    Note: Compare by unpacking and comparing sign, exponent, mantissa
    Let bits_a be proc memory_get_int64 from Memory with a_ptr, 0
    Let bits_b be proc memory_get_int64 from Memory with b_ptr, 0
    Let sign_a be proc right_shift from Bitwise with bits_a, 63
    Let sign_b be proc right_shift from Bitwise with bits_b, 63

    Note: If different signs, positive is larger
    If sign_a is not equal to sign_b:
        If sign_a is equal to 0:
            proc memory_copy from Memory with result_ptr, a_ptr, 8
        Otherwise:
            proc memory_copy from Memory with result_ptr, b_ptr, 8
        End If
        Return
    End If

    Note: Same sign - compare magnitude
    Let mag_a be proc bitwise_and from Bitwise with bits_a, 9223372036854775807
    Let mag_b be proc bitwise_and from Bitwise with bits_b, 9223372036854775807

    If sign_a is equal to 0:
        Note: Both positive - larger magnitude is larger
        If mag_a is greater than or equal to mag_b:
            proc memory_copy from Memory with result_ptr, a_ptr, 8
        Otherwise:
            proc memory_copy from Memory with result_ptr, b_ptr, 8
        End If
    Otherwise:
        Note: Both negative - smaller magnitude is larger
        If mag_a is less than or equal to mag_b:
            proc memory_copy from Memory with result_ptr, a_ptr, 8
        Otherwise:
            proc memory_copy from Memory with result_ptr, b_ptr, 8
        End If
    End If
End Process

Note: ============================================================================
Note: Float64 Arithmetic Notes
Note: ============================================================================

Note: All float operations follow IEEE 754 standard:
Note: - Division by zero produces ±Infinity (not a runtime error)
Note: - Invalid operations produce NaN (e.g., sqrt(-1), 0/0, Inf-Inf)
Note: - NaN propagates through operations (any op with NaN yields NaN)
Note: - Signed zeros: +0.0 and -0.0 are distinct but compare equal

Note: SSE2 instructions used:
Note: - addsd, subsd, mulsd, divsd (scalar double-precision arithmetic)
Note: - sqrtsd (square root)
Note: - minsd, maxsd (minimum/maximum with IEEE 754 semantics)
Note: - andpd, xorpd (bitwise operations on packed doubles)
Note: - movsd (move scalar double)
Note: ============================================================================

Note: ============================================================================
Note: Hardware Overflow Detection (using CPU flags)
Note: ============================================================================

Process called "add_checked_hw" takes a as Integer, b as Integer, overflow_ptr as Integer returns Integer:
    Note: Add with overflow detection
    Note: Pure Runa implementation using software-based overflow checking
    Note: Delegates to add_checked for actual implementation
    Return proc add_checked with a, b, overflow_ptr
End Process

Process called "subtract_checked_hw" takes a as Integer, b as Integer, overflow_ptr as Integer returns Integer:
    Note: Subtract with overflow detection
    Note: Pure Runa implementation using software-based overflow checking
    Note: Delegates to subtract_checked for actual implementation
    Return proc subtract_checked with a, b, overflow_ptr
End Process

Process called "multiply_checked_hw" takes a as Integer, b as Integer, overflow_ptr as Integer returns Integer:
    Note: Multiply with overflow detection
    Note: Pure Runa implementation using software-based overflow checking
    Note: Delegates to multiply_checked for actual implementation
    Return proc multiply_checked with a, b, overflow_ptr
End Process

Note: ============================================================================
Note: Saturating Arithmetic (clamp on overflow)
Note: ============================================================================

Note: Saturating arithmetic clamps results to INT64_MIN or INT64_MAX on overflow
Note: Useful for audio processing, graphics, and bounded computations

Process called "add_saturating" takes a as Integer, b as Integer, scratch_ptr as Integer returns Integer:
    Note: Saturating addition: clamps to INT64_MIN/MAX on overflow
    Note: INT64_MAX = 9223372036854775807
    Note: INT64_MIN = -9223372036854775808
    Note: SCRATCH SPACE REQUIRED: 8 bytes (1 × 8-byte overflow flag)

    Let overflow_flag be scratch_ptr
    Let result be proc add_checked_hw with a, b, overflow_flag
    Let overflow be proc memory_get_int64 from Memory with overflow_flag, 0

    If overflow is equal to 1:
        Note: Overflow occurred - determine direction and saturate
        If a is greater than 0:
            If b is greater than 0:
                Note: Positive overflow - saturate to INT64_MAX
                Return 9223372036854775807
            End If
        Otherwise:
            If b is less than 0:
                Note: Negative overflow - saturate to INT64_MIN
                Return -9223372036854775808
            End If
        End If
    End If

    Return result
End Process

Process called "subtract_saturating" takes a as Integer, b as Integer, scratch_ptr as Integer returns Integer:
    Note: Saturating subtraction: clamps to INT64_MIN/MAX on overflow
    Note: SCRATCH SPACE REQUIRED: 8 bytes (1 × 8-byte overflow flag)

    Let overflow_flag be scratch_ptr
    Let result be proc subtract_checked_hw with a, b, overflow_flag
    Let overflow be proc memory_get_int64 from Memory with overflow_flag, 0

    If overflow is equal to 1:
        Note: Overflow occurred - determine direction and saturate
        If a is greater than 0:
            If b is less than 0:
                Note: Positive - Negative overflow - saturate to INT64_MAX
                Return 9223372036854775807
            End If
        Otherwise:
            If b is greater than 0:
                Note: Negative - Positive overflow - saturate to INT64_MIN
                Return -9223372036854775808
            End If
        End If
    End If

    Return result
End Process

Process called "multiply_saturating" takes a as Integer, b as Integer, scratch_ptr as Integer returns Integer:
    Note: Saturating multiplication: clamps to INT64_MIN/MAX on overflow
    Note: SCRATCH SPACE REQUIRED: 8 bytes (1 × 8-byte overflow flag)

    Let overflow_flag be scratch_ptr
    Let result be proc multiply_checked_hw with a, b, overflow_flag
    Let overflow be proc memory_get_int64 from Memory with overflow_flag, 0

    If overflow is equal to 1:
        Note: Determine saturation direction based on signs
        Let result_should_be_positive be 0

        If a is greater than 0:
            If b is greater than 0:
                Set result_should_be_positive to 1
            End If
        Otherwise:
            If b is less than 0:
                Set result_should_be_positive to 1
            End If
        End If

        If result_should_be_positive is equal to 1:
            Return 9223372036854775807  Note: Saturate to INT64_MAX
        Otherwise:
            Return -9223372036854775808  Note: Saturate to INT64_MIN
        End If
    End If

    Return result
End Process

Note: ============================================================================
Note: Wrapping Arithmetic (explicit overflow behavior)
Note: ============================================================================

Note: Wrapping arithmetic explicitly allows overflow with well-defined wraparound
Note: This is standard two's complement behavior, but made explicit

Process called "add_wrapping" takes a as Integer, b as Integer returns Integer:
    Note: Wrapping addition: allows overflow with wraparound
    Note: This is the default behavior, but made explicit for clarity
    Return a plus b
End Process

Process called "subtract_wrapping" takes a as Integer, b as Integer returns Integer:
    Note: Wrapping subtraction: allows overflow with wraparound
    Return a minus b
End Process

Process called "multiply_wrapping" takes a as Integer, b as Integer returns Integer:
    Note: Wrapping multiplication: allows overflow with wraparound
    Return a multiplied by b
End Process

Note: ============================================================================
Note: Float32 Arithmetic Operations (IEEE 754 Single Precision)
Note: ============================================================================

Note: These operations work with 4-byte float32 values stored in memory.
Note: All operations use SSE instructions (addss, subss, mulss, divss).
Note: Float32 is useful for graphics, audio, and memory-constrained applications.

Note: Float32 helper functions
Process called "float32_to_float64_helper" takes f32_ptr as Integer, f64_ptr as Integer:
    Note: Convert Float32 to Float64 for computation
    Let f32_bits be proc memory_get_int32 from Memory with f32_ptr, 0
    Let sign be proc right_shift from Bitwise with proc bitwise_and from Bitwise with f32_bits, -2147483648, 31
    Let exp be proc right_shift from Bitwise with proc bitwise_and from Bitwise with f32_bits, 2139095040, 23
    Let mant be proc bitwise_and from Bitwise with f32_bits, 8388607

    Let f64_sign be sign
    Let f64_exp be 0
    Let f64_mant be 0

    If exp is equal to 0:
        Set f64_exp to 0
        Set f64_mant to proc left_shift from Bitwise with mant, 29
    Otherwise If exp is equal to 255:
        Set f64_exp to 2047
        Set f64_mant to proc left_shift from Bitwise with mant, 29
    Otherwise:
        Set f64_exp to exp minus 127 plus 1023
        Set f64_mant to proc left_shift from Bitwise with mant, 29
    End If

    Let f64_bits be proc left_shift from Bitwise with f64_sign, 63
    Let exp_shifted be proc left_shift from Bitwise with f64_exp, 52
    Set f64_bits to proc bitwise_or from Bitwise with f64_bits, exp_shifted
    Set f64_bits to proc bitwise_or from Bitwise with f64_bits, f64_mant
    proc memory_set_int64 from Memory with f64_ptr, 0, f64_bits
End Process

Process called "float64_to_float32_helper" takes f64_ptr as Integer, f32_ptr as Integer:
    Note: Convert Float64 to Float32
    Let f64_bits be proc memory_get_int64 from Memory with f64_ptr, 0
    Let sign be proc right_shift from Bitwise with f64_bits, 63
    Let exp be proc right_shift from Bitwise with proc bitwise_and from Bitwise with f64_bits, FLOAT64_EXPONENT_MASK, 52
    Let mant be proc bitwise_and from Bitwise with f64_bits, FLOAT64_MANTISSA_MASK

    Let f32_sign be sign
    Let f32_exp be 0
    Let f32_mant be 0

    If exp is equal to 0:
        Set f32_exp to 0
        Set f32_mant to proc right_shift from Bitwise with mant, 29
    Otherwise If exp is equal to 2047:
        Set f32_exp to 255
        Set f32_mant to proc right_shift from Bitwise with mant, 29
    Otherwise:
        Set f32_exp to exp minus 1023 plus 127
        If f32_exp is less than or equal to 0:
            Set f32_exp to 0
            Set f32_mant to 0
        Otherwise If f32_exp is greater than or equal to 255:
            Set f32_exp to 255
            Set f32_mant to 0
        Otherwise:
            Set f32_mant to proc right_shift from Bitwise with mant, 29
        End If
    End If

    Let f32_bits be proc left_shift from Bitwise with f32_sign, 31
    Let exp_shifted be proc left_shift from Bitwise with f32_exp, 23
    Set f32_bits to proc bitwise_or from Bitwise with f32_bits, exp_shifted
    Set f32_bits to proc bitwise_or from Bitwise with f32_bits, f32_mant
    proc memory_set_int32 from Memory with f32_ptr, 0, f32_bits
End Process

Process called "float32_add" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Add two float32 values via Float64 conversion
    Note: SCRATCH SPACE REQUIRED: 24 bytes (3 × 8-byte Float64 values)
    Let a_f64 be scratch_ptr
    Let b_f64 be scratch_ptr plus 8
    Let result_f64 be scratch_ptr plus 16
    proc float32_to_float64_helper with a_ptr, a_f64
    proc float32_to_float64_helper with b_ptr, b_f64
    proc float_add with a_f64, b_f64, result_f64
    proc float64_to_float32_helper with result_f64, result_ptr
End Process

Process called "float32_subtract" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Subtract two float32 values via Float64 conversion
    Note: SCRATCH SPACE REQUIRED: 32 bytes (3 × 8-byte Float64 values + 8 bytes for float_subtract scratch)
    Let a_f64 be scratch_ptr
    Let b_f64 be scratch_ptr plus 8
    Let result_f64 be scratch_ptr plus 16
    Let subtract_scratch be scratch_ptr plus 24
    proc float32_to_float64_helper with a_ptr, a_f64
    proc float32_to_float64_helper with b_ptr, b_f64
    proc float_subtract with a_f64, b_f64, result_f64, subtract_scratch
    proc float64_to_float32_helper with result_f64, result_ptr
End Process

Process called "float32_multiply" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Multiply two float32 values via Float64 conversion
    Note: SCRATCH SPACE REQUIRED: 24 bytes (3 × 8-byte Float64 values)
    Let a_f64 be scratch_ptr
    Let b_f64 be scratch_ptr plus 8
    Let result_f64 be scratch_ptr plus 16
    proc float32_to_float64_helper with a_ptr, a_f64
    proc float32_to_float64_helper with b_ptr, b_f64
    proc float_multiply with a_f64, b_f64, result_f64
    proc float64_to_float32_helper with result_f64, result_ptr
End Process

Process called "float32_divide" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Divide two float32 values via Float64 conversion
    Note: SCRATCH SPACE REQUIRED: 24 bytes (3 × 8-byte Float64 values)
    Let a_f64 be scratch_ptr
    Let b_f64 be scratch_ptr plus 8
    Let result_f64 be scratch_ptr plus 16
    proc float32_to_float64_helper with a_ptr, a_f64
    proc float32_to_float64_helper with b_ptr, b_f64
    proc float_divide with a_f64, b_f64, result_f64
    proc float64_to_float32_helper with result_f64, result_ptr
End Process

Process called "float32_sqrt" takes a_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Compute square root of float32 via Float64
    Note: Convert to Float64, compute sqrt, convert back
    Note: SCRATCH SPACE REQUIRED: 56 bytes (2 × 8-byte Float64 + 40 bytes for float_sqrt scratch)
    Let temp_f64_input be scratch_ptr
    Let temp_f64_output be scratch_ptr plus 8
    Let sqrt_scratch be scratch_ptr plus 16
    proc float32_to_float64_helper with a_ptr, temp_f64_input
    proc float_sqrt with temp_f64_input, temp_f64_output, sqrt_scratch
    proc float64_to_float32_helper with temp_f64_output, result_ptr
End Process

Process called "float32_abs" takes a_ptr as Integer, result_ptr as Integer:
    Note: Absolute value of float32: result = |a|
    Note: Pure Runa using bitwise AND with magnitude mask
    Let bits be proc memory_get_int32 from Memory with a_ptr, 0
    Let magnitude_mask be 2147483647
    Let abs_bits be proc bitwise_and from Bitwise with bits, magnitude_mask
    proc memory_set_int32 from Memory with result_ptr, 0, abs_bits
End Process

Process called "float32_negate" takes a_ptr as Integer, result_ptr as Integer:
    Note: Negate float32: result = -a
    Note: Pure Runa using bitwise XOR with sign bit
    Let bits be proc memory_get_int32 from Memory with a_ptr, 0
    Let sign_mask be -2147483648
    Let negated_bits be proc bitwise_xor from Bitwise with bits, sign_mask
    proc memory_set_int32 from Memory with result_ptr, 0, negated_bits
End Process

Process called "float32_min" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Minimum of two float32 values via Float64
    Note: SCRATCH SPACE REQUIRED: 24 bytes (3 × 8-byte Float64 values)
    Let temp_a_f64 be scratch_ptr
    Let temp_b_f64 be scratch_ptr plus 8
    Let temp_result_f64 be scratch_ptr plus 16
    proc float32_to_float64_helper with a_ptr, temp_a_f64
    proc float32_to_float64_helper with b_ptr, temp_b_f64
    proc float_min with temp_a_f64, temp_b_f64, temp_result_f64
    proc float64_to_float32_helper with temp_result_f64, result_ptr
End Process

Process called "float32_max" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Maximum of two float32 values via Float64
    Note: SCRATCH SPACE REQUIRED: 24 bytes (3 × 8-byte Float64 values)
    Let temp_a_f64 be scratch_ptr
    Let temp_b_f64 be scratch_ptr plus 8
    Let temp_result_f64 be scratch_ptr plus 16
    proc float32_to_float64_helper with a_ptr, temp_a_f64
    proc float32_to_float64_helper with b_ptr, temp_b_f64
    proc float_max with temp_a_f64, temp_b_f64, temp_result_f64
    proc float64_to_float32_helper with temp_result_f64, result_ptr
End Process

Note: ============================================================================
Note: Enhanced Arithmetic Notes
Note: ============================================================================

Note: Hardware overflow detection (add_checked_hw, etc.):
Note: - Uses CPU overflow flag (OF) for direct detection
Note: - Faster than software-based checking
Note: - Available on all x86-64 CPUs

Note: Saturating arithmetic:
Note: - Prevents overflow by clamping to INT64_MIN/MAX
Note: - Useful for: audio DSP, graphics, control systems
Note: - Example: 9223372036854775807 + 1 = 9223372036854775807 (stays at max)

Note: Wrapping arithmetic:
Note: - Explicit wraparound on overflow (standard two's complement)
Note: - Useful for: hash functions, checksums, modular arithmetic
Note: - Example: 9223372036854775807 + 1 = -9223372036854775808 (wraps)

Note: Float32 operations:
Note: - Half the memory of Float64 (4 bytes vs 8 bytes)
Note: - Faster on some hardware (SIMD can process 4x as many)
Note: - Precision: ~7 decimal digits (vs ~15 for Float64)
Note: - Use for: graphics, audio, ML inference, memory-constrained apps
Note: ============================================================================

Note: ============================================================================
Note: Float16 Arithmetic Operations (IEEE 754 Half Precision)
Note: ============================================================================

Note: Float16 (16-bit IEEE 754) has no native x86-64 CPU support.
Note: Operations require conversion to Float32, operation, then conversion back.
Note: Format: 1 sign bit, 5 exponent bits, 10 mantissa bits
Note: Precision: ~3-4 decimal digits, range: ±65504
Note: Use for: neural networks (ML), GPU communication, memory-critical apps

Process called "float16_to_float32" takes f16_ptr as Integer, f32_ptr as Integer:
    Note: Convert Float16 to Float32 for computation
    Note: Uses bit manipulation to expand format

    Let f16_bits be proc memory_get_int16 from Memory with f16_ptr, 0

    Note: Extract components
    Let sign be proc bitwise_and from Bitwise with f16_bits, 32768
    Let sign_shifted be proc right_shift from Bitwise with sign, 15

    Let exponent be proc bitwise_and from Bitwise with f16_bits, 31744
    Let exponent_shifted be proc right_shift from Bitwise with exponent, 10

    Let mantissa be proc bitwise_and from Bitwise with f16_bits, 1023

    Note: Convert to Float32 format
    Let f32_sign be proc left_shift from Bitwise with sign_shifted, 31

    Note: Adjust exponent bias (127 for f32, 15 for f16)
    Let f32_exponent be 0
    If exponent_shifted is not equal to 0:
        If exponent_shifted is not equal to 31:
            Note: Normal number
            Set f32_exponent to exponent_shifted minus 15 plus 127
            Set f32_exponent to proc left_shift from Bitwise with f32_exponent, 23
        Otherwise:
            Note: Inf or NaN
            Set f32_exponent to proc left_shift from Bitwise with 255, 23
        End If
    End If

    Note: Extend mantissa from 10 to 23 bits
    Let f32_mantissa be proc left_shift from Bitwise with mantissa, 13

    Note: Combine components
    Let f32_bits be proc bitwise_or from Bitwise with f32_sign, f32_exponent
    Set f32_bits to proc bitwise_or from Bitwise with f32_bits, f32_mantissa

    proc memory_set_int32 from Memory with f32_ptr, 0, f32_bits
End Process

Process called "float32_to_float16" takes f32_ptr as Integer, f16_ptr as Integer:
    Note: Convert Float32 to Float16 (with rounding)

    Let f32_bits be proc memory_get_int32 from Memory with f32_ptr, 0

    Note: Extract components
    Let sign be proc right_shift from Bitwise with proc bitwise_and from Bitwise with f32_bits, -2147483648, 16
    Let exponent be proc right_shift from Bitwise with proc bitwise_and from Bitwise with f32_bits, 2139095040, 23
    Let mantissa be proc bitwise_and from Bitwise with f32_bits, 8388607

    Note: Convert exponent
    Let f16_exponent be 0
    If exponent is not equal to 0:
        If exponent is not equal to 255:
            Note: Normal number - adjust bias
            Set f16_exponent to exponent minus 127 plus 15

            Note: Clamp to representable range
            If f16_exponent is less than or equal to 0:
                Set f16_exponent to 0  Note: Underflow to zero
            Otherwise If f16_exponent is greater than or equal to 31:
                Set f16_exponent to 31  Note: Overflow to infinity
            End If

            Set f16_exponent to proc left_shift from Bitwise with f16_exponent, 10
        Otherwise:
            Note: Inf or NaN
            Set f16_exponent to proc left_shift from Bitwise with 31, 10
        End If
    End If

    Note: Truncate mantissa from 23 to 10 bits
    Let f16_mantissa be proc right_shift from Bitwise with mantissa, 13

    Note: Combine components
    Let f16_bits be proc bitwise_or from Bitwise with sign, f16_exponent
    Set f16_bits to proc bitwise_or from Bitwise with f16_bits, f16_mantissa

    proc memory_set_int16 from Memory with f16_ptr, 0, f16_bits
End Process

Process called "float16_add" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Add two Float16 values via Float32 conversion
    Note: SCRATCH SPACE REQUIRED: 36 bytes (3 × 4-byte Float32 + 24 bytes for float32_add scratch)

    Let temp_a be scratch_ptr
    Let temp_b be scratch_ptr plus 4
    Let temp_result be scratch_ptr plus 8
    Let add_scratch be scratch_ptr plus 12

    proc float16_to_float32 with a_ptr, temp_a
    proc float16_to_float32 with b_ptr, temp_b

    proc float32_add with temp_a, temp_b, temp_result, add_scratch

    proc float32_to_float16 with temp_result, result_ptr
End Process

Process called "float16_subtract" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Subtract two Float16 values via Float32 conversion
    Note: SCRATCH SPACE REQUIRED: 44 bytes (3 × 4-byte Float32 + 32 bytes for float32_subtract scratch)

    Let temp_a be scratch_ptr
    Let temp_b be scratch_ptr plus 4
    Let temp_result be scratch_ptr plus 8
    Let subtract_scratch be scratch_ptr plus 12

    proc float16_to_float32 with a_ptr, temp_a
    proc float16_to_float32 with b_ptr, temp_b

    proc float32_subtract with temp_a, temp_b, temp_result, subtract_scratch

    proc float32_to_float16 with temp_result, result_ptr
End Process

Process called "float16_multiply" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Multiply two Float16 values via Float32 conversion
    Note: SCRATCH SPACE REQUIRED: 36 bytes (3 × 4-byte Float32 + 24 bytes for float32_multiply scratch)

    Let temp_a be scratch_ptr
    Let temp_b be scratch_ptr plus 4
    Let temp_result be scratch_ptr plus 8
    Let multiply_scratch be scratch_ptr plus 12

    proc float16_to_float32 with a_ptr, temp_a
    proc float16_to_float32 with b_ptr, temp_b

    proc float32_multiply with temp_a, temp_b, temp_result, multiply_scratch

    proc float32_to_float16 with temp_result, result_ptr
End Process

Process called "float16_divide" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Divide two Float16 values via Float32 conversion
    Note: SCRATCH SPACE REQUIRED: 36 bytes (3 × 4-byte Float32 + 24 bytes for float32_divide scratch)

    Let temp_a be scratch_ptr
    Let temp_b be scratch_ptr plus 4
    Let temp_result be scratch_ptr plus 8
    Let divide_scratch be scratch_ptr plus 12

    proc float16_to_float32 with a_ptr, temp_a
    proc float16_to_float32 with b_ptr, temp_b

    proc float32_divide with temp_a, temp_b, temp_result, divide_scratch

    proc float32_to_float16 with temp_result, result_ptr
End Process

Note: ============================================================================
Note: Float80 Arithmetic Operations (x87 Extended Precision)
Note: ============================================================================

Note: Float80 (80-bit x87 extended precision) uses the x87 FPU.
Note: Format: 1 sign bit, 15 exponent bits, 64 mantissa bits (explicit leading 1)
Note: Precision: ~19 decimal digits, range: ±1.2×10^4932
Note: Use for: high-precision scientific computing, intermediate calculations

Note: Float80 Format (x87 Extended Precision - 80 bits total):
Note: - Byte 0-7: Mantissa (64 bits) - EXPLICIT leading 1 bit (unlike Float64)
Note: - Byte 8-9: Sign (bit 79) + Exponent (bits 78-64, 15 bits)
Note: - Exponent bias: 16383
Note: - Range: ~10^-4932 to ~10^4932

Process called "float80_is_nan" takes f80_ptr as Integer returns Integer:
    Note: Check if Float80 is NaN (exponent=32767, mantissa!=0 or implicit bit clear)
    Let exp_sign_word be proc memory_get_int16 from Memory with f80_ptr, 8
    Let exp be proc bitwise_and from Bitwise with exp_sign_word, 32767
    If exp is equal to 32767:
        Let mantissa_high be proc memory_get_int64 from Memory with f80_ptr, 0
        Let implicit_bit be proc bitwise_and from Bitwise with mantissa_high, -9223372036854775808
        If implicit_bit is equal to 0:
            Return 1
        End If
        Let mantissa_low_63 be proc bitwise_and from Bitwise with mantissa_high, 9223372036854775807
        If mantissa_low_63 is not equal to 0:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "float80_is_zero" takes f80_ptr as Integer returns Integer:
    Note: Check if Float80 is ±0 (mantissa=0, ignore sign)
    Let mantissa be proc memory_get_int64 from Memory with f80_ptr, 0
    If mantissa is equal to 0:
        Let exp_sign_word be proc memory_get_int16 from Memory with f80_ptr, 8
        Let exp be proc bitwise_and from Bitwise with exp_sign_word, 32767
        If exp is equal to 0:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "float80_add" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Add two float80 values: result = a + b
    Note: Pure Runa soft-float implementation for 80-bit extended precision

    Note: Check for NaN
    If proc float80_is_nan with a_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, a_ptr, 10
        Return
    End If
    If proc float80_is_nan with b_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, b_ptr, 10
        Return
    End If

    Note: Check for zero
    If proc float80_is_zero with a_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, b_ptr, 10
        Return
    End If
    If proc float80_is_zero with b_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, a_ptr, 10
        Return
    End If

    Note: Unpack operands (Float80: mantissa is EXPLICIT 64-bit)
    Let mant_a be proc memory_get_int64 from Memory with a_ptr, 0
    Let exp_sign_a be proc memory_get_int16 from Memory with a_ptr, 8
    Let sign_a be proc right_shift from Bitwise with exp_sign_a, 15
    Let exp_a be proc bitwise_and from Bitwise with exp_sign_a, 32767

    Let mant_b be proc memory_get_int64 from Memory with b_ptr, 0
    Let exp_sign_b be proc memory_get_int16 from Memory with b_ptr, 8
    Let sign_b be proc right_shift from Bitwise with exp_sign_b, 15
    Let exp_b be proc bitwise_and from Bitwise with exp_sign_b, 32767

    Note: Handle infinity
    If exp_a is equal to 32767:
        If exp_b is equal to 32767:
            If sign_a is not equal to sign_b:
                Let nan_mant be -9223372036854775808
                proc memory_set_int64 from Memory with result_ptr, 0, nan_mant
                proc memory_set_int16 from Memory with result_ptr, 8, 32767
                Return
            End If
        End If
        proc memory_copy from Memory with result_ptr, a_ptr, 10
        Return
    End If
    If exp_b is equal to 32767:
        proc memory_copy from Memory with result_ptr, b_ptr, 10
        Return
    End If

    Note: Align exponents (shift smaller mantissa right)
    Let exp_diff be exp_a minus exp_b
    If exp_diff is greater than 0:
        If exp_diff is greater than 63:
            proc memory_copy from Memory with result_ptr, a_ptr, 10
            Return
        End If
        Set mant_b to proc right_shift from Bitwise with mant_b, exp_diff
    Otherwise If exp_diff is less than 0:
        Let abs_diff be 0 minus exp_diff
        If abs_diff is greater than 63:
            proc memory_copy from Memory with result_ptr, b_ptr, 10
            Return
        End If
        Set mant_a to proc right_shift from Bitwise with mant_a, abs_diff
        Set exp_a to exp_b
    End If

    Note: Perform addition or subtraction based on signs
    Let result_mant be 0
    Let result_sign be sign_a
    If sign_a is equal to sign_b:
        Set result_mant to mant_a plus mant_b
        Note: Check for overflow (need to normalize)
        If result_mant is less than mant_a:
            Set result_mant to proc right_shift from Bitwise with result_mant, 1
            Set exp_a to exp_a plus 1
        End If
    Otherwise:
        If mant_a is greater than or equal to mant_b:
            Set result_mant to mant_a minus mant_b
            Set result_sign to sign_a
        Otherwise:
            Set result_mant to mant_b minus mant_a
            Set result_sign to sign_b
        End If
    End If

    Note: Normalize result (shift left until bit 63 is set)
    Let shift_count be 0
    While shift_count is less than 63:
        Let bit_63 be proc bitwise_and from Bitwise with result_mant, -9223372036854775808
        If bit_63 is not equal to 0:
            Exit While
        End If
        Set result_mant to proc left_shift from Bitwise with result_mant, 1
        Set exp_a to exp_a minus 1
        Set shift_count to shift_count plus 1
    End While

    Note: Handle underflow
    If exp_a is less than or equal to 0:
        proc memory_set_int64 from Memory with result_ptr, 0, 0
        proc memory_set_int16 from Memory with result_ptr, 8, 0
        Return
    End If

    Note: Pack result
    proc memory_set_int64 from Memory with result_ptr, 0, result_mant
    Let result_exp_sign be proc left_shift from Bitwise with result_sign, 15
    Set result_exp_sign to proc bitwise_or from Bitwise with result_exp_sign, exp_a
    proc memory_set_int16 from Memory with result_ptr, 8, result_exp_sign
End Process

Process called "float80_subtract" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Subtract two float80 values: result = a - b
    Note: Implemented as a + (-b) by flipping b's sign bit

    Note: Create negated b on stack (10 bytes)
    Let b_mant be proc memory_get_int64 from Memory with b_ptr, 0
    Let b_exp_sign be proc memory_get_int16 from Memory with b_ptr, 8
    Let b_sign be proc right_shift from Bitwise with b_exp_sign, 15
    Let b_exp be proc bitwise_and from Bitwise with b_exp_sign, 32767

    Note: Flip sign
    Let negated_sign be proc bitwise_xor from Bitwise with b_sign, 1
    Let negated_exp_sign be proc left_shift from Bitwise with negated_sign, 15
    Set negated_exp_sign to proc bitwise_or from Bitwise with negated_exp_sign, b_exp

    Note: Use scratch space for negated b (assume caller provides 10 bytes after result_ptr)
    Let b_negated_ptr be result_ptr plus 10
    proc memory_set_int64 from Memory with b_negated_ptr, 0, b_mant
    proc memory_set_int16 from Memory with b_negated_ptr, 8, negated_exp_sign

    proc float80_add with a_ptr, b_negated_ptr, result_ptr
End Process

Process called "float80_multiply" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Multiply two float80 values: result = a * b
    Note: Pure Runa soft-float multiplication for 80-bit

    Note: Check for NaN
    If proc float80_is_nan with a_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, a_ptr, 10
        Return
    End If
    If proc float80_is_nan with b_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, b_ptr, 10
        Return
    End If

    Note: Check for zero
    If proc float80_is_zero with a_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, a_ptr, 10
        Return
    End If
    If proc float80_is_zero with b_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, b_ptr, 10
        Return
    End If

    Note: Unpack operands
    Let mant_a be proc memory_get_int64 from Memory with a_ptr, 0
    Let exp_sign_a be proc memory_get_int16 from Memory with a_ptr, 8
    Let sign_a be proc right_shift from Bitwise with exp_sign_a, 15
    Let exp_a be proc bitwise_and from Bitwise with exp_sign_a, 32767

    Let mant_b be proc memory_get_int64 from Memory with b_ptr, 0
    Let exp_sign_b be proc memory_get_int16 from Memory with b_ptr, 8
    Let sign_b be proc right_shift from Bitwise with exp_sign_b, 15
    Let exp_b be proc bitwise_and from Bitwise with exp_sign_b, 32767

    Note: Result sign (XOR of signs)
    Let result_sign be proc bitwise_xor from Bitwise with sign_a, sign_b

    Note: Handle infinity
    If exp_a is equal to 32767:
        proc memory_set_int64 from Memory with result_ptr, 0, -9223372036854775808
        Let result_exp_sign be proc left_shift from Bitwise with result_sign, 15
        Set result_exp_sign to proc bitwise_or from Bitwise with result_exp_sign, 32767
        proc memory_set_int16 from Memory with result_ptr, 8, result_exp_sign
        Return
    End If
    If exp_b is equal to 32767:
        proc memory_set_int64 from Memory with result_ptr, 0, -9223372036854775808
        Let result_exp_sign be proc left_shift from Bitwise with result_sign, 15
        Set result_exp_sign to proc bitwise_or from Bitwise with result_exp_sign, 32767
        proc memory_set_int16 from Memory with result_ptr, 8, result_exp_sign
        Return
    End If

    Note: Add exponents and subtract bias
    Let result_exp be exp_a plus exp_b minus 16383

    Note: Multiply mantissas (64-bit × 64-bit requires splitting)
    Let a_high be proc right_shift from Bitwise with mant_a, 32
    Let a_low be proc bitwise_and from Bitwise with mant_a, 4294967295
    Let b_high be proc right_shift from Bitwise with mant_b, 32
    Let b_low be proc bitwise_and from Bitwise with mant_b, 4294967295

    Let hh be a_high multiplied by b_high
    Let hl be a_high multiplied by b_low
    Let lh be a_low multiplied by b_high
    Let ll be a_low multiplied by b_low

    Note: Combine products (simplified - take high 64 bits)
    Let mid be hl plus lh
    Let mid_high be proc right_shift from Bitwise with mid, 32
    Let result_mant be hh plus mid_high

    Note: Normalize if needed (result should have bit 63 set)
    Let bit_63 be proc bitwise_and from Bitwise with result_mant, -9223372036854775808
    If bit_63 is equal to 0:
        Set result_mant to proc left_shift from Bitwise with result_mant, 1
        Set result_exp to result_exp minus 1
    End If

    Note: Handle overflow/underflow
    If result_exp is greater than or equal to 32767:
        proc memory_set_int64 from Memory with result_ptr, 0, -9223372036854775808
        Let result_exp_sign be proc left_shift from Bitwise with result_sign, 15
        Set result_exp_sign to proc bitwise_or from Bitwise with result_exp_sign, 32767
        proc memory_set_int16 from Memory with result_ptr, 8, result_exp_sign
        Return
    End If
    If result_exp is less than or equal to 0:
        proc memory_set_int64 from Memory with result_ptr, 0, 0
        proc memory_set_int16 from Memory with result_ptr, 8, 0
        Return
    End If

    Note: Pack result
    proc memory_set_int64 from Memory with result_ptr, 0, result_mant
    Let result_exp_sign be proc left_shift from Bitwise with result_sign, 15
    Set result_exp_sign to proc bitwise_or from Bitwise with result_exp_sign, result_exp
    proc memory_set_int16 from Memory with result_ptr, 8, result_exp_sign
End Process

Process called "float80_divide" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Divide two float80 values: result = a / b
    Note: Pure Runa soft-float division for 80-bit

    Note: Check for NaN
    If proc float80_is_nan with a_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, a_ptr, 10
        Return
    End If
    If proc float80_is_nan with b_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, b_ptr, 10
        Return
    End If

    Note: Check for division by zero
    If proc float80_is_zero with b_ptr is equal to 1:
        Let exp_sign_a be proc memory_get_int16 from Memory with a_ptr, 8
        Let sign_a be proc right_shift from Bitwise with exp_sign_a, 15
        proc memory_set_int64 from Memory with result_ptr, 0, -9223372036854775808
        Let result_exp_sign be proc left_shift from Bitwise with sign_a, 15
        Set result_exp_sign to proc bitwise_or from Bitwise with result_exp_sign, 32767
        proc memory_set_int16 from Memory with result_ptr, 8, result_exp_sign
        Return
    End If

    Note: Check if numerator is zero
    If proc float80_is_zero with a_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, a_ptr, 10
        Return
    End If

    Note: Unpack operands
    Let mant_a be proc memory_get_int64 from Memory with a_ptr, 0
    Let exp_sign_a be proc memory_get_int16 from Memory with a_ptr, 8
    Let sign_a be proc right_shift from Bitwise with exp_sign_a, 15
    Let exp_a be proc bitwise_and from Bitwise with exp_sign_a, 32767

    Let mant_b be proc memory_get_int64 from Memory with b_ptr, 0
    Let exp_sign_b be proc memory_get_int16 from Memory with b_ptr, 8
    Let sign_b be proc right_shift from Bitwise with exp_sign_b, 15
    Let exp_b be proc bitwise_and from Bitwise with exp_sign_b, 32767

    Note: Result sign (XOR of signs)
    Let result_sign be proc bitwise_xor from Bitwise with sign_a, sign_b

    Note: Subtract exponents and add bias
    Let result_exp be exp_a minus exp_b plus 16383

    Note: Divide mantissas using bit-by-bit division
    Let quotient be 0
    Let remainder be mant_a
    Let i be 0
    While i is less than 64:
        Set remainder to proc left_shift from Bitwise with remainder, 1
        Set quotient to proc left_shift from Bitwise with quotient, 1
        If remainder is greater than or equal to mant_b:
            Set remainder to remainder minus mant_b
            Set quotient to quotient plus 1
        End If
        Set i to i plus 1
    End While

    Note: Normalize result (shift until bit 63 is set)
    Let shift_count be 0
    While shift_count is less than 63:
        Let bit_63 be proc bitwise_and from Bitwise with quotient, -9223372036854775808
        If bit_63 is not equal to 0:
            Exit While
        End If
        Set quotient to proc left_shift from Bitwise with quotient, 1
        Set result_exp to result_exp minus 1
        Set shift_count to shift_count plus 1
    End While

    Note: Handle overflow/underflow
    If result_exp is greater than or equal to 32767:
        proc memory_set_int64 from Memory with result_ptr, 0, -9223372036854775808
        Let result_exp_sign be proc left_shift from Bitwise with result_sign, 15
        Set result_exp_sign to proc bitwise_or from Bitwise with result_exp_sign, 32767
        proc memory_set_int16 from Memory with result_ptr, 8, result_exp_sign
        Return
    End If
    If result_exp is less than or equal to 0:
        proc memory_set_int64 from Memory with result_ptr, 0, 0
        proc memory_set_int16 from Memory with result_ptr, 8, 0
        Return
    End If

    Note: Pack result
    proc memory_set_int64 from Memory with result_ptr, 0, quotient
    Let result_exp_sign be proc left_shift from Bitwise with result_sign, 15
    Set result_exp_sign to proc bitwise_or from Bitwise with result_exp_sign, result_exp
    proc memory_set_int16 from Memory with result_ptr, 8, result_exp_sign
End Process

Process called "float80_sqrt" takes a_ptr as Integer, result_ptr as Integer, scratch_ptr as Integer:
    Note: Square root of Float80 using native Newton-Raphson iteration
    Note: Full 80-bit precision maintained throughout
    Note: SCRATCH SPACE REQUIRED: 80 bytes (8 × 10-byte Float80 values)
    Note:   scratch_ptr+0:  guess (10 bytes)
    Note:   scratch_ptr+10: temp1 (10 bytes) - a/guess
    Note:   scratch_ptr+20: temp2 (10 bytes) - guess + temp1
    Note:   scratch_ptr+30: temp3 (10 bytes) - temp2 * 0.5
    Note:   scratch_ptr+40: half constant (10 bytes)
    Note:   scratch_ptr+50: one constant (10 bytes)
    Note:   scratch_ptr+60: temp4 (10 bytes)
    Note:   scratch_ptr+70: temp5 (10 bytes)

    Note: Check for special cases
    If proc float80_is_nan with a_ptr is equal to 1:
        proc memory_copy from Memory with result_ptr, a_ptr, 10
        Return
    End If

    Let mant_a be proc memory_get_int64 from Memory with a_ptr, 0
    Let exp_sign_a be proc memory_get_int16 from Memory with a_ptr, 8
    Let sign_a be proc right_shift from Bitwise with exp_sign_a, 15
    Let exp_a be proc bitwise_and from Bitwise with exp_sign_a, 32767

    Note: Negative input (except -0) produces NaN
    If sign_a is equal to 1:
        If proc float80_is_zero with a_ptr is equal to 0:
            proc memory_set_int64 from Memory with result_ptr, 0, -9223372036854775808
            proc memory_set_int16 from Memory with result_ptr, 8, 32767
            Return
        Otherwise:
            proc memory_copy from Memory with result_ptr, a_ptr, 10
            Return
        End If
    End If

    Note: Handle zero
    If proc float80_is_zero with a_ptr is equal to 1:
        proc memory_set_int64 from Memory with result_ptr, 0, 0
        proc memory_set_int16 from Memory with result_ptr, 8, 0
        Return
    End If

    Note: Handle infinity
    If exp_a is equal to 32767:
        proc memory_copy from Memory with result_ptr, a_ptr, 10
        Return
    End If

    Note: Newton-Raphson: x_new = 0.5 * (x + a/x)
    Note: Initial guess: halve the exponent
    Let guess_exp be proc right_shift from Bitwise with exp_a plus 16383, 1
    Let guess_mant be -9223372036854775808

    Note: Setup scratch space pointers
    Let guess_ptr be scratch_ptr
    Let temp1_ptr be scratch_ptr plus 10
    Let temp2_ptr be scratch_ptr plus 20
    Let temp3_ptr be scratch_ptr plus 30
    Let half_ptr be scratch_ptr plus 40

    Note: Initialize guess
    proc memory_set_int64 from Memory with guess_ptr, 0, guess_mant
    proc memory_set_int16 from Memory with guess_ptr, 8, guess_exp

    Note: Create 0.5 constant (exponent = 16382, mantissa = 0x8000000000000000)
    proc memory_set_int64 from Memory with half_ptr, 0, -9223372036854775808
    proc memory_set_int16 from Memory with half_ptr, 8, 16382

    Note: Iterate 12 times for full Float80 convergence
    Let i be 0
    While i is less than 12:
        Note: temp1 = a / guess
        proc float80_divide with a_ptr, guess_ptr, temp1_ptr

        Note: temp2 = guess + temp1
        proc float80_add with guess_ptr, temp1_ptr, temp2_ptr

        Note: temp3 = temp2 * 0.5
        proc float80_multiply with temp2_ptr, half_ptr, temp3_ptr

        Note: guess = temp3
        proc memory_copy from Memory with guess_ptr, temp3_ptr, 10

        Set i to i plus 1
    End While

    Note: Copy final result
    proc memory_copy from Memory with result_ptr, guess_ptr, 10
End Process

Process called "float80_abs" takes a_ptr as Integer, result_ptr as Integer:
    Note: Absolute value of Float80: result = |a|
    Note: Pure Runa using bitwise AND to clear sign bit

    Let mant be proc memory_get_int64 from Memory with a_ptr, 0
    Let exp_sign be proc memory_get_int16 from Memory with a_ptr, 8
    Let exp_only be proc bitwise_and from Bitwise with exp_sign, 32767

    proc memory_set_int64 from Memory with result_ptr, 0, mant
    proc memory_set_int16 from Memory with result_ptr, 8, exp_only
End Process

Process called "float80_negate" takes a_ptr as Integer, result_ptr as Integer:
    Note: Negate Float80: result = -a
    Note: Pure Runa using bitwise XOR to flip sign bit

    Let mant be proc memory_get_int64 from Memory with a_ptr, 0
    Let exp_sign be proc memory_get_int16 from Memory with a_ptr, 8
    Let sign be proc right_shift from Bitwise with exp_sign, 15
    Let exp be proc bitwise_and from Bitwise with exp_sign, 32767

    Let flipped_sign be proc bitwise_xor from Bitwise with sign, 1
    Let result_exp_sign be proc left_shift from Bitwise with flipped_sign, 15
    Set result_exp_sign to proc bitwise_or from Bitwise with result_exp_sign, exp

    proc memory_set_int64 from Memory with result_ptr, 0, mant
    proc memory_set_int16 from Memory with result_ptr, 8, result_exp_sign
End Process

Note: ============================================================================
Note: Float128 Arithmetic Operations (IEEE 754 Quadruple Precision)
Note: ============================================================================

Note: Float128 (128-bit quad precision) requires software emulation on most CPUs.
Note: Format: 1 sign bit, 15 exponent bits, 112 mantissa bits
Note: Precision: ~34 decimal digits, range: ±1.2×10^4932
Note: Use for: ultra-high-precision scientific computing, cryptography

Note: Float128 uses custom pure-Runa soft-float implementation (float128_softfloat.runa).
Note: This provides production-quality IEEE 754 quadruple precision without external dependencies.
Note: Performance: ~100-400x slower than hardware Float64, acceptable for high-precision computing.

Process called "float128_add" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Float128 addition using custom soft-float library
    Note: Fully functional IEEE 754 quad precision addition
    proc float128_add from SoftFloat with a_ptr, b_ptr, result_ptr
End Process

Process called "float128_subtract" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Float128 subtraction using custom soft-float library
    proc float128_subtract from SoftFloat with a_ptr, b_ptr, result_ptr
End Process

Process called "float128_multiply" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Float128 multiplication using custom soft-float library
    proc float128_multiply from SoftFloat with a_ptr, b_ptr, result_ptr
End Process

Process called "float128_divide" takes a_ptr as Integer, b_ptr as Integer, result_ptr as Integer:
    Note: Float128 division using custom soft-float library
    proc float128_divide from SoftFloat with a_ptr, b_ptr, result_ptr
End Process

Process called "float128_sqrt" takes a_ptr as Integer, result_ptr as Integer:
    Note: Float128 square root using custom soft-float library
    proc float128_sqrt from SoftFloat with a_ptr, result_ptr
End Process

Note: ============================================================================
Note: Float Type Summary
Note: ============================================================================

Note: Type      | Size  | Precision | Range            | Implementation
Note: ----------|-------|-----------|------------------|------------------
Note: Float16   | 2B    | ~3-4 dig  | ±65504           | Software (via F32)
Note: Float32   | 4B    | ~7 dig    | ±3.4×10^38       | SSE (native HW)
Note: Float64   | 8B    | ~15 dig   | ±1.8×10^308      | SSE2 (native HW)
Note: Float80   | 10B   | ~19 dig   | ±1.2×10^4932     | x87 FPU (native HW)
Note: Float128  | 16B   | ~34 dig   | ±1.2×10^4932     | Software (pure Runa!)

Note: Recommendations:
Note: - Float32: Default for graphics, games, ML inference
Note: - Float64: Default for scientific computing, general use
Note: - Float80: High-precision intermediate calculations
Note: - Float16: Neural networks, memory-critical ML applications
Note: - Float128: Specialized high-precision scientific applications (rare)
Note: ============================================================================
