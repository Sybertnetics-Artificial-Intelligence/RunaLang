Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file provides CORE string operations needed by Layer 0 and Layer 1 primitives.

These are the absolute minimum string functions needed for:
- sizeof.runa (string_equals for type name comparison)
- offsetof.runa (string_equals for field name lookup)
- Any other primitive that needs basic string comparison

This is Layer 0 because it depends ONLY on memory_core.runa

Higher-level string operations (concat, duplicate, etc.) belong in
core/string_primitive.runa (Layer 2).

Depends on: memory_core.runa (for memory_compare)
:End Note

Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Note: ============================================================================
Note: Basic String Operations
Note: ============================================================================

Process called "string_length" takes str as Integer returns Integer:
    Note: Calculate length of null-terminated string
    Note: Returns number of characters before null terminator

    If str is equal to 0:
        Return 0  Note: NULL pointer
    End If

    Let len be 0
    While memory_get_byte(str, len) is not equal to 0:
        Set len to len plus 1
    End While

    Return len
End Process

Process called "string_char_at" takes str as Integer, index as Integer returns Integer:
    Note: Get character (byte value) at specified index in string
    Note: Returns byte value at position, or 0 if index is out of bounds or str is NULL
    Note: No bounds checking - caller must ensure index is valid

    If str is equal to 0:
        Return 0  Note: NULL pointer
    End If

    If index is less than 0:
        Return 0  Note: Negative index invalid
    End If

    Note: Get byte at position using memory_get_byte
    Let byte_value be memory_get_byte(str, index)
    Return byte_value
End Process

Process called "string_equals" takes str1 as Integer, str2 as Integer returns Integer:
    Note: Compare two strings for equality
    Note: Returns 1 if equal, 0 if not equal

    If str1 is equal to 0:
        If str2 is equal to 0:
            Return 1  Note: Both NULL
        End If
        Return 0  Note: One NULL
    End If

    If str2 is equal to 0:
        Return 0  Note: One NULL
    End If

    Note: Compare byte by byte until null terminator or mismatch
    Let i be 0
    While 1 is equal to 1:
        Let byte1 be memory_get_byte(str1, i)
        Let byte2 be memory_get_byte(str2, i)

        If byte1 is not equal to byte2:
            Return 0  Note: Mismatch
        End If

        If byte1 is equal to 0:
            Return 1  Note: Both strings ended, they're equal
        End If

        Set i to i plus 1
    End While

    Return 0  Note: Should never reach here
End Process

Process called "string_compare" takes str1 as Integer, str2 as Integer returns Integer:
    Note: Compare two strings lexicographically
    Note: Returns: -1 if str1 < str2, 0 if equal, 1 if str1 > str2

    If str1 is equal to 0:
        If str2 is equal to 0:
            Return 0  Note: Both NULL
        End If
        Return -1  Note: NULL < non-NULL
    End If

    If str2 is equal to 0:
        Return 1  Note: non-NULL > NULL
    End If

    Let i be 0
    While 1 is equal to 1:
        Let byte1 be memory_get_byte(str1, i)
        Let byte2 be memory_get_byte(str2, i)

        If byte1 is less than byte2:
            Return -1
        End If

        If byte1 is greater than byte2:
            Return 1
        End If

        If byte1 is equal to 0:
            Return 0  Note: Equal and both ended
        End If

        Set i to i plus 1
    End While

    Return 0
End Process

Process called "string_starts_with" takes str as Integer, prefix as Integer returns Integer:
    Note: Check if string starts with prefix
    Note: Returns 1 if str starts with prefix, 0 otherwise

    If str is equal to 0:
        Return 0
    End If

    If prefix is equal to 0:
        Return 1  Note: Empty prefix matches everything
    End If

    Let i be 0
    While 1 is equal to 1:
        Let prefix_byte be memory_get_byte(prefix, i)

        If prefix_byte is equal to 0:
            Return 1  Note: Reached end of prefix, match!
        End If

        Let str_byte be memory_get_byte(str, i)

        If str_byte is not equal to prefix_byte:
            Return 0  Note: Mismatch
        End If

        Set i to i plus 1
    End While

    Return 0
End Process

Process called "string_ends_with" takes str as Integer, suffix as Integer returns Integer:
    Note: Check if string ends with suffix
    Note: Returns 1 if str ends with suffix, 0 otherwise

    If str is equal to 0:
        Return 0
    End If

    If suffix is equal to 0:
        Return 1  Note: Empty suffix matches everything
    End If

    Let str_len be string_length(str)
    Let suffix_len be string_length(suffix)

    If suffix_len is greater than str_len:
        Return 0  Note: Suffix longer than string
    End If

    Note: Compare from the end
    Let offset be str_len minus suffix_len
    Let i be 0
    While i is less than suffix_len:
        Let str_byte be memory_get_byte(str, offset plus i)
        Let suffix_byte be memory_get_byte(suffix, i)

        If str_byte is not equal to suffix_byte:
            Return 0
        End If

        Set i to i plus 1
    End While

    Return 1
End Process

Process called "string_copy_to_buffer" takes src as Integer, dest as Integer, dest_offset as Integer returns Integer:
    Note: Copy source string to destination buffer at specified offset
    Note: Does NOT add null terminator - caller must handle that
    Note: Returns number of bytes copied
    Note: Used for building composite strings in error messages

    If src is equal to 0:
        Return 0  Note: NULL source
    End If

    If dest is equal to 0:
        Return 0  Note: NULL destination
    End If

    Let i be 0
    While 1 is equal to 1:
        Let byte_value be memory_get_byte(src, i)

        If byte_value is equal to 0:
            Note: Reached null terminator, done copying
            Return i
        End If

        memory_set_byte(dest, dest_offset plus i, byte_value)
        Set i to i plus 1
    End While

    Return i
End Process
