Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles boolean primitive type and boolean operations.

This file performs the following tasks:
- Process boolean values and boolean type handling
- Handle boolean operations and boolean logic processing
- Manage boolean optimization and boolean constant folding
- Process boolean conversion and boolean type promotion

This file is essential because of the following reasons:
- Boolean primitives are fundamental to logical programming and control flow
- Proper boolean handling ensures correct logical computation and decision making
- Boolean optimization improves performance for logical operations

This file consists of the following functions/features/operation types:
- Boolean value processing and boolean type handling
- Boolean operations and boolean logic processing
- Boolean optimization and boolean constant folding
- Boolean conversion and boolean type promotion

Dependencies:
- core/string_primitive.runa (for boolean_to_string conversion)
:End Note

Import "compiler/frontend/primitives/core/string_primitive.runa" as StringPrimitive

Note: ============================================================================
Note: Boolean Type Definition (Native Type)
Note: ============================================================================

Note: Boolean is a native type in Runa for type-safe logical operations.
Note: Storage: 1 byte (more efficient than 8-byte Integer)
Note: Values: true (1) or false (0)
Note: Type safety: prevents accidental use of integers as booleans
Note: ============================================================================

Type Called "Boolean":
    Note: Native boolean type with 1-byte storage
    Note: Represented as unsigned 8-bit value: 0 = false, 1 = true
    Note: Compiler enforces type safety - cannot implicitly convert Integer to Boolean

    Note: Internal representation (compiler implementation detail):
    Note: - Size: 1 byte
    Note: - Alignment: 1 byte
    Note: - Valid values: 0 (false) or 1 (true)
    Note: - Invalid values cause undefined behavior
End Type

Note: Boolean constants (built into language)
Let FALSE be 0
Let TRUE be 1

Note: ============================================================================
Note: Boolean Primitive Functions
Note: ============================================================================

Process called "boolean_true" returns Boolean:
    Note: Return the boolean true value
    Return true
End Process

Process called "boolean_false" returns Boolean:
    Note: Return the boolean false value
    Return false
End Process

Note: ============================================================================
Note: Boolean Conversion Functions
Note: ============================================================================

Process called "boolean_from_int" takes value as Integer returns Boolean:
    Note: Convert integer to boolean (explicit conversion)
    Note: Returns true if value is non-zero, false otherwise
    If value is not equal to 0:
        Return true
    End If
    Return false
End Process

Process called "boolean_to_int" takes value as Boolean returns Integer:
    Note: Convert boolean to integer (explicit conversion)
    Note: Returns 1 if true, 0 if false
    If value:
        Return 1
    End If
    Return 0
End Process

Process called "boolean_to_string" takes value as Boolean, scratch_ptr as Integer returns Integer:
    Note: Convert boolean to string representation
    Note: Returns pointer to "true" or "false" string
    Note: SCRATCH SPACE REQUIRED: 8 bytes for string allocation
    Note: Allocates a new string each time - caller must manage memory

    If value:
        Note: Return "true" (4 characters + null terminator = 5 bytes)
        Let str_true be proc allocate from StringPrimitive with 5
        proc memory_set_byte from StringPrimitive with str_true, 0, 116  Note: 't'
        proc memory_set_byte from StringPrimitive with str_true, 1, 114  Note: 'r'
        proc memory_set_byte from StringPrimitive with str_true, 2, 117  Note: 'u'
        proc memory_set_byte from StringPrimitive with str_true, 3, 101  Note: 'e'
        proc memory_set_byte from StringPrimitive with str_true, 4, 0    Note: null terminator
        Return str_true
    End If

    Note: Return "false" (5 characters + null terminator = 6 bytes)
    Let str_false be proc allocate from StringPrimitive with 6
    proc memory_set_byte from StringPrimitive with str_false, 0, 102  Note: 'f'
    proc memory_set_byte from StringPrimitive with str_false, 1, 97   Note: 'a'
    proc memory_set_byte from StringPrimitive with str_false, 2, 108  Note: 'l'
    proc memory_set_byte from StringPrimitive with str_false, 3, 115  Note: 's'
    proc memory_set_byte from StringPrimitive with str_false, 4, 101  Note: 'e'
    proc memory_set_byte from StringPrimitive with str_false, 5, 0    Note: null terminator
    Return str_false
End Process

Note: ============================================================================
Note: Boolean Logical Operations
Note: ============================================================================

Process called "boolean_and" takes a as Boolean, b as Boolean returns Boolean:
    Note: Logical AND operation on boolean values
    Note: Returns true only if both a AND b are true
    If a:
        If b:
            Return true
        End If
    End If
    Return false
End Process

Process called "boolean_or" takes a as Boolean, b as Boolean returns Boolean:
    Note: Logical OR operation on boolean values
    Note: Returns true if either a OR b is true
    If a:
        Return true
    End If
    If b:
        Return true
    End If
    Return false
End Process

Process called "boolean_not" takes a as Boolean returns Boolean:
    Note: Logical NOT operation (negation)
    Note: Returns true if a is false, false if a is true
    If a:
        Return false
    End If
    Return true
End Process

Process called "boolean_xor" takes a as Boolean, b as Boolean returns Boolean:
    Note: Logical XOR operation (exclusive or)
    Note: Returns true if exactly one of a or b is true
    If a:
        If b:
            Return false  Note: Both true = false
        End If
        Return true  Note: Only a is true = true
    End If
    If b:
        Return true  Note: Only b is true = true
    End If
    Return false  Note: Both false = false
End Process

Process called "boolean_equals" takes a as Boolean, b as Boolean returns Boolean:
    Note: Test if two booleans are equal
    Note: Returns true if a == b
    If a:
        Return b  Note: If a is true, return b
    End If
    Return proc boolean_not with b  Note: If a is false, return NOT b
End Process

Process called "boolean_not_equals" takes a as Boolean, b as Boolean returns Boolean:
    Note: Test if two booleans are not equal
    Note: Returns true if a != b (equivalent to XOR)
    Return proc boolean_xor with a, b
End Process

Note: ============================================================================
Note: Boolean Type Usage Examples
Note: ============================================================================

Note: Declaration:
Note:   Let is_valid as Boolean be true
Note:   Let is_empty as Boolean be false

Note: Conditional usage:
Note:   If is_valid:
Note:       Note: Execute when true
Note:   End If

Note: Logical operations:
Note:   Let result as Boolean be boolean_and(is_valid, boolean_not(is_empty))

Note: Conversion:
Note:   Let flag as Boolean be boolean_from_int(some_integer)
Note:   Let number as Integer be boolean_to_int(some_boolean)
Note: ============================================================================
