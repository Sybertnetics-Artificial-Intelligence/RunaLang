Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles variable statement validation and analysis for the compiler.

This file performs the following tasks:
- Validate variable declarations (let statements)
- Validate variable assignments (set statements)
- Analyze compound assignments and type compatibility
- Validate variable initialization and type inference
- Detect uninitialized variable usage

This file is essential because of the following reasons:
- Variable declarations must have valid types
- Assignments must be type-compatible
- Uninitialized variables must be detected
- Type inference must be deterministic

Dependencies:
- NONE (pure analysis and validation)
:End Note

Note: ============================================================================
Note: Let Statement Validation (Variable Declaration)
Note: ============================================================================

Process called "validate_let_statement" takes has_type as Integer, has_initializer as Integer, type_id as Integer, initializer_type as Integer returns Integer:
    Note: Validate let statement (variable declaration)
    Note: has_type: 1 if type explicitly specified
    Note: has_initializer: 1 if initial value provided
    Note: type_id: type ID if explicitly specified
    Note: initializer_type: type of initializer expression
    Note: Returns 1 if valid, 0 if invalid

    Note: Must have either explicit type or initializer for type inference
    If has_type is equal to 0:
        If has_initializer is equal to 0:
            Return 0
        End If
    End If

    Note: If both type and initializer, check compatibility
    If has_type is equal to 1:
        If has_initializer is equal to 1:
            Let compatible be proc types_compatible with initializer_type, type_id
            If compatible is equal to 0:
                Return 0
            End If
        End If
    End If

    Return 1
End Process

Process called "can_infer_type" takes has_initializer as Integer, initializer_type as Integer returns Integer:
    Note: Check if variable type can be inferred from initializer
    Note: has_initializer: 1 if initializer present
    Note: initializer_type: type of initializer (3=void is invalid)
    Note: Returns 1 if can infer, 0 if cannot

    Note: Must have initializer to infer type
    If has_initializer is equal to 0:
        Return 0
    End If

    Note: Cannot infer from void expression
    If initializer_type is equal to 3:
        Return 0
    End If

    Return 1
End Process

Process called "requires_initialization" takes type_id as Integer, has_initializer as Integer returns Integer:
    Note: Check if variable requires explicit initialization
    Note: Some types must be initialized (references, const)
    Note: type_id: type of variable
    Note: has_initializer: 1 if initializer provided
    Note: Returns 1 if needs initialization, 0 if can be uninitialized

    Note: For primitives, initialization is optional
    Note: This function returns 0 for all types (Runa allows uninitialized)
    Return 0
End Process

Note: ============================================================================
Note: Set Statement Validation (Variable Assignment)
Note: ============================================================================

Process called "validate_set_statement" takes variable_type as Integer, value_type as Integer, variable_is_const as Integer returns Integer:
    Note: Validate set statement (variable assignment)
    Note: variable_type: type of variable being assigned to
    Note: value_type: type of value being assigned
    Note: variable_is_const: 1 if variable is constant
    Note: Returns 1 if valid, 0 if invalid

    Note: Cannot assign to const variable
    If variable_is_const is equal to 1:
        Return 0
    End If

    Note: Check type compatibility
    Let compatible be proc types_compatible with value_type, variable_type
    If compatible is equal to 0:
        Return 0
    End If

    Return 1
End Process

Process called "types_compatible" takes actual_type as Integer, expected_type as Integer returns Integer:
    Note: Check if actual type can be assigned to expected type
    Note: Returns 1 if compatible, 0 if incompatible

    Note: Exact match
    If actual_type is equal to expected_type:
        Return 1
    End If

    Note: Check numeric compatibility
    Let actual_is_numeric be proc is_numeric_type with actual_type
    Let expected_is_numeric be proc is_numeric_type with expected_type

    If actual_is_numeric is equal to 1:
        If expected_is_numeric is equal to 1:
            Let can_widen be proc can_widen_numeric with actual_type, expected_type
            Return can_widen
        End If
    End If

    Note: Pointer compatibility
    If actual_type is equal to 2:
        If expected_type is equal to 2:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "is_numeric_type" takes type_id as Integer returns Integer:
    Note: Check if type is numeric
    Note: Returns 1 if numeric, 0 otherwise

    Note: Integer (1)
    If type_id is equal to 1:
        Return 1
    End If

    Note: Sized integers (10-15)
    If type_id is greater than or equal to 10:
        If type_id is less than or equal to 15:
            Return 1
        End If
    End If

    Note: Unsigned integers (19-25)
    If type_id is greater than or equal to 19:
        If type_id is less than or equal to 25:
            Return 1
        End If
    End If

    Note: Floats (30-35)
    If type_id is greater than or equal to 30:
        If type_id is less than or equal to 35:
            Return 1
        End If
    End If

    Note: Decimals (40-41)
    If type_id is greater than or equal to 40:
        If type_id is less than or equal to 41:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "can_widen_numeric" takes from_type as Integer, to_type as Integer returns Integer:
    Note: Check if numeric type can be widened
    Note: Returns 1 if can widen, 0 if cannot

    Note: Integer8 (10) can widen to larger integers
    If from_type is equal to 10:
        If to_type is greater than or equal to 11:
            If to_type is less than or equal to 15:
                Return 1
            End If
        End If
        If to_type is equal to 1:
            Return 1
        End If
    End If

    Note: Integer16 (11) can widen to 32, 64, 128, 256, 512
    If from_type is equal to 11:
        If to_type is greater than or equal to 12:
            If to_type is less than or equal to 15:
                Return 1
            End If
        End If
        If to_type is equal to 1:
            Return 1
        End If
    End If

    Note: Integer32 (12) can widen to 64, 128, 256, 512
    If from_type is equal to 12:
        If to_type is greater than or equal to 13:
            If to_type is less than or equal to 15:
                Return 1
            End If
        End If
        If to_type is equal to 1:
            Return 1
        End If
    End If

    Note: Integer (1, 64-bit) can widen to 128, 256, 512
    If from_type is equal to 1:
        If to_type is greater than or equal to 13:
            If to_type is less than or equal to 15:
                Return 1
            End If
        End If
    End If

    Note: Integer types can widen to floats
    If to_type is greater than or equal to 30:
        If to_type is less than or equal to 35:
            Return 1
        End If
    End If

    Note: Floats can widen to larger floats
    If from_type is greater than or equal to 30:
        If from_type is less than or equal to 35:
            If to_type is greater than from_type:
                If to_type is less than or equal to 35:
                    Return 1
                End If
            End If
        End If
    End If

    Return 0
End Process

Note: ============================================================================
Note: Compound Assignment Validation
Note: ============================================================================

Process called "validate_compound_assignment" takes variable_type as Integer, operation_type as Integer, operand_type as Integer returns Integer:
    Note: Validate compound assignment (+=, -=, *=, etc)
    Note: variable_type: type of variable being modified
    Note: operation_type: arithmetic operation (1=add, 2=sub, 3=mul, 4=div, 5=mod)
    Note: operand_type: type of right-hand operand
    Note: Returns 1 if valid, 0 if invalid

    Note: Variable must be numeric for arithmetic compound assignment
    Let var_is_numeric be proc is_numeric_type with variable_type
    If var_is_numeric is equal to 0:
        Return 0
    End If

    Note: Operand must be numeric
    Let op_is_numeric be proc is_numeric_type with operand_type
    If op_is_numeric is equal to 0:
        Return 0
    End If

    Note: Modulo requires both operands to be integers
    If operation_type is equal to 5:
        Let var_is_integer be proc is_integer_type with variable_type
        Let op_is_integer be proc is_integer_type with operand_type
        If var_is_integer is equal to 0:
            Return 0
        End If
        If op_is_integer is equal to 0:
            Return 0
        End If
    End If

    Return 1
End Process

Process called "is_integer_type" takes type_id as Integer returns Integer:
    Note: Check if type is integer (not float)
    Note: Returns 1 if integer, 0 otherwise

    Note: Integer (1)
    If type_id is equal to 1:
        Return 1
    End If

    Note: Sized integers (10-15)
    If type_id is greater than or equal to 10:
        If type_id is less than or equal to 15:
            Return 1
        End If
    End If

    Note: Unsigned integers (19-25)
    If type_id is greater than or equal to 19:
        If type_id is less than or equal to 25:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "get_compound_operation_result_type" takes variable_type as Integer, operand_type as Integer returns Integer:
    Note: Determine result type of compound assignment operation
    Note: Result must be compatible with variable type
    Note: Returns result type ID

    Note: Numeric promotion rules apply
    Let result_type be proc get_arithmetic_result_type with variable_type, operand_type
    Return result_type
End Process

Process called "get_arithmetic_result_type" takes left_type as Integer, right_type as Integer returns Integer:
    Note: Determine result type of arithmetic operation
    Note: Type promotion: decimal > float > integer
    Note: Returns result type ID

    Note: Decimal types (40-41) have highest precedence
    If left_type is greater than or equal to 40:
        If left_type is less than or equal to 41:
            Return left_type
        End If
    End If
    If right_type is greater than or equal to 40:
        If right_type is less than or equal to 41:
            Return right_type
        End If
    End If

    Note: Float types (30-35) promote integers
    If left_type is greater than or equal to 30:
        If left_type is less than or equal to 35:
            If right_type is greater than or equal to 30:
                If right_type is less than or equal to 35:
                    Note: Both floats, use larger
                    If left_type is greater than right_type:
                        Return left_type
                    End If
                    Return right_type
                End If
            End If
            Return left_type
        End If
    End If
    If right_type is greater than or equal to 30:
        If right_type is less than or equal to 35:
            Return right_type
        End If
    End If

    Note: Both integers, use larger
    If left_type is greater than right_type:
        Return left_type
    End If
    Return right_type
End Process

Note: ============================================================================
Note: Variable Initialization Analysis
Note: ============================================================================

Process called "is_initialized" takes has_initializer as Integer, assigned_before_use as Integer returns Integer:
    Note: Check if variable is initialized before use
    Note: has_initializer: 1 if variable has initializer in declaration
    Note: assigned_before_use: 1 if variable assigned before first use
    Note: Returns 1 if initialized, 0 if uninitialized

    Note: Has initializer in declaration
    If has_initializer is equal to 1:
        Return 1
    End If

    Note: Assigned before use
    If assigned_before_use is equal to 1:
        Return 1
    End If

    Note: Uninitialized
    Return 0
End Process

Process called "requires_zero_initialization" takes type_id as Integer returns Integer:
    Note: Check if type requires zero initialization
    Note: Pointers should be initialized to null for safety
    Note: type_id: type of variable
    Note: Returns 1 if should zero-init, 0 if can leave uninitialized

    Note: Pointers benefit from null initialization
    If type_id is equal to 2:
        Return 1
    End If

    Note: Other types do not require zero initialization
    Return 0
End Process

Process called "get_default_initializer" takes type_id as Integer returns Integer:
    Note: Get default initializer value for type
    Note: Returns default value (0 for most types)

    Note: All types default to 0
    Return 0
End Process

Note: ============================================================================
Note: Variable Usage Analysis
Note: ============================================================================

Process called "is_variable_used" takes read_count as Integer, write_count as Integer returns Integer:
    Note: Check if variable is used in code
    Note: read_count: number of times variable is read
    Note: write_count: number of times variable is written
    Note: Returns 1 if used, 0 if unused

    Note: Variable is used if read
    If read_count is greater than 0:
        Return 1
    End If

    Note: Variable is used if written (even if not read)
    If write_count is greater than 0:
        Return 1
    End If

    Return 0
End Process

Process called "is_variable_read" takes read_count as Integer returns Integer:
    Note: Check if variable is ever read
    Note: Returns 1 if read, 0 if never read

    If read_count is greater than 0:
        Return 1
    End If

    Return 0
End Process

Process called "is_write_only_variable" takes read_count as Integer, write_count as Integer returns Integer:
    Note: Check if variable is only written, never read
    Note: Write-only variables may indicate dead code
    Note: Returns 1 if write-only, 0 if read

    Note: Must have writes
    If write_count is equal to 0:
        Return 0
    End If

    Note: Must have no reads
    If read_count is greater than 0:
        Return 0
    End If

    Return 1
End Process

Note: ============================================================================
Note: Variable Scope Analysis
Note: ============================================================================

Process called "is_variable_in_scope" takes variable_scope_depth as Integer, current_scope_depth as Integer returns Integer:
    Note: Check if variable is accessible from current scope
    Note: Variables are accessible in their scope and nested scopes
    Note: variable_scope_depth: depth where variable was declared
    Note: current_scope_depth: depth of current scope
    Note: Returns 1 if in scope, 0 if out of scope

    Note: Variable accessible if declared in current or outer scope
    If variable_scope_depth is less than or equal to current_scope_depth:
        Return 1
    End If

    Return 0
End Process

Process called "is_shadowing" takes existing_var_scope as Integer, new_var_scope as Integer returns Integer:
    Note: Check if new variable shadows existing variable
    Note: Shadowing occurs when variable in inner scope has same name as outer
    Note: existing_var_scope: scope of existing variable
    Note: new_var_scope: scope of new variable
    Note: Returns 1 if shadowing, 0 if not

    Note: Shadowing if new variable is in deeper scope
    If new_var_scope is greater than existing_var_scope:
        Return 1
    End If

    Return 0
End Process

Process called "calculate_variable_lifetime" takes scope_depth as Integer returns Integer:
    Note: Calculate lifetime of variable based on scope
    Note: scope_depth: nesting depth (0=global, 1=function, 2+=nested)
    Note: Returns lifetime indicator (0=global, 1=function, 2=block)

    Note: Global variables (depth 0)
    If scope_depth is equal to 0:
        Return 0
    End If

    Note: Function-level variables (depth 1)
    If scope_depth is equal to 1:
        Return 1
    End If

    Note: Block-level variables (depth 2+)
    Return 2
End Process

Note: ============================================================================
Note: Variable Mutability Analysis
Note: ============================================================================

Process called "is_const_variable" takes is_const as Integer returns Integer:
    Note: Check if variable is constant
    Note: is_const: 1 if variable declared as const
    Note: Returns 1 if const, 0 if mutable

    If is_const is equal to 1:
        Return 1
    End If

    Return 0
End Process

Process called "can_modify_variable" takes is_const as Integer, in_initializer as Integer returns Integer:
    Note: Check if variable can be modified
    Note: is_const: 1 if variable is const
    Note: in_initializer: 1 if in initializer expression
    Note: Returns 1 if can modify, 0 if cannot

    Note: Const variables can only be set in initializer
    If is_const is equal to 1:
        If in_initializer is equal to 0:
            Return 0
        End If
    End If

    Return 1
End Process

Note: ============================================================================
Note: Variable Declaration Optimization
Note: ============================================================================

Process called "can_eliminate_unused_variable" takes is_used as Integer, has_side_effects as Integer returns Integer:
    Note: Check if unused variable can be eliminated
    Note: is_used: 1 if variable is used
    Note: has_side_effects: 1 if initializer has side effects
    Note: Returns 1 if can eliminate, 0 if must keep

    Note: Cannot eliminate used variables
    If is_used is equal to 1:
        Return 0
    End If

    Note: Cannot eliminate if initializer has side effects
    If has_side_effects is equal to 1:
        Return 0
    End If

    Return 1
End Process

Process called "can_propagate_constant" takes is_const as Integer, initializer_is_constant as Integer, single_use as Integer returns Integer:
    Note: Check if variable can be replaced with its constant value
    Note: is_const: 1 if variable is const
    Note: initializer_is_constant: 1 if initialized with constant
    Note: single_use: 1 if variable used only once
    Note: Returns 1 if can propagate, 0 if keep variable

    Note: Must be const to propagate
    If is_const is equal to 0:
        Return 0
    End If

    Note: Must have constant initializer
    If initializer_is_constant is equal to 0:
        Return 0
    End If

    Note: Can propagate const variables with constant initializers
    Return 1
End Process

Process called "should_promote_to_register" takes access_count as Integer, is_loop_variable as Integer returns Integer:
    Note: Determine if variable should be kept in register
    Note: access_count: number of times variable accessed
    Note: is_loop_variable: 1 if variable used in loop
    Note: Returns 1 if should use register, 0 if stack ok

    Note: Loop variables benefit from registers
    If is_loop_variable is equal to 1:
        Return 1
    End If

    Note: Frequently accessed variables benefit from registers
    If access_count is greater than 10:
        Return 1
    End If

    Return 0
End Process
