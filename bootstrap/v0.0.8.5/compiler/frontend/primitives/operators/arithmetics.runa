Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles arithmetic operator validation and evaluation for the compiler.

This file performs the following tasks:
- Validate arithmetic operator operands (type checking)
- Evaluate constant arithmetic expressions (compile-time constant folding)
- Determine result types for arithmetic operations
- Validate division by zero and overflow conditions

This file is essential because of the following reasons:
- Arithmetic operators work with numeric types (compiler must validate)
- Constant folding optimizes arithmetic at compile time
- Type promotion rules must be enforced for mixed-type operations
- Division by zero must be caught at compile time when possible

Dependencies:
- core/arithmetic_core.runa (arithmetic operations for constant folding)
:End Note

Import "compiler/frontend/primitives/core/arithmetic_core.runa" as ArithmeticCore

Note: ============================================================================
Note: Arithmetic Operator Type Validation
Note: ============================================================================

Process called "is_valid_arithmetic_operand_type" takes type_id as Integer returns Integer:
    Note: Check if a type is valid for arithmetic operations
    Note: Numeric types (integers, floats, decimals) are valid
    Note: Returns 1 if valid, 0 if invalid

    Note: Integer types
    If type_id is equal to 1:
        Return 1
    End If
    If type_id is equal to 10:
        Return 1
    End If
    If type_id is equal to 11:
        Return 1
    End If
    If type_id is equal to 12:
        Return 1
    End If
    If type_id is equal to 13:
        Return 1
    End If
    If type_id is equal to 14:
        Return 1
    End If
    If type_id is equal to 15:
        Return 1
    End If

    Note: Unsigned integers
    If type_id is equal to 19:
        Return 1
    End If
    If type_id is equal to 20:
        Return 1
    End If
    If type_id is equal to 21:
        Return 1
    End If
    If type_id is equal to 22:
        Return 1
    End If
    If type_id is equal to 23:
        Return 1
    End If
    If type_id is equal to 24:
        Return 1
    End If
    If type_id is equal to 25:
        Return 1
    End If

    Note: Floating point types
    If type_id is equal to 30:
        Return 1
    End If
    If type_id is equal to 31:
        Return 1
    End If
    If type_id is equal to 32:
        Return 1
    End If
    If type_id is equal to 33:
        Return 1
    End If
    If type_id is equal to 34:
        Return 1
    End If
    If type_id is equal to 35:
        Return 1
    End If

    Note: Decimal types
    If type_id is equal to 40:
        Return 1
    End If
    If type_id is equal to 41:
        Return 1
    End If

    Return 0
End Process

Process called "validate_arithmetic_binary_op" takes left_type as Integer, right_type as Integer returns Integer:
    Note: Validate operand types for binary arithmetic operations
    Note: Both operands must be numeric types
    Note: Returns 1 if valid, 0 if invalid

    Let left_valid be proc is_valid_arithmetic_operand_type with left_type
    If left_valid is equal to 0:
        Return 0
    End If

    Let right_valid be proc is_valid_arithmetic_operand_type with right_type
    If right_valid is equal to 0:
        Return 0
    End If

    Return 1
End Process

Process called "validate_arithmetic_unary_op" takes operand_type as Integer returns Integer:
    Note: Validate operand type for unary arithmetic operations
    Note: Operand must be numeric type
    Note: Returns 1 if valid, 0 if invalid

    Return proc is_valid_arithmetic_operand_type with operand_type
End Process

Process called "validate_modulo_operation" takes left_type as Integer, right_type as Integer returns Integer:
    Note: Validate modulo operation
    Note: Modulo requires integer operands (not floats or decimals)
    Note: Returns 1 if valid, 0 if invalid

    Note: Check both are integers (type_id 1-25, not floats 30-35 or decimals 40-41)
    If left_type is greater than or equal to 30:
        Return 0
    End If

    If right_type is greater than or equal to 30:
        Return 0
    End If

    Return proc validate_arithmetic_binary_op with left_type, right_type
End Process

Note: ============================================================================
Note: Arithmetic Operator Result Type Determination
Note: ============================================================================

Process called "is_integer_type" takes type_id as Integer returns Integer:
    Note: Check if type is an integer type (not float or decimal)
    If type_id is less than 30:
        If type_id is greater than or equal to 1:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "is_float_type" takes type_id as Integer returns Integer:
    Note: Check if type is a floating point type
    If type_id is greater than or equal to 30:
        If type_id is less than 40:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "is_decimal_type" takes type_id as Integer returns Integer:
    Note: Check if type is a decimal type
    If type_id is greater than or equal to 40:
        If type_id is less than 50:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "get_arithmetic_result_type" takes left_type as Integer, right_type as Integer returns Integer:
    Note: Determine result type for arithmetic operation
    Note: Follows type promotion rules: decimal > float > integer
    Note: Within same category, larger type wins

    Note: If same type, return it
    If left_type is equal to right_type:
        Return left_type
    End If

    Note: Decimal promotion: decimal plus anything equals decimal
    Let left_is_decimal be proc is_decimal_type with left_type
    Let right_is_decimal be proc is_decimal_type with right_type
    If left_is_decimal is equal to 1:
        Return left_type
    End If
    If right_is_decimal is equal to 1:
        Return right_type
    End If

    Note: Float promotion: float plus integer equals float
    Let left_is_float be proc is_float_type with left_type
    Let right_is_float be proc is_float_type with right_type
    If left_is_float is equal to 1:
        If right_is_float is equal to 1:
            Note: Both floats, return larger
            If left_type is greater than right_type:
                Return left_type
            End If
            Return right_type
        End If
        Return left_type
    End If
    If right_is_float is equal to 1:
        Return right_type
    End If

    Note: Both integers, return larger type
    If left_type is greater than right_type:
        Return left_type
    End If
    Return right_type
End Process

Note: ============================================================================
Note: Constant Folding for Arithmetic Operations
Note: ============================================================================

Process called "fold_add" takes left_value as Integer, right_value as Integer returns Integer:
    Note: Constant fold addition at compile time
    Return proc add from ArithmeticCore with left_value, right_value
End Process

Process called "fold_subtract" takes left_value as Integer, right_value as Integer returns Integer:
    Note: Constant fold subtraction at compile time
    Return proc subtract from ArithmeticCore with left_value, right_value
End Process

Process called "fold_multiply" takes left_value as Integer, right_value as Integer returns Integer:
    Note: Constant fold multiplication at compile time
    Return proc multiply from ArithmeticCore with left_value, right_value
End Process

Process called "fold_divide" takes dividend as Integer, divisor as Integer returns Integer:
    Note: Constant fold division at compile time
    Note: Caller must check for division by zero before calling

    Return proc divide from ArithmeticCore with dividend, divisor
End Process

Process called "fold_modulo" takes dividend as Integer, divisor as Integer returns Integer:
    Note: Constant fold modulo at compile time
    Note: Caller must check for division by zero before calling

    Return proc modulo from ArithmeticCore with dividend, divisor
End Process

Process called "fold_negate" takes value as Integer returns Integer:
    Note: Constant fold unary negation at compile time
    Return proc negate from ArithmeticCore with value
End Process

Process called "fold_absolute" takes value as Integer returns Integer:
    Note: Constant fold absolute value at compile time
    Return proc absolute from ArithmeticCore with value
End Process

Note: ============================================================================
Note: Division by Zero Detection
Note: ============================================================================

Process called "is_division_by_zero" takes divisor as Integer, is_constant as Integer returns Integer:
    Note: Check if division or modulo is by constant zero
    Note: is_constant equals 1 means divisor is a compile-time constant
    Note: Returns 1 if division by zero, 0 otherwise

    If is_constant is equal to 0:
        Return 0
    End If

    If divisor is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "is_division_by_one" takes divisor as Integer, is_constant as Integer returns Integer:
    Note: Check if division or modulo is by constant 1 (optimization opportunity)
    Note: x divided by 1 equals x, x modulo 1 equals 0
    Note: Returns 1 if divisor is 1, 0 otherwise

    If is_constant is equal to 0:
        Return 0
    End If

    If divisor is equal to 1:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Arithmetic Identity and Zero Optimization
Note: ============================================================================

Process called "is_add_identity" takes value as Integer returns Integer:
    Note: Check if value is identity for addition (x plus 0 equals x)
    If value is equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "is_multiply_identity" takes value as Integer returns Integer:
    Note: Check if value is identity for multiplication (x multiplied by 1 equals x)
    If value is equal to 1:
        Return 1
    End If
    Return 0
End Process

Process called "is_multiply_zero" takes value as Integer returns Integer:
    Note: Check if value is annihilator for multiplication (x multiplied by 0 equals 0)
    If value is equal to 0:
        Return 1
    End If
    Return 0
End Process

Note: ============================================================================
Note: Overflow Detection
Note: ============================================================================

Process called "can_add_overflow" takes left as Integer, right as Integer, result_type as Integer returns Integer:
    Note: Check if addition might overflow for given result type
    Note: Detects signed integer overflow using sign change
    Note: Returns 1 if might overflow, 0 if safe

    Let sum be left plus right

    Note: If both positive and sum negative, overflow occurred
    If left is greater than 0:
        If right is greater than 0:
            If sum is less than 0:
                Return 1
            End If
        End If
    End If

    Note: If both negative and sum positive, overflow occurred
    If left is less than 0:
        If right is less than 0:
            If sum is greater than 0:
                Return 1
            End If
        End If
    End If

    Return 0
End Process

Process called "can_multiply_overflow" takes left as Integer, right as Integer, result_type as Integer returns Integer:
    Note: Check if multiplication might overflow
    Note: Detects overflow by dividing result back and comparing to original
    Note: Returns 1 if might overflow, 0 if safe

    Note: Multiply by 0 or 1 never overflows
    If left is equal to 0:
        Return 0
    End If
    If right is equal to 0:
        Return 0
    End If
    If left is equal to 1:
        Return 0
    End If
    If right is equal to 1:
        Return 0
    End If
    If left is equal to -1:
        Return 0
    End If
    If right is equal to -1:
        Return 0
    End If

    Note: Check overflow by dividing result back
    Let product be left multiplied by right
    Let quotient be product divided by right

    If quotient is not equal to left:
        Return 1
    End If

    Return 0
End Process
