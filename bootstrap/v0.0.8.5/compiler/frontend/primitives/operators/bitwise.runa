Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles bitwise operator validation and evaluation for the compiler.

This file performs the following tasks:
- Validate bitwise operator operands (type checking)
- Evaluate constant bitwise expressions (compile-time constant folding)
- Determine result types for bitwise operations
- Validate shift amounts and bit positions

This file is essential because of the following reasons:
- Bitwise operators require integer operands (compiler must validate types)
- Constant folding optimizes bitwise expressions at compile time
- Type rules for bitwise operations must be enforced
- Shift operations have special validation rules (shift amount must be valid)

Dependencies:
- core/bitwise_core.runa (bitwise operations for constant folding)
:End Note

Import "compiler/frontend/primitives/core/bitwise_core.runa" as BitwiseCore

Note: ============================================================================
Note: Bitwise Operator Type Validation
Note: ============================================================================

Process called "is_valid_bitwise_operand_type" takes type_name as Integer returns Integer:
    Note: Check if a type is valid for bitwise operations
    Note: Only integer types are valid for bitwise operations
    Note: Returns 1 if valid, 0 if invalid

    Note: Fundamental integer types
    If type_name is equal to 1:
        Note: Integer (64-bit)
        Return 1
    End If

    Note: Sized integer types
    If type_name is equal to 10:
        Note: Integer8
        Return 1
    End If

    If type_name is equal to 11:
        Note: Integer16
        Return 1
    End If

    If type_name is equal to 12:
        Note: Integer32
        Return 1
    End If

    If type_name is equal to 13:
        Note: Integer128
        Return 1
    End If

    If type_name is equal to 14:
        Note: Integer256
        Return 1
    End If

    If type_name is equal to 15:
        Note: Integer512
        Return 1
    End If

    Note: Unsigned integer types
    If type_name is equal to 19:
        Note: UInteger8
        Return 1
    End If

    If type_name is equal to 20:
        Note: UInteger16
        Return 1
    End If

    If type_name is equal to 21:
        Note: UInteger32
        Return 1
    End If

    If type_name is equal to 22:
        Note: UInteger64
        Return 1
    End If

    If type_name is equal to 23:
        Note: UInteger128
        Return 1
    End If

    If type_name is equal to 24:
        Note: UInteger256
        Return 1
    End If

    If type_name is equal to 25:
        Note: UInteger512
        Return 1
    End If

    Note: All other types invalid for bitwise operations
    Return 0
End Process

Process called "validate_bitwise_binary_op" takes left_type as Integer, right_type as Integer returns Integer:
    Note: Validate operand types for binary bitwise operations (&, |, ^)
    Note: Both operands must be integer types
    Note: Returns 1 if valid, 0 if invalid

    Let left_valid be proc is_valid_bitwise_operand_type with left_type
    If left_valid is equal to 0:
        Return 0
    End If

    Let right_valid be proc is_valid_bitwise_operand_type with right_type
    If right_valid is equal to 0:
        Return 0
    End If

    Return 1
End Process

Process called "validate_bitwise_unary_op" takes operand_type as Integer returns Integer:
    Note: Validate operand type for unary bitwise operation (~)
    Note: Operand must be integer type
    Note: Returns 1 if valid, 0 if invalid

    Return proc is_valid_bitwise_operand_type with operand_type
End Process

Process called "validate_shift_operation" takes value_type as Integer, shift_amount as Integer returns Integer:
    Note: Validate shift operation (<<, >>)
    Note: Value must be integer type, shift amount must be non-negative and within bounds
    Note: Returns 1 if valid, 0 if invalid

    Let type_valid be proc is_valid_bitwise_operand_type with value_type
    If type_valid is equal to 0:
        Return 0
    End If

    Note: Shift amount must be non-negative
    If shift_amount is less than 0:
        Return 0
    End If

    Note: Shift amount must be less than type bit width to avoid undefined behavior
    Note: For 64-bit integers, shift by 64+ is undefined and produces incorrect results
    Note: We reject shifts that are too large to prevent bugs
    If shift_amount is greater than or equal to 64:
        Return 0
    End If

    Return 1
End Process

Note: ============================================================================
Note: Bitwise Operator Result Type Determination
Note: ============================================================================

Process called "get_bitwise_result_type" takes left_type as Integer, right_type as Integer returns Integer:
    Note: Determine result type for binary bitwise operation
    Note: Result type is the "larger" of the two operand types
    Note: Follows integer promotion rules

    Note: If types are the same, return that type
    If left_type is equal to right_type:
        Return left_type
    End If

    Note: Integer8 promotes to anything larger
    If left_type is equal to 10:
        Return right_type
    End If
    If right_type is equal to 10:
        Return left_type
    End If

    Note: Integer16 promotes to Integer32, Integer64, Integer128, etc.
    If left_type is equal to 11:
        Return right_type
    End If
    If right_type is equal to 11:
        Return left_type
    End If

    Note: Integer32 promotes to Integer64, Integer128, etc.
    If left_type is equal to 12:
        If right_type is greater than or equal to 1:
            Return right_type
        End If
        Return left_type
    End If
    If right_type is equal to 12:
        If left_type is greater than or equal to 1:
            Return left_type
        End If
        Return right_type
    End If

    Note: Default to Integer (64-bit)
    Return 1
End Process

Note: ============================================================================
Note: Constant Folding for Bitwise Operations
Note: ============================================================================

Process called "fold_bitwise_and" takes left_value as Integer, right_value as Integer returns Integer:
    Note: Constant fold bitwise AND operation at compile time
    Return proc bitwise_and from BitwiseCore with left_value, right_value
End Process

Process called "fold_bitwise_or" takes left_value as Integer, right_value as Integer returns Integer:
    Note: Constant fold bitwise OR operation at compile time
    Return proc bitwise_or from BitwiseCore with left_value, right_value
End Process

Process called "fold_bitwise_xor" takes left_value as Integer, right_value as Integer returns Integer:
    Note: Constant fold bitwise XOR operation at compile time
    Return proc bitwise_xor from BitwiseCore with left_value, right_value
End Process

Process called "fold_bitwise_not" takes value as Integer returns Integer:
    Note: Constant fold bitwise NOT operation at compile time
    Return proc bitwise_not from BitwiseCore with value
End Process

Process called "fold_left_shift" takes value as Integer, shift_amount as Integer returns Integer:
    Note: Constant fold left shift operation at compile time
    Return proc left_shift from BitwiseCore with value, shift_amount
End Process

Process called "fold_right_shift" takes value as Integer, shift_amount as Integer returns Integer:
    Note: Constant fold arithmetic right shift at compile time
    Return proc right_shift from BitwiseCore with value, shift_amount
End Process

Process called "fold_right_shift_logical" takes value as Integer, shift_amount as Integer returns Integer:
    Note: Constant fold logical right shift at compile time
    Return proc right_shift_logical from BitwiseCore with value, shift_amount
End Process

Note: ============================================================================
Note: Bitwise Operator Optimization Helpers
Note: ============================================================================

Process called "is_power_of_two" takes value as Integer returns Integer:
    Note: Check if a value is a power of two
    Note: Used for optimizing multiplication/division to shifts
    Note: Returns 1 if power of two, 0 otherwise

    If value is less than or equal to 0:
        Return 0
    End If

    Note: Power of two has exactly one bit set
    Note: (value & (value - 1)) == 0 for powers of two
    Let temp be value minus 1
    Let result be proc bitwise_and from BitwiseCore with value, temp
    If result is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "log2_of_power_of_two" takes value as Integer returns Integer:
    Note: Get log2 of a power of two value
    Note: Used to convert multiplication by power of two to left shift
    Note: Example: value=8 returns 3 (because 2^3 = 8)
    Note: Returns -1 if not a power of two

    Let is_pot be proc is_power_of_two with value
    If is_pot is equal to 0:
        Return -1
    End If

    Note: Count trailing zeros to get the log2
    Return proc count_trailing_zeros from BitwiseCore with value
End Process

Process called "can_optimize_multiply_to_shift" takes multiplier as Integer returns Integer:
    Note: Check if multiplication by constant can be optimized to shift
    Note: Returns 1 if multiplier is power of two, 0 otherwise

    Return proc is_power_of_two with multiplier
End Process

Process called "can_optimize_divide_to_shift" takes divisor as Integer returns Integer:
    Note: Check if division by constant can be optimized to shift
    Note: Only works for unsigned division or positive divisors
    Note: Returns 1 if divisor is power of two, 0 otherwise

    Return proc is_power_of_two with divisor
End Process

Note: ============================================================================
Note: Bitwise Operator Identity and Zero Optimization
Note: ============================================================================

Process called "is_bitwise_and_identity" takes value as Integer returns Integer:
    Note: Check if value is identity for bitwise AND
    Note: x & -1 = x (all bits set)
    Note: Returns 1 if identity, 0 otherwise

    If value is equal to -1:
        Return 1
    End If

    Return 0
End Process

Process called "is_bitwise_or_identity" takes value as Integer returns Integer:
    Note: Check if value is identity for bitwise OR
    Note: x | 0 = x
    Note: Returns 1 if identity, 0 otherwise

    If value is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "is_bitwise_xor_identity" takes value as Integer returns Integer:
    Note: Check if value is identity for bitwise XOR
    Note: x ^ 0 = x
    Note: Returns 1 if identity, 0 otherwise

    If value is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "is_bitwise_and_zero" takes value as Integer returns Integer:
    Note: Check if value is annihilator for bitwise AND
    Note: x & 0 = 0 (result is always 0)
    Note: Returns 1 if annihilator, 0 otherwise

    If value is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "is_bitwise_or_all_ones" takes value as Integer returns Integer:
    Note: Check if value is annihilator for bitwise OR
    Note: x | -1 = -1 (result is always all bits set)
    Note: Returns 1 if annihilator, 0 otherwise

    If value is equal to -1:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Bit Manipulation Validation
Note: ============================================================================

Process called "validate_bit_index" takes bit_index as Integer, type_size_bits as Integer returns Integer:
    Note: Validate that bit index is within range for given type
    Note: For a 64-bit integer, valid indices are 0-63
    Note: Returns 1 if valid, 0 if invalid

    If bit_index is less than 0:
        Return 0
    End If

    If bit_index is greater than or equal to type_size_bits:
        Return 0
    End If

    Return 1
End Process

Process called "validate_bit_field" takes start_bit as Integer, bit_count as Integer, type_size_bits as Integer returns Integer:
    Note: Validate that bit field specification is within range
    Note: bit_count must be > 0 and start_bit + bit_count <= type_size_bits
    Note: Returns 1 if valid, 0 if invalid

    If bit_count is less than or equal to 0:
        Return 0
    End If

    If start_bit is less than 0:
        Return 0
    End If

    Let end_bit be start_bit plus bit_count
    If end_bit is greater than type_size_bits:
        Return 0
    End If

    Return 1
End Process
