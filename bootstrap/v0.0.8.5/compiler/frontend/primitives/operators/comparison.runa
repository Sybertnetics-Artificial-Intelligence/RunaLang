Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles comparison operator validation and evaluation for the compiler.

This file performs the following tasks:
- Validate comparison operator operands (type checking)
- Evaluate constant comparison expressions (compile-time constant folding)
- Determine result types for comparison operations
- Validate type compatibility for comparisons

This file is essential because of the following reasons:
- Comparison operators require compatible operands (compiler must validate)
- Constant folding optimizes comparisons at compile time
- Type rules for comparisons must be enforced
- Comparisons always return boolean values

Dependencies:
- core/comparison_core.runa (comparison operations for constant folding)
:End Note

Import "compiler/frontend/primitives/core/comparison_core.runa" as ComparisonCore

Note: ============================================================================
Note: Comparison Operator Type Validation
Note: ============================================================================

Process called "is_valid_comparison_operand_type" takes type_id as Integer returns Integer:
    Note: Check if a type is valid for comparison operations
    Note: Numeric types, pointers, and booleans can be compared
    Note: Returns 1 if valid, 0 if invalid

    Note: Integer types
    If type_id is equal to 1:
        Return 1
    End If
    If type_id is equal to 10:
        Return 1
    End If
    If type_id is equal to 11:
        Return 1
    End If
    If type_id is equal to 12:
        Return 1
    End If
    If type_id is equal to 13:
        Return 1
    End If
    If type_id is equal to 14:
        Return 1
    End If
    If type_id is equal to 15:
        Return 1
    End If

    Note: Unsigned integers
    If type_id is equal to 19:
        Return 1
    End If
    If type_id is equal to 20:
        Return 1
    End If
    If type_id is equal to 21:
        Return 1
    End If
    If type_id is equal to 22:
        Return 1
    End If
    If type_id is equal to 23:
        Return 1
    End If
    If type_id is equal to 24:
        Return 1
    End If
    If type_id is equal to 25:
        Return 1
    End If

    Note: Floating point types
    If type_id is equal to 30:
        Return 1
    End If
    If type_id is equal to 31:
        Return 1
    End If
    If type_id is equal to 32:
        Return 1
    End If
    If type_id is equal to 33:
        Return 1
    End If
    If type_id is equal to 34:
        Return 1
    End If
    If type_id is equal to 35:
        Return 1
    End If

    Note: Decimal types
    If type_id is equal to 40:
        Return 1
    End If
    If type_id is equal to 41:
        Return 1
    End If

    Note: Pointer type
    If type_id is equal to 2:
        Return 1
    End If

    Note: Boolean type
    If type_id is equal to 5:
        Return 1
    End If

    Return 0
End Process

Process called "validate_comparison_operands" takes left_type as Integer, right_type as Integer returns Integer:
    Note: Validate operand types for comparison operations
    Note: Both operands must be valid comparison types
    Note: Returns 1 if valid, 0 if invalid

    Let left_valid be proc is_valid_comparison_operand_type with left_type
    If left_valid is equal to 0:
        Return 0
    End If

    Let right_valid be proc is_valid_comparison_operand_type with right_type
    If right_valid is equal to 0:
        Return 0
    End If

    Return 1
End Process

Process called "validate_equality_comparison" takes left_type as Integer, right_type as Integer returns Integer:
    Note: Validate equality comparison (equals, not equals)
    Note: Any comparable types can be tested for equality
    Note: Returns 1 if valid, 0 if invalid

    Return proc validate_comparison_operands with left_type, right_type
End Process

Process called "validate_ordered_comparison" takes left_type as Integer, right_type as Integer returns Integer:
    Note: Validate ordered comparison (less than, greater than, etc)
    Note: Requires numeric types or pointers (not booleans)
    Note: Returns 1 if valid, 0 if invalid

    Let operands_valid be proc validate_comparison_operands with left_type, right_type
    If operands_valid is equal to 0:
        Return 0
    End If

    Note: Boolean cannot be used in ordered comparisons
    If left_type is equal to 5:
        Return 0
    End If
    If right_type is equal to 5:
        Return 0
    End If

    Return 1
End Process

Note: ============================================================================
Note: Comparison Result Type
Note: ============================================================================

Process called "get_comparison_result_type" returns Integer:
    Note: Get result type for comparison operations
    Note: All comparisons return boolean (type_id 5)
    Return 5
End Process

Note: ============================================================================
Note: Constant Folding for Comparison Operations
Note: ============================================================================

Process called "fold_equals" takes left_value as Integer, right_value as Integer returns Integer:
    Note: Constant fold equality comparison at compile time
    Note: Returns 1 if equal, 0 if not equal
    Return proc equals from ComparisonCore with left_value, right_value
End Process

Process called "fold_not_equals" takes left_value as Integer, right_value as Integer returns Integer:
    Note: Constant fold inequality comparison at compile time
    Note: Returns 1 if not equal, 0 if equal
    Return proc not_equals from ComparisonCore with left_value, right_value
End Process

Process called "fold_less_than" takes left_value as Integer, right_value as Integer returns Integer:
    Note: Constant fold less than comparison at compile time
    Note: Returns 1 if left less than right, 0 otherwise
    Return proc less_than from ComparisonCore with left_value, right_value
End Process

Process called "fold_less_than_or_equal" takes left_value as Integer, right_value as Integer returns Integer:
    Note: Constant fold less than or equal comparison at compile time
    Note: Returns 1 if left less than or equal to right, 0 otherwise
    Return proc less_or_equal from ComparisonCore with left_value, right_value
End Process

Process called "fold_greater_than" takes left_value as Integer, right_value as Integer returns Integer:
    Note: Constant fold greater than comparison at compile time
    Note: Returns 1 if left greater than right, 0 otherwise
    Return proc greater_than from ComparisonCore with left_value, right_value
End Process

Process called "fold_greater_than_or_equal" takes left_value as Integer, right_value as Integer returns Integer:
    Note: Constant fold greater than or equal comparison at compile time
    Note: Returns 1 if left greater than or equal to right, 0 otherwise
    Return proc greater_or_equal from ComparisonCore with left_value, right_value
End Process

Note: ============================================================================
Note: Comparison Optimization Helpers
Note: ============================================================================

Process called "is_comparison_with_zero" takes value as Integer, is_constant as Integer returns Integer:
    Note: Check if comparison is with constant zero
    Note: Optimization: x equals 0 can use test instruction
    Note: Returns 1 if comparing with zero, 0 otherwise

    If is_constant is equal to 0:
        Return 0
    End If

    If value is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "is_comparison_with_one" takes value as Integer, is_constant as Integer returns Integer:
    Note: Check if comparison is with constant one
    Note: Optimization for boolean comparisons
    Note: Returns 1 if comparing with one, 0 otherwise

    If is_constant is equal to 0:
        Return 0
    End If

    If value is equal to 1:
        Return 1
    End If

    Return 0
End Process

Process called "is_self_comparison" takes left_id as Integer, right_id as Integer returns Integer:
    Note: Check if comparing a value to itself
    Note: Optimization: x equals x is always true
    Note: left_id and right_id are variable identifiers
    Note: Returns 1 if same variable, 0 otherwise

    If left_id is equal to right_id:
        Return 1
    End If

    Return 0
End Process

Process called "can_optimize_comparison_to_boolean" takes comparison_op as Integer, usage_context as Integer returns Integer:
    Note: Check if comparison result can be optimized to direct boolean use
    Note: Optimization: use condition flags directly instead of materializing to register
    Note: comparison_op is the comparison operator type (1=eq, 2=neq, 3=lt, 4=lte, 5=gt, 6=gte)
    Note: usage_context: 0=stored to variable, 1=used in if/while, 2=used in boolean expression
    Note: Returns 1 if can optimize, 0 otherwise

    Note: If used directly in control flow, can use flags directly
    If usage_context is equal to 1:
        Return 1
    End If

    Note: If used in boolean expression, can use flags directly
    If usage_context is equal to 2:
        Return 1
    End If

    Note: If stored to variable, must materialize the boolean value
    If usage_context is equal to 0:
        Return 0
    End If

    Note: Unknown context, cannot optimize
    Return 0
End Process

Note: ============================================================================
Note: Comparison Chain Validation
Note: ============================================================================

Process called "validate_comparison_chain" takes op1 as Integer, op2 as Integer returns Integer:
    Note: Validate chained comparisons (a less than b less than c)
    Note: Checks if operators can be chained logically
    Note: op1 and op2 are comparison operator types (1=eq, 2=neq, 3=lt, 4=lte, 5=gt, 6=gte)
    Note: Returns 1 if valid chain, 0 if invalid

    Note: Define operator types
    Let OP_EQUALS be 1
    Let OP_NOT_EQUALS be 2
    Let OP_LESS_THAN be 3
    Let OP_LESS_THAN_OR_EQUAL be 4
    Let OP_GREATER_THAN be 5
    Let OP_GREATER_THAN_OR_EQUAL be 6

    Note: Cannot chain not equals with anything (a != b != c is ambiguous)
    If op1 is equal to OP_NOT_EQUALS:
        Return 0
    End If
    If op2 is equal to OP_NOT_EQUALS:
        Return 0
    End If

    Note: Cannot chain equals with ordered comparisons (a == b < c is nonsensical)
    If op1 is equal to OP_EQUALS:
        If op2 is not equal to OP_EQUALS:
            Return 0
        End If
    End If
    If op2 is equal to OP_EQUALS:
        If op1 is not equal to OP_EQUALS:
            Return 0
        End If
    End If

    Note: Cannot chain conflicting ordered comparisons (a < b > c is invalid)
    Note: Valid chains: a < b < c, a <= b < c, a > b > c, a >= b > c
    Note: Invalid chains: a < b > c, a > b < c

    Note: Check if both are less than variants (3 or 4)
    Let op1_is_less be 0
    If op1 is equal to OP_LESS_THAN:
        Set op1_is_less to 1
    End If
    If op1 is equal to OP_LESS_THAN_OR_EQUAL:
        Set op1_is_less to 1
    End If

    Let op2_is_less be 0
    If op2 is equal to OP_LESS_THAN:
        Set op2_is_less to 1
    End If
    If op2 is equal to OP_LESS_THAN_OR_EQUAL:
        Set op2_is_less to 1
    End If

    Note: Check if both are greater than variants (5 or 6)
    Let op1_is_greater be 0
    If op1 is equal to OP_GREATER_THAN:
        Set op1_is_greater to 1
    End If
    If op1 is equal to OP_GREATER_THAN_OR_EQUAL:
        Set op1_is_greater to 1
    End If

    Let op2_is_greater be 0
    If op2 is equal to OP_GREATER_THAN:
        Set op2_is_greater to 1
    End If
    If op2 is equal to OP_GREATER_THAN_OR_EQUAL:
        Set op2_is_greater to 1
    End If

    Note: Both must go the same direction
    If op1_is_less is equal to 1:
        If op2_is_less is equal to 0:
            Return 0
        End If
    End If

    If op1_is_greater is equal to 1:
        If op2_is_greater is equal to 0:
            Return 0
        End If
    End If

    Return 1
End Process

Note: ============================================================================
Note: Special Comparison Cases
Note: ============================================================================

Process called "is_pointer_comparison" takes left_type as Integer, right_type as Integer returns Integer:
    Note: Check if comparison involves pointer types
    Note: Pointer comparisons have special semantics
    Note: Returns 1 if either operand is pointer, 0 otherwise

    If left_type is equal to 2:
        Return 1
    End If

    If right_type is equal to 2:
        Return 1
    End If

    Return 0
End Process

Process called "is_float_comparison" takes left_type as Integer, right_type as Integer returns Integer:
    Note: Check if comparison involves floating point types
    Note: Float comparisons require special handling for NaN
    Note: Returns 1 if either operand is float, 0 otherwise

    Note: Check if left is float type (30-35)
    If left_type is greater than or equal to 30:
        If left_type is less than 40:
            Return 1
        End If
    End If

    Note: Check if right is float type (30-35)
    If right_type is greater than or equal to 30:
        If right_type is less than 40:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "requires_type_promotion" takes left_type as Integer, right_type as Integer returns Integer:
    Note: Check if operands require type promotion before comparison
    Note: Different types must be promoted to common type
    Note: Returns 1 if promotion required, 0 if same type

    If left_type is equal to right_type:
        Return 0
    End If

    Return 1
End Process

Process called "get_comparison_promotion_type" takes left_type as Integer, right_type as Integer returns Integer:
    Note: Determine common type for comparison with mixed types
    Note: Follows same promotion rules as arithmetic operations
    Note: Promotes to decimal then float then larger integer

    Note: If same type, return it
    If left_type is equal to right_type:
        Return left_type
    End If

    Note: Decimal promotion
    If left_type is greater than or equal to 40:
        If left_type is less than 50:
            Return left_type
        End If
    End If
    If right_type is greater than or equal to 40:
        If right_type is less than 50:
            Return right_type
        End If
    End If

    Note: Float promotion
    If left_type is greater than or equal to 30:
        If left_type is less than 40:
            If right_type is greater than or equal to 30:
                If right_type is less than 40:
                    Note: Both floats, return larger
                    If left_type is greater than right_type:
                        Return left_type
                    End If
                    Return right_type
                End If
            End If
            Return left_type
        End If
    End If
    If right_type is greater than or equal to 30:
        If right_type is less than 40:
            Return right_type
        End If
    End If

    Note: Both integers, return larger type
    If left_type is greater than right_type:
        Return left_type
    End If
    Return right_type
End Process
