Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles logical operator validation and evaluation for the compiler.

This file performs the following tasks:
- Validate logical operator operands (type checking)
- Evaluate constant logical expressions (compile-time constant folding)
- Determine result types for logical operations
- Detect short-circuit optimization opportunities

This file is essential because of the following reasons:
- Logical operators require boolean-compatible operands (compiler must validate)
- Constant folding optimizes logical expressions at compile time
- Short-circuit evaluation can skip unnecessary computation
- Type coercion rules for logical operations must be enforced

Dependencies:
- core/logical_core.runa (logical operations for constant folding)
:End Note

Import "compiler/frontend/primitives/core/logical_core.runa" as LogicalCore

Note: ============================================================================
Note: Logical Operator Type Validation
Note: ============================================================================

Process called "is_boolean_type" takes type_id as Integer returns Integer:
    Note: Check if type is boolean
    Note: Returns 1 if boolean, 0 otherwise

    If type_id is equal to 5:
        Return 1
    End If

    Return 0
End Process

Process called "is_numeric_type" takes type_id as Integer returns Integer:
    Note: Check if type is numeric (can be coerced to boolean)
    Note: Numeric types: integers, floats, decimals
    Note: Returns 1 if numeric, 0 otherwise

    Note: Integer types (1, 10-15)
    If type_id is equal to 1:
        Return 1
    End If
    If type_id is greater than or equal to 10:
        If type_id is less than or equal to 15:
            Return 1
        End If
    End If

    Note: Unsigned integers (19-25)
    If type_id is greater than or equal to 19:
        If type_id is less than or equal to 25:
            Return 1
        End If
    End If

    Note: Floats (30-35)
    If type_id is greater than or equal to 30:
        If type_id is less than or equal to 35:
            Return 1
        End If
    End If

    Note: Decimals (40-41)
    If type_id is greater than or equal to 40:
        If type_id is less than or equal to 41:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "is_pointer_type" takes type_id as Integer returns Integer:
    Note: Check if type is pointer (can be coerced to boolean - null check)
    Note: Returns 1 if pointer, 0 otherwise

    If type_id is equal to 2:
        Return 1
    End If

    Return 0
End Process

Process called "is_valid_logical_operand_type" takes type_id as Integer returns Integer:
    Note: Check if type can be used in logical operations
    Note: Boolean, numeric, and pointer types are valid
    Note: Returns 1 if valid, 0 otherwise

    Let is_bool be proc is_boolean_type with type_id
    If is_bool is equal to 1:
        Return 1
    End If

    Let is_num be proc is_numeric_type with type_id
    If is_num is equal to 1:
        Return 1
    End If

    Let is_ptr be proc is_pointer_type with type_id
    If is_ptr is equal to 1:
        Return 1
    End If

    Return 0
End Process

Process called "validate_logical_binary_op" takes left_type as Integer, right_type as Integer returns Integer:
    Note: Validate operand types for binary logical operations (and, or)
    Note: Both operands must be convertible to boolean
    Note: Returns 1 if valid, 0 if invalid

    Let left_valid be proc is_valid_logical_operand_type with left_type
    If left_valid is equal to 0:
        Return 0
    End If

    Let right_valid be proc is_valid_logical_operand_type with right_type
    If right_valid is equal to 0:
        Return 0
    End If

    Return 1
End Process

Process called "validate_logical_unary_op" takes operand_type as Integer returns Integer:
    Note: Validate operand type for logical NOT operation
    Note: Operand must be convertible to boolean
    Note: Returns 1 if valid, 0 if invalid

    Return proc is_valid_logical_operand_type with operand_type
End Process

Note: ============================================================================
Note: Logical Result Type
Note: ============================================================================

Process called "get_logical_result_type" returns Integer:
    Note: Get result type for logical operations
    Note: All logical operations return boolean (type_id 5)
    Return 5
End Process

Note: ============================================================================
Note: Constant Folding for Logical Operations
Note: ============================================================================

Process called "fold_logical_and" takes left_value as Integer, right_value as Integer returns Integer:
    Note: Constant fold logical AND at compile time
    Note: Returns 1 if both true, 0 otherwise
    Return proc logical_and from LogicalCore with left_value, right_value
End Process

Process called "fold_logical_or" takes left_value as Integer, right_value as Integer returns Integer:
    Note: Constant fold logical OR at compile time
    Note: Returns 1 if either true, 0 otherwise
    Return proc logical_or from LogicalCore with left_value, right_value
End Process

Process called "fold_logical_not" takes value as Integer returns Integer:
    Note: Constant fold logical NOT at compile time
    Note: Returns 1 if false, 0 if true
    Return proc logical_not from LogicalCore with value
End Process

Note: ============================================================================
Note: Short-Circuit Evaluation Detection
Note: ============================================================================

Process called "can_short_circuit_and" takes left_value as Integer, is_constant as Integer returns Integer:
    Note: Check if AND expression can short-circuit
    Note: If left is constant false, entire expression is false
    Note: is_constant equals 1 means left operand is compile-time constant
    Note: Returns 1 if can short-circuit, 0 otherwise

    If is_constant is equal to 0:
        Return 0
    End If

    If left_value is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "can_short_circuit_or" takes left_value as Integer, is_constant as Integer returns Integer:
    Note: Check if OR expression can short-circuit
    Note: If left is constant true, entire expression is true
    Note: is_constant equals 1 means left operand is compile-time constant
    Note: Returns 1 if can short-circuit, 0 otherwise

    If is_constant is equal to 0:
        Return 0
    End If

    If left_value is not equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "requires_right_evaluation" takes operator as Integer, left_value as Integer, is_constant as Integer returns Integer:
    Note: Determine if right operand needs evaluation for short-circuit
    Note: operator: 1=AND, 2=OR
    Note: Returns 0 if can skip right operand, 1 if must evaluate
    Note: Returns 1 if left is not constant (runtime decision)

    If is_constant is equal to 0:
        Return 1
    End If

    Note: For AND, skip right if left is false
    If operator is equal to 1:
        If left_value is equal to 0:
            Return 0
        End If
        Return 1
    End If

    Note: For OR, skip right if left is true
    If operator is equal to 2:
        If left_value is not equal to 0:
            Return 0
        End If
        Return 1
    End If

    Note: Unknown operator, must evaluate
    Return 1
End Process

Note: ============================================================================
Note: Logical Identity Optimization
Note: ============================================================================

Process called "is_logical_and_identity" takes value as Integer returns Integer:
    Note: Check if value is identity for AND (true AND x equals x)
    Note: Returns 1 if identity, 0 otherwise

    If value is not equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "is_logical_or_identity" takes value as Integer returns Integer:
    Note: Check if value is identity for OR (false OR x equals x)
    Note: Returns 1 if identity, 0 otherwise

    If value is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "is_logical_and_annihilator" takes value as Integer returns Integer:
    Note: Check if value is annihilator for AND (false AND x equals false)
    Note: Returns 1 if annihilator, 0 otherwise

    If value is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "is_logical_or_annihilator" takes value as Integer returns Integer:
    Note: Check if value is annihilator for OR (true OR x equals true)
    Note: Returns 1 if annihilator, 0 otherwise

    If value is not equal to 0:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Boolean Coercion
Note: ============================================================================

Process called "coerce_to_boolean" takes value as Integer, type_id as Integer returns Integer:
    Note: Convert value to boolean based on type
    Note: Numeric: 0 is false, non-zero is true
    Note: Pointer: null (0) is false, non-null is true
    Note: Boolean: pass through
    Note: Returns 1 for true, 0 for false

    Note: Boolean type - pass through
    Let is_bool be proc is_boolean_type with type_id
    If is_bool is equal to 1:
        If value is equal to 0:
            Return 0
        End If
        Return 1
    End If

    Note: Numeric types - zero is false, non-zero is true
    Let is_num be proc is_numeric_type with type_id
    If is_num is equal to 1:
        If value is equal to 0:
            Return 0
        End If
        Return 1
    End If

    Note: Pointer type - null is false, non-null is true
    Let is_ptr be proc is_pointer_type with type_id
    If is_ptr is equal to 1:
        If value is equal to 0:
            Return 0
        End If
        Return 1
    End If

    Note: Invalid type - return false
    Return 0
End Process

Process called "requires_boolean_coercion" takes type_id as Integer returns Integer:
    Note: Check if type requires explicit coercion to boolean
    Note: Boolean types do not require coercion
    Note: All other valid types require coercion
    Note: Returns 1 if coercion needed, 0 otherwise

    Let is_bool be proc is_boolean_type with type_id
    If is_bool is equal to 1:
        Return 0
    End If

    Let is_valid be proc is_valid_logical_operand_type with type_id
    If is_valid is equal to 1:
        Return 1
    End If

    Note: Invalid type
    Return 0
End Process

Note: ============================================================================
Note: Logical Expression Complexity Analysis
Note: ============================================================================

Process called "is_complex_logical_expression" takes operator_count as Integer, operand_count as Integer returns Integer:
    Note: Determine if logical expression is complex
    Note: Complex expressions may benefit from different optimization strategies
    Note: Returns 1 if complex, 0 if simple

    Note: More than 3 operators is complex
    If operator_count is greater than 3:
        Return 1
    End If

    Note: More than 4 operands is complex
    If operand_count is greater than 4:
        Return 1
    End If

    Return 0
End Process

Process called "can_optimize_to_single_test" takes operator as Integer, operand_count as Integer returns Integer:
    Note: Check if logical expression can be optimized to single condition test
    Note: operator: 1=AND, 2=OR, 3=NOT
    Note: NOT with single operand can be optimized
    Note: Returns 1 if can optimize, 0 otherwise

    Note: NOT with single operand is already optimized
    If operator is equal to 3:
        If operand_count is equal to 1:
            Return 1
        End If
    End If

    Note: AND/OR with 2 operands may be optimizable depending on context
    If operator is equal to 1:
        If operand_count is equal to 2:
            Return 1
        End If
    End If

    If operator is equal to 2:
        If operand_count is equal to 2:
            Return 1
        End If
    End If

    Return 0
End Process

Note: ============================================================================
Note: De Morgan's Law Transformations
Note: ============================================================================

Process called "can_apply_demorgan" takes operator as Integer, has_negation as Integer returns Integer:
    Note: Check if De Morgan's law can be applied for optimization
    Note: NOT (a AND b) equals (NOT a) OR (NOT b)
    Note: NOT (a OR b) equals (NOT a) AND (NOT b)
    Note: operator: 1=AND, 2=OR
    Note: has_negation: 1 if expression is negated, 0 otherwise
    Note: Returns 1 if transformation beneficial, 0 otherwise

    If has_negation is equal to 0:
        Return 0
    End If

    Note: Can apply De Morgan's if AND or OR is negated
    If operator is equal to 1:
        Return 1
    End If

    If operator is equal to 2:
        Return 1
    End If

    Return 0
End Process

Process called "get_demorgan_operator" takes original_operator as Integer returns Integer:
    Note: Get the opposite operator for De Morgan's transformation
    Note: AND becomes OR, OR becomes AND
    Note: original_operator: 1=AND, 2=OR
    Note: Returns opposite operator

    If original_operator is equal to 1:
        Return 2
    End If

    If original_operator is equal to 2:
        Return 1
    End If

    Note: Invalid operator, return same
    Return original_operator
End Process

Note: ============================================================================
Note: Double Negation Elimination
Note: ============================================================================

Process called "has_double_negation" takes negation_count as Integer returns Integer:
    Note: Check if expression has double negation (NOT NOT x)
    Note: Double negation can be eliminated (NOT NOT x equals x)
    Note: Returns 1 if has even number of negations (can eliminate), 0 otherwise

    Let remainder be negation_count modulo by 2
    If remainder is equal to 0:
        If negation_count is greater than 0:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "get_effective_negation" takes negation_count as Integer returns Integer:
    Note: Calculate effective negation after eliminating double negations
    Note: Even count eliminates to no negation (0)
    Note: Odd count results in single negation (1)
    Note: Returns 0 or 1

    Let remainder be negation_count modulo by 2
    Return remainder
End Process
