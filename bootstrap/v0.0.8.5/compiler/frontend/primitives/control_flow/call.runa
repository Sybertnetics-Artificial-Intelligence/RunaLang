Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles function call validation and call site analysis for the compiler.

This file performs the following tasks:
- Validate function call arguments against signatures
- Check calling conventions and parameter passing rules
- Analyze call sites for optimization opportunities
- Validate return value handling

This file is essential because of the following reasons:
- Function calls must match signatures (argument count and types)
- Calling conventions determine parameter passing mechanism
- Tail call optimization requires specific patterns
- Inline expansion requires cost-benefit analysis

Dependencies:
- core/stack_core.runa (stack operations for call frames)
:End Note

Import "compiler/frontend/primitives/core/stack_core.runa" as StackCore

Note: ============================================================================
Note: Function Signature Validation
Note: ============================================================================

Process called "validate_argument_count" takes expected_count as Integer, actual_count as Integer returns Integer:
    Note: Validate that call has correct number of arguments
    Note: Returns 1 if count matches, 0 if mismatch

    If expected_count is equal to actual_count:
        Return 1
    End If

    Return 0
End Process

Process called "validate_argument_type" takes expected_type as Integer, actual_type as Integer, position as Integer returns Integer:
    Note: Validate that argument type matches parameter type
    Note: position is argument index (for error reporting)
    Note: Returns 1 if types match or are compatible, 0 if incompatible

    Note: Exact type match
    If expected_type is equal to actual_type:
        Return 1
    End If

    Note: Check for compatible numeric types (widening conversions)
    Let expected_is_numeric be proc is_numeric_type with expected_type
    Let actual_is_numeric be proc is_numeric_type with actual_type

    If expected_is_numeric is equal to 1:
        If actual_is_numeric is equal to 1:
            Note: Both numeric, check if actual can widen to expected
            Let can_widen be proc can_widen_numeric with actual_type, expected_type
            Return can_widen
        End If
    End If

    Note: Check for pointer compatibility
    Let expected_is_pointer be proc is_pointer_type with expected_type
    Let actual_is_pointer be proc is_pointer_type with actual_type

    If expected_is_pointer is equal to 1:
        If actual_is_pointer is equal to 1:
            Return 1
        End If
        Note: Null literal (0) can be passed to pointer
        If actual_type is equal to 1:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "is_numeric_type" takes type_id as Integer returns Integer:
    Note: Check if type is numeric
    Note: Returns 1 if numeric, 0 otherwise

    Note: Integers (1, 10-15)
    If type_id is equal to 1:
        Return 1
    End If
    If type_id is greater than or equal to 10:
        If type_id is less than or equal to 15:
            Return 1
        End If
    End If

    Note: Unsigned integers (19-25)
    If type_id is greater than or equal to 19:
        If type_id is less than or equal to 25:
            Return 1
        End If
    End If

    Note: Floats (30-35)
    If type_id is greater than or equal to 30:
        If type_id is less than or equal to 35:
            Return 1
        End If
    End If

    Note: Decimals (40-41)
    If type_id is greater than or equal to 40:
        If type_id is less than or equal to 41:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "is_pointer_type" takes type_id as Integer returns Integer:
    Note: Check if type is pointer
    Note: Returns 1 if pointer, 0 otherwise

    If type_id is equal to 2:
        Return 1
    End If

    Return 0
End Process

Process called "can_widen_numeric" takes from_type as Integer, to_type as Integer returns Integer:
    Note: Check if numeric type can be widened safely
    Note: Widening: smaller type to larger type (no data loss)
    Note: Returns 1 if can widen, 0 if cannot

    Note: Integer8 (10) can widen to any larger integer
    If from_type is equal to 10:
        If to_type is greater than or equal to 11:
            If to_type is less than or equal to 15:
                Return 1
            End If
        End If
        If to_type is equal to 1:
            Return 1
        End If
    End If

    Note: Integer16 (11) can widen to 32, 64, 128, 256, 512
    If from_type is equal to 11:
        If to_type is greater than or equal to 12:
            If to_type is less than or equal to 15:
                Return 1
            End If
        End If
        If to_type is equal to 1:
            Return 1
        End If
    End If

    Note: Integer32 (12) can widen to 64, 128, 256, 512
    If from_type is equal to 12:
        If to_type is greater than or equal to 13:
            If to_type is less than or equal to 15:
                Return 1
            End If
        End If
        If to_type is equal to 1:
            Return 1
        End If
    End If

    Note: Integer (1) is 64-bit, can widen to 128, 256, 512
    If from_type is equal to 1:
        If to_type is greater than or equal to 13:
            If to_type is less than or equal to 15:
                Return 1
            End If
        End If
    End If

    Note: Integer types can widen to floats
    If to_type is greater than or equal to 30:
        If to_type is less than or equal to 35:
            Return 1
        End If
    End If

    Note: Floats can widen to larger floats
    If from_type is greater than or equal to 30:
        If from_type is less than or equal to 35:
            If to_type is greater than from_type:
                If to_type is less than or equal to 35:
                    Return 1
                End If
            End If
        End If
    End If

    Return 0
End Process

Note: ============================================================================
Note: Calling Convention Analysis
Note: ============================================================================

Process called "get_calling_convention" takes function_id as Integer returns Integer:
    Note: Determine calling convention for function
    Note: Returns convention ID: 1=cdecl, 2=stdcall, 3=fastcall, 4=runa_native
    Note: All Runa-defined functions use runa_native calling convention
    Note: External C functions may use cdecl/stdcall/fastcall (determined by function metadata)
    Note: function_id encodes convention in high bits if external, otherwise defaults to runa_native

    Note: Check if function is external (bit 31 set in function_id)
    Let is_external_mask be 2147483648
    Let is_external_check be function_id bitwise and is_external_mask
    If is_external_check is not equal to 0:
        Note: External function: extract convention from bits 29-30
        Let convention_mask be 1610612736
        Let convention_bits be function_id bitwise and convention_mask
        Let convention be convention_bits shifted right by 29
        Return convention
    End If

    Note: Native Runa function: use runa_native convention (4)
    Return 4
End Process

Process called "requires_stack_cleanup" takes convention as Integer, is_caller as Integer returns Integer:
    Note: Check if stack cleanup is required after call
    Note: convention: calling convention ID
    Note: is_caller: 1 if checking from caller side, 0 if callee side
    Note: Returns 1 if cleanup required, 0 if not

    Note: cdecl (1): caller cleans up
    If convention is equal to 1:
        If is_caller is equal to 1:
            Return 1
        End If
        Return 0
    End If

    Note: stdcall (2): callee cleans up
    If convention is equal to 2:
        If is_caller is equal to 0:
            Return 1
        End If
        Return 0
    End If

    Note: fastcall (3): callee cleans up
    If convention is equal to 3:
        If is_caller is equal to 0:
            Return 1
        End If
        Return 0
    End If

    Note: runa_native (4): callee cleans up
    If convention is equal to 4:
        If is_caller is equal to 0:
            Return 1
        End If
        Return 0
    End If

    Return 0
End Process

Process called "get_parameter_passing_location" takes param_index as Integer, param_type as Integer, convention as Integer returns Integer:
    Note: Determine where parameter is passed (register or stack)
    Note: Returns: 0=stack, 1=register1, 2=register2, 3=register3, 4=register4, 5=register5, 6=register6
    Note: Based on System V AMD64 ABI (first 6 integer args in registers)

    Note: For runa_native convention (4)
    If convention is equal to 4:
        Note: First 6 integer parameters in registers
        Let is_int be proc is_numeric_type with param_type
        If is_int is equal to 1:
            If param_index is less than 6:
                Return param_index plus 1
            End If
        End If
        Note: Rest on stack
        Return 0
    End If

    Note: Other conventions default to stack
    Return 0
End Process

Note: ============================================================================
Note: Return Value Validation
Note: ============================================================================

Process called "validate_return_value" takes expected_type as Integer, actual_type as Integer returns Integer:
    Note: Validate that return value type matches function signature
    Note: Returns 1 if types match or are compatible, 0 if incompatible

    Note: Exact type match
    If expected_type is equal to actual_type:
        Return 1
    End If

    Note: Void return type must match exactly
    If expected_type is equal to 3:
        Return 0
    End If
    If actual_type is equal to 3:
        Return 0
    End If

    Note: Check numeric compatibility
    Let expected_is_numeric be proc is_numeric_type with expected_type
    Let actual_is_numeric be proc is_numeric_type with actual_type

    If expected_is_numeric is equal to 1:
        If actual_is_numeric is equal to 1:
            Let can_widen be proc can_widen_numeric with actual_type, expected_type
            Return can_widen
        End If
    End If

    Return 0
End Process

Process called "has_return_value" takes return_type as Integer returns Integer:
    Note: Check if function returns a value
    Note: Void functions do not return values
    Note: Returns 1 if has return value, 0 if void

    If return_type is equal to 3:
        Return 0
    End If

    Return 1
End Process

Process called "requires_return_register" takes return_type as Integer returns Integer:
    Note: Check if return value is passed in register
    Note: Small values (integers, pointers) use register
    Note: Large values (structs) may use memory
    Note: Returns 1 if uses register, 0 if uses memory

    Note: Void has no return
    If return_type is equal to 3:
        Return 0
    End If

    Note: Integers and pointers use register
    Let is_numeric be proc is_numeric_type with return_type
    If is_numeric is equal to 1:
        Return 1
    End If

    Let is_pointer be proc is_pointer_type with return_type
    If is_pointer is equal to 1:
        Return 1
    End If

    Note: Boolean uses register
    If return_type is equal to 5:
        Return 1
    End If

    Note: Assume other types use memory
    Return 0
End Process

Note: ============================================================================
Note: Call Site Optimization Analysis
Note: ============================================================================

Process called "is_tail_call" takes is_last_statement as Integer, no_local_refs as Integer, return_matches as Integer returns Integer:
    Note: Check if call is eligible for tail call optimization
    Note: is_last_statement: 1 if call is last statement before return
    Note: no_local_refs: 1 if no references to local variables after call
    Note: return_matches: 1 if return value used directly in return
    Note: Returns 1 if tail call, 0 if not

    If is_last_statement is equal to 0:
        Return 0
    End If

    If no_local_refs is equal to 0:
        Return 0
    End If

    If return_matches is equal to 0:
        Return 0
    End If

    Return 1
End Process

Process called "can_inline" takes callee_size as Integer, call_frequency as Integer, recursion_depth as Integer returns Integer:
    Note: Determine if function call should be inlined
    Note: callee_size: size of callee function in instructions
    Note: call_frequency: how often function is called (higher = more benefit)
    Note: recursion_depth: 0 if not recursive, >0 if recursive
    Note: Returns 1 if should inline, 0 if should not

    Note: Never inline recursive functions
    If recursion_depth is greater than 0:
        Return 0
    End If

    Note: Always inline very small functions (less than 5 instructions)
    If callee_size is less than 5:
        Return 1
    End If

    Note: Inline small functions if called frequently
    If callee_size is less than 20:
        If call_frequency is greater than 10:
            Return 1
        End If
    End If

    Note: Do not inline large functions
    If callee_size is greater than 50:
        Return 0
    End If

    Note: Medium functions only if very frequently called
    If call_frequency is greater than 100:
        Return 1
    End If

    Return 0
End Process

Process called "get_inline_cost" takes callee_size as Integer, call_overhead as Integer returns Integer:
    Note: Calculate cost of inlining vs calling
    Note: callee_size: size of function body in instructions
    Note: call_overhead: cost of call instruction, parameter setup, return
    Note: Returns net cost (negative means inlining saves cost)

    Note: Call overhead is typically 4-6 instructions
    Note: Inlining cost is size of function body
    Note: Net cost is body size minus call overhead
    Let net_cost be callee_size minus call_overhead
    Return net_cost
End Process

Process called "has_side_effects" takes modifies_global as Integer, performs_io as Integer, throws_exception as Integer returns Integer:
    Note: Check if function has observable side effects
    Note: modifies_global: 1 if modifies global state
    Note: performs_io: 1 if performs I/O operations
    Note: throws_exception: 1 if can throw exceptions
    Note: Returns 1 if has side effects, 0 if pure

    If modifies_global is equal to 1:
        Return 1
    End If

    If performs_io is equal to 1:
        Return 1
    End If

    If throws_exception is equal to 1:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Call Frame Analysis
Note: ============================================================================

Process called "calculate_frame_size" takes local_vars_size as Integer, spilled_regs_size as Integer, alignment as Integer returns Integer:
    Note: Calculate total size of call frame
    Note: local_vars_size: size of local variables in bytes
    Note: spilled_regs_size: size of saved registers in bytes
    Note: alignment: required alignment (typically 16 bytes)
    Note: Returns total frame size aligned to alignment boundary

    Let total_size be local_vars_size plus spilled_regs_size

    Note: Align to alignment boundary
    Let remainder be total_size Modulo by alignment
    If remainder is not equal to 0:
        Let padding be alignment minus remainder
        Set total_size to total_size plus padding
    End If

    Return total_size
End Process

Process called "requires_frame_pointer" takes has_dynamic_alloc as Integer, has_variable_args as Integer, frame_size_large as Integer returns Integer:
    Note: Check if function requires frame pointer
    Note: has_dynamic_alloc: 1 if uses alloca or VLA
    Note: has_variable_args: 1 if has variadic parameters
    Note: frame_size_large: 1 if frame is very large
    Note: Returns 1 if frame pointer needed, 0 if can use stack pointer only

    If has_dynamic_alloc is equal to 1:
        Return 1
    End If

    If has_variable_args is equal to 1:
        Return 1
    End If

    If frame_size_large is equal to 1:
        Return 1
    End If

    Return 0
End Process

Process called "get_saved_registers_count" takes uses_callee_saved as Integer, is_leaf_function as Integer returns Integer:
    Note: Determine how many registers need to be saved
    Note: uses_callee_saved: bitfield of which callee-saved registers are used
    Note: is_leaf_function: 1 if function makes no calls (leaf)
    Note: Returns count of registers to save

    Note: Leaf functions that don't call others need fewer saves
    If is_leaf_function is equal to 1:
        Note: Only save registers we actually modify
        Return proc count_set_bits with uses_callee_saved
    End If

    Note: Non-leaf functions must save all callee-saved regs they use
    Return proc count_set_bits with uses_callee_saved
End Process

Process called "count_set_bits" takes value as Integer returns Integer:
    Note: Count number of 1 bits in integer (population count)
    Note: Used for counting which registers need saving
    Note: Returns count of set bits

    Let count be 0
    Let temp be value

    While temp is greater than 0:
        Let bit be temp bitwise and 1
        Set count to count plus bit
        Set temp to temp shifted right by 1
    End While

    Return count
End Process

Note: ============================================================================
Note: Variadic Function Handling
Note: ============================================================================

Process called "is_variadic_function" takes has_varargs_marker as Integer returns Integer:
    Note: Check if function accepts variable number of arguments
    Note: has_varargs_marker: 1 if signature has ... marker
    Note: Returns 1 if variadic, 0 if fixed

    If has_varargs_marker is equal to 1:
        Return 1
    End If

    Return 0
End Process

Process called "validate_variadic_call" takes fixed_param_count as Integer, actual_arg_count as Integer returns Integer:
    Note: Validate call to variadic function
    Note: fixed_param_count: number of required parameters before ...
    Note: actual_arg_count: total arguments provided
    Note: Returns 1 if valid, 0 if invalid

    Note: Must have at least the fixed parameters
    If actual_arg_count is less than fixed_param_count:
        Return 0
    End If

    Return 1
End Process

Process called "get_varargs_start_index" takes fixed_param_count as Integer returns Integer:
    Note: Get index where variable arguments start
    Note: fixed_param_count: number of fixed parameters
    Note: Returns index of first variadic argument

    Return fixed_param_count
End Process
