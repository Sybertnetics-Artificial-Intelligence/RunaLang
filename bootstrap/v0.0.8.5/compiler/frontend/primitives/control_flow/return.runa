Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles return statement validation and optimization for the compiler.

This file performs the following tasks:
- Validate return statements and return value types
- Analyze return value handling and register usage
- Detect missing returns and unreachable code
- Optimize tail calls and return value materialization

This file is essential because of the following reasons:
- Return statements must match function signature
- Return value types must be compatible
- All code paths must return in non-void functions
- Return optimization reduces function call overhead

Dependencies:
- NONE (pure analysis and validation)
:End Note

Note: ============================================================================
Note: Return Statement Validation
Note: ============================================================================

Process called "validate_return_statement" takes has_value as Integer, return_type as Integer, function_return_type as Integer returns Integer:
    Note: Validate return statement
    Note: has_value: 1 if return has value, 0 if bare return
    Note: return_type: type ID of returned value
    Note: function_return_type: expected return type from function signature
    Note: Returns 1 if valid, 0 if invalid

    Note: Void functions must not return value
    If function_return_type is equal to 3:
        If has_value is equal to 1:
            Return 0
        End If
        Return 1
    End If

    Note: Non-void functions must return value
    If has_value is equal to 0:
        Return 0
    End If

    Note: Check type compatibility
    If return_type is equal to function_return_type:
        Return 1
    End If

    Note: Check if types are compatible (numeric widening, etc)
    Let compatible be proc types_compatible with return_type, function_return_type
    Return compatible
End Process

Process called "types_compatible" takes actual_type as Integer, expected_type as Integer returns Integer:
    Note: Check if actual type can be used where expected type is required
    Note: Returns 1 if compatible, 0 if incompatible

    Note: Exact match
    If actual_type is equal to expected_type:
        Return 1
    End If

    Note: Check numeric compatibility
    Let actual_is_numeric be proc is_numeric_type with actual_type
    Let expected_is_numeric be proc is_numeric_type with expected_type

    If actual_is_numeric is equal to 1:
        If expected_is_numeric is equal to 1:
            Let can_widen be proc can_widen_numeric with actual_type, expected_type
            Return can_widen
        End If
    End If

    Note: Pointer compatibility
    If actual_type is equal to 2:
        If expected_type is equal to 2:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "is_numeric_type" takes type_id as Integer returns Integer:
    Note: Check if type is numeric
    Note: Returns 1 if numeric, 0 otherwise

    Note: Integer (1)
    If type_id is equal to 1:
        Return 1
    End If

    Note: Sized integers (10-15)
    If type_id is greater than or equal to 10:
        If type_id is less than or equal to 15:
            Return 1
        End If
    End If

    Note: Unsigned integers (19-25)
    If type_id is greater than or equal to 19:
        If type_id is less than or equal to 25:
            Return 1
        End If
    End If

    Note: Floats (30-35)
    If type_id is greater than or equal to 30:
        If type_id is less than or equal to 35:
            Return 1
        End If
    End If

    Note: Decimals (40-41)
    If type_id is greater than or equal to 40:
        If type_id is less than or equal to 41:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "can_widen_numeric" takes from_type as Integer, to_type as Integer returns Integer:
    Note: Check if numeric type can be widened
    Note: Returns 1 if can widen, 0 if cannot

    Note: Integer8 (10) can widen to larger integers
    If from_type is equal to 10:
        If to_type is greater than or equal to 11:
            If to_type is less than or equal to 15:
                Return 1
            End If
        End If
        If to_type is equal to 1:
            Return 1
        End If
    End If

    Note: Integer16 (11) can widen to 32, 64, 128, 256, 512
    If from_type is equal to 11:
        If to_type is greater than or equal to 12:
            If to_type is less than or equal to 15:
                Return 1
            End If
        End If
        If to_type is equal to 1:
            Return 1
        End If
    End If

    Note: Integer32 (12) can widen to 64, 128, 256, 512
    If from_type is equal to 12:
        If to_type is greater than or equal to 13:
            If to_type is less than or equal to 15:
                Return 1
            End If
        End If
        If to_type is equal to 1:
            Return 1
        End If
    End If

    Note: Integer (1, 64-bit) can widen to 128, 256, 512
    If from_type is equal to 1:
        If to_type is greater than or equal to 13:
            If to_type is less than or equal to 15:
                Return 1
            End If
        End If
    End If

    Note: Integer types can widen to floats
    If to_type is greater than or equal to 30:
        If to_type is less than or equal to 35:
            Return 1
        End If
    End If

    Note: Floats can widen to larger floats
    If from_type is greater than or equal to 30:
        If from_type is less than or equal to 35:
            If to_type is greater than from_type:
                If to_type is less than or equal to 35:
                    Return 1
                End If
            End If
        End If
    End If

    Return 0
End Process

Note: ============================================================================
Note: Return Value Analysis
Note: ============================================================================

Process called "requires_return_register" takes return_type as Integer returns Integer:
    Note: Check if return value is passed in register
    Note: Small values (integers, pointers, booleans) use register
    Note: Large values (structs >16 bytes) may use memory
    Note: Returns 1 if uses register, 0 if uses memory

    Note: Void has no return value
    If return_type is equal to 3:
        Return 0
    End If

    Note: Integers use register
    Let is_numeric be proc is_numeric_type with return_type
    If is_numeric is equal to 1:
        Return 1
    End If

    Note: Pointers use register
    If return_type is equal to 2:
        Return 1
    End If

    Note: Booleans use register
    If return_type is equal to 5:
        Return 1
    End If

    Note: Other types use memory
    Return 0
End Process

Process called "get_return_register" takes return_type as Integer returns Integer:
    Note: Determine which register holds return value
    Note: Returns register ID: 1=RAX (integers, pointers), 2=XMM0 (floats), 0=memory

    Note: Void has no return register
    If return_type is equal to 3:
        Return 0
    End If

    Note: Integers and pointers use RAX
    If return_type is equal to 1:
        Return 1
    End If
    If return_type is equal to 2:
        Return 1
    End If
    If return_type is equal to 5:
        Return 1
    End If

    Note: Sized integers use RAX
    If return_type is greater than or equal to 10:
        If return_type is less than or equal to 15:
            Return 1
        End If
    End If

    Note: Unsigned integers use RAX
    If return_type is greater than or equal to 19:
        If return_type is less than or equal to 25:
            Return 1
        End If
    End If

    Note: Floats use XMM0
    If return_type is greater than or equal to 30:
        If return_type is less than or equal to 35:
            Return 2
        End If
    End If

    Note: Decimals use XMM0
    If return_type is greater than or equal to 40:
        If return_type is less than or equal to 41:
            Return 2
        End If
    End If

    Note: Other types use memory
    Return 0
End Process

Process called "requires_conversion" takes expression_type as Integer, return_type as Integer returns Integer:
    Note: Check if return value needs type conversion
    Note: expression_type: type of expression being returned
    Note: return_type: expected return type
    Note: Returns 1 if conversion needed, 0 if direct return

    Note: Exact match needs no conversion
    If expression_type is equal to return_type:
        Return 0
    End If

    Note: Compatible types need conversion
    Let compatible be proc types_compatible with expression_type, return_type
    If compatible is equal to 1:
        Return 1
    End If

    Note: Incompatible types (validation error)
    Return 0
End Process

Note: ============================================================================
Note: Control Flow Analysis
Note: ============================================================================

Process called "all_paths_return" takes has_direct_return as Integer, has_if_all_branches_return as Integer, has_switch_all_cases_return as Integer returns Integer:
    Note: Check if all code paths in function return
    Note: has_direct_return: 1 if block has direct return statement
    Note: has_if_all_branches_return: 1 if all if-else branches return
    Note: has_switch_all_cases_return: 1 if all switch cases return
    Note: Returns 1 if all paths return, 0 if some path may fall through

    Note: Direct return covers all paths from this point
    If has_direct_return is equal to 1:
        Return 1
    End If

    Note: If-else with all branches returning covers all paths
    If has_if_all_branches_return is equal to 1:
        Return 1
    End If

    Note: Switch with all cases returning covers all paths
    If has_switch_all_cases_return is equal to 1:
        Return 1
    End If

    Note: Some path may fall through
    Return 0
End Process

Process called "function_missing_return" takes function_return_type as Integer, all_paths_return as Integer returns Integer:
    Note: Check if function is missing required return
    Note: function_return_type: return type from function signature
    Note: all_paths_return: 1 if all code paths return
    Note: Returns 1 if missing return, 0 if correct

    Note: Void functions do not need return
    If function_return_type is equal to 3:
        Return 0
    End If

    Note: Non-void functions must return on all paths
    If all_paths_return is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "is_unreachable_after_return" takes has_return as Integer, has_following_code as Integer returns Integer:
    Note: Check if code after return is unreachable
    Note: has_return: 1 if block has return statement
    Note: has_following_code: 1 if code follows the return
    Note: Returns 1 if unreachable code detected, 0 if correct

    Note: No return means code is reachable
    If has_return is equal to 0:
        Return 0
    End If

    Note: Code after return is unreachable
    If has_following_code is equal to 1:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Return Value Optimization
Note: ============================================================================

Process called "can_use_tail_call" takes is_last_statement as Integer, no_cleanup_needed as Integer, return_matches as Integer returns Integer:
    Note: Check if return can use tail call optimization
    Note: is_last_statement: 1 if return is last statement before function end
    Note: no_cleanup_needed: 1 if no local cleanup required
    Note: return_matches: 1 if return value matches tail call return type
    Note: Returns 1 if can tail call, 0 if normal return

    Note: Must be last statement
    If is_last_statement is equal to 0:
        Return 0
    End If

    Note: No cleanup needed (stack frame can be reused)
    If no_cleanup_needed is equal to 0:
        Return 0
    End If

    Note: Return types must match
    If return_matches is equal to 0:
        Return 0
    End If

    Return 1
End Process

Process called "can_return_constant" takes value_is_constant as Integer, constant_fits_immediate as Integer returns Integer:
    Note: Check if constant can be returned directly
    Note: value_is_constant: 1 if return value is compile-time constant
    Note: constant_fits_immediate: 1 if constant fits in immediate operand
    Note: Returns 1 if can use immediate, 0 if needs load

    Note: Value must be constant
    If value_is_constant is equal to 0:
        Return 0
    End If

    Note: Constant must fit in immediate
    If constant_fits_immediate is equal to 0:
        Return 0
    End If

    Return 1
End Process

Process called "requires_value_materialization" takes value_in_register as Integer, correct_register as Integer returns Integer:
    Note: Check if return value needs to be materialized to return register
    Note: value_in_register: 1 if value already in a register
    Note: correct_register: 1 if value in correct return register
    Note: Returns 1 if needs move, 0 if already correct

    Note: Not in register, needs load
    If value_in_register is equal to 0:
        Return 1
    End If

    Note: In wrong register, needs move
    If correct_register is equal to 0:
        Return 1
    End If

    Note: Already in correct register
    Return 0
End Process

Note: ============================================================================
Note: Return Stack Management
Note: ============================================================================

Process called "calculate_cleanup_size" takes local_vars_size as Integer, saved_regs_size as Integer returns Integer:
    Note: Calculate stack cleanup size for return
    Note: local_vars_size: size of local variables in bytes
    Note: saved_regs_size: size of saved registers in bytes
    Note: Returns total cleanup size in bytes

    Let cleanup_size be local_vars_size plus saved_regs_size
    Return cleanup_size
End Process

Process called "requires_frame_pointer_restore" takes uses_frame_pointer as Integer returns Integer:
    Note: Check if frame pointer must be restored on return
    Note: uses_frame_pointer: 1 if function uses frame pointer
    Note: Returns 1 if must restore, 0 if not used

    If uses_frame_pointer is equal to 1:
        Return 1
    End If

    Return 0
End Process

Process called "get_saved_registers_mask" takes used_callee_saved as Integer returns Integer:
    Note: Get mask of which callee-saved registers to restore
    Note: used_callee_saved: bitfield of callee-saved registers used
    Note: Returns mask of registers to restore

    Return used_callee_saved
End Process

Note: ============================================================================
Note: Multiple Return Optimization
Note: ============================================================================

Process called "has_multiple_returns" takes return_count as Integer returns Integer:
    Note: Check if function has multiple return statements
    Note: return_count: number of return statements in function
    Note: Returns 1 if multiple, 0 if single

    If return_count is greater than 1:
        Return 1
    End If

    Return 0
End Process

Process called "can_unify_returns" takes returns_same_type as Integer, cleanup_identical as Integer returns Integer:
    Note: Check if multiple returns can be unified to single exit point
    Note: returns_same_type: 1 if all returns have same type
    Note: cleanup_identical: 1 if all returns have identical cleanup
    Note: Returns 1 if can unify, 0 if must keep separate

    Note: Must have same type to unify
    If returns_same_type is equal to 0:
        Return 0
    End If

    Note: Must have identical cleanup to unify
    If cleanup_identical is equal to 0:
        Return 0
    End If

    Return 1
End Process

Process called "should_unify_returns" takes return_count as Integer, cleanup_size as Integer returns Integer:
    Note: Determine if multiple returns should be unified
    Note: Unification benefits when cleanup is complex or returns are many
    Note: return_count: number of return statements
    Note: cleanup_size: size of cleanup code in bytes
    Note: Returns 1 if should unify, 0 if keep separate

    Note: Large cleanup benefits from unification
    If cleanup_size is greater than 20:
        Return 1
    End If

    Note: Many returns benefit from unification
    If return_count is greater than 5:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Return Value Lifetime
Note: ============================================================================

Process called "value_escapes_function" takes is_pointer as Integer, points_to_local as Integer returns Integer:
    Note: Check if return value escapes function scope
    Note: is_pointer: 1 if return value is pointer
    Note: points_to_local: 1 if pointer points to local variable
    Note: Returns 1 if escapes, 0 if error (returning pointer to local)

    Note: Non-pointers always escape safely
    If is_pointer is equal to 0:
        Return 1
    End If

    Note: Pointer to local is error (dangling pointer)
    If points_to_local is equal to 1:
        Return 0
    End If

    Note: Pointer to heap or global escapes safely
    Return 1
End Process

Process called "validate_return_lifetime" takes return_is_pointer as Integer, points_to_local as Integer returns Integer:
    Note: Validate lifetime of return value
    Note: return_is_pointer: 1 if return value is pointer
    Note: points_to_local: 1 if pointer points to local variable
    Note: Returns 1 if valid, 0 if invalid

    Note: Non-pointers have valid lifetime
    If return_is_pointer is equal to 0:
        Return 1
    End If

    Note: Pointer to local is invalid (dangling pointer)
    If points_to_local is equal to 1:
        Return 0
    End If

    Return 1
End Process

Note: ============================================================================
Note: Return Statement Position
Note: ============================================================================

Process called "is_early_return" takes is_last_statement as Integer, inside_conditional as Integer returns Integer:
    Note: Check if return is early return (not at function end)
    Note: is_last_statement: 1 if return is last statement in function
    Note: inside_conditional: 1 if return is inside if/loop
    Note: Returns 1 if early return, 0 if final return

    Note: Last statement is not early return
    If is_last_statement is equal to 1:
        Return 0
    End If

    Note: Return inside conditional is early return
    If inside_conditional is equal to 1:
        Return 1
    End If

    Note: Return not at end is early return
    Return 1
End Process

Process called "count_early_returns" takes total_returns as Integer, final_return_exists as Integer returns Integer:
    Note: Count number of early returns in function
    Note: total_returns: total number of return statements
    Note: final_return_exists: 1 if function has return at end
    Note: Returns count of early returns

    Note: If no final return, all returns are early
    If final_return_exists is equal to 0:
        Return total_returns
    End If

    Note: Subtract final return from total
    Let early_count be total_returns minus 1
    Return early_count
End Process
