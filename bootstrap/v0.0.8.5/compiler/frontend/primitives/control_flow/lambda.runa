Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles lambda expression validation and closure analysis for the compiler.

This file performs the following tasks:
- Validate lambda expressions and parameter lists
- Analyze captured variables and closure requirements
- Determine lambda invocation mechanisms
- Validate lambda type signatures

This file is essential because of the following reasons:
- Lambda expressions require closure generation for captured variables
- Proper capture analysis ensures correct variable lifetime
- Lambda validation prevents invalid closures
- Type checking ensures lambda signatures match usage

Dependencies:
- NONE (pure analysis and validation)
:End Note

Note: ============================================================================
Note: Lambda Structure Validation
Note: ============================================================================

Process called "validate_lambda_signature" takes param_count as Integer, has_return_type as Integer returns Integer:
    Note: Validate lambda signature structure
    Note: param_count: number of parameters lambda accepts
    Note: has_return_type: 1 if return type explicitly specified, 0 if inferred
    Note: Returns 1 if valid, 0 if invalid

    Note: Parameter count must be non-negative
    If param_count is less than 0:
        Return 0
    End If

    Note: Lambda signature is valid
    Return 1
End Process

Process called "validate_parameter_types" takes param_count as Integer, all_types_specified as Integer returns Integer:
    Note: Validate lambda parameter type specifications
    Note: param_count: number of parameters
    Note: all_types_specified: 1 if all parameters have explicit types, 0 if some inferred
    Note: Returns 1 if valid, 0 if invalid

    Note: If no parameters, no types to validate
    If param_count is equal to 0:
        Return 1
    End If

    Note: Parameters are valid
    Return 1
End Process

Process called "validate_lambda_body" takes has_statements as Integer, has_return as Integer, return_type as Integer returns Integer:
    Note: Validate lambda body structure
    Note: has_statements: 1 if body has statements, 0 if expression-only
    Note: has_return: 1 if body contains return statement
    Note: return_type: expected return type (3=void means no return expected)
    Note: Returns 1 if valid, 0 if invalid

    Note: Void lambdas do not need return statement
    If return_type is equal to 3:
        Return 1
    End If

    Note: Non-void lambdas with statements must have return
    If has_statements is equal to 1:
        If has_return is equal to 0:
            Return 0
        End If
    End If

    Note: Lambda body is valid
    Return 1
End Process

Note: ============================================================================
Note: Variable Capture Analysis
Note: ============================================================================

Process called "is_variable_captured" takes var_is_local as Integer, var_defined_in_lambda as Integer, var_used_in_lambda as Integer returns Integer:
    Note: Determine if variable is captured by lambda
    Note: var_is_local: 1 if variable is local to enclosing function
    Note: var_defined_in_lambda: 1 if variable defined inside lambda
    Note: var_used_in_lambda: 1 if variable used inside lambda
    Note: Returns 1 if captured, 0 if not

    Note: Variable must be used in lambda to be captured
    If var_used_in_lambda is equal to 0:
        Return 0
    End If

    Note: Variables defined inside lambda are not captured
    If var_defined_in_lambda is equal to 1:
        Return 0
    End If

    Note: Must be local variable from enclosing scope
    If var_is_local is equal to 0:
        Return 0
    End If

    Note: Variable is captured
    Return 1
End Process

Process called "get_capture_mode" takes var_is_modified as Integer, var_is_reference as Integer returns Integer:
    Note: Determine how variable should be captured
    Note: var_is_modified: 1 if variable is modified in lambda
    Note: var_is_reference: 1 if variable is already a reference type
    Note: Returns: 1=by value, 2=by reference

    Note: If variable is modified, must capture by reference
    If var_is_modified is equal to 1:
        Return 2
    End If

    Note: If variable is already reference, capture by reference
    If var_is_reference is equal to 1:
        Return 2
    End If

    Note: Default: capture by value
    Return 1
End Process

Process called "requires_heap_allocation" takes capture_count as Integer, escapes_scope as Integer returns Integer:
    Note: Determine if lambda closure requires heap allocation
    Note: capture_count: number of captured variables
    Note: escapes_scope: 1 if lambda escapes current scope (returned, stored, passed to async)
    Note: Returns 1 if needs heap, 0 if stack is sufficient

    Note: If lambda escapes scope, must allocate on heap
    If escapes_scope is equal to 1:
        Return 1
    End If

    Note: If lambda has captures, check if it escapes
    If capture_count is greater than 0:
        Note: With captures, if used beyond current scope needs heap
        Note: Since escapes_scope is 0, stack allocation is safe
        Return 0
    End If

    Note: No captures, no heap needed
    Return 0
End Process

Process called "calculate_closure_size" takes capture_count as Integer, bytes_per_capture as Integer returns Integer:
    Note: Calculate size of closure environment
    Note: capture_count: number of captured variables
    Note: bytes_per_capture: average size per captured variable
    Note: Returns total size in bytes

    Note: Closure size is count times size per capture
    Let closure_size be capture_count multiplied by bytes_per_capture

    Note: Add overhead for closure metadata (function pointer, reference count)
    Let overhead be 16
    Set closure_size to closure_size plus overhead

    Return closure_size
End Process

Note: ============================================================================
Note: Lambda Type Analysis
Note: ============================================================================

Process called "get_lambda_type_id" takes param_count as Integer, return_type as Integer returns Integer:
    Note: Generate type ID for lambda signature
    Note: param_count: number of parameters
    Note: return_type: return type ID
    Note: Returns lambda type ID encoding signature

    Note: Encode parameter count in lower 16 bits
    Let type_id be param_count

    Note: Encode return type in bits 16-31
    Let return_shifted be return_type multiplied by 65536
    Set type_id to type_id plus return_shifted

    Return type_id
End Process

Process called "lambda_types_compatible" takes lambda_type1 as Integer, lambda_type2 as Integer returns Integer:
    Note: Check if two lambda types are compatible
    Note: lambda_type1: first lambda type ID
    Note: lambda_type2: second lambda type ID
    Note: Returns 1 if compatible, 0 if incompatible

    Note: Extract parameter counts
    Let param_count1 be lambda_type1 bitwise and 65535
    Let param_count2 be lambda_type2 bitwise and 65535

    Note: Parameter counts must match
    If param_count1 is not equal to param_count2:
        Return 0
    End If

    Note: Extract return types
    Let return_type1 be lambda_type1 shifted right by 16
    Let return_type2 be lambda_type2 shifted right by 16

    Note: Return types must match
    If return_type1 is not equal to return_type2:
        Return 0
    End If

    Note: Types are compatible
    Return 1
End Process

Process called "can_convert_to_function_pointer" takes lambda_has_captures as Integer returns Integer:
    Note: Check if lambda can be converted to plain function pointer
    Note: Only lambdas without captures can be function pointers
    Note: lambda_has_captures: 1 if lambda captures variables, 0 if capture-free
    Note: Returns 1 if can convert, 0 if needs closure

    Note: Lambdas with captures require closure, cannot be plain function pointer
    If lambda_has_captures is equal to 1:
        Return 0
    End If

    Note: Capture-free lambda can be function pointer
    Return 1
End Process

Note: ============================================================================
Note: Lambda Invocation Analysis
Note: ============================================================================

Process called "get_invocation_mechanism" takes has_captures as Integer, is_inlined as Integer returns Integer:
    Note: Determine how lambda should be invoked
    Note: has_captures: 1 if lambda has closure
    Note: is_inlined: 1 if lambda is inlined at call site
    Note: Returns: 1=direct call, 2=closure invoke, 3=inline

    Note: Inlined lambdas are expanded at call site
    If is_inlined is equal to 1:
        Return 3
    End If

    Note: Lambdas with captures require closure invocation
    If has_captures is equal to 1:
        Return 2
    End If

    Note: Capture-free lambdas use direct call
    Return 1
End Process

Process called "can_inline_lambda" takes body_size as Integer, call_count as Integer, has_captures as Integer returns Integer:
    Note: Determine if lambda should be inlined
    Note: body_size: size of lambda body in instructions
    Note: call_count: number of times lambda is called
    Note: has_captures: 1 if lambda has closure
    Note: Returns 1 if should inline, 0 if should not

    Note: Very small lambdas should always be inlined
    If body_size is less than 3:
        Return 1
    End If

    Note: Capture-free small lambdas can be inlined
    If has_captures is equal to 0:
        If body_size is less than 10:
            Return 1
        End If
    End If

    Note: Lambdas called only once should be inlined
    If call_count is equal to 1:
        If body_size is less than 20:
            Return 1
        End If
    End If

    Note: Lambdas with captures have overhead, inline if small and frequent
    If has_captures is equal to 1:
        If body_size is less than 5:
            If call_count is greater than 5:
                Return 1
            End If
        End If
    End If

    Note: Do not inline
    Return 0
End Process

Process called "requires_trampoline" takes is_recursive as Integer, has_mutual_recursion as Integer returns Integer:
    Note: Check if lambda requires trampoline for recursion
    Note: is_recursive: 1 if lambda calls itself
    Note: has_mutual_recursion: 1 if part of mutually recursive group
    Note: Returns 1 if needs trampoline, 0 if direct recursion ok

    Note: Mutual recursion requires trampoline for indirection
    If has_mutual_recursion is equal to 1:
        Return 1
    End If

    Note: Simple recursion does not need trampoline
    If is_recursive is equal to 1:
        Return 0
    End If

    Note: Non-recursive lambdas need no trampoline
    Return 0
End Process

Note: ============================================================================
Note: Closure Lifetime Analysis
Note: ============================================================================

Process called "get_closure_lifetime" takes lambda_escapes as Integer, lambda_returned as Integer, lambda_stored as Integer returns Integer:
    Note: Determine lifetime requirements for closure
    Note: lambda_escapes: 1 if lambda escapes current scope
    Note: lambda_returned: 1 if lambda is returned from function
    Note: lambda_stored: 1 if lambda is stored in data structure
    Note: Returns: 1=stack (function lifetime), 2=heap (indefinite lifetime)

    Note: Returned lambdas must outlive function
    If lambda_returned is equal to 1:
        Return 2
    End If

    Note: Stored lambdas may outlive function
    If lambda_stored is equal to 1:
        Return 2
    End If

    Note: Escaping lambdas need heap allocation
    If lambda_escapes is equal to 1:
        Return 2
    End If

    Note: Lambda used only within function can use stack
    Return 1
End Process

Process called "requires_reference_counting" takes lifetime_is_heap as Integer, has_captures as Integer returns Integer:
    Note: Determine if closure needs reference counting
    Note: lifetime_is_heap: 1 if closure allocated on heap
    Note: has_captures: 1 if closure has captured variables
    Note: Returns 1 if needs refcounting, 0 if manual management ok

    Note: Stack closures do not need reference counting
    If lifetime_is_heap is equal to 0:
        Return 0
    End If

    Note: Heap closures without captures can use simple free
    If has_captures is equal to 0:
        Return 0
    End If

    Note: Heap closures with captures need reference counting
    Return 1
End Process

Process called "can_capture_by_move" takes var_used_after_lambda as Integer, var_is_copyable as Integer returns Integer:
    Note: Check if variable can be moved into closure instead of copied
    Note: var_used_after_lambda: 1 if variable used after lambda creation
    Note: var_is_copyable: 1 if variable type supports copy
    Note: Returns 1 if can move, 0 if must copy

    Note: Cannot move if variable used after lambda creation
    If var_used_after_lambda is equal to 1:
        Return 0
    End If

    Note: Non-copyable types must be moved
    If var_is_copyable is equal to 0:
        Return 1
    End If

    Note: Can move if not used after
    Return 1
End Process

Note: ============================================================================
Note: Lambda Optimization Analysis
Note: ============================================================================

Process called "can_eliminate_lambda" takes lambda_unused as Integer, has_side_effects as Integer returns Integer:
    Note: Check if lambda can be eliminated as dead code
    Note: lambda_unused: 1 if lambda is never called
    Note: has_side_effects: 1 if lambda body has side effects
    Note: Returns 1 if can eliminate, 0 if must keep

    Note: Cannot eliminate if lambda is used
    If lambda_unused is equal to 0:
        Return 0
    End If

    Note: Cannot eliminate if has side effects (even if unused)
    If has_side_effects is equal to 1:
        Return 0
    End If

    Note: Unused pure lambda can be eliminated
    Return 1
End Process

Process called "can_hoist_lambda" takes lambda_captures_loop_vars as Integer, lambda_defined_in_loop as Integer returns Integer:
    Note: Check if lambda defined in loop can be hoisted outside loop
    Note: lambda_captures_loop_vars: 1 if captures variables modified in loop
    Note: lambda_defined_in_loop: 1 if lambda definition is inside loop
    Note: Returns 1 if can hoist, 0 if must remain in loop

    Note: Must be defined in loop to hoist
    If lambda_defined_in_loop is equal to 0:
        Return 0
    End If

    Note: Cannot hoist if captures loop-modified variables
    If lambda_captures_loop_vars is equal to 1:
        Return 0
    End If

    Note: Can hoist lambda outside loop
    Return 1
End Process

Process called "can_memoize_lambda" takes lambda_is_pure as Integer, lambda_args_stable as Integer returns Integer:
    Note: Check if lambda results can be memoized
    Note: lambda_is_pure: 1 if lambda has no side effects and deterministic
    Note: lambda_args_stable: 1 if lambda arguments are stable across calls
    Note: Returns 1 if can memoize, 0 if cannot

    Note: Only pure lambdas can be memoized
    If lambda_is_pure is equal to 0:
        Return 0
    End If

    Note: Arguments must be stable to benefit from memoization
    If lambda_args_stable is equal to 0:
        Return 0
    End If

    Note: Can memoize results
    Return 1
End Process

Note: ============================================================================
Note: Nested Lambda Analysis
Note: ============================================================================

Process called "get_nesting_depth" takes parent_is_lambda as Integer, parent_depth as Integer returns Integer:
    Note: Calculate nesting depth of lambda
    Note: parent_is_lambda: 1 if parent scope is lambda
    Note: parent_depth: nesting depth of parent
    Note: Returns nesting depth (0=top-level function, 1=nested once, etc)

    Note: If parent is not lambda, this is depth 0
    If parent_is_lambda is equal to 0:
        Return 0
    End If

    Note: Increment parent depth
    Let depth be parent_depth plus 1
    Return depth
End Process

Process called "requires_environment_chain" takes nesting_depth as Integer returns Integer:
    Note: Check if lambda requires environment chain for nested access
    Note: nesting_depth: how many levels deep lambda is nested
    Note: Returns 1 if needs chain, 0 if flat closure sufficient

    Note: Single-level lambdas use flat closure
    If nesting_depth is less than or equal to 1:
        Return 0
    End If

    Note: Nested lambdas need environment chain
    Return 1
End Process

Process called "calculate_environment_chain_depth" takes nesting_depth as Integer, max_capture_depth as Integer returns Integer:
    Note: Calculate how many environment frames must be chained
    Note: nesting_depth: how deep lambda is nested
    Note: max_capture_depth: deepest scope from which variables are captured
    Note: Returns number of environment frames to chain

    Note: Chain depth is the maximum capture depth
    Return max_capture_depth
End Process
