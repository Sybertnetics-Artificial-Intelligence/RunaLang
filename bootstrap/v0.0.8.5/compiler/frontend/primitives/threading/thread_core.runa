Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions
Licensed under the Apache License, Version 2.0
:End Note

Note:
THREAD MANAGEMENT - Platform-Independent API

Provides cross-platform thread creation, management, and control.
Delegates to platform-specific threading implementations.

Thread Structure (32 bytes):
offset 0: platform_handle (8 bytes) - pthread_t or HANDLE
offset 8: function_ptr (8 bytes)
offset 16: arg_ptr (8 bytes)
offset 24: state (8 bytes) - 0=created, 1=running, 2=finished, 3=detached

Dependencies:
- assembly/threading.runa (platform delegation)
- memory/layout.runa (allocation)
:End Note

Import "compiler/frontend/primitives/assembly/threading.runa" as Threading
Import "compiler/frontend/primitives/memory/layout.runa" as Memory

Note: ============================================================================
Note: Thread Lifecycle
Note: ============================================================================

Process called "thread_create" takes function_ptr as Integer, arg_ptr as Integer returns Integer:
    Note: Create and start a new thread
    Note: Returns thread ID (pointer to thread structure), or 0 on failure
    Note: Thread runs function_ptr(arg_ptr)

    Note: Allocate thread structure (32 bytes)
    Let thread_id be proc allocate from Memory with 32
    If thread_id is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Initialize thread structure
    proc memory_set_int64 from Memory with thread_id, 8, function_ptr
    proc memory_set_int64 from Memory with thread_id, 16, arg_ptr
    proc memory_set_int64 from Memory with thread_id, 24, 0

    Note: Platform-specific thread creation
    Let platform_handle be proc platform_thread_create from Threading with function_ptr, arg_ptr
    If platform_handle is equal to 0:
        proc deallocate from Memory with thread_id
        Return 0
    End If

    Note: Store platform handle and update state
    proc memory_set_int64 from Memory with thread_id, 0, platform_handle
    proc memory_set_int64 from Memory with thread_id, 24, 1

    Return thread_id
End Process

Process called "thread_join" takes thread_id as Integer returns Integer:
    Note: Wait for thread to finish and get exit code
    Note: Returns exit code from thread, or -1 on error

    If thread_id is equal to 0:
        Return -1
    End If

    Note: Check if thread is detached
    Let state be proc memory_get_int64 from Memory with thread_id, 24
    If state is equal to 3:
        Return -1
    End If

    Note: Get platform handle
    Let platform_handle be proc memory_get_int64 from Memory with thread_id, 0

    Note: Platform-specific join
    Let exit_code be proc platform_thread_join from Threading with platform_handle

    Note: Update state and free structure
    proc memory_set_int64 from Memory with thread_id, 24, 2
    proc deallocate from Memory with thread_id

    Return exit_code
End Process

Process called "thread_detach" takes thread_id as Integer returns Integer:
    Note: Detach thread (runs independently, cannot be joined)
    Note: Returns 1 on success, 0 on error

    If thread_id is equal to 0:
        Return 0
    End If

    Note: Check if already finished or detached
    Let state be proc memory_get_int64 from Memory with thread_id, 24
    If state is equal to 2:
        Return 0
    End If
    If state is equal to 3:
        Return 0
    End If

    Note: Get platform handle
    Let platform_handle be proc memory_get_int64 from Memory with thread_id, 0

    Note: Platform-specific detach
    Let result be proc platform_thread_detach from Threading with platform_handle
    If result is equal to 0:
        Return 0
    End If


    Note: Update state
    proc memory_set_int64 from Memory with thread_id, 24, 3

    Return 1
End Process

Process called "thread_exit" takes exit_code as Integer returns Integer:
    Note: Exit current thread with exit code
    Note: Does not return
    Return proc platform_thread_exit from Threading with exit_code
End Process

Note: ============================================================================
Note: Thread Query
Note: ============================================================================

Process called "thread_current_id" returns Integer:
    Note: Get current thread ID (platform-specific handle)
    Return proc platform_thread_current_id from Threading
End Process


Process called "thread_is_alive" takes thread_id as Integer returns Integer:
    Note: Check if thread is still running
    Note: Returns 1 if alive, 0 if finished/detached/invalid

    If thread_id is equal to 0:
        Return 0
    End If

    Let state be proc memory_get_int64 from Memory with thread_id, 24
    If state is equal to 1:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Thread Control
Note: ============================================================================

Process called "thread_yield" returns Integer:
    Note: Yield CPU to other threads
    Note: Hint to scheduler to run other threads
    Return proc platform_thread_yield from Threading
End Process


Process called "thread_sleep" takes microseconds as Integer returns Integer:
    Note: Sleep for specified microseconds
    Note: Returns 0 on success, -1 on error
    Return proc platform_thread_sleep from Threading with microseconds
End Process

Process called "thread_set_name" takes name as Integer returns Integer:
    Note: Set current thread name (for debugging)
    Note: name is pointer to null-terminated string
    Note: Returns 1 on success, 0 on error
    Return proc platform_thread_set_name from Threading with name
End Process

Process called "thread_get_name" returns Integer:
    Note: Get current thread name
    Note: Returns pointer to static string, or 0 if not supported
    Return proc platform_thread_get_name from Threading
End Process

Process called "thread_get_state" takes thread_id as Integer returns Integer:
    Note: Get thread state: 0=created, 1=running, 2=finished, 3=detached
    Note: Returns -1 if invalid thread_id

    If thread_id is equal to 0:
        Return -1
    End If

    Return proc memory_get_int64 from Memory with thread_id, 24
End Process

Process called "thread_equals" takes thread_id_a as Integer, thread_id_b as Integer returns Integer:
    Note: Check if two thread IDs refer to the same thread
    Note: Returns 1 if equal, 0 if different

    If thread_id_a is equal to thread_id_b:
        Return 1
    End If

    If thread_id_a is equal to 0:
        Return 0
    End If
    If thread_id_b is equal to 0:
        Return 0
    End If

    Let handle_a be proc memory_get_int64 from Memory with thread_id_a, 0
    Let handle_b be proc memory_get_int64 from Memory with thread_id_b, 0

    If handle_a is equal to handle_b:
        Return 1
    End If

    Return 0
End Process

Process called "thread_set_priority" takes thread_id as Integer, priority as Integer returns Integer:
    Note: Set thread priority
    Note: priority: -20 (highest) to 19 (lowest), 0 is normal
    Note: Returns 1 on success, 0 on error

    If thread_id is equal to 0:
        Return 0
    End If

    If priority is less than -20:
        Return 0
    End If
    If priority is greater than 19:
        Return 0
    End If

    Let platform_handle be proc memory_get_int64 from Memory with thread_id, 0
    Return proc platform_thread_set_priority from Threading with platform_handle, priority
End Process

Process called "thread_get_priority" takes thread_id as Integer returns Integer:
    Note: Get thread priority
    Note: Returns priority value, or -999 on error

    If thread_id is equal to 0:
        Return -999
    End If

    Let platform_handle be proc memory_get_int64 from Memory with thread_id, 0
    Return proc platform_thread_get_priority from Threading with platform_handle
End Process

Note: ============================================================================
Note: Thread Affinity
Note: ============================================================================

Process called "thread_set_affinity" takes thread_id as Integer, cpu_mask as Integer returns Integer:
    Note: Set CPU affinity (which CPUs thread can run on)
    Note: cpu_mask: bitfield where bit N = CPU N
    Note: Returns 1 on success, 0 on error

    If thread_id is equal to 0:
        Return 0
    End If

    If cpu_mask is equal to 0:
        Return 0
    End If

    Let platform_handle be proc memory_get_int64 from Memory with thread_id, 0
    Return proc platform_thread_set_affinity from Threading with platform_handle, cpu_mask
End Process

Process called "thread_get_affinity" takes thread_id as Integer returns Integer:
    Note: Get CPU affinity mask
    Note: Returns cpu_mask bitfield, or 0 on error

    If thread_id is equal to 0:
        Return 0
    End If

    Let platform_handle be proc memory_get_int64 from Memory with thread_id, 0
    Return proc platform_thread_get_affinity from Threading with platform_handle
End Process

Note: ============================================================================
Note: Hardware Query
Note: ============================================================================

Process called "thread_hardware_concurrency" returns Integer:
    Note: Get number of hardware threads (CPU cores)
    Note: Returns core count, or 1 if detection fails
    Return proc platform_hardware_concurrency from Threading
End Process

Process called "thread_get_cpu_id" returns Integer:
    Note: Get current CPU ID that thread is running on
    Note: Returns CPU ID (0 to N-1), or -1 if not supported
    Return proc platform_get_cpu_id from Threading
End Process

Note: ============================================================================
Note: Thread Validation (Primitives)
Note: ============================================================================

Process called "validate_thread_creation" takes function_ptr as Integer, arg_ptr as Integer returns Integer:
    Note: Validate thread creation parameters
    Note: Returns 1 if valid, 0 if invalid

    If function_ptr is equal to 0:
        Return 0
    End If

    Let alignment_mask be 7
    Let alignment_check be function_ptr bitwise and alignment_mask
    If alignment_check is not equal to 0:
        Return 0
    End If

    If arg_ptr is not equal to 0:
        Set alignment_check to arg_ptr bitwise and alignment_mask
        If alignment_check is not equal to 0:
            Return 0
        End If
    End If

    Return 1
End Process

Process called "validate_thread_id" takes thread_id as Integer returns Integer:
    Note: Validate thread ID structure
    Note: Returns 1 if valid, 0 if invalid

    If thread_id is equal to 0:
        Return 0
    End If

    Let alignment_mask be 7
    Let alignment_check be thread_id bitwise and alignment_mask
    If alignment_check is not equal to 0:
        Return 0
    End If

    Let state be proc memory_get_int64 from Memory with thread_id, 24
    If state is less than 0:
        Return 0
    End If
    If state is greater than 3:
        Return 0
    End If

    Return 1
End Process

Process called "can_join_thread" takes thread_id as Integer returns Integer:
    Note: Check if thread can be joined
    Note: Returns 1 if joinable, 0 if not

    If thread_id is equal to 0:
        Return 0
    End If

    Let state be proc memory_get_int64 from Memory with thread_id, 24

    If state is equal to 1:
        Return 1
    End If
    If state is equal to 2:
        Return 1
    End If

    Return 0
End Process

Process called "can_detach_thread" takes thread_id as Integer returns Integer:
    Note: Check if thread can be detached
    Note: Returns 1 if detachable, 0 if not

    If thread_id is equal to 0:
        Return 0
    End If

    Let state be proc memory_get_int64 from Memory with thread_id, 24

    If state is equal to 0:
        Return 1
    End If
    If state is equal to 1:
        Return 1
    End If

    Return 0
End Process

Process called "is_current_thread" takes thread_id as Integer returns Integer:
    Note: Check if thread_id refers to current thread
    Note: Returns 1 if current thread, 0 otherwise

    If thread_id is equal to 0:
        Return 0
    End If

    Let current_handle be proc platform_thread_current_id from Threading
    Let thread_handle be proc memory_get_int64 from Memory with thread_id, 0

    If current_handle is equal to thread_handle:
        Return 1
    End If

    Return 0
End Process

Process called "validate_priority" takes priority as Integer returns Integer:
    Note: Validate thread priority value
    Note: Returns 1 if valid, 0 if invalid
    Note: Valid range: -20 to 19

    If priority is less than -20:
        Return 0
    End If
    If priority is greater than 19:
        Return 0
    End If

    Return 1
End Process

Process called "validate_cpu_mask" takes cpu_mask as Integer, max_cpus as Integer returns Integer:
    Note: Validate CPU affinity mask
    Note: Returns 1 if valid, 0 if invalid

    If cpu_mask is equal to 0:
        Return 0
    End If

    Let valid_mask be 1
    Let shift_count be 0
    While shift_count is less than max_cpus:
        Set valid_mask to valid_mask shifted left by 1
        Set shift_count to shift_count plus 1
    End While
    Set valid_mask to valid_mask minus 1

    Let invalid_bits_negated be valid_mask bitwise xor -1
    Let invalid_bits be cpu_mask bitwise and invalid_bits_negated
    If invalid_bits is not equal to 0:
        Return 0
    End If

    Return 1
End Process

Process called "estimate_thread_overhead" takes thread_count as Integer returns Integer:
    Note: Estimate memory overhead for thread_count threads
    Note: Returns bytes required
    Note: Each thread: 32 bytes structure + platform overhead

    If thread_count is less than 0:
        Return 0
    End If

    Let structure_overhead be thread_count multiplied by 32

    Let stack_size be 2097152
    Let tcb_size be 1024
    Let platform_overhead_per_thread be stack_size plus tcb_size
    Let platform_overhead be thread_count multiplied by platform_overhead_per_thread

    Let total_overhead be structure_overhead plus platform_overhead
    Return total_overhead
End Process

Process called "should_use_thread_pool" takes task_count as Integer, task_duration_us as Integer returns Integer:
    Note: Determine if thread pool is beneficial
    Note: Returns 1 if thread pool recommended, 0 for direct threads
    Note: Thread pool beneficial when: many short tasks

    Let creation_overhead_us be 50

    If task_duration_us is less than 100:
        Return 1
    End If

    If task_count is greater than 100:
        Return 1
    End If

    Let overhead_threshold be task_duration_us divided by 10
    If creation_overhead_us is greater than overhead_threshold:
        Return 1
    End If

    Return 0
End Process

Process called "calculate_optimal_thread_count" takes task_count as Integer, cpu_bound as Integer returns Integer:
    Note: Calculate optimal thread count for workload
    Note: cpu_bound: 1 if CPU-bound, 0 if I/O-bound
    Note: Returns recommended thread count

    Let cpu_count be proc platform_hardware_concurrency from Threading
    If cpu_count is less than 1:
        Set cpu_count to 1
    End If

    If cpu_bound is equal to 1:
        If task_count is less than cpu_count:
            Return task_count
        End If
        Return cpu_count
    End If

    Let optimal_count be cpu_count multiplied by 2

    If task_count is less than optimal_count:
        Return task_count
    End If

    Return optimal_count
End Process

Note: ============================================================================
Note: Thread State Constants
Note: ============================================================================

Process called "THREAD_STATE_CREATED" returns Integer:
    Return 0
End Process

Process called "THREAD_STATE_RUNNING" returns Integer:
    Return 1
End Process

Process called "THREAD_STATE_FINISHED" returns Integer:
    Return 2
End Process

Process called "THREAD_STATE_DETACHED" returns Integer:
    Return 3
End Process