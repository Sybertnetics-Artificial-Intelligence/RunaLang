Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions
Licensed under the Apache License, Version 2.0
:End Note

Note:
SYNCHRONIZATION PRIMITIVES - Platform-Independent API

Provides mutex, semaphore, condition variables, read-write locks, and spinlocks.
All primitives are platform-independent and delegate to platform-specific implementations.

Structures:
- Mutex: 24 bytes (handle + owner + lock_count)
- Semaphore: 16 bytes (handle + count)
- CondVar: 16 bytes (handle + waiter_count)
- RWLock: 24 bytes (handle + reader_count + writer_id)
- Spinlock: 8 bytes (lock_flag)

Dependencies:
- assembly/threading.runa (platform delegation)
- memory/layout.runa (allocation)
- core/atomic_core.runa (for spinlock)
:End Note

Import "compiler/frontend/primitives/assembly/threading.runa" as Threading
Import "compiler/frontend/primitives/memory/layout.runa" as Memory
Import "compiler/frontend/primitives/core/atomic_core.runa" as Atomic

Process called "mutex_create" returns Integer:

    Let mutex_ptr be proc allocate from Memory with 24
    If mutex_ptr is equal to 0:
        Return 0
    End If

    Let platform_handle be proc platform_mutex_create from Threading
    If platform_handle is equal to 0:
        proc deallocate from Memory with mutex_ptr
        Return 0
    End If

    proc memory_set_int64 from Memory with mutex_ptr, 0, platform_handle
    proc memory_set_int64 from Memory with mutex_ptr, 8, 0
    proc memory_set_int64 from Memory with mutex_ptr, 16, 0

    Return mutex_ptr
End Process

Process called "mutex_destroy" takes mutex_ptr as Integer returns Integer:

    If mutex_ptr is equal to 0:
        Return 0
    End If

    Let platform_handle be proc memory_get_int64 from Memory with mutex_ptr, 0
    Let result be proc platform_mutex_destroy from Threading with platform_handle

    proc deallocate from Memory with mutex_ptr
    Return result
End Process

Process called "mutex_lock" takes mutex_ptr as Integer returns Integer:

    If mutex_ptr is equal to 0:
        Return 0
    End If

    Let platform_handle be proc memory_get_int64 from Memory with mutex_ptr, 0
    Let result be proc platform_mutex_lock from Threading with platform_handle

    If result is equal to 1:
        Let thread_id be proc platform_thread_current_id from Threading
        proc memory_set_int64 from Memory with mutex_ptr, 8, thread_id

        Let lock_count be proc memory_get_int64 from Memory with mutex_ptr, 16
        Let new_count be lock_count plus 1
        proc memory_set_int64 from Memory with mutex_ptr, 16, new_count
    End If

    Return result
End Process

Process called "mutex_unlock" takes mutex_ptr as Integer returns Integer:

    If mutex_ptr is equal to 0:
        Return 0
    End If

    Let lock_count be proc memory_get_int64 from Memory with mutex_ptr, 16
    If lock_count is greater than 0:
        Let new_count be lock_count minus 1
        proc memory_set_int64 from Memory with mutex_ptr, 16, new_count
    End If

    If lock_count is equal to 1:
        proc memory_set_int64 from Memory with mutex_ptr, 8, 0
    End If

    Let platform_handle be proc memory_get_int64 from Memory with mutex_ptr, 0
    Return proc platform_mutex_unlock from Threading with platform_handle
End Process

Process called "mutex_try_lock" takes mutex_ptr as Integer returns Integer:

    If mutex_ptr is equal to 0:
        Return 0
    End If

    Let platform_handle be proc memory_get_int64 from Memory with mutex_ptr, 0
    Let result be proc platform_mutex_try_lock from Threading with platform_handle

    If result is equal to 1:
        Let thread_id be proc platform_thread_current_id from Threading
        proc memory_set_int64 from Memory with mutex_ptr, 8, thread_id

        Let lock_count be proc memory_get_int64 from Memory with mutex_ptr, 16
        Let new_count be lock_count plus 1
        proc memory_set_int64 from Memory with mutex_ptr, 16, new_count
    End If

    Return result
End Process

Process called "mutex_is_locked" takes mutex_ptr as Integer returns Integer:

    If mutex_ptr is equal to 0:
        Return 0
    End If

    Let lock_count be proc memory_get_int64 from Memory with mutex_ptr, 16
    If lock_count is greater than 0:
        Return 1
    End If
    Return 0
End Process

Process called "mutex_get_owner" takes mutex_ptr as Integer returns Integer:

    If mutex_ptr is equal to 0:
        Return 0
    End If

    Return proc memory_get_int64 from Memory with mutex_ptr, 8
End Process

Process called "semaphore_create" takes initial_count as Integer returns Integer:

    Let sem_ptr be proc allocate from Memory with 16
    If sem_ptr is equal to 0:
        Return 0
    End If

    Let platform_handle be proc platform_semaphore_create from Threading with initial_count
    If platform_handle is equal to 0:
        proc deallocate from Memory with sem_ptr
        Return 0
    End If

    proc memory_set_int64 from Memory with sem_ptr, 0, platform_handle
    proc memory_set_int64 from Memory with sem_ptr, 8, initial_count

    Return sem_ptr
End Process

Process called "semaphore_destroy" takes sem_ptr as Integer returns Integer:

    If sem_ptr is equal to 0:
        Return 0
    End If

    Let platform_handle be proc memory_get_int64 from Memory with sem_ptr, 0
    Let result be proc platform_semaphore_destroy from Threading with platform_handle

    proc deallocate from Memory with sem_ptr
    Return result
End Process

Process called "semaphore_wait" takes sem_ptr as Integer returns Integer:

    If sem_ptr is equal to 0:
        Return 0
    End If

    Let platform_handle be proc memory_get_int64 from Memory with sem_ptr, 0
    Let result be proc platform_semaphore_wait from Threading with platform_handle

    If result is equal to 1:
        Let count be proc memory_get_int64 from Memory with sem_ptr, 8
        Let new_count be count minus 1
        proc memory_set_int64 from Memory with sem_ptr, 8, new_count
    End If

    Return result
End Process

Process called "semaphore_signal" takes sem_ptr as Integer returns Integer:

    If sem_ptr is equal to 0:
        Return 0
    End If

    Let count be proc memory_get_int64 from Memory with sem_ptr, 8
    Let new_count be count plus 1
    proc memory_set_int64 from Memory with sem_ptr, 8, new_count

    Let platform_handle be proc memory_get_int64 from Memory with sem_ptr, 0
    Return proc platform_semaphore_signal from Threading with platform_handle
End Process

Process called "semaphore_try_wait" takes sem_ptr as Integer returns Integer:

    If sem_ptr is equal to 0:
        Return 0
    End If

    Let platform_handle be proc memory_get_int64 from Memory with sem_ptr, 0
    Let result be proc platform_semaphore_try_wait from Threading with platform_handle

    If result is equal to 1:
        Let count be proc memory_get_int64 from Memory with sem_ptr, 8
        Let new_count be count minus 1
        proc memory_set_int64 from Memory with sem_ptr, 8, new_count
    End If

    Return result
End Process

Process called "condvar_create" returns Integer:

    Let cv_ptr be proc allocate from Memory with 16
    If cv_ptr is equal to 0:
        Return 0
    End If

    Let platform_handle be proc platform_condvar_create from Threading
    If platform_handle is equal to 0:
        proc deallocate from Memory with cv_ptr
        Return 0
    End If

    proc memory_set_int64 from Memory with cv_ptr, 0, platform_handle
    proc memory_set_int64 from Memory with cv_ptr, 8, 0

    Return cv_ptr
End Process

Process called "condvar_destroy" takes cv_ptr as Integer returns Integer:
    If cv_ptr is equal to 0:
        Return 0
    End If

    Let platform_handle be proc memory_get_int64 from Memory with cv_ptr, 0
    Let result be proc platform_condvar_destroy from Threading with platform_handle

    proc deallocate from Memory with cv_ptr
    Return result
End Process

Process called "condvar_wait" takes cv_ptr as Integer, mutex_ptr as Integer returns Integer:

    If cv_ptr is equal to 0:
        Return 0
    End If
    If mutex_ptr is equal to 0:
        Return 0
    End If

    Let cv_handle be proc memory_get_int64 from Memory with cv_ptr, 0
    Let mutex_handle be proc memory_get_int64 from Memory with mutex_ptr, 0
    Let waiter_count be proc memory_get_int64 from Memory with cv_ptr, 8
    Let new_count be waiter_count plus 1
    proc memory_set_int64 from Memory with cv_ptr, 8, new_count

    Let result be proc platform_condvar_wait from Threading with cv_handle, mutex_handle
    Set waiter_count to proc memory_get_int64 from Memory with cv_ptr, 8
    Set new_count to waiter_count minus 1
    proc memory_set_int64 from Memory with cv_ptr, 8, new_count

    Return result
End Process

Process called "condvar_timed_wait" takes cv_ptr as Integer, mutex_ptr as Integer, timeout_us as Integer returns Integer:

    If cv_ptr is equal to 0:
        Return 0
    End If
    If mutex_ptr is equal to 0:
        Return 0
    End If

    Let cv_handle be proc memory_get_int64 from Memory with cv_ptr, 0
    Let mutex_handle be proc memory_get_int64 from Memory with mutex_ptr, 0

    Return proc platform_condvar_timed_wait from Threading with cv_handle, mutex_handle, timeout_us
End Process

Process called "condvar_signal" takes cv_ptr as Integer returns Integer:

    If cv_ptr is equal to 0:
        Return 0
    End If

    Let platform_handle be proc memory_get_int64 from Memory with cv_ptr, 0
    Return proc platform_condvar_signal from Threading with platform_handle
End Process

Process called "condvar_broadcast" takes cv_ptr as Integer returns Integer:

    If cv_ptr is equal to 0:
        Return 0
    End If

    Let platform_handle be proc memory_get_int64 from Memory with cv_ptr, 0
    Return proc platform_condvar_broadcast from Threading with platform_handle
End Process

Process called "rwlock_create" returns Integer:
    Let rwlock_ptr be proc allocate from Memory with 24
    If rwlock_ptr is equal to 0:
        Return 0
    End If

    Let platform_handle be proc platform_rwlock_create from Threading
    If platform_handle is equal to 0:
        proc deallocate from Memory with rwlock_ptr
        Return 0
    End If

    proc memory_set_int64 from Memory with rwlock_ptr, 0, platform_handle
    proc memory_set_int64 from Memory with rwlock_ptr, 8, 0
    proc memory_set_int64 from Memory with rwlock_ptr, 16, 0

    Return rwlock_ptr
End Process

Process called "rwlock_destroy" takes rwlock_ptr as Integer returns Integer:
    If rwlock_ptr is equal to 0:
        Return 0
    End If

    Let platform_handle be proc memory_get_int64 from Memory with rwlock_ptr, 0
    Let result be proc platform_rwlock_destroy from Threading with platform_handle

    proc deallocate from Memory with rwlock_ptr
    Return result
End Process

Process called "rwlock_read_lock" takes rwlock_ptr as Integer returns Integer:

    If rwlock_ptr is equal to 0:
        Return 0
    End If

    Let platform_handle be proc memory_get_int64 from Memory with rwlock_ptr, 0
    Let result be proc platform_rwlock_read_lock from Threading with platform_handle

    If result is equal to 1:
        Let reader_count be proc memory_get_int64 from Memory with rwlock_ptr, 8
        Let new_count be reader_count plus 1
        proc memory_set_int64 from Memory with rwlock_ptr, 8, new_count
    End If

    Return result
End Process

Process called "rwlock_write_lock" takes rwlock_ptr as Integer returns Integer:

    If rwlock_ptr is equal to 0:
        Return 0
    End If

    Let platform_handle be proc memory_get_int64 from Memory with rwlock_ptr, 0
    Let result be proc platform_rwlock_write_lock from Threading with platform_handle

    If result is equal to 1:
        Let thread_id be proc platform_thread_current_id from Threading
        proc memory_set_int64 from Memory with rwlock_ptr, 16, thread_id
    End If

    Return result
End Process

Process called "rwlock_unlock" takes rwlock_ptr as Integer returns Integer:
    If rwlock_ptr is equal to 0:
        Return 0
    End If
    Let reader_count be proc memory_get_int64 from Memory with rwlock_ptr, 8
    If reader_count is greater than 0:
        Let new_count be reader_count minus 1
        proc memory_set_int64 from Memory with rwlock_ptr, 8, new_count
    Otherwise:
        proc memory_set_int64 from Memory with rwlock_ptr, 16, 0
    End If

    Let platform_handle be proc memory_get_int64 from Memory with rwlock_ptr, 0
    Return proc platform_rwlock_unlock from Threading with platform_handle
End Process

Process called "rwlock_try_read_lock" takes rwlock_ptr as Integer returns Integer:
    If rwlock_ptr is equal to 0:
        Return 0
    End If

    Let platform_handle be proc memory_get_int64 from Memory with rwlock_ptr, 0
    Let result be proc platform_rwlock_try_read_lock from Threading with platform_handle

    If result is equal to 1:
        Let reader_count be proc memory_get_int64 from Memory with rwlock_ptr, 8
        Let new_count be reader_count plus 1
        proc memory_set_int64 from Memory with rwlock_ptr, 8, new_count
    End If

    Return result
End Process

Process called "rwlock_try_write_lock" takes rwlock_ptr as Integer returns Integer:
    If rwlock_ptr is equal to 0:
        Return 0
    End If

    Let platform_handle be proc memory_get_int64 from Memory with rwlock_ptr, 0
    Let result be proc platform_rwlock_try_write_lock from Threading with platform_handle

    If result is equal to 1:
        Let thread_id be proc platform_thread_current_id from Threading
        proc memory_set_int64 from Memory with rwlock_ptr, 16, thread_id
    End If

    Return result
End Process

Process called "spinlock_create" returns Integer:

    Let spinlock_ptr be proc allocate from Memory with 8
    If spinlock_ptr is equal to 0:
        Return 0
    End If

    proc atomic_store_relaxed from Atomic with spinlock_ptr, 0
    Return spinlock_ptr
End Process

Process called "spinlock_destroy" takes spinlock_ptr as Integer returns Integer:
    If spinlock_ptr is equal to 0:
        Return 0
    End If

    proc deallocate from Memory with spinlock_ptr
    Return 1
End Process

Process called "spinlock_lock" takes spinlock_ptr as Integer returns Integer:

    If spinlock_ptr is equal to 0:
        Return 0
    End If
    While proc atomic_flag_test_and_set from Atomic with spinlock_ptr is equal to 1:
    End While

    Return 1
End Process

Process called "spinlock_unlock" takes spinlock_ptr as Integer returns Integer:

    If spinlock_ptr is equal to 0:
        Return 0
    End If

    proc atomic_store_release from Atomic with spinlock_ptr, 0
    Return 1
End Process
