Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file implements low-level Linux x86_64 system calls using inline assembly.

System calls are the interface between user programs and the Linux kernel.
They replace C runtime library functions with direct kernel invocations.

Linux x86_64 System Call ABI:
- Syscall number in RAX
- Arguments in RDI, RSI, RDX, R10, R8, R9 (in that order)
- Return value in RAX (negative values indicate errors)
- Syscall instruction invokes the kernel
- RCX and R11 are clobbered by syscall instruction

This implementation provides:
1. Generic syscall wrappers (syscall_0 through syscall_6) for 0-6 arguments
2. High-level wrappers for common syscalls (read, write, open, close, etc.)
3. Syscall number constants for Linux x86_64
:End Note

Note: ============================================================================
Note: SYSCALL NUMBER CONSTANTS (Linux x86_64)
Note: ============================================================================
Note: Reference: /usr/include/x86_64-linux-gnu/asm/unistd_64.h
Note: Or use: ausyscall --dump to see all syscalls

Note: File I/O syscalls
Process called "SYS_READ" returns Integer:
    Return 0
End Process

Process called "SYS_WRITE" returns Integer:
    Return 1
End Process

Process called "SYS_OPEN" returns Integer:
    Return 2
End Process

Process called "SYS_CLOSE" returns Integer:
    Return 3
End Process

Note: Process/Memory syscalls
Process called "SYS_BRK" returns Integer:
    Return 12
End Process

Process called "SYS_MMAP" returns Integer:
    Return 9
End Process

Process called "SYS_MUNMAP" returns Integer:
    Return 11
End Process

Process called "SYS_EXIT" returns Integer:
    Return 60
End Process

Process called "SYS_EXIT_GROUP" returns Integer:
    Return 231
End Process

Note: File status syscalls
Process called "SYS_STAT" returns Integer:
    Return 4
End Process

Process called "SYS_FSTAT" returns Integer:
    Return 5
End Process

Process called "SYS_LSTAT" returns Integer:
    Return 6
End Process

Process called "SYS_LSEEK" returns Integer:
    Return 8
End Process

Note: More file syscalls
Process called "SYS_CREAT" returns Integer:
    Return 85
End Process

Process called "SYS_UNLINK" returns Integer:
    Return 87
End Process

Process called "SYS_MKDIR" returns Integer:
    Return 83
End Process

Process called "SYS_RMDIR" returns Integer:
    Return 84
End Process

Note: ============================================================================
Note: GENERIC SYSCALL WRAPPERS
Note: ============================================================================
Note: These provide raw syscall invocation with 0-6 arguments
Note: Arguments follow System V x86_64 ABI for function calls (RDI, RSI, RDX, RCX, R8, R9)
Note: But syscalls use R10 instead of RCX (because syscall clobbers RCX)

Note: Syscall with 0 arguments
Process called "syscall_0" takes syscall_number as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        # Load syscall number into RAX
        movq -8(%rbp), %rax

        # Invoke kernel
        syscall

        # Store result
        movq %rax, -16(%rbp)
    End Assembly
    Return result
End Process

Note: Syscall with 1 argument
Process called "syscall_1" takes syscall_number as Integer, arg1 as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        # Load syscall number into RAX
        movq -8(%rbp), %rax

        # Load argument 1 into RDI
        movq -16(%rbp), %rdi

        # Invoke kernel
        syscall

        # Store result
        movq %rax, -24(%rbp)
    End Assembly
    Return result
End Process

Note: Syscall with 2 arguments
Process called "syscall_2" takes syscall_number as Integer, arg1 as Integer, arg2 as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        # Load syscall number into RAX
        movq -8(%rbp), %rax

        # Load argument 1 into RDI
        movq -16(%rbp), %rdi

        # Load argument 2 into RSI
        movq -24(%rbp), %rsi

        # Invoke kernel
        syscall

        # Store result
        movq %rax, -32(%rbp)
    End Assembly
    Return result
End Process

Note: Syscall with 3 arguments
Process called "syscall_3" takes syscall_number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        # Load syscall number into RAX
        movq -8(%rbp), %rax

        # Load argument 1 into RDI
        movq -16(%rbp), %rdi

        # Load argument 2 into RSI
        movq -24(%rbp), %rsi

        # Load argument 3 into RDX
        movq -32(%rbp), %rdx

        # Invoke kernel
        syscall

        # Store result
        movq %rax, -40(%rbp)
    End Assembly
    Return result
End Process

Note: Syscall with 4 arguments
Process called "syscall_4" takes syscall_number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer, arg4 as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        # Load syscall number into RAX
        movq -8(%rbp), %rax

        # Load argument 1 into RDI
        movq -16(%rbp), %rdi

        # Load argument 2 into RSI
        movq -24(%rbp), %rsi

        # Load argument 3 into RDX
        movq -32(%rbp), %rdx

        # Load argument 4 into R10 (not RCX - syscall clobbers RCX!)
        movq -40(%rbp), %r10

        # Invoke kernel
        syscall

        # Store result
        movq %rax, -48(%rbp)
    End Assembly
    Return result
End Process

Note: Syscall with 5 arguments
Process called "syscall_5" takes syscall_number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer, arg4 as Integer, arg5 as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        # Load syscall number into RAX
        movq -8(%rbp), %rax

        # Load argument 1 into RDI
        movq -16(%rbp), %rdi

        # Load argument 2 into RSI
        movq -24(%rbp), %rsi

        # Load argument 3 into RDX
        movq -32(%rbp), %rdx

        # Load argument 4 into R10
        movq -40(%rbp), %r10

        # Load argument 5 into R8
        movq -48(%rbp), %r8

        # Invoke kernel
        syscall

        # Store result
        movq %rax, -56(%rbp)
    End Assembly
    Return result
End Process

Note: Syscall with 6 arguments (maximum for Linux syscalls)
Process called "syscall_6" takes syscall_number as Integer, arg1 as Integer, arg2 as Integer, arg3 as Integer, arg4 as Integer, arg5 as Integer, arg6 as Integer returns Integer:
    Let result be 0
    Inline Assembly:
        # Load syscall number into RAX
        movq -8(%rbp), %rax

        # Load argument 1 into RDI
        movq -16(%rbp), %rdi

        # Load argument 2 into RSI
        movq -24(%rbp), %rsi

        # Load argument 3 into RDX
        movq -32(%rbp), %rdx

        # Load argument 4 into R10
        movq -40(%rbp), %r10

        # Load argument 5 into R8
        movq -48(%rbp), %r8

        # Load argument 6 into R9
        movq -56(%rbp), %r9

        # Invoke kernel
        syscall

        # Store result
        movq %rax, -64(%rbp)
    End Assembly
    Return result
End Process

Note: ============================================================================
Note: HIGH-LEVEL SYSCALL WRAPPERS
Note: ============================================================================
Note: These provide convenient named functions for common syscalls

Note: Read from file descriptor
Note: fd: file descriptor (0 = stdin, 1 = stdout, 2 = stderr)
Note: buffer: pointer to buffer to read into
Note: count: number of bytes to read
Note: Returns: number of bytes read, or negative error code
Process called "syscall_read" takes fd as Integer, buffer as Integer, count as Integer returns Integer:
    Let syscall_num be SYS_READ()
    Return syscall_3(syscall_num, fd, buffer, count)
End Process

Note: Write to file descriptor
Note: fd: file descriptor (0 = stdin, 1 = stdout, 2 = stderr)
Note: buffer: pointer to buffer containing data to write
Note: count: number of bytes to write
Note: Returns: number of bytes written, or negative error code
Process called "syscall_write" takes fd as Integer, buffer as Integer, count as Integer returns Integer:
    Let syscall_num be SYS_WRITE()
    Return syscall_3(syscall_num, fd, buffer, count)
End Process

Note: Open a file
Note: filename: pointer to null-terminated filename string
Note: flags: O_RDONLY (0), O_WRONLY (1), O_RDWR (2), O_CREAT (64), O_TRUNC (512), etc.
Note: mode: file permissions (e.g., 0644 octal = 420 decimal)
Note: Returns: file descriptor number, or negative error code
Process called "syscall_open" takes filename as Integer, flags as Integer, mode as Integer returns Integer:
    Let syscall_num be SYS_OPEN()
    Return syscall_3(syscall_num, filename, flags, mode)
End Process

Note: Close a file descriptor
Note: fd: file descriptor to close
Note: Returns: 0 on success, negative error code on failure
Process called "syscall_close" takes fd as Integer returns Integer:
    Let syscall_num be SYS_CLOSE()
    Return syscall_1(syscall_num, fd)
End Process

Note: Exit process immediately
Note: status: exit code (0 = success, non-zero = failure)
Note: Does not return
Process called "syscall_exit" takes status as Integer returns Integer:
    Let syscall_num be SYS_EXIT()
    Return syscall_1(syscall_num, status)
End Process

Note: Adjust program break (heap boundary)
Note: addr: new break address (or 0 to query current break)
Note: Returns: new break address, or negative error code
Process called "syscall_brk" takes addr as Integer returns Integer:
    Let syscall_num be SYS_BRK()
    Return syscall_1(syscall_num, addr)
End Process

Note: Map memory region
Note: addr: suggested address (or 0 for kernel to choose)
Note: length: number of bytes to map
Note: prot: protection flags (PROT_READ=1, PROT_WRITE=2, PROT_EXEC=4)
Note: flags: MAP_PRIVATE=2, MAP_ANONYMOUS=32, MAP_FIXED=16
Note: fd: file descriptor (or -1 for anonymous mapping)
Note: offset: offset in file (must be page-aligned)
Note: Returns: address of mapped region, or negative error code
Process called "syscall_mmap" takes addr as Integer, length as Integer, prot as Integer, flags as Integer, fd as Integer, offset as Integer returns Integer:
    Let syscall_num be SYS_MMAP()
    Return syscall_6(syscall_num, addr, length, prot, flags, fd, offset)
End Process

Note: Unmap memory region
Note: addr: address of mapped region
Note: length: number of bytes to unmap
Note: Returns: 0 on success, negative error code on failure
Process called "syscall_munmap" takes addr as Integer, length as Integer returns Integer:
    Let syscall_num be SYS_MUNMAP()
    Return syscall_2(syscall_num, addr, length)
End Process

Note: Get file status
Note: fd: file descriptor
Note: statbuf: pointer to stat structure (144 bytes on x86_64)
Note: Returns: 0 on success, negative error code on failure
Process called "syscall_fstat" takes fd as Integer, statbuf as Integer returns Integer:
    Let syscall_num be SYS_FSTAT()
    Return syscall_2(syscall_num, fd, statbuf)
End Process

Note: Reposition file offset
Note: fd: file descriptor
Note: offset: offset in bytes
Note: whence: SEEK_SET (0), SEEK_CUR (1), SEEK_END (2)
Note: Returns: resulting offset, or negative error code
Process called "syscall_lseek" takes fd as Integer, offset as Integer, whence as Integer returns Integer:
    Let syscall_num be SYS_LSEEK()
    Return syscall_3(syscall_num, fd, offset, whence)
End Process

Note: ============================================================================
Note: SYSCALL CONSTANTS
Note: ============================================================================
Note: These are commonly used with the syscall wrappers above

Note: File open flags
Process called "O_RDONLY" returns Integer:
    Return 0
End Process

Process called "O_WRONLY" returns Integer:
    Return 1
End Process

Process called "O_RDWR" returns Integer:
    Return 2
End Process

Process called "O_CREAT" returns Integer:
    Return 64
End Process

Process called "O_TRUNC" returns Integer:
    Return 512
End Process

Process called "O_APPEND" returns Integer:
    Return 1024
End Process

Note: File permissions (octal values converted to decimal)
Process called "MODE_0644" returns Integer:
    Return 420  Note: 0644 octal = rw-r--r--
End Process

Process called "MODE_0755" returns Integer:
    Return 493  Note: 0755 octal = rwxr-xr-x
End Process

Note: Memory protection flags (for mmap)
Process called "PROT_NONE" returns Integer:
    Return 0
End Process

Process called "PROT_READ" returns Integer:
    Return 1
End Process

Process called "PROT_WRITE" returns Integer:
    Return 2
End Process

Process called "PROT_EXEC" returns Integer:
    Return 4
End Process

Note: Memory mapping flags (for mmap)
Process called "MAP_SHARED" returns Integer:
    Return 1
End Process

Process called "MAP_PRIVATE" returns Integer:
    Return 2
End Process

Process called "MAP_FIXED" returns Integer:
    Return 16
End Process

Process called "MAP_ANONYMOUS" returns Integer:
    Return 32
End Process

Note: File seek positions (for lseek)
Process called "SEEK_SET" returns Integer:
    Return 0
End Process

Process called "SEEK_CUR" returns Integer:
    Return 1
End Process

Process called "SEEK_END" returns Integer:
    Return 2
End Process

Note: Standard file descriptors
Process called "STDIN_FILENO" returns Integer:
    Return 0
End Process

Process called "STDOUT_FILENO" returns Integer:
    Return 1
End Process

Process called "STDERR_FILENO" returns Integer:
    Return 2
End Process
