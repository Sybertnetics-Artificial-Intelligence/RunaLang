Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
PLATFORM ABSTRACTION LAYER: Machine Code Generation

This file provides a platform-agnostic interface for machine code generation.
It imports the platform-specific machine code implementation based on the compile target.

Architecture:
- This file defines the common API that all Runa code uses
- Platform-specific implementations are in platform/{platform}/machine_code.runa
- The compiler sets the target platform at compile time
- Imports delegate to the correct platform-specific implementation

Machine code encoding is 100% platform-specific:
- x86_64: Variable-length instructions with ModR/M, SIB, REX prefixes
- ARM64: Fixed 32-bit instructions
- MIPS: Fixed 32-bit MIPS instruction format
- RISC-V: Variable-length compressed/uncompressed instructions
- Each platform has completely different encoding schemes

Example x86_64:
  MOV RAX, RBX → 48 89 D8 (3 bytes: REX.W + opcode + ModR/M)

Example ARM64:
  MOV X0, X1 → AA0103E0 (4 bytes: fixed format)

Usage:
All code should call functions from this file (e.g., encode_instruction, encode_mov).
The platform-specific implementation is automatically selected at compile time.
:End Note

Note: ============================================================================
Note: PLATFORM DETECTION AND IMPORT
Note: ============================================================================
Note: TODO: Compiler should set PLATFORM_TARGET at compile time
Note: For now, defaulting to linux_x86_64

Import "compiler/frontend/primitives/platform/linux_x86_64/machine_code.runa" as PlatformMachineCode

Note: ============================================================================
Note: GENERIC INSTRUCTION ENCODING (Platform-Agnostic Interface)
Note: ============================================================================

Process called "encode_instruction" takes instruction_ptr as Integer returns Integer:
    Note: Encode instruction to machine code bytes
    Note: Returns pointer to encoded bytes, or 0 on error
    Note: Delegates to platform-specific encoder
    Return PlatformMachineCode.encode_instruction(instruction_ptr)
End Process

Process called "get_instruction_length" takes instruction_ptr as Integer returns Integer:
    Note: Get encoded length in bytes for instruction
    Note: Platform-specific (x86_64: variable, ARM64: fixed 4 bytes)
    Return PlatformMachineCode.get_instruction_length(instruction_ptr)
End Process

Note: ============================================================================
Note: COMMON INSTRUCTION ENCODERS (Platform-Agnostic Interface)
Note: ============================================================================

Process called "encode_mov" takes dest_reg as Integer, src_reg as Integer returns Integer:
    Note: Encode MOV/ORR instruction (register to register)
    Note: x86_64: MOV dest, src
    Note: ARM64: ORR Xd, XZR, Xm (MOV is alias)
    Return PlatformMachineCode.encode_mov(dest_reg, src_reg)
End Process

Process called "encode_add" takes dest_reg as Integer, src_reg as Integer, value as Integer returns Integer:
    Note: Encode ADD instruction
    Note: Delegates to platform-specific implementation
    Return PlatformMachineCode.encode_add(dest_reg, src_reg, value)
End Process

Process called "encode_sub" takes dest_reg as Integer, src_reg as Integer, value as Integer returns Integer:
    Note: Encode SUB instruction
    Note: Delegates to platform-specific implementation
    Return PlatformMachineCode.encode_sub(dest_reg, src_reg, value)
End Process

Process called "encode_load" takes dest_reg as Integer, memory_addr as Integer returns Integer:
    Note: Encode LOAD/MOV from memory instruction
    Note: x86_64: MOV dest, [addr]
    Note: ARM64: LDR Xd, [addr]
    Return PlatformMachineCode.encode_load(dest_reg, memory_addr)
End Process

Process called "encode_store" takes src_reg as Integer, memory_addr as Integer returns Integer:
    Note: Encode STORE/MOV to memory instruction
    Note: x86_64: MOV [addr], src
    Note: ARM64: STR Xs, [addr]
    Return PlatformMachineCode.encode_store(src_reg, memory_addr)
End Process

Process called "encode_jump" takes target_addr as Integer returns Integer:
    Note: Encode unconditional jump instruction
    Note: x86_64: JMP target
    Note: ARM64: B target
    Return PlatformMachineCode.encode_jump(target_addr)
End Process

Process called "encode_call" takes target_addr as Integer returns Integer:
    Note: Encode function call instruction
    Note: x86_64: CALL target
    Note: ARM64: BL target
    Return PlatformMachineCode.encode_call(target_addr)
End Process

Process called "encode_return" returns Integer:
    Note: Encode function return instruction
    Note: x86_64: RET
    Note: ARM64: RET
    Return PlatformMachineCode.encode_return()
End Process

Note: ============================================================================
Note: INSTRUCTION OPTIMIZATION (Platform-Agnostic Interface)
Note: ============================================================================

Process called "optimize_instruction_sequence" takes instructions_ptr as Integer, count as Integer returns Integer:
    Note: Optimize sequence of instructions for target platform
    Note: Platform-specific optimizations (e.g., peephole optimization)
    Return PlatformMachineCode.optimize_instruction_sequence(instructions_ptr, count)
End Process

Process called "get_nop_instruction" returns Integer:
    Note: Get NOP (no-operation) instruction for padding
    Note: x86_64: 0x90 (NOP)
    Note: ARM64: 0xD503201F (NOP)
    Return PlatformMachineCode.get_nop_instruction()
End Process
