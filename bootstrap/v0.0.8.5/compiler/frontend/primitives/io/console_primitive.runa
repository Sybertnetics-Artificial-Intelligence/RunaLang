Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file provides raw console I/O primitives for the Runa compiler.

This file performs the following tasks:
- Provide raw syscall wrappers for console I/O operations
- Create IOHandle instances for standard streams (stdin, stdout, stderr)
- Detect terminal capabilities (TTY detection)
- Minimal abstraction over platform syscalls

This file is essential because of the following reasons:
- Compiler internals need console I/O for error reporting and diagnostics
- Provides foundation for higher-level runtime console APIs
- Direct syscall access with minimal overhead
- Platform-independent interface via syscall abstraction layer

This file consists of the following functions/features/operation types:
- Raw write operations (console_write_raw, console_write_stdout_raw, console_write_stderr_raw)
- Raw read operations (console_read_raw, console_read_stdin_raw)
- Handle creation for standard streams (stdout, stderr, stdin)
- Terminal detection (console_is_tty)
- Stream flushing operations

Dependencies:
- Imports platform/assembly/syscall.runa (Layer 0 platform abstraction)
- Imports core/string_core.runa (Layer 0 string operations)
- Imports core/memory_core.runa (Layer 0 memory operations)
- Imports io/io_core.runa (Layer 1 I/O primitives)
:End Note

Import "compiler/frontend/primitives/platform/assembly/syscall.runa" as Syscall
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/core/string_primitive.runa" as StringPrimitive
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/primitives/io/io_core.runa" as IOCore

Note: ============================================================================
Note: Standard File Descriptor Constants
Note: ============================================================================

Note: POSIX standard file descriptors
Constant STDIN_FD as 0
Constant STDOUT_FD as 1
Constant STDERR_FD as 2

Note: ============================================================================
Note: Terminal Control Constants
Note: ============================================================================

Note: ioctl request codes for terminal detection
Note: TCGETS = 0x5401 on Linux x86_64 (get terminal attributes)
Constant TCGETS_IOCTL as 21505

Note: ioctl request codes for terminal size detection
Note: TIOCGWINSZ = 0x5413 on Linux x86_64 (get window size)
Constant TIOCGWINSZ_IOCTL as 21523

Note: ============================================================================
Note: Raw Console Write Operations
Note: ============================================================================

Process called "console_write_raw" takes fd as Integer, data as Integer, length as Integer returns Integer:
    Note: Raw write to file descriptor
    Note: fd: File descriptor (0=stdin, 1=stdout, 2=stderr)
    Note: data: Pointer to data to write
    Note: length: Number of bytes to write
    Note: Returns: Number of bytes written, or negative error code

    Note: Validate inputs
    If fd is less than 0:
        Return proc IO_ERROR_INVALID_HANDLE from IOCore
    End If

    If data is equal to 0:
        Return proc IO_ERROR_INVALID_ARGUMENT from IOCore
    End If

    If length is less than 0:
        Return proc IO_ERROR_INVALID_ARGUMENT from IOCore
    End If

    Note: Handle zero-length write
    If length is equal to 0:
        Return 0
    End If

    Note: Perform syscall write
    Let bytes_written be proc syscall_write from Syscall with fd, data, length

    Note: Check for errors
    If bytes_written is less than 0:
        Note: Syscall returned error code
        Return bytes_written
    End If

    Return bytes_written
End Process

Process called "console_write_stdout_raw" takes data as Integer, length as Integer returns Integer:
    Note: Raw write to stdout
    Note: data: Pointer to data to write
    Note: length: Number of bytes to write
    Note: Returns: Number of bytes written, or negative error code

    Return proc console_write_raw with STDOUT_FD, data, length
End Process

Process called "console_write_stderr_raw" takes data as Integer, length as Integer returns Integer:
    Note: Raw write to stderr
    Note: data: Pointer to data to write
    Note: length: Number of bytes to write
    Note: Returns: Number of bytes written, or negative error code

    Return proc console_write_raw with STDERR_FD, data, length
End Process

Note: ============================================================================
Note: Raw Console Read Operations
Note: ============================================================================

Process called "console_read_raw" takes fd as Integer, buffer as Integer, length as Integer returns Integer:
    Note: Raw read from file descriptor
    Note: fd: File descriptor (0=stdin, 1=stdout, 2=stderr)
    Note: buffer: Pointer to buffer to read into
    Note: length: Maximum number of bytes to read
    Note: Returns: Number of bytes read, 0 for EOF, or negative error code

    Note: Validate inputs
    If fd is less than 0:
        Return proc IO_ERROR_INVALID_HANDLE from IOCore
    End If

    If buffer is equal to 0:
        Return proc IO_ERROR_INVALID_ARGUMENT from IOCore
    End If

    If length is less than 0:
        Return proc IO_ERROR_INVALID_ARGUMENT from IOCore
    End If

    Note: Handle zero-length read
    If length is equal to 0:
        Return 0
    End If

    Note: Perform syscall read
    Let bytes_read be proc syscall_read from Syscall with fd, buffer, length

    Note: Check for errors
    If bytes_read is less than 0:
        Note: Syscall returned error code
        Return bytes_read
    End If

    Note: Check for EOF
    If bytes_read is equal to 0:
        Return 0
    End If

    Return bytes_read
End Process

Process called "console_read_stdin_raw" takes buffer as Integer, length as Integer returns Integer:
    Note: Raw read from stdin
    Note: buffer: Pointer to buffer to read into
    Note: length: Maximum number of bytes to read
    Note: Returns: Number of bytes read, 0 for EOF, or negative error code

    Return proc console_read_raw with STDIN_FD, buffer, length
End Process

Note: ============================================================================
Note: Console Handle Creation
Note: ============================================================================

Process called "console_create_stdout_handle" returns Integer:
    Note: Create IOHandle for stdout
    Note: Returns: Pointer to IOHandle, or 0 on failure

    Note: Get handle type constant
    Let handle_type be proc HANDLE_TYPE_CONSOLE from IOCore

    Note: Get access mode (write-only)
    Let access_mode be proc ACCESS_MODE_WRITE from IOCore

    Note: Create handle (stdout is always blocking by default)
    Let handle be proc io_handle_create from IOCore with STDOUT_FD, handle_type, access_mode, 1

    If handle is equal to 0:
        Return 0
    End If

    Return handle
End Process

Process called "console_create_stderr_handle" returns Integer:
    Note: Create IOHandle for stderr
    Note: Returns: Pointer to IOHandle, or 0 on failure

    Note: Get handle type constant
    Let handle_type be proc HANDLE_TYPE_CONSOLE from IOCore

    Note: Get access mode (write-only)
    Let access_mode be proc ACCESS_MODE_WRITE from IOCore

    Note: Create handle (stderr is always blocking by default)
    Let handle be proc io_handle_create from IOCore with STDERR_FD, handle_type, access_mode, 1

    If handle is equal to 0:
        Return 0
    End If

    Return handle
End Process

Process called "console_create_stdin_handle" returns Integer:
    Note: Create IOHandle for stdin
    Note: Returns: Pointer to IOHandle, or 0 on failure

    Note: Get handle type constant
    Let handle_type be proc HANDLE_TYPE_CONSOLE from IOCore

    Note: Get access mode (read-only)
    Let access_mode be proc ACCESS_MODE_READ from IOCore

    Note: Create handle (stdin is always blocking by default)
    Let handle be proc io_handle_create from IOCore with STDIN_FD, handle_type, access_mode, 1

    If handle is equal to 0:
        Return 0
    End If

    Return handle
End Process

Note: ============================================================================
Note: Terminal Detection
Note: ============================================================================

Process called "console_is_tty" takes fd as Integer returns Integer:
    Note: Check if file descriptor is a terminal (TTY)
    Note: fd: File descriptor to check
    Note: Returns: 1 if TTY, 0 if not TTY or error

    Note: Validate input
    If fd is less than 0:
        Return 0
    End If

    Note: Allocate temporary buffer for ioctl call
    Note: We need space for termios structure (minimum 60 bytes on Linux)
    Note: We'll allocate 64 bytes to be safe
    Let termios_buffer be proc allocate from Layout with 64

    If termios_buffer is equal to 0:
        Return 0
    End If

    Note: Try TCGETS ioctl (get terminal attributes)
    Note: If this succeeds, fd is a TTY
    Note: If this fails, fd is not a TTY
    Let ioctl_result be proc syscall_ioctl from Syscall with fd, TCGETS_IOCTL, termios_buffer

    Note: Free temporary buffer
    proc deallocate from Layout with termios_buffer

    Note: Check ioctl result
    If ioctl_result is less than 0:
        Note: ioctl failed, not a TTY
        Return 0
    End If

    Note: ioctl succeeded, is a TTY
    Return 1
End Process

Process called "console_get_terminal_size" takes fd as Integer, width_out as Integer, height_out as Integer returns Integer:
    Note: Get terminal size (columns and rows)
    Note: fd: File descriptor to check
    Note: width_out: Pointer to store width (columns)
    Note: height_out: Pointer to store height (rows)
    Note: Returns: 1 on success, 0 on failure

    Note: Validate inputs
    If fd is less than 0:
        Return 0
    End If

    If width_out is equal to 0:
        Return 0
    End If

    If height_out is equal to 0:
        Return 0
    End If

    Note: Check if fd is a TTY first
    Let is_tty be proc console_is_tty with fd
    If is_tty is equal to 0:
        Note: Not a TTY, cannot get size
        Return 0
    End If

    Note: Allocate buffer for winsize structure
    Note: struct winsize {
    Note:     unsigned short ws_row;     (2 bytes, offset 0)
    Note:     unsigned short ws_col;     (2 bytes, offset 2)
    Note:     unsigned short ws_xpixel;  (2 bytes, offset 4)
    Note:     unsigned short ws_ypixel;  (2 bytes, offset 6)
    Note: }
    Note: Total: 8 bytes, but we'll allocate 16 for safety
    Let winsize_buffer be proc allocate from Layout with 16

    If winsize_buffer is equal to 0:
        Return 0
    End If

    Note: Initialize buffer to zero
    proc memory_fill from Memory with winsize_buffer, 0, 16

    Note: Try TIOCGWINSZ ioctl (get window size)
    Let ioctl_result be proc syscall_ioctl from Syscall with fd, TIOCGWINSZ_IOCTL, winsize_buffer

    Note: Check ioctl result
    If ioctl_result is less than 0:
        Note: ioctl failed
        proc deallocate from Layout with winsize_buffer
        Return 0
    End If

    Note: Extract rows (unsigned short at offset 0, little-endian)
    Let row_byte0 be proc memory_get_byte from Memory with winsize_buffer, 0
    Let row_byte1 be proc memory_get_byte from Memory with winsize_buffer, 1
    Let rows be row_byte0 plus row_byte1 multiplied by 256

    Note: Extract columns (unsigned short at offset 2, little-endian)
    Let col_byte0 be proc memory_get_byte from Memory with winsize_buffer, 2
    Let col_byte1 be proc memory_get_byte from Memory with winsize_buffer, 3
    Let cols be col_byte0 plus col_byte1 multiplied by 256

    Note: Free buffer
    proc deallocate from Layout with winsize_buffer

    Note: Validate size values
    If rows is less than 1:
        Set rows to 24
    End If

    If cols is less than 1:
        Set cols to 80
    End If

    Note: Store results
    proc memory_set_int64 from Memory with width_out, 0, cols
    proc memory_set_int64 from Memory with height_out, 0, rows

    Return 1
End Process

Note: ============================================================================
Note: Console Flushing Operations
Note: ============================================================================

Process called "console_flush_stdout" returns Integer:
    Note: Flush stdout buffer
    Note: Returns: 1 on success, 0 on failure

    Note: Get fsync syscall number
    Let fsync_syscall be proc SYS_FSYNC from Syscall

    Note: Call fsync on stdout
    Let result be proc syscall_1 from Syscall with fsync_syscall, STDOUT_FD

    If result is less than 0:
        Return 0
    End If

    Return 1
End Process

Process called "console_flush_stderr" returns Integer:
    Note: Flush stderr buffer
    Note: Returns: 1 on success, 0 on failure

    Note: Get fsync syscall number
    Let fsync_syscall be proc SYS_FSYNC from Syscall

    Note: Call fsync on stderr
    Let result be proc syscall_1 from Syscall with fsync_syscall, STDERR_FD

    If result is less than 0:
        Return 0
    End If

    Return 1
End Process

Note: ============================================================================
Note: High-Level Convenience Wrappers
Note: ============================================================================

Process called "console_write_string_stdout" takes message as Integer returns Integer:
    Note: Write null-terminated string to stdout
    Note: message: Pointer to null-terminated string
    Note: Returns: Number of bytes written, or negative error code

    If message is equal to 0:
        Return 0
    End If

    Note: Get string length
    Let length be proc string_length from StringCore with message

    If length is equal to 0:
        Return 0
    End If

    Note: Write to stdout
    Return proc console_write_stdout_raw with message, length
End Process

Process called "console_write_string_stderr" takes message as Integer returns Integer:
    Note: Write null-terminated string to stderr
    Note: message: Pointer to null-terminated string
    Note: Returns: Number of bytes written, or negative error code

    If message is equal to 0:
        Return 0
    End If

    Note: Get string length
    Let length be proc string_length from StringCore with message

    If length is equal to 0:
        Return 0
    End If

    Note: Write to stderr
    Return proc console_write_stderr_raw with message, length
End Process

Process called "console_writeln_stdout" takes message as Integer returns Integer:
    Note: Write null-terminated string + newline to stdout
    Note: message: Pointer to null-terminated string
    Note: Returns: Number of bytes written (including newline), or negative error code

    Note: Handle NULL message
    If message is equal to 0:
        Note: Just write newline
        Let newline be 10
        Let newline_ptr be proc allocate from Layout with 1
        If newline_ptr is equal to 0:
            Return proc IO_ERROR_OUT_OF_MEMORY from IOCore
        End If

        proc memory_set_byte from Memory with newline_ptr, 0, newline
        Let result be proc console_write_stdout_raw with newline_ptr, 1
        proc deallocate from Layout with newline_ptr
        Return result
    End If

    Note: Get string length
    Let length be proc string_length from StringCore with message

    Note: Write message first
    Let bytes_written be proc console_write_stdout_raw with message, length

    If bytes_written is less than 0:
        Return bytes_written
    End If

    Note: Write newline
    Let newline be 10
    Let newline_ptr be proc allocate from Layout with 1
    If newline_ptr is equal to 0:
        Return bytes_written
    End If

    proc memory_set_byte from Memory with newline_ptr, 0, newline
    Let newline_written be proc console_write_stdout_raw with newline_ptr, 1
    proc deallocate from Layout with newline_ptr

    If newline_written is less than 0:
        Return bytes_written
    End If

    Return bytes_written plus newline_written
End Process

Process called "console_writeln_stderr" takes message as Integer returns Integer:
    Note: Write null-terminated string + newline to stderr
    Note: message: Pointer to null-terminated string
    Note: Returns: Number of bytes written (including newline), or negative error code

    Note: Handle NULL message
    If message is equal to 0:
        Note: Just write newline
        Let newline be 10
        Let newline_ptr be proc allocate from Layout with 1
        If newline_ptr is equal to 0:
            Return proc IO_ERROR_OUT_OF_MEMORY from IOCore
        End If

        proc memory_set_byte from Memory with newline_ptr, 0, newline
        Let result be proc console_write_stderr_raw with newline_ptr, 1
        proc deallocate from Layout with newline_ptr
        Return result
    End If

    Note: Get string length
    Let length be proc string_length from StringCore with message

    Note: Write message first
    Let bytes_written be proc console_write_stderr_raw with message, length

    If bytes_written is less than 0:
        Return bytes_written
    End If

    Note: Write newline
    Let newline be 10
    Let newline_ptr be proc allocate from Layout with 1
    If newline_ptr is equal to 0:
        Return bytes_written
    End If

    proc memory_set_byte from Memory with newline_ptr, 0, newline
    Let newline_written be proc console_write_stderr_raw with newline_ptr, 1
    proc deallocate from Layout with newline_ptr

    If newline_written is less than 0:
        Return bytes_written
    End If

    Return bytes_written plus newline_written
End Process

Note: ============================================================================
Note: Read Line Operations
Note: ============================================================================

Process called "console_read_line_stdin" takes buffer as Integer, max_length as Integer returns Integer:
    Note: Read a line from stdin (up to newline or max_length)
    Note: buffer: Pointer to buffer to store line
    Note: max_length: Maximum number of bytes to read (including null terminator)
    Note: Returns: Number of bytes read (excluding null terminator), or negative error code

    Note: Validate inputs
    If buffer is equal to 0:
        Return proc IO_ERROR_INVALID_ARGUMENT from IOCore
    End If

    If max_length is less than 2:
        Note: Need at least 2 bytes (1 char + null terminator)
        Return proc IO_ERROR_INVALID_ARGUMENT from IOCore
    End If

    Note: Reserve space for null terminator
    Let available_space be max_length minus 1

    Note: Read character by character until newline or EOF
    Let bytes_read be 0
    Let found_newline be 0

    While bytes_read is less than available_space:
        Note: Read single byte
        Let byte_ptr be buffer plus bytes_read
        Let read_result be proc console_read_raw with STDIN_FD, byte_ptr, 1

        Note: Check for errors
        If read_result is less than 0:
            Note: Error occurred
            Return read_result
        End If

        Note: Check for EOF
        If read_result is equal to 0:
            Note: EOF reached
            Set found_newline to 1
            Note: Break loop
            Set bytes_read to available_space
        Otherwise:
            Note: Check if newline
            Let byte_value be proc memory_get_byte from Memory with buffer, bytes_read

            If byte_value is equal to 10:
                Note: Newline found
                Set found_newline to 1
                Note: Don't include newline in result
                Note: Break loop
                Set bytes_read to available_space
            Otherwise:
                Note: Regular character
                Set bytes_read to bytes_read plus 1
            End If
        End If
    End While

    Note: Add null terminator
    proc memory_set_byte from Memory with buffer, bytes_read, 0

    Return bytes_read
End Process

Note: ============================================================================
Note: Console State Queries
Note: ============================================================================

Process called "console_stdin_is_tty" returns Integer:
    Note: Check if stdin is a terminal
    Note: Returns: 1 if TTY, 0 if not

    Return proc console_is_tty with STDIN_FD
End Process

Process called "console_stdout_is_tty" returns Integer:
    Note: Check if stdout is a terminal
    Note: Returns: 1 if TTY, 0 if not

    Return proc console_is_tty with STDOUT_FD
End Process

Process called "console_stderr_is_tty" returns Integer:
    Note: Check if stderr is a terminal
    Note: Returns: 1 if TTY, 0 if not

    Return proc console_is_tty with STDERR_FD
End Process

Note: ============================================================================
Note: Integer/Newline Convenience Functions (For Compiler Internals)
Note: ============================================================================

Process called "console_write_integer" takes value as Integer returns Integer:
    Note: Write integer value to stdout
    Note: value: Integer value to write
    Note: Returns: Number of bytes written, or negative error code

    Note: Convert integer to string
    Let value_str be proc integer_to_string from StringPrimitive with value
    If value_str is equal to 0:
        Return proc IO_ERROR_OUT_OF_MEMORY from IOCore
    End If

    Note: Write string
    Let result be proc console_write_string_stdout with value_str

    Note: Free temporary string
    proc deallocate from Layout with value_str

    Return result
End Process

Process called "console_write_newline" returns Integer:
    Note: Write newline to stdout
    Note: Returns: Number of bytes written, or negative error code

    Note: Allocate newline character
    Let newline_ptr be proc allocate from Layout with 1
    If newline_ptr is equal to 0:
        Return proc IO_ERROR_OUT_OF_MEMORY from IOCore
    End If

    Note: Set newline byte
    proc memory_set_byte from Memory with newline_ptr, 0, 10

    Note: Write newline
    Let result be proc console_write_stdout_raw with newline_ptr, 1

    Note: Free newline buffer
    proc deallocate from Layout with newline_ptr

    Return result
End Process
