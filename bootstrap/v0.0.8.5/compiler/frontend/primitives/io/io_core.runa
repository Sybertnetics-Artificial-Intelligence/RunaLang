Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
I/O CORE PRIMITIVES - Foundation I/O Types and Operations

This file provides the foundational I/O abstractions used throughout the Runa I/O system.
It defines core types (handles, buffers, errors, results) and operations for managing them.

This is a PRIMITIVE layer - low-level, minimal abstraction, used by both compiler internals
and the runtime I/O system.

Architecture:
- IOHandle: Unified handle abstraction (console, file, socket, pipe)
- IOBuffer: Buffer management for efficient I/O
- IOError: Comprehensive error codes and messages
- IOResult: Result type combining success/failure with error information

Dependencies:
- memory_core.runa: Memory operations
- memory_utils.runa: Allocation/deallocation
- string_core.runa: String operations
:End Note

Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/internal/memory_utils.runa" as MemoryUtils
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore

Note: ============================================================================
Note: I/O ERROR CODES AND CONSTANTS
Note: ============================================================================

Note: Error codes (0 = success, negative = errors)
Constant IO_SUCCESS as 0
Constant IO_ERROR_INVALID_HANDLE as -1
Constant IO_ERROR_PERMISSION_DENIED as -2
Constant IO_ERROR_NOT_FOUND as -3
Constant IO_ERROR_EOF as -4
Constant IO_ERROR_WOULD_BLOCK as -5
Constant IO_ERROR_BROKEN_PIPE as -6
Constant IO_ERROR_INVALID_ARGUMENT as -7
Constant IO_ERROR_OUT_OF_MEMORY as -8
Constant IO_ERROR_BUFFER_FULL as -9
Constant IO_ERROR_BUFFER_EMPTY as -10
Constant IO_ERROR_NOT_OPEN as -11
Constant IO_ERROR_ALREADY_OPEN as -12
Constant IO_ERROR_TIMEOUT as -13
Constant IO_ERROR_INTERRUPTED as -14
Constant IO_ERROR_UNKNOWN as -99

Note: Handle types
Constant IO_HANDLE_TYPE_NONE as 0
Constant IO_HANDLE_TYPE_CONSOLE as 1
Constant IO_HANDLE_TYPE_FILE as 2
Constant IO_HANDLE_TYPE_SOCKET as 3
Constant IO_HANDLE_TYPE_PIPE as 4

Note: Access modes
Constant IO_ACCESS_NONE as 0
Constant IO_ACCESS_READ as 1
Constant IO_ACCESS_WRITE as 2
Constant IO_ACCESS_READ_WRITE as 3

Note: Buffer modes
Constant IO_BUFFER_MODE_UNBUFFERED as 0
Constant IO_BUFFER_MODE_LINE_BUFFERED as 1
Constant IO_BUFFER_MODE_FULLY_BUFFERED as 2

Note: Default buffer sizes
Constant IO_DEFAULT_BUFFER_SIZE as 8192
Constant IO_LINE_BUFFER_SIZE as 1024

Note: ============================================================================
Note: I/O CORE TYPES
Note: ============================================================================

Note: IOResult structure (32 bytes)
Note:   offset 0:  success (1=success, 0=failure)
Note:   offset 8:  error_code (0=no error, negative=error code)
Note:   offset 16: bytes_processed (number of bytes read/written)
Note:   offset 24: error_message (pointer to error string, or 0)
Type called "IOResult":
    success as Integer
    error_code as Integer
    bytes_processed as Integer
    error_message as Integer
End Type

Note: IOHandle structure (56 bytes)
Note:   offset 0:  descriptor (OS file descriptor / handle)
Note:   offset 8:  handle_type (Console=1, File=2, Socket=3, Pipe=4)
Note:   offset 16: access_mode (Read=1, Write=2, ReadWrite=3)
Note:   offset 24: is_blocking (1=blocking, 0=non-blocking)
Note:   offset 32: is_open (1=open, 0=closed)
Note:   offset 40: buffer_handle (pointer to IOBuffer, or 0 if unbuffered)
Note:   offset 48: platform_data (platform-specific metadata pointer)
Type called "IOHandle":
    descriptor as Integer
    handle_type as Integer
    access_mode as Integer
    is_blocking as Integer
    is_open as Integer
    buffer_handle as Integer
    platform_data as Integer
End Type

Note: IOBuffer structure (48 bytes)
Note:   offset 0:  data (pointer to buffer memory)
Note:   offset 8:  capacity (total buffer size in bytes)
Note:   offset 16: read_position (current read position)
Note:   offset 24: write_position (current write position)
Note:   offset 32: buffer_mode (Unbuffered=0, LineBuffered=1, FullyBuffered=2)
Note:   offset 40: dirty (1=needs flush, 0=clean)
Type called "IOBuffer":
    data as Integer
    capacity as Integer
    read_position as Integer
    write_position as Integer
    buffer_mode as Integer
    dirty as Integer
End Type

Note: ============================================================================
Note: IOResult Operations
Note: ============================================================================

Process called "io_result_success" takes bytes_processed as Integer returns Integer:
    Note: Create a successful IOResult
    Note: bytes_processed: Number of bytes successfully processed
    Note: Returns: Pointer to IOResult structure

    Note: Allocate IOResult structure (32 bytes)
    Let result_ptr be proc allocate from MemoryUtils with 32
    If result_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize fields
    Let dummy1 be proc memory_set_integer from MemoryCore with result_ptr, 0, 1
    Let dummy2 be proc memory_set_integer from MemoryCore with result_ptr, 8, IO_SUCCESS
    Let dummy3 be proc memory_set_integer from MemoryCore with result_ptr, 16, bytes_processed
    Let dummy4 be proc memory_set_integer from MemoryCore with result_ptr, 24, 0

    Return result_ptr
End Process

Process called "io_result_error" takes error_code as Integer, error_message as Integer returns Integer:
    Note: Create an error IOResult
    Note: error_code: Negative error code (IO_ERROR_*)
    Note: error_message: Pointer to error string (or 0 for default)
    Note: Returns: Pointer to IOResult structure

    Note: Allocate IOResult structure (32 bytes)
    Let result_ptr be proc allocate from MemoryUtils with 32
    If result_ptr is equal to 0:
        Return 0
    End If

    Note: If no error message provided, use default based on error code
    Let msg be error_message
    If msg is equal to 0:
        Set msg to proc io_error_get_message with error_code
    End If

    Note: Initialize fields
    Let dummy1 be proc memory_set_integer from MemoryCore with result_ptr, 0, 0
    Let dummy2 be proc memory_set_integer from MemoryCore with result_ptr, 8, error_code
    Let dummy3 be proc memory_set_integer from MemoryCore with result_ptr, 16, 0
    Let dummy4 be proc memory_set_integer from MemoryCore with result_ptr, 24, msg

    Return result_ptr
End Process

Process called "io_result_is_ok" takes result as Integer returns Integer:
    Note: Check if IOResult indicates success
    Note: result: Pointer to IOResult structure
    Note: Returns: 1 if success, 0 if failure

    If result is equal to 0:
        Return 0
    End If

    Let success be proc memory_get_integer from MemoryCore with result, 0
    Return success
End Process

Process called "io_result_get_error_code" takes result as Integer returns Integer:
    Note: Get error code from IOResult
    Note: result: Pointer to IOResult structure
    Note: Returns: Error code (0 = success, negative = error)

    If result is equal to 0:
        Return IO_ERROR_INVALID_ARGUMENT
    End If

    Let error_code be proc memory_get_integer from MemoryCore with result, 8
    Return error_code
End Process

Process called "io_result_get_bytes_processed" takes result as Integer returns Integer:
    Note: Get bytes processed from IOResult
    Note: result: Pointer to IOResult structure
    Note: Returns: Number of bytes processed

    If result is equal to 0:
        Return 0
    End If

    Let bytes be proc memory_get_integer from MemoryCore with result, 16
    Return bytes
End Process

Process called "io_result_get_error_message" takes result as Integer returns Integer:
    Note: Get error message from IOResult
    Note: result: Pointer to IOResult structure
    Note: Returns: Pointer to error string (or 0 if no message)

    If result is equal to 0:
        Return 0
    End If

    Let msg be proc memory_get_integer from MemoryCore with result, 24
    Return msg
End Process

Process called "io_result_destroy" takes result as Integer returns Integer:
    Note: Destroy IOResult and free memory
    Note: result: Pointer to IOResult structure
    Note: Returns: 1 if successful, 0 if failed

    If result is equal to 0:
        Return 0
    End If

    Let dealloc_result be proc deallocate from MemoryUtils with result
    Return 1
End Process

Note: ============================================================================
Note: IOHandle Operations
Note: ============================================================================

Process called "io_handle_create" takes descriptor as Integer, handle_type as Integer, access_mode as Integer returns Integer:
    Note: Create a new IOHandle
    Note: descriptor: OS file descriptor / handle
    Note: handle_type: IO_HANDLE_TYPE_*
    Note: access_mode: IO_ACCESS_*
    Note: Returns: Pointer to IOHandle structure (or 0 on failure)

    Note: Validate handle type
    If handle_type is less than IO_HANDLE_TYPE_NONE:
        Return 0
    End If
    If handle_type is greater than IO_HANDLE_TYPE_PIPE:
        Return 0
    End If

    Note: Validate access mode
    If access_mode is less than IO_ACCESS_NONE:
        Return 0
    End If
    If access_mode is greater than IO_ACCESS_READ_WRITE:
        Return 0
    End If

    Note: Allocate IOHandle structure (56 bytes)
    Let handle_ptr be proc allocate from MemoryUtils with 56
    If handle_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize fields
    Let dummy1 be proc memory_set_integer from MemoryCore with handle_ptr, 0, descriptor
    Let dummy2 be proc memory_set_integer from MemoryCore with handle_ptr, 8, handle_type
    Let dummy3 be proc memory_set_integer from MemoryCore with handle_ptr, 16, access_mode
    Let dummy4 be proc memory_set_integer from MemoryCore with handle_ptr, 24, 1
    Let dummy5 be proc memory_set_integer from MemoryCore with handle_ptr, 32, 1
    Let dummy6 be proc memory_set_integer from MemoryCore with handle_ptr, 40, 0
    Let dummy7 be proc memory_set_integer from MemoryCore with handle_ptr, 48, 0

    Return handle_ptr
End Process

Process called "io_handle_is_valid" takes handle as Integer returns Integer:
    Note: Check if handle is valid (non-null and descriptor >= 0)
    Note: handle: Pointer to IOHandle structure
    Note: Returns: 1 if valid, 0 if invalid

    If handle is equal to 0:
        Return 0
    End If

    Let descriptor be proc memory_get_integer from MemoryCore with handle, 0
    If descriptor is less than 0:
        Return 0
    End If

    Return 1
End Process

Process called "io_handle_is_open" takes handle as Integer returns Integer:
    Note: Check if handle is open
    Note: handle: Pointer to IOHandle structure
    Note: Returns: 1 if open, 0 if closed

    If handle is equal to 0:
        Return 0
    End If

    Let is_open be proc memory_get_integer from MemoryCore with handle, 32
    Return is_open
End Process

Process called "io_handle_get_descriptor" takes handle as Integer returns Integer:
    Note: Get OS file descriptor from handle
    Note: handle: Pointer to IOHandle structure
    Note: Returns: File descriptor (or -1 if invalid)

    If handle is equal to 0:
        Return -1
    End If

    Let descriptor be proc memory_get_integer from MemoryCore with handle, 0
    Return descriptor
End Process

Process called "io_handle_get_type" takes handle as Integer returns Integer:
    Note: Get handle type
    Note: handle: Pointer to IOHandle structure
    Note: Returns: IO_HANDLE_TYPE_*

    If handle is equal to 0:
        Return IO_HANDLE_TYPE_NONE
    End If

    Let handle_type be proc memory_get_integer from MemoryCore with handle, 8
    Return handle_type
End Process

Process called "io_handle_get_access_mode" takes handle as Integer returns Integer:
    Note: Get access mode
    Note: handle: Pointer to IOHandle structure
    Note: Returns: IO_ACCESS_*

    If handle is equal to 0:
        Return IO_ACCESS_NONE
    End If

    Let access_mode be proc memory_get_integer from MemoryCore with handle, 16
    Return access_mode
End Process

Process called "io_handle_set_blocking" takes handle as Integer, blocking as Integer returns Integer:
    Note: Set blocking mode
    Note: handle: Pointer to IOHandle structure
    Note: blocking: 1=blocking, 0=non-blocking
    Note: Returns: 1 if successful, 0 if failed

    If handle is equal to 0:
        Return 0
    End If

    Let normalized_blocking be 0
    If blocking is not equal to 0:
        Set normalized_blocking to 1
    End If

    Let dummy be proc memory_set_integer from MemoryCore with handle, 24, normalized_blocking
    Return 1
End Process

Process called "io_handle_is_blocking" takes handle as Integer returns Integer:
    Note: Check if handle is blocking
    Note: handle: Pointer to IOHandle structure
    Note: Returns: 1 if blocking, 0 if non-blocking

    If handle is equal to 0:
        Return 1
    End If

    Let is_blocking be proc memory_get_integer from MemoryCore with handle, 24
    Return is_blocking
End Process

Process called "io_handle_attach_buffer" takes handle as Integer, buffer as Integer returns Integer:
    Note: Attach buffer to handle
    Note: handle: Pointer to IOHandle structure
    Note: buffer: Pointer to IOBuffer structure
    Note: Returns: 1 if successful, 0 if failed

    If handle is equal to 0:
        Return 0
    End If

    If buffer is equal to 0:
        Return 0
    End If

    Let dummy be proc memory_set_integer from MemoryCore with handle, 40, buffer
    Return 1
End Process

Process called "io_handle_get_buffer" takes handle as Integer returns Integer:
    Note: Get attached buffer
    Note: handle: Pointer to IOHandle structure
    Note: Returns: Pointer to IOBuffer (or 0 if unbuffered)

    If handle is equal to 0:
        Return 0
    End If

    Let buffer be proc memory_get_integer from MemoryCore with handle, 40
    Return buffer
End Process

Process called "io_handle_mark_closed" takes handle as Integer returns Integer:
    Note: Mark handle as closed (does not close OS descriptor)
    Note: handle: Pointer to IOHandle structure
    Note: Returns: 1 if successful, 0 if failed

    If handle is equal to 0:
        Return 0
    End If

    Let dummy be proc memory_set_integer from MemoryCore with handle, 32, 0
    Return 1
End Process

Process called "io_handle_destroy" takes handle as Integer returns Integer:
    Note: Destroy handle and free memory (does not close OS descriptor)
    Note: handle: Pointer to IOHandle structure
    Note: Returns: 1 if successful, 0 if failed

    If handle is equal to 0:
        Return 0
    End If

    Let dealloc_result be proc deallocate from MemoryUtils with handle
    Return 1
End Process

Note: ============================================================================
Note: IOBuffer Operations
Note: ============================================================================

Process called "io_buffer_create" takes capacity as Integer, buffer_mode as Integer returns Integer:
    Note: Create a new IOBuffer
    Note: capacity: Buffer size in bytes (0 for default)
    Note: buffer_mode: IO_BUFFER_MODE_*
    Note: Returns: Pointer to IOBuffer structure (or 0 on failure)

    Note: Validate buffer mode
    If buffer_mode is less than IO_BUFFER_MODE_UNBUFFERED:
        Return 0
    End If
    If buffer_mode is greater than IO_BUFFER_MODE_FULLY_BUFFERED:
        Return 0
    End If

    Note: Use default capacity if not specified
    Let actual_capacity be capacity
    If actual_capacity is less than or equal to 0:
        If buffer_mode is equal to IO_BUFFER_MODE_LINE_BUFFERED:
            Set actual_capacity to IO_LINE_BUFFER_SIZE
        Otherwise:
            Set actual_capacity to IO_DEFAULT_BUFFER_SIZE
        End If
    End If

    Note: Allocate IOBuffer structure (48 bytes)
    Let buffer_ptr be proc allocate from MemoryUtils with 48
    If buffer_ptr is equal to 0:
        Return 0
    End If

    Note: Allocate buffer data
    Let data_ptr be proc allocate from MemoryUtils with actual_capacity
    If data_ptr is equal to 0:
        Let cleanup be proc deallocate from MemoryUtils with buffer_ptr
        Return 0
    End If

    Note: Initialize fields
    Let dummy1 be proc memory_set_integer from MemoryCore with buffer_ptr, 0, data_ptr
    Let dummy2 be proc memory_set_integer from MemoryCore with buffer_ptr, 8, actual_capacity
    Let dummy3 be proc memory_set_integer from MemoryCore with buffer_ptr, 16, 0
    Let dummy4 be proc memory_set_integer from MemoryCore with buffer_ptr, 24, 0
    Let dummy5 be proc memory_set_integer from MemoryCore with buffer_ptr, 32, buffer_mode
    Let dummy6 be proc memory_set_integer from MemoryCore with buffer_ptr, 40, 0

    Return buffer_ptr
End Process

Process called "io_buffer_available_read" takes buffer as Integer returns Integer:
    Note: Get number of bytes available for reading
    Note: buffer: Pointer to IOBuffer structure
    Note: Returns: Number of bytes available

    If buffer is equal to 0:
        Return 0
    End If

    Let read_pos be proc memory_get_integer from MemoryCore with buffer, 16
    Let write_pos be proc memory_get_integer from MemoryCore with buffer, 24
    Let available be write_pos minus read_pos
    Return available
End Process

Process called "io_buffer_available_write" takes buffer as Integer returns Integer:
    Note: Get number of bytes available for writing
    Note: buffer: Pointer to IOBuffer structure
    Note: Returns: Number of bytes available

    If buffer is equal to 0:
        Return 0
    End If

    Let capacity be proc memory_get_integer from MemoryCore with buffer, 8
    Let write_pos be proc memory_get_integer from MemoryCore with buffer, 24
    Let available be capacity minus write_pos
    Return available
End Process

Process called "io_buffer_is_empty" takes buffer as Integer returns Integer:
    Note: Check if buffer is empty (no data to read)
    Note: buffer: Pointer to IOBuffer structure
    Note: Returns: 1 if empty, 0 if has data

    If buffer is equal to 0:
        Return 1
    End If

    Let available be proc io_buffer_available_read with buffer
    If available is equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "io_buffer_is_full" takes buffer as Integer returns Integer:
    Note: Check if buffer is full (no space to write)
    Note: buffer: Pointer to IOBuffer structure
    Note: Returns: 1 if full, 0 if has space

    If buffer is equal to 0:
        Return 1
    End If

    Let available be proc io_buffer_available_write with buffer
    If available is equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "io_buffer_write" takes buffer as Integer, data as Integer, length as Integer returns Integer:
    Note: Write data to buffer
    Note: buffer: Pointer to IOBuffer structure
    Note: data: Pointer to data to write
    Note: length: Number of bytes to write
    Note: Returns: Number of bytes actually written (may be less if buffer full)

    If buffer is equal to 0:
        Return 0
    End If

    If data is equal to 0:
        Return 0
    End If

    If length is less than or equal to 0:
        Return 0
    End If

    Note: Check available space
    Let available_space be proc io_buffer_available_write with buffer
    If available_space is equal to 0:
        Return 0
    End If

    Note: Write only what fits
    Let bytes_to_write be length
    If bytes_to_write is greater than available_space:
        Set bytes_to_write to available_space
    End If

    Note: Get buffer fields
    Let buffer_data be proc memory_get_integer from MemoryCore with buffer, 0
    Let write_pos be proc memory_get_integer from MemoryCore with buffer, 24

    Note: Copy data to buffer
    Let dest_addr be buffer_data plus write_pos
    Let dummy1 be proc memory_copy from MemoryCore with dest_addr, data, bytes_to_write

    Note: Update write position
    Let new_write_pos be write_pos plus bytes_to_write
    Let dummy2 be proc memory_set_integer from MemoryCore with buffer, 24, new_write_pos

    Note: Mark buffer as dirty
    Let dummy3 be proc memory_set_integer from MemoryCore with buffer, 40, 1

    Return bytes_to_write
End Process

Process called "io_buffer_read" takes buffer as Integer, dest as Integer, length as Integer returns Integer:
    Note: Read data from buffer
    Note: buffer: Pointer to IOBuffer structure
    Note: dest: Pointer to destination buffer
    Note: length: Maximum number of bytes to read
    Note: Returns: Number of bytes actually read (may be less if buffer empty)

    If buffer is equal to 0:
        Return 0
    End If

    If dest is equal to 0:
        Return 0
    End If

    If length is less than or equal to 0:
        Return 0
    End If

    Note: Check available data
    Let available_data be proc io_buffer_available_read with buffer
    If available_data is equal to 0:
        Return 0
    End If

    Note: Read only what's available
    Let bytes_to_read be length
    If bytes_to_read is greater than available_data:
        Set bytes_to_read to available_data
    End If

    Note: Get buffer fields
    Let buffer_data be proc memory_get_integer from MemoryCore with buffer, 0
    Let read_pos be proc memory_get_integer from MemoryCore with buffer, 16

    Note: Copy data from buffer
    Let src_addr be buffer_data plus read_pos
    Let dummy1 be proc memory_copy from MemoryCore with dest, src_addr, bytes_to_read

    Note: Update read position
    Let new_read_pos be read_pos plus bytes_to_read
    Let dummy2 be proc memory_set_integer from MemoryCore with buffer, 16, new_read_pos

    Return bytes_to_read
End Process

Process called "io_buffer_clear" takes buffer as Integer returns Integer:
    Note: Clear buffer (reset read/write positions)
    Note: buffer: Pointer to IOBuffer structure
    Note: Returns: 1 if successful, 0 if failed

    If buffer is equal to 0:
        Return 0
    End If

    Note: Reset positions
    Let dummy1 be proc memory_set_integer from MemoryCore with buffer, 16, 0
    Let dummy2 be proc memory_set_integer from MemoryCore with buffer, 24, 0

    Note: Mark buffer as clean
    Let dummy3 be proc memory_set_integer from MemoryCore with buffer, 40, 0

    Return 1
End Process

Process called "io_buffer_is_dirty" takes buffer as Integer returns Integer:
    Note: Check if buffer needs flushing
    Note: buffer: Pointer to IOBuffer structure
    Note: Returns: 1 if dirty, 0 if clean

    If buffer is equal to 0:
        Return 0
    End If

    Let dirty be proc memory_get_integer from MemoryCore with buffer, 40
    Return dirty
End Process

Process called "io_buffer_mark_clean" takes buffer as Integer returns Integer:
    Note: Mark buffer as clean (after successful flush)
    Note: buffer: Pointer to IOBuffer structure
    Note: Returns: 1 if successful, 0 if failed

    If buffer is equal to 0:
        Return 0
    End If

    Let dummy be proc memory_set_integer from MemoryCore with buffer, 40, 0
    Return 1
End Process

Process called "io_buffer_destroy" takes buffer as Integer returns Integer:
    Note: Destroy buffer and free memory
    Note: buffer: Pointer to IOBuffer structure
    Note: Returns: 1 if successful, 0 if failed

    If buffer is equal to 0:
        Return 0
    End If

    Note: Free buffer data
    Let buffer_data be proc memory_get_integer from MemoryCore with buffer, 0
    If buffer_data is not equal to 0:
        Let dealloc1 be proc deallocate from MemoryUtils with buffer_data
    End If

    Note: Free buffer structure
    Let dealloc2 be proc deallocate from MemoryUtils with buffer
    Return 1
End Process

Note: ============================================================================
Note: Error Message Handling
Note: ============================================================================

Process called "io_error_get_message" takes error_code as Integer returns Integer:
    Note: Get default error message for error code
    Note: error_code: IO_ERROR_* constant
    Note: Returns: Pointer to static error string

    If error_code is equal to IO_SUCCESS:
        Let msg be "Success"
        Return msg
    Otherwise If error_code is equal to IO_ERROR_INVALID_HANDLE:
        Let msg be "Invalid handle"
        Return msg
    Otherwise If error_code is equal to IO_ERROR_PERMISSION_DENIED:
        Let msg be "Permission denied"
        Return msg
    Otherwise If error_code is equal to IO_ERROR_NOT_FOUND:
        Let msg be "Not found"
        Return msg
    Otherwise If error_code is equal to IO_ERROR_EOF:
        Let msg be "End of file"
        Return msg
    Otherwise If error_code is equal to IO_ERROR_WOULD_BLOCK:
        Let msg be "Operation would block"
        Return msg
    Otherwise If error_code is equal to IO_ERROR_BROKEN_PIPE:
        Let msg be "Broken pipe"
        Return msg
    Otherwise If error_code is equal to IO_ERROR_INVALID_ARGUMENT:
        Let msg be "Invalid argument"
        Return msg
    Otherwise If error_code is equal to IO_ERROR_OUT_OF_MEMORY:
        Let msg be "Out of memory"
        Return msg
    Otherwise If error_code is equal to IO_ERROR_BUFFER_FULL:
        Let msg be "Buffer full"
        Return msg
    Otherwise If error_code is equal to IO_ERROR_BUFFER_EMPTY:
        Let msg be "Buffer empty"
        Return msg
    Otherwise If error_code is equal to IO_ERROR_NOT_OPEN:
        Let msg be "Not open"
        Return msg
    Otherwise If error_code is equal to IO_ERROR_ALREADY_OPEN:
        Let msg be "Already open"
        Return msg
    Otherwise If error_code is equal to IO_ERROR_TIMEOUT:
        Let msg be "Timeout"
        Return msg
    Otherwise If error_code is equal to IO_ERROR_INTERRUPTED:
        Let msg be "Interrupted"
        Return msg
    End If

    Let msg be "Unknown error"
    Return msg
End Process

Note: ============================================================================
Note: I/O Core Primitives Complete
Note: ============================================================================
