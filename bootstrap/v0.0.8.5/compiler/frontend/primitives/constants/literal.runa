Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles literal constant validation and analysis for the compiler.

This file performs the following tasks:
- Validate literal constants and their representations
- Infer types from literal values
- Detect literal overflow and underflow
- Analyze literal encoding and storage requirements

This file is essential because of the following reasons:
- Literals must have valid syntax and values
- Type inference from literals must be deterministic
- Overflow detection prevents runtime errors
- Literal encoding affects code generation

Dependencies:
- NONE (pure analysis and validation)
:End Note

Note: ============================================================================
Note: Literal Type Classification
Note: ============================================================================

Process called "get_literal_type" takes is_integer as Integer, is_float as Integer, is_boolean as Integer, is_string as Integer returns Integer:
    Note: Determine type of literal
    Note: Returns type ID: 1=integer, 30=float, 5=boolean, 0=string (implementation-defined)

    If is_integer is equal to 1:
        Return 1
    End If

    If is_float is equal to 1:
        Return 30
    End If

    If is_boolean is equal to 1:
        Return 5
    End If

    If is_string is equal to 1:
        Return 0
    End If

    Return 0
End Process

Process called "is_integer_literal" takes has_decimal_point as Integer, has_exponent as Integer returns Integer:
    Note: Check if literal is integer
    Note: has_decimal_point: 1 if contains '.'
    Note: has_exponent: 1 if contains 'e' or 'E'
    Note: Returns 1 if integer, 0 if float

    If has_decimal_point is equal to 1:
        Return 0
    End If

    If has_exponent is equal to 1:
        Return 0
    End If

    Return 1
End Process

Process called "is_float_literal" takes has_decimal_point as Integer, has_exponent as Integer returns Integer:
    Note: Check if literal is floating-point
    Note: Returns 1 if float, 0 if integer

    If has_decimal_point is equal to 1:
        Return 1
    End If

    If has_exponent is equal to 1:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Integer Literal Validation
Note: ============================================================================

Process called "validate_integer_literal" takes value as Integer, is_negative as Integer returns Integer:
    Note: Validate integer literal value
    Note: value: absolute value of literal
    Note: is_negative: 1 if negative sign present
    Note: Returns 1 if valid, 0 if overflow

    Note: 64-bit signed range: -9223372036854775808 to 9223372036854775807
    Note: Check if value is within valid range

    Note: Negative values
    If is_negative is equal to 1:
        Note: Most negative value has absolute value 9223372036854775808
        Note: But this exceeds max positive Integer (9223372036854775807)
        Note: Special case: -9223372036854775808 is valid but its absolute value overflows
        Note: We check if value is negative (already wrapped) which indicates the min value
        If value is less than 0:
            Note: Value wrapped around, this is -9223372036854775808 which is valid
            Return 1
        End If
        Note: All other negative values are valid if they fit in Integer type
        Return 1
    End If

    Note: Positive values cannot exceed 9223372036854775807
    Note: If value is positive and fits in Integer type, it is valid
    If value is greater than 0:
        Return 1
    End If

    Note: Value is exactly zero
    If value is equal to 0:
        Return 1
    End If

    Note: Negative value in positive range indicates overflow
    Return 0
End Process

Process called "infer_integer_size" takes value as Integer returns Integer:
    Note: Infer smallest integer type that can hold value
    Note: Returns type ID: 10=int8, 11=int16, 12=int32, 1=int64

    Note: Fits in 8-bit signed (-128 to 127)
    If value is greater than or equal to 0:
        If value is less than or equal to 127:
            Return 10
        End If
    End If

    Note: Fits in 16-bit signed (-32768 to 32767)
    If value is less than or equal to 32767:
        Return 11
    End If

    Note: Fits in 32-bit signed (-2147483648 to 2147483647)
    If value is less than or equal to 2147483647:
        Return 12
    End If

    Note: Requires 64-bit
    Return 1
End Process

Process called "has_integer_suffix" takes has_suffix as Integer, suffix_type as Integer returns Integer:
    Note: Check if integer literal has type suffix
    Note: has_suffix: 1 if suffix present
    Note: suffix_type: 1=L (long), 2=LL (long long), 3=U (unsigned)
    Note: Returns 1 if has suffix, 0 if no suffix

    If has_suffix is equal to 1:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Float Literal Validation
Note: ============================================================================

Process called "validate_float_literal" takes has_valid_format as Integer, exponent_in_range as Integer returns Integer:
    Note: Validate floating-point literal
    Note: has_valid_format: 1 if format is valid (digits, optional '.', optional exponent)
    Note: exponent_in_range: 1 if exponent is within valid range
    Note: Returns 1 if valid, 0 if invalid

    If has_valid_format is equal to 0:
        Return 0
    End If

    If exponent_in_range is equal to 0:
        Return 0
    End If

    Return 1
End Process

Process called "infer_float_precision" takes has_suffix as Integer, suffix_type as Integer returns Integer:
    Note: Infer float precision from suffix
    Note: has_suffix: 1 if suffix present
    Note: suffix_type: 1=f (float32), 2=d (float64), 3=l (float80/128)
    Note: Returns type ID: 32=float32, 33=float64, 30=default float

    If has_suffix is equal to 0:
        Return 30
    End If

    Note: Float32 suffix (f)
    If suffix_type is equal to 1:
        Return 32
    End If

    Note: Float64 suffix (d)
    If suffix_type is equal to 2:
        Return 33
    End If

    Note: Extended precision suffix (l)
    If suffix_type is equal to 3:
        Return 35
    End If

    Return 30
End Process

Process called "is_special_float_value" takes is_inf as Integer, is_nan as Integer returns Integer:
    Note: Check if float literal is special value (infinity, NaN)
    Note: is_inf: 1 if literal is 'inf' or 'infinity'
    Note: is_nan: 1 if literal is 'nan'
    Note: Returns 1 if special, 0 if normal

    If is_inf is equal to 1:
        Return 1
    End If

    If is_nan is equal to 1:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Boolean Literal Validation
Note: ============================================================================

Process called "validate_boolean_literal" takes is_true as Integer, is_false as Integer returns Integer:
    Note: Validate boolean literal
    Note: is_true: 1 if literal is 'true'
    Note: is_false: 1 if literal is 'false'
    Note: Returns 1 if valid, 0 if invalid

    Note: Must be either true or false
    If is_true is equal to 1:
        Return 1
    End If

    If is_false is equal to 1:
        Return 1
    End If

    Return 0
End Process

Process called "get_boolean_value" takes is_true as Integer returns Integer:
    Note: Get boolean literal value
    Note: is_true: 1 if literal is 'true'
    Note: Returns 1 for true, 0 for false

    If is_true is equal to 1:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: String Literal Validation
Note: ============================================================================

Process called "validate_string_literal" takes has_quotes as Integer, has_valid_escapes as Integer returns Integer:
    Note: Validate string literal
    Note: has_quotes: 1 if surrounded by quotes
    Note: has_valid_escapes: 1 if all escape sequences are valid
    Note: Returns 1 if valid, 0 if invalid

    If has_quotes is equal to 0:
        Return 0
    End If

    If has_valid_escapes is equal to 0:
        Return 0
    End If

    Return 1
End Process

Process called "is_valid_escape_sequence" takes escape_char as Integer returns Integer:
    Note: Check if escape sequence is valid
    Note: escape_char: character after backslash (n, t, r, etc)
    Note: Returns 1 if valid, 0 if invalid

    Note: Newline (n = 110)
    If escape_char is equal to 110:
        Return 1
    End If

    Note: Tab (t = 116)
    If escape_char is equal to 116:
        Return 1
    End If

    Note: Carriage return (r = 114)
    If escape_char is equal to 114:
        Return 1
    End If

    Note: Backslash (\ = 92)
    If escape_char is equal to 92:
        Return 1
    End If

    Note: Quote (" = 34)
    If escape_char is equal to 34:
        Return 1
    End If

    Note: Single quote (' = 39)
    If escape_char is equal to 39:
        Return 1
    End If

    Return 0
End Process

Process called "calculate_string_length" takes char_count as Integer, escape_count as Integer returns Integer:
    Note: Calculate actual string length after processing escapes
    Note: char_count: number of characters including escape sequences
    Note: escape_count: number of escape sequences
    Note: Returns actual length

    Note: Each escape sequence is 2 chars in source but 1 in result
    Let actual_length be char_count minus escape_count
    Return actual_length
End Process

Note: ============================================================================
Note: Literal Overflow Detection
Note: ============================================================================

Process called "will_overflow_int8" takes value as Integer returns Integer:
    Note: Check if value will overflow 8-bit signed integer
    Note: value: value to check
    Note: Returns 1 if overflow, 0 if fits

    Note: 8-bit signed range: -128 to 127
    If value is less than 0:
        Let neg_value be 0 minus value
        If neg_value is greater than 128:
            Return 1
        End If
    End If

    If value is greater than 127:
        Return 1
    End If

    Return 0
End Process

Process called "will_overflow_int16" takes value as Integer returns Integer:
    Note: Check if value will overflow 16-bit signed integer
    Note: Returns 1 if overflow, 0 if fits

    Note: 16-bit signed range: -32768 to 32767
    If value is less than 0:
        Let neg_value be 0 minus value
        If neg_value is greater than 32768:
            Return 1
        End If
    End If

    If value is greater than 32767:
        Return 1
    End If

    Return 0
End Process

Process called "will_overflow_int32" takes value as Integer returns Integer:
    Note: Check if value will overflow 32-bit signed integer
    Note: Returns 1 if overflow, 0 if fits

    Note: 32-bit signed range: -2147483648 to 2147483647
    If value is greater than 2147483647:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Literal Radix Detection
Note: ============================================================================

Process called "get_literal_radix" takes has_prefix as Integer, prefix_type as Integer returns Integer:
    Note: Determine radix (base) of integer literal
    Note: has_prefix: 1 if prefix present
    Note: prefix_type: 1=0x (hex), 2=0b (binary), 3=0o (octal)
    Note: Returns radix: 16=hex, 2=binary, 8=octal, 10=decimal

    If has_prefix is equal to 0:
        Return 10
    End If

    Note: Hexadecimal (0x)
    If prefix_type is equal to 1:
        Return 16
    End If

    Note: Binary (0b)
    If prefix_type is equal to 2:
        Return 2
    End If

    Note: Octal (0o)
    If prefix_type is equal to 3:
        Return 8
    End If

    Return 10
End Process

Process called "is_valid_digit_for_radix" takes digit_value as Integer, radix as Integer returns Integer:
    Note: Check if digit is valid for radix
    Note: digit_value: numeric value of digit (0-15)
    Note: radix: base (2, 8, 10, 16)
    Note: Returns 1 if valid, 0 if invalid

    Note: Digit must be less than radix
    If digit_value is greater than or equal to radix:
        Return 0
    End If

    Return 1
End Process

Note: ============================================================================
Note: Literal Constant Folding
Note: ============================================================================

Process called "can_fold_literal_operation" takes left_is_literal as Integer, right_is_literal as Integer returns Integer:
    Note: Check if operation on literals can be folded at compile time
    Note: left_is_literal: 1 if left operand is literal
    Note: right_is_literal: 1 if right operand is literal
    Note: Returns 1 if can fold, 0 if runtime evaluation needed

    If left_is_literal is equal to 0:
        Return 0
    End If

    If right_is_literal is equal to 0:
        Return 0
    End If

    Return 1
End Process

Process called "is_literal_zero" takes value as Integer returns Integer:
    Note: Check if literal is zero
    Note: Used for optimization (multiply by zero, add zero, etc)
    Note: Returns 1 if zero, 0 if non-zero

    If value is equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "is_literal_one" takes value as Integer returns Integer:
    Note: Check if literal is one
    Note: Used for optimization (multiply by one, divide by one, etc)
    Note: Returns 1 if one, 0 if other value

    If value is equal to 1:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Literal Encoding
Note: ============================================================================

Process called "requires_immediate_encoding" takes value as Integer returns Integer:
    Note: Check if literal can be encoded as immediate operand
    Note: Most architectures support 8-16 bit immediate values
    Note: value: literal value
    Note: Returns 1 if can use immediate, 0 if needs memory load

    Note: Small values (-128 to 127) fit in immediate
    If value is greater than or equal to 0:
        If value is less than or equal to 127:
            Return 1
        End If
    End If

    Note: Values outside immediate range need memory load
    Return 0
End Process

Process called "get_encoding_size" takes value as Integer returns Integer:
    Note: Determine encoding size for literal
    Note: Returns size in bytes: 1, 2, 4, or 8

    Note: Fits in 1 byte
    If value is greater than or equal to 0:
        If value is less than or equal to 255:
            Return 1
        End If
    End If

    Note: Fits in 2 bytes
    If value is less than or equal to 65535:
        Return 2
    End If

    Note: Fits in 4 bytes
    If value is less than or equal to 2147483647:
        Return 4
    End If

    Note: Requires 8 bytes
    Return 8
End Process
