Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles reference management and reference operations.

This file performs the following tasks:
- Process reference creation and reference management
- Handle reference counting and reference lifecycle management
- Manage reference optimization and reference access optimization
- Process reference ownership tracking and reference safety validation - v0.0.8.5 feature

This file is essential because of the following reasons:
- Reference management is fundamental to memory management and object lifecycle
- Reference ownership tracking is a key v0.0.8.5 feature for memory safety
- Proper reference handling ensures memory safety and prevents reference-related errors

This file consists of the following functions/features/operation types:
- Reference creation and reference management
- Reference counting and reference lifecycle management
- Reference optimization and reference access optimization
- Reference ownership tracking and reference safety validation
:End Note

Import "memory/layout.runa" as Layout
Import "core/pointer_primitive.runa" as Pointer
Import "core/memory_core.runa" as Memory

Note: ============================================================================
Note: REFERENCE TYPE CONSTANTS
Note: ============================================================================

Process called "REF_TYPE_OWNED" returns Integer:
    Note: Owned reference - exclusive ownership, no reference counting
    Return 0
End Process

Process called "REF_TYPE_SHARED" returns Integer:
    Note: Shared reference - reference counted, multiple owners allowed
    Return 1
End Process

Process called "REF_TYPE_WEAK" returns Integer:
    Note: Weak reference - does not keep object alive
    Return 2
End Process

Process called "REF_TYPE_BORROWED" returns Integer:
    Note: Borrowed reference - temporary access, does not own
    Return 3
End Process

Note: ============================================================================
Note: REFERENCE OWNERSHIP STATES (v0.0.8.5)
Note: ============================================================================

Process called "OWNERSHIP_STATE_UNIQUE" returns Integer:
    Note: Reference has unique ownership - can mutate freely
    Return 0
End Process

Process called "OWNERSHIP_STATE_SHARED_IMMUTABLE" returns Integer:
    Note: Reference is shared but immutable - multiple readers allowed
    Return 1
End Process

Process called "OWNERSHIP_STATE_SHARED_MUTABLE" returns Integer:
    Note: Reference is shared and mutable - requires synchronization
    Return 2
End Process

Process called "OWNERSHIP_STATE_MOVED" returns Integer:
    Note: Reference ownership has been moved - use is an error
    Return 3
End Process

Process called "OWNERSHIP_STATE_BORROWED" returns Integer:
    Note: Reference is temporarily borrowed - original owner retains ownership
    Return 4
End Process

Note: ============================================================================
Note: BORROWED REFERENCE STRUCTURE
Note: ============================================================================

Note: BorrowedRef Structure (32 bytes):
Note:   offset 0:  data_ptr (pointer to actual data, 8 bytes)
Note:   offset 8:  owner_alloc_id (allocation ID of owner, 8 bytes)
Note:   offset 16: owner_generation (generation when borrow created, 8 bytes)
Note:   offset 24: offset_from_owner (offset into owner allocation, 8 bytes)

Note: This structure enables runtime borrow validation by tracking:
Note: - Which allocation owns the borrowed data
Note: - The generation counter to detect use-after-realloc
Note: - The offset for bounds checking

Process called "borrow_create" takes owner_ptr as Integer, offset as Integer returns Integer:
    Note: Create a BorrowedRef structure for runtime-validated borrowing
    Note: owner_ptr: pointer to owner allocation (user data pointer)
    Note: offset: offset into owner allocation (0 for direct borrow)
    Note: Returns pointer to BorrowedRef structure (32 bytes), or 0 on failure

    If owner_ptr is equal to 0:
        Return 0  Note: Cannot borrow from null pointer
    End If

    Note: Read allocation metadata from owner's header
    Let header_size be 32  Note: Owned allocation header size
    Let header_ptr be owner_ptr minus header_size

    Let alloc_id be proc memory_get_int64 from Memory with header_ptr, 0
    Let generation be proc memory_get_int64 from Memory with header_ptr, 8

    Note: Allocate BorrowedRef structure
    Let borrow_ref be proc allocate from Layout with 32
    If borrow_ref is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Calculate actual data pointer (owner + offset)
    Let data_ptr be owner_ptr plus offset

    Note: Initialize BorrowedRef fields
    proc memory_set_int64 from Memory with borrow_ref, 0, data_ptr
    proc memory_set_int64 from Memory with borrow_ref, 8, alloc_id
    proc memory_set_int64 from Memory with borrow_ref, 16, generation
    proc memory_set_int64 from Memory with borrow_ref, 24, offset

    Return borrow_ref
End Process

Process called "borrow_destroy" takes borrow_ref as Integer returns Integer:
    Note: Destroy a BorrowedRef structure
    Note: Returns 1 on success, 0 on failure

    If borrow_ref is equal to 0:
        Return 0
    End If

    proc deallocate from Layout with borrow_ref
    Return 1
End Process

Process called "borrow_get_data_ptr" takes borrow_ref as Integer returns Integer:
    Note: Get the data pointer from a BorrowedRef
    Note: Returns data pointer, or 0 if invalid

    If borrow_ref is equal to 0:
        Return 0
    End If

    Return proc memory_get_int64 from Memory with borrow_ref, 0
End Process

Note: ============================================================================
Note: OWNED REFERENCE OPERATIONS
Note: ============================================================================

Process called "owned_create" takes size as Integer returns Integer:
    Note: Create owned reference with exclusive ownership
    Note: Returns pointer to owned heap allocation
    Note: Caller has exclusive ownership and must call owned_destroy()

    Let ptr be proc allocate from Layout with size
    Return ptr
End Process

Process called "owned_destroy" takes ptr as Integer returns Integer:
    Note: Destroy owned reference and free memory
    Note: Only call when you have exclusive ownership
    Note: After this call, ptr is invalid

    proc deallocate from Layout with ptr
    Return 0
End Process

Process called "owned_transfer_ownership" takes ptr as Integer returns Integer:
    Note: Transfer ownership to another reference
    Note: After this call, original reference should not be used
    Note: Returns the same pointer (ownership semantics only)
    Note: This is a semantic marker for ownership tracking

    Return ptr
End Process

Note: ============================================================================
Note: SHARED REFERENCE OPERATIONS
Note: ============================================================================

Process called "shared_create" takes size as Integer returns Integer:
    Note: Create shared reference with reference counting
    Note: Initial reference count is 1
    Note: Returns pointer to shared allocation
    Note: Must call shared_release() when done

    Let ptr be proc shared create from Layout with size
    Return ptr
End Process

Process called "shared_retain" takes ptr as Integer returns Integer:
    Note: Increment reference count - creates new shared reference
    Note: Call this when creating a new reference to the same object
    Note: Each retain must be balanced with a release

    Let new_ptr be proc shared retain from Layout with ptr
    Return new_ptr
End Process

Process called "shared_release" takes ptr as Integer returns Integer:
    Note: Decrement reference count - releases shared reference
    Note: Object is freed when reference count reaches 0
    Note: After this call, do not use ptr

    proc shared release from Layout with ptr
    Return 0
End Process

Process called "shared_get_refcount" takes ptr as Integer returns Integer:
    Note: Get current reference count for debugging
    Note: Useful for debugging memory leaks and reference cycles

    Let count be proc shared get refcount from Layout with ptr
    Return count
End Process

Process called "shared_is_unique" takes ptr as Integer returns Integer:
    Note: Check if this is the only reference to the object
    Note: Returns 1 if refcount is 1, 0 otherwise
    Note: Useful for copy-on-write optimization

    Let count be proc shared get refcount from Layout with ptr
    If count is equal to 1:
        Return 1
    End If
    Return 0
End Process

Note: ============================================================================
Note: WEAK REFERENCE OPERATIONS
Note: ============================================================================

Process called "weak_create" takes shared_ptr as Integer returns Integer:
    Note: Create weak reference from shared reference
    Note: Weak reference does not keep object alive
    Note: Must check if object is still alive before using
    Note: Returns weak pointer (same value as shared_ptr)

    Note: Weak references are tracked in the shared object header
    Note: This increments the weak reference count
    Let weak_ptr be proc weak create from Layout with shared_ptr
    Return weak_ptr
End Process

Process called "weak_release" takes weak_ptr as Integer returns Integer:
    Note: Release weak reference
    Note: Decrements weak reference count

    proc weak destroy from Layout with weak_ptr
    Return 0
End Process

Process called "weak_try_promote" takes weak_ptr as Integer returns Integer:
    Note: Try to promote weak reference to strong reference
    Note: Returns strong reference pointer if object is still alive
    Note: Returns 0 if object has been deallocated
    Note: If successful, must call shared_release() when done

    Let strong_ptr be proc weak lock from Layout with weak_ptr
    Return strong_ptr
End Process

Process called "weak_is_alive" takes weak_ptr as Integer returns Integer:
    Note: Check if object referenced by weak pointer is still alive
    Note: Returns 1 if alive, 0 if deallocated

    Let strong_ptr be proc weak lock from Layout with weak_ptr
    If strong_ptr is equal to 0:
        Return 0  Note: Object is dead
    End If

    Note: Object is alive - but we created a strong reference, so release it
    proc shared release from Layout with strong_ptr
    Return 1
End Process

Note: ============================================================================
Note: BORROWED REFERENCE OPERATIONS
Note: ============================================================================

Process called "borrowed_create" takes ptr as Integer returns Integer:
    Note: Create borrowed reference - does not take ownership
    Note: Borrowed references are temporary and do not affect reference count
    Note: Original owner must ensure object stays alive during borrow
    Note: Returns the same pointer (borrowing is a semantic concept)

    Return ptr
End Process

Process called "borrowed_is_valid" takes borrowed_ptr as Integer returns Integer:
    Note: Check if borrowed reference is still valid
    Note: Uses allocation registry for complete runtime validation
    Note: Validates ALL allocation types (owned brk, owned mmap, shared)
    Note: Returns 1 if valid, 0 if invalid (freed, corrupted, or never allocated)

    If borrowed_ptr is equal to 0:
        Return 0  Note: Null pointer is invalid
    End If

    Note: Read allocation metadata from header
    Note: Try owned allocation header first (32 bytes)
    Let header_size be 32
    Let header_ptr be borrowed_ptr minus header_size

    Note: Extract allocation_id from header
    Let alloc_id be proc memory_get_int64 from Memory with header_ptr, 0
    Let header_generation be proc memory_get_int64 from Memory with header_ptr, 8

    Note: Look up allocation in registry
    Let registry_entry be proc registry_lookup from Layout with alloc_id
    If registry_entry is equal to 0:
        Note: Not in registry - might be shared allocation with different header size
        Note: Try shared allocation header (48 bytes)
        Set header_size to 48
        Set header_ptr to borrowed_ptr minus header_size
        Set alloc_id to proc memory_get_int64 from Memory with header_ptr, 0
        Set header_generation to proc memory_get_int64 from Memory with header_ptr, 8
        Set registry_entry to proc registry_lookup from Layout with alloc_id

        If registry_entry is equal to 0:
            Return 0  Note: Not found in registry - invalid allocation
        End If
    End If

    Note: Extract registry metadata (RegistryEntry is 56 bytes)
    Let registry_generation be proc memory_get_int64 from Memory with registry_entry, 16
    Let is_alive be proc memory_get_int64 from Memory with registry_entry, 48

    Note: Check generation (detect use-after-realloc)
    If registry_generation is not equal to header_generation:
        Return 0  Note: Generation mismatch - allocation was freed and reused
    End If

    Note: Check if allocation is still alive
    If is_alive is equal to 0:
        Return 0  Note: Allocation has been freed
    End If

    Return 1  Note: Allocation is valid
End Process

Note: ============================================================================
Note: REFERENCE SAFETY VALIDATION (v0.0.8.5)
Note: ============================================================================

Process called "validate_ownership_unique" takes ptr as Integer returns Integer:
    Note: Validate that reference has unique ownership
    Note: For owned references, always true
    Note: For shared references, checks if refcount == 1
    Note: Returns 1 if unique, 0 if shared

    If ptr is equal to 0:
        Return 0  Note: Null pointer has no ownership
    End If

    Note: Determine ownership by checking reference count
    Note: Shared allocations have metadata, owned allocations return 0
    Let count be proc shared get refcount from Layout with ptr

    If count is equal to 0:
        Note: Not a shared allocation - this is an owned allocation
        Return 1  Note: Owned allocations have unique ownership
    End If

    If count is equal to 1:
        Return 1  Note: Shared but only one reference - unique ownership
    End If

    Note: Multiple references exist
    Return 0  Note: Shared ownership - not unique
End Process

Process called "validate_ownership_shared" takes ptr as Integer returns Integer:
    Note: Validate that reference can be shared
    Note: Returns 1 if reference supports sharing, 0 otherwise

    If ptr is equal to 0:
        Return 0
    End If

    Note: Check if this is a shared allocation by trying to get refcount
    Let count be proc shared get refcount from Layout with ptr
    If count is greater than 0:
        Return 1  Note: This is a shared allocation
    End If

    Note: Not a shared allocation
    Return 0
End Process

Process called "validate_ownership_moved" takes ptr as Integer, moved_flag as Integer returns Integer:
    Note: Validate that reference has not been moved
    Note: moved_flag: 1 if ownership has been moved, 0 otherwise
    Note: Returns 1 if valid (not moved), 0 if moved (use is error)

    If moved_flag is equal to 1:
        Return 0  Note: Ownership was moved - use is error
    End If

    Return 1  Note: Valid - not moved
End Process

Process called "validate_borrow_lifetime" takes borrowed_ptr as Integer, owner_ptr as Integer returns Integer:
    Note: Validate that borrowed reference lifetime is valid
    Note: Checks that owner still exists and has not been freed
    Note: Returns 1 if borrow is valid, 0 if invalid
    
    Note: FULL IMPLEMENTATION using BorrowedRef and allocation registry
    Note: borrowed_ptr should be a BorrowedRef structure pointer (32 bytes)
    Note: owner_ptr parameter is optional - validation uses registry instead

    If borrowed_ptr is equal to 0:
        Return 0  Note: Null borrow reference
    End If

    Note: Step 1: Extract borrow metadata from BorrowedRef structure
    Let data_ptr be proc memory_get_int64 from Memory with borrowed_ptr, 0
    Let owner_alloc_id be proc memory_get_int64 from Memory with borrowed_ptr, 8
    Let owner_generation be proc memory_get_int64 from Memory with borrowed_ptr, 16
    Let offset_from_owner be proc memory_get_int64 from Memory with borrowed_ptr, 24

    Note: Step 2: Look up owner allocation in registry
    Let registry_entry be proc registry_lookup from Layout with owner_alloc_id
    If registry_entry is equal to 0:
        Return 0  Note: Owner allocation not found (freed and removed from registry)
    End If

    Note: Step 3: Extract registry metadata (RegistryEntry is 56 bytes)
    Note: RegistryEntry layout:
    Note:   offset 0:  is_occupied (8 bytes)
    Note:   offset 8:  allocation_id (8 bytes)
    Note:   offset 16: generation (8 bytes)
    Note:   offset 24: base_ptr (8 bytes)
    Note:   offset 32: size (8 bytes)
    Note:   offset 40: alloc_type (8 bytes)
    Note:   offset 48: is_alive (8 bytes)

    Let registry_generation be proc memory_get_int64 from Memory with registry_entry, 16
    Let owner_base be proc memory_get_int64 from Memory with registry_entry, 24
    Let owner_size be proc memory_get_int64 from Memory with registry_entry, 32
    Let is_alive be proc memory_get_int64 from Memory with registry_entry, 48

    Note: Step 4: Check generation (detect use-after-realloc)
    If registry_generation is not equal to owner_generation:
        Return 0  Note: Generation mismatch - address was reused after free
    End If

    Note: Step 5: Check if allocation is still alive
    If is_alive is equal to 0:
        Return 0  Note: Owner has been freed
    End If

    Note: Step 6: Verify data_ptr is within allocation bounds
    Let owner_end be owner_base plus owner_size

    If data_ptr is less than owner_base:
        Return 0  Note: Pointer before allocation start (out of bounds)
    End If

    If data_ptr is greater than or equal to owner_end:
        Return 0  Note: Pointer past allocation end (out of bounds)
    End If

    Note: Step 7: Verify offset consistency (detect corruption)
    Let computed_ptr be owner_base plus offset_from_owner
    If data_ptr is not equal to computed_ptr:
        Return 0  Note: Pointer offset mismatch - possible memory corruption
    End If

    Note: All validation checks passed!
    Return 1  Note: Borrow is valid
End Process

Note: ============================================================================
Note: REFERENCE OPTIMIZATION
Note: ============================================================================

Process called "can_move_instead_of_clone" takes ptr as Integer returns Integer:
    Note: Check if we can move instead of cloning
    Note: If reference is unique, moving is safe (no other owners)
    Note: Returns 1 if can move (optimize clone→move), 0 if must clone
    Note: This is a query function for compiler optimization decisions

    Let is_unique be proc shared_is_unique with ptr
    If is_unique is equal to 1:
        Return 1  Note: Unique - can move instead of clone
    End If

    Return 0  Note: Shared - must clone (cannot move)
End Process

Process called "can_optimize_cow" takes ptr as Integer returns Integer:
    Note: Check if copy-on-write optimization is possible
    Note: Returns 1 if can mutate in place (unique reference)
    Note: Returns 0 if copy is needed before mutation (shared reference)
    Note: This is a query function - actual COW must be done by caller with size

    Let is_unique be proc shared_is_unique with ptr
    If is_unique is equal to 1:
        Return 1  Note: Unique - can mutate in place without copying
    End If

    Return 0  Note: Shared - must copy before mutation
End Process

Process called "perform_cow" takes ptr as Integer, size as Integer returns Integer:
    Note: Perform copy-on-write optimization
    Note: If reference is unique, returns original ptr (can mutate in place)
    Note: If reference is shared, creates new copy and returns new ptr
    Note: Caller must release old reference if copy was made

    Let is_unique be proc shared_is_unique with ptr
    If is_unique is equal to 1:
        Return ptr  Note: Unique - can mutate in place without copying
    End If

    Note: Shared - must create copy
    Let new_ptr be proc shared_create with size
    If new_ptr is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Copy data from old ptr to new ptr
    proc memory copy from Memory with new_ptr, ptr, size

    Note: Return new pointer - caller must release old reference
    Return new_ptr
End Process

Process called "should_inline_value" takes size as Integer returns Integer:
    Note: Determine if value should be inlined vs heap-allocated
    Note: Small values (≤ 16 bytes) can be passed by value efficiently
    Note: Returns 1 if should inline, 0 if should heap-allocate
    Note: This is a query function for compiler optimization decisions

    If size is less than or equal to 16:
        Return 1  Note: Small enough to inline (fits in 2 registers)
    End If

    Return 0  Note: Too large - use heap allocation
End Process

Note: ============================================================================
Note: REFERENCE TYPE QUERIES
Note: ============================================================================

Process called "get_reference_type" takes ptr as Integer returns Integer:
    Note: Determine reference type from pointer using allocation registry
    Note: Returns REF_TYPE constant (0=owned, 1=shared)
    Note: Uses registry's alloc_type field for accurate type detection
    Note: Returns -1 for invalid pointers or allocations not in registry

    If ptr is equal to 0:
        Return -1  Note: Invalid pointer
    End If

    Note: Read allocation metadata from header
    Note: Try owned allocation header first (32 bytes)
    Let header_size be 32
    Let header_ptr be ptr minus header_size

    Note: Extract allocation_id from header
    Let alloc_id be proc memory_get_int64 from Memory with header_ptr, 0

    Note: Look up allocation in registry
    Let registry_entry be proc registry_lookup from Layout with alloc_id
    If registry_entry is equal to 0:
        Note: Not in registry - might be shared allocation with different header size
        Note: Try shared allocation header (48 bytes)
        Set header_size to 48
        Set header_ptr to ptr minus header_size
        Set alloc_id to proc memory_get_int64 from Memory with header_ptr, 0
        Set registry_entry to proc registry_lookup from Layout with alloc_id

        If registry_entry is equal to 0:
            Return -1  Note: Not found in registry - invalid or external allocation
        End If
    End If

    Note: Extract allocation type from registry (RegistryEntry offset 40)
    Note: alloc_type: 1=brk (owned), 2=mmap (owned), 3=shared
    Let alloc_type be proc memory_get_int64 from Memory with registry_entry, 40

    If alloc_type is equal to 3:
        Return proc REF_TYPE_SHARED  Note: Shared allocation
    End If

    If alloc_type is equal to 1:
        Return proc REF_TYPE_OWNED  Note: Owned brk allocation
    End If

    If alloc_type is equal to 2:
        Return proc REF_TYPE_OWNED  Note: Owned mmap allocation
    End If

    Note: Unknown allocation type
    Return -1
End Process

Process called "is_owned_reference" takes ptr as Integer returns Integer:
    Note: Check if this is an owned reference
    Note: Returns 1 if owned, 0 otherwise

    Let ref_type be proc get_reference_type with ptr
    If ref_type is equal to proc REF_TYPE_OWNED:
        Return 1
    End If
    Return 0
End Process

Process called "is_shared_reference" takes ptr as Integer returns Integer:
    Note: Check if this is a shared reference
    Note: Returns 1 if shared, 0 otherwise

    Let ref_type be proc get_reference_type with ptr
    If ref_type is equal to proc REF_TYPE_SHARED:
        Return 1
    End If
    Return 0
End Process

Note: ============================================================================
Note: REFERENCE DEBUGGING
Note: ============================================================================

Process called "debug_print_refcount" takes ptr as Integer returns Integer:
    Note: Get reference count for debugging output
    Note: Only works for shared references (returns 0 for owned references)
    Note: Returns the reference count value
    Note: Caller can use IO primitives to print this value

    Let count be proc shared get refcount from Layout with ptr
    Return count
End Process

Process called "debug_check_refcount_leak" takes ptr as Integer, expected_count as Integer returns Integer:
    Note: Check if reference count matches expected value
    Note: Useful for detecting reference leaks in tests
    Note: Returns 1 if match, 0 if mismatch

    Let actual_count be proc shared get refcount from Layout with ptr
    If actual_count is equal to expected_count:
        Return 1  Note: Count matches expected
    End If

    Return 0  Note: Potential leak - count mismatch
End Process
