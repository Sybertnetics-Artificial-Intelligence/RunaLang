Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file implements the Four-Tier Memory Architecture for v0.0.8.5

TIER 1: STACK - Automatic local variables (compiler-managed, zero-cost)
TIER 2: ARENA - Temporary allocations (bump-pointer, bulk free, O(1))
TIER 3: OWNED HEAP - Permanent structures (individual ownership, explicit free)
TIER 4: SHARED - Reference counted (future: for shared ownership)

GOLDEN RULE: "Arena for TEMPS, Ownership for PERMANENT"

This architecture was proven in v0.0.8.4.5.2 to reduce memory leaks by 34.6%
while maintaining compilation correctness.

Depends on:
- assembly/syscall.runa (for mmap/munmap/brk)
- core/memory_core.runa (for memory operations)
- core/alignment_core.runa (for alignment)
:End Note

Import "compiler/frontend/primitives/assembly/syscall.runa" as Syscall
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
Import "compiler/frontend/primitives/core/alignment_core.runa" as Alignment

Note: ============================================================================
Note: TIER 2: ARENA ALLOCATOR (Temporary Allocations)
Note: ============================================================================

Note: Arena structure (24 bytes):
Note:   offset 0: buffer (pointer to allocated memory)
Note:   offset 8: size (total capacity in bytes)
Note:   offset 16: used (bytes currently allocated)

Process called "arena_create" takes initial_size as Integer returns Integer:
    Note: Create arena allocator with initial capacity
    Note: Returns pointer to Arena structure, or 0 on failure

    Note: Allocate arena structure (24 bytes)
    Let arena be allocate(24)
    If arena is equal to 0:
        Return 0  Note: Failed to allocate arena structure
    End If

    Note: Allocate buffer using mmap for large allocations
    Note: PROT_READ | PROT_WRITE = 3
    Note: MAP_PRIVATE | MAP_ANONYMOUS = 0x22
    Let prot be 3
    Let flags be 34  Note: 0x22
    Let buffer be syscall_mmap(0, initial_size, prot, flags, -1, 0)

    Note: Check for mmap failure (returns -1 or negative)
    If buffer is less than 0:
        deallocate(arena)
        Return 0  Note: Failed to allocate buffer
    End If

    Note: Initialize arena fields
    memory_set_pointer(arena, 0, buffer)      Note: buffer
    memory_set_int64(arena, 8, initial_size)  Note: size
    memory_set_int64(arena, 16, 0)            Note: used = 0

    Return arena
End Process

Process called "arena_allocate" takes arena as Integer, size as Integer returns Integer:
    Note: Allocate memory from arena (bump-pointer allocation)
    Note: Returns pointer to allocated memory, or 0 if out of space

    If arena is equal to 0:
        Return 0  Note: Invalid arena
    End If

    Note: Align allocation size to 8 bytes
    Let aligned_size be align_up(size, 8)

    Note: Get current state
    Let buffer be memory_get_pointer(arena, 0)
    Let capacity be memory_get_int64(arena, 8)
    Let used be memory_get_int64(arena, 16)

    Note: Check if we have enough space
    Let new_used be used plus aligned_size
    If new_used is greater than capacity:
        Return 0  Note: Out of arena space
    End If

    Note: Calculate allocation address
    Let ptr be buffer plus used

    Note: Update used counter (bump the pointer)
    memory_set_int64(arena, 16, new_used)

    Return ptr
End Process

Process called "arena_string_duplicate" takes arena as Integer, str as Integer returns Integer:
    Note: Duplicate string into arena memory
    Note: Used for temporary strings during compilation

    If str is equal to 0:
        Return 0
    End If

    Let len be string_length(str)
    Let size be len plus 1  Note: Include null terminator

    Let new_str be arena_allocate(arena, size)
    If new_str is equal to 0:
        Return 0  Note: Arena out of space
    End If

    memory_copy(new_str, str, size)
    Return new_str
End Process

Process called "arena_integer_to_string" takes arena as Integer, value as Integer returns Integer:
    Note: Convert integer to string using arena
    Note: Eliminates temporary string leaks

    Note: Use heap version first, then copy to arena
    Let heap_str be integer_to_string(value)
    Let arena_str be arena_string_duplicate(arena, heap_str)
    deallocate(heap_str)

    Return arena_str
End Process

Process called "arena_string_concat" takes arena as Integer, str1 as Integer, str2 as Integer returns Integer:
    Note: Concatenate strings using arena
    Note: Eliminates result leak

    Let heap_result be string_concat(str1, str2)
    Let arena_result be arena_string_duplicate(arena, heap_result)
    deallocate(heap_result)

    Return arena_result
End Process

Process called "arena_reset" takes arena as Integer returns Integer:
    Note: Reset arena to empty state (reuse buffer)
    Note: All previous allocations become invalid!

    If arena is equal to 0:
        Return 0
    End If

    memory_set_int64(arena, 16, 0)  Note: Reset used to 0
    Return 1
End Process

Process called "arena_destroy" takes arena as Integer returns Integer:
    Note: Destroy arena and free all memory
    Note: This is O(1) bulk deallocation!

    If arena is equal to 0:
        Return 0
    End If

    Let buffer be memory_get_pointer(arena, 0)
    Let size be memory_get_int64(arena, 8)

    Note: Unmap the buffer
    If buffer is not equal to 0:
        syscall_munmap(buffer, size)
    End If

    Note: Free arena structure
    deallocate(arena)

    Return 1
End Process

Process called "arena_get_used" takes arena as Integer returns Integer:
    Note: Get bytes currently used in arena
    If arena is equal to 0:
        Return 0
    End If
    Return memory_get_int64(arena, 16)
End Process

Process called "arena_get_capacity" takes arena as Integer returns Integer:
    Note: Get total capacity of arena
    If arena is equal to 0:
        Return 0
    End If
    Return memory_get_int64(arena, 8)
End Process

Note: 
============================================================================
TIER 3: OWNED HEAP (Permanent Allocations)
============================================================================
:End Note

Note:
Allocation header structure (prepended to each allocation):
offset -16: size (total size including header, 8 bytes)
offset -8: type (1=brk, 2=mmap, 8 bytes)
offset 0: user data begins here
:End Note

Note: 
Free List Structure (for brk allocations):
When a brk block is freed, we reuse its user data area to store:
offset 0: next_free (pointer to next free block, 8 bytes)
offset 8: is_free (1 = free, 0 = allocated, 8 bytes)
The header (offset -16, -8) remains intact with size and type
:End Note

Note: 
Free List Head (stored in heap metadata):
We reserve the first 16 bytes of the heap for metadata
offset 0: free_list_head (pointer to first free block)
offset 8: heap_initialized (1 if initialized, 0 otherwise)
:End Note

Let heap_metadata_addr be 0  Note: Will be initialized on first brk call

Note: ============================================================================
Note: Free List Management Functions
Note: ============================================================================

Process called "heap_init" returns Integer:
    Note: Initialize heap metadata on first brk allocation
    Note: Reserves 16 bytes at the start of the heap for free list metadata

    If heap_metadata_addr is not equal to 0:
        Return heap_metadata_addr  Note: Already initialized
    End If

    Note: Get current brk (this will be our metadata location)
    Let current_brk be syscall_brk(0)
    Set heap_metadata_addr to current_brk

    Note: Reserve 16 bytes for metadata
    Let metadata_size be 16
    Let new_brk be current_brk plus metadata_size
    Let result_brk be syscall_brk(new_brk)

    If result_brk is less than new_brk:
        Set heap_metadata_addr to 0
        Return 0  Note: Failed to reserve metadata space
    End If

    Note: Initialize metadata
    memory_set_pointer(heap_metadata_addr, 0, 0)  Note: free_list_head = NULL
    memory_set_int64(heap_metadata_addr, 8, 1)     Note: heap_initialized = 1

    Return heap_metadata_addr
End Process

Process called "heap_get_free_list_head" returns Integer:
    Note: Get pointer to the first free block
    If heap_metadata_addr is equal to 0:
        Return 0
    End If
    Return memory_get_pointer(heap_metadata_addr, 0)
End Process

Process called "heap_set_free_list_head" takes head as Integer returns Integer:
    Note: Set the free list head pointer
    If heap_metadata_addr is equal to 0:
        Let dummy be heap_init()
    End If
    memory_set_pointer(heap_metadata_addr, 0, head)
    Return 1
End Process

Process called "free_list_find_fit" takes size as Integer returns Integer:
    Note: Find a free block that fits the requested size (first-fit algorithm)
    Note: Returns pointer to user data area, or 0 if no fit found

    Let current be heap_get_free_list_head()

    While current is not equal to 0:
        Let block_size be free_block_get_size(current)
        If block_size is greater than or equal to size:
            Return current  Note: Found a fit
        End If
        Set current to free_block_get_next(current)
    End While

    Return 0  Note: No suitable block found
End Process

Process called "free_list_remove_block" takes block as Integer returns Integer:
    Note: Remove block from free list (when reusing it for allocation)

    Let head be heap_get_free_list_head()
    Let next be 0  Note: Declare once at function scope

    Note: If it's the head, update head pointer
    If block is equal to head:
        Set next to free_block_get_next(block)
        Let dummy be heap_set_free_list_head(next)
        Return 1
    End If

    Note: Search for block in the list
    Let current be head
    While current is not equal to 0:
        Set next to free_block_get_next(current)
        If next is equal to block:
            Note: Found it - unlink from list
            Let next_next be free_block_get_next(block)
            Let dummy2 be free_block_set_next(current, next_next)
            Return 1
        End If
        Set current to next
    End While

    Return 0  Note: Block not found in list
End Process

Process called "free_list_add_block" takes block as Integer returns Integer:
    Note: Add block to the front of free list (LIFO)

    Let old_head be heap_get_free_list_head()
    Let dummy be free_block_set_next(block, old_head)
    Let dummy2 be free_block_set_free_flag(block, 1)
    Let dummy3 be heap_set_free_list_head(block)
    Return 1
End Process

Process called "free_block_set_next" takes block as Integer, next as Integer returns Integer:
    Note: Set next pointer in a free block (block points to user data area)
    memory_set_pointer(block, 0, next)
    Return 1
End Process

Process called "free_block_get_next" takes block as Integer returns Integer:
    Note: Get next pointer from a free block
    Return memory_get_pointer(block, 0)
End Process

Process called "free_block_set_free_flag" takes block as Integer, is_free as Integer returns Integer:
    Note: Mark block as free (1) or allocated (0)
    memory_set_int64(block, 8, is_free)
    Return 1
End Process

Process called "free_block_get_free_flag" takes block as Integer returns Integer:
    Note: Check if block is free
    Return memory_get_int64(block, 8)
End Process

Process called "free_block_get_size" takes block as Integer returns Integer:
    Note: Get total size of block from header (block points to user data)
    Let header_ptr be block minus 16
    Return memory_get_int64(header_ptr, 0)
End Process

Note: ============================================================================
Note: Allocation and Deallocation
Note: ============================================================================

Process called "allocate" takes size as Integer returns Integer:
    Note: Allocate memory from heap (Tier 3: Owned)
    Note: This memory must be explicitly freed with deallocate()
    Note: Returns pointer to USER DATA (header is hidden before it)

    If size is less than or equal to 0:
        Return 0
    End If

    Note: Align size to 8 bytes
    Let aligned_size be align_up(size, 8)
    Let header_size be 16  Note: 8 bytes size + 8 bytes type
    Let total_size be header_size plus aligned_size

    Note: For small allocations, use brk
    Note: For large allocations (>128KB user data), use mmap
    Let threshold be 131072  Note: 128KB
    Let user_ptr be 0  Note: Will be set in either branch

    If aligned_size is greater than threshold:
        Note: Large allocation - use mmap
        Let prot be 3  Note: PROT_READ | PROT_WRITE
        Let flags be 34  Note: MAP_PRIVATE | MAP_ANONYMOUS
        Let header_ptr be syscall_mmap(0, total_size, prot, flags, -1, 0)

        If header_ptr is less than 0:
            Return 0  Note: mmap failed
        End If

        Note: Write header metadata
        memory_set_int64(header_ptr, 0, total_size)  Note: size
        memory_set_int64(header_ptr, 8, 2)           Note: type = mmap

        Note: Return pointer to user data (skip header)
        Set user_ptr to header_ptr plus header_size
        Return user_ptr
    End If

    Note: Small allocation - check free list first
    Note: Initialize heap metadata if needed
    If heap_metadata_addr is equal to 0:
        Let init_result be heap_init()
        If init_result is equal to 0:
            Return 0  Note: Failed to initialize heap
        End If
    End If

    Note: Try to find a free block that fits
    Let free_block be free_list_find_fit(total_size)
    If free_block is not equal to 0:
        Note: Found a suitable free block - reuse it!
        Let dummy be free_list_remove_block(free_block)
        Let dummy2 be free_block_set_free_flag(free_block, 0)  Note: Mark as allocated
        Return free_block
    End If

    Note: No suitable free block - allocate new memory with brk
    Let current_brk be syscall_brk(0)
    Let new_brk be current_brk plus total_size
    Let result_brk be syscall_brk(new_brk)

    If result_brk is less than new_brk:
        Return 0  Note: brk failed
    End If

    Note: Write header metadata at current_brk
    memory_set_int64(current_brk, 0, total_size)  Note: size
    memory_set_int64(current_brk, 8, 1)           Note: type = brk

    Note: Initialize free flag (0 = allocated)
    Set user_ptr to current_brk plus header_size
    memory_set_int64(user_ptr, 8, 0)  Note: is_free = 0

    Return user_ptr
End Process

Process called "deallocate" takes ptr as Integer returns Integer:
    Note: Free memory allocated with allocate()
    Note: WARNING: Do NOT call this on arena-allocated memory!
    Note: Returns 1 on success, 0 on error

    If ptr is equal to 0:
        Return 0  Note: NULL pointer (safe to ignore)
    End If

    Note: Get header pointer (16 bytes before user data)
    Let header_size be 16
    Let header_ptr be ptr minus header_size

    Note: Read allocation metadata from header
    Let total_size be memory_get_int64(header_ptr, 0)
    Let alloc_type be memory_get_int64(header_ptr, 8)

    Note: Type 2 = mmap allocation (can be freed immediately)
    If alloc_type is equal to 2:
        Let result be syscall_munmap(header_ptr, total_size)
        If result is equal to 0:
            Return 1  Note: Successfully freed
        End If
        Return 0  Note: munmap failed
    End If

    Note: Type 1 = brk allocation - add to free list for reuse
    Let dummy be free_list_add_block(ptr)
    Return 1  Note: Successfully added to free list
End Process

Note: ============================================================================
Note: Variable Tracking (For Compiler Symbol Table)
Note: ============================================================================

Note: Variable structure (32 bytes):
Note:   offset 0: name (string pointer)
Note:   offset 8: stack_offset (integer)
Note:   offset 16: type_name (string pointer)
Note:   offset 24: is_parameter (integer)

Process called "variable_create" takes name as String, stack_offset as Integer, type_name as String, is_parameter as Integer returns Integer:
    Note: Create variable entry (Tier 3: Owned)

    Let var be allocate(32)
    If var is equal to 0:
        Return 0
    End If

    memory_set_pointer(var, 0, string_duplicate(name))
    memory_set_int64(var, 8, stack_offset)
    memory_set_pointer(var, 16, string_duplicate(type_name))
    memory_set_int64(var, 24, is_parameter)

    Return var
End Process

Process called "variable_destroy" takes var as Integer returns Integer:
    Note: Destroy variable entry

    If var is equal to 0:
        Return 0
    End If

    Let name be memory_get_pointer(var, 0)
    Let type_name be memory_get_pointer(var, 16)

    If name is not equal to 0:
        deallocate(name)
    End If

    If type_name is not equal to 0:
        deallocate(type_name)
    End If

    deallocate(var)
    Return 1
End Process

Note: ============================================================================
Note: Memory Statistics
Note: ============================================================================

Process called "get_page_size" returns Integer:
    Note: Standard page size on x86_64 Linux
    Return 4096
End Process

Process called "get_cache_line_size" returns Integer:
    Note: Typical L1 cache line size
    Return 64
End Process
