Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file recognizes and validates statement patterns in Runa.

This file performs the following tasks:
- Recognize variable declaration patterns (Let, Define, Set)
- Identify control flow statement patterns (If, Match, For, While)
- Track ownership transfer patterns for v0.0.8.5
- Validate statement structure and completeness
- Detect common statement errors and provide recovery

This file is essential because of the following reasons:
- Statement patterns define Runa's natural language syntax structure
- Proper pattern recognition enables accurate parsing and AST construction
- Ownership tracking is critical for memory safety in v0.0.8.5
- Pattern validation catches syntax errors early in compilation

This file consists of the following functions/features/operation types:
- Statement pattern matching and recognition
- Variable ownership and borrow tracking for v0.0.8.5
- Statement structure validation
- Error detection and recovery for malformed statements
- Context-sensitive statement analysis

Dependencies:
- Imports keywords.runa for keyword recognition
- Imports operators.runa for operator context
- Imports memory/layout.runa for Token and structure allocation
:End Note

Import "compiler/frontend/lexical/keywords.runa" as Keywords
Import "compiler/frontend/lexical/operators.runa" as Operators
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore

Note: ============================================================================
Note: Statement Pattern Type Constants
Note: ============================================================================

Constant PATTERN_LET_STATEMENT as Integer is 800        Note: Let variable be value
Constant PATTERN_SET_STATEMENT as Integer is 801        Note: Set variable to value
Constant PATTERN_DEFINE_STATEMENT as Integer is 802     Note: Constant as value
Constant PATTERN_IF_STATEMENT as Integer is 803         Note: If condition: ... End If
Constant PATTERN_OTHERWISE_STATEMENT as Integer is 804  Note: Otherwise: ...
Constant PATTERN_MATCH_STATEMENT as Integer is 805      Note: Match expression: When ... End Match
Constant PATTERN_FOR_STATEMENT as Integer is 806        Note: For variable in iterable: ... End For
Constant PATTERN_WHILE_STATEMENT as Integer is 807      Note: While condition: ... End While
Constant PATTERN_LOOP_STATEMENT as Integer is 808       Note: Loop: ... End Loop
Constant PATTERN_RETURN_STATEMENT as Integer is 809     Note: Return value
Constant PATTERN_YIELD_STATEMENT as Integer is 810      Note: Yield value
Constant PATTERN_BREAK_STATEMENT as Integer is 811      Note: Break
Constant PATTERN_CONTINUE_STATEMENT as Integer is 812   Note: Continue

Note: Ownership Transfer Patterns (v0.0.8.5)
Constant PATTERN_MOVE_OWNERSHIP as Integer is 820       Note: Move value (transfer ownership)
Constant PATTERN_BORROW_REFERENCE as Integer is 821     Note: Borrow value (shared reference)
Constant PATTERN_MUTABLE_BORROW as Integer is 822       Note: Borrow mutable value

Note: ============================================================================
Note: Statement Pattern Structure
Note: ============================================================================

Type called "StatementPattern":
    pattern_type as Integer      Note: Pattern type constant (PATTERN_LET_STATEMENT, etc.)
    required_keywords as Integer Note: Array of required keyword token types
    keyword_count as Integer     Note: Number of required keywords
    has_colon_block as Integer   Note: Boolean: 1 if pattern requires : and block
    has_end_keyword as Integer   Note: Boolean: 1 if pattern requires "End ..." terminator
    allows_type_annotation as Integer Note: Boolean: 1 if pattern allows "as Type"
    requires_expression as Integer Note: Boolean: 1 if pattern requires expression
    ownership_semantic as Integer Note: Ownership semantics (move, borrow, none)

Type called "OwnershipContext":
    variable_name as Integer     Note: Pointer to variable name
    ownership_status as Integer  Note: 0=owned, 1=borrowed, 2=moved
    borrow_count as Integer      Note: Number of active borrows
    is_mutable as Integer        Note: Boolean: 1 if mutable, 0 if immutable
    declaration_line as Integer  Note: Line where variable declared
    last_use_line as Integer     Note: Line of last use

Note: ============================================================================
Note: Variable Declaration Pattern Recognition
Note: ============================================================================

Process called "recognize_let_pattern" takes lexer as Integer, let_token as Integer returns Integer:
    Note:
    Recognize Let statement pattern.
    Pattern: [Private] Let <identifier> [as <type>] be <expression>
    Returns StatementPattern pointer or 0 if malformed.
    :End Note

    Note: Verify let_token is TOKEN_LET (300)
    Let token_type be proc memory_get_int64 from Layout with let_token, 0
    If token_type is not equal to 300:
        Return 0  Note: Not a Let token
    End If

    Note: Create statement pattern for Let
    Let pattern be proc create_statement_pattern with PATTERN_LET_STATEMENT

    If pattern is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Configure Let pattern properties
    Note: Field 3 (offset 24): has_colon_block = 0 (Let statements don't have blocks)
    Let dummy1 be proc memory_set_int64 from Layout with pattern, 24, 0

    Note: Field 4 (offset 32): has_end_keyword = 0 (Let statements are single-line)
    Let dummy2 be proc memory_set_int64 from Layout with pattern, 32, 0

    Note: Field 5 (offset 40): allows_type_annotation = 1 (Let allows "as Type")
    Let dummy3 be proc memory_set_int64 from Layout with pattern, 40, 1

    Note: Field 6 (offset 48): requires_expression = 1 (Let requires expression after "be")
    Let dummy4 be proc memory_set_int64 from Layout with pattern, 48, 1

    Note: Field 7 (offset 56): ownership_semantic = 0 (standard ownership rules)
    Let dummy5 be proc memory_set_int64 from Layout with pattern, 56, 0

    Note: Lexer provides pattern structure
    Note: Parser will validate full syntax (identifier, "be" keyword, expression)
    Return pattern
End Process

Process called "recognize_set_pattern" takes lexer as Integer, set_token as Integer returns Integer:
    Note:
    Recognize Set statement pattern.
    Pattern: Set <assignable> to <expression>
    Returns StatementPattern pointer or 0 if malformed.
    :End Note

    Note: Verify set_token is TOKEN_SET (301)
    Let token_type be proc memory_get_int64 from Layout with set_token, 0
    If token_type is not equal to 301:
        Return 0
    End If

    Note: Create statement pattern for Set
    Let pattern be proc create_statement_pattern with PATTERN_SET_STATEMENT

    If pattern is equal to 0:
        Return 0
    End If

    Note: Configure Set pattern properties
    Let dummy1 be proc memory_set_int64 from Layout with pattern, 24, 0  Note: has_colon_block = 0
    Let dummy2 be proc memory_set_int64 from Layout with pattern, 32, 0  Note: has_end_keyword = 0
    Let dummy3 be proc memory_set_int64 from Layout with pattern, 40, 0  Note: allows_type_annotation = 0
    Let dummy4 be proc memory_set_int64 from Layout with pattern, 48, 1  Note: requires_expression = 1

    Return pattern
End Process

Process called "recognize_define_pattern" takes lexer as Integer, define_token as Integer returns Integer:
    Note:
    Recognize Define statement pattern.
    Pattern: Define <identifier> [as <type>] as <expression>
    Returns StatementPattern pointer or 0 if malformed.
    :End Note

    Note: Verify define_token is TOKEN_DEFINE (302)
    Let token_type be proc memory_get_int64 from Layout with define_token, 0
    If token_type is not equal to 302:
        Return 0
    End If

    Let pattern be proc create_statement_pattern with PATTERN_DEFINE_STATEMENT

    If pattern is equal to 0:
        Return 0
    End If

    Note: Configure Define pattern properties
    Let dummy1 be proc memory_set_int64 from Layout with pattern, 24, 0  Note: has_colon_block = 0
    Let dummy2 be proc memory_set_int64 from Layout with pattern, 32, 0  Note: has_end_keyword = 0
    Let dummy3 be proc memory_set_int64 from Layout with pattern, 40, 1  Note: allows_type_annotation = 1
    Let dummy4 be proc memory_set_int64 from Layout with pattern, 48, 1  Note: requires_expression = 1

    Return pattern
End Process

Note: ============================================================================
Note: Control Flow Pattern Recognition
Note: ============================================================================

Process called "recognize_if_pattern" takes lexer as Integer, if_token as Integer returns Integer:
    Note:
    Recognize If statement pattern.
    Pattern: If <condition>: ... End If
    Returns StatementPattern pointer or 0 if malformed.
    :End Note

    Note: Verify if_token is TOKEN_IF (310)
    Let token_type be proc memory_get_int64 from Layout with if_token, 0
    If token_type is not equal to 310:
        Return 0
    End If

    Let pattern be proc create_statement_pattern with PATTERN_IF_STATEMENT

    If pattern is equal to 0:
        Return 0
    End If

    Note: Configure If pattern properties (block statement)
    Let dummy1 be proc memory_set_int64 from Layout with pattern, 24, 1  Note: has_colon_block = 1
    Let dummy2 be proc memory_set_int64 from Layout with pattern, 32, 1  Note: has_end_keyword = 1 ("End If")
    Let dummy3 be proc memory_set_int64 from Layout with pattern, 40, 0  Note: allows_type_annotation = 0
    Let dummy4 be proc memory_set_int64 from Layout with pattern, 48, 1  Note: requires_expression = 1

    Return pattern
End Process

Process called "recognize_match_pattern" takes lexer as Integer, match_token as Integer returns Integer:
    Note:
    Recognize Match statement pattern.
    Pattern: Match <expression>: When ... End Match
    Returns StatementPattern pointer or 0 if malformed.
    :End Note

    Note: Verify match_token is TOKEN_MATCH (314)
    Let token_type be proc memory_get_int64 from Layout with match_token, 0
    If token_type is not equal to 314:
        Return 0
    End If

    Let pattern be proc create_statement_pattern with PATTERN_MATCH_STATEMENT

    If pattern is equal to 0:
        Return 0
    End If

    Note: Configure Match pattern properties (block statement with When arms)
    Let dummy1 be proc memory_set_int64 from Layout with pattern, 24, 1  Note: has_colon_block = 1
    Let dummy2 be proc memory_set_int64 from Layout with pattern, 32, 1  Note: has_end_keyword = 1 ("End Match")
    Let dummy3 be proc memory_set_int64 from Layout with pattern, 40, 0  Note: allows_type_annotation = 0
    Let dummy4 be proc memory_set_int64 from Layout with pattern, 48, 1  Note: requires_expression = 1

    Return pattern
End Process

Process called "recognize_for_pattern" takes lexer as Integer, for_token as Integer returns Integer:
    Note:
    Recognize For loop pattern.
    Pattern: For <variable> in <iterable>: ... End For
    Returns StatementPattern pointer or 0 if malformed.
    :End Note

    Note: Verify for_token is TOKEN_FOR (315)
    Let token_type be proc memory_get_int64 from Layout with for_token, 0
    If token_type is not equal to 315:
        Return 0
    End If

    Let pattern be proc create_statement_pattern with PATTERN_FOR_STATEMENT

    If pattern is equal to 0:
        Return 0
    End If

    Note: Configure For pattern properties (block statement)
    Let dummy1 be proc memory_set_int64 from Layout with pattern, 24, 1  Note: has_colon_block = 1
    Let dummy2 be proc memory_set_int64 from Layout with pattern, 32, 1  Note: has_end_keyword = 1 ("End For")
    Let dummy3 be proc memory_set_int64 from Layout with pattern, 40, 0  Note: allows_type_annotation = 0
    Let dummy4 be proc memory_set_int64 from Layout with pattern, 48, 1  Note: requires_expression = 1

    Return pattern
End Process

Process called "recognize_while_pattern" takes lexer as Integer, while_token as Integer returns Integer:
    Note:
    Recognize While loop pattern.
    Pattern: While <condition>: ... End While
    Returns StatementPattern pointer or 0 if malformed.
    :End Note

    Note: Verify while_token is TOKEN_WHILE (316)
    Let token_type be proc memory_get_int64 from Layout with while_token, 0
    If token_type is not equal to 316:
        Return 0
    End If

    Let pattern be proc create_statement_pattern with PATTERN_WHILE_STATEMENT

    If pattern is equal to 0:
        Return 0
    End If

    Note: Configure While pattern properties (block statement)
    Let dummy1 be proc memory_set_int64 from Layout with pattern, 24, 1  Note: has_colon_block = 1
    Let dummy2 be proc memory_set_int64 from Layout with pattern, 32, 1  Note: has_end_keyword = 1 ("End While")
    Let dummy3 be proc memory_set_int64 from Layout with pattern, 40, 0  Note: allows_type_annotation = 0
    Let dummy4 be proc memory_set_int64 from Layout with pattern, 48, 1  Note: requires_expression = 1

    Return pattern
End Process

Note: ============================================================================
Note: Ownership Pattern Recognition (v0.0.8.5)
Note: ============================================================================

Process called "detect_ownership_transfer" takes lexer as Integer, identifier_token as Integer returns Integer:
    Note:
    Detect if variable usage transfers ownership (move semantics).
    Returns OwnershipContext pointer if ownership transferred, 0 otherwise.
    :End Note

    Note: Ownership transfer detection is primarily a semantic analysis task
    Note: Lexer identifies potential transfer patterns:
    Note:   - Let/Set statements (assignment transfers ownership by default)
    Note:   - Return statements (returning value transfers ownership)
    Note:   - Function calls (depends on function signature - semantic analysis)

    Note: Get source and position to check context
    Let source be proc memory_get_int64 from Layout with lexer, 0
    Let position be proc memory_get_int64 from Layout with lexer, 8

    Note: Look for patterns indicating ownership transfer
    Note: Check if preceded by "Let" keyword (implies assignment/transfer)
    Note: Check if followed by assignment context

    Note: At lexical level, we mark potential ownership transfers
    Note: Full ownership transfer analysis requires semantic context (type info, function signatures)
    Note: Parser and semantic analyzer will make final determination

    Note: Get identifier name from token
    Let identifier_ptr be proc memory_get_int64 from Layout with identifier_token, 8

    Note: Create ownership context marking as potentially moved
    Let context be proc create_ownership_context with identifier_ptr

    If context is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Mark as moved (ownership_status = 2)
    Note: Semantic analyzer will confirm or revise based on full context
    Let dummy be proc memory_set_int64 from Layout with context, 8, 2

    Return context
End Process

Process called "detect_borrow_pattern" takes lexer as Integer, identifier_token as Integer returns Integer:
    Note:
    Detect if variable is being borrowed (reference semantics).
    Returns OwnershipContext pointer if borrowed, 0 otherwise.
    :End Note

    Note: Borrow pattern detection looks for & symbol
    Note: Get source and position
    Let source be proc memory_get_int64 from Layout with lexer, 0
    Let position be proc memory_get_int64 from Layout with lexer, 8

    Note: Check for & symbol (ASCII 38) indicating borrow
    Let current_char be proc memory_get_byte from StringCore with source, position

    If current_char is not equal to 38:  Note: Not '&'
        Return 0  Note: Not a borrow pattern
    End If

    Note: Found borrow operator &
    Note: Check if mutable borrow: "& mutable"
    Let next_pos be position plus 1
    Let is_mutable_borrow be 0

    Note: Skip whitespace after & to check for "mutable" keyword
    Let check_pos be next_pos
    Let max_scan be 10
    Let scan_count be 0

    While scan_count is less than max_scan:
        Let check_char be proc memory_get_byte from StringCore with source, check_pos

        Note: Check if whitespace (space=32, tab=9, newline=10, carriage return=13)
        If check_char is equal to 32:
            Set check_pos to check_pos plus 1
            Set scan_count to scan_count plus 1
        Otherwise:
            If check_char is equal to 9:
                Set check_pos to check_pos plus 1
                Set scan_count to scan_count plus 1
            Otherwise:
                If check_char is equal to 10:
                    Set check_pos to check_pos plus 1
                    Set scan_count to scan_count plus 1
                Otherwise:
                    If check_char is equal to 13:
                        Set check_pos to check_pos plus 1
                        Set scan_count to scan_count plus 1
                    Otherwise:
                        Note: Non-whitespace found, break
                        Set scan_count to max_scan
                    End If
                End If
            End If
        End If
    End While

    Note: Extract word starting at check_pos to see if it's "mutable"
    Note: "mutable" has 7 characters
    Let word_length be 0
    Let mutable_str be "mutable"
    Let matches be 1

    While word_length is less than 7:
        Let source_char be proc memory_get_byte from StringCore with source, check_pos plus word_length
        Let expected_char be proc memory_get_byte from StringCore with mutable_str, word_length

        If source_char is not equal to expected_char:
            Set matches to 0
            Set word_length to 7  Note: Break
        Otherwise:
            Set word_length to word_length plus 1
        End If
    End While

    Note: If "mutable" keyword found, mark as mutable borrow
    If matches is equal to 1:
        Set is_mutable_borrow to 1
    End If

    Note: Get identifier from token
    Let identifier_ptr be proc memory_get_int64 from Layout with identifier_token, 8

    Note: Create ownership context for borrowed variable
    Let context be proc create_ownership_context with identifier_ptr

    If context is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Mark as borrowed (ownership_status = 1)
    Let dummy1 be proc memory_set_int64 from Layout with context, 8, 1

    Note: Increment borrow count
    Let dummy2 be proc memory_set_int64 from Layout with context, 16, 1

    Note: Set mutability based on "mutable" keyword detection
    Let dummy3 be proc memory_set_int64 from Layout with context, 24, is_mutable_borrow

    Return context
End Process

Process called "track_variable_ownership" takes variable_name as Integer, ownership_context as Integer returns Integer:
    Note:
    Track ownership state for a variable.
    Updates ownership context and validates ownership rules.
    Returns 1 on success, 0 on ownership violation.
    :End Note

    Note: Get current ownership status from context
    Let ownership_status be proc memory_get_int64 from Layout with ownership_context, 8
    Let borrow_count be proc memory_get_int64 from Layout with ownership_context, 16
    Let is_mutable be proc memory_get_int64 from Layout with ownership_context, 24

    Note: Ownership validation rules for v0.0.8.5:
    Note: 1. Cannot use variable after it has been moved (ownership_status = 2)
    Note: 2. Cannot have mutable borrow while other borrows active
    Note: 3. Cannot have multiple mutable borrows simultaneously

    Note: Check for use-after-move error
    If ownership_status is equal to 2:  Note: 2 = moved
        Note: Error: Variable used after ownership transferred
        Return 0
    End If

    Note: Check for conflicting borrows
    If ownership_status is equal to 1:  Note: 1 = borrowed
        Note: If mutable borrow exists, no other borrows allowed
        If is_mutable is equal to 1:
            If borrow_count is greater than 1:
                Note: Error: Mutable borrow conflicts with other borrows
                Return 0
            End If
        End If
    End If

    Note: Ownership tracking pattern is valid
    Note: Tracking table updates are handled by parser/semantic analyzer
    Note: Lexer validates patterns and reports syntax issues
    Return 1
End Process

Note: ============================================================================
Note: Statement Validation
Note: ============================================================================

Process called "validate_statement_completeness" takes pattern as Integer, lexer as Integer returns Integer:
    Note:
    Validate that statement pattern is complete and well-formed.
    Performs comprehensive validation of pattern structure.
    Returns 1 if valid, 0 if errors found.
    :End Note

    Note: Get pattern fields
    Let pattern_type be proc memory_get_int64 from Layout with pattern, 0
    Let has_colon_block be proc memory_get_int64 from Layout with pattern, 24
    Let has_end_keyword be proc memory_get_int64 from Layout with pattern, 32
    Let requires_expression be proc memory_get_int64 from Layout with pattern, 48

    Note: Basic validation - pattern must have valid type
    If pattern_type is less than 800:
        Return 0  Note: Invalid pattern type
    End If

    If pattern_type is greater than 822:
        Return 0  Note: Invalid pattern type
    End If

    Note: Lexer-level validation is basic - parser will do detailed validation
    Note: At lexer stage, we primarily ensure tokens exist and are in reasonable order
    Note: Full structural validation happens during parsing phase

    Note: For patterns requiring expression, ensure non-zero lexer position
    Note: (Expression validation is parser's responsibility)
    If requires_expression is equal to 1:
        Let position be proc memory_get_int64 from Layout with lexer, 8
        If position is equal to 0:
            Return 0  Note: No tokens for expression
        End If
    End If

    Note: Statement appears structurally valid at lexical level
    Return 1
End Process

Process called "detect_common_statement_errors" takes pattern as Integer, lexer as Integer returns Integer:
    Note:
    Detect common statement syntax errors.
    Returns number of errors detected (lexer reports errors via error context).
    :End Note

    Let error_count be 0
    Let pattern_type be proc memory_get_int64 from Layout with pattern, 0

    Note: Get source and position for error checking
    Let source be proc memory_get_int64 from Layout with lexer, 0
    Let position be proc memory_get_int64 from Layout with lexer, 8

    Note: Common error: Using = instead of "be" or "to"
    Note: Check for = character (ASCII 61) in inappropriate context
    Let current_char be proc memory_get_byte from StringCore with source, position
    If current_char is equal to 61:  Note: '='
        Note: Assignment operator = found where keyword expected
        Note: Pattern-specific suggestions:
        If pattern_type is equal to 800:  Note: PATTERN_LET_STATEMENT
            Note: Error: "Let x = value" should be "Let x be value"
            Set error_count to error_count plus 1
        End If

        If pattern_type is equal to 801:  Note: PATTERN_SET_STATEMENT
            Note: Error: "Set x = value" should be "Set x to value"
            Set error_count to error_count plus 1
        End If

        If pattern_type is equal to 802:  Note: PATTERN_DEFINE_STATEMENT
            Note: Error: "Define X = value" should be "Define X as value"
            Set error_count to error_count plus 1
        End If
    End If

    Note: Additional errors are better detected by parser
    Note: Lexer primarily reports token-level issues
    Note: Parser handles structural issues (missing End, wrong keywords, etc.)

    Return error_count
End Process

Note: ============================================================================
Note: Utility Functions
Note: ============================================================================

Process called "create_statement_pattern" takes pattern_type as Integer returns Integer:
    Note:
    Create a new StatementPattern structure.
    Allocates and initializes with default values.
    Returns pattern pointer or 0 on allocation failure.
    :End Note

    Note: StatementPattern: 8 fields × 8 bytes = 64 bytes
    Note: Fields: pattern_type, required_keywords, keyword_count, has_colon_block,
    Note:         has_end_keyword, allows_type_annotation, requires_expression, ownership_semantic
    Let pattern_size be 64
    Let pattern be proc allocate from Layout with pattern_size

    If pattern is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Initialize fields
    Note: Field 0 (offset 0): pattern_type
    Let dummy1 be proc memory_set_int64 from Layout with pattern, 0, pattern_type

    Note: Field 1 (offset 8): required_keywords (null initially)
    Let dummy2 be proc memory_set_int64 from Layout with pattern, 8, 0

    Note: Field 2 (offset 16): keyword_count (0 initially)
    Let dummy3 be proc memory_set_int64 from Layout with pattern, 16, 0

    Note: Field 3 (offset 24): has_colon_block (default 0)
    Let dummy4 be proc memory_set_int64 from Layout with pattern, 24, 0

    Note: Field 4 (offset 32): has_end_keyword (default 0)
    Let dummy5 be proc memory_set_int64 from Layout with pattern, 32, 0

    Note: Field 5 (offset 40): allows_type_annotation (default 0)
    Let dummy6 be proc memory_set_int64 from Layout with pattern, 40, 0

    Note: Field 6 (offset 48): requires_expression (default 1 for most patterns)
    Let dummy7 be proc memory_set_int64 from Layout with pattern, 48, 1

    Note: Field 7 (offset 56): ownership_semantic (default 0 = no special semantics)
    Let dummy8 be proc memory_set_int64 from Layout with pattern, 56, 0

    Return pattern
End Process

Process called "create_ownership_context" takes variable_name as Integer returns Integer:
    Note:
    Create a new OwnershipContext for a variable.
    Initializes with default ownership state: owned, no borrows, immutable.
    Returns context pointer or 0 on allocation failure.
    :End Note

    Note: OwnershipContext: 6 fields × 8 bytes = 48 bytes
    Note: Fields: variable_name, ownership_status, borrow_count, is_mutable, declaration_line, last_use_line
    Let context_size be 48
    Let context be proc allocate from Layout with context_size

    If context is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Initialize ownership context
    Note: Field 0 (offset 0): variable_name
    Let dummy1 be proc memory_set_int64 from Layout with context, 0, variable_name

    Note: Field 1 (offset 8): ownership_status (0 = owned)
    Let dummy2 be proc memory_set_int64 from Layout with context, 8, 0

    Note: Field 2 (offset 16): borrow_count (0 initially)
    Let dummy3 be proc memory_set_int64 from Layout with context, 16, 0

    Note: Field 3 (offset 24): is_mutable (0 = immutable by default)
    Let dummy4 be proc memory_set_int64 from Layout with context, 24, 0

    Note: Field 4 (offset 32): declaration_line (0 initially, set by caller)
    Let dummy5 be proc memory_set_int64 from Layout with context, 32, 0

    Note: Field 5 (offset 40): last_use_line (0 initially)
    Let dummy6 be proc memory_set_int64 from Layout with context, 40, 0

    Return context
End Process

Process called "pattern_type_to_string" takes pattern_type as Integer returns Integer:
    Note:
    Convert pattern type constant to readable string.
    Returns pointer to pattern name or "Unknown pattern".
    :End Note

    Note: Statement patterns (800-812)
    If pattern_type is equal to 800:
        Return "Let statement"
    End If
    If pattern_type is equal to 801:
        Return "Set statement"
    End If
    If pattern_type is equal to 802:
        Return "Define statement"
    End If
    If pattern_type is equal to 803:
        Return "If statement"
    End If
    If pattern_type is equal to 804:
        Return "Otherwise statement"
    End If
    If pattern_type is equal to 805:
        Return "Match statement"
    End If
    If pattern_type is equal to 806:
        Return "For statement"
    End If
    If pattern_type is equal to 807:
        Return "While statement"
    End If
    If pattern_type is equal to 808:
        Return "Loop statement"
    End If
    If pattern_type is equal to 809:
        Return "Return statement"
    End If
    If pattern_type is equal to 810:
        Return "Yield statement"
    End If
    If pattern_type is equal to 811:
        Return "Break statement"
    End If
    If pattern_type is equal to 812:
        Return "Continue statement"
    End If

    Note: Ownership patterns (820-822)
    If pattern_type is equal to 820:
        Return "Move ownership"
    End If
    If pattern_type is equal to 821:
        Return "Borrow reference"
    End If
    If pattern_type is equal to 822:
        Return "Mutable borrow"
    End If

    Note: Unknown pattern type
    Return "Unknown pattern"
End Process
