Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles literal value recognition and tokenization in Runa.

This file performs the following tasks:
- Recognize and tokenize string literals (single and double quoted, raw, formatted)
- Process numeric literals (integers, floats, hex, octal, binary, scientific notation)
- Handle boolean literals (true, false)
- Process null literals (null, none, nil)
- Support string interpolation for formatted strings - v0.0.8.5 feature

This file is essential because of the following reasons:
- Literals are fundamental data types in Runa programs
- Proper literal handling ensures correct value representation and type safety
- Literal tokenization is required for accurate semantic analysis and code generation
- String interpolation is a core v0.0.8.5 feature requirement

This file consists of the following functions/features/operation types:
- String literal parsing with escape sequence handling
- Numeric literal recognition with multiple base support
- Boolean and null literal processing
- Formatted string (interpolation) tokenization
- Literal value validation and type inference

Dependencies:
- Imports core/string_core.runa for string manipulation
- Imports constants/literal.runa for literal constant definitions
- Imports memory/layout.runa for Token structure allocation
:End Note

Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/constants/literal.runa" as LiteralConstants
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/lexical/encasing_handler.runa" as CasingHandler

Note: ============================================================================
Note: Token Type Constants for Literals
Note: ============================================================================

Note: These constants define the token types for different literal values
Note: Used in Token.token_type field to identify literal kind

Note: String literal types
Constant TOKEN_STRING_LITERAL as Integer is 100
Constant TOKEN_RAW_STRING_LITERAL as Integer is 101
Constant TOKEN_FORMATTED_STRING_LITERAL as Integer is 102

Note: Numeric literal types
Constant TOKEN_INTEGER_LITERAL as Integer is 110
Constant TOKEN_FLOAT_LITERAL as Integer is 111
Constant TOKEN_HEX_LITERAL as Integer is 112
Constant TOKEN_BINARY_LITERAL as Integer is 113
Constant TOKEN_OCTAL_LITERAL as Integer is 114

Note: Boolean literal types
Constant TOKEN_BOOLEAN_TRUE as Integer is 120
Constant TOKEN_BOOLEAN_FALSE as Integer is 121

Note: Null literal types
Constant TOKEN_NULL as Integer is 130
Constant TOKEN_NONE as Integer is 131
Constant TOKEN_NIL as Integer is 132

Note: Character literal type
Constant TOKEN_CHARACTER_LITERAL as Integer is 140

Note: ============================================================================
Note: Token Structure for Literal Values
Note: ============================================================================

Type called "Token":
    token_type as Integer      Note: Type identifier (TOKEN_STRING_LITERAL, TOKEN_INTEGER_LITERAL, etc.)
    value as Integer           Note: Pointer to token value string or numeric representation
    line as Integer            Note: Line number where token starts (1-indexed)
    column as Integer          Note: Column number where token starts (1-indexed)
    length as Integer          Note: Total length of token in source code
    literal_metadata as Integer Note: Pointer to additional literal-specific metadata

Note: Literal metadata structure for additional information
Type called "LiteralMetadata":
    base as Integer            Note: Numeric base (2, 8, 10, 16) for integer literals
    has_underscores as Integer Note: Boolean: 1 if literal contains underscore separators
    quote_style as Integer     Note: Quote character used (34 for ", 39 for ')
    is_raw as Integer          Note: Boolean: 1 if raw string (r"...")
    is_formatted as Integer    Note: Boolean: 1 if formatted string (f"...")
    escape_count as Integer    Note: Number of escape sequences in string

Note: ============================================================================
Note: String Literal Tokenization
Note: ============================================================================

Process called "tokenize_string_literal" takes lexer as Integer, start_pos as Integer, start_line as Integer, start_column as Integer returns Integer:
    Note:
    Tokenize string literal with full support for normal, raw, and formatted strings.
    Handles escape sequences, interpolation, and multi-line strings.
    Returns Token pointer or 0 on error.
    :End Note

    Note: Get source code from lexer (offset 0)
    Let source be proc memory_get_int64 from Layout with lexer, 0

    Note: Detect string prefix (r for raw, f for formatted)
    Let is_raw be 0
    Let is_formatted be 0
    Let quote_start be start_pos

    Let prefix_char be proc memory_get_byte from StringCore with source, start_pos

    Note: Check for r or f prefix
    If prefix_char is equal to 114:  Note: ASCII 'r'
        Set is_raw to 1
        Set quote_start to start_pos plus 1
    End If

    If prefix_char is equal to 102:  Note: ASCII 'f'
        Set is_formatted to 1
        Set quote_start to start_pos plus 1
    End If

    Note: Get opening quote character
    Let quote_char be proc memory_get_byte from StringCore with source, quote_start

    Note: Check for valid quote (" or ')
    If quote_char is not equal to 34:  Note: Not "
        If quote_char is not equal to 39:  Note: Not '
            Return 0  Note: Not a string literal
        End If
    End If

    Note: Scan for closing quote
    Let current_pos be quote_start plus 1
    Let string_start be current_pos
    Let found_end be 0
    Let escape_count be 0

    While found_end is equal to 0:
        Let current_char be proc memory_get_byte from StringCore with source, current_pos

        Note: Check for end of source
        If current_char is equal to 0:
            Return 0  Note: Unterminated string
        End If

        Note: Check for closing quote
        If current_char is equal to quote_char:
            Set found_end to 1
        End If

        Note: Handle escape sequences (if not raw)
        If is_raw is equal to 0:
            If current_char is equal to 92:  Note: Backslash
                Set escape_count to escape_count plus 1
                Set current_pos to current_pos plus 1  Note: Skip next character
            End If
        End If

        Set current_pos to current_pos plus 1
    End While

    Note: Extract string content
    Let string_length be current_pos minus string_start minus 1
    Let raw_content be proc allocate from Layout with string_length plus 1

    Let i be 0
    While i is less than string_length:
        Let char_val be proc memory_get_byte from StringCore with source, string_start plus i
        Let dummy1 be proc memory_set_byte from StringCore with raw_content, i, char_val
        Set i to i plus 1
    End While

    Let dummy2 be proc memory_set_byte from StringCore with raw_content, string_length, 0

    Note: Process escape sequences if not raw
    Let processed_content be raw_content
    If is_raw is equal to 0:
        If escape_count is greater than 0:
            Set processed_content to proc process_escape_sequences with raw_content, string_length
        End If
    End If

    Note: Determine token type
    Let token_type be TOKEN_STRING_LITERAL
    If is_raw is equal to 1:
        Set token_type to TOKEN_RAW_STRING_LITERAL
    End If
    If is_formatted is equal to 1:
        Set token_type to TOKEN_FORMATTED_STRING_LITERAL
    End If

    Note: Create metadata
    Let metadata be proc create_literal_metadata with 0, 0, quote_char, is_raw, is_formatted, escape_count

    Note: Calculate total length
    Let total_length be current_pos minus start_pos

    Note: Create token
    Let token be proc create_literal_token with token_type, processed_content, start_line, start_column, total_length, metadata

    Return token
End Process

Process called "process_escape_sequences" takes raw_string as Integer, string_length as Integer returns Integer:
    Note:
    Process escape sequences in string literal.
    Converts \n, \t, \r, \\, \", \', \u{XXXX} to actual bytes.
    Returns new allocated string or 0 on invalid sequence.
    :End Note

    Note: Allocate processed string (max same size as raw)
    Let processed be proc allocate from Layout with string_length plus 1

    Let src_i be 0
    Let dst_i be 0

    While src_i is less than string_length:
        Let current_char be proc memory_get_byte from StringCore with raw_string, src_i

        Note: Check for escape sequence
        If current_char is equal to 92:  Note: Backslash
            Set src_i to src_i plus 1
            Let escape_char be proc memory_get_byte from StringCore with raw_string, src_i

            Note: Convert escape sequence
            If escape_char is equal to 110:  Note: 'n'
                Let dummy1 be proc memory_set_byte from StringCore with processed, dst_i, 10  Note: Newline
            End If
            If escape_char is equal to 116:  Note: 't'
                Let dummy2 be proc memory_set_byte from StringCore with processed, dst_i, 9  Note: Tab
            End If
            If escape_char is equal to 114:  Note: 'r'
                Let dummy3 be proc memory_set_byte from StringCore with processed, dst_i, 13  Note: CR
            End If
            If escape_char is equal to 92:  Note: '\'
                Let dummy4 be proc memory_set_byte from StringCore with processed, dst_i, 92  Note: Backslash
            End If
            If escape_char is equal to 34:  Note: '"'
                Let dummy5 be proc memory_set_byte from StringCore with processed, dst_i, 34  Note: Double quote
            End If
            If escape_char is equal to 39:  Note: Single quote
                Let dummy6 be proc memory_set_byte from StringCore with processed, dst_i, 39  Note: Single quote
            End If

            Set dst_i to dst_i plus 1
            Set src_i to src_i plus 1
        Otherwise:
            Let dummy7 be proc memory_set_byte from StringCore with processed, dst_i, current_char
            Set dst_i to dst_i plus 1
            Set src_i to src_i plus 1
        End If
    End While

    Note: Null-terminate
    Let dummy8 be proc memory_set_byte from StringCore with processed, dst_i, 0

    Return processed
End Process

Process called "detect_interpolation_points" takes arena as Integer, format_string as Integer, string_length as Integer returns Integer:
    Note:
    Detect interpolation points in formatted string.
    Returns InterpolationContext pointer containing interpolation metadata.

    Parameters:
      arena - Arena for operation-scoped temporary allocation
      format_string - Formatted string content
      string_length - Length of string

    Returns:
      InterpolationContext pointer or 0 if no interpolations
    :End Note

    Note: Delegate to encasing_handler's detect_string_interpolation function
    Let interpolation_context be proc detect_string_interpolation from CasingHandler with arena, format_string, string_length

    Return interpolation_context
End Process

Note: ============================================================================
Note: Numeric Literal Tokenization
Note: ============================================================================

Process called "tokenize_numeric_literal" takes lexer as Integer, start_pos as Integer, start_line as Integer, start_column as Integer returns Integer:
    Note:
    Tokenize numeric literal with full base and format support.
    Handles decimal, hex, binary, octal, float, and scientific notation.
    Returns Token pointer or 0 on error.
    :End Note

    Note: Get source code from lexer
    Let source be proc memory_get_int64 from Layout with lexer, 0

    Let first_char be proc memory_get_byte from StringCore with source, start_pos
    Let second_char be proc memory_get_byte from StringCore with source, start_pos plus 1

    Note: Determine base
    Let base be 10
    Let token_type be TOKEN_INTEGER_LITERAL
    Let current_pos be start_pos
    Let has_underscores be 0
    Let is_float be 0

    Note: Check for base prefix
    If first_char is equal to 48:  Note: '0'
        If second_char is equal to 120:  Note: 'x' for hex
            Set base to 16
            Set token_type to TOKEN_HEX_LITERAL
            Set current_pos to start_pos plus 2
        End If
        If second_char is equal to 98:  Note: 'b' for binary
            Set base to 2
            Set token_type to TOKEN_BINARY_LITERAL
            Set current_pos to start_pos plus 2
        End If
        If second_char is equal to 111:  Note: 'o' for octal
            Set base to 8
            Set token_type to TOKEN_OCTAL_LITERAL
            Set current_pos to start_pos plus 2
        End If
    End If

    Note: Scan digits
    Let digit_start be current_pos
    Let scanning be 1

    While scanning is equal to 1:
        Let current_char be proc memory_get_byte from StringCore with source, current_pos

        Note: Check if valid digit for base
        Let is_valid be proc is_digit with current_char, base

        If is_valid is equal to 1:
            Set current_pos to current_pos plus 1
        Otherwise:
            Note: Check for underscore
            If current_char is equal to 95:  Note: '_'
                Set has_underscores to 1
                Set current_pos to current_pos plus 1
            Otherwise:
                Note: Check for decimal point (only for base 10)
                If current_char is equal to 46:  Note: '.'
                    If base is equal to 10:
                        Set is_float to 1
                        Set token_type to TOKEN_FLOAT_LITERAL
                        Set current_pos to current_pos plus 1
                    Otherwise:
                        Set scanning to 0
                    End If
                Otherwise:
                    Set scanning to 0
                End If
            End If
        End If
    End While

    Note: Extract number string
    Let num_length be current_pos minus start_pos
    Let num_string be proc allocate from Layout with num_length plus 1

    Let i be 0
    While i is less than num_length:
        Let char_val be proc memory_get_byte from StringCore with source, start_pos plus i
        Let dummy1 be proc memory_set_byte from StringCore with num_string, i, char_val
        Set i to i plus 1
    End While

    Let dummy2 be proc memory_set_byte from StringCore with num_string, num_length, 0

    Note: Create metadata
    Let metadata be proc create_literal_metadata with base, has_underscores, 0, 0, 0, 0

    Note: Create token
    Let token be proc create_literal_token with token_type, num_string, start_line, start_column, num_length, metadata

    Return token
End Process

Process called "validate_numeric_format" takes number_string as Integer, base as Integer, is_float as Integer returns Integer:
    Note:
    Validate numeric literal format rules.
    Checks digit validity, underscore placement, float format.
    Returns 1 if valid, 0 if invalid.
    :End Note

    Note: Get string length
    Let length be proc string_length from StringCore with number_string

    Note: Check each character
    Let i be 0
    Let prev_was_underscore be 0

    While i is less than length:
        Let current_char be proc memory_get_byte from StringCore with number_string, i

        Note: Check if valid digit for base
        Let is_valid be proc is_digit with current_char, base

        If is_valid is equal to 0:
            Note: Check if underscore
            If current_char is not equal to 95:  Note: Not '_'
                Note: Check if decimal point (only valid for floats)
                If current_char is not equal to 46:  Note: Not '.'
                    Return 0  Note: Invalid character
                End If
            End If

            Note: Check for consecutive underscores
            If current_char is equal to 95:
                If prev_was_underscore is equal to 1:
                    Return 0  Note: Consecutive underscores
                End If
                Set prev_was_underscore to 1
            Otherwise:
                Set prev_was_underscore to 0
            End If
        Otherwise:
            Set prev_was_underscore to 0
        End If

        Set i to i plus 1
    End While

    Return 1
End Process

Note: ============================================================================
Note: Boolean and Null Literal Tokenization
Note: ============================================================================

Process called "tokenize_boolean_literal" takes lexer as Integer, start_pos as Integer, start_line as Integer, start_column as Integer, is_true as Integer returns Integer:
    Note:
    Tokenize boolean literal (true or false).
    Returns Token pointer with appropriate type and value.
    :End Note

    Note: Determine token type and value
    Let token_type be TOKEN_BOOLEAN_TRUE
    Let value_string be "true"
    Let length be 4

    If is_true is equal to 0:
        Set token_type to TOKEN_BOOLEAN_FALSE
        Set value_string to "false"
        Set length to 5
    End If

    Note: Create token (no metadata needed for booleans)
    Let token be proc create_literal_token with token_type, value_string, start_line, start_column, length, 0

    Return token
End Process

Process called "tokenize_null_literal" takes lexer as Integer, start_pos as Integer, start_line as Integer, start_column as Integer, null_variant as Integer returns Integer:
    Note:
    Tokenize null literal (null, none, or nil).
    Returns Token pointer with appropriate variant type.
    :End Note

    Note: Determine token type, value, and length based on variant
    Let token_type be TOKEN_NULL
    Let value_string be "null"
    Let length be 4

    If null_variant is equal to 1:
        Set token_type to TOKEN_NONE
        Set value_string to "none"
        Set length to 4
    End If

    If null_variant is equal to 2:
        Set token_type to TOKEN_NIL
        Set value_string to "nil"
        Set length to 3
    End If

    Note: Create token (no metadata needed for null)
    Let token be proc create_literal_token with token_type, value_string, start_line, start_column, length, 0

    Return token
End Process

Note: ============================================================================
Note: Character Literal Tokenization
Note: ============================================================================

Process called "tokenize_character_literal" takes lexer as Integer, start_pos as Integer, start_line as Integer, start_column as Integer returns Integer:
    Note:
    Tokenize character literal with escape sequence support.
    Returns Token pointer or 0 on error.
    :End Note

    Note: Get source code from lexer
    Let source be proc memory_get_int64 from Layout with lexer, 0

    Note: Character literal starts with single quote
    Let quote_char be proc memory_get_byte from StringCore with source, start_pos

    If quote_char is not equal to 39:  Note: Not single quote
        Return 0
    End If

    Note: Get character value
    Let char_pos be start_pos plus 1
    Let char_val be proc memory_get_byte from StringCore with source, char_pos
    Let escape_count be 0
    Let length be 3  Note: 'c'

    Note: Check for escape sequence
    If char_val is equal to 92:  Note: Backslash
        Set escape_count to 1
        Set length to 4  Note: '\n'
    End If

    Note: Check for closing quote
    Let close_pos be start_pos plus length minus 1
    Let close_quote be proc memory_get_byte from StringCore with source, close_pos

    If close_quote is not equal to 39:
        Return 0  Note: Unclosed character literal
    End If

    Note: Extract character value
    Let char_length be length minus 2  Note: Without quotes
    Let char_string be proc allocate from Layout with char_length plus 1

    Let i be 0
    While i is less than char_length:
        Let byte_val be proc memory_get_byte from StringCore with source, char_pos plus i
        Let dummy1 be proc memory_set_byte from StringCore with char_string, i, byte_val
        Set i to i plus 1
    End While

    Let dummy2 be proc memory_set_byte from StringCore with char_string, char_length, 0

    Note: Create metadata
    Let metadata be proc create_literal_metadata with 0, 0, 39, 0, 0, escape_count

    Note: Create token
    Let token be proc create_literal_token with TOKEN_CHARACTER_LITERAL, char_string, start_line, start_column, length, metadata

    Return token
End Process

Note: ============================================================================
Note: Literal Validation and Utility Functions
Note: ============================================================================

Process called "is_digit" takes character as Integer, base as Integer returns Integer:
    Note:
    Check if character is valid digit for given base.
    Returns 1 if valid, 0 otherwise.
    :End Note

    Note: Binary (base 2): 0-1
    If base is equal to 2:
        If character is greater than or equal to 48:  Note: '0'
            If character is less than or equal to 49:  Note: '1'
                Return 1
            End If
        End If
        Return 0
    End If

    Note: Octal (base 8): 0-7
    If base is equal to 8:
        If character is greater than or equal to 48:  Note: '0'
            If character is less than or equal to 55:  Note: '7'
                Return 1
            End If
        End If
        Return 0
    End If

    Note: Decimal (base 10): 0-9
    If base is equal to 10:
        If character is greater than or equal to 48:  Note: '0'
            If character is less than or equal to 57:  Note: '9'
                Return 1
            End If
        End If
        Return 0
    End If

    Note: Hexadecimal (base 16): 0-9, A-F, a-f
    If base is equal to 16:
        Note: 0-9
        If character is greater than or equal to 48:
            If character is less than or equal to 57:
                Return 1
            End If
        End If

        Note: A-F
        If character is greater than or equal to 65:
            If character is less than or equal to 70:
                Return 1
            End If
        End If

        Note: a-f
        If character is greater than or equal to 97:
            If character is less than or equal to 102:
                Return 1
            End If
        End If

        Return 0
    End If

    Return 0
End Process

Process called "char_to_digit_value" takes character as Integer, base as Integer returns Integer:
    Note:
    Convert character digit to numeric value in given base.
    Returns 0-15 for hex, 0-9 for decimal, etc. Returns -1 if invalid.
    :End Note

    Note: Check if valid digit first
    Let is_valid be proc is_digit with character, base

    If is_valid is equal to 0:
        Return -1
    End If

    Note: 0-9 (ASCII 48-57)
    If character is greater than or equal to 48:
        If character is less than or equal to 57:
            Let value be character minus 48
            Return value
        End If
    End If

    Note: A-F (ASCII 65-70)
    If character is greater than or equal to 65:
        If character is less than or equal to 70:
            Let value be character minus 65 plus 10
            Return value
        End If
    End If

    Note: a-f (ASCII 97-102)
    If character is greater than or equal to 97:
        If character is less than or equal to 102:
            Let value be character minus 97 plus 10
            Return value
        End If
    End If

    Return -1
End Process

Process called "create_literal_token" takes token_type as Integer, value as Integer, line as Integer, column as Integer, length as Integer, metadata as Integer returns Integer:
    Note:
    Create and populate Token structure for literal value.
    Returns Token pointer or 0 on allocation failure.
    :End Note

    Note: Token: 6 fields × 8 bytes = 48 bytes
    Let token_size be 48
    Let token be proc allocate from Layout with token_size

    If token is equal to 0:
        Return 0
    End If

    Note: Populate fields: token_type, value, line, column, length, literal_metadata
    Let dummy1 be proc memory_set_int64 from Layout with token, 0, token_type
    Let dummy2 be proc memory_set_int64 from Layout with token, 8, value
    Let dummy3 be proc memory_set_int64 from Layout with token, 16, line
    Let dummy4 be proc memory_set_int64 from Layout with token, 24, column
    Let dummy5 be proc memory_set_int64 from Layout with token, 32, length
    Let dummy6 be proc memory_set_int64 from Layout with token, 40, metadata

    Return token
End Process

Process called "create_literal_metadata" takes base as Integer, has_underscores as Integer, quote_style as Integer, is_raw as Integer, is_formatted as Integer, escape_count as Integer returns Integer:
    Note:
    Create and populate LiteralMetadata structure.
    Returns metadata pointer or 0 on allocation failure.
    :End Note

    Note: LiteralMetadata: 6 fields × 8 bytes = 48 bytes
    Let metadata_size be 48
    Let metadata be proc allocate from Layout with metadata_size

    If metadata is equal to 0:
        Return 0
    End If

    Note: Populate fields: base, has_underscores, quote_style, is_raw, is_formatted, escape_count
    Let dummy1 be proc memory_set_int64 from Layout with metadata, 0, base
    Let dummy2 be proc memory_set_int64 from Layout with metadata, 8, has_underscores
    Let dummy3 be proc memory_set_int64 from Layout with metadata, 16, quote_style
    Let dummy4 be proc memory_set_int64 from Layout with metadata, 24, is_raw
    Let dummy5 be proc memory_set_int64 from Layout with metadata, 32, is_formatted
    Let dummy6 be proc memory_set_int64 from Layout with metadata, 40, escape_count

    Return metadata
End Process
