Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles general operators beyond mathematical symbols in Runa.

This file performs the following tasks:
- Recognize assignment operators (=, +=, -=, *=, /=, %=)
- Process ternary conditional operator (? :) for v0.0.8.5
- Handle member access operators (., ->)
- Process range operators (.., ..=)
- Handle special operators (typeof, sizeof, addressof)

This file is essential because of the following reasons:
- Assignment operators are fundamental to variable manipulation
- Ternary operator enables concise conditional expressions (v0.0.8.5 feature)
- Member access operators are critical for structure and object access
- Range operators enable slice and iteration syntax
- Special operators provide meta-programming capabilities

This file consists of the following functions/features/operation types:
- Assignment and compound assignment operator recognition
- Ternary operator parsing and validation
- Member access operator processing
- Range operator handling with inclusive/exclusive variants
- Special operator recognition and context validation

Dependencies:
- Imports math_symbols.runa for arithmetic operator context
- Imports keywords.runa for keyword operator disambiguation
- Imports memory/layout.runa for Token allocation
:End Note

Import "compiler/frontend/lexical/math_symbols.runa" as MathSymbols
Import "compiler/frontend/lexical/keywords.runa" as Keywords
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore

Note: ============================================================================
Note: Token Type Constants for General Operators
Note: ============================================================================

Note: Assignment Operators
Constant TOKEN_ASSIGN as Integer is 600          Note: = (simple assignment)
Constant TOKEN_PLUS_ASSIGN as Integer is 601     Note: += (add and assign)
Constant TOKEN_MINUS_ASSIGN as Integer is 602    Note: -= (subtract and assign)
Constant TOKEN_MUL_ASSIGN as Integer is 603      Note: *= (multiply and assign)
Constant TOKEN_DIV_ASSIGN as Integer is 604      Note: /= (divide and assign)
Constant TOKEN_MOD_ASSIGN as Integer is 605      Note: %= (modulo and assign)
Constant TOKEN_AND_ASSIGN as Integer is 606      Note: &= (bitwise and assign)
Constant TOKEN_OR_ASSIGN as Integer is 607       Note: |= (bitwise or assign)
Constant TOKEN_XOR_ASSIGN as Integer is 608      Note: ^= (bitwise xor assign)
Constant TOKEN_SHL_ASSIGN as Integer is 609      Note: <<= (shift left and assign)
Constant TOKEN_SHR_ASSIGN as Integer is 610      Note: >>= (shift right and assign)

Note: Ternary Operator (v0.0.8.5)
Constant TOKEN_QUESTION as Integer is 620        Note: ? (ternary condition)
Constant TOKEN_COLON_TERNARY as Integer is 621   Note: : (ternary separator)

Note: Member Access Operators
Constant TOKEN_DOT as Integer is 630             Note: . (member access)
Constant TOKEN_ARROW as Integer is 631           Note: -> (pointer member access)

Note: Range Operators
Constant TOKEN_RANGE as Integer is 640           Note: .. (exclusive range: 0..10)
Constant TOKEN_RANGE_INCLUSIVE as Integer is 641 Note: ..= (inclusive range: 0..=10)
Constant TOKEN_DOT_DOT_DOT as Integer is 642     Note: ... (rest/spread operator)

Note: Special Operators
Constant TOKEN_TYPEOF as Integer is 650          Note: typeof (type query)
Constant TOKEN_SIZEOF as Integer is 651          Note: sizeof (size query)
Constant TOKEN_ADDRESSOF as Integer is 652       Note: addressof (address query)
Constant TOKEN_AT as Integer is 653              Note: @ (type annotation marker)

Note: Optional/Null Handling Operators (v0.0.8.5)
Constant TOKEN_QUESTION_MARK as Integer is 660   Note: ? (optional chaining: obj?.field)
Constant TOKEN_NULLISH_COALESCE as Integer is 661 Note: ?? (nullish coalescing: a ?? b)
Constant TOKEN_OPTIONAL_CHAIN as Integer is 662  Note: ?. (optional chaining operator)

Note: ============================================================================
Note: Assignment Operator Recognition
Note: ============================================================================

Process called "tokenize_assignment_operator" takes lexer as Integer, first_char as Integer, start_line as Integer, start_column as Integer returns Integer:
    Note:
    Tokenize assignment or compound assignment operator.
    Handles =, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=.
    Returns Token pointer or 0 if not assignment operator.
    :End Note

    Note: Check for simple assignment =
    If first_char is equal to 61:  Note: '='
        Let token be proc create_operator_token with TOKEN_ASSIGN, "=", start_line, start_column, 1
        Return token
    End If

    Note: Get source and position from lexer to peek next char
    Let source be proc memory_get_int64 from Layout with lexer, 0
    Let position be proc memory_get_int64 from Layout with lexer, 16
    Let next_pos be position plus 1
    Let next_char be proc memory_get_byte from StringCore with source, next_pos

    Note: Check for compound assignment
    If next_char is equal to 61:  Note: Next is '='
        Let compound_type be proc recognize_compound_assignment with first_char, next_char

        If compound_type is not equal to 0:
            Note: Determine operator string
            Let op_string be ""
            Let length be 2

            If compound_type is equal to TOKEN_PLUS_ASSIGN:
                Set op_string to "+="
            End If
            If compound_type is equal to TOKEN_MINUS_ASSIGN:
                Set op_string to "-="
            End If
            If compound_type is equal to TOKEN_MUL_ASSIGN:
                Set op_string to "*="
            End If
            If compound_type is equal to TOKEN_DIV_ASSIGN:
                Set op_string to "/="
            End If
            If compound_type is equal to TOKEN_MOD_ASSIGN:
                Set op_string to "%="
            End If
            If compound_type is equal to TOKEN_AND_ASSIGN:
                Set op_string to "&="
            End If
            If compound_type is equal to TOKEN_OR_ASSIGN:
                Set op_string to "|="
            End If
            If compound_type is equal to TOKEN_XOR_ASSIGN:
                Set op_string to "^="
            End If

            Let token be proc create_operator_token with compound_type, op_string, start_line, start_column, length
            Return token
        End If
    End If

    Return 0
End Process

Process called "recognize_compound_assignment" takes operator_char as Integer, equals_char as Integer returns Integer:
    Note:
    Recognize compound assignment from operator + equals.
    Returns token type for compound assignment, or 0 if invalid.
    :End Note

    If equals_char is not equal to 61:  Note: Not '='
        Return 0
    End If

    If operator_char is equal to 43:  Note: '+'
        Return TOKEN_PLUS_ASSIGN
    End If
    If operator_char is equal to 45:  Note: '-'
        Return TOKEN_MINUS_ASSIGN
    End If
    If operator_char is equal to 42:  Note: '*'
        Return TOKEN_MUL_ASSIGN
    End If
    If operator_char is equal to 47:  Note: '/'
        Return TOKEN_DIV_ASSIGN
    End If
    If operator_char is equal to 37:  Note: '%'
        Return TOKEN_MOD_ASSIGN
    End If
    If operator_char is equal to 38:  Note: '&'
        Return TOKEN_AND_ASSIGN
    End If
    If operator_char is equal to 124:  Note: '|'
        Return TOKEN_OR_ASSIGN
    End If
    If operator_char is equal to 94:  Note: '^'
        Return TOKEN_XOR_ASSIGN
    End If

    Return 0
End Process

Process called "is_assignment_operator" takes token_type as Integer returns Integer:
    Note:
    Check if token type is assignment operator.
    Returns 1 if assignment operator (range 600-610), 0 otherwise.
    :End Note

    If token_type is greater than or equal to 600:
        If token_type is less than or equal to 610:
            Return 1
        End If
    End If

    Return 0
End Process

Note: ============================================================================
Note: Ternary Operator Recognition (v0.0.8.5)
Note: ============================================================================

Process called "tokenize_ternary_operator" takes lexer as Integer, operator_char as Integer, start_line as Integer, start_column as Integer returns Integer:
    Note:
    Tokenize ternary conditional operator (? or :).
    Returns Token pointer with appropriate type.
    :End Note

    Let token_type be 0
    Let op_string be ""

    If operator_char is equal to 63:  Note: '?'
        Set token_type to TOKEN_QUESTION
        Set op_string to "?"
    End If

    If operator_char is equal to 58:  Note: ':'
        Set token_type to TOKEN_COLON_TERNARY
        Set op_string to ":"
    End If

    If token_type is equal to 0:
        Return 0  Note: Invalid operator char
    End If

    Let token be proc create_operator_token with token_type, op_string, start_line, start_column, 1

    Return token
End Process

Process called "validate_ternary_syntax" takes question_token as Integer, colon_token as Integer, context as Integer returns Integer:
    Note:
    Validate ternary operator is properly formed.
    Checks for matching ? and : tokens.
    Returns 1 if valid, 0 if invalid.
    :End Note

    Note: Validate question_token is not null
    If question_token is equal to 0:
        Return 0
    End If

    Note: Validate colon_token is not null
    If colon_token is equal to 0:
        Return 0
    End If

    Note: Token structure: token_type (offset 0), value (8), line (16), column (24), length (32), metadata (40)

    Note: Get token types
    Let question_type be proc memory_get_int64 from Layout with question_token, 0
    Let colon_type be proc memory_get_int64 from Layout with colon_token, 0

    Note: Verify question token type is TOKEN_QUESTION (620)
    If question_type is not equal to 620:
        Return 0
    End If

    Note: Verify colon token type is TOKEN_COLON_TERNARY (621)
    If colon_type is not equal to 621:
        Return 0
    End If

    Note: Get line and column positions
    Let question_line be proc memory_get_int64 from Layout with question_token, 16
    Let question_column be proc memory_get_int64 from Layout with question_token, 24
    Let colon_line be proc memory_get_int64 from Layout with colon_token, 16
    Let colon_column be proc memory_get_int64 from Layout with colon_token, 24

    Note: Verify tokens are in correct order (question before colon)
    Note: Either question is on earlier line, or same line with earlier column
    If colon_line is less than question_line:
        Return 0  Note: Colon before question
    End If

    If colon_line is equal to question_line:
        If colon_column is less than or equal to question_column:
            Return 0  Note: Colon at or before question on same line
        End If
    End If

    Note: Validate positions are sensible (non-negative)
    If question_line is less than 1:
        Return 0
    End If
    If question_column is less than 1:
        Return 0
    End If
    If colon_line is less than 1:
        Return 0
    End If
    If colon_column is less than 1:
        Return 0
    End If

    Note: All validation passed
    Return 1
End Process

Note: ============================================================================
Note: Member Access Operator Recognition
Note: ============================================================================

Process called "tokenize_member_access" takes lexer as Integer, operator_char as Integer, start_line as Integer, start_column as Integer returns Integer:
    Note:
    Tokenize member access operator (. or ->).
    Handles dot and arrow operators with lookahead disambiguation.
    Returns Token pointer or 0 if not member access.
    :End Note

    Note: Get source from lexer (offset 0) and position (offset 8)
    Let source be proc memory_get_int64 from Layout with lexer, 0
    Let position be proc memory_get_int64 from Layout with lexer, 8

    Note: Handle dot operator (46)
    If operator_char is equal to 46:
        Note: Peek next character to check for range operator
        Let next_char be proc memory_get_byte from StringCore with source, position

        Note: If next is also dot, this is range operator, not member access
        If next_char is equal to 46:
            Return 0
        End If

        Note: Single dot is member access
        Let token be proc create_operator_token with TOKEN_DOT, ".", start_line, start_column, 1
        Return token
    End If

    Note: Handle arrow operator (->)
    If operator_char is equal to 45:  Note: '-'
        Note: Peek next character to check for >
        Let next_char be proc memory_get_byte from StringCore with source, position

        Note: If next is >, this is arrow operator
        If next_char is equal to 62:  Note: '>'
            Let token be proc create_operator_token with TOKEN_ARROW, "->", start_line, start_column, 2
            Return token
        End If

        Note: Just minus, not arrow
        Return 0
    End If

    Note: Not a member access operator
    Return 0
End Process

Note: ============================================================================
Note: Range Operator Recognition
Note: ============================================================================

Process called "tokenize_range_operator" takes lexer as Integer, start_line as Integer, start_column as Integer returns Integer:
    Note:
    Tokenize range operator (.. or ..=).
    Handles exclusive (..) and inclusive (..=) range operators.
    Returns Token pointer or 0 if not range operator.
    :End Note

    Note: Get source from lexer (offset 0) and position (offset 8)
    Let source be proc memory_get_int64 from Layout with lexer, 0
    Let position be proc memory_get_int64 from Layout with lexer, 8

    Note: Confirm current character is dot (46)
    Let current_char be proc memory_get_byte from StringCore with source, position
    If current_char is not equal to 46:
        Return 0
    End If

    Note: Peek next character - must be dot for range
    Let next_pos be position plus 1
    Let next_char be proc memory_get_byte from StringCore with source, next_pos

    If next_char is not equal to 46:
        Return 0  Note: Single dot, not range
    End If

    Note: We have .. - check for ... (rest/spread) or ..= (inclusive range)
    Let third_pos be position plus 2
    Let third_char be proc memory_get_byte from StringCore with source, third_pos

    Note: Check for rest/spread operator ...
    If third_char is equal to 46:  Note: '.' (third dot)
        Let token be proc create_operator_token with TOKEN_DOT_DOT_DOT, "...", start_line, start_column, 3
        Return token
    End If

    Note: Check for inclusive range ..=
    If third_char is equal to 61:  Note: '='
        Let token be proc create_operator_token with TOKEN_RANGE_INCLUSIVE, "..=", start_line, start_column, 3
        Return token
    End If

    Note: Exclusive range ..
    Let token be proc create_operator_token with TOKEN_RANGE, "..", start_line, start_column, 2
    Return token
End Process

Process called "is_range_operator" takes token_type as Integer returns Integer:
    Note:
    Check if token type is a range operator.
    Returns 1 for range operators, 0 otherwise.
    :End Note

    Note: TOKEN_RANGE = 640
    If token_type is equal to 640:
        Return 1
    End If

    Note: TOKEN_RANGE_INCLUSIVE = 641
    If token_type is equal to 641:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Special Operator Recognition
Note: ============================================================================

Process called "tokenize_special_operator" takes lexer as Integer, keyword as Integer, start_line as Integer, start_column as Integer returns Integer:
    Note:
    Tokenize special meta-programming operators.
    Handles typeof, sizeof, and addressof operators.
    Returns Token pointer or 0 if not special operator.
    :End Note

    Note: Compare keyword against special operator keywords
    Let is_typeof be proc strings_equal from StringCore with keyword, "typeof"
    If is_typeof is equal to 1:
        Let token be proc create_operator_token with TOKEN_TYPEOF, "typeof", start_line, start_column, 6
        Return token
    End If

    Let is_sizeof be proc strings_equal from StringCore with keyword, "sizeof"
    If is_sizeof is equal to 1:
        Let token be proc create_operator_token with TOKEN_SIZEOF, "sizeof", start_line, start_column, 6
        Return token
    End If

    Let is_addressof be proc strings_equal from StringCore with keyword, "addressof"
    If is_addressof is equal to 1:
        Let token be proc create_operator_token with TOKEN_ADDRESSOF, "addressof", start_line, start_column, 9
        Return token
    End If

    Note: Not a special operator
    Return 0
End Process

Process called "tokenize_at_operator" takes lexer as Integer, at_char as Integer, start_line as Integer, start_column as Integer returns Integer:
    Note:
    Tokenize @ (at) operator for type annotations.
    Handles @ symbol used in @ARC, @Owned, @Shared, etc.
    Returns Token pointer or 0 if not @ symbol.
    :End Note

    Note: Confirm current character is @ (ASCII 64)
    If at_char is not equal to 64:
        Return 0
    End If

    Note: Create TOKEN_AT token
    Let token be proc create_operator_token with TOKEN_AT, "@", start_line, start_column, 1
    Return token
End Process

Process called "is_special_operator" takes token_type as Integer returns Integer:
    Note:
    Check if token type is a special operator.
    Returns 1 for special operators, 0 otherwise.
    :End Note

    Note: TOKEN_TYPEOF = 650
    If token_type is equal to 650:
        Return 1
    End If

    Note: TOKEN_SIZEOF = 651
    If token_type is equal to 651:
        Return 1
    End If

    Note: TOKEN_ADDRESSOF = 652
    If token_type is equal to 652:
        Return 1
    End If

    Note: TOKEN_AT = 653
    If token_type is equal to 653:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Optional and Nullish Operators (v0.0.8.5)
Note: ============================================================================

Process called "tokenize_optional_operator" takes lexer as Integer, question_char as Integer, start_line as Integer, start_column as Integer returns Integer:
    Note:
    Tokenize optional chaining or nullish coalescing operator.
    Handles ?. (optional chaining) and ?? (nullish coalescing).
    Returns Token pointer or 0 if single ? (ternary).
    :End Note

    Note: Confirm current character is question mark (63)
    If question_char is not equal to 63:
        Return 0
    End If

    Note: Get source from lexer (offset 0) and position (offset 8)
    Let source be proc memory_get_int64 from Layout with lexer, 0
    Let position be proc memory_get_int64 from Layout with lexer, 8

    Note: Peek next character
    Let next_char be proc memory_get_byte from StringCore with source, position

    Note: Check for optional chaining ?.
    If next_char is equal to 46:  Note: '.'
        Let token be proc create_operator_token with TOKEN_OPTIONAL_CHAIN, "?.", start_line, start_column, 2
        Return token
    End If

    Note: Check for nullish coalescing ??
    If next_char is equal to 63:  Note: '?'
        Let token be proc create_operator_token with TOKEN_NULLISH_COALESCE, "??", start_line, start_column, 2
        Return token
    End If

    Note: Single ? is ternary operator, not optional operator
    Return 0
End Process

Note: ============================================================================
Note: Operator Utility Functions
Note: ============================================================================

Process called "get_operator_arity" takes token_type as Integer returns Integer:
    Note:
    Get the arity (number of operands) for an operator.
    Returns 1 (unary), 2 (binary), 3 (ternary), or 0 (unknown).
    :End Note

    Note: Ternary operators (620-621): ? :
    If token_type is greater than or equal to 620:
        If token_type is less than or equal to 621:
            Return 3
        End If
    End If

    Note: Member access operators (630-631): . ->
    If token_type is greater than or equal to 630:
        If token_type is less than or equal to 631:
            Return 2
        End If
    End If

    Note: Range operators (640-641): .. ..=
    If token_type is greater than or equal to 640:
        If token_type is less than or equal to 641:
            Return 2
        End If
    End If

    Note: Special operators (650-653): typeof sizeof addressof @
    If token_type is greater than or equal to 650:
        If token_type is less than or equal to 653:
            Return 1
        End If
    End If

    Note: Optional operators (660-662): ?. ?? ?.
    If token_type is greater than or equal to 660:
        If token_type is less than or equal to 662:
            Return 2
        End If
    End If

    Note: Assignment operators (600-611): = += -= *= /= %= &= |= ^= <<= >>=
    If token_type is greater than or equal to 600:
        If token_type is less than or equal to 611:
            Return 2
        End If
    End If

    Note: Unknown operator type
    Return 0
End Process

Process called "operator_type_to_string" takes token_type as Integer returns Integer:
    Note:
    Convert operator token type to readable string.
    Returns pointer to operator string or "UNKNOWN".
    :End Note

    Note: Assignment operators (600-611)
    If token_type is equal to 600:
        Return "="
    End If
    If token_type is equal to 601:
        Return "+="
    End If
    If token_type is equal to 602:
        Return "-="
    End If
    If token_type is equal to 603:
        Return "*="
    End If
    If token_type is equal to 604:
        Return "/="
    End If
    If token_type is equal to 605:
        Return "%="
    End If
    If token_type is equal to 606:
        Return "&="
    End If
    If token_type is equal to 607:
        Return "|="
    End If
    If token_type is equal to 608:
        Return "^="
    End If
    If token_type is equal to 609:
        Return "<<="
    End If
    If token_type is equal to 610:
        Return ">>="
    End If

    Note: Ternary operators (620-621)
    If token_type is equal to 620:
        Return "?"
    End If
    If token_type is equal to 621:
        Return ":"
    End If

    Note: Member access operators (630-631)
    If token_type is equal to 630:
        Return "."
    End If
    If token_type is equal to 631:
        Return "->"
    End If

    Note: Range operators (640-641)
    If token_type is equal to 640:
        Return ".."
    End If
    If token_type is equal to 641:
        Return "..="
    End If

    Note: Special operators (650-653)
    If token_type is equal to 650:
        Return "typeof"
    End If
    If token_type is equal to 651:
        Return "sizeof"
    End If
    If token_type is equal to 652:
        Return "addressof"
    End If
    If token_type is equal to 653:
        Return "@"
    End If

    Note: Optional operators (660-662)
    If token_type is equal to 660:
        Return "?."
    End If
    If token_type is equal to 661:
        Return "??"
    End If
    If token_type is equal to 662:
        Return "?."
    End If

    Note: Unknown operator type
    Return "UNKNOWN"
End Process

Process called "create_operator_token" takes token_type as Integer, operator_string as Integer, line as Integer, column as Integer, length as Integer returns Integer:
    Note:
    Create a token for a recognized operator.
    Allocates and populates Token structure with operator info.
    Returns Token pointer or 0 on allocation failure.
    :End Note

    Note: Token structure: 6 fields × 8 bytes = 48 bytes
    Note: Fields: token_type, value, line, column, length, metadata
    Let token_size be 48
    Let token be proc allocate from Layout with token_size

    If token is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Set token fields
    Note: Field 0 (offset 0): token_type
    Let dummy1 be proc memory_set_int64 from Layout with token, 0, token_type

    Note: Field 1 (offset 8): value (operator string)
    Let dummy2 be proc memory_set_int64 from Layout with token, 8, operator_string

    Note: Field 2 (offset 16): line
    Let dummy3 be proc memory_set_int64 from Layout with token, 16, line

    Note: Field 3 (offset 24): column
    Let dummy4 be proc memory_set_int64 from Layout with token, 24, column

    Note: Field 4 (offset 32): length
    Let dummy5 be proc memory_set_int64 from Layout with token, 32, length

    Note: Field 5 (offset 40): metadata (null for operators)
    Let dummy6 be proc memory_set_int64 from Layout with token, 40, 0

    Return token
End Process

Note: ============================================================================
Note: Operator Validation
Note: ============================================================================

Process called "validate_operator_context" takes operator_type as Integer, context as Integer returns Integer:
    Note:
    Validate that operator is used in appropriate context.
    Performs lexer-level sanity checks on operator placement.
    Returns 1 if valid context, 0 if invalid.
    :End Note

    Note: Context bit flags (offset 0): bit 0=has left operand, bit 1=at start, bit 2=at end
    Let has_left_operand be context bitwise and 1
    Let at_expression_start be context bitwise and 2
    Let at_expression_end be context bitwise and 4

    Note: Validate token type is in operator range (500-670)
    If operator_type is less than 500:
        Return 0  Note: Not an operator
    End If

    If operator_type is greater than 670:
        Return 0  Note: Out of operator range
    End If

    Note: Assignment operators (600-610) - Must have left operand, cannot be at start
    If operator_type is greater than or equal to 600:
        If operator_type is less than or equal to 610:
            Note: Assignment needs left operand
            If has_left_operand is equal to 0:
                Return 0
            End If
            Note: Assignment cannot be at expression start
            If at_expression_start is not equal to 0:
                Return 0
            End If
        End If
    End If

    Note: Ternary operators (620-621) - Cannot be at start or end
    If operator_type is greater than or equal to 620:
        If operator_type is less than or equal to 621:
            If at_expression_start is not equal to 0:
                Return 0
            End If
            If at_expression_end is not equal to 0:
                Return 0
            End If
        End If
    End If

    Note: Member access operators (630-631) - Must have left operand
    If operator_type is greater than or equal to 630:
        If operator_type is less than or equal to 631:
            If has_left_operand is equal to 0:
                Return 0
            End If
        End If
    End If

    Note: Range operators (640-641) - Need left operand for start of range
    If operator_type is greater than or equal to 640:
        If operator_type is less than or equal to 641:
            If has_left_operand is equal to 0:
                Return 0
            End If
        End If
    End If

    Note: Special operators (650-652) - Can be at start (unary)
    Note: typeof, sizeof, addressof are valid at expression start

    Note: Optional operators (660-662) - Need context checking
    If operator_type is greater than or equal to 660:
        If operator_type is less than or equal to 662:
            Note: Optional chaining needs left operand
            If operator_type is equal to 662:  Note: TOKEN_OPTIONAL_CHAIN
                If has_left_operand is equal to 0:
                    Return 0
                End If
            End If
            Note: Nullish coalescing needs left operand
            If operator_type is equal to 661:  Note: TOKEN_NULLISH_COALESCE
                If has_left_operand is equal to 0:
                    Return 0
                End If
            End If
        End If
    End If

    Note: Binary operators at expression end are invalid
    If at_expression_end is not equal to 0:
        Let is_binary be proc is_binary_operator_type with operator_type
        If is_binary is equal to 1:
            Return 0
        End If
    End If

    Note: Context validation passed
    Return 1
End Process

Process called "is_binary_operator_type" takes operator_type as Integer returns Integer:
    Note:
    Check if operator type represents a binary operator.
    Returns 1 for binary operators, 0 otherwise.
    :End Note

    Note: Assignment operators (600-610) - All binary
    If operator_type is greater than or equal to 600:
        If operator_type is less than or equal to 610:
            Return 1
        End If
    End If

    Note: Ternary colon (621) - Part of ternary, effectively binary in structure
    If operator_type is equal to 621:
        Return 1
    End If

    Note: Member access (630-631) - Binary
    If operator_type is greater than or equal to 630:
        If operator_type is less than or equal to 631:
            Return 1
        End If
    End If

    Note: Range operators (640-641) - Binary
    If operator_type is greater than or equal to 640:
        If operator_type is less than or equal to 641:
            Return 1
        End If
    End If

    Note: Nullish coalesce (661) and optional chain (662) - Binary
    If operator_type is equal to 661:
        Return 1
    End If
    If operator_type is equal to 662:
        Return 1
    End If

    Note: Not a binary operator (unary operators return 0)
    Return 0
End Process
