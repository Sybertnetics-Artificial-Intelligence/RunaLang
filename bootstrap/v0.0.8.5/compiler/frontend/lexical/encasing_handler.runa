Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles encasing syntax and string interpolation in Runa.

This file performs the following tasks:
- Process string interpolation for formatted strings (f"text {expr}")
- Handle variable name encasing ("Let variable name be value")
- Parse interpolation expressions within strings
- Manage nested brace tracking for complex interpolations
- Validate interpolation syntax and expression boundaries

This file is essential because of the following reasons:
- String interpolation is a core v0.0.8.5 feature for dynamic strings
- Encasing syntax enables Runa's natural language variable declarations
- Proper interpolation handling ensures correct expression parsing
- Nested interpolation support allows complex embedded expressions

This file consists of the following functions/features/operation types:
- String interpolation detection and tokenization
- Interpolation expression extraction and parsing
- Brace nesting tracking for nested expressions
- Encasing pattern recognition for variable declarations
- Interpolation validation and error recovery

Dependencies:
- Imports literals.runa for string literal handling
- Imports core/string_primitive.runa for string manipulation
- Imports memory/layout.runa for Token and structure allocation
:End Note

Import "compiler/frontend/lexical/literals.runa" as Literals
Import "compiler/frontend/primitives/core/string_primitive.runa" as StringPrimitive
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/internal/memory_utils.runa" as MemoryUtils
Import "compiler/internal/arena_utils.runa" as ArenaUtils
Import "runtime/io/console/console.runa" as Console
Import "runtime/io/console/format.runa" as Format

Note: ============================================================================
Note: Token Type Constants for Encasing and Interpolation
Note: ============================================================================

Constant TOKEN_INTERPOLATION_START as Integer is 700  Note: { inside formatted string
Constant TOKEN_INTERPOLATION_END as Integer is 701    Note: } inside formatted string
Constant TOKEN_INTERPOLATION_EXPR as Integer is 702   Note: Extracted expression from interpolation
Constant TOKEN_ENCASED_IDENTIFIER as Integer is 703   Note: Multi-word identifier in encasing

Note: Context-Dependent Tokens (recognized in specific syntactic positions)
Constant TOKEN_CTX_A as Integer is 710                Note: "a" in constructor syntax ("a value of type")
Constant TOKEN_CTX_VALUE as Integer is 711            Note: "value" in constructor syntax ("value of type")
Constant TOKEN_CTX_CONTAINING as Integer is 712       Note: "containing" in collection literals
Constant TOKEN_CTX_DICTIONARY as Integer is 713       Note: "dictionary" in dictionary literals
Constant TOKEN_CTX_LIST as Integer is 714             Note: "list" in list literals
Constant TOKEN_CTX_TIMES as Integer is 715            Note: "times" in loop repetition ("Repeat N times")
Constant TOKEN_CTX_WHERE as Integer is 716            Note: "where" in pattern guards
Constant TOKEN_CTX_CALLED as Integer is 717           Note: "called" in process definitions
Constant TOKEN_CTX_THAT as Integer is 718             Note: "that" in process signatures
Constant TOKEN_CTX_TAKES as Integer is 719            Note: "takes" in parameter lists
Constant TOKEN_CTX_FOREVER as Integer is 720          Note: "forever" in infinite loops
Constant TOKEN_CTX_THE as Integer is 721              Note: "the" in natural language phrases
Constant TOKEN_CTX_EACH as Integer is 722             Note: "each" in iteration syntax

Note: ============================================================================
Note: Interpolation Structure Definitions
Note: ============================================================================

Type called "InterpolationPoint":
    start_offset as Integer     Note: Position where { starts in string
    end_offset as Integer       Note: Position where } ends in string
    expression as Integer       Note: Pointer to extracted expression string
    expression_length as Integer Note: Length of expression string
    nesting_depth as Integer    Note: Depth of nested braces at this point
    line as Integer            Note: Line number of interpolation
    column as Integer          Note: Column number of interpolation

Type called "InterpolationContext":
    format_string as Integer    Note: Pointer to the full formatted string
    string_length as Integer    Note: Length of formatted string
    interpolation_points as Integer Note: Array of InterpolationPoint structures
    point_count as Integer      Note: Number of interpolation points found
    max_nesting_depth as Integer Note: Maximum brace nesting depth encountered
    has_nested_strings as Integer Note: Boolean: 1 if nested string literals found

Note: ============================================================================
Note: String Interpolation Detection
Note: ============================================================================

Process called "detect_string_interpolation" takes arena as Integer, format_string as Integer, string_length as Integer returns Integer:
    Note:
    Detect if string contains interpolation expressions

    Scans string for interpolation markers: {expr}
    Handles nested braces and string literals within expressions

    Parameters:
      arena - Arena for operation-scoped temporary allocation
      format_string - Pointer to formatted string content (without quotes)
      string_length - Length of format string

    Returns:
      Pointer to InterpolationContext structure if interpolations found
      Returns 0 if no interpolations present

    Memory Architecture Compliance:
      Uses arena for temporary depth_map allocation via track_brace_nesting
      Depth map is operation-scoped and cleaned up with arena
      No manual deallocation needed

    Algorithm:
    1. Scan string character by character
    2. Track brace nesting depth (open {, close })
    3. Identify interpolation boundaries (depth 1 braces)
    4. Extract expression text between braces
    5. Create InterpolationPoint for each interpolation
    6. Return InterpolationContext with all points

    Edge cases:
      - Escaped braces: \{ and \} are not interpolation markers
      - Nested braces: {dict["key"]} requires tracking depth
      - String literals in expressions: {"text" if x else "other"}
      - Empty interpolations: {} is invalid, report error
    :End Note

    If arena is equal to 0:
        Return 0  Note: Arena required
    End If

    Note: Build depth map for the string using arena
    Let depth_map be proc track_brace_nesting with arena, format_string, string_length

    If depth_map is equal to 0:
        Return 0
    End If

    Note: First pass: count interpolation points
    Let point_count be 0
    Let i be 0
    Let open_brace be 123  Note: {

    While i is less than string_length:
        Let char_val be proc memory_get_byte from MemoryCore with format_string, i
        Let depth be proc memory_get_integer from MemoryCore with depth_map, i multiplied by 8

        Note: Depth 1 open brace marks start of interpolation
        If char_val is equal to open_brace:
            If depth is equal to 1:
                Set point_count to point_count plus 1
            End If
        End If

        Set i to i plus 1
    End While

    Note: If no interpolations found, return 0
    If point_count is equal to 0:
        Note: No deallocation needed - arena will clean up depth_map
        Return 0
    End If

    Note: Create interpolation context
    Let context be proc create_interpolation_context

    If context is equal to 0:
        Note: No deallocation needed - arena will clean up depth_map
        Return 0
    End If

    Note: Allocate array of InterpolationPoint (56 bytes each)
    Let points_size be point_count multiplied by 56
    Let points_array be proc allocate from MemoryUtils with points_size

    If points_array is equal to 0:
        Let dummy3 be proc destroy_interpolation_context with context
        Note: No deallocation needed - arena will clean up depth_map
        Return 0
    End If

    Note: Second pass: fill in interpolation points
    Set i to 0
    Let point_index be 0
    Let max_depth be 0

    While i is less than string_length:
        Let char_val be proc memory_get_byte from MemoryCore with format_string, i
        Let depth be proc memory_get_integer from MemoryCore with depth_map, i multiplied by 8

        Note: Track max depth
        If depth is greater than max_depth:
            Set max_depth to depth
        End If

        Note: Depth 1 open brace marks interpolation start
        If char_val is equal to open_brace:
            If depth is equal to 1:
                Note: Find matching closing brace
                Let close_pos be proc find_matching_closing_brace with format_string, i, depth_map

                If close_pos is greater than 0:
                    Note: Extract expression
                    Let expr_ptr be proc extract_interpolation_expression with format_string, i, close_pos

                    Note: Fill InterpolationPoint (point_index * 56 bytes offset)
                    Let point_offset be point_index multiplied by 56
                    Let point_ptr be points_array plus point_offset

                    Let dummy5 be proc memory_set_integer from MemoryCore with point_ptr, 0, i
                    Let dummy6 be proc memory_set_integer from MemoryCore with point_ptr, 8, close_pos
                    Let dummy7 be proc memory_set_integer from MemoryCore with point_ptr, 16, expr_ptr

                    Let expr_len be close_pos minus i minus 1
                    Let dummy8 be proc memory_set_integer from MemoryCore with point_ptr, 24, expr_len
                    Let dummy9 be proc memory_set_integer from MemoryCore with point_ptr, 32, depth
                    Let dummy10 be proc memory_set_integer from MemoryCore with point_ptr, 40, 0
                    Let dummy11 be proc memory_set_integer from MemoryCore with point_ptr, 48, 0

                    Set point_index to point_index plus 1
                End If
            End If
        End If

        Set i to i plus 1
    End While

    Note: Fill context fields
    Let dummy12 be proc memory_set_integer from MemoryCore with context, 0, format_string
    Let dummy13 be proc memory_set_integer from MemoryCore with context, 8, string_length
    Let dummy14 be proc memory_set_integer from MemoryCore with context, 16, points_array
    Let dummy15 be proc memory_set_integer from MemoryCore with context, 24, point_count
    Let dummy16 be proc memory_set_integer from MemoryCore with context, 32, max_depth
    Let dummy17 be proc memory_set_integer from MemoryCore with context, 40, 0

    Note: No cleanup needed - arena will automatically clean up depth_map

    Return context
End Process

Process called "extract_interpolation_expression" takes format_string as Integer, start_offset as Integer, end_offset as Integer returns Integer:
    Note:
    Extract expression text from interpolation boundaries

    Given positions of { and }, extract the expression between them

    Parameters:
      format_string - Pointer to full formatted string
      start_offset - Position of opening { (not inclusive)
      end_offset - Position of closing } (not inclusive)

    Returns:
      Pointer to extracted expression string
      Returns 0 on error (invalid offsets, empty expression)

    Examples:
      f"value is {x + 5}" -> extract_interpolation_expression(..., 10, 16) -> "x + 5"
      f"name: {user["name"]}" -> extract_interpolation_expression(..., 7, 21) -> "user["name"]"
    :End Note

    Note: Validate offsets
    If start_offset is greater than or equal to end_offset:
        Return 0
    End If

    Note: Calculate expression start (skip the { character)
    Let expr_start be start_offset plus 1

    Note: Calculate expression length
    Let expr_length be end_offset minus expr_start

    If expr_length is less than or equal to 0:
        Return 0
    End If

    Note: Allocate space for expression string (length + 1 for null terminator)
    Let alloc_size be expr_length plus 1
    Let expr_ptr be proc allocate from MemoryUtils with alloc_size

    If expr_ptr is equal to 0:
        Return 0
    End If

    Note: Copy expression substring
    Let src_ptr be format_string plus expr_start
    Let i be 0

    While i is less than expr_length:
        Let char_val be proc memory_get_byte from MemoryCore with src_ptr, i
        Let dummy1 be proc memory_set_byte from MemoryCore with expr_ptr, i, char_val
        Set i to i plus 1
    End While

    Note: Null terminate
    Let dummy2 be proc memory_set_byte from MemoryCore with expr_ptr, expr_length, 0

    Return expr_ptr
End Process

Note: ============================================================================
Note: Nested Brace Tracking
Note: ============================================================================

Process called "track_brace_nesting" takes arena as Integer, format_string as Integer, string_length as Integer returns Integer:
    Note:
    Track brace nesting depth throughout formatted string

    Builds a depth map for each character position in string
    Accounts for escaped braces, string literals, and nested structures

    Parameters:
      arena - Arena for operation-scoped temporary allocation
      format_string - Pointer to formatted string content
      string_length - Length of string

    Returns:
      Pointer to integer array (depth map) of length string_length
      Each element is nesting depth at that character position
      Returns 0 on error

    Memory Architecture Compliance:
      Uses TIER 2 ARENA allocation for temporary depth map working buffer
      Memory is operation-scoped and cleaned up with arena
      Eliminates manual deallocation - zero leak risk

    Depth map example for f"x={y+{a:b}}":
      Position:  0 1 2 3 4 5 6 7 8 9 10 11
      String:    x = { y + { a : b }  }
      Depth:     0 0 0 1 1 1 1 2 2 2 2  1   0

    Algorithm:
    1. Initialize depth counter to 0
    2. Scan string character by character
    3. For each character:
       - If {: increment depth (unless escaped)
       - If }: decrement depth (unless escaped)
       - Skip string literals (track quote state)
    4. Store depth at each position
    5. Return depth map array
    :End Note

    If arena is equal to 0:
        Return 0  Note: Arena required for temporary allocation
    End If

    Note: Allocate depth map from arena (string_length * 8 bytes for integers)
    Let map_size be string_length multiplied by 8
    Let depth_map be proc arena_allocate from ArenaUtils with arena, map_size, 8

    If depth_map is equal to 0:
        Return 0
    End If

    Note: ASCII codes
    Let open_brace be 123    Note: {
    Let close_brace be 125   Note: }
    Let backslash be 92      Note: \
    Let double_quote be 34   Note: "

    Let current_depth be 0
    Let in_string be 0
    Let prev_was_escape be 0
    Let i be 0

    While i is less than string_length:
        Let char_val be proc memory_get_byte from MemoryCore with format_string, i

        Note: Check if previous character was escape
        If prev_was_escape is equal to 1:
            Set prev_was_escape to 0
            Let dummy1 be proc memory_set_integer from MemoryCore with depth_map, i multiplied by 8, current_depth
            Set i to i plus 1
            Continue
        End If

        Note: Check for escape character
        If char_val is equal to backslash:
            Set prev_was_escape to 1
            Let dummy2 be proc memory_set_integer from MemoryCore with depth_map, i multiplied by 8, current_depth
            Set i to i plus 1
            Continue
        End If

        Note: Track string literal state
        If char_val is equal to double_quote:
            If in_string is equal to 0:
                Set in_string to 1
            Otherwise:
                Set in_string to 0
            End If
            Let dummy3 be proc memory_set_integer from MemoryCore with depth_map, i multiplied by 8, current_depth
            Set i to i plus 1
            Continue
        End If

        Note: Only track braces outside of string literals
        If in_string is equal to 0:
            If char_val is equal to open_brace:
                Set current_depth to current_depth plus 1
            Otherwise If char_val is equal to close_brace:
                If current_depth is greater than 0:
                    Set current_depth to current_depth minus 1
                End If
            End If
        End If

        Note: Store current depth for this position
        Let dummy4 be proc memory_set_integer from MemoryCore with depth_map, i multiplied by 8, current_depth

        Set i to i plus 1
    End While

    Return depth_map
End Process

Process called "find_matching_closing_brace" takes format_string as Integer, open_pos as Integer, depth_map as Integer returns Integer:
    Note:
    Find the matching closing brace for an opening brace

    Given position of {, find the corresponding } at same nesting level

    Parameters:
      format_string - Pointer to formatted string
      open_pos - Position of opening {
      depth_map - Depth map from track_brace_nesting

    Returns:
      Position of matching closing }
      Returns -1 if no matching brace found (unclosed interpolation)

    Algorithm:
    1. Get depth at open_pos (should be depth where { opens)
    2. Scan forward from open_pos + 1
    3. Find first position where depth returns to open_pos depth - 1
    4. That position is the matching }
    5. Return position or -1 if not found
    :End Note

    Note: Get depth at opening brace position
    Let open_depth be proc memory_get_integer from MemoryCore with depth_map, open_pos multiplied by 8

    Note: Target depth is one less than opening depth
    Let target_depth be open_depth minus 1

    Note: Scan forward looking for position where depth returns to target
    Let pos be open_pos plus 1
    Let max_scan be 10000  Note: Safety limit to prevent infinite loops

    While pos is less than max_scan:
        Let current_depth be proc memory_get_integer from MemoryCore with depth_map, pos multiplied by 8

        Note: Check if depth has returned to target
        If current_depth is equal to target_depth:
            Note: Verify this position has a closing brace
            Let char_val be proc memory_get_byte from MemoryCore with format_string, pos
            Let close_brace be 125  Note: }

            If char_val is equal to close_brace:
                Return pos
            End If
        End If

        Set pos to pos plus 1
    End While

    Note: No matching brace found
    Return -1
End Process

Note: ============================================================================
Note: Interpolation Validation
Note: ============================================================================

Process called "validate_interpolation_syntax" takes arena as Integer, context as Integer returns Integer:
    Note:
    Validate that all interpolations are syntactically correct

    Checks:
      - All opening braces have matching closing braces
      - No empty interpolations {}
      - Expressions are valid (basic syntax check)
      - Nesting depth doesn't exceed limits

    Parameters:
      arena - Arena for operation-scoped temporary allocation
      context - Pointer to InterpolationContext

    Returns:
      1 if all interpolations are valid, 0 if errors found

    Side Effects:
      - Reports specific errors for each invalid interpolation
      - Provides line/column information for errors
    :End Note

    If arena is equal to 0:
        Return 0  Note: Arena required
    End If

    If context is equal to 0:
        Return 0
    End If

    Note: Get interpolation points
    Let points_array be proc memory_get_integer from MemoryCore with context, 16
    Let point_count be proc memory_get_integer from MemoryCore with context, 24
    Let max_depth be proc memory_get_integer from MemoryCore with context, 32

    Note: Check max depth limit
    Let max_allowed_depth be 10
    If max_depth is greater than max_allowed_depth:
        Let error_msg be "Nesting depth exceeds maximum"
        Let dummy1 be proc report_interpolation_error with arena, 4, 0, 0, error_msg
        Return 0
    End If

    Note: Validate each interpolation point
    Let i be 0

    While i is less than point_count:
        Let point_offset be i multiplied by 56
        Let point_ptr be points_array plus point_offset

        Note: Get expression pointer and length
        Let expr_ptr be proc memory_get_integer from MemoryCore with point_ptr, 16
        Let expr_len be proc memory_get_integer from MemoryCore with point_ptr, 24

        Note: Check for empty expression
        If expr_len is equal to 0:
            Let empty_msg be "Empty interpolation"
            Let dummy2 be proc report_interpolation_error with arena, 2, 0, 0, empty_msg
            Return 0
        End If

        Note: Check that expression is not null
        If expr_ptr is equal to 0:
            Let null_msg be "Null expression pointer"
            Let dummy3 be proc report_interpolation_error with arena, 3, 0, 0, null_msg
            Return 0
        End If

        Set i to i plus 1
    End While

    Note: All validations passed
    Return 1
End Process

Process called "report_interpolation_error" takes arena as Integer, error_type as Integer, line as Integer, column as Integer, message as Integer returns Integer:
    Note:
    Report an interpolation-related error

    Error types:
      1: Unclosed interpolation (missing })
      2: Empty interpolation ({})
      3: Invalid expression syntax
      4: Nesting depth exceeded
      5: Mismatched braces

    Parameters:
      arena - Arena for operation-scoped temporary allocation
      error_type - Error type constant
      line - Line number where error occurs
      column - Column number where error occurs
      message - Additional error message context (string pointer)

    Returns:
      1 (error reported successfully)
      0 on validation failure

    Memory Architecture Compliance:
      Uses TIER 2 ARENA allocation for temporary sprintf args array
      Memory is operation-scoped and cleaned up with arena
      Eliminates manual deallocation - zero leak risk

    Algorithm:
      1. Validate error_type parameter
      2. Build error type description string
      3. Format complete error message with line/column
      4. Output to stderr via Console.printErr
      5. Return success indicator
    :End Note

    If arena is equal to 0:
        Return 0  Note: Arena required for temporary allocation
    End If

    Note: Error type validation
    If error_type is less than 1:
        Return 0
    End If

    If error_type is greater than 5:
        Return 0
    End If

    Note: Build error type description
    Let error_desc be 0

    If error_type is equal to 1:
        Set error_desc to "Unclosed interpolation (missing })"
    Otherwise If error_type is equal to 2:
        Set error_desc to "Empty interpolation ({})"
    Otherwise If error_type is equal to 3:
        Set error_desc to "Invalid expression syntax"
    Otherwise If error_type is equal to 4:
        Set error_desc to "Nesting depth exceeded"
    Otherwise If error_type is equal to 5:
        Set error_desc to "Mismatched braces"
    End If

    Note: Build complete error message
    Let format_str be "Interpolation error: %s at line %d, column %d"

    Note: If additional message provided, use extended format
    If message is not equal to 0:
        Set format_str to "Interpolation error: %s - %s at line %d, column %d"
    End If

    Note: Allocate argument array from arena
    Let args_size be 0
    Let args be 0

    If message is not equal to 0:
        Note: 4 arguments: 2 strings + 2 integers
        Set args_size to 32
        Set args to proc arena_allocate from ArenaUtils with arena, args_size, 8

        If args is equal to 0:
            Return 0
        End If

        Note: Set arguments: error_desc, message, line, column
        Let dummy1 be proc memory_set_integer from MemoryCore with args, 0, error_desc
        Let dummy2 be proc memory_set_integer from MemoryCore with args, 8, message
        Let dummy3 be proc memory_set_integer from MemoryCore with args, 16, line
        Let dummy4 be proc memory_set_integer from MemoryCore with args, 24, column
    Otherwise:
        Note: 3 arguments: 1 string + 2 integers
        Set args_size to 24
        Set args to proc arena_allocate from ArenaUtils with arena, args_size, 8

        If args is equal to 0:
            Return 0
        End If

        Note: Set arguments: error_desc, line, column
        Let dummy5 be proc memory_set_integer from MemoryCore with args, 0, error_desc
        Let dummy6 be proc memory_set_integer from MemoryCore with args, 8, line
        Let dummy7 be proc memory_set_integer from MemoryCore with args, 16, column
    End If

    Note: Format the error message
    Let arg_count be 3
    If message is not equal to 0:
        Set arg_count to 4
    End If

    Let error_msg be proc sprintf from Format with format_str, args, arg_count

    Note: No deallocation needed - arena will clean up args array

    If error_msg is equal to 0:
        Return 0
    End If

    Note: Output error message to stderr
    Let dummy9 be proc printErr from Console with error_msg

    Note: Deallocate formatted message
    Let dummy10 be proc deallocate from MemoryUtils with error_msg

    Return 1
End Process

Note: ============================================================================
Note: Encasing Pattern Recognition
Note: ============================================================================

Process called "contains_reserved_keywords" takes arena as Integer, identifier as Integer returns Integer:
    Note:
    Check if an identifier contains Runa reserved keywords

    Multi-word identifiers cannot contain reserved keywords:
      Invalid: "Let if be 5"           (contains "if")
      Invalid: "Set while loop to 10"   (contains "while")
      Valid: "Let user name be value"   (no keywords)

    Parameters:
      arena - Arena for operation-scoped temporary allocation
      identifier - Pointer to identifier string (may contain spaces)

    Returns:
      1 if identifier contains any reserved keyword
      0 if identifier is valid (no keywords)

    Memory Architecture Compliance:
      Uses TIER 2 ARENA allocation for temporary word buffers during scanning
      Memory is operation-scoped and cleaned up with arena
      Eliminates manual deallocation - zero leak risk

    Algorithm:
      1. Split identifier into individual words by spaces
      2. For each word, check against reserved keyword list
      3. Return 1 if any word is a keyword, 0 otherwise

    Reserved keywords (from language specification):
      Let, Define, Set, If, Otherwise, Unless, When, Match, Process, Type,
      Import, Export, Try, Catch, Finally, For, While, Loop, Return, Yield,
      Break, Continue, Throw, Assert, Display, Delete, Await, Send, Receive,
      Spawn, New, Static, Public, Private, Async, External, Protocol, proc,
      Constant, End, Note
    :End Note

    If arena is equal to 0:
        Return 1  Note: Arena required for temporary allocation
    End If

    If identifier is equal to 0:
        Return 1  Note: Null identifier is invalid
    End If

    Note: Get identifier length
    Let ident_len be proc string_length from StringPrimitive with identifier

    If ident_len is equal to 0:
        Return 1  Note: Empty identifier is invalid
    End If

    Note: Scan through identifier word by word
    Let pos be 0
    Let word_start be 0
    Let space be 32

    While pos is less than or equal to ident_len:
        Let char_val be proc memory_get_byte from MemoryCore with identifier, pos

        Note: Check if we hit word boundary (space or end of string)
        If char_val is equal to space:
            Note: Extract word from word_start to pos
            If pos is greater than word_start:
                Let word_len be pos minus word_start
                Let word_ptr be proc arena_allocate from ArenaUtils with arena, word_len plus 1, 1

                If word_ptr is not equal to 0:
                    Note: Copy word
                    Let i be 0
                    While i is less than word_len:
                        Let word_char be proc memory_get_byte from MemoryCore with identifier, word_start plus i
                        Let dummy1 be proc memory_set_byte from MemoryCore with word_ptr, i, word_char
                        Set i to i plus 1
                    End While

                    Let dummy2 be proc memory_set_byte from MemoryCore with word_ptr, word_len, 0

                    Note: Check if word is a reserved keyword
                    Let is_keyword be proc is_reserved_keyword with word_ptr

                    Note: No deallocation needed - arena will clean up word_ptr

                    If is_keyword is equal to 1:
                        Return 1  Note: Found keyword, identifier is invalid
                    End If
                End If
            End If

            Set word_start to pos plus 1
        Otherwise If pos is equal to ident_len:
            Note: End of string, check last word
            If pos is greater than word_start:
                Let word_len be pos minus word_start
                Let word_ptr be proc arena_allocate from ArenaUtils with arena, word_len plus 1, 1

                If word_ptr is not equal to 0:
                    Note: Copy word
                    Let i be 0
                    While i is less than word_len:
                        Let word_char be proc memory_get_byte from MemoryCore with identifier, word_start plus i
                        Let dummy4 be proc memory_set_byte from MemoryCore with word_ptr, i, word_char
                        Set i to i plus 1
                    End While

                    Let dummy5 be proc memory_set_byte from MemoryCore with word_ptr, word_len, 0

                    Note: Check if word is a reserved keyword
                    Let is_keyword be proc is_reserved_keyword with word_ptr

                    Note: No deallocation needed - arena will clean up word_ptr

                    If is_keyword is equal to 1:
                        Return 1  Note: Found keyword, identifier is invalid
                    End If
                End If
            End If
        End If

        Set pos to pos plus 1
    End While

    Note: No keywords found, identifier is valid
    Return 0
End Process

Process called "is_reserved_keyword" takes word as Integer returns Integer:
    Note:
    Check if a single word is a Runa reserved keyword

    Parameters:
      word - Pointer to word string (no spaces)

    Returns:
      1 if word is a reserved keyword
      0 if word is not a keyword

    Note: Check all reserved keywords using string_equals
    :End Note

    If word is equal to 0:
        Return 0
    End If

    Note: Control flow keywords
    If proc string_equals from StringPrimitive with word, "If" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Otherwise" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Unless" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "When" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Match" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "For" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "While" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Loop" is equal to 1:
        Return 1
    End If

    Note: Declaration keywords
    If proc string_equals from StringPrimitive with word, "Let" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Define" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Set" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Constant" is equal to 1:
        Return 1
    End If

    Note: Definition keywords
    If proc string_equals from StringPrimitive with word, "Process" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Type" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Protocol" is equal to 1:
        Return 1
    End If

    Note: Module keywords
    If proc string_equals from StringPrimitive with word, "Import" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Export" is equal to 1:
        Return 1
    End If

    Note: Error handling keywords
    If proc string_equals from StringPrimitive with word, "Try" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Catch" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Finally" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Throw" is equal to 1:
        Return 1
    End If

    Note: Flow control keywords
    If proc string_equals from StringPrimitive with word, "Return" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Yield" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Break" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Continue" is equal to 1:
        Return 1
    End If

    Note: Other keywords
    If proc string_equals from StringPrimitive with word, "Assert" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Display" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Delete" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Await" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Send" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Receive" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Spawn" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "New" is equal to 1:
        Return 1
    End If

    Note: Visibility keywords
    If proc string_equals from StringPrimitive with word, "Static" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Public" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Private" is equal to 1:
        Return 1
    End If

    Note: Function keywords
    If proc string_equals from StringPrimitive with word, "Async" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "External" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "proc" is equal to 1:
        Return 1
    End If

    Note: Structural keywords
    If proc string_equals from StringPrimitive with word, "End" is equal to 1:
        Return 1
    End If
    If proc string_equals from StringPrimitive with word, "Note" is equal to 1:
        Return 1
    End If

    Note: Not a reserved keyword
    Return 0
End Process

Process called "recognize_encased_identifier" takes arena as Integer, lexer as Integer, start_pos as Integer, start_line as Integer, start_column as Integer returns Integer:
    Note:
    Recognize multi-word identifier in encasing pattern

    Runa's encasing syntax allows multi-word identifiers:
      Let user name be "Alice"
      Set total count to 100
      Define maximum value as 999

    The identifier is "encased" between keywords (Let ... be, Set ... to, Define ... as)

    Parameters:
      arena - Arena for operation-scoped temporary allocation
      lexer - Pointer to lexer state structure
      start_pos - Position where identifier starts
      start_line - Line number
      start_column - Column number

    Returns:
      Pointer to Token structure with:
        - token_type = TOKEN_ENCASED_IDENTIFIER (703)
        - value = Full multi-word identifier ("user name", "total count")
        - line/column = identifier position
        - length = Total identifier length including spaces
      Returns 0 if not in encasing context

    Algorithm:
    1. Check if current context is encasing (after Let, Set, Define keywords)
    2. Find terminator position (be, to, as)
    3. Extract text between start_pos and terminator
    4. Trim leading/trailing whitespace
    5. Validate identifier is not empty
    6. Create Token structure with extracted identifier
    7. Return Token pointer
    :End Note

    If arena is equal to 0:
        Return 0  Note: Arena required
    End If

    Note: Check if in encasing context
    Let in_encasing be proc is_encasing_context with lexer

    If in_encasing is equal to 0:
        Return 0
    End If

    Note: Find terminator position
    Let terminator_pos be proc find_encasing_terminator with lexer, start_pos

    If terminator_pos is less than 0:
        Return 0
    End If

    Note: Get source text from lexer
    Let source_text be proc memory_get_integer from MemoryCore with lexer, 0

    If source_text is equal to 0:
        Return 0
    End If

    Note: Calculate identifier length
    Let ident_length be terminator_pos minus start_pos

    If ident_length is less than or equal to 0:
        Return 0
    End If

    Note: Allocate space for identifier string (ident_length + 1 for null terminator)
    Let alloc_size be ident_length plus 1
    Let ident_str be proc allocate from MemoryUtils with alloc_size

    If ident_str is equal to 0:
        Return 0
    End If

    Note: Copy identifier text
    Let src_ptr be source_text plus start_pos
    Let i be 0

    While i is less than ident_length:
        Let char_val be proc memory_get_byte from MemoryCore with src_ptr, i
        Let dummy1 be proc memory_set_byte from MemoryCore with ident_str, i, char_val
        Set i to i plus 1
    End While

    Note: Null terminate
    Let dummy2 be proc memory_set_byte from MemoryCore with ident_str, ident_length, 0

    Note: Trim leading and trailing whitespace
    Let trimmed_str be proc string_trim from StringPrimitive with ident_str

    Note: Deallocate original if different
    If trimmed_str is not equal to ident_str:
        Let dummy3 be proc deallocate from MemoryUtils with ident_str
    End If

    If trimmed_str is equal to 0:
        Return 0
    End If

    Note: Validate identifier is not empty after trimming
    Let trimmed_len be proc string_length from StringPrimitive with trimmed_str

    If trimmed_len is equal to 0:
        Let dummy4 be proc deallocate from MemoryUtils with trimmed_str
        Return 0
    End If

    Note: Validate identifier does not contain reserved keywords
    Let has_keywords be proc contains_reserved_keywords with arena, trimmed_str

    If has_keywords is equal to 1:
        Note: Identifier contains keywords - invalid
        Let dummy5 be proc deallocate from MemoryUtils with trimmed_str
        Return 0
    End If

    Note: Create Token structure
    Note: Token structure: type(8) + value(8) + line(8) + column(8) + length(8) = 40 bytes
    Let token_size be 40
    Let token_ptr be proc allocate from MemoryUtils with token_size

    If token_ptr is equal to 0:
        Let dummy6 be proc deallocate from MemoryUtils with trimmed_str
        Return 0
    End If

    Note: Fill Token fields
    Let dummy7 be proc memory_set_integer from MemoryCore with token_ptr, 0, TOKEN_ENCASED_IDENTIFIER
    Let dummy8 be proc memory_set_integer from MemoryCore with token_ptr, 8, trimmed_str
    Let dummy9 be proc memory_set_integer from MemoryCore with token_ptr, 16, start_line
    Let dummy10 be proc memory_set_integer from MemoryCore with token_ptr, 24, start_column
    Let dummy11 be proc memory_set_integer from MemoryCore with token_ptr, 32, trimmed_len

    Return token_ptr
End Process

Process called "is_encasing_context" takes lexer as Integer returns Integer:
    Note:
    Check if lexer is currently in an encasing context

    Encasing contexts occur after:
      - "Let" keyword (before "be" or "as")
      - "Set" keyword (before "to")
      - "Define" keyword (before "as")

    Parameters:
      lexer - Pointer to lexer state structure
              Expected structure offsets:
                0: source_text pointer
                8: source_length
                16: current_position
                24: previous_token_type
                32: previous_token_text pointer

    Returns:
      1 if in encasing context, 0 otherwise

    Algorithm:
      1. Get previous token text from lexer state
      2. Check if it matches encasing keywords (Let, Set, Define, Constant)
      3. Return 1 if match found, 0 otherwise
    :End Note

    If lexer is equal to 0:
        Return 0
    End If

    Note: Get previous token text pointer from lexer (offset 32)
    Let prev_token_text be proc memory_get_integer from MemoryCore with lexer, 32

    If prev_token_text is equal to 0:
        Return 0
    End If

    Note: Check if previous token is an encasing keyword
    Let is_let be proc string_equals from StringPrimitive with prev_token_text, "Let"
    If is_let is equal to 1:
        Return 1
    End If

    Let is_set be proc string_equals from StringPrimitive with prev_token_text, "Set"
    If is_set is equal to 1:
        Return 1
    End If

    Let is_define be proc string_equals from StringPrimitive with prev_token_text, "Define"
    If is_define is equal to 1:
        Return 1
    End If

    Let is_constant be proc string_equals from StringPrimitive with prev_token_text, "Constant"
    If is_constant is equal to 1:
        Return 1
    End If

    Note: Not in encasing context
    Return 0
End Process

Process called "find_encasing_terminator" takes lexer as Integer, start_pos as Integer returns Integer:
    Note:
    Find the keyword that terminates the encasing pattern

    Terminators:
      - "be" for Let statements
      - "to" for Set statements
      - "as" for Define/Constant statements and type annotations

    Parameters:
      lexer - Pointer to lexer state (provides source text)
      start_pos - Position to start searching from

    Returns:
      Position of terminator keyword
      Returns -1 if no terminator found (syntax error)

    Algorithm:
      1. Get source text from lexer
      2. Scan forward from start_pos
      3. Skip whitespace and collect words
      4. Check each word against terminators: "be", "to", "as"
      5. Return position of terminator
      6. Stop at newline or end of line (syntax error)
    :End Note

    If lexer is equal to 0:
        Return -1
    End If

    Note: Get source text and length from lexer (offsets 0 and 8)
    Let source_text be proc memory_get_integer from MemoryCore with lexer, 0
    Let source_length be proc memory_get_integer from MemoryCore with lexer, 8

    If source_text is equal to 0:
        Return -1
    End If

    Note: ASCII codes for scanning
    Let space be 32
    Let tab be 9
    Let newline be 10
    Let carriage_return be 13
    Let left_paren be 40  Note: ( for type annotations

    Note: Scan forward from start_pos
    Let pos be start_pos
    Let max_scan be source_length

    While pos is less than max_scan:
        Let char_val be proc memory_get_byte from MemoryCore with source_text, pos

        Note: Stop at newline (terminator should be on same line)
        If char_val is equal to newline:
            Return -1
        End If

        If char_val is equal to carriage_return:
            Return -1
        End If

        Note: Skip whitespace
        If char_val is equal to space:
            Set pos to pos plus 1
            Continue
        End If

        If char_val is equal to tab:
            Set pos to pos plus 1
            Continue
        End If

        Note: Check if we found a word - collect it
        Note: Check for "be" (2 chars)
        If pos plus 2 is less than or equal to max_scan:
            Let char1 be proc memory_get_byte from MemoryCore with source_text, pos
            Let char2 be proc memory_get_byte from MemoryCore with source_text, pos plus 1
            Let char3 be proc memory_get_byte from MemoryCore with source_text, pos plus 2

            Note: Check for "be" followed by space or ( or :
            If char1 is equal to 98:  Note: 'b'
                If char2 is equal to 101:  Note: 'e'
                    Note: Verify next char is word boundary
                    If char3 is equal to space:
                        Return pos
                    End If
                    If char3 is equal to left_paren:
                        Return pos
                    End If
                    If char3 is equal to 58:  Note: ':'
                        Return pos
                    End If
                End If
            End If

            Note: Check for "to" followed by space
            If char1 is equal to 116:  Note: 't'
                If char2 is equal to 111:  Note: 'o'
                    If char3 is equal to space:
                        Return pos
                    End If
                    If char3 is equal to left_paren:
                        Return pos
                    End If
                End If
            End If

            Note: Check for "as" followed by space
            If char1 is equal to 97:  Note: 'a'
                If char2 is equal to 115:  Note: 's'
                    If char3 is equal to space:
                        Return pos
                    End If
                    If char3 is equal to left_paren:
                        Return pos
                    End If
                End If
            End If
        End If

        Note: Move to next character
        Set pos to pos plus 1
    End While

    Note: No terminator found
    Return -1
End Process

Note: ============================================================================
Note: Interpolation Tokenization
Note: ============================================================================

Process called "tokenize_interpolated_string" takes arena as Integer, lexer as Integer, format_string as Integer, string_length as Integer, start_line as Integer, start_column as Integer returns Integer:
    Note:
    Tokenize a formatted string with interpolations into token sequence

    Converts f"text {expr} more" into sequence:
      TOKEN_STRING_LITERAL ("text ")
      TOKEN_INTERPOLATION_START ({)
      TOKEN_INTERPOLATION_EXPR (expr)
      TOKEN_INTERPOLATION_END (})
      TOKEN_STRING_LITERAL (" more")

    Parameters:
      arena - Arena for operation-scoped temporary allocation
      lexer - Pointer to lexer state
      format_string - Formatted string content
      string_length - Length of string
      start_line - Line number of string start
      start_column - Column number of string start

    Returns:
      Pointer to array of Token structures
      Array terminated with null token (token_type = 0)
      Returns 0 on error

    Algorithm:
    1. Detect all interpolation points using detect_string_interpolation
    2. Calculate total tokens needed (text segments + interpolation markers)
    3. Allocate token array
    4. Build tokens for text before/between/after interpolations
    5. Build tokens for interpolation expressions
    6. Add null terminator token
    7. Return token array
    :End Note

    If arena is equal to 0:
        Return 0  Note: Arena required
    End If

    Note: Detect interpolations
    Let context be proc detect_string_interpolation with arena, format_string, string_length

    If context is equal to 0:
        Note: No interpolations - return 0 for simple string handling
        Return 0
    End If

    Note: Validate interpolations
    Let is_valid be proc validate_interpolation_syntax with arena, context

    If is_valid is equal to 0:
        Let dummy1 be proc destroy_interpolation_context with context
        Return 0
    End If

    Note: Get interpolation points
    Let points_array be proc memory_get_integer from MemoryCore with context, 16
    Let point_count be proc memory_get_integer from MemoryCore with context, 24

    Note: Calculate token count
    Note: Each interpolation creates 3 tokens (START, EXPR, END)
    Note: Text segments: point_count + 1 (before, between, after)
    Note: Plus 1 for null terminator
    Let token_count be point_count multiplied by 3
    Set token_count to token_count plus point_count plus 1
    Set token_count to token_count plus 1  Note: Null terminator

    Note: Allocate token array (40 bytes per token)
    Let token_size be 40
    Let array_size be token_count multiplied by token_size
    Let token_array be proc allocate from MemoryUtils with array_size

    If token_array is equal to 0:
        Let dummy2 be proc destroy_interpolation_context with context
        Return 0
    End If

    Note: Build tokens
    Let token_index be 0
    Let current_pos be 0
    Let i be 0

    While i is less than point_count:
        Note: Get interpolation point
        Let point_offset be i multiplied by 56
        Let point_ptr be points_array plus point_offset

        Let start_offset be proc memory_get_integer from MemoryCore with point_ptr, 0
        Let end_offset be proc memory_get_integer from MemoryCore with point_ptr, 8
        Let expr_ptr be proc memory_get_integer from MemoryCore with point_ptr, 16

        Note: Create token for text before interpolation (if any)
        If start_offset is greater than current_pos:
            Let text_len be start_offset minus current_pos
            Let text_ptr be proc allocate from MemoryUtils with text_len plus 1

            If text_ptr is not equal to 0:
                Note: Copy text segment
                Let j be 0
                While j is less than text_len:
                    Let char_val be proc memory_get_byte from MemoryCore with format_string, current_pos plus j
                    Let dummy3 be proc memory_set_byte from MemoryCore with text_ptr, j, char_val
                    Set j to j plus 1
                End While

                Let dummy4 be proc memory_set_byte from MemoryCore with text_ptr, text_len, 0

                Note: Create TOKEN_STRING_LITERAL
                Let token_ptr be token_array plus token_index multiplied by token_size
                Let dummy5 be proc memory_set_integer from MemoryCore with token_ptr, 0, 400  Note: TOKEN_STRING_LITERAL
                Let dummy6 be proc memory_set_integer from MemoryCore with token_ptr, 8, text_ptr
                Let dummy7 be proc memory_set_integer from MemoryCore with token_ptr, 16, start_line
                Let dummy8 be proc memory_set_integer from MemoryCore with token_ptr, 24, start_column
                Let dummy9 be proc memory_set_integer from MemoryCore with token_ptr, 32, text_len

                Set token_index to token_index plus 1
            End If
        End If

        Note: Create TOKEN_INTERPOLATION_START
        Let start_token_ptr be token_array plus token_index multiplied by token_size
        Let dummy10 be proc memory_set_integer from MemoryCore with start_token_ptr, 0, TOKEN_INTERPOLATION_START
        Let dummy11 be proc memory_set_integer from MemoryCore with start_token_ptr, 8, 0
        Let dummy12 be proc memory_set_integer from MemoryCore with start_token_ptr, 16, start_line
        Let dummy13 be proc memory_set_integer from MemoryCore with start_token_ptr, 24, start_column
        Let dummy14 be proc memory_set_integer from MemoryCore with start_token_ptr, 32, 1

        Set token_index to token_index plus 1

        Note: Create TOKEN_INTERPOLATION_EXPR
        Let expr_token_ptr be token_array plus token_index multiplied by token_size
        Let dummy15 be proc memory_set_integer from MemoryCore with expr_token_ptr, 0, TOKEN_INTERPOLATION_EXPR
        Let dummy16 be proc memory_set_integer from MemoryCore with expr_token_ptr, 8, expr_ptr
        Let dummy17 be proc memory_set_integer from MemoryCore with expr_token_ptr, 16, start_line
        Let dummy18 be proc memory_set_integer from MemoryCore with expr_token_ptr, 24, start_column
        Let expr_len be proc memory_get_integer from MemoryCore with point_ptr, 24
        Let dummy19 be proc memory_set_integer from MemoryCore with expr_token_ptr, 32, expr_len

        Set token_index to token_index plus 1

        Note: Create TOKEN_INTERPOLATION_END
        Let end_token_ptr be token_array plus token_index multiplied by token_size
        Let dummy20 be proc memory_set_integer from MemoryCore with end_token_ptr, 0, TOKEN_INTERPOLATION_END
        Let dummy21 be proc memory_set_integer from MemoryCore with end_token_ptr, 8, 0
        Let dummy22 be proc memory_set_integer from MemoryCore with end_token_ptr, 16, start_line
        Let dummy23 be proc memory_set_integer from MemoryCore with end_token_ptr, 24, start_column
        Let dummy24 be proc memory_set_integer from MemoryCore with end_token_ptr, 32, 1

        Set token_index to token_index plus 1

        Note: Update current position
        Set current_pos to end_offset plus 1

        Set i to i plus 1
    End While

    Note: Create token for text after last interpolation (if any)
    If current_pos is less than string_length:
        Let text_len be string_length minus current_pos
        Let text_ptr be proc allocate from MemoryUtils with text_len plus 1

        If text_ptr is not equal to 0:
            Note: Copy text segment
            Let j be 0
            While j is less than text_len:
                Let char_val be proc memory_get_byte from MemoryCore with format_string, current_pos plus j
                Let dummy25 be proc memory_set_byte from MemoryCore with text_ptr, j, char_val
                Set j to j plus 1
            End While

            Let dummy26 be proc memory_set_byte from MemoryCore with text_ptr, text_len, 0

            Note: Create TOKEN_STRING_LITERAL
            Let token_ptr be token_array plus token_index multiplied by token_size
            Let dummy27 be proc memory_set_integer from MemoryCore with token_ptr, 0, 400  Note: TOKEN_STRING_LITERAL
            Let dummy28 be proc memory_set_integer from MemoryCore with token_ptr, 8, text_ptr
            Let dummy29 be proc memory_set_integer from MemoryCore with token_ptr, 16, start_line
            Let dummy30 be proc memory_set_integer from MemoryCore with token_ptr, 24, start_column
            Let dummy31 be proc memory_set_integer from MemoryCore with token_ptr, 32, text_len

            Set token_index to token_index plus 1
        End If
    End If

    Note: Add null terminator token
    Let null_token_ptr be token_array plus token_index multiplied by token_size
    Let dummy32 be proc memory_set_integer from MemoryCore with null_token_ptr, 0, 0
    Let dummy33 be proc memory_set_integer from MemoryCore with null_token_ptr, 8, 0
    Let dummy34 be proc memory_set_integer from MemoryCore with null_token_ptr, 16, 0
    Let dummy35 be proc memory_set_integer from MemoryCore with null_token_ptr, 24, 0
    Let dummy36 be proc memory_set_integer from MemoryCore with null_token_ptr, 32, 0

    Note: Clean up context (expressions are now owned by tokens, don't deallocate them)
    Note: Only deallocate the context structure and points array
    Let points_array_copy be proc memory_get_integer from MemoryCore with context, 16
    If points_array_copy is not equal to 0:
        Let dummy37 be proc deallocate from MemoryUtils with points_array_copy
    End If
    Let dummy38 be proc deallocate from MemoryUtils with context

    Return token_array
End Process

Note: ============================================================================
Note: Utility Functions
Note: ============================================================================

Process called "create_interpolation_context" returns Integer:
    Note:
    Create a new InterpolationContext structure

    Returns:
      Pointer to initialized InterpolationContext
      Returns 0 on allocation failure
    :End Note

    Note: InterpolationContext has 6 fields * 8 bytes = 48 bytes
    Let context_size be 48
    Let context_ptr be proc allocate from MemoryUtils with context_size

    If context_ptr is equal to 0:
        Return 0
    End If

    Note: Initialize all fields to 0
    Let dummy1 be proc memory_set_integer from MemoryCore with context_ptr, 0, 0
    Let dummy2 be proc memory_set_integer from MemoryCore with context_ptr, 8, 0
    Let dummy3 be proc memory_set_integer from MemoryCore with context_ptr, 16, 0
    Let dummy4 be proc memory_set_integer from MemoryCore with context_ptr, 24, 0
    Let dummy5 be proc memory_set_integer from MemoryCore with context_ptr, 32, 0
    Let dummy6 be proc memory_set_integer from MemoryCore with context_ptr, 40, 0

    Return context_ptr
End Process

Process called "destroy_interpolation_context" takes context as Integer returns Integer:
    Note:
    Clean up and deallocate InterpolationContext

    Parameters:
      context - Pointer to InterpolationContext

    Returns:
      1 on success
    :End Note

    If context is equal to 0:
        Return 0
    End If

    Note: Get interpolation_points array
    Let points_array be proc memory_get_integer from MemoryCore with context, 16

    Note: Deallocate each InterpolationPoint's expression string
    If points_array is not equal to 0:
        Let point_count be proc memory_get_integer from MemoryCore with context, 24
        Let i be 0

        While i is less than point_count:
            Note: InterpolationPoint size is 7 fields * 8 bytes = 56 bytes
            Let point_offset be i multiplied by 56
            Let point_ptr be points_array plus point_offset

            Note: Get expression pointer (offset 16 in InterpolationPoint)
            Let expr_ptr be proc memory_get_integer from MemoryCore with point_ptr, 16

            If expr_ptr is not equal to 0:
                Let dummy1 be proc deallocate from MemoryUtils with expr_ptr
            End If

            Set i to i plus 1
        End While

        Note: Deallocate points array
        Let dummy2 be proc deallocate from MemoryUtils with points_array
    End If

    Note: Deallocate context
    Let dummy3 be proc deallocate from MemoryUtils with context

    Return 1
End Process
