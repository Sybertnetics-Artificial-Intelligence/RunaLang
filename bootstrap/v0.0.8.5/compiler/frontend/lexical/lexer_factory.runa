Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file provides factory functions for creating and configuring lexers.

This file performs the following tasks:
- Create lexers from various input sources (file, string, stream)
- Configure lexer modes (Canon, Developer, Viewer)
- Set lexer options and flags
- Provide pre-configured lexers for testing
- Manage lexer lifecycle and resource cleanup

This file is essential because of the following reasons:
- Factory pattern simplifies lexer creation with proper initialization
- Configuration helpers ensure consistent lexer behavior
- Testing utilities enable isolated lexer verification
- Resource management prevents memory leaks
- Abstraction layer isolates lexer implementation details

This file consists of the following functions/features/operation types:
- Lexer factory methods for different input sources
- Configuration builders for lexer modes and options
- Test lexer creation with mock inputs
- Lexer cleanup and resource management
- Convenience functions for common lexer operations

Dependencies:
- Imports lexer.runa for main lexer implementation
- Imports token_stream.runa for token stream creation
- Imports core/memory_core.runa for memory management
- Imports io/file.runa for file reading (when implemented)
:End Note

Import "compiler/frontend/lexical/lexer.runa" as Lexer
Import "compiler/frontend/lexical/token_stream.runa" as TokenStream
Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/internal/file_utils.runa" as FileUtils
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore

Note: ============================================================================
Note: Lexer Mode Constants
Note: ============================================================================

Constant LEXER_MODE_CANON as Integer is 0        Note: Canonical mode (natural language)
Constant LEXER_MODE_DEVELOPER as Integer is 1   Note: Developer mode (technical syntax)
Constant LEXER_MODE_VIEWER as Integer is 2      Note: Viewer mode (display optimized)

Note: ============================================================================
Note: Lexer Configuration Structure
Note: ============================================================================

Type called "LexerConfig":
    mode as Integer            Note: Lexer mode (CANON, DEVELOPER, VIEWER)
    strict_mode as Integer     Note: Boolean: 1 for strict error handling
    allow_tabs as Integer      Note: Boolean: 1 to allow tab characters for indentation
    indent_size as Integer     Note: Spaces per indentation level (typically 4)
    preserve_comments as Integer Note: Boolean: 1 to keep comment tokens
    preserve_whitespace as Integer Note: Boolean: 1 to keep whitespace tokens
    report_warnings as Integer Note: Boolean: 1 to report non-fatal warnings
    max_errors as Integer      Note: Maximum errors before stopping (0 = unlimited)

Note: ============================================================================
Note: Factory Functions - Create from Source
Note: ============================================================================

Process called "create_lexer_for_file" takes file_path as Integer, mode as Integer returns Integer:
    Note:
    Create lexer for a source file

    Parameters:
      file_path - Pointer to file path string
      mode - Lexer mode

    Returns:
      Pointer to initialized LexerState
      Returns 0 on error
    :End Note

    If file_path is equal to 0:
        Return 0  Note: NULL file path
    End If

    Note: Open file for reading
    Let FILE_MODE_READ be 0
    Let file_handle be proc file_open from FileUtils with file_path, FILE_MODE_READ, 0

    If file_handle is equal to 0:
        Return 0  Note: Failed to open file
    End If

    Note: Get file size from FileHandle (offset 16)
    Let file_size be proc memory_get_qword from Layout with file_handle, 16

    If file_size is less than 0:
        Let close_result be proc file_close from FileUtils with file_handle
        Return 0  Note: Invalid file size
    End If

    Note: Allocate buffer for file contents (plus null terminator)
    Let buffer_size be file_size plus 1
    Let buffer be proc allocate from Layout with buffer_size

    If buffer is equal to 0:
        Let close_result be proc file_close from FileUtils with file_handle
        Return 0  Note: Buffer allocation failed
    End If

    Note: Read entire file into buffer
    Let bytes_read be proc file_read from FileUtils with file_handle, buffer, file_size

    If bytes_read is less than 0:
        Let close_result be proc file_close from FileUtils with file_handle
        Let dealloc_result be proc deallocate from Layout with buffer
        Return 0  Note: Read failed
    End If

    Note: Close file
    Let close_result be proc file_close from FileUtils with file_handle

    Note: Null-terminate buffer
    Let null_offset be file_size
    proc memory_set_byte from StringCore with buffer, null_offset, 0

    Note: Create lexer with file contents
    Let lexer be proc create_lexer_for_string with buffer, file_size, mode

    Return lexer
End Process

Process called "create_lexer_for_string" takes source_code as Integer, source_length as Integer, mode as Integer returns Integer:
    Note:
    Create lexer for a source code string

    Most direct way to create lexer - pass source directly

    Parameters:
      source_code - Pointer to source code string
      source_length - Length of source code
      mode - Lexer mode

    Returns:
      Pointer to initialized LexerState
      Returns 0 on allocation failure
    :End Note

    If source_code is equal to 0:
        Return 0  Note: NULL source
    End If

    If source_length is less than 0:
        Return 0  Note: Invalid length
    End If

    Note: Validate mode
    If mode is less than 0:
        Return 0
    End If
    If mode is greater than 2:
        Return 0
    End If

    Note: Create lexer using Lexer module
    Let lexer be proc lexer_create from Lexer with source_code, source_length, mode

    Return lexer
End Process

Process called "create_lexer_for_stream" takes input_stream as Integer, mode as Integer returns Integer:
    Note:
    Create lexer for an input stream

    Reads from stream in chunks until end-of-stream is reached

    Parameters:
      input_stream - Pointer to IOHandle structure from io_core.runa
      mode - Lexer mode

    Returns:
      Pointer to initialized LexerState
      Returns 0 on error
    :End Note

    If input_stream is equal to 0:
        Return 0  Note: NULL stream
    End If

    Note: Allocate initial buffer (8KB chunks)
    Let CHUNK_SIZE be 8192
    Let buffer_capacity be CHUNK_SIZE
    Let buffer be proc allocate from Layout with buffer_capacity

    If buffer is equal to 0:
        Return 0  Note: Buffer allocation failed
    End If

    Let total_bytes_read be 0

    Note: Read from stream in chunks until EOF
    Let done be 0
    While done is equal to 0:
        Note: Check if buffer needs to grow
        If total_bytes_read is greater than or equal to buffer_capacity:
            Note: Double buffer capacity
            Let new_capacity be buffer_capacity multiplied by 2
            Let new_buffer be proc allocate from Layout with new_capacity

            If new_buffer is equal to 0:
                Let dealloc_result be proc deallocate from Layout with buffer
                Return 0  Note: Buffer reallocation failed
            End If

            Note: Copy existing data to new buffer
            Let copy_index be 0
            While copy_index is less than total_bytes_read:
                Let byte_val be proc memory_get_byte from StringCore with buffer, copy_index
                proc memory_set_byte from StringCore with new_buffer, copy_index, byte_val
                Set copy_index to copy_index plus 1
            End While

            Note: Deallocate old buffer
            Let dealloc_result be proc deallocate from Layout with buffer

            Note: Update to new buffer
            Set buffer to new_buffer
            Set buffer_capacity to new_capacity
        End If

        Note: Read one chunk from stream
        Let read_offset be total_bytes_read
        Let read_size be CHUNK_SIZE
        Let bytes_read be proc file_read from FileUtils with input_stream, buffer plus read_offset, read_size

        If bytes_read is less than 0:
            Let dealloc_result be proc deallocate from Layout with buffer
            Return 0  Note: Stream read error
        End If

        If bytes_read is equal to 0:
            Set done to 1  Note: End of stream reached
        Otherwise:
            Set total_bytes_read to total_bytes_read plus bytes_read
        End If
    End While

    Note: Null-terminate buffer
    Let null_offset be total_bytes_read
    proc memory_set_byte from StringCore with buffer, null_offset, 0

    Note: Create lexer with buffered stream data
    Let lexer be proc create_lexer_for_string with buffer, total_bytes_read, mode

    Return lexer
End Process

Note: ============================================================================
Note: Factory Functions - Create with Configuration
Note: ============================================================================

Process called "create_lexer_with_config" takes source_code as Integer, source_length as Integer, config as Integer returns Integer:
    Note:
    Create lexer with custom configuration

    Provides full control over lexer behavior via configuration object

    Parameters:
      source_code - Pointer to source code string
      source_length - Length of source code
      config - Pointer to LexerConfig structure with settings

    Returns:
      Pointer to initialized LexerState with applied configuration
      Returns 0 on error
    :End Note

    If config is equal to 0:
        Return 0  Note: NULL config
    End If

    Note: Validate config
    Let config_valid be proc validate_lexer_config with config

    If config_valid is equal to 0:
        Return 0  Note: Invalid config
    End If

    Note: Get mode from config
    Let mode be proc memory_get_qword from Layout with config, 0

    Note: Create basic lexer
    Let lexer be proc create_lexer_for_string with source_code, source_length, mode

    If lexer is equal to 0:
        Return 0  Note: Lexer creation failed
    End If

    Note: Apply configuration settings
    Let strict_mode be proc memory_get_qword from Layout with config, 8
    Let allow_tabs be proc memory_get_qword from Layout with config, 16
    Let indent_size be proc memory_get_qword from Layout with config, 24
    Let preserve_comments be proc memory_get_qword from Layout with config, 32
    Let preserve_whitespace be proc memory_get_qword from Layout with config, 40
    Let report_warnings be proc memory_get_qword from Layout with config, 48
    Let max_errors be proc memory_get_qword from Layout with config, 56

    proc configure_error_handling with lexer, strict_mode, max_errors
    proc configure_indentation with lexer, indent_size, allow_tabs
    proc configure_token_preservation with lexer, preserve_comments, preserve_whitespace

    Note: Store report_warnings flag (offset 144)
    proc memory_set_qword from Layout with lexer, 144, report_warnings

    Return lexer
End Process

Process called "create_default_config" takes arena as Integer returns Integer:
    Note:
    Create default lexer configuration

    Returns:
      Pointer to LexerConfig with default settings:
        - mode = LEXER_MODE_CANON
        - strict_mode = 1
        - allow_tabs = 0
        - indent_size = 4
        - preserve_comments = 0
        - preserve_whitespace = 0
        - report_warnings = 1
        - max_errors = 0 (unlimited)
    :End Note

    Note: LexerConfig has 8 fields, each 8 bytes = 64 bytes total
    Let config_size be 64
    Let config be proc arena_allocate from Layout with arena, config_size

    If config is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Let LEXER_MODE_CANON be 0

    Note: Initialize fields with default values
    proc memory_set_qword from Layout with config, 0, LEXER_MODE_CANON  Note: mode
    proc memory_set_qword from Layout with config, 8, 1                 Note: strict_mode = 1
    proc memory_set_qword from Layout with config, 16, 0                Note: allow_tabs = 0
    proc memory_set_qword from Layout with config, 24, 4                Note: indent_size = 4
    proc memory_set_qword from Layout with config, 32, 0                Note: preserve_comments = 0
    proc memory_set_qword from Layout with config, 40, 0                Note: preserve_whitespace = 0
    proc memory_set_qword from Layout with config, 48, 1                Note: report_warnings = 1
    proc memory_set_qword from Layout with config, 56, 0                Note: max_errors = 0 (unlimited)

    Return config
End Process

Process called "create_strict_config" takes arena as Integer returns Integer:
    Note:
    Create strict lexer configuration

    Strict mode: All warnings are errors, no tolerance for ambiguity

    Returns:
      Pointer to LexerConfig with strict settings

    Used for production builds and CI/CD pipelines
    :End Note

    Let config be proc create_default_config with arena

    If config is equal to 0:
        Return 0
    End If

    Note: Override settings for strict mode
    proc memory_set_qword from Layout with config, 8, 1    Note: strict_mode = 1
    proc memory_set_qword from Layout with config, 16, 0   Note: allow_tabs = 0 (only spaces)
    proc memory_set_qword from Layout with config, 48, 1   Note: report_warnings = 1
    proc memory_set_qword from Layout with config, 56, 1   Note: max_errors = 1 (stop on first error)

    Return config
End Process

Process called "create_permissive_config" takes arena as Integer returns Integer:
    Note:
    Create permissive lexer configuration

    Permissive mode: Allow tabs, continue on errors, suppress warnings

    Returns:
      Pointer to LexerConfig with permissive settings

    Used for development and interactive environments
    :End Note

    Let config be proc create_default_config with arena

    If config is equal to 0:
        Return 0
    End If

    Note: Override settings for permissive mode
    proc memory_set_qword from Layout with config, 8, 0    Note: strict_mode = 0
    proc memory_set_qword from Layout with config, 16, 1   Note: allow_tabs = 1
    proc memory_set_qword from Layout with config, 48, 0   Note: report_warnings = 0
    proc memory_set_qword from Layout with config, 56, 0   Note: max_errors = 0 (unlimited)

    Return config
End Process

Note: ============================================================================
Note: Factory Functions - Testing and Mocking
Note: ============================================================================

Process called "create_test_lexer" takes arena as Integer, test_source as Integer, mode as Integer returns Integer:
    Note:
    Create lexer configured for testing

    Test lexers have:
      - Strict error checking enabled
      - Comment and whitespace preservation
      - Detailed error messages
      - No error count limits

    Parameters:
      test_source - Pointer to test source code string
      mode - Lexer mode for test

    Returns:
      Pointer to initialized test lexer
    :End Note

    If test_source is equal to 0:
        Return 0  Note: NULL test source
    End If

    Note: Create test configuration
    Let config be proc create_default_config with arena

    If config is equal to 0:
        Return 0
    End If

    Note: Configure for testing
    proc memory_set_qword from Layout with config, 0, mode           Note: Set mode
    proc memory_set_qword from Layout with config, 8, 1             Note: strict_mode = 1
    proc memory_set_qword from Layout with config, 32, 1            Note: preserve_comments = 1
    proc memory_set_qword from Layout with config, 40, 1            Note: preserve_whitespace = 1
    proc memory_set_qword from Layout with config, 48, 1            Note: report_warnings = 1
    proc memory_set_qword from Layout with config, 56, 0            Note: max_errors = 0 (unlimited)

    Note: Get test source length
    Let source_length be proc string_length from MemoryCore with test_source

    Note: Create lexer with test config
    Let lexer be proc create_lexer_with_config with test_source, source_length, config

    Return lexer
End Process

Process called "create_mock_lexer_with_tokens" takes mock_tokens as Integer, token_count as Integer returns Integer:
    Note:
    Create mock lexer with predefined tokens

    For testing parser without running actual lexer

    Parameters:
      mock_tokens - Array of Token pointers to use
      token_count - Number of tokens in array

    Returns:
      Pointer to mock LexerState that returns pre-generated tokens
    :End Note

    If mock_tokens is equal to 0:
        Return 0  Note: NULL tokens
    End If

    If token_count is less than 0:
        Return 0  Note: Invalid count
    End If

    Note: Create empty lexer (with empty source)
    Let empty_source be proc string_literal from MemoryCore with ""
    Let mode be 0  Note: LEXER_MODE_CANON
    Let lexer be proc create_lexer_for_string with empty_source, 0, mode

    If lexer is equal to 0:
        Return 0
    End If

    Note: Replace tokens array with mock tokens
    Note: LexerState.tokens is at offset 80
    proc memory_set_qword from Layout with lexer, 80, mock_tokens

    Note: LexerState.token_count is at offset 88
    proc memory_set_qword from Layout with lexer, 88, token_count

    Return lexer
End Process

Note: ============================================================================
Note: Configuration Helpers
Note: ============================================================================

Process called "configure_lexer_mode" takes lexer as Integer, mode as Integer returns Integer:
    Note:
    Change lexer mode after creation

    Parameters:
      lexer - Pointer to LexerState
      mode - New mode (LEXER_MODE_CANON, LEXER_MODE_DEVELOPER, LEXER_MODE_VIEWER)

    Returns:
      1 on success, 0 if mode is invalid
    :End Note

    If lexer is equal to 0:
        Return 0  Note: NULL lexer
    End If

    Note: Validate mode value (0=CANON, 1=DEVELOPER, 2=VIEWER)
    If mode is less than 0:
        Return 0  Note: Invalid mode
    End If
    If mode is greater than 2:
        Return 0  Note: Invalid mode
    End If

    Note: LexerState.mode is at offset 40 (5 fields × 8 bytes)
    proc memory_set_qword from Layout with lexer, 40, mode

    Return 1
End Process

Process called "configure_error_handling" takes lexer as Integer, strict as Integer, max_errors as Integer returns Integer:
    Note:
    Configure error handling behavior

    Parameters:
      lexer - Pointer to LexerState
      strict - Boolean: 1 for strict mode, 0 for permissive
      max_errors - Maximum errors before stopping (0 = unlimited)

    Returns:
      1 on success
    :End Note

    If lexer is equal to 0:
        Return 0  Note: NULL lexer
    End If

    Note: Validate strict (must be 0 or 1)
    If strict is less than 0:
        Return 0
    End If
    If strict is greater than 1:
        Return 0
    End If

    Note: Validate max_errors (must be non-negative)
    If max_errors is less than 0:
        Return 0
    End If

    Note: LexerState.strict_mode is at offset 144 (field 19 of 24)
    proc memory_set_qword from Layout with lexer, 144, strict

    Note: max_errors is stored in LexerConfig only, not in LexerState
    Note: It is passed as a parameter but not persisted in lexer structure

    Return 1
End Process

Process called "configure_indentation" takes lexer as Integer, indent_size as Integer, allow_tabs as Integer returns Integer:
    Note:
    Configure indentation handling

    Parameters:
      lexer - Pointer to LexerState
      indent_size - Number of spaces per indentation level
      allow_tabs - Boolean: 1 to allow tabs, 0 to disallow

    Returns:
      1 on success
    :End Note

    If lexer is equal to 0:
        Return 0  Note: NULL lexer
    End If

    Note: Validate indent_size (must be positive, typically 2 or 4)
    If indent_size is less than 1:
        Return 0  Note: Invalid indent size
    End If
    If indent_size is greater than 16:
        Return 0  Note: Unreasonably large
    End If

    Note: Validate allow_tabs (must be 0 or 1)
    If allow_tabs is less than 0:
        Return 0
    End If
    If allow_tabs is greater than 1:
        Return 0
    End If

    Note: LexerState.indent_size is at offset 56 (7 fields × 8 bytes)
    proc memory_set_qword from Layout with lexer, 56, indent_size

    Note: LexerState.allow_tabs is at offset 120
    proc memory_set_qword from Layout with lexer, 120, allow_tabs

    Return 1
End Process

Process called "configure_token_preservation" takes lexer as Integer, preserve_comments as Integer, preserve_whitespace as Integer returns Integer:
    Note:
    Configure which tokens to preserve vs discard

    Parameters:
      lexer - Pointer to LexerState
      preserve_comments - Boolean: 1 to keep comment tokens
      preserve_whitespace - Boolean: 1 to keep whitespace tokens

    Returns:
      1 on success
    :End Note

    If lexer is equal to 0:
        Return 0  Note: NULL lexer
    End If

    Note: Validate preserve_comments (must be 0 or 1)
    If preserve_comments is less than 0:
        Return 0
    End If
    If preserve_comments is greater than 1:
        Return 0
    End If

    Note: Validate preserve_whitespace (must be 0 or 1)
    If preserve_whitespace is less than 0:
        Return 0
    End If
    If preserve_whitespace is greater than 1:
        Return 0
    End If

    Note: Store preservation flags (offsets 168 and 176)
    proc memory_set_qword from Layout with lexer, 168, preserve_comments
    proc memory_set_qword from Layout with lexer, 176, preserve_whitespace

    Return 1
End Process

Note: ============================================================================
Note: Lexer Lifecycle Management
Note: ============================================================================

Process called "lexer_factory_cleanup" takes lexer as Integer returns Integer:
    Note:
    Clean up lexer and all associated resources

    Frees tokens array, errors array, keyword table, and lexer structure

    Parameters:
      lexer - Pointer to LexerState to clean up

    Returns:
      1 on success
    :End Note

    If lexer is equal to 0:
        Return 1  Note: NULL lexer, nothing to clean
    End If

    Note: Free tokens array (offset 80)
    Let tokens_array be proc memory_get_qword from Layout with lexer, 80

    If tokens_array is not equal to 0:
        Note: Get token count (offset 88)
        Let token_count be proc memory_get_qword from Layout with lexer, 88

        Note: Free each token structure in array
        Let token_index be 0
        While token_index is less than token_count:
            Let token_offset be token_index multiplied by 48  Note: Token struct is 48 bytes
            Let token_ptr be tokens_array plus token_offset

            Note: Free token if it's a dynamically allocated token
            If token_ptr is not equal to 0:
                Let dealloc_result be proc deallocate from Layout with token_ptr
            End If

            Set token_index to token_index plus 1
        End While

        Note: Free tokens array itself
        Let dealloc_result be proc deallocate from Layout with tokens_array
    End If

    Note: Free errors array (offset 152 - if exists)
    Let errors_array be proc memory_get_qword from Layout with lexer, 152

    If errors_array is not equal to 0:
        Let dealloc_result be proc deallocate from Layout with errors_array
    End If

    Note: Free indentation stack (offset 160 - if exists)
    Let indent_stack be proc memory_get_qword from Layout with lexer, 160

    If indent_stack is not equal to 0:
        Let dealloc_result be proc deallocate from Layout with indent_stack
    End If

    Note: Free keyword table (offset 168 - if exists)
    Let keyword_table be proc memory_get_qword from Layout with lexer, 168

    If keyword_table is not equal to 0:
        Let dealloc_result be proc deallocate from Layout with keyword_table
    End If

    Note: Free delimiter context (offset 176 - if exists)
    Let delimiter_context be proc memory_get_qword from Layout with lexer, 176

    If delimiter_context is not equal to 0:
        Let dealloc_result be proc deallocate from Layout with delimiter_context
    End If

    Note: Free the lexer structure itself
    Let dealloc_result be proc deallocate from Layout with lexer

    Return 1
End Process

Process called "lexer_reset" takes lexer as Integer returns Integer:
    Note:
    Reset lexer to initial state (for re-lexing)

    Resets lexer position and state without deallocating resources

    Parameters:
      lexer - Pointer to LexerState to reset

    Returns:
      1 on success
    :End Note

    If lexer is equal to 0:
        Return 0  Note: NULL lexer
    End If

    Note: Reset position tracking (offsets 16, 24, 32)
    proc memory_set_qword from Layout with lexer, 16, 0  Note: current_position = 0
    proc memory_set_qword from Layout with lexer, 24, 1  Note: line = 1
    proc memory_set_qword from Layout with lexer, 32, 1  Note: column = 1

    Note: Reset token count (offset 88)
    proc memory_set_qword from Layout with lexer, 88, 0  Note: token_count = 0

    Note: Reset error count (offset 96)
    proc memory_set_qword from Layout with lexer, 96, 0  Note: error_count = 0

    Note: Reset indentation level (offset 48)
    proc memory_set_qword from Layout with lexer, 48, 0  Note: current_indent_level = 0

    Note: Clear context flags (offsets 72, 76, 80)
    proc memory_set_qword from Layout with lexer, 72, 0  Note: in_string = 0
    proc memory_set_qword from Layout with lexer, 76, 0  Note: in_comment = 0
    proc memory_set_qword from Layout with lexer, 84, 0  Note: in_encasing = 0

    Return 1
End Process

Note: ============================================================================
Note: Convenience Functions
Note: ============================================================================

Process called "quick_tokenize_file" takes file_path as Integer returns Integer:
    Note:
    Convenience function: tokenize file and return token stream

    One-step operation: file -> tokens with automatic cleanup

    Parameters:
      file_path - Pointer to file path string

    Returns:
      Pointer to TokenStream with all tokens
      Returns 0 on error
    :End Note

    If file_path is equal to 0:
        Return 0  Note: NULL file path
    End If

    Note: Create lexer for file using Canon mode
    Let lexer be proc create_lexer_for_file with file_path, LEXER_MODE_CANON

    If lexer is equal to 0:
        Return 0  Note: Failed to create lexer from file
    End If

    Note: Tokenize entire file
    Let token_stream be proc lexer_tokenize_all from Lexer with lexer

    If token_stream is equal to 0:
        Note: Tokenization failed - clean up lexer and return error
        Let cleanup_result be proc lexer_factory_cleanup with lexer
        Return 0
    End If

    Note: Clean up lexer (token stream is independent structure)
    Let cleanup_result be proc lexer_factory_cleanup with lexer

    Return token_stream
End Process

Process called "quick_tokenize_string" takes source_code as Integer, source_length as Integer returns Integer:
    Note:
    Convenience function: tokenize string and return token stream

    One-step operation: string -> tokens
    Uses default Canon mode configuration

    Parameters:
      source_code - Pointer to source code string
      source_length - Length of source code

    Returns:
      Pointer to TokenStream with all tokens
      Returns 0 on error
    :End Note

    Note: Validate inputs
    If source_code is equal to 0:
        Return 0  Note: NULL source code
    End If

    If source_length is less than or equal to 0:
        Return 0  Note: Invalid source length
    End If

    Note: Create lexer with default Canon mode
    Let lexer be proc create_lexer_for_string with source_code, source_length, LEXER_MODE_CANON

    If lexer is equal to 0:
        Return 0  Note: Failed to create lexer
    End If

    Note: Tokenize entire source code
    Let token_stream be proc lexer_tokenize_all from Lexer with lexer

    Note: Return token stream (0 on error)
    Return token_stream
End Process

Note: ============================================================================
Note: Utility Functions
Note: ============================================================================

Process called "validate_lexer_config" takes config as Integer returns Integer:
    Note:
    Validate lexer configuration settings

    Checks:
      - Mode is valid value
      - indent_size is positive
      - max_errors is non-negative
      - Boolean flags are 0 or 1
    :End Note

    If config is equal to 0:
        Return 0  Note: NULL config
    End If

    Note: Validate mode (0=CANON, 1=DEVELOPER, 2=VIEWER)
    Let mode be proc memory_get_qword from Layout with config, 0

    If mode is less than 0:
        Return 0  Note: Invalid mode
    End If
    If mode is greater than 2:
        Return 0  Note: Invalid mode
    End If

    Note: Validate boolean fields (must be 0 or 1)
    Let strict_mode be proc memory_get_qword from Layout with config, 8
    Let allow_tabs be proc memory_get_qword from Layout with config, 16
    Let preserve_comments be proc memory_get_qword from Layout with config, 32
    Let preserve_whitespace be proc memory_get_qword from Layout with config, 40
    Let report_warnings be proc memory_get_qword from Layout with config, 48

    If strict_mode is less than 0:
        Return 0
    End If
    If strict_mode is greater than 1:
        Return 0
    End If
    If allow_tabs is less than 0:
        Return 0
    End If
    If allow_tabs is greater than 1:
        Return 0
    End If
    If preserve_comments is less than 0:
        Return 0
    End If
    If preserve_comments is greater than 1:
        Return 0
    End If
    If preserve_whitespace is less than 0:
        Return 0
    End If
    If preserve_whitespace is greater than 1:
        Return 0
    End If
    If report_warnings is less than 0:
        Return 0
    End If
    If report_warnings is greater than 1:
        Return 0
    End If

    Note: Validate indent_size (must be positive, typically 2 or 4)
    Let indent_size be proc memory_get_qword from Layout with config, 24

    If indent_size is less than 1:
        Return 0  Note: Invalid indent size
    End If
    If indent_size is greater than 16:
        Return 0  Note: Unreasonably large indent
    End If

    Note: Validate max_errors (must be non-negative)
    Let max_errors be proc memory_get_qword from Layout with config, 56

    If max_errors is less than 0:
        Return 0  Note: Invalid max_errors
    End If

    Return 1  Note: Valid configuration
End Process

Process called "clone_lexer_config" takes arena as Integer, config as Integer returns Integer:
    Note:
    Create a copy of lexer configuration

    Parameters:
      config - Pointer to LexerConfig to clone

    Returns:
      Pointer to new LexerConfig with same settings
      Returns 0 on allocation failure
    :End Note

    If config is equal to 0:
        Return 0  Note: NULL config
    End If

    Note: Allocate new config structure
    Let config_size be 64
    Let new_config be proc arena_allocate from Layout with arena, config_size

    If new_config is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Copy all 8 fields
    Let mode be proc memory_get_qword from Layout with config, 0
    Let strict_mode be proc memory_get_qword from Layout with config, 8
    Let allow_tabs be proc memory_get_qword from Layout with config, 16
    Let indent_size be proc memory_get_qword from Layout with config, 24
    Let preserve_comments be proc memory_get_qword from Layout with config, 32
    Let preserve_whitespace be proc memory_get_qword from Layout with config, 40
    Let report_warnings be proc memory_get_qword from Layout with config, 48
    Let max_errors be proc memory_get_qword from Layout with config, 56

    proc memory_set_qword from Layout with new_config, 0, mode
    proc memory_set_qword from Layout with new_config, 8, strict_mode
    proc memory_set_qword from Layout with new_config, 16, allow_tabs
    proc memory_set_qword from Layout with new_config, 24, indent_size
    proc memory_set_qword from Layout with new_config, 32, preserve_comments
    proc memory_set_qword from Layout with new_config, 40, preserve_whitespace
    proc memory_set_qword from Layout with new_config, 48, report_warnings
    proc memory_set_qword from Layout with new_config, 56, max_errors

    Return new_config
End Process
