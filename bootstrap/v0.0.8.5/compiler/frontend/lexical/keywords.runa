Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file defines and manages Runa language keywords and reserved words.

This file performs the following tasks:
- Define all Runa language keywords (Let, Set, If, Otherwise, etc.)
- Provide keyword recognition and tokenization
- Handle keyword context and scope validation
- Manage reserved word conflicts and validation
- Support multi-word keywords and natural language operators

This file is essential because of the following reasons:
- Keywords are the foundation of Runa's natural language syntax
- Proper keyword handling ensures correct language parsing
- Keyword validation prevents naming conflicts and syntax errors
- Multi-word keyword support enables natural language expressions

This file consists of the following functions/features/operation types:
- Keyword definition and lookup tables
- Keyword recognition and tokenization functions
- Context-sensitive keyword validation
- Reserved word conflict detection and resolution
- Multi-word keyword phrase matching

Dependencies:
- Imports collections/hashtable.runa for keyword lookup table
- Imports core/string_core.runa for string comparison
- Imports memory/layout.runa for Token allocation
:End Note

Import "compiler/frontend/primitives/collections/hashtable.runa" as HashTable
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/memory/layout.runa" as Layout

Note: ============================================================================
Note: Token Type Constants for Keywords
Note: ============================================================================

Note: These constants define the token types for Runa keywords
Note: Grouped by category for organization

Note: Variable and Constant Keywords
Constant TOKEN_LET as Integer is 300         Note: Let (variable declaration)
Constant TOKEN_SET as Integer is 301         Note: Set (variable assignment)

Note: Control Flow Keywords
Constant TOKEN_IF as Integer is 310          Note: If
Constant TOKEN_OTHERWISE as Integer is 311   Note: Otherwise (else)
Constant TOKEN_UNLESS as Integer is 312      Note: Unless (negated if)
Constant TOKEN_WHEN as Integer is 313        Note: When (case)
Constant TOKEN_MATCH as Integer is 314       Note: Match (pattern matching)
Constant TOKEN_FOR as Integer is 315         Note: For (loop)
Constant TOKEN_WHILE as Integer is 316       Note: While (loop)
Constant TOKEN_LOOP as Integer is 317        Note: Loop (infinite loop)
Constant TOKEN_BREAK as Integer is 318       Note: Break
Constant TOKEN_CONTINUE as Integer is 319    Note: Continue

Note: Function and Type Keywords
Constant TOKEN_PROCESS as Integer is 320     Note: Process (function definition)
Constant TOKEN_TYPE as Integer is 321        Note: Type (type definition)
Constant TOKEN_PROTOCOL as Integer is 322    Note: Protocol (interface definition)
Constant TOKEN_RETURN as Integer is 323      Note: Return
Constant TOKEN_YIELD as Integer is 324       Note: Yield (generator)

Note: Import and Module Keywords
Constant TOKEN_IMPORT as Integer is 330      Note: Import
Constant TOKEN_FROM as Integer is 331        Note: From (import source)
Constant TOKEN_AS as Integer is 332          Note: As (alias)

Note: Exception Handling Keywords
Constant TOKEN_TRY as Integer is 340         Note: Try
Constant TOKEN_CATCH as Integer is 341       Note: Catch
Constant TOKEN_FINALLY as Integer is 342     Note: Finally
Constant TOKEN_THROW as Integer is 343       Note: Throw

Note: Visibility and Modifier Keywords
Constant TOKEN_PRIVATE as Integer is 351     Note: Private
Constant TOKEN_STATIC as Integer is 352      Note: Static
Constant TOKEN_ASYNC as Integer is 353       Note: Async

Note: Concurrency Keywords
Constant TOKEN_AWAIT as Integer is 360       Note: Await
Constant TOKEN_SEND as Integer is 361        Note: Send (message passing)
Constant TOKEN_RECEIVE as Integer is 362     Note: Receive (message passing)
Constant TOKEN_SPAWN as Integer is 363       Note: Spawn (create process)

Note: Other Keywords
Constant TOKEN_NEW as Integer is 370         Note: New (object creation)
Constant TOKEN_DELETE as Integer is 371      Note: Delete (memory deallocation)
Constant TOKEN_WITH as Integer is 372        Note: With (context manager)
Constant TOKEN_ASSERT as Integer is 373      Note: Assert (assertion)
Constant TOKEN_ALERT as Integer is 374       Note: Alert (warning)
Constant TOKEN_DISPLAY as Integer is 375     Note: Display (output)

Note: Natural Language Operator Keywords
Constant TOKEN_AND as Integer is 380         Note: And (logical and)
Constant TOKEN_OR as Integer is 381          Note: Or (logical or)
Constant TOKEN_NOT as Integer is 382         Note: Not (logical not)
Constant TOKEN_IS as Integer is 383          Note: Is (equality/type check)
Constant TOKEN_IN as Integer is 384          Note: In (containment)
Constant TOKEN_OF as Integer is 385          Note: Of (possession)
Constant TOKEN_TO as Integer is 386          Note: To (direction/target)
Constant TOKEN_BY as Integer is 387          Note: By (agent/increment)
Constant TOKEN_WITH as Integer is 388        Note: With (accompaniment)
Constant TOKEN_BE as Integer is 389          Note: Be (state)

Note: Arithmetic Word Keywords (Canon Mode)
Constant TOKEN_PLUS as Integer is 390        Note: Plus (addition)
Constant TOKEN_MINUS as Integer is 391       Note: Minus (subtraction)
Constant TOKEN_MULTIPLIED as Integer is 393  Note: Multiplied (multiplication phrase start)
Constant TOKEN_DIVIDED as Integer is 394     Note: Divided (division phrase start)
Constant TOKEN_MODULO as Integer is 395      Note: Modulo (remainder)
Constant TOKEN_POWER as Integer is 396       Note: Power (exponentiation)

Note: Comparison Word Keywords (Canon Mode)
Constant TOKEN_EQUAL as Integer is 400       Note: Equal (equality keyword)
Constant TOKEN_GREATER as Integer is 401     Note: Greater (comparison)
Constant TOKEN_LESS as Integer is 402        Note: Less (comparison)
Constant TOKEN_THAN as Integer is 403        Note: Than (comparison complement)
Constant TOKEN_CONTAINS as Integer is 404    Note: Contains (collection membership)

Note: Boolean Literals (treated as keywords)
Constant TOKEN_TRUE as Integer is 410        Note: True
Constant TOKEN_FALSE as Integer is 411       Note: False

Note: Null Literals (treated as keywords)
Constant TOKEN_NULL as Integer is 420        Note: Null
Constant TOKEN_NONE as Integer is 421        Note: None
Constant TOKEN_NIL as Integer is 422         Note: Nil

Note: End Keyword (for block termination)
Constant TOKEN_END as Integer is 430         Note: End (block terminator)

Note: Function Syntax Keywords
Constant TOKEN_PROC as Integer is 440        Note: proc (function call prefix)
Constant TOKEN_RETURNS as Integer is 444     Note: returns (return type)

Note: Constant Declaration Keyword
Constant TOKEN_CONSTANT as Integer is 460    Note: Constant (immutable declaration)

Note: Loop Control Keywords
Constant TOKEN_DO as Integer is 473          Note: Do (do-while loop)
Constant TOKEN_REPEAT as Integer is 474      Note: Repeat (repeat loop)

Note: Imperative Compound Assignment Keywords
Constant TOKEN_INCREASE as Integer is 480    Note: Increase (imperative increment)
Constant TOKEN_DECREASE as Integer is 481    Note: Decrease (imperative decrement)
Constant TOKEN_MULTIPLY as Integer is 482    Note: Multiply (imperative multiply)
Constant TOKEN_DIVIDE as Integer is 483      Note: Divide (imperative divide)

Note: Compound Assignment Phrase Keywords
Constant TOKEN_GETS as Integer is 490        Note: gets (in "gets increased by")
Constant TOKEN_INCREASED as Integer is 491   Note: increased (in "gets increased by")
Constant TOKEN_DECREASED as Integer is 492   Note: decreased (in "gets decreased by")

Note: Bitwise Operation Keywords
Constant TOKEN_BITWISE as Integer is 500     Note: bitwise (bitwise operations)
Constant TOKEN_XOR as Integer is 501         Note: xor (bitwise XOR)
Constant TOKEN_SHIFTED as Integer is 502     Note: shifted (bit shifting)
Constant TOKEN_LEFT as Integer is 503        Note: left (in "shifted left by")
Constant TOKEN_RIGHT as Integer is 504       Note: right (in "shifted right by")

Note: Unary Operator Keywords
Constant TOKEN_NEGATIVE as Integer is 540    Note: negative (unary negation)
Constant TOKEN_POSITIVE as Integer is 541    Note: positive (unary positive)

Note: String Operation Keywords
Constant TOKEN_JOINED as Integer is 560      Note: joined (in "joined with")

Note: Type Combinator Keywords
Constant TOKEN_OR_TYPE as Integer is 570     Note: OR (union types)
Constant TOKEN_AND_TYPE as Integer is 571    Note: AND (intersection types)

Note: Type System Keywords
Constant TOKEN_POINTER as Integer is 580     Note: Pointer (function pointer types)

Note: Inline Assembly Keywords
Constant TOKEN_INLINE as Integer is 590      Note: Inline (inline assembly)
Constant TOKEN_ASSEMBLY as Integer is 591    Note: Assembly (inline assembly block)

Note: Comment Keywords
Constant TOKEN_NOTE as Integer is 600        Note: Note (comment marker)

Note: Ownership and Borrowing Keywords
Constant TOKEN_DEFINE as Integer is 601      Note: Define (ownership declaration)
Constant TOKEN_BORROW as Integer is 602      Note: Borrow (borrowed reference)
Constant TOKEN_MOVE as Integer is 603        Note: Move (ownership transfer)

Note: ============================================================================
Note: Keyword Lookup Table Structure
Note: ============================================================================

Type called "KeywordTable":
    keyword_map as Integer        Note: HashTable mapping keyword string -> token type
    multi_word_keywords as Integer Note: Array of multi-word keyword patterns
    keyword_count as Integer      Note: Total number of keywords registered
    case_sensitive as Integer     Note: Boolean: 1 if keywords are case-sensitive (they are)

Type called "MultiWordKeyword":
    words as Integer             Note: Array of pointers to word strings
    word_count as Integer        Note: Number of words in this keyword phrase
    token_type as Integer        Note: Token type for this multi-word keyword
    min_words as Integer         Note: Minimum words required (for partial matching)

Note: ============================================================================
Note: Keyword Table Initialization
Note: ============================================================================

Process called "create_keyword_table" returns Integer:
    Note:
    Create and initialize the keyword lookup table.
    Populates with all Runa keywords including multi-word phrases.
    Returns pointer to initialized KeywordTable, or 0 on failure.
    :End Note

    Note: KeywordTable: 4 fields × 8 bytes = 32 bytes
    Let table_size be 32
    Let table be proc allocate from Layout with table_size

    If table is equal to 0:
        Return 0
    End If

    Note: Create hashtable for keyword mapping (initial capacity 128)
    Let keyword_map be proc create from HashTable with 128

    If keyword_map is equal to 0:
        Let dummy1 be proc deallocate from Layout with table
        Return 0
    End If

    Note: Store keyword_map in table
    Let dummy2 be proc memory_set_int64 from Layout with table, 0, keyword_map

    Note: Initialize other fields: multi_word_keywords=0, keyword_count=0, case_sensitive=1
    Let dummy3 be proc memory_set_int64 from Layout with table, 8, 0
    Let dummy4 be proc memory_set_int64 from Layout with table, 16, 0
    Let dummy5 be proc memory_set_int64 from Layout with table, 24, 1

    Note: Register all single-word keywords
    Let dummy6 be proc register_keyword with table, "Let", TOKEN_LET
    Let dummy7 be proc register_keyword with table, "Set", TOKEN_SET
    Let dummy8 be proc register_keyword with table, "If", TOKEN_IF
    Let dummy9 be proc register_keyword with table, "Otherwise", TOKEN_OTHERWISE
    Let dummy10 be proc register_keyword with table, "Unless", TOKEN_UNLESS
    Let dummy11 be proc register_keyword with table, "When", TOKEN_WHEN
    Let dummy12 be proc register_keyword with table, "Match", TOKEN_MATCH
    Let dummy13 be proc register_keyword with table, "For", TOKEN_FOR
    Let dummy14 be proc register_keyword with table, "While", TOKEN_WHILE
    Let dummy15 be proc register_keyword with table, "Loop", TOKEN_LOOP
    Let dummy16 be proc register_keyword with table, "Break", TOKEN_BREAK
    Let dummy17 be proc register_keyword with table, "Continue", TOKEN_CONTINUE
    Let dummy18 be proc register_keyword with table, "Process", TOKEN_PROCESS
    Let dummy19 be proc register_keyword with table, "Type", TOKEN_TYPE
    Let dummy20 be proc register_keyword with table, "Protocol", TOKEN_PROTOCOL
    Let dummy21 be proc register_keyword with table, "Return", TOKEN_RETURN
    Let dummy22 be proc register_keyword with table, "Yield", TOKEN_YIELD
    Let dummy23 be proc register_keyword with table, "Import", TOKEN_IMPORT
    Let dummy24 be proc register_keyword with table, "From", TOKEN_FROM
    Let dummy25 be proc register_keyword with table, "As", TOKEN_AS
    Let dummy26 be proc register_keyword with table, "Try", TOKEN_TRY
    Let dummy27 be proc register_keyword with table, "Catch", TOKEN_CATCH
    Let dummy28 be proc register_keyword with table, "Finally", TOKEN_FINALLY
    Let dummy29 be proc register_keyword with table, "Throw", TOKEN_THROW
    Let dummy30 be proc register_keyword with table, "Private", TOKEN_PRIVATE
    Let dummy31 be proc register_keyword with table, "Static", TOKEN_STATIC
    Let dummy32 be proc register_keyword with table, "Async", TOKEN_ASYNC
    Let dummy33 be proc register_keyword with table, "Await", TOKEN_AWAIT
    Let dummy34 be proc register_keyword with table, "Send", TOKEN_SEND
    Let dummy35 be proc register_keyword with table, "Receive", TOKEN_RECEIVE
    Let dummy36 be proc register_keyword with table, "Spawn", TOKEN_SPAWN
    Let dummy37 be proc register_keyword with table, "New", TOKEN_NEW
    Let dummy38 be proc register_keyword with table, "Delete", TOKEN_DELETE
    Let dummy39 be proc register_keyword with table, "With", TOKEN_WITH
    Let dummy40 be proc register_keyword with table, "Assert", TOKEN_ASSERT
    Let dummy41 be proc register_keyword with table, "Alert", TOKEN_ALERT
    Let dummy42 be proc register_keyword with table, "Display", TOKEN_DISPLAY
    Let dummy43 be proc register_keyword with table, "And", TOKEN_AND
    Let dummy44 be proc register_keyword with table, "Or", TOKEN_OR
    Let dummy45 be proc register_keyword with table, "Not", TOKEN_NOT
    Let dummy46 be proc register_keyword with table, "Is", TOKEN_IS
    Let dummy47 be proc register_keyword with table, "In", TOKEN_IN
    Let dummy48 be proc register_keyword with table, "Of", TOKEN_OF
    Let dummy49 be proc register_keyword with table, "To", TOKEN_TO
    Let dummy50 be proc register_keyword with table, "By", TOKEN_BY
    Let dummy51 be proc register_keyword with table, "Be", TOKEN_BE
    Let dummy52 be proc register_keyword with table, "Plus", TOKEN_PLUS
    Let dummy53 be proc register_keyword with table, "Minus", TOKEN_MINUS
    Let dummy54 be proc register_keyword with table, "Multiplied", TOKEN_MULTIPLIED
    Let dummy55 be proc register_keyword with table, "Divided", TOKEN_DIVIDED
    Let dummy56 be proc register_keyword with table, "Modulo", TOKEN_MODULO
    Let dummy57 be proc register_keyword with table, "Power", TOKEN_POWER
    Let dummy58 be proc register_keyword with table, "Equal", TOKEN_EQUAL
    Let dummy59 be proc register_keyword with table, "Greater", TOKEN_GREATER
    Let dummy60 be proc register_keyword with table, "Less", TOKEN_LESS
    Let dummy61 be proc register_keyword with table, "Than", TOKEN_THAN
    Let dummy62 be proc register_keyword with table, "Contains", TOKEN_CONTAINS
    Let dummy63 be proc register_keyword with table, "True", TOKEN_TRUE
    Let dummy64 be proc register_keyword with table, "False", TOKEN_FALSE
    Let dummy65 be proc register_keyword with table, "Null", TOKEN_NULL
    Let dummy66 be proc register_keyword with table, "None", TOKEN_NONE
    Let dummy67 be proc register_keyword with table, "Nil", TOKEN_NIL
    Let dummy68 be proc register_keyword with table, "End", TOKEN_END

    Note: Function Syntax Keywords
    Let dummy69 be proc register_keyword with table, "proc", TOKEN_PROC
    Let dummy70 be proc register_keyword with table, "returns", TOKEN_RETURNS

    Note: Constant Declaration Keyword
    Let dummy71 be proc register_keyword with table, "Constant", TOKEN_CONSTANT

    Note: Loop Control Keywords
    Let dummy72 be proc register_keyword with table, "Do", TOKEN_DO
    Let dummy73 be proc register_keyword with table, "Repeat", TOKEN_REPEAT

    Note: Imperative Compound Assignment Keywords
    Let dummy74 be proc register_keyword with table, "Increase", TOKEN_INCREASE
    Let dummy75 be proc register_keyword with table, "Decrease", TOKEN_DECREASE
    Let dummy76 be proc register_keyword with table, "Multiply", TOKEN_MULTIPLY
    Let dummy77 be proc register_keyword with table, "Divide", TOKEN_DIVIDE

    Note: Compound Assignment Phrase Keywords
    Let dummy78 be proc register_keyword with table, "gets", TOKEN_GETS
    Let dummy79 be proc register_keyword with table, "increased", TOKEN_INCREASED
    Let dummy80 be proc register_keyword with table, "decreased", TOKEN_DECREASED

    Note: Bitwise Operation Keywords
    Let dummy81 be proc register_keyword with table, "bitwise", TOKEN_BITWISE
    Let dummy82 be proc register_keyword with table, "xor", TOKEN_XOR
    Let dummy83 be proc register_keyword with table, "shifted", TOKEN_SHIFTED
    Let dummy84 be proc register_keyword with table, "left", TOKEN_LEFT
    Let dummy85 be proc register_keyword with table, "right", TOKEN_RIGHT

    Note: Unary Operator Keywords
    Let dummy86 be proc register_keyword with table, "negative", TOKEN_NEGATIVE
    Let dummy87 be proc register_keyword with table, "positive", TOKEN_POSITIVE

    Note: String Operation Keywords
    Let dummy88 be proc register_keyword with table, "joined", TOKEN_JOINED

    Note: Type Combinator Keywords
    Let dummy89 be proc register_keyword with table, "OR", TOKEN_OR_TYPE
    Let dummy90 be proc register_keyword with table, "AND", TOKEN_AND_TYPE

    Note: Type System Keywords
    Let dummy91 be proc register_keyword with table, "Pointer", TOKEN_POINTER

    Note: Inline Assembly Keywords
    Let dummy92 be proc register_keyword with table, "Inline", TOKEN_INLINE
    Let dummy93 be proc register_keyword with table, "Assembly", TOKEN_ASSEMBLY

    Note: Comment Keywords
    Let dummy94 be proc register_keyword with table, "Note", TOKEN_NOTE

    Note: Ownership and Borrowing Keywords
    Let dummy95 be proc register_keyword with table, "Define", TOKEN_DEFINE
    Let dummy96 be proc register_keyword with table, "Borrow", TOKEN_BORROW
    Let dummy97 be proc register_keyword with table, "Move", TOKEN_MOVE

    Return table
End Process

Process called "register_keyword" takes table as Integer, keyword as Integer, token_type as Integer returns Integer:
    Note:
    Register a single-word keyword in the lookup table.
    Adds keyword->token_type mapping to hashtable.
    Returns 1 on success, 0 on failure.
    :End Note

    Note: Get keyword_map from table (offset 0)
    Let keyword_map be proc memory_get_int64 from Layout with table, 0

    Note: Add keyword to hashtable with token_type as value
    Let success be proc set from HashTable with keyword_map, keyword, token_type

    If success is equal to 0:
        Return 0
    End If

    Note: Increment keyword_count (offset 16)
    Let current_count be proc memory_get_int64 from Layout with table, 16
    Let new_count be current_count plus 1
    Let dummy1 be proc memory_set_int64 from Layout with table, 16, new_count

    Return 1
End Process

Process called "register_multi_word_keyword" takes arena as Integer, table as Integer, words as Integer, word_count as Integer, token_type as Integer returns Integer:
    Note:
    Register multi-word keyword phrase.
    Creates MultiWordKeyword structure and adds to table.
    Returns 1 on success, 0 on failure.
    :End Note

    Note: MultiWordKeyword: 4 fields × 8 bytes = 32 bytes
    Let mwk_size be 32
    Let mwk be proc arena_allocate from Layout with arena, mwk_size

    If mwk is equal to 0:
        Return 0
    End If

    Note: Store fields: words, word_count, token_type, min_words (same as word_count)
    Let dummy1 be proc memory_set_int64 from Layout with mwk, 0, words
    Let dummy2 be proc memory_set_int64 from Layout with mwk, 8, word_count
    Let dummy3 be proc memory_set_int64 from Layout with mwk, 16, token_type
    Let dummy4 be proc memory_set_int64 from Layout with mwk, 24, word_count

    Note: Get multi_word_keywords array from table (offset 8)
    Let array_ptr be proc memory_get_int64 from Layout with table, 8

    Note: If array doesn't exist, create it
    If array_ptr is equal to 0:
        Note: Array structure: capacity (8), count (8), items (capacity × 8)
        Let initial_capacity be 16
        Let array_size be 16 plus initial_capacity multiplied by 8
        Set array_ptr to proc arena_allocate from Layout with arena, array_size

        If array_ptr is equal to 0:
            Return 0
        End If

        Note: Initialize capacity and count
        Let dummy6 be proc memory_set_int64 from Layout with array_ptr, 0, initial_capacity
        Let dummy7 be proc memory_set_int64 from Layout with array_ptr, 8, 0

        Note: Store array pointer in table
        Let dummy8 be proc memory_set_int64 from Layout with table, 8, array_ptr
    End If

    Note: Get current capacity and count
    Let capacity be proc memory_get_int64 from Layout with array_ptr, 0
    Let count be proc memory_get_int64 from Layout with array_ptr, 8

    Note: Check if array needs to grow
    If count is equal to capacity:
        Note: Double the capacity
        Let new_capacity be capacity multiplied by 2
        Let new_array_size be 16 plus new_capacity multiplied by 8
        Let new_array_ptr be proc arena_allocate from Layout with arena, new_array_size

        If new_array_ptr is equal to 0:
            Return 0
        End If

        Note: Copy capacity and count
        Let dummy10 be proc memory_set_int64 from Layout with new_array_ptr, 0, new_capacity
        Let dummy11 be proc memory_set_int64 from Layout with new_array_ptr, 8, count

        Note: Copy existing items
        Let i be 0
        While i is less than count:
            Let src_offset be 16 plus i multiplied by 8
            Let dst_offset be 16 plus i multiplied by 8
            Let item be proc memory_get_int64 from Layout with array_ptr, src_offset
            Let dummy12 be proc memory_set_int64 from Layout with new_array_ptr, dst_offset, item
            Set i to i plus 1
        End While

        Note: Update pointer to new array (old array cleaned up by arena)
        Set array_ptr to new_array_ptr
        Let dummy14 be proc memory_set_int64 from Layout with table, 8, new_array_ptr
        Set capacity to new_capacity
    End If

    Note: Add MultiWordKeyword to array at index count
    Let item_offset be 16 plus count multiplied by 8
    Let dummy15 be proc memory_set_int64 from Layout with array_ptr, item_offset, mwk

    Note: Increment count
    Let new_count be count plus 1
    Let dummy16 be proc memory_set_int64 from Layout with array_ptr, 8, new_count

    Return 1
End Process

Note: ============================================================================
Note: Keyword Recognition
Note: ============================================================================

Process called "lookup_keyword" takes table as Integer, identifier as Integer returns Integer:
    Note:
    Look up identifier in keyword table.
    Returns token type if keyword, 0 if not (case-sensitive).
    :End Note

    Note: Get keyword_map from table
    Let keyword_map be proc memory_get_int64 from Layout with table, 0

    Note: Look up identifier in hashtable
    Let token_type be proc get from HashTable with keyword_map, identifier

    Return token_type
End Process

Process called "try_match_multi_word_keyword" takes arena as Integer, table as Integer, lexer as Integer, first_word as Integer returns Integer:
    Note:
    Attempt to match multi-word keyword phrase.
    Looks ahead to check if tokens form complete phrase.
    Returns MultiWordKeyword pointer if matched, 0 otherwise.
    :End Note

    Note: Get multi_word_keywords array from table (offset 8)
    Let array_ptr be proc memory_get_int64 from Layout with table, 8

    Note: If no multi-word keywords registered, return 0
    If array_ptr is equal to 0:
        Return 0
    End If

    Note: Get count of registered multi-word keywords
    Let count be proc memory_get_int64 from Layout with array_ptr, 8

    If count is equal to 0:
        Return 0
    End If

    Note: Get lexer source and current position
    Let source be proc memory_get_int64 from Layout with lexer, 0
    Let current_pos be proc memory_get_int64 from Layout with lexer, 16

    Note: Iterate through all registered multi-word keywords
    Let i be 0
    While i is less than count:
        Let item_offset be 16 plus i multiplied by 8
        Let mwk be proc memory_get_int64 from Layout with array_ptr, item_offset

        Note: Get words array and word count from MultiWordKeyword
        Let words_array be proc memory_get_int64 from Layout with mwk, 0
        Let word_count be proc memory_get_int64 from Layout with mwk, 8

        Note: Check if first word matches
        Let first_keyword be proc memory_get_int64 from Layout with words_array, 0
        Let first_match be proc string_compare from StringCore with first_word, first_keyword

        If first_match is equal to 1:
            Note: First word matches, check remaining words
            Let all_match be 1
            Let lookahead_pos be current_pos
            Let word_idx be 1

            Note: Skip whitespace after first word
            While word_idx is less than word_count:
                Note: Skip whitespace
                Let scanning_ws be 1
                While scanning_ws is equal to 1:
                    Let char_val be proc memory_get_byte from StringCore with source, lookahead_pos
                    If char_val is equal to 32:  Note: Space
                        Set lookahead_pos to lookahead_pos plus 1
                    Otherwise:
                        If char_val is equal to 9:  Note: Tab
                            Set lookahead_pos to lookahead_pos plus 1
                        Otherwise:
                            Set scanning_ws to 0
                        End If
                    End If
                End While

                Note: Extract next word from source
                Let word_start be lookahead_pos
                Let word_end be lookahead_pos

                Let scanning_word be 1
                While scanning_word is equal to 1:
                    Let char_val be proc memory_get_byte from StringCore with source, word_end
                    Note: Check if alphanumeric (A-Z: 65-90, a-z: 97-122)
                    If char_val is greater than or equal to 65:
                        If char_val is less than or equal to 90:
                            Set word_end to word_end plus 1
                        Otherwise:
                            If char_val is greater than or equal to 97:
                                If char_val is less than or equal to 122:
                                    Set word_end to word_end plus 1
                                Otherwise:
                                    Set scanning_word to 0
                                End If
                            Otherwise:
                                Set scanning_word to 0
                            End If
                        End If
                    Otherwise:
                        Set scanning_word to 0
                    End If
                End While

                Note: Extract word and compare
                Let word_length be word_end minus word_start
                Let extracted_word be proc arena_allocate from Layout with arena, word_length plus 1

                Let copy_idx be 0
                While copy_idx is less than word_length:
                    Let byte_val be proc memory_get_byte from StringCore with source, word_start plus copy_idx
                    Let dummy1 be proc memory_set_byte from StringCore with extracted_word, copy_idx, byte_val
                    Set copy_idx to copy_idx plus 1
                End While

                Let dummy2 be proc memory_set_byte from StringCore with extracted_word, word_length, 0

                Note: Get expected word from pattern
                Let expected_offset be word_idx multiplied by 8
                Let expected_word be proc memory_get_int64 from Layout with words_array, expected_offset

                Note: Compare words (extracted_word cleaned up by arena)
                Let word_match be proc string_compare from StringCore with extracted_word, expected_word

                If word_match is not equal to 1:
                    Set all_match to 0
                    Set word_idx to word_count  Note: Break out of loop
                Otherwise:
                    Set lookahead_pos to word_end
                    Set word_idx to word_idx plus 1
                End If
            End While

            Note: If all words matched, return this MultiWordKeyword
            If all_match is equal to 1:
                Return mwk
            End If
        End If

        Set i to i plus 1
    End While

    Note: No match found
    Return 0
End Process

Process called "tokenize_keyword" takes lexer as Integer, keyword_string as Integer, token_type as Integer, start_line as Integer, start_column as Integer returns Integer:
    Note:
    Create token for recognized keyword.
    Allocates and populates Token structure.
    Returns Token pointer or 0 on failure.
    :End Note

    Note: Token: 6 fields × 8 bytes = 48 bytes
    Let token_size be 48
    Let token be proc allocate from Layout with token_size

    If token is equal to 0:
        Return 0
    End If

    Note: Get keyword length
    Let keyword_length be proc string_length from StringCore with keyword_string

    Note: Populate Token fields: token_type, value, line, column, length, literal_metadata=0
    Let dummy1 be proc memory_set_int64 from Layout with token, 0, token_type
    Let dummy2 be proc memory_set_int64 from Layout with token, 8, keyword_string
    Let dummy3 be proc memory_set_int64 from Layout with token, 16, start_line
    Let dummy4 be proc memory_set_int64 from Layout with token, 24, start_column
    Let dummy5 be proc memory_set_int64 from Layout with token, 32, keyword_length
    Let dummy6 be proc memory_set_int64 from Layout with token, 40, 0

    Return token
End Process

Note: ============================================================================
Note: Context-Sensitive Keyword Validation
Note: ============================================================================

Process called "validate_keyword_context" takes token_type as Integer, context as Integer returns Integer:
    Note:
    Validate keyword is used in appropriate context.
    Checks context flags for keywords with restrictions.
    Returns 1 if valid, 0 if invalid.
    :End Note

    Note: Context bit flags: bit 0=in Process, bit 1=in loop, bit 2=after If, bit 3=in Try, bit 4=after Catch

    Note: Check Return (only valid inside Process)
    If token_type is equal to TOKEN_RETURN:
        Let in_process be context bitwise and 1
        If in_process is equal to 0:
            Return 0
        End If
    End If

    Note: Check Break/Continue (only valid in loop)
    If token_type is equal to TOKEN_BREAK:
        Let in_loop be context bitwise and 2
        If in_loop is equal to 0:
            Return 0
        End If
    End If

    If token_type is equal to TOKEN_CONTINUE:
        Let in_loop be context bitwise and 2
        If in_loop is equal to 0:
            Return 0
        End If
    End If

    Note: Check Otherwise (only valid after If)
    If token_type is equal to TOKEN_OTHERWISE:
        Let after_if be context bitwise and 4
        If after_if is equal to 0:
            Return 0
        End If
    End If

    Note: Check Catch (only valid after Try)
    If token_type is equal to TOKEN_CATCH:
        Let in_try be context bitwise and 8
        If in_try is equal to 0:
            Return 0
        End If
    End If

    Note: Check Finally (only valid after Try or Catch)
    If token_type is equal to TOKEN_FINALLY:
        Let in_try_catch be context bitwise and 24  Note: bits 3 and 4
        If in_try_catch is equal to 0:
            Return 0
        End If
    End If

    Return 1
End Process

Process called "is_reserved_word" takes table as Integer, identifier as Integer returns Integer:
    Note:
    Check if identifier is reserved keyword.
    Returns 1 if reserved, 0 if available for use.
    :End Note

    Note: Look up identifier in keyword table
    Let token_type be proc lookup_keyword with table, identifier

    Note: If token_type is non-zero, it's a reserved keyword
    If token_type is not equal to 0:
        Return 1
    End If

    Return 0
End Process

Process called "compute_levenshtein_distance" takes arena as Integer, str1 as Integer, str2 as Integer returns Integer:
    Note:
    Calculate Levenshtein distance between two strings.
    Uses dynamic programming algorithm for edit distance.
    Returns minimum number of edits (insert, delete, substitute) needed.
    :End Note

    Note: Get string lengths
    Let len1 be proc string_length from StringCore with str1
    Let len2 be proc string_length from StringCore with str2

    Note: Handle edge cases
    If len1 is equal to 0:
        Return len2
    End If

    If len2 is equal to 0:
        Return len1
    End If

    Note: Allocate distance matrix: (len1+1) × (len2+1)
    Let rows be len1 plus 1
    Let cols be len2 plus 1
    Let matrix_size be rows multiplied by cols multiplied by 8
    Let matrix be proc arena_allocate from Layout with arena, matrix_size

    Note: Initialize first row (0, 1, 2, 3, ...)
    Let j be 0
    While j is less than cols:
        Let offset be j multiplied by 8
        Let dummy1 be proc memory_set_int64 from Layout with matrix, offset, j
        Set j to j plus 1
    End While

    Note: Initialize first column (0, 1, 2, 3, ...)
    Let i be 0
    While i is less than rows:
        Let offset be i multiplied by cols multiplied by 8
        Let dummy2 be proc memory_set_int64 from Layout with matrix, offset, i
        Set i to i plus 1
    End While

    Note: Fill matrix using dynamic programming
    Set i to 1
    While i is less than rows:
        Let char1 be proc memory_get_byte from StringCore with str1, i minus 1

        Let j be 1
        While j is less than cols:
            Let char2 be proc memory_get_byte from StringCore with str2, j minus 1

            Note: Get values from matrix: left, top, diagonal
            Let left_offset be i multiplied by cols plus j minus 1 multiplied by 8
            Let left_val be proc memory_get_int64 from Layout with matrix, left_offset

            Let top_offset be i minus 1 multiplied by cols plus j multiplied by 8
            Let top_val be proc memory_get_int64 from Layout with matrix, top_offset

            Let diag_offset be i minus 1 multiplied by cols plus j minus 1 multiplied by 8
            Let diag_val be proc memory_get_int64 from Layout with matrix, diag_offset

            Note: Calculate cost (0 if chars match, 1 if different)
            Let cost be 1
            If char1 is equal to char2:
                Set cost to 0
            End If

            Note: Calculate minimum of three operations
            Let substitute_cost be diag_val plus cost
            Let insert_cost be left_val plus 1
            Let delete_cost be top_val plus 1

            Note: Find minimum
            Let min_cost be substitute_cost
            If insert_cost is less than min_cost:
                Set min_cost to insert_cost
            End If
            If delete_cost is less than min_cost:
                Set min_cost to delete_cost
            End If

            Note: Store in matrix
            Let current_offset be i multiplied by cols plus j multiplied by 8
            Let dummy3 be proc memory_set_int64 from Layout with matrix, current_offset, min_cost

            Set j to j plus 1
        End While

        Set i to i plus 1
    End While

    Note: Get final distance (bottom-right cell)
    Let final_offset be len1 multiplied by cols plus len2 multiplied by 8
    Let distance be proc memory_get_int64 from Layout with matrix, final_offset

    Note: Matrix cleaned up by arena
    Return distance
End Process

Process called "suggest_keyword_correction" takes arena as Integer, identifier as Integer, table as Integer returns Integer:
    Note:
    Suggest keyword correction for misspelled identifiers.
    Uses Levenshtein distance for fuzzy matching.
    Returns suggested keyword string or 0 if no close match.
    :End Note

    Note: Check for instant common misspellings first (performance optimization)
    Let check1 be proc string_compare from StringCore with identifier, "lst"
    If check1 is equal to 1:
        Return "Let"
    End If

    Let check2 be proc string_compare from StringCore with identifier, "Retrun"
    If check2 is equal to 1:
        Return "Return"
    End If

    Let check3 be proc string_compare from StringCore with identifier, "Otherwize"
    If check3 is equal to 1:
        Return "Otherwise"
    End If

    Let check4 be proc string_compare from StringCore with identifier, "proccess"
    If check4 is equal to 1:
        Return "Process"
    End If

    Note: Get keyword_map from table
    Let keyword_map be proc memory_get_int64 from Layout with table, 0

    Note: Get all keywords from hashtable for Levenshtein matching
    Note: Define all keywords to check (comprehensive list)
    Let keywords be proc arena_allocate from Layout with arena, 568  Note: 71 keywords × 8 bytes

    Note: Populate keyword array (71 total keywords)
    Let dummy1 be proc memory_set_int64 from Layout with keywords, 0, "Let"
    Let dummy2 be proc memory_set_int64 from Layout with keywords, 8, "Set"
    Let dummy3 be proc memory_set_int64 from Layout with keywords, 16, "If"
    Let dummy4 be proc memory_set_int64 from Layout with keywords, 24, "Otherwise"
    Let dummy5 be proc memory_set_int64 from Layout with keywords, 32, "Unless"
    Let dummy6 be proc memory_set_int64 from Layout with keywords, 40, "When"
    Let dummy7 be proc memory_set_int64 from Layout with keywords, 48, "Match"
    Let dummy8 be proc memory_set_int64 from Layout with keywords, 56, "For"
    Let dummy9 be proc memory_set_int64 from Layout with keywords, 64, "While"
    Let dummy10 be proc memory_set_int64 from Layout with keywords, 72, "Loop"
    Let dummy11 be proc memory_set_int64 from Layout with keywords, 80, "Break"
    Let dummy12 be proc memory_set_int64 from Layout with keywords, 88, "Continue"
    Let dummy13 be proc memory_set_int64 from Layout with keywords, 96, "Process"
    Let dummy14 be proc memory_set_int64 from Layout with keywords, 104, "Type"
    Let dummy15 be proc memory_set_int64 from Layout with keywords, 112, "Protocol"
    Let dummy16 be proc memory_set_int64 from Layout with keywords, 120, "Return"
    Let dummy17 be proc memory_set_int64 from Layout with keywords, 128, "Yield"
    Let dummy18 be proc memory_set_int64 from Layout with keywords, 136, "Import"
    Let dummy19 be proc memory_set_int64 from Layout with keywords, 144, "From"
    Let dummy20 be proc memory_set_int64 from Layout with keywords, 152, "As"
    Let dummy21 be proc memory_set_int64 from Layout with keywords, 160, "Try"
    Let dummy22 be proc memory_set_int64 from Layout with keywords, 168, "Catch"
    Let dummy23 be proc memory_set_int64 from Layout with keywords, 176, "Finally"
    Let dummy24 be proc memory_set_int64 from Layout with keywords, 184, "Throw"
    Let dummy25 be proc memory_set_int64 from Layout with keywords, 192, "Private"
    Let dummy26 be proc memory_set_int64 from Layout with keywords, 200, "Static"
    Let dummy27 be proc memory_set_int64 from Layout with keywords, 208, "Async"
    Let dummy28 be proc memory_set_int64 from Layout with keywords, 216, "Await"
    Let dummy29 be proc memory_set_int64 from Layout with keywords, 224, "Send"
    Let dummy30 be proc memory_set_int64 from Layout with keywords, 232, "Receive"
    Let dummy31 be proc memory_set_int64 from Layout with keywords, 240, "Spawn"
    Let dummy32 be proc memory_set_int64 from Layout with keywords, 248, "New"
    Let dummy33 be proc memory_set_int64 from Layout with keywords, 256, "Delete"
    Let dummy34 be proc memory_set_int64 from Layout with keywords, 264, "With"
    Let dummy35 be proc memory_set_int64 from Layout with keywords, 272, "Assert"
    Let dummy36 be proc memory_set_int64 from Layout with keywords, 280, "Alert"
    Let dummy37 be proc memory_set_int64 from Layout with keywords, 288, "Display"
    Let dummy38 be proc memory_set_int64 from Layout with keywords, 296, "And"
    Let dummy39 be proc memory_set_int64 from Layout with keywords, 304, "Or"
    Let dummy40 be proc memory_set_int64 from Layout with keywords, 312, "Not"
    Let dummy41 be proc memory_set_int64 from Layout with keywords, 320, "Is"
    Let dummy42 be proc memory_set_int64 from Layout with keywords, 328, "In"
    Let dummy43 be proc memory_set_int64 from Layout with keywords, 336, "Of"
    Let dummy44 be proc memory_set_int64 from Layout with keywords, 344, "To"
    Let dummy45 be proc memory_set_int64 from Layout with keywords, 352, "By"
    Let dummy46 be proc memory_set_int64 from Layout with keywords, 360, "Be"
    Let dummy47 be proc memory_set_int64 from Layout with keywords, 368, "Plus"
    Let dummy48 be proc memory_set_int64 from Layout with keywords, 376, "Minus"
    Let dummy49 be proc memory_set_int64 from Layout with keywords, 384, "Multiplied"
    Let dummy50 be proc memory_set_int64 from Layout with keywords, 392, "Divided"
    Let dummy51 be proc memory_set_int64 from Layout with keywords, 400, "Modulo"
    Let dummy52 be proc memory_set_int64 from Layout with keywords, 408, "Power"
    Let dummy53 be proc memory_set_int64 from Layout with keywords, 416, "Equal"
    Let dummy54 be proc memory_set_int64 from Layout with keywords, 424, "Greater"
    Let dummy55 be proc memory_set_int64 from Layout with keywords, 432, "Less"
    Let dummy56 be proc memory_set_int64 from Layout with keywords, 440, "Than"
    Let dummy57 be proc memory_set_int64 from Layout with keywords, 448, "Contains"
    Let dummy58 be proc memory_set_int64 from Layout with keywords, 456, "True"
    Let dummy59 be proc memory_set_int64 from Layout with keywords, 464, "False"
    Let dummy60 be proc memory_set_int64 from Layout with keywords, 472, "Null"
    Let dummy61 be proc memory_set_int64 from Layout with keywords, 480, "None"
    Let dummy62 be proc memory_set_int64 from Layout with keywords, 488, "Nil"
    Let dummy63 be proc memory_set_int64 from Layout with keywords, 496, "End"
    Let dummy64 be proc memory_set_int64 from Layout with keywords, 504, "Note"
    Let dummy65 be proc memory_set_int64 from Layout with keywords, 512, "Constant"
    Let dummy66 be proc memory_set_int64 from Layout with keywords, 520, "Returns"
    Let dummy67 be proc memory_set_int64 from Layout with keywords, 528, "Bitwise"
    Let dummy68 be proc memory_set_int64 from Layout with keywords, 536, "Proc"
    Let dummy69 be proc memory_set_int64 from Layout with keywords, 544, "Define"
    Let dummy70 be proc memory_set_int64 from Layout with keywords, 552, "Borrow"
    Let dummy71 be proc memory_set_int64 from Layout with keywords, 560, "Move"

    Note: Iterate through all keywords to find closest match
    Let best_match be 0
    Let best_distance be 999  Note: Large initial value
    Let threshold be 2  Note: Maximum distance for suggestion

    Let i be 0
    While i is less than 71:
        Let offset be i multiplied by 8
        Let keyword be proc memory_get_int64 from Layout with keywords, offset

        Note: Calculate Levenshtein distance
        Let distance be proc compute_levenshtein_distance with arena, identifier, keyword

        Note: Update best match if closer
        If distance is less than best_distance:
            If distance is less than or equal to threshold:
                Set best_distance to distance
                Set best_match to keyword
            End If
        End If

        Set i to i plus 1
    End While

    Note: Keyword array cleaned up by arena
    Return best_match
End Process

Note: ============================================================================
Note: Keyword Utility Functions
Note: ============================================================================

Process called "is_control_flow_keyword" takes token_type as Integer returns Integer:
    Note:
    Check if token type is control flow keyword.
    Returns 1 if control flow, 0 otherwise.
    :End Note

    Note: Control flow keywords are in range 310-319
    If token_type is greater than or equal to 310:
        If token_type is less than or equal to 319:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "is_visibility_keyword" takes token_type as Integer returns Integer:
    Note:
    Check if token type is visibility modifier.
    Returns 1 if visibility modifier, 0 otherwise.
    :End Note

    Note: Visibility keywords are in range 350-354
    If token_type is greater than or equal to 350:
        If token_type is less than or equal to 354:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "keyword_token_type_to_string" takes token_type as Integer returns Integer:
    Note:
    Convert keyword token type to string representation.
    Returns keyword string or "UNKNOWN" for unrecognized types.
    :End Note

    Note: Map token types to strings
    If token_type is equal to TOKEN_LET:
        Return "Let"
    End If
    If token_type is equal to TOKEN_SET:
        Return "Set"
    End If
    If token_type is equal to TOKEN_DEFINE:
        Return "Define"
    End If
    If token_type is equal to TOKEN_IF:
        Return "If"
    End If
    If token_type is equal to TOKEN_OTHERWISE:
        Return "Otherwise"
    End If
    If token_type is equal to TOKEN_UNLESS:
        Return "Unless"
    End If
    If token_type is equal to TOKEN_WHEN:
        Return "When"
    End If
    If token_type is equal to TOKEN_MATCH:
        Return "Match"
    End If
    If token_type is equal to TOKEN_FOR:
        Return "For"
    End If
    If token_type is equal to TOKEN_WHILE:
        Return "While"
    End If
    If token_type is equal to TOKEN_LOOP:
        Return "Loop"
    End If
    If token_type is equal to TOKEN_BREAK:
        Return "Break"
    End If
    If token_type is equal to TOKEN_CONTINUE:
        Return "Continue"
    End If
    If token_type is equal to TOKEN_PROCESS:
        Return "Process"
    End If
    If token_type is equal to TOKEN_TYPE:
        Return "Type"
    End If
    If token_type is equal to TOKEN_PROTOCOL:
        Return "Protocol"
    End If
    If token_type is equal to TOKEN_RETURN:
        Return "Return"
    End If
    If token_type is equal to TOKEN_YIELD:
        Return "Yield"
    End If
    If token_type is equal to TOKEN_IMPORT:
        Return "Import"
    End If
    If token_type is equal to TOKEN_FROM:
        Return "From"
    End If
    If token_type is equal to TOKEN_AS:
        Return "As"
    End If
    If token_type is equal to TOKEN_EXPORT:
        Return "Export"
    End If
    If token_type is equal to TOKEN_TRY:
        Return "Try"
    End If
    If token_type is equal to TOKEN_CATCH:
        Return "Catch"
    End If
    If token_type is equal to TOKEN_FINALLY:
        Return "Finally"
    End If
    If token_type is equal to TOKEN_THROW:
        Return "Throw"
    End If
    If token_type is equal to TOKEN_PUBLIC:
        Return "Public"
    End If
    If token_type is equal to TOKEN_PRIVATE:
        Return "Private"
    End If
    If token_type is equal to TOKEN_STATIC:
        Return "Static"
    End If
    If token_type is equal to TOKEN_ASYNC:
        Return "Async"
    End If
    If token_type is equal to TOKEN_EXTERNAL:
        Return "External"
    End If
    If token_type is equal to TOKEN_AWAIT:
        Return "Await"
    End If
    If token_type is equal to TOKEN_SEND:
        Return "Send"
    End If
    If token_type is equal to TOKEN_RECEIVE:
        Return "Receive"
    End If
    If token_type is equal to TOKEN_SPAWN:
        Return "Spawn"
    End If
    If token_type is equal to TOKEN_NEW:
        Return "New"
    End If
    If token_type is equal to TOKEN_DELETE:
        Return "Delete"
    End If
    If token_type is equal to TOKEN_WITH:
        Return "With"
    End If
    If token_type is equal to TOKEN_ASSERT:
        Return "Assert"
    End If
    If token_type is equal to TOKEN_ALERT:
        Return "Alert"
    End If
    If token_type is equal to TOKEN_DISPLAY:
        Return "Display"
    End If
    If token_type is equal to TOKEN_AND:
        Return "And"
    End If
    If token_type is equal to TOKEN_OR:
        Return "Or"
    End If
    If token_type is equal to TOKEN_NOT:
        Return "Not"
    End If
    If token_type is equal to TOKEN_IS:
        Return "Is"
    End If
    If token_type is equal to TOKEN_IN:
        Return "In"
    End If
    If token_type is equal to TOKEN_OF:
        Return "Of"
    End If
    If token_type is equal to TOKEN_TO:
        Return "To"
    End If
    If token_type is equal to TOKEN_BY:
        Return "By"
    End If
    If token_type is equal to TOKEN_BE:
        Return "Be"
    End If
    If token_type is equal to TOKEN_PLUS:
        Return "Plus"
    End If
    If token_type is equal to TOKEN_MINUS:
        Return "Minus"
    End If
    If token_type is equal to TOKEN_TIMES:
        Return "Times"
    End If
    If token_type is equal to TOKEN_MULTIPLIED:
        Return "Multiplied"
    End If
    If token_type is equal to TOKEN_DIVIDED:
        Return "Divided"
    End If
    If token_type is equal to TOKEN_MODULO:
        Return "Modulo"
    End If
    If token_type is equal to TOKEN_POWER:
        Return "Power"
    End If
    If token_type is equal to TOKEN_EQUAL:
        Return "Equal"
    End If
    If token_type is equal to TOKEN_GREATER:
        Return "Greater"
    End If
    If token_type is equal to TOKEN_LESS:
        Return "Less"
    End If
    If token_type is equal to TOKEN_THAN:
        Return "Than"
    End If
    If token_type is equal to TOKEN_CONTAINS:
        Return "Contains"
    End If
    If token_type is equal to TOKEN_TRUE:
        Return "True"
    End If
    If token_type is equal to TOKEN_FALSE:
        Return "False"
    End If
    If token_type is equal to TOKEN_NULL:
        Return "Null"
    End If
    If token_type is equal to TOKEN_NONE:
        Return "None"
    End If
    If token_type is equal to TOKEN_NIL:
        Return "Nil"
    End If
    If token_type is equal to TOKEN_END:
        Return "End"
    End If
    If token_type is equal to TOKEN_BORROW:
        Return "Borrow"
    End If
    If token_type is equal to TOKEN_MOVE:
        Return "Move"
    End If

    Return "UNKNOWN"
End Process

Process called "get_keyword_count" takes table as Integer returns Integer:
    Note:
    Get total number of keywords in table.
    Returns keyword count from table structure.
    :End Note

    Note: Get keyword_count field (offset 16)
    Let count be proc memory_get_int64 from Layout with table, 16

    Return count
End Process
