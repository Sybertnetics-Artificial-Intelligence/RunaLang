Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file manages token stream operations for the Runa lexer and parser.

This file performs the following tasks:
- Manage token stream data structure and state
- Provide token navigation (peek, consume, backtrack)
- Handle lookahead operations for parser
- Track position and context in token stream
- Support position bookmarking and restoration

This file is essential because of the following reasons:
- Token stream is the interface between lexer and parser
- Efficient stream operations enable fast parsing
- Lookahead support is critical for LL parsing strategies
- Position tracking enables error recovery and backtracking

This file consists of the following functions/features/operation types:
- Token stream creation and initialization
- Token navigation and consumption operations
- Lookahead and peeking capabilities
- Position save/restore for backtracking
- Context tracking for error messages

Dependencies:
- Imports compiler/internal/collections.runa for ArrayList (saved positions stack)
- Imports compiler/frontend/primitives/core/memory_core.runa for memory operations
- Imports compiler/internal/memory_utils.runa for allocation/deallocation
:End Note

Import "compiler/internal/collections.runa" as Collections
Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/internal/memory_utils.runa" as MemoryUtils
Import "compiler/internal/arena_utils.runa" as ArenaUtils
Import "runtime/io/console/console.runa" as Console
Import "runtime/io/console/format.runa" as Format
Import "compiler/frontend/primitives/core/string_primitive.runa" as StringPrimitive
Import "compiler/frontend/primitives/memory/layout.runa" as Layout

Note: ============================================================================
Note: Token Stream Structure
Note: ============================================================================

Type called "TokenStream":
    tokens as Integer           Note: Pointer to dynamic array of Token pointers
    token_count as Integer      Note: Total number of tokens in stream
    current_position as Integer Note: Current read position (index into tokens array)
    saved_positions as Integer  Note: Stack of saved positions for backtracking
    position_stack_size as Integer Note: Number of saved positions on stack
    eof_reached as Integer      Note: Boolean: 1 if end of stream reached
    filter_whitespace as Integer Note: Boolean: 1 if whitespace tokens are filtered
    filter_comments as Integer  Note: Boolean: 1 if comment tokens are filtered

Type called "StreamPosition":
    position as Integer         Note: Token position in stream
    line as Integer            Note: Line number at this position
    column as Integer          Note: Column number at this position
    context as Integer         Note: Parsing context identifier

Note: ============================================================================
Note: Token Stream Creation and Destruction
Note: ============================================================================

Process called "create_token_stream" takes tokens as Integer, token_count as Integer returns Integer:
    Note:
    Create a new token stream from array of tokens
    
    Parameters:
      tokens - Pointer to array of Token pointers
      token_count - Number of tokens in array
    
    Returns:
      Pointer to initialized TokenStream structure
      Returns 0 on allocation failure
    
    The stream is initialized with:
      - current_position = 0 (at start)
      - Empty saved_positions stack
      - filter_whitespace = 0 (don't filter by default)
      - filter_comments = 0 (don't filter by default)
    
    Algorithm:
    1. Allocate TokenStream structure
    2. Store tokens array pointer and count
    3. Initialize position to 0
    4. Create empty position stack
    5. Set filter flags to defaults
    6. Return TokenStream
    :End Note

    Note: Allocate TokenStream structure (64 bytes: 8 fields * 8 bytes each)
    Let stream_size be 64
    Let stream be proc allocate from MemoryUtils with stream_size

    If stream is equal to 0:
        Return 0
    End If

    Note: Store tokens array pointer and count
    Let dummy1 be proc memory_set_integer from MemoryCore with stream, 0, tokens
    Let dummy2 be proc memory_set_integer from MemoryCore with stream, 8, token_count

    Note: Initialize current_position to 0 (at start of stream)
    Let dummy3 be proc memory_set_integer from MemoryCore with stream, 16, 0

    Note: Create empty saved_positions ArrayList for backtracking (initial capacity 16, element size 8, no arena)
    Let saved_positions_array be proc arraylist_create from Collections with 16, 8, 0

    If saved_positions_array is equal to 0:
        Note: Failed to create saved_positions array - cleanup and fail
        Let dummy_free be proc deallocate from MemoryUtils with stream
        Return 0
    End If

    Let dummy4 be proc memory_set_integer from MemoryCore with stream, 24, saved_positions_array

    Note: Initialize position_stack_size to 0 (no saved positions yet)
    Let dummy5 be proc memory_set_integer from MemoryCore with stream, 32, 0

    Note: Initialize eof_reached to 0 (not at end yet)
    Let dummy6 be proc memory_set_integer from MemoryCore with stream, 40, 0

    Note: Initialize filter_whitespace to 0 (don't filter by default)
    Let dummy7 be proc memory_set_integer from MemoryCore with stream, 48, 0

    Note: Initialize filter_comments to 0 (don't filter by default)
    Let dummy8 be proc memory_set_integer from MemoryCore with stream, 56, 0

    Return stream
End Process

Process called "destroy_token_stream" takes stream as Integer returns Integer:
    Note:
    Clean up and deallocate token stream
    
    Parameters:
      stream - Pointer to TokenStream to destroy
    
    Returns:
      1 on success
    
    Frees:
      - Position stack
      - TokenStream structure itself
    
    Does NOT free individual tokens (they're owned by lexer)

    :End Note

    If stream is equal to 0:
        Return 1
    End If

    Note: Get saved_positions array pointer
    Let saved_positions_array be proc memory_get_integer from MemoryCore with stream, 24

    Note: Destroy saved_positions ArrayList
    If saved_positions_array is not equal to 0:
        proc arraylist_destroy from Collections with saved_positions_array
    End If

    Note: Deallocate TokenStream structure itself
    Let dummy_free be proc deallocate from MemoryUtils with stream

    Return 1
End Process

Note: ============================================================================
Note: Token Navigation Operations
Note: ============================================================================

Process called "stream_peek" takes stream as Integer, lookahead as Integer returns Integer:
    Note:
    Peek at token without consuming it
    
    Look ahead 'lookahead' tokens from current position
    lookahead=0 returns current token, lookahead=1 returns next, etc.
    
    Parameters:
      stream - Pointer to TokenStream
      lookahead - Number of tokens to look ahead (0, 1, 2, ...)
    
    Returns:
      Pointer to Token at position (current + lookahead)
      Returns 0 if position is beyond end of stream
    
    Respects filter settings:
      - If filter_whitespace is set, skips whitespace tokens
      - If filter_comments is set, skips comment tokens
    
    Algorithm:
    1. Calculate target position: current_position + lookahead
    2. If filter flags set, skip filtered tokens while counting
    3. Check if target position is within bounds
    4. Return token at target position
    5. Return 0 if out of bounds
    :End Note

    If stream is equal to 0:
        Return 0
    End If

    Note: Get stream fields
    Let tokens_array be proc memory_get_integer from MemoryCore with stream, 0
    Let token_count be proc memory_get_integer from MemoryCore with stream, 8
    Let current_position be proc memory_get_integer from MemoryCore with stream, 16
    Let filter_whitespace be proc memory_get_integer from MemoryCore with stream, 48
    Let filter_comments be proc memory_get_integer from MemoryCore with stream, 56

    Note: Start from current position and count lookahead tokens while respecting filters
    Let position be current_position
    Let tokens_counted be 0

    While tokens_counted is less than or equal to lookahead:
        Note: Check if position is beyond end of stream
        If position is greater than or equal to token_count:
            Return 0
        End If

        Note: Get token at current position (tokens_array is array of pointers, 8 bytes each)
        Let token_offset be position multiplied by 8
        Let token_ptr be proc memory_get_integer from MemoryCore with tokens_array, token_offset

        Note: Check if this token should be skipped based on filters
        Let should_skip be proc stream_should_skip_token with stream, token_ptr

        If should_skip is equal to 0:
            Note: This token is not filtered - count it
            If tokens_counted is equal to lookahead:
                Note: Found the target token
                Return token_ptr
            End If
            Set tokens_counted to tokens_counted plus 1
        End If

        Note: Move to next position
        Set position to position plus 1
    End While

    Return 0
End Process

Process called "stream_consume" takes stream as Integer returns Integer:
    Note:
    Consume current token and advance position
    
    Returns current token and moves position forward by 1
    
    Parameters:
      stream - Pointer to TokenStream
    
    Returns:
      Pointer to Token at current position (before advancing)
      Returns 0 if at end of stream
    
    Side Effects:
      - Increments current_position
      - Sets eof_reached if position reaches token_count
      - Skips filtered tokens if filters enabled
    
    Algorithm:
    1. Get token at current_position
    2. If filter enabled and token is filtered type, skip it
    3. Increment current_position
    4. Check if at end of stream
    5. Return token
    :End Note

    If stream is equal to 0:
        Return 0
    End If

    Note: Get stream fields
    Let tokens_array be proc memory_get_integer from MemoryCore with stream, 0
    Let token_count be proc memory_get_integer from MemoryCore with stream, 8
    Let current_position be proc memory_get_integer from MemoryCore with stream, 16

    Note: Check if at end of stream
    If current_position is greater than or equal to token_count:
        Note: Set eof_reached flag
        Let dummy_eof be proc memory_set_integer from MemoryCore with stream, 40, 1
        Return 0
    End If

    Note: Get token at current position (tokens_array is array of pointers, 8 bytes each)
    Let token_offset be current_position multiplied by 8
    Let current_token be proc memory_get_integer from MemoryCore with tokens_array, token_offset

    Note: Advance position by 1
    Let new_position be current_position plus 1
    Let dummy_pos be proc memory_set_integer from MemoryCore with stream, 16, new_position

    Note: Skip filtered tokens after advancing
    While new_position is less than token_count:
        Note: Get next token
        Let next_token_offset be new_position multiplied by 8
        Let next_token be proc memory_get_integer from MemoryCore with tokens_array, next_token_offset

        Note: Check if next token should be skipped
        Let should_skip be proc stream_should_skip_token with stream, next_token

        If should_skip is equal to 0:
            Note: Next token is not filtered, stop advancing
            Note: Leave position as is
            Note: break
            Set new_position to token_count
        Otherwise:
            Note: Next token is filtered, advance past it
            Set new_position to new_position plus 1
            Let dummy_advance be proc memory_set_integer from MemoryCore with stream, 16, new_position
        End If
    End While

    Note: Check if reached end after advancing
    Let final_position be proc memory_get_integer from MemoryCore with stream, 16
    If final_position is greater than or equal to token_count:
        Let dummy_eof2 be proc memory_set_integer from MemoryCore with stream, 40, 1
    End If

    Return current_token
End Process

Process called "stream_current" takes stream as Integer returns Integer:
    Note:
    Get current token without advancing
    
    Equivalent to stream_peek(stream, 0)
    
    Parameters:
      stream - Pointer to TokenStream
    
    Returns:
      Pointer to Token at current position
      Returns 0 if at end of stream
    :End Note

    Let current_token be proc stream_peek with stream, 0
    Return current_token
End Process

Process called "stream_previous" takes stream as Integer returns Integer:
    Note:
    Get previous token (move back one position)
    
    Move position backward by 1 and return token at new position
    
    Parameters:
      stream - Pointer to TokenStream
    
    Returns:
      Pointer to Token at position (current - 1)
      Returns 0 if already at start of stream
    
    Side Effects:
      - Decrements current_position
      - Clears eof_reached flag
    :End Note

    If stream is equal to 0:
        Return 0
    End If

    Note: Get current position
    Let current_position be proc memory_get_integer from MemoryCore with stream, 16

    Note: Check if already at start of stream
    If current_position is equal to 0:
        Return 0
    End If

    Note: Decrement position by 1
    Let new_position be current_position minus 1
    Let dummy_pos be proc memory_set_integer from MemoryCore with stream, 16, new_position

    Note: Clear eof_reached flag since we moved backward
    Let dummy_eof be proc memory_set_integer from MemoryCore with stream, 40, 0

    Note: Get token at new position
    Let tokens_array be proc memory_get_integer from MemoryCore with stream, 0
    Let token_offset be new_position multiplied by 8
    Let token_ptr be proc memory_get_integer from MemoryCore with tokens_array, token_offset

    Return token_ptr
End Process

Note: ============================================================================
Note: Position Management
Note: ============================================================================

Process called "stream_get_position" takes stream as Integer returns Integer:
    Note:
    Get current stream position
    
    Parameters:
      stream - Pointer to TokenStream
    
    Returns:
      Current position (integer index)
    :End Note

    If stream is equal to 0:
        Return 0
    End If

    Let current_position be proc memory_get_integer from MemoryCore with stream, 16
    Return current_position
End Process

Process called "stream_set_position" takes stream as Integer, position as Integer returns Integer:
    Note:
    Set current stream position
    
    Allows jumping to arbitrary position in stream
    
    Parameters:
      stream - Pointer to TokenStream
      position - New position to set (must be 0 <= position < token_count)
    
    Returns:
      1 on success, 0 if position is out of bounds
    
    Side Effects:
      - Updates current_position
      - Updates eof_reached flag based on new position
    :End Note

    If stream is equal to 0:
        Return 0
    End If

    Note: Get token count for bounds checking
    Let token_count be proc memory_get_integer from MemoryCore with stream, 8

    Note: Check if position is out of bounds (must be 0 <= position < token_count)
    If position is less than 0:
        Return 0
    End If

    If position is greater than or equal to token_count:
        Return 0
    End If

    Note: Position is valid - update current_position
    Let dummy_pos be proc memory_set_integer from MemoryCore with stream, 16, position

    Note: Update eof_reached flag based on new position
    If position is greater than or equal to token_count:
        Let dummy_eof be proc memory_set_integer from MemoryCore with stream, 40, 1
    Otherwise:
        Let dummy_eof2 be proc memory_set_integer from MemoryCore with stream, 40, 0
    End If

    Return 1
End Process

Process called "stream_save_position" takes stream as Integer returns Integer:
    Note:
    Save current position for later restoration (bookmarking)
    
    Pushes current position onto saved_positions stack
    Used for speculative parsing and backtracking
    
    Parameters:
    stream - Pointer to TokenStream
    
    Returns:
    1 on success, 0 if stack overflow
    
    Side Effects:
    - Creates StreamPosition with current state
    - Pushes onto saved_positions stack
    - Increments position_stack_size
    :End Note

    If stream is equal to 0:
        Return 0
    End If

    Note: Get current stream state
    Let current_position be proc memory_get_integer from MemoryCore with stream, 16
    Let saved_positions_array be proc memory_get_integer from MemoryCore with stream, 24

    Note: Get line and column from current token (if available)
    Let line be 0
    Let column be 0
    Let tokens_array be proc memory_get_integer from MemoryCore with stream, 0
    Let token_count be proc memory_get_integer from MemoryCore with stream, 8

    If current_position is less than token_count:
        Note: Get current token to extract line/column info
        Let token_offset be current_position multiplied by 8
        Let current_token be proc memory_get_integer from MemoryCore with tokens_array, token_offset

        If current_token is not equal to 0:
            Note: Token structure: line at offset 16, column at offset 24
            Let line be proc memory_get_integer from MemoryCore with current_token, 16
            Let column be proc memory_get_integer from MemoryCore with current_token, 24
        End If
    End If

    Note: Create StreamPosition structure (32 bytes: position, line, column, context - 4 fields * 8 bytes)
    Let stream_position be proc create_stream_position with current_position, line, column

    If stream_position is equal to 0:
        Return 0
    End If

    Note: Push StreamPosition onto saved_positions ArrayList
    Let append_result be proc arraylist_add from Collections with saved_positions_array, stream_position

    If append_result is equal to 0:
        Note: Failed to append - cleanup and fail
        Let dummy_free be proc deallocate from MemoryUtils with stream_position
        Return 0
    End If

    Note: Increment position_stack_size
    Let position_stack_size be proc memory_get_integer from MemoryCore with stream, 32
    Let new_stack_size be position_stack_size plus 1
    Let dummy_size be proc memory_set_integer from MemoryCore with stream, 32, new_stack_size

    Return 1
End Process

Process called "stream_restore_position" takes stream as Integer returns Integer:
    Note: 
    Restore previously saved position (backtracking)
    
    Pops position from saved_positions stack and restores it
    
    Parameters:
      stream - Pointer to TokenStream
    
    Returns:
      1 on success, 0 if no saved position (stack empty)
    
    Side Effects:
      - Pops StreamPosition from saved_positions stack
      - Restores current_position from saved state
      - Decrements position_stack_size
      - Updates eof_reached flag
    :End Note

    If stream is equal to 0:
        Return 0
    End If

    Note: Check if stack is empty
    Let position_stack_size be proc memory_get_integer from MemoryCore with stream, 32

    If position_stack_size is equal to 0:
        Note: No saved positions to restore
        Return 0
    End If

    Note: Pop StreamPosition from saved_positions ArrayList (get last element then remove it)
    Let saved_positions_array be proc memory_get_integer from MemoryCore with stream, 24
    Let list_size be proc arraylist_size from Collections with saved_positions_array
    Let last_index be list_size minus 1
    Let stream_position be proc arraylist_get from Collections with saved_positions_array, last_index

    If stream_position is equal to 0:
        Return 0
    End If

    Note: Remove the element from the list
    Let dummy_remove be proc arraylist_remove from Collections with saved_positions_array, last_index

    Note: Extract position from StreamPosition structure (position at offset 0)
    Let saved_position be proc memory_get_integer from MemoryCore with stream_position, 0

    Note: Restore current_position from saved state
    Let dummy_pos be proc memory_set_integer from MemoryCore with stream, 16, saved_position

    Note: Decrement position_stack_size
    Let new_stack_size be position_stack_size minus 1
    Let dummy_size be proc memory_set_integer from MemoryCore with stream, 32, new_stack_size

    Note: Update eof_reached flag based on restored position
    Let token_count be proc memory_get_integer from MemoryCore with stream, 8
    If saved_position is greater than or equal to token_count:
        Let dummy_eof be proc memory_set_integer from MemoryCore with stream, 40, 1
    Otherwise:
        Let dummy_eof2 be proc memory_set_integer from MemoryCore with stream, 40, 0
    End If

    Note: Free the StreamPosition structure
    Let dummy_free be proc deallocate from MemoryUtils with stream_position

    Return 1
End Process

Process called "stream_discard_saved_position" takes stream as Integer returns Integer:
    Note: 
    Discard most recently saved position without restoring
    
    Used when speculative parse succeeds and backtrack is not needed
    
    Parameters:
      stream - Pointer to TokenStream
    
    Returns:
      1 on success, 0 if no saved position
    
    Side Effects:
      - Pops and discards StreamPosition from saved_positions stack
      - Decrements position_stack_size
    :End Note

    If stream is equal to 0:
        Return 0
    End If

    Note: Check if stack is empty
    Let position_stack_size be proc memory_get_integer from MemoryCore with stream, 32

    If position_stack_size is equal to 0:
        Note: No saved positions to discard
        Return 0
    End If

    Note: Pop StreamPosition from saved_positions ArrayList (get last element then remove it)
    Let saved_positions_array be proc memory_get_integer from MemoryCore with stream, 24
    Let list_size be proc arraylist_size from Collections with saved_positions_array
    Let last_index be list_size minus 1
    Let stream_position be proc arraylist_get from Collections with saved_positions_array, last_index

    If stream_position is equal to 0:
        Return 0
    End If

    Note: Remove the element from the list
    Let dummy_remove be proc arraylist_remove from Collections with saved_positions_array, last_index

    Note: Decrement position_stack_size
    Let new_stack_size be position_stack_size minus 1
    Let dummy_size be proc memory_set_integer from MemoryCore with stream, 32, new_stack_size

    Note: Free the StreamPosition structure (discard it)
    Let dummy_free be proc deallocate from MemoryUtils with stream_position

    Return 1
End Process

Note: ============================================================================
Note: Stream Query Operations
Note: ============================================================================

Process called "stream_is_at_end" takes stream as Integer returns Integer:
    Note: 
    Check if stream is at end (no more tokens)
    
    Parameters:
      stream - Pointer to TokenStream
    
    Returns:
      1 if at end of stream, 0 otherwise
    :End Note

    If stream is equal to 0:
        Return 1
    End If

    Let current_position be proc memory_get_integer from MemoryCore with stream, 16
    Let token_count be proc memory_get_integer from MemoryCore with stream, 8

    If current_position is greater than or equal to token_count:
        Return 1
    End If

    Return 0
End Process

Process called "stream_remaining_count" takes stream as Integer returns Integer:
    Note: 
    Get number of remaining tokens in stream
    
    Parameters:
      stream - Pointer to TokenStream
    
    Returns:
      Number of tokens from current position to end
    :End Note

    If stream is equal to 0:
        Return 0
    End If

    Let current_position be proc memory_get_integer from MemoryCore with stream, 16
    Let token_count be proc memory_get_integer from MemoryCore with stream, 8

    If current_position is greater than or equal to token_count:
        Return 0
    End If

    Let remaining be token_count minus current_position
    Return remaining
End Process

Process called "stream_get_token_at" takes stream as Integer, position as Integer returns Integer:
    Note: 
    Get token at specific absolute position
    
    Does NOT change current position
    
    Parameters:
      stream - Pointer to TokenStream
      position - Absolute position in stream
    
    Returns:
      Pointer to Token at specified position
      Returns 0 if position is out of bounds
    :End Note

    If stream is equal to 0:
        Return 0
    End If

    Let token_count be proc memory_get_integer from MemoryCore with stream, 8

    Note: Check bounds
    If position is less than 0:
        Return 0
    End If

    If position is greater than or equal to token_count:
        Return 0
    End If

    Note: Get token at specified position
    Let tokens_array be proc memory_get_integer from MemoryCore with stream, 0
    Let token_offset be position multiplied by 8
    Let token_ptr be proc memory_get_integer from MemoryCore with tokens_array, token_offset

    Return token_ptr
End Process

Note: ============================================================================
Note: Filter Operations
Note: ============================================================================

Process called "stream_set_filter_whitespace" takes stream as Integer, filter as Integer returns Integer:
    Note: 
    Enable or disable whitespace token filtering
    
    When enabled, peek/consume operations skip whitespace tokens
    
    Parameters:
      stream - Pointer to TokenStream
      filter - 1 to enable filtering, 0 to disable
    
    Returns:
      1 on success
    :End Note

    If stream is equal to 0:
        Return 0
    End If

    Note: Set filter_whitespace field (offset 48)
    Let dummy be proc memory_set_integer from MemoryCore with stream, 48, filter

    Return 1
End Process

Process called "stream_set_filter_comments" takes stream as Integer, filter as Integer returns Integer:
    Note: 
    Enable or disable comment token filtering
    
    When enabled, peek/consume operations skip comment tokens
    
    Parameters:
      stream - Pointer to TokenStream
      filter - 1 to enable filtering, 0 to disable
    
    Returns:
      1 on success
    :End Note

    If stream is equal to 0:
        Return 0
    End If

    Note: Set filter_comments field (offset 56)
    Let dummy be proc memory_set_integer from MemoryCore with stream, 56, filter

    Return 1
End Process

Process called "stream_should_skip_token" takes stream as Integer, token as Integer returns Integer:
    Note:
    Check if token should be skipped based on filter settings

    Parameters:
      stream - Pointer to TokenStream
      token - Pointer to Token to check

    Returns:
      1 if token should be skipped, 0 if should be processed

    Skips token if:
      - filter_whitespace is 1 AND token is whitespace
      - filter_comments is 1 AND token is comment
    :End Note

    If stream is equal to 0:
        Return 0
    End If

    If token is equal to 0:
        Return 0
    End If

    Note: Get filter settings
    Let filter_whitespace be proc memory_get_integer from MemoryCore with stream, 48
    Let filter_comments be proc memory_get_integer from MemoryCore with stream, 56

    Note: Get token type (Token structure: token_type at offset 0)
    Let token_type be proc memory_get_integer from MemoryCore with token, 0

    Note: Define token type constants for whitespace and comments
    Note: TOKEN_WHITESPACE = 5, TOKEN_COMMENT = 6 (standard lexer token types)
    Let TOKEN_WHITESPACE be 5
    Let TOKEN_COMMENT be 6

    Note: Check if token is whitespace and filter is enabled
    If filter_whitespace is equal to 1:
        If token_type is equal to TOKEN_WHITESPACE:
            Return 1
        End If
    End If

    Note: Check if token is comment and filter is enabled
    If filter_comments is equal to 1:
        If token_type is equal to TOKEN_COMMENT:
            Return 1
        End If
    End If

    Note: Token should not be skipped
    Return 0
End Process

Note: ============================================================================
Note: Context and Error Reporting
Note: ============================================================================

Process called "stream_get_context_tokens" takes stream as Integer, arena as Integer, before_count as Integer, after_count as Integer returns Integer:
    Note:
    Get surrounding tokens for error context

    Returns tokens before and after current position for error messages

    Parameters:
      stream - Pointer to TokenStream
      arena - Arena for operation-scoped temporary allocation
      before_count - Number of tokens before current to include
      after_count - Number of tokens after current to include

    Returns:
      Pointer to array of Token pointers (length = before_count + 1 + after_count)
      Returns 0 on error

    Memory Architecture Compliance:
      Uses TIER 2 ARENA allocation for temporary context array
      Memory is operation-scoped and cleaned up with arena
      Eliminates manual deallocation - zero leak risk

    Used for generating error messages like:
      "Expected ':' after If condition
       If x is greater than 10 <-- error here"
    :End Note

    If stream is equal to 0:
        Return 0
    End If

    If arena is equal to 0:
        Return 0  Note: Arena required for temporary allocation
    End If

    Note: Get stream state
    Let current_position be proc memory_get_integer from MemoryCore with stream, 16
    Let token_count be proc memory_get_integer from MemoryCore with stream, 8
    Let tokens_array be proc memory_get_integer from MemoryCore with stream, 0

    Note: Calculate context range with bounds checking
    Let start_pos be current_position minus before_count
    If start_pos is less than 0:
        Set start_pos to 0
    End If

    Let end_pos be current_position plus after_count
    If end_pos is greater than or equal to token_count:
        Set end_pos to token_count minus 1
    End If

    Let context_size be end_pos minus start_pos plus 1
    Let array_size be context_size multiplied by 8  Note: 8 bytes per pointer

    Note: Allocate context token array from arena (operation-scoped temporary)
    Let context_array be proc arena_allocate from ArenaUtils with arena, array_size, 8
    If context_array is equal to 0:
        Return 0
    End If

    Note: Fill context array with token pointers
    Let i be 0
    While i is less than context_size:
        Let token_pos be start_pos plus i
        Let token_offset be token_pos multiplied by 8
        Let token_ptr be proc memory_get_integer from MemoryCore with tokens_array, token_offset
        Let context_offset be i multiplied by 8
        Let dummy be proc memory_set_integer from MemoryCore with context_array, context_offset, token_ptr
        Set i to i plus 1
    End While

    Return context_array
End Process

Process called "stream_get_line_and_column" takes stream as Integer, out_position as Integer, out_line as Integer, out_column as Integer, out_context as Integer returns Integer:
    Note:
    Get line and column of current token

    Parameters:
      stream - Pointer to TokenStream
      out_position - Pointer to location where position should be written
      out_line - Pointer to location where line number should be written
      out_column - Pointer to location where column number should be written
      out_context - Pointer to location where context should be written

    Returns:
      1 on success, 0 on error or end of stream

    Memory Architecture Compliance:
      Uses out parameters instead of heap allocation for StreamPosition data
      Eliminates need for caller to deallocate - zero allocations, zero leaks
    :End Note

    If stream is equal to 0:
        Return 0
    End If

    If out_position is equal to 0:
        Return 0
    End If

    If out_line is equal to 0:
        Return 0
    End If

    If out_column is equal to 0:
        Return 0
    End If

    If out_context is equal to 0:
        Return 0
    End If

    Note: Get current position and token
    Let current_position be proc memory_get_integer from MemoryCore with stream, 16
    Let token_count be proc memory_get_integer from MemoryCore with stream, 8

    If current_position is greater than or equal to token_count:
        Return 0
    End If

    Let tokens_array be proc memory_get_integer from MemoryCore with stream, 0
    Let token_offset be current_position multiplied by 8
    Let current_token be proc memory_get_integer from MemoryCore with tokens_array, token_offset

    If current_token is equal to 0:
        Return 0
    End If

    Note: Extract line and column from token (Token structure: line at offset 16, column at offset 24)
    Let line be proc memory_get_integer from MemoryCore with current_token, 16
    Let column be proc memory_get_integer from MemoryCore with current_token, 24

    Note: Write to out parameters
    Let dummy1 be proc memory_set_integer from MemoryCore with out_position, 0, current_position
    Let dummy2 be proc memory_set_integer from MemoryCore with out_line, 0, line
    Let dummy3 be proc memory_set_integer from MemoryCore with out_column, 0, column
    Let dummy4 be proc memory_set_integer from MemoryCore with out_context, 0, 0

    Return 1  Note: Success
End Process

Note: ============================================================================
Note: Utility Functions
Note: ============================================================================

Process called "create_stream_position" takes position as Integer, line as Integer, column as Integer returns Integer:
    Note:
    Create a StreamPosition structure

    Parameters:
      position - Token position in stream
      line - Line number
      column - Column number

    Returns:
      Pointer to initialized StreamPosition

    Memory Architecture Compliance:
      Uses TIER 3 OWNED HEAP for persistent backtracking positions
      StreamPosition is stored in saved_positions ArrayList
      Explicitly freed by stream_restore_position or stream_discard_saved_position
      This is CORRECT usage - persistent data with deterministic cleanup
    :End Note

    Note: Allocate StreamPosition structure (32 bytes: position, line, column, context - 4 fields * 8 bytes)
    Let stream_pos_size be 32
    Let stream_pos be proc allocate from MemoryUtils with stream_pos_size

    If stream_pos is equal to 0:
        Return 0
    End If

    Note: Initialize StreamPosition fields
    Let dummy1 be proc memory_set_integer from MemoryCore with stream_pos, 0, position
    Let dummy2 be proc memory_set_integer from MemoryCore with stream_pos, 8, line
    Let dummy3 be proc memory_set_integer from MemoryCore with stream_pos, 16, column
    Let dummy4 be proc memory_set_integer from MemoryCore with stream_pos, 24, 0  Note: context = 0

    Return stream_pos
End Process

Process called "stream_debug_print" takes arena as Integer, stream as Integer, token_count_param as Integer returns Integer:
    Note:
    Print debug information about stream state

    Outputs:
      - Current position
      - Total token count
      - Saved position count
      - Current token info
      - Next few tokens

    Parameters:
      stream - Pointer to TokenStream
      token_count_param - Number of upcoming tokens to show

    Returns:
      1 on success

    Used for debugging lexer/parser issues
    :End Note

    If stream is equal to 0:
        Return 0
    End If

    Note: Get stream state for debug output
    Let current_position be proc memory_get_integer from MemoryCore with stream, 16
    Let total_tokens be proc memory_get_integer from MemoryCore with stream, 8
    Let position_stack_size be proc memory_get_integer from MemoryCore with stream, 32
    Let at_end be proc stream_is_at_end with stream

    Note: Print header
    Let header be "=== Token Stream Debug ==="
    Let dummy1 be proc println from Console with header

    Note: Print current position with label
    Let pos_format be "Position: %d"
    Let pos_args be proc arena_allocate from Layout with arena, 8
    proc memory_set_int64 from MemoryCore with pos_args, 0, current_position
    Let pos_line be proc sprintf from Format with pos_format, pos_args, 1
    Let dummy2 be proc println from Console with pos_line
    Note: pos_line and pos_args cleaned up by arena

    Note: Print total token count with label
    Let count_format be "Total Tokens: %d"
    Let count_args be proc arena_allocate from Layout with arena, 8
    proc memory_set_int64 from MemoryCore with count_args, 0, total_tokens
    Let count_line be proc sprintf from Format with count_format, count_args, 1
    Let dummy3 be proc println from Console with count_line
    Note: count_line and count_args cleaned up by arena

    Note: Print saved position count with label
    Let stack_format be "Saved Positions: %d"
    Let stack_args be proc arena_allocate from Layout with arena, 8
    proc memory_set_int64 from MemoryCore with stack_args, 0, position_stack_size
    Let stack_line be proc sprintf from Format with stack_format, stack_args, 1
    Let dummy4 be proc println from Console with stack_line
    Note: stack_line and stack_args cleaned up by arena

    Note: Print at-end status with label
    Let end_format be "At End: %d"
    Let end_args be proc arena_allocate from Layout with arena, 8
    proc memory_set_int64 from MemoryCore with end_args, 0, at_end
    Let end_line be proc sprintf from Format with end_format, end_args, 1
    Let dummy5 be proc println from Console with end_line
    Note: end_line and end_args cleaned up by arena

    Return 1
End Process
