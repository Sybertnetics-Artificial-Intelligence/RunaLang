Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles delimiter recognition and processing in the Runa lexer.

This file performs the following tasks:
- Recognize and tokenize bracket delimiters (parentheses, braces, square brackets)
- Handle nested delimiter structures and matching validation
- Track delimiter depth and nesting levels for syntax validation
- Process delimiter-related syntax errors and recovery
- Support delimiter context tracking for expression parsing

This file is essential because of the following reasons:
- Delimiters are fundamental to Runa's syntax structure and expression grouping
- Proper delimiter handling is required for correct parsing of complex expressions
- Delimiter matching is crucial for syntax error detection and recovery
- Nesting depth tracking enables better error messages and IDE features

This file consists of the following functions/features/operation types:
- Delimiter recognition and tokenization functions
- Nesting depth tracking and validation
- Delimiter matching and error detection
- Syntax recovery for mismatched delimiters
- Context-aware delimiter processing

Dependencies:
- Imports collections/stack.runa for delimiter nesting stack
- Imports memory/layout.runa for Token structure allocation
:End Note

Import "compiler/internal/collections.runa" as Collections
Import "compiler/frontend/primitives/core/memory_core.runa" as MemoryCore
Import "compiler/internal/memory_utils.runa" as MemoryUtils
Import "runtime/io/console/console.runa" as Console
Import "runtime/io/console/format.runa" as Format
Import "compiler/frontend/primitives/core/string_primitive.runa" as StringPrimitive
Import "compiler/frontend/primitives/memory/layout.runa" as Layout

Note: ============================================================================
Note: Token Type Constants for Delimiters
Note: ============================================================================

Note: These constants define the token types for delimiter characters
Note: Used in Token.token_type field to identify delimiter kind

Note: Parentheses
Constant TOKEN_LEFT_PAREN as Integer is 200      Note: (
Constant TOKEN_RIGHT_PAREN as Integer is 201    Note: )

Note: Braces (curly brackets)
Constant TOKEN_LEFT_BRACE as Integer is 202      Note: {
Constant TOKEN_RIGHT_BRACE as Integer is 203    Note: }

Note: Square brackets
Constant TOKEN_LEFT_BRACKET as Integer is 204    Note: [
Constant TOKEN_RIGHT_BRACKET as Integer is 205  Note: ]

Note: Other delimiters
Constant TOKEN_COLON as Integer is 206           Note: :
Constant TOKEN_COMMA as Integer is 207           Note: ,
Constant TOKEN_SEMICOLON as Integer is 208       Note: ;
Constant TOKEN_DOT as Integer is 209             Note: .
Constant TOKEN_ARROW as Integer is 210           Note: ->

Note: ============================================================================
Note: Delimiter Context Structure
Note: ============================================================================

Type called "DelimiterContext":
    nesting_stack as Integer    Note: Stack of DelimiterEntry (tracks open delimiters)
    paren_depth as Integer      Note: Current parentheses nesting depth
    brace_depth as Integer      Note: Current brace nesting depth
    bracket_depth as Integer    Note: Current bracket nesting depth
    total_depth as Integer      Note: Total nesting depth (all delimiter types)
    error_count as Integer      Note: Number of delimiter-related errors
End Type

Type called "DelimiterEntry":
    delimiter_type as Integer   Note: Token type of opening delimiter
    line as Integer            Note: Line number where delimiter appears
    column as Integer          Note: Column number where delimiter appears
    position as Integer        Note: Character position in source
End Type

Note: ============================================================================
Note: Delimiter Context Management
Note: ============================================================================

Process called "create_delimiter_context" returns Integer:
    Note: Create and initialize delimiter tracking context
    Note:
    Note: Returns:
    Note:   Pointer to DelimiterContext structure
    Note:   Returns 0 on allocation failure

    Note: Allocate DelimiterContext structure (6 fields × 8 bytes = 48 bytes)
    Let context_size be 48
    Let context be proc allocate from MemoryUtils with context_size

    If context is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Create nesting stack (offset 0)
    Let stack be proc stack_create from Collections
    If stack is equal to 0:
        Let dummy1 be proc deallocate from MemoryUtils with context
        Return 0  Note: Stack creation failed
    End If
    proc memory_set_integer from MemoryCore with context, 0, stack

    Note: Initialize depth counters (offsets 8, 16, 24, 32)
    proc memory_set_integer from MemoryCore with context, 8, 0   Note: paren_depth = 0
    proc memory_set_integer from MemoryCore with context, 16, 0  Note: brace_depth = 0
    proc memory_set_integer from MemoryCore with context, 24, 0  Note: bracket_depth = 0
    proc memory_set_integer from MemoryCore with context, 32, 0  Note: total_depth = 0

    Note: Initialize error counter (offset 40)
    proc memory_set_integer from MemoryCore with context, 40, 0  Note: error_count = 0

    Return context
End Process

Process called "destroy_delimiter_context" takes context as Integer returns Integer:
    Note: Cleanup and deallocate delimiter context resources
    Note:
    Note: Parameters:
    Note:   context - Pointer to DelimiterContext to destroy
    Note:
    Note: Returns:
    Note:   1 on success

    If context is equal to 0:
        Return 1  Note: NULL context, nothing to destroy
    End If

    Note: Deallocate nesting stack if not NULL (offset 0)
    Let stack_ptr be proc memory_get_integer from MemoryCore with context, 0
    If stack_ptr is not equal to 0:
        Note: Pop and deallocate any remaining entries
        Loop forever:
            Let entry be proc stack_pop from Collections with stack_ptr
            If entry is equal to 0:
                Break  Note: Stack empty
            End If
            Let dummy1 be proc deallocate from MemoryUtils with entry
        End Loop

        Let dummy1 be proc stack_destroy from Collections with stack_ptr
    End If

    Note: Deallocate the context structure
    Let dummy2 be proc deallocate from MemoryUtils with context

    Return 1
End Process

Note: ============================================================================
Note: Delimiter Tokenization
Note: ============================================================================

Process called "tokenize_delimiter" takes lexer as Integer, delimiter_char as Integer, start_line as Integer, start_column as Integer, context as Integer returns Integer:
    Note:
    Tokenize a delimiter character and update nesting context

    Handles single-character delimiters: ( ) { } [ ] : , ; .
    Also handles multi-character delimiter: -> (arrow)

    Parameters:
      lexer - Pointer to lexer state structure
      delimiter_char - The delimiter character (ASCII code)
      start_line - Line number where delimiter appears
      start_column - Column number where delimiter appears
      context - Pointer to DelimiterContext for nesting tracking

    Returns:
      Token type constant (TOKEN_LEFT_PAREN, etc.) for valid delimiters
      Returns 0 on error or unrecognized delimiter

    Side Effects:
      - For opening delimiters: Pushes DelimiterEntry onto nesting stack
      - For closing delimiters: Pops from stack and validates match
      - Updates depth counters in context

    This function returns the token type (integer) directly.
    Full Token structure allocation is handled by the lexer.
    :End Note

    Note: ASCII codes for delimiters
    Let left_paren be 40      Note: (
    Let right_paren be 41     Note: )
    Let left_brace be 123     Note: {
    Let right_brace be 125    Note: }
    Let left_bracket be 91    Note: [
    Let right_bracket be 93   Note: ]
    Let colon be 58           Note: :
    Let comma be 44           Note: ,
    Let semicolon be 59       Note: ;
    Let dot be 46             Note: .

    Let token_type be 0
    Let is_opening be 0
    Let is_closing be 0

    Note: Identify delimiter and set token type
    If delimiter_char is equal to left_paren:
        Set token_type to TOKEN_LEFT_PAREN
        Set is_opening to 1
    Otherwise If delimiter_char is equal to right_paren:
        Set token_type to TOKEN_RIGHT_PAREN
        Set is_closing to 1
    Otherwise If delimiter_char is equal to left_brace:
        Set token_type to TOKEN_LEFT_BRACE
        Set is_opening to 1
    Otherwise If delimiter_char is equal to right_brace:
        Set token_type to TOKEN_RIGHT_BRACE
        Set is_closing to 1
    Otherwise If delimiter_char is equal to left_bracket:
        Set token_type to TOKEN_LEFT_BRACKET
        Set is_opening to 1
    Otherwise If delimiter_char is equal to right_bracket:
        Set token_type to TOKEN_RIGHT_BRACKET
        Set is_closing to 1
    Otherwise If delimiter_char is equal to colon:
        Set token_type to TOKEN_COLON
    Otherwise If delimiter_char is equal to comma:
        Set token_type to TOKEN_COMMA
    Otherwise If delimiter_char is equal to semicolon:
        Set token_type to TOKEN_SEMICOLON
    Otherwise If delimiter_char is equal to dot:
        Set token_type to TOKEN_DOT
    Otherwise:
        Note: Unrecognized delimiter
        Return 0
    End If

    Note: Handle nesting tracking if context provided
    If context is not equal to 0:
        Note: For opening delimiters, push onto stack
        If is_opening is equal to 1:
            Let position be 0
            Let push_result be proc push_opening_delimiter with context, token_type, start_line, start_column, position
            If push_result is equal to 0:
                Note: Stack push failed
                Return 0
            End If
        End If

        Note: For closing delimiters, pop from stack and validate
        Otherwise If is_closing is equal to 1:
            Let entry_ptr be proc pop_closing_delimiter with context, token_type
            If entry_ptr is equal to 0:
                Note: Pop failed - mismatch or empty stack
                Note: Error already recorded by pop_closing_delimiter
                Note: Still return token type for error recovery
            End If
            Otherwise:
                Note: Successfully popped - deallocate entry
                Let dummy1 be proc deallocate from MemoryUtils with entry_ptr
            End If
        End If
    End If

    Note: Return token type for lexer to create full Token structure
    Return token_type
End Process

Process called "validate_delimiter_match" takes opening_type as Integer, closing_type as Integer returns Integer:
    Note:
    Validate that closing delimiter matches opening delimiter

    Checks delimiter pairing rules:
      ( must match with )
      { must match with }
      [ must match with ]

    Parameters:
      opening_type - Token type of opening delimiter
      closing_type - Token type of closing delimiter

    Returns:
      1 if match is valid, 0 if mismatch
    :End Note

    Note: Check parentheses match
    If opening_type is equal to TOKEN_LEFT_PAREN:
        If closing_type is equal to TOKEN_RIGHT_PAREN:
            Return 1
        End If
        Return 0
    End If

    Note: Check braces match
    If opening_type is equal to TOKEN_LEFT_BRACE:
        If closing_type is equal to TOKEN_RIGHT_BRACE:
            Return 1
        End If
        Return 0
    End If

    Note: Check brackets match
    If opening_type is equal to TOKEN_LEFT_BRACKET:
        If closing_type is equal to TOKEN_RIGHT_BRACKET:
            Return 1
        End If
        Return 0
    End If

    Note: Invalid opening type
    Return 0
End Process

Process called "push_opening_delimiter" takes context as Integer, delimiter_type as Integer, line as Integer, column as Integer, position as Integer returns Integer:
    Note:
    Push opening delimiter onto nesting stack

    Records delimiter position for later matching validation

    Parameters:
      context - Pointer to DelimiterContext
      delimiter_type - Token type of opening delimiter
      line - Line number
      column - Column number
      position - Character position in source

    Returns:
      1 on success, 0 on allocation failure

    Side Effects:
      - Increments appropriate depth counter
      - Increments total_depth
    :End Note

    If context is equal to 0:
        Return 0  Note: NULL context
    End If

    Note: Allocate DelimiterEntry (4 fields × 8 bytes = 32 bytes)
    Let entry_size be 32
    Let entry be proc allocate from MemoryUtils with entry_size

    If entry is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Populate entry fields
    proc memory_set_integer from MemoryCore with entry, 0, delimiter_type
    proc memory_set_integer from MemoryCore with entry, 8, line
    proc memory_set_integer from MemoryCore with entry, 16, column
    proc memory_set_integer from MemoryCore with entry, 24, position

    Note: Push onto stack (offset 0)
    Let stack be proc memory_get_integer from MemoryCore with context, 0
    Let push_result be proc stack_push from Collections with stack, entry

    If push_result is equal to 0:
        Let dummy1 be proc deallocate from MemoryUtils with entry
        Return 0  Note: Stack push failed
    End If

    Note: Update depth counters
    Let total_depth be proc memory_get_integer from MemoryCore with context, 32
    Set total_depth to total_depth plus 1
    proc memory_set_integer from MemoryCore with context, 32, total_depth

    Note: Increment specific depth counter
    If delimiter_type is equal to TOKEN_LEFT_PAREN:
        Let paren_depth be proc memory_get_integer from MemoryCore with context, 8
        Set paren_depth to paren_depth plus 1
        proc memory_set_integer from MemoryCore with context, 8, paren_depth
    Otherwise If delimiter_type is equal to TOKEN_LEFT_BRACE:
        Let brace_depth be proc memory_get_integer from MemoryCore with context, 16
        Set brace_depth to brace_depth plus 1
        proc memory_set_integer from MemoryCore with context, 16, brace_depth
    Otherwise If delimiter_type is equal to TOKEN_LEFT_BRACKET:
        Let bracket_depth be proc memory_get_integer from MemoryCore with context, 24
        Set bracket_depth to bracket_depth plus 1
        proc memory_set_integer from MemoryCore with context, 24, bracket_depth
    End If

    Return 1
End Process

Process called "pop_closing_delimiter" takes context as Integer, closing_type as Integer returns Integer:
    Note:
    Pop opening delimiter and validate match

    Checks that closing delimiter matches top of stack

    Parameters:
      context - Pointer to DelimiterContext
      closing_type - Token type of closing delimiter

    Returns:
      Pointer to popped DelimiterEntry on success
      Returns 0 on mismatch or empty stack

    Side Effects:
      - Decrements appropriate depth counter
      - Decrements total_depth
      - Increments error_count on mismatch
    :End Note

    If context is equal to 0:
        Return 0  Note: NULL context
    End If

    Note: Get stack (offset 0)
    Let stack be proc memory_get_integer from MemoryCore with context, 0

    Note: Pop entry from stack
    Let entry be proc stack_pop from Collections with stack

    If entry is equal to 0:
        Note: Empty stack - unmatched closing delimiter
        Let error_count be proc memory_get_integer from MemoryCore with context, 40
        Set error_count to error_count plus 1
        proc memory_set_integer from MemoryCore with context, 40, error_count
        Return 0
    End If

    Note: Get opening delimiter type
    Let opening_type be proc memory_get_integer from MemoryCore with entry, 0

    Note: Validate match
    Let is_valid_match be proc validate_delimiter_match with opening_type, closing_type

    If is_valid_match is equal to 0:
        Note: Mismatch - record error
        Let error_count be proc memory_get_integer from MemoryCore with context, 40
        Set error_count to error_count plus 1
        proc memory_set_integer from MemoryCore with context, 40, error_count

        Note: Deallocate mismatched entry
        Let dummy1 be proc deallocate from MemoryUtils with entry
        Return 0
    End If

    Note: Update depth counters
    Let total_depth be proc memory_get_integer from MemoryCore with context, 32
    Set total_depth to total_depth minus 1
    proc memory_set_integer from MemoryCore with context, 32, total_depth

    Note: Decrement specific depth counter
    If opening_type is equal to TOKEN_LEFT_PAREN:
        Let paren_depth be proc memory_get_integer from MemoryCore with context, 8
        Set paren_depth to paren_depth minus 1
        proc memory_set_integer from MemoryCore with context, 8, paren_depth
    Otherwise If opening_type is equal to TOKEN_LEFT_BRACE:
        Let brace_depth be proc memory_get_integer from MemoryCore with context, 16
        Set brace_depth to brace_depth minus 1
        proc memory_set_integer from MemoryCore with context, 16, brace_depth
    Otherwise If opening_type is equal to TOKEN_LEFT_BRACKET:
        Let bracket_depth be proc memory_get_integer from MemoryCore with context, 24
        Set bracket_depth to bracket_depth minus 1
        proc memory_set_integer from MemoryCore with context, 24, bracket_depth
    End If

    Note: Return entry for caller to deallocate
    Return entry
End Process

Note: ============================================================================
Note: Delimiter Query Functions
Note: ============================================================================

Process called "get_total_nesting_depth" takes context as Integer returns Integer:
    Note:
    Get total nesting depth across all delimiter types

    Parameters:
      context - Pointer to DelimiterContext

    Returns:
      Current total nesting depth
      Returns 0 if context is NULL
    :End Note

    If context is equal to 0:
        Return 0
    End If

    Let total_depth be proc memory_get_integer from MemoryCore with context, 32
    Return total_depth
End Process

Process called "get_delimiter_type_depth" takes context as Integer, delimiter_type as Integer returns Integer:
    Note:
    Get nesting depth for specific delimiter type

    Parameters:
      context - Pointer to DelimiterContext
      delimiter_type - Token type to query (TOKEN_LEFT_PAREN, etc.)

    Returns:
      Current depth for that delimiter type
      Returns -1 if delimiter_type is invalid

    Examples:
      After tokenizing "func(list[0]", results are:
        get_delimiter_type_depth(context, TOKEN_LEFT_PAREN) = 1
        get_delimiter_type_depth(context, TOKEN_LEFT_BRACKET) = 1
        get_delimiter_type_depth(context, TOKEN_LEFT_BRACE) = 0
    :End Note

    If context is equal to 0:
        Return 0
    End If

    If delimiter_type is equal to TOKEN_LEFT_PAREN:
        Let paren_depth be proc memory_get_integer from MemoryCore with context, 8
        Return paren_depth
    Otherwise If delimiter_type is equal to TOKEN_LEFT_BRACE:
        Let brace_depth be proc memory_get_integer from MemoryCore with context, 16
        Return brace_depth
    Otherwise If delimiter_type is equal to TOKEN_LEFT_BRACKET:
        Let bracket_depth be proc memory_get_integer from MemoryCore with context, 24
        Return bracket_depth
    End If

    Note: Invalid delimiter type
    Let result be 0 minus 1
    Return result
End Process

Process called "is_at_top_level" takes context as Integer returns Integer:
    Note:
    Check if currently at top level (no open delimiters)

    Parameters:
      context - Pointer to DelimiterContext

    Returns:
      1 if at top level (total_depth == 0), 0 otherwise
    :End Note

    If context is equal to 0:
        Return 1  Note: NULL context considered top level
    End If

    Let total_depth be proc memory_get_integer from MemoryCore with context, 32

    If total_depth is equal to 0:
        Return 1  Note: At top level
    End If

    Return 0  Note: Inside nesting
End Process

Process called "has_unmatched_delimiters" takes context as Integer returns Integer:
    Note:
    Check if there are any unclosed delimiters

    Useful for end-of-file validation

    Parameters:
      context - Pointer to DelimiterContext

    Returns:
      1 if unmatched delimiters exist, 0 if all matched
    :End Note

    If context is equal to 0:
        Return 0  Note: NULL context has no unmatched delimiters
    End If

    Let total_depth be proc memory_get_integer from MemoryCore with context, 32

    If total_depth is greater than 0:
        Return 1  Note: Unmatched delimiters exist
    End If

    Return 0  Note: All delimiters matched
End Process

Note: ============================================================================
Note: Delimiter String Representation
Note: ============================================================================

Process called "delimiter_type_to_string" takes delimiter_type as Integer returns Integer:
    Note:
    Convert delimiter token type to string representation

    Parameters:
      delimiter_type - Token type constant

    Returns:
      Pointer to string containing delimiter character
      Returns "?" for unknown types
    :End Note

    If delimiter_type is equal to TOKEN_LEFT_PAREN:
        Let result be "("
        Return result
    Otherwise If delimiter_type is equal to TOKEN_RIGHT_PAREN:
        Let result be ")"
        Return result
    Otherwise If delimiter_type is equal to TOKEN_LEFT_BRACE:
        Let result be "{"
        Return result
    Otherwise If delimiter_type is equal to TOKEN_RIGHT_BRACE:
        Let result be "}"
        Return result
    Otherwise If delimiter_type is equal to TOKEN_LEFT_BRACKET:
        Let result be "["
        Return result
    Otherwise If delimiter_type is equal to TOKEN_RIGHT_BRACKET:
        Let result be "]"
        Return result
    Otherwise If delimiter_type is equal to TOKEN_COLON:
        Let result be ":"
        Return result
    Otherwise If delimiter_type is equal to TOKEN_COMMA:
        Let result be ","
        Return result
    Otherwise If delimiter_type is equal to TOKEN_DOT:
        Let result be "."
        Return result
    Otherwise:
        Let result be "?"
        Return result
    End If
End Process

Note: ============================================================================
Note: Token Structure Creation
Note: ============================================================================

Process called "create_delimiter_token" takes token_type as Integer, symbol as Integer, line as Integer, column as Integer returns Integer:
    Note:
    Create a Token structure for a recognized delimiter.
    Allocates and populates Token structure with delimiter information.

    This function creates the full Token structure (48 bytes) that the parser expects.
    All delimiter tokenization goes through this function for consistency.

    Parameters:
      token_type - Delimiter token type constant (TOKEN_LEFT_PAREN, etc.)
      symbol - String representation of delimiter (e.g., "(", ")", "{", etc.)
      line - Line number where delimiter appears
      column - Column number where delimiter appears

    Returns:
      Pointer to allocated Token structure
      Returns 0 on allocation failure

    Token Structure (48 bytes):
      offset 0:  token_type (Integer)
      offset 8:  value (pointer to symbol string)
      offset 16: line (Integer)
      offset 24: column (Integer)
      offset 32: length (Integer - always 1 for single-char delimiters)
      offset 40: metadata (Integer - unused for delimiters, set to 0)
    :End Note

    Note: Allocate Token structure (6 fields × 8 bytes = 48 bytes)
    Let token_size be 48
    Let token be proc allocate from Layout with token_size

    If token is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Set token fields
    Note: Field 0 (offset 0): token_type
    proc memory_set_qword from Layout with token, 0, token_type

    Note: Field 1 (offset 8): value (delimiter symbol string)
    proc memory_set_qword from Layout with token, 8, symbol

    Note: Field 2 (offset 16): line
    proc memory_set_qword from Layout with token, 16, line

    Note: Field 3 (offset 24): column
    proc memory_set_qword from Layout with token, 24, column

    Note: Field 4 (offset 32): length (always 1 for single-character delimiters)
    proc memory_set_qword from Layout with token, 32, 1

    Note: Field 5 (offset 40): metadata (null for simple delimiters)
    proc memory_set_qword from Layout with token, 40, 0

    Return token
End Process
