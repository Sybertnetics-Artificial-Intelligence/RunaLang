Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles mathematical symbols and operators in Runa.

This file performs the following tasks:
- Recognize mathematical operators (+, -, *, /, %, **)
- Process comparison operators (==, !=, <, >, <=, >=)
- Handle logical operators (&&, ||, !)
- Process bitwise operators (&, |, ^, ~, <<, >>)
- Support both Developer Mode symbols and Canon Mode natural language

This file is essential because of the following reasons:
- Mathematical symbols are core to Runa's expression syntax
- Proper operator recognition enables correct expression parsing
- Mathematical operators are fundamental to programming logic
- Support for both symbol and natural language forms is required

This file consists of the following functions/features/operation types:
- Mathematical operator recognition and tokenization
- Operator precedence and associativity handling
- Multi-character operator processing (==, !=, <=, >=, **, <<, >>)
- Operator context validation and error detection
- Translation between Developer Mode symbols and Canon Mode words

Dependencies:
- Imports operators/arithmetics.runa for arithmetic operation definitions
- Imports operators/comparison.runa for comparison operation definitions
- Imports operators/bitwise.runa for bitwise operation definitions
- Imports operators/logical.runa for logical operation definitions
- Imports memory/layout.runa for Token allocation
:End Note

Import "compiler/frontend/primitives/operators/arithmetics.runa" as Arithmetics
Import "compiler/frontend/primitives/operators/comparison.runa" as Comparison
Import "compiler/frontend/primitives/operators/bitwise.runa" as Bitwise
Import "compiler/frontend/primitives/operators/logical.runa" as Logical
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/internal/arena_utils.runa" as ArenaUtils

Note: ============================================================================
Note: Token Type Constants for Mathematical Operators
Note: ============================================================================

Note: Arithmetic Operators (Developer Mode Symbols)
Constant TOKEN_PLUS as Integer is 500           Note: + (addition)
Constant TOKEN_MINUS as Integer is 501          Note: - (subtraction)
Constant TOKEN_MULTIPLY as Integer is 502       Note: * (multiplication)
Constant TOKEN_DIVIDE as Integer is 503         Note: / (division)
Constant TOKEN_MODULO as Integer is 504         Note: % (modulo/remainder)
Constant TOKEN_POWER as Integer is 505          Note: ** (exponentiation)

Note: Comparison Operators (Developer Mode Symbols)
Constant TOKEN_EQUAL_EQUAL as Integer is 510    Note: == (equality)
Constant TOKEN_NOT_EQUAL as Integer is 511      Note: != (inequality)
Constant TOKEN_LESS_THAN as Integer is 512      Note: < (less than)
Constant TOKEN_GREATER_THAN as Integer is 513   Note: > (greater than)
Constant TOKEN_LESS_EQUAL as Integer is 514     Note: <= (less than or equal)
Constant TOKEN_GREATER_EQUAL as Integer is 515  Note: >= (greater than or equal)

Note: Logical Operators (Developer Mode Symbols)
Constant TOKEN_LOGICAL_AND as Integer is 520    Note: && (logical and)
Constant TOKEN_LOGICAL_OR as Integer is 521     Note: || (logical or)
Constant TOKEN_LOGICAL_NOT as Integer is 522    Note: ! (logical not)

Note: Bitwise Operators (Developer Mode Symbols)
Constant TOKEN_BITWISE_AND as Integer is 530    Note: & (bitwise and)
Constant TOKEN_BITWISE_OR as Integer is 531     Note: | (bitwise or)
Constant TOKEN_BITWISE_XOR as Integer is 532    Note: ^ (bitwise xor)
Constant TOKEN_BITWISE_NOT as Integer is 533    Note: ~ (bitwise not/complement)
Constant TOKEN_SHIFT_LEFT as Integer is 534     Note: << (left shift)
Constant TOKEN_SHIFT_RIGHT as Integer is 535    Note: >> (right shift)

Note: ============================================================================
Note: Operator Precedence and Associativity
Note: ============================================================================

Note: Precedence levels (higher number = higher precedence)
Note: Based on standard mathematical precedence rules

Constant PRECEDENCE_LOGICAL_OR as Integer is 1       Note: || (or)
Constant PRECEDENCE_LOGICAL_AND as Integer is 2      Note: && (and)
Constant PRECEDENCE_BITWISE_OR as Integer is 3       Note: | (bitwise or)
Constant PRECEDENCE_BITWISE_XOR as Integer is 4      Note: ^ (bitwise xor)
Constant PRECEDENCE_BITWISE_AND as Integer is 5      Note: & (bitwise and)
Constant PRECEDENCE_EQUALITY as Integer is 6         Note: ==, != (equality, inequality)
Constant PRECEDENCE_COMPARISON as Integer is 7       Note: <, >, <=, >= (relational)
Constant PRECEDENCE_SHIFT as Integer is 8            Note: <<, >> (bit shifts)
Constant PRECEDENCE_ADDITIVE as Integer is 9         Note: +, - (addition, subtraction)
Constant PRECEDENCE_MULTIPLICATIVE as Integer is 10  Note: *, /, % (multiplication, division, modulo)
Constant PRECEDENCE_EXPONENTIATION as Integer is 11  Note: ** (power)
Constant PRECEDENCE_UNARY as Integer is 12           Note: !, ~, - (unary operations)

Note: Associativity constants
Constant ASSOC_LEFT as Integer is 0    Note: Left-to-right associativity
Constant ASSOC_RIGHT as Integer is 1   Note: Right-to-left associativity

Note: ============================================================================
Note: Operator Information Structure
Note: ============================================================================

Type called "OperatorInfo":
    token_type as Integer      Note: Token type constant
    symbol as Integer          Note: Pointer to operator symbol string ("+", "==", etc.)
    canon_form as Integer      Note: Pointer to Canon Mode natural language form
    precedence as Integer      Note: Precedence level (higher = tighter binding)
    associativity as Integer   Note: ASSOC_LEFT or ASSOC_RIGHT
    is_unary as Integer        Note: Boolean: 1 if can be unary, 0 if only binary
    is_binary as Integer       Note: Boolean: 1 if can be binary, 0 if only unary
    arity as Integer           Note: 1 for unary, 2 for binary, 3 for ternary

Note: ============================================================================
Note: Operator Recognition
Note: ============================================================================

Process called "tokenize_math_operator" takes lexer as Integer, current_char as Integer, start_line as Integer, start_column as Integer returns Integer:
    Note:
    Tokenize mathematical operator (single or multi-character).
    Handles arithmetic, comparison, logical, and bitwise operators.
    Returns Token pointer or 0 if not recognized.
    :End Note

    Note: Get source from lexer (offset 0) and position (offset 8)
    Let source be proc memory_get_int64 from Layout with lexer, 0
    Let position be proc memory_get_int64 from Layout with lexer, 8

    Note: Peek next character for multi-char operators
    Let next_char be proc memory_get_byte from StringCore with source, position

    Note: Try arithmetic operators first (+, -, *, /, %, **)
    Let arith_type be proc recognize_arithmetic_operator with current_char, next_char
    If arith_type is not equal to 0:
        Note: Determine operator symbol and length
        Let op_symbol be proc operator_type_to_string with arith_type
        Let op_length be 1

        Note: Power operator ** is 2 chars
        If arith_type is equal to 505:  Note: TOKEN_POWER
            Set op_length to 2
        End If

        Let token be proc create_operator_token with arith_type, op_symbol, start_line, start_column, op_length
        Return token
    End If

    Note: Try comparison operators (==, !=, <, >, <=, >=)
    Let comp_type be proc recognize_comparison_operator with current_char, next_char
    If comp_type is not equal to 0:
        Let op_symbol be proc operator_type_to_string with comp_type
        Let op_length be 1

        Note: Multi-char comparison operators: ==, !=, <=, >=
        If comp_type is equal to 510:  Note: TOKEN_EQUAL_EQUAL
            Set op_length to 2
        End If
        If comp_type is equal to 511:  Note: TOKEN_NOT_EQUAL
            Set op_length to 2
        End If
        If comp_type is equal to 514:  Note: TOKEN_LESS_EQUAL
            Set op_length to 2
        End If
        If comp_type is equal to 515:  Note: TOKEN_GREATER_EQUAL
            Set op_length to 2
        End If

        Let token be proc create_operator_token with comp_type, op_symbol, start_line, start_column, op_length
        Return token
    End If

    Note: Try logical operators (&&, ||, !)
    Let logical_type be proc recognize_logical_operator with current_char, next_char
    If logical_type is not equal to 0:
        Let op_symbol be proc operator_type_to_string with logical_type
        Let op_length be 1

        Note: Multi-char logical operators: &&, ||
        If logical_type is equal to 520:  Note: TOKEN_LOGICAL_AND
            Set op_length to 2
        End If
        If logical_type is equal to 521:  Note: TOKEN_LOGICAL_OR
            Set op_length to 2
        End If

        Let token be proc create_operator_token with logical_type, op_symbol, start_line, start_column, op_length
        Return token
    End If

    Note: Try bitwise operators (&, |, ^, ~, <<, >>)
    Let bitwise_type be proc recognize_bitwise_operator with current_char, next_char
    If bitwise_type is not equal to 0:
        Let op_symbol be proc operator_type_to_string with bitwise_type
        Let op_length be 1

        Note: Multi-char bitwise operators: <<, >>
        If bitwise_type is equal to 534:  Note: TOKEN_SHIFT_LEFT
            Set op_length to 2
        End If
        If bitwise_type is equal to 535:  Note: TOKEN_SHIFT_RIGHT
            Set op_length to 2
        End If

        Let token be proc create_operator_token with bitwise_type, op_symbol, start_line, start_column, op_length
        Return token
    End If

    Note: Not a recognized math operator
    Return 0
End Process

Process called "recognize_arithmetic_operator" takes first_char as Integer, second_char as Integer returns Integer:
    Note:
    Recognize arithmetic operators (+, -, *, /, %, **).
    Returns token type constant or 0 if not arithmetic operator.
    :End Note

    Note: Check for + (ASCII 43)
    If first_char is equal to 43:
        Return TOKEN_PLUS
    End If

    Note: Check for - (ASCII 45)
    If first_char is equal to 45:
        Return TOKEN_MINUS
    End If

    Note: Check for * (ASCII 42)
    If first_char is equal to 42:
        Note: Check for ** (power operator)
        If second_char is equal to 42:
            Return TOKEN_POWER
        End If
        Return TOKEN_MULTIPLY
    End If

    Note: Check for / (ASCII 47)
    If first_char is equal to 47:
        Return TOKEN_DIVIDE
    End If

    Note: Check for % (ASCII 37)
    If first_char is equal to 37:
        Return TOKEN_MODULO
    End If

    Note: Not an arithmetic operator
    Return 0
End Process

Process called "recognize_comparison_operator" takes first_char as Integer, second_char as Integer returns Integer:
    Note:
    Recognize comparison operators (==, !=, <, >, <=, >=).
    Returns token type constant or 0 if not comparison operator.
    :End Note

    Note: Check for == (ASCII 61, 61)
    If first_char is equal to 61:
        If second_char is equal to 61:
            Return TOKEN_EQUAL_EQUAL
        End If
    End If

    Note: Check for ! (ASCII 33) followed by =
    If first_char is equal to 33:
        If second_char is equal to 61:
            Return TOKEN_NOT_EQUAL
        End If
    End If

    Note: Check for < (ASCII 60)
    If first_char is equal to 60:
        Note: Check for <= (less than or equal)
        If second_char is equal to 61:
            Return TOKEN_LESS_EQUAL
        End If
        Note: Single < (less than)
        Return TOKEN_LESS_THAN
    End If

    Note: Check for > (ASCII 62)
    If first_char is equal to 62:
        Note: Check for >= (greater than or equal)
        If second_char is equal to 61:
            Return TOKEN_GREATER_EQUAL
        End If
        Note: Single > (greater than)
        Return TOKEN_GREATER_THAN
    End If

    Note: Not a comparison operator
    Return 0
End Process

Process called "recognize_logical_operator" takes first_char as Integer, second_char as Integer returns Integer:
    Note:
    Recognize logical operators (&&, ||, !).
    Returns token type constant or 0 if not logical operator.
    :End Note

    Note: Check for && (ASCII 38, 38)
    If first_char is equal to 38:
        If second_char is equal to 38:
            Return TOKEN_LOGICAL_AND
        End If
        Note: Single & is bitwise, not logical
        Return 0
    End If

    Note: Check for || (ASCII 124, 124)
    If first_char is equal to 124:
        If second_char is equal to 124:
            Return TOKEN_LOGICAL_OR
        End If
        Note: Single | is bitwise, not logical
        Return 0
    End If

    Note: Check for ! (ASCII 33)
    If first_char is equal to 33:
        Note: Must not be != (that's comparison)
        If second_char is not equal to 61:
            Return TOKEN_LOGICAL_NOT
        End If
    End If

    Note: Not a logical operator
    Return 0
End Process

Process called "recognize_bitwise_operator" takes first_char as Integer, second_char as Integer returns Integer:
    Note:
    Recognize bitwise operators (&, |, ^, ~, <<, >>).
    Returns token type constant or 0 if not bitwise operator.
    :End Note

    Note: Check for & (ASCII 38)
    If first_char is equal to 38:
        Note: Must be single & (not &&)
        If second_char is not equal to 38:
            Return TOKEN_BITWISE_AND
        End If
        Note: && is logical, not bitwise
        Return 0
    End If

    Note: Check for | (ASCII 124)
    If first_char is equal to 124:
        Note: Must be single | (not ||)
        If second_char is not equal to 124:
            Return TOKEN_BITWISE_OR
        End If
        Note: || is logical, not bitwise
        Return 0
    End If

    Note: Check for ^ (ASCII 94)
    If first_char is equal to 94:
        Return TOKEN_BITWISE_XOR
    End If

    Note: Check for ~ (ASCII 126)
    If first_char is equal to 126:
        Return TOKEN_BITWISE_NOT
    End If

    Note: Check for < (ASCII 60) for <<
    If first_char is equal to 60:
        If second_char is equal to 60:
            Return TOKEN_SHIFT_LEFT
        End If
        Note: Single < is comparison, not bitwise
        Return 0
    End If

    Note: Check for > (ASCII 62) for >>
    If first_char is equal to 62:
        If second_char is equal to 62:
            Return TOKEN_SHIFT_RIGHT
        End If
        Note: Single > is comparison, not bitwise
        Return 0
    End If

    Note: Not a bitwise operator
    Return 0
End Process

Note: ============================================================================
Note: Operator Information Retrieval
Note: ============================================================================

Process called "get_operator_info" takes arena as Integer, token_type as Integer returns Integer:
    Note:
    Get comprehensive information about an operator.
    Returns pointer to OperatorInfo structure or 0 for unknown operator.

    Parameters:
      arena - Arena for operation-scoped temporary allocation
      token_type - Token type constant for the operator

    Returns:
      Pointer to OperatorInfo structure with operator details
      Returns 0 on error

    Memory Architecture Compliance:
      Uses TIER 2 ARENA allocation for temporary OperatorInfo structure
      Memory is operation-scoped and cleaned up with arena
      Eliminates manual deallocation - zero leak risk
    :End Note

    If arena is equal to 0:
        Return 0  Note: Arena required for temporary allocation
    End If

    Note: OperatorInfo structure: 8 fields × 8 bytes = 64 bytes
    Note: Fields: token_type, symbol, canon_form, precedence, associativity, is_unary, is_binary, arity
    Let info_size be 64
    Let info be proc arena_allocate from ArenaUtils with arena, info_size, 8

    If info is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Get operator properties using existing functions
    Let symbol_string be proc operator_type_to_string with token_type
    Let canon_string be proc translate_symbol_to_canon with symbol_string
    Let precedence be proc get_operator_precedence with token_type
    Let associativity be proc get_operator_associativity with token_type
    Let is_unary be proc is_unary_operator with token_type
    Let is_binary be proc is_binary_operator with token_type

    Note: Calculate arity
    Let arity be 0
    If is_binary is equal to 1:
        Set arity to 2
    End If
    If is_unary is equal to 1:
        If arity is equal to 0:
            Set arity to 1
        End If
    End If

    Note: Populate OperatorInfo structure
    Note: Field 0 (offset 0): token_type
    Let dummy1 be proc memory_set_int64 from Layout with info, 0, token_type

    Note: Field 1 (offset 8): symbol
    Let dummy2 be proc memory_set_int64 from Layout with info, 8, symbol_string

    Note: Field 2 (offset 16): canon_form
    Let dummy3 be proc memory_set_int64 from Layout with info, 16, canon_string

    Note: Field 3 (offset 24): precedence
    Let dummy4 be proc memory_set_int64 from Layout with info, 24, precedence

    Note: Field 4 (offset 32): associativity
    Let dummy5 be proc memory_set_int64 from Layout with info, 32, associativity

    Note: Field 5 (offset 40): is_unary
    Let dummy6 be proc memory_set_int64 from Layout with info, 40, is_unary

    Note: Field 6 (offset 48): is_binary
    Let dummy7 be proc memory_set_int64 from Layout with info, 48, is_binary

    Note: Field 7 (offset 56): arity
    Let dummy8 be proc memory_set_int64 from Layout with info, 56, arity

    Return info
End Process

Process called "get_operator_precedence" takes token_type as Integer returns Integer:
    Note:
    Get precedence level for an operator.
    Higher precedence = tighter binding = evaluated first.
    Returns precedence (1-12) or 0 for unknown.
    :End Note

    Note: Logical OR (521) - Precedence 1
    If token_type is equal to 521:
        Return PRECEDENCE_LOGICAL_OR
    End If

    Note: Logical AND (520) - Precedence 2
    If token_type is equal to 520:
        Return PRECEDENCE_LOGICAL_AND
    End If

    Note: Bitwise OR (531) - Precedence 3
    If token_type is equal to 531:
        Return PRECEDENCE_BITWISE_OR
    End If

    Note: Bitwise XOR (532) - Precedence 4
    If token_type is equal to 532:
        Return PRECEDENCE_BITWISE_XOR
    End If

    Note: Bitwise AND (530) - Precedence 5
    If token_type is equal to 530:
        Return PRECEDENCE_BITWISE_AND
    End If

    Note: Equality operators (510, 511) - Precedence 6
    If token_type is equal to 510:  Note: ==
        Return PRECEDENCE_EQUALITY
    End If
    If token_type is equal to 511:  Note: !=
        Return PRECEDENCE_EQUALITY
    End If

    Note: Comparison operators (512-515) - Precedence 7
    If token_type is greater than or equal to 512:
        If token_type is less than or equal to 515:
            Return PRECEDENCE_COMPARISON
        End If
    End If

    Note: Shift operators (534, 535) - Precedence 8
    If token_type is equal to 534:  Note: <<
        Return PRECEDENCE_SHIFT
    End If
    If token_type is equal to 535:  Note: >>
        Return PRECEDENCE_SHIFT
    End If

    Note: Additive operators (500, 501) - Precedence 9
    If token_type is equal to 500:  Note: +
        Return PRECEDENCE_ADDITIVE
    End If
    If token_type is equal to 501:  Note: -
        Return PRECEDENCE_ADDITIVE
    End If

    Note: Multiplicative operators (502-504) - Precedence 10
    If token_type is greater than or equal to 502:
        If token_type is less than or equal to 504:
            Return PRECEDENCE_MULTIPLICATIVE
        End If
    End If

    Note: Exponentiation (505) - Precedence 11
    If token_type is equal to 505:
        Return PRECEDENCE_EXPONENTIATION
    End If

    Note: Unary operators (522, 533) - Precedence 12
    If token_type is equal to 522:  Note: ! (logical not)
        Return PRECEDENCE_UNARY
    End If
    If token_type is equal to 533:  Note: ~ (bitwise not)
        Return PRECEDENCE_UNARY
    End If

    Note: Unknown operator
    Return 0
End Process

Process called "get_operator_associativity" takes token_type as Integer returns Integer:
    Note:
    Get associativity for an operator.
    Returns ASSOC_LEFT (0) or ASSOC_RIGHT (1).
    :End Note

    Note: Exponentiation (505) is right-associative: a ** b ** c = a ** (b ** c)
    If token_type is equal to 505:
        Return ASSOC_RIGHT
    End If

    Note: Unary operators (522, 533) are right-associative
    If token_type is equal to 522:  Note: ! (logical not)
        Return ASSOC_RIGHT
    End If
    If token_type is equal to 533:  Note: ~ (bitwise not)
        Return ASSOC_RIGHT
    End If

    Note: All other operators are left-associative
    Note: Arithmetic (500-504), comparison (510-515), logical (520-521), bitwise (530-532, 534-535)
    Return ASSOC_LEFT
End Process

Process called "is_unary_operator" takes token_type as Integer returns Integer:
    Note:
    Check if operator can be used as unary operator.
    Returns 1 for unary operators, 0 otherwise.
    :End Note

    Note: TOKEN_MINUS (501) - Can be unary negation: -x
    If token_type is equal to 501:
        Return 1
    End If

    Note: TOKEN_PLUS (500) - Can be unary plus: +x (though rarely used)
    If token_type is equal to 500:
        Return 1
    End If

    Note: TOKEN_LOGICAL_NOT (522) - Unary logical not: !condition
    If token_type is equal to 522:
        Return 1
    End If

    Note: TOKEN_BITWISE_NOT (533) - Unary bitwise not: ~bits
    If token_type is equal to 533:
        Return 1
    End If

    Note: Not a unary operator
    Return 0
End Process

Process called "is_binary_operator" takes token_type as Integer returns Integer:
    Note:
    Check if operator can be used as binary operator.
    Returns 1 for binary operators, 0 otherwise.
    :End Note

    Note: Arithmetic operators (500-505) - All binary
    If token_type is greater than or equal to 500:
        If token_type is less than or equal to 505:
            Return 1
        End If
    End If

    Note: Comparison operators (510-515) - All binary
    If token_type is greater than or equal to 510:
        If token_type is less than or equal to 515:
            Return 1
        End If
    End If

    Note: Logical AND and OR (520-521) - Binary
    If token_type is equal to 520:
        Return 1
    End If
    If token_type is equal to 521:
        Return 1
    End If

    Note: Logical NOT (522) - Unary only
    If token_type is equal to 522:
        Return 0
    End If

    Note: Bitwise operators (530-532, 534-535) - Binary
    If token_type is equal to 530:  Note: &
        Return 1
    End If
    If token_type is equal to 531:  Note: |
        Return 1
    End If
    If token_type is equal to 532:  Note: ^
        Return 1
    End If
    If token_type is equal to 534:  Note: <<
        Return 1
    End If
    If token_type is equal to 535:  Note: >>
        Return 1
    End If

    Note: Bitwise NOT (533) - Unary only
    If token_type is equal to 533:
        Return 0
    End If

    Note: Unknown operator
    Return 0
End Process

Note: ============================================================================
Note: Developer Mode to Canon Mode Translation
Note: ============================================================================

Process called "translate_symbol_to_canon" takes operator_symbol as Integer returns Integer:
    Note:
    Translate Developer Mode symbol to Canon Mode natural language.
    Returns pointer to Canon string or 0 if no translation.
    :End Note

    Note: Arithmetic operators
    Let is_match be proc strings_equal from StringCore with operator_symbol, "+"
    If is_match is equal to 1:
        Return "plus"
    End If

    Set is_match to proc strings_equal from StringCore with operator_symbol, "-"
    If is_match is equal to 1:
        Return "minus"
    End If

    Set is_match to proc strings_equal from StringCore with operator_symbol, "*"
    If is_match is equal to 1:
        Return "multiplied by"
    End If

    Set is_match to proc strings_equal from StringCore with operator_symbol, "/"
    If is_match is equal to 1:
        Return "divided by"
    End If

    Set is_match to proc strings_equal from StringCore with operator_symbol, "%"
    If is_match is equal to 1:
        Return "modulo"
    End If

    Set is_match to proc strings_equal from StringCore with operator_symbol, "**"
    If is_match is equal to 1:
        Return "raised to"
    End If

    Note: Comparison operators
    Set is_match to proc strings_equal from StringCore with operator_symbol, "=="
    If is_match is equal to 1:
        Return "is equal to"
    End If

    Set is_match to proc strings_equal from StringCore with operator_symbol, "!="
    If is_match is equal to 1:
        Return "is not equal to"
    End If

    Set is_match to proc strings_equal from StringCore with operator_symbol, "<"
    If is_match is equal to 1:
        Return "is less than"
    End If

    Set is_match to proc strings_equal from StringCore with operator_symbol, ">"
    If is_match is equal to 1:
        Return "is greater than"
    End If

    Set is_match to proc strings_equal from StringCore with operator_symbol, "<="
    If is_match is equal to 1:
        Return "is less than or equal to"
    End If

    Set is_match to proc strings_equal from StringCore with operator_symbol, ">="
    If is_match is equal to 1:
        Return "is greater than or equal to"
    End If

    Note: Logical operators
    Set is_match to proc strings_equal from StringCore with operator_symbol, "&&"
    If is_match is equal to 1:
        Return "and"
    End If

    Set is_match to proc strings_equal from StringCore with operator_symbol, "||"
    If is_match is equal to 1:
        Return "or"
    End If

    Set is_match to proc strings_equal from StringCore with operator_symbol, "!"
    If is_match is equal to 1:
        Return "not"
    End If

    Note: No translation available
    Return 0
End Process

Process called "translate_canon_to_symbol" takes canon_phrase as Integer returns Integer:
    Note:
    Translate Canon Mode natural language to Developer Mode symbol.
    Returns pointer to symbol string or 0 if no translation.
    :End Note

    Note: Arithmetic operators
    Let is_match be proc strings_equal from StringCore with canon_phrase, "plus"
    If is_match is equal to 1:
        Return "+"
    End If

    Set is_match to proc strings_equal from StringCore with canon_phrase, "minus"
    If is_match is equal to 1:
        Return "-"
    End If

    Set is_match to proc strings_equal from StringCore with canon_phrase, "multiplied by"
    If is_match is equal to 1:
        Return "*"
    End If

    Set is_match to proc strings_equal from StringCore with canon_phrase, "divided by"
    If is_match is equal to 1:
        Return "/"
    End If

    Set is_match to proc strings_equal from StringCore with canon_phrase, "modulo"
    If is_match is equal to 1:
        Return "%"
    End If

    Set is_match to proc strings_equal from StringCore with canon_phrase, "raised to"
    If is_match is equal to 1:
        Return "**"
    End If

    Note: Comparison operators
    Set is_match to proc strings_equal from StringCore with canon_phrase, "is equal to"
    If is_match is equal to 1:
        Return "=="
    End If

    Set is_match to proc strings_equal from StringCore with canon_phrase, "is not equal to"
    If is_match is equal to 1:
        Return "!="
    End If

    Set is_match to proc strings_equal from StringCore with canon_phrase, "is less than"
    If is_match is equal to 1:
        Return "<"
    End If

    Set is_match to proc strings_equal from StringCore with canon_phrase, "is greater than"
    If is_match is equal to 1:
        Return ">"
    End If

    Set is_match to proc strings_equal from StringCore with canon_phrase, "is less than or equal to"
    If is_match is equal to 1:
        Return "<="
    End If

    Set is_match to proc strings_equal from StringCore with canon_phrase, "is greater than or equal to"
    If is_match is equal to 1:
        Return ">="
    End If

    Note: Logical operators
    Set is_match to proc strings_equal from StringCore with canon_phrase, "and"
    If is_match is equal to 1:
        Return "&&"
    End If

    Set is_match to proc strings_equal from StringCore with canon_phrase, "or"
    If is_match is equal to 1:
        Return "||"
    End If

    Set is_match to proc strings_equal from StringCore with canon_phrase, "not"
    If is_match is equal to 1:
        Return "!"
    End If

    Note: No translation available
    Return 0
End Process

Note: ============================================================================
Note: Operator Validation
Note: ============================================================================

Process called "validate_operator_context" takes operator_type as Integer, context as Integer returns Integer:
    Note:
    Validate that operator is used in appropriate context.
    Context validation will be done primarily by parser.
    Lexer performs basic sanity checks.
    :End Note

    Note: The lexer accepts all operators as tokens
    Note: Parser performs full context validation:
    Note:   - Unary/binary disambiguation based on preceding tokens
    Note:   - Operator chaining validation
    Note:   - Precedence and associativity enforcement

    Note: Lexer-level validation: ensure valid token type
    If operator_type is less than 500:
        Return 0  Note: Not a math operator
    End If

    If operator_type is greater than 540:
        Return 0  Note: Out of math operator range
    End If

    Note: Valid math operator
    Return 1
End Process

Process called "create_operator_token" takes token_type as Integer, symbol as Integer, line as Integer, column as Integer, length as Integer returns Integer:
    Note:
    Create a token for a recognized operator.
    Allocates and populates Token structure.
    Returns Token pointer or 0 on allocation failure.
    :End Note

    Note: Token structure: 6 fields × 8 bytes = 48 bytes
    Note: Fields: token_type, value, line, column, length, metadata
    Let token_size be 48
    Let token be proc allocate from Layout with token_size

    If token is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Set token fields
    Note: Field 0 (offset 0): token_type
    Let dummy1 be proc memory_set_int64 from Layout with token, 0, token_type

    Note: Field 1 (offset 8): value (operator symbol string)
    Let dummy2 be proc memory_set_int64 from Layout with token, 8, symbol

    Note: Field 2 (offset 16): line
    Let dummy3 be proc memory_set_int64 from Layout with token, 16, line

    Note: Field 3 (offset 24): column
    Let dummy4 be proc memory_set_int64 from Layout with token, 24, column

    Note: Field 4 (offset 32): length
    Let dummy5 be proc memory_set_int64 from Layout with token, 32, length

    Note: Field 5 (offset 40): metadata (null for simple operators)
    Let dummy6 be proc memory_set_int64 from Layout with token, 40, 0

    Return token
End Process
