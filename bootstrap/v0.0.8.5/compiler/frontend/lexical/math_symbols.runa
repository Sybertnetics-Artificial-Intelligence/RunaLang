Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles mathematical symbols and operators in Runa.

This file performs the following tasks:
- Recognize mathematical operators (+, -, *, /, %, **)
- Process comparison operators (==, !=, <, >, <=, >=)
- Handle logical operators (&&, ||, !)
- Process bitwise operators (&, |, ^, ~, <<, >>)
- Support both Developer Mode symbols and Canon Mode natural language

This file is essential because of the following reasons:
- Mathematical symbols are core to Runa's expression syntax
- Proper operator recognition enables correct expression parsing
- Mathematical operators are fundamental to programming logic
- Support for both symbol and natural language forms is required

This file consists of the following functions/features/operation types:
- Mathematical operator recognition and tokenization
- Operator precedence and associativity handling
- Multi-character operator processing (==, !=, <=, >=, **, <<, >>)
- Operator context validation and error detection
- Translation between Developer Mode symbols and Canon Mode words

Dependencies:
- Imports operators/arithmetics.runa for arithmetic operation definitions
- Imports operators/comparison.runa for comparison operation definitions
- Imports operators/bitwise.runa for bitwise operation definitions
- Imports operators/logical.runa for logical operation definitions
- Imports memory/layout.runa for Token allocation
:End Note

Import "compiler/frontend/primitives/operators/arithmetics.runa" as Arithmetics
Import "compiler/frontend/primitives/operators/comparison.runa" as Comparison
Import "compiler/frontend/primitives/operators/bitwise.runa" as Bitwise
Import "compiler/frontend/primitives/operators/logical.runa" as Logical
Import "compiler/frontend/primitives/memory/layout.runa" as Layout

Note: ============================================================================
Note: Token Type Constants for Mathematical Operators
Note: ============================================================================

Note: Arithmetic Operators (Developer Mode Symbols)
Define constant TOKEN_PLUS as 500           Note: + (addition)
Define constant TOKEN_MINUS as 501          Note: - (subtraction)
Define constant TOKEN_MULTIPLY as 502       Note: * (multiplication)
Define constant TOKEN_DIVIDE as 503         Note: / (division)
Define constant TOKEN_MODULO as 504         Note: % (modulo/remainder)
Define constant TOKEN_POWER as 505          Note: ** (exponentiation)

Note: Comparison Operators (Developer Mode Symbols)
Define constant TOKEN_EQUAL_EQUAL as 510    Note: == (equality)
Define constant TOKEN_NOT_EQUAL as 511      Note: != (inequality)
Define constant TOKEN_LESS_THAN as 512      Note: < (less than)
Define constant TOKEN_GREATER_THAN as 513   Note: > (greater than)
Define constant TOKEN_LESS_EQUAL as 514     Note: <= (less than or equal)
Define constant TOKEN_GREATER_EQUAL as 515  Note: >= (greater than or equal)

Note: Logical Operators (Developer Mode Symbols)
Define constant TOKEN_LOGICAL_AND as 520    Note: && (logical and)
Define constant TOKEN_LOGICAL_OR as 521     Note: || (logical or)
Define constant TOKEN_LOGICAL_NOT as 522    Note: ! (logical not)

Note: Bitwise Operators (Developer Mode Symbols)
Define constant TOKEN_BITWISE_AND as 530    Note: & (bitwise and)
Define constant TOKEN_BITWISE_OR as 531     Note: | (bitwise or)
Define constant TOKEN_BITWISE_XOR as 532    Note: ^ (bitwise xor)
Define constant TOKEN_BITWISE_NOT as 533    Note: ~ (bitwise not/complement)
Define constant TOKEN_SHIFT_LEFT as 534     Note: << (left shift)
Define constant TOKEN_SHIFT_RIGHT as 535    Note: >> (right shift)

Note: ============================================================================
Note: Operator Precedence and Associativity
Note: ============================================================================

Note: Precedence levels (higher number = higher precedence)
Note: Based on standard mathematical precedence rules

Define constant PRECEDENCE_LOGICAL_OR as 1       Note: || (or)
Define constant PRECEDENCE_LOGICAL_AND as 2      Note: && (and)
Define constant PRECEDENCE_BITWISE_OR as 3       Note: | (bitwise or)
Define constant PRECEDENCE_BITWISE_XOR as 4      Note: ^ (bitwise xor)
Define constant PRECEDENCE_BITWISE_AND as 5      Note: & (bitwise and)
Define constant PRECEDENCE_EQUALITY as 6         Note: ==, != (equality, inequality)
Define constant PRECEDENCE_COMPARISON as 7       Note: <, >, <=, >= (relational)
Define constant PRECEDENCE_SHIFT as 8            Note: <<, >> (bit shifts)
Define constant PRECEDENCE_ADDITIVE as 9         Note: +, - (addition, subtraction)
Define constant PRECEDENCE_MULTIPLICATIVE as 10  Note: *, /, % (multiplication, division, modulo)
Define constant PRECEDENCE_EXPONENTIATION as 11  Note: ** (power)
Define constant PRECEDENCE_UNARY as 12           Note: !, ~, - (unary operations)

Note: Associativity constants
Define constant ASSOC_LEFT as 0    Note: Left-to-right associativity
Define constant ASSOC_RIGHT as 1   Note: Right-to-left associativity

Note: ============================================================================
Note: Operator Information Structure
Note: ============================================================================

Type called "OperatorInfo":
    token_type as Integer      Note: Token type constant
    symbol as Integer          Note: Pointer to operator symbol string ("+", "==", etc.)
    canon_form as Integer      Note: Pointer to Canon Mode natural language form
    precedence as Integer      Note: Precedence level (higher = tighter binding)
    associativity as Integer   Note: ASSOC_LEFT or ASSOC_RIGHT
    is_unary as Integer        Note: Boolean: 1 if can be unary, 0 if only binary
    is_binary as Integer       Note: Boolean: 1 if can be binary, 0 if only unary
    arity as Integer           Note: 1 for unary, 2 for binary, 3 for ternary

Note: ============================================================================
Note: Operator Recognition
Note: ============================================================================

Process called "tokenize_math_operator" takes lexer as Integer, current_char as Integer, start_line as Integer, start_column as Integer returns Integer:
    Note: Tokenize a mathematical operator starting with current_char
    Note: 
    Note: Handles both single-character and multi-character operators:
    Note:   Single: +, -, *, /, %, <, >, &, |, ^, ~, !
    Note:   Multi: ==, !=, <=, >=, **, &&, ||, <<, >>
    Note: 
    Note: Must lookahead to distinguish:
    Note:   - vs -= (minus vs compound assignment - handled elsewhere)
    Note:   * vs ** (multiply vs power)
    Note:   < vs << vs <= (less than vs shift left vs less equal)
    Note:   & vs && (bitwise and vs logical and)
    Note: 
    Note: Parameters:
    Note:   lexer - Pointer to lexer state structure
    Note:   current_char - Current character (ASCII code)
    Note:   start_line - Line number where operator starts
    Note:   start_column - Column number where operator starts
    Note: 
    Note: Returns:
    Note:   Pointer to Token structure with:
    Note:     - token_type = Appropriate operator token type
    Note:     - value = Operator symbol string
    Note:     - line/column = operator position
    Note:     - length = 1 or 2 (single or multi-char)
    Note:   Returns 0 if not a recognized operator
    Note: 
    Note: Algorithm:
    Note: 1. Check current_char against single-char operators
    Note: 2. Peek next character to check for multi-char operators
    Note: 3. Determine longest matching operator
    Note: 4. Create OperatorInfo for the operator
    Note: 5. Allocate and populate Token structure
    Note: 6. Return Token
    Note: 
    Note: TODO: Implement using:
    Note: - Lexer peek_next_char to check for multi-char operators
    Note: - recognize_arithmetic_operator for +,-,*,/,%,**
    Note: - recognize_comparison_operator for ==,!=,<,>,<=,>=
    Note: - recognize_logical_operator for &&,||,!
    Note: - recognize_bitwise_operator for &,|,^,~,<<,>>
    Note: - Layout.allocate for Token structure
    
    Return 0  Note: Placeholder
End Process

Process called "recognize_arithmetic_operator" takes first_char as Integer, second_char as Integer returns Integer:
    Note: Recognize arithmetic operators (+, -, *, /, %, **)
    Note: 
    Note: Parameters:
    Note:   first_char - First character (ASCII code)
    Note:   second_char - Second character for multi-char operators (or 0 if none)
    Note: 
    Note: Returns:
    Note:   Token type constant if recognized (TOKEN_PLUS, TOKEN_MULTIPLY, etc.)
    Note:   Returns 0 if not an arithmetic operator
    Note: 
    Note: Checks:
    Note:   + (43) -> TOKEN_PLUS (500)
    Note:   - (45) -> TOKEN_MINUS (501)
    Note:   * (42) -> TOKEN_MULTIPLY (502), or ** -> TOKEN_POWER (505)
    Note:   / (47) -> TOKEN_DIVIDE (503)
    Note:   % (37) -> TOKEN_MODULO (504)
    Note: 
    Note: TODO: Implement character code checks with lookahead for **
    
    Return 0  Note: Placeholder
End Process

Process called "recognize_comparison_operator" takes first_char as Integer, second_char as Integer returns Integer:
    Note: Recognize comparison operators (==, !=, <, >, <=, >=)
    Note: 
    Note: Parameters:
    Note:   first_char - First character (ASCII code)
    Note:   second_char - Second character for multi-char operators (or 0)
    Note: 
    Note: Returns:
    Note:   Token type constant if recognized
    Note:   Returns 0 if not a comparison operator
    Note: 
    Note: Checks:
    Note:   == (61,61) -> TOKEN_EQUAL_EQUAL (510)
    Note:   != (33,61) -> TOKEN_NOT_EQUAL (511)
    Note:   < (60) -> TOKEN_LESS_THAN (512), or <= -> TOKEN_LESS_EQUAL (514)
    Note:   > (62) -> TOKEN_GREATER_THAN (513), or >= -> TOKEN_GREATER_EQUAL (515)
    Note: 
    Note: Note: Single = is assignment (handled elsewhere), not equality
    Note: 
    Note: TODO: Implement character code checks with lookahead for <=, >=
    
    Return 0  Note: Placeholder
End Process

Process called "recognize_logical_operator" takes first_char as Integer, second_char as Integer returns Integer:
    Note: Recognize logical operators (&&, ||, !)
    Note: 
    Note: Parameters:
    Note:   first_char - First character (ASCII code)
    Note:   second_char - Second character for multi-char operators (or 0)
    Note: 
    Note: Returns:
    Note:   Token type constant if recognized
    Note:   Returns 0 if not a logical operator
    Note: 
    Note: Checks:
    Note:   && (38,38) -> TOKEN_LOGICAL_AND (520)
    Note:   || (124,124) -> TOKEN_LOGICAL_OR (521)
    Note:   ! (33) -> TOKEN_LOGICAL_NOT (522)
    Note: 
    Note: Note: Single & and | are bitwise operators
    Note: 
    Note: TODO: Implement character code checks with && vs & and || vs | disambiguation
    
    Return 0  Note: Placeholder
End Process

Process called "recognize_bitwise_operator" takes first_char as Integer, second_char as Integer returns Integer:
    Note: Recognize bitwise operators (&, |, ^, ~, <<, >>)
    Note: 
    Note: Parameters:
    Note:   first_char - First character (ASCII code)
    Note:   second_char - Second character for multi-char operators (or 0)
    Note: 
    Note: Returns:
    Note:   Token type constant if recognized
    Note:   Returns 0 if not a bitwise operator
    Note: 
    Note: Checks:
    Note:   & (38) -> TOKEN_BITWISE_AND (530) if NOT &&
    Note:   | (124) -> TOKEN_BITWISE_OR (531) if NOT ||
    Note:   ^ (94) -> TOKEN_BITWISE_XOR (532)
    Note:   ~ (126) -> TOKEN_BITWISE_NOT (533)
    Note:   << (60,60) -> TOKEN_SHIFT_LEFT (534)
    Note:   >> (62,62) -> TOKEN_SHIFT_RIGHT (535)
    Note: 
    Note: TODO: Implement character code checks with << vs < and >> vs > disambiguation
    
    Return 0  Note: Placeholder
End Process

Note: ============================================================================
Note: Operator Information Retrieval
Note: ============================================================================

Process called "get_operator_info" takes token_type as Integer returns Integer:
    Note: Get comprehensive information about an operator
    Note: 
    Note: Parameters:
    Note:   token_type - Operator token type constant
    Note: 
    Note: Returns:
    Note:   Pointer to OperatorInfo structure with:
    Note:     - symbol: Operator string representation
    Note:     - canon_form: Natural language equivalent
    Note:     - precedence: Precedence level
    Note:     - associativity: ASSOC_LEFT or ASSOC_RIGHT
    Note:     - arity: 1 (unary), 2 (binary), or 3 (ternary)
    Note:   Returns 0 for unrecognized operator type
    Note: 
    Note: Example mappings:
    Note:   TOKEN_PLUS (500) -> {"+", "plus", PRECEDENCE_ADDITIVE, ASSOC_LEFT, 2}
    Note:   TOKEN_MULTIPLY (502) -> {"*", "multiplied by", PRECEDENCE_MULTIPLICATIVE, ASSOC_LEFT, 2}
    Note:   TOKEN_POWER (505) -> {"**", "raised to", PRECEDENCE_EXPONENTIATION, ASSOC_RIGHT, 2}
    Note: 
    Note: TODO: Implement lookup table or switch logic for all operator types
    Note: - Allocate OperatorInfo structure
    Note: - Populate fields based on token_type
    
    Return 0  Note: Placeholder
End Process

Process called "get_operator_precedence" takes token_type as Integer returns Integer:
    Note: Get precedence level for an operator
    Note: 
    Note: Higher precedence = tighter binding = evaluated first
    Note: 
    Note: Parameters:
    Note:   token_type - Operator token type constant
    Note: 
    Note: Returns:
    Note:   Precedence level (1-12, where 12 is highest)
    Note:   Returns 0 for non-operator or unknown type
    Note: 
    Note: Precedence order (low to high):
    Note:   1: || (logical or)
    Note:   2: && (logical and)
    Note:   3: | (bitwise or)
    Note:   4: ^ (bitwise xor)
    Note:   5: & (bitwise and)
    Note:   6: ==, != (equality)
    Note:   7: <, >, <=, >= (comparison)
    Note:   8: <<, >> (shifts)
    Note:   9: +, - (addition/subtraction)
    Note:   10: *, /, % (multiplication/division/modulo)
    Note:   11: ** (exponentiation)
    Note:   12: unary -, !, ~ (unary operators)
    Note: 
    Note: TODO: Return appropriate precedence constant based on token_type
    
    Return 0  Note: Placeholder
End Process

Process called "get_operator_associativity" takes token_type as Integer returns Integer:
    Note: Get associativity for an operator
    Note: 
    Note: Associativity determines evaluation order for same-precedence operators:
    Note:   Left: a + b + c = (a + b) + c
    Note:   Right: a ** b ** c = a ** (b ** c)
    Note: 
    Note: Parameters:
    Note:   token_type - Operator token type constant
    Note: 
    Note: Returns:
    Note:   ASSOC_LEFT (0) for left-to-right evaluation
    Note:   ASSOC_RIGHT (1) for right-to-left evaluation
    Note: 
    Note: Most operators are left-associative
    Note: Right-associative operators: ** (exponentiation), unary operators
    Note: 
    Note: TODO: Return ASSOC_LEFT for most operators, ASSOC_RIGHT for ** and unary
    
    Return 0  Note: Placeholder
End Process

Process called "is_unary_operator" takes token_type as Integer returns Integer:
    Note: Check if operator can be used as unary operator
    Note: 
    Note: Unary operators have one operand: -x, !flag, ~bits
    Note: 
    Note: Parameters:
    Note:   token_type - Operator token type constant
    Note: 
    Note: Returns:
    Note:   1 if operator can be unary, 0 otherwise
    Note: 
    Note: Unary operators:
    Note:   - (negation): -5, -x
    Note:   ! (logical not): !true, !condition
    Note:   ~ (bitwise not): ~0xFF
    Note: 
    Note: Note: + can technically be unary (+5) but is often omitted
    Note: 
    Note: TODO: Check if token_type is TOKEN_MINUS, TOKEN_LOGICAL_NOT, or TOKEN_BITWISE_NOT
    
    Return 0  Note: Placeholder
End Process

Process called "is_binary_operator" takes token_type as Integer returns Integer:
    Note: Check if operator can be used as binary operator
    Note: 
    Note: Binary operators have two operands: a + b, x * y
    Note: 
    Note: Parameters:
    Note:   token_type - Operator token type constant
    Note: 
    Note: Returns:
    Note:   1 if operator can be binary, 0 otherwise
    Note: 
    Note: Most operators are binary (arithmetic, comparison, logical, bitwise)
    Note: Unary-only operators: ~ (bitwise not in most languages)
    Note: 
    Note: TODO: Return 1 for most operators, handle special cases
    
    Return 1  Note: Placeholder - most operators are binary
End Process

Note: ============================================================================
Note: Developer Mode to Canon Mode Translation
Note: ============================================================================

Process called "translate_symbol_to_canon" takes operator_symbol as Integer returns Integer:
    Note: Translate Developer Mode symbol to Canon Mode natural language
    Note: 
    Note: Runa supports two syntax modes:
    Note:   - Developer Mode: Uses symbols (+, -, *, /, ==, etc.)
    Note:   - Canon Mode: Uses natural language (plus, minus, multiplied by, etc.)
    Note: 
    Note: This function converts symbols to their Canon equivalents
    Note: 
    Note: Parameters:
    Note:   operator_symbol - Symbol string ("+", "*", "==", etc.)
    Note: 
    Note: Returns:
    Note:   Pointer to Canon Mode string, or 0 if no translation needed
    Note: 
    Note: Translation mappings:
    Note:   "+" -> "plus"
    Note:   "-" -> "minus"
    Note:   "*" -> "multiplied by"
    Note:   "/" -> "divided by"
    Note:   "%" -> "modulo by"
    Note:   "**" -> "raised to"
    Note:   "==" -> "is equal to"
    Note:   "!=" -> "is not equal to"
    Note:   "<" -> "is less than"
    Note:   ">" -> "is greater than"
    Note:   "<=" -> "is less than or equal to"
    Note:   ">=" -> "is greater than or equal to"
    Note:   "&&" -> "and"
    Note:   "||" -> "or"
    Note:   "!" -> "not"
    Note: 
    Note: TODO: Implement translation lookup table
    
    Return 0  Note: Placeholder
End Process

Process called "translate_canon_to_symbol" takes canon_phrase as Integer returns Integer:
    Note: Translate Canon Mode natural language to Developer Mode symbol
    Note: 
    Note: Reverse translation of translate_symbol_to_canon
    Note: Allows parsing of Canon Mode source and generating Developer Mode output
    Note: 
    Note: Parameters:
    Note:   canon_phrase - Natural language phrase ("plus", "is equal to", etc.)
    Note: 
    Note: Returns:
    Note:   Pointer to symbol string, or 0 if no translation available
    Note: 
    Note: Translation mappings (reverse of translate_symbol_to_canon):
    Note:   "plus" -> "+"
    Note:   "multiplied by" -> "*"
    Note:   "is equal to" -> "=="
    Note:   "and" -> "&&"
    Note:   etc.
    Note: 
    Note: TODO: Implement reverse translation lookup table
    
    Return 0  Note: Placeholder
End Process

Note: ============================================================================
Note: Operator Validation
Note: ============================================================================

Process called "validate_operator_context" takes operator_type as Integer, context as Integer returns Integer:
    Note: Validate that operator is used in appropriate context
    Note: 
    Note: Some operators have context-dependent validity:
    Note:   - Unary minus must precede expression
    Note:   - Binary operators must appear between expressions
    Note:   - Comparison operators shouldn't chain without parentheses (a < b < c is ambiguous)
    Note: 
    Note: Parameters:
    Note:   operator_type - Operator token type
    Note:   context - Parsing context (expression position, precedence stack, etc.)
    Note: 
    Note: Returns:
    Note:   1 if operator is valid in context, 0 if invalid
    Note: 
    Note: TODO: Implement context validation rules
    Note: - Check if unary/binary usage matches position
    Note: - Validate operator chaining rules
    
    Return 1  Note: Placeholder - assume valid
End Process

Process called "create_operator_token" takes token_type as Integer, symbol as Integer, line as Integer, column as Integer, length as Integer returns Integer:
    Note: Create a token for a recognized operator
    Note: 
    Note: Parameters:
    Note:   token_type - Operator token type constant
    Note:   symbol - Operator symbol string
    Note:   line - Line number where operator appears
    Note:   column - Column number where operator appears
    Note:   length - Length of operator (1 or 2 characters)
    Note: 
    Note: Returns:
    Note:   Pointer to Token structure with populated fields
    Note:   Returns 0 on allocation failure
    Note: 
    Note: TODO: Implement using Layout.allocate for Token structure
    
    Return 0  Note: Placeholder
End Process
