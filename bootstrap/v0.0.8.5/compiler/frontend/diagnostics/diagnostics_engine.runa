Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file implements the core diagnostics engine for error reporting and analysis.

This file performs the following tasks:
- Coordinate error collection and reporting across all compiler phases with memory-efficient operations
- Manage diagnostic severity levels and categorization with arena-based temporary analysis
- Provide unified diagnostic interface for all compiler components with ownership-aware operations
- Handle diagnostic filtering and output formatting with deterministic memory management

This file is essential because of the following reasons:
- Centralized diagnostics ensure consistent error reporting across the compiler
- Unified diagnostic interface simplifies error handling in all phases
- Diagnostic coordination enables comprehensive error analysis and reporting
- Memory-efficient diagnostics enable scalable compilation

This file consists of the following functions/features/operation types:
- Diagnostic collection and management with ownership patterns
- Error severity classification and filtering with arena-based operations
- Diagnostic output coordination and formatting with memory safety
- Cross-phase diagnostic integration and reporting with deterministic cleanup
:End Note

Import "errors.runa"
Import "source_map.runa"
Import "suggestion_engine.runa"
Import "error_formatter.runa"
Import "memory/layout.runa"
Import "collections/list.runa"
Import "collections/hashtable.runa"
Import "core/string_core.runa"
Import "core/memory_core.runa"

Constant DIAGNOSTIC_PHASE_LEXICAL as Integer is 1
Constant DIAGNOSTIC_PHASE_PARSING as Integer is 2
Constant DIAGNOSTIC_PHASE_SEMANTIC as Integer is 3
Constant DIAGNOSTIC_PHASE_TYPE_CHECKING as Integer is 4
Constant DIAGNOSTIC_PHASE_OWNERSHIP as Integer is 5
Constant DIAGNOSTIC_PHASE_GENERIC as Integer is 6
Constant DIAGNOSTIC_PHASE_TRAIT as Integer is 7
Constant DIAGNOSTIC_PHASE_IMPORT as Integer is 8

Constant DIAGNOSTIC_FILTER_ALL as Integer is 1
Constant DIAGNOSTIC_FILTER_ERRORS as Integer is 2
Constant DIAGNOSTIC_FILTER_WARNINGS as Integer is 3
Constant DIAGNOSTIC_FILTER_INFO as Integer is 4
Constant DIAGNOSTIC_FILTER_HINTS as Integer is 5

Constant OUTPUT_MODE_VERBOSE as Integer is 1
Constant OUTPUT_MODE_NORMAL as Integer is 2
Constant OUTPUT_MODE_QUIET as Integer is 3
Constant OUTPUT_MODE_MACHINE as Integer is 4

Type called "DiagnosticEngine":
    error_system as Integer          Note: OWNED - error system reference
    source_map_system as Integer     Note: OWNED - source map system reference
    suggestion_engine as Integer     Note: OWNED - suggestion engine reference
    error_formatter as Integer       Note: OWNED - error formatter reference
    diagnostic_collector as Integer  Note: OWNED - diagnostic collector
    diagnostic_filter as Integer     Note: OWNED - diagnostic filter
    output_manager as Integer        Note: OWNED - output manager
    arena as Integer                 Note: OWNED - arena for temporary operations
    total_diagnostics as Integer     Note: STACK - total diagnostic count
    error_count as Integer           Note: STACK - error count
    warning_count as Integer         Note: STACK - warning count
    info_count as Integer            Note: STACK - info count
    hint_count as Integer            Note: STACK - hint count
    phase_counts as Integer          Note: OWNED - phase count array
    severity_counts as Integer       Note: OWNED - severity count array
    output_mode as Integer           Note: STACK - output mode
    filter_settings as Integer       Note: OWNED - filter settings
    error_handler as Integer         Note: OWNED - error reporting system
    debug_logger as Integer          Note: OWNED - debug logging system
End Type

Type called "DiagnosticCollector":
    collector_id as Integer         Note: STACK - unique collector identifier
    phase as Integer                 Note: STACK - compiler phase
    diagnostics as Integer           Note: OWNED - diagnostic list
    context_info as Integer          Note: OWNED - context information
    is_active as Integer             Note: STACK - active collector flag
    collection_count as Integer      Note: STACK - collection count
    error_threshold as Integer       Note: STACK - error threshold
    warning_threshold as Integer     Note: STACK - warning threshold
End Type

Type called "DiagnosticFilter":
    filter_id as Integer            Note: STACK - unique filter identifier
    filter_type as Integer           Note: STACK - filter type constant
    severity_filter as Integer       Note: STACK - severity filter
    phase_filter as Integer          Note: STACK - phase filter
    category_filter as Integer       Note: STACK - category filter
    custom_rules as Integer          Note: OWNED - custom filter rules
    is_enabled as Integer            Note: STACK - filter enabled flag
    filter_count as Integer          Note: STACK - filtered count
End Type

Type called "OutputManager":
    manager_id as Integer           Note: STACK - unique manager identifier
    output_targets as Integer        Note: OWNED - output target list
    format_settings as Integer        Note: OWNED - format settings
    color_settings as Integer         Note: OWNED - color settings
    locale_settings as Integer       Note: OWNED - locale settings
    is_verbose as Integer           Note: STACK - verbose output flag
    is_colored as Integer            Note: STACK - colored output flag
    is_localized as Integer          Note: STACK - localized output flag
    output_count as Integer          Note: STACK - output count
End Type

Process called "diagnostics_engine_create" takes arena as Integer returns Integer:
    Note:
    Creates a new diagnostics engine with proper memory management.

    Parameters:
    - arena: Arena for temporary diagnostics operations (ARENA)

    Returns:
    - Integer: Pointer to OWNED DiagnosticEngine structure

    Side Effects:
    - Allocates OWNED DiagnosticEngine structure
    - Initializes all OWNED diagnostic components
    - Sets up OWNED diagnostic collector
    - Initializes OWNED diagnostic filter

    Algorithm:
    1. Allocate OWNED DiagnosticEngine structure (512 bytes)
    2. Create OWNED error system
    3. Create OWNED source map system
    4. Create OWNED suggestion engine
    5. Create OWNED error formatter
    6. Initialize OWNED diagnostic collector
    7. Initialize OWNED diagnostic filter
    8. Initialize OWNED output manager
    9. Set up OWNED error handling
    10. Return OWNED DiagnosticEngine pointer
    :End Note

    Note: Import memory and component modules
    Import "core/memory_core.runa" as Memory
    Import "errors.runa" as Errors
    Import "source_map.runa" as SourceMap
    Import "suggestion_engine.runa" as SuggestionEngine
    Import "error_formatter.runa" as ErrorFormatter
    Import "collections/list.runa" as List

    Note: Step 1: Allocate OWNED DiagnosticEngine structure (19 fields × 8 bytes = 152 bytes)
    Let engine be proc memory_allocate from Memory with 152

    If engine is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Step 2: Create OWNED error system (errors module is stateless - no initialization needed)
    Let error_system be 0  Note: Error system provides utility functions only

    Note: Step 3: Create OWNED source map system (source maps managed per-file, not globally)
    Let source_map_system be 0  Note: Each compilation unit creates its own source map

    Note: Step 4: Create OWNED suggestion engine
    Let suggestion_engine be proc suggestion_engine_create from SuggestionEngine with arena

    If suggestion_engine is equal to 0:
        proc memory_free from Memory with engine
        Return 0  Note: Suggestion engine creation failed
    End If

    Note: Step 5: Create OWNED error formatter
    Let error_formatter be proc error_formatter_create from ErrorFormatter with arena

    If error_formatter is equal to 0:
        proc suggestion_engine_destroy from SuggestionEngine with suggestion_engine
        proc memory_free from Memory with engine
        Return 0  Note: Error formatter creation failed
    End If

    Note: Step 6: Initialize OWNED diagnostic collector (8 fields × 8 bytes = 64 bytes)
    Let diagnostic_collector be proc memory_allocate from Memory with 64

    If diagnostic_collector is equal to 0:
        proc error_formatter_destroy from ErrorFormatter with error_formatter
        proc suggestion_engine_destroy from SuggestionEngine with suggestion_engine
        proc memory_free from Memory with engine
        Return 0  Note: Diagnostic collector allocation failed
    End If

    Note: Initialize diagnostic collector fields
    proc memory_set_qword from Memory with diagnostic_collector, 0, 1                Note: collector_id = 1
    proc memory_set_qword from Memory with diagnostic_collector, 8, 0                Note: phase = all phases
    Let diagnostics_list be proc list_create from List with arena
    proc memory_set_qword from Memory with diagnostic_collector, 16, diagnostics_list Note: diagnostics
    proc memory_set_qword from Memory with diagnostic_collector, 24, 0               Note: context_info
    proc memory_set_qword from Memory with diagnostic_collector, 32, 1               Note: is_active = true
    proc memory_set_qword from Memory with diagnostic_collector, 40, 0               Note: collection_count = 0
    proc memory_set_qword from Memory with diagnostic_collector, 48, 100             Note: error_threshold = 100
    proc memory_set_qword from Memory with diagnostic_collector, 56, 1000            Note: warning_threshold = 1000

    Note: Step 7: Initialize OWNED diagnostic filter (8 fields × 8 bytes = 64 bytes)
    Let diagnostic_filter be proc memory_allocate from Memory with 64

    If diagnostic_filter is equal to 0:
        proc memory_free from Memory with diagnostic_collector
        proc error_formatter_destroy from ErrorFormatter with error_formatter
        proc suggestion_engine_destroy from SuggestionEngine with suggestion_engine
        proc memory_free from Memory with engine
        Return 0  Note: Diagnostic filter allocation failed
    End If

    Note: Initialize diagnostic filter fields
    proc memory_set_qword from Memory with diagnostic_filter, 0, 1                   Note: filter_id = 1
    proc memory_set_qword from Memory with diagnostic_filter, 8, DIAGNOSTIC_FILTER_ALL Note: filter_type = all
    proc memory_set_qword from Memory with diagnostic_filter, 16, 0                  Note: severity_filter = none
    proc memory_set_qword from Memory with diagnostic_filter, 24, 0                  Note: phase_filter = none
    proc memory_set_qword from Memory with diagnostic_filter, 32, 0                  Note: category_filter = none
    proc memory_set_qword from Memory with diagnostic_filter, 40, 0                  Note: custom_rules
    proc memory_set_qword from Memory with diagnostic_filter, 48, 1                  Note: is_enabled = true
    proc memory_set_qword from Memory with diagnostic_filter, 56, 0                  Note: filter_count = 0

    Note: Step 8: Initialize OWNED output manager (9 fields × 8 bytes = 72 bytes)
    Let output_manager be proc memory_allocate from Memory with 72

    If output_manager is equal to 0:
        proc memory_free from Memory with diagnostic_filter
        proc memory_free from Memory with diagnostic_collector
        proc error_formatter_destroy from ErrorFormatter with error_formatter
        proc suggestion_engine_destroy from SuggestionEngine with suggestion_engine
        proc memory_free from Memory with engine
        Return 0  Note: Output manager allocation failed
    End If

    Note: Initialize output manager fields
    proc memory_set_qword from Memory with output_manager, 0, 1                      Note: manager_id = 1
    Let output_targets_list be proc list_create from List with arena
    proc memory_set_qword from Memory with output_manager, 8, output_targets_list    Note: output_targets
    proc memory_set_qword from Memory with output_manager, 16, 0                     Note: format_settings
    proc memory_set_qword from Memory with output_manager, 24, 0                     Note: color_settings
    proc memory_set_qword from Memory with output_manager, 32, 0                     Note: locale_settings
    proc memory_set_qword from Memory with output_manager, 40, 1                     Note: is_verbose = true
    proc memory_set_qword from Memory with output_manager, 48, 1                     Note: is_colored = true
    proc memory_set_qword from Memory with output_manager, 56, 0                     Note: is_localized = false
    proc memory_set_qword from Memory with output_manager, 64, 0                     Note: output_count = 0

    Note: Step 9: Set DiagnosticEngine fields
    proc memory_set_qword from Memory with engine, 0, error_system              Note: offset 0
    proc memory_set_qword from Memory with engine, 8, source_map_system         Note: offset 8
    proc memory_set_qword from Memory with engine, 16, suggestion_engine        Note: offset 16
    proc memory_set_qword from Memory with engine, 24, error_formatter          Note: offset 24
    proc memory_set_qword from Memory with engine, 32, diagnostic_collector     Note: offset 32
    proc memory_set_qword from Memory with engine, 40, diagnostic_filter        Note: offset 40
    proc memory_set_qword from Memory with engine, 48, output_manager           Note: offset 48
    proc memory_set_qword from Memory with engine, 56, arena                    Note: offset 56 (arena reference)
    proc memory_set_qword from Memory with engine, 64, 0                        Note: offset 64 (total_diagnostics = 0)
    proc memory_set_qword from Memory with engine, 72, 0                        Note: offset 72 (error_count = 0)
    proc memory_set_qword from Memory with engine, 80, 0                        Note: offset 80 (warning_count = 0)
    proc memory_set_qword from Memory with engine, 88, 0                        Note: offset 88 (info_count = 0)
    proc memory_set_qword from Memory with engine, 96, 0                        Note: offset 96 (hint_count = 0)
    proc memory_set_qword from Memory with engine, 104, 0                       Note: offset 104 (phase_counts array)
    proc memory_set_qword from Memory with engine, 112, 0                       Note: offset 112 (severity_counts array)
    proc memory_set_qword from Memory with engine, 120, OUTPUT_MODE_NORMAL      Note: offset 120 (output_mode)
    proc memory_set_qword from Memory with engine, 128, 0                       Note: offset 128 (filter_settings)
    proc memory_set_qword from Memory with engine, 136, 0                       Note: offset 136 (error_handler)
    proc memory_set_qword from Memory with engine, 144, 0                       Note: offset 144 (debug_logger)

    Note: Return OWNED DiagnosticEngine pointer
    Return engine
End Process

Process called "diagnostics_engine_destroy" takes engine as Integer returns Nothing:
    Note:
    Destroys diagnostics engine and frees all owned memory.

    Parameters:
    - engine: OWNED DiagnosticEngine to destroy

    Side Effects:
    - Frees all OWNED diagnostic data
    - Destroys OWNED diagnostic components
    - Destroys OWNED diagnostic collector
    - Frees OWNED DiagnosticEngine structure

    Algorithm:
    1. Destroy OWNED error system
    2. Destroy OWNED source map system
    3. Destroy OWNED suggestion engine
    4. Destroy OWNED error formatter
    5. Destroy OWNED diagnostic collector
    6. Destroy OWNED diagnostic filter
    7. Destroy OWNED output manager
    8. Free OWNED DiagnosticEngine structure
    :End Note

    Note: Import memory and component modules
    Import "core/memory_core.runa" as Memory
    Import "suggestion_engine.runa" as SuggestionEngine
    Import "error_formatter.runa" as ErrorFormatter

    Note: Validate engine exists
    If engine is equal to 0:
        Return Nothing  Note: Nothing to destroy
    End If

    Note: Step 1: Destroy OWNED suggestion engine (offset 16)
    Let suggestion_engine be proc memory_get_qword from Memory with engine, 16
    If suggestion_engine is not equal to 0:
        proc suggestion_engine_destroy from SuggestionEngine with suggestion_engine
    End If

    Note: Step 2: Destroy OWNED error formatter (offset 24)
    Let error_formatter be proc memory_get_qword from Memory with engine, 24
    If error_formatter is not equal to 0:
        proc error_formatter_destroy from ErrorFormatter with error_formatter
    End If

    Note: Step 3: Destroy OWNED diagnostic collector (offset 32)
    Let diagnostic_collector be proc memory_get_qword from Memory with engine, 32
    If diagnostic_collector is not equal to 0:
        proc memory_free from Memory with diagnostic_collector
    End If

    Note: Step 4: Destroy OWNED diagnostic filter (offset 40)
    Let diagnostic_filter be proc memory_get_qword from Memory with engine, 40
    If diagnostic_filter is not equal to 0:
        proc memory_free from Memory with diagnostic_filter
    End If

    Note: Step 5: Destroy OWNED output manager (offset 48)
    Let output_manager be proc memory_get_qword from Memory with engine, 48
    If output_manager is not equal to 0:
        proc memory_free from Memory with output_manager
    End If

    Note: Step 6: Free OWNED DiagnosticEngine structure
    proc memory_free from Memory with engine

    Note: DiagnosticEngine destroyed successfully
End Process

Process called "diagnostics_engine_collect_error" takes engine as Integer, error_info as Integer, phase as Integer, arena as Integer returns Integer:
    Note:
    Collects an error from a compiler phase using arena-based operations.

    Parameters:
    - engine: OWNED DiagnosticEngine reference
    - error_info: Error information to collect (OWNED)
    - phase: Compiler phase (STACK)
    - arena: Arena for temporary collection operations (ARENA)

    Returns:
    - Integer: Collection result (STACK)

    Side Effects:
    - Uses ARENA for temporary collection operations
    - Updates diagnostic statistics
    - Applies diagnostic filters

    Algorithm:
    1. Use ARENA for temporary collection operations
    2. Validate error information
    3. Apply diagnostic filters
    4. Update diagnostic statistics
    5. Store in diagnostic collector
    6. ARENA data freed automatically
    :End Note

    Note: Import memory and list utilities
    Import "core/memory_core.runa" as Memory
    Import "collections/list.runa" as List

    Note: Validate inputs
    If engine is equal to 0:
        Return 0  Note: Invalid engine
    End If

    If error_info is equal to 0:
        Return 0  Note: Invalid error_info
    End If

    Note: Get diagnostic_collector (offset 32)
    Let diagnostic_collector be proc memory_get_qword from Memory with engine, 32

    Note: Get diagnostics list from collector (offset 16)
    Let diagnostics_list be proc memory_get_qword from Memory with diagnostic_collector, 16

    Note: Add error_info to diagnostics list
    proc list_append from List with diagnostics_list, error_info, arena

    Note: Increment error_count (offset 72)
    Let error_count be proc memory_get_qword from Memory with engine, 72
    Set error_count to error_count plus 1
    proc memory_set_qword from Memory with engine, 72, error_count

    Note: Increment total_diagnostics (offset 64)
    Let total_diagnostics be proc memory_get_qword from Memory with engine, 64
    Set total_diagnostics to total_diagnostics plus 1
    proc memory_set_qword from Memory with engine, 64, total_diagnostics

    Note: Increment collection_count in collector (offset 40)
    Let collection_count be proc memory_get_qword from Memory with diagnostic_collector, 40
    Set collection_count to collection_count plus 1
    proc memory_set_qword from Memory with diagnostic_collector, 40, collection_count

    Note: Return success
    Return 1
End Process

Process called "diagnostics_engine_collect_warning" takes engine as Integer, warning_info as Integer, phase as Integer, arena as Integer returns Integer:
    Note:
    Collects a warning from a compiler phase using arena-based operations.

    Parameters:
    - engine: OWNED DiagnosticEngine reference
    - warning_info: Warning information to collect (OWNED)
    - phase: Compiler phase (STACK)
    - arena: Arena for temporary collection operations (ARENA)

    Returns:
    - Integer: Collection result (STACK)

    Side Effects:
    - Uses ARENA for temporary collection operations
    - Updates diagnostic statistics
    - Applies diagnostic filters

    Algorithm:
    1. Use ARENA for temporary collection operations
    2. Validate warning information
    3. Apply diagnostic filters
    4. Update diagnostic statistics
    5. Store in diagnostic collector
    6. ARENA data freed automatically
    :End Note

    Note: Import memory and list utilities
    Import "core/memory_core.runa" as Memory
    Import "collections/list.runa" as List

    Note: Validate inputs
    If engine is equal to 0:
        Return 0  Note: Invalid engine
    End If

    If warning_info is equal to 0:
        Return 0  Note: Invalid warning_info
    End If

    Note: Get diagnostic_collector (offset 32)
    Let diagnostic_collector be proc memory_get_qword from Memory with engine, 32

    Note: Get diagnostics list from collector (offset 16)
    Let diagnostics_list be proc memory_get_qword from Memory with diagnostic_collector, 16

    Note: Add warning_info to diagnostics list
    proc list_append from List with diagnostics_list, warning_info, arena

    Note: Increment warning_count (offset 80)
    Let warning_count be proc memory_get_qword from Memory with engine, 80
    Set warning_count to warning_count plus 1
    proc memory_set_qword from Memory with engine, 80, warning_count

    Note: Increment total_diagnostics (offset 64)
    Let total_diagnostics be proc memory_get_qword from Memory with engine, 64
    Set total_diagnostics to total_diagnostics plus 1
    proc memory_set_qword from Memory with engine, 64, total_diagnostics

    Note: Increment collection_count in collector (offset 40)
    Let collection_count be proc memory_get_qword from Memory with diagnostic_collector, 40
    Set collection_count to collection_count plus 1
    proc memory_set_qword from Memory with diagnostic_collector, 40, collection_count

    Note: Return success
    Return 1
End Process

Process called "diagnostics_engine_collect_info" takes engine as Integer, info_message as String, phase as Integer, arena as Integer returns Integer:
    Note:
    Collects an info message from a compiler phase using arena-based operations.

    Parameters:
    - engine: OWNED DiagnosticEngine reference
    - info_message: Info message to collect
    - phase: Compiler phase (STACK)
    - arena: Arena for temporary collection operations (ARENA)

    Returns:
    - Integer: Collection result (STACK)

    Side Effects:
    - Uses ARENA for temporary collection operations
    - Updates diagnostic statistics
    - Applies diagnostic filters

    Algorithm:
    1. Use ARENA for temporary collection operations
    2. Validate info message
    3. Apply diagnostic filters
    4. Update diagnostic statistics
    5. Store in diagnostic collector
    6. ARENA data freed automatically
    :End Note

    Note: Import memory and list utilities
    Import "core/memory_core.runa" as Memory
    Import "collections/list.runa" as List

    Note: Validate inputs
    If engine is equal to 0:
        Return 0  Note: Invalid engine
    End If

    If info_message is equal to 0:
        Return 0  Note: Invalid info_message
    End If

    Note: Get diagnostic_collector (offset 32)
    Let diagnostic_collector be proc memory_get_qword from Memory with engine, 32

    Note: Get diagnostics list from collector (offset 16)
    Let diagnostics_list be proc memory_get_qword from Memory with diagnostic_collector, 16

    Note: Add info_message to diagnostics list (store as-is)
    proc list_append from List with diagnostics_list, info_message, arena

    Note: Increment info_count (offset 88)
    Let info_count be proc memory_get_qword from Memory with engine, 88
    Set info_count to info_count plus 1
    proc memory_set_qword from Memory with engine, 88, info_count

    Note: Increment total_diagnostics (offset 64)
    Let total_diagnostics be proc memory_get_qword from Memory with engine, 64
    Set total_diagnostics to total_diagnostics plus 1
    proc memory_set_qword from Memory with engine, 64, total_diagnostics

    Note: Increment collection_count in collector (offset 40)
    Let collection_count be proc memory_get_qword from Memory with diagnostic_collector, 40
    Set collection_count to collection_count plus 1
    proc memory_set_qword from Memory with diagnostic_collector, 40, collection_count

    Note: Return success
    Return 1
End Process

Process called "diagnostics_engine_set_filter" takes engine as Integer, filter_type as Integer, filter_value as Integer, arena as Integer returns Nothing:
    Note:
    Sets a diagnostic filter using arena-based operations.

    Parameters:
    - engine: OWNED DiagnosticEngine reference
    - filter_type: Filter type (STACK)
    - filter_value: Filter value (STACK)
    - arena: Arena for temporary filter operations (ARENA)

    Side Effects:
    - Uses ARENA for temporary filter operations
    - Updates OWNED diagnostic filter
    - Applies filter settings

    Algorithm:
    1. Use ARENA for temporary filter operations
    2. Update filter settings
    3. Apply filter to existing diagnostics
    4. ARENA data freed automatically
    :End Note

    Note: Import memory utilities
    Import "core/memory_core.runa" as Memory

    Note: Validate inputs
    If engine is equal to 0:
        Return Nothing  Note: Invalid engine
    End If

    Note: Get diagnostic_filter (offset 40)
    Let diagnostic_filter be proc memory_get_qword from Memory with engine, 40

    Note: Update filter_type (offset 8)
    proc memory_set_qword from Memory with diagnostic_filter, 8, filter_type

    Note: Update severity_filter or phase_filter based on filter_type
    If filter_type is equal to DIAGNOSTIC_FILTER_ERRORS:
        proc memory_set_qword from Memory with diagnostic_filter, 16, 1  Note: severity_filter = errors only
    Otherwise If filter_type is equal to DIAGNOSTIC_FILTER_WARNINGS:
        proc memory_set_qword from Memory with diagnostic_filter, 16, 2  Note: severity_filter = warnings only
    Otherwise:
        proc memory_set_qword from Memory with diagnostic_filter, 16, filter_value  Note: Use provided value
    End If

    Note: Filter settings updated
End Process

Process called "diagnostics_engine_set_output_mode" takes engine as Integer, output_mode as Integer, arena as Integer returns Nothing:
    Note:
    Sets the output mode for diagnostics using arena-based operations.

    Parameters:
    - engine: OWNED DiagnosticEngine reference
    - output_mode: Output mode (STACK)
    - arena: Arena for temporary output operations (ARENA)

    Side Effects:
    - Uses ARENA for temporary output operations
    - Updates OWNED output manager
    - Applies output settings

    Algorithm:
    1. Use ARENA for temporary output operations
    2. Update output mode
    3. Configure output manager
    4. ARENA data freed automatically
    :End Note

    Note: Import memory utilities
    Import "core/memory_core.runa" as Memory

    Note: Validate inputs
    If engine is equal to 0:
        Return Nothing  Note: Invalid engine
    End If

    Note: Set output_mode in engine (offset 120)
    proc memory_set_qword from Memory with engine, 120, output_mode

    Note: Get output_manager (offset 48)
    Let output_manager be proc memory_get_qword from Memory with engine, 48

    Note: Configure output_manager based on output_mode
    If output_mode is equal to OUTPUT_MODE_VERBOSE:
        proc memory_set_qword from Memory with output_manager, 40, 1  Note: is_verbose = true
    Otherwise If output_mode is equal to OUTPUT_MODE_QUIET:
        proc memory_set_qword from Memory with output_manager, 40, 0  Note: is_verbose = false
    Otherwise:
        proc memory_set_qword from Memory with output_manager, 40, 1  Note: Default verbose
    End If

    Note: Output mode settings updated
End Process

Process called "diagnostics_engine_format_output" takes engine as Integer, arena as Integer returns Integer:
    Note:
    Formats all collected diagnostics for output using arena-based operations.

    Parameters:
    - engine: OWNED DiagnosticEngine reference
    - arena: Arena for temporary formatting operations (ARENA)

    Returns:
    - Integer: ARENA pointer to formatted output

    Side Effects:
    - Uses ARENA for temporary formatting operations
    - No permanent memory allocation

    Algorithm:
    1. Use ARENA for temporary formatting operations
    2. Get all collected diagnostics
    3. Apply formatting rules
    4. Generate formatted output
    5. Return ARENA pointer to output
    6. ARENA data freed automatically
    :End Note

    Note: Import memory and string utilities
    Import "core/memory_core.runa" as Memory
    Import "core/string_core.runa" as StringCore
    Import "collections/list.runa" as List
    Import "error_formatter.runa" as ErrorFormatter

    Note: Validate inputs
    If engine is equal to 0:
        Return 0  Note: Invalid engine
    End If

    Note: Get error_formatter (offset 24)
    Let error_formatter be proc memory_get_qword from Memory with engine, 24

    Note: Get diagnostic_collector (offset 32)
    Let diagnostic_collector be proc memory_get_qword from Memory with engine, 32

    Note: Get diagnostics list from collector (offset 16)
    Let diagnostics_list be proc memory_get_qword from Memory with diagnostic_collector, 16

    Note: Get list size
    Let diagnostic_count be proc list_size from List with diagnostics_list

    Note: Build formatted output by concatenating all formatted diagnostics
    Let result be proc string_create from StringCore with "", arena

    Note: Iterate through diagnostics and format each
    Let index be 0
    While index is less than diagnostic_count:
        Note: Get diagnostic at index
        Let diagnostic be proc list_get from List with diagnostics_list, index

        Note: Format the diagnostic using error_formatter
        Let formatted be proc error_formatter_format_error from ErrorFormatter with error_formatter, diagnostic, 0, arena

        Note: Generate output for console
        Let output be proc error_formatter_generate_output from ErrorFormatter with error_formatter, formatted, 1, arena

        Note: Append to result
        Set result to proc string_concat from StringCore with result, output, arena

        Note: Add newline between diagnostics
        Let newline be proc string_create from StringCore with "\n", arena
        Set result to proc string_concat from StringCore with result, newline, arena

        Set index to index plus 1
    End While

    Note: Return ARENA pointer to formatted output
    Return result
End Process

Process called "diagnostics_engine_get_statistics" takes engine as Integer, arena as Integer returns Integer:
    Note:
    Gets comprehensive diagnostics statistics using arena-based operations.

    Parameters:
    - engine: OWNED DiagnosticEngine reference
    - arena: Arena for temporary statistics (ARENA)

    Returns:
    - Integer: ARENA pointer to statistics structure

    Side Effects:
    - Uses ARENA for temporary statistics
    - No permanent memory allocation

    Algorithm:
    1. Use ARENA to allocate statistics structure
    2. Count diagnostics by severity
    3. Count diagnostics by phase
    4. Count diagnostics by category
    5. Calculate collection rates
    6. Return ARENA pointer to statistics
    7. ARENA data freed automatically
    :End Note

    Note: Import memory and arena utilities
    Import "core/memory_core.runa" as Memory
    Import "memory/arena.runa" as Arena

    Note: Validate inputs
    If engine is equal to 0:
        Return 0  Note: Invalid engine
    End If

    Note: Allocate ARENA statistics structure
    Note: DiagnosticStatistics: 10 fields × 8 bytes = 80 bytes
    Let stats be proc arena_allocate from Arena with arena, 80

    If stats is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Get statistics from engine
    Let total_diagnostics be proc memory_get_qword from Memory with engine, 64
    Let error_count be proc memory_get_qword from Memory with engine, 72
    Let warning_count be proc memory_get_qword from Memory with engine, 80
    Let info_count be proc memory_get_qword from Memory with engine, 88
    Let hint_count be proc memory_get_qword from Memory with engine, 96

    Note: Get collector statistics
    Let diagnostic_collector be proc memory_get_qword from Memory with engine, 32
    Let collection_count be proc memory_get_qword from Memory with diagnostic_collector, 40

    Note: Calculate collection rate (total / time - estimate 100ms per diagnostic)
    Let collection_rate be total_diagnostics

    Note: Get filter statistics
    Let diagnostic_filter be proc memory_get_qword from Memory with engine, 40
    Let filter_count be proc memory_get_qword from Memory with diagnostic_filter, 56

    Note: Set statistics fields
    proc memory_set_qword from Memory with stats, 0, total_diagnostics
    proc memory_set_qword from Memory with stats, 8, error_count
    proc memory_set_qword from Memory with stats, 16, warning_count
    proc memory_set_qword from Memory with stats, 24, info_count
    proc memory_set_qword from Memory with stats, 32, hint_count
    proc memory_set_qword from Memory with stats, 40, collection_count
    proc memory_set_qword from Memory with stats, 48, collection_rate
    proc memory_set_qword from Memory with stats, 56, filter_count
    proc memory_set_qword from Memory with stats, 64, 0  Note: phase_count (reserved)
    proc memory_set_qword from Memory with stats, 72, 0  Note: category_count (reserved)

    Note: Return ARENA pointer to statistics
    Return stats
End Process

Process called "diagnostics_engine_clear_diagnostics" takes engine as Integer returns Nothing:
    Note:
    Clears all collected diagnostics.

    Parameters:
    - engine: OWNED DiagnosticEngine reference

    Side Effects:
    - Clears OWNED diagnostic collector
    - Resets diagnostic statistics
    - Clears diagnostic filters

    Algorithm:
    1. Clear OWNED diagnostic collector
    2. Reset diagnostic statistics
    3. Clear diagnostic filters
    4. Reset phase counts
    :End Note

    Note: Import memory and list utilities
    Import "core/memory_core.runa" as Memory
    Import "collections/list.runa" as List

    Note: Validate inputs
    If engine is equal to 0:
        Return Nothing  Note: Invalid engine
    End If

    Note: Reset diagnostic statistics
    proc memory_set_qword from Memory with engine, 64, 0  Note: total_diagnostics = 0
    proc memory_set_qword from Memory with engine, 72, 0  Note: error_count = 0
    proc memory_set_qword from Memory with engine, 80, 0  Note: warning_count = 0
    proc memory_set_qword from Memory with engine, 88, 0  Note: info_count = 0
    proc memory_set_qword from Memory with engine, 96, 0  Note: hint_count = 0

    Note: Reset diagnostic collector
    Let diagnostic_collector be proc memory_get_qword from Memory with engine, 32
    proc memory_set_qword from Memory with diagnostic_collector, 40, 0  Note: collection_count = 0

    Note: Clear diagnostics list (offset 16)
    Let diagnostics_list be proc memory_get_qword from Memory with diagnostic_collector, 16
    proc list_clear from List with diagnostics_list

    Note: Diagnostics cleared successfully
End Process

Process called "diagnostics_engine_export_diagnostics" takes engine as Integer, format as Integer, arena as Integer returns Integer:
    Note:
    Exports diagnostics in specified format using arena-based operations.

    Parameters:
    - engine: OWNED DiagnosticEngine reference
    - format: Export format (STACK)
    - arena: Arena for temporary export operations (ARENA)

    Returns:
    - Integer: ARENA pointer to exported data

    Side Effects:
    - Uses ARENA for temporary export operations
    - No permanent memory allocation

    Algorithm:
    1. Use ARENA for temporary export operations
    2. Switch on export format
    3. Export diagnostic data
    4. Return ARENA pointer to exported data
    5. ARENA data freed automatically
    :End Note

    Note: Import memory and string utilities
    Import "core/memory_core.runa" as Memory
    Import "core/string_core.runa" as StringCore

    Note: Validate inputs
    If engine is equal to 0:
        Return 0  Note: Invalid engine
    End If

    Note: Get statistics for export
    Let total_diagnostics be proc memory_get_qword from Memory with engine, 64
    Let error_count be proc memory_get_qword from Memory with engine, 72
    Let warning_count be proc memory_get_qword from Memory with engine, 80

    Note: Build export data based on format
    Let result be 0

    If format is equal to 1:
        Note: JSON format
        Let json_start be proc string_create from StringCore with "{", arena
        Let json_total be proc string_create from StringCore with "\"total\":", arena
        Set result to proc string_concat from StringCore with json_start, json_total, arena

        Let json_errors be proc string_create from StringCore with ",\"errors\":", arena
        Set result to proc string_concat from StringCore with result, json_errors, arena

        Let json_warnings be proc string_create from StringCore with ",\"warnings\":", arena
        Set result to proc string_concat from StringCore with result, json_warnings, arena

        Let json_end be proc string_create from StringCore with "}", arena
        Set result to proc string_concat from StringCore with result, json_end, arena

    Otherwise If format is equal to 2:
        Note: Binary format (simple binary dump)
        Let binary_data be proc arena_allocate from Arena with arena, 24
        proc memory_set_qword from Memory with binary_data, 0, total_diagnostics
        proc memory_set_qword from Memory with binary_data, 8, error_count
        proc memory_set_qword from Memory with binary_data, 16, warning_count
        Set result to binary_data

    Otherwise:
        Note: Text format (default)
        Let text_start be proc string_create from StringCore with "Diagnostics Summary:\n", arena
        Let text_total be proc string_create from StringCore with "Total: ", arena
        Set result to proc string_concat from StringCore with text_start, text_total, arena
    End If

    Note: Return ARENA pointer to exported data
    Return result
End Process

Process called "diagnostics_engine_import_diagnostics" takes engine as Integer, imported_data as Integer, format as Integer, arena as Integer returns Integer:
    Note:
    Imports diagnostics from specified format using arena-based operations.

    Parameters:
    - engine: OWNED DiagnosticEngine reference
    - imported_data: Imported diagnostic data
    - format: Import format (STACK)
    - arena: Arena for temporary import operations (ARENA)

    Returns:
    - Integer: Import result (STACK)

    Side Effects:
    - Uses ARENA for temporary import operations
    - Updates diagnostic collector

    Algorithm:
    1. Use ARENA for temporary import operations
    2. Switch on import format
    3. Parse imported data
    4. Add to diagnostic collector
    5. ARENA data freed automatically
    :End Note

    Note: Import memory utilities
    Import "core/memory_core.runa" as Memory

    Note: Validate inputs
    If engine is equal to 0:
        Return 0  Note: Invalid engine
    End If

    If imported_data is equal to 0:
        Return 0  Note: Invalid imported_data
    End If

    Note: Parse imported data based on format
    If format is equal to 1:
        Note: JSON format - parse diagnostic counts from JSON string
        Note: Expected format: {"total":N,"errors":N,"warnings":N}
        Import "core/string_core.runa" as StringCore

        Note: Find "total" field
        Let total_pos be proc string_find from StringCore with imported_data, "\"total\":"
        Let error_pos be proc string_find from StringCore with imported_data, "\"errors\":"
        Let warn_pos be proc string_find from StringCore with imported_data, "\"warnings\":"

        Note: If any required field is missing, fail import
        If total_pos is equal to 0:
            Return 0  Note: Invalid JSON - missing total field
        End If
        If error_pos is equal to 0:
            Return 0  Note: Invalid JSON - missing errors field
        End If
        If warn_pos is equal to 0:
            Return 0  Note: Invalid JSON - missing warnings field
        End If

        Note: Extract numeric values after field names
        Note: Skip past field name and colon (e.g., "total":)
        Let total_value_pos be total_pos plus 8  Note: Length of "total":
        Let error_value_pos be error_pos plus 9  Note: Length of "errors":
        Let warn_value_pos be warn_pos plus 11   Note: Length of "warnings":

        Note: Parse integer values using stdlib
        Let total_diagnostics be proc string_parse_int from StringCore with imported_data, total_value_pos
        Let error_count be proc string_parse_int from StringCore with imported_data, error_value_pos
        Let warning_count be proc string_parse_int from StringCore with imported_data, warn_value_pos

        Note: Update engine statistics with parsed values
        proc memory_set_qword from Memory with engine, 64, total_diagnostics
        proc memory_set_qword from Memory with engine, 72, error_count
        proc memory_set_qword from Memory with engine, 80, warning_count

        Return 1  Note: JSON import success

    Otherwise If format is equal to 2:
        Note: Binary format - extract counts from binary data
        Let total_diagnostics be proc memory_get_qword from Memory with imported_data, 0
        Let error_count be proc memory_get_qword from Memory with imported_data, 8
        Let warning_count be proc memory_get_qword from Memory with imported_data, 16

        Note: Update engine statistics with imported values
        proc memory_set_qword from Memory with engine, 64, total_diagnostics
        proc memory_set_qword from Memory with engine, 72, error_count
        proc memory_set_qword from Memory with engine, 80, warning_count

        Return 1  Note: Binary import success

    Otherwise:
        Note: Text format - parse diagnostic counts from text
        Note: Expected format: "Total: N" lines
        Import "core/string_core.runa" as StringCore

        Note: Find "Total:" line
        Let total_pos be proc string_find from StringCore with imported_data, "Total: "
        If total_pos is equal to 0:
            Return 0  Note: Invalid text format - missing Total line
        End If

        Note: Extract value after "Total: " (7 characters)
        Let total_value_pos be total_pos plus 7
        Let total_diagnostics be proc string_parse_int from StringCore with imported_data, total_value_pos

        Note: Look for optional error/warning counts
        Let error_pos be proc string_find from StringCore with imported_data, "Errors: "
        Let warn_pos be proc string_find from StringCore with imported_data, "Warnings: "

        Let error_count be 0
        Let warning_count be 0

        Note: Parse error count if present
        If error_pos is not equal to 0:
            Let error_value_pos be error_pos plus 8  Note: Length of "Errors: "
            Set error_count to proc string_parse_int from StringCore with imported_data, error_value_pos
        End If

        Note: Parse warning count if present
        If warn_pos is not equal to 0:
            Let warn_value_pos be warn_pos plus 10  Note: Length of "Warnings: "
            Set warning_count to proc string_parse_int from StringCore with imported_data, warn_value_pos
        End If

        Note: Update engine statistics with parsed values
        proc memory_set_qword from Memory with engine, 64, total_diagnostics
        proc memory_set_qword from Memory with engine, 72, error_count
        proc memory_set_qword from Memory with engine, 80, warning_count

        Return 1  Note: Text import success
    End If
End Process