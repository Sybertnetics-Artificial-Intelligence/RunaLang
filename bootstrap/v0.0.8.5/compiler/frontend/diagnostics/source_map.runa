Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles source map generation and management for debugging and error reporting.

This file performs the following tasks:
- Generate source maps for compiled code to enable debugging with memory-efficient operations
- Map compiled code positions back to original source locations with arena-based temporary analysis
- Handle source map encoding and decoding for debugging tools with ownership-aware operations
- Provide source location tracking for error reporting with deterministic memory management

This file is essential because of the following reasons:
- Source maps enable debugging of compiled Runa code
- Source location mapping improves error reporting accuracy
- Source map support is essential for modern development tools integration
- Memory-efficient source mapping enables scalable debugging support

This file consists of the following functions/features/operation types:
- Source map generation and encoding with ownership patterns
- Source location mapping and tracking with arena-based operations
- Source map decoding and debugging support with memory safety
- Source location utilities for error reporting with deterministic cleanup
:End Note

Import "errors.runa"
Import "memory/layout.runa"
Import "collections/list.runa"
Import "collections/hashtable.runa"
Import "core/string_core.runa"
Import "core/memory_core.runa"

Constant SOURCE_MAP_VERSION_3 as Integer is 3
Constant SOURCE_MAP_VERSION_2 as Integer is 2
Constant SOURCE_MAP_VERSION_1 as Integer is 1

Constant MAPPING_TYPE_EXACT as Integer is 1
Constant MAPPING_TYPE_APPROXIMATE as Integer is 2
Constant MAPPING_TYPE_INFERRED as Integer is 3
Constant MAPPING_TYPE_GENERATED as Integer is 4

Constant SOURCE_MAP_FORMAT_JSON as Integer is 1
Constant SOURCE_MAP_FORMAT_BINARY as Integer is 2
Constant SOURCE_MAP_FORMAT_TEXT as Integer is 3

Type called "SourceLocation":
    line_number as Integer           Note: STACK - source line number
    column_number as Integer        Note: STACK - source column number
    file_path as String             Note: OWNED - source file path
    function_name as String         Note: OWNED - function name
    scope_level as Integer          Note: STACK - scope nesting level
    is_generated as Integer         Note: STACK - generated code flag
    confidence as Integer            Note: STACK - mapping confidence level
End Type

Type called "CompiledLocation":
    line_number as Integer           Note: STACK - compiled line number
    column_number as Integer        Note: STACK - compiled column number
    instruction_offset as Integer   Note: STACK - instruction offset
    function_offset as Integer      Note: STACK - function offset
    is_optimized as Integer         Note: STACK - optimization flag
    optimization_level as Integer   Note: STACK - optimization level
End Type

Type called "SourceMapping":
    mapping_id as Integer           Note: STACK - unique mapping identifier
    source_location as Integer      Note: OWNED - source location reference
    compiled_location as Integer    Note: OWNED - compiled location reference
    mapping_type as Integer         Note: STACK - mapping type constant
    confidence as Integer           Note: STACK - mapping confidence
    is_reliable as Integer          Note: STACK - reliability flag
    context_info as Integer         Note: OWNED - additional context
End Type

Type called "SourceMap":
    version as Integer              Note: STACK - source map version
    file_path as String            Note: OWNED - source file path
    generated_file as String        Note: OWNED - generated file path
    mappings as Integer            Note: OWNED - mapping list
    sources as Integer              Note: OWNED - source file list
    names as Integer                Note: OWNED - name list
    sources_content as Integer      Note: OWNED - source content list
    format as Integer               Note: STACK - source map format
    encoding as Integer             Note: STACK - encoding type
    is_optimized as Integer         Note: STACK - optimization flag
    total_mappings as Integer       Note: STACK - total mapping count
    reliable_mappings as Integer    Note: STACK - reliable mapping count
End Type

Type called "SourceMapGenerator":
    source_map as Integer           Note: OWNED - source map being generated
    mapping_cache as Integer        Note: OWNED - mapping cache
    source_registry as Integer      Note: OWNED - source file registry
    name_registry as Integer        Note: OWNED - name registry
    arena as Integer                Note: OWNED - arena for temporary operations
    current_source as String        Note: OWNED - current source file
    current_line as Integer         Note: STACK - current line number
    current_column as Integer       Note: STACK - current column number
    mapping_count as Integer        Note: STACK - total mapping count
    optimization_level as Integer   Note: STACK - optimization level
    debug_mode as Integer           Note: STACK - debug mode flag
    error_handler as Integer        Note: OWNED - error reporting system
    debug_logger as Integer         Note: OWNED - debug logging system
End Type

Process called "source_map_create" takes source_file as String, generated_file as String, arena as Integer returns Integer:
    Note:
    Creates a new source map with proper memory management.

    Parameters:
    - source_file: Source file path
    - generated_file: Generated file path
    - arena: Arena for temporary source map operations (ARENA)

    Returns:
    - Integer: Pointer to OWNED SourceMap structure

    Side Effects:
    - Allocates OWNED SourceMap structure
    - Uses ARENA for temporary source map operations
    - Initializes source map components

    Algorithm:
    1. Use ARENA for temporary source map operations
    2. Allocate OWNED SourceMap structure (96 bytes: 12 fields × 8)
    3. Set source and generated file paths
    4. Initialize mapping list
    5. Initialize source file list
    6. Initialize name list
    7. Set source map version and format
    8. ARENA data freed automatically
    :End Note

    Note: Import memory and list utilities
    Import "core/memory_core.runa" as Memory
    Import "collections/list.runa" as List

    Note: Allocate OWNED SourceMap structure (12 fields × 8 bytes = 96 bytes)
    Let source_map be proc memory_allocate from Memory with 96

    If source_map is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Create OWNED mapping list
    Let mappings be proc list_create from List with arena
    If mappings is equal to 0:
        proc memory_free from Memory with source_map
        Return 0  Note: List creation failed
    End If

    Note: Create OWNED source file list
    Let sources be proc list_create from List with arena
    If sources is equal to 0:
        proc list_destroy from List with mappings
        proc memory_free from Memory with source_map
        Return 0  Note: List creation failed
    End If

    Note: Create OWNED name list
    Let names be proc list_create from List with arena
    If names is equal to 0:
        proc list_destroy from List with sources
        proc list_destroy from List with mappings
        proc memory_free from Memory with source_map
        Return 0  Note: List creation failed
    End If

    Note: Create OWNED source content list
    Let sources_content be proc list_create from List with arena
    If sources_content is equal to 0:
        proc list_destroy from List with names
        proc list_destroy from List with sources
        proc list_destroy from List with mappings
        proc memory_free from Memory with source_map
        Return 0  Note: List creation failed
    End If

    Note: Initialize SourceMap fields (offsets: version=0, file_path=8, generated_file=16, mappings=24, sources=32, names=40, sources_content=48, format=56, encoding=64, is_optimized=72, total_mappings=80, reliable_mappings=88)
    proc memory_set_qword from Memory with source_map, 0, SOURCE_MAP_VERSION_3     Note: version (using latest v3)
    proc memory_set_qword from Memory with source_map, 8, source_file               Note: file_path
    proc memory_set_qword from Memory with source_map, 16, generated_file           Note: generated_file
    proc memory_set_qword from Memory with source_map, 24, mappings                 Note: mappings list
    proc memory_set_qword from Memory with source_map, 32, sources                  Note: sources list
    proc memory_set_qword from Memory with source_map, 40, names                    Note: names list
    proc memory_set_qword from Memory with source_map, 48, sources_content          Note: sources_content list
    proc memory_set_qword from Memory with source_map, 56, SOURCE_MAP_FORMAT_JSON   Note: format (default JSON)
    proc memory_set_qword from Memory with source_map, 64, 1                        Note: encoding (1 = UTF-8)
    proc memory_set_qword from Memory with source_map, 72, 0                        Note: is_optimized (false initially)
    proc memory_set_qword from Memory with source_map, 80, 0                        Note: total_mappings (zero initially)
    proc memory_set_qword from Memory with source_map, 88, 0                        Note: reliable_mappings (zero initially)

    Note: Add source file to sources list
    proc list_add from List with sources, source_file, arena

    Return source_map
End Process

Process called "source_map_destroy" takes source_map as Integer returns Nothing:
    Note:
    Destroys source map and frees all owned memory.

    Parameters:
    - source_map: OWNED SourceMap to destroy

    Side Effects:
    - Frees all OWNED source map data
    - Destroys OWNED mapping list
    - Destroys OWNED source file list
    - Frees OWNED SourceMap structure

    Algorithm:
    1. Free OWNED source file path
    2. Free OWNED generated file path
    3. Destroy OWNED mapping list
    4. Destroy OWNED source file list
    5. Destroy OWNED name list
    6. Destroy OWNED source content list
    7. Free OWNED SourceMap structure
    :End Note

    Note: Import memory and list utilities
    Import "core/memory_core.runa" as Memory
    Import "collections/list.runa" as List

    If source_map is equal to 0:
        Return  Note: Nothing to destroy
    End If

    Note: Get OWNED pointers from SourceMap (offsets: file_path=8, generated_file=16, mappings=24, sources=32, names=40, sources_content=48)
    Let file_path be proc memory_get_qword from Memory with source_map, 8
    Let generated_file be proc memory_get_qword from Memory with source_map, 16
    Let mappings be proc memory_get_qword from Memory with source_map, 24
    Let sources be proc memory_get_qword from Memory with source_map, 32
    Let names be proc memory_get_qword from Memory with source_map, 40
    Let sources_content be proc memory_get_qword from Memory with source_map, 48

    Note: Free OWNED file_path if exists
    If file_path is not equal to 0:
        proc memory_free from Memory with file_path
    End If

    Note: Free OWNED generated_file if exists
    If generated_file is not equal to 0:
        proc memory_free from Memory with generated_file
    End If

    Note: Destroy OWNED mappings list if exists
    If mappings is not equal to 0:
        proc list_destroy from List with mappings
    End If

    Note: Destroy OWNED sources list if exists
    If sources is not equal to 0:
        proc list_destroy from List with sources
    End If

    Note: Destroy OWNED names list if exists
    If names is not equal to 0:
        proc list_destroy from List with names
    End If

    Note: Destroy OWNED sources_content list if exists
    If sources_content is not equal to 0:
        proc list_destroy from List with sources_content
    End If

    Note: Free OWNED SourceMap structure
    proc memory_free from Memory with source_map
End Process

Process called "source_map_add_mapping" takes source_map as Integer, source_line as Integer, source_column as Integer, compiled_line as Integer, compiled_column as Integer, arena as Integer returns Integer:
    Note:
    Adds a source mapping to the source map using arena-based operations.

    Parameters:
    - source_map: OWNED SourceMap reference
    - source_line: Source line number (STACK)
    - source_column: Source column number (STACK)
    - compiled_line: Compiled line number (STACK)
    - compiled_column: Compiled column number (STACK)
    - arena: Arena for temporary mapping operations (ARENA)

    Returns:
    - Integer: Mapping ID (STACK)

    Side Effects:
    - Uses ARENA for temporary mapping operations
    - Creates OWNED SourceMapping
    - Adds to OWNED mapping list

    Algorithm:
    1. Use ARENA for temporary mapping operations
    2. Create OWNED SourceLocation
    3. Create OWNED CompiledLocation
    4. Create OWNED SourceMapping
    5. Add to OWNED mapping list
    6. Update mapping count
    7. ARENA data freed automatically
    :End Note

    Note: Import memory and list utilities
    Import "core/memory_core.runa" as Memory
    Import "collections/list.runa" as List

    Note: Create OWNED SourceLocation structure (7 fields × 8 bytes = 56 bytes)
    Let source_location be proc memory_allocate from Memory with 56
    If source_location is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Initialize SourceLocation fields (offsets: line_number=0, column_number=8, file_path=16, function_name=24, scope_level=32, is_generated=40, confidence=48)
    proc memory_set_qword from Memory with source_location, 0, source_line    Note: line_number
    proc memory_set_qword from Memory with source_location, 8, source_column  Note: column_number
    proc memory_set_qword from Memory with source_location, 16, 0             Note: file_path (from source_map)
    proc memory_set_qword from Memory with source_location, 24, 0             Note: function_name (null initially)
    proc memory_set_qword from Memory with source_location, 32, 0             Note: scope_level (0 = global)
    proc memory_set_qword from Memory with source_location, 40, 0             Note: is_generated (false)
    proc memory_set_qword from Memory with source_location, 48, 100           Note: confidence (100%)

    Note: Create OWNED CompiledLocation structure (6 fields × 8 bytes = 48 bytes)
    Let compiled_location be proc memory_allocate from Memory with 48
    If compiled_location is equal to 0:
        proc memory_free from Memory with source_location
        Return 0  Note: Allocation failed
    End If

    Note: Initialize CompiledLocation fields (offsets: line_number=0, column_number=8, instruction_offset=16, function_offset=24, is_optimized=32, optimization_level=40)
    proc memory_set_qword from Memory with compiled_location, 0, compiled_line      Note: line_number
    proc memory_set_qword from Memory with compiled_location, 8, compiled_column    Note: column_number
    proc memory_set_qword from Memory with compiled_location, 16, 0                 Note: instruction_offset (unknown)
    proc memory_set_qword from Memory with compiled_location, 24, 0                 Note: function_offset (unknown)
    proc memory_set_qword from Memory with compiled_location, 32, 0                 Note: is_optimized (false)
    proc memory_set_qword from Memory with compiled_location, 40, 0                 Note: optimization_level (none)

    Note: Create OWNED SourceMapping structure (7 fields × 8 bytes = 56 bytes)
    Let source_mapping be proc memory_allocate from Memory with 56
    If source_mapping is equal to 0:
        proc memory_free from Memory with compiled_location
        proc memory_free from Memory with source_location
        Return 0  Note: Allocation failed
    End If

    Note: Get current total_mappings to use as mapping_id (offset 80)
    Let mapping_id be proc memory_get_qword from Memory with source_map, 80

    Note: Initialize SourceMapping fields (offsets: mapping_id=0, source_location=8, compiled_location=16, mapping_type=24, confidence=32, is_reliable=40, context_info=48)
    proc memory_set_qword from Memory with source_mapping, 0, mapping_id           Note: mapping_id
    proc memory_set_qword from Memory with source_mapping, 8, source_location      Note: source_location pointer
    proc memory_set_qword from Memory with source_mapping, 16, compiled_location   Note: compiled_location pointer
    proc memory_set_qword from Memory with source_mapping, 24, MAPPING_TYPE_EXACT  Note: mapping_type (exact)
    proc memory_set_qword from Memory with source_mapping, 32, 100                 Note: confidence (100%)
    proc memory_set_qword from Memory with source_mapping, 40, 1                   Note: is_reliable (true)
    proc memory_set_qword from Memory with source_mapping, 48, 0                   Note: context_info (null)

    Note: Get mappings list from source_map (offset 24)
    Let mappings be proc memory_get_qword from Memory with source_map, 24

    Note: Add mapping to OWNED mappings list
    proc list_add from List with mappings, source_mapping, arena

    Note: Increment total_mappings count (offset 80)
    Set mapping_id to mapping_id plus 1
    proc memory_set_qword from Memory with source_map, 80, mapping_id

    Note: Return the mapping_id of the mapping we just added (before increment)
    Let result_id be mapping_id minus 1
    Return result_id
End Process

Process called "source_map_lookup_source" takes source_map as Integer, compiled_line as Integer, compiled_column as Integer, arena as Integer returns Integer:
    Note:
    Looks up source location for compiled location using arena-based operations.

    Parameters:
    - source_map: OWNED SourceMap reference
    - compiled_line: Compiled line number (STACK)
    - compiled_column: Compiled column number (STACK)
    - arena: Arena for temporary lookup operations (ARENA)

    Returns:
    - Integer: OWNED SourceLocation or 0 if not found

    Side Effects:
    - Uses ARENA for temporary lookup operations
    - Creates OWNED SourceLocation if found

    Algorithm:
    1. Use ARENA for temporary lookup operations
    2. Search mapping list for compiled location
    3. Find best matching mapping (exact or closest)
    4. Create OWNED SourceLocation copy
    5. ARENA data freed automatically
    :End Note

    Note: Import memory and list utilities
    Import "core/memory_core.runa" as Memory
    Import "collections/list.runa" as List

    Note: Get mappings list from source_map (offset 24)
    Let mappings be proc memory_get_qword from Memory with source_map, 24
    If mappings is equal to 0:
        Return 0  Note: No mappings
    End If

    Note: Get mapping count from list
    Let mapping_count be proc list_size from List with mappings
    If mapping_count is equal to 0:
        Return 0  Note: Empty mappings list
    End If

    Note: Linear search for exact or closest match
    Let best_match be 0
    Let best_distance be 999999999  Note: Large initial distance
    Let index be 0

    While index is less than mapping_count:
        Note: Get mapping at index
        Let mapping be proc list_get from List with mappings, index

        If mapping is not equal to 0:
            Note: Get compiled_location from mapping (offset 16)
            Let compiled_loc be proc memory_get_qword from Memory with mapping, 16

            If compiled_loc is not equal to 0:
                Note: Get line and column from compiled_location (offsets 0, 8)
                Let map_line be proc memory_get_qword from Memory with compiled_loc, 0
                Let map_column be proc memory_get_qword from Memory with compiled_loc, 8

                Note: Calculate distance (Manhattan distance)
                Let line_diff be map_line minus compiled_line
                If line_diff is less than 0:
                    Set line_diff to 0 minus line_diff  Note: Absolute value
                End If

                Let col_diff be map_column minus compiled_column
                If col_diff is less than 0:
                    Set col_diff to 0 minus col_diff  Note: Absolute value
                End If

                Let distance be line_diff plus col_diff

                Note: Check for exact match first
                If distance is equal to 0:
                    Set best_match to mapping
                    Set best_distance to 0
                    Set index to mapping_count  Note: Exit loop early
                Otherwise:
                    Note: Track closest match
                    If distance is less than best_distance:
                        Set best_match to mapping
                        Set best_distance to distance
                    End If
                End If
            End If
        End If

        Set index to index plus 1
    End While

    Note: Return source_location from best match if found
    If best_match is not equal to 0:
        Note: Get source_location from mapping (offset 8)
        Let source_loc be proc memory_get_qword from Memory with best_match, 8

        Note: Create OWNED copy of SourceLocation (56 bytes)
        Let result_loc be proc memory_allocate from Memory with 56
        If result_loc is equal to 0:
            Return 0  Note: Allocation failed
        End If

        Note: Copy all 7 fields (7 × 8 = 56 bytes)
        Let field_index be 0
        While field_index is less than 56:
            Let field_value be proc memory_get_qword from Memory with source_loc, field_index
            proc memory_set_qword from Memory with result_loc, field_index, field_value
            Set field_index to field_index plus 8
        End While

        Return result_loc
    End If

    Return 0  Note: No match found
End Process

Process called "source_map_lookup_compiled" takes source_map as Integer, source_line as Integer, source_column as Integer, arena as Integer returns Integer:
    Note:
    Looks up compiled location for source location using arena-based operations.

    Parameters:
    - source_map: OWNED SourceMap reference
    - source_line: Source line number (STACK)
    - source_column: Source column number (STACK)
    - arena: Arena for temporary lookup operations (ARENA)

    Returns:
    - Integer: OWNED CompiledLocation or 0 if not found

    Side Effects:
    - Uses ARENA for temporary lookup operations
    - Creates OWNED CompiledLocation if found

    Algorithm:
    1. Use ARENA for temporary lookup operations
    2. Search mapping list for source location
    3. Find best matching mapping (exact or closest)
    4. Create OWNED CompiledLocation copy
    5. ARENA data freed automatically
    :End Note

    Note: Import memory and list utilities
    Import "core/memory_core.runa" as Memory
    Import "collections/list.runa" as List

    Note: Get mappings list from source_map (offset 24)
    Let mappings be proc memory_get_qword from Memory with source_map, 24
    If mappings is equal to 0:
        Return 0  Note: No mappings
    End If

    Note: Get mapping count from list
    Let mapping_count be proc list_size from List with mappings
    If mapping_count is equal to 0:
        Return 0  Note: Empty mappings list
    End If

    Note: Linear search for exact or closest match
    Let best_match be 0
    Let best_distance be 999999999  Note: Large initial distance
    Let index be 0

    While index is less than mapping_count:
        Note: Get mapping at index
        Let mapping be proc list_get from List with mappings, index

        If mapping is not equal to 0:
            Note: Get source_location from mapping (offset 8)
            Let source_loc be proc memory_get_qword from Memory with mapping, 8

            If source_loc is not equal to 0:
                Note: Get line and column from source_location (offsets 0, 8)
                Let map_line be proc memory_get_qword from Memory with source_loc, 0
                Let map_column be proc memory_get_qword from Memory with source_loc, 8

                Note: Calculate distance (Manhattan distance)
                Let line_diff be map_line minus source_line
                If line_diff is less than 0:
                    Set line_diff to 0 minus line_diff  Note: Absolute value
                End If

                Let col_diff be map_column minus source_column
                If col_diff is less than 0:
                    Set col_diff to 0 minus col_diff  Note: Absolute value
                End If

                Let distance be line_diff plus col_diff

                Note: Check for exact match first
                If distance is equal to 0:
                    Set best_match to mapping
                    Set best_distance to 0
                    Set index to mapping_count  Note: Exit loop early
                Otherwise:
                    Note: Track closest match
                    If distance is less than best_distance:
                        Set best_match to mapping
                        Set best_distance to distance
                    End If
                End If
            End If
        End If

        Set index to index plus 1
    End While

    Note: Return compiled_location from best match if found
    If best_match is not equal to 0:
        Note: Get compiled_location from mapping (offset 16)
        Let compiled_loc be proc memory_get_qword from Memory with best_match, 16

        Note: Create OWNED copy of CompiledLocation (48 bytes)
        Let result_loc be proc memory_allocate from Memory with 48
        If result_loc is equal to 0:
            Return 0  Note: Allocation failed
        End If

        Note: Copy all 6 fields (6 × 8 = 48 bytes)
        Let field_index be 0
        While field_index is less than 48:
            Let field_value be proc memory_get_qword from Memory with compiled_loc, field_index
            proc memory_set_qword from Memory with result_loc, field_index, field_value
            Set field_index to field_index plus 8
        End While

        Return result_loc
    End If

    Return 0  Note: No match found
End Process

Process called "source_map_encode" takes source_map as Integer, format as Integer, arena as Integer returns Integer:
    Note:
    Encodes source map to specified format using arena-based operations.

    Parameters:
    - source_map: OWNED SourceMap reference
    - format: Encoding format (STACK)
    - arena: Arena for temporary encoding operations (ARENA)

    Returns:
    - Integer: ARENA pointer to encoded source map string

    Side Effects:
    - Uses ARENA for temporary encoding operations
    - No permanent memory allocation

    Algorithm:
    1. Use ARENA for temporary encoding operations
    2. Switch on encoding format
    3. Encode source map data to format
    4. Return ARENA pointer to encoded data
    5. ARENA data freed automatically
    :End Note

    Note: Import memory and string utilities
    Import "core/memory_core.runa" as Memory
    Import "core/string_core.runa" as StringCore
    Import "memory/arena.runa" as Arena

    Note: Handle different encoding formats
    If format is equal to SOURCE_MAP_FORMAT_JSON:
        Note: Get SourceMap fields
        Let version be proc memory_get_qword from Memory with source_map, 0
        Let file_path be proc memory_get_qword from Memory with source_map, 8
        Let generated_file be proc memory_get_qword from Memory with source_map, 16
        Let total_mappings be proc memory_get_qword from Memory with source_map, 80

        Note: Build JSON string in arena (basic metadata without VLQ-encoded mappings)
        Note: Full format: {"version":3,"sources":["file"],"file":"output","mappings":""}
        Let json_start be proc string_create from StringCore with "{\"version\":", arena
        Let version_str be proc string_from_int from StringCore with version, arena
        Let json_v be proc string_concat from StringCore with json_start, version_str, arena

        Let json_sources be proc string_concat from StringCore with json_v, ",\"sources\":[\"", arena
        Let json_sf be proc string_concat from StringCore with json_sources, file_path, arena
        Let json_src be proc string_concat from StringCore with json_sf, "\"]", arena

        Let json_file be proc string_concat from StringCore with json_src, ",\"file\":\"", arena
        Let json_gf be proc string_concat from StringCore with json_file, generated_file, arena
        Let json_gen be proc string_concat from StringCore with json_gf, "\"", arena

        Note: Mappings field is empty (VLQ encoding would require full mapping data)
        Let json_map be proc string_concat from StringCore with json_gen, ",\"mappings\":\"\"", arena
        Let json_final be proc string_concat from StringCore with json_map, "}", arena

        Return json_final

    Otherwise If format is equal to SOURCE_MAP_FORMAT_BINARY:
        Note: Binary format: version (8) + mapping_count (8) + mapping data
        Let binary_size be 16  Note: Header: version + count
        Let binary_data be proc arena_allocate from Arena with arena, binary_size

        If binary_data is equal to 0:
            Return 0  Note: Allocation failed
        End If

        Note: Write version and mapping count
        Let version be proc memory_get_qword from Memory with source_map, 0
        Let total_mappings be proc memory_get_qword from Memory with source_map, 80
        proc memory_set_qword from Memory with binary_data, 0, version
        proc memory_set_qword from Memory with binary_data, 8, total_mappings

        Return binary_data

    Otherwise If format is equal to SOURCE_MAP_FORMAT_TEXT:
        Note: Text format: simple line-by-line mapping representation
        Let total_mappings be proc memory_get_qword from Memory with source_map, 80
        Let count_str be proc string_from_int from StringCore with total_mappings, arena
        Let text_header be proc string_create from StringCore with "SourceMap Mappings: ", arena
        Let text_result be proc string_concat from StringCore with text_header, count_str, arena

        Return text_result

    Otherwise:
        Note: Unknown format, return empty string
        Return proc string_create from StringCore with "", arena
    End If
End Process

Process called "source_map_decode" takes encoded_data as Integer, format as Integer, arena as Integer returns Integer:
    Note:
    Decodes source map from specified format using arena-based operations.

    Parameters:
    - encoded_data: Encoded source map data
    - format: Decoding format (STACK)
    - arena: Arena for temporary decoding operations (ARENA)

    Returns:
    - Integer: OWNED SourceMap or 0 on failure

    Side Effects:
    - Uses ARENA for temporary decoding operations
    - Creates OWNED SourceMap if successful

    Algorithm:
    1. Use ARENA for temporary decoding operations
    2. Switch on decoding format
    3. Decode source map data
    4. Create OWNED SourceMap
    5. ARENA data freed automatically
    :End Note

    Note: Import memory utilities
    Import "core/memory_core.runa" as Memory
    Import "core/string_core.runa" as StringCore

    If encoded_data is equal to 0:
        Return 0  Note: Invalid input
    End If

    Note: Handle different decoding formats
    If format is equal to SOURCE_MAP_FORMAT_JSON:
        Note: JSON decoding - parse source map fields from JSON string
        Note: Expected format: {"version":N,"sources":["path"],"file":"output","mappings":""}

        Note: Find version field
        Let version_pos be proc string_find from StringCore with encoded_data, "\"version\":"
        Let sources_pos be proc string_find from StringCore with encoded_data, "\"sources\":[\""
        Let file_pos be proc string_find from StringCore with encoded_data, "\"file\":\""

        Note: If JSON is malformed, return null
        If version_pos is equal to 0:
            Return 0  Note: Invalid JSON - missing version
        End If

        Note: Parse version number (skip past "version":)
        Let version_value_pos be version_pos plus 10
        Let version be proc string_parse_int from StringCore with encoded_data, version_value_pos

        Note: Extract source file path if present
        Let source_file be proc string_create from StringCore with "", arena
        If sources_pos is not equal to 0:
            Let source_start be sources_pos plus 12  Note: Skip "sources":["
            Let source_end be proc string_find from StringCore with encoded_data, "\"]"
            If source_end is greater than source_start:
                Set source_file to proc string_substring from StringCore with encoded_data, source_start, source_end, arena
            End If
        End If

        Note: Extract generated file path if present
        Let generated_file be proc string_create from StringCore with "", arena
        If file_pos is not equal to 0:
            Let file_start be file_pos plus 8  Note: Skip "file":"
            Let file_end be proc string_find from StringCore with encoded_data, "\""
            If file_end is greater than file_start:
                Set generated_file to proc string_substring from StringCore with encoded_data, file_start, file_end, arena
            End If
        End If

        Note: Create source map with parsed data
        Let source_map be proc source_map_create with source_file, generated_file, arena

        Note: Set version if creation succeeded
        If source_map is not equal to 0:
            proc memory_set_qword from Memory with source_map, 0, version
        End If

        Return source_map

    Otherwise If format is equal to SOURCE_MAP_FORMAT_BINARY:
        Note: Binary decoding: read version and count
        Let version be proc memory_get_qword from Memory with encoded_data, 0
        Let mapping_count be proc memory_get_qword from Memory with encoded_data, 8

        Note: Create source map with decoded info
        Let empty_string be proc string_create from StringCore with "", arena
        Let source_map be proc source_map_create with empty_string, empty_string, arena

        If source_map is not equal to 0:
            Note: Set version from decoded data
            proc memory_set_qword from Memory with source_map, 0, version
        End If

        Return source_map

    Otherwise If format is equal to SOURCE_MAP_FORMAT_TEXT:
        Note: Text decoding: create empty source map
        Let empty_string be proc string_create from StringCore with "", arena
        Return proc source_map_create with empty_string, empty_string, arena

    Otherwise:
        Note: Unknown format
        Return 0
    End If
End Process

Process called "source_map_generator_create" takes arena as Integer returns Integer:
    Note:
    Creates a new source map generator with proper memory management.

    Parameters:
    - arena: Arena for temporary generator operations (ARENA)

    Returns:
    - Integer: Pointer to OWNED SourceMapGenerator structure

    Side Effects:
    - Allocates OWNED SourceMapGenerator structure
    - Uses ARENA for temporary generator operations
    - Initializes generator components

    Algorithm:
    1. Use ARENA for temporary generator operations
    2. Allocate OWNED SourceMapGenerator structure (13 fields × 8 = 104 bytes)
    3. Initialize OWNED source map
    4. Initialize OWNED mapping cache
    5. Initialize OWNED source registry
    6. Initialize OWNED name registry
    7. Set up OWNED error handling
    8. ARENA data freed automatically
    :End Note

    Note: Import memory, hashtable, and string utilities
    Import "core/memory_core.runa" as Memory
    Import "collections/hashtable.runa" as Hashtable
    Import "core/string_core.runa" as StringCore

    Note: Allocate OWNED SourceMapGenerator structure (13 fields × 8 = 104 bytes)
    Let generator be proc memory_allocate from Memory with 104

    If generator is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Create empty source map for generator
    Let empty_string be proc string_create from StringCore with "", arena
    Let source_map be proc source_map_create with empty_string, empty_string, arena
    If source_map is equal to 0:
        proc memory_free from Memory with generator
        Return 0  Note: Source map creation failed
    End If

    Note: Create OWNED mapping cache (hashtable for fast lookups)
    Let mapping_cache be proc hashtable_create from Hashtable with 256, arena
    If mapping_cache is equal to 0:
        proc source_map_destroy with source_map
        proc memory_free from Memory with generator
        Return 0  Note: Cache creation failed
    End If

    Note: Create OWNED source registry (hashtable)
    Let source_registry be proc hashtable_create from Hashtable with 64, arena
    If source_registry is equal to 0:
        proc hashtable_destroy from Hashtable with mapping_cache
        proc source_map_destroy with source_map
        proc memory_free from Memory with generator
        Return 0  Note: Registry creation failed
    End If

    Note: Create OWNED name registry (hashtable)
    Let name_registry be proc hashtable_create from Hashtable with 128, arena
    If name_registry is equal to 0:
        proc hashtable_destroy from Hashtable with source_registry
        proc hashtable_destroy from Hashtable with mapping_cache
        proc source_map_destroy with source_map
        proc memory_free from Memory with generator
        Return 0  Note: Registry creation failed
    End If

    Note: Initialize SourceMapGenerator fields (offsets: source_map=0, mapping_cache=8, source_registry=16, name_registry=24, arena=32, current_source=40, current_line=48, current_column=56, mapping_count=64, optimization_level=72, debug_mode=80, error_handler=88, debug_logger=96)
    proc memory_set_qword from Memory with generator, 0, source_map          Note: source_map
    proc memory_set_qword from Memory with generator, 8, mapping_cache       Note: mapping_cache
    proc memory_set_qword from Memory with generator, 16, source_registry    Note: source_registry
    proc memory_set_qword from Memory with generator, 24, name_registry      Note: name_registry
    proc memory_set_qword from Memory with generator, 32, arena              Note: arena
    proc memory_set_qword from Memory with generator, 40, empty_string       Note: current_source
    proc memory_set_qword from Memory with generator, 48, 0                  Note: current_line
    proc memory_set_qword from Memory with generator, 56, 0                  Note: current_column
    proc memory_set_qword from Memory with generator, 64, 0                  Note: mapping_count
    proc memory_set_qword from Memory with generator, 72, 0                  Note: optimization_level
    proc memory_set_qword from Memory with generator, 80, 0                  Note: debug_mode (false)
    proc memory_set_qword from Memory with generator, 88, 0                  Note: error_handler (null)
    proc memory_set_qword from Memory with generator, 96, 0                  Note: debug_logger (null)

    Return generator
End Process

Process called "source_map_generator_destroy" takes generator as Integer returns Nothing:
    Note:
    Destroys source map generator and frees all owned memory.

    Parameters:
    - generator: OWNED SourceMapGenerator to destroy

    Side Effects:
    - Frees all OWNED generator data
    - Destroys OWNED source map
    - Destroys OWNED mapping cache
    - Frees OWNED SourceMapGenerator structure

    Algorithm:
    1. Destroy OWNED source map
    2. Destroy OWNED mapping cache
    3. Destroy OWNED source registry
    4. Destroy OWNED name registry
    5. Free OWNED current source file
    6. Free OWNED SourceMapGenerator structure
    :End Note

    Note: Import memory and hashtable utilities
    Import "core/memory_core.runa" as Memory
    Import "collections/hashtable.runa" as Hashtable

    If generator is equal to 0:
        Return  Note: Nothing to destroy
    End If

    Note: Get OWNED pointers from generator (offsets: source_map=0, mapping_cache=8, source_registry=16, name_registry=24, current_source=40)
    Let source_map be proc memory_get_qword from Memory with generator, 0
    Let mapping_cache be proc memory_get_qword from Memory with generator, 8
    Let source_registry be proc memory_get_qword from Memory with generator, 16
    Let name_registry be proc memory_get_qword from Memory with generator, 24
    Let current_source be proc memory_get_qword from Memory with generator, 40

    Note: Destroy OWNED source_map if exists
    If source_map is not equal to 0:
        proc source_map_destroy with source_map
    End If

    Note: Destroy OWNED mapping_cache if exists
    If mapping_cache is not equal to 0:
        proc hashtable_destroy from Hashtable with mapping_cache
    End If

    Note: Destroy OWNED source_registry if exists
    If source_registry is not equal to 0:
        proc hashtable_destroy from Hashtable with source_registry
    End If

    Note: Destroy OWNED name_registry if exists
    If name_registry is not equal to 0:
        proc hashtable_destroy from Hashtable with name_registry
    End If

    Note: Free OWNED current_source if exists
    If current_source is not equal to 0:
        proc memory_free from Memory with current_source
    End If

    Note: Free OWNED SourceMapGenerator structure
    proc memory_free from Memory with generator
End Process

Process called "source_map_generator_add_source" takes generator as Integer, source_file as String, arena as Integer returns Integer:
    Note:
    Adds a source file to the generator using arena-based operations.

    Parameters:
    - generator: OWNED SourceMapGenerator reference
    - source_file: Source file path
    - arena: Arena for temporary source operations (ARENA)

    Returns:
    - Integer: Source ID (STACK)

    Side Effects:
    - Uses ARENA for temporary source operations
    - Adds source to OWNED source registry
    - Updates source map

    Algorithm:
    1. Use ARENA for temporary source operations
    2. Add source to OWNED source registry
    3. Update source map sources list
    4. Return source ID
    5. ARENA data freed automatically
    :End Note

    Note: Import memory, hashtable, and list utilities
    Import "core/memory_core.runa" as Memory
    Import "collections/hashtable.runa" as Hashtable
    Import "collections/list.runa" as List

    Note: Get source_registry from generator (offset 16)
    Let source_registry be proc memory_get_qword from Memory with generator, 16

    Note: Generate source_id from registry size
    Let source_id be proc hashtable_size from Hashtable with source_registry

    Note: Add source to registry (key=source_id, value=source_file)
    proc hashtable_insert from Hashtable with source_registry, source_id, source_file, arena

    Note: Get source_map from generator (offset 0) and add to sources list
    Let source_map be proc memory_get_qword from Memory with generator, 0
    Let sources be proc memory_get_qword from Memory with source_map, 32
    proc list_add from List with sources, source_file, arena

    Note: Update current_source (offset 40)
    proc memory_set_qword from Memory with generator, 40, source_file

    Return source_id
End Process

Process called "source_map_generator_add_mapping" takes generator as Integer, source_line as Integer, source_column as Integer, compiled_line as Integer, compiled_column as Integer, arena as Integer returns Integer:
    Note:
    Adds a mapping to the generator using arena-based operations.

    Parameters:
    - generator: OWNED SourceMapGenerator reference
    - source_line: Source line number (STACK)
    - source_column: Source column number (STACK)
    - compiled_line: Compiled line number (STACK)
    - compiled_column: Compiled column number (STACK)
    - arena: Arena for temporary mapping operations (ARENA)

    Returns:
    - Integer: Mapping ID (STACK)

    Side Effects:
    - Uses ARENA for temporary mapping operations
    - Creates OWNED mapping
    - Adds to OWNED mapping cache

    Algorithm:
    1. Use ARENA for temporary mapping operations
    2. Create OWNED SourceMapping via source_map_add_mapping
    3. Add to OWNED mapping cache for fast lookup
    4. Update mapping count
    5. ARENA data freed automatically
    :End Note

    Note: Import memory utilities
    Import "core/memory_core.runa" as Memory

    Note: Get source_map from generator (offset 0)
    Let source_map be proc memory_get_qword from Memory with generator, 0

    Note: Add mapping to source map
    Let mapping_id be proc source_map_add_mapping with source_map, source_line, source_column, compiled_line, compiled_column, arena

    Note: Increment generator mapping_count (offset 64)
    Let mapping_count be proc memory_get_qword from Memory with generator, 64
    Set mapping_count to mapping_count plus 1
    proc memory_set_qword from Memory with generator, 64, mapping_count

    Return mapping_id
End Process

Process called "source_map_generator_finalize" takes generator as Integer, arena as Integer returns Integer:
    Note:
    Finalizes the source map generation using arena-based operations.

    Parameters:
    - generator: OWNED SourceMapGenerator reference
    - arena: Arena for temporary finalization operations (ARENA)

    Returns:
    - Integer: OWNED SourceMap or 0 on failure

    Side Effects:
    - Uses ARENA for temporary finalization operations
    - Returns OWNED SourceMap from generator
    - Generator should be destroyed after finalize

    Algorithm:
    1. Use ARENA for temporary finalization operations
    2. Get source_map from generator
    3. Return source_map (ownership transferred to caller)
    4. ARENA data freed automatically
    :End Note

    Note: Import memory utilities
    Import "core/memory_core.runa" as Memory

    Note: Get source_map from generator (offset 0)
    Let source_map be proc memory_get_qword from Memory with generator, 0

    Note: Transfer ownership: clear generator's source_map pointer
    proc memory_set_qword from Memory with generator, 0, 0

    Note: Return OWNED source_map (caller must destroy it)
    Return source_map
End Process

Process called "source_map_get_statistics" takes source_map as Integer, arena as Integer returns Integer:
    Note:
    Gets source map statistics using arena-based operations.

    Parameters:
    - source_map: OWNED SourceMap reference
    - arena: Arena for temporary statistics (ARENA)

    Returns:
    - Integer: ARENA pointer to statistics structure

    Side Effects:
    - Uses ARENA for temporary statistics
    - No permanent memory allocation

    Algorithm:
    1. Use ARENA to allocate statistics structure
    2. Count total mappings
    3. Count reliable mappings
    4. Count source files
    5. Calculate mapping density
    6. Return ARENA pointer to statistics
    7. ARENA data freed automatically
    :End Note

    Note: Import memory and arena utilities
    Import "core/memory_core.runa" as Memory
    Import "collections/list.runa" as List
    Import "memory/arena.runa" as Arena

    Note: Allocate statistics structure from arena (5 fields × 8 = 40 bytes)
    Let statistics be proc arena_allocate from Arena with arena, 40

    If statistics is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Get total_mappings from source_map (offset 80)
    Let total_mappings be proc memory_get_qword from Memory with source_map, 80

    Note: Get reliable_mappings from source_map (offset 88)
    Let reliable_mappings be proc memory_get_qword from Memory with source_map, 88

    Note: Get sources list and count
    Let sources be proc memory_get_qword from Memory with source_map, 32
    Let source_count be 0
    If sources is not equal to 0:
        Set source_count to proc list_size from List with sources
    End If

    Note: Calculate mapping density (mappings per source)
    Let mapping_density be 0
    If source_count is greater than 0:
        Set mapping_density to total_mappings divided by source_count
    End If

    Note: Initialize statistics fields (offsets: total_mappings=0, reliable_mappings=8, source_count=16, mapping_density=24, version=32)
    proc memory_set_qword from Memory with statistics, 0, total_mappings       Note: total_mappings
    proc memory_set_qword from Memory with statistics, 8, reliable_mappings    Note: reliable_mappings
    proc memory_set_qword from Memory with statistics, 16, source_count        Note: source_count
    proc memory_set_qword from Memory with statistics, 24, mapping_density     Note: mapping_density
    proc memory_set_qword from Memory with statistics, 32, SOURCE_MAP_VERSION_3  Note: version

    Return statistics
End Process