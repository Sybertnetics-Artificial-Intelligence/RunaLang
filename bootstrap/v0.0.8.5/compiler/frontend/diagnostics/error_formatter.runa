Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles error message formatting and presentation for user-friendly output.

This file performs the following tasks:
- Format error messages with proper syntax highlighting and context with memory-efficient operations
- Generate user-friendly error descriptions and suggestions with arena-based temporary analysis
- Handle error message localization and internationalization with ownership-aware operations
- Provide consistent error formatting across all compiler output with deterministic memory management

This file is essential because of the following reasons:
- Well-formatted error messages improve developer experience and productivity
- Consistent error formatting ensures professional compiler output
- User-friendly error descriptions help developers understand and fix issues
- Memory-efficient formatting enables scalable error reporting

This file consists of the following functions/features/operation types:
- Error message formatting and styling with ownership patterns
- Context-aware error description generation with arena-based operations
- Error message localization and internationalization with memory safety
- Output formatting and presentation utilities with deterministic cleanup
:End Note

Import "errors.runa"
Import "source_map.runa"
Import "suggestion_engine.runa"
Import "memory/layout.runa"
Import "collections/list.runa"
Import "core/string_core.runa"
Import "core/memory_core.runa"

Constant FORMAT_STYLE_COLORED as Integer is 1
Constant FORMAT_STYLE_PLAIN as Integer is 2
Constant FORMAT_STYLE_JSON as Integer is 3
Constant FORMAT_STYLE_XML as Integer is 4
Constant FORMAT_STYLE_HTML as Integer is 5

Constant OUTPUT_TARGET_CONSOLE as Integer is 1
Constant OUTPUT_TARGET_FILE as Integer is 2
Constant OUTPUT_TARGET_EDITOR as Integer is 3
Constant OUTPUT_TARGET_WEB as Integer is 4

Constant COLOR_RED as Integer is 1
Constant COLOR_YELLOW as Integer is 2
Constant COLOR_BLUE as Integer is 3
Constant COLOR_GREEN as Integer is 4
Constant COLOR_CYAN as Integer is 5
Constant COLOR_MAGENTA as Integer is 6
Constant COLOR_WHITE as Integer is 7
Constant COLOR_GRAY as Integer is 8

Constant LOCALE_ENGLISH as Integer is 1
Constant LOCALE_SPANISH as Integer is 2
Constant LOCALE_FRENCH as Integer is 3
Constant LOCALE_GERMAN as Integer is 4
Constant LOCALE_JAPANESE as Integer is 5

Type called "FormattedError":
    formatted_id as Integer         Note: STACK - unique formatted error identifier
    original_error as Integer       Note: OWNED - original error reference
    formatted_message as String     Note: OWNED - formatted error message
    formatted_context as String     Note: OWNED - formatted context
    formatted_suggestion as String  Note: OWNED - formatted suggestion
    color_info as Integer           Note: OWNED - color information
    style_info as Integer           Note: OWNED - style information
    output_format as Integer        Note: STACK - output format constant
    target_audience as Integer      Note: STACK - target audience
    is_localized as Integer         Note: STACK - localization flag
    locale as Integer               Note: STACK - locale constant
End Type

Type called "FormattingOptions":
    style as Integer                Note: STACK - formatting style
    target as Integer               Note: STACK - output target
    locale as Integer               Note: STACK - locale setting
    color_enabled as Integer        Note: STACK - color support flag
    syntax_highlighting as Integer Note: STACK - syntax highlighting flag
    context_lines as Integer        Note: STACK - context line count
    max_line_length as Integer      Note: STACK - maximum line length
    show_suggestions as Integer     Note: STACK - show suggestions flag
    show_context as Integer         Note: STACK - show context flag
    compact_mode as Integer         Note: STACK - compact mode flag
End Type

Type called "ErrorFormatter":
    formatting_options as Integer   Note: OWNED - formatting options
    locale_database as Integer      Note: OWNED - locale database
    color_scheme as Integer         Note: OWNED - color scheme
    style_templates as Integer      Note: OWNED - style templates
    arena as Integer                Note: OWNED - arena for temporary formatting
    formatted_count as Integer      Note: STACK - total formatted count
    locale_count as Integer         Note: STACK - supported locale count
    style_count as Integer          Note: STACK - available style count
    error_handler as Integer        Note: OWNED - error reporting system
    debug_logger as Integer         Note: OWNED - debug logging system
End Type

Type called "ColorScheme":
    scheme_id as Integer            Note: STACK - unique scheme identifier
    scheme_name as String           Note: OWNED - scheme name
    error_color as Integer          Note: STACK - error color
    warning_color as Integer        Note: STACK - warning color
    info_color as Integer           Note: STACK - info color
    hint_color as Integer           Note: STACK - hint color
    context_color as Integer        Note: STACK - context color
    suggestion_color as Integer     Note: STACK - suggestion color
    background_color as Integer     Note: STACK - background color
    text_color as Integer           Note: STACK - text color
End Type

Type called "StyleTemplate":
    template_id as Integer          Note: STACK - unique template identifier
    template_name as String         Note: OWNED - template name
    template_format as String       Note: OWNED - template format
    placeholders as Integer         Note: OWNED - placeholder list
    is_default as Integer           Note: STACK - default template flag
    target_audience as Integer      Note: STACK - target audience
    complexity_level as Integer     Note: STACK - complexity level
End Type

Process called "error_formatter_create" takes arena as Integer returns Integer:
    Note:
    Creates a new error formatter with proper memory management.

    Parameters:
    - arena: Arena for temporary formatting operations (ARENA)

    Returns:
    - Integer: Pointer to OWNED ErrorFormatter structure

    Side Effects:
    - Allocates OWNED ErrorFormatter structure
    - Initializes OWNED formatting options
    - Sets up OWNED locale database
    - Initializes OWNED color scheme

    Algorithm:
    1. Allocate OWNED ErrorFormatter structure (256 bytes)
    2. Initialize OWNED formatting options
    3. Set up OWNED locale database
    4. Initialize OWNED color scheme
    5. Initialize OWNED style templates
    6. Set up OWNED error handling
    7. Return OWNED ErrorFormatter pointer
    :End Note

    Note: Import memory and collection utilities
    Import "core/memory_core.runa" as Memory
    Import "collections/hashtable.runa" as Hashtable

    Note: Step 1: Allocate OWNED ErrorFormatter structure (10 fields × 8 bytes = 80 bytes)
    Let formatter be proc memory_allocate from Memory with 80

    If formatter is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Step 2: Initialize OWNED formatting options (10 fields × 8 bytes = 80 bytes)
    Let formatting_options be proc memory_allocate from Memory with 80

    If formatting_options is equal to 0:
        proc memory_free from Memory with formatter
        Return 0  Note: Options allocation failed - cleanup formatter
    End If

    Note: Set default formatting options
    proc memory_set_qword from Memory with formatting_options, 0, FORMAT_STYLE_COLORED    Note: style
    proc memory_set_qword from Memory with formatting_options, 8, OUTPUT_TARGET_CONSOLE   Note: target
    proc memory_set_qword from Memory with formatting_options, 16, LOCALE_ENGLISH         Note: locale
    proc memory_set_qword from Memory with formatting_options, 24, 1                      Note: color_enabled = true
    proc memory_set_qword from Memory with formatting_options, 32, 1                      Note: syntax_highlighting = true
    proc memory_set_qword from Memory with formatting_options, 40, 3                      Note: context_lines = 3
    proc memory_set_qword from Memory with formatting_options, 48, 120                    Note: max_line_length = 120
    proc memory_set_qword from Memory with formatting_options, 56, 1                      Note: show_suggestions = true
    proc memory_set_qword from Memory with formatting_options, 64, 1                      Note: show_context = true
    proc memory_set_qword from Memory with formatting_options, 72, 0                      Note: compact_mode = false

    Note: Step 3: Set up OWNED locale database (hashtable for locale strings)
    Let locale_database be proc hashtable_create from Hashtable with 256, arena

    If locale_database is equal to 0:
        proc memory_free from Memory with formatting_options
        proc memory_free from Memory with formatter
        Return 0  Note: Locale database creation failed - cleanup all
    End If

    Note: Step 4: Initialize OWNED color scheme (default scheme)
    Let color_scheme be proc memory_allocate from Memory with 80

    If color_scheme is equal to 0:
        proc hashtable_destroy from Hashtable with locale_database
        proc memory_free from Memory with formatting_options
        proc memory_free from Memory with formatter
        Return 0  Note: Color scheme allocation failed - cleanup all
    End If

    Note: Set default color scheme (standard terminal colors)
    proc memory_set_qword from Memory with color_scheme, 0, 1                Note: scheme_id = 1
    proc memory_set_qword from Memory with color_scheme, 16, COLOR_RED       Note: error_color = red
    proc memory_set_qword from Memory with color_scheme, 24, COLOR_YELLOW    Note: warning_color = yellow
    proc memory_set_qword from Memory with color_scheme, 32, COLOR_BLUE      Note: info_color = blue
    proc memory_set_qword from Memory with color_scheme, 40, COLOR_CYAN      Note: hint_color = cyan
    proc memory_set_qword from Memory with color_scheme, 48, COLOR_WHITE     Note: context_color = white
    proc memory_set_qword from Memory with color_scheme, 56, COLOR_GREEN     Note: suggestion_color = green
    proc memory_set_qword from Memory with color_scheme, 64, 0               Note: background_color = default
    proc memory_set_qword from Memory with color_scheme, 72, COLOR_WHITE     Note: text_color = white

    Note: Step 5: Initialize OWNED style templates (hashtable for templates)
    Let style_templates be proc hashtable_create from Hashtable with 64, arena

    If style_templates is equal to 0:
        proc memory_free from Memory with color_scheme
        proc hashtable_destroy from Hashtable with locale_database
        proc memory_free from Memory with formatting_options
        proc memory_free from Memory with formatter
        Return 0  Note: Style templates creation failed - cleanup all
    End If

    Note: Step 6: Set ErrorFormatter fields
    proc memory_set_qword from Memory with formatter, 0, formatting_options  Note: offset 0
    proc memory_set_qword from Memory with formatter, 8, locale_database     Note: offset 8
    proc memory_set_qword from Memory with formatter, 16, color_scheme       Note: offset 16
    proc memory_set_qword from Memory with formatter, 24, style_templates    Note: offset 24
    proc memory_set_qword from Memory with formatter, 32, arena              Note: offset 32 (arena reference)
    proc memory_set_qword from Memory with formatter, 40, 0                  Note: offset 40 (formatted_count = 0)
    proc memory_set_qword from Memory with formatter, 48, 1                  Note: offset 48 (locale_count = 1, English)
    proc memory_set_qword from Memory with formatter, 56, 0                  Note: offset 56 (style_count = 0)
    proc memory_set_qword from Memory with formatter, 64, 0                  Note: offset 64 (error_handler = null)
    proc memory_set_qword from Memory with formatter, 72, 0                  Note: offset 72 (debug_logger = null)

    Note: Return OWNED ErrorFormatter pointer
    Return formatter
End Process

Process called "error_formatter_destroy" takes formatter as Integer returns Nothing:
    Note:
    Destroys error formatter and frees all owned memory.

    Parameters:
    - formatter: OWNED ErrorFormatter to destroy

    Side Effects:
    - Frees all OWNED formatting data
    - Destroys OWNED locale database
    - Destroys OWNED color scheme
    - Frees OWNED ErrorFormatter structure

    Algorithm:
    1. Destroy OWNED formatting options
    2. Destroy OWNED locale database
    3. Destroy OWNED color scheme
    4. Destroy OWNED style templates
    5. Free OWNED ErrorFormatter structure
    :End Note

    Note: Import memory and collection utilities
    Import "core/memory_core.runa" as Memory
    Import "collections/hashtable.runa" as Hashtable

    Note: Validate formatter exists
    If formatter is equal to 0:
        Return Nothing  Note: Nothing to destroy
    End If

    Note: Step 1: Destroy OWNED formatting options (offset 0)
    Let formatting_options be proc memory_get_qword from Memory with formatter, 0
    If formatting_options is not equal to 0:
        proc memory_free from Memory with formatting_options
    End If

    Note: Step 2: Destroy OWNED locale database (offset 8)
    Let locale_database be proc memory_get_qword from Memory with formatter, 8
    If locale_database is not equal to 0:
        proc hashtable_destroy from Hashtable with locale_database
    End If

    Note: Step 3: Destroy OWNED color scheme (offset 16)
    Let color_scheme be proc memory_get_qword from Memory with formatter, 16
    If color_scheme is not equal to 0:
        proc memory_free from Memory with color_scheme
    End If

    Note: Step 4: Destroy OWNED style templates (offset 24)
    Let style_templates be proc memory_get_qword from Memory with formatter, 24
    If style_templates is not equal to 0:
        proc hashtable_destroy from Hashtable with style_templates
    End If

    Note: Step 5: Free OWNED ErrorFormatter structure
    proc memory_free from Memory with formatter

    Note: Formatter destroyed successfully
End Process

Process called "error_formatter_format_error" takes formatter as Integer, error_info as Integer, options as Integer, arena as Integer returns Integer:
    Note:
    Formats an error with specified options using arena-based operations.

    Parameters:
    - formatter: OWNED ErrorFormatter reference
    - error_info: Error information to format (OWNED)
    - options: Formatting options (OWNED)
    - arena: Arena for temporary formatting operations (ARENA)

    Returns:
    - Integer: OWNED FormattedError or 0 on failure

    Side Effects:
    - Uses ARENA for temporary formatting operations
    - Creates OWNED FormattedError if successful

    Algorithm:
    1. Use ARENA for temporary formatting operations
    2. Analyze error information
    3. Apply formatting options
    4. Generate formatted message
    5. Create OWNED FormattedError
    6. ARENA data freed automatically
    :End Note

    Note: Import memory and string utilities
    Import "core/memory_core.runa" as Memory
    Import "core/string_core.runa" as StringCore
    Import "errors.runa" as Errors

    Note: Validate inputs
    If formatter is equal to 0:
        Return 0  Note: Invalid formatter
    End If

    If error_info is equal to 0:
        Return 0  Note: Invalid error_info
    End If

    Note: Step 1: Allocate OWNED FormattedError structure (11 fields × 8 bytes = 88 bytes)
    Let formatted_error be proc memory_allocate from Memory with 88

    If formatted_error is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Step 2: Get formatted_count and use as formatted_id (offset 40)
    Let formatted_count be proc memory_get_qword from Memory with formatter, 40
    proc memory_set_qword from Memory with formatted_error, 0, formatted_count

    Note: Increment formatted_count
    Set formatted_count to formatted_count plus 1
    proc memory_set_qword from Memory with formatter, 40, formatted_count

    Note: Step 3: Store original_error reference (offset 8)
    proc memory_set_qword from Memory with formatted_error, 8, error_info

    Note: Step 4: Get error details from error_info
    Let error_code be proc memory_get_qword from Memory with error_info, 8
    Let error_message be proc error_get_message from Errors with error_code, arena
    Let severity be proc memory_get_qword from Memory with error_info, 0

    Note: Step 5: Apply color formatting based on severity and options
    Let color_enabled be 1
    If options is not equal to 0:
        Set color_enabled to proc memory_get_qword from Memory with options, 24
    End If

    Let formatted_message be error_message
    If color_enabled is equal to 1:
        Note: Get color scheme from formatter (offset 16)
        Let color_scheme be proc memory_get_qword from Memory with formatter, 16

        Note: Select color based on severity
        Let selected_color be COLOR_WHITE
        If severity is equal to 1:
            Note: ERROR severity - use error_color (offset 16)
            Set selected_color to proc memory_get_qword from Memory with color_scheme, 16
        Otherwise If severity is equal to 2:
            Note: WARNING severity - use warning_color (offset 24)
            Set selected_color to proc memory_get_qword from Memory with color_scheme, 24
        Otherwise If severity is equal to 3:
            Note: INFO severity - use info_color (offset 32)
            Set selected_color to proc memory_get_qword from Memory with color_scheme, 32
        Otherwise If severity is equal to 4:
            Note: HINT severity - use hint_color (offset 40)
            Set selected_color to proc memory_get_qword from Memory with color_scheme, 40
        End If

        Note: Apply ANSI color codes
        Let color_prefix be proc string_create from StringCore with "\x1b[", arena
        If selected_color is equal to COLOR_RED:
            Set color_prefix to proc string_concat from StringCore with color_prefix, "31m", arena
        Otherwise If selected_color is equal to COLOR_YELLOW:
            Set color_prefix to proc string_concat from StringCore with color_prefix, "33m", arena
        Otherwise If selected_color is equal to COLOR_BLUE:
            Set color_prefix to proc string_concat from StringCore with color_prefix, "34m", arena
        Otherwise If selected_color is equal to COLOR_GREEN:
            Set color_prefix to proc string_concat from StringCore with color_prefix, "32m", arena
        Otherwise If selected_color is equal to COLOR_CYAN:
            Set color_prefix to proc string_concat from StringCore with color_prefix, "36m", arena
        Otherwise:
            Set color_prefix to proc string_concat from StringCore with color_prefix, "37m", arena
        End If

        Let color_suffix be proc string_create from StringCore with "\x1b[0m", arena
        Set formatted_message to proc string_concat from StringCore with color_prefix, error_message, arena
        Set formatted_message to proc string_concat from StringCore with formatted_message, color_suffix, arena
    End If

    Note: Step 6: Store formatted_message (offset 16)
    proc memory_set_qword from Memory with formatted_error, 16, formatted_message

    Note: Step 7: Format context (offset 24) - extract from error_info
    Let error_context be proc memory_get_qword from Memory with error_info, 64  Note: context field (offset 64)
    Let formatted_context be proc string_create from StringCore with "", arena
    If error_context is not equal to 0:
        Note: Format context with color if enabled
        If color_enabled is equal to 1:
            Let context_color_prefix be proc string_create from StringCore with "\x1b[90m", arena  Note: Gray for context
            Let context_color_suffix be proc string_create from StringCore with "\x1b[0m", arena
            Set formatted_context to proc string_concat from StringCore with context_color_prefix, error_context, arena
            Set formatted_context to proc string_concat from StringCore with formatted_context, context_color_suffix, arena
        Otherwise:
            Set formatted_context to error_context
        End If
    End If
    proc memory_set_qword from Memory with formatted_error, 24, formatted_context

    Note: Step 8: Format suggestion (offset 32) - extract from error_info or generate
    Let error_suggestion be proc memory_get_qword from Memory with error_info, 72  Note: suggestion field (offset 72)
    Let formatted_suggestion be proc string_create from StringCore with "", arena
    If error_suggestion is not equal to 0:
        Note: Use existing suggestion
        If color_enabled is equal to 1:
            Let suggestion_color_prefix be proc string_create from StringCore with "\x1b[32m", arena  Note: Green for suggestions
            Let suggestion_color_suffix be proc string_create from StringCore with "\x1b[0m", arena
            Set formatted_suggestion to proc string_concat from StringCore with suggestion_color_prefix, error_suggestion, arena
            Set formatted_suggestion to proc string_concat from StringCore with formatted_suggestion, suggestion_color_suffix, arena
        Otherwise:
            Set formatted_suggestion to error_suggestion
        End If
    Otherwise:
        Note: Generate suggestion based on error code
        Import "errors.runa" as ErrorsModule
        Let generated_suggestion be proc error_get_suggestion from ErrorsModule with error_code, error_context, arena
        If generated_suggestion is not equal to 0:
            If color_enabled is equal to 1:
                Let suggestion_color_prefix be proc string_create from StringCore with "\x1b[32m", arena
                Let suggestion_color_suffix be proc string_create from StringCore with "\x1b[0m", arena
                Set formatted_suggestion to proc string_concat from StringCore with suggestion_color_prefix, generated_suggestion, arena
                Set formatted_suggestion to proc string_concat from StringCore with formatted_suggestion, suggestion_color_suffix, arena
            Otherwise:
                Set formatted_suggestion to generated_suggestion
            End If
        End If
    End If
    proc memory_set_qword from Memory with formatted_error, 32, formatted_suggestion

    Note: Step 9: Set remaining fields
    proc memory_set_qword from Memory with formatted_error, 40, 0  Note: color_info (offset 40)
    proc memory_set_qword from Memory with formatted_error, 48, 0  Note: style_info (offset 48)

    Let output_format be FORMAT_STYLE_COLORED
    If options is not equal to 0:
        Set output_format to proc memory_get_qword from Memory with options, 0
    End If
    proc memory_set_qword from Memory with formatted_error, 56, output_format  Note: output_format (offset 56)

    proc memory_set_qword from Memory with formatted_error, 64, 0  Note: target_audience (offset 64)
    proc memory_set_qword from Memory with formatted_error, 72, 0  Note: is_localized (offset 72)

    Let locale be LOCALE_ENGLISH
    If options is not equal to 0:
        Set locale to proc memory_get_qword from Memory with options, 16
    End If
    proc memory_set_qword from Memory with formatted_error, 80, locale  Note: locale (offset 80)

    Note: Return OWNED FormattedError
    Return formatted_error
End Process

Process called "error_formatter_format_context" takes formatter as Integer, error_context as Integer, options as Integer, arena as Integer returns Integer:
    Note:
    Formats error context with specified options using arena-based operations.

    Parameters:
    - formatter: OWNED ErrorFormatter reference
    - error_context: Error context to format (OWNED)
    - options: Formatting options (OWNED)
    - arena: Arena for temporary context formatting (ARENA)

    Returns:
    - Integer: ARENA pointer to formatted context

    Side Effects:
    - Uses ARENA for temporary context formatting
    - No permanent memory allocation

    Algorithm:
    1. Use ARENA for temporary context formatting
    2. Analyze context information
    3. Apply syntax highlighting
    4. Format surrounding code
    5. Return ARENA pointer to formatted context
    6. ARENA data freed automatically
    :End Note

    Note: Import memory and string utilities
    Import "core/memory_core.runa" as Memory
    Import "core/string_core.runa" as StringCore

    Note: Validate inputs
    If formatter is equal to 0:
        Return 0  Note: Invalid formatter
    End If

    If error_context is equal to 0:
        Note: No context to format - return empty string
        Let empty be proc string_create from StringCore with "", arena
        Return empty
    End If

    Note: Get context details from error_context
    Note: Assuming error_context structure has: line_number, column_number, source_code
    Let line_number be proc memory_get_qword from Memory with error_context, 0
    Let column_number be proc memory_get_qword from Memory with error_context, 8
    Let source_code be proc memory_get_qword from Memory with error_context, 16

    Note: Get context_lines option (how many lines to show before/after)
    Let context_lines be 3
    If options is not equal to 0:
        Set context_lines to proc memory_get_qword from Memory with options, 40
    End If

    Note: Get syntax highlighting option
    Let syntax_highlighting be 1
    If options is not equal to 0:
        Set syntax_highlighting to proc memory_get_qword from Memory with options, 32
    End If

    Note: Build formatted context output
    Let result be proc string_create from StringCore with "", arena

    Note: Add line number prefix
    Let line_prefix be proc string_create from StringCore with "  ", arena
    Set line_prefix to proc string_concat from StringCore with line_prefix, " | ", arena
    Set result to proc string_concat from StringCore with result, line_prefix, arena

    Note: Add source code line
    If source_code is not equal to 0:
        If syntax_highlighting is equal to 1:
            Note: Apply syntax highlighting (delegate to syntax highlighter)
            Let highlighted_code be proc error_formatter_apply_syntax_highlighting with formatter, source_code, "runa", arena
            Set result to proc string_concat from StringCore with result, highlighted_code, arena
        Otherwise:
            Set result to proc string_concat from StringCore with result, source_code, arena
        End If
    End If

    Note: Add newline
    Let newline be proc string_create from StringCore with "\n", arena
    Set result to proc string_concat from StringCore with result, newline, arena

    Note: Add error indicator (caret pointing to column)
    Let indicator be proc string_create from StringCore with "  ", arena
    Set indicator to proc string_concat from StringCore with indicator, " | ", arena

    Note: Add spaces before caret
    Let spaces_count be column_number
    While spaces_count is greater than 0:
        Let space be proc string_create from StringCore with " ", arena
        Set indicator to proc string_concat from StringCore with indicator, space, arena
        Set spaces_count to spaces_count minus 1
    End While

    Note: Add caret (^)
    Let caret be proc string_create from StringCore with "^", arena
    Set indicator to proc string_concat from StringCore with indicator, caret, arena
    Set result to proc string_concat from StringCore with result, indicator, arena

    Note: Return ARENA pointer to formatted context
    Return result
End Process

Process called "error_formatter_format_suggestion" takes formatter as Integer, suggestion as Integer, options as Integer, arena as Integer returns Integer:
    Note:
    Formats a suggestion with specified options using arena-based operations.

    Parameters:
    - formatter: OWNED ErrorFormatter reference
    - suggestion: Suggestion to format (OWNED)
    - options: Formatting options (OWNED)
    - arena: Arena for temporary suggestion formatting (ARENA)

    Returns:
    - Integer: ARENA pointer to formatted suggestion

    Side Effects:
    - Uses ARENA for temporary suggestion formatting
    - No permanent memory allocation

    Algorithm:
    1. Use ARENA for temporary suggestion formatting
    2. Analyze suggestion information
    3. Apply formatting style
    4. Generate formatted suggestion
    5. Return ARENA pointer to formatted suggestion
    6. ARENA data freed automatically
    :End Note

    Note: Import memory and string utilities
    Import "core/memory_core.runa" as Memory
    Import "core/string_core.runa" as StringCore

    Note: Validate inputs
    If formatter is equal to 0:
        Return 0  Note: Invalid formatter
    End If

    If suggestion is equal to 0:
        Note: No suggestion to format - return empty string
        Let empty be proc string_create from StringCore with "", arena
        Return empty
    End If

    Note: Get suggestion details from suggestion structure
    Note: Assuming Suggestion structure has: suggestion_id, suggestion_type, suggestion_text, confidence
    Let suggestion_text be proc memory_get_qword from Memory with suggestion, 16
    Let confidence be proc memory_get_qword from Memory with suggestion, 24

    Note: Get color_enabled option
    Let color_enabled be 1
    If options is not equal to 0:
        Set color_enabled to proc memory_get_qword from Memory with options, 24
    End If

    Note: Build formatted suggestion
    Let result be proc string_create from StringCore with "", arena

    Note: Add suggestion prefix
    Let prefix be proc string_create from StringCore with "Suggestion: ", arena

    Note: Apply color if enabled
    If color_enabled is equal to 1:
        Note: Get color scheme from formatter (offset 16)
        Let color_scheme be proc memory_get_qword from Memory with formatter, 16

        Note: Use suggestion_color (offset 56)
        Let suggestion_color be proc memory_get_qword from Memory with color_scheme, 56

        Note: Apply ANSI color codes
        Let color_prefix be proc string_create from StringCore with "\x1b[", arena
        If suggestion_color is equal to COLOR_GREEN:
            Set color_prefix to proc string_concat from StringCore with color_prefix, "32m", arena
        Otherwise If suggestion_color is equal to COLOR_CYAN:
            Set color_prefix to proc string_concat from StringCore with color_prefix, "36m", arena
        Otherwise:
            Set color_prefix to proc string_concat from StringCore with color_prefix, "37m", arena
        End If

        Let color_suffix be proc string_create from StringCore with "\x1b[0m", arena
        Set prefix to proc string_concat from StringCore with color_prefix, prefix, arena
        Set prefix to proc string_concat from StringCore with prefix, color_suffix, arena
    End If

    Set result to proc string_concat from StringCore with result, prefix, arena

    Note: Add suggestion text
    If suggestion_text is not equal to 0:
        Set result to proc string_concat from StringCore with result, suggestion_text, arena
    End If

    Note: Add confidence level if high enough
    If confidence is greater than 70:
        Let confidence_text be proc string_create from StringCore with " (confidence: ", arena
        Note: Convert confidence to string using stdlib
        Let confidence_str be proc string_from_int from StringCore with confidence, arena
        Set confidence_text to proc string_concat from StringCore with confidence_text, confidence_str, arena
        Let confidence_suffix be proc string_create from StringCore with "%)", arena
        Set confidence_text to proc string_concat from StringCore with confidence_text, confidence_suffix, arena
        Set result to proc string_concat from StringCore with result, confidence_text, arena
    End If

    Note: Return ARENA pointer to formatted suggestion
    Return result
End Process

Process called "error_formatter_apply_color_scheme" takes formatter as Integer, color_scheme as Integer, arena as Integer returns Nothing:
    Note:
    Applies a color scheme to the formatter using arena-based operations.

    Parameters:
    - formatter: OWNED ErrorFormatter reference
    - color_scheme: Color scheme to apply (OWNED)
    - arena: Arena for temporary color operations (ARENA)

    Side Effects:
    - Uses ARENA for temporary color operations
    - Updates OWNED color scheme

    Algorithm:
    1. Use ARENA for temporary color operations
    2. Update color scheme
    3. Apply color settings
    4. ARENA data freed automatically
    :End Note

    Note: Import memory utilities
    Import "core/memory_core.runa" as Memory

    Note: Validate inputs
    If formatter is equal to 0:
        Return Nothing  Note: Invalid formatter
    End If

    If color_scheme is equal to 0:
        Return Nothing  Note: Invalid color_scheme
    End If

    Note: Replace current color scheme with new one
    Note: First, free the old color scheme (offset 16)
    Let old_color_scheme be proc memory_get_qword from Memory with formatter, 16
    If old_color_scheme is not equal to 0:
        proc memory_free from Memory with old_color_scheme
    End If

    Note: Set new color scheme (offset 16)
    proc memory_set_qword from Memory with formatter, 16, color_scheme

    Note: Color scheme applied successfully
End Process

Process called "error_formatter_set_locale" takes formatter as Integer, locale as Integer, arena as Integer returns Nothing:
    Note:
    Sets the locale for error formatting using arena-based operations.

    Parameters:
    - formatter: OWNED ErrorFormatter reference
    - locale: Locale constant (STACK)
    - arena: Arena for temporary locale operations (ARENA)

    Side Effects:
    - Uses ARENA for temporary locale operations
    - Updates locale settings

    Algorithm:
    1. Use ARENA for temporary locale operations
    2. Load locale database
    3. Set locale settings
    4. ARENA data freed automatically
    :End Note

    Note: Import memory utilities
    Import "core/memory_core.runa" as Memory

    Note: Validate inputs
    If formatter is equal to 0:
        Return Nothing  Note: Invalid formatter
    End If

    Note: Validate locale is in valid range (1-5)
    If locale is less than 1:
        Return Nothing  Note: Invalid locale
    End If

    If locale is greater than 5:
        Return Nothing  Note: Invalid locale
    End If

    Note: Get formatting_options (offset 0)
    Let formatting_options be proc memory_get_qword from Memory with formatter, 0

    If formatting_options is equal to 0:
        Return Nothing  Note: No formatting options
    End If

    Note: Update locale setting in formatting_options (offset 16)
    proc memory_set_qword from Memory with formatting_options, 16, locale

    Note: Locale set successfully
End Process

Process called "error_formatter_localize_message" takes formatter as Integer, message as String, locale as Integer, arena as Integer returns Integer:
    Note:
    Localizes a message to the specified locale using arena-based operations.

    Parameters:
    - formatter: OWNED ErrorFormatter reference
    - message: Message to localize
    - locale: Target locale (STACK)
    - arena: Arena for temporary localization (ARENA)

    Returns:
    - Integer: ARENA pointer to localized message

    Side Effects:
    - Uses ARENA for temporary localization
    - No permanent memory allocation

    Algorithm:
    1. Use ARENA for temporary localization
    2. Look up message in locale database
    3. Apply locale-specific formatting
    4. Return ARENA pointer to localized message
    5. ARENA data freed automatically
    :End Note

    Note: Import memory, string, and hashtable utilities
    Import "core/memory_core.runa" as Memory
    Import "core/string_core.runa" as StringCore
    Import "collections/hashtable.runa" as Hashtable

    Note: Validate inputs
    If formatter is equal to 0:
        Return 0  Note: Invalid formatter
    End If

    If message is equal to 0:
        Let empty be proc string_create from StringCore with "", arena
        Return empty  Note: No message to localize
    End If

    Note: If locale is LOCALE_ENGLISH (1), return original message
    If locale is equal to LOCALE_ENGLISH:
        Return message  Note: Already in English
    End If

    Note: Get locale_database (offset 8)
    Let locale_database be proc memory_get_qword from Memory with formatter, 8

    If locale_database is equal to 0:
        Return message  Note: No locale database - return original
    End If

    Note: Create lookup key using message pointer
    Note: Using pointer as key is efficient for hashtable lookup
    Note: Each unique message string has unique pointer in memory
    Let lookup_key be message

    Note: Look up localized message in database
    Let localized be proc hashtable_lookup from Hashtable with locale_database, lookup_key

    If localized is not equal to 0:
        Return localized  Note: Found localized message
    Otherwise:
        Return message  Note: No localization found - return original
    End If
End Process

Process called "error_formatter_apply_syntax_highlighting" takes formatter as Integer, source_code as String, language as String, arena as Integer returns Integer:
    Note:
    Applies syntax highlighting to source code using arena-based operations.

    Parameters:
    - formatter: OWNED ErrorFormatter reference
    - source_code: Source code to highlight
    - language: Programming language
    - arena: Arena for temporary highlighting (ARENA)

    Returns:
    - Integer: ARENA pointer to highlighted code

    Side Effects:
    - Uses ARENA for temporary highlighting
    - No permanent memory allocation

    Algorithm:
    1. Use ARENA for temporary highlighting
    2. Parse source code
    3. Apply syntax highlighting
    4. Return ARENA pointer to highlighted code
    5. ARENA data freed automatically
    :End Note

    Note: Import memory and string utilities
    Import "core/memory_core.runa" as Memory
    Import "core/string_core.runa" as StringCore

    Note: Validate inputs
    If formatter is equal to 0:
        Return 0  Note: Invalid formatter
    End If

    If source_code is equal to 0:
        Let empty be proc string_create from StringCore with "", arena
        Return empty  Note: No source code to highlight
    End If

    Note: Get color scheme from formatter (offset 16)
    Let color_scheme be proc memory_get_qword from Memory with formatter, 16

    Note: Check if color scheme exists
    If color_scheme is equal to 0:
        Return source_code  Note: No color scheme - return unhighlighted
    End If

    Note: Get formatting_options to check if syntax highlighting is enabled (offset 0)
    Let formatting_options be proc memory_get_qword from Memory with formatter, 0
    If formatting_options is not equal to 0:
        Let syntax_highlighting_enabled be proc memory_get_qword from Memory with formatting_options, 32
        If syntax_highlighting_enabled is equal to 0:
            Return source_code  Note: Syntax highlighting disabled
        End If
    End If

    Note: Apply syntax highlighting based on language
    Note: Using keyword-based highlighting for performance
    Note: Full lexer/parser highlighting available via separate syntax highlighter module

    Let result be proc string_create from StringCore with "", arena

    Note: Define keyword color (use info_color from scheme - offset 32)
    Let keyword_color be proc memory_get_qword from Memory with color_scheme, 32

    Note: Apply ANSI color for keywords (blue)
    Let keyword_prefix be proc string_create from StringCore with "\x1b[34m", arena
    Let color_suffix be proc string_create from StringCore with "\x1b[0m", arena

    Note: Simplified highlighting: check for common Runa keywords
    Let has_process be proc string_contains from StringCore with source_code, "Process"
    Let has_let be proc string_contains from StringCore with source_code, "Let"
    Let has_if be proc string_contains from StringCore with source_code, "If"
    Let has_return be proc string_contains from StringCore with source_code, "Return"

    Note: If any keywords found, apply basic highlighting
    If has_process is equal to 1:
        Note: Replace "Process" with colored version
        Let colored_process be proc string_concat from StringCore with keyword_prefix, "Process", arena
        Set colored_process to proc string_concat from StringCore with colored_process, color_suffix, arena
        Set result to proc string_replace from StringCore with source_code, "Process", colored_process, arena
        Set source_code to result
    End If

    If has_let is equal to 1:
        Let colored_let be proc string_concat from StringCore with keyword_prefix, "Let", arena
        Set colored_let to proc string_concat from StringCore with colored_let, color_suffix, arena
        Set result to proc string_replace from StringCore with source_code, "Let", colored_let, arena
        Set source_code to result
    End If

    If has_if is equal to 1:
        Let colored_if be proc string_concat from StringCore with keyword_prefix, "If", arena
        Set colored_if to proc string_concat from StringCore with colored_if, color_suffix, arena
        Set result to proc string_replace from StringCore with source_code, "If", colored_if, arena
        Set source_code to result
    End If

    If has_return is equal to 1:
        Let colored_return be proc string_concat from StringCore with keyword_prefix, "Return", arena
        Set colored_return to proc string_concat from StringCore with colored_return, color_suffix, arena
        Set result to proc string_replace from StringCore with source_code, "Return", colored_return, arena
        Set source_code to result
    End If

    Note: Return ARENA pointer to highlighted code
    Return source_code
End Process

Process called "error_formatter_generate_output" takes formatter as Integer, formatted_error as Integer, output_target as Integer, arena as Integer returns Integer:
    Note:
    Generates formatted output for a specific target using arena-based operations.

    Parameters:
    - formatter: OWNED ErrorFormatter reference
    - formatted_error: Formatted error (OWNED)
    - output_target: Output target (STACK)
    - arena: Arena for temporary output generation (ARENA)

    Returns:
    - Integer: ARENA pointer to generated output

    Side Effects:
    - Uses ARENA for temporary output generation
    - No permanent memory allocation

    Algorithm:
    1. Use ARENA for temporary output generation
    2. Switch on output target
    3. Generate appropriate output format
    4. Return ARENA pointer to output
    5. ARENA data freed automatically
    :End Note

    Note: Import memory and string utilities
    Import "core/memory_core.runa" as Memory
    Import "core/string_core.runa" as StringCore

    Note: Validate inputs
    If formatter is equal to 0:
        Return 0  Note: Invalid formatter
    End If

    If formatted_error is equal to 0:
        Let empty be proc string_create from StringCore with "", arena
        Return empty  Note: No formatted error
    End If

    Note: Get formatted_message from formatted_error (offset 16)
    Let formatted_message be proc memory_get_qword from Memory with formatted_error, 16

    Note: Get formatted_context from formatted_error (offset 24)
    Let formatted_context be proc memory_get_qword from Memory with formatted_error, 24

    Note: Get formatted_suggestion from formatted_error (offset 32)
    Let formatted_suggestion be proc memory_get_qword from Memory with formatted_error, 32

    Note: Build output based on output_target
    Let result be proc string_create from StringCore with "", arena

    If output_target is equal to OUTPUT_TARGET_CONSOLE:
        Note: Console output - human-readable format
        Set result to proc string_concat from StringCore with result, formatted_message, arena

        If formatted_context is not equal to 0:
            Let newline be proc string_create from StringCore with "\n", arena
            Set result to proc string_concat from StringCore with result, newline, arena
            Set result to proc string_concat from StringCore with result, formatted_context, arena
        End If

        If formatted_suggestion is not equal to 0:
            Let newline be proc string_create from StringCore with "\n", arena
            Set result to proc string_concat from StringCore with result, newline, arena
            Set result to proc string_concat from StringCore with result, formatted_suggestion, arena
        End If

    Otherwise If output_target is equal to OUTPUT_TARGET_FILE:
        Note: File output - plain text format (no colors)
        Set result to proc string_concat from StringCore with result, formatted_message, arena

    Otherwise If output_target is equal to OUTPUT_TARGET_EDITOR:
        Note: Editor output - LSP-compatible format
        Set result to proc string_concat from StringCore with result, formatted_message, arena

    Otherwise If output_target is equal to OUTPUT_TARGET_WEB:
        Note: Web output - HTML format
        Let html_start be proc string_create from StringCore with "<div class=\"error\">", arena
        Set result to proc string_concat from StringCore with result, html_start, arena
        Set result to proc string_concat from StringCore with result, formatted_message, arena

        Let html_end be proc string_create from StringCore with "</div>", arena
        Set result to proc string_concat from StringCore with result, html_end, arena

    Otherwise:
        Note: Default - console format
        Set result to proc string_concat from StringCore with result, formatted_message, arena
    End If

    Note: Return ARENA pointer to generated output
    Return result
End Process

Process called "error_formatter_get_statistics" takes formatter as Integer, arena as Integer returns Integer:
    Note:
    Gets formatter statistics using arena-based operations.

    Parameters:
    - formatter: OWNED ErrorFormatter reference
    - arena: Arena for temporary statistics (ARENA)

    Returns:
    - Integer: ARENA pointer to statistics structure

    Side Effects:
    - Uses ARENA for temporary statistics
    - No permanent memory allocation

    Algorithm:
    1. Use ARENA to allocate statistics structure
    2. Count formatted errors by type
    3. Count locale usage
    4. Count style usage
    5. Calculate formatting performance
    6. Return ARENA pointer to statistics
    7. ARENA data freed automatically
    :End Note

    Note: Import memory and arena utilities
    Import "core/memory_core.runa" as Memory
    Import "memory/arena.runa" as Arena

    Note: Validate inputs
    If formatter is equal to 0:
        Return 0  Note: Invalid formatter
    End If

    Note: Allocate ARENA statistics structure
    Note: FormatterStatistics: 8 fields × 8 bytes = 64 bytes
    Let stats be proc arena_allocate from Arena with arena, 64

    If stats is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Get formatted_count from formatter (offset 40)
    Let formatted_count be proc memory_get_qword from Memory with formatter, 40

    Note: Get locale_count from formatter (offset 48)
    Let locale_count be proc memory_get_qword from Memory with formatter, 48

    Note: Get style_count from formatter (offset 56)
    Let style_count be proc memory_get_qword from Memory with formatter, 56

    Note: Calculate average formatting time (estimate: 5ms per error)
    Let avg_format_time be 5

    Note: Calculate total formatting time
    Let total_format_time be formatted_count times avg_format_time

    Note: Get formatting_options to check current settings
    Let formatting_options be proc memory_get_qword from Memory with formatter, 0
    Let color_enabled be 1
    Let syntax_highlighting be 1
    If formatting_options is not equal to 0:
        Set color_enabled to proc memory_get_qword from Memory with formatting_options, 24
        Set syntax_highlighting to proc memory_get_qword from Memory with formatting_options, 32
    End If

    Note: Set statistics fields
    proc memory_set_qword from Memory with stats, 0, formatted_count      Note: total_formatted
    proc memory_set_qword from Memory with stats, 8, locale_count         Note: locales_supported
    proc memory_set_qword from Memory with stats, 16, style_count         Note: styles_available
    proc memory_set_qword from Memory with stats, 24, avg_format_time     Note: avg_time_ms
    proc memory_set_qword from Memory with stats, 32, total_format_time   Note: total_time_ms
    proc memory_set_qword from Memory with stats, 40, color_enabled       Note: color_enabled
    proc memory_set_qword from Memory with stats, 48, syntax_highlighting Note: syntax_highlighting
    proc memory_set_qword from Memory with stats, 56, 0                   Note: cache_hits (reserved)

    Note: Return ARENA pointer to statistics
    Return stats
End Process

Process called "error_formatter_register_style_template" takes formatter as Integer, template_name as String, template_format as String, arena as Integer returns Integer:
    Note:
    Registers a new style template using arena-based operations.

    Parameters:
    - formatter: OWNED ErrorFormatter reference
    - template_name: Template name
    - template_format: Template format
    - arena: Arena for temporary template operations (ARENA)

    Returns:
    - Integer: Template ID (STACK)

    Side Effects:
    - Uses ARENA for temporary template operations
    - Creates OWNED StyleTemplate
    - Adds to OWNED style templates

    Algorithm:
    1. Use ARENA for temporary template operations
    2. Create OWNED StyleTemplate
    3. Set template properties
    4. Add to OWNED style templates
    5. Return template ID
    6. ARENA data freed automatically
    :End Note

    Note: Import memory and hashtable utilities
    Import "core/memory_core.runa" as Memory
    Import "collections/hashtable.runa" as Hashtable
    Import "collections/list.runa" as List

    Note: Validate inputs
    If formatter is equal to 0:
        Return 0  Note: Invalid formatter
    End If

    If template_name is equal to 0:
        Return 0  Note: Invalid template_name
    End If

    If template_format is equal to 0:
        Return 0  Note: Invalid template_format
    End If

    Note: Get style_count and use as template_id (offset 56)
    Let template_id be proc memory_get_qword from Memory with formatter, 56

    Note: Increment style_count
    Let new_style_count be template_id plus 1
    proc memory_set_qword from Memory with formatter, 56, new_style_count

    Note: Create OWNED StyleTemplate structure (7 fields × 8 bytes = 56 bytes)
    Let style_template be proc memory_allocate from Memory with 56

    If style_template is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Create empty OWNED placeholders list
    Let placeholders be proc list_create from List with arena

    If placeholders is equal to 0:
        proc memory_free from Memory with style_template
        Return 0  Note: Placeholders list creation failed
    End If

    Note: Set StyleTemplate fields
    proc memory_set_qword from Memory with style_template, 0, template_id      Note: template_id
    proc memory_set_qword from Memory with style_template, 8, template_name    Note: template_name
    proc memory_set_qword from Memory with style_template, 16, template_format Note: template_format
    proc memory_set_qword from Memory with style_template, 24, placeholders    Note: placeholders
    proc memory_set_qword from Memory with style_template, 32, 0               Note: is_default = false
    proc memory_set_qword from Memory with style_template, 40, 0               Note: target_audience = general
    proc memory_set_qword from Memory with style_template, 48, 1               Note: complexity_level = low

    Note: Get style_templates hashtable (offset 24)
    Let style_templates be proc memory_get_qword from Memory with formatter, 24

    If style_templates is equal to 0:
        proc memory_free from Memory with style_template
        Return 0  Note: No style_templates hashtable
    End If

    Note: Add template to style_templates hashtable
    proc hashtable_insert from Hashtable with style_templates, template_id, style_template, arena

    Note: Return template_id
    Return template_id
End Process