Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file defines Abstract Syntax Tree (AST) node types and structures for Runa.

This file performs the following tasks:
- Define all AST node types for Runa language constructs
- Provide AST node data structures and type definitions
- Handle AST node relationships and hierarchy
- Manage AST node metadata and attribute storage
- Support ownership tracking for v0.0.8.5 memory safety

This file is essential because of the following reasons:
- AST node definitions are the foundation of the parsing system
- Proper AST structure enables accurate representation of Runa code
- AST node types support all language features and constructs
- Ownership tracking nodes enable memory safety analysis

This file consists of the following functions/features/operation types:
- AST node type definitions and data structures
- AST node relationship and hierarchy management
- AST node metadata and attribute handling
- AST node validation and consistency checking
- Ownership tracking node support for v0.0.8.5

Dependencies:
- Imports memory/layout.runa for structure allocation
- Imports collections/list.runa for child node management
- Imports core/string_core.runa for string operations
:End Note

Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/primitives/collections/list.runa" as List
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore

Note: ============================================================================
Note: AST Node Type Constants
Note: ============================================================================

Note: Expression Node Types (1000-1999)
Constant AST_LITERAL as Integer is 1000              Note: String, Integer, Float, Boolean, Null literals
Constant AST_IDENTIFIER as Integer is 1001           Note: Variable/function/type identifiers
Constant AST_BINARY_EXPRESSION as Integer is 1002    Note: Binary operations (+, -, *, /, ==, etc.)
Constant AST_UNARY_EXPRESSION as Integer is 1003     Note: Unary operations (!, ~, -, +)
Constant AST_TERNARY_EXPRESSION as Integer is 1004   Note: Ternary operator (condition ? true : false) - v0.0.8.5
Constant AST_CALL_EXPRESSION as Integer is 1005      Note: Function/method calls
Constant AST_INDEX_EXPRESSION as Integer is 1006     Note: Array/collection indexing
Constant AST_MEMBER_EXPRESSION as Integer is 1007    Note: Field/method access (., ->)
Constant AST_PARENTHESIZED as Integer is 1008        Note: Parenthesized expressions
Constant AST_INTERPOLATED_STRING as Integer is 1009  Note: String interpolation (f"text {expr}") - v0.0.8.5
Constant AST_RANGE_EXPRESSION as Integer is 1010     Note: Range expressions (.., ..=)
Constant AST_ARRAY_LITERAL as Integer is 1011        Note: Array literals [1, 2, 3]
Constant AST_TUPLE_LITERAL as Integer is 1012        Note: Tuple literals (a, b, c)
Constant AST_RECORD_LITERAL as Integer is 1013       Note: Record literals {field: value}

Note: Statement Node Types (2000-2999)
Constant AST_LET_STATEMENT as Integer is 2000        Note: Let variable be value
Constant AST_SET_STATEMENT as Integer is 2001        Note: Set variable to value
Constant AST_DEFINE_STATEMENT as Integer is 2002     Note: Constant as value
Constant AST_IF_STATEMENT as Integer is 2003         Note: If condition: ... End If
Constant AST_OTHERWISE_STATEMENT as Integer is 2004  Note: Otherwise: ... (else clause)
Constant AST_MATCH_STATEMENT as Integer is 2005      Note: Match expression: When ... End Match
Constant AST_WHEN_CLAUSE as Integer is 2006          Note: When pattern: ... (match arm)
Constant AST_FOR_STATEMENT as Integer is 2007        Note: For variable in iterable: ... End For
Constant AST_WHILE_STATEMENT as Integer is 2008      Note: While condition: ... End While
Constant AST_LOOP_STATEMENT as Integer is 2009       Note: Loop: ... End Loop
Constant AST_RETURN_STATEMENT as Integer is 2010     Note: Return value
Constant AST_YIELD_STATEMENT as Integer is 2011      Note: Yield value
Constant AST_BREAK_STATEMENT as Integer is 2012      Note: Break
Constant AST_CONTINUE_STATEMENT as Integer is 2013   Note: Continue
Constant AST_THROW_STATEMENT as Integer is 2014      Note: Throw exception
Constant AST_TRY_STATEMENT as Integer is 2015        Note: Try: ... Catch: ... Finally: ...
Constant AST_CATCH_CLAUSE as Integer is 2016         Note: Catch exception: ... (catch clause)
Constant AST_FINALLY_CLAUSE as Integer is 2017       Note: Finally: ... (finally clause)
Constant AST_BLOCK_STATEMENT as Integer is 2018      Note: Block of statements

Note: Declaration Node Types (3000-3999)
Constant AST_PROCESS_DEFINITION as Integer is 3000  Note: Process called name takes params returns type
Constant AST_TYPE_DEFINITION as Integer is 3001     Note: Type called name: ... End Type
Constant AST_IMPORT_STATEMENT as Integer is 3002    Note: Import "path" as Alias
Constant AST_PROTOCOL_DEFINITION as Integer is 3003 Note: Protocol definition
Constant AST_EXTERNAL_DECLARATION as Integer is 3004 Note: External function declaration

Note: Type Node Types (4000-4999)
Constant AST_BASIC_TYPE as Integer is 4000          Note: Integer, Float, String, Boolean, etc.
Constant AST_GENERIC_TYPE as Integer is 4001        Note: Generic type with parameters
Constant AST_UNION_TYPE as Integer is 4002          Note: Union types (A OR B)
Constant AST_INTERSECTION_TYPE as Integer is 4003   Note: Intersection types (A AND B)
Constant AST_FUNCTION_TYPE as Integer is 4004       Note: Function type (params) -> return_type
Constant AST_OPTIONAL_TYPE as Integer is 4005       Note: Optional type (T?)
Constant AST_ARRAY_TYPE as Integer is 4006          Note: Array type (T[])
Constant AST_TUPLE_TYPE as Integer is 4007          Note: Tuple type (T1, T2, T3)
Constant AST_RECORD_TYPE as Integer is 4008         Note: Record type {field: Type}
Constant AST_TYPE_ANNOTATION as Integer is 4009     Note: Type annotation (as Type)

Note: Pattern Node Types (5000-5999)
Constant AST_IDENTIFIER_PATTERN as Integer is 5000  Note: Identifier pattern (variable binding)
Constant AST_LITERAL_PATTERN as Integer is 5001     Note: Literal pattern (constant matching)
Constant AST_TUPLE_PATTERN as Integer is 5002       Note: Tuple pattern (a, b, c)
Constant AST_RECORD_PATTERN as Integer is 5003      Note: Record pattern {field: pattern}
Constant AST_WILDCARD_PATTERN as Integer is 5004    Note: Wildcard pattern (_)
Constant AST_TYPE_PATTERN as Integer is 5005        Note: Type pattern (Type(inner_pattern))
Constant AST_GUARD_PATTERN as Integer is 5006       Note: Pattern with guard condition
Constant AST_RANGE_PATTERN as Integer is 5007       Note: Range pattern (1..10, 1..=100)
Constant AST_VARIANT_PATTERN as Integer is 5008     Note: Variant/enum pattern (Some(x), Ok(value))
Constant AST_ARRAY_PATTERN as Integer is 5009       Note: Array/list pattern ([a, b, ...rest])
Constant AST_OR_PATTERN as Integer is 5010          Note: Alternative pattern (1 | 2 | 3)
Constant AST_REST_PATTERN as Integer is 5011        Note: Rest pattern (...rest)

Note: Ownership Node Types (6000-6999) - v0.0.8.5
Constant AST_MOVE_EXPRESSION as Integer is 6000     Note: Move ownership transfer
Constant AST_BORROW_EXPRESSION as Integer is 6001   Note: Borrow reference
Constant AST_MUTABLE_BORROW as Integer is 6002      Note: Mutable borrow reference
Constant AST_OWNERSHIP_TRACKING as Integer is 6003  Note: Ownership state tracking

Note: Annotation Node Types (7000-7999)
Constant AST_AI_ANNOTATION as Integer is 7000       Note: AI annotation for code generation
Constant AST_ANNOTATION_TARGET as Integer is 7001   Note: Annotation target specification
Constant AST_ANNOTATION_PARAMETERS as Integer is 7002 Note: Annotation parameters

Note: Macro Node Types (8000-8999)
Constant AST_MACRO_DEFINITION as Integer is 8000    Note: Macro definition
Constant AST_MACRO_INVOCATION as Integer is 8001    Note: Macro invocation
Constant AST_MACRO_EXPANSION as Integer is 8002     Note: Macro expansion result

Note: ============================================================================
Note: Base AST Node Structure
Note: ============================================================================

Type called "ASTNode":
    node_type as Integer      Note: Node type constant (AST_LITERAL, AST_BINARY_EXPRESSION, etc.)
    line as Integer           Note: Line number where node appears (1-indexed)
    column as Integer         Note: Column number where node appears (1-indexed)
    children as Integer       Note: Pointer to List of child AST nodes
    child_count as Integer    Note: Number of child nodes
    value as Integer          Note: Node value (literal value, identifier name, operator, etc.)
    value_type as Integer     Note: Type of value (string, integer, float, etc.)
    metadata as Integer       Note: Pointer to additional node metadata
    parent as Integer         Note: Pointer to parent AST node (for traversal)
    ownership_info as Integer Note: Pointer to ownership tracking info (v0.0.8.5)

Note: ============================================================================
Note: Specialized Node Structures
Note: ============================================================================

Type called "BinaryExpressionNode":
    base as ASTNode           Note: Base AST node structure
    operator as Integer       Note: Operator token type
    left as Integer           Note: Pointer to left operand AST node
    right as Integer          Note: Pointer to right operand AST node

Type called "TernaryExpressionNode":
    base as ASTNode           Note: Base AST node structure
    condition as Integer       Note: Pointer to condition expression
    true_value as Integer     Note: Pointer to true branch expression
    false_value as Integer    Note: Pointer to false branch expression

Type called "CallExpressionNode":
    base as ASTNode           Note: Base AST node structure
    callee as Integer         Note: Pointer to function/object being called
    arguments as Integer      Note: Pointer to List of argument expressions
    argument_count as Integer Note: Number of arguments

Type called "MemberExpressionNode":
    base as ASTNode           Note: Base AST node structure
    object as Integer          Note: Pointer to object expression
    property as Integer        Note: Pointer to property identifier
    computed as Integer        Note: Boolean: 1 if computed property (obj[expr]), 0 if dot notation

Type called "IndexExpressionNode":
    base as ASTNode           Note: Base AST node structure
    object as Integer          Note: Pointer to object expression
    index as Integer           Note: Pointer to index expression

Type called "InterpolatedStringNode":
    base as ASTNode           Note: Base AST node structure
    parts as Integer          Note: Pointer to List of string parts and expressions
    part_count as Integer     Note: Number of parts (strings + expressions)

Type called "ProcessDefinitionNode":
    base as ASTNode           Note: Base AST node structure
    name as Integer           Note: Pointer to process name string
    parameters as Integer     Note: Pointer to List of parameter nodes
    parameter_count as Integer Note: Number of parameters
    return_type as Integer    Note: Pointer to return type AST node
    body as Integer           Note: Pointer to body statement AST node
    is_async as Integer       Note: Boolean: 1 if async process
    is_public as Integer      Note: Boolean: 1 if public process

Type called "TypeDefinitionNode":
    base as ASTNode           Note: Base AST node structure
    name as Integer           Note: Pointer to type name string
    generic_parameters as Integer Note: Pointer to List of generic parameter nodes
    generic_count as Integer  Note: Number of generic parameters
    body as Integer           Note: Pointer to type body AST node
    is_public as Integer      Note: Boolean: 1 if public type

Type called "MatchStatementNode":
    base as ASTNode           Note: Base AST node structure
    expression as Integer     Note: Pointer to expression being matched
    arms as Integer           Note: Pointer to List of When clause nodes
    arm_count as Integer      Note: Number of match arms
    has_otherwise as Integer  Note: Boolean: 1 if has Otherwise clause

Type called "WhenClauseNode":
    base as ASTNode           Note: Base AST node structure
    pattern as Integer        Note: Pointer to pattern AST node
    guard as Integer          Note: Pointer to guard condition (optional)
    body as Integer           Note: Pointer to body statement AST node

Type called "OwnershipInfo":
    variable_name as Integer  Note: Pointer to variable name
    ownership_status as Integer Note: 0=owned, 1=borrowed, 2=moved
    borrow_count as Integer   Note: Number of active borrows
    is_mutable as Integer     Note: Boolean: 1 if mutable, 0 if immutable
    declaration_line as Integer Note: Line where variable declared
    last_use_line as Integer  Note: Line of last use

Note: ============================================================================
Note: AST Node Creation and Management
Note: ============================================================================

Process called "create_ast_node" takes node_type as Integer, line as Integer, column as Integer returns Integer:
    Note: Create a new AST node with specified type and position

    Note: ASTNode structure size: 10 fields × 8 bytes = 80 bytes
    Let node_size be 80
    Let node be proc allocate from Layout with node_size

    If node is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Set node_type field (offset 0)
    proc memory_set_qword from Layout with node, 0, node_type

    Note: Set line field (offset 8)
    proc memory_set_qword from Layout with node, 8, line

    Note: Set column field (offset 16)
    proc memory_set_qword from Layout with node, 16, column

    Note: Create empty children List (offset 24)
    Let children_list be proc create from List
    proc memory_set_qword from Layout with node, 24, children_list

    Note: Set child_count to 0 (offset 32)
    proc memory_set_qword from Layout with node, 32, 0

    Note: Set value to 0 - no value initially (offset 40)
    proc memory_set_qword from Layout with node, 40, 0

    Note: Set value_type to 0 - no type initially (offset 48)
    proc memory_set_qword from Layout with node, 48, 0

    Note: Set metadata to 0 - no metadata initially (offset 56)
    proc memory_set_qword from Layout with node, 56, 0

    Note: Set parent to 0 - no parent initially (offset 64)
    proc memory_set_qword from Layout with node, 64, 0

    Note: Set ownership_info to 0 - no ownership tracking initially (offset 72)
    proc memory_set_qword from Layout with node, 72, 0

    Return node
End Process

Process called "destroy_ast_node" takes node as Integer returns Integer:
    Note: Destroy an AST node and all its children recursively

    If node is equal to 0:
        Return 1  Note: NULL node already destroyed
    End If

    Note: Get children List (offset 24)
    Let children_list be proc memory_get_qword from Layout with node, 24

    Note: Get child_count (offset 32)
    Let child_count be proc memory_get_qword from Layout with node, 32

    Note: Destroy all children recursively
    Let index be 0
    Loop forever:
        If index is greater than or equal to child_count:
            Break
        End If

        Let child be proc get from List with children_list, index
        If child is not equal to 0:
            proc destroy_ast_node with child  Note: Recursive destruction
        End If

        Set index to index plus 1
    End Loop

    Note: Destroy children List
    If children_list is not equal to 0:
        proc destroy from List with children_list
    End If

    Note: Get metadata (offset 56)
    Let metadata be proc memory_get_qword from Layout with node, 56

    Note: Destroy metadata if present
    If metadata is not equal to 0:
        proc deallocate from Layout with metadata
    End If

    Note: Get ownership_info (offset 72)
    Let ownership_info be proc memory_get_qword from Layout with node, 72

    Note: Destroy ownership_info if present
    If ownership_info is not equal to 0:
        proc deallocate from Layout with ownership_info
    End If

    Note: Deallocate the node itself
    proc deallocate from Layout with node

    Return 1
End Process

Note: ============================================================================
Note: AST Node Relationship Management
Note: ============================================================================

Process called "ast_node_add_child" takes parent as Integer, child as Integer returns Integer:
    Note: Add a child node to a parent AST node

    If parent is equal to 0:
        Return 0  Note: NULL parent
    End If

    If child is equal to 0:
        Return 0  Note: NULL child
    End If

    Note: Get parent's children List (offset 24)
    Let children_list be proc memory_get_qword from Layout with parent, 24

    Note: Add child to children List
    Let append_result be proc append from List with children_list, child

    If append_result is equal to 0:
        Return 0  Note: List append failed
    End If

    Note: Get current child_count (offset 32)
    Let child_count be proc memory_get_qword from Layout with parent, 32

    Note: Increment child_count
    Set child_count to child_count plus 1
    proc memory_set_qword from Layout with parent, 32, child_count

    Note: Set child's parent field to parent (offset 64)
    proc memory_set_qword from Layout with child, 64, parent

    Return 1
End Process

Process called "ast_node_remove_child" takes parent as Integer, child as Integer returns Integer:
    Note: Remove a child node from a parent AST node

    If parent is equal to 0:
        Return 0  Note: NULL parent
    End If

    If child is equal to 0:
        Return 0  Note: NULL child
    End If

    Note: Get parent's children List (offset 24)
    Let children_list be proc memory_get_qword from Layout with parent, 24

    Note: Get current child_count (offset 32)
    Let child_count be proc memory_get_qword from Layout with parent, 32

    Note: Find and remove child from List
    Let index be 0
    Let found be 0
    Loop forever:
        If index is greater than or equal to child_count:
            Break
        End If

        Let current_child be proc get from List with children_list, index
        If current_child is equal to child:
            Set found to 1
            Break
        End If

        Set index to index plus 1
    End Loop

    If found is equal to 0:
        Return 0  Note: Child not found in parent
    End If

    Note: Remove child from List at index
    Let remove_result be proc remove_at from List with children_list, index

    If remove_result is equal to 0:
        Return 0  Note: Remove failed
    End If

    Note: Decrement child_count
    Set child_count to child_count minus 1
    proc memory_set_qword from Layout with parent, 32, child_count

    Note: Set child's parent field to 0 (offset 64)
    proc memory_set_qword from Layout with child, 64, 0

    Return 1
End Process

Process called "ast_node_get_child" takes parent as Integer, index as Integer returns Integer:
    Note: Get a child node by index

    If parent is equal to 0:
        Return 0  Note: NULL parent
    End If

    Note: Get child_count (offset 32)
    Let child_count be proc memory_get_qword from Layout with parent, 32

    Note: Check bounds
    If index is less than 0:
        Return 0  Note: Negative index
    End If

    If index is greater than or equal to child_count:
        Return 0  Note: Index out of bounds
    End If

    Note: Get children List (offset 24)
    Let children_list be proc memory_get_qword from Layout with parent, 24

    Note: Get child at index
    Let child be proc get from List with children_list, index

    Return child
End Process

Note: ============================================================================
Note: AST Node Value Management
Note: ============================================================================

Process called "ast_node_set_value" takes node as Integer, value as Integer, value_type as Integer returns Integer:
    Note: Set the value of an AST node

    If node is equal to 0:
        Return 0  Note: NULL node
    End If

    Note: Set value field (offset 40)
    proc memory_set_qword from Layout with node, 40, value

    Note: Set value_type field (offset 48)
    proc memory_set_qword from Layout with node, 48, value_type

    Return 1
End Process

Process called "ast_node_get_value" takes node as Integer returns Integer:
    Note: Get the value of an AST node

    If node is equal to 0:
        Return 0  Note: NULL node
    End If

    Note: Get value field (offset 40)
    Let value be proc memory_get_qword from Layout with node, 40

    Return value
End Process

Process called "ast_node_get_value_type" takes node as Integer returns Integer:
    Note: Get the value type of an AST node

    If node is equal to 0:
        Return 0  Note: NULL node
    End If

    Note: Get value_type field (offset 48)
    Let value_type be proc memory_get_qword from Layout with node, 48

    Return value_type
End Process

Note: ============================================================================
Note: Specialized Node Creation
Note: ============================================================================

Process called "create_binary_expression_node" takes operator as Integer, left as Integer, right as Integer, line as Integer, column as Integer returns Integer:
    Note: Create a binary expression AST node
    Note: BinaryExpressionNode size: base (80) + operator (8) + left (8) + right (8) = 104 bytes

    Let node_size be 104
    Let node be proc allocate from Layout with node_size

    If node is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Initialize base ASTNode fields (offsets 0-72)
    proc memory_set_qword from Layout with node, 0, AST_BINARY_EXPRESSION  Note: node_type
    proc memory_set_qword from Layout with node, 8, line
    proc memory_set_qword from Layout with node, 16, column

    Let children_list be proc create from List
    proc memory_set_qword from Layout with node, 24, children_list  Note: children
    proc memory_set_qword from Layout with node, 32, 2  Note: child_count = 2
    proc memory_set_qword from Layout with node, 40, 0  Note: value
    proc memory_set_qword from Layout with node, 48, 0  Note: value_type
    proc memory_set_qword from Layout with node, 56, 0  Note: metadata
    proc memory_set_qword from Layout with node, 64, 0  Note: parent
    proc memory_set_qword from Layout with node, 72, 0  Note: ownership_info

    Note: Set specialized fields
    proc memory_set_qword from Layout with node, 80, operator  Note: operator field
    proc memory_set_qword from Layout with node, 88, left  Note: left field
    proc memory_set_qword from Layout with node, 96, right  Note: right field

    Note: Add children to list
    proc append from List with children_list, left
    proc append from List with children_list, right

    Note: Set parent pointers for children
    If left is not equal to 0:
        proc memory_set_qword from Layout with left, 64, node
    End If

    If right is not equal to 0:
        proc memory_set_qword from Layout with right, 64, node
    End If

    Return node
End Process

Process called "create_ternary_expression_node" takes condition as Integer, true_value as Integer, false_value as Integer, line as Integer, column as Integer returns Integer:
    Note: Create a ternary expression AST node (v0.0.8.5 feature)
    Note: TernaryExpressionNode size: base (80) + condition (8) + true_value (8) + false_value (8) = 104 bytes

    Let node_size be 104
    Let node be proc allocate from Layout with node_size

    If node is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Initialize base ASTNode fields
    proc memory_set_qword from Layout with node, 0, AST_TERNARY_EXPRESSION  Note: node_type
    proc memory_set_qword from Layout with node, 8, line
    proc memory_set_qword from Layout with node, 16, column

    Let children_list be proc create from List
    proc memory_set_qword from Layout with node, 24, children_list  Note: children
    proc memory_set_qword from Layout with node, 32, 3  Note: child_count = 3
    proc memory_set_qword from Layout with node, 40, 0  Note: value
    proc memory_set_qword from Layout with node, 48, 0  Note: value_type
    proc memory_set_qword from Layout with node, 56, 0  Note: metadata
    proc memory_set_qword from Layout with node, 64, 0  Note: parent
    proc memory_set_qword from Layout with node, 72, 0  Note: ownership_info

    Note: Set specialized fields
    proc memory_set_qword from Layout with node, 80, condition  Note: condition field
    proc memory_set_qword from Layout with node, 88, true_value  Note: true_value field
    proc memory_set_qword from Layout with node, 96, false_value  Note: false_value field

    Note: Add children to list
    proc append from List with children_list, condition
    proc append from List with children_list, true_value
    proc append from List with children_list, false_value

    Note: Set parent pointers for children
    If condition is not equal to 0:
        proc memory_set_qword from Layout with condition, 64, node
    End If

    If true_value is not equal to 0:
        proc memory_set_qword from Layout with true_value, 64, node
    End If

    If false_value is not equal to 0:
        proc memory_set_qword from Layout with false_value, 64, node
    End If

    Return node
End Process

Process called "create_call_expression_node" takes callee as Integer, arguments as Integer, argument_count as Integer, line as Integer, column as Integer returns Integer:
    Note: Create a function call expression AST node
    Note: CallExpressionNode size: base (80) + callee (8) + arguments (8) + argument_count (8) = 104 bytes

    Let node_size be 104
    Let node be proc allocate from Layout with node_size

    If node is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Initialize base ASTNode fields
    proc memory_set_qword from Layout with node, 0, AST_CALL_EXPRESSION  Note: node_type
    proc memory_set_qword from Layout with node, 8, line
    proc memory_set_qword from Layout with node, 16, column

    Let children_list be proc create from List
    proc memory_set_qword from Layout with node, 24, children_list  Note: children

    Note: Child count is 1 (callee) + argument_count
    Let total_children be 1 plus argument_count
    proc memory_set_qword from Layout with node, 32, total_children

    proc memory_set_qword from Layout with node, 40, 0  Note: value
    proc memory_set_qword from Layout with node, 48, 0  Note: value_type
    proc memory_set_qword from Layout with node, 56, 0  Note: metadata
    proc memory_set_qword from Layout with node, 64, 0  Note: parent
    proc memory_set_qword from Layout with node, 72, 0  Note: ownership_info

    Note: Set specialized fields
    proc memory_set_qword from Layout with node, 80, callee  Note: callee field
    proc memory_set_qword from Layout with node, 88, arguments  Note: arguments field
    proc memory_set_qword from Layout with node, 96, argument_count  Note: argument_count field

    Note: Add callee to children list
    proc append from List with children_list, callee
    If callee is not equal to 0:
        proc memory_set_qword from Layout with callee, 64, node
    End If

    Note: Add all arguments to children list
    Let index be 0
    Loop forever:
        If index is greater than or equal to argument_count:
            Break
        End If

        Let arg be proc get from List with arguments, index
        proc append from List with children_list, arg

        If arg is not equal to 0:
            proc memory_set_qword from Layout with arg, 64, node
        End If

        Set index to index plus 1
    End Loop

    Return node
End Process

Process called "create_process_definition_node" takes name as Integer, parameters as Integer, return_type as Integer, body as Integer, line as Integer, column as Integer returns Integer:
    Note: Create a process definition AST node
    Note: ProcessDefinitionNode size: base (80) + name (8) + parameters (8) + parameter_count (8) + return_type (8) + body (8) + is_async (8) + is_public (8) = 136 bytes

    Let node_size be 136
    Let node be proc allocate from Layout with node_size

    If node is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Initialize base ASTNode fields
    proc memory_set_qword from Layout with node, 0, AST_PROCESS_DEFINITION  Note: node_type
    proc memory_set_qword from Layout with node, 8, line
    proc memory_set_qword from Layout with node, 16, column

    Let children_list be proc create from List
    proc memory_set_qword from Layout with node, 24, children_list  Note: children

    Note: Count children: parameters list + return_type + body
    Let param_count be 0
    If parameters is not equal to 0:
        Set param_count to proc size from List with parameters
    End If

    Let total_children be param_count plus 2  Note: return_type + body
    proc memory_set_qword from Layout with node, 32, total_children

    proc memory_set_qword from Layout with node, 40, 0  Note: value
    proc memory_set_qword from Layout with node, 48, 0  Note: value_type
    proc memory_set_qword from Layout with node, 56, 0  Note: metadata
    proc memory_set_qword from Layout with node, 64, 0  Note: parent
    proc memory_set_qword from Layout with node, 72, 0  Note: ownership_info

    Note: Set specialized fields
    proc memory_set_qword from Layout with node, 80, name  Note: name field
    proc memory_set_qword from Layout with node, 88, parameters  Note: parameters field
    proc memory_set_qword from Layout with node, 96, param_count  Note: parameter_count field
    proc memory_set_qword from Layout with node, 104, return_type  Note: return_type field
    proc memory_set_qword from Layout with node, 112, body  Note: body field
    proc memory_set_qword from Layout with node, 120, 0  Note: is_async = false
    proc memory_set_qword from Layout with node, 128, 0  Note: is_public = false

    Note: Add parameters to children list
    Let index be 0
    Loop forever:
        If index is greater than or equal to param_count:
            Break
        End If

        Let param be proc get from List with parameters, index
        proc append from List with children_list, param

        If param is not equal to 0:
            proc memory_set_qword from Layout with param, 64, node
        End If

        Set index to index plus 1
    End Loop

    Note: Add return_type to children list
    proc append from List with children_list, return_type
    If return_type is not equal to 0:
        proc memory_set_qword from Layout with return_type, 64, node
    End If

    Note: Add body to children list
    proc append from List with children_list, body
    If body is not equal to 0:
        proc memory_set_qword from Layout with body, 64, node
    End If

    Return node
End Process

Note: ============================================================================
Note: Ownership Tracking Support (v0.0.8.5)
Note: ============================================================================

Process called "create_ownership_info" takes variable_name as Integer, ownership_status as Integer, is_mutable as Integer, declaration_line as Integer returns Integer:
    Note: Create ownership tracking information for a variable
    Note: OwnershipInfo size: 6 fields × 8 bytes = 48 bytes

    Let info_size be 48
    Let info be proc allocate from Layout with info_size

    If info is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Set variable_name (offset 0)
    proc memory_set_qword from Layout with info, 0, variable_name

    Note: Set ownership_status (offset 8)
    proc memory_set_qword from Layout with info, 8, ownership_status

    Note: Set borrow_count to 0 initially (offset 16)
    proc memory_set_qword from Layout with info, 16, 0

    Note: Set is_mutable (offset 24)
    proc memory_set_qword from Layout with info, 24, is_mutable

    Note: Set declaration_line (offset 32)
    proc memory_set_qword from Layout with info, 32, declaration_line

    Note: Set last_use_line to 0 initially (offset 40)
    proc memory_set_qword from Layout with info, 40, 0

    Return info
End Process

Process called "ast_node_set_ownership_info" takes node as Integer, ownership_info as Integer returns Integer:
    Note: Set ownership tracking information for an AST node

    If node is equal to 0:
        Return 0  Note: NULL node
    End If

    Note: Set ownership_info field (offset 72)
    proc memory_set_qword from Layout with node, 72, ownership_info

    Return 1
End Process

Process called "ast_node_get_ownership_info" takes node as Integer returns Integer:
    Note: Get ownership tracking information for an AST node

    If node is equal to 0:
        Return 0  Note: NULL node
    End If

    Note: Get ownership_info field (offset 72)
    Let ownership_info be proc memory_get_qword from Layout with node, 72

    Return ownership_info
End Process

Note: ============================================================================
Note: AST Node Validation
Note: ============================================================================

Process called "validate_ast_node" takes node as Integer returns Integer:
    Note: Validate that an AST node is well-formed

    Note: Check if node is null
    If node is equal to 0:
        Return 0  Note: NULL node is invalid
    End If

    Note: Get node_type (offset 0)
    Let node_type be proc memory_get_qword from Layout with node, 0

    Note: Validate node type is in valid range
    Note: Expression nodes: 1000-1999, Statement nodes: 2000-2999, Declaration nodes: 3000-3999
    Note: Type nodes: 4000-4999, Pattern nodes: 5000-5999, Ownership nodes: 6000-6999
    Note: Annotation nodes: 7000-7999, Macro nodes: 8000-8999
    If node_type is less than 1000:
        Return 0  Note: Invalid node type
    End If

    If node_type is greater than 8999:
        Return 0  Note: Invalid node type
    End If

    Note: Get line (offset 8)
    Let line be proc memory_get_qword from Layout with node, 8

    Note: Validate line is positive
    If line is less than 1:
        Return 0  Note: Invalid line number
    End If

    Note: Get column (offset 16)
    Let column be proc memory_get_qword from Layout with node, 16

    Note: Validate column is positive
    If column is less than 1:
        Return 0  Note: Invalid column number
    End If

    Note: Get children list (offset 24)
    Let children_list be proc memory_get_qword from Layout with node, 24

    Note: Get child_count (offset 32)
    Let child_count be proc memory_get_qword from Layout with node, 32

    Note: Validate children list size matches child_count
    If children_list is not equal to 0:
        Let list_size be proc size from List with children_list

        If list_size is not equal to child_count:
            Return 0  Note: Children count mismatch
        End If
    End If

    Note: Recursively validate all children
    Let index be 0
    Loop forever:
        If index is greater than or equal to child_count:
            Break
        End If

        Let child be proc get from List with children_list, index

        Note: Validate child
        Let child_valid be proc validate_ast_node with child

        If child_valid is equal to 0:
            Return 0  Note: Invalid child found
        End If

        Note: Validate parent-child relationship
        If child is not equal to 0:
            Let child_parent be proc memory_get_qword from Layout with child, 64

            If child_parent is not equal to node:
                Return 0  Note: Parent-child relationship inconsistent
            End If
        End If

        Set index to index plus 1
    End Loop

    Return 1  Note: Node is valid
End Process

Process called "ast_node_type_to_string" takes node_type as Integer returns Integer:
    Note: Convert AST node type constant to readable string

    Note: Expression Node Types (1000-1999)
    If node_type is equal to AST_LITERAL:
        Return proc string_from_cstr from StringCore with "AST_LITERAL"
    Otherwise if node_type is equal to AST_IDENTIFIER:
        Return proc string_from_cstr from StringCore with "AST_IDENTIFIER"
    Otherwise if node_type is equal to AST_BINARY_EXPRESSION:
        Return proc string_from_cstr from StringCore with "AST_BINARY_EXPRESSION"
    Otherwise if node_type is equal to AST_UNARY_EXPRESSION:
        Return proc string_from_cstr from StringCore with "AST_UNARY_EXPRESSION"
    Otherwise if node_type is equal to AST_TERNARY_EXPRESSION:
        Return proc string_from_cstr from StringCore with "AST_TERNARY_EXPRESSION"
    Otherwise if node_type is equal to AST_CALL_EXPRESSION:
        Return proc string_from_cstr from StringCore with "AST_CALL_EXPRESSION"
    Otherwise if node_type is equal to AST_INDEX_EXPRESSION:
        Return proc string_from_cstr from StringCore with "AST_INDEX_EXPRESSION"
    Otherwise if node_type is equal to AST_MEMBER_EXPRESSION:
        Return proc string_from_cstr from StringCore with "AST_MEMBER_EXPRESSION"
    Otherwise if node_type is equal to AST_PARENTHESIZED:
        Return proc string_from_cstr from StringCore with "AST_PARENTHESIZED"
    Otherwise if node_type is equal to AST_INTERPOLATED_STRING:
        Return proc string_from_cstr from StringCore with "AST_INTERPOLATED_STRING"
    Otherwise if node_type is equal to AST_RANGE_EXPRESSION:
        Return proc string_from_cstr from StringCore with "AST_RANGE_EXPRESSION"
    Otherwise if node_type is equal to AST_ARRAY_LITERAL:
        Return proc string_from_cstr from StringCore with "AST_ARRAY_LITERAL"
    Otherwise if node_type is equal to AST_TUPLE_LITERAL:
        Return proc string_from_cstr from StringCore with "AST_TUPLE_LITERAL"
    Otherwise if node_type is equal to AST_RECORD_LITERAL:
        Return proc string_from_cstr from StringCore with "AST_RECORD_LITERAL"
    End If

    Note: Statement Node Types (2000-2999)
    If node_type is equal to AST_LET_STATEMENT:
        Return proc string_from_cstr from StringCore with "AST_LET_STATEMENT"
    Otherwise if node_type is equal to AST_SET_STATEMENT:
        Return proc string_from_cstr from StringCore with "AST_SET_STATEMENT"
    Otherwise if node_type is equal to AST_DEFINE_STATEMENT:
        Return proc string_from_cstr from StringCore with "AST_DEFINE_STATEMENT"
    Otherwise if node_type is equal to AST_IF_STATEMENT:
        Return proc string_from_cstr from StringCore with "AST_IF_STATEMENT"
    Otherwise if node_type is equal to AST_OTHERWISE_STATEMENT:
        Return proc string_from_cstr from StringCore with "AST_OTHERWISE_STATEMENT"
    Otherwise if node_type is equal to AST_MATCH_STATEMENT:
        Return proc string_from_cstr from StringCore with "AST_MATCH_STATEMENT"
    Otherwise if node_type is equal to AST_WHEN_CLAUSE:
        Return proc string_from_cstr from StringCore with "AST_WHEN_CLAUSE"
    Otherwise if node_type is equal to AST_FOR_STATEMENT:
        Return proc string_from_cstr from StringCore with "AST_FOR_STATEMENT"
    Otherwise if node_type is equal to AST_WHILE_STATEMENT:
        Return proc string_from_cstr from StringCore with "AST_WHILE_STATEMENT"
    Otherwise if node_type is equal to AST_LOOP_STATEMENT:
        Return proc string_from_cstr from StringCore with "AST_LOOP_STATEMENT"
    Otherwise if node_type is equal to AST_RETURN_STATEMENT:
        Return proc string_from_cstr from StringCore with "AST_RETURN_STATEMENT"
    Otherwise if node_type is equal to AST_YIELD_STATEMENT:
        Return proc string_from_cstr from StringCore with "AST_YIELD_STATEMENT"
    Otherwise if node_type is equal to AST_BREAK_STATEMENT:
        Return proc string_from_cstr from StringCore with "AST_BREAK_STATEMENT"
    Otherwise if node_type is equal to AST_CONTINUE_STATEMENT:
        Return proc string_from_cstr from StringCore with "AST_CONTINUE_STATEMENT"
    Otherwise if node_type is equal to AST_THROW_STATEMENT:
        Return proc string_from_cstr from StringCore with "AST_THROW_STATEMENT"
    Otherwise if node_type is equal to AST_TRY_STATEMENT:
        Return proc string_from_cstr from StringCore with "AST_TRY_STATEMENT"
    Otherwise if node_type is equal to AST_CATCH_CLAUSE:
        Return proc string_from_cstr from StringCore with "AST_CATCH_CLAUSE"
    Otherwise if node_type is equal to AST_FINALLY_CLAUSE:
        Return proc string_from_cstr from StringCore with "AST_FINALLY_CLAUSE"
    Otherwise if node_type is equal to AST_BLOCK_STATEMENT:
        Return proc string_from_cstr from StringCore with "AST_BLOCK_STATEMENT"
    End If

    Note: Declaration Node Types (3000-3999)
    If node_type is equal to AST_PROCESS_DEFINITION:
        Return proc string_from_cstr from StringCore with "AST_PROCESS_DEFINITION"
    Otherwise if node_type is equal to AST_TYPE_DEFINITION:
        Return proc string_from_cstr from StringCore with "AST_TYPE_DEFINITION"
    Otherwise if node_type is equal to AST_IMPORT_STATEMENT:
        Return proc string_from_cstr from StringCore with "AST_IMPORT_STATEMENT"
    Otherwise if node_type is equal to AST_PROTOCOL_DEFINITION:
        Return proc string_from_cstr from StringCore with "AST_PROTOCOL_DEFINITION"
    Otherwise if node_type is equal to AST_EXTERNAL_DECLARATION:
        Return proc string_from_cstr from StringCore with "AST_EXTERNAL_DECLARATION"
    End If

    Note: Type Node Types (4000-4999)
    If node_type is equal to AST_BASIC_TYPE:
        Return proc string_from_cstr from StringCore with "AST_BASIC_TYPE"
    Otherwise if node_type is equal to AST_GENERIC_TYPE:
        Return proc string_from_cstr from StringCore with "AST_GENERIC_TYPE"
    Otherwise if node_type is equal to AST_UNION_TYPE:
        Return proc string_from_cstr from StringCore with "AST_UNION_TYPE"
    Otherwise if node_type is equal to AST_INTERSECTION_TYPE:
        Return proc string_from_cstr from StringCore with "AST_INTERSECTION_TYPE"
    Otherwise if node_type is equal to AST_FUNCTION_TYPE:
        Return proc string_from_cstr from StringCore with "AST_FUNCTION_TYPE"
    Otherwise if node_type is equal to AST_OPTIONAL_TYPE:
        Return proc string_from_cstr from StringCore with "AST_OPTIONAL_TYPE"
    Otherwise if node_type is equal to AST_ARRAY_TYPE:
        Return proc string_from_cstr from StringCore with "AST_ARRAY_TYPE"
    Otherwise if node_type is equal to AST_TUPLE_TYPE:
        Return proc string_from_cstr from StringCore with "AST_TUPLE_TYPE"
    Otherwise if node_type is equal to AST_RECORD_TYPE:
        Return proc string_from_cstr from StringCore with "AST_RECORD_TYPE"
    Otherwise if node_type is equal to AST_TYPE_ANNOTATION:
        Return proc string_from_cstr from StringCore with "AST_TYPE_ANNOTATION"
    End If

    Note: Pattern Node Types (5000-5999)
    If node_type is equal to AST_IDENTIFIER_PATTERN:
        Return proc string_from_cstr from StringCore with "AST_IDENTIFIER_PATTERN"
    Otherwise if node_type is equal to AST_LITERAL_PATTERN:
        Return proc string_from_cstr from StringCore with "AST_LITERAL_PATTERN"
    Otherwise if node_type is equal to AST_TUPLE_PATTERN:
        Return proc string_from_cstr from StringCore with "AST_TUPLE_PATTERN"
    Otherwise if node_type is equal to AST_RECORD_PATTERN:
        Return proc string_from_cstr from StringCore with "AST_RECORD_PATTERN"
    Otherwise if node_type is equal to AST_WILDCARD_PATTERN:
        Return proc string_from_cstr from StringCore with "AST_WILDCARD_PATTERN"
    Otherwise if node_type is equal to AST_TYPE_PATTERN:
        Return proc string_from_cstr from StringCore with "AST_TYPE_PATTERN"
    Otherwise if node_type is equal to AST_GUARD_PATTERN:
        Return proc string_from_cstr from StringCore with "AST_GUARD_PATTERN"
    Otherwise if node_type is equal to AST_RANGE_PATTERN:
        Return proc string_from_cstr from StringCore with "AST_RANGE_PATTERN"
    Otherwise if node_type is equal to AST_VARIANT_PATTERN:
        Return proc string_from_cstr from StringCore with "AST_VARIANT_PATTERN"
    Otherwise if node_type is equal to AST_ARRAY_PATTERN:
        Return proc string_from_cstr from StringCore with "AST_ARRAY_PATTERN"
    Otherwise if node_type is equal to AST_OR_PATTERN:
        Return proc string_from_cstr from StringCore with "AST_OR_PATTERN"
    Otherwise if node_type is equal to AST_REST_PATTERN:
        Return proc string_from_cstr from StringCore with "AST_REST_PATTERN"
    End If

    Note: Ownership Node Types (6000-6999)
    If node_type is equal to AST_MOVE_EXPRESSION:
        Return proc string_from_cstr from StringCore with "AST_MOVE_EXPRESSION"
    Otherwise if node_type is equal to AST_BORROW_EXPRESSION:
        Return proc string_from_cstr from StringCore with "AST_BORROW_EXPRESSION"
    Otherwise if node_type is equal to AST_MUTABLE_BORROW:
        Return proc string_from_cstr from StringCore with "AST_MUTABLE_BORROW"
    Otherwise if node_type is equal to AST_OWNERSHIP_TRACKING:
        Return proc string_from_cstr from StringCore with "AST_OWNERSHIP_TRACKING"
    End If

    Note: Annotation Node Types (7000-7999)
    If node_type is equal to AST_AI_ANNOTATION:
        Return proc string_from_cstr from StringCore with "AST_AI_ANNOTATION"
    Otherwise if node_type is equal to AST_ANNOTATION_TARGET:
        Return proc string_from_cstr from StringCore with "AST_ANNOTATION_TARGET"
    Otherwise if node_type is equal to AST_ANNOTATION_PARAMETERS:
        Return proc string_from_cstr from StringCore with "AST_ANNOTATION_PARAMETERS"
    End If

    Note: Macro Node Types (8000-8999)
    If node_type is equal to AST_MACRO_DEFINITION:
        Return proc string_from_cstr from StringCore with "AST_MACRO_DEFINITION"
    Otherwise if node_type is equal to AST_MACRO_INVOCATION:
        Return proc string_from_cstr from StringCore with "AST_MACRO_INVOCATION"
    Otherwise if node_type is equal to AST_MACRO_EXPANSION:
        Return proc string_from_cstr from StringCore with "AST_MACRO_EXPANSION"
    End If

    Note: Unknown type
    Return proc string_from_cstr from StringCore with "UNKNOWN"
End Process

Process called "ast_node_debug_print" takes node as Integer, depth as Integer returns Integer:
    Note: Print AST node structure for debugging

    If node is equal to 0:
        Return 1  Note: NULL node, nothing to print
    End If

    Note: Print indentation based on depth
    Let indent_count be 0
    Loop forever:
        If indent_count is greater than or equal to depth:
            Break
        End If

        External call to "write" with 1, "  ", 2  Note: Print 2 spaces for each depth level
        Set indent_count to indent_count plus 1
    End Loop

    Note: Get node type (offset 0)
    Let node_type be proc memory_get_qword from Layout with node, 0

    Note: Get type name string
    Let type_name be proc ast_node_type_to_string with node_type

    Note: Print node type
    Let type_len be proc string_length from StringCore with type_name
    Let type_cstr be proc string_to_cstr from StringCore with type_name
    External call to "write" with 1, type_cstr, type_len

    Note: Get line and column (offsets 8 and 16)
    Let line be proc memory_get_qword from Layout with node, 8
    Let column be proc memory_get_qword from Layout with node, 16

    Note: Print position (line:column)
    External call to "write" with 1, " at ", 4
    Note: Convert line to string and print
    Let line_str be proc integer_to_string from StringCore with line
    Let line_len be proc string_length from StringCore with line_str
    External call to "write" with 1, line_str, line_len
    External call to "write" with 1, ":", 1
    Note: Convert column to string and print
    Let column_str be proc integer_to_string from StringCore with column
    Let column_len be proc string_length from StringCore with column_str
    External call to "write" with 1, column_str, column_len

    Note: Get value (offset 40)
    Let value be proc memory_get_qword from Layout with node, 40

    Note: Print value if present
    If value is not equal to 0:
        External call to "write" with 1, " value=", 7
        Note: Get value type (offset 48)
        Let value_type be proc memory_get_qword from Layout with node, 48

        Note: Format value based on value_type
        Note: VALUE_TYPE_STRING = 1, VALUE_TYPE_INTEGER = 2, VALUE_TYPE_POINTER = 3
        If value_type is equal to 1:
            Note: String value - print directly
            Let value_len be proc string_length from StringCore with value
            External call to "write" with 1, value, value_len
        End If

        If value_type is equal to 2:
            Note: Integer value - convert to string
            Let value_str be proc integer_to_string from StringCore with value
            Let value_str_len be proc string_length from StringCore with value_str
            External call to "write" with 1, value_str, value_str_len
        End If

        If value_type is equal to 3:
            Note: Pointer value - print as hex address
            External call to "write" with 1, "0x", 2
            Let value_str be proc integer_to_hex_string from StringCore with value
            Let value_str_len be proc string_length from StringCore with value_str
            External call to "write" with 1, value_str, value_str_len
        End If
    End If

    Note: Print newline
    External call to "write" with 1, "\n", 1

    Note: Get children list and count (offsets 24 and 32)
    Let children_list be proc memory_get_qword from Layout with node, 24
    Let child_count be proc memory_get_qword from Layout with node, 32

    Note: Recursively print all children with increased depth
    Let index be 0
    Let next_depth be depth plus 1

    Loop forever:
        If index is greater than or equal to child_count:
            Break
        End If

        Let child be proc get from List with children_list, index

        Note: Recursively print child
        proc ast_node_debug_print with child, next_depth

        Set index to index plus 1
    End Loop

    Return 1
End Process