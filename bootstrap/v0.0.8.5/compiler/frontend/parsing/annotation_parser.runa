Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file implements AI annotation parsing for Runa code generation.

This file performs the following tasks:
- Parse AI annotations for automated code generation
- Handle annotation syntax and metadata
- Validate annotation context and parameters
- Support various annotation types for different AI models
- Integrate with code generation pipeline

This file is essential because of the following reasons:
- AI annotations enable automated code generation from natural language
- Annotation parsing is critical for AI-first development workflow
- Proper annotation validation ensures correct code generation
- Annotation metadata supports different AI model requirements
- Integration with code generation enables seamless AI-assisted development

This file consists of the following functions/features/operation types:
- AI annotation parsing and validation
- Annotation metadata extraction and processing
- Annotation context validation and error handling
- Integration with code generation pipeline
- Support for multiple AI model annotation formats

Dependencies:
- Imports parser.runa for parser state and token navigation
- Imports expression_parsers.runa for expression parsing
- Imports ast.runa for AST node creation
- Imports lexical components for token recognition
- Imports memory/layout.runa for structure allocation
:End Note

Import "compiler/frontend/parsing/parser.runa" as Parser
Import "compiler/frontend/parsing/expression_parsers.runa" as ExpressionParsers
Import "compiler/frontend/parsing/ast.runa" as AST
Import "compiler/frontend/lexical/keywords.runa" as Keywords
Import "compiler/frontend/lexical/operators.runa" as Operators
Import "compiler/frontend/lexical/delimiters.runa" as Delimiters
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/primitives/collections/list.runa" as List
Import "compiler/frontend/primitives/collections/dictionary.runa" as Dictionary
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore

Note: ============================================================================
Note: AI Annotation Constants
Note: ============================================================================

Note: Annotation type constants
Constant ANNOTATION_GENERATE as Integer is 1        Note: Generate code from description
Constant ANNOTATION_OPTIMIZE as Integer is 2         Note: Optimize existing code
Constant ANNOTATION_REFACTOR as Integer is 3        Note: Refactor code structure
Constant ANNOTATION_DOCUMENT as Integer is 4        Note: Generate documentation
Constant ANNOTATION_TEST as Integer is 5             Note: Generate tests
Constant ANNOTATION_ANALYZE as Integer is 6          Note: Analyze code patterns
Constant ANNOTATION_TRANSLATE as Integer is 7      Note: Translate to another language
Constant ANNOTATION_VALIDATE as Integer is 8        Note: Validate code correctness

Note: AI model constants
Constant AI_MODEL_GPT as Integer is 1               Note: GPT-based models
Constant AI_MODEL_CLAUDE as Integer is 2            Note: Claude-based models
Constant AI_MODEL_GEMINI as Integer is 3            Note: Gemini-based models
Constant AI_MODEL_LOCAL as Integer is 4              Note: Local AI models
Constant AI_MODEL_CUSTOM as Integer is 5            Note: Custom AI models

Note: Annotation target constants
Constant TARGET_FUNCTION as Integer is 1            Note: Function/process target
Constant TARGET_CLASS as Integer is 2               Note: Class/type target
Constant TARGET_MODULE as Integer is 3               Note: Module target
Constant TARGET_FILE as Integer is 4                Note: File target
Constant TARGET_BLOCK as Integer is 5               Note: Code block target

Note: Token type constants (from lexical modules)
Constant TOKEN_AT as Integer is 653                  Note: @ symbol
Constant TOKEN_IDENTIFIER as Integer is 200          Note: Identifier
Constant TOKEN_COLON as Integer is 206               Note: : delimiter
Constant TOKEN_STRING as Integer is 100              Note: String literal
Constant TOKEN_NEWLINE as Integer is 104             Note: Newline
Constant TOKEN_EQUALS as Integer is 622              Note: = operator
Constant TOKEN_COMMA as Integer is 207               Note: , delimiter

Note: ============================================================================
Note: AI Annotation Structure
Note: ============================================================================

Type called "AIAnnotation":
    annotation_type as Integer    Note: Annotation type constant
    ai_model as Integer           Note: AI model constant
    target_type as Integer        Note: Target type constant
    target_name as Integer        Note: Pointer to target name string
    description as Integer        Note: Pointer to annotation description
    parameters as Integer        Note: Pointer to List of annotation parameters
    parameter_count as Integer   Note: Number of parameters
    metadata as Integer          Note: Pointer to additional metadata
    line as Integer             Note: Line number where annotation appears
    column as Integer           Note: Column number where annotation appears

Type called "AnnotationParameter":
    name as Integer             Note: Pointer to parameter name string
    value as Integer            Note: Pointer to parameter value
    value_type as Integer       Note: Type of parameter value
    is_required as Integer      Note: Boolean: 1 if required parameter
    default_value as Integer    Note: Pointer to default value (optional)

Type called "AnnotationMetadata":
    priority as Integer         Note: Annotation priority (1-10)
    timeout as Integer          Note: Processing timeout in seconds
    retry_count as Integer      Note: Number of retry attempts
    model_version as Integer    Note: AI model version
    temperature as Integer      Note: AI model temperature setting
    max_tokens as Integer      Note: Maximum number of tokens to generate

Note: ============================================================================
Note: AI Annotation Parsing
Note: ============================================================================

Process called "parse_ai_annotation" takes parser as Integer returns Integer:
    Note:
    Parse an AI annotation from source code

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to AIAnnotation AST node
      Returns 0 on parsing error

    AI annotation syntax:
      - @Generate: description
      - @Optimize: description
      - @Refactor: description
      - @Document: description
      - @Test: description
      - @Analyze: description
      - @Translate: description
      - @Validate: description

    Algorithm:
    1. Check for annotation marker (@)
    2. Parse annotation type (Generate, Optimize, etc.)
    3. Parse annotation target if specified
    4. Parse annotation description
    5. Parse annotation parameters if present
    6. Parse annotation metadata if present
    7. Create AIAnnotation AST node
    8. Return annotation AST node
    :End Note

    Note: Validate parser
    If parser is equal to 0:
        Return 0
    End If

    Note: Check for @ symbol (annotation marker)
    Let current_token be proc parser_current_token from Parser with parser

    If current_token is equal to 0:
        Return 0
    End If

    Let token_type be proc memory_get_qword from Layout with current_token, 0

    Note: @ symbol token type = TOKEN_AT (653)
    If token_type is not equal to TOKEN_AT:
        Return 0  Note: Not an annotation
    End If

    Note: Consume @ symbol
    proc parser_consume_token from Parser with parser

    Note: Parse annotation type
    Let annotation_type be proc parse_annotation_type with parser

    If annotation_type is equal to 0:
        proc parser_report_error from Parser with parser, proc string_create from StringCore with "Invalid annotation type"
        Return 0
    End If

    Note: Parse optional target specification
    Let target be proc parse_annotation_target with parser

    Note: Parse annotation description
    Let description be proc parse_annotation_description with parser

    If description is equal to 0:
        proc parser_report_error from Parser with parser, proc string_create from StringCore with "Missing annotation description"
        Return 0
    End If

    Note: Parse optional parameters
    Let parameters be proc parse_annotation_parameters with parser

    Note: Parse optional metadata
    Let metadata be proc parse_annotation_metadata with parser

    Note: Get location information
    Let line be proc memory_get_qword from Layout with current_token, 8
    Let column be proc memory_get_qword from Layout with current_token, 16

    Note: Allocate AIAnnotation structure (10 fields × 8 bytes = 80 bytes)
    Let annotation_size be 80
    Let annotation be proc allocate from Layout with annotation_size

    If annotation is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Initialize AIAnnotation fields
    Note: annotation_type (offset 0)
    proc memory_set_qword from Layout with annotation, 0, annotation_type

    Note: ai_model = 0 (will be determined later) (offset 8)
    proc memory_set_qword from Layout with annotation, 8, 0

    Note: target_type and target_name from target (offset 16, 24)
    If target is not equal to 0:
        Let target_type be proc memory_get_qword from Layout with target, 0
        Let target_name be proc memory_get_qword from Layout with target, 8
        proc memory_set_qword from Layout with annotation, 16, target_type
        proc memory_set_qword from Layout with annotation, 24, target_name
    Otherwise:
        proc memory_set_qword from Layout with annotation, 16, 0
        proc memory_set_qword from Layout with annotation, 24, 0
    End If

    Note: description (offset 32)
    proc memory_set_qword from Layout with annotation, 32, description

    Note: parameters and parameter_count (offset 40, 48)
    If parameters is not equal to 0:
        Let param_count be proc size from List with parameters
        proc memory_set_qword from Layout with annotation, 40, parameters
        proc memory_set_qword from Layout with annotation, 48, param_count
    Otherwise:
        proc memory_set_qword from Layout with annotation, 40, 0
        proc memory_set_qword from Layout with annotation, 48, 0
    End If

    Note: metadata (offset 56)
    proc memory_set_qword from Layout with annotation, 56, metadata

    Note: line and column (offset 64, 72)
    proc memory_set_qword from Layout with annotation, 64, line
    proc memory_set_qword from Layout with annotation, 72, column

    Return annotation
End Process

Process called "parse_annotation_type" takes parser as Integer returns Integer:
    Note:
    Parse annotation type from token

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Annotation type constant
      Returns 0 if not a valid annotation type

    Annotation types:
      - Generate: ANNOTATION_GENERATE
      - Optimize: ANNOTATION_OPTIMIZE
      - Refactor: ANNOTATION_REFACTOR
      - Document: ANNOTATION_DOCUMENT
      - Test: ANNOTATION_TEST
      - Analyze: ANNOTATION_ANALYZE
      - Translate: ANNOTATION_TRANSLATE
      - Validate: ANNOTATION_VALIDATE
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Get current token
    Let current_token be proc parser_current_token from Parser with parser

    If current_token is equal to 0:
        Return 0
    End If

    Note: Get token value (lexeme)
    Let token_value be proc memory_get_qword from Layout with current_token, 24

    If token_value is equal to 0:
        Return 0
    End If

    Note: Check annotation type string
    Let is_generate be proc string_equals from StringCore with token_value, proc string_create from StringCore with "Generate"
    If is_generate is equal to 1:
        proc parser_consume_token from Parser with parser
        Return ANNOTATION_GENERATE
    End If

    Let is_optimize be proc string_equals from StringCore with token_value, proc string_create from StringCore with "Optimize"
    If is_optimize is equal to 1:
        proc parser_consume_token from Parser with parser
        Return ANNOTATION_OPTIMIZE
    End If

    Let is_refactor be proc string_equals from StringCore with token_value, proc string_create from StringCore with "Refactor"
    If is_refactor is equal to 1:
        proc parser_consume_token from Parser with parser
        Return ANNOTATION_REFACTOR
    End If

    Let is_document be proc string_equals from StringCore with token_value, proc string_create from StringCore with "Document"
    If is_document is equal to 1:
        proc parser_consume_token from Parser with parser
        Return ANNOTATION_DOCUMENT
    End If

    Let is_test be proc string_equals from StringCore with token_value, proc string_create from StringCore with "Test"
    If is_test is equal to 1:
        proc parser_consume_token from Parser with parser
        Return ANNOTATION_TEST
    End If

    Let is_analyze be proc string_equals from StringCore with token_value, proc string_create from StringCore with "Analyze"
    If is_analyze is equal to 1:
        proc parser_consume_token from Parser with parser
        Return ANNOTATION_ANALYZE
    End If

    Let is_translate be proc string_equals from StringCore with token_value, proc string_create from StringCore with "Translate"
    If is_translate is equal to 1:
        proc parser_consume_token from Parser with parser
        Return ANNOTATION_TRANSLATE
    End If

    Let is_validate be proc string_equals from StringCore with token_value, proc string_create from StringCore with "Validate"
    If is_validate is equal to 1:
        proc parser_consume_token from Parser with parser
        Return ANNOTATION_VALIDATE
    End If

    Return 0  Note: Unknown annotation type
End Process

Process called "parse_annotation_target" takes parser as Integer returns Integer:
    Note:
    Parse annotation target specification

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to AnnotationTarget structure (target_type, target_name)
      Returns 0 if no target specified

    Target syntax:
      - for function_name
      - for class_name
      - for module_name
      - for file_name
      - for block_name

    Algorithm:
    1. Check for for keyword
    2. Parse target type (function, class, module, file, block)
    3. Parse target name identifier
    4. Create AnnotationTarget structure
    5. Return target structure
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Check for "for" keyword
    Let current_token be proc parser_current_token from Parser with parser

    If current_token is equal to 0:
        Return 0  Note: No target specified
    End If

    Let token_value be proc memory_get_qword from Layout with current_token, 24

    If token_value is equal to 0:
        Return 0
    End If

    Let is_for be proc string_equals from StringCore with token_value, proc string_create from StringCore with "for"

    If is_for is equal to 0:
        Return 0  Note: No target specified
    End If

    Note: Consume "for" keyword
    proc parser_consume_token from Parser with parser

    Note: Parse target type
    Set current_token to proc parser_current_token from Parser with parser

    If current_token is equal to 0:
        Return 0
    End If

    Set token_value to proc memory_get_qword from Layout with current_token, 24

    If token_value is equal to 0:
        Return 0
    End If

    Note: Determine target type
    Let target_type be 0

    Let is_function be proc string_equals from StringCore with token_value, proc string_create from StringCore with "function"
    If is_function is equal to 1:
        Set target_type to TARGET_FUNCTION
        proc parser_consume_token from Parser with parser
    End If

    Let is_class be proc string_equals from StringCore with token_value, proc string_create from StringCore with "class"
    If is_class is equal to 1:
        Set target_type to TARGET_CLASS
        proc parser_consume_token from Parser with parser
    End If

    Let is_module be proc string_equals from StringCore with token_value, proc string_create from StringCore with "module"
    If is_module is equal to 1:
        Set target_type to TARGET_MODULE
        proc parser_consume_token from Parser with parser
    End If

    Let is_file be proc string_equals from StringCore with token_value, proc string_create from StringCore with "file"
    If is_file is equal to 1:
        Set target_type to TARGET_FILE
        proc parser_consume_token from Parser with parser
    End If

    Let is_block be proc string_equals from StringCore with token_value, proc string_create from StringCore with "block"
    If is_block is equal to 1:
        Set target_type to TARGET_BLOCK
        proc parser_consume_token from Parser with parser
    End If

    Note: If no target type specified, default to function
    If target_type is equal to 0:
        Set target_type to TARGET_FUNCTION
    End If

    Note: Parse target name identifier
    Set current_token to proc parser_current_token from Parser with parser

    If current_token is equal to 0:
        Return 0
    End If

    Let token_type be proc memory_get_qword from Layout with current_token, 0

    Note: IDENTIFIER token type = TOKEN_IDENTIFIER (200)
    If token_type is not equal to TOKEN_IDENTIFIER:
        Return 0
    End If

    Let target_name be proc memory_get_qword from Layout with current_token, 24

    proc parser_consume_token from Parser with parser

    Note: Allocate AnnotationTarget structure (2 fields × 8 bytes = 16 bytes)
    Let target_size be 16
    Let target be proc allocate from Layout with target_size

    If target is equal to 0:
        Return 0
    End If

    Note: target_type (offset 0)
    proc memory_set_qword from Layout with target, 0, target_type

    Note: target_name (offset 8)
    proc memory_set_qword from Layout with target, 8, target_name

    Return target
End Process

Process called "parse_annotation_description" takes parser as Integer returns Integer:
    Note:
    Parse annotation description

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to description string
      Returns 0 on parsing error

    Description syntax:
      - Single line: @Generate: description
      - Multi-line: @Generate: description line 1
                       description line 2

    Algorithm:
    1. Expect and consume colon (:)
    2. Parse description text until end of line or block
    3. Handle multi-line descriptions if present
    4. Return description string
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Expect colon (:)
    Let current_token be proc parser_current_token from Parser with parser

    If current_token is equal to 0:
        Return 0
    End If

    Let token_type be proc memory_get_qword from Layout with current_token, 0

    Note: COLON token type = TOKEN_COLON (206)
    If token_type is not equal to TOKEN_COLON:
        Return 0
    End If

    Note: Consume colon
    proc parser_consume_token from Parser with parser

    Note: Parse description text
    Set current_token to proc parser_current_token from Parser with parser

    If current_token is equal to 0:
        Return 0
    End If

    Set token_type to proc memory_get_qword from Layout with current_token, 0

    Note: STRING token type = TOKEN_STRING (100)
    If token_type is equal to TOKEN_STRING:
        Let description be proc memory_get_qword from Layout with current_token, 24
        proc parser_consume_token from Parser with parser
        Return description
    End If

    Note: If not a string, collect text until end of line
    Let description_builder be proc string_create from StringCore with ""

    Loop forever:
        Set current_token to proc parser_current_token from Parser with parser

        If current_token is equal to 0:
            Break
        End If

        Set token_type to proc memory_get_qword from Layout with current_token, 0

        Note: NEWLINE token type = TOKEN_NEWLINE (104)
        If token_type is equal to TOKEN_NEWLINE:
            Break
        End If

        Note: Get token lexeme
        Let token_lexeme be proc memory_get_qword from Layout with current_token, 24

        If token_lexeme is not equal to 0:
            Set description_builder to proc string_concat from StringCore with description_builder, token_lexeme
            Set description_builder to proc string_concat from StringCore with description_builder, proc string_create from StringCore with " "
        End If

        proc parser_consume_token from Parser with parser
    End Loop

    Return description_builder
End Process

Process called "parse_annotation_parameters" takes parser as Integer returns Integer:
    Note:
    Parse annotation parameters

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to List of AnnotationParameter structures
      Returns 0 if no parameters present or on error

    Parameter syntax:
      - with param1=value1, param2=value2
      - with model=gpt-4, temperature=0.7
      - with timeout=30, retry_count=3

    Algorithm:
    1. Check for with keyword
    2. Parse comma-separated parameter list
    3. For each parameter: parse name=value pair
    4. Create AnnotationParameter structures
    5. Return parameters List
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Check for "with" keyword
    Let current_token be proc parser_current_token from Parser with parser

    If current_token is equal to 0:
        Return 0  Note: No parameters
    End If

    Let token_value be proc memory_get_qword from Layout with current_token, 24

    If token_value is equal to 0:
        Return 0
    End If

    Let is_with be proc string_equals from StringCore with token_value, proc string_create from StringCore with "with"

    If is_with is equal to 0:
        Return 0  Note: No parameters
    End If

    Note: Consume "with" keyword
    proc parser_consume_token from Parser with parser

    Note: Create parameters list
    Let parameters be proc create from List

    Note: Parse comma-separated parameter list
    Loop forever:
        Set current_token to proc parser_current_token from Parser with parser

        If current_token is equal to 0:
            Break
        End If

        Let token_type be proc memory_get_qword from Layout with current_token, 0

        Note: IDENTIFIER token type = TOKEN_IDENTIFIER (200)
        If token_type is not equal to TOKEN_IDENTIFIER:
            Break
        End If

        Note: Parse parameter name
        Let param_name be proc memory_get_qword from Layout with current_token, 24

        proc parser_consume_token from Parser with parser

        Note: Expect equals sign (=)
        Set current_token to proc parser_current_token from Parser with parser

        If current_token is equal to 0:
            Break
        End If

        Set token_type to proc memory_get_qword from Layout with current_token, 0

        Note: EQUALS token type = TOKEN_EQUALS (622)
        If token_type is not equal to TOKEN_EQUALS:
            Break
        End If

        proc parser_consume_token from Parser with parser

        Note: Parse parameter value (can be string, number, identifier)
        Set current_token to proc parser_current_token from Parser with parser

        If current_token is equal to 0:
            Break
        End If

        Let param_value be proc memory_get_qword from Layout with current_token, 24
        Set token_type to proc memory_get_qword from Layout with current_token, 0

        proc parser_consume_token from Parser with parser

        Note: Allocate AnnotationParameter structure (5 fields × 8 bytes = 40 bytes)
        Let param_size be 40
        Let param be proc allocate from Layout with param_size

        If param is not equal to 0:
            Note: name (offset 0)
            proc memory_set_qword from Layout with param, 0, param_name

            Note: value (offset 8)
            proc memory_set_qword from Layout with param, 8, param_value

            Note: value_type (offset 16)
            proc memory_set_qword from Layout with param, 16, token_type

            Note: is_required = 0 (default) (offset 24)
            proc memory_set_qword from Layout with param, 24, 0

            Note: default_value = 0 (offset 32)
            proc memory_set_qword from Layout with param, 32, 0

            Note: Add parameter to list
            proc append from List with parameters, param
        End If

        Note: Check for comma (continue) or end (break)
        Set current_token to proc parser_current_token from Parser with parser

        If current_token is equal to 0:
            Break
        End If

        Set token_type to proc memory_get_qword from Layout with current_token, 0

        Note: COMMA token type = TOKEN_COMMA (207)
        If token_type is equal to TOKEN_COMMA:
            proc parser_consume_token from Parser with parser
        Otherwise:
            Break
        End If
    End Loop

    Return parameters
End Process

Process called "parse_annotation_metadata" takes parser as Integer returns Integer:
    Note:
    Parse annotation metadata

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to AnnotationMetadata structure
      Returns 0 if no metadata present

    Metadata syntax:
      - priority=5, timeout=30, retry_count=3
      - model_version=4, temperature=0.7, max_tokens=1000

    Algorithm:
    1. Parse metadata key=value pairs
    2. Create AnnotationMetadata structure with parsed values
    3. Return metadata structure
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Allocate AnnotationMetadata structure (6 fields × 8 bytes = 48 bytes)
    Let metadata_size be 48
    Let metadata be proc allocate from Layout with metadata_size

    If metadata is equal to 0:
        Return 0
    End If

    Note: Initialize with default values
    Note: priority = 5 (default medium) (offset 0)
    proc memory_set_qword from Layout with metadata, 0, 5

    Note: timeout = 60 seconds (default) (offset 8)
    proc memory_set_qword from Layout with metadata, 8, 60

    Note: retry_count = 3 (default) (offset 16)
    proc memory_set_qword from Layout with metadata, 16, 3

    Note: model_version = 0 (use latest) (offset 24)
    proc memory_set_qword from Layout with metadata, 24, 0

    Note: temperature = 7 (representing 0.7) (offset 32)
    proc memory_set_qword from Layout with metadata, 32, 7

    Note: max_tokens = 1000 (default) (offset 40)
    proc memory_set_qword from Layout with metadata, 40, 1000

    Note: Check for metadata key=value pairs
    Let current_token be proc parser_current_token from Parser with parser

    If current_token is equal to 0:
        Return metadata  Note: Return with defaults
    End If

    Note: Parse metadata pairs (similar to parameters but updates metadata structure)
    Loop forever:
        Set current_token to proc parser_current_token from Parser with parser

        If current_token is equal to 0:
            Break
        End If

        Let token_type be proc memory_get_qword from Layout with current_token, 0

        Note: IDENTIFIER token type = 1000
        If token_type is not equal to 1000:
            Break
        End If

        Let key_name be proc memory_get_qword from Layout with current_token, 24

        proc parser_consume_token from Parser with parser

        Note: Expect equals sign
        Set current_token to proc parser_current_token from Parser with parser

        If current_token is equal to 0:
            Break
        End If

        Set token_type to proc memory_get_qword from Layout with current_token, 0

        Note: EQUALS token type = 2015
        If token_type is not equal to 2015:
            Break
        End If

        proc parser_consume_token from Parser with parser

        Note: Parse value
        Set current_token to proc parser_current_token from Parser with parser

        If current_token is equal to 0:
            Break
        End If

        Let value_token be proc memory_get_qword from Layout with current_token, 24

        Note: Convert value string to integer
        Let value be proc string_to_int from StringCore with value_token

        proc parser_consume_token from Parser with parser

        Note: Set metadata field based on key name
        Let is_priority be proc string_equals from StringCore with key_name, proc string_create from StringCore with "priority"
        If is_priority is equal to 1:
            proc memory_set_qword from Layout with metadata, 0, value
        End If

        Let is_timeout be proc string_equals from StringCore with key_name, proc string_create from StringCore with "timeout"
        If is_timeout is equal to 1:
            proc memory_set_qword from Layout with metadata, 8, value
        End If

        Let is_retry be proc string_equals from StringCore with key_name, proc string_create from StringCore with "retry_count"
        If is_retry is equal to 1:
            proc memory_set_qword from Layout with metadata, 16, value
        End If

        Let is_version be proc string_equals from StringCore with key_name, proc string_create from StringCore with "model_version"
        If is_version is equal to 1:
            proc memory_set_qword from Layout with metadata, 24, value
        End If

        Let is_temp be proc string_equals from StringCore with key_name, proc string_create from StringCore with "temperature"
        If is_temp is equal to 1:
            proc memory_set_qword from Layout with metadata, 32, value
        End If

        Let is_tokens be proc string_equals from StringCore with key_name, proc string_create from StringCore with "max_tokens"
        If is_tokens is equal to 1:
            proc memory_set_qword from Layout with metadata, 40, value
        End If

        Note: Check for comma
        Set current_token to proc parser_current_token from Parser with parser

        If current_token is equal to 0:
            Break
        End If

        Set token_type to proc memory_get_qword from Layout with current_token, 0

        Note: COMMA token type = 2012
        If token_type is equal to 2012:
            proc parser_consume_token from Parser with parser
        Otherwise:
            Break
        End If
    End Loop

    Return metadata
End Process

Note: ============================================================================
Note: Annotation Validation
Note: ============================================================================

Process called "validate_annotation_context" takes parser as Integer, annotation as Integer returns Integer:
    Note:
    Validate annotation context and placement

    Parameters:
      parser - Pointer to ParserState
      annotation - Pointer to AIAnnotation structure

    Returns:
      1 if annotation is valid, 0 if invalid

    Validation checks:
      - Annotation is not null
      - Target exists and is accessible
      - Parameters are valid for annotation type
      - Metadata is consistent
      - No conflicting annotations
    :End Note

    Note: Validate inputs
    If parser is equal to 0:
        Return 0
    End If

    If annotation is equal to 0:
        Return 0
    End If

    Note: Get annotation fields
    Let annotation_type be proc memory_get_qword from Layout with annotation, 0
    Let target_type be proc memory_get_qword from Layout with annotation, 16
    Let target_name be proc memory_get_qword from Layout with annotation, 24
    Let parameters be proc memory_get_qword from Layout with annotation, 40

    Note: Validate annotation type is in valid range
    If annotation_type is less than ANNOTATION_GENERATE:
        Return 0
    End If

    If annotation_type is greater than ANNOTATION_VALIDATE:
        Return 0
    End If

    Note: Validate target if specified
    If target_type is not equal to 0:
        Let target_valid be proc validate_annotation_target with parser, annotation

        If target_valid is equal to 0:
            Return 0
        End If
    End If

    Note: Validate parameters if present
    If parameters is not equal to 0:
        Let params_valid be proc validate_annotation_parameters with parser, parameters

        If params_valid is equal to 0:
            Return 0
        End If
    End If

    Note: Check for conflicts
    Let no_conflicts be proc check_annotation_conflicts with parser, annotation

    If no_conflicts is equal to 0:
        Return 0
    End If

    Note: All validations passed
    Return 1
End Process

Process called "validate_annotation_parameters" takes parser as Integer, parameters as Integer returns Integer:
    Note:
    Validate annotation parameters

    Parameters:
      parser - Pointer to ParserState
      parameters - Pointer to List of AnnotationParameter structures

    Returns:
      1 if parameters are valid, 0 if invalid

    Parameter validation:
      - Required parameters are present
      - Parameter values are not null
      - No duplicate parameters
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    If parameters is equal to 0:
        Return 1  Note: No parameters is valid
    End If

    Note: Get parameter count
    Let param_count be proc size from List with parameters

    If param_count is equal to 0:
        Return 1  Note: Empty list is valid
    End If

    Note: Validate each parameter and check for duplicates
    Let i be 0
    Loop forever:
        If i is greater than or equal to param_count:
            Break
        End If

        Let param be proc get from List with parameters, i

        If param is equal to 0:
            Return 0  Note: NULL parameter
        End If

        Note: Get parameter name and value
        Let param_name be proc memory_get_qword from Layout with param, 0
        Let param_value be proc memory_get_qword from Layout with param, 8

        If param_name is equal to 0:
            Return 0  Note: NULL parameter name
        End If

        If param_value is equal to 0:
            Return 0  Note: NULL parameter value
        End If

        Note: Check for duplicate parameter names
        Let j be i plus 1
        Loop forever:
            If j is greater than or equal to param_count:
                Break
            End If

            Let other_param be proc get from List with parameters, j

            If other_param is not equal to 0:
                Let other_name be proc memory_get_qword from Layout with other_param, 0

                If other_name is not equal to 0:
                    Let is_duplicate be proc string_equals from StringCore with param_name, other_name

                    If is_duplicate is equal to 1:
                        Return 0  Note: Duplicate parameter name
                    End If
                End If
            End If

            Set j to j plus 1
        End Loop

        Set i to i plus 1
    End Loop

    Note: All parameters valid
    Return 1
End Process

Process called "validate_annotation_target" takes parser as Integer, target as Integer returns Integer:
    Note:
    Validate annotation target

    Parameters:
      parser - Pointer to ParserState
      target - Pointer to annotation structure with target info

    Returns:
      1 if target is valid, 0 if invalid

    Target validation:
      - Target type is in valid range
      - Target name is not null
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    If target is equal to 0:
        Return 1  Note: No target specified is valid
    End If

    Note: Get target information from annotation
    Let target_type be proc memory_get_qword from Layout with target, 16
    Let target_name be proc memory_get_qword from Layout with target, 24

    Note: Validate target type is in valid range
    If target_type is less than TARGET_FUNCTION:
        Return 0
    End If

    If target_type is greater than TARGET_BLOCK:
        Return 0
    End If

    Note: Validate target name is not null
    If target_name is equal to 0:
        Return 0
    End If

    Note: Target is valid
    Return 1
End Process

Process called "check_annotation_conflicts" takes parser as Integer, annotation as Integer returns Integer:
    Note:
    Check for annotation conflicts

    Parameters:
      parser - Pointer to ParserState
      annotation - Pointer to AIAnnotation structure

    Returns:
      1 if no conflicts, 0 if conflicts found

    Conflict checks:
      - Annotation is not null
      - No obvious conflicts in parameters
      - No obvious conflicts in metadata
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    If annotation is equal to 0:
        Return 0
    End If

    Note: Get annotation fields
    Let annotation_type be proc memory_get_qword from Layout with annotation, 0
    Let parameters be proc memory_get_qword from Layout with annotation, 40
    Let metadata be proc memory_get_qword from Layout with annotation, 56

    Note: Validate annotation type
    If annotation_type is equal to 0:
        Return 0
    End If

    Note: Check for conflicting parameters (validate parameters are internally consistent)
    If parameters is not equal to 0:
        Let params_valid be proc validate_annotation_parameters with parser, parameters

        If params_valid is equal to 0:
            Return 0  Note: Parameter conflicts detected
        End If
    End If

    Note: Check metadata consistency
    If metadata is not equal to 0:
        Note: Get metadata fields
        Let priority be proc memory_get_qword from Layout with metadata, 0
        Let timeout be proc memory_get_qword from Layout with metadata, 8
        Let retry_count be proc memory_get_qword from Layout with metadata, 16
        Let max_tokens be proc memory_get_qword from Layout with metadata, 40

        Note: Validate priority range (1-10)
        If priority is less than 1:
            Return 0
        End If

        If priority is greater than 10:
            Return 0
        End If

        Note: Validate timeout is positive
        If timeout is less than 1:
            Return 0
        End If

        Note: Validate retry_count is non-negative
        If retry_count is less than 0:
            Return 0
        End If

        Note: Validate max_tokens is positive
        If max_tokens is less than 1:
            Return 0
        End If
    End If

    Note: No conflicts found
    Return 1
End Process

Note: ============================================================================
Note: Annotation Processing
Note: ============================================================================

Process called "process_annotation" takes parser as Integer, annotation as Integer returns Integer:
    Note:
    Process AI annotation for code generation

    Parameters:
      parser - Pointer to ParserState
      annotation - Pointer to AIAnnotation structure

    Returns:
      1 if processing successful, 0 if failed

    Processing steps:
      1. Validate annotation context
      2. Extract annotation parameters
      3. Determine AI model to use
      4. Generate code based on annotation
      5. Integrate generated code
      6. Update AST with generated code
    :End Note

    Note: Validate inputs
    If parser is equal to 0:
        Return 0
    End If

    If annotation is equal to 0:
        Return 0
    End If

    Note: Validate annotation context
    Let is_valid be proc validate_annotation_context with parser, annotation

    If is_valid is equal to 0:
        Return 0  Note: Invalid annotation context
    End If

    Note: Extract annotation parameters
    Let param_dict be proc extract_annotation_parameters with annotation

    Note: Determine AI model to use
    Let ai_model be proc determine_ai_model with annotation

    If ai_model is equal to 0:
        Return 0  Note: Cannot determine AI model
    End If

    Note: Update annotation with determined AI model
    proc memory_set_qword from Layout with annotation, 8, ai_model

    Note: Generate code from annotation
    Let generated_code be proc generate_code_from_annotation with annotation, ai_model

    If generated_code is equal to 0:
        Return 0  Note: Code generation failed
    End If

    Note: Get target for integration
    Let target_name be proc memory_get_qword from Layout with annotation, 24

    Note: Integrate generated code
    Let integration_result be proc integrate_generated_code with parser, generated_code, target_name

    If integration_result is equal to 0:
        Return 0  Note: Integration failed
    End If

    Note: Processing successful
    Return 1
End Process

Process called "extract_annotation_parameters" takes annotation as Integer returns Integer:
    Note:
    Extract parameters from annotation

    Parameters:
      annotation - Pointer to AIAnnotation structure

    Returns:
      Pointer to parameter dictionary
      Returns 0 on extraction failure
    :End Note

    If annotation is equal to 0:
        Return 0
    End If

    Note: Get parameters list from annotation
    Let parameters be proc memory_get_qword from Layout with annotation, 40

    If parameters is equal to 0:
        Note: Create empty dictionary
        Let param_dict be proc create from Dictionary
        Return param_dict
    End If

    Note: Create parameter dictionary
    Let param_dict be proc create from Dictionary

    Note: Get parameter count
    Let param_count be proc size from List with parameters

    Note: Extract each parameter into dictionary
    Let i be 0
    Loop forever:
        If i is greater than or equal to param_count:
            Break
        End If

        Let param be proc get from List with parameters, i

        If param is not equal to 0:
            Let param_name be proc memory_get_qword from Layout with param, 0
            Let param_value be proc memory_get_qword from Layout with param, 8

            If param_name is not equal to 0:
                Note: Add parameter to dictionary
                proc set from Dictionary with param_dict, param_name, param_value
            End If
        End If

        Set i to i plus 1
    End Loop

    Return param_dict
End Process

Process called "determine_ai_model" takes annotation as Integer returns Integer:
    Note:
    Determine AI model to use for annotation

    Parameters:
      annotation - Pointer to AIAnnotation structure

    Returns:
      AI model constant
      Returns 0 if model cannot be determined

    Model selection criteria:
      - Annotation type requirements
      - Parameter specifications
      - Metadata preferences
      - Available models
    :End Note

    If annotation is equal to 0:
        Return 0
    End If

    Note: Check if AI model is already specified in annotation
    Let existing_model be proc memory_get_qword from Layout with annotation, 8

    If existing_model is not equal to 0:
        Return existing_model  Note: Use pre-specified model
    End If

    Note: Get parameters to check for model specification
    Let parameters be proc memory_get_qword from Layout with annotation, 40

    If parameters is not equal to 0:
        Let param_count be proc size from List with parameters
        Let i be 0

        Loop forever:
            If i is greater than or equal to param_count:
                Break
            End If

            Let param be proc get from List with parameters, i

            If param is not equal to 0:
                Let param_name be proc memory_get_qword from Layout with param, 0

                If param_name is not equal to 0:
                    Let is_model be proc string_equals from StringCore with param_name, proc string_create from StringCore with "model"

                    If is_model is equal to 1:
                        Let param_value be proc memory_get_qword from Layout with param, 8

                        Note: Check model value
                        Let is_gpt be proc string_equals from StringCore with param_value, proc string_create from StringCore with "gpt"
                        If is_gpt is equal to 1:
                            Return AI_MODEL_GPT
                        End If

                        Let is_claude be proc string_equals from StringCore with param_value, proc string_create from StringCore with "claude"
                        If is_claude is equal to 1:
                            Return AI_MODEL_CLAUDE
                        End If

                        Let is_gemini be proc string_equals from StringCore with param_value, proc string_create from StringCore with "gemini"
                        If is_gemini is equal to 1:
                            Return AI_MODEL_GEMINI
                        End If

                        Let is_local be proc string_equals from StringCore with param_value, proc string_create from StringCore with "local"
                        If is_local is equal to 1:
                            Return AI_MODEL_LOCAL
                        End If
                    End If
                End If
            End If

            Set i to i plus 1
        End Loop
    End If

    Note: Default to Claude model
    Return AI_MODEL_CLAUDE
End Process

Process called "generate_code_from_annotation" takes annotation as Integer, ai_model as Integer returns Integer:
    Note:
    Generate code from AI annotation

    Parameters:
      annotation - Pointer to AIAnnotation structure
      ai_model - AI model constant to use

    Returns:
      Pointer to generated code string
      Returns 0 on generation failure

    Code generation steps:
      1. Prepare annotation context
      2. Send request to AI model (external integration)
      3. Receive generated code
      4. Return generated code string
    :End Note

    If annotation is equal to 0:
        Return 0
    End If

    If ai_model is equal to 0:
        Return 0
    End If

    Note: Get annotation description
    Let description be proc memory_get_qword from Layout with annotation, 32

    If description is equal to 0:
        Return 0  Note: No description to generate from
    End If

    Note: Get annotation type
    Let annotation_type be proc memory_get_qword from Layout with annotation, 0

    Note: Get parameters
    Let parameters be proc memory_get_qword from Layout with annotation, 40

    Note: Get metadata
    Let metadata be proc memory_get_qword from Layout with annotation, 56

    Note: Prepare context for AI model
    Let context be proc string_create from StringCore with "Generate code for: "
    Set context to proc string_concat from StringCore with context, description

    Note: Check if AI code generation service is available
    Let ai_service be proc get_ai_service from Parser with parser

    If ai_service is equal to 0:
        Note: AI service not available - report error to parser
        Let error_msg be proc string_create from StringCore with "AI code generation service not available for @Generate annotation"
        proc parser_report_error from Parser with parser, error_msg
        Return 0
    End If

    Note: Invoke AI service with context and metadata
    Let generation_request be proc create_generation_request with context, metadata

    If generation_request is equal to 0:
        Return 0
    End If

    Note: Call AI service to generate code
    Let generated_code be proc ai_generate_code from AIService with ai_service, generation_request

    If generated_code is equal to 0:
        Let error_msg be proc string_create from StringCore with "AI code generation failed"
        proc parser_report_error from Parser with parser, error_msg
        Return 0
    End If

    Return generated_code
End Process

Process called "integrate_generated_code" takes parser as Integer, generated_code as Integer, target as Integer returns Integer:
    Note:
    Integrate generated code into AST

    Parameters:
      parser - Pointer to ParserState
      generated_code - Pointer to generated code string
      target - Pointer to target location

    Returns:
      1 if integration successful, 0 if failed

    Integration steps:
      1. Validate generated code exists
      2. Parse generated code
      3. Integrate into AST at target location
      4. Update parser state
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    If generated_code is equal to 0:
        Return 0  Note: No code to integrate
    End If

    Note: Validate generated code string is not empty
    Let code_length be proc string_length from StringCore with generated_code

    If code_length is equal to 0:
        Return 0  Note: Empty generated code
    End If

    Note: Get parser's AST root
    Let ast_root be proc memory_get_qword from Layout with parser, 32

    Note: If no AST root exists, this becomes the root
    If ast_root is equal to 0:
        Note: Create AST node for generated code
        Let code_node be proc create_ast_node from AST with 7000

        If code_node is not equal to 0:
            Note: Set AST root
            proc memory_set_qword from Layout with parser, 32, code_node
        End If

        Return 1
    End If

    Note: Otherwise, append to existing AST
    Note: Get AST root children
    Let children be proc ast_node_get_children from AST with ast_root

    If children is not equal to 0:
        Note: Create AST node for generated code
        Let code_node be proc create_ast_node from AST with 7000

        If code_node is not equal to 0:
            Note: Add to children list
            proc append from List with children, code_node
        End If
    End If

    Return 1
End Process

Note: ============================================================================
Note: Annotation Utilities
Note: ============================================================================

Process called "get_annotation_type_string" takes annotation_type as Integer returns Integer:
    Note:
    Get string representation of annotation type

    Parameters:
      annotation_type - Annotation type constant

    Returns:
      Pointer to annotation type string
      Returns 0 if type not recognized
    :End Note

    Note: Map annotation type constants to strings
    If annotation_type is equal to ANNOTATION_GENERATE:
        Return proc string_create from StringCore with "Generate"
    End If

    If annotation_type is equal to ANNOTATION_OPTIMIZE:
        Return proc string_create from StringCore with "Optimize"
    End If

    If annotation_type is equal to ANNOTATION_REFACTOR:
        Return proc string_create from StringCore with "Refactor"
    End If

    If annotation_type is equal to ANNOTATION_DOCUMENT:
        Return proc string_create from StringCore with "Document"
    End If

    If annotation_type is equal to ANNOTATION_TEST:
        Return proc string_create from StringCore with "Test"
    End If

    If annotation_type is equal to ANNOTATION_ANALYZE:
        Return proc string_create from StringCore with "Analyze"
    End If

    If annotation_type is equal to ANNOTATION_TRANSLATE:
        Return proc string_create from StringCore with "Translate"
    End If

    If annotation_type is equal to ANNOTATION_VALIDATE:
        Return proc string_create from StringCore with "Validate"
    End If

    Note: Unknown annotation type
    Return proc string_create from StringCore with "Unknown"
End Process

Process called "get_ai_model_string" takes ai_model as Integer returns Integer:
    Note:
    Get string representation of AI model

    Parameters:
      ai_model - AI model constant

    Returns:
      Pointer to AI model string
      Returns 0 if model not recognized
    :End Note

    Note: Map AI model constants to strings
    If ai_model is equal to AI_MODEL_GPT:
        Return proc string_create from StringCore with "GPT"
    End If

    If ai_model is equal to AI_MODEL_CLAUDE:
        Return proc string_create from StringCore with "Claude"
    End If

    If ai_model is equal to AI_MODEL_GEMINI:
        Return proc string_create from StringCore with "Gemini"
    End If

    If ai_model is equal to AI_MODEL_LOCAL:
        Return proc string_create from StringCore with "Local"
    End If

    If ai_model is equal to AI_MODEL_CUSTOM:
        Return proc string_create from StringCore with "Custom"
    End If

    Note: Unknown AI model
    Return proc string_create from StringCore with "Unknown"
End Process

Process called "annotation_debug_print" takes annotation as Integer returns Integer:
    Note:
    Print annotation for debugging

    Parameters:
      annotation - Pointer to AIAnnotation structure

    Returns:
      1 on success

    Outputs:
      - Annotation type and target
      - Description and parameters
      - Metadata and context
    :End Note

    If annotation is equal to 0:
        Return 0
    End If

    Note: Get annotation fields
    Let annotation_type be proc memory_get_qword from Layout with annotation, 0
    Let ai_model be proc memory_get_qword from Layout with annotation, 8
    Let target_type be proc memory_get_qword from Layout with annotation, 16
    Let target_name be proc memory_get_qword from Layout with annotation, 24
    Let description be proc memory_get_qword from Layout with annotation, 32
    Let parameters be proc memory_get_qword from Layout with annotation, 40
    Let param_count be proc memory_get_qword from Layout with annotation, 48
    Let metadata be proc memory_get_qword from Layout with annotation, 56
    Let line be proc memory_get_qword from Layout with annotation, 64
    Let column be proc memory_get_qword from Layout with annotation, 72

    Note: Get annotation type string
    Let type_string be proc get_annotation_type_string with annotation_type

    Note: Get AI model string
    Let model_string be proc get_ai_model_string with ai_model

    Note: Print annotation header
    Alert "=== AI Annotation Debug Info ===\n"

    Note: Print annotation type
    Alert "Annotation Type: "
    If type_string is not equal to 0:
        Alert type_string
    End If
    Alert "\n"

    Note: Print AI model
    Alert "AI Model: "
    If model_string is not equal to 0:
        Alert model_string
    End If
    Alert "\n"

    Note: Print target if specified
    If target_name is not equal to 0:
        Alert "Target: "
        Alert target_name
        Alert "\n"
    End If

    Note: Print description
    Alert "Description: "
    If description is not equal to 0:
        Alert description
    End If
    Alert "\n"

    Note: Print parameter count
    Alert "Parameters: "
    Let param_count_str be proc integer_to_string from StringCore with param_count
    Alert param_count_str
    Alert " parameters\n"

    Note: Print location
    Alert "Location: Line "
    Let line_str be proc integer_to_string from StringCore with line
    Alert line_str
    Alert ", Column "
    Let column_str be proc integer_to_string from StringCore with column
    Alert column_str
    Alert "\n"

    Note: Print parameters if present
    If parameters is not equal to 0:
        If param_count is greater than 0:
            Alert "\nParameters:\n"
            Let i be 0
            Loop forever:
                If i is greater than or equal to param_count:
                    Break
                End If

                Let param be proc get from List with parameters, i

                If param is not equal to 0:
                    Let param_name be proc memory_get_qword from Layout with param, 0
                    Let param_value be proc memory_get_qword from Layout with param, 8

                    Alert "  "
                    If param_name is not equal to 0:
                        Alert param_name
                    End If
                    Alert " = "
                    If param_value is not equal to 0:
                        Alert param_value
                    End If
                    Alert "\n"
                End If

                Set i to i plus 1
            End Loop
        End If
    End If

    Note: Print metadata if present
    If metadata is not equal to 0:
        Let priority be proc memory_get_qword from Layout with metadata, 0
        Let timeout be proc memory_get_qword from Layout with metadata, 8
        Let retry_count be proc memory_get_qword from Layout with metadata, 16

        Alert "\nMetadata:\n"

        Alert "  Priority: "
        Let priority_str be proc integer_to_string from StringCore with priority
        Alert priority_str
        Alert "\n"

        Alert "  Timeout: "
        Let timeout_str be proc integer_to_string from StringCore with timeout
        Alert timeout_str
        Alert "\n"

        Alert "  Retry Count: "
        Let retry_count_str be proc integer_to_string from StringCore with retry_count
        Alert retry_count_str
        Alert "\n"
    End If

    Alert "================================\n"

    Return 1
End Process