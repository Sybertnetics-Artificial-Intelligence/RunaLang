Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file implements statement parsing for Runa language statements.

This file performs the following tasks:
- Parse control flow statements (If, Otherwise, While, For, Match, When)
- Handle variable declaration and assignment statements (Let, Set, Define)
- Process function and process definition statements
- Handle ownership tracking and move semantics - v0.0.8.5 feature
- Parse block statements and statement sequences
- Support AI annotations and macro expansions

This file is essential because of the following reasons:
- Statement parsing is fundamental to Runa's control flow and program structure
- Ownership tracking is a key v0.0.8.5 feature for memory safety
- Proper statement parsing enables correct program analysis and code generation
- Control flow statements define program execution paths
- Variable statements manage program state and memory

This file consists of the following functions/features/operation types:
- Control flow statement parsing and validation
- Variable declaration and assignment statement processing
- Function and process definition parsing
- Ownership tracking statement parsing and validation (v0.0.8.5)
- Block statement and statement sequence parsing
- AI annotation and macro expansion integration

Dependencies:
- Imports parser.runa for parser state and token navigation
- Imports expression_parsers.runa for expression parsing
- Imports ast_builder.runa for AST construction
- Imports lexical components for token recognition
- Imports memory/layout.runa for structure allocation
:End Note

Import "compiler/frontend/parsing/parser.runa" as Parser
Import "compiler/frontend/parsing/expression_parsers.runa" as ExpressionParsers
Import "compiler/frontend/parsing/ast_builder.runa" as ASTBuilder
Import "compiler/frontend/parsing/type_annotations.runa" as TypeAnnotations
Import "compiler/frontend/parsing/ast.runa" as AST
Import "compiler/frontend/lexical/keywords.runa" as Keywords
Import "compiler/frontend/lexical/operators.runa" as Operators
Import "compiler/frontend/lexical/delimiters.runa" as Delimiters
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore

Note: ============================================================================
Note: Variable Declaration and Assignment Statements
Note: ============================================================================

Process called "parse_let_statement" takes parser as Integer returns Integer:
    Note: Parse a Let statement (Let variable be value)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to Let statement AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume Let keyword
    Note: 2. Parse identifier using parse_identifier
    Note: 3. Parse optional type annotation using parse_type_annotation
    Note: 4. Expect and consume be keyword
    Note: 5. Parse value expression using ExpressionParsers.parse_expression
    Note: 6. Create Let statement AST node using ASTBuilder.build_let_statement
    Note: 7. Track variable ownership if needed (v0.0.8.5)
    Note: 8. Return Let statement AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Expect and consume Let keyword
    Let let_consumed be proc parser_expect_token from Parser with parser, TOKEN_LET
    If let_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'Let' keyword at start of Let statement"
        Return 0
    End If

    Note: 2. Parse identifier
    Let identifier be proc parse_identifier with parser
    If identifier is equal to 0:
        proc parser_report_error from Parser with parser, "Expected identifier after 'Let' keyword"
        Return 0
    End If

    Note: 3. Parse optional type annotation
    Let type_annotation be 0
    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token

    Note: Check for as keyword (type annotation)
    If token_type is equal to TOKEN_AS:
        Set type_annotation to proc parse_type_annotation with parser
        If type_annotation is equal to 0:
            proc parser_report_error from Parser with parser, "Expected type annotation after 'as' keyword"
            Return 0
        End If
    End If

    Note: 4. Expect and consume be keyword
    Let be_consumed be proc parser_expect_token from Parser with parser, TOKEN_BE
    If be_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'be' keyword in Let statement"
        Return 0
    End If

    Note: 5. Parse value expression
    Let value_expr be proc parse_expression from ExpressionParsers with parser
    If value_expr is equal to 0:
        proc parser_report_error from Parser with parser, "Expected expression after 'be' keyword in Let statement"
        Return 0
    End If

    Note: 6. Create Let statement AST node
    Let let_stmt be proc build_let_statement from ASTBuilder with identifier, type_annotation, value_expr
    If let_stmt is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create Let statement AST node"
        Return 0
    End If

    Note: 7. Track variable ownership (v0.0.8.5)
    Let ownership_tracked be proc track_variable_ownership with parser, identifier, OWNERSHIP_CREATED
    If ownership_tracked is equal to 0:
        Note: Warning: Ownership tracking failed, but continue (non-fatal)
        proc parser_report_warning from Parser with parser, "Failed to track ownership for variable in Let statement"
    End If

    Note: 8. Return Let statement AST node
    Return let_stmt
End Process

Process called "parse_set_statement" takes parser as Integer returns Integer:
    Note: Parse a Set statement (Set variable to value)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to Set statement AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume Set keyword
    Note: 2. Parse target (identifier, member access, or index) using parse_assignable
    Note: 3. Expect and consume to keyword
    Note: 4. Parse value expression using ExpressionParsers.parse_expression
    Note: 5. Create Set statement AST node using ASTBuilder.build_set_statement
    Note: 6. Track variable ownership if needed (v0.0.8.5)
    Note: 7. Return Set statement AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Expect and consume Set keyword
    Let set_consumed be proc parser_expect_token from Parser with parser, TOKEN_SET
    If set_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'Set' keyword at start of Set statement"
        Return 0
    End If

    Note: 2. Parse target (identifier, member access, or index)
    Let target be proc parse_assignable with parser
    If target is equal to 0:
        proc parser_report_error from Parser with parser, "Expected assignable target after 'Set' keyword"
        Return 0
    End If

    Note: 3. Expect and consume to keyword
    Let to_consumed be proc parser_expect_token from Parser with parser, TOKEN_TO
    If to_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'to' keyword in Set statement"
        Return 0
    End If

    Note: 4. Parse value expression
    Let value_expr be proc parse_expression from ExpressionParsers with parser
    If value_expr is equal to 0:
        proc parser_report_error from Parser with parser, "Expected expression after 'to' keyword in Set statement"
        Return 0
    End If

    Note: 5. Create Set statement AST node
    Let set_stmt be proc build_set_statement from ASTBuilder with target, value_expr
    If set_stmt is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create Set statement AST node"
        Return 0
    End If

    Note: 6. Track variable ownership (v0.0.8.5)
    Note: Extract base identifier from target for ownership tracking
    Let base_identifier be proc ast_node_get_base_identifier from AST with target
    If base_identifier is not equal to 0:
        Let ownership_tracked be proc track_variable_ownership with parser, base_identifier, OWNERSHIP_MODIFIED
        If ownership_tracked is equal to 0:
            proc parser_report_warning from Parser with parser, "Failed to track ownership for variable in Set statement"
        End If
    End If

    Note: 7. Return Set statement AST node
    Return set_stmt
End Process

Process called "parse_define_statement" takes parser as Integer returns Integer:
    Note: Parse a Define statement (Constant as value)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to Define statement AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume Define keyword
    Note: 2. Parse identifier using parse_identifier
    Note: 3. Parse optional type annotation using parse_type_annotation
    Note: 4. Expect and consume as keyword
    Note: 5. Parse value expression using ExpressionParsers.parse_expression
    Note: 6. Create Define statement AST node using ASTBuilder.build_define_statement
    Note: 7. Track variable ownership if needed (v0.0.8.5)
    Note: 8. Return Define statement AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Expect and consume Define keyword
    Let define_consumed be proc parser_expect_token from Parser with parser, TOKEN_DEFINE
    If define_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'Define' or 'Constant' keyword at start of Define statement"
        Return 0
    End If

    Note: 2. Parse identifier
    Let identifier be proc parse_identifier with parser
    If identifier is equal to 0:
        proc parser_report_error from Parser with parser, "Expected identifier after 'Define' keyword"
        Return 0
    End If

    Note: 3. Parse optional type annotation
    Let type_annotation be 0
    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token

    Note: Check for as keyword before value (type annotation)
    If token_type is equal to TOKEN_AS:
        Note: Need to distinguish between type annotation and value assignment
        Note: Look ahead to determine if this is type annotation or value
        Let saved_position be proc parser_save_position from Parser with parser
        proc parser_consume_token from Parser with parser

        Let next_token be proc parser_current_token from Parser with parser
        Let next_type be proc token_get_type from Parser with next_token

        Note: If next token is a type keyword or identifier, it's a type annotation
        Let is_type be proc is_type_keyword from Keywords with next_type
        If is_type is equal to 1:
            Note: This is a type annotation
            proc parser_restore_position from Parser with parser, saved_position
            Set type_annotation to proc parse_type_annotation with parser
            If type_annotation is equal to 0:
                proc parser_report_error from Parser with parser, "Expected type annotation"
                Return 0
            End If

            Note: Now expect is keyword for value
            Let is_consumed be proc parser_expect_token from Parser with parser, TOKEN_IS
            If is_consumed is equal to 0:
                proc parser_report_error from Parser with parser, "Expected 'is' keyword after type annotation in Define statement"
                Return 0
            End If
        Otherwise:
            Note: The 'as' introduces the value directly - restore and continue
            proc parser_restore_position from Parser with parser, saved_position
            Note: Consume the 'as' token
            proc parser_expect_token from Parser with parser, TOKEN_AS
        End If
    End If

    Note: 5. Parse value expression
    Let value_expr be proc parse_expression from ExpressionParsers with parser
    If value_expr is equal to 0:
        proc parser_report_error from Parser with parser, "Expected expression for constant value in Define statement"
        Return 0
    End If

    Note: 6. Create Define statement AST node
    Let define_stmt be proc build_define_statement from ASTBuilder with identifier, type_annotation, value_expr
    If define_stmt is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create Define statement AST node"
        Return 0
    End If

    Note: 7. Track variable ownership (v0.0.8.5)
    Let ownership_tracked be proc track_variable_ownership with parser, identifier, OWNERSHIP_CONSTANT
    If ownership_tracked is equal to 0:
        proc parser_report_warning from Parser with parser, "Failed to track ownership for constant in Define statement"
    End If

    Note: 8. Return Define statement AST node
    Return define_stmt
End Process

Process called "parse_assignable" takes parser as Integer returns Integer:
    Note: Parse an assignable target (identifier, member access, index)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to assignable AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Parse primary expression using ExpressionParsers.parse_primary_expression
    Note: 2. While current token is member access or index operator:
    Note:    - If dot (.): parse member access
    Note:    - If bracket ([): parse index access
    Note: 3. Return final assignable AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Parse base (must be identifier to start)
    Let base be proc parse_primary_expression from ExpressionParsers with parser
    If base is equal to 0:
        proc parser_report_error from Parser with parser, "Expected identifier or assignable expression"
        Return 0
    End If

    Note: 2. Parse postfix operations (member access, index)
    Loop:
        Let current_token be proc parser_current_token from Parser with parser
        Let token_type be proc token_get_type from Parser with current_token

        Note: Check for member access (.)
        If token_type is equal to TOKEN_DOT:
            Set base to proc parse_member_expression from ExpressionParsers with parser, base
            If base is equal to 0:
                proc parser_report_error from Parser with parser, "Failed to parse member access in assignable"
                Return 0
            End If
            Continue
        End If

        Note: Check for index access ([)
        If token_type is equal to TOKEN_LEFT_BRACKET:
            Set base to proc parse_index_expression from ExpressionParsers with parser, base
            If base is equal to 0:
                proc parser_report_error from Parser with parser, "Failed to parse index access in assignable"
                Return 0
            End If
            Continue
        End If

        Note: No more postfix operators
        Break
    End Loop

    Note: 3. Return final assignable
    Return base
End Process

Note: ============================================================================
Note: Control Flow Statements
Note: ============================================================================

Process called "parse_if_statement" takes parser as Integer returns Integer:
    Note: Parse an If statement (If condition: ... End If)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to If statement AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume If keyword
    Note: 2. Parse condition expression using ExpressionParsers.parse_expression
    Note: 3. Expect and consume colon (:)
    Note: 4. Parse then block using parse_block_statement
    Note: 5. Parse optional Otherwise clause using parse_otherwise_clause
    Note: 6. Create If statement AST node using ASTBuilder.build_if_statement
    Note: 7. Return If statement AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Expect and consume If keyword
    Let if_consumed be proc parser_expect_token from Parser with parser, TOKEN_IF
    If if_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'If' keyword at start of If statement"
        Return 0
    End If

    Note: 2. Parse condition expression
    Let condition be proc parse_expression from ExpressionParsers with parser
    If condition is equal to 0:
        proc parser_report_error from Parser with parser, "Expected condition expression after 'If' keyword"
        Return 0
    End If

    Note: 3. Expect and consume colon
    Let colon_consumed be proc parser_expect_token from Parser with parser, TOKEN_COLON
    If colon_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected ':' after If condition"
        Return 0
    End If

    Note: 4. Parse then block
    Let then_block be proc parse_block_statement with parser
    If then_block is equal to 0:
        proc parser_report_error from Parser with parser, "Expected block after If condition"
        Return 0
    End If

    Note: 5. Parse optional Otherwise clause
    Let else_block be proc parse_otherwise_clause with parser

    Note: Expect End If
    Let end_if be proc parser_expect_token from Parser with parser, TOKEN_END
    If end_if is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'End If' to close If statement"
        Return 0
    End If

    Let if_keyword be proc parser_expect_token from Parser with parser, TOKEN_IF
    If if_keyword is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'If' after 'End' keyword"
        Return 0
    End If

    Note: 6. Create If statement AST node
    Let if_stmt be proc build_if_statement from ASTBuilder with condition, then_block, else_block
    If if_stmt is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create If statement AST node"
        Return 0
    End If

    Note: 7. Return If statement AST node
    Return if_stmt
End Process

Process called "parse_otherwise_clause" takes parser as Integer returns Integer:
    Note: Parse an Otherwise clause (Otherwise: ...)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to Otherwise clause AST node
    Note:   Returns 0 if no Otherwise clause found
    Note:
    Note: Algorithm:
    Note: 1. Check if current token is Otherwise keyword
    Note: 2. If not Otherwise: return 0 (no else clause)
    Note: 3. Consume Otherwise keyword
    Note: 4. Expect and consume colon (:)
    Note: 5. Parse else block using parse_block_statement
    Note: 6. Return else block AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Check if current token is Otherwise keyword
    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token

    Note: 2. If not Otherwise, return 0 (no else clause)
    If token_type is not equal to TOKEN_OTHERWISE:
        Return 0
    End If

    Note: 3. Consume Otherwise keyword
    proc parser_consume_token from Parser with parser

    Note: 4. Expect and consume colon
    Let colon_consumed be proc parser_expect_token from Parser with parser, TOKEN_COLON
    If colon_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected ':' after 'Otherwise' keyword"
        Return 0
    End If

    Note: 5. Parse else block
    Let else_block be proc parse_block_statement with parser
    If else_block is equal to 0:
        proc parser_report_error from Parser with parser, "Expected block after 'Otherwise:'"
        Return 0
    End If

    Note: 6. Return else block AST node
    Return else_block
End Process

Process called "parse_match_statement" takes parser as Integer returns Integer:
    Note: Parse a Match statement (Match expression: When pattern: ... End Match)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to Match statement AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume Match keyword
    Note: 2. Parse expression using ExpressionParsers.parse_expression
    Note: 3. Expect and consume colon (:)
    Note: 4. Parse When clauses using parse_when_clauses
    Note: 5. Parse optional Otherwise clause using parse_otherwise_clause
    Note: 6. Expect and consume End Match keywords
    Note: 7. Create Match statement AST node using ASTBuilder.build_match_statement
    Note: 8. Return Match statement AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Expect and consume Match keyword
    Let match_consumed be proc parser_expect_token from Parser with parser, TOKEN_MATCH
    If match_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'Match' keyword at start of Match statement"
        Return 0
    End If

    Note: 2. Parse expression
    Let expression be proc parse_expression from ExpressionParsers with parser
    If expression is equal to 0:
        proc parser_report_error from Parser with parser, "Expected expression after 'Match' keyword"
        Return 0
    End If

    Note: 3. Expect and consume colon
    Let colon_consumed be proc parser_expect_token from Parser with parser, TOKEN_COLON
    If colon_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected ':' after Match expression"
        Return 0
    End If

    Note: 4. Parse When clauses
    Let when_clauses be proc parse_when_clauses with parser
    If when_clauses is equal to 0:
        proc parser_report_error from Parser with parser, "Expected at least one 'When' clause in Match statement"
        Return 0
    End If

    Note: 5. Parse optional Otherwise clause
    Let default_clause be proc parse_otherwise_clause with parser

    Note: 6. Expect End Match
    Let end_consumed be proc parser_expect_token from Parser with parser, TOKEN_END
    If end_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'End Match' to close Match statement"
        Return 0
    End If

    Let match_keyword be proc parser_expect_token from Parser with parser, TOKEN_MATCH
    If match_keyword is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'Match' after 'End' keyword"
        Return 0
    End If

    Note: 7. Create Match statement AST node
    Let match_stmt be proc build_match_statement from ASTBuilder with expression, when_clauses, default_clause
    If match_stmt is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create Match statement AST node"
        Return 0
    End If

    Note: 8. Return Match statement AST node
    Return match_stmt
End Process

Process called "parse_when_clauses" takes parser as Integer returns Integer:
    Note: Parse When clauses (match arms)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to List of When clause AST nodes
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Create empty List for When clauses
    Note: 2. While current token is When keyword:
    Note:    - Parse When clause using parse_when_clause
    Note:    - Add to clauses List
    Note: 3. Return clauses List

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Create empty list for When clauses
    Let clauses be proc create_list from Layout
    If clauses is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create When clauses list"
        Return 0
    End If

    Note: 2. Parse When clauses while available
    Loop:
        Let current_token be proc parser_current_token from Parser with parser
        Let token_type be proc token_get_type from Parser with current_token

        Note: Check if current token is When keyword
        If token_type is not equal to TOKEN_WHEN:
            Break
        End If

        Note: Parse When clause
        Let when_clause be proc parse_when_clause with parser
        If when_clause is equal to 0:
            proc parser_report_error from Parser with parser, "Failed to parse When clause"
            Return 0
        End If

        Note: Add to clauses list
        proc list_append from Layout with clauses, when_clause
    End Loop

    Note: 3. Return clauses list
    Note: Check that at least one clause was parsed
    Let clause_count be proc list_length from Layout with clauses
    If clause_count is equal to 0:
        Return 0
    End If

    Return clauses
End Process

Process called "parse_when_clause" takes parser as Integer returns Integer:
    Note: Parse a When clause (When pattern: ...)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to When clause AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume When keyword
    Note: 2. Parse pattern using parse_pattern
    Note: 3. Parse optional guard condition using parse_guard_condition
    Note: 4. Expect and consume colon (:)
    Note: 5. Parse body using parse_block_statement
    Note: 6. Create When clause AST node using ASTBuilder.build_when_clause
    Note: 7. Return When clause AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Expect and consume When keyword
    Let when_consumed be proc parser_expect_token from Parser with parser, TOKEN_WHEN
    If when_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'When' keyword at start of When clause"
        Return 0
    End If

    Note: 2. Parse pattern
    Let pattern be proc parse_pattern with parser
    If pattern is equal to 0:
        proc parser_report_error from Parser with parser, "Expected pattern after 'When' keyword"
        Return 0
    End If

    Note: 3. Parse optional guard condition
    Let guard_condition be proc parse_guard_condition with parser

    Note: 4. Expect and consume colon
    Let colon_consumed be proc parser_expect_token from Parser with parser, TOKEN_COLON
    If colon_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected ':' after When pattern"
        Return 0
    End If

    Note: 5. Parse body
    Let body be proc parse_block_statement with parser
    If body is equal to 0:
        proc parser_report_error from Parser with parser, "Expected block after When pattern"
        Return 0
    End If

    Note: 6. Create When clause AST node
    Let when_clause be proc build_when_clause from ASTBuilder with pattern, guard_condition, body
    If when_clause is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create When clause AST node"
        Return 0
    End If

    Note: 7. Return When clause AST node
    Return when_clause
End Process

Process called "parse_for_statement" takes parser as Integer returns Integer:
    Note: Parse a For statement (For variable in iterable: ... End For)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to For statement AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume For keyword
    Note: 2. Parse loop variable using parse_identifier
    Note: 3. Expect and consume in keyword
    Note: 4. Parse iterable expression using ExpressionParsers.parse_expression
    Note: 5. Expect and consume colon (:)
    Note: 6. Parse body using parse_block_statement
    Note: 7. Expect and consume End For keywords
    Note: 8. Create For statement AST node using ASTBuilder.build_for_statement
    Note: 9. Return For statement AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Expect and consume For keyword
    Let for_consumed be proc parser_expect_token from Parser with parser, TOKEN_FOR
    If for_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'For' keyword at start of For statement"
        Return 0
    End If

    Note: 2. Parse loop variable
    Let loop_variable be proc parse_identifier with parser
    If loop_variable is equal to 0:
        proc parser_report_error from Parser with parser, "Expected loop variable after 'For' keyword"
        Return 0
    End If

    Note: 3. Expect and consume in keyword
    Let in_consumed be proc parser_expect_token from Parser with parser, TOKEN_IN
    If in_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'in' keyword after loop variable"
        Return 0
    End If

    Note: 4. Parse iterable expression
    Let iterable be proc parse_expression from ExpressionParsers with parser
    If iterable is equal to 0:
        proc parser_report_error from Parser with parser, "Expected iterable expression after 'in' keyword"
        Return 0
    End If

    Note: 5. Expect and consume colon
    Let colon_consumed be proc parser_expect_token from Parser with parser, TOKEN_COLON
    If colon_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected ':' after For iterable"
        Return 0
    End If

    Note: 6. Parse body
    Let body be proc parse_block_statement with parser
    If body is equal to 0:
        proc parser_report_error from Parser with parser, "Expected block after For header"
        Return 0
    End If

    Note: 7. Expect End For
    Let end_consumed be proc parser_expect_token from Parser with parser, TOKEN_END
    If end_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'End For' to close For statement"
        Return 0
    End If

    Let for_keyword be proc parser_expect_token from Parser with parser, TOKEN_FOR
    If for_keyword is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'For' after 'End' keyword"
        Return 0
    End If

    Note: 8. Create For statement AST node
    Let for_stmt be proc build_for_statement from ASTBuilder with loop_variable, iterable, body
    If for_stmt is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create For statement AST node"
        Return 0
    End If

    Note: 9. Return For statement AST node
    Return for_stmt
End Process

Process called "parse_while_statement" takes parser as Integer returns Integer:
    Note: Parse a While statement (While condition: ... End While)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to While statement AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume While keyword
    Note: 2. Parse condition expression using ExpressionParsers.parse_expression
    Note: 3. Expect and consume colon (:)
    Note: 4. Parse body using parse_block_statement
    Note: 5. Expect and consume End While keywords
    Note: 6. Create While statement AST node using ASTBuilder.build_while_statement
    Note: 7. Return While statement AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Expect and consume While keyword
    Let while_consumed be proc parser_expect_token from Parser with parser, TOKEN_WHILE
    If while_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'While' keyword at start of While statement"
        Return 0
    End If

    Note: 2. Parse condition expression
    Let condition be proc parse_expression from ExpressionParsers with parser
    If condition is equal to 0:
        proc parser_report_error from Parser with parser, "Expected condition expression after 'While' keyword"
        Return 0
    End If

    Note: 3. Expect and consume colon
    Let colon_consumed be proc parser_expect_token from Parser with parser, TOKEN_COLON
    If colon_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected ':' after While condition"
        Return 0
    End If

    Note: 4. Parse body
    Let body be proc parse_block_statement with parser
    If body is equal to 0:
        proc parser_report_error from Parser with parser, "Expected block after While condition"
        Return 0
    End If

    Note: 5. Expect End While
    Let end_consumed be proc parser_expect_token from Parser with parser, TOKEN_END
    If end_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'End While' to close While statement"
        Return 0
    End If

    Let while_keyword be proc parser_expect_token from Parser with parser, TOKEN_WHILE
    If while_keyword is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'While' after 'End' keyword"
        Return 0
    End If

    Note: 6. Create While statement AST node
    Let while_stmt be proc build_while_statement from ASTBuilder with condition, body
    If while_stmt is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create While statement AST node"
        Return 0
    End If

    Note: 7. Return While statement AST node
    Return while_stmt
End Process

Process called "parse_loop_statement" takes parser as Integer returns Integer:
    Note: Parse a Loop statement (Loop: ... End Loop)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to Loop statement AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume Loop keyword
    Note: 2. Expect and consume colon (:)
    Note: 3. Parse body using parse_block_statement
    Note: 4. Expect and consume End Loop keywords
    Note: 5. Create Loop statement AST node using ASTBuilder.build_loop_statement
    Note: 6. Return Loop statement AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Expect and consume Loop keyword
    Let loop_consumed be proc parser_expect_token from Parser with parser, TOKEN_LOOP
    If loop_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'Loop' keyword at start of Loop statement"
        Return 0
    End If

    Note: 2. Expect and consume colon
    Let colon_consumed be proc parser_expect_token from Parser with parser, TOKEN_COLON
    If colon_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected ':' after 'Loop' keyword"
        Return 0
    End If

    Note: 3. Parse body
    Let body be proc parse_block_statement with parser
    If body is equal to 0:
        proc parser_report_error from Parser with parser, "Expected block after 'Loop:'"
        Return 0
    End If

    Note: 4. Expect End Loop
    Let end_consumed be proc parser_expect_token from Parser with parser, TOKEN_END
    If end_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'End Loop' to close Loop statement"
        Return 0
    End If

    Let loop_keyword be proc parser_expect_token from Parser with parser, TOKEN_LOOP
    If loop_keyword is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'Loop' after 'End' keyword"
        Return 0
    End If

    Note: 5. Create Loop statement AST node
    Let loop_stmt be proc build_loop_statement from ASTBuilder with body
    If loop_stmt is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create Loop statement AST node"
        Return 0
    End If

    Note: 6. Return Loop statement AST node
    Return loop_stmt
End Process

Note: ============================================================================
Note: Simple Statements
Note: ============================================================================

Process called "parse_return_statement" takes parser as Integer returns Integer:
    Note: Parse a Return statement (Return value)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to Return statement AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume Return keyword
    Note: 2. Parse optional return value using ExpressionParsers.parse_expression
    Note: 3. Create Return statement AST node using ASTBuilder.build_return_statement
    Note: 4. Return Return statement AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Expect and consume Return keyword
    Let return_consumed be proc parser_expect_token from Parser with parser, TOKEN_RETURN
    If return_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'Return' keyword at start of Return statement"
        Return 0
    End If

    Note: 2. Parse optional return value
    Let value be 0
    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token

    Note: Check if next token is statement terminator (no return value)
    If token_type is not equal to TOKEN_NEWLINE:
        If token_type is not equal to TOKEN_EOF:
            If token_type is not equal to TOKEN_END:
                Note: Parse return value expression
                Set value to proc parse_expression from ExpressionParsers with parser
                If value is equal to 0:
                    proc parser_report_error from Parser with parser, "Invalid expression in Return statement"
                    Return 0
                End If
            End If
        End If
    End If

    Note: 3. Create Return statement AST node
    Let return_stmt be proc build_return_statement from ASTBuilder with value
    If return_stmt is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create Return statement AST node"
        Return 0
    End If

    Note: 4. Return Return statement AST node
    Return return_stmt
End Process

Process called "parse_break_statement" takes parser as Integer returns Integer:
    Note: Parse a Break statement (Break)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to Break statement AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume Break keyword
    Note: 2. Create Break statement AST node
    Note: 3. Return Break statement AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Expect and consume Break keyword
    Let break_consumed be proc parser_expect_token from Parser with parser, TOKEN_BREAK
    If break_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'Break' keyword at start of Break statement"
        Return 0
    End If

    Note: 2. Create Break statement AST node
    Let break_stmt be proc build_break_statement from ASTBuilder
    If break_stmt is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create Break statement AST node"
        Return 0
    End If

    Note: 3. Return Break statement AST node
    Return break_stmt
End Process

Process called "parse_continue_statement" takes parser as Integer returns Integer:
    Note: Parse a Continue statement (Continue)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to Continue statement AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume Continue keyword
    Note: 2. Create Continue statement AST node
    Note: 3. Return Continue statement AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Expect and consume Continue keyword
    Let continue_consumed be proc parser_expect_token from Parser with parser, TOKEN_CONTINUE
    If continue_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'Continue' keyword at start of Continue statement"
        Return 0
    End If

    Note: 2. Create Continue statement AST node
    Let continue_stmt be proc build_continue_statement from ASTBuilder
    If continue_stmt is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create Continue statement AST node"
        Return 0
    End If

    Note: 3. Return Continue statement AST node
    Return continue_stmt
End Process

Note: ============================================================================
Note: Declaration Statements
Note: ============================================================================

Process called "parse_process_definition" takes parser as Integer returns Integer:
    Note: Parse a Process definition (Process called name takes params returns type: ... End Process)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to Process definition AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume Process keyword
    Note: 2. Expect and consume called keyword
    Note: 3. Parse process name using parse_identifier
    Note: 4. Parse parameters using parse_parameter_list
    Note: 5. Parse return type using parse_return_type
    Note: 6. Expect and consume colon (:)
    Note: 7. Parse body using parse_block_statement
    Note: 8. Expect and consume End Process keywords
    Note: 9. Create Process definition AST node using ASTBuilder.build_process_definition
    Note: 10. Return Process definition AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Expect and consume Process keyword
    Let process_consumed be proc parser_expect_token from Parser with parser, TOKEN_PROCESS
    If process_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'Process' keyword at start of Process definition"
        Return 0
    End If

    Note: 2. Expect and consume called keyword
    Let called_consumed be proc parser_expect_token from Parser with parser, TOKEN_CALLED
    If called_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'called' keyword after 'Process'"
        Return 0
    End If

    Note: 3. Parse process name
    Let process_name be proc parse_identifier with parser
    If process_name is equal to 0:
        proc parser_report_error from Parser with parser, "Expected process name after 'called' keyword"
        Return 0
    End If

    Note: 4. Parse parameters
    Let parameters be proc parse_parameter_list with parser
    Note: Parameters may be empty (0), which is valid

    Note: 5. Parse return type
    Let return_type be proc parse_return_type with parser
    Note: Return type may be empty (0), which means void/no return

    Note: 6. Expect and consume colon
    Let colon_consumed be proc parser_expect_token from Parser with parser, TOKEN_COLON
    If colon_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected ':' after Process signature"
        Return 0
    End If

    Note: 7. Parse body
    Let body be proc parse_block_statement with parser
    If body is equal to 0:
        proc parser_report_error from Parser with parser, "Expected block after Process signature"
        Return 0
    End If

    Note: 8. Expect End Process
    Let end_consumed be proc parser_expect_token from Parser with parser, TOKEN_END
    If end_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'End Process' to close Process definition"
        Return 0
    End If

    Let process_keyword be proc parser_expect_token from Parser with parser, TOKEN_PROCESS
    If process_keyword is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'Process' after 'End' keyword"
        Return 0
    End If

    Note: 9. Create Process definition AST node
    Let process_def be proc build_process_definition from ASTBuilder with process_name, parameters, return_type, body
    If process_def is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create Process definition AST node"
        Return 0
    End If

    Note: 10. Return Process definition AST node
    Return process_def
End Process

Process called "parse_type_definition" takes parser as Integer returns Integer:
    Note: Parse a Type definition (Type called name: ... End Type)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to Type definition AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume Type keyword
    Note: 2. Expect and consume called keyword
    Note: 3. Parse type name using parse_identifier
    Note: 4. Parse generic parameters using parse_generic_parameters (optional)
    Note: 5. Expect and consume colon (:)
    Note: 6. Parse type body using parse_type_body
    Note: 7. Expect and consume End Type keywords
    Note: 8. Create Type definition AST node using ASTBuilder.build_type_definition
    Note: 9. Return Type definition AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Expect and consume Type keyword
    Let type_consumed be proc parser_expect_token from Parser with parser, TOKEN_TYPE
    If type_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'Type' keyword at start of Type definition"
        Return 0
    End If

    Note: 2. Expect and consume called keyword
    Let called_consumed be proc parser_expect_token from Parser with parser, TOKEN_CALLED
    If called_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'called' keyword after 'Type'"
        Return 0
    End If

    Note: 3. Parse type name
    Let type_name be proc parse_identifier with parser
    If type_name is equal to 0:
        proc parser_report_error from Parser with parser, "Expected type name after 'called' keyword"
        Return 0
    End If

    Note: 4. Parse optional generic parameters
    Let generic_params be 0
    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token

    Note: Check for left angle bracket (generic parameters)
    If token_type is equal to TOKEN_LEFT_ANGLE:
        Set generic_params to proc parse_generic_parameters from TypeAnnotations with parser
        If generic_params is equal to 0:
            proc parser_report_error from Parser with parser, "Failed to parse generic parameters"
            Return 0
        End If
    End If

    Note: 5. Expect and consume colon
    Let colon_consumed be proc parser_expect_token from Parser with parser, TOKEN_COLON
    If colon_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected ':' after Type name"
        Return 0
    End If

    Note: 6. Parse type body
    Let type_body be proc parse_type_body from TypeAnnotations with parser
    If type_body is equal to 0:
        proc parser_report_error from Parser with parser, "Expected type body after ':'"
        Return 0
    End If

    Note: 7. Expect End Type
    Let end_consumed be proc parser_expect_token from Parser with parser, TOKEN_END
    If end_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'End Type' to close Type definition"
        Return 0
    End If

    Let type_keyword be proc parser_expect_token from Parser with parser, TOKEN_TYPE
    If type_keyword is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'Type' after 'End' keyword"
        Return 0
    End If

    Note: 8. Create Type definition AST node
    Let type_def be proc build_type_definition from ASTBuilder with type_name, generic_params, type_body
    If type_def is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create Type definition AST node"
        Return 0
    End If

    Note: 9. Return Type definition AST node
    Return type_def
End Process

Process called "parse_import_statement" takes parser as Integer returns Integer:
    Note: Parse an Import statement (Import "path" as Alias)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to Import statement AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume Import keyword
    Note: 2. Parse import path using parse_string_literal
    Note: 3. Parse optional alias using parse_import_alias
    Note: 4. Create Import statement AST node using ASTBuilder.build_import_statement
    Note: 5. Return Import statement AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Expect and consume Import keyword
    Let import_consumed be proc parser_expect_token from Parser with parser, TOKEN_IMPORT
    If import_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected 'Import' keyword at start of Import statement"
        Return 0
    End If

    Note: 2. Parse import path (string literal)
    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token

    If token_type is not equal to TOKEN_STRING:
        proc parser_report_error from Parser with parser, "Expected string literal for import path"
        Return 0
    End If

    Let import_path be proc token_get_value from Parser with current_token
    proc parser_consume_token from Parser with parser

    Note: 3. Parse optional alias
    Let alias be 0
    Set current_token to proc parser_current_token from Parser with parser
    Set token_type to proc token_get_type from Parser with current_token

    Note: Check for as keyword (alias)
    If token_type is equal to TOKEN_AS:
        proc parser_consume_token from Parser with parser

        Note: Parse alias identifier
        Set alias to proc parse_identifier with parser
        If alias is equal to 0:
            proc parser_report_error from Parser with parser, "Expected identifier after 'as' keyword in Import statement"
            Return 0
        End If
    End If

    Note: 4. Create Import statement AST node
    Let import_stmt be proc build_import_statement from ASTBuilder with import_path, alias
    If import_stmt is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create Import statement AST node"
        Return 0
    End If

    Note: 5. Return Import statement AST node
    Return import_stmt
End Process

Note: ============================================================================
Note: Block and Statement Sequence Parsing
Note: ============================================================================

Process called "parse_block_statement" takes parser as Integer returns Integer:
    Note: Parse a block statement (indented statement sequence)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to block statement AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Push new context onto parser context stack
    Note: 2. Parse statement sequence using parse_statement_sequence
    Note: 3. Pop context from parser context stack
    Note: 4. Create block statement AST node using ASTBuilder.build_block_statement
    Note: 5. Return block statement AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Push new context
    proc parser_push_context from Parser with parser

    Note: 2. Parse statement sequence
    Let statements be proc parse_statement_sequence with parser
    If statements is equal to 0:
        Note: Pop context even on failure
        proc parser_pop_context from Parser with parser
        proc parser_report_error from Parser with parser, "Failed to parse statement sequence in block"
        Return 0
    End If

    Note: 3. Pop context
    proc parser_pop_context from Parser with parser

    Note: 4. Create block statement AST node
    Let block be proc build_block_statement from ASTBuilder with statements
    If block is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create block statement AST node"
        Return 0
    End If

    Note: 5. Return block statement AST node
    Return block
End Process

Process called "parse_statement_sequence" takes parser as Integer returns Integer:
    Note: Parse a sequence of statements
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to List of statement AST nodes
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Create empty List for statements
    Note: 2. While not at block end (End keyword or EOF):
    Note:    - Parse statement using parse_single_statement
    Note:    - Add to statements List
    Note: 3. Return statements List

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Create empty list for statements
    Let statements be proc create_list from Layout
    If statements is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create statement list"
        Return 0
    End If

    Note: 2. Parse statements until block end
    Loop:
        Let current_token be proc parser_current_token from Parser with parser
        Let token_type be proc token_get_type from Parser with current_token

        Note: Check for block terminators
        If token_type is equal to TOKEN_END:
            Break
        End If

        If token_type is equal to TOKEN_EOF:
            Break
        End If

        If token_type is equal to TOKEN_OTHERWISE:
            Break
        End If

        If token_type is equal to TOKEN_WHEN:
            Break
        End If

        Note: Parse single statement
        Let statement be proc parse_single_statement with parser
        If statement is equal to 0:
            Note: Skip this statement and continue (error recovery)
            proc parser_skip_to_next_statement from Parser with parser
            Continue
        End If

        Note: Add statement to list
        proc list_append from Layout with statements, statement
    End Loop

    Note: 3. Return statements list
    Return statements
End Process

Process called "parse_single_statement" takes parser as Integer returns Integer:
    Note: Parse a single statement
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to statement AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Check current token type
    Note: 2. Route to appropriate statement parser:
    Note:    - Let: parse_let_statement
    Note:    - Set: parse_set_statement
    Note:    - Define: parse_define_statement
    Note:    - If: parse_if_statement
    Note:    - Match: parse_match_statement
    Note:    - For: parse_for_statement
    Note:    - While: parse_while_statement
    Note:    - Loop: parse_loop_statement
    Note:    - Return: parse_return_statement
    Note:    - Break: parse_break_statement
    Note:    - Continue: parse_continue_statement
    Note:    - Process: parse_process_definition
    Note:    - Type: parse_type_definition
    Note:    - Import: parse_import_statement
    Note: 3. Return statement AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Check current token type
    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token

    Note: 2. Route to appropriate statement parser based on keyword
    If token_type is equal to TOKEN_LET:
        Return proc parse_let_statement with parser
    End If

    If token_type is equal to TOKEN_SET:
        Return proc parse_set_statement with parser
    End If

    If token_type is equal to TOKEN_DEFINE:
        Return proc parse_define_statement with parser
    End If

    If token_type is equal to TOKEN_CONSTANT:
        Return proc parse_define_statement with parser
    End If

    If token_type is equal to TOKEN_IF:
        Return proc parse_if_statement with parser
    End If

    If token_type is equal to TOKEN_MATCH:
        Return proc parse_match_statement with parser
    End If

    If token_type is equal to TOKEN_FOR:
        Return proc parse_for_statement with parser
    End If

    If token_type is equal to TOKEN_WHILE:
        Return proc parse_while_statement with parser
    End If

    If token_type is equal to TOKEN_LOOP:
        Return proc parse_loop_statement with parser
    End If

    If token_type is equal to TOKEN_RETURN:
        Return proc parse_return_statement with parser
    End If

    If token_type is equal to TOKEN_BREAK:
        Return proc parse_break_statement with parser
    End If

    If token_type is equal to TOKEN_CONTINUE:
        Return proc parse_continue_statement with parser
    End If

    If token_type is equal to TOKEN_PROCESS:
        Return proc parse_process_definition with parser
    End If

    If token_type is equal to TOKEN_TYPE:
        Return proc parse_type_definition with parser
    End If

    If token_type is equal to TOKEN_IMPORT:
        Return proc parse_import_statement with parser
    End If

    Note: Unknown statement type - report error
    Let token_value be proc token_get_value from Parser with current_token
    proc parser_report_error from Parser with parser, "Unexpected token in statement position"
    Return 0
End Process

Note: ============================================================================
Note: Ownership Tracking Support (v0.0.8.5)
Note: ============================================================================

Process called "parse_ownership_operation" takes parser as Integer returns Integer:
    Note: Parse an ownership operation (Move, Borrow, Mutable Borrow)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to ownership operation AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Check current token for ownership keywords:
    Note:    - Move: parse move operation
    Note:    - Borrow: parse borrow operation
    Note:    - Mutable Borrow: parse mutable borrow operation
    Note: 2. Parse target variable using parse_identifier
    Note: 3. Create ownership operation AST node
    Note: 4. Track ownership change in parser state
    Note: 5. Return ownership operation AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: 1. Check ownership keywords
    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token
    Let operation_type be 0

    Note: Determine ownership operation type
    If token_type is equal to TOKEN_MOVE:
        Set operation_type to OWNERSHIP_MOVED
        proc parser_consume_token from Parser with parser
    Otherwise:
        If token_type is equal to TOKEN_BORROW:
            Set operation_type to OWNERSHIP_BORROWED
            proc parser_consume_token from Parser with parser
        Otherwise:
            If token_type is equal to TOKEN_MUTABLE:
                Note: Check for "Mutable Borrow"
                proc parser_consume_token from Parser with parser
                Let borrow_token be proc parser_expect_token from Parser with parser, TOKEN_BORROW
                If borrow_token is equal to 0:
                    proc parser_report_error from Parser with parser, "Expected 'Borrow' after 'Mutable'"
                    Return 0
                End If
                Set operation_type to OWNERSHIP_MUTABLE_BORROWED
            Otherwise:
                Note: Not an ownership operation
                Return 0
            End If
        End If
    End If

    Note: 2. Parse target variable
    Let target_variable be proc parse_identifier with parser
    If target_variable is equal to 0:
        proc parser_report_error from Parser with parser, "Expected identifier after ownership keyword"
        Return 0
    End If

    Note: 3. Create ownership operation AST node
    Let ownership_node be proc build_ownership_operation from ASTBuilder with operation_type, target_variable
    If ownership_node is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create ownership operation AST node"
        Return 0
    End If

    Note: 4. Track ownership change
    Let tracked be proc track_variable_ownership with parser, target_variable, operation_type
    If tracked is equal to 0:
        proc parser_report_warning from Parser with parser, "Failed to track ownership change"
    End If

    Note: 5. Return ownership operation AST node
    Return ownership_node
End Process

Process called "track_variable_ownership" takes parser as Integer, variable as Integer, operation as Integer returns Integer:
    Note: Track ownership change for a variable (v0.0.8.5)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:   variable - Pointer to variable identifier
    Note:   operation - Ownership operation type
    Note:
    Note: Returns:
    Note:   1 on success, 0 on failure
    Note:
    Note: Side Effects:
    Note:   - Updates ownership tracking in parser state
    Note:   - Reports ownership violations if detected
    Note:   - Updates current scope ownership state

    If parser is equal to 0:
        Return 0
    End If

    If variable is equal to 0:
        Return 0
    End If

    Note: Get variable name from identifier node
    Let variable_name be proc ast_node_get_value from AST with variable
    If variable_name is equal to 0:
        Return 0
    End If

    Note: Track ownership change in parser state
    Let result be proc parser_track_variable_ownership from Parser with parser, variable_name, operation

    Note: Check for ownership violations
    If result is equal to 0:
        Note: Ownership violation detected - error already reported by parser
        Return 0
    End If

    Return 1
End Process

Note: ============================================================================
Note: Helper Functions
Note: ============================================================================

Process called "parse_identifier" takes parser as Integer returns Integer:
    Note: Parse an identifier
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to identifier AST node
    Note:   Returns 0 on parsing error

    If parser is equal to 0:
        Return 0
    End If

    Note: Get current token
    Let current_token be proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Return 0
    End If

    Let token_type be proc token_get_type from Parser with current_token

    Note: Check if token is identifier
    If token_type is not equal to TOKEN_IDENTIFIER:
        Return 0
    End If

    Note: Get identifier value
    Let identifier_value be proc token_get_value from Parser with current_token
    If identifier_value is equal to 0:
        Return 0
    End If

    Note: Create identifier AST node
    Let identifier_node be proc build_identifier_node from ASTBuilder with identifier_value
    If identifier_node is equal to 0:
        Return 0
    End If

    Note: Consume token and return identifier node
    proc parser_consume_token from Parser with parser
    Return identifier_node
End Process

Process called "parse_type_annotation" takes parser as Integer returns Integer:
    Note:
    Parse a type annotation (as Type or as @ARC Type).

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to type annotation AST node
      Returns 0 if no type annotation found

    Syntax examples:
      - as Integer
      - as @ARC Node
      - as @Owned String
      - as @Shared Buffer
      - as @Arena TempData
      - as @Stack SmallValue

    Algorithm:
    1. Check for "as" keyword - return 0 if not found
    2. Consume "as" keyword
    3. Get line/column for error reporting
    4. Check for @ symbol (TOKEN_AT = 653)
    5. If @ found:
       a. Consume @ token
       b. Get annotation name (ARC, Owned, Shared, Arena, Stack)
       c. Parse annotation name using TypeAnnotations
       d. Validate annotation
       e. Consume annotation name token
    6. Parse base type name (Integer, String, Node, etc.)
    7. Create AST node:
       - If annotation exists: AST_TYPE_ANNOTATION with annotation metadata
       - Otherwise: AST_TYPE_BASIC for plain type
    8. Return AST node
    :End Note

    Note: Validate parser
    If parser is equal to 0:
        Return 0
    End If

    Note: Check for "as" keyword
    Let current_token be proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Return 0  Note: No current token
    End If

    Let token_type be proc memory_get_qword from Layout with current_token, 0

    Note: TOKEN_AS (keyword) - need to check if it's "as" keyword
    Let token_value be proc memory_get_qword from Layout with current_token, 8
    If token_value is equal to 0:
        Return 0  Note: No token value
    End If

    Let is_as be proc string_equals from StringCore with token_value, "as"
    If is_as is equal to 0:
        Return 0  Note: Not "as" keyword - no type annotation
    End If

    Note: Get location for error reporting
    Let line be proc memory_get_qword from Layout with current_token, 16
    Let column be proc memory_get_qword from Layout with current_token, 24

    Note: Consume "as" keyword
    proc parser_consume_token from Parser with parser

    Note: Check for @ symbol (type annotation marker)
    Set current_token to proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Return 0  Note: Missing type after "as"
    End If

    Set token_type to proc memory_get_qword from Layout with current_token, 0

    Note: Initialize annotation tracking
    Let has_annotation be 0
    Let annotation_type be 0
    Let annotation_name be 0

    Note: Check for @ annotation marker
    If token_type is equal to TOKEN_AT:
        Set has_annotation to 1

        Note: Consume @ symbol
        proc parser_consume_token from Parser with parser

        Note: Get annotation name (ARC, Owned, Shared, Arena, Stack)
        Set current_token to proc parser_current_token from Parser with parser
        If current_token is equal to 0:
            Return 0  Note: Missing annotation name after @
        End If

        Set annotation_name to proc memory_get_qword from Layout with current_token, 8
        If annotation_name is equal to 0:
            Return 0  Note: Invalid annotation name
        End If

        Note: Parse annotation name to get annotation type constant
        Set annotation_type to proc parse_type_annotation from TypeAnnotations with annotation_name

        If annotation_type is equal to 0:
            Note: Invalid annotation type - report error
            Return 0
        End If

        Note: Consume annotation name token
        proc parser_consume_token from Parser with parser
    End If

    Note: Parse base type name (Integer, String, Node, etc.)
    Set current_token to proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Return 0  Note: Missing type name
    End If

    Let type_name be proc memory_get_qword from Layout with current_token, 8
    If type_name is equal to 0:
        Return 0  Note: Invalid type name
    End If

    Note: Consume type name token
    proc parser_consume_token from Parser with parser

    Note: Create AST node based on whether annotation exists
    If has_annotation is equal to 1:
        Note: Create type annotation AST node with annotation metadata
        Let type_annotation_node be proc create_type_annotation from TypeAnnotations with annotation_type, type_name, line, column
        Return type_annotation_node
    End If

    Note: No annotation - create basic type node
    Let basic_type_node be proc create_ast_node from AST with 4000, line, column  Note: AST_TYPE_BASIC = 4000
    If basic_type_node is equal to 0:
        Return 0  Note: Failed to create AST node
    End If

    Note: Set type name in value field
    proc ast_node_set_value from AST with basic_type_node, type_name, 1  Note: 1 = string value

    Return basic_type_node
End Process

Process called "parse_parameter_list" takes parser as Integer returns Integer:
    Note: Parse a parameter list (takes param1 as Type1, param2 as Type2)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to List of parameter AST nodes
    Note:   Returns 0 on parsing error

    If parser is equal to 0:
        Return 0
    End If

    Note: Check for takes keyword
    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token

    Note: If no takes keyword, return 0 (empty parameter list is valid)
    If token_type is not equal to TOKEN_TAKES:
        Return 0
    End If

    Note: Consume takes keyword
    proc parser_consume_token from Parser with parser

    Note: Create list for parameters
    Let parameters be proc create_list from Layout
    If parameters is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create parameter list"
        Return 0
    End If

    Note: Parse comma-separated parameters
    Loop:
        Note: Parse parameter name
        Let param_name be proc parse_identifier with parser
        If param_name is equal to 0:
            proc parser_report_error from Parser with parser, "Expected parameter name"
            Return 0
        End If

        Note: Parse type annotation
        Let param_type be proc parse_type_annotation with parser
        If param_type is equal to 0:
            proc parser_report_error from Parser with parser, "Expected type annotation for parameter"
            Return 0
        End If

        Note: Create parameter node
        Let param_node be proc build_parameter_node from ASTBuilder with param_name, param_type
        If param_node is equal to 0:
            proc parser_report_error from Parser with parser, "Failed to create parameter node"
            Return 0
        End If

        Note: Add to parameters list
        proc list_append from Layout with parameters, param_node

        Note: Check for comma (more parameters) or end of parameter list
        Set current_token to proc parser_current_token from Parser with parser
        Set token_type to proc token_get_type from Parser with current_token

        If token_type is equal to TOKEN_COMMA:
            proc parser_consume_token from Parser with parser
            Continue
        Otherwise:
            Break
        End If
    End Loop

    Return parameters
End Process

Process called "parse_return_type" takes parser as Integer returns Integer:
    Note: Parse a return type (returns Type)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to return type AST node
    Note:   Returns 0 if no return type specified

    If parser is equal to 0:
        Return 0
    End If

    Note: Check for returns keyword
    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token

    Note: If no returns keyword, return 0 (void return)
    If token_type is not equal to TOKEN_RETURNS:
        Return 0
    End If

    Note: Consume returns keyword
    proc parser_consume_token from Parser with parser

    Note: Parse return type
    Let return_type be proc parse_type_annotation with parser
    Note: Type annotation expects "as Type" format, but for return type we just have "Type"
    Note: So we need to parse the type name directly
    Set current_token to proc parser_current_token from Parser with parser
    Let type_name_token be proc token_get_value from Parser with current_token

    If type_name_token is equal to 0:
        proc parser_report_error from Parser with parser, "Expected return type after 'returns' keyword"
        Return 0
    End If

    Note: Create return type AST node
    Let return_type_node be proc build_type_node from ASTBuilder with type_name_token
    If return_type_node is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create return type node"
        Return 0
    End If

    Note: Consume type token
    proc parser_consume_token from Parser with parser

    Return return_type_node
End Process

Process called "parse_pattern" takes parser as Integer returns Integer:
    Note:
    Production-perfect pattern parser supporting all Runa pattern types.
    Implements: wildcard, literal, identifier, tuple, record, array, range,
    variant, type, and OR patterns with complete validation.

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to pattern AST node
      Returns 0 on parsing error
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Parse OR pattern (handles alternatives: pattern1 OR pattern2 OR pattern3)
    Let pattern be proc parse_pattern_or with parser

    Return pattern
End Process

Process called "parse_pattern_or" takes parser as Integer returns Integer:
    Note:
    Parse OR pattern (alternative patterns).
    Syntax: pattern OR pattern OR pattern
    Returns AST_OR_PATTERN if multiple alternatives, otherwise single pattern.
    :End Note

    Note: Parse first pattern
    Let left_pattern be proc parse_pattern_primary with parser
    If left_pattern is equal to 0:
        Return 0
    End If

    Note: Check for OR keyword
    Let current_token be proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Return left_pattern  Note: No OR, return single pattern
    End If

    Let token_type be proc memory_get_qword from Layout with current_token, 0

    Note: If no OR token, return single pattern
    If token_type is not equal to TOKEN_OR_TYPE:
        Return left_pattern
    End If

    Note: Build OR pattern - collect all alternatives
    Let alternatives be proc arena_allocate from Layout with parser, 80  Note: Up to 10 alternatives
    proc memory_set_qword from Layout with alternatives, 0, left_pattern
    Let alt_count be 1

    Note: Parse additional alternatives
    While token_type is equal to TOKEN_OR_TYPE:
        Note: Consume OR keyword
        proc parser_consume_token from Parser with parser

        Note: Parse next alternative
        Let next_pattern be proc parse_pattern_primary with parser
        If next_pattern is equal to 0:
            proc parser_report_error from Parser with parser, "Expected pattern after OR"
            Return 0
        End If

        Note: Add to alternatives array
        If alt_count is less than 10:
            proc memory_set_qword from Layout with alternatives, alt_count multiplied by 8, next_pattern
            Set alt_count to alt_count plus 1
        End If

        Note: Check for another OR
        Set current_token to proc parser_current_token from Parser with parser
        If current_token is equal to 0:
            Note: End of OR chain
            Set token_type to 0
        End If

        If current_token is not equal to 0:
            Set token_type to proc memory_get_qword from Layout with current_token, 0
        End If
    End While

    Note: Build OR pattern node
    Let line be proc parser_get_current_line from Parser with parser
    Let or_pattern be proc build_or_pattern from ASTBuilder with alternatives, alt_count, line

    Return or_pattern
End Process

Process called "parse_pattern_primary" takes parser as Integer returns Integer:
    Note:
    Parse primary pattern (atomic patterns and destructuring).
    Handles: wildcard, literals, identifiers, tuples, records, arrays,
    ranges, variants, and type patterns.
    :End Note

    Let current_token be proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        proc parser_report_error from Parser with parser, "Expected pattern"
        Return 0
    End If

    Let token_type be proc memory_get_qword from Layout with current_token, 0
    Let line be proc parser_get_current_line from Parser with parser

    Note: Wildcard pattern: _
    If token_type is equal to TOKEN_IDENTIFIER:
        Let token_value be proc memory_get_qword from Layout with current_token, 8
        Let is_underscore be proc string_compare from StringCore with token_value, "_"

        If is_underscore is equal to 1:
            proc parser_consume_token from Parser with parser
            Let wildcard be proc build_wildcard_pattern from ASTBuilder with line
            Return wildcard
        End If
    End If

    Note: Tuple pattern: (pattern1, pattern2, ...)
    If token_type is equal to TOKEN_LEFT_PAREN:
        Let tuple_pattern be proc parse_tuple_pattern with parser
        Return tuple_pattern
    End If

    Note: Record pattern: {field1, field2: pattern, ...}
    If token_type is equal to TOKEN_LEFT_BRACE:
        Let record_pattern be proc parse_record_pattern with parser
        Return record_pattern
    End If

    Note: Array pattern: [pattern1, pattern2, ...rest]
    If token_type is equal to TOKEN_LEFT_BRACKET:
        Let array_pattern be proc parse_array_pattern with parser
        Return array_pattern
    End If

    Note: Literal patterns (integer, string, boolean)
    If token_type is equal to TOKEN_INTEGER_LITERAL:
        Let value be proc memory_get_qword from Layout with current_token, 8
        proc parser_consume_token from Parser with parser
        Let literal be proc build_literal_pattern from ASTBuilder with value, 1, line
        Return literal
    End If

    If token_type is equal to TOKEN_STRING_LITERAL:
        Let value be proc memory_get_qword from Layout with current_token, 8
        proc parser_consume_token from Parser with parser
        Let literal be proc build_literal_pattern from ASTBuilder with value, 2, line
        Return literal
    End If

    If token_type is equal to TOKEN_TRUE:
        proc parser_consume_token from Parser with parser
        Let literal be proc build_literal_pattern from ASTBuilder with 1, 3, line
        Return literal
    End If

    If token_type is equal to TOKEN_FALSE:
        proc parser_consume_token from Parser with parser
        Let literal be proc build_literal_pattern from ASTBuilder with 0, 3, line
        Return literal
    End If

    Note: Identifier pattern (variable binding) or Variant pattern
    If token_type is equal to TOKEN_IDENTIFIER:
        Let identifier be proc memory_get_qword from Layout with current_token, 8
        proc parser_consume_token from Parser with parser

        Note: Check if this is a variant pattern (constructor with payload)
        Set current_token to proc parser_current_token from Parser with parser
        If current_token is not equal to 0:
            Set token_type to proc memory_get_qword from Layout with current_token, 0

            Note: Variant pattern: Constructor(inner_pattern)
            If token_type is equal to TOKEN_LEFT_PAREN:
                proc parser_consume_token from Parser with parser  Note: Consume (

                Note: Parse inner pattern
                Let inner_pattern be proc parse_pattern_primary with parser
                If inner_pattern is equal to 0:
                    proc parser_report_error from Parser with parser, "Expected pattern in variant constructor"
                    Return 0
                End If

                Note: Expect closing paren
                Let close_consumed be proc parser_expect_token from Parser with parser, TOKEN_RIGHT_PAREN
                If close_consumed is equal to 0:
                    proc parser_report_error from Parser with parser, "Expected ) after variant pattern"
                    Return 0
                End If

                Let variant_pattern be proc build_variant_pattern from ASTBuilder with identifier, inner_pattern, line
                Return variant_pattern
            End If
        End If

        Note: Check for range pattern: start..end or start..=end
        Set current_token to proc parser_current_token from Parser with parser
        If current_token is not equal to 0:
            Set token_type to proc memory_get_qword from Layout with current_token, 0

            Note: Range pattern with identifier as start
            If token_type is equal to TOKEN_RANGE:
                Note: Build literal pattern for range start
                Let start_pattern be proc build_identifier_pattern from ASTBuilder with identifier, line

                Let range_pattern be proc parse_range_pattern_continuation with parser, start_pattern
                Return range_pattern
            End If

            If token_type is equal to TOKEN_RANGE_INCLUSIVE:
                Let start_pattern be proc build_identifier_pattern from ASTBuilder with identifier, line

                Let range_pattern be proc parse_range_pattern_continuation with parser, start_pattern
                Return range_pattern
            End If
        End If

        Note: Simple identifier pattern (variable binding)
        Let ident_pattern be proc build_identifier_pattern from ASTBuilder with identifier, line
        Return ident_pattern
    End If

    Note: Range pattern starting with literal: 1..10 or 1..=100
    If token_type is equal to TOKEN_INTEGER_LITERAL:
        Let start_value be proc memory_get_qword from Layout with current_token, 8
        proc parser_consume_token from Parser with parser

        Set current_token to proc parser_current_token from Parser with parser
        If current_token is not equal to 0:
            Set token_type to proc memory_get_qword from Layout with current_token, 0

            If token_type is equal to TOKEN_RANGE:
                Let start_literal be proc build_literal_pattern from ASTBuilder with start_value, 1, line
                Let range_pattern be proc parse_range_pattern_continuation with parser, start_literal
                Return range_pattern
            End If

            If token_type is equal to TOKEN_RANGE_INCLUSIVE:
                Let start_literal be proc build_literal_pattern from ASTBuilder with start_value, 1, line
                Let range_pattern be proc parse_range_pattern_continuation with parser, start_literal
                Return range_pattern
            End If
        End If

        Note: Not a range, just a literal
        Let literal be proc build_literal_pattern from ASTBuilder with start_value, 1, line
        Return literal
    End If

    Note: Unrecognized pattern
    proc parser_report_error from Parser with parser, "Expected pattern (wildcard, literal, identifier, tuple, record, or array)"
    Return 0
End Process

Process called "parse_tuple_pattern" takes parser as Integer returns Integer:
    Note:
    Parse tuple pattern for tuple destructuring.
    Syntax: (pattern1, pattern2, pattern3)
    Returns AST_TUPLE_PATTERN node.
    :End Note

    Note: Consume left paren
    Let paren_consumed be proc parser_expect_token from Parser with parser, TOKEN_LEFT_PAREN
    If paren_consumed is equal to 0:
        Return 0
    End If

    Let line be proc parser_get_current_line from Parser with parser

    Note: Allocate array for tuple elements
    Let elements be proc arena_allocate from Layout with parser, 80  Note: Up to 10 elements
    Let element_count be 0

    Note: Parse tuple elements
    Let current_token be proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        proc parser_report_error from Parser with parser, "Unexpected end in tuple pattern"
        Return 0
    End If

    Let token_type be proc memory_get_qword from Layout with current_token, 0

    Note: Handle empty tuple ()
    If token_type is equal to TOKEN_RIGHT_PAREN:
        proc parser_consume_token from Parser with parser
        Let empty_tuple be proc build_tuple_pattern from ASTBuilder with elements, 0, line
        Return empty_tuple
    End If

    Note: Parse first element
    Let element be proc parse_pattern_primary with parser
    If element is equal to 0:
        proc parser_report_error from Parser with parser, "Expected pattern in tuple"
        Return 0
    End If

    proc memory_set_qword from Layout with elements, 0, element
    Set element_count to 1

    Note: Parse additional elements (comma-separated)
    Set current_token to proc parser_current_token from Parser with parser
    While current_token is not equal to 0:
        Set token_type to proc memory_get_qword from Layout with current_token, 0

        Note: Check for comma
        If token_type is not equal to TOKEN_COMMA:
            Note: No more elements
            Set current_token to 0
        End If

        If token_type is equal to TOKEN_COMMA:
            proc parser_consume_token from Parser with parser

            Note: Check for trailing comma
            Set current_token to proc parser_current_token from Parser with parser
            If current_token is equal to 0:
                proc parser_report_error from Parser with parser, "Expected pattern after comma"
                Return 0
            End If

            Set token_type to proc memory_get_qword from Layout with current_token, 0
            If token_type is equal to TOKEN_RIGHT_PAREN:
                Note: Trailing comma before ), stop parsing
                Set current_token to 0
            End If

            If token_type is not equal to TOKEN_RIGHT_PAREN:
                Note: Parse next element
                Set element to proc parse_pattern_primary with parser
                If element is equal to 0:
                    proc parser_report_error from Parser with parser, "Expected pattern in tuple"
                    Return 0
                End If

                Note: Add to elements array
                If element_count is less than 10:
                    proc memory_set_qword from Layout with elements, element_count multiplied by 8, element
                    Set element_count to element_count plus 1
                End If

                Set current_token to proc parser_current_token from Parser with parser
            End If
        End If
    End While

    Note: Expect closing paren
    Let close_consumed be proc parser_expect_token from Parser with parser, TOKEN_RIGHT_PAREN
    If close_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected ) after tuple pattern"
        Return 0
    End If

    Note: Build tuple pattern node
    Let tuple_pattern be proc build_tuple_pattern from ASTBuilder with elements, element_count, line

    Return tuple_pattern
End Process

Process called "parse_record_pattern" takes parser as Integer returns Integer:
    Note:
    Parse record pattern for record/struct destructuring.
    Syntax: {field1, field2: pattern, field3}
    Returns AST_RECORD_PATTERN node.
    :End Note

    Note: Consume left brace
    Let brace_consumed be proc parser_expect_token from Parser with parser, TOKEN_LEFT_BRACE
    If brace_consumed is equal to 0:
        Return 0
    End If

    Let line be proc parser_get_current_line from Parser with parser

    Note: Allocate array for field patterns (field_name, pattern pairs)
    Let fields be proc arena_allocate from Layout with parser, 160  Note: Up to 10 fields  16 bytes (name + pattern)
    Let field_count be 0

    Note: Parse field patterns
    Let current_token be proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        proc parser_report_error from Parser with parser, "Unexpected end in record pattern"
        Return 0
    End If

    Let token_type be proc memory_get_qword from Layout with current_token, 0

    Note: Handle empty record {}
    If token_type is equal to TOKEN_RIGHT_BRACE:
        proc parser_consume_token from Parser with parser
        Let empty_record be proc build_record_pattern from ASTBuilder with fields, 0, line
        Return empty_record
    End If

    Note: Parse field patterns
    While token_type is not equal to TOKEN_RIGHT_BRACE:
        Note: Parse field name
        If token_type is not equal to TOKEN_IDENTIFIER:
            proc parser_report_error from Parser with parser, "Expected field name in record pattern"
            Return 0
        End If

        Let field_name be proc memory_get_qword from Layout with current_token, 8
        proc parser_consume_token from Parser with parser

        Note: Check for colon (field: pattern) or shorthand (field)
        Set current_token to proc parser_current_token from Parser with parser
        If current_token is equal to 0:
            proc parser_report_error from Parser with parser, "Unexpected end in record pattern"
            Return 0
        End If

        Set token_type to proc memory_get_qword from Layout with current_token, 0

        Let field_pattern be 0

        Note: Field with explicit pattern: field: pattern
        If token_type is equal to TOKEN_COLON:
            proc parser_consume_token from Parser with parser

            Note: Parse field pattern
            Set field_pattern to proc parse_pattern_primary with parser
            If field_pattern is equal to 0:
                proc parser_report_error from Parser with parser, "Expected pattern after : in record pattern"
                Return 0
            End If
        End If

        Note: Shorthand field: field (binds to variable with same name)
        If token_type is not equal to TOKEN_COLON:
            Set field_pattern to proc build_identifier_pattern from ASTBuilder with field_name, line
        End If

        Note: Store field name and pattern as pair (field_name, pattern)
        Note: Each field takes 2 slots: [field_name_ptr, pattern_ptr]
        If field_count is less than 10:
            Note: Store field name at even index
            Let field_name_offset be field_count multiplied by 16
            proc memory_set_qword from Layout with fields, field_name_offset, field_name

            Note: Store pattern at odd index
            Let pattern_offset be field_name_offset plus 8
            proc memory_set_qword from Layout with fields, pattern_offset, field_pattern

            Set field_count to field_count plus 1
        End If

        Note: Check for comma or closing brace
        Set current_token to proc parser_current_token from Parser with parser
        If current_token is equal to 0:
            proc parser_report_error from Parser with parser, "Expected , or } in record pattern"
            Return 0
        End If

        Set token_type to proc memory_get_qword from Layout with current_token, 0

        If token_type is equal to TOKEN_COMMA:
            proc parser_consume_token from Parser with parser

            Note: Check for trailing comma
            Set current_token to proc parser_current_token from Parser with parser
            If current_token is equal to 0:
                proc parser_report_error from Parser with parser, "Expected field or } after comma"
                Return 0
            End If

            Set token_type to proc memory_get_qword from Layout with current_token, 0
            Note: Allow trailing comma before }
        End If
    End While

    Note: Expect closing brace
    Let close_consumed be proc parser_expect_token from Parser with parser, TOKEN_RIGHT_BRACE
    If close_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected } after record pattern"
        Return 0
    End If

    Note: Build record pattern node
    Let record_pattern be proc build_record_pattern from ASTBuilder with fields, field_count, line

    Return record_pattern
End Process

Process called "parse_array_pattern" takes parser as Integer returns Integer:
    Note:
    Parse array pattern for array/list destructuring.
    Syntax: [pattern1, pattern2, ...rest]
    Returns AST_ARRAY_PATTERN node.
    :End Note

    Note: Consume left bracket
    Let bracket_consumed be proc parser_expect_token from Parser with parser, TOKEN_LEFT_BRACKET
    If bracket_consumed is equal to 0:
        Return 0
    End If

    Let line be proc parser_get_current_line from Parser with parser

    Note: Allocate array for elements
    Let elements be proc arena_allocate from Layout with parser, 80  Note: Up to 10 elements
    Let element_count be 0
    Let has_rest be 0

    Note: Parse array elements
    Let current_token be proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        proc parser_report_error from Parser with parser, "Unexpected end in array pattern"
        Return 0
    End If

    Let token_type be proc memory_get_qword from Layout with current_token, 0

    Note: Handle empty array []
    If token_type is equal to TOKEN_RIGHT_BRACKET:
        proc parser_consume_token from Parser with parser
        Let empty_array be proc build_array_pattern from ASTBuilder with elements, 0, 0, line
        Return empty_array
    End If

    Note: Parse array elements
    While token_type is not equal to TOKEN_RIGHT_BRACKET:
        Note: Check for rest pattern: ...rest or ...
        If token_type is equal to TOKEN_DOT_DOT_DOT:
            proc parser_consume_token from Parser with parser
            Set has_rest to 1

            Note: Check if rest has a name: ...rest
            Set current_token to proc parser_current_token from Parser with parser
            If current_token is equal to 0:
                proc parser_report_error from Parser with parser, "Expected identifier or ] after ..."
                Return 0
            End If

            Set token_type to proc memory_get_qword from Layout with current_token, 0

            Let rest_name be 0

            Note: Rest with binding: ...rest
            If token_type is equal to TOKEN_IDENTIFIER:
                Set rest_name to proc memory_get_qword from Layout with current_token, 8
                proc parser_consume_token from Parser with parser
            End If

            Note: Build rest pattern and add to elements
            Let rest_pattern be proc build_rest_pattern from ASTBuilder with rest_name, line
            If element_count is less than 10:
                proc memory_set_qword from Layout with elements, element_count multiplied by 8, rest_pattern
                Set element_count to element_count plus 1
            End If

            Note: Rest pattern must be last element
            Set current_token to proc parser_current_token from Parser with parser
            If current_token is equal to 0:
                proc parser_report_error from Parser with parser, "Expected ] after rest pattern"
                Return 0
            End If

            Set token_type to proc memory_get_qword from Layout with current_token, 0

            Note: Allow optional trailing comma after rest
            If token_type is equal to TOKEN_COMMA:
                proc parser_consume_token from Parser with parser
                Set current_token to proc parser_current_token from Parser with parser
                If current_token is equal to 0:
                    proc parser_report_error from Parser with parser, "Expected ] after comma"
                    Return 0
                End If
                Set token_type to proc memory_get_qword from Layout with current_token, 0
            End If

            Note: Rest pattern must be last, expect closing bracket
            If token_type is not equal to TOKEN_RIGHT_BRACKET:
                proc parser_report_error from Parser with parser, "Rest pattern must be last element in array pattern"
                Return 0
            End If

            Note: Break out of loop, rest is last element
            Set token_type to TOKEN_RIGHT_BRACKET
        End If

        Note: Regular element pattern (not rest)
        If token_type is not equal to TOKEN_RIGHT_BRACKET:
            Note: Parse element pattern
            Let element be proc parse_pattern_primary with parser
            If element is equal to 0:
                proc parser_report_error from Parser with parser, "Expected pattern in array"
                Return 0
            End If

            Note: Add to elements array
            If element_count is less than 10:
                proc memory_set_qword from Layout with elements, element_count multiplied by 8, element
                Set element_count to element_count plus 1
            End If

            Note: Check for comma or closing bracket
            Set current_token to proc parser_current_token from Parser with parser
            If current_token is equal to 0:
                proc parser_report_error from Parser with parser, "Expected , or ] in array pattern"
                Return 0
            End If

            Set token_type to proc memory_get_qword from Layout with current_token, 0

            If token_type is equal to TOKEN_COMMA:
                proc parser_consume_token from Parser with parser

                Note: Check for trailing comma or next element
                Set current_token to proc parser_current_token from Parser with parser
                If current_token is equal to 0:
                    proc parser_report_error from Parser with parser, "Expected pattern or ] after comma"
                    Return 0
                End If

                Set token_type to proc memory_get_qword from Layout with current_token, 0
                Note: Allow trailing comma before ]
            End If
        End If
    End While

    Note: Expect closing bracket
    Let close_consumed be proc parser_expect_token from Parser with parser, TOKEN_RIGHT_BRACKET
    If close_consumed is equal to 0:
        proc parser_report_error from Parser with parser, "Expected ] after array pattern"
        Return 0
    End If

    Note: Build array pattern node
    Let array_pattern be proc build_array_pattern from ASTBuilder with elements, element_count, has_rest, line

    Return array_pattern
End Process

Process called "parse_range_pattern_continuation" takes parser as Integer, start_pattern as Integer returns Integer:
    Note:
    Parse range pattern continuation after start value.
    Handles: .. or ..= followed by end value.
    Returns AST_RANGE_PATTERN node.
    :End Note

    Let current_token be proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Return 0
    End If

    Let token_type be proc memory_get_qword from Layout with current_token, 0
    Let line be proc parser_get_current_line from Parser with parser

    Let inclusive be 0

    Note: Check range type
    If token_type is equal to TOKEN_RANGE:
        Set inclusive to 0
        proc parser_consume_token from Parser with parser
    End If

    If token_type is equal to TOKEN_RANGE_INCLUSIVE:
        Set inclusive to 1
        proc parser_consume_token from Parser with parser
    End If

    Note: Parse range end
    Set current_token to proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        proc parser_report_error from Parser with parser, "Expected end value in range pattern"
        Return 0
    End If

    Set token_type to proc memory_get_qword from Layout with current_token, 0

    Let end_pattern be 0

    Note: Parse end as literal or identifier
    If token_type is equal to TOKEN_INTEGER_LITERAL:
        Let end_value be proc memory_get_qword from Layout with current_token, 8
        proc parser_consume_token from Parser with parser
        Set end_pattern to proc build_literal_pattern from ASTBuilder with end_value, 1, line
    End If

    If token_type is equal to TOKEN_IDENTIFIER:
        Let end_identifier be proc memory_get_qword from Layout with current_token, 8
        proc parser_consume_token from Parser with parser
        Set end_pattern to proc build_identifier_pattern from ASTBuilder with end_identifier, line
    End If

    If end_pattern is equal to 0:
        proc parser_report_error from Parser with parser, "Expected integer or identifier for range end"
        Return 0
    End If

    Note: Build range pattern node
    Let range_pattern be proc build_range_pattern from ASTBuilder with start_pattern, end_pattern, inclusive, line

    Return range_pattern
End Process

Process called "parse_guard_condition" takes parser as Integer returns Integer:
    Note: Parse a guard condition for match arms
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to guard condition AST node
    Note:   Returns 0 if no guard condition

    If parser is equal to 0:
        Return 0
    End If

    Note: Check for guard keyword (if)
    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token

    Note: Guard conditions use "if" keyword
    Note: Example: When pattern if condition:
    If token_type is not equal to TOKEN_IF:
        Return 0  Note: No guard condition
    End If

    Note: Consume if keyword
    proc parser_consume_token from Parser with parser

    Note: Parse guard condition expression
    Let guard_expr be proc parse_expression from ExpressionParsers with parser
    If guard_expr is equal to 0:
        proc parser_report_error from Parser with parser, "Expected expression after guard 'if' keyword"
        Return 0
    End If

    Return guard_expr
End Process