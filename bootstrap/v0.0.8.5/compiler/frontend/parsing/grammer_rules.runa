Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file implements grammar rule validation for Runa parsing.

This file performs the following tasks:
- Validate grammar rules during parsing to ensure syntactic correctness
- Enforce syntactic constraints and language rules
- Validate encasing syntax patterns (Let [variable] be [value])
- Check block structure and indentation rules
- Validate parameter lists and type annotations
- Enforce End keyword matching for blocks

This file is essential because of the following reasons:
- Grammar validation ensures syntactic correctness during parsing
- Encasing syntax validation is critical for Runa's natural language features
- Block structure validation prevents malformed code
- Parameter and type validation ensures correct function definitions
- End keyword matching prevents unmatched blocks

This file consists of the following functions/features/operation types:
- Grammar rule validation and constraint enforcement
- Encasing syntax validation for natural language patterns
- Block structure and indentation validation
- Parameter list and type annotation validation
- End keyword matching and validation

Dependencies:
- Imports parser.runa for parser state and token navigation
- Imports ast.runa for AST node validation
- Imports lexical components for token recognition
- Imports memory/layout.runa for structure allocation
:End Note

Import "compiler/frontend/parsing/parser.runa" as Parser
Import "compiler/frontend/parsing/ast.runa" as AST
Import "compiler/frontend/lexical/keywords.runa" as Keywords
Import "compiler/frontend/lexical/operators.runa" as Operators
Import "compiler/frontend/lexical/delimiters.runa" as Delimiters
Import "compiler/frontend/primitives/memory/layout.runa" as Layout

Note: ============================================================================
Note: Grammar Rule Constants
Note: ============================================================================

Note: Validation result constants
Constant GRAMMAR_VALID as Integer is 1           Note: Grammar rule is valid
Constant GRAMMAR_INVALID as Integer is 0        Note: Grammar rule is invalid
Constant GRAMMAR_AMBIGUOUS as Integer is -1     Note: Grammar rule is ambiguous

Note: Encasing syntax validation constants
Constant ENCASING_VALID as Integer is 1         Note: Encasing syntax is valid
Constant ENCASING_MISSING_KEYWORD as Integer is 0 Note: Missing encasing keyword
Constant ENCASING_MISSING_IDENTIFIER as Integer is -1 Note: Missing identifier in encasing
Constant ENCASING_MISSING_VALUE as Integer is -2 Note: Missing value in encasing

Note: Block structure validation constants
Constant BLOCK_VALID as Integer is 1            Note: Block structure is valid
Constant BLOCK_MISSING_END as Integer is 0     Note: Missing End keyword
Constant BLOCK_MISMATCHED_END as Integer is -1 Note: Mismatched End keyword
Constant BLOCK_INVALID_INDENTATION as Integer is -2 Note: Invalid indentation

Note: Token type constants (from lexical modules)
Constant TOKEN_LET as Integer is 300         Note: Let keyword
Constant TOKEN_SET as Integer is 301         Note: Set keyword
Constant TOKEN_CONSTANT as Integer is 460    Note: Constant keyword
Constant TOKEN_IF as Integer is 310          Note: If keyword
Constant TOKEN_MATCH as Integer is 314       Note: Match keyword
Constant TOKEN_LOOP as Integer is 317        Note: Loop keyword
Constant TOKEN_PROCESS as Integer is 320     Note: Process keyword
Constant TOKEN_END as Integer is 430         Note: End keyword
Constant TOKEN_AS as Integer is 332          Note: As keyword
Constant TOKEN_COMMA as Integer is 207       Note: Comma delimiter
Constant TOKEN_COLON as Integer is 206       Note: Colon delimiter
Constant TOKEN_LEFT_BRACKET as Integer is 203   Note: [ delimiter
Constant TOKEN_RIGHT_BRACKET as Integer is 204  Note: ] delimiter

Note: ============================================================================
Note: Encasing Syntax Validation
Note: ============================================================================

Process called "validate_encasing_syntax" takes parser as Integer, keyword as Integer returns Integer:
    Note:
    Validate encasing syntax pattern (Let [variable] be [value])

    Parameters:
      parser - Pointer to ParserState
      keyword - Keyword token type (Let, Set, Define)

    Returns:
      ENCASING_VALID if syntax is valid
      Error code otherwise
    :End Note

    If parser is equal to 0:
        Return ENCASING_MISSING_KEYWORD
    End If

    Note: Get current token
    Let current_token be proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Return ENCASING_MISSING_KEYWORD
    End If

    Note: Check if current token matches expected keyword
    Let token_type be proc memory_get_qword from Layout with current_token, 0
    If token_type is not equal to keyword:
        Return ENCASING_MISSING_KEYWORD
    End If

    Note: Consume keyword
    proc parser_consume_token from Parser with parser

    Note: Check for identifier after keyword
    Set current_token to proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Return ENCASING_MISSING_IDENTIFIER
    End If

    Note: Peek next token to check for connector (be, to, as)
    Let next_token be proc parser_peek_token from Parser with parser
    If next_token is equal to 0:
        Return ENCASING_MISSING_VALUE
    End If

    Return ENCASING_VALID
End Process

Process called "validate_let_encasing" takes parser as Integer returns Integer:
    Note:
    Validate Let statement encasing syntax

    Pattern: Let [identifier] be [expression]
    :End Note

    Note: LET keyword type = TOKEN_LET (300)
    Return proc validate_encasing_syntax with parser, TOKEN_LET
End Process

Process called "validate_set_encasing" takes parser as Integer returns Integer:
    Note:
    Validate Set statement encasing syntax

    Pattern: Set [target] to [expression]
    :End Note

    Note: SET keyword type = TOKEN_SET (301)
    Return proc validate_encasing_syntax with parser, TOKEN_SET
End Process

Process called "validate_define_encasing" takes parser as Integer returns Integer:
    Note:
    Validate Constant declaration encasing syntax

    Pattern: Constant [identifier] as [expression]
    :End Note

    Note: CONSTANT keyword type = TOKEN_CONSTANT (460)
    Return proc validate_encasing_syntax with parser, TOKEN_CONSTANT
End Process

Process called "validate_process_encasing" takes parser as Integer returns Integer:
    Note:
    Validate Process definition encasing syntax

    Pattern: Process called [name] takes [params] returns [type]:
    :End Note

    If parser is equal to 0:
        Return ENCASING_MISSING_KEYWORD
    End If

    Note: Check for Process keyword
    Let current_token be proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Return ENCASING_MISSING_KEYWORD
    End If

    Note: Check for called keyword
    proc parser_consume_token from Parser with parser
    Set current_token to proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Return ENCASING_MISSING_IDENTIFIER
    End If

    Note: All required keywords present
    Return ENCASING_VALID
End Process

Note: ============================================================================
Note: Block Structure Validation
Note: ============================================================================

Process called "validate_block_structure" takes parser as Integer returns Integer:
    Note:
    Validate block structure and indentation

    Returns:
      BLOCK_VALID if structure is valid
      Error code otherwise
    :End Note

    If parser is equal to 0:
        Return BLOCK_MISSING_END
    End If

    Note: Check for colon to start block
    Let current_token be proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Return BLOCK_MISSING_END
    End If

    Note: Verify token is colon (TOKEN_COLON)
    Let token_type be proc memory_get_qword from Layout with current_token, 0

    Note: COLON token type = TOKEN_COLON (206)
    If token_type is not equal to TOKEN_COLON:
        Return BLOCK_INVALID_STRUCTURE
    End If

    Return BLOCK_VALID
End Process

Process called "validate_if_block_structure" takes parser as Integer returns Integer:
    Note:
    Validate If statement block structure
    :End Note

    Let result be proc validate_block_structure with parser
    If result is not equal to BLOCK_VALID:
        Return result
    End If

    Note: IF keyword type = TOKEN_IF (310)
    Return proc enforce_end_keyword with parser, TOKEN_IF
End Process

Process called "validate_match_block_structure" takes parser as Integer returns Integer:
    Note:
    Validate Match statement block structure
    :End Note

    Let result be proc validate_block_structure with parser
    If result is not equal to BLOCK_VALID:
        Return result
    End If

    Note: MATCH keyword type = TOKEN_MATCH (314)
    Return proc enforce_end_keyword with parser, TOKEN_MATCH
End Process

Process called "validate_loop_block_structure" takes parser as Integer returns Integer:
    Note:
    Validate loop block structure (For, While, Loop)
    :End Note

    Let result be proc validate_block_structure with parser
    If result is not equal to BLOCK_VALID:
        Return result
    End If

    Note: LOOP keyword type = TOKEN_LOOP (317)
    Return proc enforce_end_keyword with parser, TOKEN_LOOP
End Process

Process called "validate_process_block_structure" takes parser as Integer returns Integer:
    Note:
    Validate Process definition block structure
    :End Note

    Let result be proc validate_block_structure with parser
    If result is not equal to BLOCK_VALID:
        Return result
    End If

    Note: PROCESS keyword type = TOKEN_PROCESS (320)
    Return proc enforce_end_keyword with parser, TOKEN_PROCESS
End Process

Note: ============================================================================
Note: End Keyword Validation
Note: ============================================================================

Process called "enforce_end_keyword" takes parser as Integer, expected_end as Integer returns Integer:
    Note:
    Enforce matching End keyword for blocks

    Parameters:
      parser - Pointer to ParserState
      expected_end - Expected End keyword token type

    Returns:
      BLOCK_VALID if End keyword matches
      Error code otherwise
    :End Note

    If parser is equal to 0:
        Return BLOCK_MISSING_END
    End If

    Note: Check for END keyword
    Let current_token be proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Return BLOCK_MISSING_END
    End If

    Let token_type be proc memory_get_qword from Layout with current_token, 0

    Note: END keyword type = TOKEN_END (430)
    If token_type is not equal to TOKEN_END:
        Return BLOCK_MISSING_END
    End If

    Note: Consume END keyword
    proc parser_consume_token from Parser with parser

    Note: Check for expected keyword after END
    Set current_token to proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Return BLOCK_MISMATCHED_END
    End If

    Set token_type to proc memory_get_qword from Layout with current_token, 0
    If token_type is not equal to expected_end:
        Return BLOCK_MISMATCHED_END
    End If

    Note: Consume expected keyword
    proc parser_consume_token from Parser with parser

    Return BLOCK_VALID
End Process

Process called "validate_end_if" takes parser as Integer returns Integer:
    Note:
    Validate End If keyword
    :End Note

    Note: IF keyword type = TOKEN_IF (310)
    Return proc enforce_end_keyword with parser, TOKEN_IF
End Process

Process called "validate_end_match" takes parser as Integer returns Integer:
    Note:
    Validate End Match keyword
    :End Note

    Note: MATCH keyword type = 1050
    Return proc enforce_end_keyword with parser, 1050
End Process

Process called "validate_end_for" takes parser as Integer returns Integer:
    Note:
    Validate End For keyword
    :End Note

    Note: FOR keyword type = 1060
    Return proc enforce_end_keyword with parser, 1060
End Process

Process called "validate_end_while" takes parser as Integer returns Integer:
    Note:
    Validate End While keyword
    :End Note

    Note: WHILE keyword type = 1070
    Return proc enforce_end_keyword with parser, 1070
End Process

Process called "validate_end_loop" takes parser as Integer returns Integer:
    Note:
    Validate End Loop keyword
    :End Note

    Note: LOOP keyword type = 1080
    Return proc enforce_end_keyword with parser, 1080
End Process

Process called "validate_end_process" takes parser as Integer returns Integer:
    Note:
    Validate End Process keyword
    :End Note

    Note: PROCESS keyword type = 1090
    Return proc enforce_end_keyword with parser, 1090
End Process

Process called "validate_end_type" takes parser as Integer returns Integer:
    Note:
    Validate End Type keyword
    :End Note

    Note: TYPE keyword type = 1100
    Return proc enforce_end_keyword with parser, 1100
End Process

Note: ============================================================================
Note: Parameter List Validation
Note: ============================================================================

Process called "validate_parameter_list" takes parser as Integer returns Integer:
    Note:
    Validate parameter list syntax

    Pattern: takes param1 as Type1, param2 as Type2
    :End Note

    If parser is equal to 0:
        Return GRAMMAR_INVALID
    End If

    Note: Check current token (should be after takes keyword)
    Let current_token be proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Return GRAMMAR_VALID  Note: Empty parameter list
    End If

    Note: Validate each parameter
    Loop forever:
        Let result be proc validate_parameter_syntax with parser
        If result is not equal to GRAMMAR_VALID:
            Return result
        End If

        Note: Check for comma
        Set current_token to proc parser_current_token from Parser with parser
        If current_token is equal to 0:
            Break
        End If

        Let token_type be proc memory_get_qword from Layout with current_token, 0
        Note: COMMA delimiter type = TOKEN_COMMA (207)
        If token_type is not equal to TOKEN_COMMA:
            Break  Note: No more parameters
        End If

        Note: Consume comma and continue
        proc parser_consume_token from Parser with parser
    End Loop

    Return GRAMMAR_VALID
End Process

Process called "validate_parameter_syntax" takes parser as Integer returns Integer:
    Note:
    Validate individual parameter syntax

    Pattern: identifier as Type
    :End Note

    If parser is equal to 0:
        Return GRAMMAR_INVALID
    End If

    Note: Check for identifier
    Let current_token be proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Return GRAMMAR_INVALID
    End If

    Note: Consume identifier
    proc parser_consume_token from Parser with parser

    Note: Check for optional type annotation
    Set current_token to proc parser_current_token from Parser with parser
    If current_token is not equal to 0:
        Let token_type be proc memory_get_qword from Layout with current_token, 0
        Note: AS keyword type = TOKEN_AS (332)
        If token_type is equal to TOKEN_AS:
            Note: Has type annotation
            Return proc validate_type_annotation with parser
        End If
    End If

    Return GRAMMAR_VALID
End Process

Process called "validate_comma_separation" takes parser as Integer returns Integer:
    Note:
    Validate comma separation in parameter lists
    :End Note

    If parser is equal to 0:
        Return GRAMMAR_INVALID
    End If

    Note: Check for comma
    Let current_token be proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Return GRAMMAR_VALID  Note: No comma (end of list)
    End If

    Let token_type be proc memory_get_qword from Layout with current_token, 0
    Note: COMMA type = TOKEN_COMMA (207)
    If token_type is equal to TOKEN_COMMA:
        proc parser_consume_token from Parser with parser
        Return GRAMMAR_VALID
    End If

    Return GRAMMAR_INVALID
End Process

Note: ============================================================================
Note: Type Annotation Validation
Note: ============================================================================

Process called "validate_type_annotation" takes parser as Integer returns Integer:
    Note:
    Validate type annotation syntax

    Pattern: as Type
    :End Note

    If parser is equal to 0:
        Return GRAMMAR_INVALID
    End If

    Note: Verify current token is 'as' keyword
    Let current_token be proc parser_current_token from Parser with parser

    If current_token is equal to 0:
        Return GRAMMAR_INVALID
    End If

    Let token_type be proc memory_get_qword from Layout with current_token, 0

    Note: AS keyword token type = TOKEN_AS (332)
    If token_type is not equal to TOKEN_AS:
        Return GRAMMAR_INVALID
    End If

    Note: Consume 'as' keyword
    proc parser_consume_token from Parser with parser

    Note: Validate type expression after 'as'
    Return proc validate_type_expression with parser
End Process

Process called "validate_type_expression" takes parser as Integer returns Integer:
    Note:
    Validate type expression syntax

    Supports: basic types, generic types, union types, etc.
    :End Note

    If parser is equal to 0:
        Return GRAMMAR_INVALID
    End If

    Note: Check for type identifier
    Let current_token be proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Return GRAMMAR_INVALID
    End If

    Note: Consume type identifier
    proc parser_consume_token from Parser with parser

    Note: Check for generic type brackets
    Set current_token to proc parser_current_token from Parser with parser
    If current_token is not equal to 0:
        Let token_type be proc memory_get_qword from Layout with current_token, 0
        Note: LEFT_BRACKET type = TOKEN_LEFT_BRACKET (203)
        If token_type is equal to TOKEN_LEFT_BRACKET:
            Return proc validate_generic_type_syntax with parser
        End If
    End If

    Return GRAMMAR_VALID
End Process

Process called "validate_generic_type_syntax" takes parser as Integer returns Integer:
    Note:
    Validate generic type syntax

    Pattern: Type[TypeArg1, TypeArg2, ...]
    :End Note

    If parser is equal to 0:
        Return GRAMMAR_INVALID
    End If

    Note: Consume left bracket
    proc parser_consume_token from Parser with parser

    Note: Validate type arguments (at least one required)
    Let result be proc validate_type_expression with parser
    If result is not equal to GRAMMAR_VALID:
        Return result
    End If

    Note: Check for right bracket or comma
    Loop forever:
        Let current_token be proc parser_current_token from Parser with parser
        If current_token is equal to 0:
            Return GRAMMAR_INVALID
        End If

        Let token_type be proc memory_get_qword from Layout with current_token, 0

        Note: RIGHT_BRACKET type = TOKEN_RIGHT_BRACKET (204)
        If token_type is equal to TOKEN_RIGHT_BRACKET:
            proc parser_consume_token from Parser with parser
            Return GRAMMAR_VALID
        End If

        Note: COMMA type = TOKEN_COMMA (207)
        If token_type is equal to TOKEN_COMMA:
            proc parser_consume_token from Parser with parser
            Set result to proc validate_type_expression with parser
            If result is not equal to GRAMMAR_VALID:
                Return result
            End If
        End If
    End Loop

    Return GRAMMAR_INVALID
End Process

Note: ============================================================================
Note: Grammar Error Detection and Reporting
Note: ============================================================================

Process called "detect_grammar_error" takes parser as Integer, rule_type as Integer returns Integer:
    Note:
    Detect grammar rule violations

    Parameters:
      parser - Pointer to ParserState
      rule_type - Type of grammar rule being checked

    Returns:
      Error type constant if error detected, 0 if no error
    :End Note

    If parser is equal to 0:
        Return 1000  Note: Generic grammar error
    End If

    Note: Check current token validity
    Let current_token be proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Note: Check if at end of stream
        Let at_end be proc parser_is_at_end from Parser with parser
        If at_end is equal to 0:
            Return 1001  Note: Unexpected token error
        End If
    End If

    Note: No error detected
    Return 0
End Process

Process called "report_grammar_error" takes parser as Integer, error_type as Integer, message as Integer returns Integer:
    Note:
    Report a grammar rule violation

    Parameters:
      parser - Pointer to ParserState
      error_type - Error type constant
      message - Pointer to error message string

    Returns:
      1 on success (error reported)
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    If message is equal to 0:
        Return 0
    End If

    Note: Get current token line and column
    Let line be 0
    Let column be 0

    Let current_token be proc parser_current_token from Parser with parser
    If current_token is not equal to 0:
        Set line to proc memory_get_qword from Layout with current_token, 8
        Set column to proc memory_get_qword from Layout with current_token, 16
    End If

    Note: Report error using parser_report_error
    Return proc parser_report_error from Parser with parser, error_type, message, line, column
End Process

Process called "suggest_grammar_fix" takes parser as Integer, error_type as Integer returns Integer:
    Note:
    Suggest fix for grammar rule violations

    Parameters:
      parser - Pointer to ParserState
      error_type - Error type constant

    Returns:
      Pointer to suggestion string
      Returns 0 if no suggestion available
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Generate suggestion based on error type
    If error_type is less than 1100:
        Let suggestion be proc create_from_cstring from StringCore with "Check keyword syntax"
        Return proc to_cstring from StringCore with suggestion
    End If

    If error_type is less than 2000:
        Let suggestion be proc create_from_cstring from StringCore with "Check block structure and End keywords"
        Return proc to_cstring from StringCore with suggestion
    End If

    Let suggestion be proc create_from_cstring from StringCore with "Check grammar rule syntax"
    Return proc to_cstring from StringCore with suggestion
End Process

Note: ============================================================================
Note: Grammar Rule Utilities
Note: ============================================================================

Process called "is_grammar_rule_valid" takes result as Integer returns Integer:
    Note:
    Check if grammar rule validation result is valid

    Parameters:
      result - Grammar rule validation result

    Returns:
      1 if result indicates valid grammar, 0 otherwise
    :End Note

    If result is equal to GRAMMAR_VALID:
        Return 1
    End If

    If result is equal to ENCASING_VALID:
        Return 1
    End If

    If result is equal to BLOCK_VALID:
        Return 1
    End If

    Return 0
End Process

Process called "get_grammar_error_message" takes error_type as Integer returns Integer:
    Note:
    Get error message for grammar rule violation

    Parameters:
      error_type - Error type constant

    Returns:
      Pointer to error message string
      Returns 0 if error type not recognized
    :End Note

    Note: Generate message based on error type
    If error_type is equal to ENCASING_MISSING_KEYWORD:
        Let msg be proc create_from_cstring from StringCore with "Missing encasing keyword"
        Return proc to_cstring from StringCore with msg
    End If

    If error_type is equal to ENCASING_MISSING_IDENTIFIER:
        Let msg be proc create_from_cstring from StringCore with "Missing identifier in encasing"
        Return proc to_cstring from StringCore with msg
    End If

    If error_type is equal to ENCASING_MISSING_VALUE:
        Let msg be proc create_from_cstring from StringCore with "Missing value in encasing"
        Return proc to_cstring from StringCore with msg
    End If

    If error_type is equal to BLOCK_MISSING_END:
        Let msg be proc create_from_cstring from StringCore with "Missing End keyword"
        Return proc to_cstring from StringCore with msg
    End If

    If error_type is equal to BLOCK_MISMATCHED_END:
        Let msg be proc create_from_cstring from StringCore with "Mismatched End keyword"
        Return proc to_cstring from StringCore with msg
    End If

    If error_type is equal to BLOCK_INVALID_INDENTATION:
        Let msg be proc create_from_cstring from StringCore with "Invalid indentation"
        Return proc to_cstring from StringCore with msg
    End If

    Let msg be proc create_from_cstring from StringCore with "Unknown grammar error"
    Return proc to_cstring from StringCore with msg
End Process

Process called "grammar_rule_debug_print" takes parser as Integer, rule_type as Integer returns Integer:
    Note:
    Print grammar rule validation debug information

    Parameters:
      parser - Pointer to ParserState
      rule_type - Type of grammar rule being validated

    Returns:
      1 on success
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Get current token
    Let current_token be proc parser_current_token from Parser with parser

    If current_token is not equal to 0:
        Let token_type be proc memory_get_qword from Layout with current_token, 0
        Let line be proc memory_get_qword from Layout with current_token, 8
        Let column be proc memory_get_qword from Layout with current_token, 16

        Note: Print debug header
        Alert "=== Grammar Rule Validation Debug ===\n"

        Note: Print rule type
        Alert "Rule Type: "
        Let rule_type_str be proc integer_to_string from StringCore with rule_type
        Alert rule_type_str
        Alert "\n"

        Note: Print token type
        Alert "Token Type: "
        Let token_type_str be proc integer_to_string from StringCore with token_type
        Alert token_type_str
        Alert "\n"

        Note: Print location
        Alert "Location: Line "
        Let line_str be proc integer_to_string from StringCore with line
        Alert line_str
        Alert ", Column "
        Let column_str be proc integer_to_string from StringCore with column
        Alert column_str
        Alert "\n"

        Alert "=====================================\n"
    End If

    Return 1
End Process