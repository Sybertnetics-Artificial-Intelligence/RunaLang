Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file contains the main parser implementation for Runa source code.

This file performs the following tasks:
- Coordinate parsing of Runa source code into Abstract Syntax Trees
- Manage parsing state and token stream processing
- Handle parsing errors and recovery strategies
- Provide the primary interface for syntax analysis
- Support ownership tracking for v0.0.8.5 memory safety

This file is essential because of the following reasons:
- The parser is the core of the syntax analysis phase
- Proper parsing enables accurate AST construction and semantic analysis
- Parser coordination ensures consistent syntax analysis across all language features
- Ownership tracking integration enables memory safety analysis

This file consists of the following functions/features/operation types:
- Main parser orchestration and syntax analysis
- Token stream processing and parsing state management
- Integration with specialized parsing components
- AST construction and parsing error handling
- Ownership tracking state management for v0.0.8.5

Dependencies:
- Imports lexical/lexer.runa for tokenization
- Imports lexical/token_stream.runa for token navigation
- Imports ast.runa for AST node creation
- Imports all parsing components (expression_parsers, statement_parsers, etc.)
- Imports memory/layout.runa for structure allocation
:End Note

Import "compiler/frontend/lexical/lexer.runa" as Lexer
Import "compiler/frontend/lexical/token_stream.runa" as TokenStream
Import "compiler/frontend/parsing/ast.runa" as AST
Import "compiler/frontend/parsing/expression_parsers.runa" as ExpressionParsers
Import "compiler/frontend/parsing/statement_parsers.runa" as StatementParsers
Import "compiler/frontend/parsing/precedence.runa" as Precedence
Import "compiler/frontend/parsing/grammer_rules.runa" as GrammarRules
Import "compiler/frontend/parsing/error_recovery.runa" as ErrorRecovery
Import "compiler/frontend/parsing/annotation_parser.runa" as AnnotationParser
Import "compiler/frontend/parsing/macro_expansion.runa" as MacroExpansion
Import "compiler/frontend/parsing/type_annotations.runa" as TypeAnnotations
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/primitives/collections/list.runa" as List
Import "compiler/frontend/primitives/collections/stack.runa" as Stack
Import "compiler/frontend/primitives/collections/hashtable.runa" as HashTable
Import "compiler/frontend/diagnostics/diagnostics_engine.runa" as Diagnostics
Import "compiler/frontend/diagnostics/errors.runa" as Errors
Import "runtime/core/memory/arena.runa" as Arena

Note: ============================================================================
Note: Parser State Structure
Note: ============================================================================

Type called "ParserState":
    arena as Integer          Note: Pointer to Arena for temporary allocations
    token_stream as Integer   Note: Pointer to TokenStream for token navigation
    current_token as Integer  Note: Pointer to current token being processed
    errors as Integer         Note: Pointer to List of parsing errors
    error_count as Integer    Note: Number of parsing errors encountered
    ast_root as Integer       Note: Pointer to root AST node of parsed program
    context_stack as Integer  Note: Pointer to Stack of parsing contexts

    Note: Ownership tracking state (v0.0.8.5)
    ownership_table as Integer Note: Pointer to HashTable of variable ownership info
    current_scope as Integer   Note: Pointer to current scope for ownership tracking

    Note: Parsing configuration
    strict_mode as Integer     Note: Boolean: 1 for strict error handling
    allow_implicit_types as Integer Note: Boolean: 1 to allow type inference
    preserve_comments as Integer Note: Boolean: 1 to preserve comment nodes

    Note: Error recovery state
    recovery_mode as Integer   Note: Boolean: 1 if in error recovery mode
    sync_points as Integer     Note: Pointer to List of synchronization points

    Note: Diagnostics integration (v0.0.8.5)
    diagnostics_engine as Integer Note: OWNED DiagnosticsEngine for error reporting

Type called "ParsingContext":
    context_type as Integer    Note: Type of context (function, block, match, etc.)
    parent as Integer          Note: Pointer to parent context
    variables as Integer       Note: Pointer to HashTable of variables in scope
    ownership_state as Integer Note: Pointer to ownership tracking state
    line as Integer           Note: Line where context starts
    column as Integer         Note: Column where context starts

Note: Context type constants
Constant CONTEXT_GLOBAL as Integer is 0        Note: Global scope
Constant CONTEXT_FUNCTION as Integer is 1      Note: Function/process scope
Constant CONTEXT_BLOCK as Integer is 2         Note: Block scope
Constant CONTEXT_MATCH as Integer is 3         Note: Match statement scope
Constant CONTEXT_LOOP as Integer is 4          Note: Loop scope
Constant CONTEXT_TRY as Integer is 5           Note: Try block scope

Note: ============================================================================
Note: Parser Creation and Destruction
Note: ============================================================================

Process called "parser_create" takes token_stream as Integer, arena as Integer returns Integer:
    Note:
    Create a new parser with the given token stream

    Parameters:
      token_stream - Pointer to TokenStream to parse
      arena - Arena for temporary allocations during parsing

    Returns:
      Pointer to initialized ParserState structure
      Returns 0 on allocation failure
    :End Note

    Note: Validate input
    If token_stream is equal to 0:
        Return 0  Note: NULL token stream
    End If

    If arena is equal to 0:
        Return 0  Note: NULL arena
    End If

    Note: Allocate ParserState structure (16 fields Ã— 8 bytes = 128 bytes)
    Let parser_size be 128
    Let parser be proc allocate from Layout with parser_size

    If parser is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Store arena pointer (offset 0)
    proc memory_set_qword from Layout with parser, 0, arena

    Note: Initialize token_stream pointer (offset 8)
    proc memory_set_qword from Layout with parser, 8, token_stream

    Note: Get first token as current_token (offset 16)
    Let first_token be proc stream_current from TokenStream with token_stream
    proc memory_set_qword from Layout with parser, 16, first_token

    Note: Create errors List (offset 24)
    Let errors_list be proc create from List
    proc memory_set_qword from Layout with parser, 24, errors_list

    Note: Initialize error_count to 0 (offset 32)
    proc memory_set_qword from Layout with parser, 32, 0

    Note: Initialize ast_root to 0 (offset 40)
    proc memory_set_qword from Layout with parser, 40, 0

    Note: Create context_stack (offset 48)
    Let context_stack be proc create from Stack
    proc memory_set_qword from Layout with parser, 48, context_stack

    Note: Create ownership_table for v0.0.8.5 ownership tracking (offset 56)
    Let ownership_table be proc create from HashTable
    proc memory_set_qword from Layout with parser, 56, ownership_table

    Note: Initialize current_scope to 0 (offset 64)
    proc memory_set_qword from Layout with parser, 64, 0

    Note: Set default configuration flags
    Note: strict_mode = 0 (permissive by default) (offset 72)
    proc memory_set_qword from Layout with parser, 72, 0

    Note: allow_implicit_types = 1 (allow type inference) (offset 80)
    proc memory_set_qword from Layout with parser, 80, 1

    Note: preserve_comments = 0 (don't preserve by default) (offset 88)
    proc memory_set_qword from Layout with parser, 88, 0

    Note: Initialize error recovery state
    Note: recovery_mode = 0 (not in recovery) (offset 96)
    proc memory_set_qword from Layout with parser, 96, 0

    Note: Create sync_points List (offset 104)
    Let sync_points be proc create from List
    proc memory_set_qword from Layout with parser, 104, sync_points

    Note: Create diagnostics engine for error reporting (offset 112)
    Let diagnostics_engine be proc diagnostics_engine_create from Diagnostics with arena

    If diagnostics_engine is equal to 0:
        Note: Cleanup on failure - cascade cleanup
        If sync_points is not equal to 0:
            proc destroy from List with sync_points
        End If
        If ownership_table is not equal to 0:
            proc destroy from HashTable with ownership_table
        End If
        If context_stack is not equal to 0:
            proc destroy from Stack with context_stack
        End If
        If errors_list is not equal to 0:
            proc destroy from List with errors_list
        End If
        proc deallocate from Layout with parser
        Return 0  Note: Diagnostics engine creation failed
    End If

    proc memory_set_qword from Layout with parser, 112, diagnostics_engine

    Note: Push global context onto context stack
    proc parser_push_context with parser, CONTEXT_GLOBAL, 1, 1

    Return parser
End Process

Process called "parser_destroy" takes parser as Integer returns Integer:
    Note:
    Destroy parser and clean up all resources

    Parameters:
      parser - Pointer to ParserState to destroy

    Returns:
      1 on success, 0 on failure
    :End Note

    Note: Validate input
    If parser is equal to 0:
        Return 0  Note: NULL parser
    End If

    Note: Get ast_root (offset 40)
    Let ast_root be proc memory_get_qword from Layout with parser, 40

    Note: Destroy AST tree if present
    If ast_root is not equal to 0:
        proc destroy_ast_node from AST with ast_root
    End If

    Note: Get errors list (offset 24)
    Let errors_list be proc memory_get_qword from Layout with parser, 24

    Note: Destroy errors list
    If errors_list is not equal to 0:
        proc destroy from List with errors_list
    End If

    Note: Get context_stack (offset 48)
    Let context_stack be proc memory_get_qword from Layout with parser, 48

    Note: Pop and destroy all contexts
    If context_stack is not equal to 0:
        Loop forever:
            Let is_empty be proc is_empty from Stack with context_stack

            If is_empty is equal to 1:
                Break
            End If

            Note: Pop context
            Let context be proc pop from Stack with context_stack

            Note: Destroy context variables hashtable if present
            If context is not equal to 0:
                Let variables be proc memory_get_qword from Layout with context, 16
                If variables is not equal to 0:
                    proc destroy from HashTable with variables
                End If

                Note: Deallocate context structure
                proc deallocate from Layout with context
            End If
        End Loop

        Note: Destroy context stack itself
        proc destroy from Stack with context_stack
    End If

    Note: Get ownership_table (offset 56)
    Let ownership_table be proc memory_get_qword from Layout with parser, 56

    Note: Destroy ownership table
    If ownership_table is not equal to 0:
        proc destroy from HashTable with ownership_table
    End If

    Note: Get sync_points list (offset 104)
    Let sync_points be proc memory_get_qword from Layout with parser, 104

    Note: Destroy sync_points list
    If sync_points is not equal to 0:
        proc destroy from List with sync_points
    End If

    Note: Destroy diagnostics_engine (offset 112)
    Let diagnostics_engine be proc memory_get_qword from Layout with parser, 112

    If diagnostics_engine is not equal to 0:
        proc diagnostics_engine_destroy from Diagnostics with diagnostics_engine
    End If

    Note: Deallocate ParserState structure
    proc deallocate from Layout with parser

    Return 1
End Process

Note: ============================================================================
Note: Main Parsing Entry Points
Note: ============================================================================

Process called "parser_parse_program" takes parser as Integer returns Integer:
    Note:
    Parse a complete Runa program into AST

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to root AST node of the program
      Returns 0 on parsing failure

    Program structure:
      - Zero or more declarations (Process, Type, Import, Protocol, External)
      - Zero or more statements
      - Zero or more AI annotations

    Algorithm:
    1. Create root AST node (AST_PROGRAM type)
    2. While not at end of token stream:
       - Try to parse declaration
       - If not declaration, try to parse statement
       - If none match, report error and synchronize
    3. Set parser.ast_root to root node
    4. Return root node
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Create root AST node (AST_PROGRAM = 3000)
    Let root_node be proc create_ast_node from AST with 3000

    If root_node is equal to 0:
        Return 0
    End If

    Note: Create children list for program elements
    Let children be proc create from List

    Note: Parse until end of token stream
    Loop forever:
        Let at_end be proc parser_is_at_end with parser

        If at_end is equal to 1:
            Break
        End If

        Note: Try to parse declaration
        Let decl_node be proc parser_parse_declaration with parser

        If decl_node is not equal to 0:
            proc append from List with children, decl_node
        Otherwise:
            Note: Try to parse statement
            Let stmt_node be proc parser_parse_statement with parser

            If stmt_node is not equal to 0:
                proc append from List with children, stmt_node
            Otherwise:
                Note: Cannot parse - report error and synchronize
                Let current_token be proc parser_current_token with parser

                If current_token is not equal to 0:
                    Let line be proc memory_get_qword from Layout with current_token, 8
                    Let column be proc memory_get_qword from Layout with current_token, 16
                    proc parser_report_error with parser, 1, proc string_create from StringCore with "Unexpected token", line, column
                End If

                Note: Synchronize to next statement boundary
                proc parser_synchronize with parser
            End If
        End If
    End Loop

    Note: Attach children to root node
    proc ast_node_set_children from AST with root_node, children

    Note: Set parser.ast_root (offset 32)
    proc memory_set_qword from Layout with parser, 32, root_node

    Return root_node
End Process

Process called "parser_parse_declaration" takes parser as Integer returns Integer:
    Note:
    Parse a declaration (Process, Type, Import, Protocol, External)

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to declaration AST node
      Returns 0 if not a declaration or parsing error

    Declaration types:
      - Process definition: "Process called name takes params returns type:"
      - Type definition: "Type called name: ... End Type"
      - Import statement: "Import 'path' as Alias"
      - Constant declaration: "Constant name as Type is value"
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Get current token
    Let current_token be proc parser_current_token with parser

    If current_token is equal to 0:
        Return 0
    End If

    Note: Get token value to check for keywords
    Let token_value be proc memory_get_qword from Layout with current_token, 24

    If token_value is equal to 0:
        Return 0
    End If

    Note: Check for Process keyword
    Let is_process be proc string_equals from StringCore with token_value, proc string_create from StringCore with "Process"

    If is_process is equal to 1:
        Note: Parse process definition using StatementParsers
        Let process_node be proc parse_process_definition from StatementParsers with parser

        If process_node is equal to 0:
            Note: Process parsing failed - report error
            Let error_msg be proc string_create from StringCore with "Failed to parse process definition"
            proc parser_report_error from Parser with parser, error_msg
            Return 0
        End If

        Return process_node
    End If

    Note: Check for Type keyword
    Let is_type be proc string_equals from StringCore with token_value, proc string_create from StringCore with "Type"

    If is_type is equal to 1:
        Note: Parse type definition
        Let type_node be proc create_ast_node from AST with 3002
        proc parser_consume_token with parser
        Return type_node
    End If

    Note: Check for Import keyword
    Let is_import be proc string_equals from StringCore with token_value, proc string_create from StringCore with "Import"

    If is_import is equal to 1:
        Note: Parse import statement
        Let import_node be proc create_ast_node from AST with 3003
        proc parser_consume_token with parser
        Return import_node
    End If

    Note: Check for Constant keyword
    Let is_constant be proc string_equals from StringCore with token_value, proc string_create from StringCore with "Constant"

    If is_constant is equal to 1:
        Note: Parse constant declaration
        Let constant_node be proc create_ast_node from AST with 3004
        proc parser_consume_token with parser
        Return constant_node
    End If

    Note: Not a declaration
    Return 0
End Process

Process called "parser_parse_statement" takes parser as Integer returns Integer:
    Note:
    Parse a statement (Let, Set, Define, If, Match, For, While, etc.)

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to statement AST node
      Returns 0 if not a statement or parsing error

    Statement types:
      - Simple: Let, Set, Return, Break, Continue
      - Compound: If/Otherwise, Match/When, For, While, Loop
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Get current token
    Let current_token be proc parser_current_token with parser

    If current_token is equal to 0:
        Return 0
    End If

    Note: Get token value
    Let token_value be proc memory_get_qword from Layout with current_token, 24

    If token_value is equal to 0:
        Return 0
    End If

    Note: Check for Let keyword
    Let is_let be proc string_equals from StringCore with token_value, proc string_create from StringCore with "Let"

    If is_let is equal to 1:
        Let let_node be proc create_ast_node from AST with 2001
        proc parser_consume_token with parser
        Return let_node
    End If

    Note: Check for Set keyword
    Let is_set be proc string_equals from StringCore with token_value, proc string_create from StringCore with "Set"

    If is_set is equal to 1:
        Let set_node be proc create_ast_node from AST with 2002
        proc parser_consume_token with parser
        Return set_node
    End If

    Note: Check for Return keyword
    Let is_return be proc string_equals from StringCore with token_value, proc string_create from StringCore with "Return"

    If is_return is equal to 1:
        Let return_node be proc create_ast_node from AST with 2003
        proc parser_consume_token with parser
        Return return_node
    End If

    Note: Check for If keyword
    Let is_if be proc string_equals from StringCore with token_value, proc string_create from StringCore with "If"

    If is_if is equal to 1:
        Let if_node be proc create_ast_node from AST with 2004
        proc parser_consume_token with parser
        Return if_node
    End If

    Note: Check for For keyword
    Let is_for be proc string_equals from StringCore with token_value, proc string_create from StringCore with "For"

    If is_for is equal to 1:
        Let for_node be proc create_ast_node from AST with 2005
        proc parser_consume_token with parser
        Return for_node
    End If

    Note: Check for While keyword
    Let is_while be proc string_equals from StringCore with token_value, proc string_create from StringCore with "While"

    If is_while is equal to 1:
        Let while_node be proc create_ast_node from AST with 2006
        proc parser_consume_token with parser
        Return while_node
    End If

    Note: Check for Loop keyword
    Let is_loop be proc string_equals from StringCore with token_value, proc string_create from StringCore with "Loop"

    If is_loop is equal to 1:
        Let loop_node be proc create_ast_node from AST with 2007
        proc parser_consume_token with parser
        Return loop_node
    End If

    Note: Not a statement
    Return 0
End Process

Note: ============================================================================
Note: Token Navigation and Processing
Note: ============================================================================

Process called "parser_current_token" takes parser as Integer returns Integer:
    Note:
    Get the current token being processed

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to current Token
      Returns 0 if at end of stream
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Get current_token (offset 16)
    Let current_token be proc memory_get_qword from Layout with parser, 16

    Return current_token
End Process

Process called "parser_peek_token" takes parser as Integer, lookahead as Integer returns Integer:
    Note:
    Peek at a token without consuming it

    Parameters:
      parser - Pointer to ParserState
      lookahead - Number of tokens to look ahead (0=current, 1=next, etc.)

    Returns:
      Pointer to token at lookahead position
      Returns 0 if beyond end of stream
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Get token_stream (offset 8)
    Let token_stream be proc memory_get_qword from Layout with parser, 8

    If token_stream is equal to 0:
        Return 0
    End If

    Note: Peek at token using TokenStream
    Let peeked_token be proc stream_peek from TokenStream with token_stream, lookahead

    Return peeked_token
End Process

Process called "parser_consume_token" takes parser as Integer returns Integer:
    Note:
    Consume current token and advance to next

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to consumed token
      Returns 0 if at end of stream

    Side Effects:
      - Advances parser.current_token to next token
      - Updates position tracking
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Get current token (offset 16)
    Let current_token be proc memory_get_qword from Layout with parser, 16

    Note: Get token_stream (offset 8)
    Let token_stream be proc memory_get_qword from Layout with parser, 8

    If token_stream is equal to 0:
        Return current_token
    End If

    Note: Consume token from stream
    proc stream_consume from TokenStream with token_stream

    Note: Get new current token
    Let new_token be proc stream_current from TokenStream with token_stream

    Note: Update parser.current_token (offset 16)
    proc memory_set_qword from Layout with parser, 16, new_token

    Return current_token
End Process

Process called "parser_expect_token" takes parser as Integer, expected_type as Integer returns Integer:
    Note:
    Expect a specific token type and consume it

    Parameters:
      parser - Pointer to ParserState
      expected_type - Token type constant to expect

    Returns:
      Pointer to consumed token if match
      Returns 0 if token doesn't match (error reported)

    Side Effects:
      - If match: consumes token and advances
      - If no match: reports error
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Get current token
    Let current_token be proc parser_current_token with parser

    If current_token is equal to 0:
        Return 0
    End If

    Note: Get token type
    Let token_type be proc memory_get_qword from Layout with current_token, 0

    Note: Check if token type matches expected
    If token_type is equal to expected_type:
        Note: Match - consume and return
        Return proc parser_consume_token with parser
    End If

    Note: No match - report error
    Let line be proc memory_get_qword from Layout with current_token, 8
    Let column be proc memory_get_qword from Layout with current_token, 16

    proc parser_report_error with parser, 1, proc string_create from StringCore with "Unexpected token", line, column

    Return 0
End Process

Process called "parser_match_keyword" takes parser as Integer, keyword as Integer returns Integer:
    Note:
    Check if current token is a specific keyword

    Parameters:
      parser - Pointer to ParserState
      keyword - Keyword token type constant to match

    Returns:
      1 if current token matches keyword, 0 otherwise

    Does NOT consume the token - just checks for match
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Get current token
    Let current_token be proc parser_current_token with parser

    If current_token is equal to 0:
        Return 0
    End If

    Note: Get token type
    Let token_type be proc memory_get_qword from Layout with current_token, 0

    Note: Check if token type matches keyword
    If token_type is equal to keyword:
        Return 1
    End If

    Return 0
End Process

Note: ============================================================================
Note: Context Management
Note: ============================================================================

Process called "parser_push_context" takes parser as Integer, context_type as Integer, line as Integer, column as Integer returns Integer:
    Note:
    Push a new parsing context onto the context stack

    Parameters:
      parser - Pointer to ParserState
      context_type - Type of context (CONTEXT_FUNCTION, CONTEXT_BLOCK, etc.)
      line - Line number where context starts
      column - Column number where context starts

    Returns:
      Pointer to new ParsingContext
      Returns 0 on allocation failure

    Side Effects:
      - Creates new ParsingContext
      - Pushes context onto parser.context_stack
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Allocate ParsingContext structure (5 fields Ã— 8 bytes = 40 bytes)
    Let context be proc allocate from Layout with 40

    If context is equal to 0:
        Return 0
    End If

    Note: Initialize context fields
    Note: context_type (offset 0)
    proc memory_set_qword from Layout with context, 0, context_type

    Note: depth = current stack size + 1 (offset 8)
    Let context_stack be proc memory_get_qword from Layout with parser, 48
    Let depth be 1

    If context_stack is not equal to 0:
        Set depth to proc size from Stack with context_stack
        Set depth to depth plus 1
    End If

    proc memory_set_qword from Layout with context, 8, depth

    Note: Create variables hashtable for this context (offset 16)
    Let variables be proc create from HashTable
    proc memory_set_qword from Layout with context, 16, variables

    Note: line (offset 24)
    proc memory_set_qword from Layout with context, 24, line

    Note: column (offset 32)
    proc memory_set_qword from Layout with context, 32, column

    Note: Push context onto stack
    If context_stack is not equal to 0:
        proc push from Stack with context_stack, context
    End If

    Return context
End Process

Process called "parser_pop_context" takes parser as Integer returns Integer:
    Note:
    Pop the current parsing context from the context stack

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to popped ParsingContext
      Returns 0 if context stack is empty

    Side Effects:
      - Pops context from parser.context_stack
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Get context_stack (offset 48)
    Let context_stack be proc memory_get_qword from Layout with parser, 48

    If context_stack is equal to 0:
        Return 0
    End If

    Note: Check if stack is empty
    Let is_empty be proc is_empty from Stack with context_stack

    If is_empty is equal to 1:
        Return 0
    End If

    Note: Pop context from stack
    Let context be proc pop from Stack with context_stack

    Return context
End Process

Process called "parser_get_current_context" takes parser as Integer returns Integer:
    Note:
    Get the current parsing context

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to current ParsingContext
      Returns 0 if no context
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Get context_stack (offset 48)
    Let context_stack be proc memory_get_qword from Layout with parser, 48

    If context_stack is equal to 0:
        Return 0
    End If

    Note: Peek at top of stack
    Let context be proc peek from Stack with context_stack

    Return context
End Process

Note: ============================================================================
Note: Ownership Tracking (v0.0.8.5)
Note: ============================================================================

Process called "parser_track_variable_ownership" takes parser as Integer, variable_name as Integer, operation as Integer returns Integer:
    Note:
    Track ownership operation for a variable

    Parameters:
      parser - Pointer to ParserState
      variable_name - Pointer to variable name string
      operation - Ownership operation (move, borrow, mutable_borrow)

    Returns:
      1 on success, 0 on failure

    Side Effects:
      - Updates ownership tracking in parser.ownership_table
      - Reports ownership violations if detected
      - Updates current scope ownership state
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    If variable_name is equal to 0:
        Return 0
    End If

    Note: Get ownership_table (offset 56)
    Let ownership_table be proc memory_get_qword from Layout with parser, 56

    If ownership_table is equal to 0:
        Note: Create ownership_table if not exists
        Set ownership_table to proc create from HashTable
        proc memory_set_qword from Layout with parser, 56, ownership_table
    End If

    Note: Check if variable already tracked
    Let existing_info be proc get from HashTable with ownership_table, variable_name

    If existing_info is not equal to 0:
        Note: Variable already tracked - validate operation
        Let current_ownership be proc memory_get_qword from Layout with existing_info, 0

        Note: Ownership states: 0=owned, 1=moved, 2=borrowed, 3=mutable_borrowed
        Note: Operation types: 0=move, 1=borrow, 2=mutable_borrow

        Note: Check for ownership violations
        If current_ownership is equal to 1:
            Note: Variable already moved - report error
            proc parser_report_error with parser, 1, proc string_create from StringCore with "Use of moved variable", 0, 0
            Return 0
        End If

        If operation is equal to 0:
            Note: Move operation - mark as moved
            proc memory_set_qword from Layout with existing_info, 0, 1
        Otherwise if operation is equal to 1:
            Note: Borrow operation - check for mutable borrow conflicts
            If current_ownership is equal to 3:
                proc parser_report_error with parser, 1, proc string_create from StringCore with "Cannot borrow while mutably borrowed", 0, 0
                Return 0
            End If
            proc memory_set_qword from Layout with existing_info, 0, 2
        Otherwise if operation is equal to 2:
            Note: Mutable borrow operation - check for any borrow conflicts
            If current_ownership is equal to 2:
                proc parser_report_error with parser, 1, proc string_create from StringCore with "Cannot mutably borrow while borrowed", 0, 0
                Return 0
            End If
            If current_ownership is equal to 3:
                proc parser_report_error with parser, 1, proc string_create from StringCore with "Cannot mutably borrow multiple times", 0, 0
                Return 0
            End If
            proc memory_set_qword from Layout with existing_info, 0, 3
        End If
    Otherwise:
        Note: Variable not tracked - create new OwnershipInfo (3 fields Ã— 8 bytes = 24 bytes)
        Let info be proc allocate from Layout with 24

        If info is equal to 0:
            Return 0
        End If

        Note: Initialize OwnershipInfo fields
        Note: ownership_state (offset 0) - set based on operation
        If operation is equal to 0:
            proc memory_set_qword from Layout with info, 0, 1
        Otherwise if operation is equal to 1:
            proc memory_set_qword from Layout with info, 0, 2
        Otherwise if operation is equal to 2:
            proc memory_set_qword from Layout with info, 0, 3
        Otherwise:
            proc memory_set_qword from Layout with info, 0, 0
        End If

        Note: scope (offset 8) - get from parser.current_scope (offset 64)
        Let current_scope be proc memory_get_qword from Layout with parser, 64
        proc memory_set_qword from Layout with info, 8, current_scope

        Note: line (offset 16) - get from current token
        Let current_token be proc parser_current_token with parser
        Let line be 0

        If current_token is not equal to 0:
            Set line to proc memory_get_qword from Layout with current_token, 8
        End If

        proc memory_set_qword from Layout with info, 16, line

        Note: Add to ownership_table
        proc set from HashTable with ownership_table, variable_name, info
    End If

    Return 1
End Process

Process called "parser_get_variable_ownership" takes parser as Integer, variable_name as Integer returns Integer:
    Note:
    Get ownership information for a variable

    Parameters:
      parser - Pointer to ParserState
      variable_name - Pointer to variable name string

    Returns:
      Pointer to OwnershipInfo structure
      Returns 0 if variable not found
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    If variable_name is equal to 0:
        Return 0
    End If

    Note: Get ownership_table (offset 56)
    Let ownership_table be proc memory_get_qword from Layout with parser, 56

    If ownership_table is equal to 0:
        Return 0
    End If

    Note: Retrieve ownership info from hashtable
    Let info be proc get from HashTable with ownership_table, variable_name

    Return info
End Process

Note: ============================================================================
Note: Error Handling and Recovery
Note: ============================================================================

Process called "parser_report_error" takes parser as Integer, error_type as Integer, message as Integer, line as Integer, column as Integer returns Integer:
    Note: Report a parsing error using diagnostics system
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:   error_type - Error type constant
    Note:   message - Pointer to error message string
    Note:   line - Line number where error occurs
    Note:   column - Column number where error occurs
    Note:
    Note: Returns:
    Note:   1 on success (error reported)
    Note:
    Note: Side Effects:
    Note:   - Reports error to diagnostics_engine
    Note:   - Increments parser.error_count
    Note:   - May trigger error recovery mode
    :End Note

    Note: Validate parser
    If parser is equal to 0:
        Return 0  Note: NULL parser
    End If

    Note: Get arena from parser (offset 0)
    Let arena be proc memory_get_qword from Layout with parser, 0

    Note: Get diagnostics_engine from parser (offset 112)
    Let diagnostics_engine be proc memory_get_qword from Layout with parser, 112

    Note: Report error to diagnostics system
    If diagnostics_engine is not equal to 0:
        If arena is not equal to 0:
            Note: Create ErrorInfo structure in arena (15 fields Ã— 8 bytes = 120 bytes)
            Let error_info be proc arena_allocate from Arena with arena, 120

            If error_info is not equal to 0:
                Note: Get token_stream to extract source file if available
                Let token_stream be proc memory_get_qword from Layout with parser, 8
                Let source_file be 0  Note: Default to NULL

                Note: Determine if error is recoverable based on error type
                Let is_recoverable be 1  Note: Most parsing errors are recoverable

                Note: Initialize ErrorInfo fields
                proc memory_set_qword from Layout with error_info, 0, 0               Note: error_id
                proc memory_set_qword from Layout with error_info, 8, 2001            Note: error_code (PARSING_ERROR)
                proc memory_set_qword from Layout with error_info, 16, 2              Note: error_type (ERROR_TYPE_PARSING)
                proc memory_set_qword from Layout with error_info, 24, 2              Note: category (PARSING)
                proc memory_set_qword from Layout with error_info, 32, 1              Note: severity (ERROR)
                proc memory_set_qword from Layout with error_info, 40, line           Note: line_number
                proc memory_set_qword from Layout with error_info, 48, column         Note: column_number
                proc memory_set_qword from Layout with error_info, 56, message        Note: message
                proc memory_set_qword from Layout with error_info, 64, 0              Note: context
                proc memory_set_qword from Layout with error_info, 72, 0              Note: suggestion
                proc memory_set_qword from Layout with error_info, 80, 0              Note: related_errors
                proc memory_set_qword from Layout with error_info, 88, source_file    Note: source_file
                proc memory_set_qword from Layout with error_info, 96, 1              Note: phase (PARSING_PHASE)
                proc memory_set_qword from Layout with error_info, 104, is_recoverable Note: is_recoverable
                proc memory_set_qword from Layout with error_info, 112, 100           Note: confidence

                Note: Collect error through diagnostics engine
                Let collect_result be proc diagnostics_engine_collect_error from Diagnostics with diagnostics_engine, error_info, 1, arena
            End If
        End If
    End If

    Note: Increment parser.error_count (offset 32)
    Let error_count be proc memory_get_qword from Layout with parser, 32
    Set error_count to error_count plus 1
    proc memory_set_qword from Layout with parser, 32, error_count

    Return 1
End Process

Process called "parser_synchronize" takes parser as Integer returns Integer:
    Note:
    Synchronize parser after error (panic-mode recovery)

    Parameters:
      parser - Pointer to ParserState

    Returns:
      1 on success, 0 on failure

    Recovery strategy:
      - Skip tokens until synchronization point found
      - Synchronization points: statement boundaries, block endings
      - Reset parser state to known good position
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Get token_stream (offset 8)
    Let token_stream be proc memory_get_qword from Layout with parser, 8

    If token_stream is equal to 0:
        Return 0
    End If

    Note: Get sync_points list (offset 104)
    Let sync_points be proc memory_get_qword from Layout with parser, 104

    Note: Delegate to ErrorRecovery.parser_synchronize
    Let result be proc parser_synchronize from ErrorRecovery with parser, token_stream, sync_points

    Note: Update parser.current_token after synchronization (offset 16)
    Let new_token be proc stream_current from TokenStream with token_stream
    proc memory_set_qword from Layout with parser, 16, new_token

    Note: Set recovery_mode to active (offset 96)
    proc memory_set_qword from Layout with parser, 96, 1

    Return result
End Process

Note: ============================================================================
Note: Utility Functions
Note: ============================================================================

Process called "parser_is_at_end" takes parser as Integer returns Integer:
    Note:
    Check if parser has reached end of token stream

    Parameters:
      parser - Pointer to ParserState

    Returns:
      1 if at end of stream, 0 otherwise
    :End Note

    If parser is equal to 0:
        Return 1
    End If

    Note: Get token_stream (offset 8)
    Let token_stream be proc memory_get_qword from Layout with parser, 8

    If token_stream is equal to 0:
        Return 1
    End If

    Note: Check if at end using TokenStream.stream_is_at_end
    Let at_end be proc stream_is_at_end from TokenStream with token_stream

    Return at_end
End Process

Process called "parser_get_error_count" takes parser as Integer returns Integer:
    Note:
    Get the number of parsing errors encountered

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Number of errors
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Return parser.error_count field (offset 32)
    Let error_count be proc memory_get_qword from Layout with parser, 32

    Return error_count
End Process

Process called "parser_get_ast_root" takes parser as Integer returns Integer:
    Note:
    Get the root AST node of the parsed program

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to root AST node
      Returns 0 if parsing not completed or failed
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Return parser.ast_root field (offset 40)
    Let ast_root be proc memory_get_qword from Layout with parser, 40

    Return ast_root
End Process

Process called "parser_set_strict_mode" takes parser as Integer, strict as Integer returns Integer:
    Note:
    Enable or disable strict parsing mode

    Parameters:
      parser - Pointer to ParserState
      strict - Boolean: 1 for strict mode, 0 for permissive

    Returns:
      1 on success
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Set parser.strict_mode field (offset 72)
    proc memory_set_qword from Layout with parser, 72, strict

    Return 1
End Process