Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file provides high-level AST building functions for Runa parsing.

This file performs the following tasks:
- Provide convenient functions for building common AST node patterns
- Handle AST node relationships and hierarchy construction
- Manage complex AST node creation with proper child relationships
- Support ownership tracking integration for v0.0.8.5
- Provide validation for AST node construction

This file is essential because of the following reasons:
- Simplifies AST construction throughout the parser
- Ensures consistent AST node structure and relationships
- Provides reusable patterns for common language constructs
- Enables proper ownership tracking integration
- Reduces code duplication in parsing components

This file consists of the following functions/features/operation types:
- High-level AST building functions for common patterns
- AST node relationship and hierarchy management
- Complex AST node construction with validation
- Ownership tracking integration for v0.0.8.5
- AST node validation and consistency checking

Dependencies:
- Imports ast.runa for AST node definitions and basic operations
- Imports memory/layout.runa for structure allocation
- Imports collections/list.runa for child node management
- Imports core/string_core.runa for string operations
:End Note

Import "compiler/frontend/parsing/ast.runa" as AST
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/primitives/collections/list.runa" as List
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore

Note: ============================================================================
Note: Expression AST Building Functions
Note: ============================================================================

Process called "build_binary_expression" takes operator as Integer, left as Integer, right as Integer, line as Integer, column as Integer returns Integer:
    Note: Build a binary expression AST node

    Note: Validate inputs
    If left is equal to 0:
        Return 0  Note: NULL left operand
    End If

    If right is equal to 0:
        Return 0  Note: NULL right operand
    End If

    Note: Create binary expression node
    Let node be proc create_binary_expression_node from AST with operator, left, right, line, column

    If node is equal to 0:
        Return 0  Note: Node creation failed
    End If

    Note: Validate constructed node
    Let is_valid be proc validate_ast_node from AST with node

    If is_valid is equal to 0:
        proc destroy_ast_node from AST with node
        Return 0  Note: Validation failed
    End If

    Return node
End Process

Process called "build_unary_expression" takes operator as Integer, operand as Integer, line as Integer, column as Integer returns Integer:
    Note: Build a unary expression AST node

    Note: Validate input
    If operand is equal to 0:
        Return 0  Note: NULL operand
    End If

    Note: Create base AST node with AST_UNARY_EXPRESSION type
    Let node be proc create_ast_node from AST with 1003, line, column  Note: AST_UNARY_EXPRESSION = 1003

    If node is equal to 0:
        Return 0  Note: Node creation failed
    End If

    Note: Set operator in value field
    proc ast_node_set_value from AST with node, operator, 0

    Note: Add operand as child
    Let add_result be proc ast_node_add_child from AST with node, operand

    If add_result is equal to 0:
        proc destroy_ast_node from AST with node
        Return 0  Note: Failed to add child
    End If

    Note: Validate constructed node
    Let is_valid be proc validate_ast_node from AST with node

    If is_valid is equal to 0:
        proc destroy_ast_node from AST with node
        Return 0  Note: Validation failed
    End If

    Return node
End Process

Process called "build_ternary_expression" takes condition as Integer, true_value as Integer, false_value as Integer, line as Integer, column as Integer returns Integer:
    Note: Build a ternary expression AST node (v0.0.8.5 feature)

    Note: Validate inputs
    If condition is equal to 0:
        Return 0  Note: NULL condition
    End If

    If true_value is equal to 0:
        Return 0  Note: NULL true value
    End If

    If false_value is equal to 0:
        Return 0  Note: NULL false value
    End If

    Note: Create ternary expression node
    Let node be proc create_ternary_expression_node from AST with condition, true_value, false_value, line, column

    If node is equal to 0:
        Return 0  Note: Node creation failed
    End If

    Note: Validate constructed node
    Let is_valid be proc validate_ast_node from AST with node

    If is_valid is equal to 0:
        proc destroy_ast_node from AST with node
        Return 0  Note: Validation failed
    End If

    Return node
End Process

Process called "build_call_expression" takes callee as Integer, arguments as Integer, argument_count as Integer, line as Integer, column as Integer returns Integer:
    Note: Build a function call expression AST node

    Note: Validate inputs
    If callee is equal to 0:
        Return 0  Note: NULL callee
    End If

    Note: Create call expression node
    Let node be proc create_call_expression_node from AST with callee, arguments, argument_count, line, column

    If node is equal to 0:
        Return 0  Note: Node creation failed
    End If

    Note: Validate constructed node
    Let is_valid be proc validate_ast_node from AST with node

    If is_valid is equal to 0:
        proc destroy_ast_node from AST with node
        Return 0  Note: Validation failed
    End If

    Return node
End Process

Process called "build_member_expression" takes object as Integer, property as Integer, computed as Integer, line as Integer, column as Integer returns Integer:
    Note:
    Build a member access expression AST node

    Parameters:
      object - Pointer to object expression
      property - Pointer to property identifier
      computed - Boolean: 1 if computed property (obj[expr]), 0 if dot notation
      line - Line number where expression appears
      column - Column number where expression appears

    Returns:
      Pointer to MemberExpressionNode structure
      Returns 0 on allocation failure
    :End Note

    Note: Validate inputs
    If object is equal to 0:
        Return 0  Note: NULL object
    End If

    If property is equal to 0:
        Return 0  Note: NULL property
    End If

    Note: Create member expression node (AST_MEMBER_EXPRESSION = 1007)
    Let node be proc create_ast_node from AST with 1007, line, column

    If node is equal to 0:
        Return 0  Note: Node creation failed
    End If

    Note: Add object and property as children
    proc ast_node_add_child from AST with node, object
    proc ast_node_add_child from AST with node, property

    Note: Set computed flag in value field
    proc ast_node_set_value from AST with node, computed, 0

    Note: Validate constructed node
    Let is_valid be proc validate_ast_node from AST with node

    If is_valid is equal to 0:
        proc destroy_ast_node from AST with node
        Return 0  Note: Validation failed
    End If

    Return node
End Process

Process called "build_index_expression" takes object as Integer, index as Integer, line as Integer, column as Integer returns Integer:
    Note:
    Build an array/collection index expression AST node

    Parameters:
      object - Pointer to object expression
      index - Pointer to index expression
      line - Line number where expression appears
      column - Column number where expression appears

    Returns:
      Pointer to IndexExpressionNode structure
      Returns 0 on allocation failure
    :End Note

    Note: Validate inputs
    If object is equal to 0:
        Return 0  Note: NULL object
    End If

    If index is equal to 0:
        Return 0  Note: NULL index
    End If

    Note: Create index expression node (AST_INDEX_EXPRESSION = 1006)
    Let node be proc create_ast_node from AST with 1006, line, column

    If node is equal to 0:
        Return 0  Note: Node creation failed
    End If

    Note: Add object and index as children
    proc ast_node_add_child from AST with node, object
    proc ast_node_add_child from AST with node, index

    Note: Validate constructed node
    Let is_valid be proc validate_ast_node from AST with node

    If is_valid is equal to 0:
        proc destroy_ast_node from AST with node
        Return 0  Note: Validation failed
    End If

    Return node
End Process

Process called "build_interpolated_string" takes parts as Integer, part_count as Integer, line as Integer, column as Integer returns Integer:
    Note:
    Build a string interpolation AST node (v0.0.8.5 feature)

    Parameters:
      parts - Pointer to List of string parts and expressions
      part_count - Number of parts
      line - Line number where expression appears
      column - Column number where expression appears

    Returns:
      Pointer to InterpolatedStringNode structure
      Returns 0 on allocation failure
    :End Note

    Note: Create interpolated string node (AST_INTERPOLATED_STRING = 1009)
    Let node be proc create_ast_node from AST with 1009, line, column

    If node is equal to 0:
        Return 0  Note: Node creation failed
    End If

    Note: Add all parts as children
    If parts is not equal to 0:
        Let index be 0
        Loop forever:
            If index is greater than or equal to part_count:
                Break
            End If

            Let part be proc get from List with parts, index
            proc ast_node_add_child from AST with node, part

            Set index to index plus 1
        End Loop
    End If

    Note: Set part_count in value field
    proc ast_node_set_value from AST with node, part_count, 0

    Note: Validate constructed node
    Let is_valid be proc validate_ast_node from AST with node

    If is_valid is equal to 0:
        proc destroy_ast_node from AST with node
        Return 0  Note: Validation failed
    End If

    Return node
End Process

Note: ============================================================================
Note: Statement AST Building Functions
Note: ============================================================================

Process called "build_let_statement" takes identifier as Integer, type_annotation as Integer, expression as Integer, line as Integer returns Integer:
    Note: Build a Let statement AST node

    Note: Validate inputs
    If identifier is equal to 0:
        Return 0  Note: NULL identifier
    End If

    If expression is equal to 0:
        Return 0  Note: NULL expression
    End If

    Note: Create Let statement node (AST_LET_STATEMENT = 2000)
    Let node be proc create_ast_node from AST with 2000, line, 1

    If node is equal to 0:
        Return 0  Note: Node creation failed
    End If

    Note: Add identifier as child
    proc ast_node_add_child from AST with node, identifier

    Note: Add type annotation if present
    If type_annotation is not equal to 0:
        proc ast_node_add_child from AST with node, type_annotation
    End If

    Note: Add expression as child
    proc ast_node_add_child from AST with node, expression

    Note: Validate constructed node
    Let is_valid be proc validate_ast_node from AST with node

    If is_valid is equal to 0:
        proc destroy_ast_node from AST with node
        Return 0  Note: Validation failed
    End If

    Return node
End Process

Process called "build_set_statement" takes target as Integer, expression as Integer, line as Integer returns Integer:
    Note: Build a Set statement AST node

    If target is equal to 0:
        Return 0  Note: NULL target
    End If

    If expression is equal to 0:
        Return 0  Note: NULL expression
    End If

    Note: Create Set statement node (AST_SET_STATEMENT = 2001)
    Let node be proc create_ast_node from AST with 2001, line, 1

    If node is equal to 0:
        Return 0
    End If

    proc ast_node_add_child from AST with node, target
    proc ast_node_add_child from AST with node, expression

    Let is_valid be proc validate_ast_node from AST with node

    If is_valid is equal to 0:
        proc destroy_ast_node from AST with node
        Return 0
    End If

    Return node
End Process

Process called "build_define_statement" takes identifier as Integer, type_annotation as Integer, expression as Integer, line as Integer returns Integer:
    Note: Build a Define statement AST node

    If identifier is equal to 0:
        Return 0
    End If

    If expression is equal to 0:
        Return 0
    End If

    Note: AST_DEFINE_STATEMENT = 2002
    Let node be proc create_ast_node from AST with 2002, line, 1

    If node is equal to 0:
        Return 0
    End If

    proc ast_node_add_child from AST with node, identifier

    If type_annotation is not equal to 0:
        proc ast_node_add_child from AST with node, type_annotation
    End If

    proc ast_node_add_child from AST with node, expression

    Let is_valid be proc validate_ast_node from AST with node

    If is_valid is equal to 0:
        proc destroy_ast_node from AST with node
        Return 0
    End If

    Return node
End Process

Process called "build_if_statement" takes condition as Integer, then_block as Integer, else_block as Integer, line as Integer returns Integer:
    Note:
    Build an If statement AST node

    Parameters:
      condition - Pointer to condition expression AST node
      then_block - Pointer to then block AST node
      else_block - Pointer to else block AST node (optional)
      line - Line number where statement appears

    Returns:
      Pointer to If statement AST node
      Returns 0 on allocation failure
    :End Note

    If condition is equal to 0:
        Return 0
    End If

    If then_block is equal to 0:
        Return 0
    End If

    Note: AST_IF_STATEMENT = 2003
    Let node be proc create_ast_node from AST with 2003, line, 1

    If node is equal to 0:
        Return 0
    End If

    proc ast_node_add_child from AST with node, condition
    proc ast_node_add_child from AST with node, then_block

    If else_block is not equal to 0:
        proc ast_node_add_child from AST with node, else_block
    End If

    Let is_valid be proc validate_ast_node from AST with node

    If is_valid is equal to 0:
        proc destroy_ast_node from AST with node
        Return 0
    End If

    Return node
End Process

Process called "build_match_statement" takes expression as Integer, arms as Integer, arm_count as Integer, has_otherwise as Integer, line as Integer returns Integer:
    Note:
    Build a Match statement AST node

    Parameters:
      expression - Pointer to expression being matched
      arms - Pointer to List of When clause AST nodes
      arm_count - Number of match arms
      has_otherwise - Boolean: 1 if has Otherwise clause
      line - Line number where statement appears

    Returns:
      Pointer to Match statement AST node
      Returns 0 on allocation failure
    :End Note

    If expression is equal to 0:
        Return 0
    End If

    Note: AST_MATCH_STATEMENT = 2005
    Let node be proc create_ast_node from AST with 2005, line, 1

    If node is equal to 0:
        Return 0
    End If

    proc ast_node_add_child from AST with node, expression

    If arms is not equal to 0:
        Let i be 0
        Loop forever:
            If i is greater than or equal to arm_count:
                Break
            End If

            Let arm be proc get from List with arms, i
            proc ast_node_add_child from AST with node, arm
            Set i to i plus 1
        End Loop
    End If

    proc ast_node_set_value from AST with node, has_otherwise, 0

    Return node
End Process

Process called "build_when_clause" takes pattern as Integer, guard as Integer, body as Integer, line as Integer returns Integer:
    Note: Build a When clause AST node (match arm)

    If pattern is equal to 0:
        Return 0
    End If

    If body is equal to 0:
        Return 0
    End If

    Note: AST_WHEN_CLAUSE = 2006
    Let node be proc create_ast_node from AST with 2006, line, 1

    If node is equal to 0:
        Return 0
    End If

    proc ast_node_add_child from AST with node, pattern

    If guard is not equal to 0:
        proc ast_node_add_child from AST with node, guard
    End If

    proc ast_node_add_child from AST with node, body

    Return node
End Process

Process called "build_for_statement" takes variable as Integer, iterable as Integer, body as Integer, line as Integer returns Integer:
    Note: Build a For statement AST node

    If variable is equal to 0:
        Return 0
    End If

    If iterable is equal to 0:
        Return 0
    End If

    If body is equal to 0:
        Return 0
    End If

    Note: AST_FOR_STATEMENT = 2007
    Let node be proc create_ast_node from AST with 2007, line, 1

    If node is equal to 0:
        Return 0
    End If

    proc ast_node_add_child from AST with node, variable
    proc ast_node_add_child from AST with node, iterable
    proc ast_node_add_child from AST with node, body

    Return node
End Process

Process called "build_while_statement" takes condition as Integer, body as Integer, line as Integer returns Integer:
    Note: Build a While statement AST node

    If condition is equal to 0:
        Return 0
    End If

    If body is equal to 0:
        Return 0
    End If

    Note: AST_WHILE_STATEMENT = 2008
    Let node be proc create_ast_node from AST with 2008, line, 1

    If node is equal to 0:
        Return 0
    End If

    proc ast_node_add_child from AST with node, condition
    proc ast_node_add_child from AST with node, body

    Return node
End Process

Process called "build_return_statement" takes expression as Integer, line as Integer returns Integer:
    Note: Build a Return statement AST node

    Note: AST_RETURN_STATEMENT = 2010
    Let node be proc create_ast_node from AST with 2010, line, 1

    If node is equal to 0:
        Return 0
    End If

    If expression is not equal to 0:
        proc ast_node_add_child from AST with node, expression
    End If

    Return node
End Process

Process called "build_block_statement" takes statements as Integer, statement_count as Integer, line as Integer returns Integer:
    Note: Build a block statement AST node

    Note: AST_BLOCK_STATEMENT = 2018
    Let node be proc create_ast_node from AST with 2018, line, 1

    If node is equal to 0:
        Return 0
    End If

    If statements is not equal to 0:
        Let i be 0
        Loop forever:
            If i is greater than or equal to statement_count:
                Break
            End If

            Let stmt be proc get from List with statements, i
            proc ast_node_add_child from AST with node, stmt
            Set i to i plus 1
        End Loop
    End If

    Return node
End Process

Note: ============================================================================
Note: Declaration AST Building Functions
Note: ============================================================================

Process called "build_process_definition" takes name as Integer, parameters as Integer, return_type as Integer, body as Integer, line as Integer returns Integer:
    Note:
    Build a Process definition AST node

    Parameters:
      name - Pointer to process name string
      parameters - Pointer to List of parameter AST nodes
      return_type - Pointer to return type AST node
      body - Pointer to body statement AST node
      line - Line number where definition appears

    Returns:
      Pointer to Process definition AST node
      Returns 0 on allocation failure
    :End Note

    Note: Validate inputs
    If name is equal to 0:
        Return 0  Note: NULL name
    End If

    If body is equal to 0:
        Return 0  Note: NULL body
    End If

    Note: Create process definition node using specialized function
    Let node be proc create_process_definition_node from AST with name, parameters, return_type, body, line, 1

    If node is equal to 0:
        Return 0  Note: Node creation failed
    End If

    Note: Validate constructed node
    Let is_valid be proc validate_ast_node from AST with node

    If is_valid is equal to 0:
        proc destroy_ast_node from AST with node
        Return 0  Note: Validation failed
    End If

    Return node
End Process

Process called "build_type_definition" takes name as Integer, generic_parameters as Integer, body as Integer, line as Integer returns Integer:
    Note:
    Build a Type definition AST node

    Parameters:
      name - Pointer to type name string
      generic_parameters - Pointer to List of generic parameter AST nodes
      body - Pointer to type body AST node
      line - Line number where definition appears

    Returns:
      Pointer to Type definition AST node
      Returns 0 on allocation failure
    :End Note

    Note: Validate inputs
    If name is equal to 0:
        Return 0  Note: NULL name
    End If

    If body is equal to 0:
        Return 0  Note: NULL body
    End If

    Note: Create type definition node (AST_TYPE_DEFINITION = 3001)
    Let node be proc create_ast_node from AST with 3001, line, 1

    If node is equal to 0:
        Return 0  Note: Node creation failed
    End If

    Note: Add name as child
    proc ast_node_add_child from AST with node, name

    Note: Add generic parameters if present
    If generic_parameters is not equal to 0:
        proc ast_node_add_child from AST with node, generic_parameters
    End If

    Note: Add body as child
    proc ast_node_add_child from AST with node, body

    Note: Validate constructed node
    Let is_valid be proc validate_ast_node from AST with node

    If is_valid is equal to 0:
        proc destroy_ast_node from AST with node
        Return 0  Note: Validation failed
    End If

    Return node
End Process

Process called "build_import_statement" takes path as Integer, alias as Integer, line as Integer returns Integer:
    Note:
    Build an Import statement AST node

    Parameters:
      path - Pointer to import path string
      alias - Pointer to import alias string (optional)
      line - Line number where statement appears

    Returns:
      Pointer to Import statement AST node
      Returns 0 on allocation failure
    :End Note

    Note: Validate inputs
    If path is equal to 0:
        Return 0  Note: NULL path
    End If

    Note: Create import statement node (AST_IMPORT_STATEMENT = 2016)
    Let node be proc create_ast_node from AST with 2016, line, 1

    If node is equal to 0:
        Return 0  Note: Node creation failed
    End If

    Note: Add path as child
    proc ast_node_add_child from AST with node, path

    Note: Add alias if present
    If alias is not equal to 0:
        proc ast_node_add_child from AST with node, alias
    End If

    Note: Validate constructed node
    Let is_valid be proc validate_ast_node from AST with node

    If is_valid is equal to 0:
        proc destroy_ast_node from AST with node
        Return 0  Note: Validation failed
    End If

    Return node
End Process

Note: ============================================================================
Note: Type AST Building Functions
Note: ============================================================================

Process called "build_basic_type" takes type_name as Integer, line as Integer returns Integer:
    Note:
    Build a basic type AST node (Integer, Float, String, etc.)

    Parameters:
      type_name - Pointer to type name string
      line - Line number where type appears

    Returns:
      Pointer to basic type AST node
      Returns 0 on allocation failure
    :End Note

    Note: Validate inputs
    If type_name is equal to 0:
        Return 0  Note: NULL type name
    End If

    Note: Create basic type node (AST_TYPE_BASIC = 4000)
    Let node be proc create_ast_node from AST with 4000, line, 1

    If node is equal to 0:
        Return 0  Note: Node creation failed
    End If

    Note: Set type name in value field
    proc ast_node_set_value from AST with node, type_name, 1

    Note: Validate constructed node
    Let is_valid be proc validate_ast_node from AST with node

    If is_valid is equal to 0:
        proc destroy_ast_node from AST with node
        Return 0  Note: Validation failed
    End If

    Return node
End Process

Process called "build_generic_type" takes base_type as Integer, type_arguments as Integer, argument_count as Integer, line as Integer returns Integer:
    Note:
    Build a generic type AST node

    Parameters:
      base_type - Pointer to base type AST node
      type_arguments - Pointer to List of type argument AST nodes
      argument_count - Number of type arguments
      line - Line number where type appears

    Returns:
      Pointer to generic type AST node
      Returns 0 on allocation failure
    :End Note

    Note: Validate inputs
    If base_type is equal to 0:
        Return 0  Note: NULL base type
    End If

    Note: Create generic type node (AST_TYPE_GENERIC = 4001)
    Let node be proc create_ast_node from AST with 4001, line, 1

    If node is equal to 0:
        Return 0  Note: Node creation failed
    End If

    Note: Add base type as child
    proc ast_node_add_child from AST with node, base_type

    Note: Add type arguments as children
    If type_arguments is not equal to 0:
        Let i be 0
        Loop forever:
            If i is greater than or equal to argument_count:
                Break
            End If

            Let arg be proc get from List with type_arguments, i
            proc ast_node_add_child from AST with node, arg
            Set i to i plus 1
        End Loop
    End If

    Note: Set argument count in value field
    proc ast_node_set_value from AST with node, argument_count, 0

    Note: Validate constructed node
    Let is_valid be proc validate_ast_node from AST with node

    If is_valid is equal to 0:
        proc destroy_ast_node from AST with node
        Return 0  Note: Validation failed
    End If

    Return node
End Process

Process called "build_function_type" takes parameters as Integer, return_type as Integer, line as Integer returns Integer:
    Note:
    Build a function type AST node

    Parameters:
      parameters - Pointer to List of parameter type AST nodes
      return_type - Pointer to return type AST node
      line - Line number where type appears

    Returns:
      Pointer to function type AST node
      Returns 0 on allocation failure
    :End Note

    Note: Create function type node (AST_TYPE_FUNCTION = 4002)
    Let node be proc create_ast_node from AST with 4002, line, 1

    If node is equal to 0:
        Return 0  Note: Node creation failed
    End If

    Note: Add parameters as child if present
    If parameters is not equal to 0:
        proc ast_node_add_child from AST with node, parameters
    End If

    Note: Add return type as child
    If return_type is not equal to 0:
        proc ast_node_add_child from AST with node, return_type
    End If

    Note: Validate constructed node
    Let is_valid be proc validate_ast_node from AST with node

    If is_valid is equal to 0:
        proc destroy_ast_node from AST with node
        Return 0  Note: Validation failed
    End If

    Return node
End Process

Note: ============================================================================
Note: Ownership Tracking Integration (v0.0.8.5)
Note: ============================================================================

Process called "build_ownership_operation" takes operation_type as Integer, variable as Integer, line as Integer returns Integer:
    Note:
    Build an ownership operation AST node (v0.0.8.5 feature)

    Parameters:
      operation_type - Type of ownership operation (move, borrow, mutable_borrow)
      variable - Pointer to variable AST node
      line - Line number where operation appears

    Returns:
      Pointer to ownership operation AST node
      Returns 0 on allocation failure
    :End Note

    Note: Validate inputs
    If variable is equal to 0:
        Return 0  Note: NULL variable
    End If

    Note: Create ownership operation node (AST_OWNERSHIP_OPERATION = 6000)
    Let node be proc create_ast_node from AST with 6000, line, 1

    If node is equal to 0:
        Return 0  Note: Node creation failed
    End If

    Note: Set operation type in value field
    proc ast_node_set_value from AST with node, operation_type, 0

    Note: Add variable as child
    proc ast_node_add_child from AST with node, variable

    Note: Validate constructed node
    Let is_valid be proc validate_ast_node from AST with node

    If is_valid is equal to 0:
        proc destroy_ast_node from AST with node
        Return 0  Note: Validation failed
    End If

    Return node
End Process

Process called "integrate_ownership_tracking" takes node as Integer, ownership_info as Integer returns Integer:
    Note:
    Integrate ownership tracking information into an AST node

    Parameters:
      node - Pointer to AST node
      ownership_info - Pointer to OwnershipInfo structure

    Returns:
      1 on success, 0 on failure

    Side Effects:
      - Sets node.ownership_info to provided ownership_info
      - Enables ownership tracking for the node
    :End Note

    Note: Validate inputs
    If node is equal to 0:
        Return 0  Note: NULL node
    End If

    If ownership_info is equal to 0:
        Return 0  Note: NULL ownership info
    End If

    Note: Set ownership info using AST function
    Let result be proc ast_node_set_ownership_info from AST with node, ownership_info

    Return result
End Process

Note: ============================================================================
Note: AST Validation and Consistency
Note: ============================================================================

Process called "validate_ast_construction" takes node as Integer returns Integer:
    Note:
    Validate that an AST node is properly constructed

    Parameters:
      node - Pointer to AST node to validate

    Returns:
      1 if node is valid, 0 if invalid

    Validation checks:
      - Node is not null
      - Node type is valid for its structure
      - Required children are present
      - Child relationships are consistent
      - Ownership tracking is valid (if present)
    :End Note

    Note: Check if node is null
    If node is equal to 0:
        Return 0  Note: NULL node
    End If

    Note: Validate using AST basic validation
    Let basic_valid be proc validate_ast_node from AST with node

    If basic_valid is equal to 0:
        Return 0  Note: Basic validation failed
    End If

    Note: Get node type for structure validation
    Let node_type be proc ast_node_get_type from AST with node

    Note: Validate node type is in valid range (1000-8999)
    If node_type is less than 1000:
        Return 0  Note: Invalid node type
    End If

    If node_type is greater than 8999:
        Return 0  Note: Invalid node type
    End If

    Note: Get child count
    Let child_count be proc ast_node_get_child_count from AST with node

    Note: Get children list
    Let children be proc ast_node_get_children from AST with node

    Note: Validate child count matches children list size
    If children is not equal to 0:
        Let list_size be proc size from List with children

        If child_count is not equal to list_size:
            Return 0  Note: Child count mismatch
        End If
    End If

    Note: Recursively validate all children
    If child_count is greater than 0:
        Let i be 0
        Loop forever:
            If i is greater than or equal to child_count:
                Break
            End If

            Let child be proc get from List with children, i

            If child is equal to 0:
                Return 0  Note: NULL child
            End If

            Note: Recursively validate child
            Let child_valid be proc validate_ast_construction with child

            If child_valid is equal to 0:
                Return 0  Note: Invalid child
            End If

            Set i to i plus 1
        End Loop
    End If

    Note: Validation passed
    Return 1
End Process

Process called "fix_ast_relationships" takes node as Integer returns Integer:
    Note:
    Fix any inconsistencies in AST node relationships

    Parameters:
      node - Pointer to AST node to fix

    Returns:
      1 on success, 0 on failure

    Fixes:
      - Ensures parent-child relationships are bidirectional
      - Validates child count matches children list size
      - Fixes ownership tracking references
    :End Note

    Note: Check if node is null
    If node is equal to 0:
        Return 0  Note: NULL node
    End If

    Note: Get children list and child count
    Let children be proc ast_node_get_children from AST with node
    Let child_count be proc ast_node_get_child_count from AST with node

    Note: Fix child count if inconsistent
    If children is not equal to 0:
        Let actual_size be proc size from List with children

        Note: Update child count if mismatch
        If child_count is not equal to actual_size:
            proc ast_node_set_child_count from AST with node, actual_size
            Set child_count to actual_size
        End If
    End If

    Note: Ensure parent-child relationships are bidirectional
    If child_count is greater than 0:
        Let i be 0
        Loop forever:
            If i is greater than or equal to child_count:
                Break
            End If

            Let child be proc get from List with children, i

            If child is not equal to 0:
                Note: Get child's parent
                Let child_parent be proc ast_node_get_parent from AST with child

                Note: Fix parent pointer if incorrect
                If child_parent is not equal to node:
                    proc ast_node_set_parent from AST with child, node
                End If

                Note: Recursively fix child relationships
                proc fix_ast_relationships with child
            End If

            Set i to i plus 1
        End Loop
    End If

    Return 1
End Process

Process called "ast_node_debug_info" takes node as Integer returns Integer:
    Note:
    Get debug information for an AST node

    Parameters:
      node - Pointer to AST node

    Returns:
      Pointer to debug information string
      Returns 0 on failure

    Debug info includes:
      - Node type and position
      - Value and value type
      - Child count and relationships
      - Ownership tracking status
    :End Note

    Note: Check if node is null
    If node is equal to 0:
        Return 0  Note: NULL node
    End If

    Note: Get node information
    Let node_type be proc ast_node_get_type from AST with node
    Let line be proc ast_node_get_line from AST with node
    Let column be proc ast_node_get_column from AST with node
    Let child_count be proc ast_node_get_child_count from AST with node
    Let value be proc ast_node_get_value from AST with node
    Let value_type be proc ast_node_get_value_type from AST with node
    Let parent be proc ast_node_get_parent from AST with node
    Let ownership_info be proc ast_node_get_ownership_info from AST with node

    Note: Create debug string using string builder pattern
    Let debug_str be proc create from StringCore

    Note: Append node type information
    Let type_label be proc create_from_cstring from StringCore with "AST Node Type: "
    proc append from StringCore with debug_str, type_label

    Let type_str be proc integer_to_string from StringCore with node_type
    proc append from StringCore with debug_str, type_str

    Let newline be proc create_from_cstring from StringCore with "\n"
    proc append from StringCore with debug_str, newline

    Note: Append position information
    Let pos_label be proc create_from_cstring from StringCore with "Position: Line "
    proc append from StringCore with debug_str, pos_label

    Let line_str be proc integer_to_string from StringCore with line
    proc append from StringCore with debug_str, line_str

    Let col_label be proc create_from_cstring from StringCore with ", Column "
    proc append from StringCore with debug_str, col_label

    Let col_str be proc integer_to_string from StringCore with column
    proc append from StringCore with debug_str, col_str
    proc append from StringCore with debug_str, newline

    Note: Append child count
    Let child_label be proc create_from_cstring from StringCore with "Child Count: "
    proc append from StringCore with debug_str, child_label

    Let child_str be proc integer_to_string from StringCore with child_count
    proc append from StringCore with debug_str, child_str
    proc append from StringCore with debug_str, newline

    Note: Append value information
    Let value_label be proc create_from_cstring from StringCore with "Value: "
    proc append from StringCore with debug_str, value_label

    Let value_str be proc integer_to_string from StringCore with value
    proc append from StringCore with debug_str, value_str

    Let vtype_label be proc create_from_cstring from StringCore with " (Type: "
    proc append from StringCore with debug_str, vtype_label

    Let vtype_str be proc integer_to_string from StringCore with value_type
    proc append from StringCore with debug_str, vtype_str

    Let close_paren be proc create_from_cstring from StringCore with ")\n"
    proc append from StringCore with debug_str, close_paren

    Note: Append parent information
    Let parent_label be proc create_from_cstring from StringCore with "Has Parent: "
    proc append from StringCore with debug_str, parent_label

    If parent is not equal to 0:
        Let yes_str be proc create_from_cstring from StringCore with "Yes\n"
        proc append from StringCore with debug_str, yes_str
    End If

    If parent is equal to 0:
        Let no_str be proc create_from_cstring from StringCore with "No\n"
        proc append from StringCore with debug_str, no_str
    End If

    Note: Append ownership tracking status
    Let ownership_label be proc create_from_cstring from StringCore with "Ownership Tracking: "
    proc append from StringCore with debug_str, ownership_label

    If ownership_info is not equal to 0:
        Let enabled_str be proc create_from_cstring from StringCore with "Enabled\n"
        proc append from StringCore with debug_str, enabled_str
    End If

    If ownership_info is equal to 0:
        Let disabled_str be proc create_from_cstring from StringCore with "Disabled\n"
        proc append from StringCore with debug_str, disabled_str
    End If

    Note: Convert to C string for return
    Let result be proc to_cstring from StringCore with debug_str

    Return result
End Process

Note: ============================================================================
Note: Pattern Builder Functions
Note: ============================================================================

Process called "build_wildcard_pattern" takes line as Integer returns Integer:
    Note:
    Build a wildcard pattern node (_) that matches any value.
    Wildcard patterns do not bind variables and match everything.
    Returns pointer to AST_WILDCARD_PATTERN node.
    :End Note

    Note: Create wildcard pattern node (no children, no value)
    Let node be proc create_ast_node from AST with AST_WILDCARD_PATTERN, line, 0, 0

    Return node
End Process

Process called "build_identifier_pattern" takes name as Integer, line as Integer returns Integer:
    Note:
    Build an identifier pattern node for variable binding.
    Identifier patterns bind the matched value to a variable name.
    Parameters:
      name - Pointer to identifier string (variable name)
      line - Source line number
    Returns pointer to AST_IDENTIFIER_PATTERN node.
    :End Note

    If name is equal to 0:
        Return 0  Note: Invalid identifier
    End If

    Note: Create identifier pattern node with name as value
    Let node be proc create_ast_node from AST with AST_IDENTIFIER_PATTERN, line, 0, 0
    proc ast_node_set_value from AST with node, name, 1  Note: Type 1 for string

    Return node
End Process

Process called "build_literal_pattern" takes value as Integer, value_type as Integer, line as Integer returns Integer:
    Note:
    Build a literal pattern node for constant matching.
    Literal patterns match exact values (42, "hello", true, etc.).
    Parameters:
      value - The literal value (integer, string pointer, etc.)
      value_type - Type of the literal (1=integer, 2=string, 3=boolean, etc.)
      line - Source line number
    Returns pointer to AST_LITERAL_PATTERN node.
    :End Note

    Note: Create literal pattern node with value and type
    Let node be proc create_ast_node from AST with AST_LITERAL_PATTERN, line, 0, 0
    proc ast_node_set_value from AST with node, value, value_type

    Return node
End Process

Process called "build_tuple_pattern" takes elements as Integer, element_count as Integer, line as Integer returns Integer:
    Note:
    Build a tuple pattern node for tuple destructuring.
    Tuple patterns match tuple values and destructure into sub-patterns: (a, b, c)
    Parameters:
      elements - Array of pattern node pointers (sub-patterns)
      element_count - Number of elements in the tuple
      line - Source line number
    Returns pointer to AST_TUPLE_PATTERN node.
    :End Note

    If elements is equal to 0:
        Return 0  Note: Invalid elements array
    End If

    If element_count is less than or equal to 0:
        Return 0  Note: Empty tuple pattern not allowed
    End If

    Note: Create tuple pattern node
    Let node be proc create_ast_node from AST with AST_TUPLE_PATTERN, line, 0, 0

    Note: Add each element as a child
    Let i be 0
    While i is less than element_count:
        Let element be proc memory_get_qword from Layout with elements, i multiplied by 8
        If element is not equal to 0:
            proc ast_node_add_child from AST with node, element
        End If
        Set i to i plus 1
    End While

    Return node
End Process

Process called "build_record_pattern" takes fields as Integer, field_count as Integer, line as Integer returns Integer:
    Note:
    Build a record pattern node for record/struct destructuring.
    Record patterns match records and extract fields: {name, age: pattern}
    Parameters:
      fields - Array of field pattern pairs (field_name, sub_pattern)
      field_count - Number of fields in the record pattern
      line - Source line number
    Returns pointer to AST_RECORD_PATTERN node.
    :End Note

    If fields is equal to 0:
        Return 0  Note: Invalid fields array
    End If

    If field_count is less than or equal to 0:
        Return 0  Note: Empty record pattern not allowed
    End If

    Note: Create record pattern node
    Let node be proc create_ast_node from AST with AST_RECORD_PATTERN, line, 0, 0

    Note: Add each field pattern as a child
    Note: Fields array contains pairs: [field_name, pattern, field_name, pattern, ...]
    Note: Create tuple pattern for each field to preserve field name
    Let i be 0
    While i is less than field_count:
        Note: Get field name and pattern from pairs
        Let field_offset be i multiplied by 16
        Let field_name be proc memory_get_qword from Layout with fields, field_offset
        Let field_pattern be proc memory_get_qword from Layout with fields, field_offset plus 8

        If field_name is not equal to 0:
            If field_pattern is not equal to 0:
                Note: Convert field name string to identifier pattern node
                Let field_name_pattern be proc build_identifier_pattern with field_name, line

                Note: Create tuple to represent (field_name, pattern) pair
                Let pair_elements be proc arena_allocate from Layout with fields, 16
                proc memory_set_qword from Layout with pair_elements, 0, field_name_pattern
                proc memory_set_qword from Layout with pair_elements, 8, field_pattern

                Note: Build tuple pattern node for this field
                Let field_tuple be proc build_tuple_pattern with pair_elements, 2, line
                proc ast_node_add_child from AST with node, field_tuple
            End If
        End If

        Set i to i plus 1
    End While

    Return node
End Process

Process called "build_array_pattern" takes elements as Integer, element_count as Integer, has_rest as Integer, line as Integer returns Integer:
    Note:
    Build an array pattern node for array/list destructuring.
    Array patterns match arrays and destructure: [first, second, ...rest]
    Parameters:
      elements - Array of pattern node pointers (sub-patterns)
      element_count - Number of element patterns
      has_rest - Boolean flag: 1 if pattern includes ...rest, 0 otherwise
      line - Source line number
    Returns pointer to AST_ARRAY_PATTERN node.
    :End Note

    If elements is equal to 0:
        Return 0  Note: Invalid elements array
    End If

    Note: Create array pattern node
    Let node be proc create_ast_node from AST with AST_ARRAY_PATTERN, line, 0, 0

    Note: Store has_rest flag as node value
    proc ast_node_set_value from AST with node, has_rest, 3  Note: Type 3 for boolean

    Note: Add each element pattern as a child
    Let i be 0
    While i is less than element_count:
        Let element be proc memory_get_qword from Layout with elements, i multiplied by 8
        If element is not equal to 0:
            proc ast_node_add_child from AST with node, element
        End If
        Set i to i plus 1
    End While

    Return node
End Process

Process called "build_range_pattern" takes start as Integer, end as Integer, inclusive as Integer, line as Integer returns Integer:
    Note:
    Build a range pattern node for range matching.
    Range patterns match values within a range: 1..10 (exclusive) or 1..=10 (inclusive)
    Parameters:
      start - AST node for range start expression
      end - AST node for range end expression
      inclusive - Boolean: 1 for inclusive (..=), 0 for exclusive (..)
      line - Source line number
    Returns pointer to AST_RANGE_PATTERN node.
    :End Note

    If start is equal to 0:
        Return 0  Note: Range start required
    End If

    If end is equal to 0:
        Return 0  Note: Range end required
    End If

    Note: Create range pattern node
    Let node be proc create_ast_node from AST with AST_RANGE_PATTERN, line, 0, 0

    Note: Store inclusive flag as node value
    proc ast_node_set_value from AST with node, inclusive, 3  Note: Type 3 for boolean

    Note: Add start and end as children
    proc ast_node_add_child from AST with node, start  Note: Child 0: start
    proc ast_node_add_child from AST with node, end    Note: Child 1: end

    Return node
End Process

Process called "build_variant_pattern" takes variant_name as Integer, inner_pattern as Integer, line as Integer returns Integer:
    Note:
    Build a variant pattern node for enum/variant matching.
    Variant patterns match enum variants and extract payload: Some(x), Ok(value)
    Parameters:
      variant_name - Pointer to variant name string
      inner_pattern - Pattern for variant payload (0 if no payload)
      line - Source line number
    Returns pointer to AST_VARIANT_PATTERN node.
    :End Note

    If variant_name is equal to 0:
        Return 0  Note: Variant name required
    End If

    Note: Create variant pattern node
    Let node be proc create_ast_node from AST with AST_VARIANT_PATTERN, line, 0, 0

    Note: Store variant name as node value
    proc ast_node_set_value from AST with node, variant_name, 1  Note: Type 1 for string

    Note: Add inner pattern as child if present
    If inner_pattern is not equal to 0:
        proc ast_node_add_child from AST with node, inner_pattern
    End If

    Return node
End Process

Process called "build_type_pattern" takes type_name as Integer, inner_pattern as Integer, line as Integer returns Integer:
    Note:
    Build a type pattern node for type-constrained matching.
    Type patterns match values of specific type: value as Integer
    Parameters:
      type_name - Pointer to type name string or type AST node
      inner_pattern - Inner pattern to match (0 for direct type match)
      line - Source line number
    Returns pointer to AST_TYPE_PATTERN node.
    :End Note

    If type_name is equal to 0:
        Return 0  Note: Type name required
    End If

    Note: Create type pattern node
    Let node be proc create_ast_node from AST with AST_TYPE_PATTERN, line, 0, 0

    Note: Store type name as node value
    proc ast_node_set_value from AST with node, type_name, 1  Note: Type 1 for string/type

    Note: Add inner pattern as child if present
    If inner_pattern is not equal to 0:
        proc ast_node_add_child from AST with node, inner_pattern
    End If

    Return node
End Process

Process called "build_guard_pattern" takes pattern as Integer, guard as Integer, line as Integer returns Integer:
    Note:
    Build a guarded pattern node combining pattern with guard condition.
    Guarded patterns add conditional check: pattern if condition
    Parameters:
      pattern - The base pattern to match
      guard - Guard condition expression (must evaluate to boolean)
      line - Source line number
    Returns pointer to AST_GUARD_PATTERN node.
    :End Note

    If pattern is equal to 0:
        Return 0  Note: Base pattern required
    End If

    If guard is equal to 0:
        Return 0  Note: Guard condition required
    End If

    Note: Create guard pattern node
    Let node be proc create_ast_node from AST with AST_GUARD_PATTERN, line, 0, 0

    Note: Add pattern and guard as children
    proc ast_node_add_child from AST with node, pattern  Note: Child 0: pattern
    proc ast_node_add_child from AST with node, guard    Note: Child 1: guard condition

    Return node
End Process

Process called "build_or_pattern" takes alternatives as Integer, alternative_count as Integer, line as Integer returns Integer:
    Note:
    Build an OR pattern node for alternative matching.
    OR patterns match if any alternative matches: 1 | 2 | 3
    Parameters:
      alternatives - Array of alternative pattern node pointers
      alternative_count - Number of alternative patterns
      line - Source line number
    Returns pointer to AST_OR_PATTERN node.
    :End Note

    If alternatives is equal to 0:
        Return 0  Note: Alternatives array required
    End If

    If alternative_count is less than 2:
        Return 0  Note: OR pattern requires at least 2 alternatives
    End If

    Note: Create OR pattern node
    Let node be proc create_ast_node from AST with AST_OR_PATTERN, line, 0, 0

    Note: Add each alternative as a child
    Let i be 0
    While i is less than alternative_count:
        Let alternative be proc memory_get_qword from Layout with alternatives, i multiplied by 8
        If alternative is not equal to 0:
            proc ast_node_add_child from AST with node, alternative
        End If
        Set i to i plus 1
    End While

    Return node
End Process

Process called "build_rest_pattern" takes name as Integer, line as Integer returns Integer:
    Note:
    Build a rest pattern node for capturing remaining elements.
    Rest patterns capture remaining array elements: ...rest or ...
    Parameters:
      name - Variable name to bind rest elements (0 for anonymous ...rest)
      line - Source line number
    Returns pointer to AST_REST_PATTERN node.
    :End Note

    Note: Create rest pattern node
    Let node be proc create_ast_node from AST with AST_REST_PATTERN, line, 0, 0

    Note: Store name if provided (0 for anonymous rest pattern)
    If name is not equal to 0:
        proc ast_node_set_value from AST with node, name, 1  Note: Type 1 for string
    End If

    Return node
End Process