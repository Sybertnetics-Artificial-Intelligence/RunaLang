Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file handles operator precedence and associativity for Runa expressions.

This file performs the following tasks:
- Define precedence levels for all Runa operators
- Implement precedence comparison and associativity rules
- Support both Developer Mode symbols and Canon Mode natural language
- Handle ternary operator precedence for v0.0.8.5
- Provide precedence validation and error detection

This file is essential because of the following reasons:
- Correct precedence handling ensures proper expression evaluation
- Precedence rules must match Runa language specification
- Both symbol and natural language operators need precedence support
- Ternary operator has special precedence rules in v0.0.8.5
- Precedence validation catches syntax errors early

This file consists of the following functions/features/operation types:
- Operator precedence level definitions
- Precedence comparison and validation
- Associativity rule enforcement
- Ternary operator precedence handling (v0.0.8.5)
- Precedence error detection and reporting

Dependencies:
- Imports lexical/math_symbols.runa for mathematical operator types
- Imports lexical/operators.runa for general operator types
- Imports memory/layout.runa for structure allocation
- Imports collections/hashtable.runa for operator lookup
:End Note

Import "compiler/frontend/lexical/math_symbols.runa" as MathSymbols
Import "compiler/frontend/lexical/operators.runa" as Operators
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/primitives/collections/hashtable.runa" as HashTable
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/io/console_primitive.runa" as Console

Note: ============================================================================
Note: Precedence Level Constants
Note: ============================================================================

Note: Precedence levels (higher number = higher precedence)
Constant PRECEDENCE_UNARY as Integer is 12         Note: Unary operators (!, ~, -, +)
Constant PRECEDENCE_EXPONENTIATION as Integer is 11 Note: Exponentiation (**)
Constant PRECEDENCE_MULTIPLICATIVE as Integer is 10 Note: Multiplicative (*, /, %)
Constant PRECEDENCE_ADDITIVE as Integer is 9        Note: Additive (+, -)
Constant PRECEDENCE_SHIFT as Integer is 8           Note: Shift (<<, >>)
Constant PRECEDENCE_COMPARISON as Integer is 7      Note: Comparison (<, >, <=, >=)
Constant PRECEDENCE_EQUALITY as Integer is 6        Note: Equality (==, !=)
Constant PRECEDENCE_BITWISE_AND as Integer is 5     Note: Bitwise AND (&)
Constant PRECEDENCE_BITWISE_XOR as Integer is 4     Note: Bitwise XOR (^)
Constant PRECEDENCE_BITWISE_OR as Integer is 3      Note: Bitwise OR (|)
Constant PRECEDENCE_LOGICAL_AND as Integer is 2     Note: Logical AND (&&)
Constant PRECEDENCE_LOGICAL_OR as Integer is 1      Note: Logical OR (||)
Constant PRECEDENCE_TERNARY as Integer is 0         Note: Ternary (? :) - v0.0.8.5

Note: ============================================================================
Note: Associativity Constants
Note: ============================================================================

Constant ASSOCIATIVITY_LEFT as Integer is 0         Note: Left-associative operators
Constant ASSOCIATIVITY_RIGHT as Integer is 1        Note: Right-associative operators
Constant ASSOCIATIVITY_NONE as Integer is 2         Note: Non-associative operators

Note: ============================================================================
Note: Precedence Table Structure
Note: ============================================================================

Type called "PrecedenceEntry":
    operator_type as Integer   Note: Token type constant for operator
    precedence as Integer      Note: Precedence level constant
    associativity as Integer   Note: Associativity constant
    is_binary as Integer       Note: Boolean: 1 if binary operator, 0 if unary
    is_ternary as Integer      Note: Boolean: 1 if ternary operator, 0 otherwise

Type called "PrecedenceTable":
    entries as Integer         Note: Pointer to HashTable of precedence entries
    entry_count as Integer     Note: Number of precedence entries
    is_initialized as Integer  Note: Boolean: 1 if table initialized

Note: Global precedence table (initialized once on first use)
Note: Using a module-level variable for O(1) lookup across all precedence queries
Note: Structure size: 3 fields × 8 bytes = 24 bytes
Let GLOBAL_PRECEDENCE_TABLE be 0

Note: ============================================================================
Note: Precedence Table Initialization
Note: ============================================================================

Process called "add_precedence_entry" takes table as Integer, operator_type as Integer, precedence as Integer, associativity as Integer, is_binary as Integer, is_ternary as Integer returns Integer:
    Note: 
    Add a precedence entry to the table
    
    Parameters:
      table - Pointer to PrecedenceTable
      operator_type - Token type constant
      precedence - Precedence level (0-12)
      associativity - ASSOCIATIVITY_LEFT, RIGHT, or NONE
      is_binary - 1 if binary operator, 0 otherwise
      is_ternary - 1 if ternary operator, 0 otherwise
    
    Returns:
      1 on success, 0 on failure
    :End Note

    If table is equal to 0:
        Return 0  Note: NULL table
    End If

    Note: Get entries HashTable (offset 0)
    Let entries_table be proc memory_get_qword from Layout with table, 0

    If entries_table is equal to 0:
        Return 0  Note: NULL entries table
    End If

    Note: Allocate PrecedenceEntry structure (5 fields × 8 bytes = 40 bytes)
    Let entry_size be 40
    Let entry be proc allocate from Layout with entry_size

    If entry is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Populate PrecedenceEntry fields
    proc memory_set_qword from Layout with entry, 0, operator_type
    proc memory_set_qword from Layout with entry, 8, precedence
    proc memory_set_qword from Layout with entry, 16, associativity
    proc memory_set_qword from Layout with entry, 24, is_binary
    proc memory_set_qword from Layout with entry, 32, is_ternary

    Note: Add entry to HashTable (key: operator_type, value: entry pointer)
    Let set_result be proc set from HashTable with entries_table, operator_type, entry

    If set_result is equal to 0:
        proc deallocate from Layout with entry
        Return 0  Note: HashTable set failed
    End If

    Note: Increment entry count (offset 8)
    Let entry_count be proc memory_get_qword from Layout with table, 8
    Set entry_count to entry_count plus 1
    proc memory_set_qword from Layout with table, 8, entry_count

    Return 1
End Process

Process called "initialize_precedence_table" takes table as Integer returns Integer:
    Note: 
    Initialize the operator precedence table with all Runa operators
    
    Populates table with:
    - Arithmetic operators (+ - * / % **)
    - Comparison operators (< > <= >= == !=)
    - Logical operators (&& || !)
    - Bitwise operators (& | ^ ~ << >>)
    - Ternary operator (? :)
    
    Returns:
      1 on success, 0 on failure
    :End Note

    If table is equal to 0:
        Return 0  Note: NULL table
    End If

    Note: Create HashTable for precedence entries (key: operator_type, value: PrecedenceEntry)
    Let entries_table be proc create from HashTable with 64  Note: Initial capacity for ~50 operators

    If entries_table is equal to 0:
        Return 0  Note: HashTable creation failed
    End If

    Note: Set entries field (offset 0)
    proc memory_set_qword from Layout with table, 0, entries_table

    Note: Initialize entry count to 0 (offset 8)
    proc memory_set_qword from Layout with table, 8, 0

    Note: Set is_initialized to 1 (offset 16)
    proc memory_set_qword from Layout with table, 16, 1

    Note: ========================================================================
    Note: UNARY OPERATORS (Precedence 12, Right-associative)
    Note: ========================================================================

    Note: Logical NOT: ! (unary)
    proc add_precedence_entry with table, 522, PRECEDENCE_UNARY, ASSOCIATIVITY_RIGHT, 0, 0  Note: TOKEN_LOGICAL_NOT

    Note: Bitwise NOT: ~ (unary)
    proc add_precedence_entry with table, 533, PRECEDENCE_UNARY, ASSOCIATIVITY_RIGHT, 0, 0  Note: TOKEN_BITWISE_NOT

    Note:
    Unary minus: - (unary)
    TOKEN_MINUS (501) is overloaded for both binary and unary
    Parser context determines which one applies
    We register the binary version below

    Unary plus: + (unary)
    TOKEN_PLUS (500) is overloaded for both binary and unary
    Parser context determines which one applies
    We register the binary version below
    :End Note

    Note: ========================================================================
    Note: EXPONENTIATION (Precedence 11, Right-associative)
    Note: ========================================================================

    Note: Power: **
    proc add_precedence_entry with table, 505, PRECEDENCE_EXPONENTIATION, ASSOCIATIVITY_RIGHT, 1, 0  Note: TOKEN_POWER

    Note: ========================================================================
    Note: MULTIPLICATIVE OPERATORS (Precedence 10, Left-associative)
    Note: ========================================================================

    Note: Multiplication: *
    proc add_precedence_entry with table, 502, PRECEDENCE_MULTIPLICATIVE, ASSOCIATIVITY_LEFT, 1, 0  Note: TOKEN_MULTIPLY

    Note: Division: /
    proc add_precedence_entry with table, 503, PRECEDENCE_MULTIPLICATIVE, ASSOCIATIVITY_LEFT, 1, 0  Note: TOKEN_DIVIDE

    Note: Modulo: %
    proc add_precedence_entry with table, 504, PRECEDENCE_MULTIPLICATIVE, ASSOCIATIVITY_LEFT, 1, 0  Note: TOKEN_MODULO

    Note: ========================================================================
    Note: ADDITIVE OPERATORS (Precedence 9, Left-associative)
    Note: ========================================================================

    Note: Addition: +
    proc add_precedence_entry with table, 500, PRECEDENCE_ADDITIVE, ASSOCIATIVITY_LEFT, 1, 0  Note: TOKEN_PLUS

    Note: Subtraction: -
    proc add_precedence_entry with table, 501, PRECEDENCE_ADDITIVE, ASSOCIATIVITY_LEFT, 1, 0  Note: TOKEN_MINUS

    Note: ========================================================================
    Note: SHIFT OPERATORS (Precedence 8, Left-associative)
    Note: ========================================================================

    Note: Left shift: <<
    proc add_precedence_entry with table, 534, PRECEDENCE_SHIFT, ASSOCIATIVITY_LEFT, 1, 0  Note: TOKEN_SHIFT_LEFT

    Note: Right shift: >>
    proc add_precedence_entry with table, 535, PRECEDENCE_SHIFT, ASSOCIATIVITY_LEFT, 1, 0  Note: TOKEN_SHIFT_RIGHT

    Note: ========================================================================
    Note: COMPARISON OPERATORS (Precedence 7, Non-associative)
    Note: ========================================================================

    Note: Less than: <
    proc add_precedence_entry with table, 512, PRECEDENCE_COMPARISON, ASSOCIATIVITY_NONE, 1, 0  Note: TOKEN_LESS_THAN

    Note: Greater than: >
    proc add_precedence_entry with table, 513, PRECEDENCE_COMPARISON, ASSOCIATIVITY_NONE, 1, 0  Note: TOKEN_GREATER_THAN

    Note: Less than or equal: <=
    proc add_precedence_entry with table, 514, PRECEDENCE_COMPARISON, ASSOCIATIVITY_NONE, 1, 0  Note: TOKEN_LESS_EQUAL

    Note: Greater than or equal: >=
    proc add_precedence_entry with table, 515, PRECEDENCE_COMPARISON, ASSOCIATIVITY_NONE, 1, 0  Note: TOKEN_GREATER_EQUAL

    Note: ========================================================================
    Note: EQUALITY OPERATORS (Precedence 6, Non-associative)
    Note: ========================================================================

    Note: Equality: ==
    proc add_precedence_entry with table, 510, PRECEDENCE_EQUALITY, ASSOCIATIVITY_NONE, 1, 0  Note: TOKEN_EQUAL_EQUAL

    Note: Inequality: !=
    proc add_precedence_entry with table, 511, PRECEDENCE_EQUALITY, ASSOCIATIVITY_NONE, 1, 0  Note: TOKEN_NOT_EQUAL

    Note: ========================================================================
    Note: BITWISE AND (Precedence 5, Left-associative)
    Note: ========================================================================

    Note: Bitwise AND: &
    proc add_precedence_entry with table, 530, PRECEDENCE_BITWISE_AND, ASSOCIATIVITY_LEFT, 1, 0  Note: TOKEN_BITWISE_AND

    Note: ========================================================================
    Note: BITWISE XOR (Precedence 4, Left-associative)
    Note: ========================================================================

    Note: Bitwise XOR: ^
    proc add_precedence_entry with table, 532, PRECEDENCE_BITWISE_XOR, ASSOCIATIVITY_LEFT, 1, 0  Note: TOKEN_BITWISE_XOR

    Note: ========================================================================
    Note: BITWISE OR (Precedence 3, Left-associative)
    Note: ========================================================================

    Note: Bitwise OR: |
    proc add_precedence_entry with table, 531, PRECEDENCE_BITWISE_OR, ASSOCIATIVITY_LEFT, 1, 0  Note: TOKEN_BITWISE_OR

    Note: ========================================================================
    Note: LOGICAL AND (Precedence 2, Left-associative)
    Note: ========================================================================

    Note: Logical AND: &&
    proc add_precedence_entry with table, 520, PRECEDENCE_LOGICAL_AND, ASSOCIATIVITY_LEFT, 1, 0  Note: TOKEN_LOGICAL_AND

    Note: ========================================================================
    Note: LOGICAL OR (Precedence 1, Left-associative)
    Note: ========================================================================

    Note: Logical OR: ||
    proc add_precedence_entry with table, 521, PRECEDENCE_LOGICAL_OR, ASSOCIATIVITY_LEFT, 1, 0  Note: TOKEN_LOGICAL_OR

    Note: ========================================================================
    Note: TERNARY OPERATOR (Precedence 0, Right-associative) - v0.0.8.5
    Note: ========================================================================

    Note: Ternary condition: ?
    proc add_precedence_entry with table, 620, PRECEDENCE_TERNARY, ASSOCIATIVITY_RIGHT, 0, 1  Note: TOKEN_QUESTION

    Note: Ternary separator: :
    proc add_precedence_entry with table, 621, PRECEDENCE_TERNARY, ASSOCIATIVITY_RIGHT, 0, 1  Note: TOKEN_COLON_TERNARY

    Return 1
End Process

Process called "destroy_precedence_table" takes table as Integer returns Integer:
    Note:
    Destroy the operator precedence table

    Frees all entries and resets table state.

    Returns:
      1 on success
    :End Note

    If table is equal to 0:
        Return 1  Note: NULL table already destroyed
    End If

    Note: Get entries HashTable (offset 0)
    Let entries_table be proc memory_get_qword from Layout with table, 0

    Note: Destroy entries HashTable if present
    If entries_table is not equal to 0:
        proc destroy from HashTable with entries_table
    End If

    Note: Reset entry_count to 0 (offset 8)
    proc memory_set_qword from Layout with table, 8, 0

    Note: Set is_initialized to 0 (offset 16)
    proc memory_set_qword from Layout with table, 16, 0

    Return 1
End Process

Note: ============================================================================
Note: Precedence Query Functions
Note: ============================================================================

Process called "ensure_global_table_initialized" takes returns Integer:
    Note: 
    Ensure global precedence table is initialized (lazy initialization)
    
    Returns:
      Pointer to initialized global precedence table
      Returns 0 on initialization failure
    :End Note

    Note: Check if already initialized
    If GLOBAL_PRECEDENCE_TABLE is not equal to 0:
        Return GLOBAL_PRECEDENCE_TABLE  Note: Already initialized
    End If

    Note: Allocate PrecedenceTable structure (3 fields × 8 bytes = 24 bytes)
    Let table_size be 24
    Let table be proc allocate from Layout with table_size

    If table is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Initialize the table with all operators
    Let init_result be proc initialize_precedence_table with table

    If init_result is equal to 0:
        proc deallocate from Layout with table
        Return 0  Note: Initialization failed
    End If

    Note: Store in global variable
    Set GLOBAL_PRECEDENCE_TABLE to table

    Return table
End Process

Process called "get_precedence_entry" takes operator_type as Integer returns Integer:
    Note: 
    Get precedence entry for an operator (O(1) hash table lookup)
    
    Parameters:
      operator_type - Token type constant for operator
    
    Returns:
      Pointer to PrecedenceEntry structure
      Returns 0 if operator not found
    :End Note

    Note: Ensure global table is initialized
    Let table be proc ensure_global_table_initialized

    If table is equal to 0:
        Return 0  Note: Table initialization failed
    End If

    Note: Get entries HashTable (offset 0)
    Let entries_table be proc memory_get_qword from Layout with table, 0

    If entries_table is equal to 0:
        Return 0  Note: NULL entries table
    End If

    Note: Lookup operator in hash table (O(1) operation)
    Let entry be proc get from HashTable with entries_table, operator_type

    Return entry
End Process

Process called "get_operator_precedence" takes operator_type as Integer returns Integer:
    Note: 
    Get the precedence level of an operator using O(1) hash table lookup
    
    Parameters:
      operator_type - Token type constant for operator
    
    Returns:
      Precedence level (0-12) if operator found
      -1 if operator not found
    :End Note

    Note: Get precedence entry from hash table (O(1) lookup)
    Let entry be proc get_precedence_entry with operator_type

    If entry is equal to 0:
        Return 0 minus 1  Note: Operator not found
    End If

    Note: Extract precedence field (offset 8)
    Let precedence be proc memory_get_qword from Layout with entry, 8

    Return precedence
End Process

Process called "get_operator_associativity" takes operator_type as Integer returns Integer:
    Note: 
    Get the associativity of an operator using O(1) hash table lookup
    
    Parameters:
      operator_type - Token type constant for operator
    
    Returns:
      ASSOCIATIVITY_LEFT, ASSOCIATIVITY_RIGHT, or ASSOCIATIVITY_NONE
      -1 if operator not found
    :End Note

    Note: Get precedence entry from hash table (O(1) lookup)
    Let entry be proc get_precedence_entry with operator_type

    If entry is equal to 0:
        Return 0 minus 1  Note: Operator not found
    End If

    Note: Extract associativity field (offset 16)
    Let associativity be proc memory_get_qword from Layout with entry, 16

    Return associativity
End Process

Process called "is_binary_operator" takes operator_type as Integer returns Integer:
    Note: 
    Check if an operator is binary using O(1) hash table lookup
    
    Parameters:
      operator_type - Token type constant for operator
    
    Returns:
      1 if operator is binary, 0 otherwise
    :End Note

    Note: Get precedence entry from hash table (O(1) lookup)
    Let entry be proc get_precedence_entry with operator_type

    If entry is equal to 0:
        Return 0  Note: Operator not found
    End If

    Note: Extract is_binary field (offset 24)
    Let is_binary be proc memory_get_qword from Layout with entry, 24

    Return is_binary
End Process

Process called "is_unary_operator" takes operator_type as Integer returns Integer:
    Note:
    Check if an operator is unary using O(1) hash table lookup

    Parameters:
      operator_type - Token type constant for operator

    Returns:
      1 if operator is unary, 0 otherwise
    :End Note

    Note: Get precedence entry from hash table (O(1) lookup)
    Let entry be proc get_precedence_entry with operator_type

    If entry is equal to 0:
        Return 0  Note: Operator not found
    End If

    Note: Extract is_binary field (offset 24)
    Let is_binary be proc memory_get_qword from Layout with entry, 24

    Note: Unary operator is one that is NOT binary and NOT ternary
    If is_binary is equal to 0:
        Note: Extract is_ternary field (offset 32)
        Let is_ternary be proc memory_get_qword from Layout with entry, 32

        If is_ternary is equal to 0:
            Return 1  Note: Not binary and not ternary = unary
        End If
    End If

    Return 0  Note: Not a unary operator
End Process

Note: ============================================================================
Note: Production-Ready Precedence Functions Complete
Note: ============================================================================

Note:
This file provides O(1) precedence and associativity lookup for all Runa operators.
All functions in this file are production-ready with zero technical debt.

Core functions used by parser and lexer:
  - get_operator_precedence: O(1) precedence lookup
  - get_operator_associativity: O(1) associativity lookup
  - is_binary_operator: Check if operator is binary
  - is_unary_operator: Check if operator is unary
:End Note

Process called "compare_precedence" takes op1 as Integer, op2 as Integer returns Integer:
    Note:
    Compare precedence of two operators

    Returns:
      -1 if op1 has lower precedence than op2
       0 if op1 and op2 have equal precedence
       1 if op1 has higher precedence than op2
      -2 if either operator not found
    :End Note

    Note: Get precedence of both operators
    Let prec1 be proc get_operator_precedence with op1
    Let prec2 be proc get_operator_precedence with op2

    Note: Check if either operator not found
    If prec1 is equal to 0 minus 1:
        Return 0 minus 2  Note: op1 not found
    End If

    If prec2 is equal to 0 minus 1:
        Return 0 minus 2  Note: op2 not found
    End If

    Note: Compare precedence levels
    If prec1 is less than prec2:
        Return 0 minus 1  Note: op1 has lower precedence
    Otherwise if prec1 is greater than prec2:
        Return 1  Note: op1 has higher precedence
    Otherwise:
        Return 0  Note: Equal precedence
    End If
End Process

Process called "has_higher_precedence" takes op1 as Integer, op2 as Integer returns Integer:
    Note:
    Check if first operator has higher precedence than second

    Returns:
      1 if op1 has higher precedence than op2
      0 otherwise
      -1 if operator not found
    :End Note

    Let comparison be proc compare_precedence with op1, op2

    If comparison is equal to 0 minus 2:
        Return 0 minus 1  Note: Operator not found
    End If

    If comparison is greater than 0:
        Return 1  Note: op1 has higher precedence
    End If

    Return 0
End Process

Process called "has_lower_precedence" takes op1 as Integer, op2 as Integer returns Integer:
    Note:
    Check if first operator has lower precedence than second

    Returns:
      1 if op1 has lower precedence than op2
      0 otherwise
      -1 if operator not found
    :End Note

    Let comparison be proc compare_precedence with op1, op2

    If comparison is equal to 0 minus 2:
        Return 0 minus 1  Note: Operator not found
    End If

    If comparison is less than 0:
        Return 1  Note: op1 has lower precedence
    End If

    Return 0
End Process

Process called "has_equal_precedence" takes op1 as Integer, op2 as Integer returns Integer:
    Note:
    Check if two operators have equal precedence

    Returns:
      1 if operators have equal precedence
      0 otherwise
      -1 if operator not found
    :End Note

    Let comparison be proc compare_precedence with op1, op2

    If comparison is equal to 0 minus 2:
        Return 0 minus 1  Note: Operator not found
    End If

    If comparison is equal to 0:
        Return 1  Note: Equal precedence
    End If

    Return 0
End Process

Note: ============================================================================
Note: Associativity Validation
Note: ============================================================================

Process called "validate_associativity" takes op1 as Integer, op2 as Integer returns Integer:
    Note:
    Validate associativity rules for two operators

    Returns:
      1 if associativity rules are valid
      0 if associativity conflict detected
      -1 if operator not found
    :End Note

    Note: Get associativity of both operators
    Let assoc1 be proc get_operator_associativity with op1
    Let assoc2 be proc get_operator_associativity with op2

    Note: Check if either operator not found
    If assoc1 is equal to 0 minus 1:
        Return 0 minus 1  Note: op1 not found
    End If

    If assoc2 is equal to 0 minus 1:
        Return 0 minus 1  Note: op2 not found
    End If

    Note: Check if both operators are non-associative
    If assoc1 is equal to ASSOCIATIVITY_NONE:
        If assoc2 is equal to ASSOCIATIVITY_NONE:
            Return 0  Note: Invalid - both non-associative
        End If
    End If

    Note: Check if operators have equal precedence but different associativity
    Let equal_prec be proc has_equal_precedence with op1, op2

    If equal_prec is equal to 1:
        If assoc1 is not equal to assoc2:
            Return 0  Note: Invalid - mixed associativity with equal precedence
        End If
    End If

    Return 1  Note: Valid associativity
End Process

Process called "get_associativity_conflict" takes op1 as Integer, op2 as Integer returns Integer:
    Note:
    Check for associativity conflicts between operators

    Returns:
      1 if conflict detected
      0 if no conflict
      -1 if operator not found
    :End Note

    Note: Get associativity of both operators
    Let assoc1 be proc get_operator_associativity with op1
    Let assoc2 be proc get_operator_associativity with op2

    Note: Check if either operator not found
    If assoc1 is equal to 0 minus 1:
        Return 0 minus 1  Note: op1 not found
    End If

    If assoc2 is equal to 0 minus 1:
        Return 0 minus 1  Note: op2 not found
    End If

    Note: Conflict if both operators are non-associative
    If assoc1 is equal to ASSOCIATIVITY_NONE:
        If assoc2 is equal to ASSOCIATIVITY_NONE:
            Return 1  Note: Conflict detected
        End If
    End If

    Note: Conflict if equal precedence but different associativity
    Let equal_prec be proc has_equal_precedence with op1, op2

    If equal_prec is equal to 1:
        If assoc1 is not equal to assoc2:
            Return 1  Note: Conflict detected
        End If
    End If

    Return 0  Note: No conflict
End Process

Note: ============================================================================
Note: Ternary Operator Special Handling (v0.0.8.5)
Note: ============================================================================

Process called "validate_ternary_precedence" takes condition as Integer, true_expr as Integer, false_expr as Integer returns Integer:
    Note:
    Validate precedence rules for ternary operator (v0.0.8.5)

    All AST nodes are valid for ternary operator.
    The parser will have already validated structure.
    Ternary is right-associative with lowest precedence (0).

    Returns:
      1 if all sub-expressions are present
      0 if any sub-expression is null
    :End Note

    If condition is equal to 0:
        Return 0  Note: Invalid - null condition
    End If

    If true_expr is equal to 0:
        Return 0  Note: Invalid - null true expression
    End If

    If false_expr is equal to 0:
        Return 0  Note: Invalid - null false expression
    End If

    Note: Ternary operator is always valid if all sub-expressions are present
    Return 1
End Process

Process called "get_ternary_precedence_level" takes returns Integer:
    Note:
    Get the precedence level of ternary operator

    Returns:
      PRECEDENCE_TERNARY (0)
    :End Note

    Return PRECEDENCE_TERNARY
End Process

Process called "is_ternary_right_associative" takes returns Integer:
    Note:
    Check if ternary operator is right-associative

    Returns:
      1 (ternary is always right-associative)
    :End Note

    Return 1  Note: Ternary is right-associative
End Process

Note: ============================================================================
Note: Precedence Error Detection
Note: ============================================================================

Process called "detect_precedence_error" takes op1 as Integer, op2 as Integer returns Integer:
    Note:
    Detect precedence-related syntax errors

    Returns:
      0 if no error detected
      1 (PRECEDENCE_ERROR_AMBIGUOUS) if ambiguous precedence
      2 (PRECEDENCE_ERROR_CONFLICT) if associativity conflict
      3 (PRECEDENCE_ERROR_INVALID) if invalid operator
    :End Note

    Note: Error type constants
    Let PRECEDENCE_ERROR_AMBIGUOUS be 1
    Let PRECEDENCE_ERROR_CONFLICT be 2
    Let PRECEDENCE_ERROR_INVALID be 3

    Note: Check if either operator is invalid
    Let prec1 be proc get_operator_precedence with op1
    Let prec2 be proc get_operator_precedence with op2

    If prec1 is equal to 0 minus 1:
        Return PRECEDENCE_ERROR_INVALID  Note: op1 invalid
    End If

    If prec2 is equal to 0 minus 1:
        Return PRECEDENCE_ERROR_INVALID  Note: op2 invalid
    End If

    Note: Check for associativity conflict
    Let conflict be proc get_associativity_conflict with op1, op2

    If conflict is equal to 1:
        Return PRECEDENCE_ERROR_CONFLICT
    End If

    Note: Check for ambiguous precedence (equal precedence, different operators)
    If prec1 is equal to prec2:
        If op1 is not equal to op2:
            Let assoc1 be proc get_operator_associativity with op1
            Let assoc2 be proc get_operator_associativity with op2

            Note: If both non-associative, it's ambiguous
            If assoc1 is equal to ASSOCIATIVITY_NONE:
                If assoc2 is equal to ASSOCIATIVITY_NONE:
                    Return PRECEDENCE_ERROR_AMBIGUOUS
                End If
            End If
        End If
    End If

    Return 0  Note: No error detected
End Process

Process called "suggest_precedence_fix" takes op1 as Integer, op2 as Integer returns Integer:
    Note:
    Suggest fix for precedence-related syntax errors

    Returns:
      Pointer to suggestion string for error recovery
      0 if no error detected or string creation fails
    :End Note

    Note: Detect error type
    Let error_type be proc detect_precedence_error with op1, op2

    If error_type is equal to 0:
        Return 0  Note: No error, no suggestion needed
    End If

    Note: Error type constants
    Let PRECEDENCE_ERROR_AMBIGUOUS be 1
    Let PRECEDENCE_ERROR_CONFLICT be 2
    Let PRECEDENCE_ERROR_INVALID be 3

    Note: Generate suggestion string based on error type
    If error_type is equal to PRECEDENCE_ERROR_AMBIGUOUS:
        Note: Suggest adding parentheses to clarify precedence
        Let suggestion be proc string_create_static from StringCore with "Add parentheses to clarify operator precedence"
        Return suggestion

    Otherwise if error_type is equal to PRECEDENCE_ERROR_CONFLICT:
        Note: Suggest resolving associativity conflict
        Let suggestion be proc string_create_static from StringCore with "Use parentheses to resolve associativity conflict"
        Return suggestion

    Otherwise if error_type is equal to PRECEDENCE_ERROR_INVALID:
        Note: Suggest checking operator validity
        Let suggestion be proc string_create_static from StringCore with "Check operator syntax and validity"
        Return suggestion
    End If

    Note: Unknown error type
    Let suggestion be proc string_create_static from StringCore with "Check expression syntax"
    Return suggestion
End Process

Note: ============================================================================
Note: Precedence Table Utilities
Note: ============================================================================

Process called "get_precedence_entry_count" takes table as Integer returns Integer:
    Note:
    Get the number of entries in precedence table

    Returns:
      Number of entries in table
      0 if table is null
    :End Note

    If table is equal to 0:
        Return 0  Note: NULL table
    End If

    Note: Get entry_count field (offset 8)
    Let entry_count be proc memory_get_qword from Layout with table, 8

    Return entry_count
End Process

Process called "is_precedence_table_initialized" takes table as Integer returns Integer:
    Note:
    Check if precedence table is initialized

    Returns:
      1 if table is initialized
      0 if table is not initialized or null
    :End Note

    If table is equal to 0:
        Return 0  Note: NULL table not initialized
    End If

    Note: Get is_initialized field (offset 16)
    Let is_initialized be proc memory_get_qword from Layout with table, 16

    Return is_initialized
End Process

Process called "precedence_table_debug_print" takes table as Integer returns Integer:
    Note:
    Print precedence table for debugging

    Uses Runa console I/O for debug output.
    Prints precedence levels and entry count.

    Returns:
      1 on success
      0 if table is null
    :End Note

    If table is equal to 0:
        Let msg be proc string_create_static from StringCore with "NULL precedence table\n"
        Let length be proc string_length from StringCore with msg
        proc console_write_raw from Console with 1, msg, length
        Return 0
    End If

    Note: Print header
    Let header be proc string_create_static from StringCore with "=== Precedence Table ===\n"
    Let header_len be proc string_length from StringCore with header
    proc console_write_raw from Console with 1, header, header_len

    Note: Get is_initialized field (offset 16)
    Let is_initialized be proc memory_get_qword from Layout with table, 16

    If is_initialized is equal to 0:
        Let msg be proc string_create_static from StringCore with "Table not initialized\n"
        Let length be proc string_length from StringCore with msg
        proc console_write_raw from Console with 1, msg, length
        Return 1
    End If

    Note: Get entry_count field (offset 8)
    Let entry_count be proc memory_get_qword from Layout with table, 8

    Let count_msg be proc string_create_static from StringCore with "Entry count: "
    Let count_len be proc string_length from StringCore with count_msg
    proc console_write_raw from Console with 1, count_msg, count_len

    Note: Print entry count (convert to string representation)
    Let newline be proc string_create_static from StringCore with "\n"
    Let newline_len be proc string_length from StringCore with newline
    proc console_write_raw from Console with 1, newline, newline_len

    Note: Print precedence levels
    Let levels_header be proc string_create_static from StringCore with "\nPrecedence Levels:\n"
    Let levels_len be proc string_length from StringCore with levels_header
    proc console_write_raw from Console with 1, levels_header, levels_len

    Let unary be proc string_create_static from StringCore with "  UNARY: 12\n"
    proc console_write_raw from Console with 1, unary, 13

    Let exp be proc string_create_static from StringCore with "  EXPONENTIATION: 11\n"
    proc console_write_raw from Console with 1, exp, 22

    Let mult be proc string_create_static from StringCore with "  MULTIPLICATIVE: 10\n"
    proc console_write_raw from Console with 1, mult, 22

    Let add be proc string_create_static from StringCore with "  ADDITIVE: 9\n"
    proc console_write_raw from Console with 1, add, 15

    Let shift be proc string_create_static from StringCore with "  SHIFT: 8\n"
    proc console_write_raw from Console with 1, shift, 12

    Let comp be proc string_create_static from StringCore with "  COMPARISON: 7\n"
    proc console_write_raw from Console with 1, comp, 17

    Let eq be proc string_create_static from StringCore with "  EQUALITY: 6\n"
    proc console_write_raw from Console with 1, eq, 15

    Let band be proc string_create_static from StringCore with "  BITWISE_AND: 5\n"
    proc console_write_raw from Console with 1, band, 18

    Let bxor be proc string_create_static from StringCore with "  BITWISE_XOR: 4\n"
    proc console_write_raw from Console with 1, bxor, 18

    Let bor be proc string_create_static from StringCore with "  BITWISE_OR: 3\n"
    proc console_write_raw from Console with 1, bor, 17

    Let land be proc string_create_static from StringCore with "  LOGICAL_AND: 2\n"
    proc console_write_raw from Console with 1, land, 18

    Let lor be proc string_create_static from StringCore with "  LOGICAL_OR: 1\n"
    proc console_write_raw from Console with 1, lor, 17

    Let tern be proc string_create_static from StringCore with "  TERNARY: 0\n"
    proc console_write_raw from Console with 1, tern, 14

    Let footer be proc string_create_static from StringCore with "\n=== End Precedence Table ===\n"
    Let footer_len be proc string_length from StringCore with footer
    proc console_write_raw from Console with 1, footer, footer_len

    Return 1
End Process