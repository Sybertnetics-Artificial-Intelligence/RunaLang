Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file implements expression parsing for Runa language expressions.

This file performs the following tasks:
- Parse arithmetic, logical, and comparison expressions using Pratt parser
- Handle ternary operator parsing (condition ? true_value : false_value) - v0.0.8.5 feature
- Process function calls and method invocations
- Handle expression precedence and associativity
- Support string interpolation parsing (f"text {expr}") - v0.0.8.5 feature
- Parse range expressions and member access

This file is essential because of the following reasons:
- Expression parsing is fundamental to Runa's computational capabilities
- Pratt parser ensures correct precedence and associativity handling
- Ternary operator is a key v0.0.8.5 feature requirement
- String interpolation enables dynamic string construction
- Proper expression parsing enables correct evaluation and code generation

This file consists of the following functions/features/operation types:
- Pratt parser implementation for expressions
- Ternary operator parsing and validation (v0.0.8.5)
- Function call and method invocation parsing
- String interpolation parsing (v0.0.8.5)
- Range expression and member access parsing
- Expression precedence and associativity handling

Dependencies:
- Imports parser.runa for parser state and token navigation
- Imports precedence.runa for operator precedence handling
- Imports ast_builder.runa for AST construction
- Imports lexical components for token recognition
- Imports memory/layout.runa for structure allocation
:End Note

Import "compiler/frontend/parsing/parser.runa" as Parser
Import "compiler/frontend/parsing/precedence.runa" as Precedence
Import "compiler/frontend/parsing/ast_builder.runa" as ASTBuilder
Import "compiler/frontend/lexical/literals.runa" as Literals
Import "compiler/frontend/lexical/keywords.runa" as Keywords
Import "compiler/frontend/lexical/math_symbols.runa" as MathSymbols
Import "compiler/frontend/lexical/operators.runa" as Operators
Import "compiler/frontend/lexical/delimiters.runa" as Delimiters
Import "compiler/frontend/primitives/memory/layout.runa" as Layout

Note: ============================================================================
Note: Expression Parsing Entry Points
Note: ============================================================================

Process called "parse_expression" takes parser as Integer returns Integer:
    Note: Parse an expression using Pratt parser algorithm
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to expression AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Parse left operand using parse_primary_expression
    Note: 2. While current token is binary operator with precedence > 0:
    Note:    - Get operator precedence using Precedence.get_operator_precedence
    Note:    - If precedence > 0 (not ternary), parse binary expression
    Note:    - Otherwise, break (ternary handled separately)
    Note: 3. Check for ternary operator (? :)
    Note: 4. If ternary found, parse ternary expression
    Note: 5. Return final expression AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: Parse with minimum precedence of 0 (parse everything)
    Let expression be proc parse_expression_with_precedence with parser, 0

    If expression is equal to 0:
        Return 0
    End If

    Note: Check for ternary operator (? :) which has special handling
    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token

    Note: If question mark found, parse ternary expression
    If token_type is equal to TOKEN_QUESTION_MARK:
        Let ternary be proc parse_ternary_expression with parser, expression
        Return ternary
    End If

    Return expression
End Process

Process called "parse_expression_with_precedence" takes parser as Integer, min_precedence as Integer returns Integer:
    Note: Parse expression with minimum precedence constraint (Pratt parser core)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:   min_precedence - Minimum precedence level to parse
    Note:
    Note: Returns:
    Note:   Pointer to expression AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Pratt parser algorithm:
    Note: 1. Parse left operand using parse_primary_expression
    Note: 2. While current token is binary operator:
    Note:    - Get operator precedence
    Note:    - If precedence < min_precedence, break
    Note:    - If precedence == min_precedence and not left-associative, break
    Note:    - Parse binary expression with precedence + 1
    Note: 3. Return expression AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: Parse left operand (prefix expression or primary)
    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token

    Note: Check for unary operators (prefix)
    Let is_unary be proc is_unary_operator from Operators with token_type
    If is_unary is equal to 1:
        Let left be proc parse_unary_expression with parser
    Otherwise:
        Let left be proc parse_primary_expression with parser
    End If

    If left is equal to 0:
        Return 0
    End If

    Note: Parse binary operators with Pratt precedence climbing
    Loop:
        Set current_token to proc parser_current_token from Parser with parser
        Set token_type to proc token_get_type from Parser with current_token

        Note: Check if current token is a binary operator
        Let is_binary be proc is_binary_operator from Operators with token_type
        If is_binary is equal to 0:
            Break  Note: Not a binary operator, done parsing
        End If

        Note: Get operator precedence
        Let precedence be proc get_operator_precedence from Precedence with token_type

        Note: If precedence less than minimum, stop parsing
        If precedence is less than min_precedence:
            Break
        End If

        Note: Check associativity for equal precedence
        If precedence is equal to min_precedence:
            Let assoc be proc get_operator_associativity from Precedence with token_type
            Note: If right-associative (assoc = 1), stop parsing
            If assoc is equal to 1:
                Break
            End If
        End If

        Note: Parse binary expression with this operator
        Set left to proc parse_binary_expression with parser, left, token_type
        If left is equal to 0:
            Return 0
        End If
    End Loop

    Note: Check for postfix operators (member access, function call, indexing)
    Loop:
        Set current_token to proc parser_current_token from Parser with parser
        Set token_type to proc token_get_type from Parser with current_token

        Note: Check for member access (.)
        If token_type is equal to TOKEN_DOT:
            Set left to proc parse_member_expression with parser, left
            If left is equal to 0:
                Return 0
            End If
            Continue
        End If

        Note: Check for function call (()
        If token_type is equal to TOKEN_LEFT_PAREN:
            Set left to proc parse_call_expression with parser, left
            If left is equal to 0:
                Return 0
            End If
            Continue
        End If

        Note: Check for array indexing ([])
        If token_type is equal to TOKEN_LEFT_BRACKET:
            Set left to proc parse_index_expression with parser, left
            If left is equal to 0:
                Return 0
            End If
            Continue
        End If

        Note: Check for range operator (..)
        If token_type is equal to TOKEN_RANGE:
            Set left to proc parse_range_expression with parser, left
            If left is equal to 0:
                Return 0
            End If
            Continue
        End If

        Note: No more postfix operators, done
        Break
    End Loop

    Return left
End Process

Note: ============================================================================
Note: Primary Expression Parsing
Note: ============================================================================

Process called "parse_primary_expression" takes parser as Integer returns Integer:
    Note: Parse a primary expression (literal, identifier, parenthesized)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to primary expression AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Primary expressions:
    Note:   - Literals: strings, numbers, booleans, null
    Note:   - Identifiers: variables, functions, types
    Note:   - Parenthesized: (expression)
    Note:   - String interpolation: f"text {expr}" (v0.0.8.5)
    Note:   - Array literals: [expr1, expr2, ...]
    Note:   - Tuple literals: (expr1, expr2, ...)
    Note:
    Note: Algorithm:
    Note: 1. Check current token type
    Note: 2. If literal: call parse_literal_expression
    Note: 3. If identifier: call parse_identifier_expression
    Note: 4. If left parenthesis: call parse_parenthesized_expression
    Note: 5. If string with f prefix: call parse_interpolated_string
    Note: 6. If left bracket: call parse_array_literal
    Note: 7. Otherwise: report error and return 0

    If parser is equal to 0:
        Return 0
    End If

    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token

    Note: Check for literals (string, number, boolean, null)
    Let is_literal be proc is_literal_token from Literals with token_type
    If is_literal is equal to 1:
        Return proc parse_literal_expression with parser
    End If

    Note: Check for identifier
    If token_type is equal to TOKEN_IDENTIFIER:
        Return proc parse_identifier_expression with parser
    End If

    Note: Check for left parenthesis (parenthesized expression or tuple)
    If token_type is equal to TOKEN_LEFT_PAREN:
        Return proc parse_parenthesized_expression with parser
    End If

    Note: Check for left bracket (array literal)
    If token_type is equal to TOKEN_LEFT_BRACKET:
        Return proc parse_array_literal with parser
    End If

    Note: Check for f-string prefix (string interpolation)
    If token_type is equal to TOKEN_F_STRING:
        Return proc parse_interpolated_string with parser
    End If

    Note: Unexpected token - report error
    proc parser_report_error from Parser with parser, "Expected primary expression (literal, identifier, or parenthesized expression)"
    Return 0
End Process

Process called "parse_literal_expression" takes parser as Integer returns Integer:
    Note: Parse a literal expression (string, number, boolean, null)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to literal expression AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Get current token
    Note: 2. Create AST node with type AST_LITERAL
    Note: 3. Set value from token
    Note: 4. Set value type from token type
    Note: 5. Consume token
    Note: 6. Return literal AST node

    If parser is equal to 0:
        Return 0
    End If

    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token
    Let token_value be proc token_get_value from Parser with current_token

    Note: Create literal AST node
    Let literal_node be proc build_literal_node from ASTBuilder with token_type, token_value

    If literal_node is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create literal AST node"
        Return 0
    End If

    Note: Consume the literal token
    proc parser_consume_token from Parser with parser

    Return literal_node
End Process

Process called "parse_identifier_expression" takes parser as Integer returns Integer:
    Note: Parse an identifier expression
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to identifier expression AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Get current token
    Note: 2. Create AST node with type AST_IDENTIFIER
    Note: 3. Set identifier name from token
    Note: 4. Consume token
    Note: 5. Return identifier AST node

    If parser is equal to 0:
        Return 0
    End If

    Let current_token be proc parser_current_token from Parser with parser
    Let token_value be proc token_get_value from Parser with current_token

    Note: Create identifier AST node
    Let identifier_node be proc build_identifier_node from ASTBuilder with token_value

    If identifier_node is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create identifier AST node"
        Return 0
    End If

    Note: Consume the identifier token
    proc parser_consume_token from Parser with parser

    Return identifier_node
End Process

Process called "parse_parenthesized_expression" takes parser as Integer returns Integer:
    Note: Parse a parenthesized expression
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to parenthesized expression AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume left parenthesis
    Note: 2. Parse inner expression using parse_expression
    Note: 3. Expect and consume right parenthesis
    Note: 4. Return inner expression (parentheses don't create new node)

    If parser is equal to 0:
        Return 0
    End If

    Note: Expect and consume left parenthesis
    Let result be proc parser_expect_token from Parser with parser, TOKEN_LEFT_PAREN
    If result is equal to 0:
        Return 0
    End If

    Note: Parse the inner expression
    Let inner_expr be proc parse_expression with parser

    If inner_expr is equal to 0:
        proc parser_report_error from Parser with parser, "Expected expression inside parentheses"
        Return 0
    End If

    Note: Expect and consume right parenthesis
    Set result to proc parser_expect_token from Parser with parser, TOKEN_RIGHT_PAREN
    If result is equal to 0:
        Return 0
    End If

    Note: Return the inner expression (parentheses are just for grouping)
    Return inner_expr
End Process

Note: ============================================================================
Note: Unary Expression Parsing
Note: ============================================================================

Process called "parse_unary_expression" takes parser as Integer returns Integer:
    Note: Parse a unary expression (not, minus, etc.)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to unary expression AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Get current token (unary operator)
    Note: 2. Consume operator token
    Note: 3. Parse operand using parse_expression_with_precedence
    Note:    - Use PRECEDENCE_UNARY as min_precedence
    Note: 4. Create unary expression AST node
    Note: 5. Return unary expression AST node

    If parser is equal to 0:
        Return 0
    End If

    Let current_token be proc parser_current_token from Parser with parser
    Let operator_type be proc token_get_type from Parser with current_token

    Note: Consume the unary operator
    proc parser_consume_token from Parser with parser

    Note: Get unary precedence level
    Let unary_precedence be proc get_unary_precedence from Precedence

    Note: Parse the operand with unary precedence
    Let operand be proc parse_expression_with_precedence with parser, unary_precedence

    If operand is equal to 0:
        proc parser_report_error from Parser with parser, "Expected expression after unary operator"
        Return 0
    End If

    Note: Build unary expression AST node
    Let unary_node be proc build_unary_expression from ASTBuilder with operator_type, operand

    If unary_node is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create unary expression AST node"
        Return 0
    End If

    Return unary_node
End Process

Note: ============================================================================
Note: Binary Expression Parsing
Note: ============================================================================

Process called "parse_binary_expression" takes parser as Integer, left as Integer, operator as Integer returns Integer:
    Note: Parse a binary expression
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:   left - Pointer to left operand AST node
    Note:   operator - Operator token type
    Note:
    Note: Returns:
    Note:   Pointer to binary expression AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Get operator precedence using Precedence.get_operator_precedence
    Note: 2. Consume operator token
    Note: 3. Parse right operand using parse_expression_with_precedence
    Note:    - Use precedence + 1 as min_precedence
    Note: 4. Create binary expression AST node using ASTBuilder.build_binary_expression
    Note: 5. Return binary expression AST node

    If parser is equal to 0:
        Return 0
    End If

    If left is equal to 0:
        Return 0
    End If

    Note: Get operator precedence
    Let precedence be proc get_operator_precedence from Precedence with operator

    Note: Consume the operator token
    proc parser_consume_token from Parser with parser

    Note: Determine right precedence based on associativity
    Let assoc be proc get_operator_associativity from Precedence with operator
    Let right_precedence be precedence

    Note: For left-associative (assoc=0), use precedence + 1
    Note: For right-associative (assoc=1), use precedence
    If assoc is equal to 0:
        Set right_precedence to precedence plus 1
    End If

    Note: Parse right operand with appropriate precedence
    Let right be proc parse_expression_with_precedence with parser, right_precedence

    If right is equal to 0:
        proc parser_report_error from Parser with parser, "Expected expression after binary operator"
        Return 0
    End If

    Note: Build binary expression AST node
    Let binary_node be proc build_binary_expression from ASTBuilder with operator, left, right

    If binary_node is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create binary expression AST node"
        Return 0
    End If

    Return binary_node
End Process

Note: ============================================================================
Note: Ternary Expression Parsing (v0.0.8.5)
Note: ============================================================================

Process called "parse_ternary_expression" takes parser as Integer, condition as Integer returns Integer:
    Note: Parse a ternary expression (condition ? true_value : false_value)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:   condition - Pointer to condition expression AST node
    Note:
    Note: Returns:
    Note:   Pointer to ternary expression AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume ? token
    Note: 2. Parse true value using parse_expression
    Note: 3. Expect and consume : token
    Note: 4. Parse false value using parse_expression
    Note: 5. Create ternary expression AST node using ASTBuilder.build_ternary_expression
    Note: 6. Return ternary expression AST node

    If parser is equal to 0:
        Return 0
    End If

    If condition is equal to 0:
        Return 0
    End If

    Note: Expect and consume question mark
    Let result be proc parser_expect_token from Parser with parser, TOKEN_QUESTION_MARK
    If result is equal to 0:
        Return 0
    End If

    Note: Parse true branch expression
    Let true_expr be proc parse_expression with parser

    If true_expr is equal to 0:
        proc parser_report_error from Parser with parser, "Expected expression after '?' in ternary operator"
        Return 0
    End If

    Note: Expect and consume colon
    Set result to proc parser_expect_token from Parser with parser, TOKEN_COLON
    If result is equal to 0:
        Return 0
    End If

    Note: Parse false branch expression
    Let false_expr be proc parse_expression with parser

    If false_expr is equal to 0:
        proc parser_report_error from Parser with parser, "Expected expression after ':' in ternary operator"
        Return 0
    End If

    Note: Build ternary expression AST node
    Let ternary_node be proc build_ternary_expression from ASTBuilder with condition, true_expr, false_expr

    If ternary_node is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create ternary expression AST node"
        Return 0
    End If

    Return ternary_node
End Process

Note: ============================================================================
Note: Function Call Expression Parsing
Note: ============================================================================

Process called "parse_call_expression" takes parser as Integer, callee as Integer returns Integer:
    Note: Parse a function call expression
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:   callee - Pointer to function/object being called
    Note:
    Note: Returns:
    Note:   Pointer to call expression AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume left parenthesis
    Note: 2. Parse argument list:
    Note:    - If right parenthesis immediately: empty arguments
    Note:    - Otherwise: parse comma-separated expressions
    Note: 3. Expect and consume right parenthesis
    Note: 4. Create call expression AST node using ASTBuilder.build_call_expression
    Note: 5. Return call expression AST node

    If parser is equal to 0:
        Return 0
    End If

    If callee is equal to 0:
        Return 0
    End If

    Note: Expect and consume left parenthesis
    Let result be proc parser_expect_token from Parser with parser, TOKEN_LEFT_PAREN
    If result is equal to 0:
        Return 0
    End If

    Note: Parse argument list
    Let arguments be proc parse_argument_list with parser

    If arguments is equal to 0:
        Note: Empty argument list is valid, create empty list
        Set arguments to proc create_list from Layout
    End If

    Note: Expect and consume right parenthesis
    Set result to proc parser_expect_token from Parser with parser, TOKEN_RIGHT_PAREN
    If result is equal to 0:
        Return 0
    End If

    Note: Build call expression AST node
    Let call_node be proc build_call_expression from ASTBuilder with callee, arguments

    If call_node is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create call expression AST node"
        Return 0
    End If

    Return call_node
End Process

Process called "parse_argument_list" takes parser as Integer returns Integer:
    Note: Parse a function call argument list
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to List of argument AST nodes
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Create empty List for arguments
    Note: 2. While not at right parenthesis:
    Note:    - Parse argument expression using parse_expression
    Note:    - Add to arguments List
    Note:    - If comma found: consume comma and continue
    Note:    - Otherwise: break
    Note: 3. Return arguments List

    If parser is equal to 0:
        Return 0
    End If

    Note: Check if we have arguments (not immediately at right paren)
    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token

    If token_type is equal to TOKEN_RIGHT_PAREN:
        Note: Empty argument list
        Return proc create_list from Layout
    End If

    Note: Create list for arguments
    Let arguments be proc create_list from Layout
    If arguments is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create argument list"
        Return 0
    End If

    Note: Parse arguments until we hit right parenthesis
    Loop:
        Note: Parse argument expression
        Let arg be proc parse_expression with parser

        If arg is equal to 0:
            proc parser_report_error from Parser with parser, "Expected expression in argument list"
            Return 0
        End If

        Note: Add argument to list
        proc list_append from Layout with arguments, arg

        Note: Check for comma (more arguments) or right paren (done)
        Set current_token to proc parser_current_token from Parser with parser
        Set token_type to proc token_get_type from Parser with current_token

        If token_type is equal to TOKEN_COMMA:
            Note: Consume comma and continue to next argument
            proc parser_consume_token from Parser with parser
            Continue
        End If

        Note: No comma, done with arguments
        Break
    End Loop

    Return arguments
End Process

Note: ============================================================================
Note: Member Access Expression Parsing
Note: ============================================================================

Process called "parse_member_expression" takes parser as Integer, object as Integer returns Integer:
    Note: Parse a member access expression (object.property)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:   object - Pointer to object expression AST node
    Note:
    Note: Returns:
    Note:   Pointer to member expression AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Check current token must be dot (.)
    Note: 2. Consume dot token
    Note: 3. Parse property identifier
    Note: 4. Create member expression
    Note: 5. Return member expression AST node

    If parser is equal to 0:
        Return 0
    End If

    If object is equal to 0:
        Return 0
    End If

    Note: Expect and consume dot
    Let result be proc parser_expect_token from Parser with parser, TOKEN_DOT
    If result is equal to 0:
        Return 0
    End If

    Note: Parse property identifier
    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token

    If token_type is not equal to TOKEN_IDENTIFIER:
        proc parser_report_error from Parser with parser, "Expected property name after '.'"
        Return 0
    End If

    Let property be proc parse_identifier_expression with parser

    If property is equal to 0:
        Return 0
    End If

    Note: Build member access AST node
    Let member_node be proc build_member_expression from ASTBuilder with object, property

    If member_node is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create member expression AST node"
        Return 0
    End If

    Return member_node
End Process

Process called "parse_index_expression" takes parser as Integer, object as Integer returns Integer:
    Note: Parse an array/collection index expression (object[index])
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:   object - Pointer to object expression AST node
    Note:
    Note: Returns:
    Note:   Pointer to index expression AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume left bracket
    Note: 2. Parse index expression using parse_expression
    Note: 3. Expect and consume right bracket
    Note: 4. Create index expression AST node using ASTBuilder.build_index_expression
    Note: 5. Return index expression AST node

    If parser is equal to 0:
        Return 0
    End If

    If object is equal to 0:
        Return 0
    End If

    Note: Expect and consume left bracket
    Let result be proc parser_expect_token from Parser with parser, TOKEN_LEFT_BRACKET
    If result is equal to 0:
        Return 0
    End If

    Note: Parse index expression
    Let index be proc parse_expression with parser

    If index is equal to 0:
        proc parser_report_error from Parser with parser, "Expected index expression inside brackets"
        Return 0
    End If

    Note: Expect and consume right bracket
    Set result to proc parser_expect_token from Parser with parser, TOKEN_RIGHT_BRACKET
    If result is equal to 0:
        Return 0
    End If

    Note: Build index expression AST node
    Let index_node be proc build_index_expression from ASTBuilder with object, index

    If index_node is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create index expression AST node"
        Return 0
    End If

    Return index_node
End Process

Note: ============================================================================
Note: String Interpolation Parsing (v0.0.8.5)
Note: ============================================================================

Process called "parse_interpolated_string" takes parser as Integer returns Integer:
    Note: Parse a string interpolation expression (f"text {expr}")
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to interpolated string AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Get current token (should be f-string)
    Note: 2. Parse interpolation parts from string content
    Note: 3. Create interpolated string AST node
    Note: 4. Consume f-string token
    Note: 5. Return interpolated string AST node

    If parser is equal to 0:
        Return 0
    End If

    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token

    If token_type is not equal to TOKEN_F_STRING:
        proc parser_report_error from Parser with parser, "Expected f-string for string interpolation"
        Return 0
    End If

    Note: Parse interpolation parts from f-string content
    Let parts be proc parse_interpolation_parts with parser, current_token

    If parts is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to parse string interpolation parts"
        Return 0
    End If

    Note: Consume the f-string token
    proc parser_consume_token from Parser with parser

    Note: Build interpolated string AST node
    Let interp_node be proc build_interpolated_string from ASTBuilder with parts

    If interp_node is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create interpolated string AST node"
        Return 0
    End If

    Return interp_node
End Process

Process called "parse_interpolation_parts" takes parser as Integer, string_literal as Integer returns Integer:
    Note: Parse interpolation parts from string literal
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:   string_literal - Pointer to string literal token
    Note:
    Note: Returns:
    Note:   Pointer to List of interpolation parts
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Extract string content from token
    Note: 2. Scan for { and } patterns
    Note: 3. For each part:
    Note:    - If string part: create literal AST node
    Note:    - If {expr}: parse expression and create AST node
    Note: 4. Return parts List

    If parser is equal to 0:
        Return 0
    End If

    If string_literal is equal to 0:
        Return 0
    End If

    Note: Create list for interpolation parts
    Let parts be proc create_list from Layout
    If parts is equal to 0:
        Return 0
    End If

    Note: Get string content from token
    Let string_content be proc token_get_value from Parser with string_literal
    Let content_length be proc string_length from Layout with string_content

    Note: Scan string for interpolation expressions
    Let i be 0
    Let current_part_start be 0

    Loop:
        If i is greater than or equal to content_length:
            Break
        End If

        Note: Check for opening brace
        Let char be proc string_char_at from Layout with string_content, i

        If char is equal to 123:  Note: ASCII '{' = 123
            Note: Found interpolation start - save string part before it
            If i is greater than current_part_start:
                Let part_length be i minus current_part_start
                Let string_part be proc string_substring from Layout with string_content, current_part_start, part_length
                Let string_node be proc build_literal_node from ASTBuilder with TOKEN_STRING, string_part
                proc list_append from Layout with parts, string_node
            End If

            Note: Find matching closing brace
            Set i to i plus 1
            Let expr_start be i
            Let brace_depth be 1

            Loop:
                If i is greater than or equal to content_length:
                    Note: Unclosed interpolation expression
                    proc parser_report_error from Parser with parser, "Unclosed interpolation expression in f-string"
                    Return 0
                End If

                Set char to proc string_char_at from Layout with string_content, i

                If char is equal to 123:  Note: '{'
                    Set brace_depth to brace_depth plus 1
                End If

                If char is equal to 125:  Note: '}'
                    Set brace_depth to brace_depth minus 1
                    If brace_depth is equal to 0:
                        Break
                    End If
                End If

                Set i to i plus 1
            End Loop

            Note: Extract and parse expression
            Let expr_length be i minus expr_start
            Let expr_string be proc string_substring from Layout with string_content, expr_start, expr_length

            Note: Create temporary lexer/parser for expression
            Let expr_node be proc parse_expression_from_string from Parser with expr_string

            If expr_node is equal to 0:
                proc parser_report_error from Parser with parser, "Invalid expression in string interpolation"
                Return 0
            End If

            proc list_append from Layout with parts, expr_node

            Set i to i plus 1
            Set current_part_start to i
            Continue
        End If

        Set i to i plus 1
    End Loop

    Note: Add remaining string part if any
    If current_part_start is less than content_length:
        Let part_length be content_length minus current_part_start
        Let string_part be proc string_substring from Layout with string_content, current_part_start, part_length
        Let string_node be proc build_literal_node from ASTBuilder with TOKEN_STRING, string_part
        proc list_append from Layout with parts, string_node
    End If

    Return parts
End Process

Note: ============================================================================
Note: Range Expression Parsing
Note: ============================================================================

Process called "parse_range_expression" takes parser as Integer, start as Integer returns Integer:
    Note: Parse a range expression (start..end or start..=end)
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:   start - Pointer to start expression AST node
    Note:
    Note: Returns:
    Note:   Pointer to range expression AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Check current token for range operator (..)
    Note: 2. Consume range operator
    Note: 3. Check if inclusive (..=) or exclusive (..)
    Note: 4. Parse end expression
    Note: 5. Create range expression AST node
    Note: 6. Return range expression AST node

    If parser is equal to 0:
        Return 0
    End If

    If start is equal to 0:
        Return 0
    End If

    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token

    If token_type is not equal to TOKEN_RANGE:
        Note: Not a range expression, return start as-is
        Return start
    End If

    Note: Consume range operator
    proc parser_consume_token from Parser with parser

    Note: Check if inclusive range (..=) by checking for equals
    Set current_token to proc parser_current_token from Parser with parser
    Set token_type to proc token_get_type from Parser with current_token

    Let is_inclusive be 0
    If token_type is equal to TOKEN_EQUALS:
        Set is_inclusive to 1
        proc parser_consume_token from Parser with parser
    End If

    Note: Parse end expression
    Let end_expr be proc parse_expression with parser

    If end_expr is equal to 0:
        proc parser_report_error from Parser with parser, "Expected expression after range operator"
        Return 0
    End If

    Note: Build range expression AST node
    Let range_node be proc build_range_expression from ASTBuilder with start, end_expr, is_inclusive

    If range_node is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create range expression AST node"
        Return 0
    End If

    Return range_node
End Process

Note: ============================================================================
Note: Array and Tuple Literal Parsing
Note: ============================================================================

Process called "parse_array_literal" takes parser as Integer returns Integer:
    Note: Parse an array literal expression ([expr1, expr2, ...])
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to array literal AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume left bracket
    Note: 2. Parse element list:
    Note:    - If right bracket immediately: empty array
    Note:    - Otherwise: parse comma-separated expressions
    Note: 3. Expect and consume right bracket
    Note: 4. Create array literal AST node
    Note: 5. Return array literal AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: Expect and consume left bracket
    Let result be proc parser_expect_token from Parser with parser, TOKEN_LEFT_BRACKET
    If result is equal to 0:
        Return 0
    End If

    Note: Parse element list
    Let elements be proc parse_element_list with parser

    If elements is equal to 0:
        Note: Empty array is valid
        Set elements to proc create_list from Layout
    End If

    Note: Expect and consume right bracket
    Set result to proc parser_expect_token from Parser with parser, TOKEN_RIGHT_BRACKET
    If result is equal to 0:
        Return 0
    End If

    Note: Build array literal AST node
    Let array_node be proc build_array_literal from ASTBuilder with elements

    If array_node is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create array literal AST node"
        Return 0
    End If

    Return array_node
End Process

Process called "parse_tuple_literal" takes parser as Integer returns Integer:
    Note: Parse a tuple literal expression ((expr1, expr2, ...))
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to tuple literal AST node
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Expect and consume left parenthesis
    Note: 2. Parse element list:
    Note:    - If right parenthesis immediately: empty tuple
    Note:    - Otherwise: parse comma-separated expressions
    Note: 3. Expect and consume right parenthesis
    Note: 4. Create tuple literal AST node
    Note: 5. Return tuple literal AST node

    If parser is equal to 0:
        Return 0
    End If

    Note: Expect and consume left parenthesis
    Let result be proc parser_expect_token from Parser with parser, TOKEN_LEFT_PAREN
    If result is equal to 0:
        Return 0
    End If

    Note: Parse element list
    Let elements be proc parse_element_list with parser

    If elements is equal to 0:
        Note: Empty tuple is valid
        Set elements to proc create_list from Layout
    End If

    Note: Expect and consume right parenthesis
    Set result to proc parser_expect_token from Parser with parser, TOKEN_RIGHT_PAREN
    If result is equal to 0:
        Return 0
    End If

    Note: Build tuple literal AST node
    Let tuple_node be proc build_tuple_literal from ASTBuilder with elements

    If tuple_node is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create tuple literal AST node"
        Return 0
    End If

    Return tuple_node
End Process

Process called "parse_element_list" takes parser as Integer returns Integer:
    Note: Parse a comma-separated list of expressions
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Pointer to List of expression AST nodes
    Note:   Returns 0 on parsing error
    Note:
    Note: Algorithm:
    Note: 1. Create empty List for elements
    Note: 2. While not at closing delimiter:
    Note:    - Parse element expression using parse_expression
    Note:    - Add to elements List
    Note:    - If comma found: consume comma and continue
    Note:    - Otherwise: break
    Note: 3. Return elements List

    If parser is equal to 0:
        Return 0
    End If

    Note: Check if empty list (closing delimiter immediately)
    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be proc token_get_type from Parser with current_token

    Note: Check for closing delimiters (bracket or paren)
    If token_type is equal to TOKEN_RIGHT_BRACKET:
        Return proc create_list from Layout
    End If

    If token_type is equal to TOKEN_RIGHT_PAREN:
        Return proc create_list from Layout
    End If

    Note: Create list for elements
    Let elements be proc create_list from Layout
    If elements is equal to 0:
        proc parser_report_error from Parser with parser, "Failed to create element list"
        Return 0
    End If

    Note: Parse elements until closing delimiter
    Loop:
        Note: Parse element expression
        Let element be proc parse_expression with parser

        If element is equal to 0:
            proc parser_report_error from Parser with parser, "Expected expression in element list"
            Return 0
        End If

        Note: Add element to list
        proc list_append from Layout with elements, element

        Note: Check for comma (more elements) or closing delimiter (done)
        Set current_token to proc parser_current_token from Parser with parser
        Set token_type to proc token_get_type from Parser with current_token

        If token_type is equal to TOKEN_COMMA:
            Note: Consume comma and continue
            proc parser_consume_token from Parser with parser
            Continue
        End If

        Note: No comma, done with elements
        Break
    End Loop

    Return elements
End Process

Note: ============================================================================
Note: Expression Validation and Error Handling
Note: ============================================================================

Process called "validate_expression_syntax" takes expression as Integer returns Integer:
    Note: Validate that an expression is syntactically correct
    Note:
    Note: Parameters:
    Note:   expression - Pointer to expression AST node
    Note:
    Note: Returns:
    Note:   1 if expression is valid, 0 if invalid
    Note:
    Note: Validation checks:
    Note:   - Expression is not null
    Note:   - All child expressions are valid
    Note:   - Operator precedence is correct
    Note:   - Ternary operator has valid structure
    Note:   - String interpolation has valid parts

    Note: Check if expression is null
    If expression is equal to 0:
        Return 0
    End If

    Note: Get node type to determine validation strategy
    Let node_type be proc ast_node_get_type from AST with expression

    Note: Validate based on node type
    If node_type is equal to AST_NODE_LITERAL:
        Note: Literals are always valid if they exist
        Return 1
    End If

    If node_type is equal to AST_NODE_IDENTIFIER:
        Note: Identifiers are always valid if they exist
        Return 1
    End If

    If node_type is equal to AST_NODE_UNARY:
        Note: Validate unary expression - must have valid operand
        Let operand be proc ast_node_get_unary_operand from AST with expression
        If operand is equal to 0:
            Return 0
        End If

        Note: Recursively validate operand
        Let operand_valid be proc validate_expression_syntax with operand
        Return operand_valid
    End If

    If node_type is equal to AST_NODE_BINARY:
        Note: Validate binary expression - must have valid left and right operands
        Let left be proc ast_node_get_binary_left from AST with expression
        Let right be proc ast_node_get_binary_right from AST with expression

        If left is equal to 0:
            Return 0
        End If

        If right is equal to 0:
            Return 0
        End If

        Note: Recursively validate both operands
        Let left_valid be proc validate_expression_syntax with left
        If left_valid is equal to 0:
            Return 0
        End If

        Let right_valid be proc validate_expression_syntax with right
        Return right_valid
    End If

    If node_type is equal to AST_NODE_TERNARY:
        Note: Validate ternary expression - must have condition, true, and false branches
        Let condition be proc ast_node_get_ternary_condition from AST with expression
        Let true_expr be proc ast_node_get_ternary_true from AST with expression
        Let false_expr be proc ast_node_get_ternary_false from AST with expression

        If condition is equal to 0:
            Return 0
        End If

        If true_expr is equal to 0:
            Return 0
        End If

        If false_expr is equal to 0:
            Return 0
        End If

        Note: Recursively validate all three parts
        Let condition_valid be proc validate_expression_syntax with condition
        If condition_valid is equal to 0:
            Return 0
        End If

        Let true_valid be proc validate_expression_syntax with true_expr
        If true_valid is equal to 0:
            Return 0
        End If

        Let false_valid be proc validate_expression_syntax with false_expr
        Return false_valid
    End If

    If node_type is equal to AST_NODE_CALL:
        Note: Validate call expression - must have valid callee and arguments
        Let callee be proc ast_node_get_call_callee from AST with expression
        If callee is equal to 0:
            Return 0
        End If

        Note: Validate callee
        Let callee_valid be proc validate_expression_syntax with callee
        If callee_valid is equal to 0:
            Return 0
        End If

        Note: Validate all arguments
        Let arguments be proc ast_node_get_call_arguments from AST with expression
        If arguments is equal to 0:
            Return 1  Note: No arguments is valid
        End If

        Let arg_count be proc list_length from Layout with arguments
        Let i be 0

        Loop:
            If i is greater than or equal to arg_count:
                Break
            End If

            Let arg be proc list_get from Layout with arguments, i
            If arg is equal to 0:
                Return 0
            End If

            Let arg_valid be proc validate_expression_syntax with arg
            If arg_valid is equal to 0:
                Return 0
            End If

            Set i to i plus 1
        End Loop

        Return 1
    End If

    If node_type is equal to AST_NODE_MEMBER:
        Note: Validate member expression - must have valid object and property
        Let object be proc ast_node_get_member_object from AST with expression
        Let property be proc ast_node_get_member_property from AST with expression

        If object is equal to 0:
            Return 0
        End If

        If property is equal to 0:
            Return 0
        End If

        Note: Validate object (property should be identifier)
        Let object_valid be proc validate_expression_syntax with object
        Return object_valid
    End If

    If node_type is equal to AST_NODE_INDEX:
        Note: Validate index expression - must have valid object and index
        Let object be proc ast_node_get_index_object from AST with expression
        Let index be proc ast_node_get_index_index from AST with expression

        If object is equal to 0:
            Return 0
        End If

        If index is equal to 0:
            Return 0
        End If

        Note: Recursively validate both parts
        Let object_valid be proc validate_expression_syntax with object
        If object_valid is equal to 0:
            Return 0
        End If

        Let index_valid be proc validate_expression_syntax with index
        Return index_valid
    End If

    If node_type is equal to AST_NODE_ARRAY:
        Note: Validate array literal - must have valid elements
        Let elements be proc ast_node_get_array_elements from AST with expression
        If elements is equal to 0:
            Return 1  Note: Empty array is valid
        End If

        Let element_count be proc list_length from Layout with elements
        Let i be 0

        Loop:
            If i is greater than or equal to element_count:
                Break
            End If

            Let element be proc list_get from Layout with elements, i
            If element is equal to 0:
                Return 0
            End If

            Let element_valid be proc validate_expression_syntax with element
            If element_valid is equal to 0:
                Return 0
            End If

            Set i to i plus 1
        End Loop

        Return 1
    End If

    If node_type is equal to AST_NODE_TUPLE:
        Note: Validate tuple literal - must have valid elements
        Let elements be proc ast_node_get_tuple_elements from AST with expression
        If elements is equal to 0:
            Return 0  Note: Empty tuple is invalid
        End If

        Let element_count be proc list_length from Layout with elements

        Note: Tuple must have at least 2 elements
        If element_count is less than 2:
            Return 0
        End If

        Let i be 0

        Loop:
            If i is greater than or equal to element_count:
                Break
            End If

            Let element be proc list_get from Layout with elements, i
            If element is equal to 0:
                Return 0
            End If

            Let element_valid be proc validate_expression_syntax with element
            If element_valid is equal to 0:
                Return 0
            End If

            Set i to i plus 1
        End Loop

        Return 1
    End If

    If node_type is equal to AST_NODE_RANGE:
        Note: Validate range expression - must have valid start and end
        Let start be proc ast_node_get_range_start from AST with expression
        Let end be proc ast_node_get_range_end from AST with expression

        If start is equal to 0:
            Return 0
        End If

        If end is equal to 0:
            Return 0
        End If

        Note: Recursively validate both parts
        Let start_valid be proc validate_expression_syntax with start
        If start_valid is equal to 0:
            Return 0
        End If

        Let end_valid be proc validate_expression_syntax with end
        Return end_valid
    End If

    If node_type is equal to AST_NODE_STRING_INTERPOLATION:
        Note: Validate string interpolation - must have valid parts
        Let parts be proc ast_node_get_interpolation_parts from AST with expression
        If parts is equal to 0:
            Return 0
        End If

        Let part_count be proc list_length from Layout with parts

        Note: Must have at least one part
        If part_count is equal to 0:
            Return 0
        End If

        Let i be 0

        Loop:
            If i is greater than or equal to part_count:
                Break
            End If

            Let part be proc list_get from Layout with parts, i
            If part is equal to 0:
                Return 0
            End If

            Let part_valid be proc validate_expression_syntax with part
            If part_valid is equal to 0:
                Return 0
            End If

            Set i to i plus 1
        End Loop

        Return 1
    End If

    Note: Unknown node type - invalid
    Return 0
End Process

Process called "detect_expression_error" takes parser as Integer returns Integer:
    Note: Detect syntax errors in expression parsing
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:
    Note: Returns:
    Note:   Error type constant if error detected, 0 if no error
    Note:
    Note: Error types:
    Note:   - EXPRESSION_ERROR_MISSING_OPERAND: Missing operand for operator (1)
    Note:   - EXPRESSION_ERROR_INVALID_OPERATOR: Invalid operator in context (2)
    Note:   - EXPRESSION_ERROR_MALFORMED_TERNARY: Malformed ternary operator (3)
    Note:   - EXPRESSION_ERROR_INVALID_INTERPOLATION: Invalid string interpolation (4)
    Note:   - EXPRESSION_ERROR_UNEXPECTED_TOKEN: Unexpected token in expression (5)
    Note:   - EXPRESSION_ERROR_MISSING_CLOSING: Missing closing delimiter (6)

    If parser is equal to 0:
        Return 0
    End If

    Note: Get current token for analysis
    Let current_token be proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Return 0  Note: No token, no error to detect
    End If

    Let token_type be proc token_get_type from Parser with current_token

    Note: Check for binary operator without left operand (at start of expression)
    Let is_binary be proc is_binary_operator from Operators with token_type
    If is_binary is equal to 1:
        Note: Check if this is the start of expression (no left operand)
        Let parse_depth be proc parser_get_depth from Parser with parser
        If parse_depth is equal to 0:
            Return 1  Note: EXPRESSION_ERROR_MISSING_OPERAND
        End If
    End If

    Note: Check for ternary operator without condition
    If token_type is equal to TOKEN_QUESTION_MARK:
        Let parse_depth be proc parser_get_depth from Parser with parser
        If parse_depth is equal to 0:
            Return 1  Note: EXPRESSION_ERROR_MISSING_OPERAND
        End If

        Note: Check if we can find matching colon
        Let saved_position be proc parser_save_position from Parser with parser
        Let found_colon be 0
        Let depth be 0

        Loop:
            proc parser_advance from Parser with parser
            Let next_token be proc parser_current_token from Parser with parser
            If next_token is equal to 0:
                Break
            End If

            Let next_type be proc token_get_type from Parser with next_token

            Note: Track nesting depth for nested ternaries
            If next_type is equal to TOKEN_QUESTION_MARK:
                Set depth to depth plus 1
            End If

            If next_type is equal to TOKEN_COLON:
                If depth is equal to 0:
                    Set found_colon to 1
                    Break
                Otherwise:
                    Set depth to depth minus 1
                End If
            End If

            Note: Stop at statement terminators
            If next_type is equal to TOKEN_SEMICOLON:
                Break
            End If

            If next_type is equal to TOKEN_NEWLINE:
                Break
            End If

            If next_type is equal to TOKEN_EOF:
                Break
            End If
        End Loop

        Note: Restore parser position
        proc parser_restore_position from Parser with parser, saved_position

        If found_colon is equal to 0:
            Return 3  Note: EXPRESSION_ERROR_MALFORMED_TERNARY
        End If
    End If

    Note: Check for colon without matching question mark (orphaned ternary)
    If token_type is equal to TOKEN_COLON:
        Note: Colon in expression context without ? is malformed ternary
        Note: Unless it's in a match/when statement (checked by caller)
        Return 3  Note: EXPRESSION_ERROR_MALFORMED_TERNARY
    End If

    Note: Check for invalid operators in primary expression context
    If token_type is equal to TOKEN_COMMA:
        Note: Comma outside of argument/element list is invalid
        Let context be proc parser_get_context from Parser with parser
        Note: Context should be CONTEXT_ARGUMENT_LIST or CONTEXT_ELEMENT_LIST
        If context is not equal to CONTEXT_ARGUMENT_LIST:
            If context is not equal to CONTEXT_ELEMENT_LIST:
                Return 2  Note: EXPRESSION_ERROR_INVALID_OPERATOR
            End If
        End If
    End If

    Note: Check for unclosed delimiters
    If token_type is equal to TOKEN_EOF:
        Note: Check if we have open delimiters
        Let paren_depth be proc parser_get_paren_depth from Parser with parser
        If paren_depth is greater than 0:
            Return 6  Note: EXPRESSION_ERROR_MISSING_CLOSING
        End If

        Let bracket_depth be proc parser_get_bracket_depth from Parser with parser
        If bracket_depth is greater than 0:
            Return 6  Note: EXPRESSION_ERROR_MISSING_CLOSING
        End If

        Let brace_depth be proc parser_get_brace_depth from Parser with parser
        If brace_depth is greater than 0:
            Return 6  Note: EXPRESSION_ERROR_MISSING_CLOSING
        End If
    End If

    Note: Check for string interpolation errors
    If token_type is equal to TOKEN_STRING_INTERPOLATED:
        Let token_value be proc token_get_value from Parser with current_token
        Let value_length be proc string_length from Layout with token_value

        Note: Check for unmatched braces in interpolation
        Let i be 0
        Let brace_count be 0

        Loop:
            If i is greater than or equal to value_length:
                Break
            End If

            Let char be proc string_char_at from Layout with token_value, i

            If char is equal to 123:  Note: '{'
                Set brace_count to brace_count plus 1
            End If

            If char is equal to 125:  Note: '}'
                Set brace_count to brace_count minus 1

                Note: More closing than opening braces
                If brace_count is less than 0:
                    Return 4  Note: EXPRESSION_ERROR_INVALID_INTERPOLATION
                End If
            End If

            Set i to i plus 1
        End Loop

        Note: Unclosed braces
        If brace_count is not equal to 0:
            Return 4  Note: EXPRESSION_ERROR_INVALID_INTERPOLATION
        End If
    End If

    Note: Check for unexpected tokens in expression
    If token_type is equal to TOKEN_SEMICOLON:
        Note: Semicolon in middle of expression is unexpected
        Let parse_depth be proc parser_get_depth from Parser with parser
        If parse_depth is greater than 0:
            Return 5  Note: EXPRESSION_ERROR_UNEXPECTED_TOKEN
        End If
    End If

    Note: Check for consecutive operators without operand between them
    Let previous_token be proc parser_previous_token from Parser with parser
    If previous_token is not equal to 0:
        Let prev_type be proc token_get_type from Parser with previous_token
        Let prev_is_binary be proc is_binary_operator from Operators with prev_type

        If prev_is_binary is equal to 1:
            If is_binary is equal to 1:
                Note: Two binary operators in a row without operand
                Return 1  Note: EXPRESSION_ERROR_MISSING_OPERAND
            End If
        End If
    End If

    Note: No error detected
    Return 0
End Process

Process called "suggest_expression_fix" takes parser as Integer, error_type as Integer returns Integer:
    Note: Suggest fix for expression syntax errors
    Note:
    Note: Parameters:
    Note:   parser - Pointer to ParserState
    Note:   error_type - Error type constant
    Note:
    Note: Returns:
    Note:   Pointer to suggestion string
    Note:   Returns 0 if no suggestion available
    Note:
    Note: Suggestions:
    Note:   - Add missing operands
    Note:   - Fix operator precedence with parentheses
    Note:   - Complete ternary operator structure
    Note:   - Fix string interpolation syntax

    If parser is equal to 0:
        Return 0
    End If

    Note: Get current token for context
    Let current_token be proc parser_current_token from Parser with parser
    Let token_type be 0
    Let token_value be 0

    If current_token is not equal to 0:
        Set token_type to proc token_get_type from Parser with current_token
        Set token_value to proc token_get_value from Parser with current_token
    End If

    Note: Generate suggestion based on error type
    If error_type is equal to 1:
        Note: EXPRESSION_ERROR_MISSING_OPERAND
        Note: Check if this is a binary operator missing operand
        Let is_binary be proc is_binary_operator from Operators with token_type

        If is_binary is equal to 1:
            Note: Binary operator needs both operands
            Let operator_name be proc token_type_to_string from Parser with token_type
            Let suggestion be proc string_concat from Layout with "Binary operator '", operator_name
            Set suggestion to proc string_concat from Layout with suggestion, "' requires operands on both sides. Add an expression before and after the operator."
            Return suggestion
        End If

        If token_type is equal to TOKEN_QUESTION_MARK:
            Note: Ternary needs condition
            Return proc string_from_literal from Layout with "Ternary operator '?' requires a condition expression before it. Example: condition ? true_value : false_value"
        End If

        Note: Generic missing operand
        Return proc string_from_literal from Layout with "Operator requires an operand. Add an expression before or after the operator."
    End If

    If error_type is equal to 2:
        Note: EXPRESSION_ERROR_INVALID_OPERATOR
        Note: Provide context-specific suggestion
        If token_type is equal to TOKEN_COMMA:
            Return proc string_from_literal from Layout with "Comma ',' is only valid inside function calls, array literals, or tuple literals. Wrap elements in brackets [] or parentheses ()."
        End If

        Let operator_name be proc token_type_to_string from Parser with token_type
        Let suggestion be proc string_concat from Layout with "Operator '", operator_name
        Set suggestion to proc string_concat from Layout with suggestion, "' is not valid in this context. Check the surrounding expression structure."
        Return suggestion
    End If

    If error_type is equal to 3:
        Note: EXPRESSION_ERROR_MALFORMED_TERNARY
        If token_type is equal to TOKEN_QUESTION_MARK:
            Return proc string_from_literal from Layout with "Ternary operator is incomplete. Expected format: condition ? true_value : false_value. Add the ':' and false value."
        End If

        If token_type is equal to TOKEN_COLON:
            Return proc string_from_literal from Layout with "Found ':' without matching '?'. Ternary operator requires: condition ? true_value : false_value. Add the '?' and condition."
        End If

        Return proc string_from_literal from Layout with "Malformed ternary operator. Expected format: condition ? true_value : false_value"
    End If

    If error_type is equal to 4:
        Note: EXPRESSION_ERROR_INVALID_INTERPOLATION
        Note: Analyze the interpolation string for specific issues
        If token_value is not equal to 0:
            Let value_length be proc string_length from Layout with token_value
            Let i be 0
            Let open_braces be 0
            Let close_braces be 0

            Loop:
                If i is greater than or equal to value_length:
                    Break
                End If

                Let char be proc string_char_at from Layout with token_value, i

                If char is equal to 123:
                    Set open_braces to open_braces plus 1
                End If

                If char is equal to 125:
                    Set close_braces to close_braces plus 1
                End If

                Set i to i plus 1
            End Loop

            If open_braces is greater than close_braces:
                Return proc string_from_literal from Layout with "String interpolation has unclosed braces. Each '{' must have a matching '}'. Example: f\"Hello {name}\""
            End If

            If close_braces is greater than open_braces:
                Return proc string_from_literal from Layout with "String interpolation has extra closing braces. Each '}' must match an opening '{'. Example: f\"Hello {name}\""
            End If
        End If

        Return proc string_from_literal from Layout with "Invalid string interpolation syntax. Use f\"text {expression}\" format with matched braces."
    End If

    If error_type is equal to 5:
        Note: EXPRESSION_ERROR_UNEXPECTED_TOKEN
        Let token_name be proc token_type_to_string from Parser with token_type
        Let suggestion be proc string_concat from Layout with "Unexpected token '", token_name
        Set suggestion to proc string_concat from Layout with suggestion, "' in expression. This token cannot appear here. Check for missing operators or delimiters."
        Return suggestion
    End If

    If error_type is equal to 6:
        Note: EXPRESSION_ERROR_MISSING_CLOSING
        Note: Check which delimiter is unclosed
        Let paren_depth be proc parser_get_paren_depth from Parser with parser
        If paren_depth is greater than 0:
            Let suggestion be proc string_from_literal from Layout with "Missing closing parenthesis ')'. Found "
            Let depth_str be proc integer_to_string from Layout with paren_depth
            Set suggestion to proc string_concat from Layout with suggestion, depth_str
            Set suggestion to proc string_concat from Layout with suggestion, " unclosed '(' in expression."
            Return suggestion
        End If

        Let bracket_depth be proc parser_get_bracket_depth from Parser with parser
        If bracket_depth is greater than 0:
            Let suggestion be proc string_from_literal from Layout with "Missing closing bracket ']'. Found "
            Let depth_str be proc integer_to_string from Layout with bracket_depth
            Set suggestion to proc string_concat from Layout with suggestion, depth_str
            Set suggestion to proc string_concat from Layout with suggestion, " unclosed '[' in expression."
            Return suggestion
        End If

        Let brace_depth be proc parser_get_brace_depth from Parser with parser
        If brace_depth is greater than 0:
            Let suggestion be proc string_from_literal from Layout with "Missing closing brace '}'. Found "
            Let depth_str be proc integer_to_string from Layout with brace_depth
            Set suggestion to proc string_concat from Layout with suggestion, depth_str
            Set suggestion to proc string_concat from Layout with suggestion, " unclosed '{' in expression."
            Return suggestion
        End If

        Return proc string_from_literal from Layout with "Missing closing delimiter. Check for unclosed parentheses, brackets, or braces."
    End If

    Note: Unknown error type - no specific suggestion
    Return 0
End Process