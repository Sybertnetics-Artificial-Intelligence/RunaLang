Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file implements macro expansion for Runa language.

This file performs the following tasks:
- Handle macro definitions and expansions
- Support hygienic macro system
- Process macro invocations and arguments
- Validate macro hygiene and scope
- Integrate macro expansion with parsing pipeline

This file is essential because of the following reasons:
- Macro expansion enables powerful metaprogramming capabilities
- Hygienic macros prevent variable capture issues
- Macro system supports code generation and transformation
- Integration with parsing pipeline ensures correct expansion order
- Macro validation prevents common macro errors

This file consists of the following functions/features/operation types:
- Macro definition parsing and validation
- Macro invocation processing and expansion
- Hygienic macro system implementation
- Macro scope and hygiene validation
- Integration with parsing pipeline

Dependencies:
- Imports parser.runa for parser state and token navigation
- Imports ast.runa for AST node creation and manipulation
- Imports ast_builder.runa for AST construction
- Imports lexical components for token recognition
- Imports memory/layout.runa for structure allocation
:End Note

Import "compiler/frontend/parsing/parser.runa" as Parser
Import "compiler/frontend/parsing/ast.runa" as AST
Import "compiler/frontend/parsing/ast_builder.runa" as ASTBuilder
Import "compiler/frontend/lexical/keywords.runa" as Keywords
Import "compiler/frontend/lexical/operators.runa" as Operators
Import "compiler/frontend/lexical/delimiters.runa" as Delimiters
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/primitives/collections/list.runa" as List
Import "compiler/frontend/primitives/collections/dictionary.runa" as Dictionary
Import "compiler/frontend/primitives/collections/hashtable.runa" as HashTable
Import "compiler/frontend/primitives/collections/stack.runa" as Stack
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore

Note: ============================================================================
Note: Macro System Constants
Note: ============================================================================

Note: Macro type constants
Constant MACRO_FUNCTION as Integer is 1          Note: Function-like macro
Constant MACRO_OBJECT as Integer is 2             Note: Object-like macro
Constant MACRO_PROCEDURAL as Integer is 3         Note: Procedural macro
Constant MACRO_DECLARATIVE as Integer is 4        Note: Declarative macro
Constant MACRO_ATTRIBUTE as Integer is 5          Note: Attribute macro

Note: Macro hygiene constants
Constant HYGIENE_SAFE as Integer is 1             Note: Hygienic macro
Constant HYGIENE_UNSAFE as Integer is 0          Note: Non-hygienic macro
Constant HYGIENE_PARTIAL as Integer is -1        Note: Partially hygienic macro

Note: Macro expansion constants
Constant EXPANSION_SUCCESS as Integer is 1        Note: Expansion successful
Constant EXPANSION_FAILED as Integer is 0         Note: Expansion failed
Constant EXPANSION_PARTIAL as Integer is -1       Note: Partial expansion

Note: Token type constants (from lexical modules)
Constant TOKEN_LEFT_PAREN as Integer is 200       Note: ( delimiter
Constant TOKEN_RIGHT_PAREN as Integer is 201      Note: ) delimiter
Constant TOKEN_END as Integer is 430              Note: End keyword
Constant TOKEN_MACRO as Integer is 325            Note: Macro keyword

Note: ============================================================================
Note: Macro System Structures
Note: ============================================================================

Type called "MacroDefinition":
    name as Integer             Note: Pointer to macro name string
    macro_type as Integer       Note: Macro type constant
    parameters as Integer       Note: Pointer to List of parameter AST nodes
    parameter_count as Integer  Note: Number of parameters
    body as Integer            Note: Pointer to macro body AST node
    hygiene_level as Integer   Note: Hygiene level constant
    scope as Integer           Note: Pointer to macro scope
    line as Integer           Note: Line number where macro defined
    column as Integer         Note: Column number where macro defined

Type called "MacroInvocation":
    name as Integer            Note: Pointer to macro name string
    arguments as Integer       Note: Pointer to List of argument AST nodes
    argument_count as Integer  Note: Number of arguments
    expansion_site as Integer  Note: Pointer to expansion site AST node
    hygiene_context as Integer Note: Pointer to hygiene context
    line as Integer           Note: Line number where macro invoked
    column as Integer         Note: Column number where macro invoked

Type called "MacroExpansion":
    original_invocation as Integer Note: Pointer to original invocation
    expanded_code as Integer   Note: Pointer to expanded code AST node
    hygiene_map as Integer     Note: Pointer to hygiene mapping
    expansion_depth as Integer Note: Current expansion depth
    is_complete as Integer     Note: Boolean: 1 if expansion complete

Type called "HygieneContext":
    variable_map as Integer    Note: Pointer to variable mapping
    scope_stack as Integer     Note: Pointer to scope stack
    hygiene_level as Integer   Note: Current hygiene level
    is_safe as Integer         Note: Boolean: 1 if context is safe

Note: ============================================================================
Note: Macro Definition Parsing
Note: ============================================================================

Process called "parse_macro_definition" takes parser as Integer returns Integer:
    Note:
    Parse a macro definition

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to MacroDefinition structure
      Returns 0 on parsing error

    Macro definition syntax:
      - Macro macro_name(params): body End Macro
      - Macro macro_name(params) hygienic: body End Macro
      - Macro macro_name(params) unsafe: body End Macro
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Get current token for location info
    Let current_token be proc parser_current_token from Parser with parser
    Let line be 0
    Let column be 0

    If current_token is not equal to 0:
        Set line to proc memory_get_qword from Layout with current_token, 8
        Set column to proc memory_get_qword from Layout with current_token, 16
    End If

    Note: Expect Macro keyword (consume it via parser)
    proc parser_consume_token from Parser with parser

    Note: Parse macro name
    Set current_token to proc parser_current_token from Parser with parser

    If current_token is equal to 0:
        Return 0
    End If

    Let macro_name be proc memory_get_qword from Layout with current_token, 24

    If macro_name is equal to 0:
        Return 0
    End If

    proc parser_consume_token from Parser with parser

    Note: Parse parameter list
    Let parameters be proc parse_macro_parameter_list with parser
    Let param_count be 0

    If parameters is not equal to 0:
        Set param_count to proc size from List with parameters
    End If

    Note: Parse optional hygiene specifier
    Let hygiene_level be proc parse_hygiene_specifier with parser

    Note: Parse macro body
    Let body be proc parse_macro_body with parser

    If body is equal to 0:
        Return 0
    End If

    Note: Expect End Macro keywords
    Let current_token be proc parser_current_token from Parser with parser

    If current_token is equal to 0:
        Return 0  Note: Missing End keyword
    End If

    Let token_type be proc memory_get_qword from Layout with current_token, 0

    If token_type is not equal to TOKEN_END:
        Return 0  Note: Expected End keyword
    End If

    proc parser_consume_token from Parser with parser

    Note: Now expect Macro keyword
    Set current_token to proc parser_current_token from Parser with parser

    If current_token is equal to 0:
        Return 0  Note: Missing Macro keyword after End
    End If

    Set token_type to proc memory_get_qword from Layout with current_token, 0

    If token_type is not equal to TOKEN_MACRO:
        Return 0  Note: Expected Macro keyword after End
    End If

    proc parser_consume_token from Parser with parser

    Note: Allocate MacroDefinition structure (9 fields Ã— 8 bytes = 72 bytes)
    Let macro_def be proc allocate from Layout with 72

    If macro_def is equal to 0:
        Return 0
    End If

    Note: name (offset 0)
    proc memory_set_qword from Layout with macro_def, 0, macro_name

    Note: macro_type = MACRO_FUNCTION (offset 8)
    proc memory_set_qword from Layout with macro_def, 8, MACRO_FUNCTION

    Note: parameters (offset 16)
    proc memory_set_qword from Layout with macro_def, 16, parameters

    Note: parameter_count (offset 24)
    proc memory_set_qword from Layout with macro_def, 24, param_count

    Note: body (offset 32)
    proc memory_set_qword from Layout with macro_def, 32, body

    Note: hygiene_level (offset 40)
    proc memory_set_qword from Layout with macro_def, 40, hygiene_level

    Note: scope = 0 (offset 48)
    proc memory_set_qword from Layout with macro_def, 48, 0

    Note: line (offset 56)
    proc memory_set_qword from Layout with macro_def, 56, line

    Note: column (offset 64)
    proc memory_set_qword from Layout with macro_def, 64, column

    Return macro_def
End Process

Process called "parse_macro_parameter_list" takes parser as Integer returns Integer:
    Note:
    Parse macro parameter list

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to List of parameter names
      Returns 0 on parsing error

    Parameter list syntax:
      - (param1, param2, param3)
      - () for parameterless macros
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Expect left parenthesis
    Let current_token be proc parser_current_token from Parser with parser

    If current_token is equal to 0:
        Return 0
    End If

    Let token_type be proc memory_get_qword from Layout with current_token, 0

    If token_type is not equal to TOKEN_LEFT_PAREN:
        Return 0
    End If

    proc parser_consume_token from Parser with parser

    Note: Create parameters list
    Let parameters be proc create from List

    Note: Check for immediate right parenthesis (empty parameters)
    Set current_token to proc parser_current_token from Parser with parser

    If current_token is not equal to 0:
        Set token_type to proc memory_get_qword from Layout with current_token, 0

        If token_type is equal to TOKEN_RIGHT_PAREN:
            proc parser_consume_token from Parser with parser
            Return parameters  Note: Empty list
        End If
    End If

    Note: Parse comma-separated parameters
    Loop forever:
        Set current_token to proc parser_current_token from Parser with parser

        If current_token is equal to 0:
            Break
        End If

        Set token_type to proc memory_get_qword from Layout with current_token, 0

        Note: IDENTIFIER token type = 1000
        If token_type is not equal to 1000:
            Break
        End If

        Let param_name be proc memory_get_qword from Layout with current_token, 24

        proc append from List with parameters, param_name

        proc parser_consume_token from Parser with parser

        Note: Check for comma or right parenthesis
        Set current_token to proc parser_current_token from Parser with parser

        If current_token is equal to 0:
            Break
        End If

        Set token_type to proc memory_get_qword from Layout with current_token, 0

        Note: COMMA token type = 2012
        If token_type is equal to 2012:
            proc parser_consume_token from Parser with parser
        Otherwise:
            Break
        End If
    End Loop

    Note: Expect right parenthesis
    Set current_token to proc parser_current_token from Parser with parser

    If current_token is not equal to 0:
        Set token_type to proc memory_get_qword from Layout with current_token, 0

        Note: RIGHT_PAREN token type = 2009
        If token_type is equal to 2009:
            proc parser_consume_token from Parser with parser
        End If
    End If

    Return parameters
End Process

Process called "parse_hygiene_specifier" takes parser as Integer returns Integer:
    Note:
    Parse hygiene specifier for macro

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Hygiene level constant
      Returns HYGIENE_SAFE if no specifier (default)

    Hygiene specifiers:
      - hygienic: HYGIENE_SAFE
      - unsafe: HYGIENE_UNSAFE
      - partial: HYGIENE_PARTIAL
    :End Note

    If parser is equal to 0:
        Return HYGIENE_SAFE
    End If

    Let current_token be proc parser_current_token from Parser with parser

    If current_token is equal to 0:
        Return HYGIENE_SAFE
    End If

    Let token_value be proc memory_get_qword from Layout with current_token, 24

    If token_value is equal to 0:
        Return HYGIENE_SAFE
    End If

    Let is_hygienic be proc string_equals from StringCore with token_value, proc string_create from StringCore with "hygienic"
    If is_hygienic is equal to 1:
        proc parser_consume_token from Parser with parser
        Return HYGIENE_SAFE
    End If

    Let is_unsafe be proc string_equals from StringCore with token_value, proc string_create from StringCore with "unsafe"
    If is_unsafe is equal to 1:
        proc parser_consume_token from Parser with parser
        Return HYGIENE_UNSAFE
    End If

    Let is_partial be proc string_equals from StringCore with token_value, proc string_create from StringCore with "partial"
    If is_partial is equal to 1:
        proc parser_consume_token from Parser with parser
        Return HYGIENE_PARTIAL
    End If

    Return HYGIENE_SAFE
End Process

Process called "parse_macro_body" takes parser as Integer returns Integer:
    Note:
    Parse macro body

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to macro body AST node
      Returns 0 on parsing error

    Macro body can contain:
      - Statements and expressions
      - Macro invocations
      - Template variables
      - Control flow constructs
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Expect colon before body
    Let current_token be proc parser_current_token from Parser with parser

    If current_token is not equal to 0:
        Let token_type be proc memory_get_qword from Layout with current_token, 0

        Note: COLON token type = 2010
        If token_type is equal to 2010:
            proc parser_consume_token from Parser with parser
        End If
    End If

    Note: Create body AST node (MACRO_BODY = 8001)
    Let body_node be proc create_ast_node from AST with 8001

    If body_node is equal to 0:
        Return 0
    End If

    Note: Parse body statements until End Macro
    Let statements be proc create from List

    Loop forever:
        Set current_token to proc parser_current_token from Parser with parser

        If current_token is equal to 0:
            Break
        End If

        Let token_value be proc memory_get_qword from Layout with current_token, 24

        If token_value is not equal to 0:
            Let is_end be proc string_equals from StringCore with token_value, proc string_create from StringCore with "End"

            If is_end is equal to 1:
                Break  Note: End of macro body
            End If
        End If

        Note: Parse statement using statement parser
        Let stmt_node be proc parse_single_statement from Parser with parser

        If stmt_node is not equal to 0:
            proc append from List with statements, stmt_node
        Otherwise:
            Note: Statement parsing failed - skip to next statement
            proc parser_skip_to_next_statement from Parser with parser
        End If
    End Loop

    Note: Attach statements to body node
    proc ast_node_set_children from AST with body_node, statements

    Return body_node
End Process

Note: ============================================================================
Note: Macro Invocation Parsing
Note: ============================================================================

Process called "parse_macro_invocation" takes parser as Integer returns Integer:
    Note:
    Parse a macro invocation

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to MacroInvocation structure
      Returns 0 on parsing error

    Macro invocation syntax:
      - macro_name(arg1, arg2, arg3)
      - macro_name for object-like macros
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Let current_token be proc parser_current_token from Parser with parser

    If current_token is equal to 0:
        Return 0
    End If

    Let line be proc memory_get_qword from Layout with current_token, 8
    Let column be proc memory_get_qword from Layout with current_token, 16
    Let macro_name be proc memory_get_qword from Layout with current_token, 24

    If macro_name is equal to 0:
        Return 0
    End If

    proc parser_consume_token from Parser with parser

    Note: Check for left parenthesis (function-like macro)
    Set current_token to proc parser_current_token from Parser with parser
    Let arguments be 0
    Let arg_count be 0

    If current_token is not equal to 0:
        Let token_type be proc memory_get_qword from Layout with current_token, 0

        Note: LEFT_PAREN = 2008
        If token_type is equal to 2008:
            Set arguments to proc parse_macro_arguments with parser

            If arguments is not equal to 0:
                Set arg_count to proc size from List with arguments
            End If
        End If
    End If

    Note: Allocate MacroInvocation structure (7 fields Ã— 8 bytes = 56 bytes)
    Let invocation be proc allocate from Layout with 56

    If invocation is equal to 0:
        Return 0
    End If

    Note: name (offset 0)
    proc memory_set_qword from Layout with invocation, 0, macro_name

    Note: arguments (offset 8)
    proc memory_set_qword from Layout with invocation, 8, arguments

    Note: argument_count (offset 16)
    proc memory_set_qword from Layout with invocation, 16, arg_count

    Note: expansion_site = 0 (offset 24)
    proc memory_set_qword from Layout with invocation, 24, 0

    Note: hygiene_context = 0 (offset 32)
    proc memory_set_qword from Layout with invocation, 32, 0

    Note: line (offset 40)
    proc memory_set_qword from Layout with invocation, 40, line

    Note: column (offset 48)
    proc memory_set_qword from Layout with invocation, 48, column

    Return invocation
End Process

Process called "parse_macro_arguments" takes parser as Integer returns Integer:
    Note:
    Parse macro arguments

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to List of argument AST nodes
      Returns 0 on parsing error

    Argument syntax:
      - (arg1, arg2, arg3)
      - () for argumentless invocations
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Let current_token be proc parser_current_token from Parser with parser

    If current_token is equal to 0:
        Return 0
    End If

    Let token_type be proc memory_get_qword from Layout with current_token, 0

    Note: LEFT_PAREN = 2008
    If token_type is not equal to 2008:
        Return 0
    End If

    proc parser_consume_token from Parser with parser

    Let arguments be proc create from List

    Note: Check for immediate right parenthesis
    Set current_token to proc parser_current_token from Parser with parser

    If current_token is not equal to 0:
        Set token_type to proc memory_get_qword from Layout with current_token, 0

        Note: RIGHT_PAREN = 2009
        If token_type is equal to 2009:
            proc parser_consume_token from Parser with parser
            Return arguments
        End If
    End If

    Note: Parse comma-separated arguments
    Loop forever:
        Set current_token to proc parser_current_token from Parser with parser

        If current_token is equal to 0:
            Break
        End If

        Note: Parse argument expression
        Let arg_node be proc parse_expression from Parser with parser

        If arg_node is not equal to 0:
            proc append from List with arguments, arg_node
        Otherwise:
            Note: Failed to parse argument
            proc parser_report_error from Parser with parser, "Expected expression for macro argument"
            Break
        End If

        Set current_token to proc parser_current_token from Parser with parser

        If current_token is equal to 0:
            Break
        End If

        Set token_type to proc memory_get_qword from Layout with current_token, 0

        Note: COMMA = 2012
        If token_type is equal to 2012:
            proc parser_consume_token from Parser with parser
        Otherwise:
            Break
        End If
    End Loop

    Note: Expect right parenthesis
    Set current_token to proc parser_current_token from Parser with parser

    If current_token is not equal to 0:
        Set token_type to proc memory_get_qword from Layout with current_token, 0

        If token_type is equal to 2009:
            proc parser_consume_token from Parser with parser
        End If
    End If

    Return arguments
End Process

Note: ============================================================================
Note: Macro Expansion
Note: ============================================================================

Process called "expand_macro" takes parser as Integer, macro as Integer, arguments as Integer returns Integer:
    Note:
    Expand a macro invocation

    Parameters:
      parser - Pointer to ParserState
      macro - Pointer to MacroDefinition structure
      arguments - Pointer to List of argument AST nodes

    Returns:
      Pointer to expanded code AST node
      Returns 0 on expansion failure

    Expansion algorithm:
    1. Validate macro and arguments
    2. Create hygiene context
    3. Substitute arguments in macro body
    4. Apply hygiene transformations
    5. Return expanded code AST node
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    If macro is equal to 0:
        Return 0
    End If

    Note: Validate expansion
    Let is_valid be proc validate_macro_expansion with parser, macro, arguments

    If is_valid is equal to 0:
        Return 0
    End If

    Note: Create hygiene context
    Let hygiene_context be proc create_hygiene_context with parser, macro

    If hygiene_context is equal to 0:
        Return 0
    End If

    Note: Get macro body
    Let macro_body be proc memory_get_qword from Layout with macro, 32

    If macro_body is equal to 0:
        Return 0
    End If

    Note: Substitute arguments in macro body
    Let substituted_body be proc substitute_arguments with macro_body, arguments, hygiene_context

    If substituted_body is equal to 0:
        Return 0
    End If

    Note: Apply hygiene transformations
    Let transformed_body be proc apply_hygiene_transformations with substituted_body, hygiene_context

    If transformed_body is equal to 0:
        Return 0
    End If

    Return transformed_body
End Process

Process called "validate_macro_expansion" takes parser as Integer, macro as Integer, arguments as Integer returns Integer:
    Note:
    Validate macro expansion parameters

    Parameters:
      parser - Pointer to ParserState
      macro - Pointer to MacroDefinition structure
      arguments - Pointer to List of argument AST nodes

    Returns:
      1 if expansion is valid, 0 if invalid

    Validation checks:
      - Macro exists
      - Argument count matches parameter count
      - Expansion depth is within limits
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    If macro is equal to 0:
        Return 0
    End If

    Note: Get parameter count from macro
    Let param_count be proc memory_get_qword from Layout with macro, 24

    Note: Get argument count
    Let arg_count be 0

    If arguments is not equal to 0:
        Set arg_count to proc size from List with arguments
    End If

    Note: Validate argument count matches parameter count
    If arg_count is not equal to param_count:
        Return 0
    End If

    Note: Check expansion depth
    Let depth be proc get_macro_expansion_depth with parser

    If depth is greater than 100:
        Return 0  Note: Maximum depth exceeded
    End If

    Return 1
End Process

Process called "create_hygiene_context" takes parser as Integer, macro as Integer returns Integer:
    Note:
    Create hygiene context for macro expansion

    Parameters:
      parser - Pointer to ParserState
      macro - Pointer to MacroDefinition structure

    Returns:
      Pointer to HygieneContext structure
      Returns 0 on allocation failure

    Hygiene context includes:
      - Variable mapping for hygiene
      - Scope stack for nested expansions
      - Hygiene level from macro definition
      - Safety flags for expansion
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    If macro is equal to 0:
        Return 0
    End If

    Note: Allocate HygieneContext structure (4 fields Ã— 8 bytes = 32 bytes)
    Let context be proc allocate from Layout with 32

    If context is equal to 0:
        Return 0
    End If

    Note: Create variable mapping
    Let variable_map be proc create from HashTable

    Note: Create scope stack
    Let scope_stack be proc create from Stack

    Note: Get hygiene level from macro
    Let hygiene_level be proc memory_get_qword from Layout with macro, 40

    Note: variable_map (offset 0)
    proc memory_set_qword from Layout with context, 0, variable_map

    Note: scope_stack (offset 8)
    proc memory_set_qword from Layout with context, 8, scope_stack

    Note: hygiene_level (offset 16)
    proc memory_set_qword from Layout with context, 16, hygiene_level

    Note: is_safe = 1 if hygiene_level is HYGIENE_SAFE (offset 24)
    Let is_safe be 0

    If hygiene_level is equal to HYGIENE_SAFE:
        Set is_safe to 1
    End If

    proc memory_set_qword from Layout with context, 24, is_safe

    Return context
End Process

Process called "substitute_arguments" takes macro_body as Integer, arguments as Integer, hygiene_context as Integer returns Integer:
    Note:
    Substitute macro arguments in macro body

    Parameters:
      macro_body - Pointer to macro body AST node
      arguments - Pointer to List of argument AST nodes
      hygiene_context - Pointer to HygieneContext

    Returns:
      Pointer to substituted body AST node
      Returns 0 on substitution failure

    Substitution algorithm:
    1. Clone macro body
    2. Traverse and substitute parameter references
    3. Return substituted body
    :End Note

    If macro_body is equal to 0:
        Return 0
    End If

    Note: Deep clone macro body to ensure independent copy
    Let substituted_body be proc ast_node_deep_clone from AST with macro_body

    If substituted_body is equal to 0:
        Return 0
    End If

    Note: Traverse AST and substitute parameter references with arguments
    Let param_count be proc list_length from List with parameters
    Let arg_count be proc list_length from List with arguments

    Note: Parameter count must match argument count
    If param_count is not equal to arg_count:
        Return 0  Note: Argument mismatch
    End If

    Note: Perform substitution for each parameter
    Let i be 0
    Loop:
        If i is greater than or equal to param_count:
            Break
        End If

        Let param be proc list_get from List with parameters, i
        Let arg be proc list_get from List with arguments, i

        If param is not equal to 0:
            If arg is not equal to 0:
                Note: Get parameter name
                Let param_name be proc ast_node_get_value from AST with param

                Note: Substitute all occurrences of parameter with argument
                proc ast_substitute_identifier from AST with substituted_body, param_name, arg
            End If
        End If

        Set i to i plus 1
    End Loop

    Return substituted_body
End Process

Process called "apply_hygiene_transformations" takes body as Integer, hygiene_context as Integer returns Integer:
    Note:
    Apply hygiene transformations to macro body

    Parameters:
      body - Pointer to macro body AST node
      hygiene_context - Pointer to HygieneContext

    Returns:
      Pointer to transformed body AST node
      Returns 0 on transformation failure

    Hygiene transformations:
      - Rename variables to avoid capture
      - Create unique identifiers
      - Preserve variable scope
    :End Note

    If body is equal to 0:
        Return 0
    End If

    If hygiene_context is equal to 0:
        Return body
    End If

    Note: Check hygiene level
    Let hygiene_level be proc memory_get_qword from Layout with hygiene_context, 16

    Note: If not hygienic, return body unchanged
    If hygiene_level is not equal to HYGIENE_SAFE:
        Return body
    End If

    Note: Generate unique suffix for variable renaming
    Let expansion_id be proc memory_get_qword from Layout with hygiene_context, 24
    Let suffix be proc integer_to_string from StringCore with expansion_id

    Note: Rename all local variables to unique identifiers
    Note: Collect all identifier nodes in the body
    Let identifiers be proc ast_collect_identifiers from AST with body

    If identifiers is equal to 0:
        Return body  Note: No identifiers to rename
    End If

    Let identifier_count be proc list_length from List with identifiers
    Let i be 0

    Loop:
        If i is greater than or equal to identifier_count:
            Break
        End If

        Let identifier be proc list_get from List with identifiers, i

        If identifier is not equal to 0:
            Note: Get identifier name
            Let old_name be proc ast_node_get_value from AST with identifier

            Note: Create unique name with suffix
            Let new_name be proc string_concat from StringCore with old_name, "_macro_"
            Set new_name to proc string_concat from StringCore with new_name, suffix

            Note: Rename all occurrences of this identifier
            proc ast_rename_identifier from AST with body, old_name, new_name
        End If

        Set i to i plus 1
    End Loop

    Return body
End Process

Process called "parse_expanded_code" takes parser as Integer, expanded_code as Integer returns Integer:
    Note:
    Parse expanded macro code

    Parameters:
      parser - Pointer to ParserState
      expanded_code - Pointer to expanded code string

    Returns:
      Pointer to parsed code AST node
      Returns 0 on parsing failure

    Parsing steps:
    1. Validate expanded code
    2. Return AST representation
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    If expanded_code is equal to 0:
        Return 0
    End If

    Note: Create temporary lexer for expanded code string
    Let temp_lexer be proc lexer_create from Lexer with expanded_code

    If temp_lexer is equal to 0:
        Return 0
    End If

    Note: Create temporary parser state
    Let temp_parser be proc parser_create from Parser with temp_lexer

    If temp_parser is equal to 0:
        proc lexer_destroy from Lexer with temp_lexer
        Return 0
    End If

    Note: Parse the expanded code into AST
    Let ast_node be proc parse_block from Parser with temp_parser

    Note: Clean up temporary parser and lexer
    proc parser_destroy from Parser with temp_parser
    proc lexer_destroy from Lexer with temp_lexer

    If ast_node is equal to 0:
        Return 0
    End If

    Return ast_node
End Process

Note: ============================================================================
Note: Macro Hygiene Validation
Note: ============================================================================

Process called "validate_macro_hygiene" takes parser as Integer, expansion as Integer returns Integer:
    Note:
    Validate macro hygiene after expansion

    Parameters:
      parser - Pointer to ParserState
      expansion - Pointer to MacroExpansion structure

    Returns:
      1 if hygiene is valid, 0 if invalid

    Hygiene validation:
      - No variable capture
      - Proper scope isolation
      - No identifier conflicts
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    If expansion is equal to 0:
        Return 0
    End If

    Note: Check variable capture
    Let no_capture be proc check_variable_capture with expansion

    If no_capture is equal to 0:
        Return 0
    End If

    Note: Check scope isolation
    Let is_isolated be proc check_scope_isolation with expansion

    If is_isolated is equal to 0:
        Return 0
    End If

    Note: Check identifier conflicts
    Let no_conflicts be proc check_identifier_conflicts with expansion

    If no_conflicts is equal to 0:
        Return 0
    End If

    Return 1
End Process

Process called "check_variable_capture" takes expansion as Integer returns Integer:
    Note:
    Check for variable capture in macro expansion

    Parameters:
      expansion - Pointer to MacroExpansion structure

    Returns:
      1 if no capture, 0 if capture detected

    Variable capture occurs when:
      - Macro parameter shadows outer variable
      - Macro body references outer variable
    :End Note

    If expansion is equal to 0:
        Return 1
    End If

    Note: Get expanded code AST from expansion structure
    Let expanded_code be proc memory_get_qword from Layout with expansion, 8

    If expanded_code is equal to 0:
        Return 1  Note: No code to check
    End If

    Note: Get hygiene map from expansion structure
    Let hygiene_map be proc memory_get_qword from Layout with expansion, 16

    If hygiene_map is equal to 0:
        Return 0  Note: No hygiene tracking - potential capture
    End If

    Note: Collect all identifiers in expanded code
    Let identifiers be proc ast_collect_identifiers from AST with expanded_code

    If identifiers is equal to 0:
        Return 1  Note: No identifiers to check
    End If

    Note: Verify each identifier is either:
    Note: 1. In hygiene map (was renamed - safe)
    Note: 2. A built-in function or type (safe)
    Note: 3. An argument substitution (safe)
    Let identifier_count be proc list_length from List with identifiers
    Let i be 0

    Loop:
        If i is greater than or equal to identifier_count:
            Break
        End If

        Let identifier be proc list_get from List with identifiers, i

        If identifier is not equal to 0:
            Let identifier_name be proc ast_node_get_value from AST with identifier

            Note: Check if identifier is in hygiene map
            Let is_in_map be proc hashtable_contains from HashTable with hygiene_map, identifier_name

            If is_in_map is equal to 0:
                Note: Identifier not in hygiene map - check if it's a built-in
                Let is_builtin be proc is_builtin_identifier with identifier_name

                If is_builtin is equal to 0:
                    Return 0  Note: Captured variable detected
                End If
            End If
        End If

        Set i to i plus 1
    End Loop

    Return 1  Note: No variable capture detected
End Process

Process called "check_scope_isolation" takes expansion as Integer returns Integer:
    Note:
    Check scope isolation in macro expansion

    Parameters:
      expansion - Pointer to MacroExpansion structure

    Returns:
      1 if scope is isolated, 0 if not

    Scope isolation ensures:
      - Macro variables don't leak
      - Outer variables are protected
    :End Note

    If expansion is equal to 0:
        Return 1
    End If

    Note: Get expanded code AST from expansion structure
    Let expanded_code be proc memory_get_qword from Layout with expansion, 8

    If expanded_code is equal to 0:
        Return 1  Note: No code to check
    End If

    Note: Get hygiene map from expansion structure
    Let hygiene_map be proc memory_get_qword from Layout with expansion, 16

    If hygiene_map is equal to 0:
        Return 0  Note: No hygiene tracking - scope isolation compromised
    End If

    Note: Collect all variable definitions in expanded code
    Let definitions be proc ast_collect_definitions from AST with expanded_code

    If definitions is equal to 0:
        Return 1  Note: No definitions to check
    End If

    Note: Verify all variable definitions are in hygiene map
    Let definition_count be proc list_length from List with definitions
    Let i be 0

    Loop:
        If i is greater than or equal to definition_count:
            Break
        End If

        Let definition be proc list_get from List with definitions, i

        If definition is not equal to 0:
            Let var_name be proc ast_node_get_value from AST with definition

            Note: Check if variable is in hygiene map
            Let is_in_map be proc hashtable_contains from HashTable with hygiene_map, var_name

            If is_in_map is equal to 0:
                Return 0  Note: Variable not properly isolated
            End If
        End If

        Set i to i plus 1
    End Loop

    Return 1  Note: Scope isolation verified
End Process

Process called "check_identifier_conflicts" takes expansion as Integer returns Integer:
    Note:
    Check for identifier conflicts in macro expansion

    Parameters:
      expansion - Pointer to MacroExpansion structure

    Returns:
      1 if no conflicts, 0 if conflicts detected

    Identifier conflicts occur when:
      - Same identifier used in different scopes
      - Macro parameter conflicts with outer variable
    :End Note

    If expansion is equal to 0:
        Return 1
    End If

    Note: Get expanded code AST from expansion structure
    Let expanded_code be proc memory_get_qword from Layout with expansion, 8

    If expanded_code is equal to 0:
        Return 1  Note: No code to check
    End If

    Note: Get hygiene map from expansion structure
    Let hygiene_map be proc memory_get_qword from Layout with expansion, 16

    If hygiene_map is equal to 0:
        Return 1  Note: No hygiene map - cannot verify conflicts
    End If

    Note: Collect all identifier uses in expanded code
    Let identifiers be proc ast_collect_identifiers from AST with expanded_code

    If identifiers is equal to 0:
        Return 1  Note: No identifiers to check
    End If

    Note: Build mapping of identifier names to their definitions
    Let identifier_map be proc create from HashTable

    If identifier_map is equal to 0:
        Return 0
    End If

    Let identifier_count be proc list_length from List with identifiers
    Let i be 0

    Loop:
        If i is greater than or equal to identifier_count:
            Break
        End If

        Let identifier be proc list_get from List with identifiers, i

        If identifier is not equal to 0:
            Let identifier_name be proc ast_node_get_value from AST with identifier

            Note: Check if identifier already mapped to different definition
            Let existing_def be proc hashtable_get from HashTable with identifier_map, identifier_name

            If existing_def is not equal to 0:
                Note: Identifier already exists - verify it's the same definition
                If existing_def is not equal to identifier:
                    Note: Same name, different definitions - potential conflict
                    Note: Verify both are in hygiene map or both are built-ins
                    Let is_in_map be proc hashtable_contains from HashTable with hygiene_map, identifier_name

                    If is_in_map is equal to 0:
                        Let is_builtin be proc is_builtin_identifier with identifier_name

                        If is_builtin is equal to 0:
                            proc destroy from HashTable with identifier_map
                            Return 0  Note: Conflict detected
                        End If
                    End If
                End If
            Otherwise:
                Note: New identifier - add to map
                proc hashtable_set from HashTable with identifier_map, identifier_name, identifier
            End If
        End If

        Set i to i plus 1
    End Loop

    proc destroy from HashTable with identifier_map

    Return 1  Note: No conflicts detected
End Process

Note: ============================================================================
Note: Macro System Utilities
Note: ============================================================================

Process called "get_macro_definition" takes parser as Integer, macro_name as Integer returns Integer:
    Note:
    Get macro definition by name

    Parameters:
      parser - Pointer to ParserState
      macro_name - Pointer to macro name string

    Returns:
      Pointer to MacroDefinition structure
      Returns 0 if macro not found
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    If macro_name is equal to 0:
        Return 0
    End If

    Note: Get context stack from parser state
    Let context_stack be proc memory_get_qword from Layout with parser, 48

    If context_stack is equal to 0:
        Return 0  Note: No context stack
    End If

    Note: Search through context stack from innermost to outermost scope
    Let context_count be proc size from Stack with context_stack
    Let i be context_count minus 1

    Loop:
        If i is less than 0:
            Break
        End If

        Let context be proc peek_at from Stack with context_stack, i

        If context is not equal to 0:
            Note: Get variables hashtable from context (includes macros)
            Let variables be proc memory_get_qword from Layout with context, 16

            If variables is not equal to 0:
                Note: Look up macro by name
                Let macro_def be proc get from HashTable with variables, macro_name

                If macro_def is not equal to 0:
                    Note: Verify this is a macro definition (not a regular variable)
                    Let node_type be proc memory_get_qword from Layout with macro_def, 0

                    Note: MACRO_DEFINITION node type (assuming AST node type constant)
                    If node_type is equal to 5000:
                        Return macro_def
                    End If
                End If
            End If
        End If

        Set i to i minus 1
    End Loop

    Return 0  Note: Macro not found in any scope
End Process

Process called "is_macro_hygienic" takes macro as Integer returns Integer:
    Note:
    Check if macro is hygienic

    Parameters:
      macro - Pointer to MacroDefinition structure

    Returns:
      1 if macro is hygienic, 0 if not
    :End Note

    If macro is equal to 0:
        Return 0
    End If

    Note: Get hygiene level from macro
    Let hygiene_level be proc memory_get_qword from Layout with macro, 40

    If hygiene_level is equal to HYGIENE_SAFE:
        Return 1
    End If

    Return 0
End Process

Process called "get_macro_expansion_depth" takes parser as Integer returns Integer:
    Note:
    Get current macro expansion depth

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Current expansion depth
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Get macro expansion depth from parser state
    Note: Offset 112 in ParserState (after sync_points at offset 104)
    Let depth be proc memory_get_qword from Layout with parser, 112

    Return depth
End Process

Process called "set_macro_expansion_depth" takes parser as Integer, depth as Integer returns Integer:
    Note:
    Set macro expansion depth

    Parameters:
      parser - Pointer to ParserState
      depth - New expansion depth

    Returns:
      1 on success, 0 on failure
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Set macro expansion depth in parser state
    Note: Offset 112 in ParserState (after sync_points at offset 104)
    proc memory_set_qword from Layout with parser, 112, depth

    Return 1
End Process

Process called "macro_expansion_debug_print" takes expansion as Integer returns Integer:
    Note:
    Print macro expansion for debugging

    Parameters:
      expansion - Pointer to MacroExpansion structure

    Returns:
      1 on success

    Outputs:
      - Original macro invocation
      - Expanded code
      - Hygiene mapping
      - Expansion depth
    :End Note

    If expansion is equal to 0:
        Return 0
    End If

    Note: Get expansion fields
    Let original_invocation be proc memory_get_qword from Layout with expansion, 0
    Let expanded_code be proc memory_get_qword from Layout with expansion, 8
    Let hygiene_map be proc memory_get_qword from Layout with expansion, 16
    Let expansion_depth be proc memory_get_qword from Layout with expansion, 24
    Let is_complete be proc memory_get_qword from Layout with expansion, 32

    Note: Print debug header
    Alert "=== Macro Expansion Debug Info ===\n"

    Note: Print original invocation
    Alert "Original Invocation: "
    If original_invocation is not equal to 0:
        Let invocation_str be proc ast_to_string from AST with original_invocation
        Alert invocation_str
        Alert "\n"
    Otherwise:
        Alert "(null)\n"
    End If

    Note: Print expanded code
    Alert "Expanded Code: "
    If expanded_code is not equal to 0:
        Let expanded_str be proc ast_to_string from AST with expanded_code
        Alert expanded_str
        Alert "\n"
    Otherwise:
        Alert "(null)\n"
    End If

    Note: Print hygiene mapping
    Alert "Hygiene Map: "
    If hygiene_map is not equal to 0:
        Let map_count be proc size from HashTable with hygiene_map
        Alert "("
        Let map_count_str be proc integer_to_string from StringCore with map_count
        Alert map_count_str
        Alert " mappings)\n"
    Otherwise:
        Alert "(null)\n"
    End If

    Note: Print expansion depth
    Alert "Expansion Depth: "
    Let depth_str be proc integer_to_string from StringCore with expansion_depth
    Alert depth_str
    Alert "\n"

    Note: Print completion status
    Alert "Completion Status: "
    If is_complete is equal to 1:
        Alert "Complete\n"
    Otherwise:
        Alert "Incomplete\n"
    End If

    Alert "================================\n"

    Return 1
End Process