Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file implements error recovery strategies for Runa parsing.

This file performs the following tasks:
- Implement panic-mode error recovery for parsing errors
- Provide synchronization points for error recovery
- Handle error recovery for different statement types
- Generate helpful error messages and suggestions
- Support graceful error recovery without stopping compilation

This file is essential because of the following reasons:
- Error recovery enables continued parsing after syntax errors
- Panic-mode recovery prevents cascading parse errors
- Synchronization points help resume parsing at safe locations
- Helpful error messages improve developer experience
- Graceful recovery allows partial compilation success

This file consists of the following functions/features/operation types:
- Panic-mode error recovery implementation
- Synchronization point detection and handling
- Error message generation and reporting
- Recovery strategy selection and execution
- Error context tracking and analysis

Dependencies:
- Imports parser.runa for parser state and error reporting
- Imports ast.runa for AST node validation
- Imports lexical components for token recognition
- Imports memory/layout.runa for structure allocation
:End Note

Import "compiler/frontend/parsing/parser.runa" as Parser
Import "compiler/frontend/parsing/ast.runa" as AST
Import "compiler/frontend/lexical/keywords.runa" as Keywords
Import "compiler/frontend/lexical/operators.runa" as Operators
Import "compiler/frontend/lexical/delimiters.runa" as Delimiters
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/primitives/collections/list.runa" as List
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore

Note: ============================================================================
Note: Error Recovery Constants
Note: ============================================================================

Note: Recovery strategy constants
Constant RECOVERY_SUCCESS as Integer is 1        Note: Recovery successful
Constant RECOVERY_FAILED as Integer is 0         Note: Recovery failed
Constant RECOVERY_PARTIAL as Integer is -1       Note: Partial recovery achieved

Note: Synchronization point constants
Constant SYNC_STATEMENT_BOUNDARY as Integer is 1 Note: Synchronize at statement boundary
Constant SYNC_BLOCK_END as Integer is 2          Note: Synchronize at block end
Constant SYNC_EXPRESSION_END as Integer is 3     Note: Synchronize at expression end
Constant SYNC_DECLARATION_END as Integer is 4    Note: Synchronize at declaration end

Note: Error severity constants
Constant ERROR_SEVERITY_LOW as Integer is 1      Note: Low severity error
Constant ERROR_SEVERITY_MEDIUM as Integer is 2   Note: Medium severity error
Constant ERROR_SEVERITY_HIGH as Integer is 3     Note: High severity error
Constant ERROR_SEVERITY_CRITICAL as Integer is 4 Note: Critical error

Note: Token type constants (from lexical modules)
Constant TOKEN_END as Integer is 430             Note: End keyword

Note: ============================================================================
Note: Error Reporting and Context
Note: ============================================================================

Process called "parser_report_error" takes arena as Integer, parser as Integer, error_type as Integer, message as Integer, line as Integer, column as Integer returns Integer:
    Note:
    Report a parsing error with context

    Parameters:
      arena - Arena for temporary allocations
      parser - Pointer to ParserState
      error_type - Error type constant
      message - Pointer to error message string
      line - Line number where error occurs
      column - Column number where error occurs

    Returns:
      1 on success (error reported)

    Side Effects:
      - Adds error to parser.errors List
      - Increments parser.error_count
      - May trigger error recovery mode
      - Updates parser recovery state
    :End Note

    Note: Validate inputs
    If arena is equal to 0:
        Return 0  Note: Arena required
    End If

    If parser is equal to 0:
        Return 0  Note: NULL parser
    End If

    If message is equal to 0:
        Return 0  Note: NULL message
    End If

    Note: Create error structure in arena (5 fields × 8 bytes = 40 bytes)
    Let error_struct_size be 40
    Let error_struct be proc arena_allocate from Layout with arena, error_struct_size

    If error_struct is equal to 0:
        Return 0  Note: Arena allocation failed
    End If

    Note: Set error fields
    proc memory_set_qword from Layout with error_struct, 0, error_type
    proc memory_set_qword from Layout with error_struct, 8, message
    proc memory_set_qword from Layout with error_struct, 16, line
    proc memory_set_qword from Layout with error_struct, 24, column

    Note: Determine error severity
    Let severity be proc analyze_error_severity with parser, error_type
    proc memory_set_qword from Layout with error_struct, 32, severity

    Note: Get errors list from parser (offset 16)
    Let errors_list be proc memory_get_qword from Layout with parser, 16

    Note: Add error to errors list
    If errors_list is not equal to 0:
        proc append from List with errors_list, error_struct
    End If

    Note: Get and increment error_count (offset 24)
    Let error_count be proc memory_get_qword from Layout with parser, 24
    Set error_count to error_count plus 1
    proc memory_set_qword from Layout with parser, 24, error_count

    Note: Check if recovery mode should be triggered
    If severity is greater than or equal to ERROR_SEVERITY_MEDIUM:
        Note: Set recovery_mode to 1 (offset 88)
        proc memory_set_qword from Layout with parser, 88, 1
    End If

    Return 1
End Process

Process called "create_error_context" takes arena as Integer, parser as Integer, error_type as Integer returns Integer:
    Note:
    Create error context information for recovery

    Parameters:
      arena - Arena for temporary allocations
      parser - Pointer to ParserState
      error_type - Error type constant

    Returns:
      Pointer to error context structure
      Returns 0 on allocation failure
    :End Note

    Note: Validate inputs
    If arena is equal to 0:
        Return 0  Note: Arena required
    End If

    If parser is equal to 0:
        Return 0
    End If

    Note: Allocate error context structure in arena (6 fields × 8 bytes = 48 bytes)
    Let context_size be 48
    Let context be proc arena_allocate from Layout with arena, context_size

    If context is equal to 0:
        Return 0  Note: Arena allocation failed
    End If

    Note: Store error type (offset 0)
    proc memory_set_qword from Layout with context, 0, error_type

    Note: Get current token from parser (offset 8)
    Let current_token be proc memory_get_qword from Layout with parser, 8
    proc memory_set_qword from Layout with context, 8, current_token

    Note: Get context stack from parser (offset 40)
    Let context_stack be proc memory_get_qword from Layout with parser, 40
    proc memory_set_qword from Layout with context, 16, context_stack

    Note: Determine appropriate sync point type
    Let sync_type be SYNC_STATEMENT_BOUNDARY
    proc memory_set_qword from Layout with context, 24, sync_type

    Note: Get recovery mode from parser (offset 88)
    Let recovery_mode be proc memory_get_qword from Layout with parser, 88
    proc memory_set_qword from Layout with context, 32, recovery_mode

    Note: Get error count from parser (offset 24)
    Let error_count be proc memory_get_qword from Layout with parser, 24
    proc memory_set_qword from Layout with context, 40, error_count

    Return context
End Process

Process called "analyze_error_severity" takes parser as Integer, error_type as Integer returns Integer:
    Note:
    Analyze error severity for recovery strategy

    Parameters:
      parser - Pointer to ParserState
      error_type - Error type constant

    Returns:
      Error severity constant
    :End Note

    Note: Low severity errors (1-999): minor syntax issues
    If error_type is less than 1000:
        Return ERROR_SEVERITY_LOW
    End If

    Note: Medium severity errors (1000-1999): significant syntax errors
    If error_type is less than 2000:
        Return ERROR_SEVERITY_MEDIUM
    End If

    Note: High severity errors (2000-2999): major structural errors
    If error_type is less than 3000:
        Return ERROR_SEVERITY_HIGH
    End If

    Note: Critical errors (3000+): fatal errors
    Return ERROR_SEVERITY_CRITICAL
End Process

Note: ============================================================================
Note: Panic-Mode Recovery
Note: ============================================================================

Process called "parser_synchronize" takes parser as Integer returns Integer:
    Note:
    Synchronize parser after error (panic-mode recovery)

    Parameters:
      parser - Pointer to ParserState

    Returns:
      RECOVERY_SUCCESS if synchronization successful
      RECOVERY_FAILED if synchronization failed
      RECOVERY_PARTIAL if partial synchronization achieved
    :End Note

    If parser is equal to 0:
        Return RECOVERY_FAILED
    End If

    Note: Try statement boundary synchronization first
    Let result be proc skip_to_synchronization_point with parser, SYNC_STATEMENT_BOUNDARY

    If result is equal to 1:
        proc reset_parser_state with parser
        Note: Increment successful recovery counter (offset 120)
        Let success_count be proc memory_get_qword from Layout with parser, 120
        Set success_count to success_count plus 1
        proc memory_set_qword from Layout with parser, 120, success_count
        Return RECOVERY_SUCCESS
    End If

    Note: Try block end synchronization
    Set result to proc skip_to_synchronization_point with parser, SYNC_BLOCK_END

    If result is equal to 1:
        proc reset_parser_state with parser
        Note: Increment successful recovery counter (partial success still counts)
        Let success_count be proc memory_get_qword from Layout with parser, 120
        Set success_count to success_count plus 1
        proc memory_set_qword from Layout with parser, 120, success_count
        Return RECOVERY_PARTIAL
    End If

    Note: Try declaration end synchronization as last resort
    Set result to proc skip_to_synchronization_point with parser, SYNC_DECLARATION_END

    If result is equal to 1:
        proc reset_parser_state with parser
        Note: Increment successful recovery counter (partial success still counts)
        Let success_count be proc memory_get_qword from Layout with parser, 120
        Set success_count to success_count plus 1
        proc memory_set_qword from Layout with parser, 120, success_count
        Return RECOVERY_PARTIAL
    End If

    Note: Increment failed recovery counter (offset 128)
    Let failed_count be proc memory_get_qword from Layout with parser, 128
    Set failed_count to failed_count plus 1
    proc memory_set_qword from Layout with parser, 128, failed_count
    Return RECOVERY_FAILED
End Process

Process called "find_synchronization_point" takes parser as Integer, sync_type as Integer returns Integer:
    Note:
    Find appropriate synchronization point for recovery

    Parameters:
      parser - Pointer to ParserState
      sync_type - Type of synchronization point to find

    Returns:
      Line number where synchronization point found
      Returns 0 if no synchronization point found
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Get current token
    Let current_token be proc parser_current_token from Parser with parser

    If current_token is equal to 0:
        Return 0
    End If

    Note: Check based on sync type
    If sync_type is equal to SYNC_STATEMENT_BOUNDARY:
        Note: Look for statement keywords (Let, Set, If, Match, For, While, Return)
        Note: Token type would be in keyword range
        Let token_type be proc memory_get_qword from Layout with current_token, 0
        If token_type is greater than or equal to 1000:
            If token_type is less than 2000:
                Let line be proc memory_get_qword from Layout with current_token, 8
                Return line
            End If
        End If
    End If

    If sync_type is equal to SYNC_BLOCK_END:
        Note: Look for End keyword
        Let token_type be proc memory_get_qword from Layout with current_token, 0
        If token_type is equal to TOKEN_END:
            Let line be proc memory_get_qword from Layout with current_token, 8
            Return line
        End If
    End If

    Return 0
End Process

Process called "skip_to_synchronization_point" takes parser as Integer, sync_type as Integer returns Integer:
    Note:
    Skip tokens until synchronization point is reached

    Parameters:
      parser - Pointer to ParserState
      sync_type - Type of synchronization point

    Returns:
      1 if synchronization point reached, 0 if not found
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Maximum tokens to skip to prevent infinite loops
    Let max_skip be 1000
    Let skip_count be 0

    Loop forever:
        Note: Check if at end of stream
        Let at_end be proc parser_is_at_end from Parser with parser
        If at_end is equal to 1:
            Return 0
        End If

        Note: Check if reached max skip limit
        If skip_count is greater than or equal to max_skip:
            Return 0
        End If

        Note: Check if current token is synchronization point
        Let sync_line be proc find_synchronization_point with parser, sync_type
        If sync_line is not equal to 0:
            Return 1
        End If

        Note: Consume token and continue
        proc parser_consume_token from Parser with parser
        Set skip_count to skip_count plus 1
    End Loop

    Return 0
End Process

Process called "reset_parser_state" takes parser as Integer returns Integer:
    Note:
    Reset parser state after error recovery

    Parameters:
      parser - Pointer to ParserState

    Returns:
      1 on success, 0 on failure
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Clear error recovery mode (offset 88)
    proc memory_set_qword from Layout with parser, 88, 0

    Note: Get context stack (offset 40)
    Let context_stack be proc memory_get_qword from Layout with parser, 40

    Note: Clear any partial contexts (keep only global context)
    If context_stack is not equal to 0:
        Loop forever:
            Let size be proc size from Stack with context_stack
            If size is less than or equal to 1:
                Break
            End If
            proc pop from Stack with context_stack
        End Loop
    End If

    Return 1
End Process

Note: ============================================================================
Note: Statement-Specific Error Recovery
Note: ============================================================================

Process called "parser_skip_to_keyword" takes parser as Integer, keyword as Integer returns Integer:
    Note:
    Skip tokens until specific keyword is found

    Parameters:
      parser - Pointer to ParserState
      keyword - Keyword token type to find

    Returns:
      1 if keyword found, 0 if not found
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Let max_skip be 500
    Let skip_count be 0

    Loop forever:
        Let at_end be proc parser_is_at_end from Parser with parser
        If at_end is equal to 1:
            Return 0
        End If

        If skip_count is greater than or equal to max_skip:
            Return 0
        End If

        Let current_token be proc parser_current_token from Parser with parser
        If current_token is not equal to 0:
            Let token_type be proc memory_get_qword from Layout with current_token, 0
            If token_type is equal to keyword:
                Return 1
            End If
        End If

        proc parser_consume_token from Parser with parser
        Set skip_count to skip_count plus 1
    End Loop

    Return 0
End Process

Process called "parser_recover_from_expression_error" takes parser as Integer returns Integer:
    Note:
    Recover from expression parsing errors

    Parameters:
      parser - Pointer to ParserState

    Returns:
      RECOVERY_SUCCESS if recovery successful
      RECOVERY_FAILED if recovery failed
    :End Note

    If parser is equal to 0:
        Return RECOVERY_FAILED
    End If

    Let result be proc skip_to_synchronization_point with parser, SYNC_EXPRESSION_END
    If result is equal to 1:
        proc reset_parser_state with parser
        Note: Increment successful recovery counter (offset 120)
        Let success_count be proc memory_get_qword from Layout with parser, 120
        Set success_count to success_count plus 1
        proc memory_set_qword from Layout with parser, 120, success_count
        Return RECOVERY_SUCCESS
    End If

    Set result to proc skip_to_synchronization_point with parser, SYNC_STATEMENT_BOUNDARY
    If result is equal to 1:
        proc reset_parser_state with parser
        Note: Increment successful recovery counter (partial success still counts)
        Let success_count be proc memory_get_qword from Layout with parser, 120
        Set success_count to success_count plus 1
        proc memory_set_qword from Layout with parser, 120, success_count
        Return RECOVERY_PARTIAL
    End If

    Note: Increment failed recovery counter (offset 128)
    Let failed_count be proc memory_get_qword from Layout with parser, 128
    Set failed_count to failed_count plus 1
    proc memory_set_qword from Layout with parser, 128, failed_count
    Return RECOVERY_FAILED
End Process

Process called "parser_recover_from_statement_error" takes parser as Integer returns Integer:
    Note:
    Recover from statement parsing errors

    Parameters:
      parser - Pointer to ParserState

    Returns:
      RECOVERY_SUCCESS if recovery successful
      RECOVERY_FAILED if recovery failed
    :End Note

    If parser is equal to 0:
        Return RECOVERY_FAILED
    End If

    Let result be proc skip_to_synchronization_point with parser, SYNC_STATEMENT_BOUNDARY
    If result is equal to 1:
        proc reset_parser_state with parser
        Note: Increment successful recovery counter (offset 120)
        Let success_count be proc memory_get_qword from Layout with parser, 120
        Set success_count to success_count plus 1
        proc memory_set_qword from Layout with parser, 120, success_count
        Return RECOVERY_SUCCESS
    End If

    Set result to proc skip_to_synchronization_point with parser, SYNC_BLOCK_END
    If result is equal to 1:
        proc reset_parser_state with parser
        Note: Increment successful recovery counter (partial success still counts)
        Let success_count be proc memory_get_qword from Layout with parser, 120
        Set success_count to success_count plus 1
        proc memory_set_qword from Layout with parser, 120, success_count
        Return RECOVERY_PARTIAL
    End If

    Note: Increment failed recovery counter (offset 128)
    Let failed_count be proc memory_get_qword from Layout with parser, 128
    Set failed_count to failed_count plus 1
    proc memory_set_qword from Layout with parser, 128, failed_count
    Return RECOVERY_FAILED
End Process

Process called "parser_recover_from_block_error" takes parser as Integer returns Integer:
    Note:
    Recover from block parsing errors

    Parameters:
      parser - Pointer to ParserState

    Returns:
      RECOVERY_SUCCESS if recovery successful
      RECOVERY_FAILED if recovery failed
    :End Note

    If parser is equal to 0:
        Return RECOVERY_FAILED
    End If

    Let result be proc skip_to_synchronization_point with parser, SYNC_BLOCK_END
    If result is equal to 1:
        proc reset_parser_state with parser
        Note: Increment successful recovery counter (offset 120)
        Let success_count be proc memory_get_qword from Layout with parser, 120
        Set success_count to success_count plus 1
        proc memory_set_qword from Layout with parser, 120, success_count
        Return RECOVERY_SUCCESS
    End If

    Note: Increment failed recovery counter (offset 128)
    Let failed_count be proc memory_get_qword from Layout with parser, 128
    Set failed_count to failed_count plus 1
    proc memory_set_qword from Layout with parser, 128, failed_count
    Return RECOVERY_FAILED
End Process

Process called "parser_recover_from_declaration_error" takes parser as Integer returns Integer:
    Note:
    Recover from declaration parsing errors

    Parameters:
      parser - Pointer to ParserState

    Returns:
      RECOVERY_SUCCESS if recovery successful
      RECOVERY_FAILED if recovery failed
    :End Note

    If parser is equal to 0:
        Return RECOVERY_FAILED
    End If

    Let result be proc skip_to_synchronization_point with parser, SYNC_DECLARATION_END
    If result is equal to 1:
        proc reset_parser_state with parser
        Note: Increment successful recovery counter (offset 120)
        Let success_count be proc memory_get_qword from Layout with parser, 120
        Set success_count to success_count plus 1
        proc memory_set_qword from Layout with parser, 120, success_count
        Return RECOVERY_SUCCESS
    End If

    Set result to proc skip_to_synchronization_point with parser, SYNC_STATEMENT_BOUNDARY
    If result is equal to 1:
        proc reset_parser_state with parser
        Note: Increment successful recovery counter (partial success still counts)
        Let success_count be proc memory_get_qword from Layout with parser, 120
        Set success_count to success_count plus 1
        proc memory_set_qword from Layout with parser, 120, success_count
        Return RECOVERY_PARTIAL
    End If

    Note: Increment failed recovery counter (offset 128)
    Let failed_count be proc memory_get_qword from Layout with parser, 128
    Set failed_count to failed_count plus 1
    proc memory_set_qword from Layout with parser, 128, failed_count
    Return RECOVERY_FAILED
End Process

Note: ============================================================================
Note: Error Message Generation
Note: ============================================================================

Process called "generate_error_message" takes parser as Integer, error_type as Integer returns Integer:
    Note:
    Generate helpful error message for parsing error

    Parameters:
      parser - Pointer to ParserState
      error_type - Error type constant

    Returns:
      Pointer to error message string
      Returns 0 on allocation failure
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Create string builder for error message
    Let message_builder be proc create from StringCore

    If message_builder is equal to 0:
        Return 0
    End If

    Note: Add error type description
    Let error_desc be proc create_from_cstring from StringCore with "Parsing error: "
    proc append from StringCore with message_builder, error_desc

    Note: Add error type number
    Let type_str be proc integer_to_string from StringCore with error_type
    proc append from StringCore with message_builder, type_str

    Note: Add location information
    Let current_token be proc parser_current_token from Parser with parser
    If current_token is not equal to 0:
        Let line be proc memory_get_qword from Layout with current_token, 8
        Let column be proc memory_get_qword from Layout with current_token, 16

        Let loc_str be proc create_from_cstring from StringCore with " at line "
        proc append from StringCore with message_builder, loc_str

        Let line_str be proc integer_to_string from StringCore with line
        proc append from StringCore with message_builder, line_str

        Let col_label be proc create_from_cstring from StringCore with ", column "
        proc append from StringCore with message_builder, col_label

        Let col_str be proc integer_to_string from StringCore with column
        proc append from StringCore with message_builder, col_str
    End If

    Note: Convert to C string
    Let result be proc to_cstring from StringCore with message_builder

    Return result
End Process

Process called "suggest_fix_for_error" takes parser as Integer, error_type as Integer returns Integer:
    Note:
    Suggest fix for parsing error

    Parameters:
      parser - Pointer to ParserState
      error_type - Error type constant

    Returns:
      Pointer to suggestion string
      Returns 0 if no suggestion available
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Generate suggestion based on error type range
    If error_type is less than 1000:
        Let suggestion be proc create_from_cstring from StringCore with "Check syntax near this location"
        Return proc to_cstring from StringCore with suggestion
    End If

    If error_type is less than 2000:
        Let suggestion be proc create_from_cstring from StringCore with "Verify statement structure and keywords"
        Return proc to_cstring from StringCore with suggestion
    End If

    If error_type is less than 3000:
        Let suggestion be proc create_from_cstring from StringCore with "Check block structure and End keywords"
        Return proc to_cstring from StringCore with suggestion
    End If

    Let suggestion be proc create_from_cstring from StringCore with "Critical error - review entire declaration"
    Return proc to_cstring from StringCore with suggestion
End Process

Process called "get_error_context_info" takes parser as Integer returns Integer:
    Note:
    Get context information for error reporting

    Parameters:
      parser - Pointer to ParserState

    Returns:
      Pointer to context information string
      Returns 0 on allocation failure
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Create string builder for context info
    Let context_builder be proc create from StringCore

    If context_builder is equal to 0:
        Return 0
    End If

    Note: Add context stack info
    Let context_stack be proc memory_get_qword from Layout with parser, 40
    If context_stack is not equal to 0:
        Let stack_size be proc size from Stack with context_stack

        Let context_label be proc create_from_cstring from StringCore with "Context depth: "
        proc append from StringCore with context_builder, context_label

        Let depth_str be proc integer_to_string from StringCore with stack_size
        proc append from StringCore with context_builder, depth_str
    End If

    Note: Add error count
    Let error_count be proc memory_get_qword from Layout with parser, 24

    Let error_label be proc create_from_cstring from StringCore with ", Errors: "
    proc append from StringCore with context_builder, error_label

    Let count_str be proc integer_to_string from StringCore with error_count
    proc append from StringCore with context_builder, count_str

    Note: Convert to C string
    Let result be proc to_cstring from StringCore with context_builder

    Return result
End Process

Note: ============================================================================
Note: Recovery Strategy Selection
Note: ============================================================================

Process called "select_recovery_strategy" takes parser as Integer, error_type as Integer returns Integer:
    Note:
    Select appropriate recovery strategy for error

    Parameters:
      parser - Pointer to ParserState
      error_type - Error type constant

    Returns:
      Recovery strategy constant (sync type)
      Returns 0 if no strategy available
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Select strategy based on error severity
    Let severity be proc analyze_error_severity with parser, error_type

    If severity is equal to ERROR_SEVERITY_LOW:
        Return SYNC_EXPRESSION_END
    End If

    If severity is equal to ERROR_SEVERITY_MEDIUM:
        Return SYNC_STATEMENT_BOUNDARY
    End If

    If severity is equal to ERROR_SEVERITY_HIGH:
        Return SYNC_BLOCK_END
    End If

    Note: Critical severity
    Return SYNC_DECLARATION_END
End Process

Process called "execute_recovery_strategy" takes parser as Integer, strategy as Integer returns Integer:
    Note:
    Execute selected recovery strategy

    Parameters:
      parser - Pointer to ParserState
      strategy - Recovery strategy constant (sync type)

    Returns:
      RECOVERY_SUCCESS if strategy executed successfully
      RECOVERY_FAILED if strategy failed
      RECOVERY_PARTIAL if partial success
    :End Note

    If parser is equal to 0:
        Return RECOVERY_FAILED
    End If

    Note: Execute recovery based on strategy (sync type)
    Let result be proc skip_to_synchronization_point with parser, strategy

    If result is equal to 0:
        Note: Increment failed recovery counter (offset 128)
        Let failed_count be proc memory_get_qword from Layout with parser, 128
        Set failed_count to failed_count plus 1
        proc memory_set_qword from Layout with parser, 128, failed_count
        Return RECOVERY_FAILED
    End If

    Note: Reset parser state after successful skip
    proc reset_parser_state with parser

    Note: Validate recovery
    Let is_valid be proc validate_recovery_success with parser

    If is_valid is equal to 1:
        Note: Increment successful recovery counter (offset 120)
        Let success_count be proc memory_get_qword from Layout with parser, 120
        Set success_count to success_count plus 1
        proc memory_set_qword from Layout with parser, 120, success_count
        Return RECOVERY_SUCCESS
    End If

    Note: Partial recovery - still counts as success
    Let success_count be proc memory_get_qword from Layout with parser, 120
    Set success_count to success_count plus 1
    proc memory_set_qword from Layout with parser, 120, success_count
    Return RECOVERY_PARTIAL
End Process

Process called "validate_recovery_success" takes parser as Integer returns Integer:
    Note:
    Validate that recovery was successful

    Parameters:
      parser - Pointer to ParserState

    Returns:
      1 if recovery successful, 0 if not
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Check parser is not at end
    Let at_end be proc parser_is_at_end from Parser with parser
    If at_end is equal to 1:
        Return 0
    End If

    Note: Check current token is valid
    Let current_token be proc parser_current_token from Parser with parser
    If current_token is equal to 0:
        Return 0
    End If

    Note: Check context stack exists
    Let context_stack be proc memory_get_qword from Layout with parser, 40
    If context_stack is equal to 0:
        Return 0
    End If

    Note: Check context stack has at least global context
    Let stack_size be proc size from Stack with context_stack
    If stack_size is less than 1:
        Return 0
    End If

    Note: Check recovery mode is cleared
    Let recovery_mode be proc memory_get_qword from Layout with parser, 88
    If recovery_mode is not equal to 0:
        Return 0
    End If

    Return 1
End Process

Note: ============================================================================
Note: Error Recovery Utilities
Note: ============================================================================

Process called "is_recovery_needed" takes parser as Integer returns Integer:
    Note:
    Check if error recovery is needed

    Parameters:
      parser - Pointer to ParserState

    Returns:
      1 if recovery needed, 0 otherwise
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Check error count threshold (offset 24)
    Let error_count be proc memory_get_qword from Layout with parser, 24

    Note: If more than 10 errors, recovery needed
    If error_count is greater than 10:
        Return 1
    End If

    Note: Check if in recovery mode (offset 88)
    Let recovery_mode be proc memory_get_qword from Layout with parser, 88
    If recovery_mode is equal to 1:
        Return 1
    End If

    Note: Check if context stack is inconsistent
    Let context_stack be proc memory_get_qword from Layout with parser, 40
    If context_stack is equal to 0:
        Return 1  Note: Missing context stack is inconsistent
    End If

    Let stack_size be proc size from Stack with context_stack
    If stack_size is less than 1:
        Return 1  Note: No global context is inconsistent
    End If

    Return 0
End Process

Process called "get_recovery_statistics" takes arena as Integer, parser as Integer returns Integer:
    Note:
    Get error recovery statistics

    Parameters:
      arena - Arena for temporary allocations
      parser - Pointer to ParserState

    Returns:
      Pointer to recovery statistics structure
      Returns 0 on allocation failure
    :End Note

    If arena is equal to 0:
        Return 0  Note: Arena required
    End If

    If parser is equal to 0:
        Return 0
    End If

    Note: Allocate statistics structure in arena (4 fields × 8 bytes = 32 bytes)
    Let stats_size be 32
    Let stats be proc arena_allocate from Layout with arena, stats_size

    If stats is equal to 0:
        Return 0  Note: Arena allocation failed
    End If

    Note: Get total error count (offset 0)
    Let error_count be proc memory_get_qword from Layout with parser, 24
    proc memory_set_qword from Layout with stats, 0, error_count

    Note: Get recovery mode state (offset 8)
    Let recovery_mode be proc memory_get_qword from Layout with parser, 88
    proc memory_set_qword from Layout with stats, 8, recovery_mode

    Note: Get successful recovery count from parser state (offset 120)
    Let successful_recoveries be proc memory_get_qword from Layout with parser, 120
    proc memory_set_qword from Layout with stats, 16, successful_recoveries

    Note: Get failed recovery count from parser state (offset 128)
    Let failed_recoveries be proc memory_get_qword from Layout with parser, 128
    proc memory_set_qword from Layout with stats, 24, failed_recoveries

    Return stats
End Process

Process called "reset_recovery_state" takes parser as Integer returns Integer:
    Note:
    Reset error recovery state

    Parameters:
      parser - Pointer to ParserState

    Returns:
      1 on success, 0 on failure
    :End Note

    If parser is equal to 0:
        Return 0
    End If

    Note: Clear recovery mode (offset 88)
    proc memory_set_qword from Layout with parser, 88, 0

    Note: Clear error count (offset 24)
    proc memory_set_qword from Layout with parser, 24, 0

    Note: Clear errors list
    Let errors_list be proc memory_get_qword from Layout with parser, 16
    If errors_list is not equal to 0:
        proc clear from List with errors_list
    End If

    Note: Clear sync points list (offset 96)
    Let sync_points be proc memory_get_qword from Layout with parser, 96
    If sync_points is not equal to 0:
        proc clear from List with sync_points
    End If

    Return 1
End Process