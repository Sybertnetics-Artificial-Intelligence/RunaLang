Note:
Example: Basic Manual ARC Usage

This example demonstrates:
- Allocating ARC-managed memory
- Manual retain and release
- Checking reference counts
- Detecting leaks
- Proper cleanup

Compile: runac 01_basic_arc.runa -o basic_arc
Run: ./basic_arc
Expected Output: No leaks detected
:End Note

Import "runtime/core/memory/arc_heap.runa" as ARC
Import "runtime/stdlib/arc/arc_utils.runa" as ARCUtils

Note: Simple data structure
Type called "Point" with annotation @ARC:
    x as Integer
    y as Integer
End Type

Process called "main" returns Integer:
    Note: ========================================
    Note: Example 1: Basic Allocation and Release
    Note: ========================================

    Note: Reset statistics for clean measurement
    proc arc_stats_reset from ARCUtils

    Note: Allocate ARC-managed Point (refcount = 1)
    Let point be proc arc_tracked_allocate from ARCUtils with 16

    Note: Initialize Point fields
    proc memory_set_int64 with point, 0, 10  Note: x = 10
    proc memory_set_int64 with point, 8, 20  Note: y = 20

    Note: Check reference count (should be 1)
    Let refcount be proc arc_get_refcount from ARC with point
    Note: refcount = 1 (we own the only reference)

    Note: Release the reference
    proc arc_tracked_release from ARCUtils with point
    Note: Object should be deallocated (refcount reached 0)

    Note: Check for leaks
    If proc arc_assert_no_leaks from ARCUtils is equal to 0:
        Note: FAILURE - Memory leak detected in Example 1
        Return 1
    End If

    Note: ========================================
    Note: Example 2: Multiple References
    Note: ========================================

    proc arc_stats_reset from ARCUtils

    Note: Allocate Point
    Let point1 be proc arc_tracked_allocate from ARCUtils with 16
    proc memory_set_int64 with point1, 0, 5
    proc memory_set_int64 with point1, 8, 15

    Note: Create second reference (refcount = 2)
    Let point2 be proc arc_tracked_retain from ARCUtils with point1

    Note: Check reference count (should be 2)
    Let refcount2 be proc arc_get_refcount from ARC with point1
    Note: refcount = 2 (point1 and point2 both reference same object)

    Note: Release first reference (refcount = 1)
    proc arc_tracked_release from ARCUtils with point1

    Note: Object still alive (point2 still holds reference)
    Let refcount3 be proc arc_get_refcount from ARC with point2
    Note: refcount = 1 (only point2 remains)

    Note: Release second reference (refcount = 0, object freed)
    proc arc_tracked_release from ARCUtils with point2

    Note: Check for leaks
    If proc arc_assert_no_leaks from ARCUtils is equal to 0:
        Note: FAILURE - Memory leak detected in Example 2
        Return 1
    End If

    Note: ========================================
    Note: Example 3: Copy-on-Write with arc_is_unique
    Note: ========================================

    proc arc_stats_reset from ARCUtils

    Note: Allocate buffer
    Let buffer be proc arc_tracked_allocate from ARCUtils with 32

    Note: Check if unique (should be 1)
    If proc arc_is_unique from ARC with buffer is equal to 1:
        Note: Buffer is unique - safe to mutate in-place
        proc memory_set_int64 with buffer, 0, 100
    End If

    Note: Create shared reference
    Let buffer_shared be proc arc_tracked_retain from ARCUtils with buffer

    Note: Check if unique (should be 0, shared now)
    If proc arc_is_unique from ARC with buffer is equal to 0:
        Note: Buffer is shared - must clone before mutation
        Let size be proc arc_get_size from ARC with buffer
        Let buffer_copy be proc arc_clone from ARC with buffer, size

        Note: Mutate the copy
        proc memory_set_int64 with buffer_copy, 0, 200

        Note: Release shared reference, use copy instead
        proc arc_tracked_release from ARCUtils with buffer
        Set buffer to buffer_copy
    End If

    Note: Release both references
    proc arc_tracked_release from ARCUtils with buffer
    proc arc_tracked_release from ARCUtils with buffer_shared

    Note: Check for leaks
    If proc arc_assert_no_leaks from ARCUtils is equal to 0:
        Note: FAILURE - Memory leak detected in Example 3
        Return 1
    End If

    Note: ========================================
    Note: Example 4: Statistics and Debugging
    Note: ========================================

    proc arc_stats_reset from ARCUtils

    Note: Allocate multiple objects
    Let obj1 be proc arc_tracked_allocate from ARCUtils with 16
    Let obj2 be proc arc_tracked_allocate from ARCUtils with 32
    Let obj3 be proc arc_tracked_allocate from ARCUtils with 64

    Note: Create some retains
    Let obj1_copy be proc arc_tracked_retain from ARCUtils with obj1
    Let obj2_copy be proc arc_tracked_retain from ARCUtils with obj2

    Note: Get statistics
    Let total_allocs be proc arc_get_stats_allocations from ARCUtils
    Let live_objects be proc arc_get_stats_live_objects from ARCUtils
    Let total_retains be proc arc_get_stats_retains from ARCUtils

    Note: total_allocs = 3, live_objects = 3, total_retains = 2

    Note: Release all references
    proc arc_tracked_release from ARCUtils with obj1
    proc arc_tracked_release from ARCUtils with obj1_copy
    proc arc_tracked_release from ARCUtils with obj2
    proc arc_tracked_release from ARCUtils with obj2_copy
    proc arc_tracked_release from ARCUtils with obj3

    Note: Check balance
    If proc arc_assert_balanced from ARCUtils is equal to 0:
        Note: FAILURE - Retain/release imbalance detected
        Return 1
    End If

    Note: Check for leaks
    If proc arc_assert_no_leaks from ARCUtils is equal to 0:
        Note: FAILURE - Memory leak detected in Example 4
        Return 1
    End If

    Note: ========================================
    Note: SUCCESS - All examples passed
    Note: ========================================

    Return 0
End Process
