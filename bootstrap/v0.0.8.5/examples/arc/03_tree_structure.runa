Note:
Example: Binary Tree with ARC

This example demonstrates:
- Tree structures with ARC
- Recursive cleanup patterns
- Parent-child ownership
- Proper reference management in recursive structures

Compile: runac 03_tree_structure.runa -o tree
Run: ./tree
Expected Output: No leaks
:End Note

Import "runtime/core/memory/arc_heap.runa" as ARC
Import "runtime/stdlib/arc/arc_utils.runa" as ARCUtils

Note: ========================================
Note: Binary Tree Node
Note: ========================================

Type called "TreeNode" with annotation @ARC:
    value as Integer        Note: Node data
    left as Integer         Note: Strong reference to left child (ARC pointer)
    right as Integer        Note: Strong reference to right child (ARC pointer)
End Type

Process called "create_tree_node" takes value as Integer returns Integer:
    Note:
    Create new tree node

    Parameters:
      value - Node value

    Returns:
      Pointer to new TreeNode (refcount = 1)
      Returns 0 on allocation failure
    :End Note

    Note: Allocate TreeNode structure (24 bytes: value + left + right)
    Let node be proc arc_allocate from ARC with 24
    If node is equal to 0:
        Return 0
    End If

    Note: Initialize fields
    proc memory_set_int64 with node, 0, value
    proc memory_set_int64 with node, 8, 0     Note: left = NULL
    proc memory_set_int64 with node, 16, 0    Note: right = NULL

    Return node
End Process

Process called "set_left_child" takes parent as Integer, child as Integer returns Integer:
    Note:
    Set left child of parent node

    Parameters:
      parent - Parent node
      child - Child node to set as left child

    Returns:
      1 on success, 0 on failure

    Ownership:
      Parent owns left child (strong reference)
      Increments child's refcount
    :End Note

    If parent is equal to 0:
        Return 0
    End If

    If child is equal to 0:
        Return 0
    End If

    Note: Get current left child
    Let old_left be proc memory_get_int64 with parent, 8

    If old_left is not equal to 0:
        Note: Release old left child before replacing
        proc arc_release from ARC with old_left
    End If

    Note: Retain new child (parent now owns it)
    Let retained_child be proc arc_retain from ARC with child

    Note: Set parent.left = child
    proc memory_set_int64 with parent, 8, retained_child

    Return 1
End Process

Process called "set_right_child" takes parent as Integer, child as Integer returns Integer:
    Note:
    Set right child of parent node

    Parameters:
      parent - Parent node
      child - Child node to set as right child

    Returns:
      1 on success, 0 on failure

    Ownership:
      Parent owns right child (strong reference)
      Increments child's refcount
    :End Note

    If parent is equal to 0:
        Return 0
    End If

    If child is equal to 0:
        Return 0
    End If

    Note: Get current right child
    Let old_right be proc memory_get_int64 with parent, 16

    If old_right is not equal to 0:
        Note: Release old right child before replacing
        proc arc_release from ARC with old_right
    End If

    Note: Retain new child (parent now owns it)
    Let retained_child be proc arc_retain from ARC with child

    Note: Set parent.right = child
    proc memory_set_int64 with parent, 16, retained_child

    Return 1
End Process

Process called "destroy_tree_recursive" takes node as Integer returns Integer:
    Note:
    Destroy tree recursively (post-order traversal)

    Parameters:
      node - Root of tree to destroy

    Returns:
      1 on success

    Cleanup Order (Post-Order):
      1. Destroy left subtree
      2. Destroy right subtree
      3. Destroy current node

    This ensures children are freed before parent
    :End Note

    If node is equal to 0:
        Return 1
    End If

    Note: Get left child
    Let left be proc memory_get_int64 with node, 8

    If left is not equal to 0:
        Note: Recursively destroy left subtree
        proc destroy_tree_recursive with left
        Note: Release left child reference
        proc arc_release from ARC with left
        Note: Clear left pointer
        proc memory_set_int64 with node, 8, 0
    End If

    Note: Get right child
    Let right be proc memory_get_int64 with node, 16

    If right is not equal to 0:
        Note: Recursively destroy right subtree
        proc destroy_tree_recursive with right
        Note: Release right child reference
        proc arc_release from ARC with right
        Note: Clear right pointer
        proc memory_set_int64 with node, 16, 0
    End If

    Note: Destroy current node
    proc arc_release from ARC with node

    Return 1
End Process

Process called "count_nodes" takes node as Integer returns Integer:
    Note:
    Count nodes in tree (for verification)

    Parameters:
      node - Root of tree

    Returns:
      Number of nodes in tree
    :End Note

    If node is equal to 0:
        Return 0
    End If

    Note: Get children
    Let left be proc memory_get_int64 with node, 8
    Let right be proc memory_get_int64 with node, 16

    Note: Count = 1 (current) + left subtree + right subtree
    Let left_count be proc count_nodes with left
    Let right_count be proc count_nodes with right

    Let total be 1 plus left_count plus right_count
    Return total
End Process

Process called "main" returns Integer:
    Note: Reset statistics
    proc arc_stats_reset from ARCUtils

    Note: ========================================
    Note: Create Binary Tree
    Note: ========================================
    Note:
    Note: Tree structure:
    Note:        1
    Note:       / \
    Note:      2   3
    Note:     / \
    Note:    4   5
    Note:
    Note: ========================================

    Note: Create nodes
    Let root be proc create_tree_node with 1
    Let node2 be proc create_tree_node with 2
    Let node3 be proc create_tree_node with 3
    Let node4 be proc create_tree_node with 4
    Let node5 be proc create_tree_node with 5

    Note: Build tree structure
    proc set_left_child with root, node2
    proc set_right_child with root, node3
    proc set_left_child with node2, node4
    proc set_right_child with node2, node5

    Note: After building, each node has refcount:
    Note: root: 1 (we own it)
    Note: node2: 2 (we own it + root owns it)
    Note: node3: 2 (we own it + root owns it)
    Note: node4: 2 (we own it + node2 owns it)
    Note: node5: 2 (we own it + node2 owns it)

    Note: Count nodes for verification
    Let node_count be proc count_nodes with root
    Note: node_count should be 5

    If node_count is not equal to 5:
        Note: FAILURE - Expected 5 nodes, got different count
        Return 1
    End If

    Note: ========================================
    Note: Cleanup
    Note: ========================================

    Note: Release our references to child nodes
    Note: (root owns them via strong references, so they won't be freed yet)
    proc arc_release from ARC with node2
    proc arc_release from ARC with node3
    proc arc_release from ARC with node4
    proc arc_release from ARC with node5

    Note: After releasing our references, refcounts are:
    Note: node2: 1 (only root owns it)
    Note: node3: 1 (only root owns it)
    Note: node4: 1 (only node2 owns it)
    Note: node5: 1 (only node2 owns it)

    Note: Recursively destroy tree
    proc destroy_tree_recursive with root

    Note: All nodes should now be freed

    Note: ========================================
    Note: Verification
    Note: ========================================

    Note: Check for leaks
    If proc arc_assert_no_leaks from ARCUtils is equal to 0:
        Note: FAILURE - Memory leak detected
        Return 1
    End If

    Note: Check balance
    If proc arc_assert_balanced from ARCUtils is equal to 0:
        Note: FAILURE - Retain/release imbalance
        Return 1
    End If

    Note: SUCCESS - Tree created and destroyed without leaks
    Return 0
End Process
