Note:
Example: Doubly-Linked List with Weak References

This example demonstrates:
- Using weak references to prevent reference cycles
- Creating bidirectional links safely
- Detecting potential cycles
- Proper cleanup of linked structures

Compile: runac 02_linked_list_weak.runa -o linked_list
Run: ./linked_list
Expected Output: No leaks, no cycles
:End Note

Import "runtime/core/memory/arc_heap.runa" as ARC
Import "runtime/stdlib/arc/arc_utils.runa" as ARCUtils

Note: ========================================
Note: Node Structure with Weak Back Reference
Note: ========================================

Note:
Doubly-linked list node with:
- Strong reference to next node (ownership)
- Weak reference to previous node (no ownership)

This prevents reference cycles:
  A --strong--> B --strong--> C
  A <--weak---- B <--weak---- C

Without weak references, we would have:
  A <--strong--> B <--strong--> C
  This creates a cycle: A retains B retains A (LEAK!)
:End Note

Type called "ListNode" with annotation @ARC:
    value as Integer                Note: Node data
    next as Integer                 Note: Strong reference to next node (ARC pointer)
    prev_weak as Integer            Note: Weak reference to previous node (weak pointer)
End Type

Process called "create_node" takes value as Integer returns Integer:
    Note:
    Create new list node

    Returns:
      Pointer to new ListNode (refcount = 1)
      Returns 0 on allocation failure
    :End Note

    Note: Allocate ListNode structure (24 bytes: value + next + prev_weak)
    Let node be proc arc_allocate from ARC with 24
    If node is equal to 0:
        Return 0
    End If

    Note: Initialize fields
    proc memory_set_int64 with node, 0, value
    proc memory_set_int64 with node, 8, 0     Note: next = NULL
    proc memory_set_int64 with node, 16, 0    Note: prev_weak = NULL

    Return node
End Process

Process called "link_nodes" takes prev as Integer, next as Integer returns Integer:
    Note:
    Link two nodes bidirectionally

    Parameters:
      prev - Previous node (strong reference)
      next - Next node (strong reference)

    Returns:
      1 on success, 0 on failure

    Links created:
      prev.next = next (strong - prev owns next)
      next.prev_weak = weak(prev) (weak - next does NOT own prev)

    This prevents cycles while maintaining bidirectional navigation
    :End Note

    If prev is equal to 0:
        Return 0
    End If

    If next is equal to 0:
        Return 0
    End If

    Note: Check for potential cycle (both nodes already have high refcounts)
    If proc arc_warn_potential_cycle from ARCUtils with prev, next is equal to 1:
        Note: WARNING - Potential cycle detected, using weak reference
    End If

    Note: Set prev.next = next (strong reference)
    Note: This increments next's refcount (prev now owns next)
    Let next_retained be proc arc_retain from ARC with next
    proc memory_set_int64 with prev, 8, next_retained

    Note: Set next.prev_weak = weak(prev) (weak reference)
    Note: This does NOT increment prev's refcount (next does NOT own prev)
    Let weak_prev be proc arc_weak_create from ARC with prev
    proc memory_set_int64 with next, 16, weak_prev

    Return 1
End Process

Process called "get_previous_node" takes node as Integer returns Integer:
    Note:
    Get previous node from weak reference

    Parameters:
      node - Current node

    Returns:
      Strong reference to previous node (if alive)
      Returns 0 if no previous node or node was deallocated

    IMPORTANT:
      Caller must call arc_release() on returned pointer when done
      Promotion increments refcount
    :End Note

    If node is equal to 0:
        Return 0
    End If

    Note: Get weak reference to previous node
    Let prev_weak be proc memory_get_int64 with node, 16

    If prev_weak is equal to 0:
        Return 0  Note: No previous node
    End If

    Note: Try to promote weak reference to strong
    Let prev_strong be proc arc_weak_promote from ARC with prev_weak

    If prev_strong is equal to 0:
        Note: Previous node was deallocated (weak reference is dead)
        Return 0
    End If

    Note: Successfully promoted - prev_strong now has refcount incremented
    Note: Caller MUST call arc_release(prev_strong) when done
    Return prev_strong
End Process

Process called "destroy_node" takes node as Integer returns Integer:
    Note:
    Destroy list node and cleanup references

    Parameters:
      node - Node to destroy

    Returns:
      1 on success

    Cleanup:
      - Releases strong reference to next node
      - Releases weak reference to previous node
      - Releases node itself
    :End Note

    If node is equal to 0:
        Return 1
    End If

    Note: Get next node (strong reference)
    Let next be proc memory_get_int64 with node, 8

    If next is not equal to 0:
        Note: Release strong reference to next
        proc arc_release from ARC with next
    End If

    Note: Get previous weak reference
    Let prev_weak be proc memory_get_int64 with node, 16

    If prev_weak is not equal to 0:
        Note: Release weak reference to previous
        proc arc_weak_release from ARC with prev_weak
    End If

    Note: Release the node itself
    proc arc_release from ARC with node

    Return 1
End Process

Process called "main" returns Integer:
    Note: Reset statistics
    proc arc_stats_reset from ARCUtils

    Note: ========================================
    Note: Create Doubly-Linked List: A <-> B <-> C
    Note: ========================================

    Note: Create three nodes
    Let node_a be proc create_node with 100
    Let node_b be proc create_node with 200
    Let node_c be proc create_node with 300

    Note: Link A <-> B
    proc link_nodes with node_a, node_b

    Note: Link B <-> C
    proc link_nodes with node_b, node_c

    Note: ========================================
    Note: Navigate Forward (Strong References)
    Note: ========================================

    Note: Navigate A -> B -> C using strong references
    Let current be node_a

    Note: Get B from A.next
    Let next be proc memory_get_int64 with current, 8
    Note: next is node_b (strong reference, no need to retain)

    Note: Get C from B.next
    Set current to next
    Set next to proc memory_get_int64 with current, 8
    Note: next is node_c

    Note: ========================================
    Note: Navigate Backward (Weak References)
    Note: ========================================

    Note: Navigate C -> B -> A using weak references
    Set current to node_c

    Note: Get B from C.prev_weak (must promote)
    Let prev be proc get_previous_node with current
    If prev is equal to 0:
        Note: FAILURE - Previous node not found
        Return 1
    End If
    Note: prev is node_b (promoted from weak)

    Note: Get A from B.prev_weak (must promote)
    Set current to prev
    Let prev2 be proc get_previous_node with current
    If prev2 is equal to 0:
        Note: FAILURE - Previous node not found
        proc arc_release from ARC with prev  Note: Cleanup prev
        Return 1
    End If
    Note: prev2 is node_a

    Note: Release promoted weak references
    proc arc_release from ARC with prev
    proc arc_release from ARC with prev2

    Note: ========================================
    Note: Cleanup
    Note: ========================================

    Note: Destroy nodes in reverse order (C, B, A)
    proc destroy_node with node_c
    proc destroy_node with node_b
    proc destroy_node with node_a

    Note: ========================================
    Note: Verification
    Note: ========================================

    Note: Check for leaks
    If proc arc_assert_no_leaks from ARCUtils is equal to 0:
        Note: FAILURE - Memory leak detected
        Return 1
    End If

    Note: Check balance
    If proc arc_assert_balanced from ARCUtils is equal to 0:
        Note: FAILURE - Retain/release imbalance
        Return 1
    End If

    Note: SUCCESS - No leaks, no cycles
    Return 0
End Process
