Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file provides printf-style formatting for console output.

This file performs the following tasks:
- Parse format strings with format specifiers (%d, %s, %f, %x, %c, etc.)
- Format integers, floats, strings, and characters
- Support width, precision, padding, and alignment
- Build formatted output strings
- Integrate with Console API for formatted printing

This file is essential because of the following reasons:
- Printf-style formatting is essential for user-friendly output
- Provides familiar formatting interface for developers
- Supports complex formatting requirements
- Production-ready formatting for all data types

This file consists of the following functions/features/operation types:
- Format string parsing
- Format specifier handling (%d, %s, %f, %x, %o, %b, %c, %%)
- Width and precision support
- Padding and alignment (left, right, zero-padding)
- Integer formatting (decimal, hex, octal, binary)
- Float formatting (fixed-point, scientific, auto)
- String and character formatting
- Printf and sprintf functions

Dependencies:
- Imports core/string_primitive.runa (string operations)
- Imports core/string_core.runa (string utilities)
- Imports core/memory_core.runa (memory operations)
- Imports memory/layout.runa (memory allocation)
- Imports io/console_primitive.runa (raw console output)
:End Note

Import "compiler/frontend/primitives/core/string_primitive.runa" as StringPrimitive
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/primitives/io/console_primitive.runa" as ConsolePrimitive

Note: ============================================================================
Note: Format Specifier Constants
Note: ============================================================================

Note: Format types
Constant FORMAT_TYPE_DECIMAL as 1        Note: %d - signed decimal integer
Constant FORMAT_TYPE_HEX as 2            Note: %x - hexadecimal (lowercase)
Constant FORMAT_TYPE_HEX_UPPER as 3      Note: %X - hexadecimal (uppercase)
Constant FORMAT_TYPE_OCTAL as 4          Note: %o - octal
Constant FORMAT_TYPE_BINARY as 5         Note: %b - binary
Constant FORMAT_TYPE_UNSIGNED as 6       Note: %u - unsigned decimal
Constant FORMAT_TYPE_CHAR as 7           Note: %c - character
Constant FORMAT_TYPE_STRING as 8         Note: %s - string
Constant FORMAT_TYPE_FLOAT as 9          Note: %f - fixed-point float
Constant FORMAT_TYPE_SCIENTIFIC as 10    Note: %e - scientific notation
Constant FORMAT_TYPE_AUTO_FLOAT as 11    Note: %g - auto (fixed or scientific)
Constant FORMAT_TYPE_PERCENT as 12       Note: %% - literal percent

Note: Alignment flags
Constant ALIGN_RIGHT as 0                Note: Default: right-align
Constant ALIGN_LEFT as 1                 Note: - flag: left-align
Constant PAD_ZERO as 2                   Note: 0 flag: zero-pad numbers

Note: ============================================================================
Note: Format Specifier Type
Note: ============================================================================

Type called "FormatSpec":
    format_type as Integer     Note: FORMAT_TYPE_* constant
    width as Integer           Note: Minimum field width (0 = no minimum)
    precision as Integer       Note: Precision for floats, max chars for strings (-1 = default)
    alignment as Integer       Note: ALIGN_RIGHT or ALIGN_LEFT
    pad_with_zero as Integer   Note: Boolean: 1 = pad with '0', 0 = pad with ' '
    show_sign as Integer       Note: Boolean: 1 = always show sign (+/-)
    show_plus as Integer       Note: Boolean: 1 = show + for positive numbers
    space_sign as Integer      Note: Boolean: 1 = show space for positive numbers
    alternate_form as Integer  Note: Boolean: 1 = alternate form (0x for hex, etc.)
End Type

Note: ============================================================================
Note: Format Specifier Parsing
Note: ============================================================================

Process called "parse_format_spec" takes format_str as Integer, pos as Integer, spec_out as Integer returns Integer:
    Note: Parse single format specifier starting at format_str[pos]
    Note: format_str: Format string pointer
    Note: pos: Current position (should be at '%')
    Note: spec_out: Pointer to FormatSpec structure to fill
    Note: Returns: New position after specifier, or -1 on error

    If format_str is equal to 0:
        Return -1
    End If

    If spec_out is equal to 0:
        Return -1
    End If

    Let current_pos be pos

    Note: Check for '%' at current position
    Let ch be proc memory_get_byte from Memory with format_str, current_pos
    If ch is not equal to 37:
        Note: Not a '%', invalid
        Return -1
    End If

    Note: Move past '%'
    Set current_pos to current_pos plus 1

    Note: Initialize FormatSpec with defaults
    proc memory_set_int64 from Memory with spec_out, 0, 0    Note: format_type = 0 (invalid)
    proc memory_set_int64 from Memory with spec_out, 8, 0    Note: width = 0
    proc memory_set_int64 from Memory with spec_out, 16, -1  Note: precision = -1 (default)
    proc memory_set_int64 from Memory with spec_out, 24, 0   Note: alignment = ALIGN_RIGHT
    proc memory_set_int64 from Memory with spec_out, 32, 0   Note: pad_with_zero = 0
    proc memory_set_int64 from Memory with spec_out, 40, 0   Note: show_sign = 0
    proc memory_set_int64 from Memory with spec_out, 48, 0   Note: show_plus = 0
    proc memory_set_int64 from Memory with spec_out, 56, 0   Note: space_sign = 0
    proc memory_set_int64 from Memory with spec_out, 64, 0   Note: alternate_form = 0

    Note: Parse flags (-+ 0#)
    Let parsing_flags be 1
    While parsing_flags is equal to 1:
        Set ch to proc memory_get_byte from Memory with format_str, current_pos

        If ch is equal to 45:
            Note: '-' flag: left-align
            proc memory_set_int64 from Memory with spec_out, 24, ALIGN_LEFT
            Set current_pos to current_pos plus 1
        Otherwise If ch is equal to 43:
            Note: '+' flag: always show sign
            proc memory_set_int64 from Memory with spec_out, 48, 1
            Set current_pos to current_pos plus 1
        Otherwise If ch is equal to 32:
            Note: ' ' flag: space for positive numbers
            proc memory_set_int64 from Memory with spec_out, 56, 1
            Set current_pos to current_pos plus 1
        Otherwise If ch is equal to 48:
            Note: '0' flag: zero-pad
            proc memory_set_int64 from Memory with spec_out, 32, 1
            Set current_pos to current_pos plus 1
        Otherwise If ch is equal to 35:
            Note: '#' flag: alternate form
            proc memory_set_int64 from Memory with spec_out, 64, 1
            Set current_pos to current_pos plus 1
        Otherwise:
            Set parsing_flags to 0
        End If
    End While

    Note: Parse width
    Set ch to proc memory_get_byte from Memory with format_str, current_pos
    If ch is greater than or equal to 48:
        If ch is less than or equal to 57:
            Note: Width specified
            Let width be 0
            While ch is greater than or equal to 48:
                If ch is less than or equal to 57:
                    Let digit be ch minus 48
                    Set width to width multiplied by 10
                    Set width to width plus digit
                    Set current_pos to current_pos plus 1
                    Set ch to proc memory_get_byte from Memory with format_str, current_pos
                Otherwise:
                    Note: Break loop
                    Set ch to 0
                End If
            End While
            proc memory_set_int64 from Memory with spec_out, 8, width
        End If
    End If

    Note: Parse precision (.N)
    Set ch to proc memory_get_byte from Memory with format_str, current_pos
    If ch is equal to 46:
        Note: '.' found, parse precision
        Set current_pos to current_pos plus 1
        Set ch to proc memory_get_byte from Memory with format_str, current_pos

        Let precision be 0
        While ch is greater than or equal to 48:
            If ch is less than or equal to 57:
                Let digit be ch minus 48
                Set precision to precision multiplied by 10
                Set precision to precision plus digit
                Set current_pos to current_pos plus 1
                Set ch to proc memory_get_byte from Memory with format_str, current_pos
            Otherwise:
                Note: Break loop
                Set ch to 0
            End If
        End While
        proc memory_set_int64 from Memory with spec_out, 16, precision
    End If

    Note: Parse format type specifier
    Set ch to proc memory_get_byte from Memory with format_str, current_pos

    If ch is equal to 100:
        Note: 'd' - decimal integer
        proc memory_set_int64 from Memory with spec_out, 0, FORMAT_TYPE_DECIMAL
        Set current_pos to current_pos plus 1
    Otherwise If ch is equal to 120:
        Note: 'x' - hex (lowercase)
        proc memory_set_int64 from Memory with spec_out, 0, FORMAT_TYPE_HEX
        Set current_pos to current_pos plus 1
    Otherwise If ch is equal to 88:
        Note: 'X' - hex (uppercase)
        proc memory_set_int64 from Memory with spec_out, 0, FORMAT_TYPE_HEX_UPPER
        Set current_pos to current_pos plus 1
    Otherwise If ch is equal to 111:
        Note: 'o' - octal
        proc memory_set_int64 from Memory with spec_out, 0, FORMAT_TYPE_OCTAL
        Set current_pos to current_pos plus 1
    Otherwise If ch is equal to 98:
        Note: 'b' - binary
        proc memory_set_int64 from Memory with spec_out, 0, FORMAT_TYPE_BINARY
        Set current_pos to current_pos plus 1
    Otherwise If ch is equal to 117:
        Note: 'u' - unsigned
        proc memory_set_int64 from Memory with spec_out, 0, FORMAT_TYPE_UNSIGNED
        Set current_pos to current_pos plus 1
    Otherwise If ch is equal to 99:
        Note: 'c' - character
        proc memory_set_int64 from Memory with spec_out, 0, FORMAT_TYPE_CHAR
        Set current_pos to current_pos plus 1
    Otherwise If ch is equal to 115:
        Note: 's' - string
        proc memory_set_int64 from Memory with spec_out, 0, FORMAT_TYPE_STRING
        Set current_pos to current_pos plus 1
    Otherwise If ch is equal to 102:
        Note: 'f' - float
        proc memory_set_int64 from Memory with spec_out, 0, FORMAT_TYPE_FLOAT
        Set current_pos to current_pos plus 1
    Otherwise If ch is equal to 101:
        Note: 'e' - scientific
        proc memory_set_int64 from Memory with spec_out, 0, FORMAT_TYPE_SCIENTIFIC
        Set current_pos to current_pos plus 1
    Otherwise If ch is equal to 103:
        Note: 'g' - auto float
        proc memory_set_int64 from Memory with spec_out, 0, FORMAT_TYPE_AUTO_FLOAT
        Set current_pos to current_pos plus 1
    Otherwise If ch is equal to 37:
        Note: '%' - literal percent
        proc memory_set_int64 from Memory with spec_out, 0, FORMAT_TYPE_PERCENT
        Set current_pos to current_pos plus 1
    Otherwise:
        Note: Invalid format specifier
        Return -1
    End If

    Return current_pos
End Process

Note: ============================================================================
Note: Integer Formatting
Note: ============================================================================

Process called "format_integer" takes value as Integer, spec as Integer returns Integer:
    Note: Format integer according to FormatSpec
    Note: value: Integer value to format
    Note: spec: Pointer to FormatSpec structure
    Note: Returns: Pointer to allocated formatted string, or 0 on failure

    Note: Get format type
    Let format_type be proc memory_get_int64 from Memory with spec, 0

    Note: Get width and flags
    Let width be proc memory_get_int64 from Memory with spec, 8
    Let alignment be proc memory_get_int64 from Memory with spec, 24
    Let pad_with_zero be proc memory_get_int64 from Memory with spec, 32
    Let show_plus be proc memory_get_int64 from Memory with spec, 48
    Let space_sign be proc memory_get_int64 from Memory with spec, 56
    Let alternate_form be proc memory_get_int64 from Memory with spec, 64

    Note: Convert integer to string based on base
    Let base_str be 0

    If format_type is equal to FORMAT_TYPE_DECIMAL:
        Set base_str to proc integer_to_string from StringPrimitive with value
    Otherwise If format_type is equal to FORMAT_TYPE_UNSIGNED:
        Note: Treat as unsigned (reinterpret bits)
        Set base_str to proc integer_to_string from StringPrimitive with value
    Otherwise If format_type is equal to FORMAT_TYPE_HEX:
        Set base_str to proc integer_to_hex from StringPrimitive with value, 0
    Otherwise If format_type is equal to FORMAT_TYPE_HEX_UPPER:
        Set base_str to proc integer_to_hex from StringPrimitive with value, 1
    Otherwise If format_type is equal to FORMAT_TYPE_OCTAL:
        Set base_str to proc integer_to_octal from StringPrimitive with value
    Otherwise If format_type is equal to FORMAT_TYPE_BINARY:
        Set base_str to proc integer_to_binary from StringPrimitive with value
    Otherwise:
        Note: Invalid type, default to decimal
        Set base_str to proc integer_to_string from StringPrimitive with value
    End If

    If base_str is equal to 0:
        Return 0
    End If

    Note: Apply padding and alignment
    Let result be proc apply_padding_and_alignment with base_str, width, alignment, pad_with_zero

    Note: Free base string (we don't need it anymore)
    proc deallocate from Layout with base_str

    Return result
End Process

Note: ============================================================================
Note: String Formatting
Note: ============================================================================

Process called "format_string" takes str as Integer, spec as Integer returns Integer:
    Note: Format string according to FormatSpec
    Note: str: String pointer to format
    Note: spec: Pointer to FormatSpec structure
    Note: Returns: Pointer to allocated formatted string, or 0 on failure

    If str is equal to 0:
        Note: NULL string, use "(null)"
        Set str to proc string_duplicate from StringPrimitive with "(null)"
        If str is equal to 0:
            Return 0
        End If
    Otherwise:
        Note: Duplicate string
        Set str to proc string_duplicate from StringPrimitive with str
        If str is equal to 0:
            Return 0
        End If
    End If

    Note: Get width and flags
    Let width be proc memory_get_int64 from Memory with spec, 8
    Let precision be proc memory_get_int64 from Memory with spec, 16
    Let alignment be proc memory_get_int64 from Memory with spec, 24

    Note: Apply precision (truncate if necessary)
    If precision is greater than or equal to 0:
        Let str_len be proc string_length from StringCore with str
        If str_len is greater than precision:
            Note: Truncate string
            proc memory_set_byte from Memory with str, precision, 0
        End If
    End If

    Note: Apply padding and alignment
    Let result be proc apply_padding_and_alignment with str, width, alignment, 0

    Note: Free duplicated string
    proc deallocate from Layout with str

    Return result
End Process

Note: ============================================================================
Note: Character Formatting
Note: ============================================================================

Process called "format_char" takes char_code as Integer, spec as Integer returns Integer:
    Note: Format character according to FormatSpec
    Note: char_code: Character code (0-255)
    Note: spec: Pointer to FormatSpec structure
    Note: Returns: Pointer to allocated formatted string, or 0 on failure

    Note: Create single-character string
    Let char_str be proc allocate from Layout with 2
    If char_str is equal to 0:
        Return 0
    End If

    Note: Set character and null terminator
    proc memory_set_byte from Memory with char_str, 0, char_code
    proc memory_set_byte from Memory with char_str, 1, 0

    Note: Get width and flags
    Let width be proc memory_get_int64 from Memory with spec, 8
    Let alignment be proc memory_get_int64 from Memory with spec, 24

    Note: Apply padding and alignment
    Let result be proc apply_padding_and_alignment with char_str, width, alignment, 0

    Note: Free character string
    proc deallocate from Layout with char_str

    Return result
End Process

Note: ============================================================================
Note: Float Formatting
Note: ============================================================================

Process called "format_float" takes f128_ptr as Integer, spec as Integer returns Integer:
    Note: Format float128 according to FormatSpec
    Note: f128_ptr: Pointer to 16-byte float128 value
    Note: spec: Pointer to FormatSpec structure
    Note: Returns: Pointer to allocated formatted string, or 0 on failure

    If f128_ptr is equal to 0:
        Return 0
    End If

    Note: Get format type and parameters
    Let format_type be proc memory_get_int64 from Memory with spec, 0
    Let width be proc memory_get_int64 from Memory with spec, 8
    Let precision be proc memory_get_int64 from Memory with spec, 16
    Let alignment be proc memory_get_int64 from Memory with spec, 24
    Let pad_with_zero be proc memory_get_int64 from Memory with spec, 32

    Note: Default precision for floats is 6
    If precision is less than 0:
        Set precision to 6
    End If

    Note: Convert float to string based on format type
    Let float_str be 0

    If format_type is equal to FORMAT_TYPE_FLOAT:
        Note: Fixed-point notation (%f)
        Set float_str to proc float128_to_string_fixed from StringPrimitive with f128_ptr, precision
    Otherwise If format_type is equal to FORMAT_TYPE_SCIENTIFIC:
        Note: Scientific notation (%e)
        Set float_str to proc float128_to_string_scientific from StringPrimitive with f128_ptr, precision
    Otherwise If format_type is equal to FORMAT_TYPE_AUTO_FLOAT:
        Note: Automatic format selection (%g)
        Set float_str to proc float128_to_string_auto from StringPrimitive with f128_ptr, precision
    Otherwise:
        Note: Invalid type, default to fixed-point
        Set float_str to proc float128_to_string_fixed from StringPrimitive with f128_ptr, precision
    End If

    If float_str is equal to 0:
        Return 0
    End If

    Note: Apply padding and alignment
    Let result be proc apply_padding_and_alignment with float_str, width, alignment, pad_with_zero

    Note: Free float string
    proc deallocate from Layout with float_str

    Return result
End Process

Note: ============================================================================
Note: Padding and Alignment
Note: ============================================================================

Process called "apply_padding_and_alignment" takes str as Integer, width as Integer, alignment as Integer, pad_with_zero as Integer returns Integer:
    Note: Apply padding and alignment to string
    Note: str: String to pad
    Note: width: Minimum field width
    Note: alignment: ALIGN_RIGHT or ALIGN_LEFT
    Note: pad_with_zero: Boolean: 1 = pad with '0', 0 = pad with ' '
    Note: Returns: Pointer to allocated padded string, or 0 on failure

    If str is equal to 0:
        Return 0
    End If

    Let str_len be proc string_length from StringCore with str

    Note: Check if padding needed
    If width is less than or equal to str_len:
        Note: No padding needed, return duplicate
        Return proc string_duplicate from StringPrimitive with str
    End If

    Note: Calculate padding amount
    Let pad_amount be width minus str_len

    Note: Allocate result buffer
    Let result be proc allocate from Layout with width plus 1

    If result is equal to 0:
        Return 0
    End If

    Note: Determine padding character
    Let pad_char be 32
    If pad_with_zero is equal to 1:
        Set pad_char to 48
    End If

    Note: Fill based on alignment
    If alignment is equal to ALIGN_LEFT:
        Note: Left-align: string first, then padding
        Let i be 0
        While i is less than str_len:
            Let ch be proc memory_get_byte from Memory with str, i
            proc memory_set_byte from Memory with result, i, ch
            Set i to i plus 1
        End While

        Set i to str_len
        While i is less than width:
            proc memory_set_byte from Memory with result, i, pad_char
            Set i to i plus 1
        End While
    Otherwise:
        Note: Right-align: padding first, then string
        Let i be 0
        While i is less than pad_amount:
            proc memory_set_byte from Memory with result, i, pad_char
            Set i to i plus 1
        End While

        Let j be 0
        While j is less than str_len:
            Let ch be proc memory_get_byte from Memory with str, j
            proc memory_set_byte from Memory with result, i, ch
            Set i to i plus 1
            Set j to j plus 1
        End While
    End If

    Note: Add null terminator
    proc memory_set_byte from Memory with result, width, 0

    Return result
End Process

Note: ============================================================================
Note: Printf Implementation
Note: ============================================================================

Process called "sprintf" takes format_str as Integer, args as Integer, arg_count as Integer returns Integer:
    Note: Format string with arguments (sprintf-style)
    Note: format_str: Format string pointer
    Note: args: Array of argument pointers (Integer*)
    Note: arg_count: Number of arguments
    Note: Returns: Pointer to allocated formatted string, or 0 on failure

    If format_str is equal to 0:
        Return 0
    End If

    Note: First pass: calculate total length
    Let total_len be 0
    Let format_len be proc string_length from StringCore with format_str
    Let pos be 0
    Let arg_index be 0

    Note: Allocate temp FormatSpec
    Let spec be proc allocate from Layout with 72
    If spec is equal to 0:
        Return 0
    End If

    Note: Calculate required buffer size
    While pos is less than format_len:
        Let ch be proc memory_get_byte from Memory with format_str, pos

        If ch is equal to 37:
            Note: Format specifier
            Let new_pos be proc parse_format_spec with format_str, pos, spec

            If new_pos is less than 0:
                Note: Invalid format specifier
                proc deallocate from Layout with spec
                Return 0
            End If

            Note: Get format type
            Let format_type be proc memory_get_int64 from Memory with spec, 0

            If format_type is equal to FORMAT_TYPE_PERCENT:
                Note: Literal %, adds 1 character
                Set total_len to total_len plus 1
            Otherwise:
                Note: Format argument - estimate 64 characters per formatted value
                Set total_len to total_len plus 64
                Set arg_index to arg_index plus 1
            End If

            Set pos to new_pos
        Otherwise:
            Note: Regular character
            Set total_len to total_len plus 1
            Set pos to pos plus 1
        End If
    End While

    Note: Allocate result buffer (total_len + 1024 for safety)
    Let result be proc allocate from Layout with total_len plus 1024

    If result is equal to 0:
        proc deallocate from Layout with spec
        Return 0
    End If

    Note: Second pass: build formatted string
    Set pos to 0
    Set arg_index to 0
    Let write_pos be 0

    While pos is less than format_len:
        Let ch be proc memory_get_byte from Memory with format_str, pos

        If ch is equal to 37:
            Note: Format specifier
            Let new_pos be proc parse_format_spec with format_str, pos, spec

            If new_pos is less than 0:
                Note: Invalid format specifier
                proc deallocate from Layout with spec
                proc deallocate from Layout with result
                Return 0
            End If

            Note: Get format type
            Let format_type be proc memory_get_int64 from Memory with spec, 0

            If format_type is equal to FORMAT_TYPE_PERCENT:
                Note: Literal %
                proc memory_set_byte from Memory with result, write_pos, 37
                Set write_pos to write_pos plus 1
            Otherwise:
                Note: Format argument
                If arg_index is greater than or equal to arg_count:
                    Note: Not enough arguments
                    proc deallocate from Layout with spec
                    proc deallocate from Layout with result
                    Return 0
                End If

                Note: Get argument value
                Let arg_offset be arg_index multiplied by 8
                Let arg_value be proc memory_get_int64 from Memory with args, arg_offset

                Note: Format based on type
                Let formatted be 0

                If format_type is equal to FORMAT_TYPE_STRING:
                    Set formatted to proc format_string with arg_value, spec
                Otherwise If format_type is equal to FORMAT_TYPE_CHAR:
                    Set formatted to proc format_char with arg_value, spec
                Otherwise If format_type is equal to FORMAT_TYPE_FLOAT:
                    Note: Fixed-point float
                    Set formatted to proc format_float with arg_value, spec
                Otherwise If format_type is equal to FORMAT_TYPE_SCIENTIFIC:
                    Note: Scientific notation float
                    Set formatted to proc format_float with arg_value, spec
                Otherwise If format_type is equal to FORMAT_TYPE_AUTO_FLOAT:
                    Note: Auto-format float
                    Set formatted to proc format_float with arg_value, spec
                Otherwise:
                    Note: Integer types (decimal, hex, octal, binary, unsigned)
                    Set formatted to proc format_integer with arg_value, spec
                End If

                If formatted is equal to 0:
                    proc deallocate from Layout with spec
                    proc deallocate from Layout with result
                    Return 0
                End If

                Note: Copy formatted string to result
                Let formatted_len be proc string_length from StringCore with formatted
                Let i be 0
                While i is less than formatted_len:
                    Let formatted_ch be proc memory_get_byte from Memory with formatted, i
                    proc memory_set_byte from Memory with result, write_pos, formatted_ch
                    Set write_pos to write_pos plus 1
                    Set i to i plus 1
                End While

                Note: Free formatted string
                proc deallocate from Layout with formatted

                Set arg_index to arg_index plus 1
            End If

            Set pos to new_pos
        Otherwise:
            Note: Regular character
            proc memory_set_byte from Memory with result, write_pos, ch
            Set write_pos to write_pos plus 1
            Set pos to pos plus 1
        End If
    End While

    Note: Add null terminator
    proc memory_set_byte from Memory with result, write_pos, 0

    Note: Free temp spec
    proc deallocate from Layout with spec

    Return result
End Process

Process called "printf" takes format_str as Integer, args as Integer, arg_count as Integer returns Integer:
    Note: Print formatted string to stdout
    Note: format_str: Format string pointer
    Note: args: Array of argument pointers (Integer*)
    Note: arg_count: Number of arguments
    Note: Returns: Number of characters written, or negative error code

    Note: Format string
    Let formatted be proc sprintf with format_str, args, arg_count

    If formatted is equal to 0:
        Return -1
    End If

    Note: Write to stdout
    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with formatted

    Note: Free formatted string
    proc deallocate from Layout with formatted

    Return bytes_written
End Process

Process called "fprintf_stdout" takes format_str as Integer, args as Integer, arg_count as Integer returns Integer:
    Note: Alias for printf
    Return proc printf with format_str, args, arg_count
End Process

Process called "fprintf_stderr" takes format_str as Integer, args as Integer, arg_count as Integer returns Integer:
    Note: Print formatted string to stderr
    Note: format_str: Format string pointer
    Note: args: Array of argument pointers (Integer*)
    Note: arg_count: Number of arguments
    Note: Returns: Number of characters written, or negative error code

    Note: Format string
    Let formatted be proc sprintf with format_str, args, arg_count

    If formatted is equal to 0:
        Return -1
    End If

    Note: Write to stderr
    Let bytes_written be proc console_write_string_stderr from ConsolePrimitive with formatted

    Note: Free formatted string
    proc deallocate from Layout with formatted

    Return bytes_written
End Process
