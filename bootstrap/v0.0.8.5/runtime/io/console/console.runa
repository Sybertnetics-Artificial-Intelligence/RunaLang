Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file provides the high-level Console API for Runa programs.

This file performs the following tasks:
- Provide user-facing Console API for standard I/O
- Manage console handles (stdin, stdout, stderr)
- Provide buffered and unbuffered I/O operations
- Handle console state (terminal detection, size)
- Provide convenient methods (write, writeln, read, readln)

This file is essential because of the following reasons:
- User programs need simple, intuitive console I/O
- Provides high-level abstraction over raw primitives
- Handles common console operations with minimal boilerplate
- Production-ready interface for Runa applications

This file consists of the following functions/features/operation types:
- Console type and initialization
- Write operations (write, writeln, writeErr, writelnErr)
- Read operations (read, readln, readChar)
- Console state queries (isTTY, getSize)
- Flush operations
- Buffering control

Dependencies:
- Imports io/io_core.runa (IOHandle, IOBuffer, IOResult types)
- Imports io/console_primitive.runa (raw console operations)
- Imports core/string_primitive.runa (string operations)
- Imports memory/layout.runa (memory allocation)
:End Note

Import "compiler/frontend/primitives/io/io_core.runa" as IOCore
Import "compiler/frontend/primitives/io/console_primitive.runa" as ConsolePrimitive
Import "compiler/frontend/primitives/core/string_primitive.runa" as StringPrimitive
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
Import "compiler/frontend/primitives/memory/layout.runa" as Layout

Note: ============================================================================
Note: Console Type Definition
Note: ============================================================================

Type called "Console":
    stdin_handle as Integer       Note: IOHandle pointer for stdin
    stdout_handle as Integer      Note: IOHandle pointer for stdout
    stderr_handle as Integer      Note: IOHandle pointer for stderr
    stdin_is_tty as Integer       Note: Boolean: 1 if stdin is TTY
    stdout_is_tty as Integer      Note: Boolean: 1 if stdout is TTY
    stderr_is_tty as Integer      Note: Boolean: 1 if stderr is TTY
    terminal_width as Integer     Note: Terminal columns (if TTY)
    terminal_height as Integer    Note: Terminal rows (if TTY)
    auto_flush as Integer         Note: Boolean: 1 to auto-flush after each write
End Type

Note: ============================================================================
Note: Console Initialization
Note: ============================================================================

Process called "Console_create" returns Integer:
    Note: Create and initialize Console instance
    Note: Returns: Pointer to Console instance, or 0 on failure

    Note: Allocate Console structure
    Let console be proc allocate from Layout with 72
    If console is equal to 0:
        Return 0
    End If

    Note: Create stdin handle
    Let stdin_handle be proc console_create_stdin_handle from ConsolePrimitive
    If stdin_handle is equal to 0:
        proc deallocate from Layout with console
        Return 0
    End If

    Note: Create stdout handle
    Let stdout_handle be proc console_create_stdout_handle from ConsolePrimitive
    If stdout_handle is equal to 0:
        proc io_handle_destroy from IOCore with stdin_handle
        proc deallocate from Layout with console
        Return 0
    End If

    Note: Create stderr handle
    Let stderr_handle be proc console_create_stderr_handle from ConsolePrimitive
    If stderr_handle is equal to 0:
        proc io_handle_destroy from IOCore with stdout_handle
        proc io_handle_destroy from IOCore with stdin_handle
        proc deallocate from Layout with console
        Return 0
    End If

    Note: Store handles
    proc memory_set_int64 from Memory with console, 0, stdin_handle
    proc memory_set_int64 from Memory with console, 8, stdout_handle
    proc memory_set_int64 from Memory with console, 16, stderr_handle

    Note: Detect TTY status
    Let stdin_is_tty be proc console_stdin_is_tty from ConsolePrimitive
    Let stdout_is_tty be proc console_stdout_is_tty from ConsolePrimitive
    Let stderr_is_tty be proc console_stderr_is_tty from ConsolePrimitive

    proc memory_set_int64 from Memory with console, 24, stdin_is_tty
    proc memory_set_int64 from Memory with console, 32, stdout_is_tty
    proc memory_set_int64 from Memory with console, 40, stderr_is_tty

    Note: Get terminal size (if stdout is TTY)
    Let terminal_width be 80
    Let terminal_height be 24

    If stdout_is_tty is equal to 1:
        Note: Allocate temp storage for width/height
        Let width_storage be proc allocate from Layout with 8
        Let height_storage be proc allocate from Layout with 8

        If width_storage is not equal to 0:
            If height_storage is not equal to 0:
                Note: Get terminal size
                Let stdout_fd be proc io_handle_get_descriptor from IOCore with stdout_handle
                Let size_result be proc console_get_terminal_size from ConsolePrimitive with stdout_fd, width_storage, height_storage

                If size_result is equal to 1:
                    Set terminal_width to proc memory_get_int64 from Memory with width_storage, 0
                    Set terminal_height to proc memory_get_int64 from Memory with height_storage, 0
                End If

                proc deallocate from Layout with height_storage
            End If
            proc deallocate from Layout with width_storage
        End If
    End If

    proc memory_set_int64 from Memory with console, 48, terminal_width
    proc memory_set_int64 from Memory with console, 56, terminal_height

    Note: Set auto-flush to true by default for interactive terminals
    Let auto_flush be 0
    If stdout_is_tty is equal to 1:
        Set auto_flush to 1
    End If
    proc memory_set_int64 from Memory with console, 64, auto_flush

    Return console
End Process

Process called "Console_destroy" takes console as Integer returns Integer:
    Note: Destroy Console instance and free resources
    Note: Returns: 1 on success, 0 on failure

    If console is equal to 0:
        Return 0
    End If

    Note: Get handles
    Let stdin_handle be proc memory_get_int64 from Memory with console, 0
    Let stdout_handle be proc memory_get_int64 from Memory with console, 8
    Let stderr_handle be proc memory_get_int64 from Memory with console, 16

    Note: Flush output streams before closing
    If stdout_handle is not equal to 0:
        proc Console_flush with console
    End If

    If stderr_handle is not equal to 0:
        proc Console_flushErr with console
    End If

    Note: Destroy handles
    If stdin_handle is not equal to 0:
        proc io_handle_destroy from IOCore with stdin_handle
    End If

    If stdout_handle is not equal to 0:
        proc io_handle_destroy from IOCore with stdout_handle
    End If

    If stderr_handle is not equal to 0:
        proc io_handle_destroy from IOCore with stderr_handle
    End If

    Note: Free console structure
    proc deallocate from Layout with console

    Return 1
End Process

Note: ============================================================================
Note: Console State Queries
Note: ============================================================================

Process called "Console_isTTY" takes console as Integer returns Integer:
    Note: Check if stdout is a terminal
    Note: Returns: 1 if TTY, 0 if not

    If console is equal to 0:
        Return 0
    End If

    Return proc memory_get_int64 from Memory with console, 32
End Process

Process called "Console_stdinIsTTY" takes console as Integer returns Integer:
    Note: Check if stdin is a terminal
    Note: Returns: 1 if TTY, 0 if not

    If console is equal to 0:
        Return 0
    End If

    Return proc memory_get_int64 from Memory with console, 24
End Process

Process called "Console_stderrIsTTY" takes console as Integer returns Integer:
    Note: Check if stderr is a terminal
    Note: Returns: 1 if TTY, 0 if not

    If console is equal to 0:
        Return 0
    End If

    Return proc memory_get_int64 from Memory with console, 40
End Process

Process called "Console_getWidth" takes console as Integer returns Integer:
    Note: Get terminal width (columns)
    Note: Returns: Width in columns, or 80 if not a TTY

    If console is equal to 0:
        Return 80
    End If

    Return proc memory_get_int64 from Memory with console, 48
End Process

Process called "Console_getHeight" takes console as Integer returns Integer:
    Note: Get terminal height (rows)
    Note: Returns: Height in rows, or 24 if not a TTY

    If console is equal to 0:
        Return 24
    End If

    Return proc memory_get_int64 from Memory with console, 56
End Process

Process called "Console_setAutoFlush" takes console as Integer, enabled as Integer returns Integer:
    Note: Enable or disable auto-flush after each write
    Note: enabled: 1 to enable, 0 to disable
    Note: Returns: 1 on success, 0 on failure

    If console is equal to 0:
        Return 0
    End If

    Note: Normalize to 0 or 1
    Let normalized be 0
    If enabled is not equal to 0:
        Set normalized to 1
    End If

    proc memory_set_int64 from Memory with console, 64, normalized
    Return 1
End Process

Process called "Console_isAutoFlush" takes console as Integer returns Integer:
    Note: Check if auto-flush is enabled
    Note: Returns: 1 if enabled, 0 if disabled

    If console is equal to 0:
        Return 0
    End If

    Return proc memory_get_int64 from Memory with console, 64
End Process

Note: ============================================================================
Note: Write Operations (stdout)
Note: ============================================================================

Process called "Console_write" takes console as Integer, message as Integer returns Integer:
    Note: Write string to stdout
    Note: message: Pointer to null-terminated string
    Note: Returns: IOResult pointer

    If console is equal to 0:
        Return proc io_result_error from IOCore with proc IO_ERROR_INVALID_HANDLE from IOCore, 0
    End If

    If message is equal to 0:
        Return proc io_result_error from IOCore with proc IO_ERROR_INVALID_ARGUMENT from IOCore, 0
    End If

    Note: Write using primitive
    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with message

    Note: Check for error
    If bytes_written is less than 0:
        Note: Convert error code to IOResult
        Let error_code be 0 minus bytes_written
        Return proc io_result_error from IOCore with error_code, 0
    End If

    Note: Auto-flush if enabled
    Let auto_flush be proc Console_isAutoFlush with console
    If auto_flush is equal to 1:
        proc Console_flush with console
    End If

    Return proc io_result_success from IOCore with bytes_written
End Process

Process called "Console_writeln" takes console as Integer, message as Integer returns Integer:
    Note: Write string + newline to stdout
    Note: message: Pointer to null-terminated string (can be NULL for just newline)
    Note: Returns: IOResult pointer

    If console is equal to 0:
        Return proc io_result_error from IOCore with proc IO_ERROR_INVALID_HANDLE from IOCore, 0
    End If

    Note: Write using primitive (handles NULL message)
    Let bytes_written be proc console_writeln_stdout from ConsolePrimitive with message

    Note: Check for error
    If bytes_written is less than 0:
        Note: Convert error code to IOResult
        Let error_code be 0 minus bytes_written
        Return proc io_result_error from IOCore with error_code, 0
    End If

    Note: Auto-flush if enabled (or always flush on newline for line-buffered)
    Let auto_flush be proc Console_isAutoFlush with console
    If auto_flush is equal to 1:
        proc Console_flush with console
    End If

    Return proc io_result_success from IOCore with bytes_written
End Process

Process called "Console_flush" takes console as Integer returns Integer:
    Note: Flush stdout buffer
    Note: Returns: IOResult pointer

    If console is equal to 0:
        Return proc io_result_error from IOCore with proc IO_ERROR_INVALID_HANDLE from IOCore, 0
    End If

    Note: Flush using primitive
    Let flush_result be proc console_flush_stdout from ConsolePrimitive

    If flush_result is equal to 0:
        Return proc io_result_error from IOCore with proc IO_ERROR_IO_FAILURE from IOCore, 0
    End If

    Return proc io_result_success from IOCore with 0
End Process

Note: ============================================================================
Note: Write Operations (stderr)
Note: ============================================================================

Process called "Console_writeErr" takes console as Integer, message as Integer returns Integer:
    Note: Write string to stderr
    Note: message: Pointer to null-terminated string
    Note: Returns: IOResult pointer

    If console is equal to 0:
        Return proc io_result_error from IOCore with proc IO_ERROR_INVALID_HANDLE from IOCore, 0
    End If

    If message is equal to 0:
        Return proc io_result_error from IOCore with proc IO_ERROR_INVALID_ARGUMENT from IOCore, 0
    End If

    Note: Write using primitive
    Let bytes_written be proc console_write_string_stderr from ConsolePrimitive with message

    Note: Check for error
    If bytes_written is less than 0:
        Note: Convert error code to IOResult
        Let error_code be 0 minus bytes_written
        Return proc io_result_error from IOCore with error_code, 0
    End If

    Note: Always auto-flush stderr (unbuffered by convention)
    proc Console_flushErr with console

    Return proc io_result_success from IOCore with bytes_written
End Process

Process called "Console_writelnErr" takes console as Integer, message as Integer returns Integer:
    Note: Write string + newline to stderr
    Note: message: Pointer to null-terminated string (can be NULL for just newline)
    Note: Returns: IOResult pointer

    If console is equal to 0:
        Return proc io_result_error from IOCore with proc IO_ERROR_INVALID_HANDLE from IOCore, 0
    End If

    Note: Write using primitive (handles NULL message)
    Let bytes_written be proc console_writeln_stderr from ConsolePrimitive with message

    Note: Check for error
    If bytes_written is less than 0:
        Note: Convert error code to IOResult
        Let error_code be 0 minus bytes_written
        Return proc io_result_error from IOCore with error_code, 0
    End If

    Note: Always auto-flush stderr (unbuffered by convention)
    proc Console_flushErr with console

    Return proc io_result_success from IOCore with bytes_written
End Process

Process called "Console_flushErr" takes console as Integer returns Integer:
    Note: Flush stderr buffer
    Note: Returns: IOResult pointer

    If console is equal to 0:
        Return proc io_result_error from IOCore with proc IO_ERROR_INVALID_HANDLE from IOCore, 0
    End If

    Note: Flush using primitive
    Let flush_result be proc console_flush_stderr from ConsolePrimitive

    If flush_result is equal to 0:
        Return proc io_result_error from IOCore with proc IO_ERROR_IO_FAILURE from IOCore, 0
    End If

    Return proc io_result_success from IOCore with 0
End Process

Note: ============================================================================
Note: Read Operations (stdin)
Note: ============================================================================

Process called "Console_readln" takes console as Integer, max_length as Integer returns Integer:
    Note: Read a line from stdin (up to newline or max_length)
    Note: max_length: Maximum length including null terminator
    Note: Returns: Pointer to allocated string, or 0 on failure/EOF

    If console is equal to 0:
        Return 0
    End If

    If max_length is less than 2:
        Return 0
    End If

    Note: Allocate buffer for line
    Let buffer be proc allocate from Layout with max_length

    If buffer is equal to 0:
        Return 0
    End If

    Note: Read line using primitive
    Let bytes_read be proc console_read_line_stdin from ConsolePrimitive with buffer, max_length

    Note: Check for error
    If bytes_read is less than 0:
        proc deallocate from Layout with buffer
        Return 0
    End If

    Note: Check for EOF with no data
    If bytes_read is equal to 0:
        proc deallocate from Layout with buffer
        Return 0
    End If

    Return buffer
End Process

Process called "Console_read" takes console as Integer, length as Integer returns Integer:
    Note: Read up to length bytes from stdin
    Note: length: Maximum number of bytes to read
    Note: Returns: Pointer to allocated buffer, or 0 on failure/EOF
    Note: Caller must check actual bytes read using string_length

    If console is equal to 0:
        Return 0
    End If

    If length is less than 1:
        Return 0
    End If

    Note: Allocate buffer (length + 1 for null terminator)
    Let buffer be proc allocate from Layout with length plus 1

    If buffer is equal to 0:
        Return 0
    End If

    Note: Read using primitive
    Let bytes_read be proc console_read_stdin_raw from ConsolePrimitive with buffer, length

    Note: Check for error
    If bytes_read is less than 0:
        proc deallocate from Layout with buffer
        Return 0
    End If

    Note: Check for EOF
    If bytes_read is equal to 0:
        proc deallocate from Layout with buffer
        Return 0
    End If

    Note: Add null terminator
    proc memory_set_byte from Memory with buffer, bytes_read, 0

    Return buffer
End Process

Process called "Console_readChar" takes console as Integer returns Integer:
    Note: Read a single character from stdin
    Note: Returns: Character code (0-255), or -1 on error/EOF

    If console is equal to 0:
        Return -1
    End If

    Note: Allocate 1-byte buffer
    Let buffer be proc allocate from Layout with 1

    If buffer is equal to 0:
        Return -1
    End If

    Note: Read single byte
    Let bytes_read be proc console_read_stdin_raw from ConsolePrimitive with buffer, 1

    Note: Check for error or EOF
    If bytes_read is less than 1:
        proc deallocate from Layout with buffer
        Return -1
    End If

    Note: Get character value
    Let char_value be proc memory_get_byte from Memory with buffer, 0

    Note: Free buffer
    proc deallocate from Layout with buffer

    Return char_value
End Process

Note: ============================================================================
Note: Convenience Functions (Global Console Instance)
Note: ============================================================================

Note: Global console instance for convenience
Note: Initialized lazily on first use
Constant GLOBAL_CONSOLE_PTR as 0

Process called "getGlobalConsole" returns Integer:
    Note: Get or create global console instance
    Note: Returns: Pointer to global Console instance

    Note: Check if already initialized
    Let current be proc memory_get_int64 from Memory with GLOBAL_CONSOLE_PTR, 0

    If current is not equal to 0:
        Return current
    End If

    Note: Create new console
    Let console be proc Console_create

    If console is equal to 0:
        Return 0
    End If

    Note: Store globally
    proc memory_set_int64 from Memory with GLOBAL_CONSOLE_PTR, 0, console

    Return console
End Process

Process called "print" takes message as Integer returns Integer:
    Note: Convenience function: print to stdout using global console
    Note: Returns: IOResult pointer

    Let console be proc getGlobalConsole
    If console is equal to 0:
        Return proc io_result_error from IOCore with proc IO_ERROR_INVALID_HANDLE from IOCore, 0
    End If

    Return proc Console_write with console, message
End Process

Process called "println" takes message as Integer returns Integer:
    Note: Convenience function: print + newline to stdout using global console
    Note: Returns: IOResult pointer

    Let console be proc getGlobalConsole
    If console is equal to 0:
        Return proc io_result_error from IOCore with proc IO_ERROR_INVALID_HANDLE from IOCore, 0
    End If

    Return proc Console_writeln with console, message
End Process

Process called "printErr" takes message as Integer returns Integer:
    Note: Convenience function: print to stderr using global console
    Note: Returns: IOResult pointer

    Let console be proc getGlobalConsole
    If console is equal to 0:
        Return proc io_result_error from IOCore with proc IO_ERROR_INVALID_HANDLE from IOCore, 0
    End If

    Return proc Console_writeErr with console, message
End Process

Process called "printlnErr" takes message as Integer returns Integer:
    Note: Convenience function: print + newline to stderr using global console
    Note: Returns: IOResult pointer

    Let console be proc getGlobalConsole
    If console is equal to 0:
        Return proc io_result_error from IOCore with proc IO_ERROR_INVALID_HANDLE from IOCore, 0
    End If

    Return proc Console_writelnErr with console, message
End Process

Process called "readLine" takes max_length as Integer returns Integer:
    Note: Convenience function: read line from stdin using global console
    Note: Returns: Pointer to allocated string, or 0 on failure/EOF

    Let console be proc getGlobalConsole
    If console is equal to 0:
        Return 0
    End If

    Return proc Console_readln with console, max_length
End Process

Process called "readInput" takes length as Integer returns Integer:
    Note: Convenience function: read bytes from stdin using global console
    Note: Returns: Pointer to allocated buffer, or 0 on failure/EOF

    Let console be proc getGlobalConsole
    If console is equal to 0:
        Return 0
    End If

    Return proc Console_read with console, length
End Process
