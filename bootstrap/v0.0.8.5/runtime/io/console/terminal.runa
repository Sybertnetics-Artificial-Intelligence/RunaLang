Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file provides terminal control and ANSI escape sequences.

This file performs the following tasks:
- Provide ANSI color code support (foreground and background)
- Cursor positioning and movement
- Screen and line clearing operations
- Text styling (bold, underline, italic, etc.)
- Terminal capability detection

This file is essential because of the following reasons:
- Rich terminal output for user interfaces
- Color-coded console messages (errors, warnings, success)
- Interactive terminal applications
- Production-ready terminal control

This file consists of the following functions/features/operation types:
- Color constants and functions (setColor, setBackground, resetColor)
- Cursor control (moveCursor, saveCursor, restoreCursor, hideCursor, showCursor)
- Screen control (clearScreen, clearLine, scrollUp, scrollDown)
- Text styling (setBold, setUnderline, setItalic, resetStyle)
- Terminal queries (getTerminalSize, isColorSupported)

Dependencies:
- Imports io/console_primitive.runa (raw console output)
- Imports core/string_primitive.runa (string operations)
- Imports core/string_core.runa (string utilities)
- Imports core/memory_core.runa (memory operations)
- Imports memory/layout.runa (memory allocation)
:End Note

Import "compiler/frontend/primitives/io/console_primitive.runa" as ConsolePrimitive
Import "compiler/frontend/primitives/core/string_primitive.runa" as StringPrimitive
Import "compiler/frontend/primitives/core/string_core.runa" as StringCore
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory
Import "compiler/frontend/primitives/memory/layout.runa" as Layout

Note: ============================================================================
Note: ANSI Color Constants
Note: ============================================================================

Note: Foreground colors (30-37, 90-97)
Constant COLOR_BLACK as 30
Constant COLOR_RED as 31
Constant COLOR_GREEN as 32
Constant COLOR_YELLOW as 33
Constant COLOR_BLUE as 34
Constant COLOR_MAGENTA as 35
Constant COLOR_CYAN as 36
Constant COLOR_WHITE as 37

Note: Bright foreground colors (90-97)
Constant COLOR_BRIGHT_BLACK as 90
Constant COLOR_BRIGHT_RED as 91
Constant COLOR_BRIGHT_GREEN as 92
Constant COLOR_BRIGHT_YELLOW as 93
Constant COLOR_BRIGHT_BLUE as 94
Constant COLOR_BRIGHT_MAGENTA as 95
Constant COLOR_BRIGHT_CYAN as 96
Constant COLOR_BRIGHT_WHITE as 97

Note: Background colors (40-47, 100-107)
Constant BG_COLOR_BLACK as 40
Constant BG_COLOR_RED as 41
Constant BG_COLOR_GREEN as 42
Constant BG_COLOR_YELLOW as 43
Constant BG_COLOR_BLUE as 44
Constant BG_COLOR_MAGENTA as 45
Constant BG_COLOR_CYAN as 46
Constant BG_COLOR_WHITE as 47

Note: Bright background colors (100-107)
Constant BG_COLOR_BRIGHT_BLACK as 100
Constant BG_COLOR_BRIGHT_RED as 101
Constant BG_COLOR_BRIGHT_GREEN as 102
Constant BG_COLOR_BRIGHT_YELLOW as 103
Constant BG_COLOR_BRIGHT_BLUE as 104
Constant BG_COLOR_BRIGHT_MAGENTA as 105
Constant BG_COLOR_BRIGHT_CYAN as 106
Constant BG_COLOR_BRIGHT_WHITE as 107

Note: Text style constants
Constant STYLE_RESET as 0
Constant STYLE_BOLD as 1
Constant STYLE_DIM as 2
Constant STYLE_ITALIC as 3
Constant STYLE_UNDERLINE as 4
Constant STYLE_BLINK as 5
Constant STYLE_REVERSE as 7
Constant STYLE_HIDDEN as 8
Constant STYLE_STRIKETHROUGH as 9

Note: ============================================================================
Note: ANSI Escape Sequence Generation
Note: ============================================================================

Process called "create_escape_sequence" takes code as Integer returns Integer:
    Note: Create ANSI escape sequence string
    Note: code: ANSI code (e.g., 31 for red foreground)
    Note: Returns: Pointer to escape sequence string "\e[<code>m", or 0 on failure

    Note: Convert code to string
    Let code_str be proc integer_to_string from StringPrimitive with code
    If code_str is equal to 0:
        Return 0
    End If

    Note: Calculate total length: "\e[" + code + "m" + null = 3 + len(code) + 1 + 1
    Let code_len be proc string_length from StringCore with code_str
    Let total_len be 3 plus code_len plus 1 plus 1

    Note: Allocate buffer
    Let result be proc allocate from Layout with total_len
    If result is equal to 0:
        proc deallocate from Layout with code_str
        Return 0
    End If

    Note: Build escape sequence: "\e[<code>m"
    proc memory_set_byte from Memory with result, 0, 27    Note: ESC character
    proc memory_set_byte from Memory with result, 1, 91    Note: '['

    Note: Copy code digits
    Let i be 0
    While i is less than code_len:
        Let ch be proc memory_get_byte from Memory with code_str, i
        proc memory_set_byte from Memory with result, 2 plus i, ch
        Set i to i plus 1
    End While

    Note: Add 'm' and null terminator
    proc memory_set_byte from Memory with result, 2 plus code_len, 109  Note: 'm'
    proc memory_set_byte from Memory with result, 3 plus code_len, 0   Note: null

    Note: Free code string
    proc deallocate from Layout with code_str

    Return result
End Process

Process called "create_complex_escape_sequence" takes codes as Integer, count as Integer returns Integer:
    Note: Create ANSI escape sequence with multiple codes
    Note: codes: Array of ANSI codes (Integer*)
    Note: count: Number of codes
    Note: Returns: Pointer to escape sequence string "\e[<code1>;<code2>;...m", or 0 on failure

    If codes is equal to 0:
        Return 0
    End If

    If count is less than 1:
        Return 0
    End If

    Note: Start with "\e[" (3 bytes: ESC + '[' + null initially)
    Let buffer_size be 128
    Let result be proc allocate from Layout with buffer_size
    If result is equal to 0:
        Return 0
    End If

    Note: Write "\e["
    proc memory_set_byte from Memory with result, 0, 27   Note: ESC
    proc memory_set_byte from Memory with result, 1, 91   Note: '['
    Let write_pos be 2

    Note: Write codes separated by ';'
    Let i be 0
    While i is less than count:
        Note: Get code
        Let code_offset be i multiplied by 8
        Let code be proc memory_get_int64 from Memory with codes, code_offset

        Note: Convert to string
        Let code_str be proc integer_to_string from StringPrimitive with code
        If code_str is equal to 0:
            proc deallocate from Layout with result
            Return 0
        End If

        Note: Copy code digits
        Let code_len be proc string_length from StringCore with code_str
        Let j be 0
        While j is less than code_len:
            Let ch be proc memory_get_byte from Memory with code_str, j
            proc memory_set_byte from Memory with result, write_pos, ch
            Set write_pos to write_pos plus 1
            Set j to j plus 1
        End While

        Note: Free code string
        proc deallocate from Layout with code_str

        Note: Add semicolon if not last code
        If i is less than count minus 1:
            proc memory_set_byte from Memory with result, write_pos, 59  Note: ';'
            Set write_pos to write_pos plus 1
        End If

        Set i to i plus 1
    End While

    Note: Add 'm' and null terminator
    proc memory_set_byte from Memory with result, write_pos, 109  Note: 'm'
    Set write_pos to write_pos plus 1
    proc memory_set_byte from Memory with result, write_pos, 0    Note: null

    Return result
End Process

Note: ============================================================================
Note: Color Functions
Note: ============================================================================

Process called "Terminal_setForegroundColor" takes color_code as Integer returns Integer:
    Note: Set foreground color using ANSI escape code
    Note: color_code: COLOR_* constant (30-37 or 90-97)
    Note: Returns: Number of bytes written, or negative error code

    Note: Create escape sequence
    Let escape_seq be proc create_escape_sequence with color_code
    If escape_seq is equal to 0:
        Return -1
    End If

    Note: Write to stdout
    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with escape_seq

    Note: Free escape sequence
    proc deallocate from Layout with escape_seq

    Return bytes_written
End Process

Process called "Terminal_setBackgroundColor" takes color_code as Integer returns Integer:
    Note: Set background color using ANSI escape code
    Note: color_code: BG_COLOR_* constant (40-47 or 100-107)
    Note: Returns: Number of bytes written, or negative error code

    Note: Create escape sequence
    Let escape_seq be proc create_escape_sequence with color_code
    If escape_seq is equal to 0:
        Return -1
    End If

    Note: Write to stdout
    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with escape_seq

    Note: Free escape sequence
    proc deallocate from Layout with escape_seq

    Return bytes_written
End Process

Process called "Terminal_setColors" takes fg_color as Integer, bg_color as Integer returns Integer:
    Note: Set both foreground and background colors
    Note: fg_color: Foreground color code (COLOR_*)
    Note: bg_color: Background color code (BG_COLOR_*)
    Note: Returns: Number of bytes written, or negative error code

    Note: Create codes array
    Let codes be proc allocate from Layout with 16
    If codes is equal to 0:
        Return -1
    End If

    proc memory_set_int64 from Memory with codes, 0, fg_color
    proc memory_set_int64 from Memory with codes, 8, bg_color

    Note: Create complex escape sequence
    Let escape_seq be proc create_complex_escape_sequence with codes, 2

    Note: Free codes array
    proc deallocate from Layout with codes

    If escape_seq is equal to 0:
        Return -1
    End If

    Note: Write to stdout
    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with escape_seq

    Note: Free escape sequence
    proc deallocate from Layout with escape_seq

    Return bytes_written
End Process

Process called "Terminal_resetColors" returns Integer:
    Note: Reset all colors and styles to default
    Note: Returns: Number of bytes written, or negative error code

    Note: ANSI reset code: "\e[0m"
    Let reset_seq be proc create_escape_sequence with STYLE_RESET
    If reset_seq is equal to 0:
        Return -1
    End If

    Note: Write to stdout
    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with reset_seq

    Note: Free escape sequence
    proc deallocate from Layout with reset_seq

    Return bytes_written
End Process

Note: ============================================================================
Note: Text Style Functions
Note: ============================================================================

Process called "Terminal_setBold" returns Integer:
    Note: Enable bold text
    Note: Returns: Number of bytes written, or negative error code

    Let escape_seq be proc create_escape_sequence with STYLE_BOLD
    If escape_seq is equal to 0:
        Return -1
    End If

    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with escape_seq
    proc deallocate from Layout with escape_seq
    Return bytes_written
End Process

Process called "Terminal_setUnderline" returns Integer:
    Note: Enable underlined text
    Note: Returns: Number of bytes written, or negative error code

    Let escape_seq be proc create_escape_sequence with STYLE_UNDERLINE
    If escape_seq is equal to 0:
        Return -1
    End If

    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with escape_seq
    proc deallocate from Layout with escape_seq
    Return bytes_written
End Process

Process called "Terminal_setItalic" returns Integer:
    Note: Enable italic text
    Note: Returns: Number of bytes written, or negative error code

    Let escape_seq be proc create_escape_sequence with STYLE_ITALIC
    If escape_seq is equal to 0:
        Return -1
    End If

    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with escape_seq
    proc deallocate from Layout with escape_seq
    Return bytes_written
End Process

Process called "Terminal_setReverse" returns Integer:
    Note: Enable reverse video (swap foreground and background)
    Note: Returns: Number of bytes written, or negative error code

    Let escape_seq be proc create_escape_sequence with STYLE_REVERSE
    If escape_seq is equal to 0:
        Return -1
    End If

    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with escape_seq
    proc deallocate from Layout with escape_seq
    Return bytes_written
End Process

Note: ============================================================================
Note: Cursor Control Functions
Note: ============================================================================

Process called "Terminal_moveCursor" takes row as Integer, col as Integer returns Integer:
    Note: Move cursor to specified position (1-indexed)
    Note: row: Row number (1 = top)
    Note: col: Column number (1 = left)
    Note: Returns: Number of bytes written, or negative error code

    Note: Create escape sequence: "\e[<row>;<col>H"
    Let row_str be proc integer_to_string from StringPrimitive with row
    If row_str is equal to 0:
        Return -1
    End If

    Let col_str be proc integer_to_string from StringPrimitive with col
    If col_str is equal to 0:
        proc deallocate from Layout with row_str
        Return -1
    End If

    Note: Calculate length: "\e[" + row + ";" + col + "H" + null
    Let row_len be proc string_length from StringCore with row_str
    Let col_len be proc string_length from StringCore with col_str
    Let total_len be 2 plus row_len plus 1 plus col_len plus 1 plus 1

    Note: Allocate buffer
    Let escape_seq be proc allocate from Layout with total_len
    If escape_seq is equal to 0:
        proc deallocate from Layout with row_str
        proc deallocate from Layout with col_str
        Return -1
    End If

    Note: Build sequence
    proc memory_set_byte from Memory with escape_seq, 0, 27   Note: ESC
    proc memory_set_byte from Memory with escape_seq, 1, 91   Note: '['

    Note: Copy row
    Let i be 0
    While i is less than row_len:
        Let ch be proc memory_get_byte from Memory with row_str, i
        proc memory_set_byte from Memory with escape_seq, 2 plus i, ch
        Set i to i plus 1
    End While

    Note: Add semicolon
    proc memory_set_byte from Memory with escape_seq, 2 plus row_len, 59  Note: ';'

    Note: Copy col
    Set i to 0
    While i is less than col_len:
        Let ch be proc memory_get_byte from Memory with col_str, i
        proc memory_set_byte from Memory with escape_seq, 3 plus row_len plus i, ch
        Set i to i plus 1
    End While

    Note: Add 'H' and null
    proc memory_set_byte from Memory with escape_seq, 3 plus row_len plus col_len, 72  Note: 'H'
    proc memory_set_byte from Memory with escape_seq, 4 plus row_len plus col_len, 0   Note: null

    Note: Free temp strings
    proc deallocate from Layout with row_str
    proc deallocate from Layout with col_str

    Note: Write to stdout
    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with escape_seq

    Note: Free escape sequence
    proc deallocate from Layout with escape_seq

    Return bytes_written
End Process

Process called "Terminal_moveCursorUp" takes lines as Integer returns Integer:
    Note: Move cursor up by specified lines
    Note: Returns: Number of bytes written, or negative error code

    Let escape_seq be proc allocate from Layout with 16
    If escape_seq is equal to 0:
        Return -1
    End If

    Let lines_str be proc integer_to_string from StringPrimitive with lines
    If lines_str is equal to 0:
        proc deallocate from Layout with escape_seq
        Return -1
    End If

    Let lines_len be proc string_length from StringCore with lines_str

    Note: Build "\e[<lines>A"
    proc memory_set_byte from Memory with escape_seq, 0, 27
    proc memory_set_byte from Memory with escape_seq, 1, 91

    Let i be 0
    While i is less than lines_len:
        Let ch be proc memory_get_byte from Memory with lines_str, i
        proc memory_set_byte from Memory with escape_seq, 2 plus i, ch
        Set i to i plus 1
    End While

    proc memory_set_byte from Memory with escape_seq, 2 plus lines_len, 65   Note: 'A'
    proc memory_set_byte from Memory with escape_seq, 3 plus lines_len, 0    Note: null

    proc deallocate from Layout with lines_str

    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with escape_seq
    proc deallocate from Layout with escape_seq

    Return bytes_written
End Process

Process called "Terminal_moveCursorDown" takes lines as Integer returns Integer:
    Note: Move cursor down by specified lines
    Note: Returns: Number of bytes written, or negative error code

    Let escape_seq be proc allocate from Layout with 16
    If escape_seq is equal to 0:
        Return -1
    End If

    Let lines_str be proc integer_to_string from StringPrimitive with lines
    If lines_str is equal to 0:
        proc deallocate from Layout with escape_seq
        Return -1
    End If

    Let lines_len be proc string_length from StringCore with lines_str

    Note: Build "\e[<lines>B"
    proc memory_set_byte from Memory with escape_seq, 0, 27
    proc memory_set_byte from Memory with escape_seq, 1, 91

    Let i be 0
    While i is less than lines_len:
        Let ch be proc memory_get_byte from Memory with lines_str, i
        proc memory_set_byte from Memory with escape_seq, 2 plus i, ch
        Set i to i plus 1
    End While

    proc memory_set_byte from Memory with escape_seq, 2 plus lines_len, 66   Note: 'B'
    proc memory_set_byte from Memory with escape_seq, 3 plus lines_len, 0    Note: null

    proc deallocate from Layout with lines_str

    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with escape_seq
    proc deallocate from Layout with escape_seq

    Return bytes_written
End Process

Process called "Terminal_saveCursor" returns Integer:
    Note: Save current cursor position
    Note: Returns: Number of bytes written, or negative error code

    Note: ANSI save cursor: "\e[s" or "\e7"
    Let escape_seq be proc allocate from Layout with 4
    If escape_seq is equal to 0:
        Return -1
    End If

    proc memory_set_byte from Memory with escape_seq, 0, 27  Note: ESC
    proc memory_set_byte from Memory with escape_seq, 1, 91  Note: '['
    proc memory_set_byte from Memory with escape_seq, 2, 115 Note: 's'
    proc memory_set_byte from Memory with escape_seq, 3, 0   Note: null

    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with escape_seq
    proc deallocate from Layout with escape_seq

    Return bytes_written
End Process

Process called "Terminal_restoreCursor" returns Integer:
    Note: Restore saved cursor position
    Note: Returns: Number of bytes written, or negative error code

    Note: ANSI restore cursor: "\e[u" or "\e8"
    Let escape_seq be proc allocate from Layout with 4
    If escape_seq is equal to 0:
        Return -1
    End If

    proc memory_set_byte from Memory with escape_seq, 0, 27  Note: ESC
    proc memory_set_byte from Memory with escape_seq, 1, 91  Note: '['
    proc memory_set_byte from Memory with escape_seq, 2, 117 Note: 'u'
    proc memory_set_byte from Memory with escape_seq, 3, 0   Note: null

    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with escape_seq
    proc deallocate from Layout with escape_seq

    Return bytes_written
End Process

Process called "Terminal_hideCursor" returns Integer:
    Note: Hide cursor
    Note: Returns: Number of bytes written, or negative error code

    Note: ANSI hide cursor: "\e[?25l"
    Let escape_seq be proc allocate from Layout with 8
    If escape_seq is equal to 0:
        Return -1
    End If

    proc memory_set_byte from Memory with escape_seq, 0, 27  Note: ESC
    proc memory_set_byte from Memory with escape_seq, 1, 91  Note: '['
    proc memory_set_byte from Memory with escape_seq, 2, 63  Note: '?'
    proc memory_set_byte from Memory with escape_seq, 3, 50  Note: '2'
    proc memory_set_byte from Memory with escape_seq, 4, 53  Note: '5'
    proc memory_set_byte from Memory with escape_seq, 5, 108 Note: 'l'
    proc memory_set_byte from Memory with escape_seq, 6, 0   Note: null

    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with escape_seq
    proc deallocate from Layout with escape_seq

    Return bytes_written
End Process

Process called "Terminal_showCursor" returns Integer:
    Note: Show cursor
    Note: Returns: Number of bytes written, or negative error code

    Note: ANSI show cursor: "\e[?25h"
    Let escape_seq be proc allocate from Layout with 8
    If escape_seq is equal to 0:
        Return -1
    End If

    proc memory_set_byte from Memory with escape_seq, 0, 27  Note: ESC
    proc memory_set_byte from Memory with escape_seq, 1, 91  Note: '['
    proc memory_set_byte from Memory with escape_seq, 2, 63  Note: '?'
    proc memory_set_byte from Memory with escape_seq, 3, 50  Note: '2'
    proc memory_set_byte from Memory with escape_seq, 4, 53  Note: '5'
    proc memory_set_byte from Memory with escape_seq, 5, 104 Note: 'h'
    proc memory_set_byte from Memory with escape_seq, 6, 0   Note: null

    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with escape_seq
    proc deallocate from Layout with escape_seq

    Return bytes_written
End Process

Note: ============================================================================
Note: Screen Control Functions
Note: ============================================================================

Process called "Terminal_clearScreen" returns Integer:
    Note: Clear entire screen and move cursor to home (1,1)
    Note: Returns: Number of bytes written, or negative error code

    Note: ANSI clear screen: "\e[2J\e[H"
    Let escape_seq be proc allocate from Layout with 10
    If escape_seq is equal to 0:
        Return -1
    End If

    proc memory_set_byte from Memory with escape_seq, 0, 27  Note: ESC
    proc memory_set_byte from Memory with escape_seq, 1, 91  Note: '['
    proc memory_set_byte from Memory with escape_seq, 2, 50  Note: '2'
    proc memory_set_byte from Memory with escape_seq, 3, 74  Note: 'J'
    proc memory_set_byte from Memory with escape_seq, 4, 27  Note: ESC
    proc memory_set_byte from Memory with escape_seq, 5, 91  Note: '['
    proc memory_set_byte from Memory with escape_seq, 6, 72  Note: 'H'
    proc memory_set_byte from Memory with escape_seq, 7, 0   Note: null

    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with escape_seq
    proc deallocate from Layout with escape_seq

    Return bytes_written
End Process

Process called "Terminal_clearLine" returns Integer:
    Note: Clear current line
    Note: Returns: Number of bytes written, or negative error code

    Note: ANSI clear line: "\e[2K"
    Let escape_seq be proc allocate from Layout with 6
    If escape_seq is equal to 0:
        Return -1
    End If

    proc memory_set_byte from Memory with escape_seq, 0, 27  Note: ESC
    proc memory_set_byte from Memory with escape_seq, 1, 91  Note: '['
    proc memory_set_byte from Memory with escape_seq, 2, 50  Note: '2'
    proc memory_set_byte from Memory with escape_seq, 3, 75  Note: 'K'
    proc memory_set_byte from Memory with escape_seq, 4, 0   Note: null

    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with escape_seq
    proc deallocate from Layout with escape_seq

    Return bytes_written
End Process

Process called "Terminal_clearToEndOfLine" returns Integer:
    Note: Clear from cursor to end of line
    Note: Returns: Number of bytes written, or negative error code

    Note: ANSI clear to end of line: "\e[K" or "\e[0K"
    Let escape_seq be proc allocate from Layout with 5
    If escape_seq is equal to 0:
        Return -1
    End If

    proc memory_set_byte from Memory with escape_seq, 0, 27  Note: ESC
    proc memory_set_byte from Memory with escape_seq, 1, 91  Note: '['
    proc memory_set_byte from Memory with escape_seq, 2, 75  Note: 'K'
    proc memory_set_byte from Memory with escape_seq, 3, 0   Note: null

    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with escape_seq
    proc deallocate from Layout with escape_seq

    Return bytes_written
End Process

Process called "Terminal_clearToStartOfLine" returns Integer:
    Note: Clear from start of line to cursor
    Note: Returns: Number of bytes written, or negative error code

    Note: ANSI clear to start of line: "\e[1K"
    Let escape_seq be proc allocate from Layout with 6
    If escape_seq is equal to 0:
        Return -1
    End If

    proc memory_set_byte from Memory with escape_seq, 0, 27  Note: ESC
    proc memory_set_byte from Memory with escape_seq, 1, 91  Note: '['
    proc memory_set_byte from Memory with escape_seq, 2, 49  Note: '1'
    proc memory_set_byte from Memory with escape_seq, 3, 75  Note: 'K'
    proc memory_set_byte from Memory with escape_seq, 4, 0   Note: null

    Let bytes_written be proc console_write_string_stdout from ConsolePrimitive with escape_seq
    proc deallocate from Layout with escape_seq

    Return bytes_written
End Process

Note: ============================================================================
Note: Terminal Capabilities
Note: ============================================================================

Process called "Terminal_isColorSupported" returns Integer:
    Note: Check if terminal supports ANSI colors
    Note: Returns: 1 if supported, 0 if not

    Note: Check if stdout is a TTY
    Let is_tty be proc console_stdout_is_tty from ConsolePrimitive

    Note: If not a TTY, colors likely not supported
    If is_tty is equal to 0:
        Return 0
    End If

    Note: Most modern TTYs support ANSI colors
    Note: Could check TERM environment variable for more accuracy
    Return 1
End Process

Process called "Terminal_getSize" takes width_out as Integer, height_out as Integer returns Integer:
    Note: Get terminal size
    Note: width_out: Pointer to store width (columns)
    Note: height_out: Pointer to store height (rows)
    Note: Returns: 1 on success, 0 on failure

    Note: Use console primitive to get size
    Return proc console_get_terminal_size from ConsolePrimitive with 1, width_out, height_out
End Process
