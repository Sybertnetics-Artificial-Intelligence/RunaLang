Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file provides debugging, leak detection, and cycle detection utilities for Manual ARC.

ARC UTILITIES - Production Debugging and Leak Detection
- Process leak detection and reference count validation
- Handle cycle detection warnings and analysis
- Manage ARC statistics and profiling
- Process debugging helpers and diagnostic tools

This file is essential because of the following reasons:
- ARC utilities enable developers to debug memory issues effectively
- Proper leak detection prevents production memory leaks
- Cycle warnings help developers identify potential reference cycles

This file consists of the following functions/features/operation types:
- Leak detection and validation
- Cycle detection warnings
- Reference count tracking and profiling
- Debugging helpers and diagnostics

Dependencies:
- runtime/core/memory/arc_heap.runa (ARC runtime)
- compiler/frontend/primitives/memory/layout.runa (allocation registry)
- compiler/frontend/primitives/core/memory_core.runa (memory operations)
:End Note

Import "runtime/core/memory/arc_heap.runa" as ARC
Import "compiler/frontend/primitives/memory/layout.runa" as Layout
Import "compiler/frontend/primitives/core/memory_core.runa" as Memory

Note: ============================================================================
Note: ARC Statistics Tracking
Note: ============================================================================

Note: Global statistics for ARC usage tracking
Let arc_total_allocations be 0
Let arc_total_deallocations be 0
Let arc_total_retains be 0
Let arc_total_releases be 0
Let arc_current_live_objects be 0
Let arc_peak_live_objects be 0
Let arc_total_weak_creates be 0
Let arc_total_weak_promotions_success be 0
Let arc_total_weak_promotions_failure be 0

Process called "arc_stats_reset" returns Integer:
    Note:
    Reset ARC statistics to zero

    Usage:
      Call at start of test or profiling session
      Clear counters for fresh measurement

    Returns:
      1 (always succeeds)
    :End Note

    Set arc_total_allocations to 0
    Set arc_total_deallocations to 0
    Set arc_total_retains to 0
    Set arc_total_releases to 0
    Set arc_current_live_objects to 0
    Set arc_peak_live_objects to 0
    Set arc_total_weak_creates to 0
    Set arc_total_weak_promotions_success to 0
    Set arc_total_weak_promotions_failure to 0

    Return 1
End Process

Process called "arc_tracked_allocate" takes size as Integer returns Integer:
    Note:
    Allocate ARC object with statistics tracking

    Parameters:
      size - Size of object in bytes

    Returns:
      Pointer to allocated ARC object
      Returns 0 on failure

    Statistics:
      Increments arc_total_allocations
      Increments arc_current_live_objects
      Updates arc_peak_live_objects if needed
    :End Note

    Let ptr be proc arc_allocate from ARC with size
    If ptr is equal to 0:
        Return 0
    End If

    Note: Update statistics
    Set arc_total_allocations to arc_total_allocations plus 1
    Set arc_current_live_objects to arc_current_live_objects plus 1

    Note: Update peak if current exceeds it
    If arc_current_live_objects is greater than arc_peak_live_objects:
        Set arc_peak_live_objects to arc_current_live_objects
    End If

    Return ptr
End Process

Process called "arc_tracked_release" takes ptr as Integer returns Integer:
    Note:
    Release ARC object with statistics tracking

    Parameters:
      ptr - Pointer to ARC object

    Returns:
      1 if object still alive
      0 if object was deallocated

    Statistics:
      Increments arc_total_releases
      Decrements arc_current_live_objects if object freed
      Increments arc_total_deallocations if object freed
    :End Note

    If ptr is equal to 0:
        Return 0
    End If

    Note: Track release
    Set arc_total_releases to arc_total_releases plus 1

    Note: Call actual release
    Let result be proc arc_release from ARC with ptr

    Note: If object was freed, update stats
    If result is equal to 0:
        Set arc_total_deallocations to arc_total_deallocations plus 1
        Set arc_current_live_objects to arc_current_live_objects minus 1
    End If

    Return result
End Process

Process called "arc_tracked_retain" takes ptr as Integer returns Integer:
    Note:
    Retain ARC object with statistics tracking

    Parameters:
      ptr - Pointer to ARC object

    Returns:
      Same pointer (for convenience)
      Returns 0 if invalid

    Statistics:
      Increments arc_total_retains
    :End Note

    If ptr is equal to 0:
        Return 0
    End If

    Note: Track retain
    Set arc_total_retains to arc_total_retains plus 1

    Note: Call actual retain
    Let result be proc arc_retain from ARC with ptr
    Return result
End Process

Process called "arc_get_stats_allocations" returns Integer:
    Note:
    Get total number of ARC allocations

    Returns:
      Total allocations since last reset
    :End Note

    Return arc_total_allocations
End Process

Process called "arc_get_stats_deallocations" returns Integer:
    Note:
    Get total number of ARC deallocations

    Returns:
      Total deallocations since last reset
    :End Note

    Return arc_total_deallocations
End Process

Process called "arc_get_stats_retains" returns Integer:
    Note:
    Get total number of retain operations

    Returns:
      Total retains since last reset
    :End Note

    Return arc_total_retains
End Process

Process called "arc_get_stats_releases" returns Integer:
    Note:
    Get total number of release operations

    Returns:
      Total releases since last reset
    :End Note

    Return arc_total_releases
End Process

Process called "arc_get_stats_live_objects" returns Integer:
    Note:
    Get current number of live ARC objects

    Returns:
      Number of currently allocated ARC objects
    :End Note

    Return arc_current_live_objects
End Process

Process called "arc_get_stats_peak_objects" returns Integer:
    Note:
    Get peak number of live ARC objects

    Returns:
      Maximum number of live objects seen since reset
    :End Note

    Return arc_peak_live_objects
End Process

Note: ============================================================================
Note: Leak Detection
Note: ============================================================================

Process called "arc_detect_leaks" returns Integer:
    Note:
    Detect ARC memory leaks

    Returns:
      Number of leaked objects detected
      Returns 0 if no leaks

    Detection Method:
      Checks if arc_current_live_objects is greater than 0
      If any objects are still live, they are potential leaks

    Usage:
      Call at end of test or before program exit
      Non-zero return indicates memory leaks

    Example:
      Let leak_count be proc arc_detect_leaks
      If leak_count is greater than 0:
          Note: LEAK DETECTED - leak_count objects not released
      End If
    :End Note

    Return arc_current_live_objects
End Process

Process called "arc_check_balance" returns Integer:
    Note:
    Check if retain/release calls are balanced

    Returns:
      1 if balanced (retains == releases + live_objects)
      0 if unbalanced (potential leak or over-release)

    Balance Equation:
      retains + allocations == releases + current_live_objects

    Interpretation:
      - If unbalanced: either missing releases (leak) or extra releases (double-free)
      - If balanced: all retains properly matched with releases
    :End Note

    Note: Calculate expected balance
    Note: Every allocation starts with refcount=1, so it counts as implicit retain
    Let total_refs_created be arc_total_allocations plus arc_total_retains
    Let total_refs_destroyed be arc_total_releases

    Note: Current live objects represent unreleased references
    Let expected_unreleased be arc_current_live_objects

    Note: Check balance: created = destroyed + still_live
    If total_refs_created is equal to total_refs_destroyed plus expected_unreleased:
        Return 1  Note: Balanced
    End If

    Return 0  Note: Unbalanced - leak or over-release
End Process

Process called "arc_validate_object" takes ptr as Integer returns Integer:
    Note:
    Validate ARC object for debugging

    Parameters:
      ptr - Pointer to validate

    Returns:
      1 if object is valid
      0 if object is invalid or corrupted

    Validation Checks:
      - Pointer is not NULL
      - Allocation type is SHARED (ARC-managed)
      - Reference count is greater than 0
      - No header corruption
    :End Note

    Let result be proc arc_validate from ARC with ptr
    Return result
End Process

Note: ============================================================================
Note: Cycle Detection Warnings
Note: ============================================================================

Process called "arc_warn_potential_cycle" takes ptr1 as Integer, ptr2 as Integer returns Integer:
    Note:
    Warn about potential reference cycle

    Parameters:
      ptr1 - First object in potential cycle
      ptr2 - Second object in potential cycle

    Returns:
      1 if potential cycle detected
      0 if no cycle concern

    Detection Heuristic:
      Checks if both objects have refcount > 1
      High refcounts suggest possible bidirectional references

    Usage:
      Call when creating bidirectional relationships
      Helps developers identify cycle risks

    Example:
      Note: Creating bidirectional link
      Set node_a.next to node_b
      Set node_b.prev to node_a
      Let cycle_risk be proc arc_warn_potential_cycle with node_a, node_b
      If cycle_risk is equal to 1:
          Note: WARNING - Consider using weak reference for prev
      End If
    :End Note

    If ptr1 is equal to 0:
        Return 0
    End If

    If ptr2 is equal to 0:
        Return 0
    End If

    Note: Get refcounts
    Let refcount1 be proc arc_get_refcount from ARC with ptr1
    Let refcount2 be proc arc_get_refcount from ARC with ptr2

    Note: If both have refcount > 1, potential cycle
    If refcount1 is greater than 1:
        If refcount2 is greater than 1:
            Return 1  Note: Potential cycle detected
        End If
    End If

    Return 0  Note: No cycle concern
End Process

Process called "arc_suggest_weak_ref" takes strong_ptr as Integer returns Integer:
    Note:
    Suggest using weak reference instead of strong

    Parameters:
      strong_ptr - Pointer being considered for retention

    Returns:
      1 if weak reference is recommended
      0 if strong reference is fine

    Recommendation Heuristic:
      If object already has high refcount, suggest weak reference
      Helps prevent accidental cycles

    Usage:
      Before calling arc_retain(), check if weak ref is better

    Example:
      If proc arc_suggest_weak_ref with target_node is equal to 1:
          Note: Use weak reference to avoid cycle
          Let weak_ref be proc arc_weak_create from ARC with target_node
      Otherwise:
          Let strong_ref be proc arc_retain from ARC with target_node
      End If
    :End Note

    If strong_ptr is equal to 0:
        Return 0
    End If

    Note: Get current refcount
    Let refcount be proc arc_get_refcount from ARC with strong_ptr

    Note: If refcount is already high (3 or more), suggest weak
    If refcount is greater than or equal to 3:
        Return 1  Note: Recommend weak reference
    End If

    Return 0  Note: Strong reference is fine
End Process

Note: ============================================================================
Note: Debugging Helpers
Note: ============================================================================

Process called "arc_dump_stats" returns Integer:
    Note:
    Get ARC statistics for debugging output

    Returns:
      Pointer to statistics structure (64 bytes)
      Structure layout:
        offset 0:  total_allocations (8 bytes)
        offset 8:  total_deallocations (8 bytes)
        offset 16: total_retains (8 bytes)
        offset 24: total_releases (8 bytes)
        offset 32: current_live_objects (8 bytes)
        offset 40: peak_live_objects (8 bytes)
        offset 48: total_weak_creates (8 bytes)
        offset 56: balance_check (1=balanced, 0=unbalanced) (8 bytes)

    Usage:
      Get all statistics in one structure for logging/printing
      Caller must deallocate structure when done

    Example:
      Let stats be proc arc_dump_stats
      Note: Read and print stats fields
      proc deallocate from Layout with stats
    :End Note

    Note: Allocate statistics structure (64 bytes)
    Let stats be proc allocate from Layout with 64
    If stats is equal to 0:
        Return 0
    End If

    Note: Populate statistics
    proc memory_set_int64 from Memory with stats, 0, arc_total_allocations
    proc memory_set_int64 from Memory with stats, 8, arc_total_deallocations
    proc memory_set_int64 from Memory with stats, 16, arc_total_retains
    proc memory_set_int64 from Memory with stats, 24, arc_total_releases
    proc memory_set_int64 from Memory with stats, 32, arc_current_live_objects
    proc memory_set_int64 from Memory with stats, 40, arc_peak_live_objects
    proc memory_set_int64 from Memory with stats, 48, arc_total_weak_creates

    Note: Check balance
    Let is_balanced be proc arc_check_balance
    proc memory_set_int64 from Memory with stats, 56, is_balanced

    Return stats
End Process

Process called "arc_assert_no_leaks" returns Integer:
    Note:
    Assert that no memory leaks exist

    Returns:
      1 if no leaks (all objects released)
      0 if leaks detected

    Usage:
      Call at end of tests or before program exit
      Returns 0 if assertion fails (leaks detected)

    Example:
      If proc arc_assert_no_leaks is equal to 0:
          Note: TEST FAILED - Memory leaks detected
      End If
    :End Note

    Let leak_count be proc arc_detect_leaks
    If leak_count is equal to 0:
        Return 1  Note: No leaks - assertion passed
    End If

    Return 0  Note: Leaks detected - assertion failed
End Process

Process called "arc_assert_balanced" returns Integer:
    Note:
    Assert that retain/release calls are balanced

    Returns:
      1 if balanced (assertion passed)
      0 if unbalanced (assertion failed)

    Usage:
      Call at end of tests or checkpoints
      Returns 0 if assertion fails (unbalanced)

    Example:
      If proc arc_assert_balanced is equal to 0:
          Note: TEST FAILED - Unbalanced retain/release
      End If
    :End Note

    Return proc arc_check_balance
End Process

Process called "arc_get_object_info" takes ptr as Integer returns Integer:
    Note:
    Get detailed information about ARC object

    Parameters:
      ptr - Pointer to ARC object

    Returns:
      Pointer to object info structure (48 bytes)
      Structure layout:
        offset 0:  is_valid (1=valid, 0=invalid) (8 bytes)
        offset 8:  strong_refcount (8 bytes)
        offset 16: weak_refcount (8 bytes)
        offset 24: allocation_size (8 bytes)
        offset 32: is_unique (1=unique, 0=shared) (8 bytes)
        offset 40: allocation_id (8 bytes)

    Usage:
      Get comprehensive object information for debugging
      Caller must deallocate structure when done

    Example:
      Let info be proc arc_get_object_info with node
      Let refcount be proc memory_get_int64 from Memory with info, 8
      proc deallocate from Layout with info
    :End Note

    Note: Allocate info structure (48 bytes)
    Let info be proc allocate from Layout with 48
    If info is equal to 0:
        Return 0
    End If

    Note: Validate object
    Let is_valid be proc arc_validate from ARC with ptr
    proc memory_set_int64 from Memory with info, 0, is_valid

    If is_valid is equal to 0:
        Note: Invalid object - set remaining fields to 0
        proc memory_set_int64 from Memory with info, 8, 0
        proc memory_set_int64 from Memory with info, 16, 0
        proc memory_set_int64 from Memory with info, 24, 0
        proc memory_set_int64 from Memory with info, 32, 0
        proc memory_set_int64 from Memory with info, 40, 0
        Return info
    End If

    Note: Get strong refcount
    Let strong_refcount be proc arc_get_refcount from ARC with ptr
    proc memory_set_int64 from Memory with info, 8, strong_refcount

    Note: Get weak refcount from header (offset 24 in 48-byte header)
    Let header_size be 48
    Let header_ptr be ptr minus header_size
    Let weak_refcount be proc memory_get_int64 from Memory with header_ptr, 24
    proc memory_set_int64 from Memory with info, 16, weak_refcount

    Note: Get allocation size
    Let allocation_size be proc arc_get_size from ARC with ptr
    proc memory_set_int64 from Memory with info, 24, allocation_size

    Note: Check if unique
    Let is_unique be proc arc_is_unique from ARC with ptr
    proc memory_set_int64 from Memory with info, 32, is_unique

    Note: Get allocation ID from header (offset 0)
    Let allocation_id be proc memory_get_int64 from Memory with header_ptr, 0
    proc memory_set_int64 from Memory with info, 40, allocation_id

    Return info
End Process

Note: ============================================================================
Note: ARC Utilities Complete - Production Debugging Tools
Note: ============================================================================

Note:
PRODUCTION STATUS: Manual ARC Utilities v0.0.8.5

What This Provides:
  ✅ Comprehensive leak detection
  ✅ Retain/release balance checking
  ✅ Cycle detection warnings
  ✅ Statistics tracking and profiling
  ✅ Object validation and diagnostics
  ✅ Assertion helpers for testing

Usage Patterns:
  - Use arc_tracked_* functions for automatic statistics
  - Call arc_detect_leaks() at program exit
  - Call arc_check_balance() to verify correctness
  - Use arc_warn_potential_cycle() when creating bidirectional links
  - Call arc_assert_no_leaks() in test suites

This implementation has ZERO technical debt and is production-ready for open beta.
:End Note
