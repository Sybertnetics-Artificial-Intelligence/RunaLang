Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file implements MIPS 64-bit specific state mapping for AOTT deoptimization.

MIPS64 STATE MAPPING - Platform-Specific State Analysis Engine
- Process MIPS 64-bit specific state mapping between optimized machine state and logical Runa state
- Handle MIPS 64-bit register allocation and calling convention analysis for deoptimization
- Manage MIPS 64-bit specific state mapping generation and validation for AOTT compilation
- Process MIPS 64-bit state mapping optimization and performance analysis for AOTT efficiency
- Handle integration with AOTT compilation phases for MIPS 64-bit state mapping generation

This file is essential because of the following reasons:
- MIPS 64-bit state mapping enables comprehensive deoptimization support for MIPS 64-bit platforms
- Proper MIPS 64-bit state mapping ensures correct program execution during optimization failures
- MIPS 64-bit state mapping support enables Runa AOTT compilation for advanced MIPS 64-bit optimization workflows

This file consists of the following functions/features/operation types:
- MIPS 64-bit specific state mapping between optimized and logical execution states
- MIPS 64-bit register allocation and calling convention analysis
- MIPS 64-bit state mapping generation and validation for AOTT compilation
- MIPS 64-bit state mapping optimization and performance analysis
- Integration with AOTT compilation phases for MIPS 64-bit state mapping generation

Dependencies:
- Imports mod.runa for deoptimization metadata structures
- Imports state_mapper.runa for base state mapping functionality
- Imports arena_utils.runa for arena-based state mapping allocation
- Imports owned_utils.runa for owned state mapping management
:End Note

Import "compiler/internal/arena_utils.runa" as ArenaUtils
Import "compiler/internal/owned_utils.runa" as OwnedUtils
Import "compiler/internal/memory_safety.runa" as MemorySafety

Note: ============================================================================
Note: MIPS 64-bit State Mapping Structures
Note: ============================================================================

Type called "MIPS64StateMap":
    general_registers as Integer Note: Pointer to general register mapping
    floating_registers as Integer Note: Pointer to floating register mapping
    vector_registers as Integer Note: Pointer to vector register mapping
    stack_frame as Integer      Note: Pointer to stack frame mapping
    calling_convention as Integer Note: Pointer to calling convention info
    is_valid as Integer         Note: Boolean: 1 if state map is valid
    arena as Integer           Note: Pointer to arena for allocation
    is_owned as Integer         Note: Boolean: 1 if owned, 0 if arena-allocated

Type called "MIPS64RegisterMapping":
    register_name as Integer    Note: Pointer to register name ($0, $1, etc.)
    register_number as Integer  Note: Register number (0-31)
    register_type as Integer    Note: Type of register (GENERAL, FLOATING, VECTOR)
    variable_name as Integer    Note: Pointer to mapped variable name
    is_live as Integer         Note: Boolean: 1 if register is live
    is_modified as Integer      Note: Boolean: 1 if register is modified
    next as Integer            Note: Pointer to next register mapping

Type called "MIPS64StackMapping":
    stack_offset as Integer     Note: Stack offset from frame pointer
    variable_name as Integer    Note: Pointer to mapped variable name
    variable_type as Integer    Note: Type of variable
    is_live as Integer         Note: Boolean: 1 if variable is live
    is_modified as Integer      Note: Boolean: 1 if variable is modified
    next as Integer            Note: Pointer to next stack mapping

Note: ============================================================================
Note: MIPS 64-bit State Mapping Constants
Note: ============================================================================

Define constant MIPS64_REGISTER_$0 as 0
Define constant MIPS64_REGISTER_$1 as 1
Define constant MIPS64_REGISTER_$2 as 2
Define constant MIPS64_REGISTER_$3 as 3
Define constant MIPS64_REGISTER_$4 as 4
Define constant MIPS64_REGISTER_$5 as 5
Define constant MIPS64_REGISTER_$6 as 6
Define constant MIPS64_REGISTER_$7 as 7
Define constant MIPS64_REGISTER_$8 as 8
Define constant MIPS64_REGISTER_$9 as 9
Define constant MIPS64_REGISTER_$10 as 10
Define constant MIPS64_REGISTER_$11 as 11
Define constant MIPS64_REGISTER_$12 as 12
Define constant MIPS64_REGISTER_$13 as 13
Define constant MIPS64_REGISTER_$14 as 14
Define constant MIPS64_REGISTER_$15 as 15
Define constant MIPS64_REGISTER_$16 as 16
Define constant MIPS64_REGISTER_$17 as 17
Define constant MIPS64_REGISTER_$18 as 18
Define constant MIPS64_REGISTER_$19 as 19
Define constant MIPS64_REGISTER_$20 as 20
Define constant MIPS64_REGISTER_$21 as 21
Define constant MIPS64_REGISTER_$22 as 22
Define constant MIPS64_REGISTER_$23 as 23
Define constant MIPS64_REGISTER_$24 as 24
Define constant MIPS64_REGISTER_$25 as 25
Define constant MIPS64_REGISTER_$26 as 26
Define constant MIPS64_REGISTER_$27 as 27
Define constant MIPS64_REGISTER_$28 as 28
Define constant MIPS64_REGISTER_$29 as 29
Define constant MIPS64_REGISTER_$30 as 30
Define constant MIPS64_REGISTER_$31 as 31

Define constant MIPS64_REGISTER_TYPE_GENERAL as 0
Define constant MIPS64_REGISTER_TYPE_FLOATING as 1
Define constant MIPS64_REGISTER_TYPE_VECTOR as 2

Define constant MIPS64_CALLING_CONVENTION_O32 as 0
Define constant MIPS64_CALLING_CONVENTION_N32 as 1
Define constant MIPS64_CALLING_CONVENTION_N64 as 2

Note: ============================================================================
Note: MIPS 64-bit State Map Generation
Note: ============================================================================

Process called "mips64_state_map_generate" takes ir_point as Integer, optimization_tier as Integer, arena as Integer returns Integer:
    Note: Generate MIPS 64-bit specific state map for IR point
    Note: Returns pointer to MIPS64StateMap structure
    Note: Analyzes IR and creates MIPS 64-bit specific state mapping
End Process

Process called "mips64_state_map_destroy" takes state_map as Integer returns Nothing:
    Note: Destroy MIPS 64-bit state map
    Note: Frees all state map data
    Note: Validates memory safety before destruction
End Process

Process called "mips64_state_map_validate" takes state_map as Integer returns Integer:
    Note: Validate MIPS 64-bit state map
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks state map integrity and consistency
End Process

Process called "mips64_state_map_clone" takes source_state_map as Integer returns Integer:
    Note: Create copy of MIPS 64-bit state map
    Note: Returns pointer to new MIPS64StateMap structure
    Note: Copies all state map data and settings
End Process

Note: ============================================================================
Note: MIPS 64-bit Register Analysis
Note: ============================================================================

Process called "mips64_register_analyze" takes ir_point as Integer returns Integer:
    Note: Analyze MIPS 64-bit register usage at IR point
    Note: Returns pointer to register analysis results
    Note: Determines register allocation and usage
End Process

Process called "mips64_register_get_general" takes ir_point as Integer returns Integer:
    Note: Get general register usage at IR point
    Note: Returns pointer to general register mapping
    Note: Maps general registers to variables
End Process

Process called "mips64_register_get_floating" takes ir_point as Integer returns Integer:
    Note: Get floating register usage at IR point
    Note: Returns pointer to floating register mapping
    Note: Maps floating registers to variables
End Process

Process called "mips64_register_get_vector" takes ir_point as Integer returns Integer:
    Note: Get vector register usage at IR point
    Note: Returns pointer to vector register mapping
    Note: Maps vector registers to variables
End Process

Process called "mips64_register_is_live" takes register_number as Integer, ir_point as Integer returns Integer:
    Note: Check if MIPS 64-bit register is live at IR point
    Note: Returns 1 if live, 0 if dead
End Process

Process called "mips64_register_is_modified" takes register_number as Integer, ir_point as Integer returns Integer:
    Note: Check if MIPS 64-bit register is modified at IR point
    Note: Returns 1 if modified, 0 if not modified
End Process

Note: ============================================================================
Note: MIPS 64-bit Stack Analysis
Note: ============================================================================

Process called "mips64_stack_analyze" takes ir_point as Integer returns Integer:
    Note: Analyze MIPS 64-bit stack usage at IR point
    Note: Returns pointer to stack analysis results
    Note: Determines stack frame layout and usage
End Process

Process called "mips64_stack_get_frame" takes ir_point as Integer returns Integer:
    Note: Get stack frame layout at IR point
    Note: Returns pointer to stack frame mapping
    Note: Maps stack frame to variables
End Process

Process called "mips64_stack_get_offset" takes variable_name as Integer, ir_point as Integer returns Integer:
    Note: Get stack offset for variable at IR point
    Note: Returns stack offset or -1 if not on stack
End Process

Process called "mips64_stack_is_live" takes stack_offset as Integer, ir_point as Integer returns Integer:
    Note: Check if stack location is live at IR point
    Note: Returns 1 if live, 0 if dead
End Process

Process called "mips64_stack_is_modified" takes stack_offset as Integer, ir_point as Integer returns Integer:
    Note: Check if stack location is modified at IR point
    Note: Returns 1 if modified, 0 if not modified
End Process

Note: ============================================================================
Note: MIPS 64-bit Calling Convention Analysis
Note: ============================================================================

Process called "mips64_calling_convention_analyze" takes ir_point as Integer returns Integer:
    Note: Analyze MIPS 64-bit calling convention at IR point
    Note: Returns pointer to calling convention analysis
    Note: Determines calling convention compliance
End Process

Process called "mips64_calling_convention_get_o32" takes ir_point as Integer returns Integer:
    Note: Get O32 calling convention analysis
    Note: Returns pointer to O32 analysis
    Note: Analyzes O32 ABI compliance
End Process

Process called "mips64_calling_convention_get_n32" takes ir_point as Integer returns Integer:
    Note: Get N32 calling convention analysis
    Note: Returns pointer to N32 analysis
    Note: Analyzes N32 ABI compliance
End Process

Process called "mips64_calling_convention_get_n64" takes ir_point as Integer returns Integer:
    Note: Get N64 calling convention analysis
    Note: Returns pointer to N64 analysis
    Note: Analyzes N64 ABI compliance
End Process

Process called "mips64_calling_convention_validate" takes ir_point as Integer returns Integer:
    Note: Validate MIPS 64-bit calling convention
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks calling convention compliance
End Process

Note: ============================================================================
Note: MIPS 64-bit State Mapping Optimization
Note: ============================================================================

Process called "mips64_state_mapping_optimize" takes state_map as Integer returns Integer:
    Note: Optimize MIPS 64-bit state mapping
    Note: Returns 1 if successful, 0 if failed
    Note: Applies MIPS 64-bit specific optimizations
End Process

Process called "mips64_state_mapping_compress" takes state_map as Integer returns Integer:
    Note: Compress MIPS 64-bit state mapping
    Note: Returns 1 if successful, 0 if failed
    Note: Reduces state mapping size
End Process

Process called "mips64_state_mapping_validate_all" takes state_map as Integer returns Integer:
    Note: Validate all MIPS 64-bit state mappings
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks all mapping consistency
End Process

Process called "mips64_state_mapping_export" takes state_map as Integer, filename as Integer returns Integer:
    Note: Export MIPS 64-bit state mapping to file
    Note: Returns 1 if successful, 0 if failed
    Note: Saves state mapping to file
End Process

Process called "mips64_state_mapping_import" takes filename as Integer returns Integer:
    Note: Import MIPS 64-bit state mapping from file
    Note: Returns pointer to MIPS64StateMap structure
    Note: Loads state mapping from file
End Process

Note: TODO - Implement MIPS 64-bit state mapping functionality
