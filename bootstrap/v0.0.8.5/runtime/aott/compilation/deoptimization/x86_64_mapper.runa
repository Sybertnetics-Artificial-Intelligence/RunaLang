Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
This file implements x86_64-specific state mapping for AOTT deoptimization.

X86_64 STATE MAPPING - Platform-Specific State Analysis Engine
- Process x86_64-specific state mapping between optimized machine state and logical Runa state
- Handle x86_64 register allocation and calling convention analysis for deoptimization
- Manage x86_64-specific state mapping generation and validation for AOTT compilation
- Process x86_64 state mapping optimization and performance analysis for AOTT efficiency
- Handle integration with AOTT compilation phases for x86_64 state mapping generation

This file is essential because of the following reasons:
- x86_64 state mapping enables comprehensive deoptimization support for x86_64 platforms
- Proper x86_64 state mapping ensures correct program execution during optimization failures
- x86_64 state mapping support enables Runa AOTT compilation for advanced x86_64 optimization workflows

This file consists of the following functions/features/operation types:
- x86_64-specific state mapping between optimized and logical execution states
- x86_64 register allocation and calling convention analysis
- x86_64 state mapping generation and validation for AOTT compilation
- x86_64 state mapping optimization and performance analysis
- Integration with AOTT compilation phases for x86_64 state mapping generation

Dependencies:
- Imports mod.runa for deoptimization metadata structures
- Imports state_mapper.runa for base state mapping functionality
- Imports arena_utils.runa for arena-based state mapping allocation
- Imports owned_utils.runa for owned state mapping management
:End Note

Import "compiler/internal/arena_utils.runa" as ArenaUtils
Import "compiler/internal/owned_utils.runa" as OwnedUtils
Import "compiler/internal/memory_safety.runa" as MemorySafety

Note: ============================================================================
Note: x86_64 State Mapping Structures
Note: ============================================================================

Type called "X86_64StateMap":
    general_registers as Integer Note: Pointer to general register mapping
    floating_registers as Integer Note: Pointer to floating register mapping
    vector_registers as Integer Note: Pointer to vector register mapping
    stack_frame as Integer      Note: Pointer to stack frame mapping
    calling_convention as Integer Note: Pointer to calling convention info
    is_valid as Integer         Note: Boolean: 1 if state map is valid
    arena as Integer           Note: Pointer to arena for allocation
    is_owned as Integer         Note: Boolean: 1 if owned, 0 if arena-allocated

Type called "X86_64RegisterMapping":
    register_name as Integer    Note: Pointer to register name (rax, rbx, etc.)
    register_number as Integer  Note: Register number (0-15)
    register_type as Integer    Note: Type of register (GENERAL, FLOATING, VECTOR)
    variable_name as Integer    Note: Pointer to mapped variable name
    is_live as Integer         Note: Boolean: 1 if register is live
    is_modified as Integer      Note: Boolean: 1 if register is modified
    next as Integer            Note: Pointer to next register mapping

Type called "X86_64StackMapping":
    stack_offset as Integer     Note: Stack offset from frame pointer
    variable_name as Integer    Note: Pointer to mapped variable name
    variable_type as Integer    Note: Type of variable
    is_live as Integer         Note: Boolean: 1 if variable is live
    is_modified as Integer      Note: Boolean: 1 if variable is modified
    next as Integer            Note: Pointer to next stack mapping

Note: ============================================================================
Note: x86_64 State Mapping Constants
Note: ============================================================================

Define constant X86_64_REGISTER_RAX as 0
Define constant X86_64_REGISTER_RBX as 1
Define constant X86_64_REGISTER_RCX as 2
Define constant X86_64_REGISTER_RDX as 3
Define constant X86_64_REGISTER_RSI as 4
Define constant X86_64_REGISTER_RDI as 5
Define constant X86_64_REGISTER_RBP as 6
Define constant X86_64_REGISTER_RSP as 7
Define constant X86_64_REGISTER_R8 as 8
Define constant X86_64_REGISTER_R9 as 9
Define constant X86_64_REGISTER_R10 as 10
Define constant X86_64_REGISTER_R11 as 11
Define constant X86_64_REGISTER_R12 as 12
Define constant X86_64_REGISTER_R13 as 13
Define constant X86_64_REGISTER_R14 as 14
Define constant X86_64_REGISTER_R15 as 15

Define constant X86_64_REGISTER_TYPE_GENERAL as 0
Define constant X86_64_REGISTER_TYPE_FLOATING as 1
Define constant X86_64_REGISTER_TYPE_VECTOR as 2

Define constant X86_64_CALLING_CONVENTION_SYSTEM_V as 0
Define constant X86_64_CALLING_CONVENTION_MICROSOFT as 1

Note: ============================================================================
Note: x86_64 State Map Generation
Note: ============================================================================

Process called "x86_64_state_map_generate" takes ir_point as Integer, optimization_tier as Integer, arena as Integer returns Integer:
    Note: Generate x86_64-specific state map for IR point
    Note: Returns pointer to X86_64StateMap structure
    Note: Analyzes IR and creates x86_64-specific state mapping
End Process

Process called "x86_64_state_map_destroy" takes state_map as Integer returns Nothing:
    Note: Destroy x86_64 state map
    Note: Frees all state map data
    Note: Validates memory safety before destruction
End Process

Process called "x86_64_state_map_validate" takes state_map as Integer returns Integer:
    Note: Validate x86_64 state map
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks state map integrity and consistency
End Process

Process called "x86_64_state_map_clone" takes source_state_map as Integer returns Integer:
    Note: Create copy of x86_64 state map
    Note: Returns pointer to new X86_64StateMap structure
    Note: Copies all state map data and settings
End Process

Note: ============================================================================
Note: x86_64 Register Analysis
Note: ============================================================================

Process called "x86_64_register_analyze" takes ir_point as Integer returns Integer:
    Note: Analyze x86_64 register usage at IR point
    Note: Returns pointer to register analysis results
    Note: Determines register allocation and usage
End Process

Process called "x86_64_register_get_general" takes ir_point as Integer returns Integer:
    Note: Get general register usage at IR point
    Note: Returns pointer to general register mapping
    Note: Maps general registers to variables
End Process

Process called "x86_64_register_get_floating" takes ir_point as Integer returns Integer:
    Note: Get floating register usage at IR point
    Note: Returns pointer to floating register mapping
    Note: Maps floating registers to variables
End Process

Process called "x86_64_register_get_vector" takes ir_point as Integer returns Integer:
    Note: Get vector register usage at IR point
    Note: Returns pointer to vector register mapping
    Note: Maps vector registers to variables
End Process

Process called "x86_64_register_is_live" takes register_number as Integer, ir_point as Integer returns Integer:
    Note: Check if x86_64 register is live at IR point
    Note: Returns 1 if live, 0 if dead
End Process

Process called "x86_64_register_is_modified" takes register_number as Integer, ir_point as Integer returns Integer:
    Note: Check if x86_64 register is modified at IR point
    Note: Returns 1 if modified, 0 if not modified
End Process

Note: ============================================================================
Note: x86_64 Stack Analysis
Note: ============================================================================

Process called "x86_64_stack_analyze" takes ir_point as Integer returns Integer:
    Note: Analyze x86_64 stack usage at IR point
    Note: Returns pointer to stack analysis results
    Note: Determines stack frame layout and usage
End Process

Process called "x86_64_stack_get_frame" takes ir_point as Integer returns Integer:
    Note: Get stack frame layout at IR point
    Note: Returns pointer to stack frame mapping
    Note: Maps stack frame to variables
End Process

Process called "x86_64_stack_get_offset" takes variable_name as Integer, ir_point as Integer returns Integer:
    Note: Get stack offset for variable at IR point
    Note: Returns stack offset or -1 if not on stack
End Process

Process called "x86_64_stack_is_live" takes stack_offset as Integer, ir_point as Integer returns Integer:
    Note: Check if stack location is live at IR point
    Note: Returns 1 if live, 0 if dead
End Process

Process called "x86_64_stack_is_modified" takes stack_offset as Integer, ir_point as Integer returns Integer:
    Note: Check if stack location is modified at IR point
    Note: Returns 1 if modified, 0 if not modified
End Process

Note: ============================================================================
Note: x86_64 Calling Convention Analysis
Note: ============================================================================

Process called "x86_64_calling_convention_analyze" takes ir_point as Integer returns Integer:
    Note: Analyze x86_64 calling convention at IR point
    Note: Returns pointer to calling convention analysis
    Note: Determines calling convention compliance
End Process

Process called "x86_64_calling_convention_get_system_v" takes ir_point as Integer returns Integer:
    Note: Get System V calling convention analysis
    Note: Returns pointer to System V analysis
    Note: Analyzes System V ABI compliance
End Process

Process called "x86_64_calling_convention_get_microsoft" takes ir_point as Integer returns Integer:
    Note: Get Microsoft calling convention analysis
    Note: Returns pointer to Microsoft analysis
    Note: Analyzes Microsoft ABI compliance
End Process

Process called "x86_64_calling_convention_validate" takes ir_point as Integer returns Integer:
    Note: Validate x86_64 calling convention
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks calling convention compliance
End Process

Note: ============================================================================
Note: x86_64 State Mapping Optimization
Note: ============================================================================

Process called "x86_64_state_mapping_optimize" takes state_map as Integer returns Integer:
    Note: Optimize x86_64 state mapping
    Note: Returns 1 if successful, 0 if failed
    Note: Applies x86_64-specific optimizations
End Process

Process called "x86_64_state_mapping_compress" takes state_map as Integer returns Integer:
    Note: Compress x86_64 state mapping
    Note: Returns 1 if successful, 0 if failed
    Note: Reduces state mapping size
End Process

Process called "x86_64_state_mapping_validate_all" takes state_map as Integer returns Integer:
    Note: Validate all x86_64 state mappings
    Note: Returns 1 if valid, 0 if invalid
    Note: Checks all mapping consistency
End Process

Process called "x86_64_state_mapping_export" takes state_map as Integer, filename as Integer returns Integer:
    Note: Export x86_64 state mapping to file
    Note: Returns 1 if successful, 0 if failed
    Note: Saves state mapping to file
End Process

Process called "x86_64_state_mapping_import" takes filename as Integer returns Integer:
    Note: Import x86_64 state mapping from file
    Note: Returns pointer to X86_64StateMap structure
    Note: Loads state mapping from file
End Process

Note: TODO - Implement x86_64 state mapping functionality
