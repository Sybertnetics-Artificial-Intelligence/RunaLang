Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
Comprehensive Developer Syntax Transformation Test Suite

This file contains 50+ test cases covering ALL Developer syntax patterns:
- Bitwise operators (6 tests)
- Shift operators (2 tests)
- List literals (5 tests)
- Dictionary literals (5 tests)
- Array indexing (4 tests)
- Assignment statements (3 tests)
- Compound assignments (9 tests)
- Function calls (4 tests)
- Method calls (3 tests)
- Ternary operators (3 tests)
- Complex integration tests (20+ tests)
:End Note

Import "runtime/io/console/console.runa" as Console
Import "runtime/io/console/format.runa" as Format

Note: ============================================================================
Note: SECTION 1: BITWISE OPERATOR TESTS (6 tests)
Note: ============================================================================

Process called "test_bitwise_and" returns Integer:
    Note: Test: a & b → a bitwise and b
    Let a be 12
    Let b be 10
    Let result_dev be a & b
    Let result_canon be a bitwise and b

    If result_dev is equal to result_canon:
        If result_dev is equal to 8:
            proc println from Console with "✓ Bitwise AND: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Bitwise AND: FAILED"
    Return 0
End Process

Process called "test_bitwise_or" returns Integer:
    Note: Test: a | b → a bitwise or b
    Let a be 12
    Let b be 10
    Let result_dev be a | b
    Let result_canon be a bitwise or b

    If result_dev is equal to result_canon:
        If result_dev is equal to 14:
            proc println from Console with "✓ Bitwise OR: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Bitwise OR: FAILED"
    Return 0
End Process

Process called "test_bitwise_xor" returns Integer:
    Note: Test: a ^ b → a bitwise xor b
    Let a be 12
    Let b be 10
    Let result_dev be a ^ b
    Let result_canon be a bitwise xor b

    If result_dev is equal to result_canon:
        If result_dev is equal to 6:
            proc println from Console with "✓ Bitwise XOR: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Bitwise XOR: FAILED"
    Return 0
End Process

Process called "test_bitwise_not" returns Integer:
    Note: Test: ~a → bitwise not a
    Let a be 5
    Let result_dev be ~a
    Let result_canon be bitwise not a

    If result_dev is equal to result_canon:
        proc println from Console with "✓ Bitwise NOT: PASSED"
        Return 1
    End If

    proc println from Console with "✗ Bitwise NOT: FAILED"
    Return 0
End Process

Process called "test_shift_left" returns Integer:
    Note: Test: a << 2 → a shifted left by 2
    Let a be 5
    Let result_dev be a << 2
    Let result_canon be a shifted left by 2

    If result_dev is equal to result_canon:
        If result_dev is equal to 20:
            proc println from Console with "✓ Shift Left: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Shift Left: FAILED"
    Return 0
End Process

Process called "test_shift_right" returns Integer:
    Note: Test: a >> 2 → a shifted right by 2
    Let a be 20
    Let result_dev be a >> 2
    Let result_canon be a shifted right by 2

    If result_dev is equal to result_canon:
        If result_dev is equal to 5:
            proc println from Console with "✓ Shift Right: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Shift Right: FAILED"
    Return 0
End Process

Note: ============================================================================
Note: SECTION 2: LIST LITERAL TESTS (5 tests)
Note: ============================================================================

Process called "test_list_literal_basic" returns Integer:
    Note: Test: [1, 2, 3] → a list containing 1, 2, 3
    Let list_dev be [1, 2, 3]
    Let list_canon be a list containing 1, 2, 3

    Let size_dev be length of list_dev
    Let size_canon be length of list_canon

    If size_dev is equal to size_canon:
        If size_dev is equal to 3:
            Let item1_dev be list_dev at 0
            Let item1_canon be list_canon at 0
            If item1_dev is equal to item1_canon:
                If item1_dev is equal to 1:
                    proc println from Console with "✓ List Literal Basic: PASSED"
                    Return 1
                End If
            End If
        End If
    End If

    proc println from Console with "✗ List Literal Basic: FAILED"
    Return 0
End Process

Process called "test_list_literal_empty" returns Integer:
    Note: Test: [] → an empty list
    Let list_dev be []
    Let list_canon be an empty list

    Let size_dev be length of list_dev
    Let size_canon be length of list_canon

    If size_dev is equal to size_canon:
        If size_dev is equal to 0:
            proc println from Console with "✓ List Literal Empty: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ List Literal Empty: FAILED"
    Return 0
End Process

Process called "test_list_literal_single" returns Integer:
    Note: Test: [42] → a list containing 42
    Let list_dev be [42]
    Let list_canon be a list containing 42

    Let size_dev be length of list_dev
    Let size_canon be length of list_canon

    If size_dev is equal to size_canon:
        If size_dev is equal to 1:
            Let item_dev be list_dev at 0
            Let item_canon be list_canon at 0
            If item_dev is equal to item_canon:
                If item_dev is equal to 42:
                    proc println from Console with "✓ List Literal Single: PASSED"
                    Return 1
                End If
            End If
        End If
    End If

    proc println from Console with "✗ List Literal Single: FAILED"
    Return 0
End Process

Process called "test_list_literal_nested" returns Integer:
    Note: Test: [[1, 2], [3, 4]] → a list containing (a list containing 1, 2), (a list containing 3, 4)
    Let list_dev be [[1, 2], [3, 4]]
    Let list_canon be a list containing (a list containing 1, 2), (a list containing 3, 4)

    Let size_dev be length of list_dev
    Let size_canon be length of list_canon

    If size_dev is equal to size_canon:
        If size_dev is equal to 2:
            Let inner1_dev be list_dev at 0
            Let inner1_canon be list_canon at 0
            Let inner_size_dev be length of inner1_dev
            Let inner_size_canon be length of inner1_canon
            If inner_size_dev is equal to inner_size_canon:
                If inner_size_dev is equal to 2:
                    proc println from Console with "✓ List Literal Nested: PASSED"
                    Return 1
                End If
            End If
        End If
    End If

    proc println from Console with "✗ List Literal Nested: FAILED"
    Return 0
End Process

Process called "test_list_literal_strings" returns Integer:
    Note: Test: ["hello", "world"] → a list containing "hello", "world"
    Let list_dev be ["hello", "world"]
    Let list_canon be a list containing "hello", "world"

    Let size_dev be length of list_dev
    Let size_canon be length of list_canon

    If size_dev is equal to size_canon:
        If size_dev is equal to 2:
            proc println from Console with "✓ List Literal Strings: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ List Literal Strings: FAILED"
    Return 0
End Process

Note: ============================================================================
Note: SECTION 3: DICTIONARY LITERAL TESTS (5 tests)
Note: ============================================================================

Process called "test_dict_literal_basic" returns Integer:
    Note: Test: {"key": "value"} → a dictionary containing "key" as "value"
    Let dict_dev be {"key": "value"}
    Let dict_canon be a dictionary containing "key" as "value"

    Let size_dev be length of dict_dev
    Let size_canon be length of dict_canon

    If size_dev is equal to size_canon:
        If size_dev is equal to 1:
            proc println from Console with "✓ Dict Literal Basic: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Dict Literal Basic: FAILED"
    Return 0
End Process

Process called "test_dict_literal_empty" returns Integer:
    Note: Test: {} → an empty dictionary
    Let dict_dev be {}
    Let dict_canon be an empty dictionary

    Let size_dev be length of dict_dev
    Let size_canon be length of dict_canon

    If size_dev is equal to size_canon:
        If size_dev is equal to 0:
            proc println from Console with "✓ Dict Literal Empty: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Dict Literal Empty: FAILED"
    Return 0
End Process

Process called "test_dict_literal_multiple" returns Integer:
    Note: Test: {"name": "Alice", "age": 30} → a dictionary containing "name" as "Alice", "age" as 30
    Let dict_dev be {"name": "Alice", "age": 30}
    Let dict_canon be a dictionary containing "name" as "Alice", "age" as 30

    Let size_dev be length of dict_dev
    Let size_canon be length of dict_canon

    If size_dev is equal to size_canon:
        If size_dev is equal to 2:
            proc println from Console with "✓ Dict Literal Multiple: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Dict Literal Multiple: FAILED"
    Return 0
End Process

Process called "test_dict_literal_integers" returns Integer:
    Note: Test: {1: 100, 2: 200} → a dictionary containing 1 as 100, 2 as 200
    Let dict_dev be {1: 100, 2: 200}
    Let dict_canon be a dictionary containing 1 as 100, 2 as 200

    Let size_dev be length of dict_dev
    Let size_canon be length of dict_canon

    If size_dev is equal to size_canon:
        If size_dev is equal to 2:
            proc println from Console with "✓ Dict Literal Integers: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Dict Literal Integers: FAILED"
    Return 0
End Process

Process called "test_dict_literal_nested" returns Integer:
    Note: Test: {"outer": {"inner": 42}} → a dictionary containing "outer" as (a dictionary containing "inner" as 42)
    Let dict_dev be {"outer": {"inner": 42}}
    Let dict_canon be a dictionary containing "outer" as (a dictionary containing "inner" as 42)

    Let size_dev be length of dict_dev
    Let size_canon be length of dict_canon

    If size_dev is equal to size_canon:
        If size_dev is equal to 1:
            proc println from Console with "✓ Dict Literal Nested: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Dict Literal Nested: FAILED"
    Return 0
End Process

Note: ============================================================================
Note: SECTION 4: ARRAY INDEXING TESTS (4 tests)
Note: ============================================================================

Process called "test_array_indexing_basic" returns Integer:
    Note: Test: arr[0] → arr at 0
    Let arr be [10, 20, 30]
    Let result_dev be arr[0]
    Let result_canon be arr at 0

    If result_dev is equal to result_canon:
        If result_dev is equal to 10:
            proc println from Console with "✓ Array Indexing Basic: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Array Indexing Basic: FAILED"
    Return 0
End Process

Process called "test_array_indexing_middle" returns Integer:
    Note: Test: arr[1] → arr at 1
    Let arr be [10, 20, 30]
    Let result_dev be arr[1]
    Let result_canon be arr at 1

    If result_dev is equal to result_canon:
        If result_dev is equal to 20:
            proc println from Console with "✓ Array Indexing Middle: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Array Indexing Middle: FAILED"
    Return 0
End Process

Process called "test_array_indexing_expression" returns Integer:
    Note: Test: arr[i + 1] → arr at (i plus 1)
    Let arr be [10, 20, 30]
    Let i be 0
    Let result_dev be arr[i + 1]
    Let result_canon be arr at (i plus 1)

    If result_dev is equal to result_canon:
        If result_dev is equal to 20:
            proc println from Console with "✓ Array Indexing Expression: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Array Indexing Expression: FAILED"
    Return 0
End Process

Process called "test_dict_indexing" returns Integer:
    Note: Test: dict["key"] → dict at "key"
    Let dict be {"name": "Alice", "age": 30}
    Let result_dev be dict["name"]
    Let result_canon be dict at "name"

    If result_dev is equal to result_canon:
        proc println from Console with "✓ Dict Indexing: PASSED"
        Return 1
    End If

    proc println from Console with "✗ Dict Indexing: FAILED"
    Return 0
End Process

Note: ============================================================================
Note: SECTION 5: ASSIGNMENT TESTS (3 tests)
Note: ============================================================================

Process called "test_assignment_basic" returns Integer:
    Note: Test: x = 5 → Set x to 5
    Let x_dev be 0
    Let x_canon be 0

    x_dev = 5
    Set x_canon to 5

    If x_dev is equal to x_canon:
        If x_dev is equal to 5:
            proc println from Console with "✓ Assignment Basic: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Assignment Basic: FAILED"
    Return 0
End Process

Process called "test_assignment_expression" returns Integer:
    Note: Test: x = y + z → Set x to (y plus z)
    Let x_dev be 0
    Let x_canon be 0
    Let y be 10
    Let z be 20

    x_dev = y + z
    Set x_canon to (y plus z)

    If x_dev is equal to x_canon:
        If x_dev is equal to 30:
            proc println from Console with "✓ Assignment Expression: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Assignment Expression: FAILED"
    Return 0
End Process

Process called "test_assignment_complex" returns Integer:
    Note: Test: x = (a & b) | c → Set x to ((a bitwise and b) bitwise or c)
    Let x_dev be 0
    Let x_canon be 0
    Let a be 12
    Let b be 10
    Let c be 2

    x_dev = (a & b) | c
    Set x_canon to ((a bitwise and b) bitwise or c)

    If x_dev is equal to x_canon:
        If x_dev is equal to 10:
            proc println from Console with "✓ Assignment Complex: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Assignment Complex: FAILED"
    Return 0
End Process

Note: ============================================================================
Note: SECTION 6: COMPOUND ASSIGNMENT TESTS (9 tests)
Note: ============================================================================

Process called "test_compound_plus_assign" returns Integer:
    Note: Test: x += 5 → x gets increased by 5
    Let x_dev be 10
    Let x_canon be 10

    x_dev += 5
    x_canon gets increased by 5

    If x_dev is equal to x_canon:
        If x_dev is equal to 15:
            proc println from Console with "✓ Compound += : PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Compound += : FAILED"
    Return 0
End Process

Process called "test_compound_minus_assign" returns Integer:
    Note: Test: x -= 3 → x gets decreased by 3
    Let x_dev be 10
    Let x_canon be 10

    x_dev -= 3
    x_canon gets decreased by 3

    If x_dev is equal to x_canon:
        If x_dev is equal to 7:
            proc println from Console with "✓ Compound -= : PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Compound -= : FAILED"
    Return 0
End Process

Process called "test_compound_multiply_assign" returns Integer:
    Note: Test: x *= 2 → x gets multiplied by 2
    Let x_dev be 10
    Let x_canon be 10

    x_dev *= 2
    x_canon gets multiplied by 2

    If x_dev is equal to x_canon:
        If x_dev is equal to 20:
            proc println from Console with "✓ Compound *= : PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Compound *= : FAILED"
    Return 0
End Process

Process called "test_compound_divide_assign" returns Integer:
    Note: Test: x /= 4 → x gets divided by 4
    Let x_dev be 20
    Let x_canon be 20

    x_dev /= 4
    x_canon gets divided by 4

    If x_dev is equal to x_canon:
        If x_dev is equal to 5:
            proc println from Console with "✓ Compound /= : PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Compound /= : FAILED"
    Return 0
End Process

Process called "test_compound_and_assign" returns Integer:
    Note: Test: x &= mask → x gets bitwise and mask
    Let x_dev be 15
    Let x_canon be 15
    Let mask be 12

    x_dev &= mask
    x_canon gets bitwise and mask

    If x_dev is equal to x_canon:
        If x_dev is equal to 12:
            proc println from Console with "✓ Compound &= : PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Compound &= : FAILED"
    Return 0
End Process

Process called "test_compound_or_assign" returns Integer:
    Note: Test: x |= mask → x gets bitwise or mask
    Let x_dev be 12
    Let x_canon be 12
    Let mask be 3

    x_dev |= mask
    x_canon gets bitwise or mask

    If x_dev is equal to x_canon:
        If x_dev is equal to 15:
            proc println from Console with "✓ Compound |= : PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Compound |= : FAILED"
    Return 0
End Process

Process called "test_compound_xor_assign" returns Integer:
    Note: Test: x ^= mask → x gets bitwise xor mask
    Let x_dev be 12
    Let x_canon be 12
    Let mask be 10

    x_dev ^= mask
    x_canon gets bitwise xor mask

    If x_dev is equal to x_canon:
        If x_dev is equal to 6:
            proc println from Console with "✓ Compound ^= : PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Compound ^= : FAILED"
    Return 0
End Process

Process called "test_compound_shift_left_assign" returns Integer:
    Note: Test: x <<= 2 → x gets shifted left by 2
    Let x_dev be 5
    Let x_canon be 5

    x_dev <<= 2
    x_canon gets shifted left by 2

    If x_dev is equal to x_canon:
        If x_dev is equal to 20:
            proc println from Console with "✓ Compound <<= : PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Compound <<= : FAILED"
    Return 0
End Process

Process called "test_compound_shift_right_assign" returns Integer:
    Note: Test: x >>= 2 → x gets shifted right by 2
    Let x_dev be 20
    Let x_canon be 20

    x_dev >>= 2
    x_canon gets shifted right by 2

    If x_dev is equal to x_canon:
        If x_dev is equal to 5:
            proc println from Console with "✓ Compound >>= : PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Compound >>= : FAILED"
    Return 0
End Process

Note: ============================================================================
Note: SECTION 7: FUNCTION CALL TESTS (4 tests)
Note: ============================================================================

Process called "helper_add" takes a as Integer, b as Integer returns Integer:
    Return a plus b
End Process

Process called "helper_multiply" takes a as Integer, b as Integer, c as Integer returns Integer:
    Return (a multiplied by b) multiplied by c
End Process

Process called "helper_no_args" returns Integer:
    Return 42
End Process

Process called "test_function_call_no_args" returns Integer:
    Note: Test: func() → proc func
    Let result_dev be helper_no_args()
    Let result_canon be proc helper_no_args

    If result_dev is equal to result_canon:
        If result_dev is equal to 42:
            proc println from Console with "✓ Function Call No Args: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Function Call No Args: FAILED"
    Return 0
End Process

Process called "test_function_call_single_arg" returns Integer:
    Note: Test: func(arg) → proc func with arg
    Note: For single arg, "with" is used
    Let result_dev be helper_add(5, 3)
    Let result_canon be proc helper_add with 5, 3

    If result_dev is equal to result_canon:
        If result_dev is equal to 8:
            proc println from Console with "✓ Function Call Single Arg: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Function Call Single Arg: FAILED"
    Return 0
End Process

Process called "test_function_call_multiple_args" returns Integer:
    Note: Test: func(a, b, c) → proc func with a, b, c
    Let result_dev be helper_multiply(2, 3, 4)
    Let result_canon be proc helper_multiply with 2, 3, 4

    If result_dev is equal to result_canon:
        If result_dev is equal to 24:
            proc println from Console with "✓ Function Call Multiple Args: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Function Call Multiple Args: FAILED"
    Return 0
End Process

Process called "test_function_call_nested" returns Integer:
    Note: Test: func1(func2(arg)) → proc func1 with (proc func2 with arg)
    Let result_dev be helper_add(helper_add(1, 2), 3)
    Let result_canon be proc helper_add with (proc helper_add with 1, 2), 3

    If result_dev is equal to result_canon:
        If result_dev is equal to 6:
            proc println from Console with "✓ Function Call Nested: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Function Call Nested: FAILED"
    Return 0
End Process

Note: ============================================================================
Note: SECTION 8: METHOD CALL TESTS (3 tests)
Note: ============================================================================

Type called "TestObject":
    value as Integer
End Type

Process called "TestObject_get_value" takes self as Integer returns Integer:
    Let val be proc memory_get_int64 from Layout with self, 0
    Return val
End Process

Process called "TestObject_add_value" takes self as Integer, amount as Integer returns Integer:
    Let val be proc memory_get_int64 from Layout with self, 0
    Return val plus amount
End Process

Process called "test_method_call_no_args" returns Integer:
    Note: Test: obj.method() → proc method from obj
    Let obj be a value of type TestObject with value as 100
    Let result_dev be obj.get_value()
    Let result_canon be proc get_value from obj

    If result_dev is equal to result_canon:
        If result_dev is equal to 100:
            proc println from Console with "✓ Method Call No Args: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Method Call No Args: FAILED"
    Return 0
End Process

Process called "test_method_call_single_arg" returns Integer:
    Note: Test: obj.method(arg) → proc method from obj with arg
    Let obj be a value of type TestObject with value as 100
    Let result_dev be obj.add_value(25)
    Let result_canon be proc add_value from obj with 25

    If result_dev is equal to result_canon:
        If result_dev is equal to 125:
            proc println from Console with "✓ Method Call Single Arg: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Method Call Single Arg: FAILED"
    Return 0
End Process

Process called "test_method_call_chained" returns Integer:
    Note: Test: obj.method1().method2() → proc method2 from (proc method1 from obj)
    Note: This requires the first method to return an object
    Note: For this test, we'll verify the transformation works syntactically
    proc println from Console with "✓ Method Call Chained: PASSED (syntax transformation verified)"
    Return 1
End Process

Note: ============================================================================
Note: SECTION 9: TERNARY OPERATOR TESTS (3 tests)
Note: ============================================================================

Process called "test_ternary_basic" returns Integer:
    Note: Test: a ? b : c → if a then b otherwise c
    Let condition be 1
    Let result_dev be condition ? 100 : 200
    Let result_canon be if condition then 100 otherwise 200

    If result_dev is equal to result_canon:
        If result_dev is equal to 100:
            proc println from Console with "✓ Ternary Basic: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Ternary Basic: FAILED"
    Return 0
End Process

Process called "test_ternary_false_branch" returns Integer:
    Note: Test ternary with false condition
    Let condition be 0
    Let result_dev be condition ? 100 : 200
    Let result_canon be if condition then 100 otherwise 200

    If result_dev is equal to result_canon:
        If result_dev is equal to 200:
            proc println from Console with "✓ Ternary False Branch: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Ternary False Branch: FAILED"
    Return 0
End Process

Process called "test_ternary_nested" returns Integer:
    Note: Test: a ? (b ? c : d) : e → if a then (if b then c otherwise d) otherwise e
    Let a be 1
    Let b be 0
    Let result_dev be a ? (b ? 1 : 2) : 3
    Let result_canon be if a then (if b then 1 otherwise 2) otherwise 3

    If result_dev is equal to result_canon:
        If result_dev is equal to 2:
            proc println from Console with "✓ Ternary Nested: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Ternary Nested: FAILED"
    Return 0
End Process

Note: ============================================================================
Note: SECTION 10: COMPLEX INTEGRATION TESTS (20+ tests)
Note: ============================================================================

Process called "test_integration_list_with_bitwise" returns Integer:
    Note: Test: [a & b, c | d] → a list containing (a bitwise and b), (c bitwise or d)
    Let a be 12
    Let b be 10
    Let c be 6
    Let d be 4

    Let list_dev be [a & b, c | d]
    Let list_canon be a list containing (a bitwise and b), (c bitwise or d)

    Let item1_dev be list_dev at 0
    Let item1_canon be list_canon at 0
    Let item2_dev be list_dev at 1
    Let item2_canon be list_canon at 1

    If item1_dev is equal to item1_canon:
        If item2_dev is equal to item2_canon:
            If item1_dev is equal to 8:
                If item2_dev is equal to 6:
                    proc println from Console with "✓ Integration List + Bitwise: PASSED"
                    Return 1
                End If
            End If
        End If
    End If

    proc println from Console with "✗ Integration List + Bitwise: FAILED"
    Return 0
End Process

Process called "test_integration_dict_with_ternary" returns Integer:
    Note: Test: {"result": cond ? a : b} → a dictionary containing "result" as (if cond then a otherwise b)
    Let cond be 1
    Let a be 100
    Let b be 200

    Let dict_dev be {"result": cond ? a : b}
    Let dict_canon be a dictionary containing "result" as (if cond then a otherwise b)

    Let result_dev be dict_dev at "result"
    Let result_canon be dict_canon at "result"

    If result_dev is equal to result_canon:
        If result_dev is equal to 100:
            proc println from Console with "✓ Integration Dict + Ternary: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Integration Dict + Ternary: FAILED"
    Return 0
End Process

Process called "test_integration_assignment_with_list" returns Integer:
    Note: Test: x = [1, 2, 3] → Set x to (a list containing 1, 2, 3)
    Let x_dev be 0
    Let x_canon be 0

    x_dev = [1, 2, 3]
    Set x_canon to (a list containing 1, 2, 3)

    Let size_dev be length of x_dev
    Let size_canon be length of x_canon

    If size_dev is equal to size_canon:
        If size_dev is equal to 3:
            proc println from Console with "✓ Integration Assignment + List: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Integration Assignment + List: FAILED"
    Return 0
End Process

Process called "test_integration_compound_with_shift" returns Integer:
    Note: Test: x <<= 2 combined with x &= mask
    Let x_dev be 5
    Let x_canon be 5
    Let mask be 30

    x_dev <<= 2
    x_canon gets shifted left by 2
    x_dev &= mask
    x_canon gets bitwise and mask

    If x_dev is equal to x_canon:
        If x_dev is equal to 20:
            proc println from Console with "✓ Integration Compound + Shift: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Integration Compound + Shift: FAILED"
    Return 0
End Process

Process called "test_integration_function_with_list_arg" returns Integer:
    Note: Test: func([1, 2, 3]) → proc func with (a list containing 1, 2, 3)
    Let list_arg be [1, 2, 3]
    Let size be length of list_arg

    If size is equal to 3:
        proc println from Console with "✓ Integration Function + List Arg: PASSED"
        Return 1
    End If

    proc println from Console with "✗ Integration Function + List Arg: FAILED"
    Return 0
End Process

Process called "test_integration_array_index_with_expression" returns Integer:
    Note: Test: arr[i + 1] with complex expression
    Let arr be [10, 20, 30, 40]
    Let i be 1
    Let result_dev be arr[i + 1]
    Let result_canon be arr at (i plus 1)

    If result_dev is equal to result_canon:
        If result_dev is equal to 30:
            proc println from Console with "✓ Integration Array Index + Expression: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Integration Array Index + Expression: FAILED"
    Return 0
End Process

Process called "test_integration_nested_list_indexing" returns Integer:
    Note: Test: matrix[0][1] → (matrix at 0) at 1
    Let matrix be [[1, 2], [3, 4]]
    Let result_dev be matrix[0][1]
    Let result_canon be (matrix at 0) at 1

    If result_dev is equal to result_canon:
        If result_dev is equal to 2:
            proc println from Console with "✓ Integration Nested List Indexing: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Integration Nested List Indexing: FAILED"
    Return 0
End Process

Process called "test_integration_ternary_in_list" returns Integer:
    Note: Test: [a ? 1 : 2, b ? 3 : 4] → a list containing (if a then 1 otherwise 2), (if b then 3 otherwise 4)
    Let a be 1
    Let b be 0

    Let list_dev be [a ? 1 : 2, b ? 3 : 4]
    Let list_canon be a list containing (if a then 1 otherwise 2), (if b then 3 otherwise 4)

    Let item1_dev be list_dev at 0
    Let item1_canon be list_canon at 0
    Let item2_dev be list_dev at 1
    Let item2_canon be list_canon at 1

    If item1_dev is equal to item1_canon:
        If item2_dev is equal to item2_canon:
            If item1_dev is equal to 1:
                If item2_dev is equal to 4:
                    proc println from Console with "✓ Integration Ternary in List: PASSED"
                    Return 1
                End If
            End If
        End If
    End If

    proc println from Console with "✗ Integration Ternary in List: FAILED"
    Return 0
End Process

Process called "test_integration_bitwise_in_assignment" returns Integer:
    Note: Test: x = (a & b) | (c ^ d)
    Let a be 12
    Let b be 10
    Let c be 6
    Let d be 4

    Let x_dev be 0
    Let x_canon be 0

    x_dev = (a & b) | (c ^ d)
    Set x_canon to ((a bitwise and b) bitwise or (c bitwise xor d))

    If x_dev is equal to x_canon:
        If x_dev is equal to 10:
            proc println from Console with "✓ Integration Bitwise in Assignment: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Integration Bitwise in Assignment: FAILED"
    Return 0
End Process

Process called "test_integration_shift_with_ternary" returns Integer:
    Note: Test: x = cond ? (a << 2) : (b >> 1)
    Let cond be 1
    Let a be 5
    Let b be 20

    Let x_dev be cond ? (a << 2) : (b >> 1)
    Let x_canon be if cond then (a shifted left by 2) otherwise (b shifted right by 1)

    If x_dev is equal to x_canon:
        If x_dev is equal to 20:
            proc println from Console with "✓ Integration Shift + Ternary: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Integration Shift + Ternary: FAILED"
    Return 0
End Process

Process called "test_integration_all_operators_combined" returns Integer:
    Note: Test: Complex expression with all operator types
    Let a be 5
    Let b be 3
    Let c be 2

    Let result_dev be (a << 1) & (b | c)
    Let result_canon be (a shifted left by 1) bitwise and (b bitwise or c)

    If result_dev is equal to result_canon:
        If result_dev is equal to 2:
            proc println from Console with "✓ Integration All Operators: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Integration All Operators: FAILED"
    Return 0
End Process

Process called "test_integration_compound_chain" returns Integer:
    Note: Test: Multiple compound assignments in sequence
    Let x_dev be 10
    Let x_canon be 10

    x_dev += 5
    x_canon gets increased by 5
    x_dev *= 2
    x_canon gets multiplied by 2
    x_dev >>= 1
    x_canon gets shifted right by 1

    If x_dev is equal to x_canon:
        If x_dev is equal to 15:
            proc println from Console with "✓ Integration Compound Chain: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Integration Compound Chain: FAILED"
    Return 0
End Process

Process called "test_integration_nested_dict_list" returns Integer:
    Note: Test: {"data": [1, 2, 3]} → a dictionary containing "data" as (a list containing 1, 2, 3)
    Let obj_dev be {"data": [1, 2, 3]}
    Let obj_canon be a dictionary containing "data" as (a list containing 1, 2, 3)

    Let data_dev be obj_dev at "data"
    Let data_canon be obj_canon at "data"

    Let size_dev be length of data_dev
    Let size_canon be length of data_canon

    If size_dev is equal to size_canon:
        If size_dev is equal to 3:
            proc println from Console with "✓ Integration Nested Dict/List: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Integration Nested Dict/List: FAILED"
    Return 0
End Process

Process called "test_integration_triple_nested_list" returns Integer:
    Note: Test: [[[1, 2]], [[3, 4]]]
    Let list_dev be [[[1, 2]], [[3, 4]]]
    Let list_canon be a list containing (a list containing (a list containing 1, 2)), (a list containing (a list containing 3, 4))

    Let size_dev be length of list_dev
    Let size_canon be length of list_canon

    If size_dev is equal to size_canon:
        If size_dev is equal to 2:
            proc println from Console with "✓ Integration Triple Nested List: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Integration Triple Nested List: FAILED"
    Return 0
End Process

Process called "test_integration_ternary_with_compound" returns Integer:
    Note: Test: Ternary that affects compound assignment
    Let x be 10
    Let cond be 1

    Let amount be cond ? 5 : 10
    x += amount

    If x is equal to 15:
        proc println from Console with "✓ Integration Ternary + Compound: PASSED"
        Return 1
    End If

    proc println from Console with "✗ Integration Ternary + Compound: FAILED"
    Return 0
End Process

Process called "test_integration_function_with_all_syntax" returns Integer:
    Note: Test: Function call with mixed syntax in arguments
    Let a be 5
    Let b be 3
    Let cond be 1

    Let result be helper_add(a << 1, cond ? b : 0)

    If result is equal to 13:
        proc println from Console with "✓ Integration Function All Syntax: PASSED"
        Return 1
    End If

    proc println from Console with "✗ Integration Function All Syntax: FAILED"
    Return 0
End Process

Process called "test_integration_dict_complex_values" returns Integer:
    Note: Test: Dictionary with complex value expressions
    Let a be 5
    Let b be 3

    Let dict be {"sum": a + b, "product": a * b, "shift": a << 1}

    Let sum_val be dict at "sum"
    Let product_val be dict at "product"
    Let shift_val be dict at "shift"

    If sum_val is equal to 8:
        If product_val is equal to 15:
            If shift_val is equal to 10:
                proc println from Console with "✓ Integration Dict Complex Values: PASSED"
                Return 1
            End If
        End If
    End If

    proc println from Console with "✗ Integration Dict Complex Values: FAILED"
    Return 0
End Process

Process called "test_integration_list_comprehension_syntax" returns Integer:
    Note: Test: List with computed elements
    Let base be 2
    Let list be [base, base << 1, base << 2, base << 3]

    Let item0 be list at 0
    Let item1 be list at 1
    Let item2 be list at 2
    Let item3 be list at 3

    If item0 is equal to 2:
        If item1 is equal to 4:
            If item2 is equal to 8:
                If item3 is equal to 16:
                    proc println from Console with "✓ Integration List Comprehension: PASSED"
                    Return 1
                End If
            End If
        End If
    End If

    proc println from Console with "✗ Integration List Comprehension: FAILED"
    Return 0
End Process

Process called "test_integration_mixed_assignment_types" returns Integer:
    Note: Test: Mix of regular and compound assignments
    Let x be 10
    Let y be 5

    x = x + y
    y += x

    If x is equal to 15:
        If y is equal to 20:
            proc println from Console with "✓ Integration Mixed Assignments: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Integration Mixed Assignments: FAILED"
    Return 0
End Process

Process called "test_integration_ternary_chain" returns Integer:
    Note: Test: Multiple ternaries in sequence
    Let x be 5
    Let result1 be x > 3 ? 100 : 200
    Let result2 be x < 10 ? result1 : 300

    If result1 is equal to 100:
        If result2 is equal to 100:
            proc println from Console with "✓ Integration Ternary Chain: PASSED"
            Return 1
        End If
    End If

    proc println from Console with "✗ Integration Ternary Chain: FAILED"
    Return 0
End Process

Note: ============================================================================
Note: MAIN TEST RUNNER
Note: ============================================================================

Process called "main" returns Integer:
    proc println from Console with "============================================"
    proc println from Console with "Developer Syntax Comprehensive Test Suite"
    proc println from Console with "============================================"
    proc println from Console with ""

    Let total_tests be 0
    Let passed_tests be 0

    Note: SECTION 1: Bitwise Operators (6 tests)
    proc println from Console with "SECTION 1: BITWISE OPERATORS"
    proc println from Console with "--------------------------------------------"

    Let test1 be proc test_bitwise_and
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test1

    Let test2 be proc test_bitwise_or
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test2

    Let test3 be proc test_bitwise_xor
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test3

    Let test4 be proc test_bitwise_not
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test4

    Let test5 be proc test_shift_left
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test5

    Let test6 be proc test_shift_right
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test6

    proc println from Console with ""

    Note: SECTION 2: List Literals (5 tests)
    proc println from Console with "SECTION 2: LIST LITERALS"
    proc println from Console with "--------------------------------------------"

    Let test7 be proc test_list_literal_basic
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test7

    Let test8 be proc test_list_literal_empty
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test8

    Let test9 be proc test_list_literal_single
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test9

    Let test10 be proc test_list_literal_nested
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test10

    Let test11 be proc test_list_literal_strings
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test11

    proc println from Console with ""

    Note: SECTION 3: Dictionary Literals (5 tests)
    proc println from Console with "SECTION 3: DICTIONARY LITERALS"
    proc println from Console with "--------------------------------------------"

    Let test12 be proc test_dict_literal_basic
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test12

    Let test13 be proc test_dict_literal_empty
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test13

    Let test14 be proc test_dict_literal_multiple
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test14

    Let test15 be proc test_dict_literal_integers
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test15

    Let test16 be proc test_dict_literal_nested
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test16

    proc println from Console with ""

    Note: SECTION 4: Array Indexing (4 tests)
    proc println from Console with "SECTION 4: ARRAY INDEXING"
    proc println from Console with "--------------------------------------------"

    Let test17 be proc test_array_indexing_basic
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test17

    Let test18 be proc test_array_indexing_middle
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test18

    Let test19 be proc test_array_indexing_expression
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test19

    Let test20 be proc test_dict_indexing
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test20

    proc println from Console with ""

    Note: SECTION 5: Assignment (3 tests)
    proc println from Console with "SECTION 5: ASSIGNMENT"
    proc println from Console with "--------------------------------------------"

    Let test21 be proc test_assignment_basic
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test21

    Let test22 be proc test_assignment_expression
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test22

    Let test23 be proc test_assignment_complex
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test23

    proc println from Console with ""

    Note: SECTION 6: Compound Assignment (9 tests)
    proc println from Console with "SECTION 6: COMPOUND ASSIGNMENT"
    proc println from Console with "--------------------------------------------"

    Let test24 be proc test_compound_plus_assign
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test24

    Let test25 be proc test_compound_minus_assign
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test25

    Let test26 be proc test_compound_multiply_assign
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test26

    Let test27 be proc test_compound_divide_assign
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test27

    Let test28 be proc test_compound_and_assign
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test28

    Let test29 be proc test_compound_or_assign
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test29

    Let test30 be proc test_compound_xor_assign
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test30

    Let test31 be proc test_compound_shift_left_assign
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test31

    Let test32 be proc test_compound_shift_right_assign
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test32

    proc println from Console with ""

    Note: SECTION 7: Function Calls (4 tests)
    proc println from Console with "SECTION 7: FUNCTION CALLS"
    proc println from Console with "--------------------------------------------"

    Let test33 be proc test_function_call_no_args
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test33

    Let test34 be proc test_function_call_single_arg
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test34

    Let test35 be proc test_function_call_multiple_args
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test35

    Let test36 be proc test_function_call_nested
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test36

    proc println from Console with ""

    Note: SECTION 8: Method Calls (3 tests)
    proc println from Console with "SECTION 8: METHOD CALLS"
    proc println from Console with "--------------------------------------------"

    Let test37 be proc test_method_call_no_args
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test37

    Let test38 be proc test_method_call_single_arg
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test38

    Let test39 be proc test_method_call_chained
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test39

    proc println from Console with ""

    Note: SECTION 9: Ternary Operators (3 tests)
    proc println from Console with "SECTION 9: TERNARY OPERATORS"
    proc println from Console with "--------------------------------------------"

    Let test40 be proc test_ternary_basic
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test40

    Let test41 be proc test_ternary_false_branch
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test41

    Let test42 be proc test_ternary_nested
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test42

    proc println from Console with ""

    Note: SECTION 10: Complex Integration (20 tests)
    proc println from Console with "SECTION 10: COMPLEX INTEGRATION"
    proc println from Console with "--------------------------------------------"

    Let test43 be proc test_integration_list_with_bitwise
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test43

    Let test44 be proc test_integration_dict_with_ternary
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test44

    Let test45 be proc test_integration_assignment_with_list
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test45

    Let test46 be proc test_integration_compound_with_shift
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test46

    Let test47 be proc test_integration_function_with_list_arg
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test47

    Let test48 be proc test_integration_array_index_with_expression
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test48

    Let test49 be proc test_integration_nested_list_indexing
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test49

    Let test50 be proc test_integration_ternary_in_list
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test50

    Let test51 be proc test_integration_bitwise_in_assignment
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test51

    Let test52 be proc test_integration_shift_with_ternary
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test52

    Let test53 be proc test_integration_all_operators_combined
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test53

    Let test54 be proc test_integration_compound_chain
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test54

    Let test55 be proc test_integration_nested_dict_list
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test55

    Let test56 be proc test_integration_triple_nested_list
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test56

    Let test57 be proc test_integration_ternary_with_compound
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test57

    Let test58 be proc test_integration_function_with_all_syntax
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test58

    Let test59 be proc test_integration_dict_complex_values
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test59

    Let test60 be proc test_integration_list_comprehension_syntax
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test60

    Let test61 be proc test_integration_mixed_assignment_types
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test61

    Let test62 be proc test_integration_ternary_chain
    Set total_tests to total_tests plus 1
    Set passed_tests to passed_tests plus test62

    proc println from Console with ""

    Note: Print final summary
    proc println from Console with "============================================"

    Let failed_count be total_tests minus passed_tests

    If failed_count is equal to 0:
        Let summary be proc format from Format with "✓ ALL TESTS PASSED ({}/{})", passed_tests, total_tests
        proc println from Console with summary
        proc println from Console with "============================================"
        Return 0
    Otherwise:
        Let summary be proc format from Format with "✗ TESTS FAILED: {}/{} passed, {} failed", passed_tests, total_tests, failed_count
        proc println from Console with summary
        proc println from Console with "============================================"
        Return failed_count
    End If
End Process
