// AST implementation transpiled from Rust to Runa-Zero
// Uses fixed-size arrays and manual memory management

// Memory management
global MEMORY_POOL = 0;
global MEMORY_OFFSET = 0;
global MEMORY_SIZE = 131072;

fn allocate(size: i64) -> i64 {
    if (MEMORY_OFFSET + size > MEMORY_SIZE) {
        return 0;
    }
    let ptr: i64 = MEMORY_POOL + MEMORY_OFFSET;
    MEMORY_OFFSET = MEMORY_OFFSET + size;
    return ptr;
}

fn init_memory() -> i64 {
    MEMORY_POOL = malloc(MEMORY_SIZE * 8);
    if (MEMORY_POOL == 0) {
        return 0;
    }
    MEMORY_OFFSET = 0;
    return 1;
}

// Token type constants
global TOKEN_NUMBER = 1;
global TOKEN_IDENTIFIER = 2;
global TOKEN_FN = 3;
global TOKEN_LET = 4;
global TOKEN_IF = 5;
global TOKEN_ELSE = 6;
global TOKEN_WHILE = 7;
global TOKEN_RETURN = 8;
global TOKEN_GLOBAL = 9;
global TOKEN_PLUS = 10;
global TOKEN_MINUS = 11;
global TOKEN_DIVIDE = 12;
global TOKEN_ASSIGN = 13;
global TOKEN_EQUAL = 14;
global TOKEN_NOT_EQUAL = 15;
global TOKEN_LESS = 16;
global TOKEN_GREATER = 17;
global TOKEN_LESS_EQUAL = 18;
global TOKEN_GREATER_EQUAL = 19;
global TOKEN_LEFT_PAREN = 20;
global TOKEN_RIGHT_PAREN = 21;
global TOKEN_LEFT_BRACE = 22;
global TOKEN_RIGHT_BRACE = 23;
global TOKEN_SEMICOLON = 24;
global TOKEN_COLON = 25;
global TOKEN_ARROW = 26;
global TOKEN_AMPERSAND = 27;
global TOKEN_STAR = 28;
global TOKEN_COMMA = 29;
global TOKEN_STRING_LITERAL = 30;
global TOKEN_CHAR_LITERAL = 31;
global TOKEN_NEWLINE = 32;
global TOKEN_EOF = 33;

// Token storage arrays
global TOKEN_TYPES = 0;
global TOKEN_VALUES = 0;
global TOKEN_STRINGS = 0;
global TOKEN_COUNT = 0;
global MAX_TOKENS = 1000;

// Statement type constants
global STMT_FUNCTION_DEF = 100;
global STMT_GLOBAL_DECL = 101;
global STMT_VARIABLE_DECL = 102;
global STMT_ASSIGNMENT = 103;
global STMT_IF = 104;
global STMT_WHILE = 105;
global STMT_RETURN = 106;
global STMT_EXPRESSION = 107;

// Expression type constants
global EXPR_LITERAL = 200;
global EXPR_STRING_LITERAL = 201;
global EXPR_CHAR_LITERAL = 202;
global EXPR_VARIABLE = 203;
global EXPR_BINARY_OP = 204;
global EXPR_UNARY_OP = 205;
global EXPR_CALL = 206;
global EXPR_ADDRESS_OF = 207;
global EXPR_DEREFERENCE = 208;

// Binary operator constants
global OP_ADD = 1;
global OP_SUB = 2;
global OP_MUL = 3;
global OP_DIV = 4;
global OP_EQUAL = 5;
global OP_NOT_EQUAL = 6;
global OP_LESS = 7;
global OP_GREATER = 8;
global OP_LESS_EQUAL = 9;
global OP_GREATER_EQUAL = 10;

// Unary operator constants
global UNARY_MINUS = 1;

// AST node storage
global AST_NODES = 0;
global AST_COUNT = 0;
global MAX_AST_NODES = 2000;
global AST_NODE_SIZE = 8;

// String storage for identifiers and literals
global STRING_STORAGE = 0;
global STRING_OFFSET = 0;
global MAX_STRING_STORAGE = 50000;

fn init_ast() -> i64 {
    TOKEN_TYPES = allocate(MAX_TOKENS * 8);
    TOKEN_VALUES = allocate(MAX_TOKENS * 8);
    TOKEN_STRINGS = allocate(MAX_TOKENS * 8);
    AST_NODES = allocate(MAX_AST_NODES * AST_NODE_SIZE);
    STRING_STORAGE = allocate(MAX_STRING_STORAGE);

    if (TOKEN_TYPES == 0) {
        return 0;
    }
    if (TOKEN_VALUES == 0) {
        return 0;
    }
    if (TOKEN_STRINGS == 0) {
        return 0;
    }
    if (AST_NODES == 0) {
        return 0;
    }
    if (STRING_STORAGE == 0) {
        return 0;
    }

    TOKEN_COUNT = 0;
    AST_COUNT = 0;
    STRING_OFFSET = 0;

    return 1;
}

// String operations
fn string_length(str: i64) -> i64 {
    let len: i64 = 0;
    while (*(str + len) != 0) {
        len = len + 1;
    }
    return len;
}

fn string_copy(dest: i64, src: i64) -> i64 {
    let i: i64 = 0;
    while (*(src + i) != 0) {
        *(dest + i) = *(src + i);
        i = i + 1;
    }
    *(dest + i) = 0;
    return i;
}

fn string_compare(str1: i64, str2: i64) -> i64 {
    let i: i64 = 0;
    while (*(str1 + i) != 0) {
        if (*(str2 + i) == 0) {
            return 0;
        }
        if (*(str1 + i) != *(str2 + i)) {
            return 0;
        }
        i = i + 1;
    }
    if (*(str1 + i) == 0) {
        if (*(str2 + i) == 0) {
            return 1;
        }
    }
    return 0;
}

fn store_string(str: i64) -> i64 {
    let len: i64 = string_length(str);
    if (STRING_OFFSET + len + 1 > MAX_STRING_STORAGE) {
        return 0;
    }

    let offset: i64 = STRING_OFFSET;
    string_copy(STRING_STORAGE + offset, str);
    STRING_OFFSET = STRING_OFFSET + len + 1;
    return offset;
}

fn store_string_n(str: i64, len: i64) -> i64 {
    if (STRING_STORAGE == 0) {
        puts("ERROR: STRING_STORAGE is null!");
        return 0;
    }
    if (STRING_OFFSET + len + 1 > MAX_STRING_STORAGE) {
        puts("ERROR: STRING_STORAGE overflow!");
        return 0;
    }

    let offset: i64 = STRING_OFFSET;
    let i: i64 = 0;
    while (i < len) {
        *(STRING_STORAGE + offset + i) = *(str + i);
        i = i + 1;
    }
    *(STRING_STORAGE + offset + len) = 0;
    STRING_OFFSET = STRING_OFFSET + len + 1;
    return offset;
}

fn get_string(offset: i64) -> i64 {
    return STRING_STORAGE + offset;
}

// Token operations
fn add_token(token_type: i64, value: i64, string_data: i64) -> i64 {
    if (TOKEN_COUNT >= MAX_TOKENS) {
        return 0;
    }

    *(TOKEN_TYPES + TOKEN_COUNT) = token_type;
    *(TOKEN_VALUES + TOKEN_COUNT) = value;
    *(TOKEN_STRINGS + TOKEN_COUNT) = string_data;
    TOKEN_COUNT = TOKEN_COUNT + 1;
    return 1;
}

fn get_token_type(index: i64) -> i64 {
    if (index >= TOKEN_COUNT) {
        return TOKEN_EOF;
    }
    return *(TOKEN_TYPES + index);
}

fn get_token_value(index: i64) -> i64 {
    if (index >= TOKEN_COUNT) {
        return 0;
    }
    return *(TOKEN_VALUES + index);
}

fn get_token_string(index: i64) -> i64 {
    if (index >= TOKEN_COUNT) {
        return 0;
    }
    return *(TOKEN_STRINGS + index);
}

// AST node operations
fn create_node(node_type: i64) -> i64 {
    if (AST_COUNT >= MAX_AST_NODES) {
        return 0;
    }

    let node_index: i64 = AST_COUNT;
    let node_ptr: i64 = AST_NODES + (node_index * AST_NODE_SIZE);

    // Initialize node
    let i: i64 = 0;
    while (i < AST_NODE_SIZE) {
        *(node_ptr + i) = 0;
        i = i + 1;
    }

    *(node_ptr + 0) = node_type;
    AST_COUNT = AST_COUNT + 1;
    return node_index;
}

fn get_node_type(node_index: i64) -> i64 {
    if (node_index >= AST_COUNT) {
        return 0;
    }
    let node_ptr: i64 = AST_NODES + (node_index * AST_NODE_SIZE);
    return *(node_ptr + 0);
}

fn set_node_data(node_index: i64, field: i64, value: i64) -> i64 {
    if (node_index >= AST_COUNT) {
        return 0;
    }
    if (field >= AST_NODE_SIZE) {
        return 0;
    }
    let node_ptr: i64 = AST_NODES + (node_index * AST_NODE_SIZE);
    *(node_ptr + field) = value;
    return 1;
}

fn get_node_data(node_index: i64, field: i64) -> i64 {
    if (node_index >= AST_COUNT) {
        return 0;
    }
    if (field >= AST_NODE_SIZE) {
        return 0;
    }
    let node_ptr: i64 = AST_NODES + (node_index * AST_NODE_SIZE);
    return *(node_ptr + field);
}

// Expression constructors
fn create_literal_expr(value: i64) -> i64 {
    let node: i64 = create_node(EXPR_LITERAL);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, value);
    return node;
}

fn create_variable_expr(name_offset: i64) -> i64 {
    let node: i64 = create_node(EXPR_VARIABLE);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, name_offset);
    return node;
}

fn create_binary_expr(op: i64, left: i64, right: i64) -> i64 {
    let node: i64 = create_node(EXPR_BINARY_OP);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, op);
    set_node_data(node, 2, left);
    set_node_data(node, 3, right);
    return node;
}

fn create_unary_expr(op: i64, operand: i64) -> i64 {
    let node: i64 = create_node(EXPR_UNARY_OP);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, op);
    set_node_data(node, 2, operand);
    return node;
}

fn create_call_expr(name_offset: i64, arg_count: i64) -> i64 {
    let node: i64 = create_node(EXPR_CALL);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, name_offset);
    set_node_data(node, 2, arg_count);
    return node;
}

// Statement constructors
fn create_function_stmt(name_offset: i64, param_count: i64, return_type_offset: i64, body_count: i64) -> i64 {
    let node: i64 = create_node(STMT_FUNCTION_DEF);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, name_offset);
    set_node_data(node, 2, param_count);
    set_node_data(node, 3, return_type_offset);
    set_node_data(node, 4, body_count);
    return node;
}

fn create_global_stmt(name_offset: i64, value_expr: i64) -> i64 {
    let node: i64 = create_node(STMT_GLOBAL_DECL);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, name_offset);
    set_node_data(node, 2, value_expr);
    return node;
}

fn create_variable_stmt(name_offset: i64, type_offset: i64, value_expr: i64) -> i64 {
    let node: i64 = create_node(STMT_VARIABLE_DECL);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, name_offset);
    set_node_data(node, 2, type_offset);
    set_node_data(node, 3, value_expr);
    return node;
}

fn create_return_stmt(expr: i64) -> i64 {
    let node: i64 = create_node(STMT_RETURN);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, expr);
    return node;
}

fn create_if_stmt(condition: i64, then_count: i64, else_count: i64) -> i64 {
    let node: i64 = create_node(STMT_IF);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, condition);
    set_node_data(node, 2, then_count);
    set_node_data(node, 3, else_count);
    return node;
}

fn create_while_stmt(condition: i64, body_count: i64) -> i64 {
    let node: i64 = create_node(STMT_WHILE);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, condition);
    set_node_data(node, 2, body_count);
    return node;
}

// Additional string utility functions needed by codegen
fn int_to_string(n: i64) -> i64 {
    let buffer: i64 = allocate(32);
    let ptr: i64 = buffer;
    let negative: i64 = 0;
    let num: i64 = n;

    if (num < 0) {
        negative = 1;
        num = 0 - num;
    }

    if (num == 0) {
        *ptr = 48; // '0'
        *(ptr + 1) = 0;
        return buffer;
    }

    // Convert digits
    let digits: i64 = 0;
    let temp: i64 = num;
    while (temp > 0) {
        digits = digits + 1;
        temp = temp / 10;
    }

    // Write digits in reverse
    let pos: i64 = digits - 1;
    if (negative) {
        pos = pos + 1;
    }

    temp = num;
    while (temp > 0) {
        let digit: i64 = temp - (temp / 10) * 10;  // Modulo using division
        *(ptr + pos) = digit + 48;
        pos = pos - 1;
        temp = temp / 10;
    }

    if (negative) {
        *ptr = 45; // '-'
    }

    // Null terminate
    if (negative) {
        *(ptr + digits + 1) = 0;
    } else {
        *(ptr + digits) = 0;
    }

    return buffer;
}

fn string_concat(dest: i64, src: i64) -> i64 {
    // Find end of destination string
    let dest_ptr: i64 = dest;
    while (*dest_ptr != 0) {
        dest_ptr = dest_ptr + 1;
    }

    // Copy source to end of destination
    let src_ptr: i64 = src;
    while (*src_ptr != 0) {
        *dest_ptr = *src_ptr;
        dest_ptr = dest_ptr + 1;
        src_ptr = src_ptr + 1;
    }

    // Null terminate
    *dest_ptr = 0;
    return dest;
}

// Lexer implementation transpiled from Rust to Runa-Zero
// Uses fixed-size arrays instead of Vec<char> and String

// Lexer state
global INPUT_CHARS = 0;
global INPUT_LENGTH = 0;
global POSITION = 0;
global LINE = 1;
global COLUMN = 1;

// Character classification helpers
fn is_digit(ch: i64) -> i64 {
    if (ch >= 48) {
        if (ch <= 57) {
            return 1;
        }
    }
    return 0;
}

fn is_alpha(ch: i64) -> i64 {
    if (ch >= 97) {
        if (ch <= 122) {
            return 1;
        }
    }
    if (ch >= 65) {
        if (ch <= 90) {
            return 1;
        }
    }
    if (ch == 95) {
        return 1;
    }
    return 0;
}

fn is_alnum(ch: i64) -> i64 {
    if (is_alpha(ch) == 1) {
        return 1;
    }
    if (is_digit(ch) == 1) {
        return 1;
    }
    return 0;
}

fn is_whitespace(ch: i64) -> i64 {
    if (ch == 32) {
        return 1;
    }
    if (ch == 9) {
        return 1;
    }
    if (ch == 13) {
        return 1;
    }
    return 0;
}

// Lexer initialization
fn lexer_new(input: i64, length: i64) -> i64 {
    INPUT_CHARS = input;
    INPUT_LENGTH = length;
    POSITION = 0;
    LINE = 1;
    COLUMN = 1;
    return 1;
}

// Current character operations
fn current_char() -> i64 {
    if (POSITION >= INPUT_LENGTH) {
        return 0;
    }
    return *(INPUT_CHARS + POSITION);
}

fn advance() -> i64 {
    if (POSITION >= INPUT_LENGTH) {
        return 0;
    }

    let ch: i64 = *(INPUT_CHARS + POSITION);
    POSITION = POSITION + 1;

    if (ch == 10) {
        LINE = LINE + 1;
        COLUMN = 1;
    } else {
        COLUMN = COLUMN + 1;
    }

    return ch;
}

fn peek() -> i64 {
    if (POSITION + 1 >= INPUT_LENGTH) {
        return 0;
    }
    return *(INPUT_CHARS + POSITION + 1);
}

// Number reading
fn read_number() -> i64 {
    let number: i64 = 0;

    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();
        if (is_digit(ch) == 0) {
            return number;
        }
        number = number * 10 + (ch - 48);
        advance();
    }

    return number;
}

// Identifier reading
fn read_identifier() -> i64 {
    let start_pos: i64 = POSITION;
    let length: i64 = 0;

    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();
        if (is_alnum(ch) == 0) {
            return length;
        }
        length = length + 1;
        advance();
    }

    return length;
}

// String reading
fn read_string() -> i64 {
    advance();
    let start_pos: i64 = POSITION;
    let length: i64 = 0;

    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();
        if (ch == 34) {
            advance();
            return length;
        }
        if (ch == 10) {
            return -1;
        }
        if (ch == 92) {
            advance();
            if (POSITION >= INPUT_LENGTH) {
                return -1;
            }
            advance();
            length = length + 2;
        } else {
            advance();
            length = length + 1;
        }
    }

    return -1;
}

// Character reading
fn read_char() -> i64 {
    advance();

    if (POSITION >= INPUT_LENGTH) {
        return -1;
    }

    let ch: i64 = current_char();
    if (ch == 92) {
        advance();
        if (POSITION >= INPUT_LENGTH) {
            return -1;
        }
        let escaped: i64 = current_char();
        advance();

        if (current_char() != 39) {
            return -1;
        }
        advance();

        if (escaped == 110) {
            return 10;
        }
        if (escaped == 116) {
            return 9;
        }
        if (escaped == 114) {
            return 13;
        }
        if (escaped == 92) {
            return 92;
        }
        if (escaped == 39) {
            return 39;
        }
        return escaped;
    } else {
        advance();
        if (current_char() != 39) {
            return -1;
        }
        advance();
        return ch;
    }
}

// Comment skipping
fn skip_line_comment() -> i64 {
    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();
        if (ch == 10) {
            return 1;
        }
        advance();
    }
    return 1;
}

// Keyword recognition
fn keyword_or_identifier(text_start: i64, length: i64) -> i64 {
    if (length == 2) {
        if (*(text_start + 0) == 102) {
            if (*(text_start + 1) == 110) {
                return TOKEN_FN;
            }
        }
        if (*(text_start + 0) == 105) {
            if (*(text_start + 1) == 102) {
                return TOKEN_IF;
            }
        }
    }

    if (length == 3) {
        if (*(text_start + 0) == 108) {
            if (*(text_start + 1) == 101) {
                if (*(text_start + 2) == 116) {
                    return TOKEN_LET;
                }
            }
        }
    }

    if (length == 4) {
        if (*(text_start + 0) == 101) {
            if (*(text_start + 1) == 108) {
                if (*(text_start + 2) == 115) {
                    if (*(text_start + 3) == 101) {
                        return TOKEN_ELSE;
                    }
                }
            }
        }
    }

    if (length == 5) {
        if (*(text_start + 0) == 119) {
            if (*(text_start + 1) == 104) {
                if (*(text_start + 2) == 105) {
                    if (*(text_start + 3) == 108) {
                        if (*(text_start + 4) == 101) {
                            return TOKEN_WHILE;
                        }
                    }
                }
            }
        }
    }

    if (length == 6) {
        if (*(text_start + 0) == 114) {
            if (*(text_start + 1) == 101) {
                if (*(text_start + 2) == 116) {
                    if (*(text_start + 3) == 117) {
                        if (*(text_start + 4) == 114) {
                            if (*(text_start + 5) == 110) {
                                return TOKEN_RETURN;
                            }
                        }
                    }
                }
            }
        }
        if (*(text_start + 0) == 103) {
            if (*(text_start + 1) == 108) {
                if (*(text_start + 2) == 111) {
                    if (*(text_start + 3) == 98) {
                        if (*(text_start + 4) == 97) {
                            if (*(text_start + 5) == 108) {
                                return TOKEN_GLOBAL;
                            }
                        }
                    }
                }
            }
        }
    }

    return TOKEN_IDENTIFIER;
}

// Main tokenization function
fn tokenize() -> i64 {
    TOKEN_COUNT = 0;

    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();

        // Debug: Show current character
        puts("DEBUG: Processing character at position");

        if (is_whitespace(ch) == 1) {
            advance();
            continue;
        }

        if (ch == 10) {
            if (add_token(TOKEN_NEWLINE, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (is_digit(ch) == 1) {
            let number: i64 = read_number();
            if (add_token(TOKEN_NUMBER, number, 0) == 0) {
                return 0;
            }
            continue;
        }

        if (is_alpha(ch) == 1) {
            puts("DEBUG: Found alphabetic character");
            let start_pos: i64 = POSITION;
            let length: i64 = read_identifier();
            puts("DEBUG: After read_identifier");
            let token_type: i64 = keyword_or_identifier(INPUT_CHARS + start_pos, length);
            puts("DEBUG: After keyword_or_identifier");

            let string_offset: i64 = 0;
            if (token_type == TOKEN_IDENTIFIER) {
                puts("DEBUG: Is identifier, storing string");
                string_offset = store_string_n(INPUT_CHARS + start_pos, length);
                if (string_offset == 0) {
                    puts("ERROR: store_string returned 0");
                    return 0;
                }
            }

            puts("DEBUG: About to add_token");
            if (add_token(token_type, 0, string_offset) == 0) {
                puts("ERROR: add_token returned 0");
                return 0;
            }
            puts("DEBUG: Successfully added token");
            continue;
        }

        if (ch == 34) {
            let start_pos: i64 = POSITION + 1;
            let length: i64 = read_string();
            if (length < 0) {
                return 0;
            }

            let string_offset: i64 = store_string_n(INPUT_CHARS + start_pos, length);
            if (string_offset == 0) {
                return 0;
            }

            if (add_token(TOKEN_STRING_LITERAL, 0, string_offset) == 0) {
                return 0;
            }
            continue;
        }

        if (ch == 39) {
            let char_value: i64 = read_char();
            if (char_value < 0) {
                return 0;
            }

            if (add_token(TOKEN_CHAR_LITERAL, char_value, 0) == 0) {
                return 0;
            }
            continue;
        }

        if (ch == 43) {
            if (add_token(TOKEN_PLUS, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 45) {
            if (peek() == 62) {
                if (add_token(TOKEN_ARROW, 0, 0) == 0) {
                    return 0;
                }
                advance();
                advance();
            } else {
                if (add_token(TOKEN_MINUS, 0, 0) == 0) {
                    return 0;
                }
                advance();
            }
            continue;
        }

        if (ch == 42) {
            if (add_token(TOKEN_STAR, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 47) {
            if (peek() == 47) {
                skip_line_comment();
            } else {
                if (add_token(TOKEN_DIVIDE, 0, 0) == 0) {
                    return 0;
                }
                advance();
            }
            continue;
        }

        if (ch == 61) {
            if (peek() == 61) {
                if (add_token(TOKEN_EQUAL, 0, 0) == 0) {
                    return 0;
                }
                advance();
                advance();
            } else {
                if (add_token(TOKEN_ASSIGN, 0, 0) == 0) {
                    return 0;
                }
                advance();
            }
            continue;
        }

        if (ch == 33) {
            if (peek() == 61) {
                if (add_token(TOKEN_NOT_EQUAL, 0, 0) == 0) {
                    return 0;
                }
                advance();
                advance();
            } else {
                return 0;
            }
            continue;
        }

        if (ch == 60) {
            if (peek() == 61) {
                if (add_token(TOKEN_LESS_EQUAL, 0, 0) == 0) {
                    return 0;
                }
                advance();
                advance();
            } else {
                if (add_token(TOKEN_LESS, 0, 0) == 0) {
                    return 0;
                }
                advance();
            }
            continue;
        }

        if (ch == 62) {
            if (peek() == 61) {
                if (add_token(TOKEN_GREATER_EQUAL, 0, 0) == 0) {
                    return 0;
                }
                advance();
                advance();
            } else {
                if (add_token(TOKEN_GREATER, 0, 0) == 0) {
                    return 0;
                }
                advance();
            }
            continue;
        }

        if (ch == 40) {
            if (add_token(TOKEN_LEFT_PAREN, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 41) {
            if (add_token(TOKEN_RIGHT_PAREN, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 123) {
            if (add_token(TOKEN_LEFT_BRACE, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 125) {
            if (add_token(TOKEN_RIGHT_BRACE, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 59) {
            if (add_token(TOKEN_SEMICOLON, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 58) {
            if (add_token(TOKEN_COLON, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 38) {
            if (add_token(TOKEN_AMPERSAND, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 44) {
            if (add_token(TOKEN_COMMA, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        // Unrecognized character
        puts("Error: Unrecognized character in lexer");
        return 0;
    }

    if (add_token(TOKEN_EOF, 0, 0) == 0) {
        return 0;
    }

    return 1;
}

// Initialize lexer state
fn init_lexer() -> i64 {
    INPUT_CHARS = 0;
    INPUT_LENGTH = 0;
    POSITION = 0;
    LINE = 1;
    COLUMN = 1;

    TOKEN_COUNT = 0;
    TOKEN_TYPES = allocate(1000 * 8);
    TOKEN_VALUES = allocate(1000 * 8);
    TOKEN_STRINGS = allocate(1000 * 8);

    return 1;
}

// Parser implementation transpiled from Rust to Runa-Zero
// Complete parser with all statement and expression parsing

// Parser state
global CURRENT_TOKEN_INDEX = 0;

// Initialize parser state
fn init_parser() -> i64 {
    CURRENT_TOKEN_INDEX = 0;
    return 1;
}

fn parser_new() -> i64 {
    CURRENT_TOKEN_INDEX = 0;
    return 1;
}

fn current_token_type() -> i64 {
    if (CURRENT_TOKEN_INDEX >= TOKEN_COUNT) {
        return TOKEN_EOF;
    }
    return *(TOKEN_TYPES + CURRENT_TOKEN_INDEX);
}

fn current_token_value() -> i64 {
    if (CURRENT_TOKEN_INDEX >= TOKEN_COUNT) {
        return 0;
    }
    return *(TOKEN_VALUES + CURRENT_TOKEN_INDEX);
}

fn current_token_string() -> i64 {
    if (CURRENT_TOKEN_INDEX >= TOKEN_COUNT) {
        return 0;
    }
    return *(TOKEN_STRINGS + CURRENT_TOKEN_INDEX);
}

fn advance_token() -> i64 {
    if (CURRENT_TOKEN_INDEX < TOKEN_COUNT) {
        CURRENT_TOKEN_INDEX = CURRENT_TOKEN_INDEX + 1;
    }
    return 1;
}

fn previous_token_type() -> i64 {
    if (CURRENT_TOKEN_INDEX == 0) {
        return TOKEN_EOF;
    }
    return *(TOKEN_TYPES + CURRENT_TOKEN_INDEX - 1);
}

fn previous_token_value() -> i64 {
    if (CURRENT_TOKEN_INDEX == 0) {
        return 0;
    }
    return *(TOKEN_VALUES + CURRENT_TOKEN_INDEX - 1);
}

fn previous_token_string() -> i64 {
    if (CURRENT_TOKEN_INDEX == 0) {
        return 0;
    }
    return *(TOKEN_STRINGS + CURRENT_TOKEN_INDEX - 1);
}

fn is_at_end() -> i64 {
    return (current_token_type() == TOKEN_EOF);
}

fn skip_newlines() -> i64 {
    while (current_token_type() == TOKEN_NEWLINE) {
        advance_token();
    }
    return 1;
}

fn expect_token(expected_type: i64) -> i64 {
    if (current_token_type() == expected_type) {
        advance_token();
        return 1;
    }
    return 0;
}

// Parse program (list of global statements)
fn parse_program() -> i64 {
    let program_node: i64 = create_node(STMT_EXPRESSION);  // Root node

    while (is_at_end() == 0) {
        skip_newlines();
        if (is_at_end() == 1) {
            return program_node;
        }

        let stmt: i64 = 0;
        if (current_token_type() == TOKEN_FN) {
            stmt = parse_function();
        } else {
            if (current_token_type() == TOKEN_GLOBAL) {
                stmt = parse_global_declaration();
            } else {
                return 0;
            }
        }

        if (stmt == 0) {
            return 0;
        }

        skip_newlines();
    }

    return program_node;
}

// Parse function definition
fn parse_function() -> i64 {
    if (expect_token(TOKEN_FN) == 0) {
        return 0;
    }

    if (current_token_type() != TOKEN_IDENTIFIER) {
        return 0;
    }
    let name_offset: i64 = current_token_string();
    advance_token();

    if (expect_token(TOKEN_LEFT_PAREN) == 0) {
        return 0;
    }

    let param_count: i64 = 0;
    let params_start: i64 = AST_COUNT;

    if (current_token_type() != TOKEN_RIGHT_PAREN) {
        let done: i64 = 0;
        while (done == 0) {
            if (current_token_type() != TOKEN_IDENTIFIER) {
                return 0;
            }
            let param_name: i64 = current_token_string();
            advance_token();

            if (expect_token(TOKEN_COLON) == 0) {
                return 0;
            }

            if (current_token_type() != TOKEN_IDENTIFIER) {
                return 0;
            }
            let param_type: i64 = current_token_string();
            advance_token();

            // Store parameter as a node
            let param_node: i64 = create_node(EXPR_VARIABLE);
            set_node_data(param_node, 1, param_name);
            set_node_data(param_node, 2, param_type);
            param_count = param_count + 1;

            if (current_token_type() == TOKEN_COMMA) {
                advance_token();
            } else {
                done = 1;
            }
        }
    }

    if (expect_token(TOKEN_RIGHT_PAREN) == 0) {
        return 0;
    }

    if (expect_token(TOKEN_ARROW) == 0) {
        return 0;
    }

    if (current_token_type() != TOKEN_IDENTIFIER) {
        return 0;
    }
    let return_type: i64 = current_token_string();
    advance_token();

    if (expect_token(TOKEN_LEFT_BRACE) == 0) {
        return 0;
    }
    skip_newlines();

    let body_start: i64 = AST_COUNT;
    let body_count: i64 = 0;

    while (current_token_type() != TOKEN_RIGHT_BRACE) {
        if (is_at_end() == 1) {
            return 0;
        }

        let stmt: i64 = parse_statement();
        if (stmt == 0) {
            return 0;
        }
        body_count = body_count + 1;
        skip_newlines();
    }

    if (expect_token(TOKEN_RIGHT_BRACE) == 0) {
        return 0;
    }

    return create_function_stmt(name_offset, param_count, return_type, body_count);
}

// Parse global declaration
fn parse_global_declaration() -> i64 {
    if (expect_token(TOKEN_GLOBAL) == 0) {
        return 0;
    }

    if (current_token_type() != TOKEN_IDENTIFIER) {
        return 0;
    }
    let name_offset: i64 = current_token_string();
    advance_token();

    if (expect_token(TOKEN_ASSIGN) == 0) {
        return 0;
    }

    let value: i64 = parse_expression();
    if (value == 0) {
        return 0;
    }

    if (expect_token(TOKEN_SEMICOLON) == 0) {
        return 0;
    }

    return create_global_stmt(name_offset, value);
}

// Parse statement
fn parse_statement() -> i64 {
    if (current_token_type() == TOKEN_LET) {
        return parse_variable_declaration();
    }
    if (current_token_type() == TOKEN_IF) {
        return parse_if_statement();
    }
    if (current_token_type() == TOKEN_WHILE) {
        return parse_while_statement();
    }
    if (current_token_type() == TOKEN_RETURN) {
        return parse_return_statement();
    }

    // Try assignment or expression statement
    let expr: i64 = parse_expression();
    if (expr == 0) {
        return 0;
    }

    if (current_token_type() == TOKEN_ASSIGN) {
        advance_token();
        let value: i64 = parse_expression();
        if (value == 0) {
            return 0;
        }
        if (expect_token(TOKEN_SEMICOLON) == 0) {
            return 0;
        }

        let assign_node: i64 = create_node(STMT_ASSIGNMENT);
        set_node_data(assign_node, 1, expr);
        set_node_data(assign_node, 2, value);
        return assign_node;
    } else {
        if (expect_token(TOKEN_SEMICOLON) == 0) {
            return 0;
        }

        let expr_stmt: i64 = create_node(STMT_EXPRESSION);
        set_node_data(expr_stmt, 1, expr);
        return expr_stmt;
    }
}

// Parse variable declaration
fn parse_variable_declaration() -> i64 {
    if (expect_token(TOKEN_LET) == 0) {
        return 0;
    }

    if (current_token_type() != TOKEN_IDENTIFIER) {
        return 0;
    }
    let name_offset: i64 = current_token_string();
    advance_token();

    if (expect_token(TOKEN_COLON) == 0) {
        return 0;
    }

    if (current_token_type() != TOKEN_IDENTIFIER) {
        return 0;
    }
    let type_offset: i64 = current_token_string();
    advance_token();

    if (expect_token(TOKEN_ASSIGN) == 0) {
        return 0;
    }

    let value: i64 = parse_expression();
    if (value == 0) {
        return 0;
    }

    if (expect_token(TOKEN_SEMICOLON) == 0) {
        return 0;
    }

    return create_variable_stmt(name_offset, type_offset, value);
}

// Parse if statement
fn parse_if_statement() -> i64 {
    if (expect_token(TOKEN_IF) == 0) {
        return 0;
    }

    if (expect_token(TOKEN_LEFT_PAREN) == 0) {
        return 0;
    }

    let condition: i64 = parse_expression();
    if (condition == 0) {
        return 0;
    }

    if (expect_token(TOKEN_RIGHT_PAREN) == 0) {
        return 0;
    }

    if (expect_token(TOKEN_LEFT_BRACE) == 0) {
        return 0;
    }
    skip_newlines();

    let then_start: i64 = AST_COUNT;
    let then_count: i64 = 0;

    while (current_token_type() != TOKEN_RIGHT_BRACE) {
        if (is_at_end() == 1) {
            return 0;
        }

        let stmt: i64 = parse_statement();
        if (stmt == 0) {
            return 0;
        }
        then_count = then_count + 1;
        skip_newlines();
    }

    if (expect_token(TOKEN_RIGHT_BRACE) == 0) {
        return 0;
    }

    let else_count: i64 = 0;
    if (current_token_type() == TOKEN_ELSE) {
        advance_token();

        if (expect_token(TOKEN_LEFT_BRACE) == 0) {
            return 0;
        }
        skip_newlines();

        while (current_token_type() != TOKEN_RIGHT_BRACE) {
            if (is_at_end() == 1) {
                return 0;
            }

            let stmt: i64 = parse_statement();
            if (stmt == 0) {
                return 0;
            }
            else_count = else_count + 1;
            skip_newlines();
        }

        if (expect_token(TOKEN_RIGHT_BRACE) == 0) {
            return 0;
        }
    }

    return create_if_stmt(condition, then_count, else_count);
}

// Parse while statement
fn parse_while_statement() -> i64 {
    if (expect_token(TOKEN_WHILE) == 0) {
        return 0;
    }

    if (expect_token(TOKEN_LEFT_PAREN) == 0) {
        return 0;
    }

    let condition: i64 = parse_expression();
    if (condition == 0) {
        return 0;
    }

    if (expect_token(TOKEN_RIGHT_PAREN) == 0) {
        return 0;
    }

    if (expect_token(TOKEN_LEFT_BRACE) == 0) {
        return 0;
    }
    skip_newlines();

    let body_start: i64 = AST_COUNT;
    let body_count: i64 = 0;

    while (current_token_type() != TOKEN_RIGHT_BRACE) {
        if (is_at_end() == 1) {
            return 0;
        }

        let stmt: i64 = parse_statement();
        if (stmt == 0) {
            return 0;
        }
        body_count = body_count + 1;
        skip_newlines();
    }

    if (expect_token(TOKEN_RIGHT_BRACE) == 0) {
        return 0;
    }

    return create_while_stmt(condition, body_count);
}

// Parse return statement
fn parse_return_statement() -> i64 {
    if (expect_token(TOKEN_RETURN) == 0) {
        return 0;
    }

    let expr: i64 = parse_expression();
    if (expr == 0) {
        return 0;
    }

    if (expect_token(TOKEN_SEMICOLON) == 0) {
        return 0;
    }

    return create_return_stmt(expr);
}

// Parse expression (equality level)
fn parse_expression() -> i64 {
    return parse_equality();
}

// Parse equality expressions
fn parse_equality() -> i64 {
    let expr: i64 = parse_comparison();
    if (expr == 0) {
        return 0;
    }

    let done: i64 = 0;
    while (done == 0) {
        let op: i64 = 0;
        if (current_token_type() == TOKEN_EQUAL) {
            op = OP_EQUAL;
            advance_token();
        } else {
            if (current_token_type() == TOKEN_NOT_EQUAL) {
                op = OP_NOT_EQUAL;
                advance_token();
            } else {
                done = 1;
            }
        }

        if (done == 0) {
            let right: i64 = parse_comparison();
            if (right == 0) {
                return 0;
            }

            expr = create_binary_expr(op, expr, right);
            if (expr == 0) {
                return 0;
            }
        }
    }

    return expr;
}

// Parse comparison expressions
fn parse_comparison() -> i64 {
    let expr: i64 = parse_term();
    if (expr == 0) {
        return 0;
    }

    let done: i64 = 0;
    while (done == 0) {
        let op: i64 = 0;
        if (current_token_type() == TOKEN_LESS) {
            op = OP_LESS;
            advance_token();
        } else {
            if (current_token_type() == TOKEN_GREATER) {
                op = OP_GREATER;
                advance_token();
            } else {
                if (current_token_type() == TOKEN_LESS_EQUAL) {
                    op = OP_LESS_EQUAL;
                    advance_token();
                } else {
                    if (current_token_type() == TOKEN_GREATER_EQUAL) {
                        op = OP_GREATER_EQUAL;
                        advance_token();
                    } else {
                        done = 1;
                    }
                }
            }
        }

        if (done == 0) {
            let right: i64 = parse_term();
            if (right == 0) {
                return 0;
            }

            expr = create_binary_expr(op, expr, right);
            if (expr == 0) {
                return 0;
            }
        }
    }

    return expr;
}

// Parse term (addition/subtraction)
fn parse_term() -> i64 {
    let expr: i64 = parse_factor();
    if (expr == 0) {
        return 0;
    }

    let done: i64 = 0;
    while (done == 0) {
        let op: i64 = 0;
        if (current_token_type() == TOKEN_PLUS) {
            op = OP_ADD;
            advance_token();
        } else {
            if (current_token_type() == TOKEN_MINUS) {
                op = OP_SUB;
                advance_token();
            } else {
                done = 1;
            }
        }

        if (done == 0) {
            let right: i64 = parse_factor();
            if (right == 0) {
                return 0;
            }

            expr = create_binary_expr(op, expr, right);
            if (expr == 0) {
                return 0;
            }
        }
    }

    return expr;
}

// Parse factor (multiplication/division)
fn parse_factor() -> i64 {
    let expr: i64 = parse_unary();
    if (expr == 0) {
        return 0;
    }

    let done: i64 = 0;
    while (done == 0) {
        let op: i64 = 0;
        if (current_token_type() == TOKEN_STAR) {
            op = OP_MUL;
            advance_token();
        } else {
            if (current_token_type() == TOKEN_DIVIDE) {
                op = OP_DIV;
                advance_token();
            } else {
                done = 1;
            }
        }

        if (done == 0) {
            let right: i64 = parse_unary();
            if (right == 0) {
                return 0;
            }

            expr = create_binary_expr(op, expr, right);
            if (expr == 0) {
                return 0;
            }
        }
    }

    return expr;
}

// Parse unary expressions
fn parse_unary() -> i64 {
    if (current_token_type() == TOKEN_MINUS) {
        advance_token();
        let operand: i64 = parse_unary();
        if (operand == 0) {
            return 0;
        }
        return create_unary_expr(UNARY_MINUS, operand);
    }

    if (current_token_type() == TOKEN_AMPERSAND) {
        advance_token();
        let operand: i64 = parse_unary();
        if (operand == 0) {
            return 0;
        }
        let node: i64 = create_node(EXPR_ADDRESS_OF);
        set_node_data(node, 1, operand);
        return node;
    }

    if (current_token_type() == TOKEN_STAR) {
        advance_token();
        let operand: i64 = parse_unary();
        if (operand == 0) {
            return 0;
        }
        let node: i64 = create_node(EXPR_DEREFERENCE);
        set_node_data(node, 1, operand);
        return node;
    }

    return parse_primary();
}

// Parse primary expressions
fn parse_primary() -> i64 {
    // Number literal
    if (current_token_type() == TOKEN_NUMBER) {
        let value: i64 = current_token_value();
        advance_token();
        return create_literal_expr(value);
    }

    // String literal
    if (current_token_type() == TOKEN_STRING_LITERAL) {
        let string_offset: i64 = current_token_string();
        advance_token();
        let node: i64 = create_node(EXPR_STRING_LITERAL);
        set_node_data(node, 1, string_offset);
        return node;
    }

    // Character literal
    if (current_token_type() == TOKEN_CHAR_LITERAL) {
        let char_value: i64 = current_token_value();
        advance_token();
        let node: i64 = create_node(EXPR_CHAR_LITERAL);
        set_node_data(node, 1, char_value);
        return node;
    }

    // Identifier (variable or function call)
    if (current_token_type() == TOKEN_IDENTIFIER) {
        let name_offset: i64 = current_token_string();
        advance_token();

        // Check for function call
        if (current_token_type() == TOKEN_LEFT_PAREN) {
            advance_token();

            let arg_count: i64 = 0;
            let args_start: i64 = AST_COUNT;

            if (current_token_type() != TOKEN_RIGHT_PAREN) {
                let done: i64 = 0;
                while (done == 0) {
                    let arg: i64 = parse_expression();
                    if (arg == 0) {
                        return 0;
                    }
                    arg_count = arg_count + 1;

                    if (current_token_type() == TOKEN_COMMA) {
                        advance_token();
                    } else {
                        done = 1;
                    }
                }
            }

            if (expect_token(TOKEN_RIGHT_PAREN) == 0) {
                return 0;
            }

            return create_call_expr(name_offset, arg_count);
        } else {
            // Variable reference
            return create_variable_expr(name_offset);
        }
    }

    // Parenthesized expression
    if (current_token_type() == TOKEN_LEFT_PAREN) {
        advance_token();
        let expr: i64 = parse_expression();
        if (expr == 0) {
            return 0;
        }
        if (expect_token(TOKEN_RIGHT_PAREN) == 0) {
            return 0;
        }
        return expr;
    }

    return 0;
}

// Main parse function
fn parse() -> i64 {
    parser_new();
    return parse_program();
}

// Code Generator for Runa-Zero Compiler v0.1
// Transpiled from Rust to Runa-Zero

// Global constants
global OUTPUT_BUFFER = 0;
global OUTPUT_BUFFER_SIZE = 1048576;  // 1MB buffer
global OUTPUT_POS = 0;

global LABEL_COUNTER = 0;

// Local variable tracking (stack of function scopes)
global LOCAL_NAMES = 0;
global LOCAL_OFFSETS = 0;
global LOCAL_COUNT = 0;
global MAX_LOCALS = 100;

global STACK_OFFSET = 0;

// Global variable tracking
global GLOBAL_NAMES = 0;
global GLOBAL_LABELS = 0;
global GLOBAL_COUNT = 0;
global MAX_GLOBALS = 100;

// String literal tracking
global STRING_CONTENTS = 0;
global STRING_LABELS = 0;
global STRING_COUNT = 0;
global MAX_STRINGS = 100;
global STRING_COUNTER = 0;

// Initialize code generator
fn init_codegen() -> i64 {
    OUTPUT_BUFFER = allocate(OUTPUT_BUFFER_SIZE);
    OUTPUT_POS = 0;
    LABEL_COUNTER = 0;

    // Initialize local variable tracking
    LOCAL_NAMES = allocate(MAX_LOCALS * 256);  // 256 chars per name
    LOCAL_OFFSETS = allocate(MAX_LOCALS * 8);
    LOCAL_COUNT = 0;

    STACK_OFFSET = 0;

    // Initialize global variable tracking
    GLOBAL_NAMES = allocate(MAX_GLOBALS * 256);
    GLOBAL_LABELS = allocate(MAX_GLOBALS * 256);
    GLOBAL_COUNT = 0;

    // Initialize string literal tracking
    STRING_CONTENTS = allocate(MAX_STRINGS * 256);
    STRING_LABELS = allocate(MAX_STRINGS * 256);
    STRING_COUNT = 0;
    STRING_COUNTER = 0;

    return 1;
}

// Emit instruction to output buffer
fn emit(instruction: i64) -> i64 {
    // Add 4 spaces indentation
    let spaces: i64 = OUTPUT_BUFFER + OUTPUT_POS;
    *(spaces + 0) = 32;  // space
    *(spaces + 1) = 32;
    *(spaces + 2) = 32;
    *(spaces + 3) = 32;
    OUTPUT_POS = OUTPUT_POS + 4;

    // Copy instruction string
    let i: i64 = 0;
    while (*(instruction + i) != 0) {
        *(OUTPUT_BUFFER + OUTPUT_POS) = *(instruction + i);
        OUTPUT_POS = OUTPUT_POS + 1;
        i = i + 1;
    }

    // Add newline
    *(OUTPUT_BUFFER + OUTPUT_POS) = 10;
    OUTPUT_POS = OUTPUT_POS + 1;

    return 1;
}

// Emit label (no indentation)
fn emit_label(label: i64) -> i64 {
    // Copy label string
    let i: i64 = 0;
    while (*(label + i) != 0) {
        *(OUTPUT_BUFFER + OUTPUT_POS) = *(label + i);
        OUTPUT_POS = OUTPUT_POS + 1;
        i = i + 1;
    }

    // Add colon and newline
    *(OUTPUT_BUFFER + OUTPUT_POS) = 58;  // colon
    OUTPUT_POS = OUTPUT_POS + 1;
    *(OUTPUT_BUFFER + OUTPUT_POS) = 10;  // newline
    OUTPUT_POS = OUTPUT_POS + 1;

    return 1;
}

// Emit raw string without indentation
fn emit_raw(str: i64) -> i64 {
    let i: i64 = 0;
    while (*(str + i) != 0) {
        *(OUTPUT_BUFFER + OUTPUT_POS) = *(str + i);
        OUTPUT_POS = OUTPUT_POS + 1;
        i = i + 1;
    }
    return 1;
}

// Generate new label
fn new_label() -> i64 {
    let label_buf: i64 = allocate(32);
    *(label_buf + 0) = 76;  // 'L'

    // Convert counter to string
    let num_str: i64 = int_to_string(LABEL_COUNTER);
    let i: i64 = 0;
    while (*(num_str + i) != 0) {
        *(label_buf + 1 + i) = *(num_str + i);
        i = i + 1;
    }
    *(label_buf + 1 + i) = 0;

    LABEL_COUNTER = LABEL_COUNTER + 1;
    return label_buf;
}

// Look up local variable
fn lookup_local(name: i64) -> i64 {
    let i: i64 = 0;
    while (i < LOCAL_COUNT) {
        let local_name: i64 = LOCAL_NAMES + (i * 256);
        if (string_compare(local_name, name) == 1) {
            return *(LOCAL_OFFSETS + (i * 8));
        }
        i = i + 1;
    }
    return 999999;  // Not found marker
}

// Add local variable
fn add_local(name: i64, offset: i64) -> i64 {
    if (LOCAL_COUNT >= MAX_LOCALS) {
        return 0;
    }

    // Copy name
    let local_name: i64 = LOCAL_NAMES + (LOCAL_COUNT * 256);
    string_copy(local_name, name);

    // Store offset
    *(LOCAL_OFFSETS + (LOCAL_COUNT * 8)) = offset;
    LOCAL_COUNT = LOCAL_COUNT + 1;

    return 1;
}

// Clear locals (for new function)
fn clear_locals() -> i64 {
    LOCAL_COUNT = 0;
    STACK_OFFSET = 0;
    return 1;
}

// Look up global variable
fn lookup_global(name: i64) -> i64 {
    let i: i64 = 0;
    while (i < GLOBAL_COUNT) {
        let global_name: i64 = GLOBAL_NAMES + (i * 256);
        if (string_compare(global_name, name) == 1) {
            return GLOBAL_LABELS + (i * 256);
        }
        i = i + 1;
    }
    return 0;  // Not found
}

// Add global variable
fn add_global(name: i64, label: i64) -> i64 {
    if (GLOBAL_COUNT >= MAX_GLOBALS) {
        return 0;
    }

    // Copy name
    let global_name: i64 = GLOBAL_NAMES + (GLOBAL_COUNT * 256);
    string_copy(global_name, name);

    // Copy label
    let global_label: i64 = GLOBAL_LABELS + (GLOBAL_COUNT * 256);
    string_copy(global_label, label);

    GLOBAL_COUNT = GLOBAL_COUNT + 1;
    return 1;
}

// Look up string literal
fn lookup_string(content: i64) -> i64 {
    let i: i64 = 0;
    while (i < STRING_COUNT) {
        let str_content: i64 = STRING_CONTENTS + (i * 256);
        if (string_compare(str_content, content) == 1) {
            return STRING_LABELS + (i * 256);
        }
        i = i + 1;
    }
    return 0;  // Not found
}

// Add string literal
fn add_string(content: i64) -> i64 {
    // Check if already exists
    let existing: i64 = lookup_string(content);
    if (existing != 0) {
        return existing;
    }

    if (STRING_COUNT >= MAX_STRINGS) {
        return 0;
    }

    // Copy content
    let str_content: i64 = STRING_CONTENTS + (STRING_COUNT * 256);
    string_copy(str_content, content);

    // Generate label
    let label: i64 = STRING_LABELS + (STRING_COUNT * 256);
    *(label + 0) = 115;  // 's'
    *(label + 1) = 116;  // 't'
    *(label + 2) = 114;  // 'r'
    *(label + 3) = 95;   // '_'

    let num_str: i64 = int_to_string(STRING_COUNTER);
    let i: i64 = 0;
    while (*(num_str + i) != 0) {
        *(label + 4 + i) = *(num_str + i);
        i = i + 1;
    }
    *(label + 4 + i) = 0;

    STRING_COUNT = STRING_COUNT + 1;
    STRING_COUNTER = STRING_COUNTER + 1;

    return label;
}

// Emit prologue
fn emit_prologue() -> i64 {
    emit_raw("section .data\n");

    // Emit global variables
    let i: i64 = 0;
    while (i < GLOBAL_COUNT) {
        emit_raw("    ");
        emit_raw(GLOBAL_LABELS + (i * 256));
        emit_raw(" dq 0\n");
        i = i + 1;
    }

    // Emit string literals
    i = 0;
    while (i < STRING_COUNT) {
        emit_raw("    ");
        emit_raw(STRING_LABELS + (i * 256));
        emit_raw(" db ");

        // Emit string bytes
        let content: i64 = STRING_CONTENTS + (i * 256);
        let j: i64 = 0;
        let first: i64 = 1;
        while (*(content + j) != 0) {
            if (first == 0) {
                emit_raw(", ");
            }
            first = 0;

            let ch: i64 = *(content + j);
            if (ch == 10) {  // newline
                emit_raw("10");
            } else {
                if (ch == 13) {  // carriage return
                    emit_raw("13");
                } else {
                    if (ch == 9) {  // tab
                        emit_raw("9");
                    } else {
                        if (ch == 92) {  // backslash
                            emit_raw("92");
                        } else {
                            if (ch == 34) {  // quote
                                emit_raw("34");
                            } else {
                                if (ch >= 32) {
                                    if (ch <= 126) {
                                        // Printable ASCII - emit as character
                                        emit_raw("'");
                                        let char_buf: i64 = allocate(2);
                                        *(char_buf + 0) = ch;
                                        *(char_buf + 1) = 0;
                                        emit_raw(char_buf);
                                        emit_raw("'");
                                    } else {
                                        // Non-printable
                                        emit_raw(int_to_string(ch));
                                    }
                                } else {
                                    // Non-printable
                                    emit_raw(int_to_string(ch));
                                }
                            }
                        }
                    }
                }
            }
            j = j + 1;
        }

        emit_raw(", 0\n");  // Null terminator
        i = i + 1;
    }

    emit_raw("\nsection .text\n");
    emit_raw("    global _start\n");
    emit_raw("    extern puts, malloc, exit\n\n");
    emit_raw("_start:\n");

    return 1;
}

// Collect globals from program (first pass)
fn collect_globals(program: i64) -> i64 {
    let current: i64 = AST_NODES;
    let end: i64 = AST_NODES + (AST_COUNT * NODE_SIZE);

    while (current < end) {
        let node_type: i64 = *(current + 0);

        if (node_type == STMT_GLOBAL_DECL) {
            let name_ptr: i64 = *(current + 8);

            // Generate label for global
            let label: i64 = allocate(256);
            string_copy(label, "global_");
            string_concat(label, name_ptr);

            add_global(name_ptr, label);

            // Collect strings from value expression
            let value_node: i64 = *(current + 16);
            collect_strings_from_expression(value_node);
        }

        if (node_type == STMT_FUNCTION_DEF) {
            // Recursively collect from function body
            let body_start: i64 = *(current + 32);
            let body_count: i64 = *(current + 40);
            collect_globals_from_statements(body_start, body_count);
        }

        // Collect strings from other statement types
        collect_strings_from_statement(current);

        current = current + NODE_SIZE;
    }

    return 1;
}

// Collect strings from expression
fn collect_strings_from_expression(expr_node: i64) -> i64 {
    if (expr_node == 0) {
        return 1;
    }

    let expr_type: i64 = *(expr_node + 0);

    if (expr_type == EXPR_STRING_LITERAL) {
        let content: i64 = *(expr_node + 8);
        add_string(content);
    }

    if (expr_type == EXPR_BINARY_OP) {
        let left: i64 = *(expr_node + 16);
        let right: i64 = *(expr_node + 24);
        collect_strings_from_expression(left);
        collect_strings_from_expression(right);
    }

    if (expr_type == EXPR_UNARY_OP) {
        let operand: i64 = *(expr_node + 16);
        collect_strings_from_expression(operand);
    }

    if (expr_type == EXPR_CALL) {
        let args_start: i64 = *(expr_node + 16);
        let args_count: i64 = *(expr_node + 24);
        let i: i64 = 0;
        while (i < args_count) {
            let arg: i64 = *(args_start + (i * 8));
            collect_strings_from_expression(arg);
            i = i + 1;
        }
    }

    return 1;
}

// Collect strings from statement
fn collect_strings_from_statement(stmt_node: i64) -> i64 {
    let stmt_type: i64 = *(stmt_node + 0);

    if (stmt_type == STMT_VARIABLE_DECL) {
        let value: i64 = *(stmt_node + 24);
        collect_strings_from_expression(value);
    }

    if (stmt_type == STMT_ASSIGNMENT) {
        let target: i64 = *(stmt_node + 8);
        let value: i64 = *(stmt_node + 16);
        collect_strings_from_expression(target);
        collect_strings_from_expression(value);
    }

    if (stmt_type == STMT_IF) {
        let condition: i64 = *(stmt_node + 8);
        collect_strings_from_expression(condition);
    }

    if (stmt_type == STMT_WHILE) {
        let condition: i64 = *(stmt_node + 8);
        collect_strings_from_expression(condition);
    }

    if (stmt_type == STMT_RETURN) {
        let expr: i64 = *(stmt_node + 8);
        collect_strings_from_expression(expr);
    }

    if (stmt_type == STMT_EXPRESSION) {
        let expr: i64 = *(stmt_node + 8);
        collect_strings_from_expression(expr);
    }

    return 1;
}

// Collect globals from statement list
fn collect_globals_from_statements(start: i64, count: i64) -> i64 {
    let i: i64 = 0;
    while (i < count) {
        let stmt: i64 = *(start + (i * 8));
        collect_strings_from_statement(stmt);
        i = i + 1;
    }
    return 1;
}

// Generate code for expression
fn generate_expression(expr_node: i64) -> i64 {
    if (expr_node == 0) {
        emit("mov rax, 0");
        emit("push rax");
        return 1;
    }

    let expr_type: i64 = *(expr_node + 0);

    if (expr_type == EXPR_LITERAL) {
        let value: i64 = *(expr_node + 8);
        let buf: i64 = allocate(256);
        string_copy(buf, "mov rax, ");
        string_concat(buf, int_to_string(value));
        emit(buf);
        emit("push rax");
        return 1;
    }

    if (expr_type == EXPR_STRING_LITERAL) {
        let content: i64 = *(expr_node + 8);
        let label: i64 = lookup_string(content);
        let buf: i64 = allocate(256);
        string_copy(buf, "mov rax, ");
        string_concat(buf, label);
        emit(buf);
        emit("push rax");
        return 1;
    }

    if (expr_type == EXPR_CHAR_LITERAL) {
        let ch: i64 = *(expr_node + 8);
        let buf: i64 = allocate(256);
        string_copy(buf, "mov rax, ");
        string_concat(buf, int_to_string(ch));
        emit(buf);
        emit("push rax");
        return 1;
    }

    if (expr_type == EXPR_VARIABLE) {
        let name: i64 = *(expr_node + 8);
        let local_offset: i64 = lookup_local(name);

        if (local_offset != 999999) {
            // Local variable
            let buf: i64 = allocate(256);
            string_copy(buf, "mov rax, [rbp");
            if (local_offset < 0) {
                string_concat(buf, int_to_string(local_offset));
            } else {
                string_concat(buf, "+");
                string_concat(buf, int_to_string(local_offset));
            }
            string_concat(buf, "]");
            emit(buf);
        } else {
            // Check global
            let global_label: i64 = lookup_global(name);
            if (global_label != 0) {
                let buf: i64 = allocate(256);
                string_copy(buf, "mov rax, [");
                string_concat(buf, global_label);
                string_concat(buf, "]");
                emit(buf);
            } else {
                // Unknown variable
                emit("mov rax, 0");
            }
        }
        emit("push rax");
        return 1;
    }

    if (expr_type == EXPR_BINARY_OP) {
        let op: i64 = *(expr_node + 8);
        let left: i64 = *(expr_node + 16);
        let right: i64 = *(expr_node + 24);

        generate_expression(left);
        generate_expression(right);
        emit("pop rdi");  // right
        emit("pop rax");  // left

        if (op == OP_ADD) {
            emit("add rax, rdi");
        }
        if (op == OP_SUB) {
            emit("sub rax, rdi");
        }
        if (op == OP_MUL) {
            emit("imul rax, rdi");
        }
        if (op == OP_DIV) {
            emit("cqo");
            emit("idiv rdi");
        }
        if (op == OP_EQUAL) {
            emit("cmp rax, rdi");
            emit("sete al");
            emit("movzx rax, al");
        }
        if (op == OP_NOT_EQUAL) {
            emit("cmp rax, rdi");
            emit("setne al");
            emit("movzx rax, al");
        }
        if (op == OP_LESS) {
            emit("cmp rax, rdi");
            emit("setl al");
            emit("movzx rax, al");
        }
        if (op == OP_GREATER) {
            emit("cmp rax, rdi");
            emit("setg al");
            emit("movzx rax, al");
        }
        if (op == OP_LESS_EQUAL) {
            emit("cmp rax, rdi");
            emit("setle al");
            emit("movzx rax, al");
        }
        if (op == OP_GREATER_EQUAL) {
            emit("cmp rax, rdi");
            emit("setge al");
            emit("movzx rax, al");
        }
        if (op == OP_MOD) {
            emit("cqo");
            emit("idiv rdi");
            emit("mov rax, rdx");
        }

        emit("push rax");
        return 1;
    }

    if (expr_type == EXPR_UNARY_OP) {
        let op: i64 = *(expr_node + 8);
        let operand: i64 = *(expr_node + 16);

        generate_expression(operand);
        emit("pop rax");

        if (op == OP_MINUS) {
            emit("neg rax");
        }
        if (op == OP_NOT) {
            emit("cmp rax, 0");
            emit("sete al");
            emit("movzx rax, al");
        }

        emit("push rax");
        return 1;
    }

    if (expr_type == EXPR_CALL) {
        let name: i64 = *(expr_node + 8);
        let args_start: i64 = *(expr_node + 16);
        let args_count: i64 = *(expr_node + 24);

        // Generate arguments in reverse order
        let i: i64 = args_count - 1;
        while (i >= 0) {
            let arg: i64 = *(args_start + (i * 8));
            generate_expression(arg);
            i = i - 1;
        }

        // Check for built-in functions
        if (string_compare(name, "puts") == 1) {
            emit("pop rdi");
            emit("call puts");
        } else {
            if (string_compare(name, "malloc") == 1) {
                emit("pop rdi");
                emit("call malloc");
            } else {
                if (string_compare(name, "exit") == 1) {
                    emit("pop rdi");
                    emit("call exit");
                } else {
                    // User-defined function
                    let buf: i64 = allocate(256);
                    string_copy(buf, "call ");
                    string_concat(buf, name);
                    emit(buf);

                    // Clean up arguments
                    if (args_count > 0) {
                        buf = allocate(256);
                        string_copy(buf, "add rsp, ");
                        string_concat(buf, int_to_string(args_count * 8));
                        emit(buf);
                    }
                }
            }
        }

        emit("push rax");
        return 1;
    }

    if (expr_type == EXPR_ADDRESS_OF) {
        let inner: i64 = *(expr_node + 8);
        let inner_type: i64 = *(inner + 0);

        if (inner_type == EXPR_VARIABLE) {
            let name: i64 = *(inner + 8);
            let local_offset: i64 = lookup_local(name);

            if (local_offset != 999999) {
                // Local variable address
                let buf: i64 = allocate(256);
                string_copy(buf, "lea rax, [rbp");
                if (local_offset < 0) {
                    string_concat(buf, int_to_string(local_offset));
                } else {
                    string_concat(buf, "+");
                    string_concat(buf, int_to_string(local_offset));
                }
                string_concat(buf, "]");
                emit(buf);
            } else {
                // Global variable address
                let global_label: i64 = lookup_global(name);
                if (global_label != 0) {
                    let buf: i64 = allocate(256);
                    string_copy(buf, "mov rax, ");
                    string_concat(buf, global_label);
                    emit(buf);
                } else {
                    emit("mov rax, 0");
                }
            }
        } else {
            // Other expressions - simplified
            emit("mov rax, 0");
        }

        emit("push rax");
        return 1;
    }

    if (expr_type == EXPR_DEREFERENCE) {
        let ptr_expr: i64 = *(expr_node + 8);
        generate_expression(ptr_expr);
        emit("pop rax");
        emit("mov rax, [rax]");
        emit("push rax");
        return 1;
    }

    // Unknown expression type
    emit("mov rax, 0");
    emit("push rax");
    return 1;
}

// Generate code for statement
fn generate_statement(stmt_node: i64) -> i64 {
    let stmt_type: i64 = *(stmt_node + 0);

    if (stmt_type == STMT_FUNCTION_DEF) {
        let name: i64 = *(stmt_node + 8);
        let params_start: i64 = *(stmt_node + 16);
        let params_count: i64 = *(stmt_node + 24);
        let body_start: i64 = *(stmt_node + 32);
        let body_count: i64 = *(stmt_node + 40);

        emit_label(name);

        // Function prologue
        emit("push rbp");
        emit("mov rbp, rsp");

        // Clear locals for new function
        clear_locals();

        // Allocate space for parameters
        let i: i64 = 0;
        while (i < params_count) {
            let param: i64 = *(params_start + (i * 8));
            let param_name: i64 = *(param + 0);

            STACK_OFFSET = STACK_OFFSET - 8;
            add_local(param_name, STACK_OFFSET);

            emit("sub rsp, 8");

            let buf: i64 = allocate(256);
            string_copy(buf, "mov rax, [rbp+");
            string_concat(buf, int_to_string(16 + (i * 8)));
            string_concat(buf, "]");
            emit(buf);

            buf = allocate(256);
            string_copy(buf, "mov [rbp");
            string_concat(buf, int_to_string(STACK_OFFSET));
            string_concat(buf, "], rax");
            emit(buf);

            i = i + 1;
        }

        // Generate function body
        i = 0;
        while (i < body_count) {
            let stmt: i64 = *(body_start + (i * 8));
            generate_statement(stmt);
            i = i + 1;
        }

        // Default return (in case no explicit return)
        emit("mov rax, 0");
        emit("mov rsp, rbp");
        emit("pop rbp");
        emit("ret");
        emit_raw("\n");

        return 1;
    }

    if (stmt_type == STMT_VARIABLE_DECL) {
        let name: i64 = *(stmt_node + 8);
        let value: i64 = *(stmt_node + 24);

        STACK_OFFSET = STACK_OFFSET - 8;
        add_local(name, STACK_OFFSET);

        emit("sub rsp, 8");

        generate_expression(value);
        emit("pop rax");

        let buf: i64 = allocate(256);
        string_copy(buf, "mov [rbp");
        string_concat(buf, int_to_string(STACK_OFFSET));
        string_concat(buf, "], rax");
        emit(buf);

        return 1;
    }

    if (stmt_type == STMT_ASSIGNMENT) {
        let target: i64 = *(stmt_node + 8);
        let value: i64 = *(stmt_node + 16);

        // Generate value first
        generate_expression(value);

        // Store to target
        let target_type: i64 = *(target + 0);
        if (target_type == EXPR_VARIABLE) {
            let name: i64 = *(target + 8);
            let local_offset: i64 = lookup_local(name);

            emit("pop rax");

            if (local_offset != 999999) {
                // Local variable
                let buf: i64 = allocate(256);
                string_copy(buf, "mov [rbp");
                string_concat(buf, int_to_string(local_offset));
                string_concat(buf, "], rax");
                emit(buf);
            } else {
                // Global variable
                let global_label: i64 = lookup_global(name);
                if (global_label != 0) {
                    let buf: i64 = allocate(256);
                    string_copy(buf, "mov [");
                    string_concat(buf, global_label);
                    string_concat(buf, "], rax");
                    emit(buf);
                }
            }
        } else {
            if (target_type == EXPR_DEREFERENCE) {
                let ptr_expr: i64 = *(target + 8);
                generate_expression(ptr_expr);
                emit("pop rdi");  // address
                emit("pop rax");  // value
                emit("mov [rdi], rax");
            } else {
                // Invalid target - just pop the value
                emit("pop rax");
            }
        }

        return 1;
    }

    if (stmt_type == STMT_IF) {
        let condition: i64 = *(stmt_node + 8);
        let then_start: i64 = *(stmt_node + 16);
        let then_count: i64 = *(stmt_node + 24);
        let else_start: i64 = *(stmt_node + 32);
        let else_count: i64 = *(stmt_node + 40);

        let else_label: i64 = new_label();
        let end_label: i64 = new_label();

        generate_expression(condition);
        emit("pop rax");
        emit("cmp rax, 0");

        let buf: i64 = allocate(256);
        string_copy(buf, "je ");
        string_concat(buf, else_label);
        emit(buf);

        // Then branch
        let i: i64 = 0;
        while (i < then_count) {
            let stmt: i64 = *(then_start + (i * 8));
            generate_statement(stmt);
            i = i + 1;
        }

        buf = allocate(256);
        string_copy(buf, "jmp ");
        string_concat(buf, end_label);
        emit(buf);

        // Else branch
        emit_label(else_label);
        if (else_count > 0) {
            i = 0;
            while (i < else_count) {
                let stmt: i64 = *(else_start + (i * 8));
                generate_statement(stmt);
                i = i + 1;
            }
        }

        emit_label(end_label);
        return 1;
    }

    if (stmt_type == STMT_WHILE) {
        let condition: i64 = *(stmt_node + 8);
        let body_start: i64 = *(stmt_node + 16);
        let body_count: i64 = *(stmt_node + 24);

        let start_label: i64 = new_label();
        let end_label: i64 = new_label();

        emit_label(start_label);

        generate_expression(condition);
        emit("pop rax");
        emit("cmp rax, 0");

        let buf: i64 = allocate(256);
        string_copy(buf, "je ");
        string_concat(buf, end_label);
        emit(buf);

        // Loop body
        let i: i64 = 0;
        while (i < body_count) {
            let stmt: i64 = *(body_start + (i * 8));
            generate_statement(stmt);
            i = i + 1;
        }

        buf = allocate(256);
        string_copy(buf, "jmp ");
        string_concat(buf, start_label);
        emit(buf);

        emit_label(end_label);
        return 1;
    }

    if (stmt_type == STMT_RETURN) {
        let expr: i64 = *(stmt_node + 8);
        generate_expression(expr);
        emit("pop rax");
        emit("mov rsp, rbp");
        emit("pop rbp");
        emit("ret");
        return 1;
    }

    if (stmt_type == STMT_EXPRESSION) {
        let expr: i64 = *(stmt_node + 8);
        generate_expression(expr);
        emit("pop rax");  // Discard result
        return 1;
    }

    if (stmt_type == STMT_GLOBAL_DECL) {
        let name: i64 = *(stmt_node + 8);
        let value: i64 = *(stmt_node + 16);

        // Global initialization
        generate_expression(value);
        emit("pop rax");

        let global_label: i64 = lookup_global(name);
        if (global_label != 0) {
            let buf: i64 = allocate(256);
            string_copy(buf, "mov [");
            string_concat(buf, global_label);
            string_concat(buf, "], rax");
            emit(buf);
        }

        return 1;
    }

    return 1;
}

// Main code generation function
fn generate(program: i64) -> i64 {
    // Initialize
    init_codegen();

    // First pass: collect globals and strings
    collect_globals(program);

    // Emit prologue
    emit_prologue();

    // Generate global initializations in _start
    let current: i64 = AST_NODES;
    let end: i64 = AST_NODES + (AST_COUNT * NODE_SIZE);

    while (current < end) {
        let node_type: i64 = *(current + 0);
        if (node_type == STMT_GLOBAL_DECL) {
            generate_statement(current);
        }
        current = current + NODE_SIZE;
    }

    // Add main call after global initialization
    emit_raw("    call main\n");
    emit_raw("    mov rdi, rax\n");
    emit_raw("    call exit\n\n");

    // Generate all function definitions
    current = AST_NODES;
    while (current < end) {
        let node_type: i64 = *(current + 0);
        if (node_type == STMT_FUNCTION_DEF) {
            generate_statement(current);
        }
        current = current + NODE_SIZE;
    }

    // Null-terminate output
    *(OUTPUT_BUFFER + OUTPUT_POS) = 0;

    return OUTPUT_BUFFER;
}

// Main driver for Runa-Zero Compiler v0.1
// Using libc functions for file I/O and process execution

// These libc functions are recognized by v0.0 as external calls:
// puts, malloc, free, exit, fopen, fgetc, fprintf, fclose, system

// Read entire file into memory using libc
fn read_file(path: i64) -> i64 {
    let file: i64 = fopen(path, "r");
    if (file == 0) {
        puts("Error: Cannot open file");
        return 0;
    }

    // Allocate initial buffer
    let buffer_size: i64 = 65536;  // 64KB initial size
    let buffer: i64 = malloc(buffer_size);
    let pos: i64 = 0;

    // Read file character by character
    let c: i64 = fgetc(file);
    while (c != 4294967295) {  // 4294967295 is EOF (unsigned 32-bit -1)
        if (pos >= buffer_size - 1) {
            // Need to grow buffer
            let new_size: i64 = buffer_size * 2;
            let new_buffer: i64 = malloc(new_size);

            // Copy old buffer to new
            let i: i64 = 0;
            while (i < pos) {
                *(new_buffer + i) = *(buffer + i);
                i = i + 1;
            }

            free(buffer);
            buffer = new_buffer;
            buffer_size = new_size;
        }

        *(buffer + pos) = c;
        pos = pos + 1;
        c = fgetc(file);
    }

    // Null-terminate
    *(buffer + pos) = 0;

    fclose(file);
    return buffer;
}

// Write string to file using libc
fn write_file(path: i64, content: i64) -> i64 {
    let file: i64 = fopen(path, "w");
    if (file == 0) {
        puts("Error: Cannot create file");
        return 0;
    }

    // Use fprintf to write the content
    fprintf(file, "%s", content);

    fclose(file);
    return 1;
}

// Build a command string by concatenating parts
fn build_command(parts: i64, count: i64) -> i64 {
    // Calculate total length needed
    let total_len: i64 = 0;
    let i: i64 = 0;
    while (i < count) {
        let part: i64 = *(parts + (i * 8));
        let j: i64 = 0;
        while (*(part + j) != 0) {
            total_len = total_len + 1;
            j = j + 1;
        }
        if (i < count - 1) {
            total_len = total_len + 1;  // Space between parts
        }
        i = i + 1;
    }

    // Allocate buffer
    let cmd: i64 = malloc(total_len + 1);
    let pos: i64 = 0;

    // Copy parts
    i = 0;
    while (i < count) {
        let part: i64 = *(parts + (i * 8));
        let j: i64 = 0;
        while (*(part + j) != 0) {
            *(cmd + pos) = *(part + j);
            pos = pos + 1;
            j = j + 1;
        }
        if (i < count - 1) {
            *(cmd + pos) = 32;  // Space
            pos = pos + 1;
        }
        i = i + 1;
    }

    *(cmd + pos) = 0;
    return cmd;
}

// String comparison helper
fn str_equal(s1: i64, s2: i64) -> i64 {
    let i: i64 = 0;
    while (1 == 1) {
        let c1: i64 = *(s1 + i);
        let c2: i64 = *(s2 + i);
        if (c1 != c2) {
            return 0;
        }
        if (c1 == 0) {
            return 1;
        }
        i = i + 1;
    }
    return 0;
}

// Parse command line arguments
fn parse_args() -> i64 {
    // Check argument count
    if (ARGC < 2) {
        puts("Usage: runac [OPTIONS] <input>");
        puts("  -o <FILE>        Output file");
        puts("  --emit-asm-only  Only emit assembly");
        exit(1);
    }

    // Initialize defaults
    let input_file: i64 = 0;
    let output_file: i64 = 0;
    let emit_asm_only: i64 = 0;

    // Parse arguments
    let i: i64 = 1;
    while (i < ARGC) {
        let arg: i64 = *(ARGV + (i * 8));

        if (str_equal(arg, "-o") == 1) {
            // Output file
            i = i + 1;
            if (i >= ARGC) {
                puts("Error: -o requires an argument");
                exit(1);
            }
            output_file = *(ARGV + (i * 8));
        } else {
            if (str_equal(arg, "--emit-asm-only") == 1) {
                // Emit assembly only
                emit_asm_only = 1;
            } else {
                // Must be input file
                if (input_file == 0) {
                    input_file = arg;
                } else {
                    puts("Error: Multiple input files specified");
                    exit(1);
                }
            }
        }

        i = i + 1;
    }

    // Check for required input file
    if (input_file == 0) {
        puts("Error: No input file specified");
        exit(1);
    }

    // Set default output if not specified
    if (output_file == 0) {
        output_file = "a.out";
    }

    // Store parsed arguments in globals
    INPUT_FILE = input_file;
    OUTPUT_FILE = output_file;
    EMIT_ASM_ONLY = emit_asm_only;

    return 1;
}

// Command line arguments
global ARGC = 0;
global ARGV = 0;

// Globals for parsed arguments
global INPUT_FILE = 0;
global OUTPUT_FILE = 0;
global EMIT_ASM_ONLY = 0;

// Compile function - main compilation pipeline
fn compile() -> i64 {
    // Initialize memory first
    if (init_memory() == 0) {
        puts("Error: Failed to initialize memory");
        return 0;
    }

    // Read source file
    puts("Reading input file...");
    let source: i64 = read_file(INPUT_FILE);
    if (source == 0) {
        return 0;
    }

    // Initialize compiler components
    init_lexer();
    init_ast();
    init_parser();
    init_codegen();

    // Set up input for lexer
    INPUT_CHARS = source;
    INPUT_LENGTH = string_length(source);
    POSITION = 0;
    LINE = 1;
    COLUMN = 1;

    // Lexical analysis
    puts("Lexing...");
    let token_count: i64 = tokenize();
    if (token_count == 0) {
        puts("Error: Lexer failed");
        return 0;
    }

    // Parsing
    puts("Parsing...");
    let ast_result: i64 = parse();
    if (ast_result == 0) {
        puts("Error: Parser failed");
        return 0;
    }

    // Code generation
    puts("Generating code...");
    let assembly: i64 = generate(0);
    if (assembly == 0) {
        puts("Error: Code generation failed");
        return 0;
    }

    // Determine output assembly file name
    let asm_file: i64 = 0;
    if (EMIT_ASM_ONLY == 1) {
        asm_file = OUTPUT_FILE;
    } else {
        // Create .s filename
        asm_file = malloc(256);
        let i: i64 = 0;
        while (*(OUTPUT_FILE + i) != 0) {
            *(asm_file + i) = *(OUTPUT_FILE + i);
            i = i + 1;
        }
        *(asm_file + i) = 46;      // '.'
        *(asm_file + i + 1) = 115;  // 's'
        *(asm_file + i + 2) = 0;
    }

    // Write assembly file
    puts("Writing assembly...");
    if (write_file(asm_file, assembly) == 0) {
        return 0;
    }

    // If only emitting assembly, we're done
    if (EMIT_ASM_ONLY == 1) {
        puts("Assembly written successfully");
        return 1;
    }

    // Assemble with NASM
    puts("Assembling with NASM...");

    // Build NASM command: "nasm -f elf64 file.s -o file.o"
    let nasm_parts: i64 = malloc(6 * 8);
    *(nasm_parts + 0) = "nasm";
    *(nasm_parts + 8) = "-f";
    *(nasm_parts + 16) = "elf64";
    *(nasm_parts + 24) = asm_file;
    *(nasm_parts + 32) = "-o";

    // Create .o filename
    let obj_file: i64 = malloc(256);
    let i: i64 = 0;
    while (*(OUTPUT_FILE + i) != 0) {
        *(obj_file + i) = *(OUTPUT_FILE + i);
        i = i + 1;
    }
    *(obj_file + i) = 46;      // '.'
    *(obj_file + i + 1) = 111;  // 'o'
    *(obj_file + i + 2) = 0;

    *(nasm_parts + 40) = obj_file;

    let nasm_cmd: i64 = build_command(nasm_parts, 6);
    if (system(nasm_cmd) != 0) {
        puts("Error: NASM assembly failed");
        return 0;
    }

    // Link with GCC
    puts("Linking with GCC...");

    // Build GCC command: "gcc file.o -o output -nostartfiles -lc -no-pie"
    let gcc_parts: i64 = malloc(7 * 8);
    *(gcc_parts + 0) = "gcc";
    *(gcc_parts + 8) = obj_file;
    *(gcc_parts + 16) = "-o";
    *(gcc_parts + 24) = OUTPUT_FILE;
    *(gcc_parts + 32) = "-nostartfiles";
    *(gcc_parts + 40) = "-lc";
    *(gcc_parts + 48) = "-no-pie";

    let gcc_cmd: i64 = build_command(gcc_parts, 7);
    if (system(gcc_cmd) != 0) {
        puts("Error: GCC linking failed");
        return 0;
    }

    puts("Compilation successful!");
    return 1;
}

// Main entry point - receives argc and argv from runtime
fn main(argc: i64, argv: i64) -> i64 {
    // Store command line arguments
    ARGC = argc;
    ARGV = argv;

    // Parse arguments
    parse_args();

    // Run compilation
    if (compile() == 0) {
        exit(1);
    }

    return 0;
}