// Lexer tests for Runa-Zero implementation
// Tests equivalent functionality to the Rust lexer tests

global test_input = 0;
global test_length = 0;

fn setup_test(input: i64, length: i64) -> i64 {
    if (init_memory() == 0) {
        return 0;
    }
    if (init_ast() == 0) {
        return 0;
    }
    if (lexer_new(input, length) == 0) {
        return 0;
    }
    return 1;
}

fn assert_token_count(expected: i64) -> i64 {
    if (TOKEN_COUNT != expected) {
        return 0;
    }
    return 1;
}

fn assert_token_type(index: i64, expected_type: i64) -> i64 {
    if (get_token_type(index) != expected_type) {
        return 0;
    }
    return 1;
}

fn assert_token_value(index: i64, expected_value: i64) -> i64 {
    if (get_token_value(index) != expected_value) {
        return 0;
    }
    return 1;
}

fn test_empty_input() -> i64 {
    let empty_str: i64 = malloc(8);
    *(empty_str + 0) = 0;

    if (setup_test(empty_str, 0) == 0) {
        return 0;
    }

    if (tokenize() == 0) {
        return 0;
    }

    if (assert_token_count(1) == 0) {
        return 0;
    }

    if (assert_token_type(0, TOKEN_EOF) == 0) {
        return 0;
    }

    return 1;
}

fn test_whitespace() -> i64 {
    let input: i64 = malloc(64);
    *(input + 0) = 32;
    *(input + 1) = 32;
    *(input + 2) = 9;
    *(input + 3) = 32;
    *(input + 4) = 0;

    if (setup_test(input, 4) == 0) {
        return 0;
    }

    if (tokenize() == 0) {
        return 0;
    }

    if (assert_token_count(1) == 0) {
        return 0;
    }

    if (assert_token_type(0, TOKEN_EOF) == 0) {
        return 0;
    }

    return 1;
}

fn test_newlines() -> i64 {
    let input: i64 = malloc(64);
    *(input + 0) = 10;
    *(input + 1) = 10;
    *(input + 2) = 0;

    if (setup_test(input, 2) == 0) {
        return 0;
    }

    if (tokenize() == 0) {
        return 0;
    }

    if (assert_token_count(3) == 0) {
        return 0;
    }

    if (assert_token_type(0, TOKEN_NEWLINE) == 0) {
        return 0;
    }

    if (assert_token_type(1, TOKEN_NEWLINE) == 0) {
        return 0;
    }

    if (assert_token_type(2, TOKEN_EOF) == 0) {
        return 0;
    }

    return 1;
}

fn test_numbers() -> i64 {
    let input: i64 = malloc(64);
    *(input + 0) = 52;
    *(input + 1) = 50;
    *(input + 2) = 32;
    *(input + 3) = 48;
    *(input + 4) = 32;
    *(input + 5) = 49;
    *(input + 6) = 50;
    *(input + 7) = 51;
    *(input + 8) = 0;

    if (setup_test(input, 8) == 0) {
        return 0;
    }

    if (tokenize() == 0) {
        return 0;
    }

    if (assert_token_count(4) == 0) {
        return 0;
    }

    if (assert_token_type(0, TOKEN_NUMBER) == 0) {
        return 0;
    }

    if (assert_token_value(0, 42) == 0) {
        return 0;
    }

    if (assert_token_type(1, TOKEN_NUMBER) == 0) {
        return 0;
    }

    if (assert_token_value(1, 0) == 0) {
        return 0;
    }

    if (assert_token_type(2, TOKEN_NUMBER) == 0) {
        return 0;
    }

    if (assert_token_value(2, 123) == 0) {
        return 0;
    }

    if (assert_token_type(3, TOKEN_EOF) == 0) {
        return 0;
    }

    return 1;
}

fn test_keywords() -> i64 {
    let input: i64 = malloc(128);
    *(input + 0) = 102;
    *(input + 1) = 110;
    *(input + 2) = 32;
    *(input + 3) = 108;
    *(input + 4) = 101;
    *(input + 5) = 116;
    *(input + 6) = 32;
    *(input + 7) = 105;
    *(input + 8) = 102;
    *(input + 9) = 32;
    *(input + 10) = 101;
    *(input + 11) = 108;
    *(input + 12) = 115;
    *(input + 13) = 101;
    *(input + 14) = 32;
    *(input + 15) = 119;
    *(input + 16) = 104;
    *(input + 17) = 105;
    *(input + 18) = 108;
    *(input + 19) = 101;
    *(input + 20) = 32;
    *(input + 21) = 114;
    *(input + 22) = 101;
    *(input + 23) = 116;
    *(input + 24) = 117;
    *(input + 25) = 114;
    *(input + 26) = 110;
    *(input + 27) = 32;
    *(input + 28) = 103;
    *(input + 29) = 108;
    *(input + 30) = 111;
    *(input + 31) = 98;
    *(input + 32) = 97;
    *(input + 33) = 108;
    *(input + 34) = 0;

    if (setup_test(input, 34) == 0) {
        return 0;
    }

    if (tokenize() == 0) {
        return 0;
    }

    if (assert_token_count(8) == 0) {
        return 0;
    }

    if (assert_token_type(0, TOKEN_FN) == 0) {
        return 0;
    }

    if (assert_token_type(1, TOKEN_LET) == 0) {
        return 0;
    }

    if (assert_token_type(2, TOKEN_IF) == 0) {
        return 0;
    }

    if (assert_token_type(3, TOKEN_ELSE) == 0) {
        return 0;
    }

    if (assert_token_type(4, TOKEN_WHILE) == 0) {
        return 0;
    }

    if (assert_token_type(5, TOKEN_RETURN) == 0) {
        return 0;
    }

    if (assert_token_type(6, TOKEN_GLOBAL) == 0) {
        return 0;
    }

    if (assert_token_type(7, TOKEN_EOF) == 0) {
        return 0;
    }

    return 1;
}

fn test_operators() -> i64 {
    let input: i64 = malloc(64);
    *(input + 0) = 43;
    *(input + 1) = 32;
    *(input + 2) = 45;
    *(input + 3) = 32;
    *(input + 4) = 42;
    *(input + 5) = 32;
    *(input + 6) = 47;
    *(input + 7) = 32;
    *(input + 8) = 61;
    *(input + 9) = 32;
    *(input + 10) = 61;
    *(input + 11) = 61;
    *(input + 12) = 32;
    *(input + 13) = 33;
    *(input + 14) = 61;
    *(input + 15) = 32;
    *(input + 16) = 60;
    *(input + 17) = 32;
    *(input + 18) = 62;
    *(input + 19) = 32;
    *(input + 20) = 60;
    *(input + 21) = 61;
    *(input + 22) = 32;
    *(input + 23) = 62;
    *(input + 24) = 61;
    *(input + 25) = 32;
    *(input + 26) = 38;
    *(input + 27) = 32;
    *(input + 28) = 45;
    *(input + 29) = 62;
    *(input + 30) = 0;

    if (setup_test(input, 30) == 0) {
        return 0;
    }

    if (tokenize() == 0) {
        return 0;
    }

    if (assert_token_count(13) == 0) {
        return 0;
    }

    if (assert_token_type(0, TOKEN_PLUS) == 0) {
        return 0;
    }

    if (assert_token_type(1, TOKEN_MINUS) == 0) {
        return 0;
    }

    if (assert_token_type(2, TOKEN_STAR) == 0) {
        return 0;
    }

    if (assert_token_type(3, TOKEN_DIVIDE) == 0) {
        return 0;
    }

    if (assert_token_type(4, TOKEN_ASSIGN) == 0) {
        return 0;
    }

    if (assert_token_type(5, TOKEN_EQUAL) == 0) {
        return 0;
    }

    if (assert_token_type(6, TOKEN_NOT_EQUAL) == 0) {
        return 0;
    }

    if (assert_token_type(7, TOKEN_LESS) == 0) {
        return 0;
    }

    if (assert_token_type(8, TOKEN_GREATER) == 0) {
        return 0;
    }

    if (assert_token_type(9, TOKEN_LESS_EQUAL) == 0) {
        return 0;
    }

    if (assert_token_type(10, TOKEN_GREATER_EQUAL) == 0) {
        return 0;
    }

    if (assert_token_type(11, TOKEN_AMPERSAND) == 0) {
        return 0;
    }

    if (assert_token_type(12, TOKEN_ARROW) == 0) {
        return 0;
    }

    return 1;
}

fn test_punctuation() -> i64 {
    let input: i64 = malloc(32);
    *(input + 0) = 40;
    *(input + 1) = 41;
    *(input + 2) = 123;
    *(input + 3) = 125;
    *(input + 4) = 59;
    *(input + 5) = 58;
    *(input + 6) = 44;
    *(input + 7) = 0;

    if (setup_test(input, 7) == 0) {
        return 0;
    }

    if (tokenize() == 0) {
        return 0;
    }

    if (assert_token_count(8) == 0) {
        return 0;
    }

    if (assert_token_type(0, TOKEN_LEFT_PAREN) == 0) {
        return 0;
    }

    if (assert_token_type(1, TOKEN_RIGHT_PAREN) == 0) {
        return 0;
    }

    if (assert_token_type(2, TOKEN_LEFT_BRACE) == 0) {
        return 0;
    }

    if (assert_token_type(3, TOKEN_RIGHT_BRACE) == 0) {
        return 0;
    }

    if (assert_token_type(4, TOKEN_SEMICOLON) == 0) {
        return 0;
    }

    if (assert_token_type(5, TOKEN_COLON) == 0) {
        return 0;
    }

    if (assert_token_type(6, TOKEN_COMMA) == 0) {
        return 0;
    }

    if (assert_token_type(7, TOKEN_EOF) == 0) {
        return 0;
    }

    return 1;
}

fn test_character_literal() -> i64 {
    let input: i64 = malloc(32);
    *(input + 0) = 39;
    *(input + 1) = 97;
    *(input + 2) = 39;
    *(input + 3) = 32;
    *(input + 4) = 39;
    *(input + 5) = 92;
    *(input + 6) = 110;
    *(input + 7) = 39;
    *(input + 8) = 0;

    if (setup_test(input, 8) == 0) {
        return 0;
    }

    if (tokenize() == 0) {
        return 0;
    }

    if (assert_token_count(3) == 0) {
        return 0;
    }

    if (assert_token_type(0, TOKEN_CHAR_LITERAL) == 0) {
        return 0;
    }

    if (assert_token_value(0, 97) == 0) {
        return 0;
    }

    if (assert_token_type(1, TOKEN_CHAR_LITERAL) == 0) {
        return 0;
    }

    if (assert_token_value(1, 10) == 0) {
        return 0;
    }

    if (assert_token_type(2, TOKEN_EOF) == 0) {
        return 0;
    }

    return 1;
}

fn test_comments() -> i64 {
    let input: i64 = malloc(64);
    *(input + 0) = 52;
    *(input + 1) = 50;
    *(input + 2) = 32;
    *(input + 3) = 47;
    *(input + 4) = 47;
    *(input + 5) = 32;
    *(input + 6) = 99;
    *(input + 7) = 111;
    *(input + 8) = 109;
    *(input + 9) = 109;
    *(input + 10) = 101;
    *(input + 11) = 110;
    *(input + 12) = 116;
    *(input + 13) = 10;
    *(input + 14) = 49;
    *(input + 15) = 50;
    *(input + 16) = 51;
    *(input + 17) = 0;

    if (setup_test(input, 17) == 0) {
        return 0;
    }

    if (tokenize() == 0) {
        return 0;
    }

    if (assert_token_count(4) == 0) {
        return 0;
    }

    if (assert_token_type(0, TOKEN_NUMBER) == 0) {
        return 0;
    }

    if (assert_token_value(0, 42) == 0) {
        return 0;
    }

    if (assert_token_type(1, TOKEN_NEWLINE) == 0) {
        return 0;
    }

    if (assert_token_type(2, TOKEN_NUMBER) == 0) {
        return 0;
    }

    if (assert_token_value(2, 123) == 0) {
        return 0;
    }

    if (assert_token_type(3, TOKEN_EOF) == 0) {
        return 0;
    }

    return 1;
}

fn run_all_tests() -> i64 {
    let passed: i64 = 0;
    let total: i64 = 9;

    if (test_empty_input()) {
        passed = passed + 1;
    }

    if (test_whitespace()) {
        passed = passed + 1;
    }

    if (test_newlines()) {
        passed = passed + 1;
    }

    if (test_numbers()) {
        passed = passed + 1;
    }

    if (test_keywords()) {
        passed = passed + 1;
    }

    if (test_operators()) {
        passed = passed + 1;
    }

    if (test_punctuation()) {
        passed = passed + 1;
    }

    if (test_character_literal()) {
        passed = passed + 1;
    }

    if (test_comments()) {
        passed = passed + 1;
    }

    return passed;
}

fn main() -> i64 {
    let passed: i64 = run_all_tests();
    return passed;
}