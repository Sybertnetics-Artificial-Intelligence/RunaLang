// Complete lexer test with embedded AST and lexer modules

// Memory management
global MEMORY_POOL = 0;
global MEMORY_OFFSET = 0;
global MEMORY_SIZE = 131072;

fn allocate(size: i64) -> i64 {
    if (MEMORY_OFFSET + size > MEMORY_SIZE) {
        return 0;
    }
    let ptr: i64 = MEMORY_POOL + MEMORY_OFFSET;
    MEMORY_OFFSET = MEMORY_OFFSET + size;
    return ptr;
}

fn init_memory() -> i64 {
    MEMORY_POOL = malloc(MEMORY_SIZE * 8);
    if (MEMORY_POOL == 0) {
        return 0;
    }
    MEMORY_OFFSET = 0;
    return 1;
}

// Token type constants
global TOKEN_NUMBER = 1;
global TOKEN_IDENTIFIER = 2;
global TOKEN_FN = 3;
global TOKEN_LET = 4;
global TOKEN_IF = 5;
global TOKEN_ELSE = 6;
global TOKEN_WHILE = 7;
global TOKEN_RETURN = 8;
global TOKEN_GLOBAL = 9;
global TOKEN_PLUS = 10;
global TOKEN_MINUS = 11;
global TOKEN_DIVIDE = 12;
global TOKEN_ASSIGN = 13;
global TOKEN_EQUAL = 14;
global TOKEN_NOT_EQUAL = 15;
global TOKEN_LESS = 16;
global TOKEN_GREATER = 17;
global TOKEN_LESS_EQUAL = 18;
global TOKEN_GREATER_EQUAL = 19;
global TOKEN_LEFT_PAREN = 20;
global TOKEN_RIGHT_PAREN = 21;
global TOKEN_LEFT_BRACE = 22;
global TOKEN_RIGHT_BRACE = 23;
global TOKEN_SEMICOLON = 24;
global TOKEN_COLON = 25;
global TOKEN_ARROW = 26;
global TOKEN_AMPERSAND = 27;
global TOKEN_STAR = 28;
global TOKEN_COMMA = 29;
global TOKEN_STRING_LITERAL = 30;
global TOKEN_CHAR_LITERAL = 31;
global TOKEN_NEWLINE = 32;
global TOKEN_EOF = 33;

// Token storage arrays
global TOKEN_TYPES = 0;
global TOKEN_VALUES = 0;
global TOKEN_STRINGS = 0;
global TOKEN_COUNT = 0;
global MAX_TOKENS = 1000;

// String storage
global STRING_STORAGE = 0;
global STRING_OFFSET = 0;
global MAX_STRING_STORAGE = 50000;

fn init_ast() -> i64 {
    TOKEN_TYPES = allocate(MAX_TOKENS);
    TOKEN_VALUES = allocate(MAX_TOKENS);
    TOKEN_STRINGS = allocate(MAX_TOKENS);
    STRING_STORAGE = allocate(MAX_STRING_STORAGE);

    if (TOKEN_TYPES == 0) {
        return 0;
    }
    if (TOKEN_VALUES == 0) {
        return 0;
    }
    if (TOKEN_STRINGS == 0) {
        return 0;
    }
    if (STRING_STORAGE == 0) {
        return 0;
    }

    TOKEN_COUNT = 0;
    STRING_OFFSET = 0;
    return 1;
}

fn string_length(str: i64) -> i64 {
    let len: i64 = 0;
    while (*(str + len) != 0) {
        len = len + 1;
    }
    return len;
}

fn string_copy(dest: i64, src: i64) -> i64 {
    let i: i64 = 0;
    while (*(src + i) != 0) {
        *(dest + i) = *(src + i);
        i = i + 1;
    }
    *(dest + i) = 0;
    return i;
}

fn store_string(str: i64) -> i64 {
    let len: i64 = string_length(str);
    if (STRING_OFFSET + len + 1 > MAX_STRING_STORAGE) {
        return 0;
    }

    let offset: i64 = STRING_OFFSET;
    string_copy(STRING_STORAGE + offset, str);
    STRING_OFFSET = STRING_OFFSET + len + 1;
    return offset;
}

fn add_token(token_type: i64, value: i64, string_data: i64) -> i64 {
    if (TOKEN_COUNT >= MAX_TOKENS) {
        return 0;
    }

    *(TOKEN_TYPES + TOKEN_COUNT) = token_type;
    *(TOKEN_VALUES + TOKEN_COUNT) = value;
    *(TOKEN_STRINGS + TOKEN_COUNT) = string_data;
    TOKEN_COUNT = TOKEN_COUNT + 1;
    return 1;
}

fn get_token_type(index: i64) -> i64 {
    if (index >= TOKEN_COUNT) {
        return TOKEN_EOF;
    }
    return *(TOKEN_TYPES + index);
}

fn get_token_value(index: i64) -> i64 {
    if (index >= TOKEN_COUNT) {
        return 0;
    }
    return *(TOKEN_VALUES + index);
}

// Lexer state
global INPUT_CHARS = 0;
global INPUT_LENGTH = 0;
global POSITION = 0;
global LINE = 1;
global COLUMN = 1;

fn is_digit(ch: i64) -> i64 {
    if (ch >= 48 && ch <= 57) {
        return 1;
    }
    return 0;
}

fn is_alpha(ch: i64) -> i64 {
    if (ch >= 97) {
        if (ch <= 122) {
            return 1;
        }
    }
    if (ch >= 65) {
        if (ch <= 90) {
            return 1;
        }
    }
    if (ch == 95) {
        return 1;
    }
    return 0;
}

fn is_alnum(ch: i64) -> i64 {
    if (is_alpha(ch)) {
        return 1;
    }
    if (is_digit(ch)) {
        return 1;
    }
    return 0;
}

fn is_whitespace(ch: i64) -> i64 {
    if (ch == 32) {
        return 1;
    }
    if (ch == 9) {
        return 1;
    }
    if (ch == 13) {
        return 1;
    }
    return 0;
}

fn lexer_new(input: i64, length: i64) -> i64 {
    INPUT_CHARS = input;
    INPUT_LENGTH = length;
    POSITION = 0;
    LINE = 1;
    COLUMN = 1;
    return 1;
}

fn current_char() -> i64 {
    if (POSITION >= INPUT_LENGTH) {
        return 0;
    }
    return *(INPUT_CHARS + POSITION);
}

fn advance() -> i64 {
    if (POSITION >= INPUT_LENGTH) {
        return 0;
    }

    let ch: i64 = *(INPUT_CHARS + POSITION);
    POSITION = POSITION + 1;

    if (ch == 10) {
        LINE = LINE + 1;
        COLUMN = 1;
    } else {
        COLUMN = COLUMN + 1;
    }

    return ch;
}

fn peek() -> i64 {
    if (POSITION + 1 >= INPUT_LENGTH) {
        return 0;
    }
    return *(INPUT_CHARS + POSITION + 1);
}

fn read_number() -> i64 {
    let number: i64 = 0;

    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();
        if (is_digit(ch) == 0) {
            return number;
        }
        number = number * 10 + (ch - 48);
        advance();
    }

    return number;
}

fn read_identifier() -> i64 {
    let start_pos: i64 = POSITION;
    let length: i64 = 0;

    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();
        if (is_alnum(ch) == 0) {
            return length;
        }
        length = length + 1;
        advance();
    }

    return length;
}

fn read_char() -> i64 {
    advance();

    if (POSITION >= INPUT_LENGTH) {
        return -1;
    }

    let ch: i64 = current_char();
    if (ch == 92) {
        advance();
        if (POSITION >= INPUT_LENGTH) {
            return -1;
        }
        let escaped: i64 = current_char();
        advance();

        if (current_char() != 39) {
            return -1;
        }
        advance();

        if (escaped == 110) {
            return 10;
        }
        if (escaped == 116) {
            return 9;
        }
        if (escaped == 114) {
            return 13;
        }
        if (escaped == 92) {
            return 92;
        }
        if (escaped == 39) {
            return 39;
        }
        return escaped;
    } else {
        advance();
        if (current_char() != 39) {
            return -1;
        }
        advance();
        return ch;
    }
}

fn skip_line_comment() -> i64 {
    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();
        if (ch == 10) {
            return 1;
        }
        advance();
    }
    return 1;
}

fn keyword_or_identifier(text_start: i64, length: i64) -> i64 {
    if (length == 2) {
        if (*(text_start + 0) == 102) {
            if (*(text_start + 1) == 110) {
                return TOKEN_FN;
            }
        }
        if (*(text_start + 0) == 105) {
            if (*(text_start + 1) == 102) {
                return TOKEN_IF;
            }
        }
    }

    if (length == 3) {
        }
        if (*(text_start + 0) == 108) {
            if (*(text_start + 1) == 101) {
                if (*(text_start + 2) == 116) {
            return TOKEN_LET;
        }
    }

    if (length == 4) {
            }
        }
        if (*(text_start + 0) == 101) {
            if (*(text_start + 1) == 108) {
                if (*(text_start + 2) == 115) {
                    if (*(text_start + 3) == 101) {
            return TOKEN_ELSE;
        }
    }

    if (length == 5) {
                }
            }
        }
        if (*(text_start + 0) == 119) {
            if (*(text_start + 1) == 104) {
                if (*(text_start + 2) == 105) {
                    if (*(text_start + 3) == 108) {
                        if (*(text_start + 4) == 101) {
            return TOKEN_WHILE;
        }
    }

    if (length == 6) {
                    }
                }
            }
        }
        if (*(text_start + 0) == 114) {
            if (*(text_start + 1) == 101) {
                if (*(text_start + 2) == 116) {
                    if (*(text_start + 3) == 117) {
                        if (*(text_start + 4) == 114) {
                            if (*(text_start + 5) == 110) {
            return TOKEN_RETURN;
        }
                        }
                    }
                }
            }
        }
        if (*(text_start + 0) == 103) {
            if (*(text_start + 1) == 108) {
                if (*(text_start + 2) == 111) {
                    if (*(text_start + 3) == 98) {
                        if (*(text_start + 4) == 97) {
                            if (*(text_start + 5) == 108) {
                                return TOKEN_GLOBAL;
                            }
                        }
                    }
                }
            }
        }
    }

    return TOKEN_IDENTIFIER;
}

fn tokenize() -> i64 {
    TOKEN_COUNT = 0;

    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();

        if (is_whitespace(ch)) {
            advance();
            continue;
        }

        if (ch == 10) {
            if (add_token(TOKEN_NEWLINE, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (is_digit(ch)) {
            let number: i64 = read_number();
            if (add_token(TOKEN_NUMBER, number, 0) == 0) {
                return 0;
            }
            continue;
        }

        if (is_alpha(ch)) {
            let start_pos: i64 = POSITION;
            let length: i64 = read_identifier();
            let token_type: i64 = keyword_or_identifier(INPUT_CHARS + start_pos, length);

            let string_offset: i64 = 0;
            if (token_type == TOKEN_IDENTIFIER) {
                string_offset = store_string(INPUT_CHARS + start_pos);
                if (string_offset == 0) {
                    return 0;
                }
            }

            if (add_token(token_type, 0, string_offset) == 0) {
                return 0;
            }
            continue;
        }

        if (ch == 39) {
            let char_value: i64 = read_char();
            if (char_value < 0) {
                return 0;
            }

            if (add_token(TOKEN_CHAR_LITERAL, char_value, 0) == 0) {
                return 0;
            }
            continue;
        }

        if (ch == 43) {
            if (add_token(TOKEN_PLUS, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 45) {
            if (peek() == 62) {
                if (add_token(TOKEN_ARROW, 0, 0) == 0) {
                    return 0;
                }
                advance();
                advance();
            } else {
                if (add_token(TOKEN_MINUS, 0, 0) == 0) {
                    return 0;
                }
                advance();
            }
            continue;
        }

        if (ch == 42) {
            if (add_token(TOKEN_STAR, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 47) {
            if (peek() == 47) {
                skip_line_comment();
            } else {
                if (add_token(TOKEN_DIVIDE, 0, 0) == 0) {
                    return 0;
                }
                advance();
            }
            continue;
        }

        if (ch == 61) {
            if (peek() == 61) {
                if (add_token(TOKEN_EQUAL, 0, 0) == 0) {
                    return 0;
                }
                advance();
                advance();
            } else {
                if (add_token(TOKEN_ASSIGN, 0, 0) == 0) {
                    return 0;
                }
                advance();
            }
            continue;
        }

        if (ch == 33) {
            if (peek() == 61) {
                if (add_token(TOKEN_NOT_EQUAL, 0, 0) == 0) {
                    return 0;
                }
                advance();
                advance();
            } else {
                return 0;
            }
            continue;
        }

        if (ch == 60) {
            if (peek() == 61) {
                if (add_token(TOKEN_LESS_EQUAL, 0, 0) == 0) {
                    return 0;
                }
                advance();
                advance();
            } else {
                if (add_token(TOKEN_LESS, 0, 0) == 0) {
                    return 0;
                }
                advance();
            }
            continue;
        }

        if (ch == 62) {
            if (peek() == 61) {
                if (add_token(TOKEN_GREATER_EQUAL, 0, 0) == 0) {
                    return 0;
                }
                advance();
                advance();
            } else {
                if (add_token(TOKEN_GREATER, 0, 0) == 0) {
                    return 0;
                }
                advance();
            }
            continue;
        }

        if (ch == 40) {
            if (add_token(TOKEN_LEFT_PAREN, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 41) {
            if (add_token(TOKEN_RIGHT_PAREN, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 123) {
            if (add_token(TOKEN_LEFT_BRACE, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 125) {
            if (add_token(TOKEN_RIGHT_BRACE, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 59) {
            if (add_token(TOKEN_SEMICOLON, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 58) {
            if (add_token(TOKEN_COLON, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 38) {
            if (add_token(TOKEN_AMPERSAND, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 44) {
            if (add_token(TOKEN_COMMA, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        return 0;
    }

    if (add_token(TOKEN_EOF, 0, 0) == 0) {
        return 0;
    }

    return 1;
}

// Test functions
fn assert_token_count(expected: i64) -> i64 {
    if (TOKEN_COUNT != expected) {
        return 0;
    }
    return 1;
}

fn assert_token_type(index: i64, expected_type: i64) -> i64 {
    if (get_token_type(index) != expected_type) {
        return 0;
    }
    return 1;
}

fn assert_token_value(index: i64, expected_value: i64) -> i64 {
    if (get_token_value(index) != expected_value) {
        return 0;
    }
    return 1;
}

fn setup_test(input: i64, length: i64) -> i64 {
    if (init_memory() == 0) {
        return 0;
    }
    if (init_ast() == 0) {
        return 0;
    }
    if (lexer_new(input, length) == 0) {
        return 0;
    }
    return 1;
}

fn test_empty_input() -> i64 {
    let empty_str: i64 = malloc(8);
    *(empty_str + 0) = 0;

    if (setup_test(empty_str, 0) == 0) {
        return 0;
    }

    if (tokenize() == 0) {
        return 0;
    }

    if (assert_token_count(1) == 0) {
        return 0;
    }

    if (assert_token_type(0, TOKEN_EOF) == 0) {
        return 0;
    }

    return 1;
}

fn test_numbers() -> i64 {
    let input: i64 = malloc(64);
    *(input + 0) = 52;
    *(input + 1) = 50;
    *(input + 2) = 32;
    *(input + 3) = 48;
    *(input + 4) = 32;
    *(input + 5) = 49;
    *(input + 6) = 50;
    *(input + 7) = 51;
    *(input + 8) = 0;

    if (setup_test(input, 8) == 0) {
        return 0;
    }

    if (tokenize() == 0) {
        return 0;
    }

    if (assert_token_count(4) == 0) {
        return 0;
    }

    if (assert_token_type(0, TOKEN_NUMBER) == 0) {
        return 0;
    }

    if (assert_token_value(0, 42) == 0) {
        return 0;
    }

    if (assert_token_type(1, TOKEN_NUMBER) == 0) {
        return 0;
    }

    if (assert_token_value(1, 0) == 0) {
        return 0;
    }

    if (assert_token_type(2, TOKEN_NUMBER) == 0) {
        return 0;
    }

    if (assert_token_value(2, 123) == 0) {
        return 0;
    }

    if (assert_token_type(3, TOKEN_EOF) == 0) {
        return 0;
    }

    return 1;
}

fn test_keywords() -> i64 {
    let input: i64 = malloc(128);
    *(input + 0) = 102;
    *(input + 1) = 110;
    *(input + 2) = 32;
    *(input + 3) = 105;
    *(input + 4) = 102;
    *(input + 5) = 0;

    if (setup_test(input, 5) == 0) {
        return 0;
    }

    if (tokenize() == 0) {
        return 0;
    }

    if (assert_token_count(3) == 0) {
        return 0;
    }

    if (assert_token_type(0, TOKEN_FN) == 0) {
        return 0;
    }

    if (assert_token_type(1, TOKEN_IF) == 0) {
        return 0;
    }

    if (assert_token_type(2, TOKEN_EOF) == 0) {
        return 0;
    }

    return 1;
}

fn run_basic_tests() -> i64 {
    let passed: i64 = 0;

    if (test_empty_input()) {
        passed = passed + 1;
    }

    if (test_numbers()) {
        passed = passed + 1;
    }

    if (test_keywords()) {
        passed = passed + 1;
    }

    return passed;
}

fn main() -> i64 {
    return run_basic_tests();
}