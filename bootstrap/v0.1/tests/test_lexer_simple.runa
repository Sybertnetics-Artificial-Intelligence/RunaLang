// Simplified lexer test for Runa-Zero

global MEMORY_POOL = 0;
global MEMORY_OFFSET = 0;
global MEMORY_SIZE = 131072;

fn allocate(size: i64) -> i64 {
    if (MEMORY_OFFSET + size > MEMORY_SIZE) {
        return 0;
    }
    let ptr: i64 = MEMORY_POOL + MEMORY_OFFSET;
    MEMORY_OFFSET = MEMORY_OFFSET + size;
    return ptr;
}

fn init_memory() -> i64 {
    MEMORY_POOL = malloc(MEMORY_SIZE * 8);
    if (MEMORY_POOL == 0) {
        return 0;
    }
    MEMORY_OFFSET = 0;
    return 1;
}

// Token constants
global TOKEN_NUMBER = 1;
global TOKEN_EOF = 33;

// Token storage
global TOKEN_TYPES = 0;
global TOKEN_VALUES = 0;
global TOKEN_COUNT = 0;
global MAX_TOKENS = 1000;

fn init_ast() -> i64 {
    TOKEN_TYPES = allocate(MAX_TOKENS);
    TOKEN_VALUES = allocate(MAX_TOKENS);

    if (TOKEN_TYPES == 0) {
        return 0;
    }
    if (TOKEN_VALUES == 0) {
        return 0;
    }

    TOKEN_COUNT = 0;
    return 1;
}

fn add_token(token_type: i64, value: i64) -> i64 {
    if (TOKEN_COUNT >= MAX_TOKENS) {
        return 0;
    }

    *(TOKEN_TYPES + TOKEN_COUNT) = token_type;
    *(TOKEN_VALUES + TOKEN_COUNT) = value;
    TOKEN_COUNT = TOKEN_COUNT + 1;
    return 1;
}

fn get_token_type(index: i64) -> i64 {
    if (index >= TOKEN_COUNT) {
        return TOKEN_EOF;
    }
    return *(TOKEN_TYPES + index);
}

fn get_token_value(index: i64) -> i64 {
    if (index >= TOKEN_COUNT) {
        return 0;
    }
    return *(TOKEN_VALUES + index);
}

// Lexer state
global INPUT_CHARS = 0;
global INPUT_LENGTH = 0;
global POSITION = 0;

fn is_digit(ch: i64) -> i64 {
    if (ch >= 48) {
        if (ch <= 57) {
            return 1;
        }
    }
    return 0;
}

fn lexer_new(input: i64, length: i64) -> i64 {
    INPUT_CHARS = input;
    INPUT_LENGTH = length;
    POSITION = 0;
    return 1;
}

fn current_char() -> i64 {
    if (POSITION >= INPUT_LENGTH) {
        return 0;
    }
    return *(INPUT_CHARS + POSITION);
}

fn advance() -> i64 {
    if (POSITION >= INPUT_LENGTH) {
        return 0;
    }
    let ch: i64 = *(INPUT_CHARS + POSITION);
    POSITION = POSITION + 1;
    return ch;
}

fn read_number() -> i64 {
    let number: i64 = 0;

    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();
        if (is_digit(ch) == 0) {
            return number;
        }
        number = number * 10 + (ch - 48);
        advance();
    }

    return number;
}

fn tokenize() -> i64 {
    TOKEN_COUNT = 0;

    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();

        if (ch == 32) {
            advance();
            continue;
        }

        if (is_digit(ch)) {
            let number: i64 = read_number();
            if (add_token(TOKEN_NUMBER, number) == 0) {
                return 0;
            }
            continue;
        }

        return 0;
    }

    if (add_token(TOKEN_EOF, 0) == 0) {
        return 0;
    }

    return 1;
}

// Test functions
fn test_numbers() -> i64 {
    let input: i64 = malloc(64);
    *(input + 0) = 52;
    *(input + 1) = 50;
    *(input + 2) = 32;
    *(input + 3) = 49;
    *(input + 4) = 50;
    *(input + 5) = 51;
    *(input + 6) = 0;

    if (init_memory() == 0) {
        return 0;
    }
    if (init_ast() == 0) {
        return 0;
    }
    if (lexer_new(input, 6) == 0) {
        return 0;
    }

    if (tokenize() == 0) {
        return 0;
    }

    if (TOKEN_COUNT != 3) {
        return 0;
    }

    if (get_token_type(0) != TOKEN_NUMBER) {
        return 0;
    }

    if (get_token_value(0) != 42) {
        return 0;
    }

    if (get_token_type(1) != TOKEN_NUMBER) {
        return 0;
    }

    if (get_token_value(1) != 123) {
        return 0;
    }

    if (get_token_type(2) != TOKEN_EOF) {
        return 0;
    }

    return 1;
}

fn main() -> i64 {
    if (test_numbers()) {
        return 1;
    }
    return 0;
}