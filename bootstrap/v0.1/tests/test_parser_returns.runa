// Test various return statement contexts
fn test_simple_return() -> i64 {
    return 42;
}

fn test_return_expression() -> i64 {
    let x: i64 = 10;
    let y: i64 = 20;
    return x + y * 2;
}

fn test_conditional_return() -> i64 {
    let x: i64 = 5;
    if (x > 0) {
        return x * 2;
    }
    return 0;
}

fn test_loop_return() -> i64 {
    let i: i64 = 0;
    let done: i64 = 0;
    while (done == 0) {
        if (i == 5) {
            return i;
        }
        i = i + 1;
        if (i > 10) {
            done = 1;
        }
    }
    return -1;
}

fn test_nested_return() -> i64 {
    for (let i: i64 = 0; i < 10; i = i + 1) {
        if (i > 5) {
            if (i == 7) {
                return i;
            }
        }
    }
    return 0;
}

fn test_return_call() -> i64 {
    return test_simple_return();
}

fn helper(x: i64) -> i64 {
    return x * x;
}

fn test_return_complex() -> i64 {
    return helper(3) + helper(4);
}

fn main() -> i64 {
    let result: i64 = test_simple_return();
    if (result != 42) {
        return 1;
    }

    result = test_return_expression();
    if (result != 50) {
        return 2;
    }

    result = test_conditional_return();
    if (result != 10) {
        return 3;
    }

    result = test_loop_return();
    if (result != 5) {
        return 4;
    }

    result = test_nested_return();
    if (result != 7) {
        return 5;
    }

    result = test_return_call();
    if (result != 42) {
        return 6;
    }

    result = test_return_complex();
    if (result != 25) {
        return 7;
    }

    return 0;
}