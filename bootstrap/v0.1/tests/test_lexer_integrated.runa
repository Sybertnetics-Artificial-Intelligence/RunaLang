// Comprehensive lexer integration test
// Tests lexer with real input to verify functionality

// Include AST definitions first (manually inlined)
global MEMORY_POOL = 0;
global MEMORY_OFFSET = 0;
global MEMORY_SIZE = 131072;

fn allocate(size: i64) -> i64 {
    if (MEMORY_OFFSET + size > MEMORY_SIZE) {
        return 0;
    }
    let ptr: i64 = MEMORY_POOL + MEMORY_OFFSET;
    MEMORY_OFFSET = MEMORY_OFFSET + size;
    return ptr;
}

fn init_memory() -> i64 {
    MEMORY_POOL = malloc(MEMORY_SIZE * 8);
    if (MEMORY_POOL == 0) {
        return 0;
    }
    MEMORY_OFFSET = 0;
    return 1;
}

// Token constants
global TOKEN_NUMBER = 1;
global TOKEN_IDENTIFIER = 2;
global TOKEN_FN = 3;
global TOKEN_LET = 4;
global TOKEN_IF = 5;
global TOKEN_EOF = 33;

// Token storage
global TOKEN_TYPES = 0;
global TOKEN_VALUES = 0;
global TOKEN_STRINGS = 0;
global TOKEN_COUNT = 0;
global MAX_TOKENS = 1000;

// String storage
global STRING_STORAGE = 0;
global STRING_OFFSET = 0;
global MAX_STRING_STORAGE = 50000;

fn init_ast() -> i64 {
    TOKEN_TYPES = allocate(MAX_TOKENS);
    TOKEN_VALUES = allocate(MAX_TOKENS);
    TOKEN_STRINGS = allocate(MAX_TOKENS);
    STRING_STORAGE = allocate(MAX_STRING_STORAGE);

    if (TOKEN_TYPES == 0) {
        return 0;
    }
    if (TOKEN_VALUES == 0) {
        return 0;
    }
    if (TOKEN_STRINGS == 0) {
        return 0;
    }
    if (STRING_STORAGE == 0) {
        return 0;
    }

    TOKEN_COUNT = 0;
    STRING_OFFSET = 0;
    return 1;
}

fn string_length(str: i64) -> i64 {
    let len: i64 = 0;
    while (*(str + len) != 0) {
        len = len + 1;
    }
    return len;
}

fn string_copy(dest: i64, src: i64) -> i64 {
    let i: i64 = 0;
    while (*(src + i) != 0) {
        *(dest + i) = *(src + i);
        i = i + 1;
    }
    *(dest + i) = 0;
    return i;
}

fn store_string(str: i64) -> i64 {
    let len: i64 = string_length(str);
    if (STRING_OFFSET + len + 1 > MAX_STRING_STORAGE) {
        return 0;
    }

    let offset: i64 = STRING_OFFSET;
    string_copy(STRING_STORAGE + offset, str);
    STRING_OFFSET = STRING_OFFSET + len + 1;
    return offset;
}

fn add_token(token_type: i64, value: i64, string_data: i64) -> i64 {
    if (TOKEN_COUNT >= MAX_TOKENS) {
        return 0;
    }

    *(TOKEN_TYPES + TOKEN_COUNT) = token_type;
    *(TOKEN_VALUES + TOKEN_COUNT) = value;
    *(TOKEN_STRINGS + TOKEN_COUNT) = string_data;
    TOKEN_COUNT = TOKEN_COUNT + 1;
    return 1;
}

fn get_token_type(index: i64) -> i64 {
    if (index >= TOKEN_COUNT) {
        return TOKEN_EOF;
    }
    return *(TOKEN_TYPES + index);
}

fn get_token_value(index: i64) -> i64 {
    if (index >= TOKEN_COUNT) {
        return 0;
    }
    return *(TOKEN_VALUES + index);
}

// Lexer state
global INPUT_CHARS = 0;
global INPUT_LENGTH = 0;
global POSITION = 0;
global LINE = 1;
global COLUMN = 1;

fn is_digit(ch: i64) -> i64 {
    if (ch >= 48) {
        if (ch <= 57) {
            return 1;
        }
    }
    return 0;
}

fn is_alpha(ch: i64) -> i64 {
    if (ch >= 97) {
        if (ch <= 122) {
            return 1;
        }
    }
    if (ch >= 65) {
        if (ch <= 90) {
            return 1;
        }
    }
    if (ch == 95) {
        return 1;
    }
    return 0;
}

fn is_alnum(ch: i64) -> i64 {
    if (is_alpha(ch)) {
        return 1;
    }
    if (is_digit(ch)) {
        return 1;
    }
    return 0;
}

fn is_whitespace(ch: i64) -> i64 {
    if (ch == 32) {
        return 1;
    }
    if (ch == 9) {
        return 1;
    }
    if (ch == 13) {
        return 1;
    }
    return 0;
}

fn lexer_new(input: i64, length: i64) -> i64 {
    INPUT_CHARS = input;
    INPUT_LENGTH = length;
    POSITION = 0;
    LINE = 1;
    COLUMN = 1;
    return 1;
}

fn current_char() -> i64 {
    if (POSITION >= INPUT_LENGTH) {
        return 0;
    }
    return *(INPUT_CHARS + POSITION);
}

fn advance() -> i64 {
    if (POSITION >= INPUT_LENGTH) {
        return 0;
    }

    let ch: i64 = *(INPUT_CHARS + POSITION);
    POSITION = POSITION + 1;

    if (ch == 10) {
        LINE = LINE + 1;
        COLUMN = 1;
    } else {
        COLUMN = COLUMN + 1;
    }

    return ch;
}

fn read_number() -> i64 {
    let number: i64 = 0;

    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();
        if (is_digit(ch) == 0) {
            return number;
        }
        number = number * 10 + (ch - 48);
        advance();
    }

    return number;
}

fn read_identifier() -> i64 {
    let start_pos: i64 = POSITION;
    let length: i64 = 0;

    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();
        if (is_alnum(ch) == 0) {
            return length;
        }
        length = length + 1;
        advance();
    }

    return length;
}

fn keyword_or_identifier(text_start: i64, length: i64) -> i64 {
    if (length == 2) {
        if (*(text_start + 0) == 102) {
            if (*(text_start + 1) == 110) {
                return TOKEN_FN;
            }
        }
        if (*(text_start + 0) == 105) {
            if (*(text_start + 1) == 102) {
                return TOKEN_IF;
            }
        }
    }

    if (length == 3) {
        if (*(text_start + 0) == 108) {
            if (*(text_start + 1) == 101) {
                if (*(text_start + 2) == 116) {
                    return TOKEN_LET;
                }
            }
        }
    }

    return TOKEN_IDENTIFIER;
}

fn tokenize() -> i64 {
    TOKEN_COUNT = 0;

    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();

        if (is_whitespace(ch)) {
            advance();
            continue;
        }

        if (ch == 10) {
            advance();
            continue;
        }

        if (is_digit(ch)) {
            let number: i64 = read_number();
            if (add_token(TOKEN_NUMBER, number, 0) == 0) {
                return 0;
            }
            continue;
        }

        if (is_alpha(ch)) {
            let start_pos: i64 = POSITION;
            let length: i64 = read_identifier();
            let token_type: i64 = keyword_or_identifier(INPUT_CHARS + start_pos, length);

            let string_offset: i64 = 0;
            if (token_type == TOKEN_IDENTIFIER) {
                string_offset = store_string(INPUT_CHARS + start_pos);
                if (string_offset == 0) {
                    return 0;
                }
            }

            if (add_token(token_type, 0, string_offset) == 0) {
                return 0;
            }
            continue;
        }

        return 0;
    }

    if (add_token(TOKEN_EOF, 0, 0) == 0) {
        return 0;
    }

    return 1;
}

// Test function
fn test_basic_lexing() -> i64 {
    // Test input: "let x 42 fn if"
    let input: i64 = malloc(128);
    *(input + 0) = 108;  // l
    *(input + 1) = 101;  // e
    *(input + 2) = 116;  // t
    *(input + 3) = 32;   // space
    *(input + 4) = 120;  // x
    *(input + 5) = 32;   // space
    *(input + 6) = 52;   // 4
    *(input + 7) = 50;   // 2
    *(input + 8) = 32;   // space
    *(input + 9) = 102;  // f
    *(input + 10) = 110; // n
    *(input + 11) = 32;  // space
    *(input + 12) = 105; // i
    *(input + 13) = 102; // f
    *(input + 14) = 0;   // null

    if (init_memory() == 0) {
        return 0;
    }
    if (init_ast() == 0) {
        return 0;
    }
    if (lexer_new(input, 14) == 0) {
        return 0;
    }

    if (tokenize() == 0) {
        return 0;
    }

    // Verify tokens
    if (TOKEN_COUNT != 6) {
        return 0;
    }

    // Check first token is LET
    if (get_token_type(0) != TOKEN_LET) {
        return 0;
    }

    // Check second token is IDENTIFIER "x"
    if (get_token_type(1) != TOKEN_IDENTIFIER) {
        return 0;
    }

    // Check third token is NUMBER 42
    if (get_token_type(2) != TOKEN_NUMBER) {
        return 0;
    }
    if (get_token_value(2) != 42) {
        return 0;
    }

    // Check fourth token is FN
    if (get_token_type(3) != TOKEN_FN) {
        return 0;
    }

    // Check fifth token is IF
    if (get_token_type(4) != TOKEN_IF) {
        return 0;
    }

    // Check last token is EOF
    if (get_token_type(5) != TOKEN_EOF) {
        return 0;
    }

    return 1;
}

fn main() -> i64 {
    if (test_basic_lexing()) {
        return 1;
    }
    return 0;
}