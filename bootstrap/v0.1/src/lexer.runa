// Lexer implementation transpiled from Rust to Runa-Zero
// Uses fixed-size arrays instead of Vec<char> and String

// Lexer state
global INPUT_CHARS = 0;
global INPUT_LENGTH = 0;
global POSITION = 0;
global LINE = 1;
global COLUMN = 1;

// Character classification helpers
fn is_digit(ch: i64) -> i64 {
    if (ch >= 48) {
        if (ch <= 57) {
            return 1;
        }
    }
    return 0;
}

fn is_alpha(ch: i64) -> i64 {
    if (ch >= 97) {
        if (ch <= 122) {
            return 1;
        }
    }
    if (ch >= 65) {
        if (ch <= 90) {
            return 1;
        }
    }
    if (ch == 95) {
        return 1;
    }
    return 0;
}

fn is_alnum(ch: i64) -> i64 {
    if (is_alpha(ch)) {
        return 1;
    }
    if (is_digit(ch)) {
        return 1;
    }
    return 0;
}

fn is_whitespace(ch: i64) -> i64 {
    if (ch == 32) {
        return 1;
    }
    if (ch == 9) {
        return 1;
    }
    if (ch == 13) {
        return 1;
    }
    return 0;
}

// Lexer initialization
fn lexer_new(input: i64, length: i64) -> i64 {
    INPUT_CHARS = input;
    INPUT_LENGTH = length;
    POSITION = 0;
    LINE = 1;
    COLUMN = 1;
    return 1;
}

// Current character operations
fn current_char() -> i64 {
    if (POSITION >= INPUT_LENGTH) {
        return 0;
    }
    return *(INPUT_CHARS + POSITION);
}

fn advance() -> i64 {
    if (POSITION >= INPUT_LENGTH) {
        return 0;
    }

    let ch: i64 = *(INPUT_CHARS + POSITION);
    POSITION = POSITION + 1;

    if (ch == 10) {
        LINE = LINE + 1;
        COLUMN = 1;
    } else {
        COLUMN = COLUMN + 1;
    }

    return ch;
}

fn peek() -> i64 {
    if (POSITION + 1 >= INPUT_LENGTH) {
        return 0;
    }
    return *(INPUT_CHARS + POSITION + 1);
}

// Number reading
fn read_number() -> i64 {
    let number: i64 = 0;

    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();
        if (is_digit(ch) == 0) {
            return number;
        }
        number = number * 10 + (ch - 48);
        advance();
    }

    return number;
}

// Identifier reading
fn read_identifier() -> i64 {
    let start_pos: i64 = POSITION;
    let length: i64 = 0;

    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();
        if (is_alnum(ch) == 0) {
            return length;
        }
        length = length + 1;
        advance();
    }

    return length;
}

// String reading
fn read_string() -> i64 {
    advance();
    let start_pos: i64 = POSITION;
    let length: i64 = 0;

    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();
        if (ch == 34) {
            advance();
            return length;
        }
        if (ch == 10) {
            return -1;
        }
        if (ch == 92) {
            advance();
            if (POSITION >= INPUT_LENGTH) {
                return -1;
            }
            advance();
            length = length + 2;
        } else {
            advance();
            length = length + 1;
        }
    }

    return -1;
}

// Character reading
fn read_char() -> i64 {
    advance();

    if (POSITION >= INPUT_LENGTH) {
        return -1;
    }

    let ch: i64 = current_char();
    if (ch == 92) {
        advance();
        if (POSITION >= INPUT_LENGTH) {
            return -1;
        }
        let escaped: i64 = current_char();
        advance();

        if (current_char() != 39) {
            return -1;
        }
        advance();

        if (escaped == 110) {
            return 10;
        }
        if (escaped == 116) {
            return 9;
        }
        if (escaped == 114) {
            return 13;
        }
        if (escaped == 92) {
            return 92;
        }
        if (escaped == 39) {
            return 39;
        }
        return escaped;
    } else {
        advance();
        if (current_char() != 39) {
            return -1;
        }
        advance();
        return ch;
    }
}

// Comment skipping
fn skip_line_comment() -> i64 {
    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();
        if (ch == 10) {
            return 1;
        }
        advance();
    }
    return 1;
}

// String reading
fn read_string() -> i64 {
    advance();
    let start_pos: i64 = POSITION;
    let length: i64 = 0;

    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();
        if (ch == 34) {
            advance();
            return length;
        }
        if (ch == 10) {
            return -1;
        }
        if (ch == 92) {
            advance();
            if (POSITION >= INPUT_LENGTH) {
                return -1;
            }
            advance();
            length = length + 2;
        } else {
            advance();
            length = length + 1;
        }
    }

    return -1;
}

// Character reading
fn read_char() -> i64 {
    advance();

    if (POSITION >= INPUT_LENGTH) {
        return -1;
    }

    let ch: i64 = current_char();
    if (ch == 92) {
        advance();
        if (POSITION >= INPUT_LENGTH) {
            return -1;
        }
        let escaped: i64 = current_char();
        advance();

        if (current_char() != 39) {
            return -1;
        }
        advance();

        if (escaped == 110) {
            return 10;
        }
        if (escaped == 116) {
            return 9;
        }
        if (escaped == 114) {
            return 13;
        }
        if (escaped == 92) {
            return 92;
        }
        if (escaped == 39) {
            return 39;
        }
        return escaped;
    } else {
        advance();
        if (current_char() != 39) {
            return -1;
        }
        advance();
        return ch;
    }
}

// Comment skipping
fn skip_line_comment() -> i64 {
    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();
        if (ch == 10) {
            return 1;
        }
        advance();
    }
    return 1;
}

// Keyword recognition
fn keyword_or_identifier(text_start: i64, length: i64) -> i64 {
    if (length == 2) {
        if (*(text_start + 0) == 102) {
            if (*(text_start + 1) == 110) {
                return TOKEN_FN;
            }
        }
        if (*(text_start + 0) == 105) {
            if (*(text_start + 1) == 102) {
                return TOKEN_IF;
            }
        }
    }

    if (length == 3) {
        if (*(text_start + 0) == 108) {
            if (*(text_start + 1) == 101) {
                if (*(text_start + 2) == 116) {
                    return TOKEN_LET;
                }
            }
        }
    }

    if (length == 4) {
        if (*(text_start + 0) == 101) {
            if (*(text_start + 1) == 108) {
                if (*(text_start + 2) == 115) {
                    if (*(text_start + 3) == 101) {
                        return TOKEN_ELSE;
                    }
                }
            }
        }
    }

    if (length == 5) {
        if (*(text_start + 0) == 119) {
            if (*(text_start + 1) == 104) {
                if (*(text_start + 2) == 105) {
                    if (*(text_start + 3) == 108) {
                        if (*(text_start + 4) == 101) {
                            return TOKEN_WHILE;
                        }
                    }
                }
            }
        }
    }

    if (length == 6) {
        if (*(text_start + 0) == 114) {
            if (*(text_start + 1) == 101) {
                if (*(text_start + 2) == 116) {
                    if (*(text_start + 3) == 117) {
                        if (*(text_start + 4) == 114) {
                            if (*(text_start + 5) == 110) {
                                return TOKEN_RETURN;
                            }
                        }
                    }
                }
            }
        }
        if (*(text_start + 0) == 103) {
            if (*(text_start + 1) == 108) {
                if (*(text_start + 2) == 111) {
                    if (*(text_start + 3) == 98) {
                        if (*(text_start + 4) == 97) {
                            if (*(text_start + 5) == 108) {
                                return TOKEN_GLOBAL;
                            }
                        }
                    }
                }
            }
        }
    }

    return TOKEN_IDENTIFIER;
}

// Main tokenization function
fn tokenize() -> i64 {
    TOKEN_COUNT = 0;

    while (POSITION < INPUT_LENGTH) {
        let ch: i64 = current_char();

        if (is_whitespace(ch)) {
            advance();
            continue;
        }

        if (ch == 10) {
            if (add_token(TOKEN_NEWLINE, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (is_digit(ch)) {
            let number: i64 = read_number();
            if (add_token(TOKEN_NUMBER, number, 0) == 0) {
                return 0;
            }
            continue;
        }

        if (is_alpha(ch)) {
            let start_pos: i64 = POSITION;
            let length: i64 = read_identifier();
            let token_type: i64 = keyword_or_identifier(INPUT_CHARS + start_pos, length);

            let string_offset: i64 = 0;
            if (token_type == TOKEN_IDENTIFIER) {
                string_offset = store_string(INPUT_CHARS + start_pos);
                if (string_offset == 0) {
                    return 0;
                }
            }

            if (add_token(token_type, 0, string_offset) == 0) {
                return 0;
            }
            continue;
        }

        if (ch == 34) {
            let start_pos: i64 = POSITION + 1;
            let length: i64 = read_string();
            if (length < 0) {
                return 0;
            }

            let string_offset: i64 = store_string(INPUT_CHARS + start_pos);
            if (string_offset == 0) {
                return 0;
            }

            if (add_token(TOKEN_STRING_LITERAL, 0, string_offset) == 0) {
                return 0;
            }
            continue;
        }

        if (ch == 39) {
            let char_value: i64 = read_char();
            if (char_value < 0) {
                return 0;
            }

            if (add_token(TOKEN_CHAR_LITERAL, char_value, 0) == 0) {
                return 0;
            }
            continue;
        }

        if (ch == 43) {
            if (add_token(TOKEN_PLUS, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 45) {
            if (peek() == 62) {
                if (add_token(TOKEN_ARROW, 0, 0) == 0) {
                    return 0;
                }
                advance();
                advance();
            } else {
                if (add_token(TOKEN_MINUS, 0, 0) == 0) {
                    return 0;
                }
                advance();
            }
            continue;
        }

        if (ch == 42) {
            if (add_token(TOKEN_STAR, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 47) {
            if (peek() == 47) {
                skip_line_comment();
            } else {
                if (add_token(TOKEN_DIVIDE, 0, 0) == 0) {
                    return 0;
                }
                advance();
            }
            continue;
        }

        if (ch == 61) {
            if (peek() == 61) {
                if (add_token(TOKEN_EQUAL, 0, 0) == 0) {
                    return 0;
                }
                advance();
                advance();
            } else {
                if (add_token(TOKEN_ASSIGN, 0, 0) == 0) {
                    return 0;
                }
                advance();
            }
            continue;
        }

        if (ch == 33) {
            if (peek() == 61) {
                if (add_token(TOKEN_NOT_EQUAL, 0, 0) == 0) {
                    return 0;
                }
                advance();
                advance();
            } else {
                return 0;
            }
            continue;
        }

        if (ch == 60) {
            if (peek() == 61) {
                if (add_token(TOKEN_LESS_EQUAL, 0, 0) == 0) {
                    return 0;
                }
                advance();
                advance();
            } else {
                if (add_token(TOKEN_LESS, 0, 0) == 0) {
                    return 0;
                }
                advance();
            }
            continue;
        }

        if (ch == 62) {
            if (peek() == 61) {
                if (add_token(TOKEN_GREATER_EQUAL, 0, 0) == 0) {
                    return 0;
                }
                advance();
                advance();
            } else {
                if (add_token(TOKEN_GREATER, 0, 0) == 0) {
                    return 0;
                }
                advance();
            }
            continue;
        }

        if (ch == 40) {
            if (add_token(TOKEN_LEFT_PAREN, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 41) {
            if (add_token(TOKEN_RIGHT_PAREN, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 123) {
            if (add_token(TOKEN_LEFT_BRACE, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 125) {
            if (add_token(TOKEN_RIGHT_BRACE, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 59) {
            if (add_token(TOKEN_SEMICOLON, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 58) {
            if (add_token(TOKEN_COLON, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 38) {
            if (add_token(TOKEN_AMPERSAND, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        if (ch == 44) {
            if (add_token(TOKEN_COMMA, 0, 0) == 0) {
                return 0;
            }
            advance();
            continue;
        }

        return 0;
    }

    if (add_token(TOKEN_EOF, 0, 0) == 0) {
        return 0;
    }

    return 1;
}