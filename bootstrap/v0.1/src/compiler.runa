// Complete Runa-Zero Compiler v0.1
// Self-contained version using libc functions

// These libc functions are recognized by v0.0 as external calls:
// puts, malloc, free, exit, fopen, fgetc, fprintf, fclose, system

// =============================================================================
// MEMORY ALLOCATOR (using malloc for simplicity)
// =============================================================================

fn allocate(size: i64) -> i64 {
    let ptr: i64 = malloc(size);
    if (ptr == 0) {
        puts("Error: Out of memory");
        exit(1);
    }

    // Clear allocated memory
    let i: i64 = 0;
    while (i < size) {
        *(ptr + i) = 0;
        i = i + 1;
    }

    return ptr;
}

// =============================================================================
// STRING UTILITIES
// =============================================================================

fn string_length(str: i64) -> i64 {
    let len: i64 = 0;
    while (*(str + len) != 0) {
        len = len + 1;
    }
    return len;
}

fn string_copy(dest: i64, src: i64) -> i64 {
    let i: i64 = 0;
    while (*(src + i) != 0) {
        *(dest + i) = *(src + i);
        i = i + 1;
    }
    *(dest + i) = 0;
    return 1;
}

fn string_concat(dest: i64, src: i64) -> i64 {
    let dest_len: i64 = string_length(dest);
    let i: i64 = 0;
    while (*(src + i) != 0) {
        *(dest + dest_len + i) = *(src + i);
        i = i + 1;
    }
    *(dest + dest_len + i) = 0;
    return 1;
}

fn string_compare(s1: i64, s2: i64) -> i64 {
    let i: i64 = 0;
    while (1 == 1) {
        let c1: i64 = *(s1 + i);
        let c2: i64 = *(s2 + i);

        if (c1 != c2) {
            return 0;
        }
        if (c1 == 0) {
            return 1;
        }
        i = i + 1;
    }
    return 0;
}

fn int_to_string(n: i64) -> i64 {
    let buf: i64 = allocate(32);
    let i: i64 = 0;
    let negative: i64 = 0;

    if (n < 0) {
        negative = 1;
        n = -n;
    }

    if (n == 0) {
        *(buf + 0) = 48;
        *(buf + 1) = 0;
        return buf;
    }

    // Build string in reverse
    while (n > 0) {
        *(buf + i) = 48 + (n % 10);
        n = n / 10;
        i = i + 1;
    }

    if (negative == 1) {
        *(buf + i) = 45;  // '-'
        i = i + 1;
    }

    *(buf + i) = 0;

    // Reverse the string
    let j: i64 = 0;
    i = i - 1;
    while (j < i) {
        let temp: i64 = *(buf + j);
        *(buf + j) = *(buf + i);
        *(buf + i) = temp;
        j = j + 1;
        i = i - 1;
    }

    return buf;
}


// =============================================================================
// MAIN COMPILER ENTRY POINT
// =============================================================================

// Main entry point for self-contained compiler
fn main(argc: i64, argv: i64) -> i64 {
    if (argc != 3) {
        puts("Usage: runac <input.runa> <output>");
        return 1;
    }

    let input_path: i64 = *(argv + 8);   // argv[1]
    let output_path: i64 = *(argv + 16);  // argv[2]

    // 1. Read the source file
    let file: i64 = fopen(input_path, "r");
    if (file == 0) {
        puts("Error: Cannot open input file");
        return 1;
    }

    // Read file into buffer
    let buffer_size: i64 = 65536;
    let buffer: i64 = malloc(buffer_size);
    let pos: i64 = 0;

    let c: i64 = fgetc(file);
    while (c != -1) {
        *(buffer + pos) = c;
        pos = pos + 1;
        if (pos >= buffer_size - 1) {
            puts("Error: Input file too large");
            fclose(file);
            return 1;
        }
        c = fgetc(file);
    }
    *(buffer + pos) = 0;
    fclose(file);

    // 2. Initialize compiler components
    init_lexer();
    init_ast();
    init_parser();
    init_codegen();

    // 3. Lex, Parse, Generate code
    puts("Compiling...");

    // These functions would use the actual implementations
    let tokens: i64 = tokenize(buffer);
    let ast: i64 = parse();
    let asm_code: i64 = generate(0);

    // 4. Write assembly output
    let asm_file: i64 = fopen("temp.s", "w");
    if (asm_file == 0) {
        puts("Error: Cannot create assembly file");
        return 1;
    }
    fprintf(asm_file, "%s", asm_code);
    fclose(asm_file);

    // 5. Assemble with NASM
    let nasm_cmd: i64 = malloc(256);
    let i: i64 = 0;

    // Build "nasm -f elf64 temp.s -o temp.o"
    let nasm_str: i64 = "nasm -f elf64 temp.s -o temp.o";
    while (*(nasm_str + i) != 0) {
        *(nasm_cmd + i) = *(nasm_str + i);
        i = i + 1;
    }
    *(nasm_cmd + i) = 0;

    if (system(nasm_cmd) != 0) {
        puts("Error: NASM assembly failed");
        return 1;
    }

    // 6. Link with GCC
    let gcc_cmd: i64 = malloc(512);

    // Build "gcc temp.o -o output -nostartfiles -lc -no-pie"
    let gcc_prefix: i64 = "gcc temp.o -o ";
    i = 0;
    while (*(gcc_prefix + i) != 0) {
        *(gcc_cmd + i) = *(gcc_prefix + i);
        i = i + 1;
    }

    // Add output path
    let j: i64 = 0;
    while (*(output_path + j) != 0) {
        *(gcc_cmd + i) = *(output_path + j);
        i = i + 1;
        j = j + 1;
    }

    // Add flags
    let gcc_suffix: i64 = " -nostartfiles -lc -no-pie";
    j = 0;
    while (*(gcc_suffix + j) != 0) {
        *(gcc_cmd + i) = *(gcc_suffix + j);
        i = i + 1;
        j = j + 1;
    }
    *(gcc_cmd + i) = 0;

    if (system(gcc_cmd) != 0) {
        puts("Error: GCC linking failed");
        return 1;
    }

    puts("Compilation successful!");
    return 0;
}

// Component initialization stubs
// These would call the actual implementations from lexer.runa, parser.runa, codegen.runa

fn init_lexer() -> i64 {
    // Initialization from lexer.runa
    return 1;
}

fn init_ast() -> i64 {
    // Initialization from ast.runa
    return 1;
}

fn init_parser() -> i64 {
    // Initialization from parser.runa
    return 1;
}

fn init_codegen() -> i64 {
    // Initialization from codegen.runa
    return 1;
}