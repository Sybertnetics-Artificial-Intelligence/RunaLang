// Main driver for Runa-Zero Compiler v0.1
// Using libc functions for file I/O and process execution

// These libc functions are recognized by v0.0 as external calls:
// puts, malloc, free, exit, fopen, fgetc, fprintf, fclose, system

// Read entire file into memory using libc
fn read_file(path: i64) -> i64 {
    let file: i64 = fopen(path, "r");
    if (file == 0) {
        puts("Error: Cannot open file");
        return 0;
    }

    // Allocate initial buffer
    let buffer_size: i64 = 65536;  // 64KB initial size
    let buffer: i64 = malloc(buffer_size);
    let pos: i64 = 0;

    // Read file character by character
    let c: i64 = fgetc(file);
    while (c != -1) {  // -1 is EOF
        if (pos >= buffer_size - 1) {
            // Need to grow buffer
            let new_size: i64 = buffer_size * 2;
            let new_buffer: i64 = malloc(new_size);

            // Copy old buffer to new
            let i: i64 = 0;
            while (i < pos) {
                *(new_buffer + i) = *(buffer + i);
                i = i + 1;
            }

            free(buffer);
            buffer = new_buffer;
            buffer_size = new_size;
        }

        *(buffer + pos) = c;
        pos = pos + 1;
        c = fgetc(file);
    }

    // Null-terminate
    *(buffer + pos) = 0;

    fclose(file);
    return buffer;
}

// Write string to file using libc
fn write_file(path: i64, content: i64) -> i64 {
    let file: i64 = fopen(path, "w");
    if (file == 0) {
        puts("Error: Cannot create file");
        return 0;
    }

    // Use fprintf to write the content
    fprintf(file, "%s", content);

    fclose(file);
    return 1;
}

// Build a command string by concatenating parts
fn build_command(parts: i64, count: i64) -> i64 {
    // Calculate total length needed
    let total_len: i64 = 0;
    let i: i64 = 0;
    while (i < count) {
        let part: i64 = *(parts + (i * 8));
        let j: i64 = 0;
        while (*(part + j) != 0) {
            total_len = total_len + 1;
            j = j + 1;
        }
        if (i < count - 1) {
            total_len = total_len + 1;  // Space between parts
        }
        i = i + 1;
    }

    // Allocate buffer
    let cmd: i64 = malloc(total_len + 1);
    let pos: i64 = 0;

    // Copy parts
    i = 0;
    while (i < count) {
        let part: i64 = *(parts + (i * 8));
        let j: i64 = 0;
        while (*(part + j) != 0) {
            *(cmd + pos) = *(part + j);
            pos = pos + 1;
            j = j + 1;
        }
        if (i < count - 1) {
            *(cmd + pos) = 32;  // Space
            pos = pos + 1;
        }
        i = i + 1;
    }

    *(cmd + pos) = 0;
    return cmd;
}

// String comparison helper
fn str_equal(s1: i64, s2: i64) -> i64 {
    let i: i64 = 0;
    while (1 == 1) {
        let c1: i64 = *(s1 + i);
        let c2: i64 = *(s2 + i);
        if (c1 != c2) {
            return 0;
        }
        if (c1 == 0) {
            return 1;
        }
        i = i + 1;
    }
    return 0;
}

// Parse command line arguments
fn parse_args() -> i64 {
    // Check argument count
    if (ARGC < 2) {
        puts("Usage: runac [OPTIONS] <input>");
        puts("  -o <FILE>        Output file");
        puts("  --emit-asm-only  Only emit assembly");
        exit(1);
    }

    // Initialize defaults
    let input_file: i64 = 0;
    let output_file: i64 = 0;
    let emit_asm_only: i64 = 0;

    // Parse arguments
    let i: i64 = 1;
    while (i < ARGC) {
        let arg: i64 = *(ARGV + (i * 8));

        if (str_equal(arg, "-o") == 1) {
            // Output file
            i = i + 1;
            if (i >= ARGC) {
                puts("Error: -o requires an argument");
                exit(1);
            }
            output_file = *(ARGV + (i * 8));
        } else {
            if (str_equal(arg, "--emit-asm-only") == 1) {
                // Emit assembly only
                emit_asm_only = 1;
            } else {
                // Must be input file
                if (input_file == 0) {
                    input_file = arg;
                } else {
                    puts("Error: Multiple input files specified");
                    exit(1);
                }
            }
        }

        i = i + 1;
    }

    // Check for required input file
    if (input_file == 0) {
        puts("Error: No input file specified");
        exit(1);
    }

    // Set default output if not specified
    if (output_file == 0) {
        output_file = "a.out";
    }

    // Store parsed arguments in globals
    INPUT_FILE = input_file;
    OUTPUT_FILE = output_file;
    EMIT_ASM_ONLY = emit_asm_only;

    return 1;
}

// Globals for parsed arguments
let INPUT_FILE: i64 = 0;
let OUTPUT_FILE: i64 = 0;
let EMIT_ASM_ONLY: i64 = 0;

// Compile function - main compilation pipeline
fn compile() -> i64 {
    // Read source file
    puts("Reading input file...");
    let source: i64 = read_file(INPUT_FILE);
    if (source == 0) {
        return 0;
    }

    // Initialize compiler components
    init_lexer();
    init_ast();
    init_parser();
    init_codegen();

    // Lexical analysis
    puts("Lexing...");
    let token_count: i64 = tokenize(source);
    if (token_count < 0) {
        puts("Error: Lexer failed");
        return 0;
    }

    // Parsing
    puts("Parsing...");
    let ast_result: i64 = parse();
    if (ast_result == 0) {
        puts("Error: Parser failed");
        return 0;
    }

    // Code generation
    puts("Generating code...");
    let assembly: i64 = generate(0);
    if (assembly == 0) {
        puts("Error: Code generation failed");
        return 0;
    }

    // Determine output assembly file name
    let asm_file: i64 = 0;
    if (EMIT_ASM_ONLY == 1) {
        asm_file = OUTPUT_FILE;
    } else {
        // Create .s filename
        asm_file = malloc(256);
        let i: i64 = 0;
        while (*(OUTPUT_FILE + i) != 0) {
            *(asm_file + i) = *(OUTPUT_FILE + i);
            i = i + 1;
        }
        *(asm_file + i) = 46;      // '.'
        *(asm_file + i + 1) = 115;  // 's'
        *(asm_file + i + 2) = 0;
    }

    // Write assembly file
    puts("Writing assembly...");
    if (write_file(asm_file, assembly) == 0) {
        return 0;
    }

    // If only emitting assembly, we're done
    if (EMIT_ASM_ONLY == 1) {
        puts("Assembly written successfully");
        return 1;
    }

    // Assemble with NASM
    puts("Assembling with NASM...");

    // Build NASM command: "nasm -f elf64 file.s -o file.o"
    let nasm_parts: i64 = malloc(6 * 8);
    *(nasm_parts + 0) = "nasm";
    *(nasm_parts + 8) = "-f";
    *(nasm_parts + 16) = "elf64";
    *(nasm_parts + 24) = asm_file;
    *(nasm_parts + 32) = "-o";

    // Create .o filename
    let obj_file: i64 = malloc(256);
    let i: i64 = 0;
    while (*(OUTPUT_FILE + i) != 0) {
        *(obj_file + i) = *(OUTPUT_FILE + i);
        i = i + 1;
    }
    *(obj_file + i) = 46;      // '.'
    *(obj_file + i + 1) = 111;  // 'o'
    *(obj_file + i + 2) = 0;

    *(nasm_parts + 40) = obj_file;

    let nasm_cmd: i64 = build_command(nasm_parts, 6);
    if (system(nasm_cmd) != 0) {
        puts("Error: NASM assembly failed");
        return 0;
    }

    // Link with GCC
    puts("Linking with GCC...");

    // Build GCC command: "gcc file.o -o output -nostartfiles -lc -no-pie"
    let gcc_parts: i64 = malloc(7 * 8);
    *(gcc_parts + 0) = "gcc";
    *(gcc_parts + 8) = obj_file;
    *(gcc_parts + 16) = "-o";
    *(gcc_parts + 24) = OUTPUT_FILE;
    *(gcc_parts + 32) = "-nostartfiles";
    *(gcc_parts + 40) = "-lc";
    *(gcc_parts + 48) = "-no-pie";

    let gcc_cmd: i64 = build_command(gcc_parts, 7);
    if (system(gcc_cmd) != 0) {
        puts("Error: GCC linking failed");
        return 0;
    }

    puts("Compilation successful!");
    return 1;
}

// Main entry point - receives argc and argv from runtime
fn main(argc: i64, argv: i64) -> i64 {
    // Store command line arguments
    ARGC = argc;
    ARGV = argv;

    // Parse arguments
    parse_args();

    // Run compilation
    if (compile() == 0) {
        exit(1);
    }

    return 0;
}