// Code Generator for Runa-Zero Compiler v0.1
// Transpiled from Rust to Runa-Zero

// Global constants
let OUTPUT_BUFFER: i64 = 0;
let OUTPUT_BUFFER_SIZE: i64 = 1048576;  // 1MB buffer
let OUTPUT_POS: i64 = 0;

let LABEL_COUNTER: i64 = 0;

// Local variable tracking (stack of function scopes)
let LOCAL_NAMES: i64 = 0;
let LOCAL_OFFSETS: i64 = 0;
let LOCAL_COUNT: i64 = 0;
let MAX_LOCALS: i64 = 100;

let STACK_OFFSET: i64 = 0;

// Global variable tracking
let GLOBAL_NAMES: i64 = 0;
let GLOBAL_LABELS: i64 = 0;
let GLOBAL_COUNT: i64 = 0;
let MAX_GLOBALS: i64 = 100;

// String literal tracking
let STRING_CONTENTS: i64 = 0;
let STRING_LABELS: i64 = 0;
let STRING_COUNT: i64 = 0;
let MAX_STRINGS: i64 = 100;
let STRING_COUNTER: i64 = 0;

// Initialize code generator
fn init_codegen() -> i64 {
    OUTPUT_BUFFER = allocate(OUTPUT_BUFFER_SIZE);
    OUTPUT_POS = 0;
    LABEL_COUNTER = 0;

    // Initialize local variable tracking
    LOCAL_NAMES = allocate(MAX_LOCALS * 256);  // 256 chars per name
    LOCAL_OFFSETS = allocate(MAX_LOCALS * 8);
    LOCAL_COUNT = 0;

    STACK_OFFSET = 0;

    // Initialize global variable tracking
    GLOBAL_NAMES = allocate(MAX_GLOBALS * 256);
    GLOBAL_LABELS = allocate(MAX_GLOBALS * 256);
    GLOBAL_COUNT = 0;

    // Initialize string literal tracking
    STRING_CONTENTS = allocate(MAX_STRINGS * 256);
    STRING_LABELS = allocate(MAX_STRINGS * 256);
    STRING_COUNT = 0;
    STRING_COUNTER = 0;

    return 1;
}

// Emit instruction to output buffer
fn emit(instruction: i64) -> i64 {
    // Add 4 spaces indentation
    let spaces: i64 = OUTPUT_BUFFER + OUTPUT_POS;
    *(spaces + 0) = 32;  // space
    *(spaces + 1) = 32;
    *(spaces + 2) = 32;
    *(spaces + 3) = 32;
    OUTPUT_POS = OUTPUT_POS + 4;

    // Copy instruction string
    let i: i64 = 0;
    while (*(instruction + i) != 0) {
        *(OUTPUT_BUFFER + OUTPUT_POS) = *(instruction + i);
        OUTPUT_POS = OUTPUT_POS + 1;
        i = i + 1;
    }

    // Add newline
    *(OUTPUT_BUFFER + OUTPUT_POS) = 10;
    OUTPUT_POS = OUTPUT_POS + 1;

    return 1;
}

// Emit label (no indentation)
fn emit_label(label: i64) -> i64 {
    // Copy label string
    let i: i64 = 0;
    while (*(label + i) != 0) {
        *(OUTPUT_BUFFER + OUTPUT_POS) = *(label + i);
        OUTPUT_POS = OUTPUT_POS + 1;
        i = i + 1;
    }

    // Add colon and newline
    *(OUTPUT_BUFFER + OUTPUT_POS) = 58;  // colon
    OUTPUT_POS = OUTPUT_POS + 1;
    *(OUTPUT_BUFFER + OUTPUT_POS) = 10;  // newline
    OUTPUT_POS = OUTPUT_POS + 1;

    return 1;
}

// Emit raw string without indentation
fn emit_raw(str: i64) -> i64 {
    let i: i64 = 0;
    while (*(str + i) != 0) {
        *(OUTPUT_BUFFER + OUTPUT_POS) = *(str + i);
        OUTPUT_POS = OUTPUT_POS + 1;
        i = i + 1;
    }
    return 1;
}

// Generate new label
fn new_label() -> i64 {
    let label_buf: i64 = allocate(32);
    *(label_buf + 0) = 76;  // 'L'

    // Convert counter to string
    let num_str: i64 = int_to_string(LABEL_COUNTER);
    let i: i64 = 0;
    while (*(num_str + i) != 0) {
        *(label_buf + 1 + i) = *(num_str + i);
        i = i + 1;
    }
    *(label_buf + 1 + i) = 0;

    LABEL_COUNTER = LABEL_COUNTER + 1;
    return label_buf;
}

// Look up local variable
fn lookup_local(name: i64) -> i64 {
    let i: i64 = 0;
    while (i < LOCAL_COUNT) {
        let local_name: i64 = LOCAL_NAMES + (i * 256);
        if (string_compare(local_name, name) == 1) {
            return *(LOCAL_OFFSETS + (i * 8));
        }
        i = i + 1;
    }
    return 999999;  // Not found marker
}

// Add local variable
fn add_local(name: i64, offset: i64) -> i64 {
    if (LOCAL_COUNT >= MAX_LOCALS) {
        return 0;
    }

    // Copy name
    let local_name: i64 = LOCAL_NAMES + (LOCAL_COUNT * 256);
    string_copy(local_name, name);

    // Store offset
    *(LOCAL_OFFSETS + (LOCAL_COUNT * 8)) = offset;
    LOCAL_COUNT = LOCAL_COUNT + 1;

    return 1;
}

// Clear locals (for new function)
fn clear_locals() -> i64 {
    LOCAL_COUNT = 0;
    STACK_OFFSET = 0;
    return 1;
}

// Look up global variable
fn lookup_global(name: i64) -> i64 {
    let i: i64 = 0;
    while (i < GLOBAL_COUNT) {
        let global_name: i64 = GLOBAL_NAMES + (i * 256);
        if (string_compare(global_name, name) == 1) {
            return GLOBAL_LABELS + (i * 256);
        }
        i = i + 1;
    }
    return 0;  // Not found
}

// Add global variable
fn add_global(name: i64, label: i64) -> i64 {
    if (GLOBAL_COUNT >= MAX_GLOBALS) {
        return 0;
    }

    // Copy name
    let global_name: i64 = GLOBAL_NAMES + (GLOBAL_COUNT * 256);
    string_copy(global_name, name);

    // Copy label
    let global_label: i64 = GLOBAL_LABELS + (GLOBAL_COUNT * 256);
    string_copy(global_label, label);

    GLOBAL_COUNT = GLOBAL_COUNT + 1;
    return 1;
}

// Look up string literal
fn lookup_string(content: i64) -> i64 {
    let i: i64 = 0;
    while (i < STRING_COUNT) {
        let str_content: i64 = STRING_CONTENTS + (i * 256);
        if (string_compare(str_content, content) == 1) {
            return STRING_LABELS + (i * 256);
        }
        i = i + 1;
    }
    return 0;  // Not found
}

// Add string literal
fn add_string(content: i64) -> i64 {
    // Check if already exists
    let existing: i64 = lookup_string(content);
    if (existing != 0) {
        return existing;
    }

    if (STRING_COUNT >= MAX_STRINGS) {
        return 0;
    }

    // Copy content
    let str_content: i64 = STRING_CONTENTS + (STRING_COUNT * 256);
    string_copy(str_content, content);

    // Generate label
    let label: i64 = STRING_LABELS + (STRING_COUNT * 256);
    *(label + 0) = 115;  // 's'
    *(label + 1) = 116;  // 't'
    *(label + 2) = 114;  // 'r'
    *(label + 3) = 95;   // '_'

    let num_str: i64 = int_to_string(STRING_COUNTER);
    let i: i64 = 0;
    while (*(num_str + i) != 0) {
        *(label + 4 + i) = *(num_str + i);
        i = i + 1;
    }
    *(label + 4 + i) = 0;

    STRING_COUNT = STRING_COUNT + 1;
    STRING_COUNTER = STRING_COUNTER + 1;

    return label;
}

// Emit prologue
fn emit_prologue() -> i64 {
    emit_raw("section .data\n");

    // Emit global variables
    let i: i64 = 0;
    while (i < GLOBAL_COUNT) {
        emit_raw("    ");
        emit_raw(GLOBAL_LABELS + (i * 256));
        emit_raw(" dq 0\n");
        i = i + 1;
    }

    // Emit string literals
    i = 0;
    while (i < STRING_COUNT) {
        emit_raw("    ");
        emit_raw(STRING_LABELS + (i * 256));
        emit_raw(" db ");

        // Emit string bytes
        let content: i64 = STRING_CONTENTS + (i * 256);
        let j: i64 = 0;
        let first: i64 = 1;
        while (*(content + j) != 0) {
            if (first == 0) {
                emit_raw(", ");
            }
            first = 0;

            let ch: i64 = *(content + j);
            if (ch == 10) {  // newline
                emit_raw("10");
            } else {
                if (ch == 13) {  // carriage return
                    emit_raw("13");
                } else {
                    if (ch == 9) {  // tab
                        emit_raw("9");
                    } else {
                        if (ch == 92) {  // backslash
                            emit_raw("92");
                        } else {
                            if (ch == 34) {  // quote
                                emit_raw("34");
                            } else {
                                if (ch >= 32) {
                                    if (ch <= 126) {
                                        // Printable ASCII - emit as character
                                        emit_raw("'");
                                        let char_buf: i64 = allocate(2);
                                        *(char_buf + 0) = ch;
                                        *(char_buf + 1) = 0;
                                        emit_raw(char_buf);
                                        emit_raw("'");
                                    } else {
                                        // Non-printable
                                        emit_raw(int_to_string(ch));
                                    }
                                } else {
                                    // Non-printable
                                    emit_raw(int_to_string(ch));
                                }
                            }
                        }
                    }
                }
            }
            j = j + 1;
        }

        emit_raw(", 0\n");  // Null terminator
        i = i + 1;
    }

    emit_raw("\nsection .text\n");
    emit_raw("    global _start\n");
    emit_raw("    extern puts, malloc, exit\n\n");
    emit_raw("_start:\n");

    return 1;
}

// Collect globals from program (first pass)
fn collect_globals(program: i64) -> i64 {
    let current: i64 = AST_NODES;
    let end: i64 = AST_NODES + (AST_COUNT * NODE_SIZE);

    while (current < end) {
        let node_type: i64 = *(current + 0);

        if (node_type == STMT_GLOBAL_DECL) {
            let name_ptr: i64 = *(current + 8);

            // Generate label for global
            let label: i64 = allocate(256);
            string_copy(label, "global_");
            string_concat(label, name_ptr);

            add_global(name_ptr, label);

            // Collect strings from value expression
            let value_node: i64 = *(current + 16);
            collect_strings_from_expression(value_node);
        }

        if (node_type == STMT_FUNCTION_DEF) {
            // Recursively collect from function body
            let body_start: i64 = *(current + 32);
            let body_count: i64 = *(current + 40);
            collect_globals_from_statements(body_start, body_count);
        }

        // Collect strings from other statement types
        collect_strings_from_statement(current);

        current = current + NODE_SIZE;
    }

    return 1;
}

// Collect strings from expression
fn collect_strings_from_expression(expr_node: i64) -> i64 {
    if (expr_node == 0) {
        return 1;
    }

    let expr_type: i64 = *(expr_node + 0);

    if (expr_type == EXPR_STRING_LITERAL) {
        let content: i64 = *(expr_node + 8);
        add_string(content);
    }

    if (expr_type == EXPR_BINARY_OP) {
        let left: i64 = *(expr_node + 16);
        let right: i64 = *(expr_node + 24);
        collect_strings_from_expression(left);
        collect_strings_from_expression(right);
    }

    if (expr_type == EXPR_UNARY_OP) {
        let operand: i64 = *(expr_node + 16);
        collect_strings_from_expression(operand);
    }

    if (expr_type == EXPR_CALL) {
        let args_start: i64 = *(expr_node + 16);
        let args_count: i64 = *(expr_node + 24);
        let i: i64 = 0;
        while (i < args_count) {
            let arg: i64 = *(args_start + (i * 8));
            collect_strings_from_expression(arg);
            i = i + 1;
        }
    }

    return 1;
}

// Collect strings from statement
fn collect_strings_from_statement(stmt_node: i64) -> i64 {
    let stmt_type: i64 = *(stmt_node + 0);

    if (stmt_type == STMT_VARIABLE_DECL) {
        let value: i64 = *(stmt_node + 24);
        collect_strings_from_expression(value);
    }

    if (stmt_type == STMT_ASSIGNMENT) {
        let target: i64 = *(stmt_node + 8);
        let value: i64 = *(stmt_node + 16);
        collect_strings_from_expression(target);
        collect_strings_from_expression(value);
    }

    if (stmt_type == STMT_IF) {
        let condition: i64 = *(stmt_node + 8);
        collect_strings_from_expression(condition);
    }

    if (stmt_type == STMT_WHILE) {
        let condition: i64 = *(stmt_node + 8);
        collect_strings_from_expression(condition);
    }

    if (stmt_type == STMT_RETURN) {
        let expr: i64 = *(stmt_node + 8);
        collect_strings_from_expression(expr);
    }

    if (stmt_type == STMT_EXPRESSION) {
        let expr: i64 = *(stmt_node + 8);
        collect_strings_from_expression(expr);
    }

    return 1;
}

// Collect globals from statement list
fn collect_globals_from_statements(start: i64, count: i64) -> i64 {
    let i: i64 = 0;
    while (i < count) {
        let stmt: i64 = *(start + (i * 8));
        collect_strings_from_statement(stmt);
        i = i + 1;
    }
    return 1;
}

// Generate code for expression
fn generate_expression(expr_node: i64) -> i64 {
    if (expr_node == 0) {
        emit("mov rax, 0");
        emit("push rax");
        return 1;
    }

    let expr_type: i64 = *(expr_node + 0);

    if (expr_type == EXPR_LITERAL) {
        let value: i64 = *(expr_node + 8);
        let buf: i64 = allocate(256);
        string_copy(buf, "mov rax, ");
        string_concat(buf, int_to_string(value));
        emit(buf);
        emit("push rax");
        return 1;
    }

    if (expr_type == EXPR_STRING_LITERAL) {
        let content: i64 = *(expr_node + 8);
        let label: i64 = lookup_string(content);
        let buf: i64 = allocate(256);
        string_copy(buf, "mov rax, ");
        string_concat(buf, label);
        emit(buf);
        emit("push rax");
        return 1;
    }

    if (expr_type == EXPR_CHAR_LITERAL) {
        let ch: i64 = *(expr_node + 8);
        let buf: i64 = allocate(256);
        string_copy(buf, "mov rax, ");
        string_concat(buf, int_to_string(ch));
        emit(buf);
        emit("push rax");
        return 1;
    }

    if (expr_type == EXPR_VARIABLE) {
        let name: i64 = *(expr_node + 8);
        let local_offset: i64 = lookup_local(name);

        if (local_offset != 999999) {
            // Local variable
            let buf: i64 = allocate(256);
            string_copy(buf, "mov rax, [rbp");
            if (local_offset < 0) {
                string_concat(buf, int_to_string(local_offset));
            } else {
                string_concat(buf, "+");
                string_concat(buf, int_to_string(local_offset));
            }
            string_concat(buf, "]");
            emit(buf);
        } else {
            // Check global
            let global_label: i64 = lookup_global(name);
            if (global_label != 0) {
                let buf: i64 = allocate(256);
                string_copy(buf, "mov rax, [");
                string_concat(buf, global_label);
                string_concat(buf, "]");
                emit(buf);
            } else {
                // Unknown variable
                emit("mov rax, 0");
            }
        }
        emit("push rax");
        return 1;
    }

    if (expr_type == EXPR_BINARY_OP) {
        let op: i64 = *(expr_node + 8);
        let left: i64 = *(expr_node + 16);
        let right: i64 = *(expr_node + 24);

        generate_expression(left);
        generate_expression(right);
        emit("pop rdi");  // right
        emit("pop rax");  // left

        if (op == OP_ADD) {
            emit("add rax, rdi");
        }
        if (op == OP_SUB) {
            emit("sub rax, rdi");
        }
        if (op == OP_MUL) {
            emit("imul rax, rdi");
        }
        if (op == OP_DIV) {
            emit("cqo");
            emit("idiv rdi");
        }
        if (op == OP_EQUAL) {
            emit("cmp rax, rdi");
            emit("sete al");
            emit("movzx rax, al");
        }
        if (op == OP_NOT_EQUAL) {
            emit("cmp rax, rdi");
            emit("setne al");
            emit("movzx rax, al");
        }
        if (op == OP_LESS) {
            emit("cmp rax, rdi");
            emit("setl al");
            emit("movzx rax, al");
        }
        if (op == OP_GREATER) {
            emit("cmp rax, rdi");
            emit("setg al");
            emit("movzx rax, al");
        }
        if (op == OP_LESS_EQUAL) {
            emit("cmp rax, rdi");
            emit("setle al");
            emit("movzx rax, al");
        }
        if (op == OP_GREATER_EQUAL) {
            emit("cmp rax, rdi");
            emit("setge al");
            emit("movzx rax, al");
        }
        if (op == OP_MOD) {
            emit("cqo");
            emit("idiv rdi");
            emit("mov rax, rdx");
        }

        emit("push rax");
        return 1;
    }

    if (expr_type == EXPR_UNARY_OP) {
        let op: i64 = *(expr_node + 8);
        let operand: i64 = *(expr_node + 16);

        generate_expression(operand);
        emit("pop rax");

        if (op == OP_MINUS) {
            emit("neg rax");
        }
        if (op == OP_NOT) {
            emit("cmp rax, 0");
            emit("sete al");
            emit("movzx rax, al");
        }

        emit("push rax");
        return 1;
    }

    if (expr_type == EXPR_CALL) {
        let name: i64 = *(expr_node + 8);
        let args_start: i64 = *(expr_node + 16);
        let args_count: i64 = *(expr_node + 24);

        // Generate arguments in reverse order
        let i: i64 = args_count - 1;
        while (i >= 0) {
            let arg: i64 = *(args_start + (i * 8));
            generate_expression(arg);
            i = i - 1;
        }

        // Check for built-in functions
        if (string_compare(name, "puts") == 1) {
            emit("pop rdi");
            emit("call puts");
        } else {
            if (string_compare(name, "malloc") == 1) {
                emit("pop rdi");
                emit("call malloc");
            } else {
                if (string_compare(name, "exit") == 1) {
                    emit("pop rdi");
                    emit("call exit");
                } else {
                    // User-defined function
                    let buf: i64 = allocate(256);
                    string_copy(buf, "call ");
                    string_concat(buf, name);
                    emit(buf);

                    // Clean up arguments
                    if (args_count > 0) {
                        buf = allocate(256);
                        string_copy(buf, "add rsp, ");
                        string_concat(buf, int_to_string(args_count * 8));
                        emit(buf);
                    }
                }
            }
        }

        emit("push rax");
        return 1;
    }

    if (expr_type == EXPR_ADDRESS_OF) {
        let inner: i64 = *(expr_node + 8);
        let inner_type: i64 = *(inner + 0);

        if (inner_type == EXPR_VARIABLE) {
            let name: i64 = *(inner + 8);
            let local_offset: i64 = lookup_local(name);

            if (local_offset != 999999) {
                // Local variable address
                let buf: i64 = allocate(256);
                string_copy(buf, "lea rax, [rbp");
                if (local_offset < 0) {
                    string_concat(buf, int_to_string(local_offset));
                } else {
                    string_concat(buf, "+");
                    string_concat(buf, int_to_string(local_offset));
                }
                string_concat(buf, "]");
                emit(buf);
            } else {
                // Global variable address
                let global_label: i64 = lookup_global(name);
                if (global_label != 0) {
                    let buf: i64 = allocate(256);
                    string_copy(buf, "mov rax, ");
                    string_concat(buf, global_label);
                    emit(buf);
                } else {
                    emit("mov rax, 0");
                }
            }
        } else {
            // Other expressions - simplified
            emit("mov rax, 0");
        }

        emit("push rax");
        return 1;
    }

    if (expr_type == EXPR_DEREFERENCE) {
        let ptr_expr: i64 = *(expr_node + 8);
        generate_expression(ptr_expr);
        emit("pop rax");
        emit("mov rax, [rax]");
        emit("push rax");
        return 1;
    }

    // Unknown expression type
    emit("mov rax, 0");
    emit("push rax");
    return 1;
}

// Generate code for statement
fn generate_statement(stmt_node: i64) -> i64 {
    let stmt_type: i64 = *(stmt_node + 0);

    if (stmt_type == STMT_FUNCTION_DEF) {
        let name: i64 = *(stmt_node + 8);
        let params_start: i64 = *(stmt_node + 16);
        let params_count: i64 = *(stmt_node + 24);
        let body_start: i64 = *(stmt_node + 32);
        let body_count: i64 = *(stmt_node + 40);

        emit_label(name);

        // Function prologue
        emit("push rbp");
        emit("mov rbp, rsp");

        // Clear locals for new function
        clear_locals();

        // Allocate space for parameters
        let i: i64 = 0;
        while (i < params_count) {
            let param: i64 = *(params_start + (i * 8));
            let param_name: i64 = *(param + 0);

            STACK_OFFSET = STACK_OFFSET - 8;
            add_local(param_name, STACK_OFFSET);

            emit("sub rsp, 8");

            let buf: i64 = allocate(256);
            string_copy(buf, "mov rax, [rbp+");
            string_concat(buf, int_to_string(16 + (i * 8)));
            string_concat(buf, "]");
            emit(buf);

            buf = allocate(256);
            string_copy(buf, "mov [rbp");
            string_concat(buf, int_to_string(STACK_OFFSET));
            string_concat(buf, "], rax");
            emit(buf);

            i = i + 1;
        }

        // Generate function body
        i = 0;
        while (i < body_count) {
            let stmt: i64 = *(body_start + (i * 8));
            generate_statement(stmt);
            i = i + 1;
        }

        // Default return (in case no explicit return)
        emit("mov rax, 0");
        emit("mov rsp, rbp");
        emit("pop rbp");
        emit("ret");
        emit_raw("\n");

        return 1;
    }

    if (stmt_type == STMT_VARIABLE_DECL) {
        let name: i64 = *(stmt_node + 8);
        let value: i64 = *(stmt_node + 24);

        STACK_OFFSET = STACK_OFFSET - 8;
        add_local(name, STACK_OFFSET);

        emit("sub rsp, 8");

        generate_expression(value);
        emit("pop rax");

        let buf: i64 = allocate(256);
        string_copy(buf, "mov [rbp");
        string_concat(buf, int_to_string(STACK_OFFSET));
        string_concat(buf, "], rax");
        emit(buf);

        return 1;
    }

    if (stmt_type == STMT_ASSIGNMENT) {
        let target: i64 = *(stmt_node + 8);
        let value: i64 = *(stmt_node + 16);

        // Generate value first
        generate_expression(value);

        // Store to target
        let target_type: i64 = *(target + 0);
        if (target_type == EXPR_VARIABLE) {
            let name: i64 = *(target + 8);
            let local_offset: i64 = lookup_local(name);

            emit("pop rax");

            if (local_offset != 999999) {
                // Local variable
                let buf: i64 = allocate(256);
                string_copy(buf, "mov [rbp");
                string_concat(buf, int_to_string(local_offset));
                string_concat(buf, "], rax");
                emit(buf);
            } else {
                // Global variable
                let global_label: i64 = lookup_global(name);
                if (global_label != 0) {
                    let buf: i64 = allocate(256);
                    string_copy(buf, "mov [");
                    string_concat(buf, global_label);
                    string_concat(buf, "], rax");
                    emit(buf);
                }
            }
        } else {
            if (target_type == EXPR_DEREFERENCE) {
                let ptr_expr: i64 = *(target + 8);
                generate_expression(ptr_expr);
                emit("pop rdi");  // address
                emit("pop rax");  // value
                emit("mov [rdi], rax");
            } else {
                // Invalid target - just pop the value
                emit("pop rax");
            }
        }

        return 1;
    }

    if (stmt_type == STMT_IF) {
        let condition: i64 = *(stmt_node + 8);
        let then_start: i64 = *(stmt_node + 16);
        let then_count: i64 = *(stmt_node + 24);
        let else_start: i64 = *(stmt_node + 32);
        let else_count: i64 = *(stmt_node + 40);

        let else_label: i64 = new_label();
        let end_label: i64 = new_label();

        generate_expression(condition);
        emit("pop rax");
        emit("cmp rax, 0");

        let buf: i64 = allocate(256);
        string_copy(buf, "je ");
        string_concat(buf, else_label);
        emit(buf);

        // Then branch
        let i: i64 = 0;
        while (i < then_count) {
            let stmt: i64 = *(then_start + (i * 8));
            generate_statement(stmt);
            i = i + 1;
        }

        buf = allocate(256);
        string_copy(buf, "jmp ");
        string_concat(buf, end_label);
        emit(buf);

        // Else branch
        emit_label(else_label);
        if (else_count > 0) {
            i = 0;
            while (i < else_count) {
                let stmt: i64 = *(else_start + (i * 8));
                generate_statement(stmt);
                i = i + 1;
            }
        }

        emit_label(end_label);
        return 1;
    }

    if (stmt_type == STMT_WHILE) {
        let condition: i64 = *(stmt_node + 8);
        let body_start: i64 = *(stmt_node + 16);
        let body_count: i64 = *(stmt_node + 24);

        let start_label: i64 = new_label();
        let end_label: i64 = new_label();

        emit_label(start_label);

        generate_expression(condition);
        emit("pop rax");
        emit("cmp rax, 0");

        let buf: i64 = allocate(256);
        string_copy(buf, "je ");
        string_concat(buf, end_label);
        emit(buf);

        // Loop body
        let i: i64 = 0;
        while (i < body_count) {
            let stmt: i64 = *(body_start + (i * 8));
            generate_statement(stmt);
            i = i + 1;
        }

        buf = allocate(256);
        string_copy(buf, "jmp ");
        string_concat(buf, start_label);
        emit(buf);

        emit_label(end_label);
        return 1;
    }

    if (stmt_type == STMT_RETURN) {
        let expr: i64 = *(stmt_node + 8);
        generate_expression(expr);
        emit("pop rax");
        emit("mov rsp, rbp");
        emit("pop rbp");
        emit("ret");
        return 1;
    }

    if (stmt_type == STMT_EXPRESSION) {
        let expr: i64 = *(stmt_node + 8);
        generate_expression(expr);
        emit("pop rax");  // Discard result
        return 1;
    }

    if (stmt_type == STMT_GLOBAL_DECL) {
        let name: i64 = *(stmt_node + 8);
        let value: i64 = *(stmt_node + 16);

        // Global initialization
        generate_expression(value);
        emit("pop rax");

        let global_label: i64 = lookup_global(name);
        if (global_label != 0) {
            let buf: i64 = allocate(256);
            string_copy(buf, "mov [");
            string_concat(buf, global_label);
            string_concat(buf, "], rax");
            emit(buf);
        }

        return 1;
    }

    return 1;
}

// Main code generation function
fn generate(program: i64) -> i64 {
    // Initialize
    init_codegen();

    // First pass: collect globals and strings
    collect_globals(program);

    // Emit prologue
    emit_prologue();

    // Generate global initializations in _start
    let current: i64 = AST_NODES;
    let end: i64 = AST_NODES + (AST_COUNT * NODE_SIZE);

    while (current < end) {
        let node_type: i64 = *(current + 0);
        if (node_type == STMT_GLOBAL_DECL) {
            generate_statement(current);
        }
        current = current + NODE_SIZE;
    }

    // Add main call after global initialization
    emit_raw("    call main\n");
    emit_raw("    mov rdi, rax\n");
    emit_raw("    call exit\n\n");

    // Generate all function definitions
    current = AST_NODES;
    while (current < end) {
        let node_type: i64 = *(current + 0);
        if (node_type == STMT_FUNCTION_DEF) {
            generate_statement(current);
        }
        current = current + NODE_SIZE;
    }

    // Null-terminate output
    *(OUTPUT_BUFFER + OUTPUT_POS) = 0;

    return OUTPUT_BUFFER;
}