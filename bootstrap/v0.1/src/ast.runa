// AST implementation transpiled from Rust to Runa-Zero
// Uses fixed-size arrays and manual memory management

// Memory management
global MEMORY_POOL = 0;
global MEMORY_OFFSET = 0;
global MEMORY_SIZE = 131072;

fn allocate(size: i64) -> i64 {
    if (MEMORY_OFFSET + size > MEMORY_SIZE) {
        return 0;
    }
    let ptr: i64 = MEMORY_POOL + MEMORY_OFFSET;
    MEMORY_OFFSET = MEMORY_OFFSET + size;
    return ptr;
}

fn init_memory() -> i64 {
    MEMORY_POOL = malloc(MEMORY_SIZE * 8);
    if (MEMORY_POOL == 0) {
        return 0;
    }
    MEMORY_OFFSET = 0;
    return 1;
}

// Token type constants
global TOKEN_NUMBER = 1;
global TOKEN_IDENTIFIER = 2;
global TOKEN_FN = 3;
global TOKEN_LET = 4;
global TOKEN_IF = 5;
global TOKEN_ELSE = 6;
global TOKEN_WHILE = 7;
global TOKEN_RETURN = 8;
global TOKEN_GLOBAL = 9;
global TOKEN_PLUS = 10;
global TOKEN_MINUS = 11;
global TOKEN_DIVIDE = 12;
global TOKEN_ASSIGN = 13;
global TOKEN_EQUAL = 14;
global TOKEN_NOT_EQUAL = 15;
global TOKEN_LESS = 16;
global TOKEN_GREATER = 17;
global TOKEN_LESS_EQUAL = 18;
global TOKEN_GREATER_EQUAL = 19;
global TOKEN_LEFT_PAREN = 20;
global TOKEN_RIGHT_PAREN = 21;
global TOKEN_LEFT_BRACE = 22;
global TOKEN_RIGHT_BRACE = 23;
global TOKEN_SEMICOLON = 24;
global TOKEN_COLON = 25;
global TOKEN_ARROW = 26;
global TOKEN_AMPERSAND = 27;
global TOKEN_STAR = 28;
global TOKEN_COMMA = 29;
global TOKEN_STRING_LITERAL = 30;
global TOKEN_CHAR_LITERAL = 31;
global TOKEN_NEWLINE = 32;
global TOKEN_EOF = 33;

// Token storage arrays
global TOKEN_TYPES = 0;
global TOKEN_VALUES = 0;
global TOKEN_STRINGS = 0;
global TOKEN_COUNT = 0;
global MAX_TOKENS = 1000;

// Statement type constants
global STMT_FUNCTION_DEF = 100;
global STMT_GLOBAL_DECL = 101;
global STMT_VARIABLE_DECL = 102;
global STMT_ASSIGNMENT = 103;
global STMT_IF = 104;
global STMT_WHILE = 105;
global STMT_RETURN = 106;
global STMT_EXPRESSION = 107;

// Expression type constants
global EXPR_LITERAL = 200;
global EXPR_STRING_LITERAL = 201;
global EXPR_CHAR_LITERAL = 202;
global EXPR_VARIABLE = 203;
global EXPR_BINARY_OP = 204;
global EXPR_UNARY_OP = 205;
global EXPR_CALL = 206;
global EXPR_ADDRESS_OF = 207;
global EXPR_DEREFERENCE = 208;

// Binary operator constants
global OP_ADD = 1;
global OP_SUB = 2;
global OP_MUL = 3;
global OP_DIV = 4;
global OP_EQUAL = 5;
global OP_NOT_EQUAL = 6;
global OP_LESS = 7;
global OP_GREATER = 8;
global OP_LESS_EQUAL = 9;
global OP_GREATER_EQUAL = 10;

// Unary operator constants
global UNARY_MINUS = 1;

// AST node storage
global AST_NODES = 0;
global AST_COUNT = 0;
global MAX_AST_NODES = 2000;
global AST_NODE_SIZE = 8;

// String storage for identifiers and literals
global STRING_STORAGE = 0;
global STRING_OFFSET = 0;
global MAX_STRING_STORAGE = 50000;

fn init_ast() -> i64 {
    TOKEN_TYPES = allocate(MAX_TOKENS);
    TOKEN_VALUES = allocate(MAX_TOKENS);
    TOKEN_STRINGS = allocate(MAX_TOKENS);
    AST_NODES = allocate(MAX_AST_NODES * AST_NODE_SIZE);
    STRING_STORAGE = allocate(MAX_STRING_STORAGE);

    if (TOKEN_TYPES == 0) {
        return 0;
    }
    if (TOKEN_VALUES == 0) {
        return 0;
    }
    if (TOKEN_STRINGS == 0) {
        return 0;
    }
    if (AST_NODES == 0) {
        return 0;
    }
    if (STRING_STORAGE == 0) {
        return 0;
    }

    TOKEN_COUNT = 0;
    AST_COUNT = 0;
    STRING_OFFSET = 0;

    return 1;
}

// String operations
fn string_length(str: i64) -> i64 {
    let len: i64 = 0;
    while (*(str + len) != 0) {
        len = len + 1;
    }
    return len;
}

fn string_copy(dest: i64, src: i64) -> i64 {
    let i: i64 = 0;
    while (*(src + i) != 0) {
        *(dest + i) = *(src + i);
        i = i + 1;
    }
    *(dest + i) = 0;
    return i;
}

fn string_compare(str1: i64, str2: i64) -> i64 {
    let i: i64 = 0;
    while (*(str1 + i) != 0) {
        if (*(str2 + i) == 0) {
            return 0;
        }
        if (*(str1 + i) != *(str2 + i)) {
            return 0;
        }
        i = i + 1;
    }
    if (*(str1 + i) == 0) {
        if (*(str2 + i) == 0) {
            return 1;
        }
    }
    return 0;
}

fn store_string(str: i64) -> i64 {
    let len: i64 = string_length(str);
    if (STRING_OFFSET + len + 1 > MAX_STRING_STORAGE) {
        return 0;
    }

    let offset: i64 = STRING_OFFSET;
    string_copy(STRING_STORAGE + offset, str);
    STRING_OFFSET = STRING_OFFSET + len + 1;
    return offset;
}

fn get_string(offset: i64) -> i64 {
    return STRING_STORAGE + offset;
}

// Token operations
fn add_token(token_type: i64, value: i64, string_data: i64) -> i64 {
    if (TOKEN_COUNT >= MAX_TOKENS) {
        return 0;
    }

    *(TOKEN_TYPES + TOKEN_COUNT) = token_type;
    *(TOKEN_VALUES + TOKEN_COUNT) = value;
    *(TOKEN_STRINGS + TOKEN_COUNT) = string_data;
    TOKEN_COUNT = TOKEN_COUNT + 1;
    return 1;
}

fn get_token_type(index: i64) -> i64 {
    if (index >= TOKEN_COUNT) {
        return TOKEN_EOF;
    }
    return *(TOKEN_TYPES + index);
}

fn get_token_value(index: i64) -> i64 {
    if (index >= TOKEN_COUNT) {
        return 0;
    }
    return *(TOKEN_VALUES + index);
}

fn get_token_string(index: i64) -> i64 {
    if (index >= TOKEN_COUNT) {
        return 0;
    }
    return *(TOKEN_STRINGS + index);
}

// AST node operations
fn create_node(node_type: i64) -> i64 {
    if (AST_COUNT >= MAX_AST_NODES) {
        return 0;
    }

    let node_index: i64 = AST_COUNT;
    let node_ptr: i64 = AST_NODES + (node_index * AST_NODE_SIZE);

    // Initialize node
    let i: i64 = 0;
    while (i < AST_NODE_SIZE) {
        *(node_ptr + i) = 0;
        i = i + 1;
    }

    *(node_ptr + 0) = node_type;
    AST_COUNT = AST_COUNT + 1;
    return node_index;
}

fn get_node_type(node_index: i64) -> i64 {
    if (node_index >= AST_COUNT) {
        return 0;
    }
    let node_ptr: i64 = AST_NODES + (node_index * AST_NODE_SIZE);
    return *(node_ptr + 0);
}

fn set_node_data(node_index: i64, field: i64, value: i64) -> i64 {
    if (node_index >= AST_COUNT) {
        return 0;
    }
    if (field >= AST_NODE_SIZE) {
        return 0;
    }
    let node_ptr: i64 = AST_NODES + (node_index * AST_NODE_SIZE);
    *(node_ptr + field) = value;
    return 1;
}

fn get_node_data(node_index: i64, field: i64) -> i64 {
    if (node_index >= AST_COUNT) {
        return 0;
    }
    if (field >= AST_NODE_SIZE) {
        return 0;
    }
    let node_ptr: i64 = AST_NODES + (node_index * AST_NODE_SIZE);
    return *(node_ptr + field);
}

// Expression constructors
fn create_literal_expr(value: i64) -> i64 {
    let node: i64 = create_node(EXPR_LITERAL);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, value);
    return node;
}

fn create_variable_expr(name_offset: i64) -> i64 {
    let node: i64 = create_node(EXPR_VARIABLE);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, name_offset);
    return node;
}

fn create_binary_expr(op: i64, left: i64, right: i64) -> i64 {
    let node: i64 = create_node(EXPR_BINARY_OP);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, op);
    set_node_data(node, 2, left);
    set_node_data(node, 3, right);
    return node;
}

fn create_unary_expr(op: i64, operand: i64) -> i64 {
    let node: i64 = create_node(EXPR_UNARY_OP);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, op);
    set_node_data(node, 2, operand);
    return node;
}

fn create_call_expr(name_offset: i64, arg_count: i64) -> i64 {
    let node: i64 = create_node(EXPR_CALL);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, name_offset);
    set_node_data(node, 2, arg_count);
    return node;
}

// Statement constructors
fn create_function_stmt(name_offset: i64, param_count: i64, return_type_offset: i64, body_count: i64) -> i64 {
    let node: i64 = create_node(STMT_FUNCTION_DEF);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, name_offset);
    set_node_data(node, 2, param_count);
    set_node_data(node, 3, return_type_offset);
    set_node_data(node, 4, body_count);
    return node;
}

fn create_global_stmt(name_offset: i64, value_expr: i64) -> i64 {
    let node: i64 = create_node(STMT_GLOBAL_DECL);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, name_offset);
    set_node_data(node, 2, value_expr);
    return node;
}

fn create_variable_stmt(name_offset: i64, type_offset: i64, value_expr: i64) -> i64 {
    let node: i64 = create_node(STMT_VARIABLE_DECL);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, name_offset);
    set_node_data(node, 2, type_offset);
    set_node_data(node, 3, value_expr);
    return node;
}

fn create_return_stmt(expr: i64) -> i64 {
    let node: i64 = create_node(STMT_RETURN);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, expr);
    return node;
}

fn create_if_stmt(condition: i64, then_count: i64, else_count: i64) -> i64 {
    let node: i64 = create_node(STMT_IF);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, condition);
    set_node_data(node, 2, then_count);
    set_node_data(node, 3, else_count);
    return node;
}

fn create_while_stmt(condition: i64, body_count: i64) -> i64 {
    let node: i64 = create_node(STMT_WHILE);
    if (node == 0) {
        return 0;
    }
    set_node_data(node, 1, condition);
    set_node_data(node, 2, body_count);
    return node;
}