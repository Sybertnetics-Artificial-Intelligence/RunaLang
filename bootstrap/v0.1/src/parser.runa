// Parser implementation transpiled from Rust to Runa-Zero
// Complete parser with all statement and expression parsing

// Parser state
global CURRENT_TOKEN_INDEX = 0;

fn parser_new() -> i64 {
    CURRENT_TOKEN_INDEX = 0;
    return 1;
}

fn current_token_type() -> i64 {
    if (CURRENT_TOKEN_INDEX >= TOKEN_COUNT) {
        return TOKEN_EOF;
    }
    return *(TOKEN_TYPES + CURRENT_TOKEN_INDEX);
}

fn current_token_value() -> i64 {
    if (CURRENT_TOKEN_INDEX >= TOKEN_COUNT) {
        return 0;
    }
    return *(TOKEN_VALUES + CURRENT_TOKEN_INDEX);
}

fn current_token_string() -> i64 {
    if (CURRENT_TOKEN_INDEX >= TOKEN_COUNT) {
        return 0;
    }
    return *(TOKEN_STRINGS + CURRENT_TOKEN_INDEX);
}

fn advance_token() -> i64 {
    if (CURRENT_TOKEN_INDEX < TOKEN_COUNT) {
        CURRENT_TOKEN_INDEX = CURRENT_TOKEN_INDEX + 1;
    }
    return 1;
}

fn previous_token_type() -> i64 {
    if (CURRENT_TOKEN_INDEX == 0) {
        return TOKEN_EOF;
    }
    return *(TOKEN_TYPES + CURRENT_TOKEN_INDEX - 1);
}

fn previous_token_value() -> i64 {
    if (CURRENT_TOKEN_INDEX == 0) {
        return 0;
    }
    return *(TOKEN_VALUES + CURRENT_TOKEN_INDEX - 1);
}

fn previous_token_string() -> i64 {
    if (CURRENT_TOKEN_INDEX == 0) {
        return 0;
    }
    return *(TOKEN_STRINGS + CURRENT_TOKEN_INDEX - 1);
}

fn is_at_end() -> i64 {
    return (current_token_type() == TOKEN_EOF);
}

fn skip_newlines() -> i64 {
    while (current_token_type() == TOKEN_NEWLINE) {
        advance_token();
    }
    return 1;
}

fn expect_token(expected_type: i64) -> i64 {
    if (current_token_type() == expected_type) {
        advance_token();
        return 1;
    }
    return 0;
}

// Parse program (list of global statements)
fn parse_program() -> i64 {
    let program_node: i64 = create_node(STMT_EXPRESSION);  // Root node

    while (is_at_end() == 0) {
        skip_newlines();
        if (is_at_end()) {
            return program_node;
        }

        let stmt: i64 = 0;
        if (current_token_type() == TOKEN_FN) {
            stmt = parse_function();
        } else {
            if (current_token_type() == TOKEN_GLOBAL) {
                stmt = parse_global_declaration();
            } else {
                return 0;
            }
        }

        if (stmt == 0) {
            return 0;
        }

        skip_newlines();
    }

    return program_node;
}

// Parse function definition
fn parse_function() -> i64 {
    if (expect_token(TOKEN_FN) == 0) {
        return 0;
    }

    if (current_token_type() != TOKEN_IDENTIFIER) {
        return 0;
    }
    let name_offset: i64 = current_token_string();
    advance_token();

    if (expect_token(TOKEN_LEFT_PAREN) == 0) {
        return 0;
    }

    let param_count: i64 = 0;
    let params_start: i64 = AST_COUNT;

    if (current_token_type() != TOKEN_RIGHT_PAREN) {
        let done: i64 = 0;
        while (done == 0) {
            if (current_token_type() != TOKEN_IDENTIFIER) {
                return 0;
            }
            let param_name: i64 = current_token_string();
            advance_token();

            if (expect_token(TOKEN_COLON) == 0) {
                return 0;
            }

            if (current_token_type() != TOKEN_IDENTIFIER) {
                return 0;
            }
            let param_type: i64 = current_token_string();
            advance_token();

            // Store parameter as a node
            let param_node: i64 = create_node(EXPR_VARIABLE);
            set_node_data(param_node, 1, param_name);
            set_node_data(param_node, 2, param_type);
            param_count = param_count + 1;

            if (current_token_type() == TOKEN_COMMA) {
                advance_token();
            } else {
                done = 1;
            }
        }
    }

    if (expect_token(TOKEN_RIGHT_PAREN) == 0) {
        return 0;
    }

    if (expect_token(TOKEN_ARROW) == 0) {
        return 0;
    }

    if (current_token_type() != TOKEN_IDENTIFIER) {
        return 0;
    }
    let return_type: i64 = current_token_string();
    advance_token();

    if (expect_token(TOKEN_LEFT_BRACE) == 0) {
        return 0;
    }
    skip_newlines();

    let body_start: i64 = AST_COUNT;
    let body_count: i64 = 0;

    while (current_token_type() != TOKEN_RIGHT_BRACE) {
        if (is_at_end()) {
            return 0;
        }

        let stmt: i64 = parse_statement();
        if (stmt == 0) {
            return 0;
        }
        body_count = body_count + 1;
        skip_newlines();
    }

    if (expect_token(TOKEN_RIGHT_BRACE) == 0) {
        return 0;
    }

    return create_function_stmt(name_offset, param_count, return_type, body_count);
}

// Parse global declaration
fn parse_global_declaration() -> i64 {
    if (expect_token(TOKEN_GLOBAL) == 0) {
        return 0;
    }

    if (current_token_type() != TOKEN_IDENTIFIER) {
        return 0;
    }
    let name_offset: i64 = current_token_string();
    advance_token();

    if (expect_token(TOKEN_ASSIGN) == 0) {
        return 0;
    }

    let value: i64 = parse_expression();
    if (value == 0) {
        return 0;
    }

    if (expect_token(TOKEN_SEMICOLON) == 0) {
        return 0;
    }

    return create_global_stmt(name_offset, value);
}

// Parse statement
fn parse_statement() -> i64 {
    if (current_token_type() == TOKEN_LET) {
        return parse_variable_declaration();
    }
    if (current_token_type() == TOKEN_IF) {
        return parse_if_statement();
    }
    if (current_token_type() == TOKEN_WHILE) {
        return parse_while_statement();
    }
    if (current_token_type() == TOKEN_RETURN) {
        return parse_return_statement();
    }

    // Try assignment or expression statement
    let expr: i64 = parse_expression();
    if (expr == 0) {
        return 0;
    }

    if (current_token_type() == TOKEN_ASSIGN) {
        advance_token();
        let value: i64 = parse_expression();
        if (value == 0) {
            return 0;
        }
        if (expect_token(TOKEN_SEMICOLON) == 0) {
            return 0;
        }

        let assign_node: i64 = create_node(STMT_ASSIGNMENT);
        set_node_data(assign_node, 1, expr);
        set_node_data(assign_node, 2, value);
        return assign_node;
    } else {
        if (expect_token(TOKEN_SEMICOLON) == 0) {
            return 0;
        }

        let expr_stmt: i64 = create_node(STMT_EXPRESSION);
        set_node_data(expr_stmt, 1, expr);
        return expr_stmt;
    }
}

// Parse variable declaration
fn parse_variable_declaration() -> i64 {
    if (expect_token(TOKEN_LET) == 0) {
        return 0;
    }

    if (current_token_type() != TOKEN_IDENTIFIER) {
        return 0;
    }
    let name_offset: i64 = current_token_string();
    advance_token();

    if (expect_token(TOKEN_COLON) == 0) {
        return 0;
    }

    if (current_token_type() != TOKEN_IDENTIFIER) {
        return 0;
    }
    let type_offset: i64 = current_token_string();
    advance_token();

    if (expect_token(TOKEN_ASSIGN) == 0) {
        return 0;
    }

    let value: i64 = parse_expression();
    if (value == 0) {
        return 0;
    }

    if (expect_token(TOKEN_SEMICOLON) == 0) {
        return 0;
    }

    return create_variable_stmt(name_offset, type_offset, value);
}

// Parse if statement
fn parse_if_statement() -> i64 {
    if (expect_token(TOKEN_IF) == 0) {
        return 0;
    }

    if (expect_token(TOKEN_LEFT_PAREN) == 0) {
        return 0;
    }

    let condition: i64 = parse_expression();
    if (condition == 0) {
        return 0;
    }

    if (expect_token(TOKEN_RIGHT_PAREN) == 0) {
        return 0;
    }

    if (expect_token(TOKEN_LEFT_BRACE) == 0) {
        return 0;
    }
    skip_newlines();

    let then_start: i64 = AST_COUNT;
    let then_count: i64 = 0;

    while (current_token_type() != TOKEN_RIGHT_BRACE) {
        if (is_at_end()) {
            return 0;
        }

        let stmt: i64 = parse_statement();
        if (stmt == 0) {
            return 0;
        }
        then_count = then_count + 1;
        skip_newlines();
    }

    if (expect_token(TOKEN_RIGHT_BRACE) == 0) {
        return 0;
    }

    let else_count: i64 = 0;
    if (current_token_type() == TOKEN_ELSE) {
        advance_token();

        if (expect_token(TOKEN_LEFT_BRACE) == 0) {
            return 0;
        }
        skip_newlines();

        while (current_token_type() != TOKEN_RIGHT_BRACE) {
            if (is_at_end()) {
                return 0;
            }

            let stmt: i64 = parse_statement();
            if (stmt == 0) {
                return 0;
            }
            else_count = else_count + 1;
            skip_newlines();
        }

        if (expect_token(TOKEN_RIGHT_BRACE) == 0) {
            return 0;
        }
    }

    return create_if_stmt(condition, then_count, else_count);
}

// Parse while statement
fn parse_while_statement() -> i64 {
    if (expect_token(TOKEN_WHILE) == 0) {
        return 0;
    }

    if (expect_token(TOKEN_LEFT_PAREN) == 0) {
        return 0;
    }

    let condition: i64 = parse_expression();
    if (condition == 0) {
        return 0;
    }

    if (expect_token(TOKEN_RIGHT_PAREN) == 0) {
        return 0;
    }

    if (expect_token(TOKEN_LEFT_BRACE) == 0) {
        return 0;
    }
    skip_newlines();

    let body_start: i64 = AST_COUNT;
    let body_count: i64 = 0;

    while (current_token_type() != TOKEN_RIGHT_BRACE) {
        if (is_at_end()) {
            return 0;
        }

        let stmt: i64 = parse_statement();
        if (stmt == 0) {
            return 0;
        }
        body_count = body_count + 1;
        skip_newlines();
    }

    if (expect_token(TOKEN_RIGHT_BRACE) == 0) {
        return 0;
    }

    return create_while_stmt(condition, body_count);
}

// Parse return statement
fn parse_return_statement() -> i64 {
    if (expect_token(TOKEN_RETURN) == 0) {
        return 0;
    }

    let expr: i64 = parse_expression();
    if (expr == 0) {
        return 0;
    }

    if (expect_token(TOKEN_SEMICOLON) == 0) {
        return 0;
    }

    return create_return_stmt(expr);
}

// Parse expression (equality level)
fn parse_expression() -> i64 {
    return parse_equality();
}

// Parse equality expressions
fn parse_equality() -> i64 {
    let expr: i64 = parse_comparison();
    if (expr == 0) {
        return 0;
    }

    let done: i64 = 0;
    while (done == 0) {
        let op: i64 = 0;
        if (current_token_type() == TOKEN_EQUAL) {
            op = OP_EQUAL;
            advance_token();
        } else {
            if (current_token_type() == TOKEN_NOT_EQUAL) {
                op = OP_NOT_EQUAL;
                advance_token();
            } else {
                done = 1;
            }
        }

        if (done == 0) {
            let right: i64 = parse_comparison();
            if (right == 0) {
                return 0;
            }

            expr = create_binary_expr(op, expr, right);
            if (expr == 0) {
                return 0;
            }
        }
    }

    return expr;
}

// Parse comparison expressions
fn parse_comparison() -> i64 {
    let expr: i64 = parse_term();
    if (expr == 0) {
        return 0;
    }

    let done: i64 = 0;
    while (done == 0) {
        let op: i64 = 0;
        if (current_token_type() == TOKEN_LESS) {
            op = OP_LESS;
            advance_token();
        } else {
            if (current_token_type() == TOKEN_GREATER) {
                op = OP_GREATER;
                advance_token();
            } else {
                if (current_token_type() == TOKEN_LESS_EQUAL) {
                    op = OP_LESS_EQUAL;
                    advance_token();
                } else {
                    if (current_token_type() == TOKEN_GREATER_EQUAL) {
                        op = OP_GREATER_EQUAL;
                        advance_token();
                    } else {
                        done = 1;
                    }
                }
            }
        }

        if (done == 0) {
            let right: i64 = parse_term();
            if (right == 0) {
                return 0;
            }

            expr = create_binary_expr(op, expr, right);
            if (expr == 0) {
                return 0;
            }
        }
    }

    return expr;
}

// Parse term (addition/subtraction)
fn parse_term() -> i64 {
    let expr: i64 = parse_factor();
    if (expr == 0) {
        return 0;
    }

    let done: i64 = 0;
    while (done == 0) {
        let op: i64 = 0;
        if (current_token_type() == TOKEN_PLUS) {
            op = OP_ADD;
            advance_token();
        } else {
            if (current_token_type() == TOKEN_MINUS) {
                op = OP_SUB;
                advance_token();
            } else {
                done = 1;
            }
        }

        if (done == 0) {
            let right: i64 = parse_factor();
            if (right == 0) {
                return 0;
            }

            expr = create_binary_expr(op, expr, right);
            if (expr == 0) {
                return 0;
            }
        }
    }

    return expr;
}

// Parse factor (multiplication/division)
fn parse_factor() -> i64 {
    let expr: i64 = parse_unary();
    if (expr == 0) {
        return 0;
    }

    let done: i64 = 0;
    while (done == 0) {
        let op: i64 = 0;
        if (current_token_type() == TOKEN_STAR) {
            op = OP_MUL;
            advance_token();
        } else {
            if (current_token_type() == TOKEN_DIVIDE) {
                op = OP_DIV;
                advance_token();
            } else {
                done = 1;
            }
        }

        if (done == 0) {
            let right: i64 = parse_unary();
            if (right == 0) {
                return 0;
            }

            expr = create_binary_expr(op, expr, right);
            if (expr == 0) {
                return 0;
            }
        }
    }

    return expr;
}

// Parse unary expressions
fn parse_unary() -> i64 {
    if (current_token_type() == TOKEN_MINUS) {
        advance_token();
        let operand: i64 = parse_unary();
        if (operand == 0) {
            return 0;
        }
        return create_unary_expr(UNARY_MINUS, operand);
    }

    if (current_token_type() == TOKEN_AMPERSAND) {
        advance_token();
        let operand: i64 = parse_unary();
        if (operand == 0) {
            return 0;
        }
        let node: i64 = create_node(EXPR_ADDRESS_OF);
        set_node_data(node, 1, operand);
        return node;
    }

    if (current_token_type() == TOKEN_STAR) {
        advance_token();
        let operand: i64 = parse_unary();
        if (operand == 0) {
            return 0;
        }
        let node: i64 = create_node(EXPR_DEREFERENCE);
        set_node_data(node, 1, operand);
        return node;
    }

    return parse_primary();
}

// Parse primary expressions
fn parse_primary() -> i64 {
    // Number literal
    if (current_token_type() == TOKEN_NUMBER) {
        let value: i64 = current_token_value();
        advance_token();
        return create_literal_expr(value);
    }

    // String literal
    if (current_token_type() == TOKEN_STRING_LITERAL) {
        let string_offset: i64 = current_token_string();
        advance_token();
        let node: i64 = create_node(EXPR_STRING_LITERAL);
        set_node_data(node, 1, string_offset);
        return node;
    }

    // Character literal
    if (current_token_type() == TOKEN_CHAR_LITERAL) {
        let char_value: i64 = current_token_value();
        advance_token();
        let node: i64 = create_node(EXPR_CHAR_LITERAL);
        set_node_data(node, 1, char_value);
        return node;
    }

    // Identifier (variable or function call)
    if (current_token_type() == TOKEN_IDENTIFIER) {
        let name_offset: i64 = current_token_string();
        advance_token();

        // Check for function call
        if (current_token_type() == TOKEN_LEFT_PAREN) {
            advance_token();

            let arg_count: i64 = 0;
            let args_start: i64 = AST_COUNT;

            if (current_token_type() != TOKEN_RIGHT_PAREN) {
                let done: i64 = 0;
                while (done == 0) {
                    let arg: i64 = parse_expression();
                    if (arg == 0) {
                        return 0;
                    }
                    arg_count = arg_count + 1;

                    if (current_token_type() == TOKEN_COMMA) {
                        advance_token();
                    } else {
                        done = 1;
                    }
                }
            }

            if (expect_token(TOKEN_RIGHT_PAREN) == 0) {
                return 0;
            }

            return create_call_expr(name_offset, arg_count);
        } else {
            // Variable reference
            return create_variable_expr(name_offset);
        }
    }

    // Parenthesized expression
    if (current_token_type() == TOKEN_LEFT_PAREN) {
        advance_token();
        let expr: i64 = parse_expression();
        if (expr == 0) {
            return 0;
        }
        if (expect_token(TOKEN_RIGHT_PAREN) == 0) {
            return 0;
        }
        return expr;
    }

    return 0;
}

// Main parse function
fn parse() -> i64 {
    parser_new();
    return parse_program();
}