Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Parser for Runa v0.0.7.5
Note: Line-by-line transliteration from v0.0.7.3 parser.c

Note: Offsets for program structure (MUST match codegen.runa expectations!)
Note: This layout matches v0.0.7.3 C struct Program
Let PROGRAM_FUNCTIONS be 0      Note: Function **functions
Let PROGRAM_FUNCTION_COUNT be 8 Note: int function_count
Let PROGRAM_FUNCTION_CAPACITY be 12 Note: int function_capacity
Let PROGRAM_TYPES be 16         Note: TypeDefinition **types
Let PROGRAM_TYPE_COUNT be 24    Note: int type_count
Let PROGRAM_TYPE_CAPACITY be 28 Note: int type_capacity
Let PROGRAM_IMPORTS be 32       Note: Import **imports
Let PROGRAM_IMPORT_COUNT be 40  Note: int import_count
Let PROGRAM_IMPORT_CAPACITY be 44 Note: int import_capacity
Let PROGRAM_GLOBAL_VARS be 48   Note: GlobalVariable **globals
Let PROGRAM_GLOBAL_COUNT be 56  Note: int global_count
Let PROGRAM_GLOBAL_CAPACITY be 60 Note: int global_capacity

Note: Helper function to check if a token can be used as an identifier
Note: Some keywords are context-sensitive and can be variable names
Process called "token_can_be_identifier" takes token_type as Integer returns Integer:
    Note: Always accept TOKEN_IDENTIFIER
    If token_type is equal to 53:
        Return 1
    Otherwise If token_type is equal to 148:  Note: TOKEN_AT
        Return 1
    Otherwise If token_type is equal to 149:  Note: TOKEN_INDEX
        Return 1
    Otherwise If token_type is equal to 150:  Note: TOKEN_KEY
        Return 1
    Otherwise If token_type is equal to 151:  Note: TOKEN_LENGTH
        Return 1
    Otherwise If token_type is equal to 152:  Note: TOKEN_IN
        Return 1
    Otherwise If token_type is equal to 153:  Note: TOKEN_WHERE
        Return 1
    Otherwise If token_type is equal to 154:  Note: TOKEN_AN
        Return 1
    Otherwise If token_type is equal to 156:  Note: TOKEN_CONTAINING
        Return 1
    Otherwise If token_type is equal to 144:  Note: TOKEN_FROM
        Return 1
    Otherwise If token_type is equal to 145:  Note: TOKEN_EACH
        Return 1
    Otherwise If token_type is equal to 159:  Note: TOKEN_LIST
        Return 1
    Otherwise If token_type is equal to 160:  Note: TOKEN_DICTIONARY
        Return 1

    Note: Common variable names that are context-sensitive
    Otherwise If token_type is equal to 132:  Note: TOKEN_COUNT
        Return 1
    Otherwise If token_type is equal to 124:  Note: TOKEN_POINTER
        Return 1
    Otherwise If token_type is equal to 129:  Note: TOKEN_ERROR
        Return 1
    Otherwise If token_type is equal to 126:  Note: TOKEN_ARRAY
        Return 1
    End If

    Return 0
End Process

Note: Parser parse expression - entry point for expression parsing with PEMDAS precedence
Process called "parser_parse_expression" takes parser as Integer returns Integer:
    Return parser_parse_logical_or(parser)
End Process

Note: Parse logical OR expressions
Process called "parser_parse_logical_or" takes parser as Integer returns Integer:
    Let left be parser_parse_logical_and(parser)

    Let loop_or be 1
    While loop_or is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 31:  Note: TOKEN_OR
            parser_eat(parser, 31)
            Let right be parser_parse_logical_and(parser)
            Set left to expression_create_binary_op(left, 31, right)
        Otherwise:
            Set loop_or to 0
        End If
    End While

    Return left
End Process

Note: Parse logical AND expressions
Process called "parser_parse_logical_and" takes parser as Integer returns Integer:
    Let left be parser_parse_comparison_level(parser)

    Let loop_and be 1
    While loop_and is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 30:  Note: TOKEN_AND
            parser_eat(parser, 30)
            Let right be parser_parse_comparison_level(parser)
            Set left to expression_create_binary_op(left, 30, right)
        Otherwise:
            Set loop_and to 0
        End If
    End While

    Return left
End Process

Note: Parse comparison expressions (==, !=, <, >, etc.)
Process called "parser_parse_comparison_level" takes parser as Integer returns Integer:
    Return parser_parse_comparison(parser)
End Process

Note: Parse additive expressions (+ and -)
Process called "parser_parse_additive" takes parser as Integer returns Integer:
    Let left be parser_parse_multiplicative(parser)

    Let loop_additive be 1
    While loop_additive is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 16:  Note: TOKEN_PLUS
            Let operator be token_type
            parser_eat(parser, 16)
            Let right be parser_parse_multiplicative(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise:
            If token_type is equal to 17:  Note: TOKEN_MINUS
                Let operator be token_type
                parser_eat(parser, 17)
                Let right be parser_parse_multiplicative(parser)
                Set left to expression_create_binary_op(left, operator, right)
            Otherwise:
                Set loop_additive to 0
            End If
        End If
    End While

    Return left
End Process

Note: Parse multiplicative expressions (*, /, %)
Process called "parser_parse_multiplicative" takes parser as Integer returns Integer:
    Let left be parser_parse_primary_with_postfix(parser)

    Let loop_multiplicative be 1
    While loop_multiplicative is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 35:  Note: TOKEN_MULTIPLIED
            Let operator be token_type
            parser_eat(parser, 35)
            parser_eat(parser, 38)
            Let right be parser_parse_primary_with_postfix(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise:
            If token_type is equal to 36:  Note: TOKEN_DIVIDED
                Let operator be token_type
                parser_eat(parser, 36)
                parser_eat(parser, 38)
                Let right be parser_parse_primary_with_postfix(parser)
                Set left to expression_create_binary_op(left, operator, right)
            Otherwise:
                If token_type is equal to 37:  Note: TOKEN_MODULO
                    Let operator be token_type
                    parser_eat(parser, 37)
                    parser_eat(parser, 38)
                    Let right be parser_parse_primary_with_postfix(parser)
                    Set left to expression_create_binary_op(left, operator, right)
                Otherwise:
                    If token_type is equal to 42:  Note: TOKEN_BIT_SHIFT_LEFT
                        Let operator be token_type
                        parser_eat(parser, 42)
                        Let right be parser_parse_primary_with_postfix(parser)
                        Set left to expression_create_binary_op(left, operator, right)
                    Otherwise:
                        If token_type is equal to 43:  Note: TOKEN_BIT_SHIFT_RIGHT
                            Let operator be token_type
                            parser_eat(parser, 43)
                            Let right be parser_parse_primary_with_postfix(parser)
                            Set left to expression_create_binary_op(left, operator, right)
                        Otherwise:
                            If token_type is equal to 39:  Note: TOKEN_BIT_AND
                                Let operator be token_type
                                parser_eat(parser, 39)
                                Let right be parser_parse_primary_with_postfix(parser)
                                Set left to expression_create_binary_op(left, operator, right)
                            Otherwise:
                                If token_type is equal to 40:  Note: TOKEN_BIT_OR
                                    Let operator be token_type
                                    parser_eat(parser, 40)
                                    Let right be parser_parse_primary_with_postfix(parser)
                                    Set left to expression_create_binary_op(left, operator, right)
                                Otherwise:
                                    If token_type is equal to 41:  Note: TOKEN_BIT_XOR
                                        Let operator be token_type
                                        parser_eat(parser, 41)
                                        Let right be parser_parse_primary_with_postfix(parser)
                                        Set left to expression_create_binary_op(left, operator, right)
                                    Otherwise:
                                        Set loop_multiplicative to 0
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            End If
        End If
    End While

    Return left
End Process

Note: Parse primary expressions with postfix operators (function calls, field access, array indexing)
Process called "parser_parse_primary_with_postfix" takes parser as Integer returns Integer:
    Let left be parser_parse_primary(parser)

    Note: Check for function call (if primary was an identifier and followed by '(')
    Let current_token_fc be memory_get_pointer(parser, 8)
    Let token_type_fc be memory_get_integer(current_token_fc, 0)
    If token_type_fc is equal to 48:  Note: TOKEN_LPAREN (48)
        Note: Convert variable expression to function call
        Let expr_type be memory_get_integer(left, 0)
        If expr_type is equal to EXPR_VARIABLE:
            Note: Get the variable name from the EXPR_VARIABLE
            Let var_name be memory_get_pointer(left, 8)

            Note: Parse function arguments
            parser_eat(parser, 48)

            Note: Allocate space for arguments
            Let arguments be 0
            Let argument_count be 0
            Let argument_capacity be 4
            Let arg_ptr_size be 8
            Let arg_size be argument_capacity multiplied by arg_ptr_size
            Set arguments to memory_allocate(arg_size)

            Note: Parse arguments until we hit ')'
            Let continue_args be 1
            While continue_args is equal to 1:
                Let current_token_arg be memory_get_pointer(parser, 8)
                Let token_type_arg be memory_get_integer(current_token_arg, 0)

                If token_type_arg is equal to 49:  Note: TOKEN_RPAREN (49)
                    Set continue_args to 0
                Otherwise:
                    Note: Parse the argument expression
                    Let arg_expr be parser_parse_additive(parser)

                    Note: Store argument
                    Let arg_offset be argument_count multiplied by arg_ptr_size
                    Let arg_ptr be arguments plus arg_offset
                    memory_set_pointer(arg_ptr, 0, arg_expr)
                    Set argument_count to argument_count plus 1

                    Note: Check for comma
                    Let current_token_comma be memory_get_pointer(parser, 8)
                    Let token_type_comma be memory_get_integer(current_token_comma, 0)
                    If token_type_comma is equal to 52:  Note: TOKEN_COMMA (52)
                        parser_eat(parser, 52)
                    End If
                End If
            End While

            parser_eat(parser, 49)

            Note: Create function call expression
            Let func_call be expression_create_function_call(var_name, arguments, argument_count)
            deallocate(left)  Note: Free the old EXPR_VARIABLE
            Set left to func_call
        End If
    End If

    Note: Handle field access and array indexing (highest precedence)
    Let loop_field be 1
    While loop_field is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 51:  Note: TOKEN_DOT
            parser_eat(parser, 51)

            Let current_token2 be memory_get_pointer(parser, 8)
            Let token_type2 be memory_get_integer(current_token2, 0)
            If token_type2 is not equal to 53:  Note: TOKEN_IDENTIFIER
                Let error_msg be "[PARSER ERROR] Expected field name after '.' at line "
                print_string(error_msg)
                Let line be memory_get_int32(current_token2, 16)
                print_integer(line)
                print_newline()
                exit_with_code(1)
            End If

            Let token_value be memory_get_pointer(current_token2, 8)
            Let field_name be string_duplicate_parser(token_value)
            parser_eat(parser, 53)

            Let field_access be memory_allocate(32)  Note: sizeof(Expression)
            memory_set_integer(field_access, 0, 10)  Note: EXPR_FIELD_ACCESS
            memory_set_pointer(field_access, 8, left)  Note: field_access.object
            memory_set_pointer(field_access, 16, field_name)  Note: field_access.field_name
            Set left to field_access
        End If

        If token_type is equal to 148:  Note: TOKEN_AT (canonical: "at index")
            Note: Peek ahead to check if "index" follows
            parser_eat(parser, 148)  Note: at
            Set current_token to memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Set token_type to memory_get_int32(current_token, TOKEN_TYPE_OFFSET)

            If token_type is equal to 149:  Note: TOKEN_INDEX
                parser_eat(parser, 149)  Note: index

                Note: Parse index expression
                Let index be parser_parse_additive(parser)

                Let array_index be memory_allocate(32)  Note: sizeof(Expression)
                memory_set_integer(array_index, 0, 16)  Note: EXPR_ARRAY_INDEX
                memory_set_pointer(array_index, 8, left)  Note: array_index.array
                memory_set_pointer(array_index, 16, index)  Note: array_index.index
                Set left to array_index
            Otherwise:
                Note: TOKEN_AT without "index" - syntax error
                print_string("[PARSER ERROR] Expected 'index' after 'at' at line ")
                Let error_line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                print_integer(error_line)
                print_newline()
                exit(1)
            End If
        End If

        If token_type is not equal to 51:
            If token_type is not equal to 148:
                Set loop_field to 0
            End If
        End If
    End While

    Return left
End Process

Note: Parser parse comparison - handles comparison operators
Process called "parser_parse_comparison" takes parser as Integer returns Integer:
    Let left be parser_parse_additive(parser)

    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_integer(current_token, 0)

    If token_type is equal to 21:  Note: TOKEN_IS
        parser_eat(parser, 21)

        Let current_token2 be memory_get_pointer(parser, 8)
        Let token_type2 be memory_get_integer(current_token2, 0)

        Note: Check for "not" negation
        Let is_negated be 0
        If token_type2 is equal to 29:  Note: TOKEN_NOT
            parser_eat(parser, 29)
            Set is_negated to 1
            Set current_token2 to memory_get_pointer(parser, 8)
            Set token_type2 to memory_get_integer(current_token2, 0)
        End If

        Let comparison_op be 0

        Note: Handle EQUAL / NOT EQUAL
        If token_type2 is equal to 22:  Note: TOKEN_EQUAL
            parser_eat(parser, 22)
            parser_eat(parser, 15)  Note: TOKEN_TO
            If is_negated is equal to 1:
                Let comparison_op be 23  Note: TOKEN_NOT_EQUAL
            Otherwise:
                Let comparison_op be 22  Note: TOKEN_EQUAL
            End If
        End If

        Note: Handle LESS THAN (and LESS EQUAL)
        If token_type2 is equal to 24:
            parser_eat(parser, 24)
            Let current_token3 be memory_get_pointer(parser, 8)
            Let token_type3 be memory_get_integer(current_token3, 0)
            If token_type3 is equal to 28:  Note: TOKEN_THAN
                parser_eat(parser, 28)
                Let current_token4 be memory_get_pointer(parser, 8)
                Let token_type4 be memory_get_integer(current_token4, 0)
                If token_type4 is equal to 31:  Note: TOKEN_OR (for "or equal to")
                    parser_eat(parser, 31)
                    parser_eat(parser, 22)
                    parser_eat(parser, 15)
                    Note: "is less than or equal to" vs "is not less than or equal to"
                    If is_negated is equal to 1:
                        Let comparison_op be 25  Note: TOKEN_GREATER (inverted)
                    Otherwise:
                        Let comparison_op be 27  Note: TOKEN_LESS_EQUAL
                    End If
                End If
                If token_type4 is not equal to 31:  Note: Not TOKEN_OR
                    Note: "is less than" vs "is not less than"
                    If is_negated is equal to 1:
                        Let comparison_op be 26  Note: TOKEN_GREATER_EQUAL (inverted)
                    Otherwise:
                        Let comparison_op be 24  Note: TOKEN_LESS
                    End If
                End If
            End If
            If token_type3 is not equal to 28:  Note: Not TOKEN_THAN
                Let error_msg be "[PARSER ERROR] Expected 'than' after 'less' at line "
                print_string(error_msg)
                Let line be memory_get_int32(current_token3, 16)
                print_integer(line)
                print_newline()
                exit_with_code(1)
            End If
        End If

        Note: Handle GREATER THAN (and GREATER EQUAL)
        If token_type2 is equal to 25:
            parser_eat(parser, 25)
            Let current_token3 be memory_get_pointer(parser, 8)
            Let token_type3 be memory_get_integer(current_token3, 0)
            If token_type3 is equal to 28:  Note: TOKEN_THAN
                parser_eat(parser, 28)
                Let current_token4 be memory_get_pointer(parser, 8)
                Let token_type4 be memory_get_integer(current_token4, 0)
                If token_type4 is equal to 31:  Note: TOKEN_OR (for "or equal to")
                    parser_eat(parser, 31)
                    parser_eat(parser, 22)
                    parser_eat(parser, 15)
                    Note: "is greater than or equal to" vs "is not greater than or equal to"
                    If is_negated is equal to 1:
                        Let comparison_op be 24  Note: TOKEN_LESS (inverted)
                    Otherwise:
                        Let comparison_op be 26  Note: TOKEN_GREATER_EQUAL
                    End If
                End If
                If token_type4 is not equal to 31:  Note: Not TOKEN_OR
                    Note: "is greater than" vs "is not greater than"
                    If is_negated is equal to 1:
                        Let comparison_op be 27  Note: TOKEN_LESS_EQUAL (inverted)
                    Otherwise:
                        Let comparison_op be 25  Note: TOKEN_GREATER
                    End If
                End If
            End If
            If token_type3 is not equal to 28:  Note: Not TOKEN_THAN
                Let error_msg be "[PARSER ERROR] Expected 'than' after 'greater' at line "
                print_string(error_msg)
                Let line be memory_get_int32(current_token3, 16)
                print_integer(line)
                print_newline()
                exit_with_code(1)
            End If
        End If

        Note: Check if we got a valid comparison operator
        If comparison_op is equal to 0:
            Let error_msg be "[PARSER ERROR] Expected 'equal', 'less', or 'greater' after 'is' at line "
            print_string(error_msg)
            Let line be memory_get_int32(current_token2, 16)
            print_integer(line)
            print_newline()
            exit_with_code(1)
        End If

        Let right be parser_parse_additive(parser)
        Return expression_create_comparison(left, comparison_op, right)
    End If

    Return left
End Process

Note: Parser parse let statement - handles "Let var be expression"
Process called "parser_parse_let_statement" takes parser as Integer returns Integer:
    Note: Debug check for NULL parser
    If parser is equal to 0:
        print_string("[PARSER ERROR] NULL parser in parser_parse_let_statement")
        print_newline()
        exit(1)
    End If
    parser_eat(parser, 12)  Note: TOKEN_LET

    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_integer(current_token, 0)
    Let can_be_id be token_can_be_identifier(token_type)
    If can_be_id is not equal to 1:
        Let error_msg be "[PARSER ERROR] Expected identifier after Let at line "
        print_string(error_msg)
        Let line be memory_get_int32(current_token, 16)
        print_integer(line)
        print_newline()
        exit_with_code(1)
    End If

    Let token_value be memory_get_pointer(current_token, 8)
    Let var_name be string_duplicate_parser(token_value)
    parser_eat(parser, token_type)

    parser_eat(parser, 13)

    Note: Debug check before expression parsing
    If parser is equal to 0:
        print_string("[PARSER ERROR] parser became NULL before expression parsing in Let")
        print_newline()
        exit(1)
    End If

    Let expr be parser_parse_expression(parser)

    Return statement_create_let(var_name, expr)
End Process

Note: Parser parse set statement - handles "Set target to expression"
Process called "parser_parse_implicit_compound_assign" takes parser as Integer, operation as Integer returns Integer:
    Note: Parse implicit compound assignment: Increase/Decrease/Multiply/Divide X by Y
    Note: operation: 0=add, 1=sub, 2=mul, 3=div

    Note: Eat the operation token (INCREASE/DECREASE/MULTIPLY/DIVIDE)
    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_int32(current_token, 0)
    parser_eat(parser, token_type)

    Note: Parse target variable/expression
    Let target be parser_parse_expression(parser)

    Note: Eat BY token (38)
    parser_eat(parser, 38)

    Note: Parse value expression
    Let expr be parser_parse_expression(parser)

    Note: Create compound assignment statement
    Let stmt be statement_create_compound_assign(target, operation, expr)
    Return stmt
End Process

Process called "parser_parse_set_statement" takes parser as Integer returns Integer:
    parser_eat(parser, 14)

    Note: Parse the target expression (could be variable or nested field access)
    Let target be parser_parse_expression(parser)

    Note: Check for compound assignment: gets [increased|decreased|multiplied|divided] by
    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_int32(current_token, 0)

    Note: TOKEN_GETS is 136
    If token_type is equal to 136:
        Note: This is a compound assignment: Set X gets [op] by Y
        parser_eat(parser, 136)

        Note: Get operation token
        Set current_token to memory_get_pointer(parser, 8)
        Set token_type to memory_get_int32(current_token, 0)

        Let operation be 0
        Note: TOKEN_INCREASED is 137, TOKEN_DECREASED is 138
        Note: TOKEN_MULTIPLIED is 35, TOKEN_DIVIDED is 36
        Note: TOKEN_MULTIPLY is 141, TOKEN_DIVIDE is 142
        If token_type is equal to 137:
            Set operation to 0
            parser_eat(parser, 137)
        End If
        If token_type is equal to 138:
            Set operation to 1
            parser_eat(parser, 138)
        End If
        If token_type is equal to 35:
            Set operation to 2
            parser_eat(parser, 35)
        End If
        If token_type is equal to 141:
            Set operation to 2
            parser_eat(parser, 141)
        End If
        If token_type is equal to 36:
            Set operation to 3
            parser_eat(parser, 36)
        End If
        If token_type is equal to 142:
            Set operation to 3
            parser_eat(parser, 142)
        End If
        If operation is equal to 0:
            If token_type is not equal to 137:
                print_string("Parser error: Expected operation after gets (got token ")
                print_integer(token_type)
                print_string(")")
                print_newline()
                exit_with_code(1)
            End If
        End If

        parser_eat(parser, 38)

        Let expr be parser_parse_expression(parser)

        Let stmt be statement_create_compound_assign(target, operation, expr)
        Return stmt
    End If

    Note: Normal set statement: Set X to Y
    parser_eat(parser, 15)

    Let expr be parser_parse_expression(parser)

    Let stmt be statement_create_set(target, expr)
    Return stmt
End Process

Note: token_destroy is provided by lexer module - use external reference
Note: Process called "token_destroy" is defined in lexer.runa

Note: Expression type constants
Let EXPR_INTEGER be 0
Let EXPR_VARIABLE be 1
Let EXPR_BINARY_OP be 2
Let EXPR_COMPARISON be 3
Let EXPR_FUNCTION_CALL be 4
Let EXPR_STRING_LITERAL be 5
Let EXPR_FIELD_ACCESS be 6
Let EXPR_TYPE_NAME be 7
Let EXPR_BUILTIN_CALL be 8
Let EXPR_VARIANT_CONSTRUCTOR be 9
Let EXPR_FUNCTION_POINTER be 10
Let EXPR_INDIRECT_CALL be 11
Let EXPR_ARRAY_INDEX be 16
Let EXPR_LIST_LITERAL be 17
Let EXPR_SET_LITERAL be 21
Let EXPR_DICT_LITERAL be 22
Let EXPR_STRUCT_CONSTRUCTION be 20

Note: Statement type constants - synchronized with codegen.runa
Let STMT_LET be 1
Let STMT_SET be 2
Let STMT_RETURN be 3
Let STMT_PRINT be 4
Let STMT_IF be 5
Let STMT_WHILE be 6
Let STMT_EXPRESSION be 7
Let STMT_MATCH be 8
Let STMT_BREAK be 9
Let STMT_CONTINUE be 10
Let STMT_FOR be 11
Let STMT_FOR_EACH be 12
Let STMT_IMPORT be 13
Let STMT_INLINE_ASSEMBLY be 16
Let STMT_COMPOUND_ASSIGN be 17

Note: Match statement structure offsets
Let STMT_MATCH_EXPR be 8
Let STMT_MATCH_WHEN_CLAUSES be 16
Let STMT_MATCH_WHEN_COUNT be 24

Note: Type kind constants
Let TYPE_KIND_STRUCT be 0
Let TYPE_KIND_VARIANT be 1
Let TYPE_KIND_FUNCTION be 2
Let TYPE_KIND_ARRAY be 3

Note: TOKEN constants (from lexer.h enum - sequential numbering)
Note: These are defined in lexer.runa and will be available as external symbols
Note: DO NOT REDEFINE - use external references from lexer module
Note: Let TOKEN_EOF be 0
Note: Let TOKEN_PROCESS be 1
Note: Let TOKEN_CALLED be 2
Note: Let TOKEN_RETURNS be 3
Note: Let TOKEN_INTEGER_TYPE be 4
Note: Let TOKEN_STRING_TYPE be 5
Note: Let TOKEN_CHARACTER_TYPE be 6
Note: Let TOKEN_RETURN be 7
Note: Let TOKEN_END be 8
Note: Let TOKEN_COLON be 9
Note: Let TOKEN_STRING_LITERAL be 10
Note: Let TOKEN_INTEGER be 11
Note: Let TOKEN_LET be 12
Note: Let TOKEN_BE be 13
Note: Let TOKEN_SET be 14
Note: Let TOKEN_TO be 15
Note: Let TOKEN_PLUS be 16
Note: Let TOKEN_MINUS be 17
Note: Let TOKEN_IF be 18
Note: Let TOKEN_OTHERWISE be 19
Note: Let TOKEN_WHILE be 20
Note: Let TOKEN_IS be 21
Note: Let TOKEN_EQUAL be 22
Note: Let TOKEN_NOT_EQUAL be 23
Note: Let TOKEN_LESS be 24
Note: Let TOKEN_GREATER be 25
Note: Let TOKEN_GREATER_EQUAL be 26
Note: Let TOKEN_LESS_EQUAL be 27
Note: Let TOKEN_THAN be 28
Note: Let TOKEN_NOT be 29
Note: Let TOKEN_AND be 30
Note: Let TOKEN_OR be 31
Note: Let TOKEN_THAT be 32
Note: Let TOKEN_TAKES be 33
Note: Let TOKEN_AS be 34
Note: Let TOKEN_MULTIPLIED be 35
Note: Let TOKEN_DIVIDED be 36
Note: Let TOKEN_MODULO be 37
Note: Let TOKEN_BY be 38
Note: Let TOKEN_BIT_AND be 39
Note: Let TOKEN_BIT_OR be 40
Note: Let TOKEN_BIT_XOR be 41
Note: Let TOKEN_BIT_SHIFT_LEFT be 42
Note: Let TOKEN_BIT_SHIFT_RIGHT be 43
Note: Let TOKEN_BREAK be 44
Note: Let TOKEN_CONTINUE be 45
Note: Let TOKEN_OTHERWISE_IF be 46
Note: Let TOKEN_PRINT be 47
Note: Let TOKEN_LPAREN be 48
Note: Let TOKEN_RPAREN be 49
Note: Let TOKEN_TYPE be 50
Note: Let TOKEN_DOT be 51
Note: Let TOKEN_COMMA be 52
Note: Let TOKEN_IDENTIFIER be 53
Note: Let TOKEN_READ_FILE be 54
Note: Let TOKEN_WRITE_FILE be 55
Note: Let TOKEN_IMPORT be 56
Note: Let TOKEN_STRING_LENGTH be 57
Note: Let TOKEN_STRING_CHAR_AT be 58
Note: Let TOKEN_STRING_SUBSTRING be 59
Note: Let TOKEN_STRING_EQUALS be 60
Note: Let TOKEN_ASCII_VALUE_OF be 61
Note: Let TOKEN_IS_DIGIT be 62
Note: Let TOKEN_IS_ALPHA be 63
Note: Let TOKEN_IS_WHITESPACE be 64
Note: Let TOKEN_LIST_CREATE be 65
Note: Let TOKEN_LIST_APPEND be 66
Note: Let TOKEN_LIST_GET be 67
Note: Let TOKEN_LIST_GET_INTEGER be 68
Note: Let TOKEN_LIST_LENGTH be 69
Note: Let TOKEN_LIST_DESTROY be 70
Note: Let TOKEN_LIST_SET be 71
Note: Let TOKEN_LIST_INSERT be 72
Note: Let TOKEN_LIST_REMOVE be 73
Note: Let TOKEN_LIST_CLEAR be 74
Note: Let TOKEN_LIST_FIND be 75
Note: Let TOKEN_LIST_SORT be 76
Note: Let TOKEN_LIST_REVERSE be 77
Note: Let TOKEN_LIST_COPY be 78
Note: Let TOKEN_LIST_MERGE be 79
Note: Let TOKEN_STRING_CONCAT be 80
Note: Let TOKEN_STRING_COMPARE be 81
Note: Let TOKEN_STRING_TO_INTEGER be 82
Note: Let TOKEN_INTEGER_TO_STRING be 83
Note: Let TOKEN_STRING_FIND be 84
Note: Let TOKEN_STRING_REPLACE be 85
Note: Let TOKEN_STRING_TRIM be 86
Note: Let TOKEN_STRING_SPLIT be 87
Note: Let TOKEN_FILE_OPEN be 88
Note: Let TOKEN_FILE_CLOSE be 89
Note: Let TOKEN_FILE_READ_LINE be 90
Note: Let TOKEN_FILE_WRITE_LINE be 91
Note: Let TOKEN_FILE_EXISTS be 92
Note: Let TOKEN_FILE_DELETE be 93
Note: Let TOKEN_FILE_SIZE be 94
Note: Let TOKEN_FILE_SEEK be 95
Note: Let TOKEN_FILE_TELL be 96
Note: Let TOKEN_FILE_EOF be 97
Note: Let TOKEN_SIN be 98
Note: Let TOKEN_COS be 99
Note: Let TOKEN_TAN be 100
Note: Let TOKEN_SQRT be 101
Note: Let TOKEN_POW be 102
Note: Let TOKEN_ABS be 103
Note: Let TOKEN_FLOOR be 104
Note: Let TOKEN_CEIL be 105
Note: Let TOKEN_MIN be 106
Note: Let TOKEN_MAX be 107
Note: Let TOKEN_RANDOM be 108
Note: Let TOKEN_LOG be 109
Note: Let TOKEN_EXP be 110
Note: Let TOKEN_PIPE be 111
Note: Let TOKEN_MATCH be 112
Note: Let TOKEN_WHEN be 113
Note: Let TOKEN_WITH be 114
Note: Let TOKEN_GET_COMMAND_LINE_ARGS be 115
Note: Let TOKEN_EXIT_WITH_CODE be 116
Note: Let TOKEN_PANIC be 117
Note: Let TOKEN_ASSERT be 118
Note: Let TOKEN_ALLOCATE be 119
Note: Let TOKEN_DEALLOCATE be 120
Note: Let TOKEN_INLINE be 121
Note: Let TOKEN_ASSEMBLY be 122
Note: Let TOKEN_NOTE be 123
Note: Let TOKEN_POINTER be 124
Note: Let TOKEN_OF be 125
Note: Let TOKEN_ARRAY be 126
Note: Let TOKEN_LBRACKET be 127
Note: Let TOKEN_RBRACKET be 128
Note: Let TOKEN_ERROR be 129
Note: Let TOKEN_COUNT be 130

Note: TypeDefinition constants (matching C struct layout)
Let TypeDefinition_SIZE be 48
Let TYPEDEFINITION_NAME_OFFSET be 0
Let TYPEDEFINITION_KIND_OFFSET be 8
Let TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET be 16
Let TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET be 24
Let TYPEDEFINITION_SIZE_OFFSET be 40
Let TYPEDEFINITION_DATA_ARRAY_ELEMENT_TYPE_OFFSET be 16
Let TYPEDEFINITION_DATA_ARRAY_ELEMENT_SIZE_OFFSET be 24
Let TYPEDEFINITION_DATA_ARRAY_LENGTH_OFFSET be 28
Let TYPEDEFINITION_DATA_FUNCTION_PARAM_TYPES_OFFSET be 16
Let TYPEDEFINITION_DATA_FUNCTION_PARAM_COUNT_OFFSET be 24
Let TYPEDEFINITION_DATA_FUNCTION_RETURN_TYPE_OFFSET be 32
Let TYPEDEFINITION_DATA_VARIANT_VARIANTS_OFFSET be 16
Let TYPEDEFINITION_DATA_VARIANT_VARIANT_COUNT_OFFSET be 24

Note: TypeField constants (matching C struct layout)
Let TYPEFIELD_SIZE be 24
Let TYPEFIELD_NAME_OFFSET be 0
Let TYPEFIELD_TYPE_OFFSET be 8
Let TYPEFIELD_OFFSET_OFFSET be 16
Let TYPEFIELD_SIZE_OFFSET be 20

Note: Variant constants (matching C struct layout)
Let VARIANT_SIZE be 32
Let VARIANT_NAME_OFFSET be 0
Let VARIANT_FIELDS_OFFSET be 8
Let VARIANT_FIELD_COUNT_OFFSET be 16
Let VARIANT_TAG_OFFSET be 20

Note: Type kind constants already defined above

Note: Parser constants (definitions moved to bottom of file)
Let PARSER_CURRENT_TOKEN_OFFSET be 8
Let EXPRESSION_TYPE_OFFSET be 0

Note: String duplicate helper (already in string_utils but needed locally)
Process called "string_duplicate_parser" takes str as Integer returns Integer:
    If str is equal to 0:
        Return 0
    End If
    Let len be string_length(str)
    Let one be 1
    Let size be len plus one
    Let dup be memory_allocate(size)
    string_copy(dup, str)
    Return dup
End Process

Note: Parser advance - moves to next token
Process called "parser_advance" takes parser as Integer returns Integer:
    Let current_token be memory_get_pointer(parser, 8)  Note: parser->current_token
    token_destroy(current_token)
    Let lexer be memory_get_pointer(parser, 0)  Note: parser->lexer
    Let next_token be lexer_next_token(lexer)
    memory_set_pointer(parser, 8, next_token)
    Return 0
End Process

Note: Parser eat - consume expected token
Process called "parser_eat" takes parser as Integer, expected_type as Integer returns Integer:
    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_integer(current_token, 0)

    If token_type is equal to expected_type:
        Let dummy be parser_advance(parser)
    Otherwise:
        Note: Print error message
        Let error_msg be "[PARSER ERROR] Expected token type "
        print_string(error_msg)
        print_integer(expected_type)
        Let got_msg be ", got "
        print_string(got_msg)
        print_integer(token_type)
        Let at_line_msg be " at line "
        print_string(at_line_msg)
        Let line be memory_get_int32(current_token, 16)
        print_integer(line)
        print_newline()
        exit_with_code(1)
    End If
    Return 0
End Process

Note: Check if token is builtin function
Process called "parser_is_builtin_function_token" takes type as Integer returns Integer:
    Note: All builtin functions in order (54-120, excluding non-builtin tokens)
    Note: File operations
    If type is equal to 54:  Note: TOKEN_READ_FILE
        Return 1
    Otherwise If type is equal to 55:  Note: TOKEN_WRITE_FILE
        Return 1
    Note: String operations
    Otherwise If type is equal to 57:  Note: TOKEN_STRING_LENGTH
        Return 1
    Otherwise If type is equal to 58:  Note: TOKEN_STRING_CHAR_AT
        Return 1
    Otherwise If type is equal to 59:  Note: TOKEN_STRING_SUBSTRING
        Return 1
    Otherwise If type is equal to 60:  Note: TOKEN_STRING_EQUALS
        Return 1
    Otherwise If type is equal to 61:  Note: TOKEN_ASCII_VALUE_OF
        Return 1
    Otherwise If type is equal to 62:  Note: TOKEN_IS_DIGIT
        Return 1
    Otherwise If type is equal to 63:  Note: TOKEN_IS_ALPHA
        Return 1
    Otherwise If type is equal to 64:  Note: TOKEN_IS_WHITESPACE
        Return 1
    Note: List operations
    Otherwise If type is equal to 65:  Note: TOKEN_LIST_CREATE
        Return 1
    Otherwise If type is equal to 66:  Note: TOKEN_LIST_APPEND
        Return 1
    Otherwise If type is equal to 67:  Note: TOKEN_LIST_GET
        Return 1
    Otherwise If type is equal to 68:  Note: TOKEN_LIST_GET_INTEGER
        Return 1
    Otherwise If type is equal to 69:  Note: TOKEN_LIST_LENGTH
        Return 1
    Otherwise If type is equal to 70:  Note: TOKEN_LIST_DESTROY
        Return 1
    Otherwise If type is equal to 71:  Note: TOKEN_LIST_SET
        Return 1
    Otherwise If type is equal to 72:  Note: TOKEN_LIST_INSERT
        Return 1
    Otherwise If type is equal to 73:  Note: TOKEN_LIST_REMOVE
        Return 1
    Otherwise If type is equal to 74:  Note: TOKEN_LIST_CLEAR
        Return 1
    Otherwise If type is equal to 75:  Note: TOKEN_LIST_FIND
        Return 1
    Otherwise If type is equal to 76:  Note: TOKEN_LIST_SORT
        Return 1
    Otherwise If type is equal to 77:  Note: TOKEN_LIST_REVERSE
        Return 1
    Otherwise If type is equal to 78:  Note: TOKEN_LIST_COPY
        Return 1
    Otherwise If type is equal to 79:  Note: TOKEN_LIST_MERGE
        Return 1
    Note: More string operations
    Otherwise If type is equal to 80:  Note: TOKEN_STRING_CONCAT
        Return 1
    Otherwise If type is equal to 81:  Note: TOKEN_STRING_COMPARE
        Return 1
    Otherwise If type is equal to 82:  Note: TOKEN_STRING_TO_INTEGER
        Return 1
    Otherwise If type is equal to 83:  Note: TOKEN_INTEGER_TO_STRING
        Return 1
    Otherwise If type is equal to 84:  Note: TOKEN_STRING_FIND
        Return 1
    Otherwise If type is equal to 85:  Note: TOKEN_STRING_REPLACE
        Return 1
    Otherwise If type is equal to 86:  Note: TOKEN_STRING_TRIM
        Return 1
    Otherwise If type is equal to 87:  Note: TOKEN_STRING_SPLIT
        Return 1
    Note: More file operations
    Otherwise If type is equal to 88:  Note: TOKEN_FILE_OPEN
        Return 1
    Otherwise If type is equal to 89:  Note: TOKEN_FILE_CLOSE
        Return 1
    Otherwise If type is equal to 90:  Note: TOKEN_FILE_READ_LINE
        Return 1
    Otherwise If type is equal to 91:  Note: TOKEN_FILE_WRITE_LINE
        Return 1
    Otherwise If type is equal to 92:  Note: TOKEN_FILE_EXISTS
        Return 1
    Otherwise If type is equal to 93:  Note: TOKEN_FILE_DELETE
        Return 1
    Otherwise If type is equal to 94:  Note: TOKEN_FILE_SIZE
        Return 1
    Otherwise If type is equal to 95:  Note: TOKEN_FILE_SEEK
        Return 1
    Otherwise If type is equal to 96:  Note: TOKEN_FILE_TELL
        Return 1
    Otherwise If type is equal to 97:  Note: TOKEN_FILE_EOF
        Return 1
    Note: Math operations
    Otherwise If type is equal to 98:  Note: TOKEN_SIN
        Return 1
    Otherwise If type is equal to 99:  Note: TOKEN_COS
        Return 1
    Otherwise If type is equal to 100:  Note: TOKEN_TAN
        Return 1
    Otherwise If type is equal to 101:  Note: TOKEN_SQRT
        Return 1
    Otherwise If type is equal to 102:  Note: TOKEN_POW
        Return 1
    Otherwise If type is equal to 103:  Note: TOKEN_ABS
        Return 1
    Otherwise If type is equal to 104:  Note: TOKEN_FLOOR
        Return 1
    Otherwise If type is equal to 105:  Note: TOKEN_CEIL
        Return 1
    Otherwise If type is equal to 106:  Note: TOKEN_MIN
        Return 1
    Otherwise If type is equal to 107:  Note: TOKEN_MAX
        Return 1
    Otherwise If type is equal to 108:  Note: TOKEN_RANDOM
        Return 1
    Otherwise If type is equal to 109:  Note: TOKEN_LOG
        Return 1
    Otherwise If type is equal to 110:  Note: TOKEN_EXP
        Return 1
    Note: System operations
    Otherwise If type is equal to 115:  Note: TOKEN_GET_COMMAND_LINE_ARGS
        Return 1
    Otherwise If type is equal to 116:  Note: TOKEN_EXIT_WITH_CODE
        Return 1
    Otherwise If type is equal to 117:  Note: TOKEN_PANIC
        Return 1
    Otherwise If type is equal to 118:  Note: TOKEN_ASSERT
        Return 1
    Otherwise If type is equal to 119:  Note: TOKEN_ALLOCATE
        Return 1
    Otherwise If type is equal to 120:  Note: TOKEN_DEALLOCATE
        Return 1
    Otherwise If type is equal to 130:  Note: TOKEN_MEMORY_GET_BYTE
        Return 1
    Otherwise If type is equal to 131:  Note: TOKEN_MEMORY_SET_BYTE
        Return 1
    End If
    Return 0
End Process

Note: Create integer expression
Process called "expression_create_integer" takes value as Integer returns Integer:
    Let expr_size be 32  Note: Ensure sufficient space: type(8) + value(8) + padding
    Let expr be memory_allocate(expr_size)
    memory_set_int32(expr, 0, EXPR_INTEGER)
    memory_set_integer(expr, 8, value)
    Return expr
End Process

Note: Create variable expression
Process called "expression_create_variable" takes name as Integer returns Integer:
    Let expr_size be 32  Note: Ensure sufficient space: type(8) + name_pointer(8) + padding
    Let expr be memory_allocate(expr_size)
    memory_set_int32(expr, 0, EXPR_VARIABLE)
    Let dup_name be string_duplicate_parser(name)
    memory_set_pointer(expr, 8, dup_name)
    Return expr
End Process

Note: Create binary operation expression
Process called "expression_create_binary_op" takes left as Integer, operator as Integer, right as Integer returns Integer:
    Let expr_size be 32  Note: type plus left plus right plusoperator
    Let expr be memory_allocate(expr_size)
    memory_set_int32(expr, 0, EXPR_BINARY_OP)
    memory_set_pointer(expr, 8, left)
    memory_set_pointer(expr, 16, right)
    memory_set_integer(expr, 24, operator)
    Return expr
End Process

Note: Create comparison expression
Process called "expression_create_comparison" takes left as Integer, comparison_op as Integer, right as Integer returns Integer:
    Let expr_size be 32
    Let expr be memory_allocate(expr_size)
    memory_set_int32(expr, 0, EXPR_COMPARISON)
    memory_set_pointer(expr, 8, left)
    memory_set_pointer(expr, 16, right)
    memory_set_integer(expr, 24, comparison_op)
    Return expr
End Process

Note: Create unary operator expression (for NOT)
Process called "expression_create_unary_op" takes operator as Integer, operand as Integer returns Integer:
    Let expr_size be 32
    Let expr be memory_allocate(expr_size)
    memory_set_int32(expr, 0, 12)  Note: Use 12 for EXPR_UNARY (11 conflicts with INDIRECT_CALL)
    memory_set_integer(expr, 8, operator)
    memory_set_pointer(expr, 16, operand)
    Return expr
End Process

Note: Create function call expression
Process called "expression_create_function_call" takes function_name as Integer, arguments as Integer, argument_count as Integer returns Integer:
    Let expr_size be 32
    Let expr be memory_allocate(expr_size)
    memory_set_int32(expr, 0, EXPR_FUNCTION_CALL)
    Let dup_name be string_duplicate_parser(function_name)
    memory_set_pointer(expr, 8, dup_name)
    memory_set_pointer(expr, 16, arguments)
    memory_set_integer(expr, 24, argument_count)
    Return expr
End Process

Note: Create string literal expression (takes ownership)
Process called "expression_create_string_literal_owned" takes string_value as Integer returns Integer:
    Let expr_size be 32  Note: Match other expression types for safety
    Let expr be memory_allocate(expr_size)
    memory_set_int32(expr, 0, EXPR_STRING_LITERAL)
    memory_set_pointer(expr, 8, string_value)  Note: Takes ownership

    Return expr
End Process

Note: Create let statement
Process called "statement_create_let" takes var_name as Integer, expr as Integer returns Integer:
    Let stmt_size be 24
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_LET)
    Let dup_name be string_duplicate_parser(var_name)
    memory_set_pointer(stmt, 8, dup_name)   Note: variable_name at offset 8
    memory_set_pointer(stmt, 16, expr)      Note: expression at offset 16
    Return stmt
End Process

Note: Create set statement
Process called "statement_create_set" takes target as Integer, expr as Integer returns Integer:
    Let stmt_size be 24
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_SET)
    memory_set_pointer(stmt, 8, target)  Note: target at offset 8
    memory_set_pointer(stmt, 16, expr)   Note: expression at offset 16
    Return stmt
End Process

Note: Create compound assignment statement
Process called "statement_create_compound_assign" takes target as Integer, operation as Integer, expr as Integer returns Integer:
    Let stmt_size be 32
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_COMPOUND_ASSIGN)
    memory_set_pointer(stmt, 8, target)      Note: target at offset 8
    memory_set_int32(stmt, 16, operation)    Note: operation (0=add, 1=sub, 2=mul, 3=div) at offset 16
    memory_set_pointer(stmt, 24, expr)       Note: expression at offset 24
    Return stmt
End Process

Note: Create for-range statement
Process called "statement_create_for_range" takes var_name as Integer, start_expr as Integer, end_expr as Integer, step_expr as Integer, body as Integer, body_count as Integer returns Integer:
    Let stmt_size be 56
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_FOR)
    memory_set_pointer(stmt, 8, var_name)       Note: loop variable name at offset 8
    memory_set_pointer(stmt, 16, start_expr)    Note: start expression at offset 16
    memory_set_pointer(stmt, 24, end_expr)      Note: end expression at offset 24
    memory_set_pointer(stmt, 32, step_expr)     Note: step expression at offset 32 (0 if not specified)
    memory_set_pointer(stmt, 40, body)          Note: body statements at offset 40
    memory_set_integer(stmt, 48, body_count)    Note: body count at offset 48
    Return stmt
End Process

Note: Create for-each statement
Process called "statement_create_for_each" takes var_name as Integer, collection_expr as Integer, body as Integer, body_count as Integer returns Integer:
    Let stmt_size be 40
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_FOR_EACH)
    memory_set_pointer(stmt, 8, var_name)          Note: loop variable name at offset 8
    memory_set_pointer(stmt, 16, collection_expr)  Note: collection expression at offset 16
    memory_set_pointer(stmt, 24, body)             Note: body statements at offset 24
    memory_set_integer(stmt, 32, body_count)       Note: body count at offset 32
    Return stmt
End Process

Note: Create return statement
Process called "statement_create_return" takes expr as Integer returns Integer:
    Let stmt_size be 24  Note: Match other statement types that have fields at offset 16
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_RETURN)
    memory_set_pointer(stmt, 8, expr)
    Return stmt
End Process

Note: Create print statement
Process called "statement_create_print" takes expr as Integer returns Integer:
    Let stmt_size be 24  Note: Match other statement types for consistency
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_PRINT)
    memory_set_pointer(stmt, 8, expr)
    Return stmt
End Process

Note: Create expression statement
Process called "statement_create_expression" takes expr as Integer returns Integer:
    Let stmt_size be 24  Note: Match other statement types for consistency
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_EXPRESSION)
    memory_set_pointer(stmt, 8, expr)
    Return stmt
End Process

Note: Create if statement
Process called "statement_create_if" takes condition as Integer, if_body as Integer, if_body_count as Integer, else_body as Integer, else_body_count as Integer returns Integer:
    Let stmt_size be 48
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_IF)
    memory_set_pointer(stmt, 8, condition)
    memory_set_pointer(stmt, 16, if_body)
    memory_set_integer(stmt, 24, if_body_count)
    memory_set_pointer(stmt, 32, else_body)
    memory_set_integer(stmt, 40, else_body_count)
    Return stmt
End Process

Note: Create while statement
Process called "statement_create_while" takes condition as Integer, body as Integer, body_count as Integer returns Integer:
    Let stmt_size be 32
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_WHILE)
    memory_set_pointer(stmt, 8, condition)
    memory_set_pointer(stmt, 16, body)
    memory_set_integer(stmt, 24, body_count)
    Return stmt
End Process

Note: Create break statement
Process called "statement_create_break" takes dummy as Integer returns Integer:
    Let stmt_size be 8
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_BREAK)
    Return stmt
End Process

Note: Create continue statement
Process called "statement_create_continue" takes dummy as Integer returns Integer:
    Let stmt_size be 8
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_CONTINUE)
    Return stmt
End Process

Note: Create function
Process called "function_create" takes name as Integer, return_type as Integer returns Integer:
    Let func_size be 48  Note: name, parameters, parameter_count, return_type, statements, statement_count
    Let func be memory_allocate(func_size)
    Let dup_name be string_duplicate_parser(name)
    memory_set_pointer(func, 0, dup_name)
    memory_set_pointer(func, 8, 0)  Note: parameters = NULL
    memory_set_int32(func, 16, 0)  Note: parameter_count = 0
    Let dup_type be string_duplicate_parser(return_type)
    memory_set_pointer(func, 24, dup_type)
    memory_set_pointer(func, 32, 0)  Note: statements = NULL
    memory_set_int32(func, 40, 0)  Note: statement_count = 0
    Return func
End Process

Note: Add parameter to function
Process called "function_add_parameter" takes func as Integer, param_name as Integer, param_type as Integer returns Integer:
    Let parameter_count be memory_get_int32(func, 16)
    Let new_count be parameter_count plus 1
    Let param_size be 16  Note: sizeof(Parameter) = name plustype
    Let new_size be new_count multiplied by param_size

    Let parameters be memory_get_pointer(func, 8)
    Let new_parameters be memory_reallocate(parameters, new_size)

    Let offset be parameter_count multiplied by param_size
    Let param_ptr be new_parameters plus offset
    Let dup_name be string_duplicate_parser(param_name)
    memory_set_pointer(param_ptr, 0, dup_name)
    Let dup_type be string_duplicate_parser(param_type)
    memory_set_pointer(param_ptr, 8, dup_type)

    memory_set_pointer(func, 8, new_parameters)
    memory_set_integer(func, 16, new_count)
    Return 0
End Process

Note: Add statement to function
Process called "function_add_statement" takes func as Integer, stmt as Integer returns Integer:

    Let statement_count be memory_get_int32(func, 40)  Note: Changed from memory_get_integer
    Let new_count be statement_count plus 1
    Let ptr_size be 8
    Let new_size be new_count multiplied by ptr_size

    Let statements be memory_get_pointer(func, 32)

    Let new_statements be memory_reallocate(statements, new_size)

    Let offset be statement_count multiplied by ptr_size
    Let stmt_ptr be new_statements plus offset
    memory_set_pointer(stmt_ptr, 0, stmt)

    memory_set_pointer(func, 32, new_statements)
    memory_set_int32(func, 40, new_count)  Note: Changed from memory_set_integer

    Return 0
End Process

Note: Create program
Process called "program_create" takes dummy as Integer returns Integer:
    Let prog_size be 64  Note: 8 fields multiplied by 8 bytes each
    Let program be memory_allocate(prog_size)
    memory_set_pointer(program, 0, 0)   Note: functions = NULL
    memory_set_int32(program, 8, 0)   Note: function_count = 0
    memory_set_int32(program, 12, 0)  Note: function_capacity = 0
    memory_set_pointer(program, 16, 0)  Note: types = NULL
    memory_set_int32(program, 24, 0)  Note: type_count = 0
    memory_set_int32(program, 28, 0)  Note: type_capacity = 0
    memory_set_pointer(program, 32, 0)  Note: imports = NULL
    memory_set_int32(program, 40, 0)  Note: import_count = 0
    memory_set_int32(program, 44, 0)  Note: import_capacity = 0
    memory_set_pointer(program, 48, 0)  Note: globals = NULL
    memory_set_int32(program, 56, 0)  Note: global_count = 0
    memory_set_int32(program, 60, 0)  Note: global_capacity = 0
    Return program
End Process

Note: Add function to program
Process called "program_add_function" takes program as Integer, func as Integer returns Integer:
    Let function_count be memory_get_int32(program, 8)
    Let function_capacity be memory_get_int32(program, 12)

    If function_count is greater than or equal to function_capacity:
        If function_capacity is equal to 0:
            Set function_capacity to 4
        Otherwise:
            Set function_capacity to function_capacity multiplied by 2
        End If

        Let ptr_size be 8
        Let new_size be function_capacity multiplied by ptr_size
        Let functions be memory_get_pointer(program, 0)
        Let new_functions be memory_reallocate(functions, new_size)
        memory_set_pointer(program, 0, new_functions)
        memory_set_int32(program, 12, function_capacity)
    End If

    Let functions be memory_get_pointer(program, 0)
    Let func_offset be function_count multiplied by 8
    Let func_slot be functions plus func_offset
    memory_set_pointer(func_slot, 0, func)

    Let new_count be function_count plus 1
    memory_set_int32(program, 8, new_count)
    Return 0
End Process

Note: Add global variable to program
Process called "program_add_global" takes program as Integer, global as Integer returns Integer:
    Let global_count be memory_get_int32(program, 56)
    Let global_capacity be memory_get_int32(program, 60)

    If global_count is greater than or equal to global_capacity:
        If global_capacity is equal to 0:
            Set global_capacity to 4
        Otherwise:
            Set global_capacity to global_capacity multiplied by 2
        End If

        Let ptr_size be 8
        Let new_size be global_capacity multiplied by ptr_size
        Let globals be memory_get_pointer(program, 48)
        Let new_globals be memory_reallocate(globals, new_size)
        memory_set_pointer(program, 48, new_globals)
        memory_set_int32(program, 60, global_capacity)
    End If

    Let globals be memory_get_pointer(program, 48)
    Let global_offset be global_count multiplied by 8
    Let global_slot be globals plus global_offset
    memory_set_pointer(global_slot, 0, global)

    Let new_count be global_count plus 1
    memory_set_int32(program, 56, new_count)
    Return 0
End Process

Note: Add type to program
Process called "program_add_type" takes program as Integer, type as Integer returns Integer:
    Let type_count be memory_get_int32(program, 24)
    Let type_capacity be memory_get_int32(program, 28)

    If type_count is greater than or equal to type_capacity:
        If type_capacity is equal to 0:
            Set type_capacity to 4
        Otherwise:
            Set type_capacity to type_capacity multiplied by 2
        End If

        Let ptr_size be 8
        Let new_size be type_capacity multiplied by ptr_size
        Let types be memory_get_pointer(program, 16)
        Let new_types be memory_reallocate(types, new_size)
        memory_set_pointer(program, 16, new_types)
        memory_set_int32(program, 28, type_capacity)
    End If

    Let types be memory_get_pointer(program, 16)
    Let type_offset be type_count multiplied by 8
    Let type_slot be types plus type_offset
    memory_set_pointer(type_slot, 0, type)

    Let new_count be type_count plus 1
    memory_set_int32(program, 24, new_count)
    Return 0
End Process

Note: Add import to program
Process called "program_add_import" takes program as Integer, import as Integer returns Integer:
    Let import_count be memory_get_int32(program, 40)
    Let import_capacity be memory_get_int32(program, 44)

    If import_count is greater than or equal to import_capacity:
        If import_capacity is equal to 0:
            Set import_capacity to 4
        Otherwise:
            Set import_capacity to import_capacity multiplied by 2
        End If

        Let ptr_size be 8
        Let new_size be import_capacity multiplied by ptr_size
        Let imports be memory_get_pointer(program, 32)
        Let new_imports be memory_reallocate(imports, new_size)
        memory_set_pointer(program, 32, new_imports)
        memory_set_int32(program, 44, import_capacity)
    End If

    Let imports be memory_get_pointer(program, 32)
    Let import_offset be import_count multiplied by 8
    Let import_slot be imports plus import_offset
    memory_set_pointer(import_slot, 0, import)

    Let new_count be import_count plus 1
    memory_set_int32(program, 40, new_count)
    Return 0
End Process

Note: Parse primary expression
Process called "parser_parse_primary" takes parser as Integer returns Integer:
    Note: Add null check for parser
    If parser is equal to 0:
        print_string("[PARSER ERROR] Null parser in parse_primary")
        exit_with_code(1)
    End If

    Let current_token be memory_get_pointer(parser, 8)

    Note: Add null check for current_token
    If current_token is equal to 0:
        print_string("[PARSER ERROR] Null current_token in parse_primary")
        exit_with_code(1)
    End If

    Let token_type be memory_get_integer(current_token, 0)

    Note: Handle built-in functions
    Let is_builtin be parser_is_builtin_function_token(token_type)
    If is_builtin is equal to 1:
        Let builtin_type be token_type
        Let dummy be parser_eat(parser, builtin_type)

        Let dummy2 be parser_eat(parser, 48)  Note: TOKEN_LPAREN

        Note: Parse arguments
        Let arguments be 0
        Let argument_count be 0

        Let current_token2 be memory_get_pointer(parser, 8)
        Let token_type2 be memory_get_integer(current_token2, 0)

        If token_type2 is not equal to 49:  Note: TOKEN_RPAREN
            Let capacity be 2
            Let ptr_size be 8
            Let size be capacity multiplied by ptr_size
            Set arguments to memory_allocate(size)

            Let continue_args be 1
            While continue_args is equal to 1:
                Let current_token3 be memory_get_pointer(parser, 8)
                Let token_type3 be memory_get_integer(current_token3, 0)

                If token_type3 is equal to 52:  Note: TOKEN_COMMA
                    Let dummy3 be parser_eat(parser, 52)  Note: TOKEN_COMMA
                End If

                Let arg be parser_parse_additive(parser)

                If argument_count is greater than or equal to capacity:
                    Set capacity to capacity multiplied by 2
                    Let new_size be capacity multiplied by ptr_size
                    Set arguments to memory_reallocate(arguments, new_size)
                End If

                Let offset be argument_count multiplied by ptr_size
                Let arg_ptr be arguments plus offset
                memory_set_pointer(arg_ptr, 0, arg)
                Set argument_count to argument_count plus 1

                Let current_token4 be memory_get_pointer(parser, 8)
                Let token_type4 be memory_get_integer(current_token4, 0)
                If token_type4 is not equal to 52:  Note: TOKEN_COMMA
                    Set continue_args to 0
                End If
            End While
        End If

        Let dummy4 be parser_eat(parser, 49)  Note: TOKEN_RPAREN

        Note: Create builtin call expression
        Let expr_size be 32
        Let expr be memory_allocate(expr_size)
        memory_set_int32(expr, 0, 8)  Note: EXPR_BUILTIN_CALL
        memory_set_integer(expr, 8, builtin_type)
        memory_set_pointer(expr, 16, arguments)
        memory_set_integer(expr, 24, argument_count)
        Return expr
    End If

    Note: Handle integer literal
    If token_type is equal to 11:
        Let value_str be memory_get_pointer(current_token, 8)
        Let value be string_to_integer(value_str)
        Let dummy5 be parser_eat(parser, 11)
        Let expr be expression_create_integer(value)
        Return expr
    End If

    Note: Handle string literal
    If token_type is equal to 10:
        Let value_str be memory_get_pointer(current_token, 8)
        Let string_value be string_duplicate_parser(value_str)


        Note: Check if this string literal is a known type name
        Let is_type be 0
        Let prog be memory_get_pointer(parser, PARSER_CURRENT_PROGRAM_OFFSET)  Note: parser->current_program
        If prog is not equal to 0:
            Let type_count be memory_get_int32(prog, PROGRAM_TYPE_COUNT)
            Let types be memory_get_pointer(prog, PROGRAM_TYPES)
            Let i be 0
            While i is less than type_count:
                Let ptr_size be 8
                Let offset be i multiplied by ptr_size
                Let type_ptr be types plus offset
                Let type_def be memory_get_pointer(type_ptr, 0)
                Let type_name be memory_get_pointer(type_def, 0)
                Let result be string_equals(type_name, string_value)
                If result is equal to 1:
                    Set is_type to 1
                    Set i to type_count  Note: Break loop
                Otherwise:
                    Set i to i plus 1
                End If
            End While
        End If

        Let dummy6 be parser_eat(parser, 10)

        If is_type is equal to 1:
            Note: This is a type name, create a type expression
            Let expr_size be 32  Note: Match other expression types for safety
            Let expr be memory_allocate(expr_size)
            memory_set_int32(expr, 0, EXPR_TYPE_NAME)
            memory_set_pointer(expr, 8, string_value)
            Return expr
        Otherwise:
            Let expr be expression_create_string_literal_owned(string_value)
            Return expr
        End If
    End If

    Note: Handle function pointer ($identifier)
    If token_type is equal to 157:  Note: TOKEN_DOLLAR
        Let dummy_dollar be parser_eat(parser, 157)

        Note: Expect identifier after $
        Let func_token be memory_get_pointer(parser, 8)
        Let func_token_type be memory_get_integer(func_token, 0)
        If func_token_type is not equal to 53:  Note: TOKEN_IDENTIFIER
            print_string("[PARSER ERROR] Expected function name after $ at line ")
            Let err_line be memory_get_integer(func_token, 16)
            print_integer(err_line)
            print_newline()
            exit_with_code(1)
        End If

        Let func_name_str be memory_get_pointer(func_token, 8)
        Let func_name be string_duplicate_parser(func_name_str)
        Let dummy_ident be parser_eat(parser, 53)

        Note: Create EXPR_FUNCTION_POINTER
        Let expr_size be 32
        Let expr be memory_allocate(expr_size)
        memory_set_int32(expr, 0, 10)  Note: EXPR_FUNCTION_POINTER
        memory_set_pointer(expr, 8, func_name)
        Return expr
    End If

    Note: Handle parentheses for expression grouping
    If token_type is equal to 48:  Note: TOKEN_LPAREN
        parser_eat(parser, 48)  Note: Eat '('
        Let grouped_expr be parser_parse_expression(parser)
        parser_eat(parser, 49)  Note: Eat ')'
        Return grouped_expr
    End If

    Note: Handle unary minus for negative numbers
    If token_type is equal to 17:  Note: TOKEN_MINUS
        parser_eat(parser, 17)  Note: Eat '-'
        Let operand be parser_parse_primary(parser)
        Note: Create binary expression: 0 - operand
        Let zero_expr be expression_create_integer(0)
        Let neg_expr be expression_create_binary_op(zero_expr, 17, operand)  Note: TOKEN_MINUS (fixed parameter order)
        Return neg_expr
    End If

    Note: Handle field access: "the FIELD of OBJECT"
    If token_type is equal to 158:  Note: TOKEN_THE
        parser_eat(parser, 158)  Note: Eat 'the'

        Note: Next token should be field name
        Set current_token to memory_get_pointer(parser, 8)
        Set token_type to memory_get_int32(current_token, 0)
        If token_type is not equal to 53:  Note: TOKEN_IDENTIFIER
            print_string("[PARSER ERROR] Expected field name after 'the' at line ")
            Let line be memory_get_int32(current_token, 16)
            print_integer(line)
            print_newline()
            exit_with_code(1)
        End If

        Let token_value be memory_get_pointer(current_token, 8)
        Let field_name be string_duplicate_parser(token_value)
        parser_eat(parser, 53)  Note: Eat field name

        Note: Expect 'of' keyword
        Set current_token to memory_get_pointer(parser, 8)
        Set token_type to memory_get_int32(current_token, 0)
        If token_type is not equal to 125:  Note: TOKEN_OF
            print_string("[PARSER ERROR] Expected 'of' after field name at line ")
            Let line be memory_get_int32(current_token, 16)
            print_integer(line)
            print_newline()
            exit_with_code(1)
        End If
        parser_eat(parser, 125)  Note: Eat 'of'

        Note: Parse object expression
        Let object be parser_parse_primary(parser)

        Note: Create field access expression
        Let field_access be memory_allocate(32)  Note: sizeof(Expression)
        memory_set_int32(field_access, 0, 6)  Note: EXPR_FIELD_ACCESS
        memory_set_pointer(field_access, 8, object)
        memory_set_pointer(field_access, 16, field_name)
        Return field_access
    End If

    Note: Handle canonical collection literals: "a list containing..." or "an Array of..."
    Note: This must come BEFORE the general identifier handler
    Note: Check for pattern: identifier("a" or "an") followed by collection type
    If token_type is equal to 53:  Note: TOKEN_IDENTIFIER
        Let token_value be memory_get_pointer(current_token, 8)
        Let is_a be string_equals(token_value, "a")
        Let is_an be string_equals(token_value, "an")

        If is_a is equal to 1:
            Note: Peek ahead: get lexer position to check next token
            Let lexer_ptr be memory_get_pointer(parser, 0)  Note: parser->lexer
            Let lexer_position be memory_get_integer(lexer_ptr, 0)  Note: Save current position

            Note: Temporarily advance to peek at next token
            parser_eat(parser, 53)  Note: eat "a"
            Set current_token to memory_get_pointer(parser, 8)
            Set token_type to memory_get_integer(current_token, 0)

            Note: Check if next token is identifier "list"
            If token_type is equal to 53:  Note: TOKEN_IDENTIFIER
                Let next_value be memory_get_pointer(current_token, 8)
                Let is_list be string_equals(next_value, "list")

                If is_list is equal to 1:
                    Note: Confirmed "a list" pattern - continue parsing
                    parser_eat(parser, 53)  Note: eat "list"

                Note: Expect "containing"
                Set current_token to memory_get_pointer(parser, 8)
                Set token_type to memory_get_int32(current_token, 0)
                If token_type is not equal to 156:  Note: TOKEN_CONTAINING
                    print_string("[PARSER ERROR] Expected 'containing' after 'a list' at line ")
                    Let line be memory_get_int32(current_token, 16)
                    print_integer(line)
                    print_newline()
                    exit(1)
                End If
                parser_eat(parser, 156)  Note: containing

                Note: Parse list elements
                Let elements be 0
                Let element_count be 0
                Let capacity be 4
                Let ptr_size be 8
                Let size be capacity multiplied by ptr_size
                Set elements to memory_allocate(size)

                Note: Parse first element
                Let elem be parser_parse_expression(parser)
                memory_set_pointer(elements, 0, elem)
                Set element_count to 1

                Note: Parse remaining elements (comma or "and" separated)
                Let continue_parsing be 1
                While continue_parsing is equal to 1:
                    Set current_token to memory_get_pointer(parser, 8)
                    Set token_type to memory_get_integer(current_token, 0)

                    If token_type is equal to 52:  Note: TOKEN_COMMA
                        parser_eat(parser, 52)  Note: ,

                        Note: Check for optional "and" after comma
                        Set current_token to memory_get_pointer(parser, 8)
                        Set token_type to memory_get_integer(current_token, 0)
                        If token_type is equal to 30:  Note: TOKEN_AND
                            parser_eat(parser, 30)  Note: and
                        End If

                        Note: Parse next element
                        Let elem2 be parser_parse_expression(parser)

                        Note: Grow array if needed
                        If element_count is greater than or equal to capacity:
                            Set capacity to capacity multiplied by 2
                            Let new_size be capacity multiplied by ptr_size
                            Set elements to memory_reallocate(elements, new_size)
                        End If

                        Let offset be element_count multiplied by ptr_size
                        Let elem_ptr be elements plus offset
                        memory_set_pointer(elem_ptr, 0, elem2)
                        Set element_count to element_count plus 1
                    Otherwise:
                        Set continue_parsing to 0
                    End If
                End While

                Note: Create EXPR_LIST_LITERAL expression
                Let list_expr be memory_allocate(32)
                memory_set_int32(list_expr, 0, 17)  Note: EXPR_LIST_LITERAL
                memory_set_pointer(list_expr, 8, elements)
                memory_set_int32(list_expr, 16, element_count)
                Return list_expr
                Otherwise:
                    Note: Not "list" - check if this is "set"
                    Let is_set be string_equals(next_value, "set")

                    If is_set is equal to 1:
                        Note: Confirmed "a set" pattern - continue parsing
                        parser_eat(parser, 53)  Note: eat "set"

                        Note: Expect "containing"
                        Set current_token to memory_get_pointer(parser, 8)
                        Set token_type to memory_get_int32(current_token, 0)
                        If token_type is not equal to 156:  Note: TOKEN_CONTAINING
                            print_string("[PARSER ERROR] Expected 'containing' after 'a set' at line ")
                            Let line be memory_get_int32(current_token, 16)
                            print_integer(line)
                            print_newline()
                            exit(1)
                        End If
                        parser_eat(parser, 156)  Note: containing

                        Note: Parse set elements
                        Let elements be 0
                        Let element_count be 0
                        Let capacity be 4
                        Let ptr_size be 8
                        Let size be capacity multiplied by ptr_size
                        Set elements to memory_allocate(size)

                        Note: Parse first element
                        Let elem be parser_parse_expression(parser)
                        memory_set_pointer(elements, 0, elem)
                        Set element_count to 1

                        Note: Parse remaining elements (comma or "and" separated)
                        Let continue_parsing be 1
                        While continue_parsing is equal to 1:
                            Set current_token to memory_get_pointer(parser, 8)
                            Set token_type to memory_get_integer(current_token, 0)

                            If token_type is equal to 52:  Note: TOKEN_COMMA
                                parser_eat(parser, 52)  Note: ,

                                Note: Check for optional "and" after comma
                                Set current_token to memory_get_pointer(parser, 8)
                                Set token_type to memory_get_integer(current_token, 0)
                                If token_type is equal to 30:  Note: TOKEN_AND
                                    parser_eat(parser, 30)  Note: and
                                End If

                                Note: Parse next element
                                Let elem2 be parser_parse_expression(parser)

                                Note: Grow array if needed
                                If element_count is greater than or equal to capacity:
                                    Set capacity to capacity multiplied by 2
                                    Let new_size be capacity multiplied by ptr_size
                                    Set elements to memory_reallocate(elements, new_size)
                                End If

                                Let offset be element_count multiplied by ptr_size
                                Let elem_ptr be elements plus offset
                                memory_set_pointer(elem_ptr, 0, elem2)
                                Set element_count to element_count plus 1
                            Otherwise:
                                Set continue_parsing to 0
                            End If
                        End While

                        Note: Create EXPR_SET_LITERAL expression
                        Let set_expr be memory_allocate(32)
                        memory_set_int32(set_expr, 0, 21)  Note: EXPR_SET_LITERAL
                        memory_set_pointer(set_expr, 8, elements)
                        memory_set_int32(set_expr, 16, element_count)
                        Return set_expr
                    Otherwise:
                        Note: Not "list" or "set" - check if this is struct construction: "a TypeName with..."
                        Note: next_value already contains the type name candidate
                Let prog be memory_get_pointer(parser, 16)  Note: parser->current_program (PARSER_CURRENT_PROGRAM_OFFSET)
                Let is_struct_type be 0

                    If prog is not equal to 0:
                        Let type_count be memory_get_int32(prog, 24)  Note: program->type_count
                        Let types be memory_get_pointer(prog, 16)     Note: program->types

                        Let type_check_i be 0
                        While type_check_i is less than type_count:
                            Let type_offset be type_check_i multiplied by 8
                            Let type_ptr be memory_get_pointer(types, type_offset)
                            Let type_name be memory_get_pointer(type_ptr, 0)
                            If string_equals(type_name, next_value) is equal to 1:
                                Let is_struct_type be 1
                                Let type_check_i be type_count  Note: break
                            End If
                            Let type_check_i be type_check_i plus 1
                        End While
                    End If

                    If is_struct_type is equal to 1:
                        Note: This is struct construction: "a TypeName with field value and field value"
                        Let struct_type_name be string_duplicate_parser(next_value)
                        parser_eat(parser, 53)  Note: eat type name

                        Note: Expect "with"
                        Set current_token to memory_get_pointer(parser, 8)
                        Set token_type to memory_get_int32(current_token, 0)
                        If token_type is not equal to 114:  Note: TOKEN_WITH
                            print_string("[PARSER ERROR] Expected 'with' after struct type name at line ")
                            Let line be memory_get_int32(current_token, 16)
                            print_integer(line)
                            print_newline()
                            exit_with_code(1)
                        End If
                        parser_eat(parser, 114)  Note: eat "with"

                        Note: Parse field assignments: field value and field value...
                        Let field_names be 0
                        Let field_values be 0
                        Let field_count be 0
                        Let field_capacity be 4
                        Let ptr_size be 8
                        Let field_array_size be field_capacity multiplied by ptr_size
                        Set field_names to memory_allocate(field_array_size)
                        Set field_values to memory_allocate(field_array_size)

                        Let continue_fields be 1
                        While continue_fields is equal to 1:
                            Note: Parse field name (identifier)
                            Set current_token to memory_get_pointer(parser, 8)
                            Set token_type to memory_get_int32(current_token, 0)
                            If token_type is not equal to 53:  Note: TOKEN_IDENTIFIER
                                print_string("[PARSER ERROR] Expected field name at line ")
                                Let line be memory_get_int32(current_token, 16)
                                print_integer(line)
                                print_newline()
                                exit_with_code(1)
                            End If

                            Let field_name_token be memory_get_pointer(current_token, 8)
                            Let field_name be string_duplicate_parser(field_name_token)
                            parser_eat(parser, 53)  Note: eat field name

                            Note: Parse field value (expression)
                            Let field_value be parser_parse_additive(parser)

                            Note: Grow arrays if needed
                            If field_count is greater than or equal to field_capacity:
                                Set field_capacity to field_capacity multiplied by 2
                                Let new_field_array_size be field_capacity multiplied by ptr_size
                                Set field_names to memory_reallocate(field_names, new_field_array_size)
                                Set field_values to memory_reallocate(field_values, new_field_array_size)
                            End If

                            Note: Store field name and value
                            Let field_offset be field_count multiplied by ptr_size
                            Let name_ptr be field_names plus field_offset
                            Let value_ptr be field_values plus field_offset
                            memory_set_pointer(name_ptr, 0, field_name)
                            memory_set_pointer(value_ptr, 0, field_value)
                            Set field_count to field_count plus 1

                            Note: Check for "and" to continue or end
                            Set current_token to memory_get_pointer(parser, 8)
                            Set token_type to memory_get_int32(current_token, 0)
                            If token_type is equal to 30:  Note: TOKEN_AND
                                parser_eat(parser, 30)  Note: eat "and"
                            Otherwise:
                                Set continue_fields to 0
                            End If
                        End While

                        Note: Create EXPR_STRUCT_CONSTRUCTION expression
                        Note: Structure: type(int32), type_name(ptr at 8), field_names(ptr at 16), field_values(ptr at 24), field_count(int32 at 32)
                        Let struct_expr be memory_allocate(40)
                        memory_set_int32(struct_expr, 0, 20)  Note: EXPR_STRUCT_CONSTRUCTION
                        memory_set_pointer(struct_expr, 8, struct_type_name)
                        memory_set_pointer(struct_expr, 16, field_names)
                        memory_set_pointer(struct_expr, 24, field_values)
                        memory_set_int32(struct_expr, 32, field_count)
                        Return struct_expr
                    Otherwise:
                        Note: Not "a list", "a set", or struct - "a" is just a variable, already consumed
                        Note: Create string "a" for the variable name
                        Let var_name_a be memory_allocate(2)
                        memory_set_byte(var_name_a, 0, 97)  Note: 'a'
                        memory_set_byte(var_name_a, 1, 0)   Note: null terminator
                        Let var_expr be expression_create_variable(var_name_a)
                        Return var_expr
                    End If
                    End If
                End If
            Otherwise:
                Note: Next token after "a" is not an identifier
                Note: "a" is just a variable, already consumed
                Note: Create string "a" for the variable name
                Let var_name_a2 be memory_allocate(2)
                memory_set_byte(var_name_a2, 0, 97)  Note: 'a'
                memory_set_byte(var_name_a2, 1, 0)   Note: null terminator
                Let var_expr2 be expression_create_variable(var_name_a2)
                Return var_expr2
            End If
        End If

        Note: Check for "an Array" pattern
        If is_an is equal to 1:
            Note: Eat "an"
            parser_eat(parser, 53)
            Set current_token to memory_get_pointer(parser, 8)
            Set token_type to memory_get_integer(current_token, 0)

            If token_type is equal to 53:  Note: Next token might be "Array"
                Let next_value be memory_get_pointer(current_token, 8)
                Let is_array be string_equals(next_value, "Array")

                If is_array is equal to 1:
                    Note: Confirmed "an Array" pattern
                    parser_eat(parser, 53)  Note: eat "Array"

                    Note: Expect "of"
                    Set current_token to memory_get_pointer(parser, 8)
                    Set token_type to memory_get_integer(current_token, 0)
                    If token_type is not equal to 125:  Note: TOKEN_OF
                        print_string("[PARSER ERROR] Expected 'of' after 'an Array' at line ")
                        Let line be memory_get_integer(current_token, 16)
                        print_integer(line)
                        print_newline()
                        exit(1)
                    End If
                    parser_eat(parser, 125)  Note: of

                    Note: Parse array size (must be integer)
                    Set current_token to memory_get_pointer(parser, 8)
                    Set token_type to memory_get_integer(current_token, 0)
                    If token_type is not equal to 11:  Note: TOKEN_INTEGER
                        print_string("[PARSER ERROR] Expected integer size after 'an Array of' at line ")
                        Let line be memory_get_integer(current_token, 16)
                        print_integer(line)
                        print_newline()
                        exit(1)
                    End If
                    Let size_str be memory_get_pointer(current_token, 8)
                    Let array_size be string_to_integer(size_str)
                    parser_eat(parser, 11)  Note: eat size

                    Note: Parse element type (identifier)
                    Set current_token to memory_get_pointer(parser, 8)
                    Set token_type to memory_get_integer(current_token, 0)
                    If token_type is not equal to 53:  Note: TOKEN_IDENTIFIER
                        print_string("[PARSER ERROR] Expected type name after array size at line ")
                        Let line be memory_get_integer(current_token, 16)
                        print_integer(line)
                        print_newline()
                        exit(1)
                    End If
                    Let type_name_str be memory_get_pointer(current_token, 8)
                    Let elem_type be string_duplicate_parser(type_name_str)
                    parser_eat(parser, 53)  Note: eat type name

                    Note: Check for optional "containing"
                    Set current_token to memory_get_pointer(parser, 8)
                    Set token_type to memory_get_integer(current_token, 0)

                    If token_type is equal to 156:  Note: TOKEN_CONTAINING
                        parser_eat(parser, 156)  Note: containing

                        Note: Parse array elements (same as list)
                        Let elements be 0
                        Let element_count be 0
                        Let capacity be 4
                        Let ptr_size be 8
                        Let size be capacity multiplied by ptr_size
                        Set elements to memory_allocate(size)

                        Note: Parse first element
                        Let elem be parser_parse_expression(parser)
                        memory_set_pointer(elements, 0, elem)
                        Set element_count to 1

                        Note: Parse remaining elements
                        Let continue_parsing be 1
                        While continue_parsing is equal to 1:
                            Set current_token to memory_get_pointer(parser, 8)
                            Set token_type to memory_get_integer(current_token, 0)

                            If token_type is equal to 52:  Note: TOKEN_COMMA
                                parser_eat(parser, 52)

                                Note: Check for optional "and"
                                Set current_token to memory_get_pointer(parser, 8)
                                Set token_type to memory_get_integer(current_token, 0)
                                If token_type is equal to 30:  Note: TOKEN_AND
                                    parser_eat(parser, 30)
                                End If

                                Note: Parse next element
                                Let elem2 be parser_parse_expression(parser)

                                Note: Grow array if needed
                                If element_count is greater than or equal to capacity:
                                    Set capacity to capacity multiplied by 2
                                    Let new_size be capacity multiplied by ptr_size
                                    Set elements to memory_reallocate(elements, new_size)
                                End If

                                Let offset be element_count multiplied by ptr_size
                                Let elem_ptr be elements plus offset
                                memory_set_pointer(elem_ptr, 0, elem2)
                                Set element_count to element_count plus 1
                            Otherwise:
                                Set continue_parsing to 0
                            End If
                        End While

                        Note: Verify element count matches declared size
                        If element_count is not equal to array_size:
                            print_string("[PARSER ERROR] Array size mismatch: declared ")
                            print_integer(array_size)
                            print_string(" but got ")
                            print_integer(element_count)
                            print_string(" elements")
                            print_newline()
                            exit(1)
                        End If

                        Note: Create EXPR_ARRAY_LITERAL with elements
                        Let array_expr be memory_allocate(32)
                        memory_set_integer(array_expr, 0, 18)  Note: EXPR_ARRAY_LITERAL
                        memory_set_pointer(array_expr, 8, elements)
                        memory_set_integer(array_expr, 16, array_size)
                        memory_set_pointer(array_expr, 24, elem_type)
                        Return array_expr
                    Otherwise:
                        Note: No "containing" - just type declaration
                        Note: Create EXPR_ARRAY_TYPE (uninitialized array)
                        Let array_type be memory_allocate(32)
                        memory_set_integer(array_type, 0, 19)  Note: EXPR_ARRAY_TYPE
                        memory_set_integer(array_type, 8, array_size)
                        memory_set_pointer(array_type, 16, elem_type)
                        Return array_type
                    End If
                Otherwise:
                    Note: Not "an Array" - "an" is just a variable
                    Let var_name_an be string_duplicate_parser(token_value)
                    Let var_expr_an be expression_create_variable(var_name_an)
                    Return var_expr_an
                End If
            Otherwise:
                Note: Next token after "an" is not an identifier
                Let var_name_an2 be string_duplicate_parser(token_value)
                Let var_expr_an2 be expression_create_variable(var_name_an2)
                Return var_expr_an2
            End If
        End If
    End If

    Note: Handle identifier (including context-sensitive keywords and "list containing")
    Let can_be_id be token_can_be_identifier(token_type)
    If can_be_id is equal to 1:
        Let value_str be memory_get_pointer(current_token, 8)
        Let name be string_duplicate_parser(value_str)

        Note: Check for "list containing" syntax
        Let is_list_literal be string_equals(name, "list")
        If is_list_literal is equal to 1:
            Note: Peek at next token to see if it's "containing"
            parser_eat(parser, token_type)  Note: eat "list"
            Set current_token to memory_get_pointer(parser, 8)
            Let next_token_type be memory_get_int32(current_token, 0)

            If next_token_type is equal to 156:  Note: TOKEN_CONTAINING
                Note: This is "list containing" syntax
                parser_eat(parser, 156)  Note: eat "containing"

                Note: Parse list elements
                Let elements be 0
                Let element_count be 0
                Let capacity be 4
                Let ptr_size be 8
                Let size be capacity multiplied by ptr_size
                Set elements to memory_allocate(size)

                Note: Parse first element
                Let elem be parser_parse_expression(parser)
                memory_set_pointer(elements, 0, elem)
                Set element_count to 1

                Note: Parse remaining elements (comma or "and" separated)
                Let continue_parsing be 1
                While continue_parsing is equal to 1:
                    Set current_token to memory_get_pointer(parser, 8)
                    Set token_type to memory_get_integer(current_token, 0)

                    If token_type is equal to 52:  Note: TOKEN_COMMA
                        parser_eat(parser, 52)  Note: ,

                        Note: Check for optional "and" after comma
                        Set current_token to memory_get_pointer(parser, 8)
                        Set token_type to memory_get_integer(current_token, 0)
                        If token_type is equal to 30:  Note: TOKEN_AND
                            parser_eat(parser, 30)  Note: and
                        End If

                        Note: Parse next element
                        Let elem2 be parser_parse_expression(parser)

                        Note: Grow array if needed
                        If element_count is greater than or equal to capacity:
                            Set capacity to capacity multiplied by 2
                            Let new_size be capacity multiplied by ptr_size
                            Set elements to memory_reallocate(elements, new_size)
                        End If

                        Let offset be element_count multiplied by ptr_size
                        Let elem_ptr be elements plus offset
                        memory_set_pointer(elem_ptr, 0, elem2)
                        Set element_count to element_count plus 1
                    Otherwise:
                        Set continue_parsing to 0
                    End If
                End While

                Note: Create EXPR_LIST_LITERAL expression
                Let list_expr be memory_allocate(32)
                memory_set_int32(list_expr, 0, 17)  Note: EXPR_LIST_LITERAL
                memory_set_pointer(list_expr, 8, elements)
                memory_set_int32(list_expr, 16, element_count)
                deallocate(name)
                Return list_expr
            Otherwise:
                Note: "list" is just a variable name, not followed by "containing"
                Let var_expr be expression_create_variable(name)
                Return var_expr
            End If
        End If

        Note: Check for "set containing" syntax
        Let is_set_literal be string_equals(name, "set")
        If is_set_literal is equal to 1:
            Note: Peek at next token to see if it's "containing"
            parser_eat(parser, token_type)  Note: eat "set"
            Set current_token to memory_get_pointer(parser, 8)
            Let next_token_type be memory_get_int32(current_token, 0)

            If next_token_type is equal to 156:  Note: TOKEN_CONTAINING
                Note: This is "set containing" syntax
                parser_eat(parser, 156)  Note: eat "containing"

                Note: Parse set elements
                Let elements be 0
                Let element_count be 0
                Let capacity be 4
                Let ptr_size be 8
                Let size be capacity multiplied by ptr_size
                Set elements to memory_allocate(size)

                Note: Parse first element
                Let elem be parser_parse_expression(parser)
                memory_set_pointer(elements, 0, elem)
                Set element_count to 1

                Note: Parse remaining elements (comma or "and" separated)
                Let continue_parsing be 1
                While continue_parsing is equal to 1:
                    Set current_token to memory_get_pointer(parser, 8)
                    Set token_type to memory_get_integer(current_token, 0)

                    If token_type is equal to 52:  Note: TOKEN_COMMA
                        parser_eat(parser, 52)  Note: ,

                        Note: Check for optional "and" after comma
                        Set current_token to memory_get_pointer(parser, 8)
                        Set token_type to memory_get_integer(current_token, 0)
                        If token_type is equal to 30:  Note: TOKEN_AND
                            parser_eat(parser, 30)  Note: and
                        End If

                        Note: Parse next element
                        Let elem2 be parser_parse_expression(parser)

                        Note: Grow array if needed
                        If element_count is greater than or equal to capacity:
                            Set capacity to capacity multiplied by 2
                            Let new_size be capacity multiplied by ptr_size
                            Set elements to memory_reallocate(elements, new_size)
                        End If

                        Let offset be element_count multiplied by ptr_size
                        Let elem_ptr be elements plus offset
                        memory_set_pointer(elem_ptr, 0, elem2)
                        Set element_count to element_count plus 1
                    Otherwise:
                        Set continue_parsing to 0
                    End If
                End While

                Note: Create EXPR_SET_LITERAL expression
                Let set_expr be memory_allocate(32)
                memory_set_int32(set_expr, 0, 21)  Note: EXPR_SET_LITERAL
                memory_set_pointer(set_expr, 8, elements)
                memory_set_int32(set_expr, 16, element_count)
                deallocate(name)
                Return set_expr
            Otherwise:
                Note: "set" is just a variable name, not followed by "containing"
                Let var_expr be expression_create_variable(name)
                Return var_expr
            End If
        End If

        Note: Check for "dictionary with:" syntax
        Let is_dict_literal be string_equals(name, "dictionary")
        If is_dict_literal is equal to 1:
            Note: Peek at next token to see if it's "with"
            parser_eat(parser, token_type)  Note: eat "dictionary"
            Set current_token to memory_get_pointer(parser, 8)
            Let next_token_type be memory_get_int32(current_token, 0)

            If next_token_type is equal to 114:  Note: TOKEN_WITH
                Note: This is "dictionary with:" syntax
                parser_eat(parser, 114)  Note: eat "with"

                Note: Expect colon after "with"
                Set current_token to memory_get_pointer(parser, 8)
                Set token_type to memory_get_int32(current_token, 0)
                If token_type is not equal to 9:  Note: TOKEN_COLON
                    print_string("[PARSER ERROR] Expected ':' after 'dictionary with' at line ")
                    Let line be memory_get_int32(current_token, 16)
                    print_integer(line)
                    print_newline()
                    exit(1)
                End If
                parser_eat(parser, 9)  Note: eat ':'

                Note: Parse key-value pairs
                Let keys be 0
                Let values be 0
                Let pair_count be 0
                Let capacity be 4
                Let ptr_size be 8
                Let size be capacity multiplied by ptr_size
                Set keys to memory_allocate(size)
                Set values to memory_allocate(size)

                Note: Parse first key-value pair
                Let key_expr be parser_parse_additive(parser)

                Note: Expect "as"
                Set current_token to memory_get_pointer(parser, 8)
                Set token_type to memory_get_int32(current_token, 0)
                If token_type is not equal to 34:  Note: TOKEN_AS
                    print_string("[PARSER ERROR] Expected 'as' in dictionary literal at line ")
                    Let line be memory_get_int32(current_token, 16)
                    print_integer(line)
                    print_newline()
                    exit(1)
                End If
                parser_eat(parser, 34)  Note: eat "as"

                Let value_expr be parser_parse_additive(parser)

                memory_set_pointer(keys, 0, key_expr)
                memory_set_pointer(values, 0, value_expr)
                Set pair_count to 1

                Note: Parse remaining key-value pairs (separated by "and")
                Let continue_parsing be 1
                While continue_parsing is equal to 1:
                    Set current_token to memory_get_pointer(parser, 8)
                    Set token_type to memory_get_integer(current_token, 0)

                    If token_type is equal to 30:  Note: TOKEN_AND
                        parser_eat(parser, 30)  Note: and

                        Note: Parse next key
                        Let key_expr2 be parser_parse_additive(parser)

                        Note: Expect "as"
                        Set current_token to memory_get_pointer(parser, 8)
                        Set token_type to memory_get_int32(current_token, 0)
                        If token_type is not equal to 34:  Note: TOKEN_AS
                            print_string("[PARSER ERROR] Expected 'as' in dictionary literal at line ")
                            Let line be memory_get_int32(current_token, 16)
                            print_integer(line)
                            print_newline()
                            exit(1)
                        End If
                        parser_eat(parser, 34)  Note: eat "as"

                        Note: Parse next value
                        Let value_expr2 be parser_parse_additive(parser)

                        Note: Grow arrays if needed
                        If pair_count is greater than or equal to capacity:
                            Set capacity to capacity multiplied by 2
                            Let new_size be capacity multiplied by ptr_size
                            Set keys to memory_reallocate(keys, new_size)
                            Set values to memory_reallocate(values, new_size)
                        End If

                        Let offset be pair_count multiplied by ptr_size
                        Let key_ptr be keys plus offset
                        Let value_ptr be values plus offset
                        memory_set_pointer(key_ptr, 0, key_expr2)
                        memory_set_pointer(value_ptr, 0, value_expr2)
                        Set pair_count to pair_count plus 1
                    Otherwise:
                        Set continue_parsing to 0
                    End If
                End While

                Note: Create EXPR_DICT_LITERAL expression
                Note: Structure: type(int32), keys(ptr at 8), values(ptr at 16), pair_count(int32 at 24)
                Let dict_expr be memory_allocate(32)
                memory_set_int32(dict_expr, 0, 22)  Note: EXPR_DICT_LITERAL
                memory_set_pointer(dict_expr, 8, keys)
                memory_set_pointer(dict_expr, 16, values)
                memory_set_int32(dict_expr, 24, pair_count)
                deallocate(name)
                Return dict_expr
            Otherwise:
                Note: "dictionary" is just a variable name, not followed by "with"
                Let var_expr be expression_create_variable(name)
                Return var_expr
            End If
        End If

        Note: Check if this identifier is a known type name
        Let is_type be 0
        Let prog be memory_get_pointer(parser, PARSER_CURRENT_PROGRAM_OFFSET)
        If prog is equal to 0:
        End If
        If prog is not equal to 0:
            Let type_count be memory_get_int32(prog, PROGRAM_TYPE_COUNT)
            If type_count is equal to 0:
            Otherwise:
            End If
            Let types be memory_get_pointer(prog, PROGRAM_TYPES)
            If types is equal to 0:
            Otherwise:
            End If
            Let i be 0
            Let continue_type_search be 1
            While continue_type_search is equal to 1:
                Let search_done be 0
                If i is greater than or equal to type_count:
                    Let search_done be 1
                End If
                If search_done is equal to 1:
                    Let continue_type_search be 0
                End If
                If search_done is equal to 0:
                    Let ptr_size be 8
                    Let offset be i multiplied by ptr_size
                    Let type_ptr be types plus offset
                    Let type_def be memory_get_pointer(type_ptr, 0)
                    Let type_name be memory_get_pointer(type_def, 0)
                    Let result be string_equals(type_name, name)
                    If result is equal to 1:
                        Set is_type to 1
                        Let continue_type_search be 0  Note: Break loop
                    End If
                    Set i to i plus 1
                End If
            End While
        End If

        Let dummy7 be parser_eat(parser, token_type)

        Note: Phase 5: Check for explicit variant syntax "TypeName as VariantName"
        Let current_token_as_check be memory_get_pointer(parser, 8)
        If current_token_as_check is not equal to 0:
            Let token_type_as_check be memory_get_integer(current_token_as_check, 0)
            If token_type_as_check is equal to 34:  Note: TOKEN_AS
                Note: Explicit syntax: name is the type, next identifier is the variant
                parser_eat(parser, 34)

                Let variant_token be memory_get_pointer(parser, 8)
                If variant_token is equal to 0:
                    print_string("[PARSER ERROR] Expected variant name after 'as'")
                    Return 0
                End If
                Let variant_token_type be memory_get_integer(variant_token, 0)
                If variant_token_type is not equal to 53:  Note: TOKEN_IDENTIFIER
                    print_string("[PARSER ERROR] Expected variant name after 'as'")
                    Return 0
                End If
                Let variant_name_explicit be string_duplicate_parser(memory_get_pointer(variant_token, 8))
                parser_eat(parser, 53)

                Note: Create variant constructor with type_name=name, variant_name=variant_name_explicit
                Let expr_size be 40
                Let expr be memory_allocate(expr_size)
                memory_set_int32(expr, 0, EXPR_VARIANT_CONSTRUCTOR)
                memory_set_pointer(expr, 8, name)
                memory_set_pointer(expr, 16, variant_name_explicit)
                memory_set_integer(expr, 24, 0)
                memory_set_int32(expr, 32, 0)

                Note: Check for optional "with" for fields
                Let with_token be memory_get_pointer(parser, 8)
                If with_token is not equal to 0:
                    Let with_token_type be memory_get_integer(with_token, 0)
                    If with_token_type is equal to 114:  Note: TOKEN_WITH
                        parser_eat(parser, 114)
                        Note: TODO: Parse field values
                    End If
                End If

                Return expr
            End If
        End If

        Note: Check if this identifier is itself a variant name (fieldless variant)
        Note: Only check if next token is NOT "with" (otherwise it's a variant constructor with fields)
        Let current_token_peek be memory_get_pointer(parser, 8)
        Let token_type_peek be memory_get_integer(current_token_peek, 0)
        Let variant_name_check be name
        Let adt_type_for_fieldless be 0
        Let should_check_fieldless be 1
        If token_type_peek is equal to 114:  Note: TOKEN_WITH
            Set should_check_fieldless to 0
        End If
        If should_check_fieldless is equal to 1:
            If prog is not equal to 0:
                Let type_count_check be memory_get_int32(prog, PROGRAM_TYPE_COUNT)
                Let types_check be memory_get_pointer(prog, PROGRAM_TYPES)
                Let ic be 0
                While ic is less than type_count_check:
                    Let type_ptr_check be types_check plus ic multiplied by 8
                    Let type_def_check be memory_get_pointer(type_ptr_check, 0)
                    Let type_kind_check be memory_get_int32(type_def_check, TYPEDEFINITION_KIND_OFFSET)
                    If type_kind_check is equal to TYPE_KIND_VARIANT:
                        Let variant_count_check be memory_get_int32(type_def_check, TYPEDEFINITION_DATA_VARIANT_VARIANT_COUNT_OFFSET)
                        Let variants_check be memory_get_pointer(type_def_check, TYPEDEFINITION_DATA_VARIANT_VARIANTS_OFFSET)
                        Let jc be 0
                        While jc is less than variant_count_check:
                            Let variant_ptr_check be variants_check plus jc multiplied by VARIANT_SIZE
                            Let vname_check be memory_get_pointer(variant_ptr_check, 0)
                            If string_equals(vname_check, variant_name_check) is equal to 1:
                                Set adt_type_for_fieldless to type_def_check
                                Set jc to variant_count_check  Note: Break
                                Set ic to type_count_check  Note: Break outer
                            End If
                            Set jc to jc plus 1
                        End While
                    End If
                    Set ic to ic plus 1
                End While
            End If
        End If

        If adt_type_for_fieldless is not equal to 0:
            Note: This is a fieldless variant constructor
            Let expr_size be 40
            Let expr be memory_allocate(expr_size)
            memory_set_int32(expr, 0, EXPR_VARIANT_CONSTRUCTOR)
            Let adt_type_name be memory_get_pointer(adt_type_for_fieldless, 0)
            memory_set_pointer(expr, 8, adt_type_name)  Note: type_name
            memory_set_pointer(expr, 16, variant_name_check)  Note: variant_name
            memory_set_integer(expr, 24, 0)  Note: field_values
            memory_set_int32(expr, 32, 0)  Note: field_count
            Return expr
        End If

        Note: Check if this is a variant constructor (with keyword)
        Let current_token5 be memory_get_pointer(parser, 8)
        Let token_type5 be memory_get_integer(current_token5, 0)

        If token_type5 is equal to 124:
            Note: Check if this identifier is a variant name within any ADT type
            Let variant_name be name
            Let adt_type be 0

            Note: Find the ADT type that contains this variant
            If prog is not equal to 0:
                Let type_count be memory_get_integer(prog, PROGRAM_TYPE_COUNT)
                Let types be memory_get_pointer(prog, PROGRAM_TYPES)
                Let i be 0
                Let continue_outer be 1
                While continue_outer is equal to 1:
                    Let is_done be 0
                    If i is greater than or equal to type_count:
                        Let is_done be 1
                    End If
                    If is_done is equal to 1:
                        Let continue_outer be 0
                    End If
                    If is_done is equal to 0:
                        Let ptr_size be 8
                        Let offset be i multiplied by ptr_size
                        Let type_ptr be types plus offset
                        Let type_def be memory_get_pointer(type_ptr, 0)
                        Let type_kind be memory_get_integer(type_def, 8)

                        Note: Check if this is a variant type
                        Let is_variant_type be 0
                        If type_kind is equal to TYPE_KIND_VARIANT:
                            Let is_variant_type be 1
                        End If
                        If is_variant_type is equal to 1:
                            Let variant_count be memory_get_integer(type_def, 24)
                            Let variants be memory_get_pointer(type_def, 16)
                            Let j be 0
                            Let continue_inner be 1
                            While continue_inner is equal to 1:
                                Let inner_done be 0
                                If j is greater than or equal to variant_count:
                                    Let inner_done be 1
                                End If
                                If inner_done is equal to 1:
                                    Let continue_inner be 0
                                End If
                                If inner_done is equal to 0:
                                    Let variant_offset be j multiplied by VARIANT_SIZE
                                    Let variant_ptr be variants plus variant_offset
                                    Let variant_name_ptr be memory_get_pointer(variant_ptr, 0)
                                    Let variant_match be string_equals(variant_name_ptr, variant_name)
                                    If variant_match is equal to 1:
                                        Let adt_type be type_def
                                        Let continue_inner be 0  Note: Break inner loop
                                        Let continue_outer be 0  Note: Break outer loop
                                    End If
                                    Let j be j plus 1
                                End If
                            End While
                        End If
                        Let i be i plus 1
                    End If
                End While
            End If

            If adt_type is not equal to 0:
                Note: This is a variant constructor
                Let expr_size be 40
                Let expr be memory_allocate(expr_size)
                memory_set_int32(expr, 0, EXPR_VARIANT_CONSTRUCTOR)
                Let adt_type_name be memory_get_integer(adt_type, 0)
                memory_set_pointer(expr, 8, string_duplicate_parser(adt_type_name))  Note: type_name
                memory_set_pointer(expr, 16, variant_name)  Note: variant_name
                memory_set_integer(expr, 24, 0)  Note: field_values
                memory_set_int32(expr, 32, 0)  Note: field_count

                Note: Check if there are fields (optional "with" keyword)
                Let current_token_check be memory_get_pointer(parser, 8)
                Let token_type_check be memory_get_integer(current_token_check, 0)
                If token_type_check is equal to 114:  Note: TOKEN_WITH
                    parser_eat(parser, 114)
                    Note: TODO: Parse fields and store in field_values
                End If

                Return expr
            End If
        End If

        Note: Check if this is a function call - DISABLED to use postfix parsing instead
        Let check_func_call be 0
        Note: Completely bypass this problematic logic - all function calls use postfix parsing

        If check_func_call is equal to 1:
            Let dummy9 be parser_eat(parser, 51)

            Note: Parse arguments
            Let arguments be 0
            Let argument_count be 0
            Let argument_capacity be 0

            Let continue_loop be 1
            While continue_loop is equal to 1:
                Let current_token7 be memory_get_pointer(parser, 8)
                Let token_type7 be memory_get_integer(current_token7, 0)

                Note: Check for closing paren
                If token_type7 is equal to 49:
                    Set continue_loop to 0
                End If

                Note: Check for EOF
                If token_type7 is equal to 0:
                    Set continue_loop to 0
                End If

                Note: Process argument
                Let should_process_arg be 0
                If token_type7 is not equal to 49:
                    If token_type7 is not equal to 0:
                        Set should_process_arg to 1
                    End If
                End If

                If should_process_arg is equal to 1:
                    If argument_count is greater than or equal to argument_capacity:
                        If argument_capacity is equal to 0:
                            Set argument_capacity to 4
                        End If
                        If argument_capacity is not equal to 4:
                            Set argument_capacity to argument_capacity multiplied by 2
                        End If
                        Let ptr_size be 8
                        Let new_size be argument_capacity multiplied by ptr_size
                        Set arguments to memory_reallocate(arguments, new_size)
                    End If

                    Let arg be parser_parse_additive(parser)
                    Let ptr_size be 8
                    Let offset be argument_count multiplied by ptr_size
                    Let arg_ptr be arguments plus offset
                    memory_set_pointer(arg_ptr, 0, arg)
                    Set argument_count to argument_count plus 1

                    Let current_token8 be memory_get_pointer(parser, 8)
                    Let token_type8 be memory_get_integer(current_token8, 0)

                    Note: Check what comes after the argument
                    If token_type8 is equal to 49:
                        Set continue_loop to 0
                    Otherwise If token_type8 is equal to 52:
                        Let dummy10 be parser_eat(parser, 52)
                    Otherwise:
                        Note: Error: expected comma or closing paren
                        Let error_msg be "[PARSER ERROR] Expected ',' or ')' in function arguments at line "
                        print_string(error_msg)
                        Let line be memory_get_int32(current_token8, 16)
                        print_integer(line)
                        print_newline()
                        exit_with_code(1)
                    End If
                End If
            End While

            Let dummy16 be parser_eat(parser, 52)
            Let expr be expression_create_function_call(name, arguments, argument_count)
            Return expr
        End If

        Note: Handle type name
        If is_type is equal to 1:
            Note: This is a type name, create a type expression
            Let expr_size be 32  Note: Match other expression types for safety
            Let expr be memory_allocate(expr_size)
            memory_set_int32(expr, 0, EXPR_TYPE_NAME)
            memory_set_pointer(expr, 8, name)
            Return expr
        End If

        Note: Default case: variable expression
        Let expr be expression_create_variable(name)
        Return expr
    End If

    Note: Handle true literal
    If token_type is equal to 134:  Note: TOKEN_TRUE
        Let dummy8 be parser_eat(parser, 134)
        Let expr be expression_create_integer(1)
        Return expr
    End If

    Note: Handle false literal
    If token_type is equal to 135:  Note: TOKEN_FALSE
        Let dummy9 be parser_eat(parser, 135)
        Let expr be expression_create_integer(0)
        Return expr
    End If

    Note: Handle negative literal
    If token_type is equal to 133:  Note: TOKEN_NEGATIVE
        Let dummy10 be parser_eat(parser, 133)
        Note: Expect an integer after "negative"
        Let neg_token be memory_get_pointer(parser, 8)
        Let neg_token_type be memory_get_integer(neg_token, 0)
        If neg_token_type is not equal to 11:  Note: TOKEN_INTEGER
            print_string("[PARSER ERROR] Expected integer after 'negative' at line ")
            Let err_line be memory_get_integer(neg_token, 16)
            print_integer(err_line)
            print_newline()
            exit_with_code(1)
        End If
        Let value_str be memory_get_pointer(neg_token, 8)
        Let value be string_to_integer(value_str)
        Let negative_value be -value
        Let dummy11 be parser_eat(parser, 11)
        Let expr be expression_create_integer(negative_value)
        Return expr
    End If

    Note: Error: unexpected token
    Let error_msg be "[PARSER ERROR] Expected integer or identifier at line "
    print_string(error_msg)
    Let line be memory_get_integer(current_token, 16)
    print_integer(line)
    print_newline()
    exit_with_code(1)
    Return 0  Note: Unreachable
End Process

Note: Parser parse return statement - handles "Return expression"
Process called "parser_parse_return_statement" takes parser as Integer returns Integer:
    Let dummy be parser_eat(parser, 7)
    Let expr be parser_parse_expression(parser)
    Let stmt be statement_create_return(expr)
    Return stmt
End Process

Note: Parser parse break statement - handles "Break"
Process called "parser_parse_break_statement" takes parser as Integer returns Integer:
    Let dummy be parser_eat(parser, 44)
    Return statement_create_break(0)
End Process

Note: Parser parse continue statement - handles "Continue"
Process called "parser_parse_continue_statement" takes parser as Integer returns Integer:
    Let dummy be parser_eat(parser, 45)
    Return statement_create_continue(0)
End Process

Note: Parser parse print statement - handles "Print expression" or "Display expression"
Process called "parser_parse_print_statement" takes parser as Integer returns Integer:
    Let dummy be parser_eat(parser, 47)

    Note: Check if next token is LPAREN - Display/Print should NOT use function call syntax
    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_int32(current_token, 0)
    If token_type is equal to 48:  Note: TOKEN_LPAREN
        print_string("[PARSER ERROR] Display/Print is a statement and should not use parentheses. Use 'Display expression' not 'Display(expression)' at line ")
        Let err_line be memory_get_integer(current_token, 16)
        print_integer(err_line)
        print_newline()
        exit_with_code(1)
    End If

    Let expr be parser_parse_expression(parser)
    Return statement_create_print(expr)
End Process

Note: Parser parse statement block - parses block of statements until END/OTHERWISE/EOF
Process called "parser_parse_statement_block" takes parser as Integer, count_ptr as Integer returns Integer:
    Let statements be 0
    Let capacity be 0
    memory_set_integer(count_ptr, 0, 0)

    Let continue_loop be 1
    While continue_loop is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_int32(current_token, 0)

        Note: Check for block termination conditions
        If token_type is equal to 8:
            Set continue_loop to 0
        End If
        If token_type is equal to 19:
            Set continue_loop to 0
        End If
        If token_type is equal to 113:  Note: TOKEN_WHEN
            Set continue_loop to 0
        End If
        If token_type is equal to 0:
            Set continue_loop to 0
        End If

        If continue_loop is equal to 1:
            Let stmt be 0

            Note: Parse different statement types
            If token_type is equal to 12:
                Set stmt to parser_parse_let_statement(parser)
            End If

            If token_type is equal to 14:
                Set stmt to parser_parse_set_statement(parser)
            End If

            If token_type is equal to 7:
                Set stmt to parser_parse_return_statement(parser)
            End If

            If token_type is equal to 44:
                Set stmt to parser_parse_break_statement(parser)
            End If

            If token_type is equal to 45:
                Set stmt to parser_parse_continue_statement(parser)
            End If

            If token_type is equal to 47:
                Set stmt to parser_parse_print_statement(parser)
            End If

            If token_type is equal to 18:
                Set stmt to parser_parse_if_statement(parser)
            End If

            If token_type is equal to 20:
                Set stmt to parser_parse_while_statement(parser)
            End If

            If token_type is equal to 121:
                Set stmt to parser_parse_inline_assembly_statement(parser)
            End If

            If token_type is equal to 112:
                Set stmt to parser_parse_match_statement(parser)
            End If

            If token_type is equal to 143:  Note: TOKEN_FOR
                Set stmt to parser_parse_for_range_statement(parser)
            End If

            Note: Handle implicit compound assignment: Increase/Decrease/Multiply/Divide X by Y
            Note: TOKEN_INCREASE is 139, TOKEN_DECREASE is 140
            Note: TOKEN_MULTIPLY is 141, TOKEN_DIVIDE is 142
            If token_type is equal to 139:
                Set stmt to parser_parse_implicit_compound_assign(parser, 0)
            End If

            If token_type is equal to 140:
                Set stmt to parser_parse_implicit_compound_assign(parser, 1)
            End If

            If token_type is equal to 141:
                Set stmt to parser_parse_implicit_compound_assign(parser, 2)
            End If

            If token_type is equal to 142:
                Set stmt to parser_parse_implicit_compound_assign(parser, 3)
            End If

            Note: Handle identifier - could be function call
            If token_type is equal to 53:
                Let expr be parser_parse_expression(parser)
                Let expr_type be memory_get_int32(expr, 0)
                If expr_type is equal to EXPR_FUNCTION_CALL:
                    Set stmt to statement_create_expression(expr)
                End If
                If expr_type is not equal to EXPR_FUNCTION_CALL:
                    Let error_msg be "[PARSER ERROR] Only function calls can be used as statements (expr_type="
                    print_string(error_msg)
                    print_integer(expr_type)
                    print_string(", expected ")
                    print_integer(EXPR_FUNCTION_CALL)
                    print_string(") at line ")
                    Let line be memory_get_int32(current_token, 16)
                    print_integer(line)
                    print_newline()
                    exit_with_code(1)
                End If
            End If

            Note: Handle builtin function calls
            Let is_builtin be parser_is_builtin_function_token(token_type)
            If is_builtin is equal to 1:
                Let expr be parser_parse_expression(parser)
                Let expr_type be memory_get_int32(expr, 0)
                If expr_type is equal to EXPR_BUILTIN_CALL:
                    Set stmt to statement_create_expression(expr)
                End If
                If expr_type is not equal to EXPR_BUILTIN_CALL:
                    Let error_msg be "[PARSER ERROR] Invalid builtin function statement at line "
                    print_string(error_msg)
                    Let line be memory_get_int32(current_token, 16)
                    print_integer(line)
                    print_newline()
                    exit_with_code(1)
                End If
            End If

            Note: If no statement was parsed, break
            If stmt is equal to 0:
                Set continue_loop to 0
            End If

            Note: Add statement to array if parsed
            If stmt is not equal to 0:
                Let current_count be memory_get_integer(count_ptr, 0)
                If current_count is greater than or equal to capacity:
                    If capacity is equal to 0:
                        Set capacity to 4
                    Otherwise:
                        Set capacity to capacity multiplied by 2
                    End If
                    Let ptr_size be 8
                    Let new_size be capacity multiplied by ptr_size
                    Set statements to memory_reallocate(statements, new_size)
                End If

                Let ptr_size be 8
                Let offset be current_count multiplied by ptr_size
                Let stmt_ptr be statements plus offset
                memory_set_pointer(stmt_ptr, 0, stmt)

                Let new_count be current_count plus 1
                memory_set_integer(count_ptr, 0, new_count)
            End If
        End If
    End While

    Return statements
End Process

Note: Parser parse while statement - handles "While condition: ... End While"
Process called "parser_parse_while_statement" takes parser as Integer returns Integer:
    Let dummy1 be parser_eat(parser, 20)
    Let condition be parser_parse_comparison(parser)
    Let dummy2 be parser_eat(parser, 9)

    Let body_count_ptr be memory_allocate(8)
    Let body be parser_parse_statement_block(parser, body_count_ptr)
    Let body_count be memory_get_integer(body_count_ptr, 0)
    deallocate(body_count_ptr)

    Let dummy3 be parser_eat(parser, 8)
    Let dummy4 be parser_eat(parser, 20)

    Let while_stmt be statement_create_while(condition, body, body_count)
    Return while_stmt
End Process

Note: Parser parse for-range statement - handles "For i from start to end by step: ... End For"
Note: Also handles "For each item in collection: ... End For"
Process called "parser_parse_for_range_statement" takes parser as Integer returns Integer:
    parser_eat(parser, 143)  Note: TOKEN_FOR

    Note: Check if this is "for each" or "for from" by looking at next token
    Let peek_token be memory_get_pointer(parser, 8)
    Let peek_token_type be memory_get_int32(peek_token, 0)

    Note: Handle "For each item in collection"
    If peek_token_type is equal to 145:  Note: TOKEN_EACH
        parser_eat(parser, 145)  Note: TOKEN_EACH

        Note: Parse loop variable name
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_int32(current_token, 0)
        Let var_name_temp be memory_get_pointer(current_token, 8)
        Let var_name be string_duplicate(var_name_temp)
        parser_eat(parser, token_type)

        parser_eat(parser, 152)  Note: TOKEN_IN
        Let collection_expr be parser_parse_expression(parser)
        parser_eat(parser, 9)    Note: TOKEN_COLON

        Let body_count_ptr be memory_allocate(8)
        Let body be parser_parse_statement_block(parser, body_count_ptr)
        Let body_count be memory_get_integer(body_count_ptr, 0)
        deallocate(body_count_ptr)

        parser_eat(parser, 8)    Note: TOKEN_END
        parser_eat(parser, 143)  Note: TOKEN_FOR

        Let foreach_stmt be statement_create_for_each(var_name, collection_expr, body, body_count)
        Return foreach_stmt
    End If

    Note: Handle "For i from start to end by step"
    Note: Parse loop variable name
    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_int32(current_token, 0)
    Let var_name_temp be memory_get_pointer(current_token, 8)
    Let var_name be string_duplicate(var_name_temp)
    parser_eat(parser, token_type)

    parser_eat(parser, 144)  Note: TOKEN_FROM
    Let start_expr be parser_parse_expression(parser)

    parser_eat(parser, 15)  Note: TOKEN_TO
    Let end_expr be parser_parse_expression(parser)

    Note: Check for optional "by step"
    Let current_token2 be memory_get_pointer(parser, 8)
    Let token_type2 be memory_get_int32(current_token2, 0)
    Let step_expr be 0
    If token_type2 is equal to 38:  Note: TOKEN_BY
        parser_eat(parser, 38)
        Set step_expr to parser_parse_expression(parser)
    End If

    parser_eat(parser, 9)  Note: TOKEN_COLON

    Let body_count_ptr be memory_allocate(8)
    Let body be parser_parse_statement_block(parser, body_count_ptr)
    Let body_count be memory_get_integer(body_count_ptr, 0)
    deallocate(body_count_ptr)

    parser_eat(parser, 8)   Note: TOKEN_END
    parser_eat(parser, 143)  Note: TOKEN_FOR

    Let for_stmt be statement_create_for_range(var_name, start_expr, end_expr, step_expr, body, body_count)
    Return for_stmt
End Process

Note: Parser parse if statement - handles "If condition: ... Otherwise If ... Otherwise ... End If"
Note: Handle elif/else chains with proper nesting
Process called "parser_parse_if_statement" takes parser as Integer returns Integer:
    Let dummy1 be parser_eat(parser, 18)
    Let condition be parser_parse_expression(parser)
    Let dummy2 be parser_eat(parser, 9)

    Let if_body_count_ptr be memory_allocate(8)
    Let if_body be parser_parse_statement_block(parser, if_body_count_ptr)
    Let if_body_count be memory_get_integer(if_body_count_ptr, 0)
    deallocate(if_body_count_ptr)

    Let else_body be 0
    Let else_body_count be 0

    Note: Handle elif/else chains
    Let continue_parsing be 1
    While continue_parsing is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 19:
            Let dummy3 be parser_eat(parser, 19)
            Let next_token be memory_get_pointer(parser, 8)
            Let next_token_type be memory_get_integer(next_token, 0)

            Note: Check if this is "Otherwise If" (elif)
            If next_token_type is equal to 18:
                Let dummy4 be parser_eat(parser, 18)
                Let elif_condition be parser_parse_expression(parser)
                Let dummy5 be parser_eat(parser, 9)

                Let elif_body_count_ptr be memory_allocate(8)
                Let elif_body be parser_parse_statement_block(parser, elif_body_count_ptr)
                Let elif_body_count be memory_get_integer(elif_body_count_ptr, 0)
                deallocate(elif_body_count_ptr)

                Note: Create nested if statement for elif
                Let elif_stmt be statement_create_if(elif_condition, elif_body, elif_body_count, 0, 0)

                Note: Chain elifs by nesting them
                Note: Save the current count to detect if this is the first elif
                Let prev_count be else_body_count

                If prev_count is equal to 0:
                    Note: First elif - create else body with one statement
                    Set else_body to memory_allocate(8)
                    memory_set_pointer(else_body, 0, elif_stmt)
                    Set else_body_count to 1
                End If

                If prev_count is greater than 0:
                    Note: Subsequent elif - traverse chain to find the last elif
                    Let current_elif be memory_get_pointer(else_body, 0)
                    Let current_elif_else be memory_get_pointer(current_elif, 32)

                    Note: Keep following the chain until we find an elif with no else
                    While current_elif_else is not equal to 0:
                        Set current_elif to memory_get_pointer(current_elif_else, 0)
                        Set current_elif_else to memory_get_pointer(current_elif, 32)
                    End While

                    Note: Now current_elif is the last elif in the chain
                    Note: Create new else body for the last elif with just this new elif
                    Let new_elif_else be memory_allocate(8)
                    memory_set_pointer(new_elif_else, 0, elif_stmt)

                    Note: Attach to last elif
                    memory_set_pointer(current_elif, 32, new_elif_else)
                    memory_set_integer(current_elif, 40, 1)
                End If
            End If

            Note: Handle regular "Otherwise" clause
            If next_token_type is not equal to 18:
                Let dummy6 be parser_eat(parser, 9)
                Let final_else_count_ptr be memory_allocate(8)
                Let final_else_body be parser_parse_statement_block(parser, final_else_count_ptr)
                Let final_else_count be memory_get_integer(final_else_count_ptr, 0)
                deallocate(final_else_count_ptr)

                If else_body is equal to 0:
                    Note: No previous elifs, simple else
                    Set else_body to final_else_body
                    Set else_body_count to final_else_count
                End If

                If else_body is not equal to 0:
                    If else_body is not equal to final_else_body:
                        Note: Attach final else to the last elif in the chain
                        Note: Traverse the chain to find the actual last elif
                        Let current_elif be memory_get_pointer(else_body, 0)
                        Let current_elif_else be memory_get_pointer(current_elif, 32)

                        Note: Keep following the chain until we find an elif with no else
                        While current_elif_else is not equal to 0:
                            Set current_elif to memory_get_pointer(current_elif_else, 0)
                            Set current_elif_else to memory_get_pointer(current_elif, 32)
                        End While

                        Note: Now current_elif is the last elif in the chain
                        memory_set_pointer(current_elif, 32, final_else_body)
                        memory_set_integer(current_elif, 40, final_else_count)
                    End If
                End If

                Set continue_parsing to 0  Note: Final else ends the chain
            End If
        End If

        If token_type is not equal to 19:
            Set continue_parsing to 0
        End If
    End While

    Let dummy7 be parser_eat(parser, 8)
    Let dummy8 be parser_eat(parser, 18)

    Return statement_create_if(condition, if_body, if_body_count, else_body, else_body_count)
End Process

Note: Parser parse match statement - handles "Match expr: When pattern: ... End Match"
Process called "parser_parse_match_statement" takes parser as Integer returns Integer:
    parser_eat(parser, 112)  Note: Eat TOKEN_MATCH
    Let match_expr be parser_parse_expression(parser)
    parser_eat(parser, 9)  Note: Eat colon

    Note: Parse When clauses
    Let when_capacity be 4
    Let when_clauses be memory_allocate(when_capacity multiplied by 24)  Note: Array of when clause structs (24 bytes each)
    Let when_count be 0

    Let continue_parsing be 1
    While continue_parsing is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        If current_token is equal to 0:
            Set continue_parsing to 0
        End If
        If current_token is not equal to 0:
            Let token_type be memory_get_int32(current_token, 0)

            If token_type is equal to 113:  Note: TOKEN_WHEN
                parser_eat(parser, 113)

                Note: Parse pattern (for now, just an expression - literal only)
                Let pattern_expr be parser_parse_expression(parser)
                parser_eat(parser, 9)  Note: Eat colon

                Note: Parse body statements
                Let body_count_ptr be memory_allocate(8)
                Let body_stmts be parser_parse_statement_block(parser, body_count_ptr)
                Let body_count be memory_get_integer(body_count_ptr, 0)
                deallocate(body_count_ptr)

                Note: Grow array if needed
                If when_count is greater than or equal to when_capacity:
                    Set when_capacity to when_capacity multiplied by 2
                    Set when_clauses to memory_reallocate(when_clauses, when_capacity multiplied by 24)
                End If

                Note: Store when clause: pattern (8 bytes), body (8 bytes), body_count (8 bytes)
                Let clause_offset be when_count multiplied by 24
                Let clause_ptr be when_clauses plus clause_offset
                memory_set_pointer(clause_ptr, 0, pattern_expr)
                memory_set_pointer(clause_ptr, 8, body_stmts)
                memory_set_integer(clause_ptr, 16, body_count)
                Set when_count to when_count plus 1
            Otherwise If token_type is equal to 8:  Note: TOKEN_END
                parser_eat(parser, 8)
                parser_eat(parser, 112)  Note: Eat TOKEN_MATCH
                Set continue_parsing to 0
            Otherwise:
                Set continue_parsing to 0
            End If
        End If
    End While

    Note: Create match statement
    Let stmt be memory_allocate(32)
    memory_set_int32(stmt, 0, STMT_MATCH)
    memory_set_pointer(stmt, STMT_MATCH_EXPR, match_expr)
    memory_set_pointer(stmt, STMT_MATCH_WHEN_CLAUSES, when_clauses)
    memory_set_int32(stmt, STMT_MATCH_WHEN_COUNT, when_count)

    Return stmt
End Process

Note: Parser parse inline assembly statement - handles "Inline Assembly: ... End Assembly"
Note: NEW: Raw text mode - no string literals, no Note: comments, # comments allowed
Process called "parser_parse_inline_assembly_statement" takes parser as Integer returns Integer:
    Note: Inline Assembly:
    Note:     # This is an assembly comment
    Note:     movq $42, %rax
    Note:     syscall
    Note: End Assembly

    Let dummy1 be parser_eat(parser, 121)  Note: Eat "Inline"
    Let dummy2 be parser_eat(parser, 122)  Note: Eat "Assembly"

    Note: Don't eat ":" via parser - we need lexer to be right at it for raw reading
    Note: Get lexer from parser to read raw text
    Let lexer be memory_get_pointer(parser, 0)

    Note: Manually skip the ":" character
    Let colon_char be memory_get_byte(lexer, 20)  Note: Should be ':'
    Let dummy_colon be lexer_advance(lexer)

    Note: Allocate statement: type (4 bytes) + raw_text_ptr (8 bytes) + text_length (4 bytes) = 20 bytes
    Let stmt be allocate(32)
    Let stmt_type be 16  Note: STMT_INLINE_ASSEMBLY
    memory_set_int32(stmt, 0, stmt_type)

    Note: Read raw text until we hit "End Assembly"
    Let raw_text be parser_read_raw_assembly_until_end(parser, lexer)

    Note: Store raw text pointer and length
    Let text_length be string_length(raw_text)
    memory_set_pointer(stmt, 8, raw_text)
    memory_set_int32(stmt, 16, text_length)

    Note: After reading raw text, parser needs to get next token
    Note: The lexer has consumed up to and including "End Assembly"
    Note: We need to advance parser to next token after "End Assembly"
    Let dummy_advance be parser_advance(parser)

    Return stmt
End Process

Note: Read raw assembly text until "End Assembly" is encountered
Note: This reads character by character, preserving # comments and all whitespace
Process called "parser_read_raw_assembly_until_end" takes parser as Integer, lexer as Integer returns Integer:
    Note: Allocate buffer for raw text (max 8192 bytes)
    Let buffer_size be 8192
    Let buffer be allocate(buffer_size)
    Let buffer_pos be 0

    Note: Read characters until we see "End Assembly"
    Let continue_reading be 1
    While continue_reading is equal to 1:
        Let current_char be memory_get_byte(lexer, 20)  Note: lexer->current_char

        Note: Check for end of file
        If current_char is equal to 0:
            Set continue_reading to 0
        Otherwise:
            Note: Check if we're at potential "End Assembly"
            Let e_char be 69  Note: 'E'
            If current_char is equal to e_char:
                Note: Try to match "End Assembly"
                Let matches be parser_try_match_end_assembly(lexer)
                If matches is equal to 1:
                    Set continue_reading to 0
                Otherwise:
                    Note: Not "End Assembly", just store 'E' and continue
                    memory_set_byte(buffer, buffer_pos, current_char)
                    Set buffer_pos to buffer_pos plus 1
                    Let dummy be lexer_advance(lexer)
                End If
            Otherwise:
                Note: Regular character, store it
                memory_set_byte(buffer, buffer_pos, current_char)
                Set buffer_pos to buffer_pos plus 1
                Let dummy be lexer_advance(lexer)
            End If
        End If

        Note: Check buffer overflow
        If buffer_pos is greater than or equal to buffer_size minus 1:
            print_string("[PARSER ERROR] Inline assembly block too large (max 8192 bytes)\n")
            exit_with_code(1)
        End If
    End While

    Note: Null-terminate the buffer
    memory_set_byte(buffer, buffer_pos, 0)

    Note: Create final string
    Let final_string be string_duplicate_parser(buffer)
    deallocate(buffer)

    Return final_string
End Process

Note: Try to match "End Assembly" at current lexer position
Note: Returns 1 if match, 0 if not. Does NOT consume tokens if no match.
Process called "parser_try_match_end_assembly" takes lexer as Integer returns Integer:
    Note: Save current lexer position
    Let saved_pos be memory_get_integer(lexer, 0)  Note: lexer->position
    Let saved_char be memory_get_byte(lexer, 20)   Note: lexer->current_char

    Note: Try to match "End Assembly" (with optional whitespace)
    Note: Expected pattern: "End" + whitespace + "Assembly"

    Note: Match "End"
    Let matches_end be lexer_try_match_word(lexer, "End")
    If matches_end is equal to 0:
        Note: Restore position and return failure
        memory_set_integer(lexer, 0, saved_pos)
        memory_set_byte(lexer, 20, saved_char)
        Return 0
    End If

    Note: Skip whitespace
    Let dummy be lexer_skip_whitespace(lexer)

    Note: Match "Assembly"
    Let matches_assembly be lexer_try_match_word(lexer, "Assembly")
    If matches_assembly is equal to 0:
        Note: Restore position and return failure
        memory_set_integer(lexer, 0, saved_pos)
        memory_set_byte(lexer, 20, saved_char)
        Return 0
    End If

    Note: Success! Don't restore position, we consumed "End Assembly"
    Return 1
End Process

Note: Try to match a specific word at current position
Note: Returns 1 if match, 0 if not. Consumes characters on success.
Process called "lexer_try_match_word" takes lexer as Integer, word as Integer returns Integer:
    Let word_len be string_length(word)
    Let i be 0

    While i is less than word_len:
        Let expected_char be string_char_at(word, i)
        Let current_char be memory_get_byte(lexer, 20)

        If current_char is not equal to expected_char:
            Return 0
        End If

        Let dummy be lexer_advance(lexer)
        Set i to i plus 1
    End While

    Return 1
End Process

Note: Calculate size of a type in bytes (helper function)
Process called "calculate_type_size" takes type_name as Integer, program as Integer returns Integer:
    Note: Built-in types
    Let integer_str be "Integer"
    Let byte_str be "Byte"
    Let short_str be "Short"
    Let long_str be "Long"

    If string_equals(type_name, integer_str) is equal to 1:
        Return 8  Note: 64-bit integer
    Otherwise If string_equals(type_name, byte_str) is equal to 1:
        Return 1  Note: 8-bit byte
    Otherwise If string_equals(type_name, short_str) is equal to 1:
        Return 2  Note: 16-bit short
    Otherwise If string_equals(type_name, long_str) is equal to 1:
        Return 8  Note: 64-bit long
    End If

    Note: Custom types - look up in the program
    If program is not equal to 0:
        Let type_count be memory_get_int32(program, 24)
        Let types be memory_get_pointer(program, 16)
        Let i be 0
        Let continue_lookup be 1
        While continue_lookup is equal to 1:
            Let is_complete be 0
            If i is greater than or equal to type_count:
                Let is_complete be 1
            End If
            If is_complete is equal to 1:
                Let continue_lookup be 0
            End If
            If is_complete is equal to 0:
                Let ptr_size be 8
                Let offset be i multiplied by ptr_size
                Let type_ptr be types plus offset
                Let type_def be memory_get_pointer(type_ptr, 0)
                Let current_type_name be memory_get_pointer(type_def, 0)
                Let name_match be string_equals(current_type_name, type_name)
                If name_match is equal to 1:
                    Let type_size be memory_get_int32(type_def, 40)  Note: TypeDefinition.size offset
                    Return type_size
                End If
                Let i be i plus 1
            End If
        End While
    End If

    Note: Unknown type - default to 8 bytes and warn
    Let warning_msg be "[PARSER WARNING] Unknown type '"
    print_string(warning_msg)
    print_string(type_name)
    Let warning_msg2 be "', defaulting to 8 bytes"
    print_string(warning_msg2)
    print_newline()
    Return 8
End Process

Process called "parser_parse_type_definition" takes parser as Integer returns Integer:
    Note: Use global TypeDefinition and TypeField constants defined at top of file
    Note: TypeDefinition_SIZE = 48
    Note: TYPEFIELD_SIZE = 24

    Note: Parse: Type called "name": OR Type Name is
    parser_eat(parser, 50)

    Let type be memory_allocate(TypeDefinition_SIZE)

    Note: Check for "called" syntax for struct types
    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)

    If token_type is equal to 2:
        parser_eat(parser, 2)

        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
        If token_type is not equal to 10:
            print_string("[PARSER ERROR] Expected type name at line ")
            Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
            print_integer(line)
            print_newline()
            exit(1)
        End If

        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
        Let type_name be string_duplicate(token_value)
        memory_set_pointer(type, TYPEDEFINITION_NAME_OFFSET, type_name)
        parser_eat(parser, 10)
        parser_eat(parser, 9)

        Note: This is a struct type
        memory_set_int32(type, TYPEDEFINITION_KIND_OFFSET, TYPE_KIND_STRUCT)
        memory_set_pointer(type, TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET, 0)
        memory_set_int32(type, TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET, 0)
        Let current_offset be 0

        Note: Parse field declarations until "End Type"
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
        While token_type is not equal to 8:
            Note: Parse field: name as Type
            If token_type is not equal to 53:
                print_string("[PARSER ERROR] Expected field name at line ")
                Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                print_integer(line)
                print_string(" (got token type ")
                print_integer(token_type)
                print_string(")")
                print_newline()
                exit(1)
            End If

            Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
            Let field_name be string_duplicate(token_value)
            parser_eat(parser, 53)
            parser_eat(parser, 34)

            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
            If token_type is not equal to 4:
                If token_type is not equal to 5:
                    If token_type is not equal to 6:
                        If token_type is not equal to 53:
                            print_string("[PARSER ERROR] Expected field type at line ")
                            Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                            print_integer(line)
                            print_newline()
                            exit(1)
                        End If
                    End If
                End If
            End If

            Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
            Let field_type be string_duplicate(token_value)
            If token_type is equal to 4:
                parser_eat(parser, 4)
            End If
            If token_type is equal to 5:
                parser_eat(parser, 5)
            End If
            If token_type is equal to 6:
                parser_eat(parser, 6)
            End If
            If token_type is equal to 53:
                parser_eat(parser, 53)
            End If

            Note: Check for comma after field declaration (optional for last field)
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
            If token_type is equal to 52:
                parser_eat(parser, 52)
            End If

            Note: Add field to type
            Let field_count be memory_get_integer(type, TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET)
            Let new_field_count be field_count plus 1
            memory_set_int32(type, TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET, new_field_count)

            Let fields be memory_get_pointer(type, TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET)
            Let new_fields_size be new_field_count multiplied by TYPEFIELD_SIZE
            Let new_fields be 0
            If fields is equal to 0:
                Set new_fields to memory_allocate(new_fields_size)
            Otherwise:
                Set new_fields to memory_reallocate(fields, new_fields_size)
            End If
            memory_set_pointer(type, TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET, new_fields)

            Let field_index be new_field_count minus 1
            Let field_offset be field_index multiplied by TYPEFIELD_SIZE
            Let field be new_fields plus field_offset
            memory_set_pointer(field, TYPEFIELD_NAME_OFFSET, field_name)
            memory_set_pointer(field, TYPEFIELD_TYPE_OFFSET, field_type)
            memory_set_int32(field, TYPEFIELD_OFFSET_OFFSET, current_offset)

            Note: Calculate field size based on type
            Let current_program be memory_get_pointer(parser, PARSER_CURRENT_PROGRAM_OFFSET)
            Let field_size be calculate_type_size(field_type, current_program)
            memory_set_int32(field, TYPEFIELD_SIZE_OFFSET, field_size)
            Let current_offset be current_offset plus field_size

            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
        End While

        memory_set_int32(type, TYPEDEFINITION_SIZE_OFFSET, current_offset)

        parser_eat(parser, 8)
        parser_eat(parser, 50)
        Return type
    End If

    Note: Refresh current token after TOKEN_CALLED processing
    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)

    Note: Check for variant syntax: Type Name is | Variant1 ...
    If token_type is equal to 53:
        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
        Let type_name be string_duplicate(token_value)
        memory_set_pointer(type, TYPEDEFINITION_NAME_OFFSET, type_name)
        parser_eat(parser, 53)
        parser_eat(parser, 21)
        parser_eat(parser, 9)  Note: Require colon after "is"

        Note: Now check what kind of type definition follows the colon
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)

        Note: Array type: Type X is: array [size] of ElementType
        If token_type is equal to 126:
            parser_eat(parser, 126)
            parser_eat(parser, 127)

            Note: Parse array size
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
            If token_type is not equal to 11:
                print_string("[PARSER ERROR] Expected array size at line ")
                Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                print_integer(line)
                print_newline()
                exit(1)
            End If
            Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
            Let array_length be string_to_integer(token_value)
            parser_eat(parser, 11)
            parser_eat(parser, 128)
            parser_eat(parser, 125)

            Note: Parse element type
            Let element_type be 0
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
            If token_type is equal to 4:
                Let element_type be string_duplicate("Integer")
                parser_eat(parser, 4)
            End If
            If token_type is equal to 5:
                Let element_type be string_duplicate("String")
                parser_eat(parser, 5)
            End If
            If token_type is equal to 6:
                Let element_type be string_duplicate("Character")
                parser_eat(parser, 6)
            End If
            If token_type is equal to 53:
                Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
                Let element_type be string_duplicate(token_value)
                parser_eat(parser, 53)
            End If
            If element_type is equal to 0:
                print_string("[PARSER ERROR] Expected element type at line ")
                Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                print_integer(line)
                print_newline()
                exit(1)
            End If

            Note: Setup array type
            memory_set_int32(type, TYPEDEFINITION_KIND_OFFSET, TYPE_KIND_ARRAY)
            memory_set_pointer(type, TYPEDEFINITION_DATA_ARRAY_ELEMENT_TYPE_OFFSET, element_type)
            memory_set_int32(type, TYPEDEFINITION_DATA_ARRAY_LENGTH_OFFSET, array_length)

            Note: Calculate element size (8 bytes for Integer, custom types handled separately)
            memory_set_int32(type, TYPEDEFINITION_DATA_ARRAY_ELEMENT_SIZE_OFFSET, 8)
            Let total_size be array_length multiplied by 8
            memory_set_int32(type, TYPEDEFINITION_SIZE_OFFSET, total_size)

            Note: Parse "End Type" after array type definition
            parser_eat(parser, 8)
            parser_eat(parser, 50)
        Otherwise If token_type is equal to 124:
            Note: Function pointer type: Type X is: Pointer to Process ...
            parser_eat(parser, 124)
            parser_eat(parser, 15)
            parser_eat(parser, 1)

            Note: This is a function pointer type
            memory_set_int32(type, TYPEDEFINITION_KIND_OFFSET, TYPE_KIND_FUNCTION)
            memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_PARAM_TYPES_OFFSET, 0)
            memory_set_int32(type, TYPEDEFINITION_DATA_FUNCTION_PARAM_COUNT_OFFSET, 0)
            memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_RETURN_TYPE_OFFSET, 0)
            memory_set_int32(type, TYPEDEFINITION_SIZE_OFFSET, 8)  Note: Pointer size on x86_64

            Note: Parse optional parameters: [that] takes param1 as Type1, param2 as Type2
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
            If token_type is equal to 32:
                parser_eat(parser, 32)
                parser_eat(parser, 33)
            End If
            If token_type is equal to 33:
                parser_eat(parser, 33)
            End If

            Note: Parse parameters if we have takes
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
            If token_type is equal to 53:
                Let param_capacity be 2
                Let param_types be memory_allocate(param_capacity multiplied by 8)  Note: Array of char* pointers
                memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_PARAM_TYPES_OFFSET, param_types)

                Let continue_parsing be 1
                While continue_parsing is equal to 1:
                    Note: Skip parameter name (we only store types for function pointers)
                    If token_type is equal to 53:
                        parser_eat(parser, 53)
                        parser_eat(parser, 34)
                    End If

                    Note: Get parameter type
                    Let param_type be 0
                    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                    Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
                    If token_type is equal to 4:
                        Let param_type be string_duplicate("Integer")
                        parser_eat(parser, 4)
                    End If
                    If token_type is equal to 5:
                        Let param_type be string_duplicate("String")
                        parser_eat(parser, 5)
                    End If
                    If token_type is equal to 6:
                        Let param_type be string_duplicate("Character")
                        parser_eat(parser, 6)
                    End If
                    If token_type is equal to 53:
                        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
                        Let param_type be string_duplicate(token_value)
                        parser_eat(parser, 53)
                    End If
                    If param_type is equal to 0:
                        print_string("[PARSER ERROR] Expected parameter type at line ")
                        Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                        print_integer(line)
                        print_newline()
                        exit(1)
                    End If

                    Note: Expand array if needed
                    Let param_count be memory_get_integer(type, TYPEDEFINITION_DATA_FUNCTION_PARAM_COUNT_OFFSET)
                    If param_count is greater than or equal to param_capacity:
                        Let param_capacity be param_capacity multiplied by 2
                        Let new_param_types be memory_reallocate(param_types, param_capacity multiplied by 8)
                        memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_PARAM_TYPES_OFFSET, new_param_types)
                        Let param_types be new_param_types
                    End If

                    Let param_offset be param_count multiplied by 8
                    memory_set_pointer(param_types plus param_offset, 0, param_type)
                    Let new_param_count be param_count plus 1
                    memory_set_int32(type, TYPEDEFINITION_DATA_FUNCTION_PARAM_COUNT_OFFSET, new_param_count)

                    Note: Check for more parameters (comma or 'and')
                    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                    Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
                    If token_type is equal to 52:
                        parser_eat(parser, 52)
                    End If
                    If token_type is equal to 30:
                        parser_eat(parser, 30)
                    Otherwise:
                        Let continue_parsing be 0
                    End If
                End While
            End If

            Note: Parse return type: returns Type
            parser_eat(parser, 3)
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
            If token_type is equal to 4:
                Let return_type be string_duplicate("Integer")
                memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_RETURN_TYPE_OFFSET, return_type)
                parser_eat(parser, 4)
            End If
            If token_type is equal to 5:
                Let return_type be string_duplicate("String")
                memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_RETURN_TYPE_OFFSET, return_type)
                parser_eat(parser, 5)
            End If
            If token_type is equal to 6:
                Let return_type be string_duplicate("Character")
                memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_RETURN_TYPE_OFFSET, return_type)
                parser_eat(parser, 6)
            End If
            If token_type is equal to 53:
                Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
                Let return_type be string_duplicate(token_value)
                memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_RETURN_TYPE_OFFSET, return_type)
                parser_eat(parser, 53)
            Otherwise:
                print_string("[PARSER ERROR] Expected return type at line ")
                Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                print_integer(line)
                print_newline()
                exit(1)
            End If

            Note: Parse "End Type" after function pointer type definition
            parser_eat(parser, 8)
            parser_eat(parser, 50)
        Otherwise:
            Note: Otherwise this is a variant type
            memory_set_int32(type, TYPEDEFINITION_KIND_OFFSET, TYPE_KIND_VARIANT)
            memory_set_pointer(type, TYPEDEFINITION_DATA_VARIANT_VARIANTS_OFFSET, 0)
            memory_set_int32(type, TYPEDEFINITION_DATA_VARIANT_VARIANT_COUNT_OFFSET, 0)

            Note: Parse variants
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
            While token_type is equal to 111:
                parser_eat(parser, 111)

                Note: Parse variant name
                Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
                If token_type is not equal to 53:
                    print_string("[PARSER ERROR] Expected variant name at line ")
                    Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                    print_integer(line)
                    print_newline()
                    exit(1)
                End If

                Note: Add variant
                Let variant_count be memory_get_int32(type, TYPEDEFINITION_DATA_VARIANT_VARIANT_COUNT_OFFSET)
                Let new_variant_count be variant_count plus 1
                memory_set_int32(type, TYPEDEFINITION_DATA_VARIANT_VARIANT_COUNT_OFFSET, new_variant_count)

                Let variants be memory_get_pointer(type, TYPEDEFINITION_DATA_VARIANT_VARIANTS_OFFSET)
                Let new_variants_size be new_variant_count multiplied by VARIANT_SIZE
                Let new_variants be memory_reallocate(variants, new_variants_size)
                memory_set_pointer(type, TYPEDEFINITION_DATA_VARIANT_VARIANTS_OFFSET, new_variants)

                Let variant_index be new_variant_count minus 1
                Let variant_offset be variant_index multiplied by VARIANT_SIZE
                Let variant be new_variants plus variant_offset
                Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
                Let variant_name be string_duplicate(token_value)
                memory_set_pointer(variant, VARIANT_NAME_OFFSET, variant_name)
                memory_set_pointer(variant, VARIANT_FIELDS_OFFSET, 0)
                memory_set_int32(variant, VARIANT_FIELD_COUNT_OFFSET, 0)
                Let tag be new_variant_count minus 1  Note: Tag is 0-based index
                memory_set_int32(variant, VARIANT_TAG_OFFSET, tag)

                parser_eat(parser, 53)

                Note: Parse optional variant fields
                Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
                If token_type is equal to 114:
                    parser_eat(parser, 114)

                    Let field_offset be 8  Note: Start after tag (8 bytes for tag)

                    Note: Parse fields: field1 as Type1 and field2 as Type2...
                    Let continue_parsing be 1
                    While continue_parsing is equal to 1:
                        Note: Parse field name
                        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                        Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
                        If token_type is not equal to 53:
                            print_string("[PARSER ERROR] Expected field name in variant at line ")
                            Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                            print_integer(line)
                            print_newline()
                            exit(1)
                        End If

                        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
                        Let field_name be string_duplicate(token_value)
                        parser_eat(parser, 53)
                        parser_eat(parser, 34)

                        Note: Parse field type
                        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                        Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
                        If token_type is not equal to 4:
                            If token_type is not equal to 5:
                                If token_type is not equal to 6:
                                    If token_type is not equal to 53:
                                        print_string("[PARSER ERROR] Expected field type at line ")
                                        Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                                        print_integer(line)
                                        print_newline()
                                        exit(1)
                                    End If
                                End If
                            End If
                        End If

                        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
                        Let field_type be string_duplicate(token_value)
                        If token_type is equal to 4:
                            parser_eat(parser, 4)
                        End If
                        If token_type is equal to 5:
                            parser_eat(parser, 5)
                        End If
                        If token_type is equal to 6:
                            parser_eat(parser, 6)
                        End If
                        If token_type is equal to 53:
                            parser_eat(parser, 53)
                        End If

                        Note: Add field to variant
                        Let variant_field_count be memory_get_int32(variant, VARIANT_FIELD_COUNT_OFFSET)
                        Let new_variant_field_count be variant_field_count plus 1
                        memory_set_int32(variant, VARIANT_FIELD_COUNT_OFFSET, new_variant_field_count)

                        Let variant_fields be memory_get_pointer(variant, VARIANT_FIELDS_OFFSET)
                        Let new_variant_fields_size be new_variant_field_count multiplied by TYPEFIELD_SIZE
                        Let new_variant_fields be memory_reallocate(variant_fields, new_variant_fields_size)
                        memory_set_pointer(variant, VARIANT_FIELDS_OFFSET, new_variant_fields)

                        Let variant_field_index be new_variant_field_count minus 1
                        Let variant_field_offset be variant_field_index multiplied by TYPEFIELD_SIZE
                        Let field be new_variant_fields plus variant_field_offset
                        memory_set_pointer(field, TYPEFIELD_NAME_OFFSET, field_name)
                        memory_set_pointer(field, TYPEFIELD_TYPE_OFFSET, field_type)
                        memory_set_int32(field, TYPEFIELD_OFFSET_OFFSET, field_offset)

                        Let current_program be memory_get_pointer(parser, PARSER_CURRENT_PROGRAM_OFFSET)
                        Let field_size be calculate_type_size(field_type, current_program)
                        memory_set_int32(field, TYPEFIELD_SIZE_OFFSET, field_size)
                        Let field_offset be field_offset plus field_size

                        Note: Check for "and" to continue with more fields
                        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                        Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
                        If token_type is equal to 30:
                            parser_eat(parser, 30)
                        Otherwise:
                            Let continue_parsing be 0
                        End If
                    End While
                End If

                Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
            End While

            Note: Calculate max size needed for any variant
            memory_set_int32(type, TYPEDEFINITION_SIZE_OFFSET, 8)  Note: At least tag size
            Let variant_count be memory_get_int32(type, TYPEDEFINITION_DATA_VARIANT_VARIANT_COUNT_OFFSET)
            Let variants be memory_get_pointer(type, TYPEDEFINITION_DATA_VARIANT_VARIANTS_OFFSET)
            Let i be 0
            While i is less than variant_count:
                Let variant_offset be i multiplied by VARIANT_SIZE
                Let variant be variants plus variant_offset
                Let variant_size be 8  Note: Tag size
                Let variant_field_count be memory_get_int32(variant, VARIANT_FIELD_COUNT_OFFSET)
                Let variant_fields be memory_get_pointer(variant, VARIANT_FIELDS_OFFSET)
                Let j be 0
                While j is less than variant_field_count:
                    Let field_offset be j multiplied by TYPEFIELD_SIZE
                    Let field be variant_fields plus field_offset
                    Let field_size be memory_get_int32(field, TYPEFIELD_SIZE_OFFSET)
                    Let variant_size be variant_size plus field_size
                    Let j be j plus 1
                End While
                Let current_type_size be memory_get_int32(type, TYPEDEFINITION_SIZE_OFFSET)
                If variant_size is greater than current_type_size:
                    memory_set_int32(type, TYPEDEFINITION_SIZE_OFFSET, variant_size)
                End If
                Let i be i plus 1
            End While

            Note: Parse "End Type" after variant type definition
            parser_eat(parser, 8)
            parser_eat(parser, 50)
        End If
    Otherwise:
        print_string("[PARSER ERROR] Expected 'called' or type name after 'Type' at line ")
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
        print_newline()
        exit(1)
    End If

    Return type
End Process

Process called "parser_parse_function" takes parser as Integer returns Integer:
    Note: Parse: Process called "name" [that takes param as Type] returns Type:
    parser_eat(parser, 1)
    parser_eat(parser, 2)

    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
    If token_type is not equal to 10:
        print_string("[PARSER ERROR] Expected function name string literal (type ")
        print_integer(10)
        print_string("), got type ")
        print_integer(token_type)
        print_string(" at line ")
        Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
        print_integer(line)
        print_newline()
        exit(1)
    End If

    Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
    If token_value is equal to 0:
        print_string("[PARSER ERROR] Function name is NULL!")
        exit(1)
    End If
    Let func_name be string_duplicate(token_value)
    parser_eat(parser, 10)

    Let default_return_type be string_duplicate("Integer")
    Let func be function_create(func_name, default_return_type)

    Note: Check for parameters: "takes param as Type" or "takes x as Type, y as Type"
    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
    If token_type is equal to 33:
        parser_eat(parser, 33)

        Note: Parse first parameter
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
        Let can_be_id be token_can_be_identifier(token_type)
        If can_be_id is not equal to 1:
            print_string("[PARSER ERROR] Expected parameter name at line ")
            Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
            print_integer(line)
            print_newline()
            exit(1)
        End If

        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
        Let param_name be string_duplicate(token_value)
        parser_eat(parser, token_type)
        parser_eat(parser, 34)

        Note: Accept built-in types or custom type names (for function pointers and structs)
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
        If token_type is not equal to 4:
            If token_type is not equal to 5:
                If token_type is not equal to 6:
                    If token_type is not equal to 53:
                        print_string("[PARSER ERROR] Expected parameter type at line ")
                        Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                        print_integer(line)
                        print_newline()
                        exit(1)
                    End If
                End If
            End If
        End If

        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
        Let param_type be string_duplicate(token_value)
        If token_type is equal to 4:
            parser_eat(parser, 4)
        End If
        If token_type is equal to 5:
            parser_eat(parser, 5)
        End If
        If token_type is equal to 6:
            parser_eat(parser, 6)
        End If
        If token_type is equal to 53:
            Note: Custom type name (struct, variant, or function pointer)
            parser_eat(parser, 53)
        End If

        function_add_parameter(func, param_name, param_type)

        Note: Parse additional parameters separated by commas
        Let loop_current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let loop_token_type be memory_get_int32(loop_current_token, TOKEN_TYPE_OFFSET)
        While loop_token_type is equal to 52:
            parser_eat(parser, 52)

            Let param_current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let param_token_type be memory_get_int32(param_current_token, TOKEN_TYPE_OFFSET)
            Let param_can_be_id be token_can_be_identifier(param_token_type)
            If param_can_be_id is not equal to 1:
                print_string("[PARSER ERROR] Expected parameter name after comma at line ")
                Let param_line be memory_get_int32(param_current_token, TOKEN_LINE_OFFSET)
                print_integer(param_line)
                print_newline()
                exit(1)
            End If

            Let param_token_value be memory_get_pointer(param_current_token, TOKEN_VALUE_OFFSET)
            Let param_name be string_duplicate(param_token_value)
            parser_eat(parser, param_token_type)
            parser_eat(parser, 34)

            Note: Accept built-in types or custom type names (for function pointers and structs)
            Let paramtype_current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let paramtype_token_type be memory_get_int32(paramtype_current_token, TOKEN_TYPE_OFFSET)
            If paramtype_token_type is not equal to 4:
                If paramtype_token_type is not equal to 5:
                    If paramtype_token_type is not equal to 6:
                        If paramtype_token_type is not equal to 53:
                            print_string("[PARSER ERROR] Expected parameter type at line ")
                            Let paramtype_line be memory_get_int32(paramtype_current_token, TOKEN_LINE_OFFSET)
                            print_integer(paramtype_line)
                            print_newline()
                            exit(1)
                        End If
                    End If
                End If
            End If

            Let paramtype_token_value be memory_get_pointer(paramtype_current_token, TOKEN_VALUE_OFFSET)
            Let param_type be string_duplicate(paramtype_token_value)
            If paramtype_token_type is equal to 4:
                parser_eat(parser, 4)
            End If
            If paramtype_token_type is equal to 5:
                parser_eat(parser, 5)
            End If
            If paramtype_token_type is equal to 6:
                parser_eat(parser, 6)
            End If
            If paramtype_token_type is equal to 53:
                Note: Custom type name (struct, variant, or function pointer)
                parser_eat(parser, 53)
            End If

            function_add_parameter(func, param_name, param_type)

            Let loop_current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let loop_token_type be memory_get_int32(loop_current_token, TOKEN_TYPE_OFFSET)
        End While
    End If

    parser_eat(parser, 3)

    Note: Handle different return types
    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
    Let type_handled be 0
    If token_type is equal to 4:
        parser_eat(parser, 4)
        Let type_handled be 1
    Otherwise If token_type is equal to 5:
        parser_eat(parser, 5)
        Let type_handled be 1
    Otherwise If token_type is equal to 6:
        parser_eat(parser, 6)
        Let type_handled be 1
    Otherwise If token_type is equal to 53:
        Note: Custom type
        parser_eat(parser, 53)
        Let type_handled be 1
    End If
    If type_handled is equal to 0:
        print_string("[PARSER ERROR] Expected return type at line ")
        Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
        print_integer(line)
        print_newline()
        exit(1)
    End If

    parser_eat(parser, 9)

    Note: Parse function body statements
    Let body_current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let body_token_type be memory_get_int32(body_current_token, TOKEN_TYPE_OFFSET)
    While body_token_type is not equal to 7:
        If body_token_type is equal to 8:
            Note: Exit if we hit End Process before Return
            Break
        End If
        If body_token_type is equal to 0:
            Break
        End If

        Let stmt be 0

        If body_token_type is equal to 12:
            Set stmt to parser_parse_let_statement(parser)  Note: Changed from Let to Set
        End If
        If body_token_type is equal to 14:
            Set stmt to parser_parse_set_statement(parser)  Note: Changed from Let to Set
        End If
        If body_token_type is equal to 18:
            Set stmt to parser_parse_if_statement(parser)  Note: Changed from Let to Set
        End If
        If body_token_type is equal to 20:
            Set stmt to parser_parse_while_statement(parser)  Note: Changed from Let to Set
        End If
        If body_token_type is equal to 112:
            Set stmt to parser_parse_match_statement(parser)  Note: Changed from Let to Set
        End If
        If body_token_type is equal to 47:
            Set stmt to parser_parse_print_statement(parser)  Note: Changed from Let to Set
        End If
        If body_token_type is equal to 121:
            Set stmt to parser_parse_inline_assembly_statement(parser)  Note: Changed from Let to Set
        End If
        If body_token_type is equal to 143:  Note: TOKEN_FOR
            Set stmt to parser_parse_for_range_statement(parser)
        End If
        If body_token_type is equal to 139:  Note: TOKEN_INCREASE
            Set stmt to parser_parse_implicit_compound_assign(parser, 0)
        End If
        If body_token_type is equal to 140:  Note: TOKEN_DECREASE
            Set stmt to parser_parse_implicit_compound_assign(parser, 1)
        End If
        If body_token_type is equal to 141:  Note: TOKEN_MULTIPLY
            Set stmt to parser_parse_implicit_compound_assign(parser, 2)
        End If
        If body_token_type is equal to 142:  Note: TOKEN_DIVIDE
            Set stmt to parser_parse_implicit_compound_assign(parser, 3)
        End If
        If body_token_type is equal to 53:
            Note: Try to parse as expression (could be a function call)
            Let expr be parser_parse_expression(parser)
            Note: Only function calls are valid as standalone statements
            Let expr_type be memory_get_integer(expr, EXPRESSION_TYPE_OFFSET)
            If expr_type is equal to EXPR_FUNCTION_CALL:
                Set stmt to statement_create_expression(expr)  Note: Changed from Let to Set
            Otherwise:
                Note: Other expressions are not valid as statements
                print_string("[PARSER ERROR] Only function calls can be used as statements (got expr_type=")
                print_integer(expr_type)
                print_string(", expected ")
                print_integer(EXPR_FUNCTION_CALL)
                print_string(") at line ")
                Let error_line be memory_get_int32(body_current_token, TOKEN_LINE_OFFSET)
                print_integer(error_line)
                print_newline()
                exit(1)
            End If
        End If

        Let is_builtin be parser_is_builtin_function_token(body_token_type)
        If is_builtin is equal to 1:
            Note: Parse builtin function call as expression statement
            Let expr be parser_parse_expression(parser)
            Let expr_type be memory_get_integer(expr, EXPRESSION_TYPE_OFFSET)
            If expr_type is equal to EXPR_BUILTIN_CALL:
                Set stmt to statement_create_expression(expr)  Note: Changed from Let to Set
            Otherwise:
                print_string("[PARSER ERROR] Invalid builtin function statement at line ")
                Let builtin_error_line be memory_get_int32(body_current_token, TOKEN_LINE_OFFSET)
                print_integer(builtin_error_line)
                print_newline()
                exit(1)
            End If
        End If

        If stmt is equal to 0:
            print_string("[PARSER ERROR] Unexpected token ")
            print_integer(body_token_type)
            print_string(" in function body at line ")
            Let stmt_error_line be memory_get_int32(body_current_token, TOKEN_LINE_OFFSET)
            print_integer(stmt_error_line)
            print_newline()
            exit(1)
        End If

        function_add_statement(func, stmt)

        Let body_current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let body_token_type be memory_get_int32(body_current_token, TOKEN_TYPE_OFFSET)
    End While

    Note: Parse Return statement
    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
    If token_type is equal to 7:
        Let return_stmt be parser_parse_return_statement(parser)
        function_add_statement(func, return_stmt)
    End If

    Note: Parse: End Process
    parser_eat(parser, 8)
    parser_eat(parser, 1)

    Return func
End Process

Note: Size constants for structures
Let SIZEOF_PARSER be 24
Let SIZEOF_PROGRAM be 64

Note: Offsets for parser structure
Let PARSER_LEXER be 0           Note: Lexer *lexer
Let PARSER_CURRENT_TOKEN be 8   Note: Token *current_token
Let PARSER_CURRENT_PROGRAM_OFFSET be 16 Note: Program *current_program

Note: Program structure offsets already defined at the top of file

Note: Token structure offsets
Let TOKEN_TYPE_OFFSET be 0      Note: TokenType type
Let TOKEN_VALUE_OFFSET be 8     Note: char *value
Let TOKEN_LINE_OFFSET be 16     Note: int line_number

Note: Additional expression types missing
Let EXPR_UNARY be 11
Let EXPR_BINARY be 2  Note: Alias for EXPR_BINARY_OP
Let EXPR_CALL be 4    Note: Alias for EXPR_FUNCTION_CALL
Let EXPR_ARRAY_ACCESS be 16  Note: Alias for EXPR_ARRAY_INDEX
Let EXPR_IDENTIFIER be 1     Note: Alias for EXPR_VARIABLE

Note: Statement types already defined above

Note: Statement structure offsets
Let STMT_TYPE be 0
Let STMT_LET_NAME be 8
Let STMT_LET_VALUE be 16
Let STMT_LET_TYPE be 24
Let STMT_SET_NAME be 8
Let STMT_SET_VALUE be 16
Let STMT_IF_CONDITION be 8
Let STMT_IF_THEN_BODY be 16
Let STMT_IF_ELSE_BODY be 24
Let STMT_WHILE_CONDITION be 8
Let STMT_WHILE_BODY be 16
Let STMT_FOR_VAR be 8
Let STMT_FOR_START be 16
Let STMT_FOR_END be 24
Let STMT_FOR_BODY be 32
Let STMT_RETURN_VALUE be 8
Let STMT_EXPR_VALUE be 8

Note: Expression structure offsets
Let EXPR_TYPE be 0
Let EXPR_BINARY_LEFT be 8
Let EXPR_BINARY_RIGHT be 16
Let EXPR_UNARY_OPERAND be 8
Let EXPR_CALL_NAME be 8
Let EXPR_CALL_ARGS be 16
Let EXPR_FIELD_OBJECT be 8
Let EXPR_FIELD_NAME be 16
Let EXPR_ARRAY_OBJECT be 8
Let EXPR_ARRAY_INDEX_OFFSET be 16  Note: Renamed to avoid collision with EXPR_ARRAY_INDEX constant
Let EXPR_IDENTIFIER_NAME be 8
Let EXPR_STRING_VALUE be 8

Note: Type kinds for destroy functions
Let TYPE_PRIMITIVE be 0
Let TYPE_STRUCT be 1
Let TYPE_ARRAY be 2
Let TYPE_POINTER be 3

Note: Type structure offsets
Let TYPE_KIND be 0
Let TYPE_STRUCT_NAME be 8
Let TYPE_STRUCT_FIELDS be 16
Let TYPE_ARRAY_ELEMENT_TYPE be 8
Let TYPE_POINTER_TARGET_TYPE be 8

Note: Function structure offsets
Let FUNCTION_NAME be 0
Let FUNCTION_PARAMETERS be 8
Let FUNCTION_RETURN_TYPE be 16
Let FUNCTION_BODY be 24

Note: parser_create - Create new parser instance
Process called "parser_create" takes lexer as Integer returns Integer:
    Let parser be memory_allocate(SIZEOF_PARSER)
    memory_set_pointer(parser, PARSER_LEXER, lexer)
    Let first_token be lexer_next_token(lexer)
    If first_token is equal to 0:
        print_string("[ERROR] lexer_next_token returned NULL!")
    End If
    memory_set_pointer(parser, PARSER_CURRENT_TOKEN, first_token)
    Return parser
End Process

Note: parser_destroy - Destroy parser instance
Process called "parser_destroy" takes parser as Integer returns Integer:
    deallocate(parser)
    Return 0
End Process

Note: parser_parse_program - Main program parsing function
Process called "parser_parse_program" takes parser as Integer returns Integer:
    Let program be memory_allocate(SIZEOF_PROGRAM)
    Let test_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let test_type be memory_get_int32(test_token, TOKEN_TYPE_OFFSET)
    If test_type is equal to 0:
        print_string("[ERROR] First token is already EOF!")
    End If
    Note: Initialize pointers to NULL (0) - they will be allocated when needed
    memory_set_pointer(program, PROGRAM_IMPORTS, 0)
    memory_set_pointer(program, PROGRAM_TYPES, 0)
    memory_set_pointer(program, PROGRAM_FUNCTIONS, 0)
    memory_set_pointer(program, PROGRAM_GLOBAL_VARS, 0)

    Note: Initialize all count fields to 0
    memory_set_int32(program, PROGRAM_FUNCTION_COUNT, 0)
    memory_set_int32(program, PROGRAM_TYPE_COUNT, 0)
    memory_set_int32(program, PROGRAM_IMPORT_COUNT, 0)
    memory_set_int32(program, PROGRAM_GLOBAL_COUNT, 0)

    Note: Initialize all capacity fields to 0
    memory_set_int32(program, PROGRAM_FUNCTION_CAPACITY, 0)
    memory_set_int32(program, PROGRAM_TYPE_CAPACITY, 0)
    memory_set_int32(program, PROGRAM_IMPORT_CAPACITY, 0)
    memory_set_int32(program, PROGRAM_GLOBAL_CAPACITY, 0)

    Note: Set current program for type lookups
    memory_set_pointer(parser, PARSER_CURRENT_PROGRAM_OFFSET, program)

    Note: Parse imports, type definitions, and functions until EOF
    Note: Use goto-style loop to avoid If statements inside While
    Let continue_parsing be 1
    While continue_parsing is equal to 1:
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        If current_token is equal to 0:
            print_string("[ERROR] current_token is NULL!")
            Return 0
        End If
        Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)

        Note: Check if EOF
        Let is_eof be 0
        If token_type is equal to 0:
            Let is_eof be 1
        End If
        If is_eof is equal to 1:
            Let continue_parsing be 0
        End If

        Note: Process tokens when not EOF
        If is_eof is equal to 0:
            Note: Handle TOKEN_IMPORT
            Let is_import be 0
            If token_type is equal to 56:
                Let is_import be 1
            End If
            If is_import is equal to 1:
                Let import_stmt be parser_parse_import(parser)
                If import_stmt is equal to 0:
                    print_string("[ERROR] parser_parse_import returned NULL!")
                    Return 0
                End If
                program_add_import(program, import_stmt)
            End If

            Note: Handle TOKEN_TYPE
            Let is_type be 0
            If token_type is equal to 50:
                Let is_type be 1
            End If
            If is_type is equal to 1:
                Let type_def be parser_parse_type_definition(parser)
                program_add_type(program, type_def)
            End If

            Note: Handle TOKEN_PROCESS
            Let is_process be 0
            If token_type is equal to 1:
                Let is_process be 1
            End If
            If is_process is equal to 1:
                Let func be parser_parse_function(parser)
                If func is equal to 0:
                    print_string("[ERROR] parser_parse_function returned NULL!")
                    Return 0
                End If
                program_add_function(program, func)
            End If

            Note: Handle TOKEN_LET (global constants) - parse and store them properly
            Let is_let be 0
            If token_type is equal to 12:
                Let is_let be 1
            End If
            If is_let is equal to 1:
                parser_eat(parser, 12)  Note: Eat 'Let'
                Let global_current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                Let global_token_type be memory_get_int32(global_current_token, TOKEN_TYPE_OFFSET)

                If global_token_type is equal to 53:  Note: identifier
                    Let var_name be string_duplicate_parser(memory_get_pointer(global_current_token, TOKEN_VALUE_OFFSET))
                    parser_eat(parser, 53)

                    Let global_be_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                    Let global_be_type be memory_get_int32(global_be_token, TOKEN_TYPE_OFFSET)
                    If global_be_type is equal to 13:  Note: 'be'
                        parser_eat(parser, 13)

                        Let global_value_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                        Let global_value_type be memory_get_int32(global_value_token, TOKEN_TYPE_OFFSET)
                        If global_value_type is equal to 11:  Note: TOKEN_INTEGER
                            Let value_str be memory_get_pointer(global_value_token, TOKEN_VALUE_OFFSET)
                            Let int_value be string_to_integer(value_str)
                            Let initial_value be expression_create_integer(int_value)
                            parser_eat(parser, 11)

                            Note: Create global variable entry using exact GlobalVariable struct layout
                            Note: GlobalVariable: name(0), type(8), initial_value(16) - total 24 bytes
                            Let global be memory_allocate(24)
                            memory_set_pointer(global, 0, var_name)
                            memory_set_pointer(global, 8, string_duplicate_parser("Integer"))
                            memory_set_pointer(global, 16, initial_value)
                            program_add_global(program, global)
                        End If
                    End If
                End If
            End If


            Note: Handle unknown token
            Let handled_token be 0
            If is_import is equal to 1:
                Let handled_token be 1
            End If
            If is_type is equal to 1:
                Let handled_token be 1
            End If
            If is_process is equal to 1:
                Let handled_token be 1
            End If
            If is_let is equal to 1:
                Let handled_token be 1
            End If
            If handled_token is equal to 0:
                Note: parser_error_with_token(parser, "Unexpected token at top level", current_token)
                Return 0
            End If
        End If
    End While

    Return program
End Process

Note: expression_destroy - Clean up expression objects
Process called "expression_destroy" takes expr as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If

    Let expr_type be memory_get_integer(expr, EXPR_TYPE)

    If expr_type is equal to EXPR_BINARY:
        Let left be memory_get_pointer(expr, EXPR_BINARY_LEFT)
        Let right be memory_get_pointer(expr, EXPR_BINARY_RIGHT)
        expression_destroy(left)
        expression_destroy(right)
    Otherwise If expr_type is equal to EXPR_UNARY:
        Let operand be memory_get_pointer(expr, EXPR_UNARY_OPERAND)
        expression_destroy(operand)
    Otherwise If expr_type is equal to EXPR_CALL:
        Let name be memory_get_pointer(expr, EXPR_CALL_NAME)
        string_destroy(name)
        Note: list_destroy_with(memory_get_pointer(expr, EXPR_CALL_ARGS), expression_destroy)
    Otherwise If expr_type is equal to EXPR_FIELD_ACCESS:
        Let obj be memory_get_pointer(expr, EXPR_FIELD_OBJECT)
        Let field_name be memory_get_pointer(expr, EXPR_FIELD_NAME)
        expression_destroy(obj)
        string_destroy(field_name)
    Otherwise If expr_type is equal to EXPR_ARRAY_ACCESS:
        Let array_obj be memory_get_pointer(expr, EXPR_ARRAY_OBJECT)
        Let index be memory_get_pointer(expr, EXPR_ARRAY_INDEX_OFFSET)
        expression_destroy(array_obj)
        expression_destroy(index)
    Otherwise If expr_type is equal to EXPR_IDENTIFIER:
        Let ident_name be memory_get_pointer(expr, EXPR_IDENTIFIER_NAME)
        string_destroy(ident_name)
    Otherwise If expr_type is equal to EXPR_STRING_LITERAL:
        Let str_val be memory_get_pointer(expr, EXPR_STRING_VALUE)
        string_destroy(str_val)
    End If

    deallocate(expr)
    Return 0
End Process

Note: statement_destroy - Clean up statement objects
Process called "statement_destroy" takes stmt as Integer returns Integer:
    If stmt is equal to 0:
        Return 0
    End If

    Let stmt_type be memory_get_integer(stmt, STMT_TYPE)

    If stmt_type is equal to STMT_LET:
        Let name be memory_get_pointer(stmt, STMT_LET_NAME)
        Let value be memory_get_pointer(stmt, STMT_LET_VALUE)
        Let type_ptr be memory_get_pointer(stmt, STMT_LET_TYPE)
        string_destroy(name)
        expression_destroy(value)
        type_destroy(type_ptr)
    Otherwise If stmt_type is equal to STMT_SET:
        Let set_name be memory_get_pointer(stmt, STMT_SET_NAME)
        Let set_value be memory_get_pointer(stmt, STMT_SET_VALUE)
        string_destroy(set_name)
        expression_destroy(set_value)
    Otherwise If stmt_type is equal to STMT_IF:
        Let condition be memory_get_pointer(stmt, STMT_IF_CONDITION)
        expression_destroy(condition)
        Note: list_destroy_with(memory_get_pointer(stmt, STMT_IF_THEN_BODY), statement_destroy)
        Note: list_destroy_with(memory_get_pointer(stmt, STMT_IF_ELSE_BODY), statement_destroy)
    Otherwise If stmt_type is equal to STMT_WHILE:
        Let while_cond be memory_get_pointer(stmt, STMT_WHILE_CONDITION)
        expression_destroy(while_cond)
        Note: list_destroy_with(memory_get_pointer(stmt, STMT_WHILE_BODY), statement_destroy)
    Otherwise If stmt_type is equal to STMT_FOR:
        Let for_var be memory_get_pointer(stmt, STMT_FOR_VAR)
        Let for_start be memory_get_pointer(stmt, STMT_FOR_START)
        Let for_end be memory_get_pointer(stmt, STMT_FOR_END)
        string_destroy(for_var)
        expression_destroy(for_start)
        expression_destroy(for_end)
        Note: list_destroy_with(memory_get_pointer(stmt, STMT_FOR_BODY), statement_destroy)
    Otherwise If stmt_type is equal to STMT_FOR_EACH:
        Let foreach_var be memory_get_pointer(stmt, 8)
        Let foreach_collection be memory_get_pointer(stmt, 16)
        string_destroy(foreach_var)
        expression_destroy(foreach_collection)
        Note: list_destroy_with(memory_get_pointer(stmt, 24), statement_destroy)
    Otherwise If stmt_type is equal to STMT_RETURN:
        Let ret_value be memory_get_pointer(stmt, STMT_RETURN_VALUE)
        expression_destroy(ret_value)
    Otherwise If stmt_type is equal to STMT_EXPRESSION:
        Let expr_value be memory_get_pointer(stmt, STMT_EXPR_VALUE)
        expression_destroy(expr_value)
    Otherwise If stmt_type is equal to STMT_BREAK:
        Note: No cleanup needed for break
    Otherwise If stmt_type is equal to STMT_CONTINUE:
        Note: No cleanup needed for continue
    End If

    deallocate(stmt)
    Return 0
End Process

Note: function_destroy - Clean up function objects
Process called "function_destroy" takes func as Integer returns Integer:
    If func is equal to 0:
        Return 0
    End If

    string_destroy(memory_get_pointer(func, FUNCTION_NAME))
    Note: list_destroy_with(memory_get_pointer(func, FUNCTION_PARAMETERS), param_destroy)
    Note: NOTE: Don't destroy return type - it's owned by the program's types array
    Note: type_destroy(memory_get_pointer(func, FUNCTION_RETURN_TYPE))
    Note: list_destroy_with(memory_get_pointer(func, FUNCTION_BODY), statement_destroy)

    deallocate(func)
    Return 0
End Process

Note: type_destroy - Clean up type definition objects
Process called "type_destroy" takes type_obj as Integer returns Integer:
    If type_obj is equal to 0:
        Return 0
    End If

    Let type_kind be memory_get_integer(type_obj, TYPE_KIND)

    If type_kind is equal to TYPE_PRIMITIVE:
        Note: No additional cleanup for primitive types
    Otherwise If type_kind is equal to TYPE_STRUCT:
        Let struct_name be memory_get_pointer(type_obj, TYPE_STRUCT_NAME)
        string_destroy(struct_name)
        Note: list_destroy_with(memory_get_pointer(type_obj, TYPE_STRUCT_FIELDS), field_destroy)
    Otherwise If type_kind is equal to TYPE_ARRAY:
        Let elem_type be memory_get_pointer(type_obj, TYPE_ARRAY_ELEMENT_TYPE)
        type_destroy(elem_type)
    Otherwise If type_kind is equal to TYPE_POINTER:
        Let target_type be memory_get_pointer(type_obj, TYPE_POINTER_TARGET_TYPE)
        type_destroy(target_type)
    End If

    deallocate(type_obj)
    Return 0
End Process

Note: program_destroy - Clean up program objects
Process called "program_destroy" takes program as Integer returns Integer:
    If program is equal to 0:
        Return 0
    End If

    Note: Clean up functions array
    Let func_count be memory_get_int32(program, PROGRAM_FUNCTION_COUNT)
    Let functions be memory_get_pointer(program, PROGRAM_FUNCTIONS)
    If functions is not equal to 0:
        Let i be 0
        While i is less than func_count:
            Let ptr_size be 8
            Let offset be i multiplied by ptr_size
            Let func_ptr be functions plus offset
            Let func be memory_get_pointer(func_ptr, 0)
            If func is not equal to 0:
                function_destroy(func)
            End If
            Set i to i plus 1
        End While
        deallocate(functions)
    End If

    Note: Clean up types array
    Let type_count be memory_get_int32(program, PROGRAM_TYPE_COUNT)
    Let types be memory_get_pointer(program, PROGRAM_TYPES)
    If types is not equal to 0:
        Let j be 0
        While j is less than type_count:
            Let ptr_size be 8
            Let offset be j multiplied by ptr_size
            Let type_ptr be types plus offset
            Let type_obj be memory_get_pointer(type_ptr, 0)
            If type_obj is not equal to 0:
                type_destroy(type_obj)
            End If
            Set j to j plus 1
        End While
        deallocate(types)
    End If

    Note: Clean up imports array (if we add import_destroy later)
    Let import_count be memory_get_int32(program, PROGRAM_IMPORT_COUNT)
    Let imports be memory_get_pointer(program, PROGRAM_IMPORTS)
    If imports is not equal to 0:
        deallocate(imports)
    End If

    Note: Clean up global variables array
    Let global_count be memory_get_int32(program, PROGRAM_GLOBAL_COUNT)
    Let globals be memory_get_pointer(program, PROGRAM_GLOBAL_VARS)
    If globals is not equal to 0:
        Let k be 0
        While k is less than global_count:
            Let ptr_size be 8
            Let offset be k multiplied by ptr_size
            Let global_ptr be globals plus offset
            Let global_stmt be memory_get_pointer(global_ptr, 0)
            If global_stmt is not equal to 0:
                statement_destroy(global_stmt)
            End If
            Set k to k plus 1
        End While
        deallocate(globals)
    End If

    deallocate(program)
    Return 0
End Process

Note: string_destroy - String cleanup (alias for memory_free)
Process called "string_destroy" takes str as Integer returns Integer:
    If str is not equal to 0:
        deallocate(str)
    End If
    Return 0
End Process

Note: param_destroy - Clean up function parameter objects
Process called "param_destroy" takes param as Integer returns Integer:
    If param is equal to 0:
        Return 0
    End If

    Note: Parameter structure: name (offset 0), type (offset 8)
    string_destroy(memory_get_pointer(param, 0))  Note: param name
    string_destroy(memory_get_pointer(param, 8))  Note: param type
    deallocate(param)
    Return 0
End Process

Note: field_destroy - Clean up struct/variant field objects
Process called "field_destroy" takes field as Integer returns Integer:
    If field is equal to 0:
        Return 0
    End If

    Note: Field structure: name (offset 0), type (offset 8)
    string_destroy(memory_get_pointer(field, 0))  Note: field name
    string_destroy(memory_get_pointer(field, 8))  Note: field type
    deallocate(field)
    Return 0
End Process

Note: import_destroy - Clean up import statement objects
Process called "import_destroy" takes import_stmt as Integer returns Integer:
    If import_stmt is equal to 0:
        Return 0
    End If

    Note: Import structure: filename (offset 0), module_name (offset 8)
    string_destroy(memory_get_pointer(import_stmt, 0))  Note: filename
    string_destroy(memory_get_pointer(import_stmt, 8))  Note: module_name
    deallocate(import_stmt)
    Return 0
End Process

Note: parser_parse_import - Parse Import statement: Import "filename" as module_name
Process called "parser_parse_import" takes parser as Integer returns Integer:
    Note: Parse: Import "filename" as module_name
    Note: Skip the Import token
    Let dummy_import be parser_advance(parser)

    Note: Get filename (must be string literal)
    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
    If token_type is not equal to 10:
        print_string("[PARSER ERROR] Expected string literal after Import, got token type ")
        print_integer(token_type)
        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
        print_string(", value: ")
        print_string(token_value)
        print_newline()
        exit_with_code(1)
    End If

    Let filename be string_duplicate_parser(memory_get_pointer(current_token, TOKEN_VALUE_OFFSET))
    Let dummy_str be parser_advance(parser)

    Note: Expect "as"
    Let as_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let as_token_type be memory_get_int32(as_token, TOKEN_TYPE_OFFSET)
    If as_token_type is not equal to 34:
        print_string("[PARSER ERROR] Expected 'as' after filename, got token type ")
        print_integer(as_token_type)
        Let as_value be memory_get_pointer(as_token, TOKEN_VALUE_OFFSET)
        print_string(", value: ")
        print_string(as_value)
        print_newline()
        exit_with_code(1)
    End If
    Let dummy_as be parser_advance(parser)

    Note: Get module name (must be identifier)
    Let name_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let name_token_type be memory_get_int32(name_token, TOKEN_TYPE_OFFSET)
    If name_token_type is not equal to 53:
        print_string("[PARSER ERROR] Expected module name after 'as', got token type ")
        print_integer(name_token_type)
        Let name_value be memory_get_pointer(name_token, TOKEN_VALUE_OFFSET)
        print_string(", value: ")
        print_string(name_value)
        print_newline()
        exit_with_code(1)
    End If

    Let module_name be string_duplicate_parser(memory_get_pointer(name_token, TOKEN_VALUE_OFFSET))
    Let dummy_name be parser_advance(parser)

    Note: Create import object
    Let import_stmt be memory_allocate(16)  Note: filename + module_name pointers
    memory_set_pointer(import_stmt, 0, filename)    Note: filename at offset 0
    memory_set_pointer(import_stmt, 8, module_name) Note: module_name at offset 8

    Return import_stmt
End Process
