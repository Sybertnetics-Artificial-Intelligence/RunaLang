Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
Code Generator for x86-64 Assembly
Transliterated from codegen_x86.c (v0.0.7.3)
Generates x86-64 assembly from parsed AST
:End Note

Note: Program structure offsets (defined in parser.runa)
Note: Using numeric values to avoid duplicate symbol errors
Note: PROGRAM_FUNCTIONS = 0
Note: PROGRAM_FUNCTION_COUNT = 8
Note: PROGRAM_TYPES = 16
Note: PROGRAM_TYPE_COUNT = 24
Note: PROGRAM_IMPORTS = 32
Note: PROGRAM_IMPORT_COUNT = 40
Note: PROGRAM_GLOBAL_VARS = 48
Note: PROGRAM_GLOBAL_COUNT = 56

Note: Forward declarations for loop context management
Note: These will be implemented later in the file

Note: Global loop context stack for break/continue
Note: Structure: (32 bytes per context)
Note:   offset 0: label_name (string pointer, 0 if unnamed loop)
Note:   offset 8: break_label (string, assembly label for loop end)
Note:   offset 16: continue_label (string, assembly label for loop start/condition)
Note:   offset 24: prev (pointer to previous context)
Let loop_context_stack be 0  Note: Current loop context (NULL if not in loop)

Note: string_duplicate is provided by string_utils module

Note: Helper to duplicate string using codegen's arena (for temporary strings)
Process called "codegen_arena_strdup" takes codegen as Integer, str as Integer returns Integer:
    Let arena be memory_get_pointer(codegen, 88)
    Return arena_string_duplicate(arena, str)
End Process

Note: Helper to convert integer to string using arena (for temporary strings)
Process called "codegen_arena_int_to_str" takes codegen as Integer, value as Integer returns Integer:
    Let arena be memory_get_pointer(codegen, 88)
    Return arena_integer_to_string(arena, value)
End Process

Note: ============================================================================
Note: LOOP CONTEXT MANAGEMENT (for Break/Continue with labels)
Note: ============================================================================

Process called "codegen_push_loop_context" takes codegen as Integer, label_name as Integer, break_label as Integer, continue_label as Integer returns Integer:
    Note: Create new loop context and push onto stack
    Let context be allocate(32)
    If context is equal to 0:
        Return 0  Note: Allocation failed
    End If

    Note: Duplicate strings so they persist
    Let dup_label_name be 0
    If label_name is not equal to 0:
        Set dup_label_name to string_duplicate(label_name)
    End If

    Let dup_break_label be string_duplicate(break_label)
    Let dup_continue_label be string_duplicate(continue_label)

    Note: Initialize context
    memory_set_pointer(context, 0, dup_label_name)
    memory_set_pointer(context, 8, dup_break_label)
    memory_set_pointer(context, 16, dup_continue_label)
    memory_set_pointer(context, 24, loop_context_stack)

    Note: Push to stack
    Set loop_context_stack to context
    Return context
End Process

Process called "codegen_pop_loop_context" takes codegen as Integer returns Integer:
    Note: Pop loop context from stack and deallocate
    If loop_context_stack is equal to 0:
        Return 0  Note: Stack empty
    End If

    Let context be loop_context_stack
    Let prev be memory_get_pointer(context, 24)

    Note: Free strings
    Let label_name be memory_get_pointer(context, 0)
    Let break_label be memory_get_pointer(context, 8)
    Let continue_label be memory_get_pointer(context, 16)

    If label_name is not equal to 0:
        deallocate(label_name)
    End If
    If break_label is not equal to 0:
        deallocate(break_label)
    End If
    If continue_label is not equal to 0:
        deallocate(continue_label)
    End If

    Note: Free context and update stack
    deallocate(context)
    Set loop_context_stack to prev
    Return 1
End Process

Process called "codegen_find_loop_context" takes label_name as Integer returns Integer:
    Note: Find loop context by label name
    Note: If label_name is 0, return current context (simple break/continue)
    Note: Returns context pointer or 0 if not found

    If label_name is equal to 0:
        Return loop_context_stack  Note: Current loop (simple break/continue)
    End If

    Note: Search stack for matching label
    Let context be loop_context_stack
    While context is not equal to 0:
        Let context_label be memory_get_pointer(context, 0)
        If context_label is not equal to 0:
            If string_equals(context_label, label_name) is equal to 1:
                Return context  Note: Found matching label
            End If
        End If
        Set context to memory_get_pointer(context, 24)  Note: Move to prev
    End While

    Return 0  Note: Label not found
End Process

Note: Helper to concatenate strings using arena (for temporary strings)
Process called "codegen_arena_concat" takes codegen as Integer, str1 as Integer, str2 as Integer returns Integer:
    Let arena be memory_get_pointer(codegen, 88)
    Return arena_string_concat(arena, str1, str2)
End Process

Note: Helper to emit a line with newline
Process called "emit_line" takes output_file as Integer, line as Integer returns Integer:
    file_write_buffered(output_file, line, 0)
    file_write_buffered(output_file, "\n", 0)
    Return 0
End Process

Note: DJB2 hash function for strings
Process called "codegen_hash_string" takes key as Integer returns Integer:
    Let str_ptr be key
    Let hash be 5381
    Let c be memory_get_byte(str_ptr, 0)
    Let offset be 0
    While c is not equal to 0:
        Let hash_shifted be hash multiplied by 32
        Set hash to hash_shifted plus hash
        Set hash to hash plus c
        Set offset to offset plus 1
        Set c to memory_get_byte(str_ptr, offset)
    End While
    Return hash
End Process

Note: String comparison for hash table
Process called "codegen_compare_strings" takes key1 as Integer, key2 as Integer returns Integer:
    Let result be string_compare(key1, key2)
    If result is equal to 0:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Note: Find variable in current scope - OPTIMIZED with first-char check
Process called "codegen_find_variable" takes codegen as Integer, name as Integer returns Integer:
    Let variable_count be memory_get_int32(codegen, 16)  Note: codegen->variable_count (int)
    Let variables be memory_get_pointer(codegen, 8)        Note: codegen->variables

    Note: Optimization: get first character of search name
    Let name_first_char be memory_get_byte(name, 0)

    Let i be 0
    While i is less than variable_count:
        Let var_offset be i multiplied by 32
        Let var_ptr be variables plus var_offset  Note: sizeof(Variable) = 32
        Let var_name be memory_get_pointer(var_ptr, 0)

        Note: Fast path: check first character before expensive string_equals
        Let var_first_char be memory_get_byte(var_name, 0)
        If var_first_char is equal to name_first_char:
            If string_equals(var_name, name) is equal to 1:
                Return i
            End If
        End If

        Set i to i plus 1
    End While
    Return -1  Note: -1 for not found
End Process

Note: Calculate size of a type in bytes - equivalent to codegen_calculate_type_size
Process called "codegen_calculate_type_size" takes type_name as Integer, program as Integer returns Integer:
    Note: Built-in types
    If string_equals(type_name, "Integer") is equal to 1:
        Return 8  Note: 64-bit integer
    Otherwise If string_equals(type_name, "Byte") is equal to 1:
        Return 1  Note: 8-bit byte
    Otherwise If string_equals(type_name, "Short") is equal to 1:
        Return 2  Note: 16-bit short
    Otherwise If string_equals(type_name, "Long") is equal to 1:
        Return 8  Note: 64-bit long
    Otherwise If string_equals(type_name, "Float16") is equal to 1:
        Return 2  Note: 16-bit half precision float
    Otherwise If string_equals(type_name, "Float32") is equal to 1:
        Return 4  Note: 32-bit single precision float
    Otherwise If string_equals(type_name, "Float64") is equal to 1:
        Return 8  Note: 64-bit double precision float
    Otherwise If string_equals(type_name, "Float80") is equal to 1:
        Return 10  Note: 80-bit extended precision float
    Otherwise If string_equals(type_name, "Float128") is equal to 1:
        Return 16  Note: 128-bit quadruple precision float
    End If

    Note: Custom types - look up in the program
    If program is not equal to 0:
        Let type_count be memory_get_int32(program, 24)  Note: PROGRAM_TYPE_COUNT - use int32
        Let types be memory_get_pointer(program, 16)       Note: PROGRAM_TYPES - use pointer
        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)  Note: type->name
            If string_equals(type_name_ptr, type_name) is equal to 1:
                Let type_size be memory_get_int32(type_ptr, 40)  Note: TYPEDEFINITION_SIZE_OFFSET
                Return type_size
            End If
            Set i to i plus 1
        End While
    End If

    Note: Unknown type - default to 8 bytes
    Return 8
End Process

Note: Helper function to check if a type is a float type
Process called "codegen_is_float_type" takes type_name as Integer returns Integer:
    If type_name is equal to 0:
        Return 0
    End If
    If string_equals(type_name, "Float16") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Float32") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Float64") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Float80") is equal to 1:
        Return 1
    End If
    If string_equals(type_name, "Float128") is equal to 1:
        Return 1
    End If
    Return 0
End Process

Note: Add variable with type and parameter flag - equivalent to codegen_add_variable_with_type_and_param_flag
Process called "codegen_add_variable_with_type_and_param_flag" takes codegen as Integer, name as Integer, type_name as Integer, is_parameter as Integer returns Integer:
    Note: Get current counts and capacity

    Let variable_count be memory_get_int32(codegen, 16)      Note: codegen->variable_count (int)
    Let variable_capacity be memory_get_int32(codegen, 20)   Note: codegen->variable_capacity (int)
    Let variables be memory_get_pointer(codegen, 8)            Note: codegen->variables

    Note: DEBUG: Show what we read
    Note: print_integer(variable_count)
    Note: print_integer(variable_capacity)

    Note: Check for duplicate variable declaration (prevent Let shadowing)
    Note: Skip check for parameters (they can shadow outer variables)
    If is_parameter is equal to 0:
        Let check_i be 0
        While check_i is less than variable_count:
            Let check_var_offset be check_i multiplied by 32
            Let check_var_ptr be variables plus check_var_offset
            Let check_existing_name be memory_get_pointer(check_var_ptr, 0)
            Let check_is_param be memory_get_int32(check_var_ptr, 24)

            Note: Only check against other non-parameter variables
            If check_is_param is equal to 0:
                If string_equals(check_existing_name, name) is equal to 1:
                    print_string("[CODEGEN ERROR] Variable '")
                    print_string(name)
                    print_string("' is already declared. Use 'Set' to reassign.")
                    print_newline()
                    exit_with_code(1)
                End If
            End If

            Set check_i to check_i plus 1
        End While
    End If

    Note: Grow array if needed
    If variable_count is greater than or equal to variable_capacity:
        Let new_capacity be variable_capacity multiplied by 2
        Let new_size be new_capacity multiplied by 32  Note: sizeof(Variable)
        Let new_variables be allocate(new_size)

        Note: Copy existing variables
        Let i be 0
        While i is less than variable_count:
            Let var_offset be i multiplied by 32
            Let old_var be variables plus var_offset
            Set var_offset to i multiplied by 32
            Let new_var be new_variables plus var_offset
            Note: Copy Variable struct (32 bytes)
            memory_copy(new_var, old_var, 32)
            Set i to i plus 1
        End While

        Note: Free old array and update
        deallocate(variables)
        memory_set_pointer(codegen, 8, new_variables)      Note: codegen->variables
        memory_set_int32(codegen, 20, new_capacity)      Note: codegen->variable_capacity (int)
        Set variables to new_variables
    End If

    Note: Calculate size based on type
    Let current_program be memory_get_pointer(codegen, 48)  Note: codegen->current_program (pointer with padding)
    Let size be codegen_calculate_type_size(type_name, current_program)
    If type_name is equal to 0:
        Set size to codegen_calculate_type_size("Integer", current_program)
    End If

    Note: Update stack offset
    Let stack_offset be memory_get_int32(codegen, 24)  Note: codegen->stack_offset (int)
    Let new_stack_offset be stack_offset plus size
    memory_set_int32(codegen, 24, new_stack_offset)  Note: codegen->stack_offset (int)

    Note: Get variable index
    Let var_index be variable_count
    Set var_offset to var_index multiplied by 32  Note: Calculate offset separately
    Let var_ptr be variables plus var_offset      Note: Then add to base pointer


    Note: Set variable fields
    memory_set_pointer(var_ptr, 0, string_duplicate(name))       Note: name
    memory_set_int32(var_ptr, 8, new_stack_offset)            Note: stack_offset (int)
    If type_name is equal to 0:
        memory_set_pointer(var_ptr, 16, string_duplicate("Integer")) Note: type_name - use literal directly
    Otherwise:
        memory_set_pointer(var_ptr, 16, string_duplicate(type_name)) Note: type_name
    End If
    memory_set_int32(var_ptr, 24, is_parameter)               Note: is_parameter (int)

    Note: Increment count
    memory_set_int32(codegen, 16, variable_count plus 1)  Note: codegen->variable_count (int)

    Return var_index
End Process

Note: Add variable with type - equivalent to codegen_add_variable_with_type
Process called "codegen_add_variable_with_type" takes codegen as Integer, name as Integer, type_name as Integer returns Integer:
    Return codegen_add_variable_with_type_and_param_flag(codegen, name, type_name, 0)
End Process

Note: Add variable with default Integer type - equivalent to codegen_add_variable
Process called "codegen_add_variable" takes codegen as Integer, name as Integer returns Integer:
    Return codegen_add_variable_with_type(codegen, name, "Integer")
End Process

Note: Add string literal - equivalent to codegen_add_string_literal
Process called "codegen_add_string_literal" takes codegen as Integer, value as Integer returns Integer:
    Note: Get current counts and capacity
    Let string_count be memory_get_int32(codegen, 40)      Note: codegen->string_count (int)
    Let string_capacity be memory_get_int32(codegen, 44)   Note: codegen->string_capacity (int)
    Let strings be memory_get_pointer(codegen, 32)           Note: codegen->strings (pointer with padding)


    Note: Grow array if needed
    If string_count is greater than or equal to string_capacity:
        Let new_capacity be string_capacity multiplied by 2
        Let new_size be new_capacity multiplied by 16  Note: sizeof(StringLiteral)
        Let new_strings be allocate(new_size)

        Note: Copy existing strings
        Let i be 0
        While i is less than string_count:
            Let str_offset be i multiplied by 16
            Let old_str be strings plus str_offset
            Set str_offset to i multiplied by 16
            Let new_str be new_strings plus str_offset
            Note: Copy StringLiteral struct (16 bytes)
            memory_copy(new_str, old_str, 16)
            Set i to i plus 1
        End While

        Note: Free old array and update
        deallocate(strings)
        memory_set_pointer(codegen, 32, new_strings)      Note: codegen->strings (pointer)
        memory_set_int32(codegen, 44, new_capacity)     Note: codegen->string_capacity (int)
        Set strings to new_strings
    End If

    Let str_index be string_count
    Set str_offset to str_index multiplied by 16
    Let str_ptr be strings plus str_offset

    Note: Set string value
    memory_set_pointer(str_ptr, 0, string_duplicate(value))  Note: value

    Note: Generate unique label for this string
    Let label be string_concat(".STR", codegen_arena_int_to_str(codegen, str_index))
    memory_set_pointer(str_ptr, 8, label)  Note: label

    Note: Increment count
    memory_set_int32(codegen, 40, string_count plus 1)  Note: codegen->string_count (int)


    Return str_index
End Process

Note: Collect strings from expression - equivalent to codegen_collect_strings_from_expression
Process called "codegen_collect_strings_from_expression" takes codegen as Integer, expr as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If
    Note: Safety check for invalid pointers
    If expr is equal to 0:
        Return 0
    End If

    Let expr_type be memory_get_int32(expr, 0)  Note: expr->type (32-bit)


    If expr_type is equal to 5:  Note: EXPR_STRING_LITERAL
        Note: Check if string already exists
        Let string_count be memory_get_int32(codegen, 40)  Note: codegen->string_count (int)
        Let strings be memory_get_pointer(codegen, 32)  Note: codegen->strings (pointer)
        Let string_literal be memory_get_pointer(expr, 8)  Note: expr->data.string_literal (union at offset 4)

        Note: Safety check for string_literal
        If string_literal is equal to 0:
            Return 0
        End If
        If string_literal is equal to 0:
            Return 0
        End If

        Note: Safety check - string_count should be reasonable
        If string_count is less than 0:
            Return 0
        End If
        Note: Don't limit string count - allow as many as needed
        Note: If string_count is greater than 1000:
        Note:     Return 0
        Note: End If

        Let i be 0
        While i is less than string_count:
            Let str_offset be i multiplied by 16
            Let str_ptr be strings plus str_offset
            Let existing_value be memory_get_pointer(str_ptr, 0)  Note: Should be pointer, not integer!
            Note: Safety check for existing_value before comparison
            If existing_value is not equal to 0:
                If existing_value is greater than 65536:
                    If string_equals(existing_value, string_literal) is equal to 1:
                        Return 0  Note: Already added
                    End If
                End If
            End If
            Set i to i plus 1
        End While

        codegen_add_string_literal(codegen, string_literal)
        Return 0
    End If

    If expr_type is equal to 25:  Note: EXPR_FLOAT_LITERAL
        Note: Float literals contain string representations that need to be in the string table
        Let float_value_string be memory_get_pointer(expr, 8)  Note: expr->data.float_literal.value_string
        If float_value_string is not equal to 0:
            codegen_add_string_literal(codegen, float_value_string)
        End If
        Return 0
    End If

    If expr_type is equal to 2:  Note: EXPR_BINARY_OP
        Let left be memory_get_pointer(expr, 8)   Note: binary_op.left
        Let right be memory_get_pointer(expr, 16) Note: binary_op.right
        codegen_collect_strings_from_expression(codegen, left)
        codegen_collect_strings_from_expression(codegen, right)
        Return 0
    End If

    If expr_type is equal to 3:  Note: EXPR_COMPARISON
        Set left to memory_get_pointer(expr, 8)   Note: comparison.left
        Set right to memory_get_pointer(expr, 16) Note: comparison.right
        codegen_collect_strings_from_expression(codegen, left)
        codegen_collect_strings_from_expression(codegen, right)
        Return 0
    End If

    If expr_type is equal to 4:  Note: EXPR_FUNCTION_CALL
        Let func_call_ptr be expr plus 8  Note: &expr->data.function_call
        Note: function_call structure: function_name (char*) at 0, arguments (Expression**) at 8, argument_count (int) at 16
        Let function_name be memory_get_pointer(func_call_ptr, 0)  Note: function_call.function_name
        Let arguments be memory_get_pointer(func_call_ptr, 8)      Note: function_call.arguments - this is a pointer!
        Let argument_count be memory_get_int32(func_call_ptr, 16) Note: function_call.argument_count


        Set i to 0
        While i is less than argument_count:
            Let arg_offset be i multiplied by 8
            Let arg_ptr be memory_get_pointer(arguments, arg_offset)


            codegen_collect_strings_from_expression(codegen, arg_ptr)
            Set i to i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 6:  Note: EXPR_FIELD_ACCESS
        Let object be memory_get_pointer(expr, 8)  Note: field_access.object
        codegen_collect_strings_from_expression(codegen, object)
        Return 0
    End If

    If expr_type is equal to 8:  Note: EXPR_BUILTIN_CALL
        Let builtin_call_ptr be expr plus 8  Note: &expr->data.builtin_call
        Note: builtin_call structure: builtin_type (int) at 0, arguments (Expression**) at 8, argument_count (int) at 16
        Let builtin_type be memory_get_int32(builtin_call_ptr, 0)  Note: builtin_call.builtin_type
        Set arguments to memory_get_pointer(builtin_call_ptr, 8)      Note: builtin_call.arguments - this is a pointer!
        Set argument_count to memory_get_int32(builtin_call_ptr, 16) Note: builtin_call.argument_count

        Set i to 0
        While i is less than argument_count:
            Set arg_offset to i multiplied by 8
            Set arg_ptr to memory_get_pointer(arguments, arg_offset)
            codegen_collect_strings_from_expression(codegen, arg_ptr)
            Set i to i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 9:  Note: EXPR_VARIANT_CONSTRUCTOR
        Let variant_constructor_ptr be expr plus 8  Note: &expr->data.variant_constructor
        Note: variant_constructor structure: type_name (char*) at 0, variant_name (char*) at 8, field_values (Expression**) at 16, field_count (int) at 24
        Let type_name be memory_get_pointer(variant_constructor_ptr, 0)     Note: variant_constructor.type_name
        Let variant_name be memory_get_pointer(variant_constructor_ptr, 8)  Note: variant_constructor.variant_name
        Let field_values be memory_get_pointer(variant_constructor_ptr, 16) Note: variant_constructor.field_values - this is a pointer!
        Let field_count be memory_get_int32(variant_constructor_ptr, 24)  Note: variant_constructor.field_count

        Set i to 0
        While i is less than field_count:
            Let field_offset be i multiplied by 8
            Let field_value_ptr be memory_get_pointer(field_values, field_offset)  Note: This is also a pointer!
            codegen_collect_strings_from_expression(codegen, field_value_ptr)
            Set i to i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 16:  Note: EXPR_ARRAY_INDEX
        Let array_index_ptr be expr plus 8  Note: &expr->data.array_index
        Let arr be memory_get_pointer(array_index_ptr, 0)  Note: array_index.array (FIX: use memory_get_pointer, not _integer)
        Let index be memory_get_pointer(array_index_ptr, 8)  Note: array_index.index (FIX: use memory_get_pointer, not _integer)
        codegen_collect_strings_from_expression(codegen, arr)
        codegen_collect_strings_from_expression(codegen, index)
        Return 0
    End If

    If expr_type is equal to 20:  Note: EXPR_STRUCT_CONSTRUCTION
        Set field_values to memory_get_pointer(expr, 24)
        Set field_count to memory_get_int32(expr, 32)
        Let field_i be 0
        While field_i is less than field_count:
            Let field_ptr_offset be field_i multiplied by 8
            Let field_value_expr be memory_get_pointer(field_values, field_ptr_offset)
            codegen_collect_strings_from_expression(codegen, field_value_expr)
            Set field_i to field_i plus 1
        End While
        Return 0
    End If

    Note: Other expression types (INTEGER, VARIABLE, TYPE_NAME, FUNCTION_POINTER) have no strings to collect
    Return 0
End Process

Note: Collect strings from statement - equivalent to codegen_collect_strings_from_statement
Process called "codegen_collect_strings_from_statement" takes codegen as Integer, stmt as Integer returns Integer:
    If stmt is equal to 0:
        Return 0
    End If

    Note: Safety check - if stmt is NULL, skip it
    If stmt is equal to 0:
        Return 0
    End If

    Let stmt_type be memory_get_int32(stmt, 0)  Note: stmt->type


    Note: Safety check - statement types should be reasonable (0-17 for now, including STMT_COMPOUND_ASSIGN = 17)
    If stmt_type is less than 0:
        Return 0
    End If
    If stmt_type is greater than 17:
        Return 1
    End If

    If stmt_type is equal to 1:  Note: STMT_LET
        Note: Statement structure: type at 0, data union at 8
        Note: let_stmt in union: var_name at 0, expression at 8
        Let var_name be memory_get_pointer(stmt, 8)   Note: stmt+8 = let_stmt.var_name
        Let expression be memory_get_pointer(stmt, 16) Note: stmt+16 = let_stmt.expression


        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 2:  Note: STMT_SET
        Note: Statement structure: type at 0, data union at 8
        Note: set_stmt in union: target at 0, expression at 8
        Let target be memory_get_pointer(stmt, 8)      Note: stmt+8 = set_stmt.target
        Set expression to memory_get_pointer(stmt, 16) Note: stmt+16 = set_stmt.expression
        codegen_collect_strings_from_expression(codegen, target)
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 3:  Note: STMT_RETURN
        Let return_stmt_ptr be stmt plus 8  Note: &stmt->data.return_stmt
        Set expression to memory_get_pointer(return_stmt_ptr, 0)  Note: return_stmt.expression
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 4:  Note: STMT_PRINT
        Let print_stmt_ptr be stmt plus 8  Note: &stmt->data.print_stmt
        Set expression to memory_get_pointer(print_stmt_ptr, 0)  Note: print_stmt.expression
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 5:  Note: STMT_IF

        Let if_stmt_ptr be stmt plus 8  Note: &stmt->data.if_stmt
        Let condition be memory_get_pointer(if_stmt_ptr, 0)        Note: if_stmt.condition (offset 8)
        Let if_body be memory_get_pointer(if_stmt_ptr, 8)          Note: if_stmt.if_body (offset 16)
        Let if_body_count be memory_get_int32(if_stmt_ptr, 16)   Note: if_stmt.if_body_count (offset 24)
        Let else_body be memory_get_pointer(if_stmt_ptr, 24)       Note: if_stmt.else_body (offset 32)
        Let else_body_count be memory_get_int32(if_stmt_ptr, 32) Note: if_stmt.else_body_count (offset 40)


        codegen_collect_strings_from_expression(codegen, condition)

        Note: Process if body - add safety check
        If if_body is not equal to 0:  Note: NULL pointer check
            Let i be 0
            While i is less than if_body_count:
                Let stmt_offset be i multiplied by 8


                Let stmt_ptr be memory_get_pointer(if_body, stmt_offset)


                codegen_collect_strings_from_statement(codegen, stmt_ptr)
                Set i to i plus 1
            End While
        End If

        Note: Process else body - add safety check
        If else_body is not equal to 0:  Note: NULL pointer check
            Set i to 0
            While i is less than else_body_count:
                Set stmt_offset to i multiplied by 8
                Set stmt_ptr to memory_get_pointer(else_body, stmt_offset)
                codegen_collect_strings_from_statement(codegen, stmt_ptr)
                Set i to i plus 1
            End While
        End If
        Return 0
    End If

    If stmt_type is equal to 6:  Note: STMT_WHILE
        Let while_stmt_ptr be stmt plus 8  Note: &stmt->data.while_stmt
        Set condition to memory_get_pointer(while_stmt_ptr, 0)   Note: while_stmt.condition (offset 8)
        Let body be memory_get_pointer(while_stmt_ptr, 8)        Note: while_stmt.body (offset 16)
        Let body_count be memory_get_int32(while_stmt_ptr, 16) Note: while_stmt.body_count (offset 24)

        codegen_collect_strings_from_expression(codegen, condition)

        Note: Process body
        Set i to 0
        While i is less than body_count:
            Set stmt_offset to i multiplied by 8
            Set stmt_ptr to memory_get_pointer(body, stmt_offset)
            codegen_collect_strings_from_statement(codegen, stmt_ptr)
            Set i to i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 6:  Note: STMT_WHILE
        Note: This is the duplicate WHILE check, should be removed but keeping for now
        Set while_stmt_ptr to stmt plus 8  Note: &stmt->data.while_stmt
        Set condition to memory_get_pointer(while_stmt_ptr, 0)   Note: while_stmt.condition (offset 8)
        Set body to memory_get_pointer(while_stmt_ptr, 8)        Note: while_stmt.body (offset 16)
        Set body_count to memory_get_int32(while_stmt_ptr, 16) Note: while_stmt.body_count (offset 24)

        codegen_collect_strings_from_expression(codegen, condition)

        Set i to 0
        While i is less than body_count:
            Set stmt_offset to i multiplied by 8
            Set stmt_ptr to memory_get_pointer(body, stmt_offset)
            codegen_collect_strings_from_statement(codegen, stmt_ptr)
            Set i to i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 7:  Note: STMT_EXPRESSION
        Let expr_stmt_ptr be stmt plus 8  Note: &stmt->data.expr_stmt
        Set expression to memory_get_pointer(expr_stmt_ptr, 0)  Note: expr_stmt.expression - this is a pointer!
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 8:  Note: STMT_MATCH
        Note: Collect strings from match expression and when clause bodies
        Let match_expr be memory_get_pointer(stmt, 8)  Note: STMT_MATCH_EXPR
        codegen_collect_strings_from_expression(codegen, match_expr)

        Let when_clauses be memory_get_pointer(stmt, 16)  Note: STMT_MATCH_WHEN_CLAUSES
        Let when_count be memory_get_int32(stmt, 24)  Note: STMT_MATCH_WHEN_COUNT

        Note: Process each when clause (48 bytes each)
        Set i to 0
        While i is less than when_count:
            Let clause_offset be i multiplied by 48
            Let clause_ptr be when_clauses plus clause_offset
            Let pattern_type be memory_get_int32(clause_ptr, 0)
            Let pattern_value be memory_get_pointer(clause_ptr, 8)
            Let body_stmts be memory_get_pointer(clause_ptr, 32)
            Set body_count to memory_get_integer(clause_ptr, 40)

            Note: Collect strings from pattern value (expression for literals)
            If pattern_type is equal to 0:  Note: PATTERN_LITERAL
                codegen_collect_strings_from_expression(codegen, pattern_value)
            End If

            Note: Collect strings from body statements
            Let j be 0
            While j is less than body_count:
                Set stmt_offset to j multiplied by 8
                Set stmt_ptr to memory_get_pointer(body_stmts, stmt_offset)
                codegen_collect_strings_from_statement(codegen, stmt_ptr)
                Set j to j plus 1
            End While

            Set i to i plus 1
        End While
        Return 0
    End If

    Note: STMT_COMPOUND_ASSIGN: target at offset 8, expression at offset 24
    If stmt_type is equal to 17:
        Set target to memory_get_pointer(stmt, 8)
        Set expression to memory_get_pointer(stmt, 24)
        Let result1 be codegen_collect_strings_from_expression(codegen, target)
        Let result2 be codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    Note: STMT_FOR: start at offset 16, end at offset 24, step at offset 32, body at offset 40
    If stmt_type is equal to 11:
        Let start_expr be memory_get_pointer(stmt, 16)
        Let end_expr be memory_get_pointer(stmt, 24)
        Let step_expr be memory_get_pointer(stmt, 32)
        Set body to memory_get_pointer(stmt, 40)
        Set body_count to memory_get_integer(stmt, 48)

        Set result1 to codegen_collect_strings_from_expression(codegen, start_expr)
        Set result2 to codegen_collect_strings_from_expression(codegen, end_expr)
        If step_expr is not equal to 0:
            Let result3 be codegen_collect_strings_from_expression(codegen, step_expr)
        End If

        Set i to 0
        While i is less than body_count:
            Let body_stmt be memory_get_pointer(body, i multiplied by 8)
            Let result_body be codegen_collect_strings_from_statement(codegen, body_stmt)
            Set i to i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 12:  Note: STMT_FOR_EACH
        Let collection_expr be memory_get_pointer(stmt, 16)
        Set body to memory_get_pointer(stmt, 24)
        Set body_count to memory_get_integer(stmt, 32)

        Set result1 to codegen_collect_strings_from_expression(codegen, collection_expr)

        Set i to 0
        While i is less than body_count:
            Set body_stmt to memory_get_pointer(body, i multiplied by 8)
            Set result_body to codegen_collect_strings_from_statement(codegen, body_stmt)
            Set i to i plus 1
        End While
        Return 0
    End If

    Note: Other statement types (IMPORT, BREAK, CONTINUE, INLINE_ASSEMBLY) don't have strings to collect
    Return 0
End Process

Note: Helper function to determine the type name of an expression
Process called "codegen_get_expression_type" takes codegen as Integer, expr as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If

    Let expr_type be memory_get_int32(expr, 0)  Note: expr->type

    If expr_type is equal to 1:  Note: EXPR_VARIABLE
        Let variable_name be memory_get_pointer(expr, 8)  Note: expr->data.variable_name
        Let var_index be codegen_find_variable(codegen, variable_name)

        If var_index is less than 0:  Note: -1 for not found
            Note: Check if this is a global variable
            Let current_program be memory_get_pointer(codegen, 48)  Note: codegen->current_program (pointer with padding)
            If current_program is not equal to 0:
                Let global_count be memory_get_int32(current_program, 56)  Note: program->global_count (PROGRAM_GLOBAL_COUNT)
                Let globals be memory_get_pointer(current_program, 48)       Note: program->globals (PROGRAM_GLOBAL_VARS)

                Let j be 0
                While j is less than global_count:
                    Let global_offset be j multiplied by 8
                    Let global_ptr be memory_get_pointer(globals, global_offset)
                    Let global_name be memory_get_pointer(global_ptr, 0)  Note: global->name
                    If string_equals(global_name, variable_name) is equal to 1:
                        Let global_type be memory_get_integer(global_ptr, 8)  Note: global->type
                        Return global_type
                    End If
                    Set j to j plus 1
                End While
            End If
            Return 0
        End If

        Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
        Let var_offset be var_index multiplied by 32
        Let var_ptr be variables plus var_offset
        Let type_name be memory_get_pointer(var_ptr, 16)  Note: variable.type_name
        Return type_name
    End If

    If expr_type is equal to 6:  Note: EXPR_FIELD_ACCESS
        Let field_access_ptr be expr plus 8  Note: &expr->data.field_access
        Let object be memory_get_pointer(field_access_ptr, 0)       Note: field_access.object
        Let field_name be memory_get_pointer(field_access_ptr, 8)   Note: field_access.field_name

        Note: Get the type of the object
        Let object_type be codegen_get_expression_type(codegen, object)
        If object_type is equal to 0:
            Return 0
        End If

        Note: Find the type definition
        Set current_program to memory_get_pointer(codegen, 48)  Note: codegen->current_program (pointer with padding)
        Let type_count be memory_get_int32(current_program, 24)  Note: PROGRAM_TYPE_COUNT
        Let types be memory_get_pointer(current_program, 16)       Note: PROGRAM_TYPES
        Let type be 0

        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)  Note: type->name
            If string_equals(type_name_ptr, object_type) is equal to 1:
                Set type to type_ptr
                Set i to type_count  Note: break loop
            End If
            Set i to i plus 1
        End While

        If type is equal to 0:
            Return 0
        End If

        Note: Find the field and return its type
        Let kind be memory_get_int32(type, 8)  Note: type->kind
        If kind is equal to 0:  Note: TYPE_KIND_STRUCT
            Note: TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET is 24
            Note: TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET is 16
            Let field_count be memory_get_int32(type, 24)
            Let fields be memory_get_pointer(type, 16)

            Set i to 0
            While i is less than field_count:
                Let field_offset be i multiplied by 24
                Let field_ptr be fields plus field_offset  Note: sizeof(FieldDefinition)
                Let field_name_ptr be memory_get_pointer(field_ptr, 0)  Note: field.name
                If string_equals(field_name_ptr, field_name) is equal to 1:
                    Let field_type be memory_get_pointer(field_ptr, 8)  Note: field.type
                    Return field_type
                End If
                Set i to i plus 1
            End While
        End If

        Return 0
    End If

    If expr_type is equal to 20:  Note: EXPR_STRUCT_CONSTRUCTION
        Let struct_type_name be memory_get_pointer(expr, 8)
        Return struct_type_name
    End If

    If expr_type is equal to 5:  Note: EXPR_STRING_LITERAL
        Return "String"
    End If

    If expr_type is equal to 25:  Note: EXPR_FLOAT_LITERAL
        Note: Float literal structure: type(4), value_string(8), float_type(4)
        Note: float_type: 1=Float16, 2=Float32, 3=Float64, 4=Float80, 5=Float128
        Let float_type be memory_get_int32(expr, 16)  Note: expr->data.float_literal.float_type
        If float_type is equal to 1:
            Return "Float16"
        Otherwise If float_type is equal to 2:
            Return "Float32"
        Otherwise If float_type is equal to 3:
            Return "Float64"
        Otherwise If float_type is equal to 4:
            Return "Float80"
        Otherwise If float_type is equal to 5:
            Return "Float128"
        End If
        Return "Float64"  Note: Default to Float64
    End If

    Note: Other expression types don't have determinable types in this context
    Return 0
End Process

Note: Generate the address of an lvalue expression (result in %rbx)
Process called "codegen_generate_lvalue_address" takes codegen as Integer, expr as Integer returns Integer:
    Let expr_type be memory_get_int32(expr, 0)  Note: expr->type
    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file

    If expr_type is equal to 1:  Note: EXPR_VARIABLE
        Note: Find variable and generate its address
        Let variable_name be memory_get_pointer(expr, 8)  Note: expr->data.variable_name
        Let var_index be codegen_find_variable(codegen, variable_name)

        If var_index is less than 0:  Note: -1 for not found
            Note: Check if this is a global variable
            Let is_global be 0
            Let current_program be memory_get_pointer(codegen, 48)  Note: codegen->current_program (pointer with padding)

            If current_program is not equal to 0:
                Let global_count be memory_get_int32(current_program, 56)  Note: program->global_count (PROGRAM_GLOBAL_COUNT)
                Let globals be memory_get_pointer(current_program, 48)       Note: program->globals (PROGRAM_GLOBAL_VARS)

                Let j be 0
                While j is less than global_count:
                    Let global_offset be j multiplied by 8
                    Let global_ptr be memory_get_pointer(globals, global_offset)
                    Let global_name be memory_get_pointer(global_ptr, 0)  Note: global->name
                    If string_equals(global_name, variable_name) is equal to 1:
                        Set is_global to 1
                        Set j to global_count  Note: break loop
                    End If
                    Set j to j plus 1
                End While
            End If

            If is_global is equal to 1:
                Note: Generate address of global variable
                file_write_buffered(output_file, "    leaq ", 0)
                file_write_buffered(output_file, variable_name, 0)
                file_write_buffered(output_file, "(%rip), %rbx  # Address of global variable", 0)
            Otherwise:
                print_string("[CODEGEN ERROR] Unknown variable '")
                print_string(variable_name)
                print_string("'")
                exit_with_code(1)
            End If
        Otherwise:
            Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
            Let var_offset be var_index multiplied by 32
            Let var_ptr be variables plus var_offset
            Let offset be memory_get_int32(var_ptr, 8)  Note: variable.stack_offset

            Note: Generate address of variable on stack
            file_write_buffered(output_file, "    leaq -", 0)
            file_write_buffered(output_file, integer_to_string(offset), 0)
            file_write_buffered(output_file, "(%rbp), %rbx\n", 0)
        End If
        Return 0
    End If

    If expr_type is equal to 6:  Note: EXPR_FIELD_ACCESS
        Let field_access_ptr be expr plus 8  Note: &expr->data.field_access
        Let object be memory_get_pointer(field_access_ptr, 0)     Note: field_access.object
        Let field_name be memory_get_pointer(field_access_ptr, 8) Note: field_access.field_name

        Note: For field access, we need the POINTER VALUE, not the address of the pointer variable
        Note: If object is a variable, we need to load its value (the pointer)
        Let obj_type be memory_get_int32(object, 0)
        If obj_type is equal to 1:  Note: EXPR_VARIABLE - load the pointer value
            Set variable_name to memory_get_pointer(object, 8)
            Set var_index to codegen_find_variable(codegen, variable_name)
            If var_index is less than 0:
                print_string("[CODEGEN ERROR] Unknown variable in field access")
                exit_with_code(1)
            End If
            Set variables to memory_get_pointer(codegen, 8)
            Set var_offset to var_index multiplied by 32
            Set var_ptr to variables plus var_offset
            Let stack_offset be memory_get_int32(var_ptr, 8)
            file_write_buffered(output_file, "    movq -", 0)
            file_write_buffered(output_file, integer_to_string(stack_offset), 0)
            file_write_buffered(output_file, "(%rbp), %rbx  # Load struct pointer\n", 0)
        Otherwise:
            Note: For other expressions, generate their value and use that as the pointer
            codegen_generate_expression(codegen, object)
            file_write_buffered(output_file, "    movq %rax, %rbx  # Use expression result as pointer\n", 0)
        End If

        Note: Now %rbx contains the struct pointer value
        Note: We need to add the field offset to get the field address

        Note: Get the type of the object using our helper function
        Let object_type be codegen_get_expression_type(codegen, object)
        If object_type is equal to 0:
            print_string("[CODEGEN ERROR] Cannot determine type of object in field access")
            exit_with_code(1)
        End If

        Note: Find the type definition
        Set current_program to memory_get_pointer(codegen, 48)  Note: codegen->current_program (pointer with padding)
        Let type_count be memory_get_int32(current_program, 24)  Note: PROGRAM_TYPE_COUNT
        Let types be memory_get_pointer(current_program, 16)       Note: PROGRAM_TYPES
        Let type be 0

        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)  Note: type->name
            If string_equals(type_name_ptr, object_type) is equal to 1:
                Set type to type_ptr
                Set i to type_count  Note: break loop
            End If
            Set i to i plus 1
        End While

        If type is equal to 0:
            print_string("[CODEGEN ERROR] Unknown type '")
            print_string(object_type)
            print_string("'")
            exit_with_code(1)
        End If

        Note: Find field offset
        Let field_offset be -1  Note: -1 for not found
        Let kind be memory_get_int32(type, 8)  Note: type->kind

        If kind is equal to 0:  Note: TYPE_KIND_STRUCT
            Note: TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET is 24
            Note: TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET is 16
            Let field_count be memory_get_int32(type, 24)
            Let fields be memory_get_pointer(type, 16)

            Set i to 0
            While i is less than field_count:
                Let field_idx_offset be i multiplied by 24
                Let field_ptr be fields plus field_idx_offset  Note: sizeof(FieldDefinition)
                Let field_name_ptr be memory_get_pointer(field_ptr, 0)  Note: field.name
                If string_equals(field_name_ptr, field_name) is equal to 1:
                    Set field_offset to memory_get_int32(field_ptr, 16)  Note: field.offset
                    Set i to field_count  Note: break loop
                End If
                Set i to i plus 1
            End While
        End If

        If field_offset is less than 0:  Note: -1 for not found
            print_string("[CODEGEN ERROR] Type '")
            print_string(object_type)
            print_string("' has no field '")
            print_string(field_name)
            print_string("'")
            exit_with_code(1)
        End If

        Note: Add field offset to object address
        file_write_buffered(output_file, "    addq $", 0)
        file_write_buffered(output_file, integer_to_string(field_offset), 0)
        file_write_buffered(output_file, ", %rbx\n", 0)
        Return 0
    End If

    If expr_type is equal to 16:  Note: EXPR_ARRAY_INDEX
        Let array_index_ptr be expr plus 8  Note: &expr->data.array_index
        Let arr be memory_get_pointer(array_index_ptr, 0)  Note: array_index.array (FIX: use memory_get_pointer, not _integer)
        Let index be memory_get_pointer(array_index_ptr, 8)  Note: array_index.index (FIX: use memory_get_pointer, not _integer)

        Note: Check if the array is a parameter or local variable
        Let array_type be memory_get_int32(arr, 0)  Note: array->type
        If array_type is equal to 1:  Note: EXPR_VARIABLE
            Let array_variable_name be memory_get_pointer(arr, 8)  Note: array->data.variable_name
            Set var_index to codegen_find_variable(codegen, array_variable_name)

            If var_index is greater than or equal to 0:  Note: found variable
                Set variables to memory_get_pointer(codegen, 8)  Note: codegen->variables
                Set var_offset to var_index multiplied by 32
                Set var_ptr to variables plus var_offset
                Let is_parameter be memory_get_int32(var_ptr, 24)  Note: variable.is_parameter

                If is_parameter is equal to 1:
                    Note: For array parameters, load the pointer value, not the address
                    Set offset to memory_get_int32(var_ptr, 8)  Note: variable.stack_offset
                    file_write_buffered(output_file, "    movq -", 0)
                    file_write_buffered(output_file, integer_to_string(offset), 0)
                    file_write_buffered(output_file, "(%rbp), %rbx  # Load array parameter pointer", 0)
                Otherwise:
                    Note: For local arrays, generate the address
                    codegen_generate_lvalue_address(codegen, arr)
                End If
            Otherwise:
                Note: For complex expressions, generate the address
                codegen_generate_lvalue_address(codegen, arr)
            End If
        Otherwise:
            Note: For complex expressions, generate the address
            codegen_generate_lvalue_address(codegen, arr)
        End If

        Note: Save base address
        emit_line(output_file, "    pushq %rbx")

        Note: Generate index expression
        codegen_generate_expression(codegen, index)

        Note: Pop base address
        emit_line(output_file, "    popq %rbx")

        Note: Calculate element address: base + (index * element_size)
        Note: For arrays, all elements are currently 8 bytes (Integer size)
        emit_line(output_file, "    imulq $8, %rax")
        emit_line(output_file, "    addq %rax, %rbx")
        Return 0
    End If

    Note: Invalid lvalue expression type
    print_string("[CODEGEN ERROR] Invalid lvalue expression type")
    exit_with_code(1)
    Return 0
End Process

Note: Helper function to generate integer literal expression
Process called "codegen_generate_integer_expr" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file
    Let integer_value be memory_get_pointer(expr, 8)  Note: expr->data.integer_value
    file_write_buffered(output_file, "    movq $", 0)
    file_write_buffered(output_file, integer_to_string(integer_value), 0)
    file_write_buffered(output_file, ", %rax\n", 0)
    Return 0
End Process

Note: Helper function to generate variable expression
Process called "codegen_generate_variable_expr" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let variable_name be memory_get_pointer(expr, 8)  Note: expr->data.variable_name
    Let var_index be codegen_find_variable(codegen, variable_name)

    If var_index is less than 0:  Note: -1 for not found
        Note: Check if this is a global variable
        Let is_global be 0
        Let current_program be memory_get_pointer(codegen, 48)

        If current_program is not equal to 0:
            Let global_count be memory_get_int32(current_program, 56)  Note: PROGRAM_GLOBAL_COUNT
            Let globals be memory_get_pointer(current_program, 48)  Note: PROGRAM_GLOBAL_VARS

            Let j be 0
            Let found_global_ptr be 0
            While j is less than global_count:
                Let global_offset be j multiplied by 8
                Let global_ptr be memory_get_pointer(globals, global_offset)
                Let global_name be memory_get_pointer(global_ptr, 0)
                If string_equals(global_name, variable_name) is equal to 1:
                    Set is_global to 1
                    Set found_global_ptr to global_ptr
                    Set j to global_count
                End If
                Set j to j plus 1
            End While
        End If

        If is_global is equal to 1:
            Note: Check if this global has an integer initial_value (compile-time constant)
            Let initial_value be memory_get_pointer(found_global_ptr, 16)  Note: global->initial_value
            If initial_value is not equal to 0:
                Let expr_type be memory_get_int32(initial_value, 0)  Note: initial_value->type
                If expr_type is equal to 0:  Note: EXPR_INTEGER (compile-time constant)
                    Let integer_value be memory_get_pointer(initial_value, 8)  Note: initial_value->data.integer_value
                    file_write_buffered(output_file, "    movq $", 0)
                    file_write_buffered(output_file, integer_to_string(integer_value), 0)
                    file_write_buffered(output_file, ", %rax  # Load compile-time constant ", 0)
                    file_write_buffered(output_file, variable_name, 0)
                    file_write_buffered(output_file, "\n", 0)
                    Return 0
                End If
            End If
            Note: Not a compile-time constant, generate runtime access
            file_write_buffered(output_file, "    movq ", 0)
            file_write_buffered(output_file, variable_name, 0)
            file_write_buffered(output_file, "(%rip), %rax  # Load global variable\n", 0)
            Return 0
        End If

        Note: Check if function name
        Let is_function be 0
        If current_program is not equal to 0:
            Let function_count be memory_get_int32(current_program, 8)  Note: PROGRAM_FUNCTION_COUNT
            Let functions be memory_get_pointer(current_program, 0)  Note: PROGRAM_FUNCTIONS

            Note: Optimization: get first character for fast filtering
            Let name_first_char be memory_get_byte(variable_name, 0)

            Set j to 0
            While j is less than function_count:
                Let func_offset be j multiplied by 8
                Let function_ptr be memory_get_pointer(functions, func_offset)
                Let function_name be memory_get_pointer(function_ptr, 0)

                Note: Fast path: check first character before expensive string_equals
                Let func_first_char be memory_get_byte(function_name, 0)
                If func_first_char is equal to name_first_char:
                    If string_equals(function_name, variable_name) is equal to 1:
                        Set is_function to 1
                        Set j to function_count
                    End If
                End If

                Set j to j plus 1
            End While
        End If

        If is_function is equal to 0:
            print_string("[CODEGEN ERROR] Undefined variable: ")
            print_string(variable_name)
            exit_with_code(1)
        End If

        file_write_buffered(output_file, "    leaq ", 0)
        file_write_buffered(output_file, variable_name, 0)
        file_write_buffered(output_file, "(%rip), %rax  # Load function address\n", 0)
        Return 0
    End If

    Note: Variable found in local scope
    Let variables be memory_get_pointer(codegen, 8)
    Let var_offset be var_index multiplied by 32
    Let var_ptr be variables plus var_offset
    Let offset be memory_get_integer(var_ptr, 8)
    Let var_type be memory_get_pointer(var_ptr, 16)

    Note: Check if this is a closure variable (offset == -1, appears as 4294967295 unsigned)
    If offset is equal to 4294967295:
        Note: This is a captured variable from closure environment
        Note: Environment pointer is at -8(%rbp), get actual offset from is_parameter field
        Let env_offset be memory_get_int32(var_ptr, 24)  Note: is_parameter field stores env offset
        emit_line(output_file, "    movq -8(%rbp), %rbx  # Load environment pointer")
        file_write_buffered(output_file, "    movq ", 0)
        file_write_buffered(output_file, integer_to_string(env_offset), 0)
        emit_line(output_file, "(%rbx), %rax  # Load captured variable from environment")
        Return 0
    End If

    Note: Check if array type
    Let is_array be 0
    Set current_program to memory_get_pointer(codegen, 48)

    If current_program is not equal to 0:
        Let type_count be memory_get_int32(current_program, 24)  Note: PROGRAM_TYPE_COUNT
        Let types be memory_get_pointer(current_program, 16)  Note: PROGRAM_TYPES

        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)
            If string_equals(type_name_ptr, var_type) is equal to 1:
                Let kind be memory_get_integer(type_ptr, 8)
                If kind is equal to 2:
                    Set is_array to 1
                End If
                Set i to type_count
            End If
            Set i to i plus 1
        End While
    End If

    If is_array is equal to 1:
        file_write_buffered(output_file, "    leaq -", 0)
        file_write_buffered(output_file, integer_to_string(offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax  # Load array address\n", 0)
    Otherwise:
        file_write_buffered(output_file, "    movq -", 0)
        file_write_buffered(output_file, integer_to_string(offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax\n", 0)
    End If

    Return 0
End Process

Note: Generate code for integer literal expressions
Process called "codegen_generate_integer_literal" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let integer_value be memory_get_pointer(expr, 8)  Note: expr->data.integer_value
    file_write_buffered(output_file, "    movq $", 0)
    file_write_buffered(output_file, integer_to_string(integer_value), 0)
    file_write_buffered(output_file, ", %rax\n", 0)
    Return 0
End Process

Note: Generate code for variable expressions
Process called "codegen_generate_variable_handler" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    codegen_generate_variable_expr(codegen, expr)  Note: Already extracted earlier
    Return 0
End Process

Note: Generate code for string literal expressions
Process called "codegen_generate_string_literal" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)

    Note: Safety check
    If expr is equal to 0:  Note: NULL pointer check
        print_string("[CODEGEN ERROR] Invalid string literal expression")
        exit_with_code(1)
    End If

    Let string_value be memory_get_pointer(expr, 8)  Note: expr->data.string_value

    Note: Find or add the string to the string table
    Let string_count be memory_get_int32(codegen, 40)  Note: codegen->string_count (after padding)
    Let string_literals be memory_get_pointer(codegen, 32)  Note: codegen->strings (pointer with padding)
    Let string_index be -1  Note: -1 for not found

    Let i be 0
    While i is less than string_count:
        Let str_offset be i multiplied by 16  Note: StringLiteral is 16 bytes
        Let stored_string be memory_get_pointer(string_literals, str_offset)
        If string_equals(stored_string, string_value) is equal to 1:
            Set string_index to i
            Set i to string_count  Note: break loop
        End If
        Set i to i plus 1
    End While

    If string_index is less than 0:
        Note: Add new string - this should call codegen_add_string_literal instead
        Set string_index to codegen_add_string_literal(codegen, string_value)
    End If

    Note: Generate reference to string
    file_write_buffered(output_file, "    leaq .STR", 0)
    file_write_buffered(output_file, integer_to_string(string_index), 0)
    file_write_buffered(output_file, "(%rip), %rax\n", 0)
    Return 0
End Process

Note: Generate code for float literal expressions
Note: Float literal structure: type(4), value_string(8), float_type(4)
Note: float_type: 1=Float16, 2=Float32, 3=Float64, 4=Float80, 5=Float128
Process called "codegen_generate_float_literal" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)

    Note: Safety check
    If expr is equal to 0:
        print_string("[CODEGEN ERROR] Invalid float literal expression")
        exit_with_code(1)
    End If

    Note: Extract float value string and type
    Let value_string be memory_get_pointer(expr, 8)   Note: expr->data.float_literal.value_string
    Let float_type be memory_get_int32(expr, 16)      Note: expr->data.float_literal.float_type

    Note: For now, we'll convert the float string to a memory representation
    Note: This will need to call the appropriate string_to_float function from primitives
    Note: Then load the float value into the appropriate register

    Note: Allocate temporary memory for float value on stack
    Let size_bytes be 8  Note: Default to Float64 size
    If float_type is equal to 1:  Note: Float16
        Set size_bytes to 2
    Otherwise If float_type is equal to 2:  Note: Float32
        Set size_bytes to 4
    Otherwise If float_type is equal to 3:  Note: Float64
        Set size_bytes to 8
    Otherwise If float_type is equal to 4:  Note: Float80
        Set size_bytes to 10
    Otherwise If float_type is equal to 5:  Note: Float128
        Set size_bytes to 16
    End If

    Note: Allocate space on stack for float value
    file_write_buffered(output_file, "    subq $", 0)
    Let aligned_size be size_bytes plus 8  Note: Extra 8 for alignment
    file_write_buffered(output_file, integer_to_string(aligned_size), 0)
    file_write_buffered(output_file, ", %rsp\n", 0)

    Note: Find the string in the string table (it was already added during collection)
    Let string_count be memory_get_int32(codegen, 40)
    Let string_literals be memory_get_pointer(codegen, 32)
    Let string_index be -1

    Let i be 0
    While i is less than string_count:
        Let str_offset be i multiplied by 16
        Let stored_string be memory_get_pointer(string_literals, str_offset)
        If string_equals(stored_string, value_string) is equal to 1:
            Set string_index to i
            Set i to string_count  Note: break loop
        End If
        Set i to i plus 1
    End While

    If string_index is less than 0:
        Note: Not found, add it now
        Set string_index to codegen_add_string_literal(codegen, value_string)
    End If

    Note: Load string pointer as first argument
    file_write_buffered(output_file, "    leaq ", 0)
    file_write_buffered(output_file, ".STR", 0)
    file_write_buffered(output_file, integer_to_string(string_index), 0)
    file_write_buffered(output_file, "(%rip), %rdi\n", 0)

    Note: Load result pointer as second argument (stack location)
    file_write_buffered(output_file, "    movq %rsp, %rsi\n", 0)

    Note: Call string_to_float function from primitives
    file_write_buffered(output_file, "    call string_to_float@PLT\n", 0)

    Note: Load the float value into %rax (as integer representation)
    If float_type is equal to 2:  Note: Float32
        file_write_buffered(output_file, "    movl (%rsp), %eax\n", 0)
    Otherwise If float_type is equal to 3:  Note: Float64
        file_write_buffered(output_file, "    movq (%rsp), %rax\n", 0)
    Otherwise:
        Note: For other types, load as 64-bit for now
        file_write_buffered(output_file, "    movq (%rsp), %rax\n", 0)
    End If

    Note: Clean up stack
    file_write_buffered(output_file, "    addq $", 0)
    file_write_buffered(output_file, integer_to_string(aligned_size), 0)
    file_write_buffered(output_file, ", %rsp\n", 0)

    Return 0
End Process

Note: Generate code for float binary operations (add, subtract, multiply, divide)
Note: Calls float primitives from v0.0.8.5 (float_add, float_subtract, float_multiply, float_divide)
Process called "codegen_generate_float_binary_op" takes codegen as Integer, left as Integer, right as Integer, primitive_name as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)

    Note: We need to allocate stack space for two operands and result
    Note: Each float is 8 bytes (we use Float64 by default)
    Note: Total: 24 bytes

    Note: Allocate 24 bytes on stack for operands and result
    emit_line(output_file, "    subq $24, %rsp")

    Note: Generate left operand (result in %rax as integer representation)
    codegen_generate_expression(codegen, left)
    Note: Store left operand on stack at offset 0
    emit_line(output_file, "    movq %rax, 0(%rsp)")

    Note: Generate right operand (result in %rax)
    codegen_generate_expression(codegen, right)
    Note: Store right operand on stack at offset 8
    emit_line(output_file, "    movq %rax, 8(%rsp)")

    Note: Set up arguments for float primitive
    Note: arg1: pointer to left operand
    emit_line(output_file, "    movq %rsp, %rdi")
    Note: arg2: pointer to right operand
    emit_line(output_file, "    leaq 8(%rsp), %rsi")
    Note: arg3: pointer to result
    emit_line(output_file, "    leaq 16(%rsp), %rdx")

    Note: Call the float primitive
    file_write_buffered(output_file, "    call ", 0)
    file_write_buffered(output_file, primitive_name, 0)
    file_write_buffered(output_file, "@PLT\n", 0)

    Note: Load result from stack into %rax
    emit_line(output_file, "    movq 16(%rsp), %rax")

    Note: Clean up stack
    emit_line(output_file, "    addq $24, %rsp")

    Return 0
End Process

Note: Generate code for binary operation expressions
Process called "codegen_generate_binary_op" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let left be memory_get_pointer(expr, 8)         Note: binary_op.left
    Let right be memory_get_pointer(expr, 16)       Note: binary_op.right
    Let operator be memory_get_integer(expr, 24)    Note: binary_op.operator

    Note: Check if either operand is a float type - if so, use float arithmetic
    Let left_type_name be codegen_get_expression_type(codegen, left)
    Let right_type_name be codegen_get_expression_type(codegen, right)
    Let is_left_float be codegen_is_float_type(left_type_name)
    Let is_right_float be codegen_is_float_type(right_type_name)

    Note: If either operand is float and operator is arithmetic, call float primitives
    If is_left_float is equal to 1:
        Note: Left is float, so result should be float operation
        If operator is equal to 16:  Note: TOKEN_PLUS
            Return codegen_generate_float_binary_op(codegen, left, right, "float_add")
        Otherwise If operator is equal to 17:  Note: TOKEN_MINUS
            Return codegen_generate_float_binary_op(codegen, left, right, "float_subtract")
        Otherwise If operator is equal to 35:  Note: TOKEN_MULTIPLIED
            Return codegen_generate_float_binary_op(codegen, left, right, "float_multiply")
        Otherwise If operator is equal to 36:  Note: TOKEN_DIVIDED
            Return codegen_generate_float_binary_op(codegen, left, right, "float_divide")
        End If
    Otherwise If is_right_float is equal to 1:
        Note: Right is float, so result should be float operation
        If operator is equal to 16:  Note: TOKEN_PLUS
            Return codegen_generate_float_binary_op(codegen, left, right, "float_add")
        Otherwise If operator is equal to 17:  Note: TOKEN_MINUS
            Return codegen_generate_float_binary_op(codegen, left, right, "float_subtract")
        Otherwise If operator is equal to 35:  Note: TOKEN_MULTIPLIED
            Return codegen_generate_float_binary_op(codegen, left, right, "float_multiply")
        Otherwise If operator is equal to 36:  Note: TOKEN_DIVIDED
            Return codegen_generate_float_binary_op(codegen, left, right, "float_divide")
        End If
    End If

    Note: OPTIMIZATION: For simple right operands (variables/integers), use direct register operations
    Let right_type be memory_get_int32(right, 0)
    Let use_direct_op be 0

    Note: Check if right is a simple variable (EXPR_VARIABLE = 1)
    If right_type is equal to 1:
        Set use_direct_op to 1
    End If

    Note: Check if right is an integer literal (EXPR_INTEGER = 0)
    If right_type is equal to 0:
        Set use_direct_op to 1
    End If

    If use_direct_op is equal to 1:
        Note: OPTIMIZED PATH: Direct register operations (3 instructions instead of 6)
        Note: Generate left operand (result in %rax)
        codegen_generate_expression(codegen, left)

        Note: For simple operations, operate directly on right without stack
        If operator is equal to 16:  Note: TOKEN_PLUS
            If right_type is equal to 0:  Note: Integer literal
                Let int_val be memory_get_pointer(right, 8)
                file_write_buffered(output_file, "    addq $", 0)
                file_write_buffered(output_file, integer_to_string(int_val), 0)
                file_write_buffered(output_file, ", %rax\n", 0)
            Otherwise:  Note: Variable
                Let var_name be memory_get_pointer(right, 8)
                Let var_index be codegen_find_variable(codegen, var_name)
                If var_index is greater than or equal to 0:
                    Let variables be memory_get_pointer(codegen, 8)
                    Let var_offset be var_index multiplied by 32
                    Let var_ptr be variables plus var_offset
                    Let stack_offset be memory_get_integer(var_ptr, 8)
                    Note: Check if this is a closure variable (offset == -1, appears as 4294967295 unsigned)
                    If stack_offset is equal to 4294967295:
                        Note: Closure variable, use general expression path
                        emit_line(output_file, "    pushq %rax")
                        codegen_generate_expression(codegen, right)
                        emit_line(output_file, "    popq %rbx")
                        emit_line(output_file, "    addq %rbx, %rax")
                    Otherwise:
                        file_write_buffered(output_file, "    addq -", 0)
                        file_write_buffered(output_file, integer_to_string(stack_offset), 0)
                        file_write_buffered(output_file, "(%rbp), %rax\n", 0)
                    End If
                Otherwise:
                    Note: Fallback to stack-based for complex cases
                    emit_line(output_file, "    pushq %rax")
                    codegen_generate_expression(codegen, right)
                    emit_line(output_file, "    popq %rbx")
                    emit_line(output_file, "    addq %rbx, %rax")
                End If
            End If
        Otherwise If operator is equal to 17:  Note: TOKEN_MINUS
            If right_type is equal to 0:  Note: Integer literal
                Set int_val to memory_get_pointer(right, 8)
                file_write_buffered(output_file, "    subq $", 0)
                file_write_buffered(output_file, integer_to_string(int_val), 0)
                file_write_buffered(output_file, ", %rax\n", 0)
            Otherwise:  Note: Variable
                Set var_name to memory_get_pointer(right, 8)
                Set var_index to codegen_find_variable(codegen, var_name)
                If var_index is greater than or equal to 0:
                    Set variables to memory_get_pointer(codegen, 8)
                    Set var_offset to var_index multiplied by 32
                    Set var_ptr to variables plus var_offset
                    Set stack_offset to memory_get_integer(var_ptr, 8)
                    Note: Check if this is a closure variable (offset == -1, appears as 4294967295 unsigned)
                    If stack_offset is equal to 4294967295:
                        Note: Closure variable, use general expression path
                        emit_line(output_file, "    pushq %rax")
                        codegen_generate_expression(codegen, right)
                        emit_line(output_file, "    popq %rbx")
                        emit_line(output_file, "    subq %rax, %rbx")
                        emit_line(output_file, "    movq %rbx, %rax")
                    Otherwise:
                        file_write_buffered(output_file, "    subq -", 0)
                        file_write_buffered(output_file, integer_to_string(stack_offset), 0)
                        file_write_buffered(output_file, "(%rbp), %rax\n", 0)
                    End If
                Otherwise:
                    Note: Fallback to stack-based for complex cases
                    emit_line(output_file, "    pushq %rax")
                    codegen_generate_expression(codegen, right)
                    emit_line(output_file, "    popq %rbx")
                    emit_line(output_file, "    subq %rax, %rbx")
                    emit_line(output_file, "    movq %rbx, %rax")
                End If
            End If
        Otherwise If operator is equal to 35:  Note: TOKEN_MULTIPLIED
            Note: Multiply requires both operands in registers, use stack-based
            emit_line(output_file, "    pushq %rax")
            codegen_generate_expression(codegen, right)
            emit_line(output_file, "    popq %rbx")
            emit_line(output_file, "    imulq %rbx, %rax")
        Note: For operations that require %rbx (div, mod, bitwise, shifts), use stack-based
        Otherwise If operator is equal to 36:  Note: TOKEN_DIVIDED
            emit_line(output_file, "    pushq %rax")
            codegen_generate_expression(codegen, right)
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    popq %rax")
            emit_line(output_file, "    testq %rcx, %rcx")
            Let label_counter be memory_get_int32(codegen, 28)
            file_write_buffered(output_file, "    jz .Ldiv_by_zero_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, "\n", 0)
            emit_line(output_file, "    cqto")
            emit_line(output_file, "    idivq %rcx")
            file_write_buffered(output_file, "    jmp .Ldiv_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, "\n", 0)
            file_write_buffered(output_file, ".Ldiv_by_zero_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            emit_line(output_file, "    movq $0, %rax")
            file_write_buffered(output_file, ".Ldiv_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            memory_set_int32(codegen, 28, label_counter plus 1)
        Otherwise If operator is equal to 37:  Note: TOKEN_MODULO
            emit_line(output_file, "    pushq %rax")
            codegen_generate_expression(codegen, right)
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    popq %rax")
            emit_line(output_file, "    testq %rcx, %rcx")
            Set label_counter to memory_get_int32(codegen, 28)
            file_write_buffered(output_file, "    jz .Lmod_by_zero_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, "\n", 0)
            emit_line(output_file, "    cqto")
            emit_line(output_file, "    idivq %rcx")
            emit_line(output_file, "    movq %rdx, %rax")
            file_write_buffered(output_file, "    jmp .Lmod_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, "\n", 0)
            file_write_buffered(output_file, ".Lmod_by_zero_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            emit_line(output_file, "    movq $0, %rax")
            file_write_buffered(output_file, ".Lmod_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            memory_set_int32(codegen, 28, label_counter plus 1)
        Otherwise If operator is equal to 39:  Note: TOKEN_BIT_AND
            If right_type is equal to 0:  Note: Integer literal
                Set int_val to memory_get_pointer(right, 8)
                file_write_buffered(output_file, "    andq $", 0)
                file_write_buffered(output_file, integer_to_string(int_val), 0)
                file_write_buffered(output_file, ", %rax\n", 0)
            Otherwise:  Note: Variable or complex
                emit_line(output_file, "    pushq %rax")
                codegen_generate_expression(codegen, right)
                emit_line(output_file, "    popq %rbx")
                emit_line(output_file, "    andq %rbx, %rax")
            End If
        Otherwise If operator is equal to 40:  Note: TOKEN_BIT_OR
            If right_type is equal to 0:  Note: Integer literal
                Set int_val to memory_get_pointer(right, 8)
                file_write_buffered(output_file, "    orq $", 0)
                file_write_buffered(output_file, integer_to_string(int_val), 0)
                file_write_buffered(output_file, ", %rax\n", 0)
            Otherwise:  Note: Variable or complex
                emit_line(output_file, "    pushq %rax")
                codegen_generate_expression(codegen, right)
                emit_line(output_file, "    popq %rbx")
                emit_line(output_file, "    orq %rbx, %rax")
            End If
        Otherwise If operator is equal to 41:  Note: TOKEN_BIT_XOR
            If right_type is equal to 0:  Note: Integer literal
                Set int_val to memory_get_pointer(right, 8)
                file_write_buffered(output_file, "    xorq $", 0)
                file_write_buffered(output_file, integer_to_string(int_val), 0)
                file_write_buffered(output_file, ", %rax\n", 0)
            Otherwise:  Note: Variable or complex
                emit_line(output_file, "    pushq %rax")
                codegen_generate_expression(codegen, right)
                emit_line(output_file, "    popq %rbx")
                emit_line(output_file, "    xorq %rbx, %rax")
            End If
        Otherwise If operator is equal to 42:  Note: TOKEN_BIT_SHIFT_LEFT
            emit_line(output_file, "    pushq %rax")
            codegen_generate_expression(codegen, right)
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    popq %rax")
            emit_line(output_file, "    salq %cl, %rax")
        Otherwise If operator is equal to 43:  Note: TOKEN_BIT_SHIFT_RIGHT
            emit_line(output_file, "    pushq %rax")
            codegen_generate_expression(codegen, right)
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    popq %rax")
            emit_line(output_file, "    sarq %cl, %rax")
        End If
    Otherwise:
        Note: FALLBACK PATH: Complex expressions use stack-based evaluation
        Note: Generate left operand (result in %rax)
        codegen_generate_expression(codegen, left)
        emit_line(output_file, "    pushq %rax")
        Note: Generate right operand (result in %rax)
        codegen_generate_expression(codegen, right)
        emit_line(output_file, "    popq %rbx")

        Note: Perform the operation based on operator
        If operator is equal to 16:  Note: TOKEN_PLUS
            emit_line(output_file, "    addq %rbx, %rax")
        Otherwise If operator is equal to 17:  Note: TOKEN_MINUS
            emit_line(output_file, "    subq %rax, %rbx")
            emit_line(output_file, "    movq %rbx, %rax")
        Otherwise If operator is equal to 35:  Note: TOKEN_MULTIPLIED
            emit_line(output_file, "    imulq %rbx, %rax")
        Otherwise If operator is equal to 36:  Note: TOKEN_DIVIDED
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    movq %rbx, %rax")
            emit_line(output_file, "    testq %rcx, %rcx")
            Set label_counter to memory_get_int32(codegen, 28)
            Let jz_label be codegen_arena_concat(codegen, "    jz .Ldiv_by_zero_", codegen_arena_int_to_str(codegen, label_counter))
            emit_line(output_file, jz_label)
            emit_line(output_file, "    cqto")
            emit_line(output_file, "    idivq %rcx")
            Note: Use file_write_buffered instead of string_concat to avoid allocations
            file_write_buffered(output_file, "    jmp .Ldiv_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, "\n", 0)
            file_write_buffered(output_file, ".Ldiv_by_zero_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            emit_line(output_file, "    movq $0, %rax")
            file_write_buffered(output_file, ".Ldiv_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            memory_set_int32(codegen, 28, label_counter plus 1)
        Otherwise If operator is equal to 37:  Note: TOKEN_MODULO
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    movq %rbx, %rax")
            emit_line(output_file, "    testq %rcx, %rcx")
            Set label_counter to memory_get_int32(codegen, 28)
            Set jz_label to codegen_arena_concat(codegen, "    jz .Lmod_by_zero_", codegen_arena_int_to_str(codegen, label_counter))
            emit_line(output_file, jz_label)
            emit_line(output_file, "    cqto")
            emit_line(output_file, "    idivq %rcx")
            emit_line(output_file, "    movq %rdx, %rax")
            Note: Use file_write_buffered instead of string_concat to avoid allocations
            file_write_buffered(output_file, "    jmp .Lmod_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, "\n", 0)
            file_write_buffered(output_file, ".Lmod_by_zero_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            emit_line(output_file, "    movq $0, %rax")
            file_write_buffered(output_file, ".Lmod_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            memory_set_int32(codegen, 28, label_counter plus 1)
        Otherwise If operator is equal to 39:  Note: TOKEN_BIT_AND
            emit_line(output_file, "    andq %rbx, %rax")
        Otherwise If operator is equal to 40:  Note: TOKEN_BIT_OR
            emit_line(output_file, "    orq %rbx, %rax")
        Otherwise If operator is equal to 41:  Note: TOKEN_BIT_XOR
            emit_line(output_file, "    xorq %rbx, %rax")
        Otherwise If operator is equal to 42:  Note: TOKEN_BIT_SHIFT_LEFT
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    movq %rbx, %rax")
            emit_line(output_file, "    salq %cl, %rax")
        Otherwise If operator is equal to 43:  Note: TOKEN_BIT_SHIFT_RIGHT
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    movq %rbx, %rax")
            emit_line(output_file, "    sarq %cl, %rax")
        Otherwise If operator is equal to 30:  Note: TOKEN_AND
            emit_line(output_file, "    andq %rbx, %rax")
        Otherwise If operator is equal to 31:  Note: TOKEN_OR
            emit_line(output_file, "    orq %rbx, %rax")
        End If
    End If
    Return 0
End Process

Note: Generate code for unary operators (NOT)
Process called "codegen_generate_unary_op" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let operator be memory_get_integer(expr, 8)
    Let operand be memory_get_pointer(expr, 16)

    codegen_generate_expression(codegen, operand)

    If operator is equal to 29:  Note: TOKEN_NOT
        emit_line(output_file, "    testq %rax, %rax")
        emit_line(output_file, "    setz %al")
        emit_line(output_file, "    movzbq %al, %rax")
    End If

    Return 0
End Process

Note: Generate code for comparison expressions
Process called "codegen_generate_comparison" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let left be memory_get_pointer(expr, 8)           Note: comparison.left
    Let right be memory_get_pointer(expr, 16)         Note: comparison.right
    Let comparison_op be memory_get_integer(expr, 24) Note: comparison.comparison_op

    Note: Generate left operand (result in %rax)
    codegen_generate_expression(codegen, left)
    emit_line(output_file, "    pushq %rax")
    Note: Generate right operand (result in %rax)
    codegen_generate_expression(codegen, right)
    emit_line(output_file, "    popq %rbx")

    Note: Compare and set result
    emit_line(output_file, "    cmpq %rax, %rbx")
    If comparison_op is equal to 22:  Note: TOKEN_EQUAL
        emit_line(output_file, "    sete %al")
    Otherwise If comparison_op is equal to 23:  Note: TOKEN_NOT_EQUAL
        emit_line(output_file, "    setne %al")
    Otherwise If comparison_op is equal to 24:  Note: TOKEN_LESS
        emit_line(output_file, "    setl %al")
    Otherwise If comparison_op is equal to 25:  Note: TOKEN_GREATER
        emit_line(output_file, "    setg %al")
    Otherwise If comparison_op is equal to 27:  Note: TOKEN_LESS_EQUAL
        emit_line(output_file, "    setle %al")
    Otherwise If comparison_op is equal to 26:  Note: TOKEN_GREATER_EQUAL
        emit_line(output_file, "    setge %al")
    End If
    emit_line(output_file, "    movzbq %al, %rax")
    Return 0
End Process

Note: Generate code for function call expressions
Process called "codegen_generate_function_call" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let function_call_ptr be expr plus 8  Note: &expr->data.function_call
    Let function_name be memory_get_pointer(function_call_ptr, 0)  Note: function_call.function_name
    Let arguments be memory_get_pointer(function_call_ptr, 8)      Note: function_call.arguments
    Let arg_count be memory_get_int32(function_call_ptr, 16)     Note: function_call.argument_count

    Note: Safety check for function_name
    If function_name is equal to 0:  Note: NULL pointer check
        exit_with_code(1)
    End If

    Note: Generate argument values in reverse order (right-to-left evaluation)
    Let i be arg_count minus 1
    While i is greater than or equal to 0:
        Let arg_offset be i multiplied by 8
        Let arg_expr be memory_get_pointer(arguments, arg_offset)

        Note: Debug check
        If arg_expr is equal to 0:
            print_string("[CODEGEN ERROR] NULL argument expression pointer: ")
            print_integer(arg_expr)
            exit_with_code(1)
        End If

        codegen_generate_expression(codegen, arg_expr)
        file_write_buffered(output_file, "    pushq %rax\n", 0)
        Set i to i minus 1
    End While

    Note: Pop arguments into registers
    If arg_count is greater than or equal to 1:
        file_write_buffered(output_file, "    popq %rdi\n", 0)
    End If
    If arg_count is greater than or equal to 2:
        file_write_buffered(output_file, "    popq %rsi\n", 0)
    End If
    If arg_count is greater than or equal to 3:
        file_write_buffered(output_file, "    popq %rdx\n", 0)
    End If
    If arg_count is greater than or equal to 4:
        file_write_buffered(output_file, "    popq %rcx\n", 0)
    End If
    If arg_count is greater than or equal to 5:
        file_write_buffered(output_file, "    popq %r8\n", 0)
    End If
    If arg_count is greater than or equal to 6:
        file_write_buffered(output_file, "    popq %r9\n", 0)
    End If

    Note: Call the function - add @PLT for external runtime functions
    file_write_buffered(output_file, "    call ", 0)
    file_write_buffered(output_file, function_name, 0)

    Note: Check if this is a runtime function that needs @PLT
    Let needs_plt be 0
    If string_equals(function_name, "allocate") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "deallocate") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "memory_allocate") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "memory_reallocate") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "string_length") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "string_char_at") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "string_equals") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "string_compare") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "string_find") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "string_substring") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "string_duplicate") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "string_concat") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "integer_to_string") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "ascii_value_of") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "is_digit") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "is_whitespace") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "file_open_buffered") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "file_write_buffered") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "file_close_buffered") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "memory_get_byte") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "memory_set_byte") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "memory_get_int32") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "memory_set_int32") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "memory_get_integer") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "memory_set_integer") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "memory_get_pointer") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "memory_set_pointer") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "memory_set_pointer_at_index") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "exit_with_code") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "read_file_internal") is equal to 1: Set needs_plt to 1
    Otherwise If string_equals(function_name, "get_command_line_arg") is equal to 1: Set needs_plt to 1
    End If
    Note: Note: print_string, print_integer, string_copy_n, string_set_char are Runa functions - no @PLT

    If needs_plt is equal to 1:
        file_write_buffered(output_file, "@PLT", 0)
    End If
    file_write_buffered(output_file, "\n", 0)

    Note: Result is now in %rax (x86_64 calling convention)
    Note: The function result is left in %rax for the calling code to use
    Return 0
End Process

Note: Generate code for indirect function call expressions (function pointers)
Process called "codegen_generate_indirect_call" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let function_call_ptr be expr plus 8  Note: &expr->data.function_call (same structure)
    Let function_expr be memory_get_pointer(function_call_ptr, 0)  Note: Expression that evaluates to function pointer
    Let arguments be memory_get_pointer(function_call_ptr, 8)      Note: function_call.arguments
    Let arg_count be memory_get_int32(function_call_ptr, 16)     Note: function_call.argument_count

    Note: Generate argument values in reverse order (right-to-left evaluation)
    Let i be arg_count minus 1
    While i is greater than or equal to 0:
        Let arg_offset be i multiplied by 8
        Let arg_expr be memory_get_pointer(arguments, arg_offset)
        codegen_generate_expression(codegen, arg_expr)
        file_write_buffered(output_file, "    pushq %rax\n", 0)
        Set i to i minus 1
    End While

    Note: Pop arguments into registers
    If arg_count is greater than or equal to 1:
        file_write_buffered(output_file, "    popq %rdi\n", 0)
    End If
    If arg_count is greater than or equal to 2:
        file_write_buffered(output_file, "    popq %rsi\n", 0)
    End If
    If arg_count is greater than or equal to 3:
        file_write_buffered(output_file, "    popq %rdx\n", 0)
    End If
    If arg_count is greater than or equal to 4:
        file_write_buffered(output_file, "    popq %rcx\n", 0)
    End If
    If arg_count is greater than or equal to 5:
        file_write_buffered(output_file, "    popq %r8\n", 0)
    End If
    If arg_count is greater than or equal to 6:
        file_write_buffered(output_file, "    popq %r9\n", 0)
    End If

    Note: Save function pointer expression - evaluate it into a temporary register
    Note: We need to be careful not to clobber argument registers
    file_write_buffered(output_file, "    pushq %rdi\n", 0)  Note: Save args if present
    If arg_count is greater than or equal to 2:
        file_write_buffered(output_file, "    pushq %rsi\n", 0)
    End If
    If arg_count is greater than or equal to 3:
        file_write_buffered(output_file, "    pushq %rdx\n", 0)
    End If
    If arg_count is greater than or equal to 4:
        file_write_buffered(output_file, "    pushq %rcx\n", 0)
    End If
    If arg_count is greater than or equal to 5:
        file_write_buffered(output_file, "    pushq %r8\n", 0)
    End If
    If arg_count is greater than or equal to 6:
        file_write_buffered(output_file, "    pushq %r9\n", 0)
    End If

    Note: Evaluate function pointer expression into %rax
    codegen_generate_expression(codegen, function_expr)
    file_write_buffered(output_file, "    movq %rax, %r10  # Save function pointer\n", 0)

    Note: Restore argument registers
    If arg_count is greater than or equal to 6:
        file_write_buffered(output_file, "    popq %r9\n", 0)
    End If
    If arg_count is greater than or equal to 5:
        file_write_buffered(output_file, "    popq %r8\n", 0)
    End If
    If arg_count is greater than or equal to 4:
        file_write_buffered(output_file, "    popq %rcx\n", 0)
    End If
    If arg_count is greater than or equal to 3:
        file_write_buffered(output_file, "    popq %rdx\n", 0)
    End If
    If arg_count is greater than or equal to 2:
        file_write_buffered(output_file, "    popq %rsi\n", 0)
    End If
    file_write_buffered(output_file, "    popq %rdi\n", 0)

    Note: Make indirect call through function pointer in %r10
    file_write_buffered(output_file, "    call *%r10  # Indirect call through function pointer\n", 0)

    Note: Result is now in %rax
    Return 0
End Process

Note: Generate code for field access expressions
Process called "codegen_generate_field_access" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let field_access_ptr be expr plus 8  Note: Union at offset 8
    Let obj be memory_get_pointer(field_access_ptr, 0)
    Let field_name be memory_get_pointer(field_access_ptr, 8)

    Note: Get the type of the object
    Let object_type be codegen_get_expression_type(codegen, obj)
    If object_type is equal to 0:
        print_string("[CODEGEN ERROR] Cannot determine type of object in field access")
        exit_with_code(1)
    End If

    Note: Find the type definition
    Let current_program be memory_get_pointer(codegen, 48)  Note: codegen->current_program
    Let type_count be memory_get_int32(current_program, 24)  Note: PROGRAM_TYPE_COUNT
    Let types be memory_get_pointer(current_program, 16)     Note: PROGRAM_TYPES
    Let type be 0

    Let i be 0
    While i is less than type_count:
        Let type_offset be i multiplied by 8
        Let type_ptr be memory_get_pointer(types, type_offset)
        Let type_name_ptr be memory_get_pointer(type_ptr, 0)  Note: type->name
        If string_equals(type_name_ptr, object_type) is equal to 1:
            Set type to type_ptr
            Set i to type_count  Note: break loop
        End If
        Set i to i plus 1
    End While

    If type is equal to 0:
        print_string("[CODEGEN ERROR] Unknown type '")
        print_string(object_type)
        print_string("'")
        exit_with_code(1)
    End If


    Note: Find field offset
    Let field_offset be -1  Note: -1 for not found
    Let kind be memory_get_int32(type, 8)  Note: type->kind

    If kind is equal to 0:  Note: TYPE_KIND_STRUCT
        Note: TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET is 24
        Note: TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET is 16
        Let field_count be memory_get_int32(type, 24)
        Let fields be memory_get_pointer(type, 16)

        Let j be 0
        While j is less than field_count:
            Let field_idx_offset be j multiplied by 24
            Let field_ptr be fields plus field_idx_offset  Note: sizeof(FieldDefinition)
            Let field_name_ptr be memory_get_pointer(field_ptr, 0)  Note: field.name
            If string_equals(field_name_ptr, field_name) is equal to 1:
                Set field_offset to memory_get_int32(field_ptr, 16)  Note: field.offset
                Set j to field_count  Note: break loop
            End If
            Set j to j plus 1
        End While
    End If

    If field_offset is less than 0:  Note: -1 for not found
        print_string("[CODEGEN ERROR] Type '")
        print_string(object_type)
        print_string("' has no field '")
        print_string(field_name)
        print_string("'")
        exit_with_code(1)
    End If

    Note: Generate code to load object address and access field
    Let obj_type be memory_get_int32(obj, 0)

    If obj_type is equal to 1:  Note: EXPR_VARIABLE
        Let obj_variable_name be memory_get_pointer(obj, 8)
        Let var_index be codegen_find_variable(codegen, obj_variable_name)
        If var_index is less than 0:
            print_string("[CODEGEN ERROR] Unknown variable")
            exit_with_code(1)
        End If

        Let variables be memory_get_pointer(codegen, 8)
        Let var_offset be var_index multiplied by 32
        Let var_ptr be variables plus var_offset
        Let stack_offset be memory_get_int32(var_ptr, 8)

        file_write_buffered(output_file, "    movq -", 0)
        file_write_buffered(output_file, integer_to_string(stack_offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax\n", 0)

        Note: Add field offset and dereference
        file_write_buffered(output_file, "    movq ", 0)
        file_write_buffered(output_file, integer_to_string(field_offset), 0)
        file_write_buffered(output_file, "(%rax), %rax\n", 0)
    Otherwise:
        Note: For complex expressions, generate the expression first
        codegen_generate_expression(codegen, obj)
        file_write_buffered(output_file, "    movq ", 0)
        file_write_buffered(output_file, integer_to_string(field_offset), 0)
        file_write_buffered(output_file, "(%rax), %rax\n", 0)
    End If

    Return 0
End Process

Note: Handle builtin call expressions
Process called "codegen_generate_builtin_call" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file
    Let builtin_call_ptr be expr plus 8  Note: &expr->data.builtin_call
    Let builtin_type be memory_get_int32(builtin_call_ptr, 0)  Note: builtin_call.builtin_type
    Let arguments be memory_get_pointer(builtin_call_ptr, 8)     Note: builtin_call.arguments
    Let arg_count be memory_get_int32(builtin_call_ptr, 16)    Note: builtin_call.argument_count

    Note: Map builtin types to function names - split into ranges to avoid deep nesting limits
    Let func_name be ""

    Note: First generate all argument values onto stack
    Let i be arg_count minus 1
    While i is greater than or equal to 0:
        Let arg_offset be i multiplied by 8
        Let arg_expr be memory_get_pointer(arguments, arg_offset)
        codegen_generate_expression(codegen, arg_expr)
        file_write_buffered(output_file, "    pushq %rax\n", 0)
        Set i to i minus 1
    End While

    Note: Pop arguments into the correct registers based on calling convention
    If arg_count is greater than or equal to 1:
        file_write_buffered(output_file, "    popq %rdi\n", 0)
    End If
    If arg_count is greater than or equal to 2:
        file_write_buffered(output_file, "    popq %rsi\n", 0)
    End If
    If arg_count is greater than or equal to 3:
        file_write_buffered(output_file, "    popq %rdx\n", 0)
    End If
    If arg_count is greater than or equal to 4:
        file_write_buffered(output_file, "    popq %rcx\n", 0)
    End If
    If arg_count is greater than or equal to 5:
        file_write_buffered(output_file, "    popq %r8\n", 0)
    End If
    If arg_count is greater than or equal to 6:
        file_write_buffered(output_file, "    popq %r9\n", 0)
    End If

    Note: Map builtin_type to function name
    Note: Since we don't have all builtins implemented, generate a generic name
    Note: This allows compilation to proceed but these calls won't work at runtime
    file_write_buffered(output_file, "    # Unimplemented builtin type ", 0)
    file_write_buffered(output_file, integer_to_string(builtin_type), 0)
    file_write_buffered(output_file, "\n", 0)
    file_write_buffered(output_file, "    movq $0, %rax  # Placeholder return value\n", 0)

    Return 0
End Process

Note: Generate code for expression - equivalent to codegen_generate_expression
Note: Simplified codegen_generate_expression that replaces the massive 1155-line function
Note: This will be inserted into codegen.runa to replace lines 1276-2431

Process called "codegen_generate_expression" takes codegen as Integer, expr as Integer returns Integer:
    Note: Safety check
    If expr is equal to 0:  Note: NULL pointer check
        print_string("[CODEGEN ERROR] NULL expression pointer")
        exit_with_code(1)
    End If

    Let expr_type be memory_get_int32(expr, 0)  Note: expr->type
    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file

    Note: Simple dispatcher without deep nesting
    If expr_type is equal to 0:  Note: EXPR_INTEGER_LITERAL
        Let integer_value be memory_get_integer(expr, 8)
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(integer_value), 0)
        file_write_buffered(output_file, ", %rax\n", 0)
        Return 0
    Otherwise If expr_type is equal to 1:  Note: EXPR_VARIABLE
        codegen_generate_variable_expr(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 2:  Note: EXPR_BINARY_OP
        codegen_generate_binary_op(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 3:  Note: EXPR_COMPARISON
        codegen_generate_comparison(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 4:  Note: EXPR_FUNCTION_CALL
        codegen_generate_function_call(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 11:  Note: EXPR_INDIRECT_CALL
        codegen_generate_indirect_call(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 12:  Note: EXPR_UNARY (NOT operator)
        codegen_generate_unary_op(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 5:  Note: EXPR_STRING_LITERAL
        codegen_generate_string_literal(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 25:  Note: EXPR_FLOAT_LITERAL
        codegen_generate_float_literal(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 6:  Note: EXPR_FIELD_ACCESS
        codegen_generate_field_access(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 7:  Note: EXPR_TYPE_CAST
        Let cast_expr be memory_get_pointer(expr, 16)
        codegen_generate_expression(codegen, cast_expr)
        Return 0
    Otherwise If expr_type is equal to 8:  Note: EXPR_BUILTIN_CALL
        Note: Simplified builtin call for Stage 1
        Let builtin_call_ptr be expr plus 8  Note: Union at offset 4
        Let arguments be memory_get_pointer(builtin_call_ptr, 8)
        Let arg_count be memory_get_integer(builtin_call_ptr, 16)

        Note: Generate arguments in reverse
        Let i be arg_count minus 1
        While i is greater than or equal to 0:
            Let arg_offset be i multiplied by 8
            Let arg_expr be memory_get_pointer(arguments, arg_offset)
            codegen_generate_expression(codegen, arg_expr)
            file_write_buffered(output_file, "    pushq %rax\n", 0)
            Set i to i minus 1
        End While

        Note: Pop into registers
        If arg_count is greater than 0:
            file_write_buffered(output_file, "    popq %rdi\n", 0)
        End If
        If arg_count is greater than 1:
            file_write_buffered(output_file, "    popq %rsi\n", 0)
        End If
        If arg_count is greater than 2:
            file_write_buffered(output_file, "    popq %rdx\n", 0)
        End If

        Note: Get builtin type token and map to function name
        Let builtin_type be memory_get_int32(builtin_call_ptr, 0)
        Let func_name be 0  Note: Will be set based on token

        Note: Map TOKEN to runtime function name
        If builtin_type is equal to 57: Set func_name to "string_length"  Note: TOKEN_STRING_LENGTH
        Otherwise If builtin_type is equal to 58: Set func_name to "string_char_at"  Note: TOKEN_STRING_CHAR_AT
        Otherwise If builtin_type is equal to 59: Set func_name to "string_substring"  Note: TOKEN_STRING_SUBSTRING
        Otherwise If builtin_type is equal to 60: Set func_name to "string_equals"  Note: TOKEN_STRING_EQUALS
        Otherwise If builtin_type is equal to 61: Set func_name to "ascii_value_of"  Note: TOKEN_ASCII_VALUE_OF
        Otherwise If builtin_type is equal to 62: Set func_name to "is_digit"  Note: TOKEN_IS_DIGIT
        Otherwise If builtin_type is equal to 64: Set func_name to "is_whitespace"  Note: TOKEN_IS_WHITESPACE
        Otherwise If builtin_type is equal to 72: Set func_name to "string_find"  Note: TOKEN_STRING_FIND
        Otherwise If builtin_type is equal to 73: Set func_name to "string_compare"  Note: TOKEN_STRING_COMPARE
        Otherwise If builtin_type is equal to 74: Set func_name to "string_concat"  Note: TOKEN_STRING_CONCAT
        Otherwise If builtin_type is equal to 75: Set func_name to "string_duplicate"  Note: TOKEN_STRING_DUPLICATE
        Otherwise If builtin_type is equal to 76: Set func_name to "integer_to_string"  Note: TOKEN_INTEGER_TO_STRING
        Otherwise If builtin_type is equal to 119: Set func_name to "allocate"  Note: TOKEN_ALLOCATE
        Otherwise If builtin_type is equal to 120: Set func_name to "deallocate"  Note: TOKEN_DEALLOCATE
        Otherwise If builtin_type is equal to 130: Set func_name to "memory_get_byte"  Note: TOKEN_MEMORY_GET_BYTE
        Otherwise If builtin_type is equal to 131: Set func_name to "memory_set_byte"  Note: TOKEN_MEMORY_SET_BYTE
        End If

        Note: Generate the call
        file_write_buffered(output_file, "    call ", 0)
        If func_name is equal to 0:
            file_write_buffered(output_file, "unknown_builtin_", 0)
            file_write_buffered(output_file, integer_to_string(builtin_type), 0)
        Otherwise:
            file_write_buffered(output_file, func_name, 0)
            file_write_buffered(output_file, "@PLT", 0)
        End If
        file_write_buffered(output_file, "\n", 0)
        Return 0
    Otherwise If expr_type is equal to 9:  Note: EXPR_VARIANT_CONSTRUCTOR
        Note: Get variant details
        Let type_name be memory_get_pointer(expr, 8)
        Let variant_name be memory_get_pointer(expr, 16)
        Let field_count be memory_get_int32(expr, 32)

        Note: Find the variant definition to get the tag
        Let current_program be memory_get_pointer(codegen, 48)
        Let type_count be memory_get_int32(current_program, 24)
        Let types be memory_get_pointer(current_program, 16)

        Let variant_tag be 0
        Set i to 0
        While i is less than type_count:
            Let type_ptr be memory_get_pointer_at_index(types, i)
            Let type_def_name be memory_get_pointer(type_ptr, 0)
            If string_equals(type_def_name, type_name) is equal to 1:
                Note: Found the type, now find the variant
                Let variant_count be memory_get_int32(type_ptr, 24)
                Let variants be memory_get_pointer(type_ptr, 16)

                Note: Loop through all variants to find match
                Let vi be 0
                Let found_match be 0
                While vi is less than variant_count:
                    Let variant_offset be vi multiplied by 32
                    Let variant_ptr be variants plus variant_offset
                    Let vname be memory_get_pointer(variant_ptr, 0)

                    If string_equals(vname, variant_name) is equal to 1:
                        Set variant_tag to memory_get_int32(variant_ptr, 20)
                        Set found_match to 1
                        Set vi to variant_count  Note: Break
                    Otherwise:
                        Set vi to vi plus 1
                    End If
                End While

                Note: If no match found, default to first variant (temporary workaround)
                If found_match is equal to 0:
                    If variant_count is greater than 0:
                        Let first_variant_ptr be variants
                        Set variant_tag to memory_get_int32(first_variant_ptr, 20)
                    End If
                End If
                Set i to type_count  Note: Break
            End If
            Set i to i plus 1
        End While

        Note: Allocate variant (8 bytes for tag + field storage)
        Let alloc_size be 8  Note: Just tag for fieldless variants
        If field_count is greater than 0:
            Let field_storage be field_count multiplied by 8
            Set alloc_size to alloc_size plus field_storage
        End If

        emit_line(output_file, "    # Allocate variant")
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(alloc_size), 0)
        file_write_buffered(output_file, ", %rdi\n", 0)
        emit_line(output_file, "    call allocate")

        Note: Store discriminator tag at offset 0
        file_write_buffered(output_file, "    movl $", 0)
        file_write_buffered(output_file, integer_to_string(variant_tag), 0)
        file_write_buffered(output_file, ", (%rax)  # Store variant tag\n", 0)

        Note: Store field values if field_count > 0
        If field_count is greater than 0:
            file_write_buffered(output_file, "    pushq %rax  # Save variant pointer\n", 0)

            Let field_values be memory_get_pointer(expr, 24)
            Let k be 0
            While k is less than field_count:
                Note: Generate field value expression
                Let field_value_expr be memory_get_pointer(field_values, k multiplied by 8)
                codegen_generate_expression(codegen, field_value_expr)

                Note: Store field value at offset 8 + (k * 8)
                Let field_offset be 8 plus k multiplied by 8
                file_write_buffered(output_file, "    movq (%rsp), %rbx  # Load variant pointer\n", 0)
                file_write_buffered(output_file, "    movq %rax, ", 0)
                file_write_buffered(output_file, integer_to_string(field_offset), 0)
                file_write_buffered(output_file, "(%rbx)  # Store field ", 0)
                file_write_buffered(output_file, integer_to_string(k), 0)
                file_write_buffered(output_file, "\n", 0)

                Set k to k plus 1
            End While

            file_write_buffered(output_file, "    popq %rax  # Restore variant pointer\n", 0)
        End If

        Return 0
    Otherwise If expr_type is equal to 10:  Note: EXPR_FUNCTION_POINTER
        Let function_pointer_ptr be expr plus 8  Note: Union at offset 4
        Set func_name to memory_get_pointer(function_pointer_ptr, 0)
        file_write_buffered(output_file, "    leaq ", 0)
        file_write_buffered(output_file, func_name, 0)
        file_write_buffered(output_file, "(%rip), %rax\n", 0)
        Return 0
    Otherwise If expr_type is equal to 16:  Note: EXPR_ARRAY_INDEX
        Note: Array indexing: array[index]
        Let array_expr be memory_get_pointer(expr, 8)
        Let index_expr be memory_get_pointer(expr, 16)

        Note: COMPILE-TIME BOUNDS CHECKING
        Note: If index is a constant integer literal, check bounds at compile time
        Let index_type be memory_get_int32(index_expr, 0)
        If index_type is equal to 0:  Note: EXPR_INTEGER_LITERAL
            Let constant_index be memory_get_int32(index_expr, 8)

            Note: Check if index is negative (always invalid)
            If constant_index is less than 0:
                print_string("[SAFETY ERROR] Array index ")
                print_integer(constant_index)
                print_string(" is negative - arrays cannot have negative indices\n")
                exit(1)
            End If

            Note: Check if array is an array literal (we know the size at compile time)
            Let array_type be memory_get_int32(array_expr, 0)
            If array_type is equal to 18:  Note: EXPR_ARRAY_LITERAL
                Let array_size be memory_get_int32(array_expr, 16)
                If constant_index is greater than or equal to array_size:
                    print_string("[SAFETY ERROR] Array index ")
                    print_integer(constant_index)
                    print_string(" is out of bounds (array size is ")
                    print_integer(array_size)
                    print_string(")\n")
                    exit(1)
                End If
                print_string("[SAFETY] Compile-time bounds check PASSED: index ")
                print_integer(constant_index)
                print_string(" is within array bounds [0..")
                print_integer(array_size)
                print_string(")\n")
            End If
        End If

        Note: Generate code for index (result in %rax)
        codegen_generate_expression(codegen, index_expr)
        file_write_buffered(output_file, "    pushq %rax  # Save index\n", 0)

        Note: Generate code for array (result in %rax)
        codegen_generate_expression(codegen, array_expr)

        Note: Pop index into %rbx, array pointer is in %rax
        file_write_buffered(output_file, "    popq %rbx  # Load index\n", 0)

        Note: RUNTIME BOUNDS CHECKING (always enabled for safety)
        Note: Runa arrays store their size in the first 8 bytes (at offset -8 from data pointer)
        Note: Check if index is negative
        file_write_buffered(output_file, "    # Runtime bounds check: ensure index >= 0\n", 0)
        file_write_buffered(output_file, "    cmpq $0, %rbx\n", 0)
        file_write_buffered(output_file, "    jl .bounds_error_negative\n", 0)

        Note: Load array size from metadata (stored at offset -8 from data pointer)
        file_write_buffered(output_file, "    # Runtime bounds check: ensure index < size\n", 0)
        file_write_buffered(output_file, "    movq -8(%rax), %rcx  # Load array size from metadata\n", 0)
        file_write_buffered(output_file, "    cmpq %rcx, %rbx  # Compare index with size\n", 0)
        file_write_buffered(output_file, "    jge .bounds_error_overflow\n", 0)

        Note: Calculate offset: index * 8 (pointer size)
        file_write_buffered(output_file, "    imulq $8, %rbx  # Multiply index by 8\n", 0)

        Note: Add offset to array pointer
        file_write_buffered(output_file, "    addq %rbx, %rax  # Add offset to array pointer\n", 0)

        Note: Load value from array[index]
        file_write_buffered(output_file, "    movq (%rax), %rax  # Load value from array\n", 0)

        Return 0
    End If

    If expr_type is equal to 17:  Note: EXPR_LIST_LITERAL
        Note: Get list elements and count
        Let elements be memory_get_pointer(expr, 8)
        Let element_count be memory_get_integer(expr, 16)

        Note: Create list using list_create()
        emit_line(output_file, "    call list_create")
        emit_line(output_file, "    pushq %rax  # Save list pointer")

        Note: Append each element using list_append()
        Set i to 0
        While i is less than element_count:
            Let elem_offset be i multiplied by 8
            Let elem_expr be memory_get_pointer(elements, elem_offset)

            Note: Generate element value
            codegen_generate_expression(codegen, elem_expr)
            emit_line(output_file, "    pushq %rax  # Save element value")

            Note: Call list_append(list, value)
            emit_line(output_file, "    movq 8(%rsp), %rdi  # Load list pointer")
            emit_line(output_file, "    movq (%rsp), %rsi   # Load element value")
            emit_line(output_file, "    call list_append")
            emit_line(output_file, "    popq %rax  # Clean up element value")

            Set i to i plus 1
        End While

        Note: Pop list pointer into %rax as result
        emit_line(output_file, "    popq %rax  # List pointer as result")
        Return 0
    End If

    If expr_type is equal to 18:  Note: EXPR_ARRAY_LITERAL
        Note: Get array elements, size, and type
        Set elements to memory_get_pointer(expr, 8)
        Set array_size to memory_get_integer(expr, 16)

        Note: Calculate size: array_size * 8 (assuming pointer-sized elements for now)
        Let total_size be array_size multiplied by 8

        Note: Allocate memory for array + 8 bytes for size metadata
        Let allocation_size be total_size plus 8
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(allocation_size), 0)
        file_write_buffered(output_file, ", %rdi\n", 0)
        file_write_buffered(output_file, "    call memory_allocate\n", 0)

        Note: Store array size in metadata at offset 0
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(array_size), 0)
        file_write_buffered(output_file, ", (%rax)  # Store array size in metadata\n", 0)

        Note: Adjust pointer to point to data (after metadata)
        file_write_buffered(output_file, "    addq $8, %rax  # Move pointer past metadata\n", 0)
        file_write_buffered(output_file, "    pushq %rax  # Save array data pointer\n", 0)

        Note: Generate code for each element and store
        Set i to 0
        While i is less than array_size:
            Set elem_offset to i multiplied by 8
            Set elem_expr to memory_get_pointer(elements, elem_offset)

            Note: Generate element value
            codegen_generate_expression(codegen, elem_expr)

            Note: Store in array
            file_write_buffered(output_file, "    movq (%rsp), %rbx  # Load array data pointer\n", 0)
            file_write_buffered(output_file, "    movq %rax, ", 0)
            file_write_buffered(output_file, integer_to_string(elem_offset), 0)
            file_write_buffered(output_file, "(%rbx)\n", 0)

            Set i to i plus 1
        End While

        Note: Pop array data pointer into %rax as result
        file_write_buffered(output_file, "    popq %rax  # Array data pointer as result\n", 0)
        Return 0
    End If

    If expr_type is equal to 19:  Note: EXPR_ARRAY_TYPE (uninitialized)
        Note: Get array size
        Set array_size to memory_get_integer(expr, 8)

        Note: Calculate size: array_size * 8
        Set total_size to array_size multiplied by 8

        Note: Allocate zeroed memory + 8 bytes for size metadata
        Set allocation_size to total_size plus 8
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(allocation_size), 0)
        file_write_buffered(output_file, ", %rdi\n", 0)
        file_write_buffered(output_file, "    call memory_allocate\n", 0)

        Note: Store array size in metadata at offset 0
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(array_size), 0)
        file_write_buffered(output_file, ", (%rax)  # Store array size in metadata\n", 0)

        Note: Adjust pointer to point to data (after metadata)
        file_write_buffered(output_file, "    addq $8, %rax  # Move pointer past metadata\n", 0)
        Return 0
    End If

    If expr_type is equal to 20:  Note: EXPR_STRUCT_CONSTRUCTION
        Note: Get struct construction data
        Let struct_type_name be memory_get_pointer(expr, 8)
        Let field_names be memory_get_pointer(expr, 16)
        Set field_values to memory_get_pointer(expr, 24)
        Set field_count to memory_get_int32(expr, 32)

        Note: Find the struct type definition to get size and field offsets
        Set current_program to memory_get_pointer(codegen, 48)
        Set type_count to memory_get_int32(current_program, 24)  Note: PROGRAM_TYPE_COUNT
        Set types to memory_get_pointer(current_program, 16)      Note: PROGRAM_TYPES
        Let type be 0

        Let type_i be 0
        While type_i is less than type_count:
            Let type_offset be type_i multiplied by 8
            Set type_ptr to memory_get_pointer(types, type_offset)
            Set type_name to memory_get_pointer(type_ptr, 0)
            If string_equals(type_name, struct_type_name) is equal to 1:
                Set type to type_ptr
                Set type_i to type_count  Note: break
            End If
            Set type_i to type_i plus 1
        End While

        If type is equal to 0:
            print_string("[CODEGEN ERROR] Unknown struct type '")
            print_string(struct_type_name)
            print_string("'")
            exit_with_code(1)
        End If

        Note: Calculate struct size from type definition
        Note: TYPEDEFINITION_SIZE_OFFSET is 40
        Let struct_size be memory_get_int32(type, 40)  Note: TYPEDEFINITION_SIZE_OFFSET

        Note: Allocate memory for struct
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(struct_size), 0)
        file_write_buffered(output_file, ", %rdi\n", 0)
        file_write_buffered(output_file, "    call allocate@PLT\n", 0)
        file_write_buffered(output_file, "    pushq %rax  # Save struct pointer\n", 0)

        Note: Set each field value
        Let field_i be 0
        While field_i is less than field_count:
            Let field_ptr_offset be field_i multiplied by 8
            Let field_name be memory_get_pointer(field_names, field_ptr_offset)
            Set field_value_expr to memory_get_pointer(field_values, field_ptr_offset)

            Note: Find field offset in type definition
            Note: TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET is 24
            Note: TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET is 16
            Let struct_field_count be memory_get_int32(type, 24)
            Let fields be memory_get_pointer(type, 16)
            Set field_offset to -1

            Let field_j be 0
            While field_j is less than struct_field_count:
                Let field_def_offset be field_j multiplied by 24
                Let field_def_ptr be fields plus field_def_offset
                Let field_def_name be memory_get_pointer(field_def_ptr, 0)
                If string_equals(field_def_name, field_name) is equal to 1:
                    Set field_offset to memory_get_int32(field_def_ptr, 16)
                    Set field_j to struct_field_count  Note: break
                End If
                Set field_j to field_j plus 1
            End While

            If field_offset is less than 0:
                print_string("[CODEGEN ERROR] Unknown field '")
                print_string(field_name)
                print_string("' in struct '")
                print_string(struct_type_name)
                print_string("'")
                exit_with_code(1)
            End If

            Note: Generate field value expression
            codegen_generate_expression(codegen, field_value_expr)

            Note: Store value in struct field
            file_write_buffered(output_file, "    movq (%rsp), %rbx  # Load struct pointer\n", 0)
            file_write_buffered(output_file, "    movq %rax, ", 0)
            file_write_buffered(output_file, integer_to_string(field_offset), 0)
            file_write_buffered(output_file, "(%rbx)  # Store field value\n", 0)

            Set field_i to field_i plus 1
        End While

        Note: Pop struct pointer into %rax as result
        file_write_buffered(output_file, "    popq %rax  # Struct pointer as result\n", 0)
        Return 0
    End If

    If expr_type is equal to 21:  Note: EXPR_SET_LITERAL
        Note: Get set elements and count
        Set elements to memory_get_pointer(expr, 8)
        Set element_count to memory_get_integer(expr, 16)

        Note: Create set using set_create()
        emit_line(output_file, "    call set_create")
        emit_line(output_file, "    pushq %rax  # Save set pointer")

        Note: Add each element using set_add()
        Set i to 0
        While i is less than element_count:
            Set elem_offset to i multiplied by 8
            Set elem_expr to memory_get_pointer(elements, elem_offset)

            Note: Generate element value
            codegen_generate_expression(codegen, elem_expr)
            emit_line(output_file, "    pushq %rax  # Save element value")

            Note: Call set_add(set, value)
            emit_line(output_file, "    movq 8(%rsp), %rdi  # Load set pointer")
            emit_line(output_file, "    movq (%rsp), %rsi   # Load element value")
            emit_line(output_file, "    call set_add")
            emit_line(output_file, "    popq %rax  # Clean up element value")

            Set i to i plus 1
        End While

        Note: Pop set pointer into %rax as result
        emit_line(output_file, "    popq %rax  # Set pointer as result")
        Return 0
    End If

    If expr_type is equal to 22:  Note: EXPR_DICT_LITERAL
        Note: Get dictionary keys, values, and pair count
        Let keys be memory_get_pointer(expr, 8)
        Let values be memory_get_pointer(expr, 16)
        Let pair_count be memory_get_integer(expr, 24)

        Note: Create dictionary using dict_create()
        emit_line(output_file, "    call dict_create")
        emit_line(output_file, "    pushq %rax  # Save dict pointer")

        Note: Add each key-value pair using dict_set()
        Set i to 0
        While i is less than pair_count:
            Let pair_offset be i multiplied by 8
            Let key_expr be memory_get_pointer(keys, pair_offset)
            Let value_expr be memory_get_pointer(values, pair_offset)

            Note: Generate key expression
            codegen_generate_expression(codegen, key_expr)
            emit_line(output_file, "    pushq %rax  # Save key")

            Note: Generate value expression
            codegen_generate_expression(codegen, value_expr)
            emit_line(output_file, "    pushq %rax  # Save value")

            Note: Call dict_set(dict, key, value)
            emit_line(output_file, "    movq 16(%rsp), %rdi  # Load dict pointer")
            emit_line(output_file, "    movq 8(%rsp), %rsi   # Load key")
            emit_line(output_file, "    movq (%rsp), %rdx    # Load value")
            emit_line(output_file, "    call dict_set")
            emit_line(output_file, "    addq $16, %rsp  # Clean up key and value")

            Set i to i plus 1
        End While

        Note: Pop dict pointer into %rax as result
        emit_line(output_file, "    popq %rax  # Dict pointer as result")
        Return 0
    End If

    If expr_type is equal to 23:  Note: EXPR_LAMBDA
        Note: Generate lambda closure (no free variables yet)

        Note: Get lambda parameters and body
        Note: Check if multi-parameter (param_count at offset 24) or single parameter
        Let param_count be memory_get_int32(expr, 24)
        Let body_expr be memory_get_pointer(expr, 16)
        Let param_names be memory_get_pointer(expr, 8)

        Note: Generate unique lambda function name
        Let lambda_counter be memory_get_int32(codegen, 28)  Note: label_counter
        memory_set_int32(codegen, 28, lambda_counter plus 1)

        Note: Build lambda function name: __lambda_N
        Let lambda_name be "__lambda_"
        Let counter_str be codegen_arena_int_to_str(codegen, lambda_counter)
        Let full_lambda_name be codegen_arena_concat(codegen, lambda_name, counter_str)

        Note: Save current function context
        Let saved_variables be memory_get_pointer(codegen, 8)
        Let saved_var_count be memory_get_int32(codegen, 16)
        Let saved_var_capacity be memory_get_int32(codegen, 20)
        Let saved_stack_offset be memory_get_int32(codegen, 24)

        Note: Create new variable context for lambda
        Let lambda_variables be allocate(16 multiplied by 32)
        memory_set_pointer(codegen, 8, lambda_variables)
        memory_set_int32(codegen, 16, 0)
        memory_set_int32(codegen, 20, 16)
        memory_set_int32(codegen, 24, 0)

        Note: Get free variables for closure support
        Let free_vars be memory_get_pointer(expr, 32)
        Let free_var_count be memory_get_int32(expr, 40)

        Note: Add free variables FIRST (mark them as closure variables)
        Note: Store the environment array index directly (0, 8, 16, etc.)
        Set i to 0
        While i is less than free_var_count:
            Let var_offset be i multiplied by 8
            Let free_var_name be memory_get_pointer(free_vars, var_offset)
            codegen_add_variable(codegen, free_var_name)
            Note: Mark this variable as a closure variable
            Let var_index be memory_get_int32(codegen, 16) minus 1
            Let variables be memory_get_pointer(codegen, 8)
            Let var_struct_offset be var_index multiplied by 32
            Let var_ptr be variables plus var_struct_offset
            Note: Store -1 as stack offset to mark as closure variable
            Note: Store actual environment offset in is_parameter field (reusing it)
            memory_set_int32(var_ptr, 8, -1)
            memory_set_int32(var_ptr, 24, var_offset)  Note: Environment offset in is_parameter field
            Set i to i plus 1
        End While

        Note: Reset stack offset before adding parameters
        Note: Free variables don't use stack space, so reset to base offset
        memory_set_int32(codegen, 24, 8)

        Note: Add parameters as local variables
        If param_count is equal to 0:
            Note: Single parameter (old format) - param_names is a string pointer
            codegen_add_variable(codegen, param_names)
            Set param_count to 1
        Otherwise:
            Note: Multiple parameters - param_names is an array of string pointers
            Set i to 0
            While i is less than param_count:
                Let param_offset be i multiplied by 8
                Let param_name be memory_get_pointer(param_names, param_offset)
                codegen_add_variable(codegen, param_name)
                Set i to i plus 1
            End While
        End If

        Note: Generate lambda function in assembly
        Note: First, emit a jump to skip over the lambda function code
        Let skip_label be "__skip_lambda_"
        Let skip_label_full be codegen_arena_concat(codegen, skip_label, counter_str)
        file_write_buffered(output_file, "    jmp ", 0)
        emit_line(output_file, skip_label_full)

        emit_line(output_file, "")
        emit_line(output_file, "# Lambda function")
        file_write_buffered(output_file, full_lambda_name, 0)
        emit_line(output_file, ":")
        emit_line(output_file, "    pushq %rbp")
        emit_line(output_file, "    movq %rsp, %rbp")

        Note: Calculate stack space needed for parameters + environment pointer
        Let stack_space be param_count multiplied by 8 plus 8
        Let stack_space_aligned be stack_space plus 8
        file_write_buffered(output_file, "    subq $", 0)
        file_write_buffered(output_file, integer_to_string(stack_space_aligned), 0)
        emit_line(output_file, ", %rsp  # Allocate space for environment + parameters")

        Note: CRITICAL: First parameter in %rdi is the environment pointer (from closure)
        Note: Store environment pointer at a fixed location we can reference
        emit_line(output_file, "    movq %rdi, -8(%rbp)  # Store environment pointer")

        Note: Store parameters on stack from registers (shifted by one)
        Note: Real parameters start at %rsi, %rdx, %rcx, %r8, %r9, stack
        If param_count is greater than 0:
            emit_line(output_file, "    movq %rsi, -16(%rbp)  # Store parameter 1")
        End If
        If param_count is greater than 1:
            emit_line(output_file, "    movq %rdx, -24(%rbp)  # Store parameter 2")
        End If
        If param_count is greater than 2:
            emit_line(output_file, "    movq %rcx, -32(%rbp)  # Store parameter 3")
        End If
        If param_count is greater than 3:
            emit_line(output_file, "    movq %r8, -40(%rbp)  # Store parameter 4")
        End If
        If param_count is greater than 4:
            emit_line(output_file, "    movq %r9, -48(%rbp)  # Store parameter 5")
        End If
        If param_count is greater than 5:
            emit_line(output_file, "    movq 16(%rbp), -56(%rbp)  # Store parameter 6 (from stack)")
        End If

        Note: Generate body expression
        codegen_generate_expression(codegen, body_expr)

        Note: Result is in %rax, clean up and return
        emit_line(output_file, "    leave")
        emit_line(output_file, "    ret")
        emit_line(output_file, "")

        Note: Emit skip label
        file_write_buffered(output_file, skip_label_full, 0)
        emit_line(output_file, ":")

        Note: Restore original function context
        deallocate(lambda_variables)
        memory_set_pointer(codegen, 8, saved_variables)
        memory_set_int32(codegen, 16, saved_var_count)
        memory_set_int32(codegen, 20, saved_var_capacity)
        memory_set_int32(codegen, 24, saved_stack_offset)

        Note: Get free variables for closure environment
        Set free_vars to memory_get_pointer(expr, 32)
        Set free_var_count to memory_get_int32(expr, 40)

        Note: Allocate environment struct if there are free variables
        Let env_ptr be 0
        If free_var_count is greater than 0:
            Note: Environment struct: array of pointers to captured values
            Let env_size be free_var_count multiplied by 8
            file_write_buffered(output_file, "    # Allocate environment for ", 0)
            file_write_buffered(output_file, integer_to_string(free_var_count), 0)
            emit_line(output_file, " captured variables")
            file_write_buffered(output_file, "    movq $", 0)
            file_write_buffered(output_file, integer_to_string(env_size), 0)
            emit_line(output_file, ", %rdi")
            emit_line(output_file, "    call allocate")
            emit_line(output_file, "    pushq %rax  # Save environment pointer")

            Note: Populate environment with current values of free variables
            Set i to 0
            While i is less than free_var_count:
                Set var_offset to i multiplied by 8
                Let var_name be memory_get_pointer(free_vars, var_offset)

                Note: Find variable in current scope
                Set var_index to codegen_find_variable(codegen, var_name)
                If var_index is less than 0:
                    print_string("[CODEGEN ERROR] Free variable not found in scope: ")
                    print_string(var_name)
                    print_newline()
                    exit(1)
                End If

                Note: Load variable value into %rbx
                Set variables to memory_get_pointer(codegen, 8)
                Set var_struct_offset to var_index multiplied by 32
                Set var_ptr to variables plus var_struct_offset
                Let stack_offset_u be memory_get_integer(var_ptr, 8)
                Note: Check if this variable is itself a closure variable (shouldn't happen in normal cases)
                If stack_offset_u is equal to 4294967295:
                    print_string("[CODEGEN ERROR] Attempting to capture a closure variable - this indicates a compiler bug")
                    exit(1)
                End If
                file_write_buffered(output_file, "    movq -", 0)
                file_write_buffered(output_file, integer_to_string(stack_offset_u), 0)
                emit_line(output_file, "(%rbp), %rbx  # Load captured variable")

                Note: Store in environment at correct offset
                emit_line(output_file, "    popq %rax  # Get environment pointer")
                file_write_buffered(output_file, "    movq %rbx, ", 0)
                file_write_buffered(output_file, integer_to_string(var_offset), 0)
                emit_line(output_file, "(%rax)  # Store in environment")
                emit_line(output_file, "    pushq %rax  # Save environment pointer again")

                Set i to i plus 1
            End While

            emit_line(output_file, "    popq %rcx  # Final environment pointer in %rcx")
        End If

        Note: Now allocate closure struct (16 bytes: function_ptr + environment)
        emit_line(output_file, "    # Allocate closure struct")
        Note: Save %rcx across allocate call (it's caller-saved and will be clobbered)
        If free_var_count is greater than 0:
            emit_line(output_file, "    pushq %rcx  # Save environment pointer across call")
        End If
        emit_line(output_file, "    movq $16, %rdi")
        emit_line(output_file, "    call allocate")
        emit_line(output_file, "    pushq %rax  # Save closure pointer")

        Note: Store function pointer in closure at offset 0
        file_write_buffered(output_file, "    leaq ", 0)
        file_write_buffered(output_file, full_lambda_name, 0)
        emit_line(output_file, "(%rip), %rbx  # Load function address")
        emit_line(output_file, "    popq %rax  # Restore closure pointer")
        emit_line(output_file, "    movq %rbx, 0(%rax)  # Store function_ptr")

        Note: Store environment pointer at offset 8
        If free_var_count is greater than 0:
            emit_line(output_file, "    popq %rcx  # Restore environment pointer")
            emit_line(output_file, "    movq %rcx, 8(%rax)  # Store environment pointer")
        Otherwise:
            emit_line(output_file, "    movq $0, 8(%rax)  # NULL environment")
        End If

        Note: Closure pointer is now in %rax as result
        Return 0
    End If

    If expr_type is equal to 24:  Note: EXPR_LAMBDA_CALL
        Note: Phase 4: Invoke lambda with multiple arguments
        Note: Structure: lambda_expr at offset 8, arguments at offset 16, arg_count at offset 24

        Note: Get lambda expression (should evaluate to closure pointer)
        Let lambda_expr be memory_get_pointer(expr, 8)
        Set arguments to memory_get_pointer(expr, 16)
        Set arg_count to memory_get_int32(expr, 24)

        Note: Evaluate all arguments and save on stack
        Note: Must evaluate in reverse order to push correctly
        Set i to 0
        While i is less than arg_count:
            Set arg_offset to i multiplied by 8
            Set arg_expr to memory_get_pointer(arguments, arg_offset)
            codegen_generate_expression(codegen, arg_expr)
            emit_line(output_file, "    pushq %rax  # Save argument on stack")
            Set i to i plus 1
        End While

        Note: Generate code to evaluate lambda expression to get closure pointer
        codegen_generate_expression(codegen, lambda_expr)
        Note: Result is closure pointer in %rax

        Note: Save closure pointer in non-argument register
        emit_line(output_file, "    movq %rax, %r10  # Save closure pointer in r10")

        Note: Load environment pointer from closure (offset 8) - this goes in %rdi
        emit_line(output_file, "    movq 8(%r10), %rdi  # Load environment pointer (first param)")

        Note: Pop arguments from stack into argument registers (reverse order, SHIFTED BY ONE)
        Note: x86-64 calling convention: %rdi=env, %rsi=arg1, %rdx=arg2, %rcx=arg3, %r8=arg4, %r9=arg5
        If arg_count is greater than 5:
            print_string("[CODEGEN ERROR] Lambda calls support max 5 arguments (6th register used for environment)")
            print_newline()
            exit_with_code(1)
        End If

        Note: Arguments are on stack in order arg1, arg2, ..., argN (argN on top)
        Note: Pop in reverse to get them into registers (shifted: %rsi, %rdx, %rcx, %r8, %r9)
        If arg_count is greater than 4:
            emit_line(output_file, "    popq %r9  # Pop argument 5")
        End If
        If arg_count is greater than 3:
            emit_line(output_file, "    popq %r8  # Pop argument 4")
        End If
        If arg_count is greater than 2:
            emit_line(output_file, "    popq %rcx  # Pop argument 3")
        End If
        If arg_count is greater than 1:
            emit_line(output_file, "    popq %rdx  # Pop argument 2")
        End If
        If arg_count is greater than 0:
            emit_line(output_file, "    popq %rsi  # Pop argument 1")
        End If

        Note: Load function pointer from closure (offset 0)
        emit_line(output_file, "    movq 0(%r10), %rbx  # Load function pointer from closure")

        Note: Call the lambda function (environment already in %rdi)
        emit_line(output_file, "    call *%rbx  # Invoke lambda")

        Note: Result is in %rax
        Return 0
    End If

    Note: Default case
    print_string("[CODEGEN ERROR] Unsupported expression type: ")
    print_integer(expr_type)
    print_newline()
    exit_with_code(1)
    Return 0
End Process

Note: ============================================================================
Note: BREAK/CONTINUE/LOOP STATEMENT GENERATION
Note: ============================================================================

Process called "codegen_generate_break" takes codegen as Integer, stmt as Integer returns Integer:
    Note: Generate break statement: jmp to loop end label
    Let output_file be memory_get_integer(codegen, 0)
    Let label_name be memory_get_pointer(stmt, 8)  Note: Optional label

    Note: Find matching loop context
    Let context be codegen_find_loop_context(label_name)

    If context is equal to 0:
        Note: Error: break outside loop or label not found
        If label_name is equal to 0:
            emit_line(output_file, "    # ERROR: Break statement outside of loop")
        Otherwise:
            Let error_msg be codegen_arena_concat(codegen, "    # ERROR: Break label not found: ", label_name)
            emit_line(output_file, error_msg)
        End If
        Return 0
    End If

    Note: Get break label from context
    Let break_label be memory_get_pointer(context, 8)

    Note: Generate jump to loop end
    Let jmp_instruction be codegen_arena_concat(codegen, "    jmp ", break_label)
    emit_line(output_file, jmp_instruction)

    Return 1
End Process

Process called "codegen_generate_continue" takes codegen as Integer, stmt as Integer returns Integer:
    Note: Generate continue statement: jmp to loop condition label
    Let output_file be memory_get_integer(codegen, 0)
    Let label_name be memory_get_pointer(stmt, 8)  Note: Optional label

    Note: Find matching loop context
    Let context be codegen_find_loop_context(label_name)

    If context is equal to 0:
        Note: Error: continue outside loop or label not found
        If label_name is equal to 0:
            emit_line(output_file, "    # ERROR: Continue statement outside of loop")
        Otherwise:
            Let error_msg be codegen_arena_concat(codegen, "    # ERROR: Continue label not found: ", label_name)
            emit_line(output_file, error_msg)
        End If
        Return 0
    End If

    Note: Get continue label from context
    Let continue_label be memory_get_pointer(context, 16)

    Note: Generate jump to loop start/condition
    Let jmp_instruction be codegen_arena_concat(codegen, "    jmp ", continue_label)
    emit_line(output_file, jmp_instruction)

    Return 1
End Process

Process called "codegen_generate_loop" takes codegen as Integer, stmt as Integer returns Integer:
    Note: Loop statement stores label name in current loop context
    Note: This doesn't generate code itself - just updates the context
    Let output_file be memory_get_integer(codegen, 0)
    Let label_name be memory_get_pointer(stmt, 8)  Note: Required label

    Note: Update current loop context with this label
    If loop_context_stack is not equal to 0:
        Note: Free old label if it exists
        Let old_label be memory_get_pointer(loop_context_stack, 0)
        If old_label is not equal to 0:
            deallocate(old_label)
        End If

        Note: Set new label
        Let dup_label be string_duplicate(label_name)
        memory_set_pointer(loop_context_stack, 0, dup_label)
    Otherwise:
        Note: Error: Loop statement outside of loop
        emit_line(output_file, "    # ERROR: Loop statement outside of loop")
        Return 0
    End If

    Return 1
End Process

Process called "codegen_generate_statement" takes codegen as Integer, stmt as Integer returns Integer:
    Let stmt_type be memory_get_int32(stmt, 0)  Note: stmt->type - use int32 not integer
    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file

    If stmt_type is equal to 1:  Note: STMT_LET
        Note: Get the variable name first - it's always needed
        Let variable_name be memory_get_pointer(stmt, 8)  Note: stmt->data.let_stmt.variable_name at offset 8

        Note: Check if this is a type allocation
        Let let_expr be memory_get_pointer(stmt, 16)  Note: stmt->data.let_stmt.expression at offset 16
        If let_expr is not equal to 0:
            Let expr_type be memory_get_int32(let_expr, 0)  Note: expr->type
            If expr_type is equal to 7:  Note: EXPR_TYPE_NAME
                Note: This is a struct allocation - find the type
                Let type_name be memory_get_pointer(let_expr, 8)  Note: expr->data.type_name
                Let current_program be memory_get_pointer(codegen, 48)  Note: codegen->current_program (pointer with padding)
                Let type_count be memory_get_int32(current_program, 24)  Note: PROGRAM_TYPE_COUNT
                Let types be memory_get_pointer(current_program, 16)  Note: PROGRAM_TYPES

                Let type_found be 0
                Let type_def be 0
                Let i be 0
                While i is less than type_count:
                    Let current_type be memory_get_pointer(types, i multiplied by 8)
                    Let current_type_name be memory_get_pointer(current_type, 0)  Note: type->name
                    If string_equals(current_type_name, type_name) is equal to 1:
                        Set type_found to 1
                        Set type_def to current_type
                        Set i to type_count  Note: Break
                    End If
                    Set i to i plus 1
                End While

                If type_found is equal to 0:
                    exit_with_code(1)
                    Return 1
                End If

                Note: Add variable with type information
                codegen_add_variable_with_type(codegen, variable_name, type_name)

                Note: Get variable info
                Let var_index be codegen_find_variable(codegen, variable_name)
                Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
                Let offset be memory_get_int32(variables, var_index multiplied by 32 plus 8)  Note: variables[var_index].stack_offset

                Note: Handle different type kinds
                Let type_kind be memory_get_int32(type_def, 8)  Note: type->kind
                Let type_size be memory_get_int32(type_def, 16)  Note: type->size

                If type_kind is equal to 3:  Note: TYPE_KIND_ARRAY
                    Note: For arrays, allocate space for all elements and zero out memory
                    Set i to 0
                    While i is less than type_size:
                        file_write_buffered(output_file, "    movq $0, -", 0)
                        file_write_buffered(output_file, integer_to_string(offset minus i), 0)
                        file_write_buffered(output_file, "(%rbp)  # Zero array element", 0)
                        Set i to i plus 8
                    End While

                    Note: Update stack offset to account for full array size
                    Let current_stack_offset be memory_get_int32(codegen, 24)  Note: codegen->stack_offset
                    memory_set_integer(codegen, 16, current_stack_offset plus type_size)
                Otherwise:
                    Note: For structs, zero out the struct memory
                    Set i to 0
                    While i is less than type_size:
                        file_write_buffered(output_file, "    movq $0, -", 0)
                        file_write_buffered(output_file, integer_to_string(offset minus i), 0)
                        file_write_buffered(output_file, "(%rbp)\n", 0)
                        Set i to i plus 8
                    End While
                End If
            Otherwise:
                Note: Regular expression - check if the expression returns a string or list
                If expr_type is equal to 8:  Note: EXPR_BUILTIN_CALL
                    Let builtin_call_ptr be let_expr plus 8  Note: &expr->data.builtin_call
                    Let builtin_type be memory_get_int32(builtin_call_ptr, 0)  Note: builtin_call.builtin_type

                    Note: Check for string-returning builtins (read_file, string_substring, string_concat, integer_to_string, string_replace, string_trim)
                    Let is_string_builtin be 0
                    If builtin_type is equal to 37:
                        Set is_string_builtin to 1
                    Otherwise If builtin_type is equal to 42:
                        Set is_string_builtin to 1
                    Otherwise If builtin_type is equal to 48:
                        Set is_string_builtin to 1
                    Otherwise If builtin_type is equal to 49:
                        Set is_string_builtin to 1
                    Otherwise If builtin_type is equal to 52:
                        Set is_string_builtin to 1
                    Otherwise If builtin_type is equal to 54:
                        Set is_string_builtin to 1
                    End If
                    If is_string_builtin is equal to 1:
                        codegen_add_variable_with_type(codegen, variable_name, "String")
                    Otherwise:
                        Note: Check for list-returning builtins (list_create, list_copy, list_merge)
                        Let is_list_builtin be 0
                        If builtin_type is equal to 19:
                            Set is_list_builtin to 1
                        Otherwise If builtin_type is equal to 31:
                            Set is_list_builtin to 1
                        Otherwise If builtin_type is equal to 32:
                            Set is_list_builtin to 1
                        End If
                        If is_list_builtin is equal to 1:
                            codegen_add_variable_with_type(codegen, variable_name, "List")
                        Otherwise:
                            Note: Regular integer/other builtin expression
                            Note: Try to infer type from expression
                            Let inferred_type be codegen_get_expression_type(codegen, let_expr)
                            If inferred_type is equal to 0:
                                codegen_add_variable(codegen, variable_name)
                            Otherwise:
                                codegen_add_variable_with_type(codegen, variable_name, inferred_type)
                            End If
                        End If
                    End If
                Otherwise:
                    Note: Regular integer/other expression (non-builtin) - infer type
                    Set inferred_type to codegen_get_expression_type(codegen, let_expr)
                    If inferred_type is equal to 0:
                        codegen_add_variable(codegen, variable_name)
                    Otherwise:
                        codegen_add_variable_with_type(codegen, variable_name, inferred_type)
                    End If
                End If

                Note: Generate expression (result in %rax)
                codegen_generate_expression(codegen, let_expr)

                Note: Store value in variable's stack slot
                Set var_index to codegen_find_variable(codegen, variable_name)
                Set variables to memory_get_pointer(codegen, 8)  Note: codegen->variables
                Set offset to memory_get_int32(variables, var_index multiplied by 32 plus 8)  Note: variables[var_index].stack_offset
                file_write_buffered(output_file, "    movq %rax, -", 0)
                file_write_buffered(output_file, integer_to_string(offset), 0)
                file_write_buffered(output_file, "(%rbp)\n", 0)
            End If
        End If
        Return 0
    End If

    If stmt_type is equal to 2:  Note: STMT_SET
        Note: Generate value expression (result in %rax)
        Let set_expr be memory_get_pointer(stmt, 16)  Note: stmt->data.set_stmt.expression
        codegen_generate_expression(codegen, set_expr)

        Note: Save the value on the stack
        emit_line(output_file, "    pushq %rax")

        Note: Generate the address of the target (result in %rbx)
        Let set_target be memory_get_pointer(stmt, 8)  Note: stmt->data.set_stmt.target
        codegen_generate_lvalue_address(codegen, set_target)

        Note: Restore value and store to target address
        emit_line(output_file, "    popq %rax")
        emit_line(output_file, "    movq %rax, (%rbx)")
        Return 0
    End If

    If stmt_type is equal to 17:  Note: STMT_COMPOUND_ASSIGN
        Note: Generate RHS expression (result in %rax)
        Let compound_expr be memory_get_pointer(stmt, 24)  Note: expression at offset 24
        codegen_generate_expression(codegen, compound_expr)

        Note: Save RHS value on stack
        emit_line(output_file, "    pushq %rax")

        Note: Generate the address of the target (result in %rbx)
        Let compound_target be memory_get_pointer(stmt, 8)  Note: target at offset 8
        codegen_generate_lvalue_address(codegen, compound_target)

        Note: Load current value from target into %rcx
        emit_line(output_file, "    movq (%rbx), %rcx")

        Note: Pop RHS value into %rax
        emit_line(output_file, "    popq %rax")

        Note: Get operation type: 0=add, 1=sub, 2=mul, 3=div
        Let operation be memory_get_int32(stmt, 16)  Note: operation at offset 16

        Note: Perform operation: %rcx = %rcx op %rax
        If operation is equal to 0:
            emit_line(output_file, "    addq %rax, %rcx")
        End If
        If operation is equal to 1:
            emit_line(output_file, "    subq %rax, %rcx")
        End If
        If operation is equal to 2:
            emit_line(output_file, "    imulq %rax, %rcx")
        End If
        If operation is equal to 3:
            Note: Division: %rcx / %rax
            Note: Move dividend to %rax, save divisor
            emit_line(output_file, "    pushq %rax")
            emit_line(output_file, "    movq %rcx, %rax")
            emit_line(output_file, "    cqto")
            emit_line(output_file, "    popq %rcx")
            emit_line(output_file, "    idivq %rcx")
            emit_line(output_file, "    movq %rax, %rcx")
        End If

        Note: Store result back to target
        emit_line(output_file, "    movq %rcx, (%rbx)")
        Return 0
    End If

    If stmt_type is equal to 11:  Note: STMT_FOR
        Let label_counter be memory_get_int32(codegen, 28)
        Let label_num be label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)

        Let loop_start_label be label_num multiplied by 10 plus 1
        Let loop_end_label be label_num multiplied by 10 plus 2

        Note: Create label strings for the new loop context system
        Let loop_start_str be codegen_arena_concat(codegen, ".L", codegen_arena_int_to_str(codegen, loop_start_label))
        Let loop_end_str be codegen_arena_concat(codegen, ".L", codegen_arena_int_to_str(codegen, loop_end_label))

        Note: Get loop components
        Let var_name be memory_get_pointer(stmt, 8)
        Let start_expr be memory_get_pointer(stmt, 16)
        Let end_expr be memory_get_pointer(stmt, 24)
        Let step_expr be memory_get_pointer(stmt, 32)
        Let body be memory_get_pointer(stmt, 40)
        Let body_count be memory_get_integer(stmt, 48)

        Note: Allocate loop variable on stack
        codegen_add_variable(codegen, var_name)
        Set var_index to codegen_find_variable(codegen, var_name)
        Set variables to memory_get_pointer(codegen, 8)
        Let var_offset be memory_get_int32(variables, var_index multiplied by 32 plus 8)

        Note: Generate start expression and store in loop variable
        codegen_generate_expression(codegen, start_expr)
        file_write_buffered(output_file, "    movq %rax, -", 0)
        file_write_buffered(output_file, integer_to_string(var_offset), 0)
        file_write_buffered(output_file, "(%rbp)\n", 0)

        Note: Generate end expression and save on stack
        codegen_generate_expression(codegen, end_expr)
        emit_line(output_file, "    pushq %rax")

        Note: Push loop context for break/continue statements (no label name for unlabeled loop)
        Let dummy_push_for be codegen_push_loop_context(codegen, 0, loop_end_str, loop_start_str)

        Note: Loop start label
        Let loop_start_label_line be codegen_arena_concat(codegen, loop_start_str, ":")
        emit_line(output_file, loop_start_label_line)

        Note: Load loop variable and end value, compare
        file_write_buffered(output_file, "    movq -", 0)
        file_write_buffered(output_file, integer_to_string(var_offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax\n", 0)
        emit_line(output_file, "    movq (%rsp), %rcx")
        emit_line(output_file, "    cmpq %rcx, %rax")
        Let jg_instruction be codegen_arena_concat(codegen, "    jg ", loop_end_str)
        emit_line(output_file, jg_instruction)

        Note: Generate loop body
        Set i to 0
        While i is less than body_count:
            Let body_stmt be memory_get_pointer(body, i multiplied by 8)
            codegen_generate_statement(codegen, body_stmt)
            Set i to i plus 1
        End While

        Note: Increment loop variable by step
        If step_expr is not equal to 0:
            codegen_generate_expression(codegen, step_expr)
            emit_line(output_file, "    pushq %rax")
        End If
        If step_expr is equal to 0:
            emit_line(output_file, "    movq $1, %rax")
            emit_line(output_file, "    pushq %rax")
        End If
        file_write_buffered(output_file, "    movq -", 0)
        file_write_buffered(output_file, integer_to_string(var_offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax\n", 0)
        emit_line(output_file, "    popq %rcx")
        emit_line(output_file, "    addq %rcx, %rax")
        file_write_buffered(output_file, "    movq %rax, -", 0)
        file_write_buffered(output_file, integer_to_string(var_offset), 0)
        file_write_buffered(output_file, "(%rbp)\n", 0)

        Note: Jump back to loop start
        Let jmp_instruction be codegen_arena_concat(codegen, "    jmp ", loop_start_str)
        emit_line(output_file, jmp_instruction)

        Note: Loop end label
        Let loop_end_label_line be codegen_arena_concat(codegen, loop_end_str, ":")
        emit_line(output_file, loop_end_label_line)

        Note: Pop end value from stack
        emit_line(output_file, "    popq %rax")

        Note: Pop loop context
        Let dummy_pop_for be codegen_pop_loop_context(codegen)

        Return 0
    End If

    If stmt_type is equal to 12:  Note: STMT_FOR_EACH
        Set label_counter to memory_get_int32(codegen, 28)
        Set label_num to label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)

        Set loop_start_label to label_num multiplied by 10 plus 1
        Set loop_end_label to label_num multiplied by 10 plus 2

        Note: Create label strings for the new loop context system
        Set loop_start_str to codegen_arena_concat(codegen, ".L", codegen_arena_int_to_str(codegen, loop_start_label))
        Set loop_end_str to codegen_arena_concat(codegen, ".L", codegen_arena_int_to_str(codegen, loop_end_label))

        Note: Get loop components
        Set var_name to memory_get_pointer(stmt, 8)
        Let collection_expr be memory_get_pointer(stmt, 16)
        Set body to memory_get_pointer(stmt, 24)
        Set body_count to memory_get_integer(stmt, 32)

        Note: Evaluate collection expression (result in %rax)
        codegen_generate_expression(codegen, collection_expr)
        emit_line(output_file, "    pushq %rax")  Note: Save collection pointer on stack

        Note: Get collection length by calling list_length
        emit_line(output_file, "    movq %rax, %rdi")
        emit_line(output_file, "    call list_length")
        emit_line(output_file, "    pushq %rax")  Note: Save length on stack

        Note: Initialize loop counter to 0
        emit_line(output_file, "    movq $0, %rax")
        emit_line(output_file, "    pushq %rax")  Note: Save counter on stack

        Note: Allocate loop variable on stack for the item value
        codegen_add_variable(codegen, var_name)
        Set var_index to codegen_find_variable(codegen, var_name)
        Set variables to memory_get_pointer(codegen, 8)
        Set var_offset to memory_get_int32(variables, var_index multiplied by 32 plus 8)

        Note: Push loop context for break/continue statements (no label name for unlabeled loop)
        Let dummy_push_foreach be codegen_push_loop_context(codegen, 0, loop_end_str, loop_start_str)

        Note: Loop start label
        Set loop_start_label_line to codegen_arena_concat(codegen, loop_start_str, ":")
        emit_line(output_file, loop_start_label_line)

        Note: Compare counter with length
        emit_line(output_file, "    movq (%rsp), %rax")       Note: Load counter
        emit_line(output_file, "    movq 8(%rsp), %rcx")      Note: Load length
        emit_line(output_file, "    cmpq %rcx, %rax")
        Let jge_instruction be codegen_arena_concat(codegen, "    jge ", loop_end_str)
        emit_line(output_file, jge_instruction)

        Note: Get item at current index: list_get(collection, counter)
        emit_line(output_file, "    movq 16(%rsp), %rdi")     Note: Load collection pointer
        emit_line(output_file, "    movq (%rsp), %rsi")       Note: Load counter as index
        emit_line(output_file, "    call list_get")

        Note: Store item in loop variable
        file_write_buffered(output_file, "    movq %rax, -", 0)
        file_write_buffered(output_file, integer_to_string(var_offset), 0)
        file_write_buffered(output_file, "(%rbp)\n", 0)

        Note: Generate loop body
        Set i to 0
        While i is less than body_count:
            Set body_stmt to memory_get_pointer(body, i multiplied by 8)
            codegen_generate_statement(codegen, body_stmt)
            Set i to i plus 1
        End While

        Note: Increment counter
        emit_line(output_file, "    movq (%rsp), %rax")
        emit_line(output_file, "    addq $1, %rax")
        emit_line(output_file, "    movq %rax, (%rsp)")

        Note: Jump back to loop start
        Set jmp_instruction to codegen_arena_concat(codegen, "    jmp ", loop_start_str)
        emit_line(output_file, jmp_instruction)

        Note: Loop end label
        Set loop_end_label_line to codegen_arena_concat(codegen, loop_end_str, ":")
        emit_line(output_file, loop_end_label_line)

        Note: Clean up stack (counter, length, collection)
        emit_line(output_file, "    addq $24, %rsp")

        Note: Pop loop context
        Let dummy_pop_foreach be codegen_pop_loop_context(codegen)

        Return 0
    End If

    If stmt_type is equal to 3:  Note: STMT_RETURN
        Note: Generate expression (result in %rax)
        Let return_expr be memory_get_pointer(stmt, 8)  Note: stmt->data.return_stmt.expression - use pointer
        codegen_generate_expression(codegen, return_expr)

        Note: Function epilogue
        file_write_buffered(output_file, "    movq %rbp, %rsp\n", 0)
        file_write_buffered(output_file, "    popq %rbp\n", 0)
        file_write_buffered(output_file, "    ret\n", 0)
        Return 0
    End If

    If stmt_type is equal to 5:  Note: STMT_IF
        Set label_counter to memory_get_int32(codegen, 28)  Note: codegen->label_counter (int)
        Set label_num to label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)  Note: codegen->label_counter++ (int)

        Let else_label be label_num multiplied by 10 plus 1
        Let end_label be label_num multiplied by 10 plus 2

        Note: Generate condition (result in %rax)
        Let condition_expr be memory_get_pointer(stmt, 8)  Note: stmt->data.if_stmt.condition - use pointer
        codegen_generate_expression(codegen, condition_expr)

        Note: Test if condition is false (0)
        emit_line(output_file, "    testq %rax, %rax")
        Let jz_instruction be codegen_arena_concat(codegen, "    jz .L", codegen_arena_int_to_str(codegen, else_label))
        emit_line(output_file, jz_instruction)

        Note: Generate if body
        Let if_body be memory_get_pointer(stmt, 16)  Note: stmt->data.if_stmt.if_body
        Let if_body_count be memory_get_int32(stmt, 24)  Note: stmt->data.if_stmt.if_body_count
        Let ifbody_i be 0
        While ifbody_i is less than if_body_count:
            Let ifbody_stmt be memory_get_pointer(if_body, ifbody_i multiplied by 8)
            codegen_generate_statement(codegen, ifbody_stmt)
            Set ifbody_i to ifbody_i plus 1
        End While

        file_write_buffered(output_file, "    jmp .L", 0)
        file_write_buffered(output_file, integer_to_string(end_label), 0)
        file_write_buffered(output_file, "\n", 0)

        Note: Generate else body
        Let else_label_str be codegen_arena_concat(codegen, ".L", codegen_arena_int_to_str(codegen, else_label))
        Let else_label_line be codegen_arena_concat(codegen, else_label_str, ":")
        emit_line(output_file, else_label_line)

        Let else_body be memory_get_pointer(stmt, 32)  Note: stmt->data.if_stmt.else_body
        Let else_body_count be memory_get_int32(stmt, 40)  Note: stmt->data.if_stmt.else_body_count
        Let elsebody_i be 0
        While elsebody_i is less than else_body_count:
            Let elsebody_stmt be memory_get_pointer(else_body, elsebody_i multiplied by 8)
            codegen_generate_statement(codegen, elsebody_stmt)
            Set elsebody_i to elsebody_i plus 1
        End While

        Let end_label_str be codegen_arena_concat(codegen, ".L", codegen_arena_int_to_str(codegen, end_label))
        Let end_label_line be codegen_arena_concat(codegen, end_label_str, ":")
        emit_line(output_file, end_label_line)
        Return 0
    End If

    If stmt_type is equal to 6:  Note: STMT_WHILE
        Set label_counter to memory_get_int32(codegen, 28)  Note: codegen->label_counter (int)
        Note: Try to use it without printing to see if it works
        If label_counter is greater than 1000000:
        End If
        Set label_num to label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)  Note: codegen->label_counter++ (int)

        Let loop_start be label_num multiplied by 10 plus 1
        Let loop_end be label_num multiplied by 10 plus 2

        Note: Create label strings for the new loop context system
        Set loop_start_str to codegen_arena_concat(codegen, ".L", codegen_arena_int_to_str(codegen, loop_start))
        Set loop_end_str to codegen_arena_concat(codegen, ".L", codegen_arena_int_to_str(codegen, loop_end))

        Note: Push loop context for break/continue statements (no label name for unlabeled loop)
        Let dummy_push be codegen_push_loop_context(codegen, 0, loop_end_str, loop_start_str)

        Note: Loop start label
        file_write_buffered(output_file, loop_start_str, 0)
        file_write_buffered(output_file, ":", 0)

        Note: Generate condition (result in %rax)
        Set condition_expr to memory_get_pointer(stmt, 8)  Note: stmt->data.while_stmt.condition
        codegen_generate_expression(codegen, condition_expr)

        Note: Test if condition is false (0)
        emit_line(output_file, "    testq %rax, %rax")
        Set jz_instruction to codegen_arena_concat(codegen, "    jz ", loop_end_str)
        emit_line(output_file, jz_instruction)

        Note: Generate loop body
        Let whilebody be memory_get_pointer(stmt, 16)  Note: stmt->data.while_stmt.body
        Let whilebody_count be memory_get_int32(stmt, 24)  Note: stmt->data.while_stmt.body_count
        Let whilebody_i be 0
        While whilebody_i is less than whilebody_count:
            Let whilebody_stmt be memory_get_pointer(whilebody, whilebody_i multiplied by 8)
            codegen_generate_statement(codegen, whilebody_stmt)
            Set whilebody_i to whilebody_i plus 1
        End While

        Note: Jump back to loop start
        Set jmp_instruction to codegen_arena_concat(codegen, "    jmp ", loop_start_str)
        emit_line(output_file, jmp_instruction)

        Note: Loop end label
        Let loop_end_line be codegen_arena_concat(codegen, loop_end_str, ":")
        emit_line(output_file, loop_end_line)

        Note: Pop loop context
        Let dummy_pop be codegen_pop_loop_context(codegen)
        Return 0
    End If

    If stmt_type is equal to 9:  Note: STMT_BREAK
        Let dummy_break be codegen_generate_break(codegen, stmt)
        Return 0
    End If

    If stmt_type is equal to 10:  Note: STMT_CONTINUE
        Let dummy_continue be codegen_generate_continue(codegen, stmt)
        Return 0
    End If

    If stmt_type is equal to 14:  Note: STMT_LOOP
        Let dummy_loop be codegen_generate_loop(codegen, stmt)
        Return 0
    End If

    Note: Inline assembly: emit raw assembly text
    If stmt_type is equal to 16:  Note: STMT_INLINE_ASSEMBLY
        Note: Get raw assembly text (single string, not array)
        Let raw_text be memory_get_pointer(stmt, 8)
        Let text_length be memory_get_int32(stmt, 16)

        Note: Write raw text directly to output, character by character
        Note: Add 4-space indentation to each line for proper assembly formatting
        Let char_idx be 0
        Let at_line_start be 1  Note: Track if we're at the start of a line

        While char_idx is less than text_length:
            Let current_char be string_char_at(raw_text, char_idx)
            Let newline be 10  Note: ASCII for '\n'

            Note: Add indentation at start of each line
            If at_line_start is equal to 1:
                Note: Check if line is not empty (not just newline)
                If current_char is not equal to newline:
                    file_write_buffered(output_file, "    ", 0)
                End If
                Set at_line_start to 0
            End If

            Note: Write character
            Let char_str_len be 2
            Let char_str be memory_allocate(char_str_len)
            memory_set_byte(char_str, 0, current_char)
            memory_set_byte(char_str, 1, 0)  Note: null terminator
            file_write_buffered(output_file, char_str, 0)
            deallocate(char_str)

            Note: Track newlines for indentation
            If current_char is equal to newline:
                Set at_line_start to 1
            End If

            Set char_idx to char_idx plus 1
        End While

        Note: Ensure we end with a newline
        If at_line_start is equal to 0:
            file_write_buffered(output_file, "\n", 0)
        End If

        Return 0
    End If

    If stmt_type is equal to 4:  Note: STMT_PRINT
        Note: Generate expression (result in %rax)
        Let print_expr be memory_get_pointer(stmt, 8)  Note: stmt->data.print_stmt.expression
        codegen_generate_expression(codegen, print_expr)

        Note: Call appropriate print function based on expression type
        Set expr_type to memory_get_int32(print_expr, 0)  Note: expr->type
        If expr_type is equal to 5:  Note: EXPR_STRING_LITERAL
            Note: String literal - call print_string
            file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
            file_write_buffered(output_file, "    call print_string\n", 0)
        Otherwise:
            If expr_type is equal to 8:  Note: EXPR_BUILTIN_CALL
                Set builtin_call_ptr to print_expr plus 8  Note: &expr->data.builtin_call
                Set builtin_type to memory_get_int32(builtin_call_ptr, 0)  Note: builtin_call.builtin_type
                Note: Check for string-returning builtins (read_file, string_substring, string_concat, integer_to_string, string_replace, string_trim)
                Set is_string_builtin to 0
                If builtin_type is equal to 37:
                    Set is_string_builtin to 1
                Otherwise If builtin_type is equal to 42:
                    Set is_string_builtin to 1
                Otherwise If builtin_type is equal to 48:
                    Set is_string_builtin to 1
                Otherwise If builtin_type is equal to 49:
                    Set is_string_builtin to 1
                Otherwise If builtin_type is equal to 52:
                    Set is_string_builtin to 1
                Otherwise If builtin_type is equal to 54:
                    Set is_string_builtin to 1
                End If
                If is_string_builtin is equal to 1:
                    Note: These functions return strings - call print_string
                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                    file_write_buffered(output_file, "    call print_string\n", 0)
                Otherwise:
                    Note: Integer expression - call print_integer
                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                    file_write_buffered(output_file, "    call print_integer\n", 0)
                End If
            Otherwise:
                If expr_type is equal to 4:  Note: EXPR_FUNCTION_CALL
                    Note: Check if function returns a string
                    Let function_call_ptr be print_expr plus 8  Note: &expr->data.function_call
                    Let function_name be memory_get_pointer(function_call_ptr, 0)  Note: function_call.function_name

                    Note: List of string-returning functions
                    Let is_string_function be 0
                    If string_equals(function_name, "string_concat") is equal to 1:
                        Set is_string_function to 1
                    Otherwise If string_equals(function_name, "string_duplicate") is equal to 1:
                        Set is_string_function to 1
                    Otherwise If string_equals(function_name, "string_substring") is equal to 1:
                        Set is_string_function to 1
                    Otherwise If string_equals(function_name, "integer_to_string") is equal to 1:
                        Set is_string_function to 1
                    Otherwise If string_equals(function_name, "string_replace") is equal to 1:
                        Set is_string_function to 1
                    Otherwise If string_equals(function_name, "string_trim") is equal to 1:
                        Set is_string_function to 1
                    Otherwise If string_equals(function_name, "read_file") is equal to 1:
                        Set is_string_function to 1
                    Otherwise If string_equals(function_name, "char_to_string") is equal to 1:
                        Set is_string_function to 1
                    End If

                    If is_string_function is equal to 1:
                        Note: Function returns string - call print_string
                        file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                        file_write_buffered(output_file, "    call print_string\n", 0)
                    Otherwise:
                        Note: Function returns integer - call print_integer
                        file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                        file_write_buffered(output_file, "    call print_integer\n", 0)
                    End If
                Otherwise If expr_type is equal to 1:  Note: EXPR_VARIABLE
                    Note: Check variable type to determine appropriate print function
                    Set variable_name to memory_get_pointer(print_expr, 8)  Note: expr->data.variable_name
                    Set var_index to codegen_find_variable(codegen, variable_name)
                    If var_index is greater than or equal to 0:
                        Set variables to memory_get_pointer(codegen, 8)  Note: codegen->variables
                        Set type_name to memory_get_pointer(variables, var_index multiplied by 32 plus 16)  Note: variables[var_index].type_name
                        If type_name is not equal to 0:
                            If string_equals(type_name, "String") is equal to 1:
                                Note: This variable contains a string - call print_string
                                file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                                file_write_buffered(output_file, "    call print_string\n", 0)
                            Otherwise:
                                If string_equals(type_name, "List") is equal to 1:
                                    Note: This variable contains a list pointer - print as integer address
                                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                                    file_write_buffered(output_file, "    call print_integer\n", 0)
                                Otherwise:
                                    Note: Assume integer for other variables
                                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                                    file_write_buffered(output_file, "    call print_integer\n", 0)
                                End If
                            End If
                        Otherwise:
                            Note: Assume integer for untyped variables
                            file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                            file_write_buffered(output_file, "    call print_integer\n", 0)
                        End If
                    Otherwise:
                        Note: Variable not found, assume integer
                        file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                        file_write_buffered(output_file, "    call print_integer\n", 0)
                    End If
                Otherwise:
                    Note: Integer expression (literal, arithmetic) - call print_integer
                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                    file_write_buffered(output_file, "    call print_integer\n", 0)
                End If
            End If
        End If
        Return 0
    End If

    If stmt_type is equal to 7:  Note: STMT_EXPRESSION
        Note: Generate the expression and ignore its result
        Let expr_stmt_expr be memory_get_pointer(stmt, 8)  Note: stmt->data.expr_stmt.expression
        codegen_generate_expression(codegen, expr_stmt_expr)
        Return 0
    End If

    If stmt_type is equal to 13:  Note: STMT_IMPORT
        Note: Imports are handled at program level, no code generation needed
        Return 0
    End If

    If stmt_type is equal to 8:  Note: STMT_MATCH
        Note: Generate code for Match statement with literal patterns
        Note: Evaluate match expression once and store in temp
        Let match_expr be memory_get_pointer(stmt, 8)  Note: STMT_MATCH_EXPR
        codegen_generate_expression(codegen, match_expr)
        file_write_buffered(output_file, "    pushq %rax  # Save match value\n", 0)

        Note: Get unique label for end of match
        Set label_counter to memory_get_int32(codegen, 28)
        Let match_id be label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)

        Note: Get when clauses
        Let when_clauses be memory_get_pointer(stmt, 16)  Note: STMT_MATCH_WHEN_CLAUSES
        Let when_count be memory_get_int32(stmt, 24)  Note: STMT_MATCH_WHEN_COUNT

        Note: Generate if-else chain for each When clause
        Set i to 0
        While i is less than when_count:
            Note: Get when clause data (48 bytes per clause)
            Let clause_offset be i multiplied by 48
            Let clause_ptr be when_clauses plus clause_offset
            Let pattern_type be memory_get_int32(clause_ptr, 0)
            Let pattern_value be memory_get_pointer(clause_ptr, 8)
            Let field_bindings be memory_get_pointer(clause_ptr, 16)
            Let field_count be memory_get_int32(clause_ptr, 24)
            Let body_stmts be memory_get_pointer(clause_ptr, 32)
            Set body_count to memory_get_integer(clause_ptr, 40)

            Note: Generate label for this case
            file_write_buffered(output_file, ".match_", 0)
            file_write_buffered(output_file, integer_to_string(match_id), 0)
            file_write_buffered(output_file, "_case_", 0)
            file_write_buffered(output_file, integer_to_string(i), 0)
            file_write_buffered(output_file, ":\n", 0)

            Note: Handle pattern based on type
            If pattern_type is equal to 2:  Note: PATTERN_WILDCARD
                Note: Wildcard always matches - no comparison needed
                Note: Just fall through to execute the body
            Otherwise If pattern_type is equal to 3:  Note: PATTERN_TYPE
                Note: Type pattern - check if value matches the specified type
                Note: pattern_value contains the type name string
                Let type_name_to_check be pattern_value

                Note: Pop match value for type checking
                file_write_buffered(output_file, "    popq %rax  # Get match value\n", 0)
                file_write_buffered(output_file, "    pushq %rax  # Keep for next comparison\n", 0)

                Note: Check if type is a primitive (Integer, Byte, etc.)
                If string_equals(type_name_to_check, "Integer") is equal to 1:
                    Note: For Integer type: check if value is small (not a pointer)
                    Note: Assume pointers are > 0x1000, integers are small values
                    file_write_buffered(output_file, "    movq $4096, %rbx  # Pointer threshold\n", 0)
                    file_write_buffered(output_file, "    cmpq %rbx, %rax  # Compare value with threshold\n", 0)
                    Note: If value >= threshold, it's a pointer (not Integer) - jump to next case
                    Let next_case be i plus 1
                    If next_case is less than when_count:
                        file_write_buffered(output_file, "    jge .match_", 0)
                        file_write_buffered(output_file, integer_to_string(match_id), 0)
                        file_write_buffered(output_file, "_case_", 0)
                        file_write_buffered(output_file, integer_to_string(next_case), 0)
                        file_write_buffered(output_file, "  # Not Integer, try next case\n", 0)
                    Otherwise:
                        file_write_buffered(output_file, "    jge .match_", 0)
                        file_write_buffered(output_file, integer_to_string(match_id), 0)
                        file_write_buffered(output_file, "_end  # Not Integer, no match\n", 0)
                    End If
                Otherwise:
                    Note: For named types (variants/structs): check if it's a valid pointer
                    Note: This is a simplified check - just verify it's a pointer-like value
                    file_write_buffered(output_file, "    movq $4096, %rbx  # Pointer threshold\n", 0)
                    file_write_buffered(output_file, "    cmpq %rbx, %rax  # Check if pointer-like\n", 0)
                    Note: If value < threshold, it's not a pointer (not this type) - jump to next case
                    Set next_case to i plus 1
                    If next_case is less than when_count:
                        file_write_buffered(output_file, "    jl .match_", 0)
                        file_write_buffered(output_file, integer_to_string(match_id), 0)
                        file_write_buffered(output_file, "_case_", 0)
                        file_write_buffered(output_file, integer_to_string(next_case), 0)
                        file_write_buffered(output_file, "  # Not pointer type, try next case\n", 0)
                    Otherwise:
                        file_write_buffered(output_file, "    jl .match_", 0)
                        file_write_buffered(output_file, integer_to_string(match_id), 0)
                        file_write_buffered(output_file, "_end  # Not pointer type, no match\n", 0)
                    End If
                End If
            Otherwise If pattern_type is equal to 0:  Note: PATTERN_LITERAL
                Note: Pop match value and compare with pattern
                file_write_buffered(output_file, "    popq %rax  # Get match value\n", 0)
                file_write_buffered(output_file, "    pushq %rax  # Keep for next comparison\n", 0)

                Note: Generate pattern expression
                codegen_generate_expression(codegen, pattern_value)

                Note: Compare: match value in stack, pattern value in %rax
                file_write_buffered(output_file, "    movq %rax, %rbx  # Pattern value to %rbx\n", 0)
                file_write_buffered(output_file, "    movq (%rsp), %rax  # Match value to %rax\n", 0)
                file_write_buffered(output_file, "    cmpq %rbx, %rax  # Compare\n", 0)
            Otherwise:  Note: PATTERN_VARIANT
                Note: Variant pattern matching
                Note: pattern_value is the variant name string
                Note: field_bindings is array of binding variable names
                Note: field_count is number of fields to extract

                Note: Get variant tag for this pattern
                Let variant_name be pattern_value
                Let variant_tag_to_match be 0
                Let variant_field_count be 0

                Note: Look up variant in program's type definitions
                Set current_program to memory_get_pointer(codegen, 48)
                Set type_count to memory_get_int32(current_program, 24)
                Set types to memory_get_pointer(current_program, 16)

                Let found_variant be 0
                Let vi be 0
                While vi is less than type_count:
                    Let type_ptr be memory_get_pointer_at_index(types, vi)
                    Set type_kind to memory_get_int32(type_ptr, 8)

                    Note: Check if this is a variant type (TYPE_KIND_VARIANT = 1)
                    If type_kind is equal to 1:
                        Let variant_count be memory_get_int32(type_ptr, 24)
                        Let variants be memory_get_pointer(type_ptr, 16)

                        Note: Loop through all variants to find match
                        Let vj be 0
                        While vj is less than variant_count:
                            Let variant_offset be vj multiplied by 32
                            Let variant_ptr be variants plus variant_offset
                            Let vname be memory_get_pointer(variant_ptr, 0)

                            If string_equals(vname, variant_name) is equal to 1:
                                Set variant_tag_to_match to memory_get_int32(variant_ptr, 20)
                                Set variant_field_count to memory_get_int32(variant_ptr, 16)
                                Set found_variant to 1
                                Set vi to type_count  Note: Break outer loop
                                Set vj to variant_count  Note: Break inner loop
                            Otherwise:
                                Set vj to vj plus 1
                            End If
                        End While
                    End If
                    Set vi to vi plus 1
                End While

                Note: Generate tag comparison
                file_write_buffered(output_file, "    movq (%rsp), %rax  # Get match value pointer\n", 0)
                file_write_buffered(output_file, "    movl (%rax), %ebx  # Load variant tag\n", 0)
                file_write_buffered(output_file, "    cmpl $", 0)
                file_write_buffered(output_file, integer_to_string(variant_tag_to_match), 0)
                file_write_buffered(output_file, ", %ebx  # Compare with expected tag\n", 0)
            End If

            Note: Jump to next case if not equal (unless wildcard or type pattern)
            If pattern_type is not equal to 2:  Note: Not wildcard
                If pattern_type is not equal to 3:  Note: Not type pattern - generate conditional jump
                    Set next_case to i plus 1
                    If next_case is less than when_count:
                        file_write_buffered(output_file, "    jne .match_", 0)
                        file_write_buffered(output_file, integer_to_string(match_id), 0)
                        file_write_buffered(output_file, "_case_", 0)
                        file_write_buffered(output_file, integer_to_string(next_case), 0)
                        file_write_buffered(output_file, "  # Try next case\n", 0)
                    Otherwise:
                        file_write_buffered(output_file, "    jne .match_", 0)
                        file_write_buffered(output_file, integer_to_string(match_id), 0)
                        file_write_buffered(output_file, "_end  # No match\n", 0)
                    End If
                End If
            End If

            Note: Generate body if matched
            Note: Handle field extraction for variant patterns
            If pattern_type is equal to 0:  Note: PATTERN_LITERAL
                file_write_buffered(output_file, "    popq %rax  # Matched, clean up stack\n", 0)
            Otherwise If pattern_type is equal to 2:  Note: PATTERN_WILDCARD
                file_write_buffered(output_file, "    popq %rax  # Matched, clean up stack\n", 0)
            Otherwise If pattern_type is equal to 3:  Note: PATTERN_TYPE
                file_write_buffered(output_file, "    popq %rax  # Matched, clean up stack\n", 0)
            Otherwise:  Note: PATTERN_VARIANT
                Note: Extract fields and bind to variables
                file_write_buffered(output_file, "    popq %rax  # Get match value pointer\n", 0)

                Note: Extract each field
                Let fk be 0
                While fk is less than field_count:
                    Note: Get field binding name
                    Let binding_name be memory_get_pointer(field_bindings, fk multiplied by 8)

                    Note: Add variable for this binding
                    codegen_add_variable(codegen, binding_name)

                    Note: Find the variable to get its stack offset
                    Set var_index to codegen_find_variable(codegen, binding_name)
                    Set variables to memory_get_pointer(codegen, 8)
                    Set var_offset to memory_get_int32(variables, var_index multiplied by 32 plus 8)

                    Note: Load field from variant at offset 8 + (fk * 8)
                    Let field_offset be 8 plus fk multiplied by 8
                    file_write_buffered(output_file, "    movq ", 0)
                    file_write_buffered(output_file, integer_to_string(field_offset), 0)
                    file_write_buffered(output_file, "(%rax), %rbx  # Load field ", 0)
                    file_write_buffered(output_file, integer_to_string(fk), 0)
                    file_write_buffered(output_file, "\n", 0)

                    Note: Store field in local variable
                    file_write_buffered(output_file, "    movq %rbx, -", 0)
                    file_write_buffered(output_file, integer_to_string(var_offset), 0)
                    file_write_buffered(output_file, "(%rbp)  # Store in binding ", 0)
                    file_write_buffered(output_file, binding_name, 0)
                    file_write_buffered(output_file, "\n", 0)

                    Set fk to fk plus 1
                End While
            End If

            Note: Generate body statements
            Let j be 0
            While j is less than body_count:
                Let stmt_offset be j multiplied by 8
                Set body_stmt to memory_get_pointer(body_stmts, stmt_offset)
                codegen_generate_statement(codegen, body_stmt)
                Set j to j plus 1
            End While

            Note: Jump to end after body
            file_write_buffered(output_file, "    jmp .match_", 0)
            file_write_buffered(output_file, integer_to_string(match_id), 0)
            file_write_buffered(output_file, "_end\n", 0)

            Set i to i plus 1
        End While

        Note: End label
        file_write_buffered(output_file, ".match_", 0)
        file_write_buffered(output_file, integer_to_string(match_id), 0)
        file_write_buffered(output_file, "_end:\n", 0)
        file_write_buffered(output_file, "    addq $8, %rsp  # Clean up match value if still on stack\n", 0)

        Return 0
    End If

    If stmt_type is equal to 7:  Note: OLD_STMT_MATCH (unused)
        Note: Evaluate the expression to match on
        Set match_expr to memory_get_pointer(stmt, 8)  Note: stmt->data.match_stmt.expression
        codegen_generate_expression(codegen, match_expr)
        file_write_buffered(output_file, "    pushq %rax  # Save match expression value", 0)

        Note: Generate unique labels for each case and the end
        Set label_counter to memory_get_int32(codegen, 28)  Note: codegen->label_counter (int)
        Set match_id to label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)  Note: codegen->label_counter++ (int)

        Set end_label to codegen_arena_concat(codegen, ".match_end_", codegen_arena_int_to_str(codegen, match_id))

        Note: Generate code for each case
        Let case_count be memory_get_int32(stmt, 16)  Note: stmt->data.match_stmt.case_count
        Let cases be memory_get_pointer(stmt, 24)  Note: stmt->data.match_stmt.cases

        Set i to 0
        While i is less than case_count:
            Let case_offset be i multiplied by 64
            Let match_case be cases plus case_offset  Note: sizeof(MatchCase) estimate
            Set variant_name to memory_get_pointer(match_case, 0)  Note: match_case->variant_name
            Set field_count to memory_get_int32(match_case, 8)  Note: match_case->field_count
            Let field_names be memory_get_pointer(match_case, 16)  Note: match_case->field_names
            Set body_count to memory_get_int32(match_case, 24)  Note: match_case->body_count
            Set body to memory_get_pointer(match_case, 32)  Note: match_case->body

            Let next_case_id be i plus 1

            Note: Check if this case matches - write label directly without string_concat
            file_write_buffered(output_file, ".match_case_", 0)
            file_write_buffered(output_file, integer_to_string(match_id), 0)
            file_write_buffered(output_file, "_", 0)
            file_write_buffered(output_file, integer_to_string(i), 0)
            file_write_buffered(output_file, ":", 0)
            file_write_buffered(output_file, "    popq %rax  # Get match expression\n", 0)
            file_write_buffered(output_file, "    pushq %rax  # Keep on stack", 0)

            Note: Load the tag from the variant
            file_write_buffered(output_file, "    movq (%rax), %rdx  # Load variant tag", 0)

            Note: Find the tag value for this variant name - ADT variant tags are sequential starting from 0
            file_write_buffered(output_file, "    cmpq $", 0)
            file_write_buffered(output_file, integer_to_string(i), 0)
            file_write_buffered(output_file, ", %rdx  # Check tag for ", 0)
            file_write_buffered(output_file, variant_name, 0)
            file_write_buffered(output_file, "\n", 0)

            If i is less than case_count minus 1:
                file_write_buffered(output_file, "    jne .match_case_", 0)
                file_write_buffered(output_file, integer_to_string(match_id), 0)
                file_write_buffered(output_file, "_", 0)
                file_write_buffered(output_file, integer_to_string(next_case_id), 0)
                file_write_buffered(output_file, "  # Jump to next case", 0)
            Otherwise:
                file_write_buffered(output_file, "    jne ", 0)
                file_write_buffered(output_file, end_label, 0)
                file_write_buffered(output_file, "  # No match, exit", 0)
            End If

            Note: If we matched, extract fields and bind to local variables
            If field_count is greater than 0:
                Note: Pop the variant pointer
                file_write_buffered(output_file, "    popq %rax  # Get variant pointer\n", 0)
                file_write_buffered(output_file, "    pushq %rax  # Keep on stack", 0)

                Note: ADT fields start at offset 8 (after tag) with 8 bytes per field
                Set j to 0
                While j is less than field_count:
                    Let field_offset_value be j multiplied by 8
                    Set field_offset to 8 plus field_offset_value
                    file_write_buffered(output_file, "    movq ", 0)
                    file_write_buffered(output_file, integer_to_string(field_offset), 0)
                    file_write_buffered(output_file, "(%rax), %rdx  # Load field ", 0)
                    file_write_buffered(output_file, integer_to_string(j), 0)
                    file_write_buffered(output_file, "\n", 0)

                    Note: Create a local variable for the binding - allocate stack space properly
                    Set current_stack_offset to memory_get_int32(codegen, 24)  Note: codegen->stack_offset
                    Let new_stack_offset be current_stack_offset plus 8
                    memory_set_integer(codegen, 16, new_stack_offset)

                    file_write_buffered(output_file, "    movq %rdx, -", 0)
                    file_write_buffered(output_file, integer_to_string(new_stack_offset), 0)
                    Let field_name be memory_get_pointer(field_names, j multiplied by 8)
                    file_write_buffered(output_file, "(%rbp, 0)  # Store ", 0)
                    file_write_buffered(output_file, field_name, 0)
                    file_write_buffered(output_file, " at stack offset", 0)

                    Note: Add the binding to the variable table with correct offset
                    Let variable_count be memory_get_int32(codegen, 16)  Note: codegen->variable_count (int)
                    Let variable_capacity be memory_get_int32(codegen, 24)  Note: codegen->variable_capacity
                    If variable_count is greater than or equal to variable_capacity:
                        Let new_capacity be variable_capacity multiplied by 2
                        memory_set_integer(codegen, 24, new_capacity)
                        Set variables to memory_get_pointer(codegen, 8)  Note: codegen->variables
                        Let new_variables be reallocate(variables, new_capacity multiplied by 32)  Note: sizeof(Variable) = 32
                        memory_set_pointer(codegen, 8, new_variables)
                    End If

                    Set variables to memory_get_pointer(codegen, 8)  Note: codegen->variables
                    Let var_idx_offset be variable_count multiplied by 32  Note: sizeof(Variable) = 32
                    memory_set_pointer(variables, var_idx_offset, string_duplicate(field_name))  Note: name
                    memory_set_integer(variables, var_idx_offset plus 8, new_stack_offset)  Note: stack_offset
                    memory_set_pointer(variables, var_idx_offset plus 16, string_duplicate("Integer"))  Note: type_name
                    memory_set_int32(codegen, 12, variable_count plus 1)  Note: Increment variable_count

                    Set j to j plus 1
                End While
            End If

            Note: Generate the case body
            Let k be 0
            While k is less than body_count:
                Let current_stmt be memory_get_pointer(body, k multiplied by 8)
                codegen_generate_statement(codegen, current_stmt)
                Set k to k plus 1
            End While

            Note: Clean up bindings from variable table but keep stack offset
            If field_count is greater than 0:
                Note: Free the variable names we allocated
                Set j to 0
                While j is less than field_count:
                    Set variable_count to memory_get_int32(codegen, 16)  Note: codegen->variable_count (int)
                    Let var_idx be variable_count minus field_count plus j
                    Set variables to memory_get_pointer(codegen, 8)  Note: codegen->variables
                    Set var_name to memory_get_integer(variables, var_idx multiplied by 24)
                    Let var_type_name be memory_get_integer(variables, var_idx multiplied by 24 plus 16)
                    deallocate(var_name)
                    deallocate(var_type_name)
                    Set j to j plus 1
                End While
                Note: Remove from variable table
                Set variable_count to memory_get_int32(codegen, 16)  Note: codegen->variable_count (int)
                memory_set_integer(codegen, 12, variable_count minus field_count)
            End If

            Note: Jump to end
            file_write_buffered(output_file, "    jmp ", 0)
            file_write_buffered(output_file, end_label, 0)
            file_write_buffered(output_file, "\n", 0)

            Set i to i plus 1
        End While

        file_write_buffered(output_file, end_label, 0)
        file_write_buffered(output_file, ":", 0)
        file_write_buffered(output_file, "    popq %rax  # Clean up match expression\n", 0)
        Return 0
    End If

    Return 0
End Process

Note: Create a new code generator - equivalent to codegen_create
Note: Codegen structure (96 bytes):
Note:   offset 0: output_file
Note:   offset 8: variables
Note:   offset 16: variable_count
Note:   offset 20: variable_capacity
Note:   offset 24: stack_offset
Note:   offset 28: label_counter
Note:   offset 32: strings
Note:   offset 40: string_count
Note:   offset 44: string_capacity
Note:   offset 48: current_program
Note:   offset 56: loop_stack
Note:   offset 64: loop_depth
Note:   offset 68: loop_capacity
Note:   offset 72: var_hashtable
Note:   offset 80: call_graph
Note:   offset 88: arena (pointer) - for temporary allocations

Process called "codegen_create" takes output_filename as Integer, arena as Integer returns Integer:
    Let codegen be allocate(96)  Note: sizeof(CodeGenerator) - expanded for arena at offset 88

    Note: Note: allocate() uses calloc() which already zeros the memory,
    Note: so no explicit initialization loop is needed

    Let output_file be file_open_buffered(output_filename, 1)  Note: 1 = write mode (O_WRONLY | O_CREAT | O_TRUNC)
    If output_file is less than 0:  Note: Negative indicates error
        Note: Failed to open output file
        deallocate(codegen)
        Return 0
    End If
    memory_set_integer(codegen, 0, output_file)  Note: codegen->output_file
    memory_set_pointer(codegen, 88, arena)  Note: codegen->arena - store for temporary allocations

    Let variables be allocate(16 multiplied by 32)  Note: 16 * sizeof(Variable) - Variable is 32 bytes
    memory_set_pointer(codegen, 8, variables)  Note: codegen->variables
    memory_set_int32(codegen, 16, 0)  Note: codegen->variable_count (int)
    memory_set_int32(codegen, 20, 16)  Note: codegen->variable_capacity (int) - Start with space for 16 variables


    memory_set_int32(codegen, 24, 0)  Note: codegen->stack_offset (int)
    memory_set_int32(codegen, 28, 0)  Note: codegen->label_counter (int)
    memory_set_int32(codegen, 40, 0)  Note: codegen->string_count (int)
    memory_set_int32(codegen, 44, 512)  Note: codegen->string_capacity (int) - Start with space for 512 strings

    Let strings be allocate(512 multiplied by 16)  Note: 512 * sizeof(StringLiteral)
    memory_set_pointer(codegen, 32, strings)  Note: codegen->strings (pointer with padding)
    memory_set_pointer(codegen, 48, 0)  Note: codegen->current_program (pointer with padding)
    memory_set_int32(codegen, 64, 0)  Note: codegen->loop_depth (int)
    memory_set_int32(codegen, 68, 8)  Note: codegen->loop_capacity (int) - Start with space for 8 nested loops

    Let loop_stack be allocate(8 multiplied by 16)  Note: 8 * sizeof(LoopContext)
    memory_set_pointer(codegen, 56, loop_stack)  Note: codegen->loop_stack (pointer)

    Note: Hash table will be created on first use (function pointers not available yet)
    memory_set_pointer(codegen, 72, 0)  Note: codegen->var_hashtable (initially NULL)

    If output_file is equal to 0:
        deallocate(variables)
        deallocate(strings)
        deallocate(loop_stack)
        deallocate(codegen)
        Return 0
    End If

    Return codegen
End Process

Note: Destroy a code generator - equivalent to codegen_destroy
Process called "codegen_destroy" takes codegen as Integer returns Integer:
    If codegen is not equal to 0:
        Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file
        If output_file is not equal to 0:
            file_close_fd(output_file)
        End If

        Note: Free variable names and type names
        Note: Read 32-bit variable_count correctly
        Let byte0 be memory_get_byte(codegen, 16)
        Let byte1 be memory_get_byte(codegen, 17)
        Let byte2 be memory_get_byte(codegen, 18)
        Let byte3 be memory_get_byte(codegen, 19)
        Let temp1 be byte1 multiplied by 256
        Let temp2 be byte2 multiplied by 65536
        Let temp3 be byte3 multiplied by 16777216
        Let variable_count be byte0 plus temp1 plus temp2 plus temp3

        Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
        If variables is not equal to 0:
            Let i be 0
            While i is less than variable_count:
                Let var_offset be i multiplied by 32  Note: sizeof(Variable) = 32
                Let var_ptr be variables plus var_offset
                Let var_name be memory_get_pointer(var_ptr, 0)  Note: Variable.name at offset 0
                Let var_type_name be memory_get_pointer(var_ptr, 16)  Note: Variable.type_name at offset 16
                If var_name is not equal to 0:
                    deallocate(var_name)
                End If
                If var_type_name is not equal to 0:
                    deallocate(var_type_name)
                End If
                Set i to i plus 1
            End While
        End If

        Note: Free string literal values and labels
        Note: Read 32-bit string_count correctly
        Set byte0 to memory_get_byte(codegen, 40)
        Set byte1 to memory_get_byte(codegen, 41)
        Set byte2 to memory_get_byte(codegen, 42)
        Set byte3 to memory_get_byte(codegen, 43)
        Set temp1 to byte1 multiplied by 256
        Set temp2 to byte2 multiplied by 65536
        Set temp3 to byte3 multiplied by 16777216
        Let string_count be byte0 plus temp1 plus temp2 plus temp3

        Let strings be memory_get_pointer(codegen, 32)  Note: codegen->strings (pointer with padding)
        If strings is not equal to 0:
            Set i to 0
            While i is less than string_count:
                Let str_offset be i multiplied by 16  Note: sizeof(StringLiteral) = 16
                Let str_ptr be strings plus str_offset
                Let str_value be memory_get_pointer(str_ptr, 0)  Note: StringLiteral.value at offset 0
                Let str_label be memory_get_pointer(str_ptr, 8)  Note: StringLiteral.label at offset 8
                If str_value is not equal to 0:
                    deallocate(str_value)
                End If
                If str_label is not equal to 0:
                    deallocate(str_label)
                End If
                Set i to i plus 1
            End While
        End If

        If variables is not equal to 0:
            deallocate(variables)
        End If
        If strings is not equal to 0:
            deallocate(strings)
        End If
        Let loop_stack be memory_get_pointer(codegen, 56)  Note: codegen->loop_stack (pointer)
        If loop_stack is not equal to 0:
            deallocate(loop_stack)
        End If
        Note: Destroy hash table
        Let var_hashtable be memory_get_pointer(codegen, 72)
        If var_hashtable is not equal to 0:
            hashtable_destroy(var_hashtable)
        End If
        Note: Destroy call graph (at offset 80)
        Let call_graph be memory_get_pointer(codegen, 80)
        If call_graph is not equal to 0:
            callgraph_destroy(call_graph)
        End If
        deallocate(codegen)
    End If
    Return 0
End Process


Note: Generate code for a function - equivalent to codegen_generate_function
Process called "codegen_generate_function" takes codegen as Integer, func as Integer returns Integer:
    Note: Reset variable state for each function
    memory_set_int32(codegen, 16, 0)  Note: codegen->variable_count = 0
    memory_set_int32(codegen, 24, 0)  Note: codegen->stack_offset = 0
    memory_set_int32(codegen, 64, 0)  Note: codegen->loop_depth = 0 (int)

    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file
    Let func_name be memory_get_pointer(func, 0)  Note: func->name

    Note: Export function as global symbol for cross-module linking
    file_write_buffered(output_file, ".globl ", 0)
    file_write_buffered(output_file, func_name, 0)
    file_write_buffered(output_file, "\n", 0)

    Note: Function label
    file_write_buffered(output_file, func_name, 0)
    file_write_buffered(output_file, ":\n", 0)

    Note: Function prologue
    emit_line(output_file, "    pushq %rbp")
    emit_line(output_file, "    movq %rsp, %rbp")

    Note: ========================================================================
    Note: STACK SAFETY: Inject stack probe for recursive functions
    Note: ========================================================================
    Let call_graph be memory_get_pointer(codegen, 80)  Note: codegen->call_graph (offset 80, NOT 72)
    If call_graph is not equal to 0:
        Let node be callgraph_find_node(call_graph, func_name)
        If node is not equal to 0:
            Let is_recursive be memory_get_int32(node, 28)
            codegen_inject_stack_probe(output_file, func_name, is_recursive)
        End If
    End If
    Note: ========================================================================

    Note: Handle parameters (System V ABI: %rdi, %rsi, %rdx, %rcx, %r8, %r9)
    Let param_registers be allocate(6 multiplied by 8)  Note: Array of 6 string pointers
    memory_set_pointer(param_registers, 0, "%rdi")
    memory_set_pointer(param_registers, 8, "%rsi")
    memory_set_pointer(param_registers, 16, "%rdx")
    memory_set_pointer(param_registers, 24, "%rcx")
    memory_set_pointer(param_registers, 32, "%r8")
    memory_set_pointer(param_registers, 40, "%r9")
    Let max_register_params be 6

    Let parameter_count be memory_get_int32(func, 16)  Note: func->parameter_count

    Note: If this is main function with argc/argv parameters, initialize command line args
    If string_equals(func_name, "main") is equal to 1:
        If parameter_count is greater than or equal to 2:
            Note: Store original argc and argv before processing them as Runa parameters
            emit_line(output_file, "    # Initialize command line arguments")
            emit_line(output_file, "    pushq %rdi  # Save argc")
            emit_line(output_file, "    pushq %rsi  # Save argv")
            emit_line(output_file, "    call runtime_set_command_line_args@PLT")
            emit_line(output_file, "    popq %rsi   # Restore argv")
            emit_line(output_file, "    popq %rdi   # Restore argc")
        End If
    End If

    Note: CRITICAL FIX: Allocate stack space BEFORE any stack access to prevent Valgrind violations
    Note: Pre-allocate generous stack space for all function variables and temporaries
    Note: Increased from 512 to 2048 to handle parser functions with many locals
    emit_line(output_file, "    subq $2048, %rsp  # Pre-allocate generous stack space")

    Let parameters be memory_get_pointer(func, 8)  Note: func->parameters (Parameter*)
    Let i be 0
    Let should_continue be 1
    While should_continue is equal to 1:
        If i is greater than or equal to parameter_count:
            Set should_continue to 0
        End If
        If i is greater than or equal to max_register_params:
            Set should_continue to 0
        End If
        If should_continue is equal to 1:
        Note: Add parameter as a variable and store from appropriate register
        Note: Use the parameter type from the function definition
        Let param_offset be i multiplied by 16  Note: sizeof(Parameter)
        Let param_name be memory_get_pointer(parameters, param_offset)  Note: parameters[i].name
        Let param_type be memory_get_pointer(parameters, param_offset plus 8)  Note: parameters[i].type
        If param_type is equal to 0:
            Set param_type to "Integer"  Note: Default type
        End If

        Let param_index be codegen_add_variable_with_type_and_param_flag(codegen, param_name, param_type, 1)  Note: Mark as parameter
        Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
        Let var_offset be param_index multiplied by 32  Note: sizeof(Variable) = 32, not 24!
        Let var_ptr be variables plus var_offset
        Let param_stack_offset be memory_get_int32(var_ptr, 8)  Note: variables[param_index].stack_offset
        Let register_name be memory_get_pointer(param_registers, i multiplied by 8)
        file_write_buffered(output_file, "    movq ", 0)
        file_write_buffered(output_file, register_name, 0)
        file_write_buffered(output_file, ", -", 0)
        file_write_buffered(output_file, integer_to_string(param_stack_offset), 0)
        file_write_buffered(output_file, "(%rbp)\n", 0)

        Set i to i plus 1
        End If  Note: End of should_continue check
    End While

    Note: Handle parameters beyond 6 (passed on stack in System V ABI)
    Set i to max_register_params
    While i is less than parameter_count:
        Set param_offset to i multiplied by 16  Note: sizeof(Parameter)
        Set param_name to memory_get_pointer(parameters, param_offset)  Note: parameters[i].name
        Set param_type to memory_get_pointer(parameters, param_offset plus 8)  Note: parameters[i].type
        Set param_index to codegen_add_variable_with_type_and_param_flag(codegen, param_name, param_type, 1)  Note: Mark as parameter
        Set variables to memory_get_pointer(codegen, 8)  Note: codegen->variables
        Set var_offset to param_index multiplied by 32  Note: sizeof(Variable) = 32, not 24!
        Set var_ptr to variables plus var_offset
        Set param_stack_offset to memory_get_int32(var_ptr, 8)  Note: variables[param_index].stack_offset

        Note: Stack parameters are at positive offsets from rbp: 16(%rbp), 24(%rbp), etc.
        Let stack_param_index be i minus max_register_params
        Let stack_param_offset_value be stack_param_index multiplied by 8
        Let stack_param_offset be 16 plus stack_param_offset_value
        file_write_buffered(output_file, "    movq ", 0)
        file_write_buffered(output_file, integer_to_string(stack_param_offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax\n", 0)
        file_write_buffered(output_file, "    movq %rax, -", 0)
        file_write_buffered(output_file, integer_to_string(param_stack_offset), 0)
        file_write_buffered(output_file, "(%rbp)", 0)

        Set i to i plus 1
    End While

    Note: Generate function body statements
    Note: Function structure has:
    Note: offset 24: return_type (string)
    Note: offset 32: statements (Statement** array)
    Note: offset 40: statement_count (int)
    Let statement_count be memory_get_int32(func, 40)  Note: func->statement_count
    Let statements be memory_get_pointer(func, 32)     Note: func->statements

    If statements is not equal to 0:
        Let stmt_idx be 0
        While stmt_idx is less than statement_count:
            Let stmt_offset be stmt_idx multiplied by 8
            Let stmt be memory_get_pointer(statements, stmt_offset)  Note: statements[stmt_idx]
            If stmt is not equal to 0:
                codegen_generate_statement(codegen, stmt)
            End If
            Set stmt_idx to stmt_idx plus 1
        End While
    End If

    Note: Add function epilogue ONLY if function doesn't end with explicit return
    Let needs_epilogue be 1
    If statement_count is greater than 0:
        Let last_stmt_offset be statement_count minus 1
        Set last_stmt_offset to last_stmt_offset multiplied by 8
        Let last_stmt be memory_get_pointer(statements, last_stmt_offset)
        If last_stmt is not equal to 0:
            Let last_stmt_type be memory_get_int32(last_stmt, 0)
            If last_stmt_type is equal to 3:  Note: STMT_RETURN
                Set needs_epilogue to 0
            End If
        End If
    End If

    If needs_epilogue is equal to 1:
        emit_line(output_file, "    movq %rbp, %rsp")
        emit_line(output_file, "    popq %rbp")
        emit_line(output_file, "    ret")
    End If

    deallocate(param_registers)
    Return 0
End Process

Note: Main code generation entry point - equivalent to codegen_generate
Process called "codegen_generate" takes codegen as Integer, program as Integer returns Integer:

    Note: Store program reference for type lookups
    memory_set_pointer(codegen, 48, program)  Note: codegen->current_program = program (pointer with padding)

    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file

    Note: Check if program is initialized properly
    Let import_count be memory_get_int32(program, 40)  Note: PROGRAM_IMPORT_COUNT - use int32 not integer
    Note: Instead check if it's a reasonable value first
    If import_count is equal to 0:
    Otherwise:
    End If

    Note: Safety check to prevent accessing invalid memory
    If import_count is less than 0:
        Set import_count to 0
    End If
    If import_count is greater than 1000:
        Set import_count to 0
    End If

    Note: Generate import comments (for documentation)
    If import_count is greater than 0:
        file_write_buffered(output_file, "# Imports:", 0)
        Let imports be memory_get_pointer(program, 32)  Note: PROGRAM_IMPORTS - should be pointer not integer
        Let i be 0
        While i is less than import_count:
            Let import be memory_get_pointer(imports, i multiplied by 8)
            Let import_filename be memory_get_integer(import, 0)  Note: import->filename
            Let module_name be memory_get_integer(import, 8)  Note: import->module_name
            file_write_buffered(output_file, "#   Import ", 0)
            file_write_buffered(output_file, import_filename, 0)
            file_write_buffered(output_file, " as ", 0)
            file_write_buffered(output_file, module_name, 0)
            file_write_buffered(output_file, "\n", 0)
            Set i to i plus 1
        End While
        file_write_buffered(output_file, "\n", 0)
    End If

    Note: First pass: collect all string literals by analyzing the AST
    Let function_count be memory_get_int32(program, 8)   Note: PROGRAM_FUNCTION_COUNT - use int32

    Note: Safety check: if function_count is negative or too large, assume no functions
    If function_count is less than 0:
        Set function_count to 0
    End If
    If function_count is greater than 10000:  Note: Sanity check
        Set function_count to 0
    End If

    Let functions be memory_get_pointer(program, 0)        Note: PROGRAM_FUNCTIONS - use pointer

    Note: Safety check - if functions is NULL, return error
    If functions is equal to 0:
        print_string("[ERROR] codegen_generate: functions pointer is NULL")
        Return 0
    End If

    Set i to 0
    While i is less than function_count:
        Let func be memory_get_pointer(functions, i multiplied by 8)



        Note: Safety check for function pointer - skip NULL pointers
        If func is not equal to 0:
                Note: Function structure in parser.runa has:
                Note: FUNCTION_STATEMENTS at 32 (Statement** - array of statements)
                Note: FUNCTION_STATEMENT_COUNT at 40

                Let func_name be memory_get_pointer(func, 0)  Note: func->name
                Let statements_array be memory_get_pointer(func, 32)  Note: func->statements (Statement**)

                Let statement_count be memory_get_int32(func, 40)  Note: func->statement_count

                Note: Process each statement in the function

                If statements_array is not equal to 0:
                    If statement_count is greater than 0:
                        Note: Process ALL statements in the function body

                        Let stmt_idx be 0
                        While stmt_idx is less than statement_count:

                            Note: Get the statement at index stmt_idx
                            Let stmt_offset be stmt_idx multiplied by 8  Note: pointer size
                            Let body_statement be memory_get_pointer(statements_array, stmt_offset)


                            Note: Process the statement
                            Let result be 0
                            If body_statement is not equal to 0:
                                Set result to codegen_collect_strings_from_statement(codegen, body_statement)

                                Note: Check if function reported critical error
                                If result is not equal to 0:
                                    Return 0
                                End If
                            End If

                            Note: Move to next statement
                            Set stmt_idx to stmt_idx plus 1
                        End While
                End If
            End If
        End If
        Set i to i plus 1
    End While

    Note: WORKAROUND removed - string collection is now working!

    Note: OLD orphaned code for rodata generation - REMOVED (now done in codegen main function)

    Note: Generate .data section for initialized global variables
    Let global_count be memory_get_int32(program, 56)  Note: PROGRAM_GLOBAL_COUNT - use int32
    Let globals be memory_get_pointer(program, 48)       Note: PROGRAM_GLOBAL_VARS - use pointer
    Let has_initialized_globals be 0
    Set i to 0
    While i is less than global_count:
        Let global be memory_get_pointer(globals, i multiplied by 8)
        Let initial_value be memory_get_pointer(global, 16)  Note: global->initial_value
        If initial_value is not equal to 0:
            Set has_initialized_globals to 1
            Set i to global_count  Note: Break
        End If
        Set i to i plus 1
    End While

    If has_initialized_globals is equal to 1:
        emit_line(output_file, ".section .data")
        Set i to 0
        While i is less than global_count:
            Set global to memory_get_pointer(globals, i multiplied by 8)
            Let global_name be memory_get_pointer(global, 0)  Note: global->name
            Set initial_value to memory_get_pointer(global, 16)  Note: global->initial_value
            If initial_value is not equal to 0:
                file_write_buffered(output_file, ".globl ", 0)
                file_write_buffered(output_file, global_name, 0)
                file_write_buffered(output_file, "\n", 0)
                file_write_buffered(output_file, global_name, 0)
                file_write_buffered(output_file, ":", 0)

                Note: Handle global variable initialization values
                Let expr_type be memory_get_int32(initial_value, 0)  Note: initial_value->type
                If expr_type is equal to 0:  Note: EXPR_INTEGER
                    Let integer_value be memory_get_pointer(initial_value, 8)  Note: initial_value->data.integer_value
                    file_write_buffered(output_file, "    .quad ", 0)
                    file_write_buffered(output_file, integer_to_string(integer_value), 0)
                    file_write_buffered(output_file, "\n", 0)
                Otherwise:
                    Note: Non-constant expressions default to zero initialization
                    file_write_buffered(output_file, "    .quad 0  # Non-constant initializer defaults to 0", 0)
                End If
            End If
            Set i to i plus 1
        End While
        file_write_buffered(output_file, "\n", 0)
    End If

    Note: Generate .bss section for uninitialized global variables
    Let has_uninitialized_globals be 0
    Set i to 0
    While i is less than global_count:
        Set global to memory_get_pointer(globals, i multiplied by 8)
        Set initial_value to memory_get_pointer(global, 16)  Note: global->initial_value
        If initial_value is equal to 0:
            Set has_uninitialized_globals to 1
            Set i to global_count  Note: Break
        End If
        Set i to i plus 1
    End While

    If has_uninitialized_globals is equal to 1:
        emit_line(output_file, ".section .bss")
        Set i to 0
        While i is less than global_count:
            Set global to memory_get_pointer(globals, i multiplied by 8)
            Set global_name to memory_get_pointer(global, 0)  Note: global->name
            Set initial_value to memory_get_pointer(global, 16)  Note: global->initial_value
            If initial_value is equal to 0:
                file_write_buffered(output_file, ".globl ", 0)
                file_write_buffered(output_file, global_name, 0)
                file_write_buffered(output_file, "\n", 0)
                file_write_buffered(output_file, global_name, 0)
                file_write_buffered(output_file, ":", 0)
                file_write_buffered(output_file, "    .zero 8  # 8 bytes for Integer", 0)
            End If
            Set i to i plus 1
        End While
        file_write_buffered(output_file, "\n", 0)
    End If

    Note: Generate .text section
    emit_line(output_file, ".text")

    Note: Add print_string runtime function
    emit_line(output_file, "print_string:")
    emit_line(output_file, "    pushq %rbp")
    emit_line(output_file, "    movq %rsp, %rbp")
    emit_line(output_file, "")
    emit_line(output_file, "    # Calculate string length")
    emit_line(output_file, "    movq %rdi, %rsi  # Save string pointer")
    emit_line(output_file, "    movq %rdi, %rcx  # Counter for strlen")
    emit_line(output_file, "    xorq %rax, %rax  # Length accumulator")
    emit_line(output_file, ".strlen_loop:")
    emit_line(output_file, "    cmpb $0, (%rcx)")
    emit_line(output_file, "    je .strlen_done")
    emit_line(output_file, "    incq %rcx")
    emit_line(output_file, "    incq %rax")
    emit_line(output_file, "    jmp .strlen_loop")
    emit_line(output_file, ".strlen_done:")
    emit_line(output_file, "")
    emit_line(output_file, "    # Call write syscall (sys_write = 1)")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    movq %rsi, %rsi   # buf = string pointer (already in rsi)")
    emit_line(output_file, "    movq %rax, %rdx   # count = string length")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    # Print newline")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    leaq .newline(%rip), %rsi  # newline string")
    emit_line(output_file, "    movq $1, %rdx     # count = 1")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    popq %rbp")
    emit_line(output_file, "    ret")
    emit_line(output_file, "\n")

    Note: Add print_integer runtime function
    emit_line(output_file, "print_integer:")
    emit_line(output_file, "    pushq %rbp")
    emit_line(output_file, "    movq %rsp, %rbp")
    emit_line(output_file, "    subq $32, %rsp  # Space for string buffer (20 digits + null)")
    emit_line(output_file, "")
    emit_line(output_file, "    # Convert integer to string")
    emit_line(output_file, "    movq %rdi, %rax  # integer value")
    emit_line(output_file, "    leaq -32(%rbp), %rsi  # buffer pointer")
    emit_line(output_file, "    addq $19, %rsi  # point to end of buffer (for reverse building)")
    emit_line(output_file, "    movb $0, (%rsi)  # null terminator")
    emit_line(output_file, "    decq %rsi")
    emit_line(output_file, "")
    emit_line(output_file, "    # Handle zero case")
    emit_line(output_file, "    testq %rax, %rax")
    emit_line(output_file, "    jnz .convert_loop")
    emit_line(output_file, "    movb $48, (%rsi)  # '0' character")
    emit_line(output_file, "    jmp .convert_done")
    emit_line(output_file, "")
    emit_line(output_file, ".convert_loop:")
    emit_line(output_file, "    testq %rax, %rax")
    emit_line(output_file, "    jz .convert_done")
    emit_line(output_file, "    movq %rax, %rcx")
    emit_line(output_file, "    movq $10, %rbx")
    emit_line(output_file, "    xorq %rdx, %rdx")
    emit_line(output_file, "    divq %rbx  # %rax = quotient, %rdx = remainder")
    emit_line(output_file, "    addq $48, %rdx  # convert remainder to ASCII")
    emit_line(output_file, "    movb %dl, (%rsi)  # store digit")
    emit_line(output_file, "    decq %rsi")
    emit_line(output_file, "    jmp .convert_loop")
    emit_line(output_file, "")
    emit_line(output_file, ".convert_done:")
    emit_line(output_file, "    incq %rsi  # point to first character")
    emit_line(output_file, "")
    emit_line(output_file, "    # Calculate string length")
    emit_line(output_file, "    movq %rsi, %rcx  # Counter for strlen")
    emit_line(output_file, "    xorq %rax, %rax  # Length accumulator")
    emit_line(output_file, ".int_strlen_loop:")
    emit_line(output_file, "    cmpb $0, (%rcx)")
    emit_line(output_file, "    je .int_strlen_done")
    emit_line(output_file, "    incq %rcx")
    emit_line(output_file, "    incq %rax")
    emit_line(output_file, "    jmp .int_strlen_loop")
    emit_line(output_file, ".int_strlen_done:")
    emit_line(output_file, "")
    emit_line(output_file, "    # Call write syscall (sys_write = 1)")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    # %rsi already points to string")
    emit_line(output_file, "    movq %rax, %rdx   # count = string length")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    # Print newline")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    leaq .newline(%rip), %rsi  # newline string")
    emit_line(output_file, "    movq $1, %rdx     # count = 1")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    movq %rbp, %rsp")
    emit_line(output_file, "    popq %rbp")
    emit_line(output_file, "    ret")
    emit_line(output_file, "\n")
    emit_line(output_file, ".section .rodata")
    emit_line(output_file, ".newline:")
    Note: Output newline string literal using ASCII byte value
    emit_line(output_file, "    .byte 10  # newline character")

    Note: Output string literals from string table
    Let byte0 be memory_get_byte(codegen, 40)
    Let byte1 be memory_get_byte(codegen, 41)
    Let byte2 be memory_get_byte(codegen, 42)
    Let byte3 be memory_get_byte(codegen, 43)
    Let temp1 be byte1 multiplied by 256
    Let temp2 be byte2 multiplied by 65536
    Let temp3 be byte3 multiplied by 16777216
    Let string_count be byte0 plus temp1 plus temp2 plus temp3

    print_integer(string_count)

    If string_count is greater than 0:
        Let strings be memory_get_pointer(codegen, 32)
        Set i to 0
        While i is less than string_count:
            Let str_label be memory_get_pointer(strings, i multiplied by 16 plus 8)
            Let str_value be memory_get_pointer(strings, i multiplied by 16)
            file_write_buffered(output_file, str_label, 0)
            file_write_buffered(output_file, ":", 0)
            file_write_buffered(output_file, "    .string ", 0)
            Let quote_bytes be memory_allocate(2)
            memory_set_byte(quote_bytes, 0, 34)
            memory_set_byte(quote_bytes, 1, 0)
            file_write_buffered(output_file, quote_bytes, 0)
            file_write_buffered(output_file, str_value, 0)
            file_write_buffered(output_file, quote_bytes, 0)
            file_write_buffered(output_file, "\n", 0)
            deallocate(quote_bytes)
            Set i to i plus 1
        End While
    End If

    emit_line(output_file, ".text")

    Note: ========================================================================
    Note: STACK SAFETY ANALYSIS PHASE - RE-ENABLED
    Note: ========================================================================
    Note: Build call graph for recursion detection and stack safety
    Let call_graph be callgraph_create(program, codegen)
    memory_set_pointer(codegen, 80, call_graph)
    callgraph_build(call_graph)
    callgraph_detect_recursion(call_graph)
    callgraph_print_warnings(call_graph)
    Note: ========================================================================

    Note: Generate all functions
    Set i to 0
    While i is less than function_count:
        Set func to memory_get_pointer(functions, i multiplied by 8)

        Note: Safety check for function pointer - skip NULL pointers
        If func is not equal to 0:
            Set func_name to memory_get_pointer(func, 0)  Note: func->name

            Note: Make main function global
            If string_equals(func_name, "main") is equal to 1:
                emit_line(output_file, ".globl main")
            End If

            emit_line(output_file, "\n")
            codegen_generate_function(codegen, func)
        End If
        Set i to i plus 1
    End While

    Note: Generate stack overflow handler if any recursive functions exist
    If call_graph is not equal to 0:
        Let nodes be memory_get_pointer(call_graph, 0)
        Let node_count be memory_get_int32(call_graph, 8)
        Let has_recursive be 0
        Set i to 0
        While i is less than node_count:
            Let node be memory_get_pointer(nodes, i multiplied by 8)
            Let is_recursive be memory_get_int32(node, 28)
            If is_recursive is equal to 1:
                Set has_recursive to 1
                Set i to node_count  Note: Break
            End If
            Set i to i plus 1
        End While

        If has_recursive is equal to 1:
            codegen_generate_stack_overflow_handler(output_file)
        End If
    End If

    Note: Add a main function wrapper if no main function exists
    Let has_main be 0
    Set i to 0
    While i is less than function_count:
        Set func to memory_get_pointer(functions, i multiplied by 8)

        Note: Safety check for function pointer - skip NULL pointers
        If func is not equal to 0:
            Set func_name to memory_get_pointer(func, 0)  Note: func->name
            If string_equals(func_name, "main") is equal to 1:
                Set has_main to 1
                Set i to function_count  Note: Break
            End If
        End If
        Set i to i plus 1
    End While

    Note: Disable automatic main wrapper generation to allow modular compilation
    Note: Each module should define its own main() if needed
    Note: This prevents multiple main() definitions when linking modules
    Note: If has_main is equal to 0:
    Note:     Note: Wrapper generation disabled for library modules
    Note: End If

    Note: Add memory safety error handlers BEFORE .note.GNU-stack
    file_write_buffered(output_file, "\n", 0)

    Note: Null pointer dereference handler
    emit_line(output_file, ".null_pointer_error:")
    emit_line(output_file, "    # Print error message for null pointer")
    emit_line(output_file, "    leaq .null_pointer_msg(%rip), %rdi")
    emit_line(output_file, "    call print_string@PLT")
    emit_line(output_file, "    # Exit with error code")
    emit_line(output_file, "    movq $1, %rdi")
    emit_line(output_file, "    call exit_with_code@PLT")
    file_write_buffered(output_file, "\n", 0)

    emit_line(output_file, ".bounds_error_negative:")
    emit_line(output_file, "    # Print error message for negative index")
    emit_line(output_file, "    leaq .bounds_error_negative_msg(%rip), %rdi")
    emit_line(output_file, "    call print_string@PLT")
    emit_line(output_file, "    # Print the negative index value")
    emit_line(output_file, "    movq %rbx, %rdi  # Index value")
    emit_line(output_file, "    call print_integer@PLT")
    emit_line(output_file, "    # Exit with error code")
    emit_line(output_file, "    movq $1, %rdi")
    emit_line(output_file, "    call exit_with_code@PLT")
    file_write_buffered(output_file, "\n", 0)

    emit_line(output_file, ".bounds_error_overflow:")
    emit_line(output_file, "    # Save registers that will be clobbered")
    emit_line(output_file, "    pushq %rcx  # Save array size")
    emit_line(output_file, "    pushq %rbx  # Save index")
    emit_line(output_file, "    # Print error message for out-of-bounds index")
    emit_line(output_file, "    leaq .bounds_error_overflow_msg(%rip), %rdi")
    emit_line(output_file, "    call print_string@PLT")
    emit_line(output_file, "    # Print the index value")
    emit_line(output_file, "    popq %rdi  # Restore and use index")
    emit_line(output_file, "    pushq %rdi  # Save again for later")
    emit_line(output_file, "    call print_integer@PLT")
    emit_line(output_file, "    # Print size message")
    emit_line(output_file, "    leaq .bounds_error_size_msg(%rip), %rdi")
    emit_line(output_file, "    call print_string@PLT")
    emit_line(output_file, "    # Print the array size")
    emit_line(output_file, "    movq 8(%rsp), %rdi  # Get saved array size from stack")
    emit_line(output_file, "    call print_integer@PLT")
    emit_line(output_file, "    # Clean up stack")
    emit_line(output_file, "    addq $16, %rsp")
    emit_line(output_file, "    # Exit with error code")
    emit_line(output_file, "    movq $1, %rdi")
    emit_line(output_file, "    call exit_with_code@PLT")
    file_write_buffered(output_file, "\n", 0)

    Note: Add error message strings to .rodata
    emit_line(output_file, ".section .rodata")

    emit_line(output_file, ".null_pointer_msg:")
    emit_line(output_file, "    .byte 70,65,84,65,76,32,69,82,82,79,82,58,32")  Note: "FATAL ERROR: "
    emit_line(output_file, "    .byte 78,117,108,108,32,112,111,105,110,116,101,114,32")  Note: "Null pointer "
    emit_line(output_file, "    .byte 100,101,114,101,102,101,114,101,110,99,101")  Note: "dereference"
    emit_line(output_file, "    .byte 10,0")  Note: "\n"
    file_write_buffered(output_file, "\n", 0)

    emit_line(output_file, ".bounds_error_negative_msg:")
    emit_line(output_file, "    .byte 70,65,84,65,76,32,69,82,82,79,82,58,32")  Note: "FATAL ERROR: "
    emit_line(output_file, "    .byte 65,114,114,97,121,32,105,110,100,101,120,32")  Note: "Array index "
    emit_line(output_file, "    .byte 105,115,32,110,101,103,97,116,105,118,101,58,32")  Note: "is negative: "
    emit_line(output_file, "    .byte 0")
    file_write_buffered(output_file, "\n", 0)

    emit_line(output_file, ".bounds_error_overflow_msg:")
    emit_line(output_file, "    .byte 70,65,84,65,76,32,69,82,82,79,82,58,32")  Note: "FATAL ERROR: "
    emit_line(output_file, "    .byte 65,114,114,97,121,32,105,110,100,101,120,32")  Note: "Array index "
    emit_line(output_file, "    .byte 111,117,116,32,111,102,32,98,111,117,110,100,115,58,32")  Note: "out of bounds: "
    emit_line(output_file, "    .byte 0")
    file_write_buffered(output_file, "\n", 0)

    emit_line(output_file, ".bounds_error_size_msg:")
    emit_line(output_file, "    .byte 32,40,97,114,114,97,121,32,115,105,122,101,32,105,115,32")  Note: " (array size is "
    emit_line(output_file, "    .byte 41,10,0")  Note: ")\n"
    file_write_buffered(output_file, "\n", 0)

    Note: Add GNU stack note to prevent executable stack warning
    file_write_buffered(output_file, "\n", 0)
    Note: Output the GNU stack section (MUST BE LAST)
    emit_line(output_file, ".section .note.GNU-stack")

    Return 0
End Process

Note: ========================================================================
Note: STACK SAFETY & MEMORY FOUNDATION
Note: ========================================================================
Note: This section implements critical compiler safety features:
Note: 1. Call graph analysis for recursion detection
Note: 2. Stack overflow protection via stack probes
Note: 3. Tail call optimization (TCO) for tail-recursive functions
Note: 4. Stack size calculation and warnings
Note: ========================================================================

Note: Data Structures for Call Graph Analysis
Note: CallGraphNode structure (40 bytes):
Note:   offset 0:  function_name (pointer)
Note:   offset 8:  function_ptr (pointer to Function AST node)
Note:   offset 16: callees (pointer array - functions this calls)
Note:   offset 24: callee_count (int32)
Note:   offset 28: is_recursive (int32) - 1 if recursively calls itself
Note:   offset 32: callee_capacity (int32) - allocated capacity for callees array

Note: CallGraph structure (32 bytes):
Note:   offset 0:  nodes (CallGraphNode** array)
Note:   offset 8:  node_count (int32)
Note:   offset 12: node_capacity (int32)
Note:   offset 16: program (pointer to Program AST)
Note:   offset 24: codegen (pointer to CodeGen state)

Note: Create a new call graph for analysis
Process called "callgraph_create" takes program as Integer, codegen as Integer returns Integer:
    Let graph be allocate(32)

    Note: Initialize with capacity for 64 functions
    Let initial_capacity be 64
    memory_set_pointer(graph, 0, allocate(initial_capacity multiplied by 8))
    memory_set_int32(graph, 8, 0)
    memory_set_int32(graph, 12, initial_capacity)
    memory_set_pointer(graph, 16, program)
    memory_set_pointer(graph, 24, codegen)

    Return graph
End Process

Note: Destroy a call graph and free all resources
Process called "callgraph_destroy" takes graph as Integer returns Integer:
    If graph is equal to 0:
        Return 0
    End If

    Note: Get nodes array and count
    Let nodes be memory_get_pointer(graph, 0)
    Let node_count be memory_get_int32(graph, 8)

    Note: Free each node
    If nodes is not equal to 0:
        Let i be 0
        While i is less than node_count:
            Let node be memory_get_pointer(nodes, i multiplied by 8)
            If node is not equal to 0:
                Note: Free node's function name
                Let func_name be memory_get_pointer(node, 0)
                If func_name is not equal to 0:
                    deallocate(func_name)
                End If

                Note: Free node's callees array
                Let callees be memory_get_pointer(node, 16)
                If callees is not equal to 0:
                    deallocate(callees)
                End If

                Note: Free the node itself
                deallocate(node)
            End If
            Set i to i plus 1
        End While

        Note: Free the nodes array
        deallocate(nodes)
    End If

    Note: Free the graph itself
    deallocate(graph)
    Return 0
End Process

Note: Create a new call graph node for a function
Process called "callgraph_node_create" takes function_name as Integer, function_ptr as Integer returns Integer:
    Let node be allocate(40)

    memory_set_pointer(node, 0, string_duplicate(function_name))
    memory_set_pointer(node, 8, function_ptr)

    Note: Initialize with capacity for 16 callees
    Let initial_callees_capacity be 16
    memory_set_pointer(node, 16, allocate(initial_callees_capacity multiplied by 8))
    memory_set_int32(node, 24, 0)  Note: callee_count
    memory_set_int32(node, 28, 0)  Note: is_recursive = false
    memory_set_int32(node, 32, initial_callees_capacity)  Note: callee_capacity

    Return node
End Process

Note: Add a callee to a call graph node
Process called "callgraph_node_add_callee" takes node as Integer, callee_name as Integer returns Integer:
    Let callees be memory_get_pointer(node, 16)
    Let callee_count be memory_get_int32(node, 24)
    Let callee_capacity be memory_get_int32(node, 32)

    Note: Check if callee already exists
    Let i be 0
    While i is less than callee_count:
        Let existing_callee be memory_get_pointer(callees, i multiplied by 8)
        If string_equals(existing_callee, callee_name) is equal to 1:
            Return 0  Note: Already exists, don't add duplicate
        End If
        Set i to i plus 1
    End While

    Note: Resize array if full
    If callee_count is greater than or equal to callee_capacity:
        Let new_capacity be callee_capacity multiplied by 2
        Let new_callees be allocate(new_capacity multiplied by 8)

        Note: Copy existing callees
        Set i to 0
        While i is less than callee_count:
            Let old_callee be memory_get_pointer(callees, i multiplied by 8)
            memory_set_pointer(new_callees, i multiplied by 8, old_callee)
            Set i to i plus 1
        End While

        deallocate(callees)
        Set callees to new_callees
        memory_set_pointer(node, 16, new_callees)
        memory_set_int32(node, 32, new_capacity)
    End If

    Note: Add new callee
    memory_set_pointer(callees, callee_count multiplied by 8, string_duplicate(callee_name))
    memory_set_int32(node, 24, callee_count plus 1)

    Return 0
End Process

Note: Add a node to the call graph
Process called "callgraph_add_node" takes graph as Integer, node as Integer returns Integer:
    Let nodes be memory_get_pointer(graph, 0)
    Let node_count be memory_get_int32(graph, 8)
    Let capacity be memory_get_int32(graph, 12)

    Note: Resize array if full
    If node_count is greater than or equal to capacity:
        Let new_capacity be capacity multiplied by 2
        Let new_nodes be allocate(new_capacity multiplied by 8)

        Note: Copy existing nodes
        Let i be 0
        While i is less than node_count:
            Let old_node be memory_get_pointer(nodes, i multiplied by 8)
            memory_set_pointer(new_nodes, i multiplied by 8, old_node)
            Set i to i plus 1
        End While

        deallocate(nodes)
        Set nodes to new_nodes
        memory_set_pointer(graph, 0, new_nodes)
        memory_set_int32(graph, 12, new_capacity)
    End If

    Note: Store the node
    memory_set_pointer(nodes, node_count multiplied by 8, node)
    memory_set_int32(graph, 8, node_count plus 1)

    Return 0
End Process

Note: Find a node in the call graph by function name
Process called "callgraph_find_node" takes graph as Integer, function_name as Integer returns Integer:
    Let nodes be memory_get_pointer(graph, 0)
    Let node_count be memory_get_int32(graph, 8)

    Let i be 0
    While i is less than node_count:
        Let node be memory_get_pointer(nodes, i multiplied by 8)
        Let node_name be memory_get_pointer(node, 0)

        If string_equals(node_name, function_name) is equal to 1:
            Return node
        End If

        Set i to i plus 1
    End While

    Return 0  Note: Not found
End Process

Note: Traverse expression to find function calls
Process called "callgraph_collect_calls_from_expr" takes graph as Integer, node as Integer, expr as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If

    Note: Sanity check: expr should be a valid heap pointer (> 4096)
    If expr is less than 4096:
        Return 0
    End If

    Let expr_type be memory_get_int32(expr, 0)

    Note: Sanity check: expr_type should be in valid range (0-30)
    If expr_type is less than 0:
        Return 0
    End If
    If expr_type is greater than 30:
        Return 0
    End If

    Note: EXPR_INTEGER_LITERAL = 0 (leaf node, no traversal)
    Note: EXPR_STRING_LITERAL = 5 (leaf node, no traversal)
    Note: EXPR_VARIABLE = 1 (leaf node, no traversal)
    Note: EXPR_FUNCTION_POINTER = 10 (leaf node, no traversal)

    Note: EXPR_FUNCTION_CALL = 4
    If expr_type is equal to 4:
        Let function_call_ptr be expr plus 8
        Let function_name be memory_get_pointer(function_call_ptr, 0)

        Note: Add this function to the callees
        callgraph_node_add_callee(node, function_name)

        Note: Also traverse arguments
        Let arguments be memory_get_pointer(function_call_ptr, 8)
        Let arg_count be memory_get_int32(function_call_ptr, 16)

        Note: Safety check: only traverse if arguments array exists
        If arguments is not equal to 0:
            Let i be 0
            While i is less than arg_count:
                Let arg_expr be memory_get_pointer(arguments, i multiplied by 8)
                callgraph_collect_calls_from_expr(graph, node, arg_expr)
                Set i to i plus 1
            End While
        End If
    End If

    Note: EXPR_BINARY_OP = 2
    If expr_type is equal to 2:
        Let binary_op_ptr be expr plus 8
        Let left be memory_get_pointer(binary_op_ptr, 0)
        Let right be memory_get_pointer(binary_op_ptr, 8)

        callgraph_collect_calls_from_expr(graph, node, left)
        callgraph_collect_calls_from_expr(graph, node, right)
    End If

    Note: EXPR_COMPARISON = 3
    If expr_type is equal to 3:
        Let comparison_ptr be expr plus 8
        Set left to memory_get_pointer(comparison_ptr, 0)
        Set right to memory_get_pointer(comparison_ptr, 8)

        callgraph_collect_calls_from_expr(graph, node, left)
        callgraph_collect_calls_from_expr(graph, node, right)
    End If

    Note: EXPR_UNARY = 12 (NOT operator)
    If expr_type is equal to 12:
        Let unary_ptr be expr plus 8
        Let operand be memory_get_pointer(unary_ptr, 8)

        callgraph_collect_calls_from_expr(graph, node, operand)
    End If

    Note: EXPR_BUILTIN_CALL = 8
    If expr_type is equal to 8:
        Let builtin_call_ptr be expr plus 8
        Set arguments to memory_get_pointer(builtin_call_ptr, 8)
        Set arg_count to memory_get_int32(builtin_call_ptr, 16)

        Note: Traverse arguments for nested calls (safety check for NULL)
        If arguments is not equal to 0:
            Set i to 0
            While i is less than arg_count:
                Set arg_expr to memory_get_pointer(arguments, i multiplied by 8)
                callgraph_collect_calls_from_expr(graph, node, arg_expr)
                Set i to i plus 1
            End While
        End If
    End If

    Note: EXPR_INDIRECT_CALL = 11 (function pointer call)
    If expr_type is equal to 11:
        Let indirect_call_ptr be expr plus 8
        Let func_ptr_expr be memory_get_pointer(indirect_call_ptr, 0)
        Set arguments to memory_get_pointer(indirect_call_ptr, 8)
        Set arg_count to memory_get_int32(indirect_call_ptr, 16)

        Note: Traverse function pointer expression
        callgraph_collect_calls_from_expr(graph, node, func_ptr_expr)

        Note: Traverse arguments (safety check for NULL)
        If arguments is not equal to 0:
            Set i to 0
            While i is less than arg_count:
                Set arg_expr to memory_get_pointer(arguments, i multiplied by 8)
                callgraph_collect_calls_from_expr(graph, node, arg_expr)
                Set i to i plus 1
            End While
        End If
    End If

    Note: EXPR_FIELD_ACCESS = 6
    If expr_type is equal to 6:
        Let field_access_ptr be expr plus 8
        Let object_expr be memory_get_pointer(field_access_ptr, 0)

        callgraph_collect_calls_from_expr(graph, node, object_expr)
    End If

    Note: EXPR_VARIANT_CONSTRUCTOR = 9
    If expr_type is equal to 9:
        Let field_values be memory_get_pointer(expr, 24)
        Let field_count be memory_get_int32(expr, 32)

        Note: Variant may have field value expressions
        If field_values is not equal to 0:
            Set i to 0
            While i is less than field_count:
                Let field_expr be memory_get_pointer(field_values, i multiplied by 8)
                callgraph_collect_calls_from_expr(graph, node, field_expr)
                Set i to i plus 1
            End While
        End If
    End If

    Note: EXPR_STRUCT_CONSTRUCTION = 20
    If expr_type is equal to 20:
        Let struct_ptr be expr plus 8
        Set field_values to memory_get_pointer(struct_ptr, 16)
        Set field_count to memory_get_int32(struct_ptr, 24)

        Note: Traverse all field value expressions (safety check for NULL)
        If field_values is not equal to 0:
            Set i to 0
            While i is less than field_count:
                Let field_value_expr be memory_get_pointer(field_values, i multiplied by 8)
                callgraph_collect_calls_from_expr(graph, node, field_value_expr)
                Set i to i plus 1
            End While
        End If
    End If

    Note: EXPR_TYPE_CAST = 7 (cast expression)
    If expr_type is equal to 7:
        Let cast_ptr be expr plus 8
        Let value_expr be memory_get_pointer(cast_ptr, 8)

        callgraph_collect_calls_from_expr(graph, node, value_expr)
    End If

    Note: EXPR_ARRAY_INDEX = 16
    If expr_type is equal to 16:
        Let array_index_ptr be expr plus 8
        Let array_expr be memory_get_pointer(array_index_ptr, 0)
        Let index_expr be memory_get_pointer(array_index_ptr, 8)

        callgraph_collect_calls_from_expr(graph, node, array_expr)
        callgraph_collect_calls_from_expr(graph, node, index_expr)
    End If

    Return 0
End Process

Note: Traverse statement to find function calls
Process called "callgraph_collect_calls_from_stmt" takes graph as Integer, node as Integer, stmt as Integer returns Integer:
    If stmt is equal to 0:
        Return 0
    End If

    Let stmt_type be memory_get_int32(stmt, 0)

    Note: STMT_EXPRESSION = 7
    If stmt_type is equal to 7:
        Let expr be memory_get_pointer(stmt, 8)
        callgraph_collect_calls_from_expr(graph, node, expr)
    End If

    Note: STMT_RETURN = 3
    If stmt_type is equal to 3:
        Let return_expr be memory_get_pointer(stmt, 8)
        callgraph_collect_calls_from_expr(graph, node, return_expr)
    End If

    Note: STMT_PRINT = 4
    If stmt_type is equal to 4:
        Set expr to memory_get_pointer(stmt, 8)
        callgraph_collect_calls_from_expr(graph, node, expr)
    End If

    Note: STMT_IF = 5
    If stmt_type is equal to 5:
        Let if_ptr be stmt plus 8
        Let condition be memory_get_pointer(if_ptr, 0)
        Let then_stmts be memory_get_pointer(if_ptr, 8)
        Let then_count be memory_get_int32(if_ptr, 16)
        Let else_stmts be memory_get_pointer(if_ptr, 24)
        Let else_count be memory_get_int32(if_ptr, 32)

        callgraph_collect_calls_from_expr(graph, node, condition)

        Let i be 0
        While i is less than then_count:
            Let then_stmt be memory_get_pointer(then_stmts, i multiplied by 8)
            callgraph_collect_calls_from_stmt(graph, node, then_stmt)
            Set i to i plus 1
        End While

        Set i to 0
        While i is less than else_count:
            Let else_stmt be memory_get_pointer(else_stmts, i multiplied by 8)
            callgraph_collect_calls_from_stmt(graph, node, else_stmt)
            Set i to i plus 1
        End While
    End If

    Note: STMT_WHILE = 6
    If stmt_type is equal to 6:
        Let while_ptr be stmt plus 8
        Set condition to memory_get_pointer(while_ptr, 0)
        Let body_stmts be memory_get_pointer(while_ptr, 8)
        Let body_count be memory_get_int32(while_ptr, 16)

        callgraph_collect_calls_from_expr(graph, node, condition)

        Set i to 0
        While i is less than body_count:
            Let body_stmt be memory_get_pointer(body_stmts, i multiplied by 8)
            callgraph_collect_calls_from_stmt(graph, node, body_stmt)
            Set i to i plus 1
        End While
    End If

    Note: STMT_FOR = 11 (For-range: For var from start to end by step)
    If stmt_type is equal to 11:
        Let start_expr be memory_get_pointer(stmt, 16)
        Let end_expr be memory_get_pointer(stmt, 24)
        Let step_expr be memory_get_pointer(stmt, 32)
        Set body_stmts to memory_get_pointer(stmt, 40)
        Set body_count to memory_get_int32(stmt, 48)

        callgraph_collect_calls_from_expr(graph, node, start_expr)
        callgraph_collect_calls_from_expr(graph, node, end_expr)

        Note: step_expr can be 0 if no step specified
        If step_expr is not equal to 0:
            callgraph_collect_calls_from_expr(graph, node, step_expr)
        End If

        Set i to 0
        While i is less than body_count:
            Set body_stmt to memory_get_pointer(body_stmts, i multiplied by 8)
            callgraph_collect_calls_from_stmt(graph, node, body_stmt)
            Set i to i plus 1
        End While
    End If

    Note: STMT_MATCH = 8
    If stmt_type is equal to 8:
        Let match_ptr be stmt plus 8
        Set expr to memory_get_pointer(match_ptr, 0)
        Let arms be memory_get_pointer(match_ptr, 8)
        Let arm_count be memory_get_int32(match_ptr, 16)

        callgraph_collect_calls_from_expr(graph, node, expr)

        Set i to 0
        While i is less than arm_count:
            Let arm_offset be i multiplied by 48  Note: sizeof(WhenClause) = 48 bytes
            Let arm be arms plus arm_offset
            Set body_stmts to memory_get_pointer(arm, 32)  Note: WHEN_BODY_STMTS = 32
            Set body_count to memory_get_int32(arm, 40)    Note: WHEN_BODY_COUNT = 40

            Let j be 0
            While j is less than body_count:
                Set body_stmt to memory_get_pointer(body_stmts, j multiplied by 8)
                callgraph_collect_calls_from_stmt(graph, node, body_stmt)
                Set j to j plus 1
            End While

            Set i to i plus 1
        End While
    End If

    Note: STMT_FOR_EACH = 12
    If stmt_type is equal to 12:
        Let for_each_ptr be stmt plus 8
        Let collection_expr be memory_get_pointer(for_each_ptr, 8)
        Set body_stmts to memory_get_pointer(for_each_ptr, 16)
        Set body_count to memory_get_int32(for_each_ptr, 24)

        callgraph_collect_calls_from_expr(graph, node, collection_expr)

        Set i to 0
        While i is less than body_count:
            Set body_stmt to memory_get_pointer(body_stmts, i multiplied by 8)
            callgraph_collect_calls_from_stmt(graph, node, body_stmt)
            Set i to i plus 1
        End While
    End If

    Note: STMT_LET = 1
    If stmt_type is equal to 1:
        Let let_expr be memory_get_pointer(stmt, 16)
        callgraph_collect_calls_from_expr(graph, node, let_expr)
    End If

    Note: STMT_SET = 2
    If stmt_type is equal to 2:
        Let set_expr be memory_get_pointer(stmt, 16)
        callgraph_collect_calls_from_expr(graph, node, set_expr)
    End If

    Note: STMT_COMPOUND_ASSIGN = 17
    If stmt_type is equal to 17:
        Let compound_expr be memory_get_pointer(stmt, 24)
        callgraph_collect_calls_from_expr(graph, node, compound_expr)
    End If

    Note: STMT_BREAK = 9 and STMT_CONTINUE = 10 have no expressions to traverse

    Return 0
End Process

Note: Build call graph from program AST
Process called "callgraph_build" takes graph as Integer returns Integer:
    Let program be memory_get_pointer(graph, 16)
    Let functions be memory_get_pointer(program, 0)
    Let function_count be memory_get_int32(program, 8)

    Note: First pass: create nodes for all functions
    Let i be 0
    While i is less than function_count:
        Let func be memory_get_pointer(functions, i multiplied by 8)

        If func is not equal to 0:
            Let func_name be memory_get_pointer(func, 0)
            Let node be callgraph_node_create(func_name, func)
            callgraph_add_node(graph, node)
        End If

        Set i to i plus 1
    End While

    Note: Second pass: traverse function bodies to collect calls
    Let nodes be memory_get_pointer(graph, 0)
    Let node_count be memory_get_int32(graph, 8)

    Note: Safety check for null nodes array
    If nodes is equal to 0:
        Return 0
    End If

    Set i to 0
    While i is less than node_count:
        Set node to memory_get_pointer(nodes, i multiplied by 8)
        Let should_skip be 0

        Note: Check if node is null
        If node is equal to 0:
            Set should_skip to 1
        End If

        Note: Check if func is null
        Set func to 0
        If should_skip is equal to 0:
            Set func to memory_get_pointer(node, 8)
            If func is equal to 0:
                Set should_skip to 1
            End If
        End If

        Note: Process node if not skipped
        If should_skip is equal to 0:
            Let statements be memory_get_pointer(func, 32)
            Let stmt_count be memory_get_int32(func, 40)

            Let j be 0
            While j is less than stmt_count:
                Let stmt be memory_get_pointer(statements, j multiplied by 8)
                If stmt is not equal to 0:
                    callgraph_collect_calls_from_stmt(graph, node, stmt)
                End If
                Set j to j plus 1
            End While
        End If

        Set i to i plus 1
    End While

    Return 0
End Process

Note: Detect direct recursion (function calls itself)
Process called "callgraph_detect_direct_recursion" takes graph as Integer, node as Integer returns Integer:
    Let function_name be memory_get_pointer(node, 0)
    Let callees be memory_get_pointer(node, 16)
    Let callee_count be memory_get_int32(node, 24)

    Let i be 0
    While i is less than callee_count:
        Let callee_name be memory_get_pointer(callees, i multiplied by 8)

        If string_equals(function_name, callee_name) is equal to 1:
            memory_set_int32(node, 28, 1)  Note: Mark as recursive
            Return 1
        End If

        Set i to i plus 1
    End While

    Return 0
End Process

Note: Detect mutual recursion using depth-first search
Note: Uses a visited array to track function visit state during DFS
Note: visited states: 0 = unvisited, 1 = visiting (on stack), 2 = visited
Process called "callgraph_detect_mutual_recursion_dfs" takes graph as Integer, node as Integer, visited as Integer, node_index as Integer returns Integer:
    Note: Mark as visiting (on stack)
    memory_set_int32(visited, node_index multiplied by 4, 1)

    Let callees be memory_get_pointer(node, 16)
    Let callee_count be memory_get_int32(node, 24)

    Let found_cycle be 0

    Let i be 0
    While i is less than callee_count:
        Let callee_name be memory_get_pointer(callees, i multiplied by 8)
        Let callee_node be callgraph_find_node(graph, callee_name)

        If callee_node is not equal to 0:
            Note: Find callee's index
            Let nodes be memory_get_pointer(graph, 0)
            Let node_count be memory_get_int32(graph, 8)

            Let callee_idx be 0
            Let j be 0
            While j is less than node_count:
                Let check_node be memory_get_pointer(nodes, j multiplied by 8)
                If check_node is equal to callee_node:
                    Set callee_idx to j
                    Set j to node_count  Note: Break
                End If
                Set j to j plus 1
            End While

            Let callee_state be memory_get_int32(visited, callee_idx multiplied by 4)

            Note: If callee is currently being visited, we found a cycle
            If callee_state is equal to 1:
                memory_set_int32(node, 28, 1)  Note: Mark current as recursive
                memory_set_int32(callee_node, 28, 1)  Note: Mark callee as recursive
                Set found_cycle to 1
            End If

            Note: If callee is unvisited, recurse
            If callee_state is equal to 0:
                Let cycle_found be callgraph_detect_mutual_recursion_dfs(graph, callee_node, visited, callee_idx)
                If cycle_found is equal to 1:
                    Set found_cycle to 1
                End If
            End If
        End If

        Set i to i plus 1
    End While

    Note: Mark as visited (done)
    memory_set_int32(visited, node_index multiplied by 4, 2)

    Return found_cycle
End Process

Note: Detect all recursion (direct and mutual)
Process called "callgraph_detect_recursion" takes graph as Integer returns Integer:
    Let nodes be memory_get_pointer(graph, 0)
    Let node_count be memory_get_int32(graph, 8)

    Note: First detect direct recursion
    Let i be 0
    While i is less than node_count:
        Let node be memory_get_pointer(nodes, i multiplied by 8)
        callgraph_detect_direct_recursion(graph, node)
        Set i to i plus 1
    End While

    Note: Then detect mutual recursion using DFS
    Let visited be allocate(node_count multiplied by 4)  Note: Array of int32

    Note: Initialize all to unvisited (0)
    Set i to 0
    While i is less than node_count:
        memory_set_int32(visited, i multiplied by 4, 0)
        Set i to i plus 1
    End While

    Note: Run DFS from each unvisited node
    Set i to 0
    While i is less than node_count:
        Let state be memory_get_int32(visited, i multiplied by 4)
        If state is equal to 0:
            Set node to memory_get_pointer(nodes, i multiplied by 8)
            callgraph_detect_mutual_recursion_dfs(graph, node, visited, i)
        End If
        Set i to i plus 1
    End While

    deallocate(visited)
    Return 0
End Process

Note: Check if a return statement is a tail call
Process called "is_tail_call" takes stmt as Integer, function_name as Integer returns Integer:
    If stmt is equal to 0:
        Return 0
    End If

    Let stmt_type be memory_get_int32(stmt, 0)

    Note: STMT_RETURN = 3
    If stmt_type is not equal to 3:
        Return 0
    End If

    Let return_expr be memory_get_pointer(stmt, 8)
    If return_expr is equal to 0:
        Return 0
    End If

    Let expr_type be memory_get_int32(return_expr, 0)

    Note: EXPR_FUNCTION_CALL = 9
    If expr_type is not equal to 9:
        Return 0
    End If

    Let function_call_ptr be return_expr plus 8
    Let called_function_name be memory_get_pointer(function_call_ptr, 0)

    Note: Check if it's calling itself
    If string_equals(function_name, called_function_name) is equal to 1:
        Return 1
    End If

    Return 0
End Process

Note: Calculate stack size needed for a function
Note: This includes local variables and call depth estimation
Process called "callgraph_calculate_stack_size" takes node as Integer returns Integer:
    Let func be memory_get_pointer(node, 8)

    Note: Base stack size: 2048 bytes (conservative estimate)
    Let stack_size be 2048

    Note: Check if recursive - if so, needs unlimited stack
    Let is_recursive be memory_get_int32(node, 28)
    If is_recursive is equal to 1:
        Return -1  Note: -1 indicates unbounded/recursive
    End If

    Note: Add 256 bytes per callee (conservative estimate for call overhead)
    Let callee_count be memory_get_int32(node, 24)
    Set stack_size to stack_size plus callee_count multiplied by 256

    Return stack_size
End Process

Note: Print recursion warnings for all recursive functions
Process called "callgraph_print_warnings" takes graph as Integer returns Integer:
    Let nodes be memory_get_pointer(graph, 0)
    Let node_count be memory_get_int32(graph, 8)

    Let i be 0
    While i is less than node_count:
        Let node be memory_get_pointer(nodes, i multiplied by 8)
        Let is_recursive be memory_get_int32(node, 28)

        If is_recursive is equal to 1:
            Let function_name be memory_get_pointer(node, 0)

            print_string("[WARNING] Recursive function detected: ")
            print_string(function_name)
            print_string("\n")
            print_string("          Stack overflow possible. Consider tail call optimization or iterative approach.\n")
        End If

        Set i to i plus 1
    End While

    Return 0
End Process

Note: Inject stack probe at function prologue
Note: This checks if stack pointer is within safe bounds before proceeding
Process called "codegen_inject_stack_probe" takes output_file as Integer, function_name as Integer, is_recursive as Integer returns Integer:
    Note: Only inject probes for recursive functions or in debug mode
    If is_recursive is equal to 0:
        Return 0
    End If

    emit_line(output_file, "    # Stack overflow protection")
    emit_line(output_file, "    movq %rsp, %rax")
    emit_line(output_file, "    subq $16384, %rax  # Check if we have 16KB stack space")

    Note: Compare against a conservative stack limit
    Note: In a full implementation, this would check against __stack_limit
    emit_line(output_file, "    cmpq $0x100000, %rax  # Compare against 1MB limit")
    emit_line(output_file, "    jb .stack_overflow_panic")

    Return 0
End Process

Note: Generate stack overflow panic handler
Process called "codegen_generate_stack_overflow_handler" takes output_file as Integer returns Integer:
    file_write_buffered(output_file, "\n", 0)
    emit_line(output_file, "# Stack overflow panic handler")
    emit_line(output_file, ".stack_overflow_panic:")
    emit_line(output_file, "    # Print error message")
    emit_line(output_file, "    leaq .stack_overflow_msg(%rip), %rdi")
    emit_line(output_file, "    call print_string@PLT")
    emit_line(output_file, "    # Exit with error code")
    emit_line(output_file, "    movq $1, %rdi")
    emit_line(output_file, "    call exit_with_code@PLT")
    file_write_buffered(output_file, "\n", 0)
    emit_line(output_file, ".section .rodata")
    emit_line(output_file, ".stack_overflow_msg:")
    emit_line(output_file, "    .byte 70,65,84,65,76,32,69,82,82,79,82,58,32")  Note: "FATAL ERROR: "
    emit_line(output_file, "    .byte 83,116,97,99,107,32,111,118,101,114,102,108,111,119,32")  Note: "Stack overflow "
    emit_line(output_file, "    .byte 100,101,116,101,99,116,101,100")  Note: "detected"
    emit_line(output_file, "    .byte 10,0")
    emit_line(output_file, ".text")
    file_write_buffered(output_file, "\n", 0)

    Return 0
End Process

Note: ========================================================================
Note: END OF STACK SAFETY & MEMORY FOUNDATION
Note: ========================================================================
