Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Main Compiler for Runa v0.0.8.4.5.3
Note: World-class recursive import system integrated directly

Note: Process to read entire file contents into memory
Note: Equivalent to C static char* read_file(const char *filename)
Process called "read_file_internal" takes filename as Integer returns Integer:
    Note: Read entire file using runtime function (handles file open failure internally)
    Let content be runtime_read_file(filename)

    Note: Check if reading failed (equivalent to fopen() returning NULL)
    If content is equal to 0:
        Note: print_string(error message (equivalent to fprintf(stderr, "[MAIN ERROR] Could not open input file '%s'\n", filename))
        Let error_msg_temp be string_concat("[MAIN ERROR] Could not open input file '", filename)
        Let error_msg be string_concat(error_msg_temp, "'")
        deallocate(error_msg_temp)
        print_string(error_msg)
        deallocate(error_msg)
        Return 0
    End If

    Return content
End Process

Note: ============================================================================
Note: WORLD-CLASS RECURSIVE IMPORT SYSTEM
Note: ============================================================================

Note: ImportContext structure (arena-allocated, 40 bytes):
Note:   offset 0: visited_files (array of string pointers, 8 bytes)
Note:   offset 8: visited_count (integer, 8 bytes)
Note:   offset 16: visited_capacity (integer, 8 bytes)
Note:   offset 24: import_stack (array of string pointers, 8 bytes)
Note:   offset 32: stack_depth (integer, 8 bytes)

Process called "import_context_create" takes arena as Integer returns Integer:
    Note: Create import context for tracking visited files

    Let context be arena_allocate(arena, 40)
    If context is equal to 0:
        Return 0
    End If

    Note: Allocate initial arrays
    Let initial_capacity be 32  Note: Start with 32 files
    Let visited_array be arena_allocate(arena, initial_capacity multiplied by 8)
    Let stack_array be arena_allocate(arena, initial_capacity multiplied by 8)

    If visited_array is equal to 0:
        Return 0
    End If

    If stack_array is equal to 0:
        Return 0
    End If

    Note: Initialize context
    memory_set_pointer(context, 0, visited_array)
    memory_set_integer(context, 8, 0)  Note: visited_count = 0
    memory_set_integer(context, 16, initial_capacity)
    memory_set_pointer(context, 24, stack_array)
    memory_set_integer(context, 32, 0)  Note: stack_depth = 0

    Return context
End Process

Process called "import_context_is_visited" takes context as Integer, filename as Integer returns Integer:
    Note: Check if file has already been visited

    Let visited_files be memory_get_pointer(context, 0)
    Let visited_count be memory_get_integer(context, 8)

    Let i be 0
    While i is less than visited_count:
        Let offset be i multiplied by 8
        Let visited_file be memory_get_pointer(visited_files plus offset, 0)

        If string_equals(visited_file, filename) is equal to 1:
            Return 1  Note: Already visited
        End If

        Set i to i plus 1
    End While

    Return 0  Note: Not visited yet
End Process

Process called "import_context_mark_visited" takes context as Integer, filename as Integer, arena as Integer returns Integer:
    Note: Mark file as visited

    Let visited_files be memory_get_pointer(context, 0)
    Let visited_count be memory_get_integer(context, 8)
    Let visited_capacity be memory_get_integer(context, 16)

    Note: Check if we need to grow the array
    If visited_count is greater than or equal to visited_capacity:
        Note: Double capacity
        Let new_capacity be visited_capacity multiplied by 2
        Let new_array be arena_allocate(arena, new_capacity multiplied by 8)

        If new_array is equal to 0:
            Return 0  Note: Allocation failed
        End If

        Note: Copy old entries
        Let i be 0
        While i is less than visited_count:
            Let old_offset be i multiplied by 8
            Let old_ptr be memory_get_pointer(visited_files plus old_offset, 0)
            memory_set_pointer(new_array plus old_offset, 0, old_ptr)
            Set i to i plus 1
        End While

        Note: Update context
        memory_set_pointer(context, 0, new_array)
        memory_set_integer(context, 16, new_capacity)
        Set visited_files to new_array
    End If

    Note: Duplicate filename into arena
    Let filename_copy be arena_string_duplicate(arena, filename)
    If filename_copy is equal to 0:
        Return 0
    End If

    Note: Add to visited array
    Let offset be visited_count multiplied by 8
    memory_set_pointer(visited_files plus offset, 0, filename_copy)
    memory_set_integer(context, 8, visited_count plus 1)

    Return 1
End Process

Process called "import_context_push_stack" takes context as Integer, filename as Integer, arena as Integer returns Integer:
    Note: Push filename onto import stack for cycle detection

    Let import_stack be memory_get_pointer(context, 24)
    Let stack_depth be memory_get_integer(context, 32)
    Let visited_capacity be memory_get_integer(context, 16)

    Note: Check capacity
    If stack_depth is greater than or equal to visited_capacity:
        Return 0  Note: Stack overflow
    End If

    Note: Duplicate filename
    Let filename_copy be arena_string_duplicate(arena, filename)
    If filename_copy is equal to 0:
        Return 0
    End If

    Note: Push to stack
    Let offset be stack_depth multiplied by 8
    memory_set_pointer(import_stack plus offset, 0, filename_copy)
    memory_set_integer(context, 32, stack_depth plus 1)

    Return 1
End Process

Process called "import_context_pop_stack" takes context as Integer returns Integer:
    Note: Pop filename from import stack

    Let stack_depth be memory_get_integer(context, 32)

    If stack_depth is equal to 0:
        Return 0  Note: Stack empty
    End If

    memory_set_integer(context, 32, stack_depth minus 1)
    Return 1
End Process

Process called "import_context_is_in_stack" takes context as Integer, filename as Integer returns Integer:
    Note: Check if filename is in import stack (cycle detection)

    Let import_stack be memory_get_pointer(context, 24)
    Let stack_depth be memory_get_integer(context, 32)

    Let i be 0
    While i is less than stack_depth:
        Let offset be i multiplied by 8
        Let stack_file be memory_get_pointer(import_stack plus offset, 0)

        If string_equals(stack_file, filename) is equal to 1:
            Return 1  Note: Cycle detected!
        End If

        Set i to i plus 1
    End While

    Return 0
End Process

Process called "import_context_print_stack" takes context as Integer returns Integer:
    Note: Print import stack for error messages

    Let import_stack be memory_get_pointer(context, 24)
    Let stack_depth be memory_get_integer(context, 32)

    print_string("  Import chain:")

    Let i be 0
    While i is less than stack_depth:
        Let offset be i multiplied by 8
        Let stack_file be memory_get_pointer(import_stack plus offset, 0)

        print_string("    -> ")
        print_string(stack_file)

        Set i to i plus 1
    End While

    Return 1
End Process

Process called "process_imports_recursive_internal" takes program as Integer, context as Integer, arena as Integer, filename as Integer returns Integer:
    Note: RECURSIVE import processor - depth-first traversal

    Note: Get import count and imports array from program
    Let import_count be memory_get_int32(program, 40)

    If import_count is equal to 0:
        Return 0
    End If

    Let imports be memory_get_pointer(program, 32)
    Let ptr_size be 8

    Note: Iterate through each import in this file
    Let i be 0
    While i is less than import_count:
        Let import_offset be i multiplied by ptr_size
        Let import_ptr be imports plus import_offset
        Let import_stmt be memory_get_pointer(import_ptr, 0)
        Let import_filename be memory_get_pointer(import_stmt, 0)

        Note: CYCLE DETECTION
        If import_context_is_in_stack(context, import_filename) is equal to 1:
            print_string("")
            print_string("[IMPORT ERROR] Circular import detected!")
            print_string("")
            Let error_msg_temp be string_concat("  Attempting to import: ", import_filename)
            print_string(error_msg_temp)
            deallocate(error_msg_temp)
            print_string("")
            import_context_print_stack(context)
            print_string("")
            print_string("  This would create a circular dependency.")
            print_string("  Tip: Reorganize your modules to break the cycle.")
            Return 1
        End If

        Note: DEDUPLICATION
        If import_context_is_visited(context, import_filename) is equal to 1:
            Set i to i plus 1
            Continue
        End If

        Note: MARK AS VISITED
        If import_context_mark_visited(context, import_filename, arena) is equal to 0:
            print_string("[IMPORT ERROR] Failed to mark file as visited")
            Return 1
        End If

        Note: PUSH TO STACK
        If import_context_push_stack(context, import_filename, arena) is equal to 0:
            print_string("[IMPORT ERROR] Import stack overflow")
            Return 1
        End If

        Note: READ IMPORTED FILE
        Let import_source be read_file_internal(import_filename)
        If import_source is equal to 0:
            Set error_msg_temp to string_concat("[IMPORT ERROR] Failed to read: ", import_filename)
            print_string(error_msg_temp)
            deallocate(error_msg_temp)
            import_context_pop_stack(context)
            Return 1
        End If

        Note: PARSE IMPORTED FILE
        Let import_lexer be lexer_create(import_source, arena)
        Let import_parser be parser_create(import_lexer, arena)
        Let import_program be parser_parse_program(import_parser)

        If import_program is equal to 0:
            Set error_msg_temp to string_concat("[IMPORT ERROR] Failed to parse: ", import_filename)
            print_string(error_msg_temp)
            deallocate(error_msg_temp)
            parser_destroy(import_parser)
            lexer_destroy(import_lexer)
            deallocate(import_source)
            import_context_pop_stack(context)
            Return 1
        End If

        Note: RECURSIVE PROCESSING
        Let recursive_result be process_imports_recursive_internal(import_program, context, arena, import_filename)

        If recursive_result is not equal to 0:
            parser_destroy(import_parser)
            lexer_destroy(import_lexer)
            deallocate(import_source)
            import_context_pop_stack(context)
            Return 1
        End If

        Note: MERGE FUNCTIONS
        Let import_func_count be memory_get_int32(import_program, 8)
        Let import_functions be memory_get_pointer(import_program, 0)

        Let j be 0
        While j is less than import_func_count:
            Let func_offset be j multiplied by ptr_size
            Let func_ptr be import_functions plus func_offset
            Let func be memory_get_pointer(func_ptr, 0)
            Let is_func_exported be memory_get_int32(func, 44)
            If is_func_exported is equal to 1:
                program_add_function(program, func)
            End If
            Set j to j plus 1
        End While

        Note: MERGE TYPES
        Let import_type_count be memory_get_int32(import_program, 32)
        Let import_types be memory_get_pointer(import_program, 40)

        Let k be 0
        While k is less than import_type_count:
            Let type_offset be k multiplied by ptr_size
            Let type_ptr be import_types plus type_offset
            Let type_def be memory_get_pointer(type_ptr, 0)
            program_add_type(program, type_def)
            Set k to k plus 1
        End While

        Note: CLEANUP
        parser_destroy(import_parser)
        lexer_destroy(import_lexer)
        deallocate(import_source)
        import_context_pop_stack(context)

        Set i to i plus 1
    End While

    Return 0
End Process

Process called "process_imports_recursive" takes program as Integer, arena as Integer returns Integer:
    Note: PUBLIC API: Process all imports recursively

    Let context be import_context_create(arena)
    If context is equal to 0:
        print_string("[IMPORT ERROR] Failed to create import context")
        Return 1
    End If

    Let result be process_imports_recursive_internal(program, context, arena, "<main>")
    Return result
End Process

Note: Main compiler entry point
Note: Equivalent to C int main(int argc, char **argv)
Process called "main" takes argc as Integer, argv as Integer returns Integer:
    Note: Check command line arguments (argc != 3)
    If argc is not equal to 3:
        Note: print_string(usage message (equivalent to fprintf(stderr, "Usage: %s <input.runa> <output.s>\n", argv[0]))
        Let prog_name be get_command_line_arg(0)
        Let usage_msg_temp be string_concat("Usage: ", prog_name)
        Let usage_msg be string_concat(usage_msg_temp, " <input.runa> <output.s>")
        deallocate(usage_msg_temp)
        print_string(usage_msg)
        deallocate(usage_msg)
        deallocate(prog_name)
        Return 1
    End If

    Note: Get command line arguments (equivalent to input_filename = argv[1])
    Let input_filename be get_command_line_arg(1)
    Let output_filename be get_command_line_arg(2)

    Note: Read source file (equivalent to char *source = read_file(input_filename))
    Let source be read_file_internal(input_filename)

    Note: Check if reading failed (equivalent to !source)
    If source is equal to 0:
        print_string("[ERROR] Failed to read source file")
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Create arena for temporary allocations (Instance/Arena Hybrid Architecture)
    Let initial_arena_size be 65536  Note: 64KB initial size
    Let arena be arena_create(initial_arena_size)
    If arena is equal to 0:
        print_string("[ERROR] Failed to create arena allocator")
        deallocate(source)
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Create lexer (equivalent to Lexer *lexer = lexer_create(source))
    Let lexer be lexer_create(source, arena)

    Note: Create parser (equivalent to Parser *parser = parser_create(lexer))
    Let parser be parser_create(lexer, arena)

    Note: Parse program (equivalent to Program *program = parser_parse_program(parser))
    Let program be parser_parse_program(parser)

    Note: Check if parsing failed (equivalent to !program)
    If program is equal to 0:
        print_string("[ERROR] main: Parsing failed - program is NULL")
        Note: Cleanup parser and lexer before returning
        arena_destroy(arena)
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source)
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Process imports recursively with world-class import system
    Let import_result be process_imports_recursive(program, arena)
    If import_result is not equal to 0:
        Note: Import processing failed
        arena_destroy(arena)
        program_destroy(program)
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source)
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Create code generator (equivalent to CodeGenerator *codegen = codegen_create(output_filename))
    Let codegen be codegen_create(output_filename, arena)

    Note: Check if codegen creation failed (equivalent to !codegen)
    If codegen is equal to 0:
        Note: Cleanup resources before returning
        arena_destroy(arena)
        program_destroy(program)
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source)
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Generate code (equivalent to codegen_generate(codegen, program))
    codegen_generate(codegen, program)

    Note: Close output file to ensure content is written (flushes buffer)
    Let output_file be memory_get_integer(codegen, 0)
    file_close_buffered(output_file)

    Note: Print success message (equivalent to printf("Successfully compiled '%s' to '%s'\n", input_filename, output_filename))
    Let success_msg_temp be string_concat("Successfully compiled '", input_filename)
    Let success_msg_temp2 be string_concat(success_msg_temp, "' to '")
    deallocate(success_msg_temp)
    Let success_msg be string_concat(success_msg_temp2, output_filename)
    deallocate(success_msg_temp2)
    Let success_msg_final be string_concat(success_msg, "'")
    deallocate(success_msg)
    print_string(success_msg_final)
    deallocate(success_msg_final)

    Note: Cleanup resources (equivalent to C cleanup code)
    arena_destroy(arena)  Note: Destroy arena first - frees all temporary allocations
    codegen_destroy(codegen)
    program_destroy(program)
    parser_destroy(parser)
    lexer_destroy(lexer)
    deallocate(source)
    deallocate(input_filename)
    deallocate(output_filename)

    Return 0
End Process