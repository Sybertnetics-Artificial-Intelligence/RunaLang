Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: ========================================================================
Note: COMPREHENSIVE STACK SAFETY TEST SUITE (v0.0.8.4.1)
Note: ========================================================================
Note: This test file validates all stack safety features:
Note: 1. Direct recursion detection
Note: 2. Mutual recursion detection
Note: 3. Stack overflow protection
Note: 4. Tail call optimization (TCO)
Note: 5. Stack size calculation
Note: 6. Recursion warnings
Note: ========================================================================

Note: ========================================================================
Note: TEST 1: Direct Recursion Detection
Note: ========================================================================
Note: This function directly calls itself
Note: Expected: Compiler should detect and warn about recursion
Note: Expected: Stack probe should be injected at function entry

Process called "factorial" takes n as Integer returns Integer:
    If n is less than or equal to 1:
        Return 1
    End If
    Let result be factorial(n minus 1)
    Return n multiplied by result
End Process

Note: ========================================================================
Note: TEST 2: Tail Recursive Function
Note: ========================================================================
Note: This function is tail recursive (last operation is the recursive call)
Note: Expected: Can be optimized to iterative form (TCO)
Note: Expected: Warning about recursion, but TCO-eligible

Process called "factorial_tail" takes n as Integer, acc as Integer returns Integer:
    If n is less than or equal to 1:
        Return acc
    End If
    Return factorial_tail(n minus 1, n multiplied by acc)
End Process

Note: ========================================================================
Note: TEST 3: Mutual Recursion Detection
Note: ========================================================================
Note: These functions call each other in a cycle
Note: Expected: Compiler should detect mutual recursion
Note: Expected: Both functions should get stack probes

Process called "is_even" takes n as Integer returns Integer:
    If n is equal to 0:
        Return 1
    End If
    Return is_odd(n minus 1)
End Process

Process called "is_odd" takes n as Integer returns Integer:
    If n is equal to 0:
        Return 0
    End If
    Return is_even(n minus 1)
End Process

Note: ========================================================================
Note: TEST 4: Deep Recursion Test
Note: ========================================================================
Note: This function recurses deeply to test stack limits
Note: Expected: Stack overflow protection should trigger if depth exceeds limits

Process called "deep_recursion" takes depth as Integer returns Integer:
    If depth is equal to 0:
        Return 1
    End If
    Let result be deep_recursion(depth minus 1)
    Return result plus 1
End Process

Note: ========================================================================
Note: TEST 5: Non-Recursive Function (Control)
Note: ========================================================================
Note: This function does not recurse
Note: Expected: No recursion warning
Note: Expected: No stack probe injected

Process called "simple_add" takes a as Integer, b as Integer returns Integer:
    Return a plus b
End Process

Note: ========================================================================
Note: TEST 6: Indirect Recursion (3-way cycle)
Note: ========================================================================
Note: These functions call each other in a 3-way cycle
Note: Expected: All three should be detected as mutually recursive

Process called "func_a" takes n as Integer returns Integer:
    If n is less than or equal to 0:
        Return 0
    End If
    Return func_b(n minus 1)
End Process

Process called "func_b" takes n as Integer returns Integer:
    If n is less than or equal to 0:
        Return 1
    End If
    Return func_c(n minus 1)
End Process

Process called "func_c" takes n as Integer returns Integer:
    If n is less than or equal to 0:
        Return 2
    End If
    Return func_a(n minus 1)
End Process

Note: ========================================================================
Note: TEST 7: Fibonacci (Multiple Recursive Calls)
Note: ========================================================================
Note: This function makes multiple recursive calls
Note: Expected: Recursion detected and warned
Note: Expected: Stack usage grows exponentially

Process called "fibonacci" takes n as Integer returns Integer:
    If n is less than or equal to 1:
        Return n
    End If
    Let a be fibonacci(n minus 1)
    Let b be fibonacci(n minus 2)
    Return a plus b
End Process

Note: ========================================================================
Note: TEST 8: Nested Function Calls (Non-Recursive)
Note: ========================================================================
Note: These functions call each other but don't form a cycle
Note: Expected: No recursion detected

Process called "helper_one" takes x as Integer returns Integer:
    Return x multiplied by 2
End Process

Process called "helper_two" takes x as Integer returns Integer:
    Let temp be helper_one(x)
    Return temp plus 10
End Process

Process called "main_func" takes x as Integer returns Integer:
    Let result be helper_two(x)
    Return result
End Process

Note: ========================================================================
Note: TEST 9: Conditional Recursion
Note: ========================================================================
Note: This function only recurses under certain conditions
Note: Expected: Still detected as recursive (conservative analysis)

Process called "conditional_recursion" takes n as Integer, flag as Integer returns Integer:
    If n is less than or equal to 0:
        Return 0
    End If

    If flag is equal to 1:
        Return conditional_recursion(n minus 1, flag)
    End If

    Return n
End Process

Note: ========================================================================
Note: TEST 10: Ackermann Function (Highly Recursive)
Note: ========================================================================
Note: This function is extremely recursive
Note: Expected: Recursion detected
Note: Expected: Stack overflow protection crucial

Process called "ackermann" takes m as Integer, n as Integer returns Integer:
    If m is equal to 0:
        Return n plus 1
    End If

    If n is equal to 0:
        Return ackermann(m minus 1, 1)
    End If

    Let temp be ackermann(m, n minus 1)
    Return ackermann(m minus 1, temp)
End Process

Note: ========================================================================
Note: MAIN TEST DRIVER
Note: ========================================================================
Note: Tests various stack safety features

Process called "main" returns Integer:
    print_string("=== STACK SAFETY TEST SUITE ===\n")
    print_string("\n")

    Note: Test 1: Direct recursion
    print_string("TEST 1: Direct Recursion (factorial)\n")
    Let fact5 be factorial(5)
    print_string("factorial(5) = ")
    print_integer(fact5)
    print_string("\n")

    Note: Test 2: Tail recursive
    print_string("\nTEST 2: Tail Recursion (factorial_tail)\n")
    Let fact_tail5 be factorial_tail(5, 1)
    print_string("factorial_tail(5, 1) = ")
    print_integer(fact_tail5)
    print_string("\n")

    Note: Test 3: Mutual recursion
    print_string("\nTEST 3: Mutual Recursion (is_even/is_odd)\n")
    Let even_test be is_even(10)
    Let odd_test be is_odd(10)
    print_string("is_even(10) = ")
    print_integer(even_test)
    print_string("\n")
    print_string("is_odd(10) = ")
    print_integer(odd_test)
    print_string("\n")

    Note: Test 4: Deep recursion (moderate depth to avoid actual overflow)
    print_string("\nTEST 4: Deep Recursion\n")
    Let deep_result be deep_recursion(100)
    print_string("deep_recursion(100) = ")
    print_integer(deep_result)
    print_string("\n")

    Note: Test 5: Non-recursive function
    print_string("\nTEST 5: Non-Recursive Function\n")
    Let sum be simple_add(10, 20)
    print_string("simple_add(10, 20) = ")
    print_integer(sum)
    print_string("\n")

    Note: Test 6: Indirect recursion (3-way)
    print_string("\nTEST 6: Indirect Recursion (3-way)\n")
    Let result_a be func_a(5)
    print_string("func_a(5) = ")
    print_integer(result_a)
    print_string("\n")

    Note: Test 7: Fibonacci
    print_string("\nTEST 7: Fibonacci (Multiple Recursive Calls)\n")
    Let fib8 be fibonacci(8)
    print_string("fibonacci(8) = ")
    print_integer(fib8)
    print_string("\n")

    Note: Test 8: Nested function calls (non-recursive)
    print_string("\nTEST 8: Nested Function Calls (Non-Recursive)\n")
    Let nested_result be main_func(5)
    print_string("main_func(5) = ")
    print_integer(nested_result)
    print_string("\n")

    Note: Test 9: Conditional recursion
    print_string("\nTEST 9: Conditional Recursion\n")
    Let cond_result be conditional_recursion(10, 1)
    print_string("conditional_recursion(10, 1) = ")
    print_integer(cond_result)
    print_string("\n")

    Note: Test 10: Ackermann (small values to avoid overflow)
    print_string("\nTEST 10: Ackermann Function\n")
    Let ack_result be ackermann(2, 2)
    print_string("ackermann(2, 2) = ")
    print_integer(ack_result)
    print_string("\n")

    print_string("\n=== ALL TESTS COMPLETE ===\n")
    print_string("\nExpected Compiler Warnings:\n")
    print_string("- factorial: direct recursion\n")
    print_string("- factorial_tail: direct recursion (tail-recursive)\n")
    print_string("- is_even/is_odd: mutual recursion\n")
    print_string("- deep_recursion: direct recursion\n")
    print_string("- func_a/func_b/func_c: mutual recursion (3-way)\n")
    print_string("- fibonacci: direct recursion\n")
    print_string("- conditional_recursion: direct recursion\n")
    print_string("- ackermann: direct recursion\n")
    print_string("\nNO warnings expected for:\n")
    print_string("- simple_add\n")
    print_string("- helper_one/helper_two/main_func\n")

    Return 0
End Process
