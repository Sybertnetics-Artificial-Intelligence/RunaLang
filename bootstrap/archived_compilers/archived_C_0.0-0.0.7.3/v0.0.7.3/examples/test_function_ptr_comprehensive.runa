# Comprehensive function pointer test - advanced features

# Math operations
Process called "add" takes a as Integer, b as Integer returns Integer:
    Return a plus b
End Process

Process called "subtract" takes a as Integer, b as Integer returns Integer:
    Return a minus b
End Process

Process called "multiply" takes a as Integer, b as Integer returns Integer:
    Return a multiplied by b
End Process

Process called "divide" takes a as Integer, b as Integer returns Integer:
    Return a divided by b
End Process

# Define function pointer type
Type BinaryOp is Pointer to Process takes x as Integer, y as Integer returns Integer

# Higher-order function that applies an operation
Process called "apply_operation" takes op as BinaryOp, left as Integer, right as Integer returns Integer:
    Return op(left, right)
End Process

# Function that returns a function pointer based on operator
Process called "get_operator" takes op_code as Integer returns BinaryOp:
    If op_code is equal to 1:
        Return add
    End If
    If op_code is equal to 2:
        Return subtract
    End If
    If op_code is equal to 3:
        Return multiply
    End If
    Return divide
End Process

# Accumulator using function pointers
Process called "accumulate" takes op as BinaryOp, start as Integer, count as Integer returns Integer:
    Let result be start
    Let i be 1
    While i is less than or equal to count:
        Set result to op(result, i)
        Set i to i plus 1
    End While
    Return result
End Process

Process called "main" returns Integer:
    # Test direct function pointer usage
    Let op1 be add
    Let result1 be op1(10, 20)
    Print result1  # Should print 30

    # Test function pointer parameter passing
    Let result2 be apply_operation(multiply, 6, 7)
    Print result2  # Should print 42

    # Test function returning function pointer
    Let selected_op be get_operator(2)
    Let result3 be selected_op(100, 25)
    Print result3  # Should print 75

    # Test accumulator with add (sum from 1 to 5)
    Let sum be accumulate(add, 0, 5)
    Print sum  # Should print 15 (0+1+2+3+4+5)

    # Test accumulator with multiply (factorial of 5)
    Let factorial be accumulate(multiply, 1, 5)
    Print factorial  # Should print 120 (1*1*2*3*4*5)

    Return 0
End Process