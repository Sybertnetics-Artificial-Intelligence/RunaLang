Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Main Compiler for Runa v0.0.7.5
Note: Line-by-line transliteration from v0.0.7.3 main.c (64 LOC)

Note: ============================================================================
Note: Import Cache System
Note: Tracks which files have been imported to prevent duplicate processing
Note: ============================================================================

Note: Global import cache
Note: Array of string pointers (filenames)
Let imported_files_cache be 0
Let imported_files_count be 0
Let imported_files_capacity be 0

Note: Initialize the import cache
Process called "init_import_cache" returns Integer:
    Let initial_capacity be 64
    Let bytes_needed be initial_capacity multiplied by 8  Note: 8 bytes per pointer
    Let cache be allocate(bytes_needed)
    Set imported_files_cache to cache
    Set imported_files_capacity to initial_capacity
    Set imported_files_count to 0
    Return 0
End Process

Note: Check if a file has already been imported
Process called "is_file_imported" takes filename as Integer returns Integer:
    Let i be 0
    While i is less than imported_files_count:
        Let offset be i multiplied by 8
        Let ptr be imported_files_cache plus offset
        Let cached_filename be memory_get_pointer(ptr, 0)

        Note: Compare filenames
        If string_equals(filename, cached_filename) is equal to 1:
            Return 1  Note: Already imported
        End If

        Set i to i plus 1
    End While

    Return 0  Note: Not yet imported
End Process

Note: Mark a file as imported
Process called "mark_file_imported" takes filename as Integer returns Integer:
    Note: Check if we need to grow the cache
    If imported_files_count is equal to imported_files_capacity:
        Note: Double the capacity
        Let new_capacity be imported_files_capacity multiplied by 2
        Let new_bytes be new_capacity multiplied by 8
        Let new_cache be allocate(new_bytes)

        Note: Copy old entries to new cache
        Let bytes_to_copy be imported_files_count multiplied by 8
        memory_copy(new_cache, imported_files_cache, bytes_to_copy)

        Note: Free old cache and update to new one
        deallocate(imported_files_cache)
        Set imported_files_cache to new_cache
        Set imported_files_capacity to new_capacity
    End If

    Note: Add filename to cache (duplicate the string)
    Let filename_copy be string_duplicate(filename)
    Let offset be imported_files_count multiplied by 8
    Let ptr be imported_files_cache plus offset
    memory_set_pointer(ptr, 0, filename_copy)

    Set imported_files_count to imported_files_count plus 1
    Return 0
End Process

Note: ============================================================================
Note: File Reading
Note: ============================================================================

Note: Process to read entire file contents into memory
Note: Equivalent to C static char* read_file(const char *filename)
Process called "read_file_internal" takes filename as Integer returns Integer:
    Note: Read entire file using runtime function (handles file open failure internally)
    Let content be runtime_read_file(filename)

    Note: Check if reading failed (equivalent to fopen() returning NULL)
    If content is equal to 0:
        Note: print_string(error message (equivalent to fprintf(stderr, "[MAIN ERROR] Could not open input file '%s'\n", filename))
        Let error_msg_temp be string_concat("[MAIN ERROR] Could not open input file '", filename)
        Let error_msg be string_concat(error_msg_temp, "'")
        deallocate(error_msg_temp)
        print_string(error_msg)
        deallocate(error_msg)
        Return 0
    End If

    Return content
End Process

Note: Process imports: load and merge imported files
Note: Takes program pointer, returns 0 on success, 1 on failure
Process called "process_imports" takes program as Integer returns Integer:
    Note: Get import count and imports array
    Let import_count be memory_get_int32(program, 40)  Note: PROGRAM_IMPORT_COUNT

    If import_count is equal to 0:
        Return 0  Note: No imports to process
    End If

    Let imports be memory_get_pointer(program, 32)  Note: PROGRAM_IMPORTS

    Note: Iterate through each import
    Let i be 0
    While i is less than import_count:
        Note: Get import statement pointer
        Let ptr_size be 8
        Let import_offset be i multiplied by ptr_size
        Let import_ptr be imports plus import_offset
        Let import_stmt be memory_get_pointer(import_ptr, 0)

        Note: Get filename from import statement (offset 0 is filename)
        Let import_filename be memory_get_pointer(import_stmt, 0)

        Note: Check if file has already been imported
        Let already_imported be is_file_imported(import_filename)
        If already_imported is equal to 0:
            Note: File not yet imported, process it

            Note: Mark file as being imported (before processing to prevent cycles)
            mark_file_imported(import_filename)

            Note: Read the imported file
            Let import_source be read_file_internal(import_filename)
            If import_source is equal to 0:
                Let error_msg_temp be string_concat("[IMPORT ERROR] Failed to read import file: ", import_filename)
                print_string(error_msg_temp)
                deallocate(error_msg_temp)
                Return 1
            End If

            Note: Create lexer for imported file
            Let import_lexer be lexer_create(import_source)

            Note: Create parser for imported file
            Let import_parser be parser_create(import_lexer)

            Note: Parse the imported file
            Let import_program be parser_parse_program(import_parser)

            If import_program is equal to 0:
                Let error_msg_temp be string_concat("[IMPORT ERROR] Failed to parse import file: ", import_filename)
                print_string(error_msg_temp)
                deallocate(error_msg_temp)
                parser_destroy(import_parser)
                lexer_destroy(import_lexer)
                deallocate(import_source)
                Return 1
            End If

            Note: Recursively process imports in the imported file
            Note: This handles transitive dependencies (A imports B, B imports C)
            Let nested_result be process_imports(import_program)
            If nested_result is not equal to 0:
                Let error_msg_temp be string_concat("[IMPORT ERROR] Failed to process nested imports in: ", import_filename)
                print_string(error_msg_temp)
                deallocate(error_msg_temp)
                parser_destroy(import_parser)
                lexer_destroy(import_lexer)
                deallocate(import_source)
                Return 1
            End If

            Note: Merge functions from imported program into main program
            Let import_func_count be memory_get_int32(import_program, 8)  Note: function_count
            Let import_functions be memory_get_pointer(import_program, 0)  Note: functions array

            Let j be 0
            While j is less than import_func_count:
                Let func_offset be j multiplied by ptr_size
                Let func_ptr be import_functions plus func_offset
                Let func be memory_get_pointer(func_ptr, 0)
                program_add_function(program, func)
                Set j to j plus 1
            End While

            Note: Merge types from imported program into main program
            Let import_type_count be memory_get_int32(import_program, 32)  Note: type_count
            Let import_types be memory_get_pointer(import_program, 40)  Note: types array

            Let k be 0
            While k is less than import_type_count:
                Let type_offset be k multiplied by ptr_size
                Let type_ptr be import_types plus type_offset
                Let type_def be memory_get_pointer(type_ptr, 0)
                program_add_type(program, type_def)
                Set k to k plus 1
            End While

            Note: Cleanup import parsing resources (but not the AST nodes - they're now in main program)
            parser_destroy(import_parser)
            lexer_destroy(import_lexer)
            deallocate(import_source)
        End If

        Set i to i plus 1
    End While

    Return 0
End Process

Note: Main compiler entry point
Note: Equivalent to C int main(int argc, char **argv)
Process called "main" takes argc as Integer, argv as Integer returns Integer:
    Note: Check command line arguments (argc != 3)
    If argc is not equal to 3:
        Note: print_string(usage message (equivalent to fprintf(stderr, "Usage: %s <input.runa> <output.s>\n", argv[0]))
        Let prog_name be get_command_line_arg(0)
        Let usage_msg_temp be string_concat("Usage: ", prog_name)
        Let usage_msg be string_concat(usage_msg_temp, " <input.runa> <output.s>")
        deallocate(usage_msg_temp)
        print_string(usage_msg)
        deallocate(usage_msg)
        deallocate(prog_name)
        Return 1
    End If

    Note: Get command line arguments (equivalent to input_filename = argv[1])
    Let input_filename be get_command_line_arg(1)
    Let output_filename be get_command_line_arg(2)

    Note: Initialize import cache to track imported files
    init_import_cache()

    Note: Read source file (equivalent to char *source = read_file(input_filename))
    Let source be read_file_internal(input_filename)

    Note: Check if reading failed (equivalent to !source)
    If source is equal to 0:
        print_string("[ERROR] Failed to read source file")
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Create lexer (equivalent to Lexer *lexer = lexer_create(source))
    Let lexer be lexer_create(source)

    Note: Create parser (equivalent to Parser *parser = parser_create(lexer))
    Let parser be parser_create(lexer)

    Note: Parse program (equivalent to Program *program = parser_parse_program(parser))
    Let program be parser_parse_program(parser)

    Note: Check if parsing failed (equivalent to !program)
    If program is equal to 0:
        print_string("[ERROR] main: Parsing failed - program is NULL")
        Note: Cleanup parser and lexer before returning
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source)
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Process imports: load and merge imported files
    Let import_result be process_imports(program)
    If import_result is not equal to 0:
        Note: Import processing failed
        program_destroy(program)
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source)
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Create code generator (equivalent to CodeGenerator *codegen = codegen_create(output_filename))
    Let codegen be codegen_create(output_filename)

    Note: Check if codegen creation failed (equivalent to !codegen)
    If codegen is equal to 0:
        Note: Cleanup resources before returning
        program_destroy(program)
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source)
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Generate code (equivalent to codegen_generate(codegen, program))
    codegen_generate(codegen, program)

    Note: Close output file to ensure content is written (flushes buffer)
    Let output_file be memory_get_integer(codegen, 0)
    file_close_buffered(output_file)

    Note: Print success message (equivalent to printf("Successfully compiled '%s' to '%s'\n", input_filename, output_filename))
    Let success_msg_temp be string_concat("Successfully compiled '", input_filename)
    Let success_msg_temp2 be string_concat(success_msg_temp, "' to '")
    deallocate(success_msg_temp)
    Let success_msg be string_concat(success_msg_temp2, output_filename)
    deallocate(success_msg_temp2)
    Let success_msg_final be string_concat(success_msg, "'")
    deallocate(success_msg)
    print_string(success_msg_final)
    deallocate(success_msg_final)

    Note: Cleanup resources (equivalent to C cleanup code)
    codegen_destroy(codegen)
    program_destroy(program)
    parser_destroy(parser)
    lexer_destroy(lexer)
    deallocate(source)
    deallocate(input_filename)
    deallocate(output_filename)

    Return 0
End Process