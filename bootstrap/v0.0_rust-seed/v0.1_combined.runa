Note: Combined v0.1 MicroRuna compiler modules for v0.0 bootstrap compilation

Note: === LEXER FUNCTIONS ===

Process called "is_letter" that takes char_code as Integer returns Integer:
    Note: Check if character is a letter
    If char_code is greater than 64:
        If char_code is less than 91:
            Return 1
        End If
    End If
    If char_code is greater than 96:
        If char_code is less than 123:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "is_digit" that takes char_code as Integer returns Integer:
    Note: Check if character is a digit 0 through 9
    If char_code is greater than 47:
        If char_code is less than 58:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "is_whitespace" that takes char_code as Integer returns Integer:
    Note: Check if character is whitespace space tab newline
    If char_code is equal to 32:
        Return 1
    End If
    If char_code is equal to 9:
        Return 1
    End If
    If char_code is equal to 10:
        Return 1
    End If
    If char_code is equal to 13:
        Return 1
    End If
    Return 0
End Process

Process called "create_token" that takes token_type as String, value as String, line as Integer, column as Integer returns String:
    Note: Create token string in pipe separated format
    Let result be token_type
    Set result to concat(result, "|")
    Set result to concat(result, value)
    Set result to concat(result, "|")
    Set result to concat(result, to_string(line))
    Set result to concat(result, "|")
    Set result to concat(result, to_string(column))
    Return result
End Process

Process called "parse_integer" that takes text as String returns Integer:
    Note: Manually parse string digits to integer value using repeated addition
    Let result be 0
    Let i be 0
    Let text_length be length_of(text)

    While i is less than text_length:
        Let current_char be char_at(text, i)
        If is_digit(current_char) is equal to 1:
            Let digit_value be current_char minus 48
            Let multiply_count be 0
            Let temp_result be result
            While multiply_count is less than 9:
                Set result to result plus temp_result
                Set multiply_count to multiply_count plus 1
            End While
            Set result to result plus digit_value
        End If
        Set i to i plus 1
    End While

    Return result
End Process

Process called "extract_word_value" that takes word_result as String returns String:
    Note: Extract word value from pipe separated result
    Let pipe_pos be 0
    Let result_length be length_of(word_result)

    While pipe_pos is less than result_length:
        Let current_char be char_at(word_result, pipe_pos)
        If current_char is equal to 124:
            Return substring(word_result, 0, pipe_pos)
        End If
        Set pipe_pos to pipe_pos plus 1
    End While

    Return word_result
End Process

Process called "extract_word_position" that takes word_result as String returns Integer:
    Note: Extract new position from pipe separated result
    Let pipe_pos be 0
    Let result_length be length_of(word_result)

    While pipe_pos is less than result_length:
        Let current_char be char_at(word_result, pipe_pos)
        If current_char is equal to 124:
            Let position_str be substring(word_result, pipe_pos plus 1, result_length)
            Return parse_integer(position_str)
        End If
        Set pipe_pos to pipe_pos plus 1
    End While

    Return 0
End Process

Process called "read_word" that takes source as String, start_pos as Integer returns String:
    Note: Read word from source starting at position and return word with new position
    Let end_pos be start_pos
    Let source_length be length_of(source)

    While end_pos is less than source_length:
        Let current_char be char_at(source, end_pos)
        If is_letter(current_char) is equal to 1:
            Set end_pos to end_pos plus 1
        End If
        If is_letter(current_char) is equal to 0:
            If is_digit(current_char) is equal to 1:
                Set end_pos to end_pos plus 1
            End If
            If is_digit(current_char) is equal to 0:
                Set end_pos to source_length
            End If
        End If
    End While

    Let word be substring(source, start_pos, end_pos)
    Let result be concat(word, "|")
    Set result to concat(result, to_string(end_pos))
    Return result
End Process

Process called "peek_next_word" that takes source as String, position as Integer returns String:
    Note: Peek at the next word without advancing position
    Let start_pos be position
    Let source_length be length_of(source)

    Note: Skip whitespace
    While start_pos is less than source_length:
        Let current_char be char_at(source, start_pos)
        If is_whitespace(current_char) is equal to 0:
            Set start_pos to source_length
        End If
        If is_whitespace(current_char) is equal to 1:
            Set start_pos to start_pos plus 1
        End If
    End While

    If start_pos is equal to source_length:
        Return ""
    End If

    Note: Read the word
    Let end_pos be start_pos
    While end_pos is less than source_length:
        Let current_char be char_at(source, end_pos)
        If is_letter(current_char) is equal to 1:
            Set end_pos to end_pos plus 1
        End If
        If is_letter(current_char) is equal to 0:
            Set end_pos to source_length
        End If
    End While

    Return substring(source, start_pos, end_pos)
End Process

Process called "classify_word_with_context" that takes word as String, source as String, position as Integer returns String:
    Note: Classify word as keyword or identifier with lookahead for compound tokens
    If word is equal to "is":
        Let next_word be peek_next_word(source, position)
        If next_word is equal to "equal":
            Let pos_after_equal be position plus length_of(next_word) plus 1
            Let word_after_equal be peek_next_word(source, pos_after_equal)
            If word_after_equal is equal to "to":
                Return "IsEqualTo|3"
            End If
        End If
        If next_word is equal to "not":
            Let pos_after_not be position plus length_of(next_word) plus 1
            Let word_after_not be peek_next_word(source, pos_after_not)
            If word_after_not is equal to "equal":
                Let pos_after_equal be pos_after_not plus length_of(word_after_not) plus 1
                Let word_after_equal be peek_next_word(source, pos_after_equal)
                If word_after_equal is equal to "to":
                    Return "IsNotEqualTo|4"
                End If
            End If
        End If
        If next_word is equal to "less":
            Let pos_after_less be position plus length_of(next_word) plus 1
            Let word_after_less be peek_next_word(source, pos_after_less)
            If word_after_less is equal to "than":
                Return "IsLessThan|3"
            End If
        End If
        If next_word is equal to "greater":
            Let pos_after_greater be position plus length_of(next_word) plus 1
            Let word_after_greater be peek_next_word(source, pos_after_greater)
            If word_after_greater is equal to "than":
                Return "IsGreaterThan|3"
            End If
        End If
        Return "Is"
    End If
    Return classify_word(word)
End Process

Process called "classify_word" that takes word as String returns String:
    Note: Classify word as keyword or identifier
    If word is equal to "Process":
        Return "Process"
    End If
    If word is equal to "called":
        Return "Called"
    End If
    If word is equal to "that":
        Return "That"
    End If
    If word is equal to "takes":
        Return "Takes"
    End If
    If word is equal to "as":
        Return "As"
    End If
    If word is equal to "returns":
        Return "Returns"
    End If
    If word is equal to "End":
        Return "End"
    End If
    If word is equal to "Let":
        Return "Let"
    End If
    If word is equal to "be":
        Return "Be"
    End If
    If word is equal to "Set":
        Return "Set"
    End If
    If word is equal to "to":
        Return "To"
    End If
    If word is equal to "If":
        Return "If"
    End If
    If word is equal to "While":
        Return "While"
    End If
    If word is equal to "Otherwise":
        Return "Otherwise"
    End If
    If word is equal to "For":
        Return "For"
    End If
    If word is equal to "Each":
        Return "Each"
    End If
    If word is equal to "in":
        Return "In"
    End If
    If word is equal to "Display":
        Return "Display"
    End If
    If word is equal to "Return":
        Return "Return"
    End If
    If word is equal to "Note":
        Return "Note"
    End If
    If word is equal to "Type":
        Return "Type"
    End If
    If word is equal to "list":
        Return "List"
    End If
    If word is equal to "containing":
        Return "Containing"
    End If
    If word is equal to "and":
        Return "And"
    End If
    If word is equal to "at":
        Return "At"
    End If
    If word is equal to "index":
        Return "Index"
    End If
    If word is equal to "key":
        Return "Key"
    End If
    If word is equal to "is":
        Return "Is"
    End If
    If word is equal to "equal":
        Return "Equal"
    End If
    If word is equal to "less":
        Return "Less"
    End If
    If word is equal to "than":
        Return "Than"
    End If
    If word is equal to "greater":
        Return "Greater"
    End If
    If word is equal to "plus":
        Return "Plus"
    End If
    If word is equal to "minus":
        Return "Minus"
    End If
    If word is equal to "not":
        Return "Not"
    End If
    If word is equal to "of":
        Return "Of"
    End If
    If word is equal to "a":
        Return "A"
    End If
    If word is equal to "value":
        Return "Value"
    End If
    If word is equal to "type":
        Return "TypeKeyword"
    End If
    If word is equal to "with":
        Return "With"
    End If
    If word is equal to "call":
        Return "Call"
    End If
    Return "Identifier"
End Process

Process called "read_number" that takes source as String, start_pos as Integer returns String:
    Note: Read number from source starting at position
    Let end_pos be start_pos
    Let source_length be length_of(source)

    While end_pos is less than source_length:
        Let current_char be char_at(source, end_pos)
        If is_digit(current_char) is equal to 1:
            Set end_pos to end_pos plus 1
        End If
        If is_digit(current_char) is equal to 0:
            Set end_pos to source_length
        End If
    End While

    Let number be substring(source, start_pos, end_pos)
    Let result be concat(number, "|")
    Set result to concat(result, to_string(end_pos))
    Return result
End Process

Process called "read_string" that takes source as String, start_pos as Integer returns String:
    Note: Read string literal from source starting at quote with escape sequence handling
    Let end_pos be start_pos plus 1
    Let source_length be length_of(source)
    Let processed_string be ""

    While end_pos is less than source_length:
        Let current_char be char_at(source, end_pos)

        Note: Check for escape sequence
        If current_char is equal to 92:
            Note: Backslash found, check next character
            If end_pos plus 1 is less than source_length:
                Let next_char be char_at(source, end_pos plus 1)

                Note: Process escape sequences
                If next_char is equal to 110:
                    Note: \n - newline
                    Let newline_char be 10
                    Set processed_string to concat(processed_string, substring(source, end_pos plus 1, end_pos plus 2))
                    Set processed_string to substring(processed_string, 0, length_of(processed_string) minus 1)
                    Note: Append actual newline character (ASCII 10)
                    Set end_pos to end_pos plus 2
                End If

                If next_char is equal to 116:
                    Note: \t - tab
                    Let tab_char be 9
                    Set processed_string to concat(processed_string, substring(source, end_pos plus 1, end_pos plus 2))
                    Set processed_string to substring(processed_string, 0, length_of(processed_string) minus 1)
                    Note: Append actual tab character (ASCII 9)
                    Set end_pos to end_pos plus 2
                End If

                If next_char is equal to 114:
                    Note: \r - carriage return
                    Let cr_char be 13
                    Set processed_string to concat(processed_string, substring(source, end_pos plus 1, end_pos plus 2))
                    Set processed_string to substring(processed_string, 0, length_of(processed_string) minus 1)
                    Note: Append actual CR character (ASCII 13)
                    Set end_pos to end_pos plus 2
                End If

                If next_char is equal to 92:
                    Note: \\ - backslash
                    Set processed_string to concat(processed_string, substring(source, end_pos plus 1, end_pos plus 2))
                    Set end_pos to end_pos plus 2
                End If

                If next_char is equal to 34:
                    Note: \" - quote
                    Set processed_string to concat(processed_string, substring(source, end_pos plus 1, end_pos plus 2))
                    Set end_pos to end_pos plus 2
                End If

                Note: If no recognized escape sequence, include backslash as-is
                If next_char is not equal to 110:
                    If next_char is not equal to 116:
                        If next_char is not equal to 114:
                            If next_char is not equal to 92:
                                If next_char is not equal to 34:
                                    Set processed_string to concat(processed_string, substring(source, end_pos, end_pos plus 1))
                                    Set end_pos to end_pos plus 1
                                End If
                            End If
                        End If
                    End If
                End If
            End If

            If end_pos plus 1 is equal to source_length:
                Set processed_string to concat(processed_string, substring(source, end_pos, end_pos plus 1))
                Set end_pos to end_pos plus 1
            End If
        End If

        Note: Check for closing quote
        If current_char is equal to 34:
            If current_char is not equal to 92:
                Let result be concat(processed_string, "|")
                Set result to concat(result, to_string(end_pos plus 1))
                Return result
            End If
        End If

        Note: Regular character
        If current_char is not equal to 92:
            If current_char is not equal to 34:
                Set processed_string to concat(processed_string, substring(source, end_pos, end_pos plus 1))
                Set end_pos to end_pos plus 1
            End If
        End If
    End While

    Note: Unterminated string
    Let result be concat(processed_string, "|")
    Set result to concat(result, to_string(source_length))
    Return result
End Process

Process called "append_token" that takes tokens as String, new_token as String returns String:
    Note: Append new token to token list with newline separator
    If length_of(tokens) is equal to 0:
        Return new_token
    End If
    Let result be concat(tokens, "\n")
    Set result to concat(result, new_token)
    Return result
End Process

Process called "tokenize_input" that takes source as String returns String:
    Note: Full tokenization implementation that scans source and generates tokens
    Let tokens be ""
    Let position be 0
    Let line be 1
    Let column be 1
    Let source_length be length_of(source)

    While position is less than source_length:
        Let current_char be char_at(source, position)

        If is_whitespace(current_char) is equal to 1:
            If current_char is equal to 10:
                Set line to line plus 1
                Set column to 1
            End If
            If current_char is not equal to 10:
                Set column to column plus 1
            End If
            Set position to position plus 1
        End If

        If is_whitespace(current_char) is equal to 0:
            If is_letter(current_char) is equal to 1:
                Let word_result be read_word(source, position)
                Let word be extract_word_value(word_result)
                Let new_position be extract_word_position(word_result)
                Let classification_result be classify_word_with_context(word, source, new_position)

                Note: Check if it's a compound token
                Let pipe_pos be 0
                Let has_pipe be 0
                Let result_length be length_of(classification_result)
                While pipe_pos is less than result_length:
                    If char_at(classification_result, pipe_pos) is equal to 124:
                        Set has_pipe to 1
                        Set pipe_pos to result_length
                    End If
                    Set pipe_pos to pipe_pos plus 1
                End While

                If has_pipe is equal to 1:
                    Note: It's a compound token, extract token type and word count
                    Let token_type be extract_word_value(classification_result)
                    Let word_count_str be extract_word_position(classification_result)
                    Let word_count be parse_integer(word_count_str)

                    Note: Build the compound value
                    Let compound_value be word
                    Let words_consumed be 1
                    Let temp_pos be new_position
                    While words_consumed is less than word_count:
                        Let next_word be peek_next_word(source, temp_pos)
                        Set compound_value to concat(compound_value, " ")
                        Set compound_value to concat(compound_value, next_word)

                        Note: Advance temp_pos past the next word
                        Let advance_amount be length_of(next_word) plus 1
                        Set temp_pos to temp_pos plus advance_amount
                        Set words_consumed to words_consumed plus 1
                    End While

                    Let token be create_token(token_type, compound_value, line, column)
                    Set tokens to append_token(tokens, token)
                    Set column to column plus length_of(compound_value)
                    Set position to temp_pos
                End If

                If has_pipe is equal to 0:
                    Let token_type be classification_result
                    Let token be create_token(token_type, word, line, column)
                    Set tokens to append_token(tokens, token)
                    Set column to column plus length_of(word)
                    Set position to new_position
                End If
            End If

            If is_digit(current_char) is equal to 1:
                Let number_result be read_number(source, position)
                Let number be extract_word_value(number_result)
                Let new_position be extract_word_position(number_result)
                Let token be create_token("Integer", number, line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus length_of(number)
                Set position to new_position
            End If

            If current_char is equal to 34:
                Let string_result be read_string(source, position)
                Let string_value be extract_word_value(string_result)
                Let new_position be extract_word_position(string_result)
                Let token be create_token("StringLiteral", string_value, line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus length_of(string_value) plus 2
                Set position to new_position
            End If

            If current_char is equal to 58:
                Let token be create_token("Colon", ":", line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus 1
                Set position to position plus 1
            End If

            If current_char is equal to 44:
                Let token be create_token("Comma", ",", line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus 1
                Set position to position plus 1
            End If

            If current_char is equal to 40:
                Let token be create_token("LeftParen", "(", line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus 1
                Set position to position plus 1
            End If

            If current_char is equal to 41:
                Let token be create_token("RightParen", ")", line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus 1
                Set position to position plus 1
            End If

            If current_char is equal to 46:
                Let token be create_token("Dot", ".", line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus 1
                Set position to position plus 1
            End If

            If is_letter(current_char) is equal to 0:
                If is_digit(current_char) is equal to 0:
                    If current_char is not equal to 34:
                        If current_char is not equal to 58:
                            If current_char is not equal to 44:
                                If current_char is not equal to 40:
                                    If current_char is not equal to 41:
                                        If current_char is not equal to 46:
                                            Set position to position plus 1
                                            Set column to column plus 1
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            End If
        End If
    End While

    Note: Add EOF token
    Let eof_token be create_token("EOF", "", line, column)
    Set tokens to append_token(tokens, eof_token)

    Return tokens
End Process

Note: === PARSER FUNCTIONS ===

Process called "get_token_at_position" that takes tokens as String, position as Integer returns String:
    Note: ExtractToken
    Let line_start be 0
    Let current_line be 0
    Let i be 0
    Let tokens_length be length_of(tokens)

    While i is less than tokens_length:
        Let char_code be char_at(tokens, i)
        If char_code is equal to 10:
            If current_line is equal to position:
                Return substring(tokens, line_start, i)
            End If
            Set current_line to current_line plus 1
            Set line_start to i plus 1
        End If
        Set i to i plus 1
    End While

    If current_line is equal to position:
        Return substring(tokens, line_start, tokens_length)
    End If
    Return "EOF|end|0|0"
End Process

Process called "extract_token_part" that takes token_data as String, part_index as Integer returns String:
    Note: ExtractTokenPart
    Let current_part be 0
    Let start_pos be 0
    Let i be 0
    Let token_length be length_of(token_data)

    While i is less than token_length:
        Let char_code be char_at(token_data, i)
        If char_code is equal to 124:
            If current_part is equal to part_index:
                Return substring(token_data, start_pos, i)
            End If
            Set current_part to current_part plus 1
            Set start_pos to i plus 1
        End If
        Set i to i plus 1
    End While

    If current_part is equal to part_index:
        Return substring(token_data, start_pos, token_length)
    End If
    Return ""
End Process

Process called "string_starts_with" that takes text as String, prefix as String returns Integer:
    Note: CheckStringPrefix
    Let text_len be length_of(text)
    Let prefix_len be length_of(prefix)

    If prefix_len is greater than text_len:
        Return 0
    End If

    Let i be 0
    While i is less than prefix_len:
        Let text_char be char_at(text, i)
        Let prefix_char be char_at(prefix, i)
        If text_char is not equal to prefix_char:
            Return 0
        End If
        Set i to i plus 1
    End While

    Return 1
End Process

Process called "append_string_with_separator" that takes base as String, addition as String, separator as String returns String:
    Note: AppendWithSeparator
    If length_of(base) is equal to 0:
        Return addition
    End If
    Let result be concat(base, separator)
    Return concat(result, addition)
End Process

Process called "count_lines" that takes text as String returns Integer:
    Note: CountLines
    Let count be 0
    Let i be 0
    Let text_length be length_of(text)

    While i is less than text_length:
        Let char_code be char_at(text, i)
        If char_code is equal to 10:
            Set count to count plus 1
        End If
        Set i to i plus 1
    End While

    Return count plus 1
End Process

Process called "parse_function_call" that takes tokens as String, position as Integer returns String:
    Note: ParseFunctionCall
    Let func_token be get_token_at_position(tokens, position)
    Let func_name be extract_token_part(func_token, 1)
    Let result be "function_call|"
    Set result to concat(result, func_name)
    Set result to concat(result, "|arguments")
    Return result
End Process

Process called "parse_list_literal" that takes tokens as String, position as Integer returns String:
    Note: Parse list literal: "a list containing x, y, z"
    Let current_pos be position

    Note: Skip "a"
    Set current_pos to current_pos plus 1

    Note: Expect "list"
    Let list_token be get_token_at_position(tokens, current_pos)
    Let list_value be extract_token_part(list_token, 1)
    If list_value is not equal to "list":
        Return "error_expected_list"
    End If
    Set current_pos to current_pos plus 1

    Note: Check for "containing"
    Let containing_token be get_token_at_position(tokens, current_pos)
    Let containing_value be extract_token_part(containing_token, 1)
    If containing_value is equal to "containing":
        Set current_pos to current_pos plus 1
    End If

    Note: Parse elements simplified for bootstrap
    Let elements be "element1|element2"
    Set current_pos to current_pos plus 3

    Let result be "list_literal|"
    Set result to concat(result, elements)
    Return result
End Process

Process called "parse_struct_creation" that takes tokens as String, position as Integer returns String:
    Note: Parse struct creation: "a value of type TypeName with field1 as value1, field2 as value2"
    Let current_pos be position

    Note: Skip "a"
    Set current_pos to current_pos plus 1

    Note: Expect "value"
    Let value_token be get_token_at_position(tokens, current_pos)
    Let value_word be extract_token_part(value_token, 1)
    If value_word is not equal to "value":
        Return "error_expected_value"
    End If
    Set current_pos to current_pos plus 1

    Note: Expect "of"
    Let of_token be get_token_at_position(tokens, current_pos)
    Let of_word be extract_token_part(of_token, 1)
    If of_word is equal to "of":
        Set current_pos to current_pos plus 1
    End If

    Note: Expect "type"
    Let type_token be get_token_at_position(tokens, current_pos)
    Let type_word be extract_token_part(type_token, 1)
    If type_word is equal to "type":
        Set current_pos to current_pos plus 1
    End If

    Note: Get the type name
    Let typename_token be get_token_at_position(tokens, current_pos)
    Let typename be extract_token_part(typename_token, 1)
    Set current_pos to current_pos plus 1

    Note: Check for "with" for field initialization
    Let with_token be get_token_at_position(tokens, current_pos)
    Let with_word be extract_token_part(with_token, 1)

    Let fields be ""
    If with_word is equal to "with":
        Set current_pos to current_pos plus 1

        Note: Parse field assignments simplified for bootstrap
        Set fields to "field1:value1|field2:value2"
        Set current_pos to current_pos plus 4
    End If

    Let result be "struct_creation|"
    Set result to concat(result, typename)
    Set result to concat(result, "|")
    Set result to concat(result, fields)
    Return result
End Process

Process called "parse_primary_expression" that takes tokens as String, position as Integer returns String:
    Note: ParsePrimaryExpression handles literals identifiers function calls field and index access
    Let current_token be get_token_at_position(tokens, position)
    Let token_type be extract_token_part(current_token, 0)
    Let token_value be extract_token_part(current_token, 1)

    If token_type is equal to "Integer":
        Return concat("integer_literal|", token_value)
    End If
    If token_type is equal to "StringLiteral":
        Return concat("string_literal|", token_value)
    End If
    If token_type is equal to "Identifier":
        Let base_expr be concat("identifier|", token_value)
        Let current_pos be position plus 1
        Let result be base_expr

        Note: Check for chained access (field access, index access, function calls)
        Let continue_parsing be 1
        While continue_parsing is equal to 1:
            Let next_token be get_token_at_position(tokens, current_pos)
            Let next_type be extract_token_part(next_token, 0)

            If next_type is equal to "LeftParen":
                Note: Function call
                Set result to concat("function_call|", token_value)
                Set result to concat(result, "|arguments")
                Set current_pos to current_pos plus 2
            Otherwise:
                If next_type is equal to "Dot":
                    Note: Field access
                    Let field_pos be current_pos plus 1
                    Let field_token be get_token_at_position(tokens, field_pos)
                    Let field_name be extract_token_part(field_token, 1)
                    Let field_result be "field_access|"
                    Set field_result to concat(field_result, result)
                    Set field_result to concat(field_result, "|")
                    Set field_result to concat(field_result, field_name)
                    Set result to field_result
                    Set current_pos to field_pos plus 1
                Otherwise:
                    If next_type is equal to "At":
                        Note: Index access using at index syntax
                        Let index_keyword_pos be current_pos plus 1
                        Let index_keyword be get_token_at_position(tokens, index_keyword_pos)
                        Let index_keyword_value be extract_token_part(index_keyword, 1)
                        If index_keyword_value is equal to "index":
                            Let index_expr_pos be index_keyword_pos plus 1
                            Let index_expr be parse_primary_expression(tokens, index_expr_pos)
                            Let index_result be "index_access|"
                            Set index_result to concat(index_result, result)
                            Set index_result to concat(index_result, "|")
                            Set index_result to concat(index_result, index_expr)
                            Set result to index_result
                            Set current_pos to index_expr_pos plus 1
                        Otherwise:
                            Set continue_parsing to 0
                        End If
                    Otherwise:
                        Set continue_parsing to 0
                    End If
                End If
            End If
        End While
        Return result
    End If

    Note: Handle "a list" and "a value of type" syntax
    If token_type is equal to "A":
        Let next_token be get_token_at_position(tokens, position plus 1)
        Let next_value be extract_token_part(next_token, 1)
        If next_value is equal to "list":
            Return parse_list_literal(tokens, position)
        End If
        If next_value is equal to "value":
            Return parse_struct_creation(tokens, position)
        End If
    End If

    Return "expression_error"
End Process

Process called "parse_additive_expression" that takes tokens as String, position as Integer returns String:
    Note: ParseAdditiveExpression
    Let left_expr be parse_primary_expression(tokens, position)
    Let operator_pos be position plus 1
    Let operator_token be get_token_at_position(tokens, operator_pos)
    Let operator_type be extract_token_part(operator_token, 0)

    If operator_type is equal to "Plus":
        Let right_pos be position plus 3
        Let right_expr be parse_primary_expression(tokens, right_pos)
        Let result be "binary_expression|"
        Set result to concat(result, left_expr)
        Set result to concat(result, "|Plus|")
        Set result to concat(result, right_expr)
        Return result
    End If

    If operator_type is equal to "Minus":
        Let right_pos be position plus 3
        Let right_expr be parse_primary_expression(tokens, right_pos)
        Let result be "binary_expression|"
        Set result to concat(result, left_expr)
        Set result to concat(result, "|Minus|")
        Set result to concat(result, right_expr)
        Return result
    End If

    Return left_expr
End Process

Process called "parse_comparison_expression" that takes tokens as String, position as Integer returns String:
    Note: ParseComparisonExpression
    Let left_expr be parse_additive_expression(tokens, position)
    Let operator_pos be position plus 1
    Let operator_token be get_token_at_position(tokens, operator_pos)
    Let operator_type be extract_token_part(operator_token, 0)

    If operator_type is equal to "IsEqualTo":
        Let right_pos be position plus 4
        Let right_expr be parse_additive_expression(tokens, right_pos)
        Let result be "comparison_expression|"
        Set result to concat(result, left_expr)
        Set result to concat(result, "|IsEqualTo|")
        Set result to concat(result, right_expr)
        Return result
    End If

    If operator_type is equal to "IsLessThan":
        Let right_pos be position plus 4
        Let right_expr be parse_additive_expression(tokens, right_pos)
        Let result be "comparison_expression|"
        Set result to concat(result, left_expr)
        Set result to concat(result, "|IsLessThan|")
        Set result to concat(result, right_expr)
        Return result
    End If

    Return left_expr
End Process

Process called "parse_expression" that takes tokens as String, position as Integer returns String:
    Note: ParseExpressionWithPrecedence
    Return parse_comparison_expression(tokens, position)
End Process

Process called "parse_condition" that takes tokens as String, position as Integer returns String:
    Note: ParseCondition
    Let left_expr be parse_expression(tokens, position)
    Let operator_position be position plus 1
    Let operator_token be get_token_at_position(tokens, operator_position)
    Let operator_type be extract_token_part(operator_token, 0)
    Let right_position be position plus 3
    Let right_expr be parse_expression(tokens, right_position)

    Let result be "binary_expression|"
    Set result to concat(result, left_expr)
    Set result to concat(result, "|")
    Set result to concat(result, operator_type)
    Set result to concat(result, "|")
    Set result to concat(result, right_expr)
    Return result
End Process

Process called "parse_note_statement" that takes tokens as String, position as Integer returns String:
    Note: ParseNoteStatement
    Let note_token be get_token_at_position(tokens, position)
    Let note_value be extract_token_part(note_token, 1)
    Let result be "note_statement|"
    Set result to concat(result, note_value)
    Return result
End Process

Process called "parse_let_statement" that takes tokens as String, position as Integer returns String:
    Note: ParseLetStatement
    Let var_token be get_token_at_position(tokens, position plus 1)
    Let var_name be extract_token_part(var_token, 1)
    Let expr_position be position plus 3
    Let expr_ast be parse_expression(tokens, expr_position)
    Let result be "let_statement|"
    Set result to concat(result, var_name)
    Set result to concat(result, "|")
    Set result to concat(result, expr_ast)
    Return result
End Process

Process called "parse_set_statement" that takes tokens as String, position as Integer returns String:
    Note: ParseSetStatement
    Let var_token be get_token_at_position(tokens, position plus 1)
    Let var_name be extract_token_part(var_token, 1)
    Let expr_position be position plus 3
    Let expr_ast be parse_expression(tokens, expr_position)
    Let result be "set_statement|"
    Set result to concat(result, var_name)
    Set result to concat(result, "|")
    Set result to concat(result, expr_ast)
    Return result
End Process

Process called "parse_display_statement" that takes tokens as String, position as Integer returns String:
    Note: ParseDisplayStatement
    Let expr_position be position plus 1
    Let expr_ast be parse_expression(tokens, expr_position)
    Let result be "display_statement|"
    Set result to concat(result, expr_ast)
    Return result
End Process

Process called "parse_return_statement" that takes tokens as String, position as Integer returns String:
    Note: ParseReturnStatement
    Let expr_position be position plus 1
    Let expr_ast be parse_expression(tokens, expr_position)
    Let result be "return_statement|"
    Set result to concat(result, expr_ast)
    Return result
End Process

Process called "parse_if_statement" that takes tokens as String, position as Integer returns String:
    Note: ParseIfStatement
    Let condition_position be position plus 1
    Let condition_ast be parse_condition(tokens, condition_position)
    Let result be "if_statement|"
    Set result to concat(result, condition_ast)
    Set result to concat(result, "|body_statements")
    Return result
End Process

Process called "parse_while_statement" that takes tokens as String, position as Integer returns String:
    Note: ParseWhileStatement
    Let condition_position be position plus 1
    Let condition_ast be parse_condition(tokens, condition_position)
    Let result be "while_statement|"
    Set result to concat(result, condition_ast)
    Set result to concat(result, "|body_statements")
    Return result
End Process

Process called "parse_process_definition" that takes tokens as String, position as Integer returns String:
    Note: ParseProcessDefinition
    Let name_token be get_token_at_position(tokens, position plus 2)
    Let process_name be extract_token_part(name_token, 1)
    Let result be "process_definition|"
    Set result to concat(result, process_name)
    Set result to concat(result, "|parameters|return_type|body_statements")
    Return result
End Process

Process called "parse_type_definition" that takes tokens as String, position as Integer returns String:
    Note: ParseTypeDefinition
    Let name_token be get_token_at_position(tokens, position plus 2)
    Let type_name be extract_token_part(name_token, 1)
    Let result be "type_definition|"
    Set result to concat(result, type_name)
    Set result to concat(result, "|fields")
    Return result
End Process


Process called "parse_statement" that takes tokens as String, position as Integer returns String:
    Note: ParseStatement
    Let current_token be get_token_at_position(tokens, position)
    Let token_type be extract_token_part(current_token, 0)

    If token_type is equal to "Let":
        Return parse_let_statement(tokens, position)
    End If
    If token_type is equal to "Set":
        Return parse_set_statement(tokens, position)
    End If
    If token_type is equal to "Display":
        Return parse_display_statement(tokens, position)
    End If
    If token_type is equal to "Return":
        Return parse_return_statement(tokens, position)
    End If
    If token_type is equal to "If":
        Return parse_if_statement(tokens, position)
    End If
    If token_type is equal to "While":
        Return parse_while_statement(tokens, position)
    End If
    If token_type is equal to "Process":
        Return parse_process_definition(tokens, position)
    End If
    If token_type is equal to "Type":
        Return parse_type_definition(tokens, position)
    End If
    If token_type is equal to "Note":
        Return parse_note_statement(tokens, position)
    End If

    Return "unknown_statement"
End Process

Process called "parse_program" that takes tokens as String returns String:
    Note: ParseProgram
    Let parsed_statements be ""
    Let current_position be 0
    Let max_tokens be count_lines(tokens)

    While current_position is less than max_tokens:
        Let current_token be get_token_at_position(tokens, current_position)
        Let token_type be extract_token_part(current_token, 0)

        If token_type is equal to "EOF":
            Set current_position to max_tokens
        End If
        If token_type is not equal to "EOF":
            Let stmt_result be parse_statement(tokens, current_position)
            Set parsed_statements to append_string_with_separator(parsed_statements, stmt_result, ";")
            Set current_position to current_position plus 1
        End If
    End While

    Return concat("program|", parsed_statements)
End Process

Note: === MAIN FUNCTIONS ===

Process called "compile_source" that takes source_code as String returns String:
    Note: MainCompilationPipeline
    Let tokens be tokenize_input(source_code)
    If length_of(tokens) is equal to 0:
        Return "ERROR: Tokenization failed"
    End If

    Let ast be parse_program(tokens)
    If length_of(ast) is equal to 0:
        Return "ERROR: Parsing failed"
    End If

    Let type_result be check_types(ast)
    If length_of(type_result) is equal to 0:
        Return "ERROR: Type checking failed"
    End If

    Let assembly_code be generate_code(ast)
    If length_of(assembly_code) is equal to 0:
        Return "ERROR: Code generation failed"
    End If

    Return assembly_code
End Process

Process called "compile_file" that takes filename as String returns String:
    Note: CompileSourceFile
    Let source_code be read_file(filename)
    If length_of(source_code) is equal to 0:
        Return "ERROR: Could not read file"
    End If
    Let compilation_result be compile_source(source_code)
    Return compilation_result
End Process

Process called "test_compiler":
    Note: TestCompilerFunction
    Let test_source be "Let x be 42\nDisplay x"
    Let result be compile_source(test_source)
    Display result

    Let test_result be compile_file("test.runa")
    Display test_result
End Process
