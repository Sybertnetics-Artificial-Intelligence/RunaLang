Note: MicroRuna Lexer built incrementally for v0.0 compatibility

Process called "is_letter" that takes char_code as Integer returns Integer:
    Note: Check if character is a letter
    If char_code is greater than 64:
        If char_code is less than 91:
            Return 1
        End If
    End If
    If char_code is greater than 96:
        If char_code is less than 123:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "is_digit" that takes char_code as Integer returns Integer:
    Note: Check if character is a digit 0 through 9
    If char_code is greater than 47:
        If char_code is less than 58:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "is_whitespace" that takes char_code as Integer returns Integer:
    Note: Check if character is whitespace space tab newline
    If char_code is equal to 32:
        Return 1
    End If
    If char_code is equal to 9:
        Return 1
    End If
    If char_code is equal to 10:
        Return 1
    End If
    If char_code is equal to 13:
        Return 1
    End If
    Return 0
End Process

Process called "create_token" that takes token_type as String, value as String, line as Integer, column as Integer returns String:
    Note: Create token string in pipe separated format
    Let result be token_type
    Set result to concat(result, "|")
    Set result to concat(result, value)
    Set result to concat(result, "|")
    Set result to concat(result, to_string(line))
    Set result to concat(result, "|")
    Set result to concat(result, to_string(column))
    Return result
End Process

Process called "parse_integer" that takes text as String returns Integer:
    Note: Manually parse string digits to integer value using repeated addition
    Let result be 0
    Let i be 0
    Let text_length be length_of(text)

    While i is less than text_length:
        Let current_char be char_at(text, i)
        If is_digit(current_char) is equal to 1:
            Let digit_value be current_char minus 48
            Let multiply_count be 0
            Let temp_result be result
            While multiply_count is less than 9:
                Set result to result plus temp_result
                Set multiply_count to multiply_count plus 1
            End While
            Set result to result plus digit_value
        End If
        Set i to i plus 1
    End While

    Return result
End Process

Process called "extract_word_value" that takes word_result as String returns String:
    Note: Extract word value from pipe separated result
    Let pipe_pos be 0
    Let result_length be length_of(word_result)

    While pipe_pos is less than result_length:
        Let current_char be char_at(word_result, pipe_pos)
        If current_char is equal to 124:
            Return substring(word_result, 0, pipe_pos)
        End If
        Set pipe_pos to pipe_pos plus 1
    End While

    Return word_result
End Process

Process called "extract_word_position" that takes word_result as String returns Integer:
    Note: Extract new position from pipe separated result
    Let pipe_pos be 0
    Let result_length be length_of(word_result)

    While pipe_pos is less than result_length:
        Let current_char be char_at(word_result, pipe_pos)
        If current_char is equal to 124:
            Let position_str be substring(word_result, pipe_pos plus 1, result_length)
            Return parse_integer(position_str)
        End If
        Set pipe_pos to pipe_pos plus 1
    End While

    Return 0
End Process

Process called "read_word" that takes source as String, start_pos as Integer returns String:
    Note: Read word from source starting at position and return word with new position
    Let end_pos be start_pos
    Let source_length be length_of(source)

    While end_pos is less than source_length:
        Let current_char be char_at(source, end_pos)
        If is_letter(current_char) is equal to 1:
            Set end_pos to end_pos plus 1
        End If
        If is_letter(current_char) is equal to 0:
            If is_digit(current_char) is equal to 1:
                Set end_pos to end_pos plus 1
            End If
            If is_digit(current_char) is equal to 0:
                Set end_pos to source_length
            End If
        End If
    End While

    Let word be substring(source, start_pos, end_pos)
    Let result be concat(word, "|")
    Set result to concat(result, to_string(end_pos))
    Return result
End Process

Process called "peek_next_word" that takes source as String, position as Integer returns String:
    Note: Peek at the next word without advancing position
    Let start_pos be position
    Let source_length be length_of(source)

    Note: Skip whitespace
    While start_pos is less than source_length:
        Let current_char be char_at(source, start_pos)
        If is_whitespace(current_char) is equal to 0:
            Set start_pos to source_length
        End If
        If is_whitespace(current_char) is equal to 1:
            Set start_pos to start_pos plus 1
        End If
    End While

    If start_pos is equal to source_length:
        Return ""
    End If

    Note: Read the word
    Let end_pos be start_pos
    While end_pos is less than source_length:
        Let current_char be char_at(source, end_pos)
        If is_letter(current_char) is equal to 1:
            Set end_pos to end_pos plus 1
        End If
        If is_letter(current_char) is equal to 0:
            Set end_pos to source_length
        End If
    End While

    Return substring(source, start_pos, end_pos)
End Process

Process called "classify_word_with_context" that takes word as String, source as String, position as Integer returns String:
    Note: Classify word as keyword or identifier with lookahead for compound tokens
    If word is equal to "is":
        Let next_word be peek_next_word(source, position)
        If next_word is equal to "equal":
            Let pos_after_equal be position plus length_of(next_word) plus 1
            Let word_after_equal be peek_next_word(source, pos_after_equal)
            If word_after_equal is equal to "to":
                Return "IsEqualTo|3"
            End If
        End If
        If next_word is equal to "not":
            Let pos_after_not be position plus length_of(next_word) plus 1
            Let word_after_not be peek_next_word(source, pos_after_not)
            If word_after_not is equal to "equal":
                Let pos_after_equal be pos_after_not plus length_of(word_after_not) plus 1
                Let word_after_equal be peek_next_word(source, pos_after_equal)
                If word_after_equal is equal to "to":
                    Return "IsNotEqualTo|4"
                End If
            End If
        End If
        If next_word is equal to "less":
            Let pos_after_less be position plus length_of(next_word) plus 1
            Let word_after_less be peek_next_word(source, pos_after_less)
            If word_after_less is equal to "than":
                Return "IsLessThan|3"
            End If
        End If
        If next_word is equal to "greater":
            Let pos_after_greater be position plus length_of(next_word) plus 1
            Let word_after_greater be peek_next_word(source, pos_after_greater)
            If word_after_greater is equal to "than":
                Return "IsGreaterThan|3"
            End If
        End If
        Return "Is"
    End If
    Return classify_word(word)
End Process

Process called "classify_word" that takes word as String returns String:
    Note: Classify word as keyword or identifier
    If word is equal to "Process":
        Return "Process"
    End If
    If word is equal to "called":
        Return "Called"
    End If
    If word is equal to "that":
        Return "That"
    End If
    If word is equal to "takes":
        Return "Takes"
    End If
    If word is equal to "as":
        Return "As"
    End If
    If word is equal to "returns":
        Return "Returns"
    End If
    If word is equal to "End":
        Return "End"
    End If
    If word is equal to "Let":
        Return "Let"
    End If
    If word is equal to "be":
        Return "Be"
    End If
    If word is equal to "Set":
        Return "Set"
    End If
    If word is equal to "to":
        Return "To"
    End If
    If word is equal to "If":
        Return "If"
    End If
    If word is equal to "While":
        Return "While"
    End If
    If word is equal to "Otherwise":
        Return "Otherwise"
    End If
    If word is equal to "For":
        Return "For"
    End If
    If word is equal to "Each":
        Return "Each"
    End If
    If word is equal to "in":
        Return "In"
    End If
    If word is equal to "Display":
        Return "Display"
    End If
    If word is equal to "Return":
        Return "Return"
    End If
    If word is equal to "Note":
        Return "Note"
    End If
    If word is equal to "Type":
        Return "Type"
    End If
    If word is equal to "list":
        Return "List"
    End If
    If word is equal to "containing":
        Return "Containing"
    End If
    If word is equal to "and":
        Return "And"
    End If
    If word is equal to "at":
        Return "At"
    End If
    If word is equal to "index":
        Return "Index"
    End If
    If word is equal to "key":
        Return "Key"
    End If
    If word is equal to "is":
        Return "Is"
    End If
    If word is equal to "equal":
        Return "Equal"
    End If
    If word is equal to "less":
        Return "Less"
    End If
    If word is equal to "than":
        Return "Than"
    End If
    If word is equal to "greater":
        Return "Greater"
    End If
    If word is equal to "plus":
        Return "Plus"
    End If
    If word is equal to "minus":
        Return "Minus"
    End If
    If word is equal to "not":
        Return "Not"
    End If
    If word is equal to "of":
        Return "Of"
    End If
    If word is equal to "a":
        Return "A"
    End If
    If word is equal to "value":
        Return "Value"
    End If
    If word is equal to "type":
        Return "TypeKeyword"
    End If
    If word is equal to "with":
        Return "With"
    End If
    If word is equal to "call":
        Return "Call"
    End If
    Return "Identifier"
End Process

Process called "read_number" that takes source as String, start_pos as Integer returns String:
    Note: Read number from source starting at position
    Let end_pos be start_pos
    Let source_length be length_of(source)

    While end_pos is less than source_length:
        Let current_char be char_at(source, end_pos)
        If is_digit(current_char) is equal to 1:
            Set end_pos to end_pos plus 1
        End If
        If is_digit(current_char) is equal to 0:
            Set end_pos to source_length
        End If
    End While

    Let number be substring(source, start_pos, end_pos)
    Let result be concat(number, "|")
    Set result to concat(result, to_string(end_pos))
    Return result
End Process

Process called "read_string" that takes source as String, start_pos as Integer returns String:
    Note: Read string literal from source starting at quote with escape sequence handling
    Let end_pos be start_pos plus 1
    Let source_length be length_of(source)
    Let processed_string be ""

    While end_pos is less than source_length:
        Let current_char be char_at(source, end_pos)

        Note: Check for escape sequence
        If current_char is equal to 92:
            Note: Backslash found, check next character
            If end_pos plus 1 is less than source_length:
                Let next_char be char_at(source, end_pos plus 1)

                Note: Process escape sequences
                If next_char is equal to 110:
                    Note: \n - newline
                    Let newline_char be 10
                    Set processed_string to concat(processed_string, substring(source, end_pos plus 1, end_pos plus 2))
                    Set processed_string to substring(processed_string, 0, length_of(processed_string) minus 1)
                    Note: Append actual newline character (ASCII 10)
                    Set end_pos to end_pos plus 2
                End If

                If next_char is equal to 116:
                    Note: \t - tab
                    Let tab_char be 9
                    Set processed_string to concat(processed_string, substring(source, end_pos plus 1, end_pos plus 2))
                    Set processed_string to substring(processed_string, 0, length_of(processed_string) minus 1)
                    Note: Append actual tab character (ASCII 9)
                    Set end_pos to end_pos plus 2
                End If

                If next_char is equal to 114:
                    Note: \r - carriage return
