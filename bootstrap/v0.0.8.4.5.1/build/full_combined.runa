Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Range Analysis for Optimal Type Inference
Note: This module implements compile-time value range tracking to automatically
Note: select the smallest integer type that safely holds all possible values.

Note: Range structure: min(int64 at 0), max(int64 at 8), is_unknown(int32 at 16)
Note: Total size: 20 bytes

Note: Type kind constants (matching parser.runa)
Let TYPE_INTEGER8 be 0
Let TYPE_INTEGER16 be 1
Let TYPE_INTEGER32 be 2
Let TYPE_INTEGER64 be 3
Let TYPE_INTEGER128 be 4
Let TYPE_UNSIGNED_INTEGER8 be 5
Let TYPE_UNSIGNED_INTEGER16 be 6
Let TYPE_UNSIGNED_INTEGER32 be 7
Let TYPE_UNSIGNED_INTEGER64 be 8
Let TYPE_UNSIGNED_INTEGER128 be 9
Let TYPE_FLOAT be 10
Let TYPE_FLOAT64 be 11
Let TYPE_POINTER be 12

Note: Integer bounds for type selection
Let INTEGER8_MIN be 0 minus 128
Let INTEGER8_MAX be 127
Let INTEGER16_MIN be 0 minus 32768
Let INTEGER16_MAX be 32767
Let INTEGER32_MIN be 0 minus 2147483648
Let INTEGER32_MAX be 2147483647
Note: INTEGER64_MIN/MAX would overflow in current system, handled specially

Let UNSIGNED_INTEGER8_MAX be 255
Let UNSIGNED_INTEGER16_MAX be 65535
Let UNSIGNED_INTEGER32_MAX be 4294967295

Note: Create a range with known bounds
Process called "range_create" takes min as Integer, max as Integer returns Integer:
    Let range be allocate(20)
    memory_set_integer(range, 0, min)
    memory_set_integer(range, 8, max)
    memory_set_int32(range, 16, 0)  Note: is_unknown = false
    Return range
End Process

Note: Create an unknown/unbounded range
Process called "range_create_unknown" returns Integer:
    Let range be allocate(20)
    memory_set_integer(range, 0, 0)
    memory_set_integer(range, 8, 0)
    memory_set_int32(range, 16, 1)  Note: is_unknown = true
    Return range
End Process

Note: Get minimum value from range
Process called "range_get_min" takes range as Integer returns Integer:
    Return memory_get_integer(range, 0)
End Process

Note: Get maximum value from range
Process called "range_get_max" takes range as Integer returns Integer:
    Return memory_get_integer(range, 8)
End Process

Note: Check if range is unknown
Process called "range_is_unknown" takes range as Integer returns Integer:
    Return memory_get_int32(range, 16)
End Process

Note: Add two ranges: [a_min + b_min, a_max + b_max]
Process called "range_add" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_min be range_get_min(a)
    Let a_max be range_get_max(a)
    Let b_min be range_get_min(b)
    Let b_max be range_get_max(b)

    Let result_min be a_min plus b_min
    Let result_max be a_max plus b_max

    Return range_create(result_min, result_max)
End Process

Note: Subtract two ranges: [a_min - b_max, a_max - b_min]
Process called "range_subtract" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_min be range_get_min(a)
    Let a_max be range_get_max(a)
    Let b_min be range_get_min(b)
    Let b_max be range_get_max(b)

    Let result_min be a_min minus b_max
    Let result_max be a_max minus b_min

    Return range_create(result_min, result_max)
End Process

Note: Multiply two ranges (handles sign changes)
Process called "range_multiply" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_min be range_get_min(a)
    Let a_max be range_get_max(a)
    Let b_min be range_get_min(b)
    Let b_max be range_get_max(b)

    Note: Calculate all four products (handles negative numbers)
    Let p1 be a_min multiplied by b_min
    Let p2 be a_min multiplied by b_max
    Let p3 be a_max multiplied by b_min
    Let p4 be a_max multiplied by b_max

    Note: Find minimum of four products
    Let result_min be p1
    If p2 is less than result_min:
        Set result_min to p2
    End If
    If p3 is less than result_min:
        Set result_min to p3
    End If
    If p4 is less than result_min:
        Set result_min to p4
    End If

    Note: Find maximum of four products
    Let result_max be p1
    If p2 is greater than result_max:
        Set result_max to p2
    End If
    If p3 is greater than result_max:
        Set result_max to p3
    End If
    If p4 is greater than result_max:
        Set result_max to p4
    End If

    Return range_create(result_min, result_max)
End Process

Note: Divide two ranges (handles sign changes, division by zero)
Process called "range_divide" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let b_min be range_get_min(b)
    Let b_max be range_get_max(b)

    Note: Check for division by zero
    If b_min is less than or equal to 0:
        If b_max is greater than or equal to 0:
            Note: Range includes zero - potential division by zero
            Return range_create_unknown()
        End If
    End If

    Let a_min be range_get_min(a)
    Let a_max be range_get_max(a)

    Note: Calculate all four quotients
    Let q1 be a_min divided by b_min
    Let q2 be a_min divided by b_max
    Let q3 be a_max divided by b_min
    Let q4 be a_max divided by b_max

    Note: Find minimum of four quotients
    Let result_min be q1
    If q2 is less than result_min:
        Set result_min to q2
    End If
    If q3 is less than result_min:
        Set result_min to q3
    End If
    If q4 is less than result_min:
        Set result_min to q4
    End If

    Note: Find maximum of four quotients
    Let result_max be q1
    If q2 is greater than result_max:
        Set result_max to q2
    End If
    If q3 is greater than result_max:
        Set result_max to q3
    End If
    If q4 is greater than result_max:
        Set result_max to q4
    End If

    Return range_create(result_min, result_max)
End Process

Note: Modulo range: [0, max(|a_max|, |b_max|) - 1]
Process called "range_modulo" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let b_max be range_get_max(b)
    Let b_min be range_get_min(b)

    Note: Get absolute values
    Let abs_b_max be b_max
    If b_max is less than 0:
        Set abs_b_max to 0 minus b_max
    End If

    Let abs_b_min be b_min
    If b_min is less than 0:
        Set abs_b_min to 0 minus b_min
    End If

    Let max_mod be abs_b_max
    If abs_b_min is greater than max_mod:
        Set max_mod to abs_b_min
    End If

    Let max_result be max_mod minus 1

    Return range_create(0, max_result)
End Process

Note: Union of two ranges: [min(a_min, b_min), max(a_max, b_max)]
Note: Used for merging ranges at control flow join points
Process called "range_union" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_min be range_get_min(a)
    Let a_max be range_get_max(a)
    Let b_min be range_get_min(b)
    Let b_max be range_get_max(b)

    Let result_min be a_min
    If b_min is less than result_min:
        Set result_min to b_min
    End If

    Let result_max be a_max
    If b_max is greater than result_max:
        Set result_max to b_max
    End If

    Return range_create(result_min, result_max)
End Process

Note: Intersection of two ranges: [max(a_min, b_min), min(a_max, b_max)]
Note: Used when refining ranges from conditionals
Process called "range_intersect" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return b
    End If
    If b_unknown is equal to 1:
        Return a
    End If

    Let a_min be range_get_min(a)
    Let a_max be range_get_max(a)
    Let b_min be range_get_min(b)
    Let b_max be range_get_max(b)

    Let result_min be a_min
    If b_min is greater than result_min:
        Set result_min to b_min
    End If

    Let result_max be a_max
    If b_max is less than result_max:
        Set result_max to b_max
    End If

    Note: Check if intersection is empty
    If result_min is greater than result_max:
        Note: Empty intersection - should not happen in valid code
        Return range_create_unknown()
    End If

    Return range_create(result_min, result_max)
End Process

Note: Select optimal type for a range
Process called "range_select_type" takes range as Integer returns Integer:
    Let is_unknown be range_is_unknown(range)
    If is_unknown is equal to 1:
        Return TYPE_INTEGER32  Note: Conservative default for unknown
    End If

    Let min be range_get_min(range)
    Let max be range_get_max(range)

    Note: Check if unsigned is better
    If min is greater than or equal to 0:
        Note: Non-negative range - consider unsigned types
        If max is less than or equal to UNSIGNED_INTEGER8_MAX:
            Return TYPE_UNSIGNED_INTEGER8
        End If
        If max is less than or equal to UNSIGNED_INTEGER16_MAX:
            Return TYPE_UNSIGNED_INTEGER16
        End If
        If max is less than or equal to UNSIGNED_INTEGER32_MAX:
            Return TYPE_UNSIGNED_INTEGER32
        End If
        Note: Larger than UnsignedInteger32, use UnsignedInteger64
        Return TYPE_UNSIGNED_INTEGER64
    End If

    Note: Signed range - check signed types
    If min is greater than or equal to INTEGER8_MIN:
        If max is less than or equal to INTEGER8_MAX:
            Return TYPE_INTEGER8
        End If
    End If

    If min is greater than or equal to INTEGER16_MIN:
        If max is less than or equal to INTEGER16_MAX:
            Return TYPE_INTEGER16
        End If
    End If

    If min is greater than or equal to INTEGER32_MIN:
        If max is less than or equal to INTEGER32_MAX:
            Return TYPE_INTEGER32
        End If
    End If

    Note: Larger than Integer32, use Integer64
    Return TYPE_INTEGER64
End Process

Note: Refine range based on comparison (for conditional analysis)
Note: op: 22=EQUAL, 23=NOT_EQUAL, 24=LESS, 25=GREATER, 26=GREATER_EQUAL, 27=LESS_EQUAL
Process called "range_refine_from_comparison" takes range as Integer, op as Integer, value as Integer returns Integer:
    Let is_unknown be range_is_unknown(range)
    If is_unknown is equal to 1:
        Note: Can't refine unknown range
        Return range
    End If

    Let min be range_get_min(range)
    Let max be range_get_max(range)

    If op is equal to 22:  Note: EQUAL
        Return range_create(value, value)
    Otherwise If op is equal to 24:  Note: LESS
        Let new_max be value minus 1
        If new_max is less than min:
            Note: Impossible condition
            Return range_create_unknown()
        End If
        Return range_create(min, new_max)
    Otherwise If op is equal to 27:  Note: LESS_EQUAL
        If value is less than min:
            Return range_create_unknown()
        End If
        Return range_create(min, value)
    Otherwise If op is equal to 25:  Note: GREATER
        Let new_min be value plus 1
        If new_min is greater than max:
            Return range_create_unknown()
        End If
        Return range_create(new_min, max)
    Otherwise If op is equal to 26:  Note: GREATER_EQUAL
        If value is greater than max:
            Return range_create_unknown()
        End If
        Return range_create(value, max)
    End If

    Note: NOT_EQUAL can't refine much, return original
    Return range
End Process

Note: Copy a range (for SSA)
Process called "range_copy" takes range as Integer returns Integer:
    Let is_unknown be range_is_unknown(range)
    If is_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let min be range_get_min(range)
    Let max be range_get_max(range)
    Return range_create(min, max)
End Process

Note: Check if range can overflow when assigned to a specific type
Process called "range_can_overflow" takes range as Integer, type_kind as Integer returns Integer:
    Let is_unknown be range_is_unknown(range)
    If is_unknown is equal to 1:
        Return 1  Note: Unknown range can potentially overflow
    End If

    Let min be range_get_min(range)
    Let max be range_get_max(range)

    If type_kind is equal to TYPE_INTEGER8:
        If min is less than INTEGER8_MIN:
            Return 1
        End If
        If max is greater than INTEGER8_MAX:
            Return 1
        End If
    Otherwise If type_kind is equal to TYPE_INTEGER16:
        If min is less than INTEGER16_MIN:
            Return 1
        End If
        If max is greater than INTEGER16_MAX:
            Return 1
        End If
    Otherwise If type_kind is equal to TYPE_INTEGER32:
        If min is less than INTEGER32_MIN:
            Return 1
        End If
        If max is greater than INTEGER32_MAX:
            Return 1
        End If
    Otherwise If type_kind is equal to TYPE_UNSIGNED_INTEGER8:
        If min is less than 0:
            Return 1
        End If
        If max is greater than UNSIGNED_INTEGER8_MAX:
            Return 1
        End If
    Otherwise If type_kind is equal to TYPE_UNSIGNED_INTEGER16:
        If min is less than 0:
            Return 1
        End If
        If max is greater than UNSIGNED_INTEGER16_MAX:
            Return 1
        End If
    Otherwise If type_kind is equal to TYPE_UNSIGNED_INTEGER32:
        If min is less than 0:
            Return 1
        End If
        If max is greater than UNSIGNED_INTEGER32_MAX:
            Return 1
        End If
    End If

    Return 0  Note: No overflow possible
End Process

Note: Debug: Print range for debugging
Process called "range_print" takes range as Integer returns Integer:
    Let is_unknown be range_is_unknown(range)
    If is_unknown is equal to 1:
        Display "[UNKNOWN]"
        Return 0
    End If

    Let min be range_get_min(range)
    Let max be range_get_max(range)

    Display "[", integer_to_string(min), ", ", integer_to_string(max), "]"
    Return 0
End Process
Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: SSA (Static Single Assignment) Transformation
Note: Converts variables to SSA form for precise range tracking

Note: SSA Variable: original_name + version number
Note: Example: x → x_0, x_1, x_2, ...

Note: Variable version table
Note: Maps variable name to current version number
Note: Structure: name -> version_number

Note: Create version table
Process called "version_table_create" returns Integer:
    Note: Simple list of (name, version) pairs
    Note: capacity(int32 at 0), size(int32 at 4), entries(ptr at 8)
    Let table be allocate(16)
    Let capacity be 64
    memory_set_int32(table, 0, capacity)
    memory_set_int32(table, 4, 0)

    Let entries_size be capacity multiplied by 16  Note: name(ptr) + version(int32)
    Let entries be allocate(entries_size)
    memory_set_pointer(table, 8, entries)

    Return table
End Process

Note: Get current version of variable
Process called "version_table_get" takes table as Integer, name as Integer returns Integer:
    Let size be memory_get_int32(table, 4)
    Let entries be memory_get_pointer(table, 8)

    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 16
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let version_offset be entry_offset plus 8
            Let version be memory_get_int32(entries, version_offset)
            Return version
        End If

        Set i to i plus 1
    End While

    Return 0  Note: First version
End Process

Note: Increment version of variable and return new version
Process called "version_table_increment" takes table as Integer, name as Integer returns Integer:
    Let size be memory_get_int32(table, 4)
    Let capacity be memory_get_int32(table, 0)
    Let entries be memory_get_pointer(table, 8)

    Note: Find existing entry
    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 16
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let version_offset be entry_offset plus 8
            Let old_version be memory_get_int32(entries, version_offset)
            Let new_version be old_version plus 1
            memory_set_int32(entries, version_offset, new_version)
            Return new_version
        End If

        Set i to i plus 1
    End While

    Note: Variable not found - add with version 1
    If size is equal to capacity:
        Display "ERROR: Version table capacity exceeded"
        exit_with_code(1)
    End If

    Let entry_offset be size multiplied by 16
    memory_set_pointer(entries, entry_offset, name)
    memory_set_int32(entries, entry_offset plus 8, 1)

    Let new_size be size plus 1
    memory_set_int32(table, 4, new_size)

    Return 1
End Process

Note: Create SSA variable name: "name_version"
Process called "ssa_var_name" takes name as Integer, version as Integer returns Integer:
    Let name_len be string_length(name)
    Let version_str be integer_to_string(version)
    Let version_len be string_length(version_str)

    Note: Allocate: name + "_" + version + null
    Let total_len be name_len plus version_len plus 2
    Let result be allocate(total_len)

    Note: Copy name
    Let i be 0
    While i is less than name_len:
        Let char be memory_get_byte(name, i)
        memory_set_byte(result, i, char)
        Set i to i plus 1
    End While

    Note: Add underscore
    memory_set_byte(result, name_len, 95)  Note: '_'

    Note: Copy version
    Let j be 0
    While j is less than version_len:
        Let char be memory_get_byte(version_str, j)
        memory_set_byte(result, name_len plus 1 plus j, char)
        Set j to j plus 1
    End While

    Note: Null terminator
    memory_set_byte(result, name_len plus version_len plus 1, 0)

    Return result
End Process

Note: Transform expression to SSA form
Process called "ssa_transform_expression" takes expr as Integer, versions as Integer returns Integer:
    Let expr_type be memory_get_int32(expr, 0)

    Let EXPR_IDENTIFIER be 2
    Let EXPR_BINARY_OP be 3
    Let EXPR_UNARY_MINUS be 5

    If expr_type is equal to EXPR_IDENTIFIER:
        Note: Replace identifier with SSA version
        Let name be memory_get_pointer(expr, 8)
        Let version be version_table_get(versions, name)
        Let ssa_name be ssa_var_name(name, version)

        Note: Create new identifier expression with SSA name
        Let new_expr be allocate(16)
        memory_set_int32(new_expr, 0, EXPR_IDENTIFIER)
        memory_set_pointer(new_expr, 8, ssa_name)

        Return new_expr

    Otherwise If expr_type is equal to EXPR_BINARY_OP:
        Note: Transform left and right operands
        Let left be memory_get_pointer(expr, 8)
        Let op be memory_get_int32(expr, 16)
        Let right be memory_get_pointer(expr, 24)

        Let new_left be ssa_transform_expression(left, versions)
        Let new_right be ssa_transform_expression(right, versions)

        Note: Create new binary op with transformed operands
        Let new_expr be allocate(32)
        memory_set_int32(new_expr, 0, EXPR_BINARY_OP)
        memory_set_pointer(new_expr, 8, new_left)
        memory_set_int32(new_expr, 16, op)
        memory_set_pointer(new_expr, 24, new_right)

        Return new_expr

    Otherwise If expr_type is equal to EXPR_UNARY_MINUS:
        Let operand be memory_get_pointer(expr, 8)
        Let new_operand be ssa_transform_expression(operand, versions)

        Let new_expr be allocate(16)
        memory_set_int32(new_expr, 0, EXPR_UNARY_MINUS)
        memory_set_pointer(new_expr, 8, new_operand)

        Return new_expr

    Otherwise:
        Note: Other expressions unchanged (literals, etc.)
        Return expr
    End If

    Return expr
End Process

Note: Transform statement to SSA form
Process called "ssa_transform_statement" takes stmt as Integer, versions as Integer returns Integer:
    Let stmt_type be memory_get_int32(stmt, 0)

    Let STMT_LET be 0
    Let STMT_SET be 1
    Let STMT_RETURN be 2

    If stmt_type is equal to STMT_LET:
        Note: Let statement: create new SSA version
        Let name be memory_get_pointer(stmt, 8)
        Let expr be memory_get_pointer(stmt, 16)

        Note: Transform expression
        Let new_expr be ssa_transform_expression(expr, versions)

        Note: Increment version and create SSA name
        Let new_version be version_table_increment(versions, name)
        Let ssa_name be ssa_var_name(name, new_version)

        Note: Create new Let statement with SSA name
        Let new_stmt be allocate(24)
        memory_set_int32(new_stmt, 0, STMT_LET)
        memory_set_pointer(new_stmt, 8, ssa_name)
        memory_set_pointer(new_stmt, 16, new_expr)

        Return new_stmt

    Otherwise If stmt_type is equal to STMT_SET:
        Note: Set statement: create new SSA version for target
        Let target be memory_get_pointer(stmt, 8)
        Let expr be memory_get_pointer(stmt, 16)

        Note: Transform expression
        Let new_expr be ssa_transform_expression(expr, versions)

        Note: Get target name (assume simple identifier)
        Let target_type be memory_get_int32(target, 0)
        Let EXPR_IDENTIFIER be 2
        If target_type is equal to EXPR_IDENTIFIER:
            Let name be memory_get_pointer(target, 8)

            Note: Increment version
            Let new_version be version_table_increment(versions, name)
            Let ssa_name be ssa_var_name(name, new_version)

            Note: Create new Let statement (Set becomes Let in SSA)
            Let new_stmt be allocate(24)
            memory_set_int32(new_stmt, 0, STMT_LET)
            memory_set_pointer(new_stmt, 8, ssa_name)
            memory_set_pointer(new_stmt, 16, new_expr)

            Return new_stmt
        End If

        Return stmt

    Otherwise If stmt_type is equal to STMT_RETURN:
        Let expr be memory_get_pointer(stmt, 8)
        Let new_expr be ssa_transform_expression(expr, versions)

        Let new_stmt be allocate(16)
        memory_set_int32(new_stmt, 0, STMT_RETURN)
        memory_set_pointer(new_stmt, 8, new_expr)

        Return new_stmt

    Otherwise:
        Note: Other statements unchanged for now
        Return stmt
    End If

    Return stmt
End Process

Note: Transform statement list to SSA form
Process called "ssa_transform_statements" takes stmt_list as Integer returns Integer:
    Let versions be version_table_create()

    Let count be list_length(stmt_list)
    Let new_list be list_create()

    Let i be 0
    While i is less than count:
        Let stmt be list_get(stmt_list, i)
        Let new_stmt be ssa_transform_statement(stmt, versions)
        Let dummy be list_append(new_list, new_stmt)
        Set i to i plus 1
    End While

    Return new_list
End Process

Note: PHI node for merging SSA variables at control flow joins
Note: phi_create(var_name, [version1, version2, ...])
Note: Represents: var_name_N = φ(var_name_version1, var_name_version2)
Process called "phi_create" takes name as Integer, versions as Integer, version_count as Integer returns Integer:
    Note: PHI node: name(ptr at 0), versions(ptr at 8), version_count(int32 at 16)
    Let phi be allocate(20)

    memory_set_pointer(phi, 0, name)
    memory_set_pointer(phi, 8, versions)
    memory_set_int32(phi, 16, version_count)

    Return phi
End Process

Note: Insert PHI nodes at merge points
Note: Simplified version - full implementation requires dominance frontiers
Process called "insert_phi_nodes" takes cfg as Integer, var_names as Integer, var_count as Integer returns Integer:
    Note: For each merge point (block with multiple predecessors)
    Note: For each variable
    Note: Insert PHI node

    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Let i be 0
    While i is less than block_count:
        Let offset be i multiplied by 8
        Let bb be memory_get_pointer(blocks, offset)
        Let pred_count be memory_get_int32(bb, 32)

        Note: If block has multiple predecessors, it's a merge point
        If pred_count is greater than 1:
            Note: Insert PHI nodes for all variables
            Let j be 0
            While j is less than var_count:
                Let var_offset be j multiplied by 8
                Let var_name be memory_get_pointer(var_names, var_offset)

                Note: TODO: Create PHI node and add to block
                Note: This requires tracking which versions come from which predecessor

                Set j to j plus 1
            End While
        End If

        Set i to i plus 1
    End While

    Return cfg
End Process
Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Control Flow Graph Builder
Note: Builds a CFG from AST for data flow analysis

Note: Basic Block structure
Note: bb_id(int32 at 0), statements(ptr at 8), stmt_count(int32 at 16),
Note: predecessors(ptr at 24), pred_count(int32 at 32),
Note: successors(ptr at 40), succ_count(int32 at 48)
Note: Total: 56 bytes

Note: CFG structure
Note: blocks(ptr at 0), block_count(int32 at 8), entry_block(int32 at 12), exit_block(int32 at 16)
Note: Total: 20 bytes

Let next_bb_id be 0

Note: Create a basic block
Process called "bb_create" returns Integer:
    Let bb be allocate(56)

    memory_set_int32(bb, 0, next_bb_id)
    Set next_bb_id to next_bb_id plus 1

    Note: Initialize statements list (capacity 16)
    Let stmts_capacity be 16
    Let stmts_size be stmts_capacity multiplied by 8
    Let stmts be allocate(stmts_size)
    memory_set_pointer(bb, 8, stmts)
    memory_set_int32(bb, 16, 0)  Note: stmt_count = 0

    Note: Initialize predecessors list (capacity 4)
    Let preds_capacity be 4
    Let preds_size be preds_capacity multiplied by 4
    Let preds be allocate(preds_size)
    memory_set_pointer(bb, 24, preds)
    memory_set_int32(bb, 32, 0)  Note: pred_count = 0

    Note: Initialize successors list (capacity 4)
    Let succs_capacity be 4
    Let succs_size be succs_capacity multiplied by 4
    Let succs be allocate(succs_size)
    memory_set_pointer(bb, 40, succs)
    memory_set_int32(bb, 48, 0)  Note: succ_count = 0

    Return bb
End Process

Note: Add statement to basic block
Process called "bb_add_statement" takes bb as Integer, stmt as Integer returns Integer:
    Let stmts be memory_get_pointer(bb, 8)
    Let stmt_count be memory_get_int32(bb, 16)

    Note: TODO: Handle capacity expansion
    If stmt_count is greater than or equal to 16:
        Display "ERROR: Basic block statement capacity exceeded"
        exit_with_code(1)
    End If

    Let offset be stmt_count multiplied by 8
    memory_set_pointer(stmts, offset, stmt)

    Let new_count be stmt_count plus 1
    memory_set_int32(bb, 16, new_count)

    Return bb
End Process

Note: Add edge from bb1 to bb2
Process called "bb_add_edge" takes bb1 as Integer, bb2 as Integer returns Integer:
    Note: Add bb2 as successor of bb1
    Let succs be memory_get_pointer(bb1, 40)
    Let succ_count be memory_get_int32(bb1, 48)

    If succ_count is greater than or equal to 4:
        Display "ERROR: Basic block successor capacity exceeded"
        exit_with_code(1)
    End If

    Let bb2_id be memory_get_int32(bb2, 0)
    Let offset be succ_count multiplied by 4
    memory_set_int32(succs, offset, bb2_id)

    Let new_succ_count be succ_count plus 1
    memory_set_int32(bb1, 48, new_succ_count)

    Note: Add bb1 as predecessor of bb2
    Let preds be memory_get_pointer(bb2, 24)
    Let pred_count be memory_get_int32(bb2, 32)

    If pred_count is greater than or equal to 4:
        Display "ERROR: Basic block predecessor capacity exceeded"
        exit_with_code(1)
    End If

    Let bb1_id be memory_get_int32(bb1, 0)
    Let pred_offset be pred_count multiplied by 4
    memory_set_int32(preds, pred_offset, bb1_id)

    Let new_pred_count be pred_count plus 1
    memory_set_int32(bb2, 32, new_pred_count)

    Return 0
End Process

Note: Create CFG
Process called "cfg_create" returns Integer:
    Let cfg be allocate(20)

    Note: Initialize blocks array (capacity 64)
    Let blocks_capacity be 64
    Let blocks_size be blocks_capacity multiplied by 8
    Let blocks be allocate(blocks_size)
    memory_set_pointer(cfg, 0, blocks)
    memory_set_int32(cfg, 8, 0)  Note: block_count = 0

    memory_set_int32(cfg, 12, 0 minus 1)  Note: entry_block = -1 (not set)
    memory_set_int32(cfg, 16, 0 minus 1)  Note: exit_block = -1 (not set)

    Return cfg
End Process

Note: Add basic block to CFG
Process called "cfg_add_block" takes cfg as Integer, bb as Integer returns Integer:
    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)

    If block_count is greater than or equal to 64:
        Display "ERROR: CFG block capacity exceeded"
        exit_with_code(1)
    End If

    Let offset be block_count multiplied by 8
    memory_set_pointer(blocks, offset, bb)

    Let new_count be block_count plus 1
    memory_set_int32(cfg, 8, new_count)

    Return cfg
End Process

Note: Get block by ID from CFG
Process called "cfg_get_block" takes cfg as Integer, bb_id as Integer returns Integer:
    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Let i be 0
    While i is less than block_count:
        Let offset be i multiplied by 8
        Let bb be memory_get_pointer(blocks, offset)
        Let id be memory_get_int32(bb, 0)

        If id is equal to bb_id:
            Return bb
        End If

        Set i to i plus 1
    End While

    Return 0  Note: Not found
End Process

Note: Build CFG from statement list
Note: Returns CFG with entry and exit blocks
Process called "build_cfg" takes stmt_list as Integer returns Integer:
    Let cfg be cfg_create()

    Note: Create entry and exit blocks
    Let entry_bb be bb_create()
    Let dummy1 be cfg_add_block(cfg, entry_bb)

    Let entry_id be memory_get_int32(entry_bb, 0)
    memory_set_int32(cfg, 12, entry_id)  Note: Set entry_block

    Note: Build CFG from statements
    Let current_bb be entry_bb
    Let stmt_count be list_length(stmt_list)

    Let i be 0
    While i is less than stmt_count:
        Let stmt be list_get(stmt_list, i)
        Let stmt_type be memory_get_int32(stmt, 0)

        Note: Statement types
        Let STMT_LET be 0
        Let STMT_SET be 1
        Let STMT_RETURN be 2
        Let STMT_IF be 3
        Let STMT_WHILE be 4
        Let STMT_FOR be 9
        Let STMT_BREAK be 6
        Let STMT_CONTINUE be 7

        If stmt_type is equal to STMT_IF:
            Note: If statement splits control flow
            Let condition be memory_get_pointer(stmt, 8)
            Let then_branch be memory_get_pointer(stmt, 16)
            Let else_branch be memory_get_pointer(stmt, 24)

            Note: Create blocks for then and else branches
            Let then_bb be bb_create()
            Let dummy2 be cfg_add_block(cfg, then_bb)

            Let else_bb be bb_create()
            Let dummy3 be cfg_add_block(cfg, else_bb)

            Note: Create merge block
            Let merge_bb be bb_create()
            Let dummy4 be cfg_add_block(cfg, merge_bb)

            Note: Add edges: current -> then, current -> else
            Let dummy5 be bb_add_edge(current_bb, then_bb)
            Let dummy6 be bb_add_edge(current_bb, else_bb)

            Note: Build then branch CFG
            Note: TODO: Recursively build sub-CFGs

            Note: Add edges: then -> merge, else -> merge
            Let dummy7 be bb_add_edge(then_bb, merge_bb)
            Let dummy8 be bb_add_edge(else_bb, merge_bb)

            Set current_bb to merge_bb

        Otherwise If stmt_type is equal to STMT_WHILE:
            Note: While loop creates back edge
            Note: TODO: Implement loop CFG

            Note: For now, create simple blocks
            Let loop_header be bb_create()
            Let dummy9 be cfg_add_block(cfg, loop_header)

            Let loop_body be bb_create()
            Let dummy10 be cfg_add_block(cfg, loop_body)

            Let loop_exit be bb_create()
            Let dummy11 be cfg_add_block(cfg, loop_exit)

            Note: Edges: current -> header
            Let dummy12 be bb_add_edge(current_bb, loop_header)

            Note: Edges: header -> body, header -> exit
            Let dummy13 be bb_add_edge(loop_header, loop_body)
            Let dummy14 be bb_add_edge(loop_header, loop_exit)

            Note: Back edge: body -> header
            Let dummy15 be bb_add_edge(loop_body, loop_header)

            Set current_bb to loop_exit

        Otherwise If stmt_type is equal to STMT_RETURN:
            Note: Return ends current block
            Let dummy16 be bb_add_statement(current_bb, stmt)

            Note: Create new block for any unreachable code after return
            Let new_bb be bb_create()
            Let dummy17 be cfg_add_block(cfg, new_bb)
            Set current_bb to new_bb

        Otherwise:
            Note: Regular statement - add to current block
            Let dummy18 be bb_add_statement(current_bb, stmt)
        End If

        Set i to i plus 1
    End While

    Note: Create exit block
    Let exit_bb be bb_create()
    Let dummy19 be cfg_add_block(cfg, exit_bb)

    Let exit_id be memory_get_int32(exit_bb, 0)
    memory_set_int32(cfg, 16, exit_id)  Note: Set exit_block

    Note: Connect current block to exit
    Let dummy20 be bb_add_edge(current_bb, exit_bb)

    Return cfg
End Process

Note: Print CFG for debugging
Process called "cfg_print" takes cfg as Integer returns Integer:
    Display "=== Control Flow Graph ==="

    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Let i be 0
    While i is less than block_count:
        Let offset be i multiplied by 8
        Let bb be memory_get_pointer(blocks, offset)
        Let bb_id be memory_get_int32(bb, 0)

        Display "Block ", integer_to_string(bb_id), ":"

        Note: Print predecessors
        Let pred_count be memory_get_int32(bb, 32)
        If pred_count is greater than 0:
            Display "  Predecessors: "
            Let preds be memory_get_pointer(bb, 24)
            Let j be 0
            While j is less than pred_count:
                Let pred_offset be j multiplied by 4
                Let pred_id be memory_get_int32(preds, pred_offset)
                Display integer_to_string(pred_id), " "
                Set j to j plus 1
            End While
        End If

        Note: Print successors
        Let succ_count be memory_get_int32(bb, 48)
        If succ_count is greater than 0:
            Display "  Successors: "
            Let succs be memory_get_pointer(bb, 40)
            Let k be 0
            While k is less than succ_count:
                Let succ_offset be k multiplied by 4
                Let succ_id be memory_get_int32(succs, succ_offset)
                Display integer_to_string(succ_id), " "
                Set k to k plus 1
            End While
        End If

        Set i to i plus 1
    End While

    Return 0
End Process

Note: ===== DOMINATOR ANALYSIS =====

Note: Dominator set structure - bitmap of dominating blocks
Note: For block i, dominators[i] is a bitset of blocks that dominate i
Note: Structure: block_count(int32 at 0), bitsets(ptr at 8)
Note: Each bitset is an array of int32s (32 bits per int)

Process called "domset_create" takes block_count as Integer returns Integer:
    Let domset be allocate(16)
    memory_set_int32(domset, 0, block_count)

    Note: Calculate size needed for bitsets
    Note: Each block needs block_count bits, rounded up to 32-bit chunks
    Let bits_per_int be 32
    Let ints_per_block be block_count divided by bits_per_int
    If block_count modulo bits_per_int is not equal to 0:
        Set ints_per_block to ints_per_block plus 1
    End If

    Note: Allocate array of bitsets (one per block)
    Let total_ints be block_count multiplied by ints_per_block
    Let bitsets_size be total_ints multiplied by 4
    Let bitsets be allocate(bitsets_size)
    memory_set_pointer(domset, 8, bitsets)

    Note: Initialize all bits to 0
    Let i be 0
    While i is less than total_ints:
        Let offset be i multiplied by 4
        memory_set_int32(bitsets, offset, 0)
        Set i to i plus 1
    End While

    Return domset
End Process

Note: Set bit in dominator set (mark block_id as dominating bb_id)
Process called "domset_set" takes domset as Integer, bb_id as Integer, dom_id as Integer returns Integer:
    Let block_count be memory_get_int32(domset, 0)
    Let bitsets be memory_get_pointer(domset, 8)

    Note: Calculate which int and which bit
    Let bits_per_int be 32
    Let ints_per_block be block_count divided by bits_per_int
    If block_count modulo bits_per_int is not equal to 0:
        Set ints_per_block to ints_per_block plus 1
    End If

    Let int_index be dom_id divided by bits_per_int
    Let bit_index be dom_id modulo bits_per_int

    Note: Calculate offset in bitsets array
    Let row_offset be bb_id multiplied by ints_per_block
    Let total_offset be row_offset plus int_index
    Let byte_offset be total_offset multiplied by 4

    Note: Read current value, set bit, write back
    Let current_value be memory_get_int32(bitsets, byte_offset)
    Let mask be 1
    Let shift_count be bit_index
    While shift_count is greater than 0:
        Set mask to mask multiplied by 2
        Set shift_count to shift_count minus 1
    End While

    Let new_value be current_value bit_or mask
    memory_set_int32(bitsets, byte_offset, new_value)

    Return domset
End Process

Note: Check if dom_id dominates bb_id
Process called "domset_contains" takes domset as Integer, bb_id as Integer, dom_id as Integer returns Integer:
    Let block_count be memory_get_int32(domset, 0)
    Let bitsets be memory_get_pointer(domset, 8)

    Note: Calculate which int and which bit
    Let bits_per_int be 32
    Let ints_per_block be block_count divided by bits_per_int
    If block_count modulo bits_per_int is not equal to 0:
        Set ints_per_block to ints_per_block plus 1
    End If

    Let int_index be dom_id divided by bits_per_int
    Let bit_index be dom_id modulo bits_per_int

    Note: Calculate offset in bitsets array
    Let row_offset be bb_id multiplied by ints_per_block
    Let total_offset be row_offset plus int_index
    Let byte_offset be total_offset multiplied by 4

    Note: Read value and check bit
    Let current_value be memory_get_int32(bitsets, byte_offset)
    Let mask be 1
    Let shift_count be bit_index
    While shift_count is greater than 0:
        Set mask to mask multiplied by 2
        Set shift_count to shift_count minus 1
    End While

    Let masked be current_value bit_and mask
    If masked is not equal to 0:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Note: Set dominator set to all blocks (for initialization)
Process called "domset_set_all" takes domset as Integer, bb_id as Integer returns Integer:
    Let block_count be memory_get_int32(domset, 0)

    Let i be 0
    While i is less than block_count:
        Let dummy be domset_set(domset, bb_id, i)
        Set i to i plus 1
    End While

    Return domset
End Process

Note: Compute intersection of two block's dominator sets and store in bb_id
Process called "domset_intersect" takes domset as Integer, bb_id as Integer, other_id as Integer returns Integer:
    Let block_count be memory_get_int32(domset, 0)
    Let bitsets be memory_get_pointer(domset, 8)

    Let bits_per_int be 32
    Let ints_per_block be block_count divided by bits_per_int
    If block_count modulo bits_per_int is not equal to 0:
        Set ints_per_block to ints_per_block plus 1
    End If

    Note: For each int in the bitset
    Let i be 0
    While i is less than ints_per_block:
        Note: Get offsets for both blocks
        Let bb_row_offset be bb_id multiplied by ints_per_block
        Let bb_offset be bb_row_offset plus i
        Let bb_byte_offset be bb_offset multiplied by 4

        Let other_row_offset be other_id multiplied by ints_per_block
        Let other_offset be other_row_offset plus i
        Let other_byte_offset be other_offset multiplied by 4

        Note: Read both values
        Let bb_value be memory_get_int32(bitsets, bb_byte_offset)
        Let other_value be memory_get_int32(bitsets, other_byte_offset)

        Note: Compute intersection
        Let intersect_value be bb_value bit_and other_value

        Note: Write back
        memory_set_int32(bitsets, bb_byte_offset, intersect_value)

        Set i to i plus 1
    End While

    Return domset
End Process

Note: Compute dominators using iterative algorithm
Process called "compute_dominators" takes cfg as Integer returns Integer:
    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)
    Let entry_id be memory_get_int32(cfg, 12)

    Note: Create dominator set structure
    Let domset be domset_create(block_count)

    Note: Initialize: entry dominates itself, all others dominate all blocks
    Let i be 0
    While i is less than block_count:
        If i is equal to entry_id:
            Note: Entry block dominates only itself
            Let dummy be domset_set(domset, entry_id, entry_id)
        Otherwise:
            Note: All other blocks initially dominate all blocks
            Let dummy2 be domset_set_all(domset, i)
        End If
        Set i to i plus 1
    End While

    Note: Iterative fixed-point computation
    Let changed be 1
    Let max_iterations be 100
    Let iteration be 0

    While changed is equal to 1:
        Set changed to 0
        Set iteration to iteration plus 1

        If iteration is greater than max_iterations:
            Display "ERROR: Dominator analysis did not converge"
            exit_with_code(1)
        End If

        Note: For each block (except entry)
        Let i be 0
        While i is less than block_count:
            If i is not equal to entry_id:
                Note: New dominators = {i} union (intersection of all predecessor dominators)
                Let bb be cfg_get_block(cfg, i)
                Let pred_count be memory_get_int32(bb, 32)

                If pred_count is greater than 0:
                    Note: Start with first predecessor's dominators
                    Let preds be memory_get_pointer(bb, 24)
                    Let first_pred_id be memory_get_int32(preds, 0)

                    Note: Create temp domset initialized to first pred
                    Let temp_domset be domset_create(block_count)
                    Let j be 0
                    While j is less than block_count:
                        Let is_dom be domset_contains(domset, first_pred_id, j)
                        If is_dom is equal to 1:
                            Let dummy3 be domset_set(temp_domset, 0, j)
                        End If
                        Set j to j plus 1
                    End While

                    Note: Intersect with remaining predecessors
                    Let k be 1
                    While k is less than pred_count:
                        Let pred_offset be k multiplied by 4
                        Let pred_id be memory_get_int32(preds, pred_offset)

                        Note: Intersect temp_domset with pred's dominators
                        Let m be 0
                        While m is less than block_count:
                            Let is_in_temp be domset_contains(temp_domset, 0, m)
                            Let is_in_pred be domset_contains(domset, pred_id, m)

                            If is_in_temp is equal to 1:
                                If is_in_pred is equal to 0:
                                    Note: Remove from temp (not in intersection)
                                    Note: Just skip it when copying
                                End If
                            End If
                            Set m to m plus 1
                        End While

                        Set k to k plus 1
                    End While

                    Note: Check if dominators changed
                    Let old_has_self be domset_contains(domset, i, i)
                    Let new_dominators_differ be 0

                    Note: Clear current dominators for block i
                    Let n be 0
                    While n is less than block_count:
                        Let old_dom be domset_contains(domset, i, n)
                        Let new_dom be domset_contains(temp_domset, 0, n)

                        If old_dom is not equal to new_dom:
                            Set new_dominators_differ to 1
                        End If
                        Set n to n plus 1
                    End While

                    Note: Copy temp to domset[i] and add i itself
                    Let p be 0
                    While p is less than block_count:
                        Let is_in_temp be domset_contains(temp_domset, 0, p)
                        Note: Clear and rebuild
                        Set p to p plus 1
                    End While

                    Note: Set dom(i) = temp union {i}
                    Let dummy4 be domset_set(domset, i, i)

                    If new_dominators_differ is equal to 1:
                        Set changed to 1
                    End If
                End If
            End If

            Set i to i plus 1
        End While
    End While

    Return domset
End Process

Note: Find immediate dominator of a block
Process called "find_idom" takes domset as Integer, cfg as Integer, bb_id as Integer returns Integer:
    Let block_count be memory_get_int32(cfg, 8)
    Let entry_id be memory_get_int32(cfg, 12)

    Note: Entry block has no immediate dominator
    If bb_id is equal to entry_id:
        Return 0 minus 1
    End If

    Note: Immediate dominator is the unique dominator != bb_id that dominates all other dominators
    Note: For simplicity: find the dominator with the longest path from entry

    Let idom be 0 minus 1
    Let max_distance be 0 minus 1

    Let i be 0
    While i is less than block_count:
        If i is not equal to bb_id:
            Let is_dom be domset_contains(domset, bb_id, i)
            If is_dom is equal to 1:
                Note: i dominates bb_id
                Note: For now, just pick the last one found (not fully correct)
                Set idom to i
            End If
        End If
        Set i to i plus 1
    End While

    Return idom
End Process

Note: Find merge points (blocks with multiple predecessors)
Process called "find_merge_points" takes cfg as Integer returns Integer:
    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Note: Create list to store merge point block IDs
    Let merge_points be list_create()

    Let i be 0
    While i is less than block_count:
        Let bb be cfg_get_block(cfg, i)
        Let pred_count be memory_get_int32(bb, 32)

        Note: Block is a merge point if it has 2+ predecessors
        If pred_count is greater than 1:
            Let bb_id be memory_get_int32(bb, 0)
            Let dummy be list_append(merge_points, bb_id)
        End If

        Set i to i plus 1
    End While

    Return merge_points
End Process

Note: Print dominator information for debugging
Process called "print_dominators" takes domset as Integer, cfg as Integer returns Integer:
    Display "=== Dominator Analysis ==="

    Let block_count be memory_get_int32(cfg, 8)

    Let i be 0
    While i is less than block_count:
        Display "Block ", integer_to_string(i), " dominated by: "

        Let j be 0
        While j is less than block_count:
            Let is_dom be domset_contains(domset, i, j)
            If is_dom is equal to 1:
                Display integer_to_string(j), " "
            End If
            Set j to j plus 1
        End While

        Display ""

        Note: Print immediate dominator
        Let idom be find_idom(domset, cfg, i)
        If idom is not equal to 0 minus 1:
            Display "  Immediate dominator: ", integer_to_string(idom)
        End If

        Set i to i plus 1
    End While

    Return 0
End Process

Note: ===== LOOP DETECTION AND ANALYSIS =====

Note: Loop structure
Note: header_id(int32 at 0), body_ids(ptr at 8), exit_id(int32 at 16), loop_type(int32 at 20)
Note: For FOR loops: init_stmt(ptr at 24), condition_expr(ptr at 32), update_stmt(ptr at 40)
Note: For WHILE loops: condition_expr(ptr at 32)

Let LOOP_TYPE_FOR be 0
Let LOOP_TYPE_WHILE be 1

Process called "loop_create" takes loop_type as Integer returns Integer:
    Let loop be allocate(48)
    memory_set_int32(loop, 0, 0 minus 1)  Note: header_id = -1
    memory_set_pointer(loop, 8, list_create())  Note: body_ids
    memory_set_int32(loop, 16, 0 minus 1)  Note: exit_id = -1
    memory_set_int32(loop, 20, loop_type)
    memory_set_pointer(loop, 24, 0)  Note: init_stmt = null
    memory_set_pointer(loop, 32, 0)  Note: condition_expr = null
    memory_set_pointer(loop, 40, 0)  Note: update_stmt = null
    Return loop
End Process

Note: Detect loops in CFG (finds back edges)
Process called "detect_loops" takes cfg as Integer, domset as Integer returns Integer:
    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Note: Create list to store detected loops
    Let loops be list_create()

    Note: A back edge is an edge from block N to block H where H dominates N
    Note: H is the loop header, N is in the loop body

    Let i be 0
    While i is less than block_count:
        Let bb be cfg_get_block(cfg, i)
        Let bb_id be memory_get_int32(bb, 0)

        Note: Check all successors
        Let succ_count be memory_get_int32(bb, 48)
        Let succs be memory_get_pointer(bb, 40)

        Let j be 0
        While j is less than succ_count:
            Let succ_offset be j multiplied by 4
            Let succ_id be memory_get_int32(succs, succ_offset)

            Note: Check if succ dominates bb (back edge!)
            Let is_dominator be domset_contains(domset, bb_id, succ_id)

            If is_dominator is equal to 1:
                Note: Found back edge: bb_id -> succ_id
                Note: succ_id is loop header

                Note: Create loop structure
                Let loop be loop_create(LOOP_TYPE_WHILE)  Note: Default to WHILE, will refine
                memory_set_int32(loop, 0, succ_id)  Note: header_id

                Note: Add to loops list
                Let dummy be list_append(loops, loop)
            End If

            Set j to j plus 1
        End While

        Set i to i plus 1
    End While

    Return loops
End Process

Note: Extract For loop bounds from AST
Process called "extract_for_loop_bounds" takes for_stmt as Integer returns Integer:
    Note: For statement: type(int32 at 0), init(ptr at 8), condition(ptr at 16), update(ptr at 24), body(ptr at 32)

    Let init_stmt be memory_get_pointer(for_stmt, 8)
    Let condition_expr be memory_get_pointer(for_stmt, 16)
    Let update_stmt be memory_get_pointer(for_stmt, 24)

    Note: Create bounds structure: loop_var(ptr at 0), start_value(ptr at 8), end_value(ptr at 16), step(int at 24)
    Let bounds be allocate(32)
    memory_set_pointer(bounds, 0, 0)  Note: loop_var = null
    memory_set_pointer(bounds, 8, 0)  Note: start_value = null
    memory_set_pointer(bounds, 16, 0)  Note: end_value = null
    memory_set_int32(bounds, 24, 1)  Note: step = 1 (default)

    Note: Extract loop variable from init statement
    If init_stmt is not equal to 0:
        Let init_type be memory_get_int32(init_stmt, 0)
        Let STMT_LET be 0

        If init_type is equal to STMT_LET:
            Note: Let i be 0
            Let var_name be memory_get_pointer(init_stmt, 8)
            Let start_expr be memory_get_pointer(init_stmt, 16)

            memory_set_pointer(bounds, 0, var_name)
            memory_set_pointer(bounds, 8, start_expr)
        End If
    End If

    Note: Extract end condition from condition expression
    If condition_expr is not equal to 0:
        Let cond_type be memory_get_int32(condition_expr, 0)
        Let EXPR_BINARY_OP be 3

        If cond_type is equal to EXPR_BINARY_OP:
            Note: i < 10
            Let left be memory_get_pointer(condition_expr, 8)
            Let op be memory_get_int32(condition_expr, 16)
            Let right be memory_get_pointer(condition_expr, 24)

            Note: Assume right side is the bound
            memory_set_pointer(bounds, 16, right)
        End If
    End If

    Note: Extract step from update statement
    If update_stmt is not equal to 0:
        Let update_type be memory_get_int32(update_stmt, 0)
        Let STMT_SET be 1

        If update_type is equal to STMT_SET:
            Note: Set i to i plus 1
            Let update_expr be memory_get_pointer(update_stmt, 16)
            Let update_expr_type be memory_get_int32(update_expr, 0)
            Let EXPR_BINARY_OP be 3

            If update_expr_type is equal to EXPR_BINARY_OP:
                Let update_op be memory_get_int32(update_expr, 16)
                Let TOKEN_PLUS be 16
                Let TOKEN_MINUS be 17

                If update_op is equal to TOKEN_PLUS:
                    Note: i plus 1 means step = 1 (already default)
                    Let step_expr be memory_get_pointer(update_expr, 24)
                    Let step_type be memory_get_int32(step_expr, 0)
                    Let EXPR_INTEGER_LITERAL be 0

                    If step_type is equal to EXPR_INTEGER_LITERAL:
                        Let step_str be memory_get_pointer(step_expr, 8)
                        Let step_value be string_to_integer(step_str)
                        memory_set_int32(bounds, 24, step_value)
                    End If
                Otherwise If update_op is equal to TOKEN_MINUS:
                    Note: i minus 1 means step = -1
                    Let step_expr be memory_get_pointer(update_expr, 24)
                    Let step_type be memory_get_int32(step_expr, 0)
                    Let EXPR_INTEGER_LITERAL be 0

                    If step_type is equal to EXPR_INTEGER_LITERAL:
                        Let step_str be memory_get_pointer(step_expr, 8)
                        Let step_value be string_to_integer(step_str)
                        Let neg_step be 0 minus step_value
                        memory_set_int32(bounds, 24, neg_step)
                    End If
                End If
            End If
        End If
    End If

    Return bounds
End Process

Note: Compute range for For loop variable
Process called "compute_for_loop_range" takes bounds as Integer, env as Integer returns Integer:
    Let start_expr be memory_get_pointer(bounds, 8)
    Let end_expr be memory_get_pointer(bounds, 16)
    Let step be memory_get_int32(bounds, 24)

    Note: Compute start and end ranges
    If start_expr is equal to 0:
        Return range_create_unknown()
    End If
    If end_expr is equal to 0:
        Return range_create_unknown()
    End If

    Let start_range be infer_expression_range(start_expr, env)
    Let end_range be infer_expression_range(end_expr, env)

    Let start_is_unknown be range_is_unknown(start_range)
    Let end_is_unknown be range_is_unknown(end_range)

    If start_is_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If end_is_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Note: Get concrete values
    Let start_min be range_get_min(start_range)
    Let start_max be range_get_max(start_range)
    Let end_min be range_get_min(end_range)
    Let end_max be range_get_max(end_range)

    Note: Loop variable ranges from start to end (exclusive)
    Note: Conservative: use widest possible range
    Let loop_min be start_min
    Let loop_max be end_max

    Note: Adjust for step direction
    If step is less than 0:
        Note: Counting down: loop var goes from start_max down to end_min
        Set loop_min to end_min
        Set loop_max to start_max
    End If

    Return range_create(loop_min, loop_max)
End Process

Note: Detect natural loops (all blocks dominated by loop header and reachable from back edge)
Process called "find_natural_loop_body" takes cfg as Integer, domset as Integer, header_id as Integer, back_edge_source as Integer returns Integer:
    Note: Natural loop = all blocks X such that header dominates X and X can reach back_edge_source

    Let body_blocks be list_create()
    Let dummy be list_append(body_blocks, header_id)
    Let dummy2 be list_append(body_blocks, back_edge_source)

    Note: Worklist algorithm: start from back_edge_source, walk backwards
    Let worklist be list_create()
    Let dummy3 be list_append(worklist, back_edge_source)

    While list_length(worklist) is greater than 0:
        Let current_id be list_get(worklist, 0)
        Let dummy4 be list_remove_at(worklist, 0)

        Let current_bb be cfg_get_block(cfg, current_id)
        Let pred_count be memory_get_int32(current_bb, 32)
        Let preds be memory_get_pointer(current_bb, 24)

        Let i be 0
        While i is less than pred_count:
            Let pred_offset be i multiplied by 4
            Let pred_id be memory_get_int32(preds, pred_offset)

            Note: Check if pred is dominated by header
            Let is_dominated be domset_contains(domset, pred_id, header_id)

            If is_dominated is equal to 1:
                Note: Check if already in body_blocks
                Let already_added be 0
                Let j be 0
                While j is less than list_length(body_blocks):
                    Let existing_id be list_get(body_blocks, j)
                    If existing_id is equal to pred_id:
                        Set already_added to 1
                    End If
                    Set j to j plus 1
                End While

                If already_added is equal to 0:
                    Let dummy5 be list_append(body_blocks, pred_id)
                    Let dummy6 be list_append(worklist, pred_id)
                End If
            End If

            Set i to i plus 1
        End While
    End While

    Return body_blocks
End Process

Note: Print loop information for debugging
Process called "print_loops" takes loops as Integer returns Integer:
    Display "=== Loop Analysis ==="

    Let loop_count be list_length(loops)
    Display "Found ", integer_to_string(loop_count), " loops"

    Let i be 0
    While i is less than loop_count:
        Let loop be list_get(loops, i)
        Let header_id be memory_get_int32(loop, 0)
        Let loop_type be memory_get_int32(loop, 20)

        Display "Loop ", integer_to_string(i), ":"
        Display "  Header: ", integer_to_string(header_id)

        If loop_type is equal to LOOP_TYPE_FOR:
            Display "  Type: FOR"
        Otherwise If loop_type is equal to LOOP_TYPE_WHILE:
            Display "  Type: WHILE"
        End If

        Set i to i plus 1
    End While

    Return 0
End Process
Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Data Flow Analysis with Fixed-Point Iteration
Note: Computes ranges for all variables across all control flow paths

Note: Data flow state for a basic block
Note: in_state(ptr at 0), out_state(ptr at 8)
Note: Each state is a variable environment (name -> range)

Note: Create data flow state for block
Process called "df_state_create" returns Integer:
    Let state be allocate(16)
    Let in_env be var_env_create()
    Let out_env be var_env_create()

    memory_set_pointer(state, 0, in_env)
    memory_set_pointer(state, 8, out_env)

    Return state
End Process

Note: Get in-state
Process called "df_state_get_in" takes state as Integer returns Integer:
    Return memory_get_pointer(state, 0)
End Process

Note: Get out-state
Process called "df_state_get_out" takes state as Integer returns Integer:
    Return memory_get_pointer(state, 8)
End Process

Note: Set in-state
Process called "df_state_set_in" takes state as Integer, env as Integer returns Integer:
    memory_set_pointer(state, 0, env)
    Return state
End Process

Note: Set out-state
Process called "df_state_set_out" takes state as Integer, env as Integer returns Integer:
    memory_set_pointer(state, 8, env)
    Return state
End Process

Note: Data flow analysis context
Note: cfg(ptr at 0), block_states(ptr at 8), worklist(ptr at 16), iteration_count(int32 at 24)
Process called "df_context_create" takes cfg as Integer returns Integer:
    Let context be allocate(28)

    memory_set_pointer(context, 0, cfg)

    Note: Create state for each block
    Let block_count be memory_get_int32(cfg, 8)
    Let states_size be block_count multiplied by 8
    Let states be allocate(states_size)

    Let i be 0
    While i is less than block_count:
        Let state be df_state_create()
        Let offset be i multiplied by 8
        memory_set_pointer(states, offset, state)
        Set i to i plus 1
    End While

    memory_set_pointer(context, 8, states)

    Note: Create worklist (initially contains all blocks)
    Let worklist be list_create()
    Let j be 0
    While j is less than block_count:
        Let dummy be list_append(worklist, j)
        Set j to j plus 1
    End While

    memory_set_pointer(context, 16, worklist)
    memory_set_int32(context, 24, 0)  Note: iteration_count = 0

    Return context
End Process

Note: Get state for block ID
Process called "df_get_block_state" takes context as Integer, bb_id as Integer returns Integer:
    Let states be memory_get_pointer(context, 8)
    Let offset be bb_id multiplied by 8
    Return memory_get_pointer(states, offset)
End Process

Note: Transfer function: compute out-state from in-state for a block
Process called "df_transfer" takes bb as Integer, in_env as Integer returns Integer:
    Note: Start with copy of in-state
    Let out_env be var_env_copy(in_env)

    Note: Apply each statement in block
    Let stmts be memory_get_pointer(bb, 8)
    Let stmt_count be memory_get_int32(bb, 16)

    Let i be 0
    While i is less than stmt_count:
        Let offset be i multiplied by 8
        Let stmt be memory_get_pointer(stmts, offset)

        Note: Analyze statement and update environment
        Set out_env to analyze_statement(stmt, out_env)

        Set i to i plus 1
    End While

    Return out_env
End Process

Note: Merge in-state from all predecessors
Process called "df_merge_predecessors" takes context as Integer, bb as Integer returns Integer:
    Let cfg be memory_get_pointer(context, 0)
    Let preds be memory_get_pointer(bb, 24)
    Let pred_count be memory_get_int32(bb, 32)

    If pred_count is equal to 0:
        Note: No predecessors - use empty environment
        Return var_env_create()
    End If

    Note: Get out-state of first predecessor
    Let first_pred_id be memory_get_int32(preds, 0)
    Let first_pred_state be df_get_block_state(context, first_pred_id)
    Let first_pred_out be df_state_get_out(first_pred_state)

    Let merged_env be var_env_copy(first_pred_out)

    Note: Merge with remaining predecessors
    Let i be 1
    While i is less than pred_count:
        Let pred_offset be i multiplied by 4
        Let pred_id be memory_get_int32(preds, pred_offset)
        Let pred_state be df_get_block_state(context, pred_id)
        Let pred_out be df_state_get_out(pred_state)

        Set merged_env to var_env_merge(merged_env, pred_out)

        Set i to i plus 1
    End While

    Return merged_env
End Process

Note: Check if two environments are equal (for convergence check)
Process called "env_equals" takes env1 as Integer, env2 as Integer returns Integer:
    Let size1 be memory_get_int32(env1, 4)
    Let size2 be memory_get_int32(env2, 4)

    If size1 is not equal to size2:
        Return 0  Note: Not equal
    End If

    Let entries1 be memory_get_pointer(env1, 8)

    Let i be 0
    While i is less than size1:
        Let entry_offset be i multiplied by 16
        Let name be memory_get_pointer(entries1, entry_offset)
        Let range1 be memory_get_pointer(entries1, entry_offset plus 8)

        Note: Look up in env2
        Let range2 be var_env_lookup(env2, name)

        Note: Compare ranges
        Let r1_min be range_get_min(range1)
        Let r1_max be range_get_max(range1)
        Let r2_min be range_get_min(range2)
        Let r2_max be range_get_max(range2)

        If r1_min is not equal to r2_min:
            Return 0
        End If
        If r1_max is not equal to r2_max:
            Return 0
        End If

        Set i to i plus 1
    End While

    Return 1  Note: Equal
End Process

Note: Process one block in the worklist
Process called "df_process_block" takes context as Integer, bb_id as Integer returns Integer:
    Let cfg be memory_get_pointer(context, 0)
    Let bb be cfg_get_block(cfg, bb_id)

    Let state be df_get_block_state(context, bb_id)

    Note: Merge in-state from predecessors
    Let new_in be df_merge_predecessors(context, bb)

    Note: Apply transfer function
    Let new_out be df_transfer(bb, new_in)

    Note: Check if out-state changed
    Let old_out be df_state_get_out(state)
    Let changed be env_equals(new_out, old_out)

    If changed is equal to 0:
        Note: State changed - update and add successors to worklist
        Let dummy1 be df_state_set_in(state, new_in)
        Let dummy2 be df_state_set_out(state, new_out)

        Note: Add all successors to worklist
        Let succs be memory_get_pointer(bb, 40)
        Let succ_count be memory_get_int32(bb, 48)

        Let worklist be memory_get_pointer(context, 16)

        Let i be 0
        While i is less than succ_count:
            Let succ_offset be i multiplied by 4
            Let succ_id be memory_get_int32(succs, succ_offset)

            Note: Add to worklist if not already there
            Let dummy3 be list_append(worklist, succ_id)

            Set i to i plus 1
        End While

        Return 1  Note: Changed
    End If

    Return 0  Note: No change
End Process

Note: Run fixed-point iteration
Note: Returns 1 if converged, 0 if max iterations exceeded
Process called "df_analyze" takes context as Integer returns Integer:
    Let max_iterations be 100
    Let iteration_count be 0

    Let worklist be memory_get_pointer(context, 16)

    While list_length(worklist) is greater than 0:
        If iteration_count is greater than or equal to max_iterations:
            Display "WARNING: Data flow analysis did not converge after ", integer_to_string(max_iterations), " iterations"
            Return 0  Note: Did not converge
        End If

        Note: Pop first block from worklist
        Let bb_id be list_get(worklist, 0)
        Let dummy be list_remove(worklist, 0)

        Note: Process block
        Let changed be df_process_block(context, bb_id)

        Set iteration_count to iteration_count plus 1
    End While

    memory_set_int32(context, 24, iteration_count)

    Display "Data flow analysis converged after ", integer_to_string(iteration_count), " iterations"
    Return 1  Note: Converged
End Process

Note: Get final range for a variable
Process called "df_get_variable_range" takes context as Integer, var_name as Integer returns Integer:
    Note: Look through all blocks and union the ranges
    Let cfg be memory_get_pointer(context, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Let result_range be range_create(0, 0)  Note: Start with [0, 0]
    Let found_any be 0

    Let i be 0
    While i is less than block_count:
        Let state be df_get_block_state(context, i)
        Let out_env be df_state_get_out(state)

        Let range be var_env_lookup(out_env, var_name)
        Let is_unknown be range_is_unknown(range)

        If is_unknown is equal to 0:
            If found_any is equal to 0:
                Set result_range to range
                Set found_any to 1
            Otherwise:
                Set result_range to range_union(result_range, range)
            End If
        End If

        Set i to i plus 1
    End While

    If found_any is equal to 0:
        Return range_create_unknown()
    End If

    Return result_range
End Process

Note: Analyze entire function
Note: Returns mapping of variable names to their inferred ranges
Process called "analyze_function" takes stmt_list as Integer returns Integer:
    Note: Build CFG
    Let cfg be build_cfg(stmt_list)

    Note: Create data flow context
    Let context be df_context_create(cfg)

    Note: Run fixed-point analysis
    Let converged be df_analyze(context)

    If converged is equal to 0:
        Display "WARNING: Analysis did not converge, using conservative types"
    End If

    Return context
End Process

Note: Print analysis results for debugging
Process called "df_print_results" takes context as Integer returns Integer:
    Display "=== Data Flow Analysis Results ==="

    Let cfg be memory_get_pointer(context, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Let i be 0
    While i is less than block_count:
        Display "Block ", integer_to_string(i), ":"

        Let state be df_get_block_state(context, i)
        Let in_env be df_state_get_in(state)
        Let out_env be df_state_get_out(state)

        Display "  IN state:"
        Note: TODO: Print environment

        Display "  OUT state:"
        Note: TODO: Print environment

        Set i to i plus 1
    End While

    Return 0
End Process

Note: ===== BACKWARD PROPAGATION =====

Note: Refine ranges based on conditional constraints
Note: When we see "If x is less than 10", we know in the then-branch: x is in [min, 9]

Note: Token constants for comparison operators
Let TOKEN_IS be 21
Let TOKEN_EQUAL be 22
Let TOKEN_NOT_EQUAL be 23
Let TOKEN_LESS be 24
Let TOKEN_GREATER be 25
Let TOKEN_GREATER_EQUAL be 26
Let TOKEN_LESS_EQUAL be 27

Note: Refine variable range from condition (for then-branch)
Process called "refine_from_condition" takes condition as Integer, env as Integer, is_then_branch as Integer returns Integer:
    Let expr_type be memory_get_int32(condition, 0)
    Let EXPR_BINARY_OP be 3

    If expr_type is not equal to EXPR_BINARY_OP:
        Note: Not a comparison - no refinement
        Return env
    End If

    Note: Get comparison components
    Let left be memory_get_pointer(condition, 8)
    Let op be memory_get_int32(condition, 16)
    Let right be memory_get_pointer(condition, 24)

    Note: Check if left is a simple identifier
    Let left_type be memory_get_int32(left, 0)
    Let EXPR_IDENTIFIER be 2

    If left_type is not equal to EXPR_IDENTIFIER:
        Note: Left is not a simple variable - skip refinement
        Return env
    End If

    Let var_name be memory_get_pointer(left, 8)

    Note: Compute range of right side
    Let right_range be infer_expression_range(right, env)
    Let right_is_unknown be range_is_unknown(right_range)

    If right_is_unknown is equal to 1:
        Note: Right side unknown - can't refine
        Return env
    End If

    Let right_min be range_get_min(right_range)
    Let right_max be range_get_max(right_range)

    Note: Get current variable range
    Let var_range be var_env_lookup(env, var_name)
    Let var_min be range_get_min(var_range)
    Let var_max be range_get_max(var_range)

    Note: Refine based on operator and branch
    If is_then_branch is equal to 1:
        Note: THEN branch: condition is true
        If op is equal to TOKEN_LESS:
            Note: x < right_max means x <= right_max - 1
            Let new_max be right_max minus 1
            If new_max is less than var_max:
                Let refined_range be range_create(var_min, new_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_LESS_EQUAL:
            Note: x <= right_max
            If right_max is less than var_max:
                Let refined_range be range_create(var_min, right_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_GREATER:
            Note: x > right_min means x >= right_min + 1
            Let new_min be right_min plus 1
            If new_min is greater than var_min:
                Let refined_range be range_create(new_min, var_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_GREATER_EQUAL:
            Note: x >= right_min
            If right_min is greater than var_min:
                Let refined_range be range_create(right_min, var_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_EQUAL:
            Note: x == right means x is in [right_min, right_max]
            Let refined_range be range_intersect(var_range, right_range)
            Let dummy be var_env_set(env, var_name, refined_range)

        End If

    Otherwise:
        Note: ELSE branch: condition is false (negate the condition)
        If op is equal to TOKEN_LESS:
            Note: NOT (x < right_max) means x >= right_max
            If right_max is greater than var_min:
                Let refined_range be range_create(right_max, var_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_LESS_EQUAL:
            Note: NOT (x <= right_max) means x > right_max
            Let new_min be right_max plus 1
            If new_min is greater than var_min:
                Let refined_range be range_create(new_min, var_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_GREATER:
            Note: NOT (x > right_min) means x <= right_min
            If right_min is less than var_max:
                Let refined_range be range_create(var_min, right_min)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_GREATER_EQUAL:
            Note: NOT (x >= right_min) means x < right_min
            Let new_max be right_min minus 1
            If new_max is less than var_max:
                Let refined_range be range_create(var_min, new_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_NOT_EQUAL:
            Note: NOT (x != right) means x == right
            Let refined_range be range_intersect(var_range, right_range)
            Let dummy be var_env_set(env, var_name, refined_range)

        End If
    End If

    Return env
End Process

Note: Enhanced transfer function that performs backward propagation
Process called "df_transfer_with_refinement" takes bb as Integer, in_env as Integer, cfg as Integer, bb_id as Integer returns Integer:
    Note: Start with copy of in-state
    Let out_env be var_env_copy(in_env)

    Note: Apply each statement in block
    Let stmts be memory_get_pointer(bb, 8)
    Let stmt_count be memory_get_int32(bb, 16)

    Let i be 0
    While i is less than stmt_count:
        Let offset be i multiplied by 8
        Let stmt be memory_get_pointer(stmts, offset)
        Let stmt_type be memory_get_int32(stmt, 0)

        Let STMT_IF be 3

        Note: Check for If statement with condition refinement
        If stmt_type is equal to STMT_IF:
            Let condition be memory_get_pointer(stmt, 8)

            Note: Get successors to identify then/else branches
            Let succ_count be memory_get_int32(bb, 48)
            Let succs be memory_get_pointer(bb, 40)

            If succ_count is greater than or equal to 2:
                Let then_bb_id be memory_get_int32(succs, 0)
                Let else_bb_id be memory_get_int32(succs, 4)

                Note: Refine environment for each branch
                Note: (This refinement will be picked up when those blocks are processed)
                Note: For now, just continue with normal analysis
            End If
        End If

        Note: Analyze statement and update environment
        Set out_env to analyze_statement(stmt, out_env)

        Set i to i plus 1
    End While

    Return out_env
End Process

Note: Enhanced merge that applies backward refinement from conditionals
Process called "df_merge_with_refinement" takes context as Integer, bb as Integer, bb_id as Integer, cfg as Integer returns Integer:
    Let preds be memory_get_pointer(bb, 24)
    Let pred_count be memory_get_int32(bb, 32)

    If pred_count is equal to 0:
        Return var_env_create()
    End If

    Note: Check if this block is part of an If statement
    Note: If predecessor has 2 successors and this is one of them, we can refine

    Let merged_env be var_env_create()
    Let first be 1

    Let i be 0
    While i is less than pred_count:
        Let pred_offset be i multiplied by 4
        Let pred_id be memory_get_int32(preds, pred_offset)
        Let pred_bb be cfg_get_block(cfg, pred_id)
        Let pred_state be df_get_block_state(context, pred_id)
        Let pred_out be df_state_get_out(pred_state)

        Note: Check if predecessor is a branch point
        Let pred_succ_count be memory_get_int32(pred_bb, 48)

        If pred_succ_count is greater than or equal to 2:
            Note: Predecessor is a branch - check if it has condition
            Let pred_stmts be memory_get_pointer(pred_bb, 8)
            Let pred_stmt_count be memory_get_int32(pred_bb, 16)

            Note: Look for If statement in predecessor
            Let j be 0
            While j is less than pred_stmt_count:
                Let stmt_offset be j multiplied by 8
                Let pred_stmt be memory_get_pointer(pred_stmts, stmt_offset)
                Let stmt_type be memory_get_int32(pred_stmt, 0)

                Let STMT_IF be 3
                If stmt_type is equal to STMT_IF:
                    Let condition be memory_get_pointer(pred_stmt, 8)

                    Note: Determine if this is then or else branch
                    Let pred_succs be memory_get_pointer(pred_bb, 40)
                    Let first_succ_id be memory_get_int32(pred_succs, 0)

                    Let is_then_branch be 0
                    If first_succ_id is equal to bb_id:
                        Set is_then_branch to 1
                    End If

                    Note: Refine environment based on condition
                    Let refined_env be var_env_copy(pred_out)
                    Set refined_env to refine_from_condition(condition, refined_env, is_then_branch)

                    Note: Merge this refined environment
                    If first is equal to 1:
                        Set merged_env to refined_env
                        Set first to 0
                    Otherwise:
                        Set merged_env to var_env_merge(merged_env, refined_env)
                    End If
                End If

                Set j to j plus 1
            End While
        Otherwise:
            Note: Regular predecessor - just merge
            If first is equal to 1:
                Set merged_env to var_env_copy(pred_out)
                Set first to 0
            Otherwise:
                Set merged_env to var_env_merge(merged_env, pred_out)
            End If
        End If

        Set i to i plus 1
    End While

    Return merged_env
End Process

Note: Process block with backward propagation
Process called "df_process_block_refined" takes context as Integer, bb_id as Integer returns Integer:
    Let cfg be memory_get_pointer(context, 0)
    Let bb be cfg_get_block(cfg, bb_id)
    Let state be df_get_block_state(context, bb_id)

    Note: Merge in-state from predecessors WITH refinement
    Let new_in be df_merge_with_refinement(context, bb, bb_id, cfg)

    Note: Apply transfer function
    Let new_out be df_transfer_with_refinement(bb, new_in, cfg, bb_id)

    Note: Check if out-state changed
    Let old_out be df_state_get_out(state)
    Let changed be env_equals(new_out, old_out)

    If changed is equal to 0:
        Let dummy1 be df_state_set_in(state, new_in)
        Let dummy2 be df_state_set_out(state, new_out)

        Note: Add all successors to worklist
        Let succs be memory_get_pointer(bb, 40)
        Let succ_count be memory_get_int32(bb, 48)
        Let worklist be memory_get_pointer(context, 16)

        Let i be 0
        While i is less than succ_count:
            Let succ_offset be i multiplied by 4
            Let succ_id be memory_get_int32(succs, succ_offset)
            Let dummy3 be list_append(worklist, succ_id)
            Set i to i plus 1
        End While

        Return 1
    End If

    Return 0
End Process

Note: Run analysis with backward propagation
Process called "df_analyze_with_backward_prop" takes context as Integer returns Integer:
    Let max_iterations be 100
    Let iteration_count be 0
    Let worklist be memory_get_pointer(context, 16)

    While list_length(worklist) is greater than 0:
        If iteration_count is greater than or equal to max_iterations:
            Display "WARNING: Data flow analysis did not converge after ", integer_to_string(max_iterations), " iterations"
            Return 0
        End If

        Let bb_id be list_get(worklist, 0)
        Let dummy be list_remove(worklist, 0)

        Let changed be df_process_block_refined(context, bb_id)

        Set iteration_count to iteration_count plus 1
    End While

    memory_set_int32(context, 24, iteration_count)
    Display "Data flow analysis (with refinement) converged after ", integer_to_string(iteration_count), " iterations"

    Return 1
End Process
Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Type Inference - Compute ranges for expressions
Note: This module analyzes AST expressions and determines their value ranges

Note: Import range analysis functions (conceptually - will be linked)
Note: Import AST constants from parser

Note: Expression type constants (from parser)
Let EXPR_INTEGER_LITERAL be 0
Let EXPR_STRING_LITERAL be 1
Let EXPR_IDENTIFIER be 2
Let EXPR_BINARY_OP be 3
Let EXPR_FUNCTION_CALL be 4
Let EXPR_UNARY_MINUS be 5
Let EXPR_ARRAY_INDEX be 6
Let EXPR_FIELD_ACCESS be 7
Let EXPR_ARRAY_LITERAL be 8
Let EXPR_LAMBDA be 9
Let EXPR_LAMBDA_CALL be 24
Let EXPR_CAST be 25  Note: New: cast expression

Note: Binary operation tokens (from lexer)
Let TOKEN_PLUS be 16
Let TOKEN_MINUS be 17
Let TOKEN_MULTIPLIED be 35
Let TOKEN_DIVIDED be 36
Let TOKEN_MODULO be 37
Let TOKEN_BIT_AND be 39
Let TOKEN_BIT_OR be 40
Let TOKEN_BIT_XOR be 41
Let TOKEN_BIT_SHIFT_LEFT be 42
Let TOKEN_BIT_SHIFT_RIGHT be 43
Let TOKEN_IS be 21
Let TOKEN_EQUAL be 22
Let TOKEN_NOT_EQUAL be 23
Let TOKEN_LESS be 24
Let TOKEN_GREATER be 25
Let TOKEN_GREATER_EQUAL be 26
Let TOKEN_LESS_EQUAL be 27

Note: Variable environment - maps variable names to ranges
Note: Structure: hash table of (name: String -> range: Range)
Note: For now, use simple list of (name, range) pairs

Note: Create empty variable environment
Process called "var_env_create" returns Integer:
    Note: Environment: list of (name_ptr, range_ptr) pairs
    Note: Structure: capacity(int32 at 0), size(int32 at 4), entries(ptr at 8)
    Let env be allocate(16)
    Let initial_capacity be 32
    memory_set_int32(env, 0, initial_capacity)
    memory_set_int32(env, 4, 0)  Note: size = 0

    Note: Allocate entries array (each entry is 16 bytes: name_ptr + range_ptr)
    Let entries_size be initial_capacity multiplied by 16
    Let entries be allocate(entries_size)
    memory_set_pointer(env, 8, entries)

    Return env
End Process

Note: Look up variable range in environment
Process called "var_env_lookup" takes env as Integer, name as Integer returns Integer:
    Let size be memory_get_int32(env, 4)
    Let entries be memory_get_pointer(env, 8)

    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 16
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let range_offset be entry_offset plus 8
            Let range be memory_get_pointer(entries, range_offset)
            Return range
        End If

        Set i to i plus 1
    End While

    Note: Not found - return unknown range
    Return range_create_unknown()
End Process

Note: Set variable range in environment
Process called "var_env_set" takes env as Integer, name as Integer, range as Integer returns Integer:
    Let size be memory_get_int32(env, 4)
    Let capacity be memory_get_int32(env, 0)
    Let entries be memory_get_pointer(env, 8)

    Note: Check if variable already exists - update it
    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 16
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let range_offset be entry_offset plus 8
            memory_set_pointer(entries, range_offset, range)
            Return env
        End If

        Set i to i plus 1
    End While

    Note: Variable not found - add new entry
    Note: TODO: Handle capacity expansion if size == capacity
    If size is equal to capacity:
        Display "ERROR: Variable environment capacity exceeded"
        exit_with_code(1)
    End If

    Let entry_offset be size multiplied by 16
    memory_set_pointer(entries, entry_offset, name)
    Let range_offset be entry_offset plus 8
    memory_set_pointer(entries, range_offset, range)

    Let new_size be size plus 1
    memory_set_int32(env, 4, new_size)

    Return env
End Process

Note: Copy environment (for branch analysis)
Process called "var_env_copy" takes env as Integer returns Integer:
    Let capacity be memory_get_int32(env, 0)
    Let size be memory_get_int32(env, 4)
    Let old_entries be memory_get_pointer(env, 8)

    Let new_env be allocate(16)
    memory_set_int32(new_env, 0, capacity)
    memory_set_int32(new_env, 4, size)

    Let entries_size be capacity multiplied by 16
    Let new_entries be allocate(entries_size)
    memory_set_pointer(new_env, 8, new_entries)

    Note: Copy all entries
    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 16
        Let name be memory_get_pointer(old_entries, entry_offset)
        Let range be memory_get_pointer(old_entries, entry_offset plus 8)

        memory_set_pointer(new_entries, entry_offset, name)
        memory_set_pointer(new_entries, entry_offset plus 8, range_copy(range))

        Set i to i plus 1
    End While

    Return new_env
End Process

Note: Merge two environments (union ranges for each variable)
Process called "var_env_merge" takes env1 as Integer, env2 as Integer returns Integer:
    Let result be var_env_copy(env1)

    Let size2 be memory_get_int32(env2, 4)
    Let entries2 be memory_get_pointer(env2, 8)

    Let i be 0
    While i is less than size2:
        Let entry_offset be i multiplied by 16
        Let name be memory_get_pointer(entries2, entry_offset)
        Let range2 be memory_get_pointer(entries2, entry_offset plus 8)

        Note: Look up in env1
        Let range1 be var_env_lookup(env1, name)

        Note: Union the ranges
        Let merged_range be range_union(range1, range2)

        Note: Update result
        Let dummy be var_env_set(result, name, merged_range)

        Set i to i plus 1
    End While

    Return result
End Process

Note: Compute range for an expression (without function table)
Process called "infer_expression_range" takes expr as Integer, env as Integer returns Integer:
    Note: Call full version with null function table
    Return infer_expression_range_full(expr, env, 0)
End Process

Note: Compute range for an expression with optional function table
Process called "infer_expression_range_full" takes expr as Integer, env as Integer, func_table as Integer returns Integer:
    Let expr_type be memory_get_int32(expr, 0)

    If expr_type is equal to EXPR_INTEGER_LITERAL:
        Note: Expression: type(int32), value_string(ptr at 8)
        Let value_str be memory_get_pointer(expr, 8)

        Note: Check for binary literal (0b prefix)
        Let first_char be memory_get_byte(value_str, 0)
        Let second_char be memory_get_byte(value_str, 1)
        If first_char is equal to 48:  Note: '0'
            If second_char is equal to 98:  Note: 'b'
                Note: Binary literal - parse it
                Let value be parse_binary_literal(value_str)
                Return range_create(value, value)
            End If
        End If

        Note: Regular decimal literal
        Let value be string_to_integer(value_str)
        Return range_create(value, value)

    Otherwise If expr_type is equal to EXPR_IDENTIFIER:
        Note: Expression: type(int32), name(ptr at 8)
        Let name be memory_get_pointer(expr, 8)
        Return var_env_lookup(env, name)

    Otherwise If expr_type is equal to EXPR_BINARY_OP:
        Note: Expression: type(int32), left(ptr at 8), op(int32 at 16), right(ptr at 24)
        Let left be memory_get_pointer(expr, 8)
        Let op be memory_get_int32(expr, 16)
        Let right be memory_get_pointer(expr, 24)

        Let left_range be infer_expression_range_full(left, env, func_table)
        Let right_range be infer_expression_range_full(right, env, func_table)

        If op is equal to TOKEN_PLUS:
            Return range_add(left_range, right_range)
        Otherwise If op is equal to TOKEN_MINUS:
            Return range_subtract(left_range, right_range)
        Otherwise If op is equal to TOKEN_MULTIPLIED:
            Return range_multiply(left_range, right_range)
        Otherwise If op is equal to TOKEN_DIVIDED:
            Return range_divide(left_range, right_range)
        Otherwise If op is equal to TOKEN_MODULO:
            Return range_modulo(left_range, right_range)
        Otherwise If op is equal to TOKEN_BIT_AND:
            Note: Bitwise AND - result bounded by min of operands
            Return range_bitwise_and(left_range, right_range)
        Otherwise If op is equal to TOKEN_BIT_OR:
            Return range_bitwise_or(left_range, right_range)
        Otherwise If op is equal to TOKEN_BIT_XOR:
            Return range_bitwise_xor(left_range, right_range)
        Otherwise:
            Note: Comparison operators return 0 or 1
            Return range_create(0, 1)
        End If

    Otherwise If expr_type is equal to EXPR_UNARY_MINUS:
        Note: Expression: type(int32), operand(ptr at 8)
        Let operand be memory_get_pointer(expr, 8)
        Let operand_range be infer_expression_range_full(operand, env, func_table)

        Let is_unknown be range_is_unknown(operand_range)
        If is_unknown is equal to 1:
            Return range_create_unknown()
        End If

        Let min be range_get_min(operand_range)
        Let max be range_get_max(operand_range)

        Note: Negate: [-max, -min]
        Let neg_max be 0 minus max
        Let neg_min be 0 minus min
        Return range_create(neg_max, neg_min)

    Otherwise If expr_type is equal to EXPR_CAST:
        Note: Cast expression: type(int32), expr(ptr at 8), target_type(ptr at 16)
        Let inner_expr be memory_get_pointer(expr, 8)
        Let target_type be memory_get_pointer(expr, 16)

        Note: Compute range of inner expression
        Let inner_range be infer_expression_range_full(inner_expr, env, func_table)

        Note: Cast doesn't change the VALUE, just the type
        Note: But we need to check if it fits
        Let type_kind be memory_get_int32(target_type, 0)
        Let can_overflow be range_can_overflow(inner_range, type_kind)

        If can_overflow is equal to 1:
            Note: Cast may overflow - need runtime check
            Note: For now, return unknown (will be refined later)
            Return range_create_unknown()
        End If

        Return inner_range

    Otherwise If expr_type is equal to EXPR_FUNCTION_CALL:
        Note: Function call - lookup return range from function table
        Note: Expression: type(int32), function_name(ptr at 8), args(ptr at 16)
        Let function_name be memory_get_pointer(expr, 8)

        Note: If function table provided, lookup return range
        If func_table is not equal to 0:
            Return func_table_lookup(func_table, function_name)
        Otherwise:
            Note: No function table - return unknown
            Return range_create_unknown()
        End If

    Otherwise:
        Note: Unknown expression type
        Return range_create_unknown()
    End If

    Return range_create_unknown()
End Process

Note: Parse binary literal string (0b10110101) to integer
Process called "parse_binary_literal" takes str as Integer returns Integer:
    Let result be 0
    Let len be string_length(str)

    Note: Skip "0b" prefix
    Let i be 2
    While i is less than len:
        Let char be memory_get_byte(str, i)

        Note: Shift result left by 1
        Set result to result multiplied by 2

        Note: Add bit value (char - '0')
        Let bit be char minus 48
        Set result to result plus bit

        Set i to i plus 1
    End While

    Return result
End Process

Note: Bitwise AND range (conservative)
Process called "range_bitwise_and" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_max be range_get_max(a)
    Let b_max be range_get_max(b)

    Note: AND result is at most the smaller of the two maxes
    Let result_max be a_max
    If b_max is less than result_max:
        Set result_max to b_max
    End If

    Note: Minimum is 0 if either can be 0
    Return range_create(0, result_max)
End Process

Note: Bitwise OR range (conservative)
Process called "range_bitwise_or" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_max be range_get_max(a)
    Let b_max be range_get_max(b)
    Let a_min be range_get_min(a)
    Let b_min be range_get_min(b)

    Note: OR result is at most the sum of the two maxes (very conservative)
    Let result_max be a_max plus b_max

    Note: Minimum is larger of the two minimums if both positive
    Let result_min be 0
    If a_min is greater than 0:
        If b_min is greater than 0:
            Set result_min to a_min
            If b_min is greater than result_min:
                Set result_min to b_min
            End If
        End If
    End If

    Return range_create(result_min, result_max)
End Process

Note: Bitwise XOR range (very conservative)
Process called "range_bitwise_xor" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_max be range_get_max(a)
    Let b_max be range_get_max(b)

    Note: XOR is very hard to bound - use sum as conservative estimate
    Let result_max be a_max plus b_max

    Return range_create(0, result_max)
End Process

Note: Analyze statement and update variable environment
Process called "analyze_statement" takes stmt as Integer, env as Integer returns Integer:
    Let stmt_type be memory_get_int32(stmt, 0)

    Note: Statement type constants (from parser)
    Let STMT_LET be 0
    Let STMT_SET be 1
    Let STMT_RETURN be 2
    Let STMT_IF be 3
    Let STMT_WHILE be 4
    Let STMT_EXPRESSION be 5
    Let STMT_BREAK be 6
    Let STMT_CONTINUE be 7
    Let STMT_PRINT be 8
    Let STMT_FOR be 9

    If stmt_type is equal to STMT_LET:
        Note: Let statement: type(int32), name(ptr at 8), expr(ptr at 16)
        Let name be memory_get_pointer(stmt, 8)
        Let expr be memory_get_pointer(stmt, 16)

        Let range be infer_expression_range(expr, env)
        Let dummy be var_env_set(env, name, range)
        Return env

    Otherwise If stmt_type is equal to STMT_SET:
        Note: Set statement: type(int32), target(ptr at 8), expr(ptr at 16)
        Let target be memory_get_pointer(stmt, 8)
        Let expr be memory_get_pointer(stmt, 16)

        Note: For simple identifier target
        Let target_type be memory_get_int32(target, 0)
        If target_type is equal to EXPR_IDENTIFIER:
            Let name be memory_get_pointer(target, 8)
            Let range be infer_expression_range(expr, env)
            Let dummy be var_env_set(env, name, range)
        End If

        Return env

    Otherwise If stmt_type is equal to STMT_IF:
        Note: If statement: type(int32), condition(ptr at 8), then_branch(ptr at 16), else_branch(ptr at 24)
        Let condition be memory_get_pointer(stmt, 8)
        Let then_branch be memory_get_pointer(stmt, 16)
        Let else_branch be memory_get_pointer(stmt, 24)

        Note: Analyze both branches separately
        Let then_env be var_env_copy(env)
        Let then_env_result be analyze_statement_list(then_branch, then_env)

        Let else_env be var_env_copy(env)
        If else_branch is not equal to 0:
            Let else_env_result be analyze_statement_list(else_branch, else_env)
            Note: Merge environments
            Return var_env_merge(then_env_result, else_env_result)
        Otherwise:
            Note: No else branch - merge with original env
            Return var_env_merge(then_env_result, env)
        End If

    Otherwise If stmt_type is equal to STMT_FOR:
        Note: For loop: analyze with fixed-point iteration
        Note: TODO: Implement full loop analysis
        Return env

    Otherwise If stmt_type is equal to STMT_WHILE:
        Note: While loop: analyze with fixed-point iteration
        Note: TODO: Implement full loop analysis
        Return env

    End If

    Return env
End Process

Note: Analyze list of statements
Process called "analyze_statement_list" takes stmt_list as Integer, env as Integer returns Integer:
    Note: Statement list: type(list), items...
    Let count be list_length(stmt_list)

    Let i be 0
    While i is less than count:
        Let stmt be list_get(stmt_list, i)
        Set env to analyze_statement(stmt, env)
        Set i to i plus 1
    End While

    Return env
End Process

Note: ===== INTER-PROCEDURAL ANALYSIS =====

Note: Function table - maps function name to (return_range, analyzed_flag)
Note: Structure: list of (name_ptr, return_range_ptr, analyzed_flag)
Process called "func_table_create" returns Integer:
    Note: Structure: capacity(int32 at 0), size(int32 at 4), entries(ptr at 8)
    Let table be allocate(16)
    Let initial_capacity be 32
    memory_set_int32(table, 0, initial_capacity)
    memory_set_int32(table, 4, 0)

    Note: Allocate entries array (each entry is 24 bytes: name_ptr + return_range_ptr + analyzed_flag)
    Let entries_size be initial_capacity multiplied by 24
    Let entries be allocate(entries_size)
    memory_set_pointer(table, 8, entries)

    Return table
End Process

Note: Lookup function return range
Process called "func_table_lookup" takes table as Integer, name as Integer returns Integer:
    Let size be memory_get_int32(table, 4)
    Let entries be memory_get_pointer(table, 8)

    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 24
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let range_offset be entry_offset plus 8
            Let return_range be memory_get_pointer(entries, range_offset)
            Return return_range
        End If

        Set i to i plus 1
    End While

    Note: Not found - return unknown range
    Return range_create_unknown()
End Process

Note: Set function return range
Process called "func_table_set" takes table as Integer, name as Integer, return_range as Integer returns Integer:
    Let size be memory_get_int32(table, 4)
    Let capacity be memory_get_int32(table, 0)
    Let entries be memory_get_pointer(table, 8)

    Note: Check if function already exists - update it
    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 24
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let range_offset be entry_offset plus 8
            memory_set_pointer(entries, range_offset, return_range)
            Return table
        End If

        Set i to i plus 1
    End While

    Note: Function not found - add new entry
    If size is equal to capacity:
        Display "ERROR: Function table capacity exceeded"
        exit_with_code(1)
    End If

    Let entry_offset be size multiplied by 24
    memory_set_pointer(entries, entry_offset, name)
    Let range_offset be entry_offset plus 8
    memory_set_pointer(entries, range_offset, return_range)
    Let analyzed_offset be entry_offset plus 16
    memory_set_int32(entries, analyzed_offset, 0)  Note: Not analyzed yet

    Let new_size be size plus 1
    memory_set_int32(table, 4, new_size)

    Return table
End Process

Note: Check if function has been analyzed
Process called "func_table_is_analyzed" takes table as Integer, name as Integer returns Integer:
    Let size be memory_get_int32(table, 4)
    Let entries be memory_get_pointer(table, 8)

    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 24
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let analyzed_offset be entry_offset plus 16
            Let analyzed_flag be memory_get_int32(entries, analyzed_offset)
            Return analyzed_flag
        End If

        Set i to i plus 1
    End While

    Return 0  Note: Not found - not analyzed
End Process

Note: Mark function as analyzed
Process called "func_table_mark_analyzed" takes table as Integer, name as Integer returns Integer:
    Let size be memory_get_int32(table, 4)
    Let entries be memory_get_pointer(table, 8)

    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 24
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let analyzed_offset be entry_offset plus 16
            memory_set_int32(entries, analyzed_offset, 1)
            Return table
        End If

        Set i to i plus 1
    End While

    Return table
End Process

Note: Call graph - tracks which functions call which
Note: Structure: caller_name -> list of callee names
Process called "callgraph_create" returns Integer:
    Note: Structure: capacity(int32 at 0), size(int32 at 4), entries(ptr at 8)
    Let graph be allocate(16)
    Let initial_capacity be 32
    memory_set_int32(graph, 0, initial_capacity)
    memory_set_int32(graph, 4, 0)

    Note: Allocate entries array (each entry is 16 bytes: caller_name_ptr + callees_list_ptr)
    Let entries_size be initial_capacity multiplied by 16
    Let entries be allocate(entries_size)
    memory_set_pointer(graph, 8, entries)

    Return graph
End Process

Note: Add edge to call graph (caller -> callee)
Process called "callgraph_add_edge" takes graph as Integer, caller as Integer, callee as Integer returns Integer:
    Let size be memory_get_int32(graph, 4)
    Let capacity be memory_get_int32(graph, 0)
    Let entries be memory_get_pointer(graph, 8)

    Note: Look for existing caller entry
    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 16
        Let entry_caller be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_caller, caller) is equal to 1:
            Note: Found caller - add callee to its list
            Let callees_offset be entry_offset plus 8
            Let callees_list be memory_get_pointer(entries, callees_offset)
            Let dummy be list_append(callees_list, callee)
            Return graph
        End If

        Set i to i plus 1
    End While

    Note: Caller not found - create new entry
    If size is equal to capacity:
        Display "ERROR: Call graph capacity exceeded"
        exit_with_code(1)
    End If

    Let entry_offset be size multiplied by 16
    memory_set_pointer(entries, entry_offset, caller)
    Let callees_list be list_create()
    Let dummy be list_append(callees_list, callee)
    Let callees_offset be entry_offset plus 8
    memory_set_pointer(entries, callees_offset, callees_list)

    Let new_size be size plus 1
    memory_set_int32(graph, 4, new_size)

    Return graph
End Process

Note: Get list of callees for a function
Process called "callgraph_get_callees" takes graph as Integer, caller as Integer returns Integer:
    Let size be memory_get_int32(graph, 4)
    Let entries be memory_get_pointer(graph, 8)

    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 16
        Let entry_caller be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_caller, caller) is equal to 1:
            Let callees_offset be entry_offset plus 8
            Let callees_list be memory_get_pointer(entries, callees_offset)
            Return callees_list
        End If

        Set i to i plus 1
    End While

    Note: Not found - return empty list
    Return list_create()
End Process

Note: Build call graph from AST
Process called "build_callgraph_from_ast" takes ast as Integer returns Integer:
    Let callgraph be callgraph_create()

    Note: AST structure: functions(ptr at 0)
    Let functions be memory_get_pointer(ast, 0)
    Let func_count be list_length(functions)

    Let i be 0
    While i is less than func_count:
        Let func be list_get(functions, i)

        Note: Function: name(ptr at 0), params(ptr at 8), return_type(ptr at 16), body(ptr at 24)
        Let func_name be memory_get_pointer(func, 0)
        Let body be memory_get_pointer(func, 24)

        Note: Scan body for function calls
        Let dummy be scan_for_calls(callgraph, func_name, body)

        Set i to i plus 1
    End While

    Return callgraph
End Process

Note: Scan statement list for function calls
Process called "scan_for_calls" takes callgraph as Integer, caller as Integer, stmt_list as Integer returns Integer:
    Let count be list_length(stmt_list)

    Let i be 0
    While i is less than count:
        Let stmt be list_get(stmt_list, i)
        Let dummy be scan_statement_for_calls(callgraph, caller, stmt)
        Set i to i plus 1
    End While

    Return callgraph
End Process

Note: Scan single statement for function calls
Process called "scan_statement_for_calls" takes callgraph as Integer, caller as Integer, stmt as Integer returns Integer:
    Let stmt_type be memory_get_int32(stmt, 0)

    Let STMT_LET be 0
    Let STMT_SET be 1
    Let STMT_RETURN be 2
    Let STMT_IF be 3
    Let STMT_WHILE be 4
    Let STMT_EXPRESSION be 5
    Let STMT_FOR be 9

    If stmt_type is equal to STMT_LET:
        Let expr be memory_get_pointer(stmt, 16)
        Let dummy be scan_expr_for_calls(callgraph, caller, expr)
        Return callgraph

    Otherwise If stmt_type is equal to STMT_SET:
        Let expr be memory_get_pointer(stmt, 16)
        Let dummy be scan_expr_for_calls(callgraph, caller, expr)
        Return callgraph

    Otherwise If stmt_type is equal to STMT_RETURN:
        Let expr be memory_get_pointer(stmt, 8)
        If expr is not equal to 0:
            Let dummy be scan_expr_for_calls(callgraph, caller, expr)
        End If
        Return callgraph

    Otherwise If stmt_type is equal to STMT_IF:
        Let condition be memory_get_pointer(stmt, 8)
        Let then_branch be memory_get_pointer(stmt, 16)
        Let else_branch be memory_get_pointer(stmt, 24)

        Let dummy be scan_expr_for_calls(callgraph, caller, condition)
        Let dummy2 be scan_for_calls(callgraph, caller, then_branch)
        If else_branch is not equal to 0:
            Let dummy3 be scan_for_calls(callgraph, caller, else_branch)
        End If
        Return callgraph

    Otherwise If stmt_type is equal to STMT_WHILE:
        Let condition be memory_get_pointer(stmt, 8)
        Let body be memory_get_pointer(stmt, 16)

        Let dummy be scan_expr_for_calls(callgraph, caller, condition)
        Let dummy2 be scan_for_calls(callgraph, caller, body)
        Return callgraph

    Otherwise If stmt_type is equal to STMT_FOR:
        Let init be memory_get_pointer(stmt, 8)
        Let condition be memory_get_pointer(stmt, 16)
        Let update be memory_get_pointer(stmt, 24)
        Let body be memory_get_pointer(stmt, 32)

        If init is not equal to 0:
            Let dummy be scan_statement_for_calls(callgraph, caller, init)
        End If
        If condition is not equal to 0:
            Let dummy2 be scan_expr_for_calls(callgraph, caller, condition)
        End If
        If update is not equal to 0:
            Let dummy3 be scan_statement_for_calls(callgraph, caller, update)
        End If
        Let dummy4 be scan_for_calls(callgraph, caller, body)
        Return callgraph

    Otherwise If stmt_type is equal to STMT_EXPRESSION:
        Let expr be memory_get_pointer(stmt, 8)
        Let dummy be scan_expr_for_calls(callgraph, caller, expr)
        Return callgraph

    End If

    Return callgraph
End Process

Note: Scan expression for function calls
Process called "scan_expr_for_calls" takes callgraph as Integer, caller as Integer, expr as Integer returns Integer:
    If expr is equal to 0:
        Return callgraph
    End If

    Let expr_type be memory_get_int32(expr, 0)

    If expr_type is equal to EXPR_FUNCTION_CALL:
        Note: Found function call - add edge
        Let callee_name be memory_get_pointer(expr, 8)
        Let dummy be callgraph_add_edge(callgraph, caller, callee_name)

        Note: Also scan arguments
        Let args be memory_get_pointer(expr, 16)
        If args is not equal to 0:
            Let arg_count be list_length(args)
            Let i be 0
            While i is less than arg_count:
                Let arg be list_get(args, i)
                Let dummy2 be scan_expr_for_calls(callgraph, caller, arg)
                Set i to i plus 1
            End While
        End If
        Return callgraph

    Otherwise If expr_type is equal to EXPR_BINARY_OP:
        Let left be memory_get_pointer(expr, 8)
        Let right be memory_get_pointer(expr, 24)
        Let dummy be scan_expr_for_calls(callgraph, caller, left)
        Let dummy2 be scan_expr_for_calls(callgraph, caller, right)
        Return callgraph

    Otherwise If expr_type is equal to EXPR_UNARY_MINUS:
        Let operand be memory_get_pointer(expr, 8)
        Let dummy be scan_expr_for_calls(callgraph, caller, operand)
        Return callgraph

    Otherwise If expr_type is equal to EXPR_CAST:
        Let inner_expr be memory_get_pointer(expr, 8)
        Let dummy be scan_expr_for_calls(callgraph, caller, inner_expr)
        Return callgraph

    Otherwise If expr_type is equal to EXPR_ARRAY_INDEX:
        Let array be memory_get_pointer(expr, 8)
        Let index be memory_get_pointer(expr, 16)
        Let dummy be scan_expr_for_calls(callgraph, caller, array)
        Let dummy2 be scan_expr_for_calls(callgraph, caller, index)
        Return callgraph

    End If

    Return callgraph
End Process

Note: Analyze function return range with inter-procedural support
Process called "analyze_function_range" takes func as Integer, func_table as Integer, callgraph as Integer returns Integer:
    Note: Function: name(ptr at 0), params(ptr at 8), return_type(ptr at 16), body(ptr at 24)
    Let func_name be memory_get_pointer(func, 0)
    Let body be memory_get_pointer(func, 24)

    Note: Check if already analyzed
    Let is_analyzed be func_table_is_analyzed(func_table, func_name)
    If is_analyzed is equal to 1:
        Return func_table_lookup(func_table, func_name)
    End If

    Note: Analyze all callees first (bottom-up)
    Let callees be callgraph_get_callees(callgraph, func_name)
    Let callee_count be list_length(callees)
    Let i be 0
    While i is less than callee_count:
        Let callee_name be list_get(callees, i)

        Note: Recursively analyze callee
        Note: TODO: Handle recursion properly (detect cycles)
        Let callee_is_analyzed be func_table_is_analyzed(func_table, callee_name)
        If callee_is_analyzed is equal to 0:
            Note: Callee not analyzed yet - need to find and analyze it
            Note: For now, assume unknown range
            Let dummy be func_table_set(func_table, callee_name, range_create_unknown())
        End If

        Set i to i plus 1
    End While

    Note: Create environment with parameter ranges (assume unknown for now)
    Let env be var_env_create()

    Note: Scan body for return statements and collect return ranges
    Let return_range be scan_for_return_range(body, env, func_table)

    Note: Update function table
    Let dummy be func_table_set(func_table, func_name, return_range)
    Let dummy2 be func_table_mark_analyzed(func_table, func_name)

    Return return_range
End Process

Note: Scan statement list for return statements and compute union of return ranges
Process called "scan_for_return_range" takes stmt_list as Integer, env as Integer, func_table as Integer returns Integer:
    Let result_range be range_create(0, 0)  Note: Start with single point [0,0]
    Let found_return be 0

    Let count be list_length(stmt_list)
    Let i be 0
    While i is less than count:
        Let stmt be list_get(stmt_list, i)
        Let stmt_range be scan_stmt_for_return_range(stmt, env, func_table)

        Note: Check if this statement has return
        If stmt_range is not equal to 0:
            Set found_return to 1
            Set result_range to range_union(result_range, stmt_range)
        End If

        Set i to i plus 1
    End While

    If found_return is equal to 0:
        Return range_create_unknown()
    End If

    Return result_range
End Process

Note: Scan single statement for return range
Process called "scan_stmt_for_return_range" takes stmt as Integer, env as Integer, func_table as Integer returns Integer:
    Let stmt_type be memory_get_int32(stmt, 0)

    Let STMT_RETURN be 2
    Let STMT_IF be 3
    Let STMT_WHILE be 4
    Let STMT_FOR be 9

    If stmt_type is equal to STMT_RETURN:
        Let expr be memory_get_pointer(stmt, 8)
        If expr is equal to 0:
            Return range_create(0, 0)  Note: No return value
        End If
        Return infer_expression_range_with_functable(expr, env, func_table)

    Otherwise If stmt_type is equal to STMT_IF:
        Let then_branch be memory_get_pointer(stmt, 16)
        Let else_branch be memory_get_pointer(stmt, 24)

        Let then_range be scan_for_return_range(then_branch, env, func_table)

        If else_branch is not equal to 0:
            Let else_range be scan_for_return_range(else_branch, env, func_table)

            Note: Only return if both branches have returns
            If then_range is not equal to 0:
                If else_range is not equal to 0:
                    Return range_union(then_range, else_range)
                End If
            End If
        End If

        Return then_range  Note: May be 0 if no return

    Otherwise If stmt_type is equal to STMT_WHILE:
        Let body be memory_get_pointer(stmt, 16)
        Return scan_for_return_range(body, env, func_table)

    Otherwise If stmt_type is equal to STMT_FOR:
        Let body be memory_get_pointer(stmt, 32)
        Return scan_for_return_range(body, env, func_table)

    End If

    Return 0  Note: No return in this statement
End Process

Note: Infer expression range with function table support (wrapper for compatibility)
Process called "infer_expression_range_with_functable" takes expr as Integer, env as Integer, func_table as Integer returns Integer:
    Return infer_expression_range_full(expr, env, func_table)
End Process
Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: String Utilities for Runa v0.0.7.5 Bootstrap Compiler
Note: Refactored to work within v0.0.7.3 compiler limitations
Note: - No Character type (use Integer for ASCII values)
Note: - No complex boolean expressions in While loops
Note: - No function calls in conditions

Note: ==== Basic String Functions ====

Process called "string_length" takes str as Integer returns Integer:
    If str is equal to 0:
        Return 0
    End If
    Let f1_len be 0
    Let f1_sl_loop be 1
    While f1_sl_loop is equal to 1:
        Let f1_sl_ch be memory_get_byte(str, f1_len)
        If f1_sl_ch is equal to 0:
            Let f1_sl_loop be 0
        Otherwise:
            Let f1_len be f1_len plus 1
        End If
    End While
    Return f1_len
End Process

Process called "string_char_at" takes str as Integer, index as Integer returns Integer:
    If str is equal to 0:
        Return 0
    End If
    Let f2_sc_char be memory_get_byte(str, index)
    Return f2_sc_char
End Process

Process called "string_equals" takes str1 as Integer, str2 as Integer returns Integer:
    If str1 is equal to 0:
        If str2 is equal to 0:
            Return 1
        End If
        Return 0
    End If
    If str2 is equal to 0:
        Return 0
    End If

    Let f3_se_i be 0
    Let f3_se_loop be 1
    While f3_se_loop is equal to 1:
        Let f3_se_c1 be memory_get_byte(str1, f3_se_i)
        Let f3_se_c2 be memory_get_byte(str2, f3_se_i)
        If f3_se_c1 is not equal to f3_se_c2:
            Return 0
        End If
        If f3_se_c1 is equal to 0:
            Let f3_se_loop be 0
        Otherwise:
            Let f3_se_i be f3_se_i plus 1
        End If
    End While
    Return 1
End Process

Process called "is_digit" takes char as Integer returns Integer:
    Let f4_zero be 48  Note: ASCII '0'
    Let f4_nine be 57  Note: ASCII '9'
    If char is greater than or equal to f4_zero:
        If char is less than or equal to f4_nine:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "is_alpha" takes char as Integer returns Integer:
    Let f5_upper_a be 65  Note: ASCII 'A'
    Let f5_upper_z be 90  Note: ASCII 'Z'
    Let f5_lower_a be 97  Note: ASCII 'a'
    Let f5_lower_z be 122 Note: ASCII 'z'

    If char is greater than or equal to f5_upper_a:
        If char is less than or equal to f5_upper_z:
            Return 1
        End If
    End If

    If char is greater than or equal to f5_lower_a:
        If char is less than or equal to f5_lower_z:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "is_whitespace" takes char as Integer returns Integer:
    Let f6_space be 32     Note: ASCII f6_space
    Let f6_tab be 9        Note: ASCII f6_tab
    Let f6_newline be 10   Note: ASCII f6_newline
    Let f6_cr be 13        Note: ASCII carriage return

    If char is equal to f6_space:
        Return 1
    Otherwise If char is equal to f6_tab:
        Return 1
    Otherwise If char is equal to f6_newline:
        Return 1
    Otherwise If char is equal to f6_cr:
        Return 1
    End If
    Return 0
End Process

Process called "integer_to_string" takes value as Integer returns Integer:
    Note: Handle special case of 0
    If value is equal to 0:
        Let f7_str be memory_allocate(2)
        memory_set_byte(f7_str, 0, 48)  Note: ASCII '0'
        memory_set_byte(f7_str, 1, 0)   Note: null terminator
        Return f7_str
    End If

    Note: Handle negative numbers
    Let f7_is_negative be 0
    Let f7_num be value
    If value is less than 0:
        Let f7_is_negative be 1
        Let f7_num be -value
    End If

    Note: Count digits
    Let f7_digit_count be 0
    Let f7_temp be f7_num
    While f7_temp is greater than 0:
        Let f7_digit_count be f7_digit_count plus 1
        Let f7_temp be f7_temp divided by 10
    End While

    Note: Allocate string (digits + sign + null)
    Let f7_size be f7_digit_count plus 1
    If f7_is_negative is equal to 1:
        Let f7_size be f7_size plus 1
    End If
    Let f7_str be memory_allocate(f7_size)

    Note: Fill from the end
    Let f7_pos be f7_digit_count
    If f7_is_negative is equal to 1:
        Let f7_pos be f7_pos plus 1
    End If
    memory_set_byte(f7_str, f7_pos, 0)  Note: null terminator

    Note: Add digits from right to left
    Let f7_temp be f7_num
    Let f7_pos be f7_digit_count minus 1
    If f7_is_negative is equal to 1:
        Let f7_pos be f7_pos plus 1
    End If

    While f7_temp is greater than 0:
        Note: f7_temp modulo 10 = f7_temp - (f7_temp / 10) * 10
        Let f7_temp_div_10 be f7_temp divided by 10
        Let f7_temp_mult_10 be f7_temp_div_10 multiplied by 10
        Let f7_digit be f7_temp minus f7_temp_mult_10
        Let f7_ascii_digit be f7_digit plus 48  Note: Convert to ASCII
        memory_set_byte(f7_str, f7_pos, f7_ascii_digit)
        Let f7_pos be f7_pos minus 1
        Let f7_temp be f7_temp divided by 10
    End While

    Note: Add minus sign if negative
    If f7_is_negative is equal to 1:
        memory_set_byte(f7_str, 0, 45)  Note: ASCII '-'
    End If

    Return f7_str
End Process

Note: memory_get_byte and memory_set_byte are provided as externs from runtime

Process called "bit_not" takes value as Integer returns Integer:
    Note: Bitwise NOT operation replaced with arithmetic
    Note: For 64-bit signed integers, ~x = -(x + 1)
    Let f8_temp be value plus 1
    Let f8_result be -f8_temp
    Return f8_result
End Process

Note: memory_set_pointer and memory_get_pointer are provided by runtime

Process called "system_write" takes fd as Integer, buffer as Integer, count as Integer returns Integer:
    Note: System call for write (syscall number 1)
    Let f9_syscall_write be 1
    Let f9_result be system_call(f9_syscall_write, fd, buffer, count)
    Return f9_result
End Process

Process called "string_to_integer" takes str as Integer returns Integer:
    Note: Convert string to integer
    If str is equal to 0:
        Return 0
    End If

    Let f10_result be 0
    Let f10_i be 0
    Let f10_is_negative be 0

    Note: Check for negative sign
    Let f10_first_char be memory_get_byte(str, 0)
    Let f10_minus_char be 45  Note: ASCII '-'
    If f10_first_char is equal to f10_minus_char:
        Let f10_is_negative be 1
        Let f10_i be 1
    End If

    Note: Parse digits
    Let f10_continue_loop be 1
    While f10_continue_loop is equal to 1:
        Let f10_char be memory_get_byte(str, f10_i)
        If f10_char is equal to 0:
            Let f10_continue_loop be 0
        Otherwise:
            Let f10_is_dig be is_digit(f10_char)
            If f10_is_dig is equal to 1:
                Let f10_result be f10_result multiplied by 10
                Let f10_zero_char be 48  Note: ASCII '0'
                Let f10_digit be f10_char minus f10_zero_char
                Let f10_result be f10_result plus f10_digit
                Let f10_i be f10_i plus 1
            Otherwise:
                Let f10_continue_loop be 0
            End If
        End If
    End While

    If f10_is_negative is equal to 1:
        Let f10_result be -f10_result
    End If

    Return f10_result
End Process

Process called "memory_reallocate" takes ptr as Integer, new_size as Integer returns Integer:
    Note: The runtime's reallocate takes 3 parameters (ptr, old_size, new_size)
    Note: but we only have ptr and new_size, so we'll use a simpler approach:
    Note: IMPORTANT: Do NOT use reallocate(ptr, 0, new_size) as it zeros the buffer!
    If ptr is equal to 0:
        Return allocate(new_size)
    End If
    Note: Use a direct realloc that preserves existing data
    Note: This external function is provided by the runtime
    Return memory_realloc(ptr, new_size)
End Process

Note: ==== Type Definitions ====
Note: WORKAROUND: Types commented out due to v0.0.7.3 bug with Type+Let combo
Note: Once v0.0.7.5 is self-hosted, uncomment these

Note: Type called "StringBuilder":
Note:     buffer as Integer,      Note: Pointer to char buffer
Note:     capacity as Integer,
Note:     length as Integer
Note: End Type

Note: Type called "StringTokenizer":
Note:     string as Integer,      Note: Pointer to string
Note:     current as Integer,     Note: Current position pointer
Note:     delimiters as Integer,  Note: Pointer to delimiters string
Note:     own_string as Integer   Note: Boolean flag
Note: End Type

Note: Type called "StringArray":
Note:     strings as Integer,     Note: Pointer to string arr
Note:     count as Integer,
Note:     capacity as Integer
Note: End Type

Note: ==== String Builder Implementation ====

Process called "string_builder_create_with_capacity" takes initial_capacity as Integer returns Integer:
    Let f12_sb be allocate(24)  Note: sizeof(StringBuilder) = 3 * 8 bytes
    If f12_sb is equal to 0:
        Return 0
    End If

    Let f12_buffer be allocate(initial_capacity)
    If f12_buffer is equal to 0:
        deallocate(f12_sb)
        Return 0
    End If

    Note: Initialize f12_buffer with null terminator
    memory_set_byte(f12_buffer, 0, 0)

    Note: Set StringBuilder fields
    memory_set_pointer(f12_sb, 0, f12_buffer)           Note: f12_sb->f12_buffer = f12_buffer
    memory_set_int32(f12_sb, 8, initial_capacity)  Note: f12_sb->capacity = initial_capacity
    memory_set_integer(f12_sb, 16, 0)               Note: f12_sb->length = 0

    Return f12_sb
End Process

Process called "string_builder_create" returns Integer:
    Return string_builder_create_with_capacity(256)
End Process

Process called "string_builder_destroy" takes sb as Integer returns Integer:
    If sb is not equal to 0:
        Let f14_buffer be memory_get_pointer(sb, 0)
        deallocate(f14_buffer)
        deallocate(sb)
    End If
    Return 0
End Process

Process called "string_builder_ensure_capacity" takes sb as Integer, needed as Integer returns Integer:
    Let f15_current_length be memory_get_integer(sb, 16)
    Let f15_current_capacity be memory_get_integer(sb, 8)
    Let f15_total_needed be f15_current_length plus needed

    If f15_total_needed is greater than or equal to f15_current_capacity:
        Let f15_new_capacity be f15_current_capacity multiplied by 2

        Note: Keep doubling capacity until it's large enough
        Let f15_capacity_ok be 0
        While f15_capacity_ok is equal to 0:
            If f15_new_capacity is greater than f15_total_needed:
                Let f15_capacity_ok be 1
            Otherwise:
                Let f15_new_capacity be f15_new_capacity multiplied by 2
            End If
        End While

        Let f15_old_buffer be memory_get_pointer(sb, 0)
        Let f15_new_buffer be reallocate(f15_old_buffer, f15_new_capacity)
        If f15_new_buffer is equal to 0:
            Return 0  Note: false
        End If

        memory_set_pointer(sb, 0, f15_new_buffer)
        memory_set_integer(sb, 8, f15_new_capacity)
    End If
    Return 1  Note: true
End Process

Process called "string_builder_append" takes sb as Integer, str as String returns Integer:
    If sb is equal to 0:
        Return 0  Note: false
    End If

    Let f16_len be string_length(str)
    If f16_len is equal to 0:
        Return 1  Note: true - empty string append succeeds
    End If

    Let f16_ensure_result be string_builder_ensure_capacity(sb, f16_len)
    If f16_ensure_result is equal to 0:
        Return 0  Note: false
    End If

    Let f16_buffer be memory_get_pointer(sb, 0)
    Let f16_current_length be memory_get_integer(sb, 16)

    Note: Copy string to f16_buffer at current position
    memory_copy_string(f16_buffer, f16_current_length, str)

    Note: Update length
    memory_set_integer(sb, 16, f16_current_length plus f16_len)

    Return 1  Note: true
End Process

Process called "string_builder_append_char" takes sb as Integer, c as Integer returns Integer:
    Note: c is ASCII value instead of Character
    If sb is equal to 0:
        Return 0  Note: false
    End If

    Let f17_ensure_result be string_builder_ensure_capacity(sb, 1)
    If f17_ensure_result is equal to 0:
        Return 0  Note: false
    End If

    Let f17_buffer be memory_get_pointer(sb, 0)
    Let f17_current_length be memory_get_integer(sb, 16)

    Note: Set character at current position
    memory_set_byte(f17_buffer, f17_current_length, c)
    Let f17_current_length be f17_current_length plus 1

    Note: Add null terminator
    memory_set_byte(f17_buffer, f17_current_length, 0)

    Note: Update length
    memory_set_integer(sb, 16, f17_current_length)

    Return 1  Note: true
End Process

Process called "string_builder_append_int" takes sb as Integer, value as Integer returns Integer:
    Let f18_buffer_str be integer_to_string(value)
    Return string_builder_append(sb, f18_buffer_str)
End Process

Process called "string_builder_to_string" takes sb as Integer returns String:
    If sb is equal to 0:
        Return ""
    End If

    Let f19_result_buffer be memory_get_pointer(sb, 0)
    Let f19_result_str be memory_pointer_to_string(f19_result_buffer)

    Note: Reset StringBuilder to empty state
    Let f19_new_buffer be allocate(1)
    memory_set_byte(f19_new_buffer, 0, 0)
    memory_set_pointer(sb, 0, f19_new_buffer)
    memory_set_integer(sb, 8, 1)
    memory_set_integer(sb, 16, 0)

    Return f19_result_str
End Process

Process called "string_builder_get_string" takes sb as Integer returns String:
    If sb is equal to 0:
        Return ""
    End If
    Let f20_buffer be memory_get_pointer(sb, 0)
    Return memory_pointer_to_string(f20_buffer)
End Process

Process called "string_builder_length" takes sb as Integer returns Integer:
    If sb is equal to 0:
        Return 0
    End If
    Return memory_get_integer(sb, 16)
End Process

Process called "string_builder_clear" takes sb as Integer returns Integer:
    If sb is not equal to 0:
        Let f22_buffer be memory_get_pointer(sb, 0)
        memory_set_byte(f22_buffer, 0, 0)
        memory_set_integer(sb, 16, 0)
    End If
    Return 0
End Process

Note: ==== String Tokenizer Implementation ====

Process called "string_tokenizer_create" takes str as String, delimiters as String returns Integer:
    If string_length(str) is equal to 0:
        Return 0
    End If
    If string_length(delimiters) is equal to 0:
        Return 0
    End If

    Let f23_tokenizer be allocate(32)  Note: sizeof(StringTokenizer)
    If f23_tokenizer is equal to 0:
        Return 0
    End If

    Let f23_str_copy be string_duplicate(str)
    If f23_str_copy is equal to 0:
        deallocate(f23_tokenizer)
        Return 0
    End If

    memory_set_pointer(f23_tokenizer, 0, f23_str_copy)
    memory_set_pointer(f23_tokenizer, 8, f23_str_copy)

    Note: Store delimiters as a duplicated string pointer
    Let f23_delim_copy be string_duplicate(delimiters)
    memory_set_pointer(f23_tokenizer, 16, f23_delim_copy)
    memory_set_integer(f23_tokenizer, 24, 1)

    Return f23_tokenizer
End Process

Process called "string_tokenizer_next" takes tokenizer as Integer returns String:
    If tokenizer is equal to 0:
        Return ""
    End If

    Let f24_current_ptr be memory_get_pointer(tokenizer, 8)
    If f24_current_ptr is equal to 0:
        Return ""
    End If

    Let f24_delimiters_ptr be memory_get_pointer(tokenizer, 16)
    Let f24_delimiters be memory_pointer_to_string(f24_delimiters_ptr)

    Note: Skip leading f24_delimiters
    Let f24_offset be 0
    Let f24_continue_skip be 1
    While f24_continue_skip is equal to 1:
        Let f24_current_char be memory_get_byte(f24_current_ptr, f24_offset)
        If f24_current_char is equal to 0:
            Let f24_continue_skip be 0
        Otherwise:
            Let f24_is_delim be string_contains_char_value(f24_delimiters, f24_current_char)
            If f24_is_delim is equal to 0:
                Let f24_continue_skip be 0
            Otherwise:
                Let f24_offset be f24_offset plus 1
            End If
        End If
    End While

    Note: Check if we reached end of string
    Let f24_current_char be memory_get_byte(f24_current_ptr, f24_offset)
    If f24_current_char is equal to 0:
        memory_set_pointer(tokenizer, 8, 0)
        Return ""
    End If

    Let f24_token_start_offset be f24_offset

    Note: Find next delimiter
    Let f24_continue_scan be 1
    While f24_continue_scan is equal to 1:
        Let f24_current_char be memory_get_byte(f24_current_ptr, f24_offset)
        If f24_current_char is equal to 0:
            Let f24_continue_scan be 0
        Otherwise:
            Let f24_is_delim be string_contains_char_value(f24_delimiters, f24_current_char)
            If f24_is_delim is equal to 1:
                Let f24_continue_scan be 0
            Otherwise:
                Let f24_offset be f24_offset plus 1
            End If
        End If
    End While

    Note: Extract token
    Let f24_token_length be f24_offset minus f24_token_start_offset
    Let f24_token be memory_get_substring(f24_current_ptr, f24_token_start_offset, f24_token_length)

    Note: Update current position
    Let f24_current_char be memory_get_byte(f24_current_ptr, f24_offset)
    If f24_current_char is not equal to 0:
        memory_set_byte(f24_current_ptr, f24_offset, 0)
        Let f24_new_current be memory_pointer_offset(f24_current_ptr, f24_offset plus 1)
        memory_set_pointer(tokenizer, 8, f24_new_current)
    Otherwise:
        memory_set_pointer(tokenizer, 8, 0)
    End If

    Return f24_token
End Process

Process called "string_tokenizer_has_next" takes tokenizer as Integer returns Integer:
    If tokenizer is equal to 0:
        Return 0
    End If

    Let f25_current_ptr be memory_get_pointer(tokenizer, 8)
    If f25_current_ptr is equal to 0:
        Return 0
    End If

    Let f25_delimiters_ptr be memory_get_pointer(tokenizer, 16)
    Let f25_delimiters be memory_pointer_to_string(f25_delimiters_ptr)

    Note: Skip f25_delimiters to check if there's a token
    Let f25_offset be 0
    Let f25_continue_check be 1
    While f25_continue_check is equal to 1:
        Let f25_temp_char be memory_get_byte(f25_current_ptr, f25_offset)
        If f25_temp_char is equal to 0:
            Let f25_continue_check be 0
        Otherwise:
            Let f25_is_delim be string_contains_char_value(f25_delimiters, f25_temp_char)
            If f25_is_delim is equal to 0:
                Let f25_continue_check be 0
            Otherwise:
                Let f25_offset be f25_offset plus 1
            End If
        End If
    End While

    Let f25_temp_char be memory_get_byte(f25_current_ptr, f25_offset)
    If f25_temp_char is equal to 0:
        Return 0
    End If
    Return 1
End Process

Process called "string_tokenizer_destroy" takes tokenizer as Integer returns Integer:
    If tokenizer is not equal to 0:
        Let f26_own_string be memory_get_byte(tokenizer, 24)
        If f26_own_string is equal to 1:
            Let f26_string_ptr be memory_get_pointer(tokenizer, 0)
            deallocate(f26_string_ptr)
            Let f26_delimiters_ptr be memory_get_pointer(tokenizer, 16)
            deallocate(f26_delimiters_ptr)
        End If
        deallocate(tokenizer)
    End If
    Return 0
End Process

Note: ==== String Array Implementation ====

Process called "string_array_create" returns Integer:
    Let f27_arr be allocate(24)  Note: sizeof(StringArray)
    If f27_arr is equal to 0:
        Return 0
    End If

    Let f27_initial_capacity be 8
    Let f27_strings_ptr be allocate(f27_initial_capacity multiplied by 8)
    If f27_strings_ptr is equal to 0:
        deallocate(f27_arr)
        Return 0
    End If

    memory_set_pointer(f27_arr, 0, f27_strings_ptr)
    memory_set_integer(f27_arr, 8, 0)
    memory_set_integer(f27_arr, 16, f27_initial_capacity)

    Return f27_arr
End Process

Process called "string_array_add" takes arr as Integer, str as String returns Integer:
    If arr is equal to 0:
        Return 0
    End If

    Let f28_count be memory_get_integer(arr, 8)
    Let f28_capacity be memory_get_int32(arr, 16)

    Note: Resize if needed
    If f28_count is greater than or equal to f28_capacity:
        Let f28_new_capacity be f28_capacity multiplied by 2
        Let f28_old_strings be memory_get_pointer(arr, 0)
        Let f28_new_strings be reallocate(f28_old_strings, f28_new_capacity multiplied by 8)
        If f28_new_strings is equal to 0:
            Return 0
        End If
        memory_set_pointer(arr, 0, f28_new_strings)
        memory_set_integer(arr, 16, f28_new_capacity)
    End If

    Note: Add string
    Let f28_strings_ptr be memory_get_pointer(arr, 0)
    Let f28_str_copy be string_duplicate(str)
    Let f28_offset be f28_count multiplied by 8
    memory_set_pointer(f28_strings_ptr, f28_offset, f28_str_copy)

    Note: Update f28_count
    memory_set_integer(arr, 8, f28_count plus 1)

    Return 1
End Process

Process called "string_array_destroy" takes arr as Integer returns Integer:
    If arr is not equal to 0:
        Let f29_count be memory_get_integer(arr, 8)
        Let f29_strings_ptr be memory_get_pointer(arr, 0)

        Note: Free all strings
        Let f29_i be 0
        While f29_i is less than f29_count:
            Let f29_offset be f29_i multiplied by 8
            Let f29_str_ptr be memory_get_pointer(f29_strings_ptr, f29_offset)
            deallocate(f29_str_ptr)
            Let f29_i be f29_i plus 1
        End While

        deallocate(f29_strings_ptr)
        deallocate(arr)
    End If
    Return 0
End Process

Note: ==== Basic String Utilities ====

Process called "string_duplicate" takes str as String returns Integer:
    Let f30_len be string_length(str)
    Let f30_result be allocate(f30_len plus 1)
    If f30_result is equal to 0:
        Return 0
    End If

    memory_copy_string_to_buffer(f30_result, str)
    Return f30_result
End Process

Process called "string_starts_with" takes str as String, prefix as String returns Integer:
    Let f31_str_len be string_length(str)
    Let f31_prefix_len be string_length(prefix)

    If f31_prefix_len is greater than f31_str_len:
        Return 0
    End If

    Let f31_str_prefix be string_substring(str, 0, f31_prefix_len)
    If string_equals(f31_str_prefix, prefix):
        Return 1
    End If
    Return 0
End Process

Process called "string_ends_with" takes str as String, suffix as String returns Integer:
    Let f32_str_len be string_length(str)
    Let f32_suffix_len be string_length(suffix)

    If f32_suffix_len is greater than f32_str_len:
        Return 0
    End If

    Let f32_start_pos be f32_str_len minus f32_suffix_len
    Let f32_str_suffix be string_substring(str, f32_start_pos, f32_suffix_len)
    If string_equals(f32_str_suffix, suffix):
        Return 1
    End If
    Return 0
End Process

Process called "string_contains" takes str as String, substring as String returns Integer:
    Let f33_pos be string_find(str, substring)
    If f33_pos is less than 0:
        Return 0
    End If
    Return 1
End Process

Process called "string_is_empty" takes str as String returns Integer:
    If string_length(str) is equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "string_is_whitespace" takes str as String returns Integer:
    Let f35_len be string_length(str)
    If f35_len is equal to 0:
        Return 1
    End If

    Let f35_i be 0
    While f35_i is less than f35_len:
        Let f35_ch be string_char_at(str, f35_i)
        Let f35_ch_value be ascii_value_of(f35_ch)
        Note: Check for space (32), tab (9), newline (10), carriage return (13)
        Let f35_is_ws be 0
        If f35_ch_value is equal to 32:
            Let f35_is_ws be 1
        Otherwise If f35_ch_value is equal to 9:
            Let f35_is_ws be 1
        Otherwise If f35_ch_value is equal to 10:
            Let f35_is_ws be 1
        Otherwise If f35_ch_value is equal to 13:
            Let f35_is_ws be 1
        End If

        If f35_is_ws is equal to 0:
            Return 0  Note: Found non-whitespace
        End If
        Let f35_i be f35_i plus 1
    End While

    Return 1  Note: All whitespace
End Process

Process called "string_is_numeric" takes str as String returns Integer:
    Let f36_len be string_length(str)
    If f36_len is equal to 0:
        Return 0
    End If

    Let f36_i be 0
    Note: Check for optional leading minus
    Let f36_ch be string_char_at(str, 0)
    Let f36_ch_value be ascii_value_of(f36_ch)
    If f36_ch_value is equal to 45:  Note: '-'
        Let f36_i be 1
        If f36_len is equal to 1:
            Return 0  Note: Just "-" is not numeric
        End If
    End If

    While f36_i is less than f36_len:
        Let f36_ch be string_char_at(str, f36_i)
        Let f36_is_d be is_digit(f36_ch)
        If f36_is_d is equal to 0:
            Return 0
        End If
        Let f36_i be f36_i plus 1
    End While

    Return 1
End Process

Note: ==== Helper Functions ====

Process called "string_contains_char_value" takes str as String, char_value as Integer returns Integer:
    Let f37_len be string_length(str)
    Let f37_i be 0
    While f37_i is less than f37_len:
        Let f37_ch be string_char_at(str, f37_i)
        Let f37_ch_val be ascii_value_of(f37_ch)
        If f37_ch_val is equal to char_value:
            Return 1
        End If
        Let f37_i be f37_i plus 1
    End While
    Return 0
End Process

Process called "string_util_split" takes str as String, delimiter as String returns Integer:
    Let f38_arr be string_array_create()
    If f38_arr is equal to 0:
        Return 0
    End If

    Let f38_tokenizer be string_tokenizer_create(str, delimiter)
    If f38_tokenizer is equal to 0:
        string_array_destroy(f38_arr)
        Return 0
    End If

    Let f38_has_more be string_tokenizer_has_next(f38_tokenizer)
    While f38_has_more is equal to 1:
        Let f38_token be string_tokenizer_next(f38_tokenizer)
        string_array_add(f38_arr, f38_token)
        Let f38_has_more be string_tokenizer_has_next(f38_tokenizer)
    End While

    string_tokenizer_destroy(f38_tokenizer)
    Return f38_arr
End Process

Note: ==== Memory Helper Functions ====
Note: Memory functions are implemented above (lines 177-201) or provided by runtime

Process called "memory_copy_string" takes ptr as Integer, offset as Integer, str as String returns Integer:
    Note: Copy string to ptr + offset
    Let f39_dest be ptr plus offset
    Let f39_src be str  Note: String is already a pointer
    Let f39_i be 0
    Let f39_continue_loop be 1

    While f39_continue_loop is equal to 1:
        Let f39_char be memory_get_byte(f39_src, f39_i)
        memory_set_byte(f39_dest, f39_i, f39_char)
        If f39_char is equal to 0:
            Let f39_continue_loop be 0
        Otherwise:
            Let f39_i be f39_i plus 1
        End If
    End While

    Return f39_i  Note: Return number of bytes copied (excluding null)
End Process

Process called "memory_copy_string_to_buffer" takes ptr as Integer, str as String returns Integer:
    Note: Copy string to buffer at ptr, return bytes copied
    Let f40_src be str  Note: String is already a pointer
    Let f40_i be 0
    Let f40_continue_loop be 1

    While f40_continue_loop is equal to 1:
        Let f40_char be memory_get_byte(f40_src, f40_i)
        memory_set_byte(ptr, f40_i, f40_char)
        If f40_char is equal to 0:
            Let f40_continue_loop be 0
        Otherwise:
            Let f40_i be f40_i plus 1
        End If
    End While

    Return f40_i  Note: Return number of bytes copied (excluding null)
End Process

Process called "memory_pointer_offset" takes ptr as Integer, offset as Integer returns Integer:
    Note: Runtime function to calculate ptr + offset
    Return ptr plus offset
End Process

Note: Additional helper functions needed by string_utils

Process called "memory_allocate" takes size as Integer returns Integer:
    Note: Wrapper for runtime allocate function
    Return allocate(size)
End Process

Note: system_call, memory_pointer_to_string, memory_get_substring are provided by runtime

Note: memory_set_pointer_at_index and memory_get_pointer_at_index removed - not needed

Note: reallocate is provided by the runtime (runtime_system.c)
Note: It properly copies old data to the new locationNote: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Hash Table Implementation - Line-for-line transliteration from hashtable.c
Note: Preserves exact hash function (djb2), collision handling, and resize logic

Note: ==== Type Definitions ====
Note: WORKAROUND: Types commented out due to v0.0.7.3 bug with Type+Let combo
Note: Once v0.0.7.5 is self-hosted, uncomment these

Note: Type called "HashEntry":
Note:     key as Integer,       Note: Pointer to key
Note:     value as Integer,     Note: Pointer to value
Note:     next as Integer       Note: Pointer to next entry (for chaining)
Note: End Type

Note: Type called "HashTable":
Note:     buckets as Integer,       Note: Pointer to array of HashEntry pointers
Note:     bucket_count as Integer,  Note: Number of buckets
Note:     entry_count as Integer,   Note: Number of entries
Note:     hash_func as Integer,     Note: Function pointer for hash function
Note:     compare_func as Integer,  Note: Function pointer for comparison
Note:     free_key as Integer,      Note: Function pointer for key destructor
Note:     free_value as Integer     Note: Function pointer for value destructor
Note: End Type

Note: Type called "HashIterator":
Note:     table as Integer,         Note: Pointer to HashTable
Note:     bucket_index as Integer,  Note: Current bucket index
Note:     current_entry as Integer  Note: Pointer to current HashEntry
Note: End Type

Note: Type called "HashTableStats":
Note:     bucket_count as Integer,
Note:     entry_count as Integer,
Note:     empty_buckets as Integer,
Note:     max_chain_length as Integer,
Note:     average_chain_length as Integer,  Note: Using Integer for simplicity (multiplied by 100)
Note:     load_factor as Integer            Note: Using Integer for simplicity (multiplied by 100)
Note: End Type

Note: ==== Hash Table Creation and Destruction ====

Process called "hashtable_create" takes initial_buckets as Integer, hash_func as Integer, compare_func as Integer returns Integer:
    Return hashtable_create_with_destructors(initial_buckets, hash_func, compare_func, 0, 0)
End Process

Process called "hashtable_create_with_destructors" takes initial_buckets as Integer, hash_func as Integer, compare_func as Integer, free_key as Integer, free_value as Integer returns Integer:
    If initial_buckets is equal to 0:
        Return 0
    End If
    If hash_func is equal to 0:
        Return 0
    End If
    If compare_func is equal to 0:
        Return 0
    End If

    Let table be allocate(56)  Note: sizeof(HashTable)
    If table is equal to 0:
        Return 0
    End If

    Let buckets_size be initial_buckets multiplied by 8
    Let buckets be allocate(buckets_size)
    If buckets is equal to 0:
        deallocate(table)
        Return 0
    End If

    Note: Initialize buckets to NULL
    Let i be 0
    While i is less than initial_buckets:
        memory_set_pointer_at_index(buckets, i, 0)
        Set i to i plus 1
    End While

    memory_set_pointer(table, 0, buckets)  Note: buckets
    memory_set_int32(table, 8, initial_buckets)  Note: bucket_count
    memory_set_int32(table, 16, 0)  Note: entry_count
    memory_set_pointer(table, 24, hash_func)  Note: hash_func
    memory_set_pointer(table, 32, compare_func)  Note: compare_func
    memory_set_pointer(table, 40, free_key)  Note: free_key
    memory_set_pointer(table, 48, free_value)  Note: free_value

    Return table
End Process

Process called "hashtable_destroy" takes table as Integer returns Integer:
    If table is equal to 0:
        Return 0
    End If

    Note: Clear all entries
    hashtable_clear(table)

    Note: Free the buckets array
    Let buckets be memory_get_pointer(table, 0)
    deallocate(buckets)

    Note: Free the table itself
    deallocate(table)

    Return 0
End Process

Note: ==== Hash Table Operations ====

Process called "hashtable_put" takes table as Integer, key as Integer, value as Integer returns Integer:
    If table is equal to 0:
        Return 0
    End If
    If key is equal to 0:
        Return 0
    End If

    Let hash_func be memory_get_pointer(table, 24)
    Let hash be call_function_1(hash_func, key)
    Let bucket_count be memory_get_int32(table, 8)
    Note: hash modulo bucket_count = hash - (hash / bucket_count) * bucket_count
    Let hash_div_count be hash divided by bucket_count
    Let hash_mult_count be hash_div_count multiplied by bucket_count
    Let bucket_index be hash minus hash_mult_count

    Let buckets be memory_get_pointer(table, 0)
    Let current be memory_get_pointer_at_index(buckets, bucket_index)
    Let prev be 0

    Note: Search for existing key
    Let continue_search be 1
    While continue_search is equal to 1:
        If current is equal to 0:
            Set continue_search to 0
        Otherwise:
            Let current_key be memory_get_pointer(current, 0)
            Let compare_func be memory_get_pointer(table, 32)
            Let is_match be call_function_2(compare_func, current_key, key)
            If is_match is equal to 1:
                Note: Key exists, update value
                Let free_value be memory_get_pointer(table, 48)
                Let current_value be memory_get_pointer(current, 8)
                If free_value is not equal to 0:
                    If current_value is not equal to 0:
                        call_function_1(free_value, current_value)
                    End If
                End If
                memory_set_pointer(current, 8, value)
                Return 1
            End If
            Set prev to current
            Set current to memory_get_pointer(current, 16)  Note: next
        End If
    End While

    Note: Key doesn't exist, create new entry
    Let new_entry be allocate(24)  Note: sizeof(HashEntry)
    If new_entry is equal to 0:
        Return 0
    End If

    memory_set_pointer(new_entry, 0, key)
    memory_set_pointer(new_entry, 8, value)
    memory_set_pointer(new_entry, 16, 0)  Note: next = NULL

    If prev is not equal to 0:
        memory_set_pointer(prev, 16, new_entry)
    Otherwise:
        memory_set_pointer_at_index(buckets, bucket_index, new_entry)
    End If

    Let entry_count be memory_get_integer(table, 16)
    memory_set_integer(table, 16, entry_count plus 1)

    Return 1
End Process

Process called "hashtable_get" takes table as Integer, key as Integer returns Integer:
    If table is equal to 0:
        Return 0
    End If
    If key is equal to 0:
        Return 0
    End If

    Let hash_func be memory_get_pointer(table, 24)
    Let hash be call_function_1(hash_func, key)
    Let bucket_count be memory_get_int32(table, 8)
    Note: hash modulo bucket_count = hash - (hash / bucket_count) * bucket_count
    Let hash_div_count be hash divided by bucket_count
    Let hash_mult_count be hash_div_count multiplied by bucket_count
    Let bucket_index be hash minus hash_mult_count

    Let buckets be memory_get_pointer(table, 0)
    Let current be memory_get_pointer_at_index(buckets, bucket_index)

    While current is not equal to 0:
        Let current_key be memory_get_pointer(current, 0)
        Let compare_func be memory_get_pointer(table, 32)
        Let is_match be call_function_2(compare_func, current_key, key)
        If is_match is equal to 1:
            Return memory_get_pointer(current, 8)  Note: return value
        End If
        Set current to memory_get_pointer(current, 16)  Note: next
    End While

    Return 0
End Process

Process called "hashtable_remove" takes table as Integer, key as Integer returns Integer:
    If table is equal to 0:
        Return 0
    End If
    If key is equal to 0:
        Return 0
    End If

    Let hash_func be memory_get_pointer(table, 24)
    Let hash be call_function_1(hash_func, key)
    Let bucket_count be memory_get_int32(table, 8)
    Note: hash modulo bucket_count = hash - (hash / bucket_count) * bucket_count
    Let hash_div_count be hash divided by bucket_count
    Let hash_mult_count be hash_div_count multiplied by bucket_count
    Let bucket_index be hash minus hash_mult_count

    Let buckets be memory_get_pointer(table, 0)
    Let current be memory_get_pointer_at_index(buckets, bucket_index)
    Let prev be 0

    While current is not equal to 0:
        Let current_key be memory_get_pointer(current, 0)
        Let compare_func be memory_get_pointer(table, 32)
        Let is_match be call_function_2(compare_func, current_key, key)
        If is_match is equal to 1:
            Note: Found the entry to remove
            Let next be memory_get_pointer(current, 16)
            If prev is not equal to 0:
                memory_set_pointer(prev, 16, next)
            Otherwise:
                memory_set_pointer_at_index(buckets, bucket_index, next)
            End If

            Note: Free key and value if destructors are provided
            Let free_key be memory_get_pointer(table, 40)
            If free_key is not equal to 0:
                If current_key is not equal to 0:
                    call_function_1(free_key, current_key)
                End If
            End If

            Let free_value be memory_get_pointer(table, 48)
            Let current_value be memory_get_pointer(current, 8)
            If free_value is not equal to 0:
                If current_value is not equal to 0:
                    call_function_1(free_value, current_value)
                End If
            End If

            deallocate(current)

            Let entry_count be memory_get_integer(table, 16)
            memory_set_integer(table, 16, entry_count minus 1)

            Return 1
        End If
        Set prev to current
        Set current to memory_get_pointer(current, 16)  Note: next
    End While

    Return 0
End Process

Process called "hashtable_contains" takes table as Integer, key as Integer returns Integer:
    Let value be hashtable_get(table, key)
    If value is not equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "hashtable_size" takes table as Integer returns Integer:
    If table is not equal to 0:
        Return memory_get_int32(table, 16)  Note: entry_count
    End If
    Return 0
End Process

Process called "hashtable_clear" takes table as Integer returns Integer:
    If table is equal to 0:
        Return 0
    End If

    Let bucket_count be memory_get_integer(table, 8)
    Let buckets be memory_get_pointer(table, 0)
    Let free_key be memory_get_pointer(table, 40)
    Let free_value be memory_get_pointer(table, 48)

    Let i be 0
    While i is less than bucket_count:
        Let current be memory_get_pointer_at_index(buckets, i)
        While current is not equal to 0:
            Let next be memory_get_pointer(current, 16)

            Note: Free key and value if destructors are provided
            If free_key is not equal to 0:
                Let current_key be memory_get_pointer(current, 0)
                If current_key is not equal to 0:
                    call_function_1(free_key, current_key)
                End If
            End If

            If free_value is not equal to 0:
                Let current_value be memory_get_pointer(current, 8)
                If current_value is not equal to 0:
                    call_function_1(free_value, current_value)
                End If
            End If

            deallocate(current)
            Set current to next
        End While
        memory_set_pointer_at_index(buckets, i, 0)
        Set i to i plus 1
    End While

    memory_set_int32(table, 16, 0)  Note: entry_count = 0

    Return 0
End Process

Note: ==== Iterator Implementation ====

Process called "hashtable_iterator_create" takes table as Integer returns Integer:
    If table is equal to 0:
        Return 0
    End If

    Let iter be allocate(24)  Note: sizeof(HashIterator)
    If iter is equal to 0:
        Return 0
    End If

    memory_set_pointer(iter, 0, table)
    memory_set_integer(iter, 8, 0)  Note: bucket_index
    memory_set_pointer(iter, 16, 0)  Note: current_entry

    Note: Find the first non-empty bucket
    Let bucket_count be memory_get_integer(table, 8)
    Let buckets be memory_get_pointer(table, 0)

    Let i be 0
    While i is less than bucket_count:
        Let entry be memory_get_pointer_at_index(buckets, i)
        If entry is not equal to 0:
            memory_set_integer(iter, 8, i)
            memory_set_pointer(iter, 16, entry)
            Return iter
        End If
        Set i to i plus 1
    End While

    Return iter
End Process

Process called "hashtable_iterator_has_next" takes iter as Integer returns Integer:
    If iter is equal to 0:
        Return 0
    End If
    Let current_entry be memory_get_pointer(iter, 16)
    If current_entry is not equal to 0:
        Return 1
    End If
    Return 0
End Process

Process called "hashtable_iterator_next" takes iter as Integer, key_ptr as Integer, value_ptr as Integer returns Integer:
    If iter is equal to 0:
        If key_ptr is not equal to 0:
            memory_set_pointer(key_ptr, 0, 0)
        End If
        If value_ptr is not equal to 0:
            memory_set_pointer(value_ptr, 0, 0)
        End If
        Return 0
    End If

    Let current_entry be memory_get_pointer(iter, 16)
    If current_entry is equal to 0:
        If key_ptr is not equal to 0:
            memory_set_pointer(key_ptr, 0, 0)
        End If
        If value_ptr is not equal to 0:
            memory_set_pointer(value_ptr, 0, 0)
        End If
        Return 0
    End If

    Note: Return current entry's key and value
    If key_ptr is not equal to 0:
        Let key be memory_get_pointer(current_entry, 0)
        memory_set_pointer(key_ptr, 0, key)
    End If
    If value_ptr is not equal to 0:
        Let value be memory_get_pointer(current_entry, 8)
        memory_set_pointer(value_ptr, 0, value)
    End If

    Note: Move to next entry
    Let next_entry be memory_get_pointer(current_entry, 16)
    memory_set_pointer(iter, 16, next_entry)

    Note: If no more entries in current bucket, find next non-empty bucket
    If next_entry is equal to 0:
        Let table be memory_get_pointer(iter, 0)
        Let bucket_count be memory_get_integer(table, 8)
        Let buckets be memory_get_pointer(table, 0)
        Let bucket_index be memory_get_integer(iter, 8)

        Let i be bucket_index plus 1
        While i is less than bucket_count:
            Let entry be memory_get_pointer_at_index(buckets, i)
            If entry is not equal to 0:
                memory_set_integer(iter, 8, i)
                memory_set_pointer(iter, 16, entry)
                Return 1
            End If
            Set i to i plus 1
        End While
    End If

    Return 1
End Process

Process called "hashtable_iterator_destroy" takes iter as Integer returns Integer:
    deallocate(iter)
    Return 0
End Process

Note: ==== Hash Functions ====

Note: Hash function for string keys (djb2 algorithm) - EXACT PRESERVATION
Process called "hash_string" takes key as Integer returns Integer:
    Let str_ptr be key
    Let hash be 5381

    Let c be memory_get_byte(str_ptr, 0)
    Let offset be 0
    While c is not equal to 0:
        Note: hash = ((hash << 5) + hash) + c  which is hash * 33 + c
        Note: Using hash * 32 for now - bit_shift_left not available in v0.0.7.5
        Let hash_shifted be hash multiplied by 32
        Set hash to hash_shifted plus hash
        Set hash to hash plus c
        Set offset to offset plus 1
        Set c to memory_get_byte(str_ptr, offset)
    End While

    Return hash
End Process

Note: Compare function for string keys
Process called "compare_strings" takes key1 as Integer, key2 as Integer returns Integer:
    Let result be string_compare(key1, key2)
    If result is equal to 0:
        Return 1
    End If
    Return 0
End Process

Note: Hash function for integer keys - EXACT PRESERVATION of mixing algorithm
Process called "hash_integer" takes key as Integer returns Integer:
    Note: Treat the pointer as pointing to an integer
    Let value be memory_get_integer(key, 0)

    Note: Simple arithmetic hash mixing without bitwise operations
    Note: Use multiplication and modulo for distribution
    Let magic1 be 13787848793156543929  Note: 0xbf58476d1ce4e5b9
    Set value to value multiplied by magic1

    Note: Add some mixing with division and modulo
    Let temp be value divided by 1073741824  Note: 2^30
    Set value to value plus temp

    Let magic2 be 10723151780598845931  Note: 0x94d049bb133111eb
    Set value to value multiplied by magic2

    Note: Final mixing
    Let temp2 be value divided by 134217728  Note: 2^27
    Set value to value plus temp2

    Note: Ensure positive value
    If value is less than 0:
        Set value to -value
    End If

    Return value
End Process

Note: Compare function for integer keys
Process called "compare_integers" takes key1 as Integer, key2 as Integer returns Integer:
    Let val1 be memory_get_integer(key1, 0)
    Let val2 be memory_get_integer(key2, 0)
    If val1 is equal to val2:
        Return 1
    End If
    Return 0
End Process

Note: Hash function for pointer keys
Process called "hash_pointer" takes key as Integer returns Integer:
    Note: Hash the pointer value itself
    Let ptr_value be key

    Note: Mix using arithmetic operations instead of bitwise
    Note: Divide by 2^32 and add to original for mixing
    Let temp be ptr_value divided by 4294967296  Note: 2^32
    Set ptr_value to ptr_value plus temp

    Note: ptr_value = ptr_value * 0x9e3779b97f4a7c15ULL
    Let magic be 11400714819323198485  Note: 0x9e3779b97f4a7c15
    Set ptr_value to ptr_value multiplied by magic

    Note: Final mixing with division
    Let temp2 be ptr_value divided by 4294967296  Note: 2^32
    Set ptr_value to ptr_value plus temp2

    Note: Ensure positive value
    If ptr_value is less than 0:
        Set ptr_value to -ptr_value
    End If

    Return ptr_value
End Process

Note: Compare function for pointer keys
Process called "compare_pointers" takes key1 as Integer, key2 as Integer returns Integer:
    If key1 is equal to key2:
        Return 1
    End If
    Return 0
End Process

Note: ==== Statistics ====

Process called "hashtable_get_stats" takes table as Integer, stats as Integer returns Integer:
    If table is equal to 0:
        Note: Initialize stats to zero
        memory_set_int32(stats, 0, 0)  Note: bucket_count
        memory_set_int32(stats, 8, 0)  Note: entry_count
        memory_set_integer(stats, 16, 0)  Note: empty_buckets
        memory_set_integer(stats, 24, 0)  Note: max_chain_length
        memory_set_integer(stats, 32, 0)  Note: average_chain_length
        memory_set_integer(stats, 40, 0)  Note: load_factor
        Return 0
    End If

    Let bucket_count be memory_get_integer(table, 8)
    Let entry_count be memory_get_integer(table, 16)
    Let buckets be memory_get_pointer(table, 0)

    memory_set_integer(stats, 0, bucket_count)
    memory_set_integer(stats, 8, entry_count)

    Let total_chain_length be 0
    Let max_chain_length be 0
    Let empty_buckets be 0

    Let i be 0
    While i is less than bucket_count:
        Let current be memory_get_pointer_at_index(buckets, i)
        If current is equal to 0:
            Set empty_buckets to empty_buckets plus 1
        Otherwise:
            Let chain_length be 0
            While current is not equal to 0:
                Set chain_length to chain_length plus 1
                Set current to memory_get_pointer(current, 16)  Note: next
            End While
            Set total_chain_length to total_chain_length plus chain_length
            If chain_length is greater than max_chain_length:
                Set max_chain_length to chain_length
            End If
        End If
        Set i to i plus 1
    End While

    memory_set_integer(stats, 16, empty_buckets)
    memory_set_integer(stats, 24, max_chain_length)

    Note: Calculate average chain length (multiplied by 100 for integer representation)
    Let non_empty_buckets be bucket_count minus empty_buckets
    Let average_chain_length be 0
    If non_empty_buckets is greater than 0:
        Set average_chain_length to total_chain_length multiplied by 100
        Set average_chain_length to average_chain_length divided by non_empty_buckets
    End If
    memory_set_integer(stats, 32, average_chain_length)

    Note: Calculate load factor (multiplied by 100 for integer representation)
    Let load_factor be entry_count multiplied by 100
    Set load_factor to load_factor divided by bucket_count
    memory_set_integer(stats, 40, load_factor)

    Return 1
End Process

Process called "hashtable_print_stats" takes table as Integer returns Integer:
    Let stats be allocate(48)  Note: sizeof(HashTableStats)
    hashtable_get_stats(table, stats)

    print_string("Hash Table Statistics:")
    print_string("  Bucket count: ")
    print_integer(memory_get_integer(stats, 0))
    print_string("  Entry count: ")
    print_integer(memory_get_integer(stats, 8))
    print_string("  Empty buckets: ")
    print_integer(memory_get_integer(stats, 16))
    print_string("  Max chain length: ")
    print_integer(memory_get_integer(stats, 24))
    print_string("  Average chain length: ")
    print_integer(memory_get_integer(stats, 32))  Note: Already multiplied by 100
    print_string("  Load factor: ")
    print_integer(memory_get_integer(stats, 40))  Note: Already multiplied by 100

    deallocate(stats)
    Return 0
End Process

Note: ==== Memory Helper Functions ====

Process called "call_function_1" takes func as Integer, arg1 as Integer returns Integer:
    Note: This will be implemented by runtime to call function pointer with 1 arg
    Return 0
End Process

Process called "call_function_2" takes func as Integer, arg1 as Integer, arg2 as Integer returns Integer:
    Note: This will be implemented by runtime to call function pointer with 2 args
    Return 0
End Process

Note: Runtime memory functions - provided by C runtime library
Note: memory_get_byte, memory_set_pointer, memory_get_pointer are external

Note: memory_set_integer and memory_get_integer are external runtime functions
Note: They will be linked from the C runtime (runtime_system.c)
Note: No Runa implementation needed - the compiler will generate PLT calls

Note: More runtime functions - provided by C runtime library
Note: memory_set_pointer_at_index, memory_get_pointer_at_index
Note: allocate, deallocate, string_compare are all externalNote: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Container implementations
Note: Transliterated from containers.c - line-by-line preservation

Note: ==== Vector Implementation ====

Note: Vector structure:
Note: offset 0: items (pointer to array of pointers)
Note: offset 8: capacity
Note: offset 16: size
Note: offset 24: free_item function pointer

Process called "vector_create" takes dummy as Integer returns Integer:
    Let initial_cap be 16
    Let result be vector_create_with_capacity(initial_cap)
    Return result
End Process

Process called "vector_create_with_capacity" takes initial_capacity as Integer returns Integer:
    Let vec be memory_allocate(32)  Note: sizeof(Vector) = 32
    If vec is equal to 0:
        Return 0
    End If

    Let items_size be initial_capacity multiplied by 8  Note: sizeof(void*) = 8
    Let items be memory_allocate(items_size)
    If items is equal to 0:
        deallocate(vec)
        Return 0
    End If

    memory_set_pointer(vec, 0, items)           Note: vec->items = items
    memory_set_int32(vec, 8, initial_capacity) Note: vec->capacity = initial_capacity
    memory_set_int32(vec, 16, 0)              Note: vec->size = 0
    memory_set_pointer(vec, 24, 0)              Note: vec->free_item = NULL
    Return vec
End Process

Process called "vector_create_with_destructor" takes free_item as Integer returns Integer:
    Let vec be vector_create()
    If vec is not equal to 0:
        memory_set_integer(vec, 24, free_item)  Note: vec->free_item = free_item
    End If
    Return vec
End Process

Process called "vector_destroy" takes vec as Integer returns Integer:
    If vec is equal to 0:
        Return 0
    End If

    Let free_item be memory_get_pointer(vec, 24)
    If free_item is not equal to 0:
        Let size be memory_get_integer(vec, 16)
        Let items be memory_get_pointer(vec, 0)
        Let i be 0
        While i is less than size:
            Let item_offset be i multiplied by 8
            Let item be memory_get_pointer(items, item_offset)
            If item is not equal to 0:
                Note: call_function_pointer(free_item, item)
            End If
            Set i to i plus 1
        End While
    End If

    Let items be memory_get_pointer(vec, 0)
    deallocate(items)
    deallocate(vec)
    Return 0
End Process

Process called "vector_push" takes vec as Integer, item as Integer returns Integer:
    If vec is equal to 0:
        Return 0  Note: false
    End If

    Let size be memory_get_integer(vec, 16)
    Let capacity be memory_get_integer(vec, 8)

    If size is greater than or equal to capacity:
        Let new_capacity be capacity multiplied by 2
        Let new_size be new_capacity multiplied by 8
        Let items be memory_get_pointer(vec, 0)
        Let new_items be memory_reallocate(items, new_size)
        If new_items is equal to 0:
            Return 0  Note: false
        End If

        memory_set_pointer(vec, 0, new_items)       Note: vec->items = new_items
        memory_set_int32(vec, 8, new_capacity)    Note: vec->capacity = new_capacity
    End If

    Let items be memory_get_pointer(vec, 0)
    Let item_offset be size multiplied by 8
    memory_set_pointer(items, item_offset, item)    Note: vec->items[size] = item

    Set size to size plus 1
    memory_set_int32(vec, 16, size)               Note: vec->size++
    Return 1  Note: true
End Process

Process called "vector_pop" takes vec as Integer returns Integer:
    If vec is equal to 0:
        Return 0
    End If

    Let size be memory_get_integer(vec, 16)
    If size is equal to 0:
        Return 0
    End If

    Set size to size minus 1
    memory_set_int32(vec, 16, size)    Note: --vec->size

    Let items be memory_get_pointer(vec, 0)
    Let item_offset be size multiplied by 8
    Let item be memory_get_pointer(items, item_offset)
    Return item
End Process

Process called "vector_get" takes vec as Integer, index as Integer returns Integer:
    If vec is equal to 0:
        Return 0
    End If

    Let size be memory_get_integer(vec, 16)
    If index is greater than or equal to size:
        Return 0
    End If

    Let items be memory_get_pointer(vec, 0)
    Let item_offset be index multiplied by 8
    Let item be memory_get_pointer(items, item_offset)
    Return item
End Process

Process called "vector_set" takes vec as Integer, index as Integer, item as Integer returns Integer:
    If vec is equal to 0:
        Return 0  Note: false
    End If

    Let size be memory_get_integer(vec, 16)
    If index is greater than or equal to size:
        Return 0  Note: false
    End If

    Let free_item be memory_get_pointer(vec, 24)
    Let items be memory_get_pointer(vec, 0)
    Let item_offset be index multiplied by 8

    If free_item is not equal to 0:
        Let old_item be memory_get_pointer(items, item_offset)
        If old_item is not equal to 0:
            Note: call_function_pointer(free_item, old_item)
        End If
    End If

    memory_set_pointer(items, item_offset, item)
    Return 1  Note: true
End Process

Process called "vector_insert" takes vec as Integer, index as Integer, item as Integer returns Integer:
    If vec is equal to 0:
        Return 0  Note: false
    End If

    Let size be memory_get_integer(vec, 16)
    If index is greater than size:
        Return 0  Note: false
    End If

    Let capacity be memory_get_integer(vec, 8)
    If size is greater than or equal to capacity:
        Let new_capacity be capacity multiplied by 2
        Let new_size be new_capacity multiplied by 8
        Let items be memory_get_pointer(vec, 0)
        Let new_items be memory_reallocate(items, new_size)
        If new_items is equal to 0:
            Return 0  Note: false
        End If

        memory_set_pointer(vec, 0, new_items)
        memory_set_integer(vec, 8, new_capacity)
    End If

    Note: Shift elements to the right
    Let items be memory_get_pointer(vec, 0)
    Let i be size
    While i is greater than index:
        Let i_minus_1 be i minus 1
        Let src_offset be i_minus_1 multiplied by 8
        Let dst_offset be i multiplied by 8
        Let value be memory_get_pointer(items, src_offset)
        memory_set_pointer(items, dst_offset, value)
        Set i to i minus 1
    End While

    Let item_offset be index multiplied by 8
    memory_set_pointer(items, item_offset, item)

    Set size to size plus 1
    memory_set_integer(vec, 16, size)
    Return 1  Note: true
End Process

Process called "vector_remove" takes vec as Integer, index as Integer returns Integer:
    If vec is equal to 0:
        Return 0  Note: false
    End If

    Let size be memory_get_integer(vec, 16)
    If index is greater than or equal to size:
        Return 0  Note: false
    End If

    Let free_item be memory_get_pointer(vec, 24)
    Let items be memory_get_pointer(vec, 0)

    If free_item is not equal to 0:
        Let item_offset be index multiplied by 8
        Let old_item be memory_get_pointer(items, item_offset)
        If old_item is not equal to 0:
            Note: call_function_pointer(free_item, old_item)
        End If
    End If

    Note: Shift elements to the left
    Let size_minus_1 be size minus 1
    Let i be index
    While i is less than size_minus_1:
        Let i_plus_1 be i plus 1
        Let src_offset be i_plus_1 multiplied by 8
        Let dst_offset be i multiplied by 8
        Let value be memory_get_pointer(items, src_offset)
        memory_set_pointer(items, dst_offset, value)
        Set i to i plus 1
    End While

    Set size to size_minus_1
    memory_set_integer(vec, 16, size)
    Return 1  Note: true
End Process

Process called "vector_clear" takes vec as Integer returns Integer:
    If vec is equal to 0:
        Return 0
    End If

    Let free_item be memory_get_pointer(vec, 24)
    If free_item is not equal to 0:
        Let size be memory_get_integer(vec, 16)
        Let items be memory_get_pointer(vec, 0)
        Let i be 0
        While i is less than size:
            Let item_offset be i multiplied by 8
            Let item be memory_get_pointer(items, item_offset)
            If item is not equal to 0:
                Note: call_function_pointer(free_item, item)
            End If
            Set i to i plus 1
        End While
    End If

    memory_set_int32(vec, 16, 0)  Note: vec->size = 0
    Return 0
End Process

Process called "vector_size" takes vec as Integer returns Integer:
    If vec is not equal to 0:
        Return memory_get_integer(vec, 16)
    Otherwise:
        Return 0
    End If
End Process

Process called "vector_capacity" takes vec as Integer returns Integer:
    If vec is not equal to 0:
        Return memory_get_integer(vec, 8)
    Otherwise:
        Return 0
    End If
End Process

Process called "vector_is_empty" takes vec as Integer returns Integer:
    If vec is equal to 0:
        Return 1  Note: true
    End If

    Let size be memory_get_integer(vec, 16)
    If size is equal to 0:
        Return 1  Note: true
    Otherwise:
        Return 0  Note: false
    End If
End Process

Process called "vector_reserve" takes vec as Integer, new_capacity as Integer returns Integer:
    If vec is equal to 0:
        Return 0  Note: false
    End If

    Let capacity be memory_get_integer(vec, 8)
    If new_capacity is less than or equal to capacity:
        Return 0  Note: false
    End If

    Let new_size be new_capacity multiplied by 8
    Let items be memory_get_pointer(vec, 0)
    Let new_items be memory_reallocate(items, new_size)
    If new_items is equal to 0:
        Return 0  Note: false
    End If

    memory_set_pointer(vec, 0, new_items)
    memory_set_integer(vec, 8, new_capacity)
    Return 1  Note: true
End Process

Process called "vector_shrink_to_fit" takes vec as Integer returns Integer:
    If vec is equal to 0:
        Return 1  Note: true
    End If

    Let size be memory_get_integer(vec, 16)
    Let capacity be memory_get_integer(vec, 8)
    If size is equal to capacity:
        Return 1  Note: true
    End If

    Let new_size be size multiplied by 8
    Let items be memory_get_pointer(vec, 0)
    Let new_items be memory_reallocate(items, new_size)

    Note: Check if realloc failed and size > 0
    Let failed be 0
    If new_items is equal to 0:
        If size is greater than 0:
            Set failed to 1
        End If
    End If

    If failed is equal to 1:
        Return 0  Note: false
    End If

    memory_set_pointer(vec, 0, new_items)
    memory_set_integer(vec, 8, size)
    Return 1  Note: true
End Process

Process called "vector_begin" takes vec as Integer returns Integer:
    If vec is not equal to 0:
        Return memory_get_pointer(vec, 0)
    Otherwise:
        Return 0
    End If
End Process

Process called "vector_end" takes vec as Integer returns Integer:
    If vec is not equal to 0:
        Let items be memory_get_pointer(vec, 0)
        Let size be memory_get_integer(vec, 16)
        Let offset be size multiplied by 8
        Return items plus offset
    Otherwise:
        Return 0
    End If
End Process

Process called "vector_foreach" takes vec as Integer, callback as Integer returns Integer:
    If vec is equal to 0:
        Return 0
    End If
    If callback is equal to 0:
        Return 0
    End If

    Let size be memory_get_integer(vec, 16)
    Let items be memory_get_pointer(vec, 0)
    Let i be 0
    While i is less than size:
        Let item_offset be i multiplied by 8
        Let item be memory_get_pointer(items, item_offset)
        Note: call_function_pointer(callback, item)
        Set i to i plus 1
    End While
    Return 0
End Process

Note: ==== Stack Implementation ====

Note: Stack structure:
Note: offset 0: vec (pointer to Vector)

Process called "stack_create" takes dummy as Integer returns Integer:
    Let stack be memory_allocate(8)  Note: sizeof(Stack) = 8
    If stack is equal to 0:
        Return 0
    End If

    Let vec be vector_create()
    If vec is equal to 0:
        deallocate(stack)
        Return 0
    End If

    memory_set_pointer(stack, 0, vec)
    Return stack
End Process

Process called "stack_create_with_destructor" takes free_item as Integer returns Integer:
    Let stack be memory_allocate(8)
    If stack is equal to 0:
        Return 0
    End If

    Let vec be vector_create_with_destructor(free_item)
    If vec is equal to 0:
        deallocate(stack)
        Return 0
    End If

    memory_set_pointer(stack, 0, vec)
    Return stack
End Process

Process called "stack_destroy" takes stack as Integer returns Integer:
    If stack is equal to 0:
        Return 0
    End If

    Let vec be memory_get_pointer(stack, 0)
    vector_destroy(vec)
    deallocate(stack)
    Return 0
End Process

Process called "stack_push" takes stack as Integer, item as Integer returns Integer:
    If stack is not equal to 0:
        Let vec be memory_get_pointer(stack, 0)
        Let result be vector_push(vec, item)
        Return result
    Otherwise:
        Return 0  Note: false
    End If
End Process

Process called "stack_pop" takes stack as Integer returns Integer:
    If stack is not equal to 0:
        Let vec be memory_get_pointer(stack, 0)
        Let result be vector_pop(vec)
        Return result
    Otherwise:
        Return 0
    End If
End Process

Process called "stack_peek" takes stack as Integer returns Integer:
    If stack is equal to 0:
        Return 0
    End If

    Let vec be memory_get_pointer(stack, 0)
    Let is_empty be vector_is_empty(vec)
    If is_empty is equal to 1:
        Return 0
    End If

    Let size be memory_get_integer(vec, 16)
    Let index be size minus 1
    Let result be vector_get(vec, index)
    Return result
End Process

Process called "stack_size" takes stack as Integer returns Integer:
    If stack is not equal to 0:
        Let vec be memory_get_pointer(stack, 0)
        Let result be vector_size(vec)
        Return result
    Otherwise:
        Return 0
    End If
End Process

Process called "stack_is_empty" takes stack as Integer returns Integer:
    If stack is equal to 0:
        Return 1  Note: true
    End If

    Let vec be memory_get_pointer(stack, 0)
    Let result be vector_is_empty(vec)
    Return result
End Process

Process called "stack_clear" takes stack as Integer returns Integer:
    If stack is not equal to 0:
        Let vec be memory_get_pointer(stack, 0)
        vector_clear(vec)
    End If
    Return 0
End Process

Note: ==== Queue Implementation ====

Note: Queue structure:
Note: offset 0: items (pointer to array)
Note: offset 8: capacity
Note: offset 16: front
Note: offset 24: rear
Note: offset 32: size
Note: offset 40: free_item function pointer

Process called "queue_create" takes dummy as Integer returns Integer:
    Let initial_cap be 16
    Let result be queue_create_with_capacity(initial_cap)
    Return result
End Process

Process called "queue_create_with_capacity" takes initial_capacity as Integer returns Integer:
    Let queue be memory_allocate(48)  Note: sizeof(Queue) = 48
    If queue is equal to 0:
        Return 0
    End If

    Let items_size be initial_capacity multiplied by 8
    Let items be memory_allocate(items_size)
    If items is equal to 0:
        deallocate(queue)
        Return 0
    End If

    memory_set_integer(queue, 0, items)            Note: queue->items = items
    memory_set_int32(queue, 8, initial_capacity) Note: queue->capacity = initial_capacity
    memory_set_integer(queue, 16, 0)               Note: queue->front = 0
    memory_set_integer(queue, 24, 0)               Note: queue->rear = 0
    memory_set_int32(queue, 32, 0)               Note: queue->size = 0
    memory_set_integer(queue, 40, 0)               Note: queue->free_item = NULL
    Return queue
End Process

Process called "queue_create_with_destructor" takes free_item as Integer returns Integer:
    Let queue be queue_create()
    If queue is not equal to 0:
        memory_set_integer(queue, 40, free_item)
    End If
    Return queue
End Process

Process called "queue_destroy" takes queue as Integer returns Integer:
    If queue is equal to 0:
        Return 0
    End If

    queue_clear(queue)
    Let items be memory_get_pointer(queue, 0)
    deallocate(items)
    deallocate(queue)
    Return 0
End Process

Process called "queue_enqueue" takes queue as Integer, item as Integer returns Integer:
    If queue is equal to 0:
        Return 0  Note: false
    End If

    Let size be memory_get_integer(queue, 32)
    Let capacity be memory_get_integer(queue, 8)
    If size is greater than or equal to capacity:
        Return 0  Note: false
    End If

    Let items be memory_get_pointer(queue, 0)
    Let rear be memory_get_integer(queue, 24)
    Let item_offset be rear multiplied by 8
    memory_set_pointer(items, item_offset, item)

    Note: queue->rear = (queue->rear + 1) % queue->capacity
    Let rear_plus_1 be rear plus 1
    Note: rear_plus_1 modulo capacity = rear_plus_1 - (rear_plus_1 / capacity) * capacity
    Let rear_div_cap be rear_plus_1 divided by capacity
    Let rear_mult_cap be rear_div_cap multiplied by capacity
    Let new_rear be rear_plus_1 minus rear_mult_cap
    memory_set_integer(queue, 24, new_rear)

    Set size to size plus 1
    memory_set_integer(queue, 32, size)
    Return 1  Note: true
End Process

Process called "queue_dequeue" takes queue as Integer returns Integer:
    If queue is equal to 0:
        Return 0
    End If

    Let size be memory_get_integer(queue, 32)
    If size is equal to 0:
        Return 0
    End If

    Let items be memory_get_pointer(queue, 0)
    Let front be memory_get_integer(queue, 16)
    Let item_offset be front multiplied by 8
    Let item be memory_get_pointer(items, item_offset)

    Note: queue->front = (queue->front + 1) % queue->capacity
    Let front_plus_1 be front plus 1
    Let capacity be memory_get_int32(queue, 8)
    Note: front_plus_1 modulo capacity = front_plus_1 - (front_plus_1 / capacity) * capacity
    Let front_div_cap be front_plus_1 divided by capacity
    Let front_mult_cap be front_div_cap multiplied by capacity
    Let new_front be front_plus_1 minus front_mult_cap
    memory_set_integer(queue, 16, new_front)

    Set size to size minus 1
    memory_set_integer(queue, 32, size)
    Return item
End Process

Process called "queue_peek" takes queue as Integer returns Integer:
    If queue is equal to 0:
        Return 0
    End If

    Let size be memory_get_integer(queue, 32)
    If size is equal to 0:
        Return 0
    End If

    Let items be memory_get_pointer(queue, 0)
    Let front be memory_get_integer(queue, 16)
    Let item_offset be front multiplied by 8
    Return memory_get_pointer(items, item_offset)
End Process

Process called "queue_size" takes queue as Integer returns Integer:
    If queue is not equal to 0:
        Return memory_get_integer(queue, 32)
    Otherwise:
        Return 0
    End If
End Process

Process called "queue_is_empty" takes queue as Integer returns Integer:
    If queue is equal to 0:
        Return 1  Note: true
    End If

    Let size be memory_get_integer(queue, 32)
    If size is equal to 0:
        Return 1  Note: true
    Otherwise:
        Return 0  Note: false
    End If
End Process

Process called "queue_is_full" takes queue as Integer returns Integer:
    If queue is equal to 0:
        Return 0  Note: false
    End If

    Let size be memory_get_integer(queue, 32)
    Let capacity be memory_get_integer(queue, 8)
    If size is greater than or equal to capacity:
        Return 1  Note: true
    Otherwise:
        Return 0  Note: false
    End If
End Process

Process called "queue_clear" takes queue as Integer returns Integer:
    If queue is equal to 0:
        Return 0
    End If

    Let free_item be memory_get_pointer(queue, 40)
    If free_item is not equal to 0:
        Let continue_loop be 1
        While continue_loop is equal to 1:
            Let size be memory_get_integer(queue, 32)
            If size is greater than 0:
                Let item be queue_dequeue(queue)
                If item is not equal to 0:
                    Note: call_function_pointer(free_item, item)
                End If
            Otherwise:
                Set continue_loop to 0
            End If
        End While
    Otherwise:
        memory_set_int32(queue, 32, 0)  Note: queue->size = 0
        memory_set_integer(queue, 16, 0)  Note: queue->front = 0
        memory_set_integer(queue, 24, 0)  Note: queue->rear = 0
    End If
    Return 0
End Process

Note: ==== Linked List Implementation ====

Note: ListNode structure:
Note: offset 0: data
Note: offset 8: prev
Note: offset 16: next

Note: LinkedList structure:
Note: offset 0: head
Note: offset 8: tail
Note: offset 16: size
Note: offset 24: free_item

Process called "container_list_create" takes dummy as Integer returns Integer:
    Let list be memory_allocate(32)  Note: sizeof(LinkedList) = 32
    If list is equal to 0:
        Return 0
    End If

    memory_set_pointer(list, 0, 0)   Note: list->head = NULL
    memory_set_pointer(list, 8, 0)   Note: list->tail = NULL
    memory_set_int32(list, 16, 0)  Note: list->size = 0
    memory_set_pointer(list, 24, 0)  Note: list->free_item = NULL
    Return list
End Process

Process called "list_create_with_destructor" takes free_item as Integer returns Integer:
    Let list be container_list_create()
    If list is not equal to 0:
        memory_set_integer(list, 24, free_item)
    End If
    Return list
End Process

Process called "container_list_destroy" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If

    container_list_clear(list)
    deallocate(list)
    Return 0
End Process

Process called "list_push_front" takes list as Integer, item as Integer returns Integer:
    If list is equal to 0:
        Return 0  Note: false
    End If

    Let new_node be memory_allocate(24)  Note: sizeof(ListNode) = 24
    If new_node is equal to 0:
        Return 0  Note: false
    End If

    memory_set_pointer(new_node, 0, item)  Note: new_node->data = item
    memory_set_pointer(new_node, 8, 0)     Note: new_node->prev = NULL

    Let head be memory_get_pointer(list, 0)
    memory_set_pointer(new_node, 16, head)  Note: new_node->next = list->head

    If head is not equal to 0:
        memory_set_pointer(head, 8, new_node)  Note: list->head->prev = new_node
    Otherwise:
        memory_set_pointer(list, 8, new_node)  Note: list->tail = new_node
    End If

    memory_set_pointer(list, 0, new_node)  Note: list->head = new_node

    Let size be memory_get_integer(list, 16)
    Set size to size plus 1
    memory_set_integer(list, 16, size)
    Return 1  Note: true
End Process

Process called "list_push_back" takes list as Integer, item as Integer returns Integer:
    If list is equal to 0:
        Return 0  Note: false
    End If

    Let new_node be memory_allocate(24)
    If new_node is equal to 0:
        Return 0  Note: false
    End If

    memory_set_pointer(new_node, 0, item)   Note: new_node->data = item
    memory_set_pointer(new_node, 16, 0)     Note: new_node->next = NULL

    Let tail be memory_get_pointer(list, 8)
    memory_set_pointer(new_node, 8, tail)   Note: new_node->prev = list->tail

    If tail is not equal to 0:
        memory_set_pointer(tail, 16, new_node)  Note: list->tail->next = new_node
    Otherwise:
        memory_set_pointer(list, 0, new_node)   Note: list->head = new_node
    End If

    memory_set_pointer(list, 8, new_node)  Note: list->tail = new_node

    Let size be memory_get_integer(list, 16)
    Set size to size plus 1
    memory_set_integer(list, 16, size)
    Return 1  Note: true
End Process

Process called "list_pop_front" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If

    Let head be memory_get_pointer(list, 0)
    If head is equal to 0:
        Return 0
    End If

    Let data be memory_get_pointer(head, 0)
    Let next be memory_get_pointer(head, 16)

    memory_set_pointer(list, 0, next)  Note: list->head = node->next
    If next is not equal to 0:
        memory_set_integer(next, 8, 0)  Note: list->head->prev = NULL
    Otherwise:
        memory_set_pointer(list, 8, 0)  Note: list->tail = NULL
    End If

    deallocate(head)

    Let size be memory_get_integer(list, 16)
    Set size to size minus 1
    memory_set_integer(list, 16, size)
    Return data
End Process

Process called "list_pop_back" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If

    Let tail be memory_get_pointer(list, 8)
    If tail is equal to 0:
        Return 0
    End If

    Let data be memory_get_pointer(tail, 0)
    Let prev be memory_get_pointer(tail, 8)

    memory_set_pointer(list, 8, prev)  Note: list->tail = node->prev
    If prev is not equal to 0:
        memory_set_integer(prev, 16, 0)  Note: list->tail->next = NULL
    Otherwise:
        memory_set_pointer(list, 0, 0)   Note: list->head = NULL
    End If

    deallocate(tail)

    Let size be memory_get_integer(list, 16)
    Set size to size minus 1
    memory_set_integer(list, 16, size)
    Return data
End Process

Process called "list_front" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If

    Let head be memory_get_pointer(list, 0)
    If head is not equal to 0:
        Return memory_get_pointer(head, 0)
    Otherwise:
        Return 0
    End If
End Process

Process called "list_back" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If

    Let tail be memory_get_pointer(list, 8)
    If tail is not equal to 0:
        Return memory_get_pointer(tail, 0)
    Otherwise:
        Return 0
    End If
End Process

Process called "list_insert_after" takes list as Integer, node as Integer, item as Integer returns Integer:
    If list is equal to 0:
        Return 0  Note: false
    End If
    If node is equal to 0:
        Return 0  Note: false
    End If

    Let new_node be memory_allocate(24)
    If new_node is equal to 0:
        Return 0  Note: false
    End If

    memory_set_pointer(new_node, 0, item)    Note: new_node->data = item
    memory_set_pointer(new_node, 8, node)    Note: new_node->prev = node

    Let node_next be memory_get_pointer(node, 16)
    memory_set_pointer(new_node, 16, node_next)  Note: new_node->next = node->next

    If node_next is not equal to 0:
        memory_set_pointer(node_next, 8, new_node)  Note: node->next->prev = new_node
    Otherwise:
        memory_set_pointer(list, 8, new_node)       Note: list->tail = new_node
    End If

    memory_set_pointer(node, 16, new_node)  Note: node->next = new_node

    Let size be memory_get_integer(list, 16)
    Set size to size plus 1
    memory_set_integer(list, 16, size)
    Return 1  Note: true
End Process

Process called "list_insert_before" takes list as Integer, node as Integer, item as Integer returns Integer:
    If list is equal to 0:
        Return 0  Note: false
    End If
    If node is equal to 0:
        Return 0  Note: false
    End If

    Let new_node be memory_allocate(24)
    If new_node is equal to 0:
        Return 0  Note: false
    End If

    memory_set_pointer(new_node, 0, item)     Note: new_node->data = item
    memory_set_pointer(new_node, 16, node)    Note: new_node->next = node

    Let node_prev be memory_get_pointer(node, 8)
    memory_set_pointer(new_node, 8, node_prev)  Note: new_node->prev = node->prev

    If node_prev is not equal to 0:
        memory_set_pointer(node_prev, 16, new_node)  Note: node->prev->next = new_node
    Otherwise:
        memory_set_pointer(list, 0, new_node)        Note: list->head = new_node
    End If

    memory_set_pointer(node, 8, new_node)  Note: node->prev = new_node

    Let size be memory_get_integer(list, 16)
    Set size to size plus 1
    memory_set_integer(list, 16, size)
    Return 1  Note: true
End Process

Process called "list_remove_node" takes list as Integer, node as Integer returns Integer:
    If list is equal to 0:
        Return 0  Note: false
    End If
    If node is equal to 0:
        Return 0  Note: false
    End If

    Let prev be memory_get_pointer(node, 8)
    Let next be memory_get_pointer(node, 16)

    If prev is not equal to 0:
        memory_set_pointer(prev, 16, next)  Note: node->prev->next = node->next
    Otherwise:
        memory_set_pointer(list, 0, next)   Note: list->head = node->next
    End If

    If next is not equal to 0:
        memory_set_pointer(next, 8, prev)   Note: node->next->prev = node->prev
    Otherwise:
        memory_set_pointer(list, 8, prev)   Note: list->tail = node->prev
    End If

    Let free_item be memory_get_pointer(list, 24)
    If free_item is not equal to 0:
        Let data be memory_get_pointer(node, 0)
        If data is not equal to 0:
            Note: call_function_pointer(free_item, data)
        End If
    End If

    deallocate(node)

    Let size be memory_get_integer(list, 16)
    Set size to size minus 1
    memory_set_integer(list, 16, size)
    Return 1  Note: true
End Process

Process called "container_list_find" takes list as Integer, item as Integer, compare as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If
    If compare is equal to 0:
        Return 0
    End If

    Let current be memory_get_pointer(list, 0)
    While current is not equal to 0:
        Let data be memory_get_pointer(current, 0)
        Let result be call_function_pointer_2args(compare, data, item)
        If result is not equal to 0:
            Return current
        End If
        Set current to memory_get_pointer(current, 16)
    End While

    Return 0
End Process

Process called "list_size" takes list as Integer returns Integer:
    If list is not equal to 0:
        Return memory_get_integer(list, 16)
    Otherwise:
        Return 0
    End If
End Process

Process called "list_is_empty" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 1  Note: true
    End If

    Let size be memory_get_integer(list, 16)
    If size is equal to 0:
        Return 1  Note: true
    Otherwise:
        Return 0  Note: false
    End If
End Process

Process called "container_list_clear" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If

    Let free_item be memory_get_pointer(list, 24)
    Let current be memory_get_pointer(list, 0)

    While current is not equal to 0:
        Let next be memory_get_pointer(current, 16)

        If free_item is not equal to 0:
            Let data be memory_get_pointer(current, 0)
            If data is not equal to 0:
                Note: call_function_pointer(free_item, data)
            End If
        End If

        deallocate(current)
        Set current to next
    End While

    memory_set_pointer(list, 0, 0)   Note: list->head = NULL
    memory_set_pointer(list, 8, 0)   Note: list->tail = NULL
    memory_set_int32(list, 16, 0)  Note: list->size = 0
    Return 0
End Process

Process called "list_begin" takes list as Integer returns Integer:
    If list is not equal to 0:
        Return memory_get_pointer(list, 0)
    Otherwise:
        Return 0
    End If
End Process

Process called "list_end" takes list as Integer returns Integer:
    Note: End is represented as NULL
    Return 0
End Process

Process called "list_next" takes node as Integer returns Integer:
    If node is not equal to 0:
        Return memory_get_pointer(node, 16)
    Otherwise:
        Return 0
    End If
End Process

Process called "list_prev" takes node as Integer returns Integer:
    If node is not equal to 0:
        Return memory_get_pointer(node, 8)
    Otherwise:
        Return 0
    End If
End Process

Process called "list_foreach" takes list as Integer, callback as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If
    If callback is equal to 0:
        Return 0
    End If

    Let current be memory_get_pointer(list, 0)
    While current is not equal to 0:
        Let data be memory_get_pointer(current, 0)
        Note: call_function_pointer(callback, data)
        Set current to memory_get_pointer(current, 16)
    End While
    Return 0
End Process

Note: ==== Set Implementation ====
Note: Note: Set is implemented using hashtable
Note: Set structure:
Note: offset 0: table (hashtable pointer)
Note: offset 8: free_item

Process called "set_create" takes hash_func as Integer, compare_func as Integer returns Integer:
    Let set be memory_allocate(16)  Note: sizeof(Set) = 16
    If set is equal to 0:
        Return 0
    End If

    Let initial_buckets be 256
    Let table be hashtable_create(initial_buckets, hash_func, compare_func)
    If table is equal to 0:
        deallocate(set)
        Return 0
    End If

    memory_set_pointer(set, 0, table)
    memory_set_integer(set, 8, 0)     Note: set->free_item = NULL
    Return set
End Process

Process called "set_create_with_destructor" takes hash_func as Integer, compare_func as Integer, free_item as Integer returns Integer:
    Let set be set_create(hash_func, compare_func)
    If set is not equal to 0:
        memory_set_integer(set, 8, free_item)
        Note: Update hash table to use destructor
        Let table be memory_get_pointer(set, 0)
        memory_set_pointer(table, 40, free_item)  Note: table->free_key = free_item
    End If
    Return set
End Process

Process called "set_destroy" takes set as Integer returns Integer:
    If set is equal to 0:
        Return 0
    End If

    Let table be memory_get_pointer(set, 0)
    hashtable_destroy(table)
    deallocate(set)
    Return 0
End Process

Process called "set_add" takes set as Integer, item as Integer returns Integer:
    If set is equal to 0:
        Return 0  Note: false
    End If

    Let table be memory_get_pointer(set, 0)
    Note: In a set, key and value are the same
    Let result be hashtable_put(table, item, item)
    Return result
End Process

Process called "set_remove" takes set as Integer, item as Integer returns Integer:
    If set is not equal to 0:
        Let table be memory_get_pointer(set, 0)
        Let result be hashtable_remove(table, item)
        Return result
    Otherwise:
        Return 0  Note: false
    End If
End Process

Process called "set_contains" takes set as Integer, item as Integer returns Integer:
    If set is not equal to 0:
        Let table be memory_get_pointer(set, 0)
        Let result be hashtable_contains(table, item)
        Return result
    Otherwise:
        Return 0  Note: false
    End If
End Process

Process called "set_size" takes set as Integer returns Integer:
    If set is not equal to 0:
        Let table be memory_get_pointer(set, 0)
        Let result be hashtable_size(table)
        Return result
    Otherwise:
        Return 0
    End If
End Process

Process called "set_is_empty" takes set as Integer returns Integer:
    If set is equal to 0:
        Return 1  Note: true
    End If

    Let table be memory_get_pointer(set, 0)
    Let size be hashtable_size(table)
    If size is equal to 0:
        Return 1  Note: true
    Otherwise:
        Return 0  Note: false
    End If
End Process

Process called "set_clear" takes set as Integer returns Integer:
    If set is not equal to 0:
        Let table be memory_get_pointer(set, 0)
        hashtable_clear(table)
    End If
    Return 0
End Process

Note: Note: Set union/intersection/difference operations would require hashtable_iterator
Note: which isn't available in v0.0.7.3. These would need to be added later.

Note: ==== Utility Functions ====

Process called "free_string_item" takes item as Integer returns Integer:
    deallocate(item)
    Return 0
End Process

Process called "free_integer_item" takes item as Integer returns Integer:
    deallocate(item)
    Return 0
End ProcessNote: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Lexer for Runa v0.0.7.5
Note: Line-by-line transliteration from v0.0.7.3 lexer.c

Note: Global variable workaround: Stage 2 memory functions have ABI issues
Let LEXER_POSITION be 0
Let LEXER_CURRENT_CHAR be 0

Note: Token type constants - matching lexer.h enum
Let TOKEN_EOF be 0
Let TOKEN_PROCESS be 1
Let TOKEN_CALLED be 2
Let TOKEN_RETURNS be 3
Let TOKEN_INTEGER_TYPE be 4
Let TOKEN_STRING_TYPE be 5
Let TOKEN_CHARACTER_TYPE be 6
Let TOKEN_RETURN be 7
Let TOKEN_END be 8
Let TOKEN_COLON be 9
Let TOKEN_STRING_LITERAL be 10
Let TOKEN_INTEGER be 11
Let TOKEN_LET be 12
Let TOKEN_BE be 13
Let TOKEN_SET be 14
Let TOKEN_TO be 15
Let TOKEN_PLUS be 16
Let TOKEN_MINUS be 17
Let TOKEN_IF be 18
Let TOKEN_OTHERWISE be 19
Let TOKEN_WHILE be 20
Let TOKEN_IS be 21
Let TOKEN_EQUAL be 22
Let TOKEN_NOT_EQUAL be 23
Let TOKEN_LESS be 24
Let TOKEN_GREATER be 25
Let TOKEN_GREATER_EQUAL be 26
Let TOKEN_LESS_EQUAL be 27
Let TOKEN_THAN be 28
Let TOKEN_NOT be 29
Let TOKEN_AND be 30
Let TOKEN_OR be 31
Let TOKEN_THAT be 32
Let TOKEN_TAKES be 33
Let TOKEN_AS be 34
Let TOKEN_MULTIPLIED be 35
Let TOKEN_DIVIDED be 36
Let TOKEN_MODULO be 37
Let TOKEN_BY be 38
Let TOKEN_BIT_AND be 39
Let TOKEN_BIT_OR be 40
Let TOKEN_BIT_XOR be 41
Let TOKEN_BIT_SHIFT_LEFT be 42
Let TOKEN_BIT_SHIFT_RIGHT be 43
Let TOKEN_BREAK be 44
Let TOKEN_CONTINUE be 45
Let TOKEN_OTHERWISE_IF be 46
Let TOKEN_PRINT be 47
Let TOKEN_LPAREN be 48
Let TOKEN_RPAREN be 49
Let TOKEN_TYPE be 50
Let TOKEN_DOT be 51
Let TOKEN_COMMA be 52
Let TOKEN_IDENTIFIER be 53
Let TOKEN_READ_FILE be 54
Let TOKEN_WRITE_FILE be 55
Let TOKEN_IMPORT be 56
Let TOKEN_STRING_LENGTH be 57
Let TOKEN_STRING_CHAR_AT be 58
Let TOKEN_STRING_SUBSTRING be 59
Let TOKEN_STRING_EQUALS be 60
Let TOKEN_ASCII_VALUE_OF be 61
Let TOKEN_IS_DIGIT be 62
Let TOKEN_IS_ALPHA be 63
Let TOKEN_IS_WHITESPACE be 64
Let TOKEN_LIST_CREATE be 65
Let TOKEN_LIST_APPEND be 66
Let TOKEN_LIST_GET be 67
Let TOKEN_LIST_GET_INTEGER be 68
Let TOKEN_LIST_LENGTH be 69
Let TOKEN_LIST_DESTROY be 70
Let TOKEN_LIST_SET be 71
Let TOKEN_LIST_INSERT be 72
Let TOKEN_LIST_REMOVE be 73
Let TOKEN_LIST_CLEAR be 74
Let TOKEN_LIST_FIND be 75
Let TOKEN_LIST_SORT be 76
Let TOKEN_LIST_REVERSE be 77
Let TOKEN_LIST_COPY be 78
Let TOKEN_LIST_MERGE be 79
Let TOKEN_STRING_CONCAT be 80
Let TOKEN_STRING_COMPARE be 81
Let TOKEN_STRING_TO_INTEGER be 82
Let TOKEN_INTEGER_TO_STRING be 83
Let TOKEN_STRING_FIND be 84
Let TOKEN_STRING_REPLACE be 85
Let TOKEN_STRING_TRIM be 86
Let TOKEN_STRING_SPLIT be 87
Let TOKEN_FILE_OPEN be 88
Let TOKEN_FILE_CLOSE be 89
Let TOKEN_FILE_READ_LINE be 90
Let TOKEN_FILE_WRITE_LINE be 91
Let TOKEN_FILE_EXISTS be 92
Let TOKEN_FILE_DELETE be 93
Let TOKEN_FILE_SIZE be 94
Let TOKEN_FILE_SEEK be 95
Let TOKEN_FILE_TELL be 96
Let TOKEN_FILE_EOF be 97
Let TOKEN_SIN be 98
Let TOKEN_COS be 99
Let TOKEN_TAN be 100
Let TOKEN_SQRT be 101
Let TOKEN_POW be 102
Let TOKEN_ABS be 103
Let TOKEN_FLOOR be 104
Let TOKEN_CEIL be 105
Let TOKEN_MIN be 106
Let TOKEN_MAX be 107
Let TOKEN_RANDOM be 108
Let TOKEN_LOG be 109
Let TOKEN_EXP be 110
Let TOKEN_PIPE be 111
Let TOKEN_MATCH be 112
Let TOKEN_WHEN be 113
Let TOKEN_WITH be 114
Let TOKEN_GET_COMMAND_LINE_ARGS be 115
Let TOKEN_EXIT_WITH_CODE be 116
Let TOKEN_PANIC be 117
Let TOKEN_ASSERT be 118
Let TOKEN_ALLOCATE be 119
Let TOKEN_DEALLOCATE be 120
Let TOKEN_INLINE be 121
Let TOKEN_ASSEMBLY be 122
Let TOKEN_NOTE be 123
Let TOKEN_POINTER be 124
Let TOKEN_OF be 125
Let TOKEN_ARRAY be 126
Let TOKEN_LBRACKET be 127
Let TOKEN_RBRACKET be 128
Let TOKEN_ERROR be 129
Let TOKEN_MEMORY_GET_BYTE be 130
Let TOKEN_MEMORY_SET_BYTE be 131
Let TOKEN_COUNT be 132
Let TOKEN_NEGATIVE be 133
Let TOKEN_TRUE be 134
Let TOKEN_FALSE be 135
Let TOKEN_GETS be 136
Let TOKEN_INCREASED be 137
Let TOKEN_DECREASED be 138
Let TOKEN_INCREASE be 139
Let TOKEN_DECREASE be 140
Let TOKEN_MULTIPLY be 141
Let TOKEN_DIVIDE be 142
Let TOKEN_FOR be 143
Let TOKEN_FROM be 144
Let TOKEN_EACH be 145
Let TOKEN_LBRACE be 146
Let TOKEN_RBRACE be 147
Let TOKEN_AT be 148
Let TOKEN_INDEX be 149
Let TOKEN_KEY be 150
Let TOKEN_LENGTH be 151
Let TOKEN_IN be 152
Let TOKEN_WHERE be 153
Let TOKEN_AN be 154
Let TOKEN_A be 155
Let TOKEN_CONTAINING be 156
Let TOKEN_DOLLAR be 157
Let TOKEN_THE be 158
Let TOKEN_LIST be 159
Let TOKEN_DICTIONARY be 160
Let TOKEN_UNDERSCORE be 161
Let TOKEN_LAMBDA be 162
Let TOKEN_INTEGER8 be 163
Let TOKEN_INTEGER16 be 164
Let TOKEN_INTEGER32 be 165
Let TOKEN_INTEGER64 be 166
Let TOKEN_INTEGER128 be 167
Let TOKEN_UNSIGNED_INTEGER8 be 168
Let TOKEN_UNSIGNED_INTEGER16 be 169
Let TOKEN_UNSIGNED_INTEGER32 be 170
Let TOKEN_UNSIGNED_INTEGER64 be 171
Let TOKEN_UNSIGNED_INTEGER128 be 172
Let TOKEN_FLOAT be 173
Let TOKEN_FLOAT64 be 174
Let TOKEN_FLOAT_LITERAL be 175
Let TOKEN_CHARACTER_LITERAL be 176

Note: Additional string helper functions specific to lexer
Process called "string_copy" takes dest as Integer, src as Integer returns Integer:
    Note: Copy string from src to dest
    Let i be 0
    Let continue_loop be 1
    While continue_loop is equal to 1:
        Let char be memory_get_byte(src, i)
        memory_set_byte(dest, i, char)
        If char is equal to 0:
            Set continue_loop to 0
        Otherwise:
            Set i to i plus 1
        End If
    End While
    Return 0
End Process

Process called "string_copy_n" takes dest as Integer, src as Integer, start as Integer, length as Integer returns Integer:
    Note: Copy n characters from src starting at position start to dest
    Let i be 0
    While i is less than length:
        Let src_pos be start plus i
        Let char be memory_get_byte(src, src_pos)
        memory_set_byte(dest, i, char)
        Set i to i plus 1
    End While
    Return 0
End Process

Process called "string_set_char" takes str as Integer, index as Integer, char as Integer returns Integer:
    memory_set_byte(str, index, char)
    Return 0
End Process

Note: print_string and print_integer are provided by codegen as assembly implementations

Note: Lexer advance - moves to next character
Process called "lexer_advance" takes lexer as Integer returns Integer:
    Let current_char be memory_get_byte(lexer, 20)
    Let newline be 10  Note: ASCII for '\n'
    If current_char is equal to newline:
        Let line be memory_get_int32(lexer, 12)
        Let new_line be line plus 1
        memory_set_int32(lexer, 12,new_line)
        memory_set_int32(lexer, 16, 0)
    End If

    Let position be memory_get_int32(lexer, 8)  Note: Get position from struct
    Let new_position be position plus 1
    memory_set_int32(lexer, 8, new_position)     Note: Update position in struct
    Set LEXER_POSITION to new_position

    Let column be memory_get_int32(lexer, 16)
    Let new_column be column plus 1
    memory_set_int32(lexer, 16, new_column)

    Let source be memory_get_pointer(lexer, 0)
    Let source_len be string_length(source)
    If new_position is greater than or equal to source_len:
        memory_set_byte(lexer, 20, 0)
        Set LEXER_CURRENT_CHAR to 0  Note: Global workaround
    Otherwise:
        Let char_at_pos be string_char_at(source, new_position)
        memory_set_byte(lexer, 20, char_at_pos)
        Set LEXER_CURRENT_CHAR to char_at_pos  Note: Global workaround
    End If

    Return 0
End Process

Note: Skip whitespace
Process called "lexer_skip_whitespace" takes lexer as Integer returns Integer:
    Let continue_loop be 1
    While continue_loop is equal to 1:
        Let current_char be memory_get_byte(lexer, 20)
        If current_char is equal to 0:
            Set continue_loop to 0
        Otherwise:
            Let is_space be is_whitespace(current_char)
            If is_space is equal to 0:
                Set continue_loop to 0
            Otherwise:
                Let dummy be lexer_advance(lexer)
            End If
        End If
    End While
    Return 0
End Process
Note: Skip Note comments - handles both inline and block notes
Note: Inline: Note: comment text
Note: Block: Note: (with newline) ... :End Note
Process called "lexer_skip_note_comment" takes lexer as Integer returns Integer:
    Note: At this point, "Note" has been consumed, current char is next after "Note"
    Let current_char be memory_get_byte(lexer, 20)

    Note: Skip whitespace after "Note" (but not newlines)
    Let continue_ws be 1
    While continue_ws is equal to 1:
        Set current_char to memory_get_byte(lexer, 20)
        Let space be 32
        Let tab be 9
        If current_char is equal to space:
            Let dummy be lexer_advance(lexer)
        Otherwise If current_char is equal to tab:
            Let dummy1 be lexer_advance(lexer)
        Otherwise:
            Set continue_ws to 0
        End If
    End While

    Note: Check what comes after "Note"
    Set current_char to memory_get_byte(lexer, 20)
    Let colon be 58

    If current_char is not equal to colon:
        Note: No colon - not a comment, this is an error or unusual case
        Note: Just return and let it be handled as Note token
        Return 0
    End If

    Note: We have "Note:" - skip the colon
    Let dummy3 be lexer_advance(lexer)

    Note: Check if this is inline (has content on same line) or block (newline follows)
    Set current_char to memory_get_byte(lexer, 20)
    Let newline be 10
    Let carriage_return be 13
    Let space be 32
    Let tab be 9

    Note: Skip any spaces/tabs after colon to check what follows
    Let has_content_on_line be 0
    Let check_continue be 1
    While check_continue is equal to 1:
        If current_char is equal to space:
            Let dummy_sp be lexer_advance(lexer)
            Set current_char to memory_get_byte(lexer, 20)
        Otherwise If current_char is equal to tab:
            Let dummy_tb be lexer_advance(lexer)
            Set current_char to memory_get_byte(lexer, 20)
        Otherwise:
            Note: Not space or tab, check what it is
            If current_char is equal to newline:
                Note: Block comment - \n
                Set has_content_on_line to 0
            Otherwise If current_char is equal to carriage_return:
                Note: Block comment - \r (may be followed by \n)
                Set has_content_on_line to 0
            Otherwise:
                Note: Has content on same line - inline comment
                Set has_content_on_line to 1
            End If
            Set check_continue to 0
        End If
    End While

    Note: Check if we have a block comment or inline comment
    If has_content_on_line is equal to 0:
        Note: Block comment Note:\n ... :End Note
        Note: Skip the newline characters (handle both \r and \n)
        Set current_char to memory_get_byte(lexer, 20)
        If current_char is equal to carriage_return:
            Let dummy_cr be lexer_advance(lexer)
            Set current_char to memory_get_byte(lexer, 20)
        End If
        If current_char is equal to newline:
            Let dummy_nl be lexer_advance(lexer)
        End If

        Note: Scan forward until :End Note
        Let continue_scan be 1
        Let note_depth be 1  Note: Track nesting in case of nested Note: blocks

        While continue_scan is equal to 1:
            Set current_char to memory_get_byte(lexer, 20)
            If current_char is equal to 0:
                Note: EOF - unterminated block comment
                Set continue_scan to 0
            Otherwise:
                Let colon be 58
                If current_char is equal to colon:
                    Note: Might be :End Note - save position in case we need to backtrack
                    Let saved_pos be memory_get_int32(lexer, 8)
                    Let saved_line be memory_get_int32(lexer, 12)
                    Let saved_col be memory_get_int32(lexer, 16)

                    Note: Advance past colon
                    Let dummy7 be lexer_advance(lexer)

                    Note: Skip whitespace after colon
                    Let continue_ws3 be 1
                    While continue_ws3 is equal to 1:
                        Set current_char to memory_get_byte(lexer, 20)
                        If current_char is equal to 32:
                            Let dummy8 be lexer_advance(lexer)
                        Otherwise If current_char is equal to 9:
                            Let dummy9 be lexer_advance(lexer)
                        Otherwise If current_char is equal to 13:
                            Let dummy_cr1 be lexer_advance(lexer)
                        Otherwise:
                            Set continue_ws3 to 0
                        End If
                    End While

                    Note: Check for "End Note"
                    Set current_char to memory_get_byte(lexer, 20)
                    If current_char is equal to 69:  Note: 'E'
                        Let word_e be lexer_read_word(lexer)
                        If string_equals(word_e, "End") is equal to 1:
                            Note: Skip whitespace
                            Let continue_ws4 be 1
                            While continue_ws4 is equal to 1:
                                Set current_char to memory_get_byte(lexer, 20)
                                If current_char is equal to 32:
                                    Let dummy10 be lexer_advance(lexer)
                                Otherwise If current_char is equal to 9:
                                    Let dummy11 be lexer_advance(lexer)
                                Otherwise If current_char is equal to 13:
                                    Let dummy_cr2 be lexer_advance(lexer)
                                Otherwise:
                                    Set continue_ws4 to 0
                                End If
                            End While

                            Note: Check for "Note"
                            Set current_char to memory_get_byte(lexer, 20)
                            If current_char is equal to 78:  Note: 'N'
                                Let word_n be lexer_read_word(lexer)
                                If string_equals(word_n, "Note") is equal to 1:
                                    Note: Found :End Note! Decrement depth
                                    Set note_depth to note_depth minus 1
                                    If note_depth is equal to 0:
                                        Note: Matching :End Note found
                                        deallocate(word_e)
                                        deallocate(word_n)
                                        Set continue_scan to 0
                                    Otherwise:
                                        Note: Nested Note: block ended, continue scanning
                                        deallocate(word_e)
                                        deallocate(word_n)
                                    End If
                                Otherwise:
                                    deallocate(word_n)
                                    deallocate(word_e)
                                End If
                            Otherwise:
                                deallocate(word_e)
                            End If
                        Otherwise:
                            deallocate(word_e)
                        End If
                    End If
                Otherwise:
                    Note: Check if this is a nested Note: to track depth
                    If current_char is equal to 78:  Note: 'N'
                        Let saved_n_pos be memory_get_int32(lexer, 8)
                        Let word_note be lexer_read_word(lexer)
                        If string_equals(word_note, "Note") is equal to 1:
                            Note: Check if followed by colon
                            Set current_char to memory_get_byte(lexer, 20)
                            If current_char is equal to 58:  Note: ':'
                                Set note_depth to note_depth plus 1
                                Let dummy_n be lexer_advance(lexer)
                            End If
                        End If
                        deallocate(word_note)
                    Otherwise:
                        Note: Not colon or Note, just advance
                        Let dummy16 be lexer_advance(lexer)
                    End If
                End If
            End If
        End While
    Otherwise:
        Note: Inline comment Note: comment text
        Note: Skip to end of line
        Let continue_inline be 1
        While continue_inline is equal to 1:
            Set current_char to memory_get_byte(lexer, 20)
            If current_char is equal to 0:
                Set continue_inline to 0
            Otherwise If current_char is equal to newline:
                Set continue_inline to 0
            Otherwise:
                Let dummy_adv be lexer_advance(lexer)
            End If
        End While
    End If

    Return 0
End Process

Note: Create token with owned string
Process called "token_create_owned" takes type as Integer, value as Integer, line as Integer, column as Integer returns Integer:
    Let token_size be 24  Note: sizeof(Token) = 24 bytes (aligned struct)
    Let token be memory_allocate(token_size)
    memory_set_int32(token, 0, type)
    memory_set_pointer(token, 8, value)  Note: Take ownership - pointer field
    memory_set_int32(token, 16, line)
    memory_set_int32(token, 20, column)
    Return token
End Process

Note: Create token with duplicated string
Process called "token_create" takes type as Integer, value as Integer, line as Integer, column as Integer returns Integer:
    Let token_size be 24  Note: sizeof(Token) = 24 bytes (aligned struct)
    Let token be memory_allocate(token_size)
    memory_set_int32(token, 0, type)
    If value is equal to 0:
        memory_set_pointer(token, 8, 0)
    Otherwise:
        Let dup be string_duplicate(value)
        memory_set_pointer(token, 8, dup)  Note: Pointer field
    End If
    memory_set_int32(token, 16, line)
    memory_set_int32(token, 20, column)
    Return token
End Process

Note: Read string literal
Process called "lexer_read_string_literal" takes lexer as Integer returns Integer:
    Let dummy be lexer_advance(lexer)  Note: Skip opening quote
    Let position be memory_get_int32(lexer, 8)  Note: Get position from struct
    Let start_pos be position

    Let continue_loop be 1
    While continue_loop is equal to 1:
        Let current_char be memory_get_byte(lexer, 20)
        Let quote be 34  Note: ASCII for '"'
        If current_char is equal to 0:
            Set continue_loop to 0
        Otherwise If current_char is equal to quote:
            Set continue_loop to 0
        Otherwise:
            Let dummy2 be lexer_advance(lexer)
        End If
    End While

    Let current_char be memory_get_byte(lexer, 20)
    Let quote be 34  Note: ASCII for '"'
    If current_char is equal to quote:
        Let position be memory_get_int32(lexer, 8)  Note: Get position from struct
        Let length be position minus start_pos
        Let one be 1
        Let size be length plus one
        Let string be memory_allocate(size)
        Let source be memory_get_pointer(lexer, 0)
        string_copy_n(string, source, start_pos, length)
        string_set_char(string, length, 0)
        Let dummy3 be lexer_advance(lexer)  Note: Skip closing quote
        Return string
    End If

    Return 0  Note: Unterminated string
End Process

Note: Read word (identifier or keyword)
Process called "lexer_read_word" takes lexer as Integer returns Integer:
    Let position be memory_get_int32(lexer, 8)  Note: Get position from struct
    Let start_pos be position

    Let continue_loop be 1
    While continue_loop is equal to 1:
        Note: Read from struct instead of global (globals don't work in stage2)
        Let current_char be memory_get_byte(lexer, 20)
        If current_char is equal to 0:
            Set continue_loop to 0
        Otherwise:
            Let is_alnum be is_alnum_char(current_char)
            Let underscore be 95  Note: ASCII for '_'
            If current_char is equal to underscore:
                Let dummy be lexer_advance(lexer)
            Otherwise If is_alnum is equal to 1:
                Let dummy2 be lexer_advance(lexer)
            Otherwise:
                Set continue_loop to 0
            End If
        End If
    End While

    Let position be memory_get_int32(lexer, 8)  Note: Get position from struct
    Let length be position minus start_pos
    Let one be 1
    Let size be length plus one
    Let word be memory_allocate(size)
    Let source be memory_get_pointer(lexer, 0)
    string_copy_n(word, source, start_pos, length)
    string_set_char(word, length, 0)

    Return word
End Process

Note: Read integer or float literal
Note: Returns a string representation - caller determines if it's integer or float
Process called "lexer_read_integer" takes lexer as Integer returns Integer:
    Note: Read from struct instead of global (globals don't work in stage2)
    Let position be memory_get_int32(lexer, 8)
    Let start_pos be position

    Let continue_loop be 1
    Let has_dot be 0
    Let has_e be 0
    While continue_loop is equal to 1:
        Let current_char be memory_get_byte(lexer, 20)
        If current_char is equal to 0:
            Set continue_loop to 0
        Otherwise:
            Let is_dig be is_digit(current_char)
            Let dot_char be 46  Note: '.'
            Let e_lower be 101  Note: 'e'
            Let e_upper be 69   Note: 'E'

            If is_dig is equal to 1:
                Let dummy be lexer_advance(lexer)
            Otherwise If current_char is equal to dot_char:
                Note: Check if we already have a dot
                If has_dot is equal to 0:
                    Set has_dot to 1
                    Let dummy be lexer_advance(lexer)
                Otherwise:
                    Set continue_loop to 0
                End If
            Otherwise If current_char is equal to e_lower:
                Note: Scientific notation - 'e' for exponent
                If has_e is equal to 0:
                    Set has_e to 1
                    Let dummy be lexer_advance(lexer)
                    Note: Check for optional +/- after 'e'
                    Let next_char be memory_get_byte(lexer, 20)
                    Let plus_sign be 43  Note: '+'
                    Let minus_sign be 45  Note: '-'
                    If next_char is equal to plus_sign:
                        Let dummy2 be lexer_advance(lexer)
                    Otherwise If next_char is equal to minus_sign:
                        Let dummy3 be lexer_advance(lexer)
                    End If
                Otherwise:
                    Set continue_loop to 0
                End If
            Otherwise If current_char is equal to e_upper:
                Note: Scientific notation - 'E' for exponent
                If has_e is equal to 0:
                    Set has_e to 1
                    Let dummy be lexer_advance(lexer)
                    Note: Check for optional +/- after 'E'
                    Let next_char be memory_get_byte(lexer, 20)
                    Let plus_sign be 43  Note: '+'
                    Let minus_sign be 45  Note: '-'
                    If next_char is equal to plus_sign:
                        Let dummy4 be lexer_advance(lexer)
                    Otherwise If next_char is equal to minus_sign:
                        Let dummy5 be lexer_advance(lexer)
                    End If
                Otherwise:
                    Set continue_loop to 0
                End If
            Otherwise:
                Set continue_loop to 0
            End If
        End If
    End While

    Let position be memory_get_int32(lexer, 8)  Note: Get position from struct
    Let length be position minus start_pos
    Let one be 1
    Let size be length plus one
    Let number be memory_allocate(size)
    Let source be memory_get_pointer(lexer, 0)
    string_copy_n(number, source, start_pos, length)
    string_set_char(number, length, 0)

    Return number
End Process

Note: Read binary literal (0b prefix)
Process called "lexer_read_binary" takes lexer as Integer returns Integer:
    Note: At this point we've seen '0', check if next is 'b' or 'B'
    Let position be memory_get_int32(lexer, 8)
    Let start_pos be position

    Let continue_loop be 1
    While continue_loop is equal to 1:
        Let current_char be memory_get_byte(lexer, 20)
        Let zero be 48  Note: '0'
        Let one be 49   Note: '1'
        If current_char is equal to zero:
            Let dummy be lexer_advance(lexer)
        Otherwise If current_char is equal to one:
            Let dummy2 be lexer_advance(lexer)
        Otherwise:
            Set continue_loop to 0
        End If
    End While

    Let position be memory_get_int32(lexer, 8)
    Let length be position minus start_pos
    Let size be length plus 1
    Let binary be memory_allocate(size)
    Let source be memory_get_pointer(lexer, 0)
    string_copy_n(binary, source, start_pos, length)
    string_set_char(binary, length, 0)

    Return binary
End Process

Note: Create lexer
Process called "lexer_create" takes source as Integer returns Integer:
    Let lexer_size be 32  Note: sizeof(Lexer) = 32 bytes with extra space for workaround
    Let lexer be memory_allocate(lexer_size)
    Let dup be string_duplicate(source)
    memory_set_pointer(lexer, 0, dup)      Note: char *source at offset 0
    memory_set_int32(lexer, 8, 0)          Note: int position at offset 8
    Set LEXER_POSITION to 0  Note: Reset position for new lexer
    memory_set_int32(lexer, 12, 1)         Note: int line at offset 12
    memory_set_int32(lexer, 16, 1)         Note: int column at offset 16

    Let src_len be string_length(source)
    Let first_char be string_char_at(source, 0)

    memory_set_byte(lexer, 20, first_char)  Note: char current_char at offset 20
    Set LEXER_CURRENT_CHAR to first_char  Note: Global workaround
    Return lexer
End Process

Note: Destroy lexer
Process called "lexer_destroy" takes lexer as Integer returns Integer:
    If lexer is not equal to 0:
        Let source be memory_get_pointer(lexer, 0)
        deallocate(source)
        deallocate(lexer)
    End If
    Return 0
End Process

Note: Get next token - main lexer function
Process called "lexer_next_token" takes lexer as Integer returns Integer:
    Let continue_main be 1
    While continue_main is equal to 1:
        Let current_char be memory_get_byte(lexer, 20)
        If current_char is equal to 0:
            Set continue_main to 0
        Otherwise:
            Let line be memory_get_int32(lexer, 12)
            Let column be memory_get_int32(lexer, 16)

            Note: Check for whitespace
            Let is_space be is_whitespace(current_char)
            If is_space is equal to 1:
                Let dummy be lexer_skip_whitespace(lexer)
            Otherwise:
                Note: Check for string literal
                Let quote be 34  Note: ASCII for '"'
                If current_char is equal to quote:
                    Let string be lexer_read_string_literal(lexer)
                    If string is not equal to 0:
                        Let token be token_create_owned(TOKEN_STRING_LITERAL, string, line, column)
                        Return token
                    Otherwise:
                        Note: Print error for unterminated string
                        Let error_msg be "[LEXER ERROR] Unterminated string literal at line "
                        print_string(error_msg)
                        print_integer(line)
                        Let column_msg be ", column "
                        print_string(column_msg)
                        print_integer(column)
                        print_newline()

                        Let error_str be "Unterminated string"
                        Let token be token_create(TOKEN_ERROR, error_str, line, column)
                        Return token
                    End If
                Otherwise:
                    Note: Check for minus sign (could be negative number or minus operator)
                    Let minus_sign be 45  Note: ASCII for '-'
                    If current_char is equal to minus_sign:
                        Note: Look ahead to see if this is a negative number literal
                        Let next_pos be memory_get_int32(lexer, 8)
                        Let next_pos be next_pos plus 1
                        Let source be memory_get_pointer(lexer, 0)
                        Let source_len be string_length(source)

                        If next_pos is less than source_len:
                            Let next_char be string_char_at(source, next_pos)
                            Let is_next_digit be is_digit(next_char)

                            If is_next_digit is equal to 1:
                                Note: This is a negative number literal like -5
                                Let dummy_minus be lexer_advance(lexer)
                                Let integer be lexer_read_integer(lexer)

                                Note: Prepend minus sign to integer string
                                Let int_len be string_length(integer)
                                Let neg_len be int_len plus 2  Note: minus + null
                                Let neg_integer be memory_allocate(neg_len)
                                memory_set_byte(neg_integer, 0, 45)  Note: minus sign

                                Note: Copy integer digits
                                Let copy_i be 0
                                While copy_i is less than int_len:
                                    Let digit_char be memory_get_byte(integer, copy_i)
                                    memory_set_byte(neg_integer, copy_i plus 1, digit_char)
                                    Set copy_i to copy_i plus 1
                                End While
                                memory_set_byte(neg_integer, int_len plus 1, 0)  Note: null terminator

                                deallocate(integer)
                                Let token be token_create_owned(TOKEN_INTEGER, neg_integer, line, column)
                                Return token
                            End If
                        End If
                        Note: Not a negative number, will be handled as single char token below
                    End If

                    Note: Check for integer or float
                    Let is_dig be is_digit(current_char)
                    If is_dig is equal to 1:
                        Note: Check for binary literal (0b prefix)
                        Let zero_char be 48  Note: '0'
                        If current_char is equal to zero_char:
                            Note: Peek ahead for 'b' or 'B'
                            Let peek_pos be memory_get_int32(lexer, 8)
                            Let peek_pos be peek_pos plus 1
                            Let source be memory_get_pointer(lexer, 0)
                            Let source_len be string_length(source)

                            If peek_pos is less than source_len:
                                Let peek_char be string_char_at(source, peek_pos)
                                Let b_lower be 98   Note: 'b'
                                Let b_upper be 66   Note: 'B'

                                If peek_char is equal to b_lower:
                                    Note: Binary literal! Skip '0b'
                                    Let dummy_0 be lexer_advance(lexer)
                                    Let dummy_b be lexer_advance(lexer)
                                    Let binary be lexer_read_binary(lexer)

                                    Note: Prepend "0b" to the result for parsing
                                    Let bin_len be string_length(binary)
                                    Let full_len be bin_len plus 3  Note: "0b" + digits + null
                                    Let full_binary be memory_allocate(full_len)
                                    memory_set_byte(full_binary, 0, 48)   Note: '0'
                                    memory_set_byte(full_binary, 1, 98)   Note: 'b'
                                    Let copy_idx be 0
                                    While copy_idx is less than bin_len:
                                        Let bin_char be memory_get_byte(binary, copy_idx)
                                        memory_set_byte(full_binary, copy_idx plus 2, bin_char)
                                        Set copy_idx to copy_idx plus 1
                                    End While
                                    memory_set_byte(full_binary, bin_len plus 2, 0)  Note: null
                                    deallocate(binary)

                                    Let token be token_create_owned(TOKEN_INTEGER, full_binary, line, column)
                                    Return token
                                Otherwise If peek_char is equal to b_upper:
                                    Note: Binary literal with uppercase B! Skip '0B'
                                    Let dummy_0b be lexer_advance(lexer)
                                    Let dummy_bb be lexer_advance(lexer)
                                    Let binary be lexer_read_binary(lexer)

                                    Note: Prepend "0b" to the result for parsing
                                    Let bin_len be string_length(binary)
                                    Let full_len be bin_len plus 3  Note: "0b" + digits + null
                                    Let full_binary be memory_allocate(full_len)
                                    memory_set_byte(full_binary, 0, 48)   Note: '0'
                                    memory_set_byte(full_binary, 1, 98)   Note: 'b'
                                    Let copy_idx be 0
                                    While copy_idx is less than bin_len:
                                        Let bin_char be memory_get_byte(binary, copy_idx)
                                        memory_set_byte(full_binary, copy_idx plus 2, bin_char)
                                        Set copy_idx to copy_idx plus 1
                                    End While
                                    memory_set_byte(full_binary, bin_len plus 2, 0)  Note: null
                                    deallocate(binary)

                                    Let token be token_create_owned(TOKEN_INTEGER, full_binary, line, column)
                                    Return token
                                End If
                            End If
                        End If

                        Note: Not binary, read as normal number (integer or float)
                        Let number be lexer_read_integer(lexer)

                        Note: Check if it contains '.' or 'e'/'E' to determine if it's a float
                        Let has_float_char be 0
                        Let check_idx be 0
                        Let num_len be string_length(number)
                        While check_idx is less than num_len:
                            Let check_char be memory_get_byte(number, check_idx)
                            Let dot_ch be 46   Note: '.'
                            Let e_low be 101   Note: 'e'
                            Let e_up be 69     Note: 'E'
                            If check_char is equal to dot_ch:
                                Set has_float_char to 1
                            Otherwise If check_char is equal to e_low:
                                Set has_float_char to 1
                            Otherwise If check_char is equal to e_up:
                                Set has_float_char to 1
                            End If
                            Set check_idx to check_idx plus 1
                        End While

                        If has_float_char is equal to 1:
                            Let token be token_create_owned(TOKEN_FLOAT_LITERAL, number, line, column)
                            Return token
                        Otherwise:
                            Let token be token_create_owned(TOKEN_INTEGER, number, line, column)
                            Return token
                        End If
                    Otherwise:
                        Note: Check for word (identifier or keyword)
                        Let is_alph be is_alpha(current_char)
                        If is_alph is equal to 1:
                            Let word be lexer_read_word(lexer)

                            Note: Special handling for Note comments - check before determining type
                            Let is_note be string_equals(word, "Note")
                            If is_note is equal to 0:
                                Note: Not a Note, determine token type and return it
                                Let type be determine_token_type(word)
                                Let token be token_create_owned(type, word, line, column)
                                Return token
                            End If

                            Note: If we get here, it's a Note comment - skip it
                            Let dummy_note be lexer_skip_note_comment(lexer)
                            deallocate(word)
                            Note: Loop will continue to next token
                        Otherwise:
                            Note: Check for single character tokens
                            Let token be check_single_char_token(lexer, current_char, line, column)
                            If token is not equal to 0:
                                Return token
                            Otherwise:
                                Note: Unexpected character error
                                Let error_msg be "[LEXER ERROR] Unexpected character '"
                                print_string(error_msg)
                                print_char(current_char)
                                Let at_msg be "' at line "
                                print_string(at_msg)
                                print_integer(line)
                                Let column_msg be ", column "
                                print_string(column_msg)
                                print_integer(column)
                                print_newline()

                                Let dummy3 be lexer_advance(lexer)
                                Let error_str be "Unexpected character"
                                Let token be token_create(TOKEN_ERROR, error_str, line, column)
                                Return token
                            End If
                        End If
                    End If
                End If
            End If
        End If
    End While

    Let line be memory_get_int32(lexer, 12)
    Let column be memory_get_int32(lexer, 16)
    Let token be token_create(TOKEN_EOF, 0, line, column)
    Return token
End Process

Note: Determine token type from word - OPTIMIZED with first-character branching
Process called "determine_token_type" takes word as Integer returns Integer:
    Note: Get first character to quickly branch
    Let first_char be memory_get_byte(word, 0)

    Note: Branch on first character - dramatically reduces comparisons
    Note: P: Process, Print
    If first_char is equal to 80:
        Return check_keywords_P(word)
    Otherwise If first_char is equal to 99:
        Note: c: called, containing
        Return check_keywords_c(word)
    Otherwise If first_char is equal to 114:
        Note: r: returns
        Return check_keywords_r(word)
    Otherwise If first_char is equal to 73:
        Note: I: Integer, If, Increase, Inline
        Return check_keywords_I(word)
    Otherwise If first_char is equal to 65:
        Note: A: Assembly
        Return check_keywords_A(word)
    Otherwise If first_char is equal to 83:
        Note: S: String, Set
        Return check_keywords_S(word)
    Otherwise If first_char is equal to 67:
        Note: C: Character, Continue
        Return check_keywords_C(word)
    Otherwise If first_char is equal to 82:
        Note: R: Return
        Return check_keywords_R(word)
    Otherwise If first_char is equal to 69:
        Note: E: End
        Return check_keywords_E(word)
    Otherwise If first_char is equal to 76:
        Note: L: Let
        Return check_keywords_L(word)
    Otherwise If first_char is equal to 98:
        Note: b: be, by
        Return check_keywords_b(word)
    Otherwise If first_char is equal to 115:
        Note: s: set (lowercase - shouldn't happen but be safe)
        Return check_keywords_s(word)
    Otherwise If first_char is equal to 116:
        Note: t: to, takes, than, that, true
        Return check_keywords_t(word)
    Otherwise If first_char is equal to 112:
        Note: p: plus
        Return check_keywords_p(word)
    Otherwise If first_char is equal to 109:
        Note: m: minus, multiplied
        Return check_keywords_m(word)
    Otherwise If first_char is equal to 105:
        Note: i: is, in, index, increased
        Return check_keywords_i(word)
    Otherwise If first_char is equal to 101:
        Note: e: equal, each
        Return check_keywords_e(word)
    Otherwise If first_char is equal to 108:
        Note: l: less, length
        Return check_keywords_l(word)
    Otherwise If first_char is equal to 103:
        Note: g: greater, gets
        Return check_keywords_g(word)
    Otherwise If first_char is equal to 110:
        Note: n: not, negative
        Return check_keywords_n(word)
    Otherwise If first_char is equal to 78:
        Note: N: Note
        Return check_keywords_N(word)
    Otherwise If first_char is equal to 97:
        Note: a: and, as, at, an, a
        Return check_keywords_a(word)
    Otherwise If first_char is equal to 111:
        Note: o: or
        Return check_keywords_o(word)
    Otherwise If first_char is equal to 79:
        Note: O: Otherwise
        Return check_keywords_O(word)
    Otherwise If first_char is equal to 87:
        Note: W: While
        Return check_keywords_W(word)
    Otherwise If first_char is equal to 84:
        Note: T: Type
        Return check_keywords_T(word)
    Otherwise If first_char is equal to 66:
        Note: B: Break
        Return check_keywords_B(word)
    Otherwise If first_char is equal to 102:
        Note: f: false, from, for
        Return check_keywords_f(word)
    Otherwise If first_char is equal to 100:
        Note: d: divided, decreased
        Return check_keywords_d(word)
    Otherwise If first_char is equal to 68:
        Note: D: Display, Decrease, Divide
        Return check_keywords_D(word)
    Otherwise If first_char is equal to 77:
        Note: M: Multiply
        Return check_keywords_M(word)
    Otherwise If first_char is equal to 70:
        Note: F: For
        Return check_keywords_F(word)
    Otherwise If first_char is equal to 119:
        Note: w: where
        Return check_keywords_w(word)
    Otherwise If first_char is equal to 107:
        Note: k: key
        Return check_keywords_k(word)
    Otherwise If first_char is equal to 85:
        Note: U: UnsignedInteger*
        Return check_keywords_U(word)
    End If

    Note: Not a keyword - check builtins then return identifier
    Let type be check_builtin_functions(word)
    Return type
End Process

Note: First-character helper functions for keyword lookup optimization

Process called "check_keywords_P" takes word as Integer returns Integer:
    If string_equals(word, "Process") is equal to 1:
        Return TOKEN_PROCESS
    Otherwise If string_equals(word, "Print") is equal to 1:
        Return TOKEN_PRINT
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_c" takes word as Integer returns Integer:
    If string_equals(word, "called") is equal to 1:
        Return TOKEN_CALLED
    Otherwise If string_equals(word, "containing") is equal to 1:
        Return TOKEN_CONTAINING
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_r" takes word as Integer returns Integer:
    If string_equals(word, "returns") is equal to 1:
        Return TOKEN_RETURNS
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_I" takes word as Integer returns Integer:
    If string_equals(word, "Integer128") is equal to 1:
        Return TOKEN_INTEGER128
    Otherwise If string_equals(word, "Integer64") is equal to 1:
        Return TOKEN_INTEGER64
    Otherwise If string_equals(word, "Integer32") is equal to 1:
        Return TOKEN_INTEGER32
    Otherwise If string_equals(word, "Integer16") is equal to 1:
        Return TOKEN_INTEGER16
    Otherwise If string_equals(word, "Integer8") is equal to 1:
        Return TOKEN_INTEGER8
    Otherwise If string_equals(word, "Integer") is equal to 1:
        Return TOKEN_INTEGER_TYPE
    Otherwise If string_equals(word, "If") is equal to 1:
        Return TOKEN_IF
    Otherwise If string_equals(word, "Increase") is equal to 1:
        Return TOKEN_INCREASE
    Otherwise If string_equals(word, "Inline") is equal to 1:
        Return TOKEN_INLINE
    Otherwise If string_equals(word, "Import") is equal to 1:
        Return TOKEN_IMPORT
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_A" takes word as Integer returns Integer:
    If string_equals(word, "Assembly") is equal to 1:
        Return TOKEN_ASSEMBLY
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_S" takes word as Integer returns Integer:
    If string_equals(word, "String") is equal to 1:
        Return TOKEN_STRING_TYPE
    Otherwise If string_equals(word, "Set") is equal to 1:
        Return TOKEN_SET
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_C" takes word as Integer returns Integer:
    If string_equals(word, "Character") is equal to 1:
        Return TOKEN_CHARACTER_TYPE
    Otherwise If string_equals(word, "Continue") is equal to 1:
        Return TOKEN_CONTINUE
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_R" takes word as Integer returns Integer:
    If string_equals(word, "Return") is equal to 1:
        Return TOKEN_RETURN
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_E" takes word as Integer returns Integer:
    If string_equals(word, "End") is equal to 1:
        Return TOKEN_END
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_L" takes word as Integer returns Integer:
    If string_equals(word, "Let") is equal to 1:
        Return TOKEN_LET
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_b" takes word as Integer returns Integer:
    If string_equals(word, "be") is equal to 1:
        Return TOKEN_BE
    Otherwise If string_equals(word, "by") is equal to 1:
        Return TOKEN_BY
    Otherwise If string_equals(word, "bit_and") is equal to 1:
        Return TOKEN_BIT_AND
    Otherwise If string_equals(word, "bit_or") is equal to 1:
        Return TOKEN_BIT_OR
    Otherwise If string_equals(word, "bit_xor") is equal to 1:
        Return TOKEN_BIT_XOR
    Otherwise If string_equals(word, "bit_shift_left") is equal to 1:
        Return TOKEN_BIT_SHIFT_LEFT
    Otherwise If string_equals(word, "bit_shift_right") is equal to 1:
        Return TOKEN_BIT_SHIFT_RIGHT
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_s" takes word as Integer returns Integer:
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_t" takes word as Integer returns Integer:
    If string_equals(word, "to") is equal to 1:
        Return TOKEN_TO
    Otherwise If string_equals(word, "takes") is equal to 1:
        Return TOKEN_TAKES
    Otherwise If string_equals(word, "than") is equal to 1:
        Return TOKEN_THAN
    Otherwise If string_equals(word, "that") is equal to 1:
        Return TOKEN_THAT
    Otherwise If string_equals(word, "true") is equal to 1:
        Return TOKEN_TRUE
    Otherwise If string_equals(word, "the") is equal to 1:
        Return TOKEN_THE
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_p" takes word as Integer returns Integer:
    If string_equals(word, "plus") is equal to 1:
        Return TOKEN_PLUS
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_m" takes word as Integer returns Integer:
    If string_equals(word, "minus") is equal to 1:
        Return TOKEN_MINUS
    Otherwise If string_equals(word, "multiplied") is equal to 1:
        Return TOKEN_MULTIPLIED
    Otherwise If string_equals(word, "modulo") is equal to 1:
        Return TOKEN_MODULO
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_i" takes word as Integer returns Integer:
    If string_equals(word, "is") is equal to 1:
        Return TOKEN_IS
    Otherwise If string_equals(word, "in") is equal to 1:
        Return TOKEN_IN
    Otherwise If string_equals(word, "index") is equal to 1:
        Return TOKEN_INDEX
    Otherwise If string_equals(word, "increased") is equal to 1:
        Return TOKEN_INCREASED
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_e" takes word as Integer returns Integer:
    If string_equals(word, "equal") is equal to 1:
        Return TOKEN_EQUAL
    Otherwise If string_equals(word, "each") is equal to 1:
        Return TOKEN_EACH
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_l" takes word as Integer returns Integer:
    If string_equals(word, "less") is equal to 1:
        Return TOKEN_LESS
    Otherwise If string_equals(word, "length") is equal to 1:
        Return TOKEN_LENGTH
    Otherwise If string_equals(word, "lambda") is equal to 1:
        Return TOKEN_LAMBDA
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_g" takes word as Integer returns Integer:
    If string_equals(word, "greater") is equal to 1:
        Return TOKEN_GREATER
    Otherwise If string_equals(word, "gets") is equal to 1:
        Return TOKEN_GETS
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_n" takes word as Integer returns Integer:
    If string_equals(word, "not") is equal to 1:
        Return TOKEN_NOT
    Otherwise If string_equals(word, "negative") is equal to 1:
        Return TOKEN_NEGATIVE
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_N" takes word as Integer returns Integer:
    If string_equals(word, "Note") is equal to 1:
        Return TOKEN_NOTE
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_a" takes word as Integer returns Integer:
    If string_equals(word, "and") is equal to 1:
        Return TOKEN_AND
    Otherwise If string_equals(word, "as") is equal to 1:
        Return TOKEN_AS
    Otherwise If string_equals(word, "at") is equal to 1:
        Return TOKEN_AT
    Otherwise If string_equals(word, "an") is equal to 1:
        Return TOKEN_AN
    Otherwise If string_equals(word, "array") is equal to 1:
        Return TOKEN_ARRAY
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_o" takes word as Integer returns Integer:
    If string_equals(word, "or") is equal to 1:
        Return TOKEN_OR
    Otherwise If string_equals(word, "of") is equal to 1:
        Return TOKEN_OF
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_O" takes word as Integer returns Integer:
    If string_equals(word, "Otherwise") is equal to 1:
        Return TOKEN_OTHERWISE
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_W" takes word as Integer returns Integer:
    If string_equals(word, "While") is equal to 1:
        Return TOKEN_WHILE
    Otherwise If string_equals(word, "When") is equal to 1:
        Return TOKEN_WHEN
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_T" takes word as Integer returns Integer:
    If string_equals(word, "Type") is equal to 1:
        Return TOKEN_TYPE
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_B" takes word as Integer returns Integer:
    If string_equals(word, "Break") is equal to 1:
        Return TOKEN_BREAK
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_f" takes word as Integer returns Integer:
    If string_equals(word, "false") is equal to 1:
        Return TOKEN_FALSE
    Otherwise If string_equals(word, "from") is equal to 1:
        Return TOKEN_FROM
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_d" takes word as Integer returns Integer:
    If string_equals(word, "divided") is equal to 1:
        Return TOKEN_DIVIDED
    Otherwise If string_equals(word, "decreased") is equal to 1:
        Return TOKEN_DECREASED
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_D" takes word as Integer returns Integer:
    If string_equals(word, "Display") is equal to 1:
        Return TOKEN_PRINT
    Otherwise If string_equals(word, "Decrease") is equal to 1:
        Return TOKEN_DECREASE
    Otherwise If string_equals(word, "Divide") is equal to 1:
        Return TOKEN_DIVIDE
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_M" takes word as Integer returns Integer:
    If string_equals(word, "Multiply") is equal to 1:
        Return TOKEN_MULTIPLY
    Otherwise If string_equals(word, "Match") is equal to 1:
        Return TOKEN_MATCH
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_F" takes word as Integer returns Integer:
    If string_equals(word, "Float64") is equal to 1:
        Return TOKEN_FLOAT64
    Otherwise If string_equals(word, "Float") is equal to 1:
        Return TOKEN_FLOAT
    Otherwise If string_equals(word, "For") is equal to 1:
        Return TOKEN_FOR
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_w" takes word as Integer returns Integer:
    If string_equals(word, "where") is equal to 1:
        Return TOKEN_WHERE
    Otherwise If string_equals(word, "with") is equal to 1:
        Return TOKEN_WITH
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_k" takes word as Integer returns Integer:
    If string_equals(word, "key") is equal to 1:
        Return TOKEN_KEY
    End If
    Return TOKEN_IDENTIFIER
End Process

Process called "check_keywords_U" takes word as Integer returns Integer:
    If string_equals(word, "UnsignedInteger128") is equal to 1:
        Return TOKEN_UNSIGNED_INTEGER128
    Otherwise If string_equals(word, "UnsignedInteger64") is equal to 1:
        Return TOKEN_UNSIGNED_INTEGER64
    Otherwise If string_equals(word, "UnsignedInteger32") is equal to 1:
        Return TOKEN_UNSIGNED_INTEGER32
    Otherwise If string_equals(word, "UnsignedInteger16") is equal to 1:
        Return TOKEN_UNSIGNED_INTEGER16
    Otherwise If string_equals(word, "UnsignedInteger8") is equal to 1:
        Return TOKEN_UNSIGNED_INTEGER8
    End If
    Return TOKEN_IDENTIFIER
End Process


Note: Check built-in function names
Process called "check_builtin_functions" takes word as Integer returns Integer:
    Note: Check all built-in functions
    Let break_str be "Break"
    Let result be string_equals(word, break_str)
    If result is equal to 1:
        Return TOKEN_BREAK
    End If

    Let continue_str be "Continue"
    Set result to string_equals(word, continue_str)
    If result is equal to 1:
        Return TOKEN_CONTINUE
    End If

    Let print_str be "Print"
    Set result to string_equals(word, print_str)
    If result is equal to 1:
        Return TOKEN_PRINT
    End If

    Let display_str be "Display"
    Set result to string_equals(word, display_str)
    If result is equal to 1:
        Return TOKEN_PRINT  Note: Display is treated as Print
    End If

    Let type_str be "Type"
    Set result to string_equals(word, type_str)
    If result is equal to 1:
        Return TOKEN_TYPE
    End If

    Let import_str be "Import"
    Set result to string_equals(word, import_str)
    If result is equal to 1:
        Return TOKEN_IMPORT
    End If

    Note: String functions
    Let string_length_str be "string_length"
    Set result to string_equals(word, string_length_str)
    If result is equal to 1:
        Return TOKEN_STRING_LENGTH
    End If

    Note: ... (continuing with all other function checks would make this too long)
    Note: For brevity, using a helper for the rest
    Let type be check_more_builtins(word)
    Return type
End Process

Note: Additional built-in checks
Process called "check_more_builtins" takes word as Integer returns Integer:
    Note: File I/O functions
    Let read_file_str be "read_file"
    Let result be string_equals(word, read_file_str)
    If result is equal to 1:
        Return TOKEN_READ_FILE
    End If
    Let write_file_str be "write_file"
    Set result to string_equals(word, write_file_str)
    If result is equal to 1:
        Return TOKEN_WRITE_FILE
    End If

    Note: Memory access functions
    Let memory_get_byte_str be "memory_get_byte"
    Set result to string_equals(word, memory_get_byte_str)
    If result is equal to 1:
        Return TOKEN_MEMORY_GET_BYTE
    End If

    Let memory_set_byte_str be "memory_set_byte"
    Set result to string_equals(word, memory_set_byte_str)
    If result is equal to 1:
        Return TOKEN_MEMORY_SET_BYTE
    End If

    Let bit_shift_left_str be "bit_shift_left"
    Set result to string_equals(word, bit_shift_left_str)
    If result is equal to 1:
        Return TOKEN_BIT_SHIFT_LEFT
    End If

    Let bit_shift_right_str be "bit_shift_right"
    Set result to string_equals(word, bit_shift_right_str)
    If result is equal to 1:
        Return TOKEN_BIT_SHIFT_RIGHT
    End If

    Let bit_and_str be "bit_and"
    Set result to string_equals(word, bit_and_str)
    If result is equal to 1:
        Return TOKEN_BIT_AND
    End If

    Let bit_or_str be "bit_or"
    Set result to string_equals(word, bit_or_str)
    If result is equal to 1:
        Return TOKEN_BIT_OR
    End If

    Let bit_xor_str be "bit_xor"
    Set result to string_equals(word, bit_xor_str)
    If result is equal to 1:
        Return TOKEN_BIT_XOR
    End If

    Note: Default to identifier
    Return TOKEN_IDENTIFIER
End Process

Note: Check single character tokens
Process called "check_single_char_token" takes lexer as Integer, char as Integer, line as Integer, column as Integer returns Integer:
    Note: Check for minus sign (when not followed by digit)
    Let minus_sign be 45  Note: ASCII for '-'
    If char is equal to minus_sign:
        Let dummy be lexer_advance(lexer)
        Let minus_str be "-"
        Let token be token_create(TOKEN_MINUS, minus_str, line, column)
        Return token
    Otherwise If char is equal to 58:
        Note: ASCII for ':'
        Let dummy be lexer_advance(lexer)
        Let colon_str be ":"
        Let token be token_create(TOKEN_COLON, colon_str, line, column)
        Return token
    Otherwise If char is equal to 40:
        Note: ASCII for '('
        Let dummy be lexer_advance(lexer)
        Let lparen_str be "("
        Let token be token_create(TOKEN_LPAREN, lparen_str, line, column)
        Return token
    Otherwise If char is equal to 41:
        Note: ASCII for ')'
        Let dummy be lexer_advance(lexer)
        Let rparen_str be ")"
        Let token be token_create(TOKEN_RPAREN, rparen_str, line, column)
        Return token
    Otherwise If char is equal to 91:
        Note: ASCII for '['
        Let dummy be lexer_advance(lexer)
        Let lbracket_str be "["
        Let token be token_create(TOKEN_LBRACKET, lbracket_str, line, column)
        Return token
    Otherwise If char is equal to 93:
        Note: ASCII for ']'
        Let dummy be lexer_advance(lexer)
        Let rbracket_str be "]"
        Let token be token_create(TOKEN_RBRACKET, rbracket_str, line, column)
        Return token
    Otherwise If char is equal to 46:
        Note: ASCII for '.'
        Let dummy be lexer_advance(lexer)
        Let dot_str be "."
        Let token be token_create(TOKEN_DOT, dot_str, line, column)
        Return token
    Otherwise If char is equal to 44:
        Note: ASCII for ','
        Let dummy be lexer_advance(lexer)
        Let comma_str be ","
        Let token be token_create(TOKEN_COMMA, comma_str, line, column)
        Return token
    Otherwise If char is equal to 124:
        Note: ASCII for '|'
        Let dummy be lexer_advance(lexer)
        Let pipe_str be "|"
        Let token be token_create(TOKEN_PIPE, pipe_str, line, column)
        Return token
    Otherwise If char is equal to 36:
        Note: ASCII for '$'
        Let dummy be lexer_advance(lexer)
        Let dollar_str be "$"
        Let token be token_create(TOKEN_DOLLAR, dollar_str, line, column)
        Return token
    Otherwise If char is equal to 95:
        Note: ASCII for '_' (underscore/wildcard)
        Let dummy be lexer_advance(lexer)
        Let underscore_str be "_"
        Let token be token_create(TOKEN_UNDERSCORE, underscore_str, line, column)
        Return token
    Otherwise If char is equal to 123:
        Note: ASCII for '{'
        Let dummy be lexer_advance(lexer)
        Let lbrace_str be "{"
        Let token be token_create(TOKEN_LBRACE, lbrace_str, line, column)
        Return token
    Otherwise If char is equal to 125:
        Note: ASCII for '}'
        Let dummy be lexer_advance(lexer)
        Let rbrace_str be "}"
        Let token be token_create(TOKEN_RBRACE, rbrace_str, line, column)
        Return token
    End If

    Return 0  Note: Not a single char token
End Process

Note: Destroy token
Process called "token_destroy" takes token as Integer returns Integer:
    If token is not equal to 0:
        Let value be memory_get_pointer(token, 8)
        If value is not equal to 0:
            deallocate(value)
        End If
        deallocate(token)
    End If
    Return 0
End Process

Note: Helper functions for character checking
Process called "is_alnum_char" takes char as Integer returns Integer:
    Let is_alph be is_alpha(char)
    If is_alph is equal to 1:
        Return 1
    End If
    Let is_dig be is_digit(char)
    Return is_dig
End Process

Note: Print functions for error messages
Process called "print_char" takes char as Integer returns Integer:
    Note: Create a temporary string with the character
    Let str be memory_allocate(2)
    string_set_char(str, 0, char)
    string_set_char(str, 1, 0)
    print_string(str)
    deallocate(str)
    Return 0
End Process

Process called "print_newline" takes dummy as Integer returns Integer:
    Let newline be 10
    Let result be print_char(newline)
    Return 0
End ProcessNote: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Parser for Runa v0.0.7.5
Note: Line-by-line transliteration from v0.0.7.3 parser.c

Note: Offsets for program structure (MUST match codegen.runa expectations!)
Note: This layout matches v0.0.7.3 C struct Program
Let PROGRAM_FUNCTIONS be 0      Note: Function **functions
Let PROGRAM_FUNCTION_COUNT be 8 Note: int function_count
Let PROGRAM_FUNCTION_CAPACITY be 12 Note: int function_capacity
Let PROGRAM_TYPES be 16         Note: TypeDefinition **types
Let PROGRAM_TYPE_COUNT be 24    Note: int type_count
Let PROGRAM_TYPE_CAPACITY be 28 Note: int type_capacity
Let PROGRAM_IMPORTS be 32       Note: Import **imports
Let PROGRAM_IMPORT_COUNT be 40  Note: int import_count
Let PROGRAM_IMPORT_CAPACITY be 44 Note: int import_capacity
Let PROGRAM_GLOBAL_VARS be 48   Note: GlobalVariable **globals
Let PROGRAM_GLOBAL_COUNT be 56  Note: int global_count
Let PROGRAM_GLOBAL_CAPACITY be 60 Note: int global_capacity

Note: Helper function to check if a token can be used as an identifier
Note: Some keywords are context-sensitive and can be variable names
Process called "token_can_be_identifier" takes token_type as Integer returns Integer:
    Note: Always accept TOKEN_IDENTIFIER
    If token_type is equal to 53:
        Return 1
    Otherwise If token_type is equal to 148:  Note: TOKEN_AT
        Return 1
    Otherwise If token_type is equal to 149:  Note: TOKEN_INDEX
        Return 1
    Otherwise If token_type is equal to 150:  Note: TOKEN_KEY
        Return 1
    Otherwise If token_type is equal to 151:  Note: TOKEN_LENGTH
        Return 1
    Otherwise If token_type is equal to 152:  Note: TOKEN_IN
        Return 1
    Otherwise If token_type is equal to 153:  Note: TOKEN_WHERE
        Return 1
    Otherwise If token_type is equal to 154:  Note: TOKEN_AN
        Return 1
    Otherwise If token_type is equal to 156:  Note: TOKEN_CONTAINING
        Return 1
    Otherwise If token_type is equal to 144:  Note: TOKEN_FROM
        Return 1
    Otherwise If token_type is equal to 145:  Note: TOKEN_EACH
        Return 1
    Otherwise If token_type is equal to 159:  Note: TOKEN_LIST
        Return 1
    Otherwise If token_type is equal to 160:  Note: TOKEN_DICTIONARY
        Return 1

    Note: Common variable names that are context-sensitive
    Otherwise If token_type is equal to 132:  Note: TOKEN_COUNT
        Return 1
    Otherwise If token_type is equal to 124:  Note: TOKEN_POINTER
        Return 1
    Otherwise If token_type is equal to 129:  Note: TOKEN_ERROR
        Return 1
    Otherwise If token_type is equal to 126:  Note: TOKEN_ARRAY
        Return 1
    End If

    Return 0
End Process

Note: Parser parse type - handles type annotations
Process called "parser_parse_type" takes parser as Integer returns Integer:
    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_int32(current_token, 0)

    Note: Check for basic types
    If token_type is equal to 163:  Note: TOKEN_INTEGER8
        parser_eat(parser, 163)
        Return type_create(0)  Note: Type kind 0 = Integer8
    Otherwise If token_type is equal to 164:  Note: TOKEN_INTEGER16
        parser_eat(parser, 164)
        Return type_create(1)  Note: Type kind 1 = Integer16
    Otherwise If token_type is equal to 165:  Note: TOKEN_INTEGER32
        parser_eat(parser, 165)
        Return type_create(2)  Note: Type kind 2 = Integer32
    Otherwise If token_type is equal to 166:  Note: TOKEN_INTEGER64
        parser_eat(parser, 166)
        Return type_create(3)  Note: Type kind 3 = Integer64
    Otherwise If token_type is equal to 167:  Note: TOKEN_INTEGER128
        parser_eat(parser, 167)
        Return type_create(4)  Note: Type kind 4 = Integer128
    Otherwise If token_type is equal to 168:  Note: TOKEN_UNSIGNED_INTEGER8
        parser_eat(parser, 168)
        Return type_create(5)  Note: Type kind 5 = UnsignedInteger8
    Otherwise If token_type is equal to 169:  Note: TOKEN_UNSIGNED_INTEGER16
        parser_eat(parser, 169)
        Return type_create(6)  Note: Type kind 6 = UnsignedInteger16
    Otherwise If token_type is equal to 170:  Note: TOKEN_UNSIGNED_INTEGER32
        parser_eat(parser, 170)
        Return type_create(7)  Note: Type kind 7 = UnsignedInteger32
    Otherwise If token_type is equal to 171:  Note: TOKEN_UNSIGNED_INTEGER64
        parser_eat(parser, 171)
        Return type_create(8)  Note: Type kind 8 = UnsignedInteger64
    Otherwise If token_type is equal to 172:  Note: TOKEN_UNSIGNED_INTEGER128
        parser_eat(parser, 172)
        Return type_create(9)  Note: Type kind 9 = UnsignedInteger128
    Otherwise If token_type is equal to 173:  Note: TOKEN_FLOAT
        parser_eat(parser, 173)
        Return type_create(10)  Note: Type kind 10 = Float
    Otherwise If token_type is equal to 174:  Note: TOKEN_FLOAT64
        parser_eat(parser, 174)
        Return type_create(11)  Note: Type kind 11 = Float64
    Otherwise If token_type is equal to 124:  Note: TOKEN_POINTER
        parser_eat(parser, 124)
        Return type_create(12)  Note: Type kind 12 = Pointer
    Otherwise If token_type is equal to 4:  Note: TOKEN_INTEGER_TYPE (default Integer)
        parser_eat(parser, 4)
        Return type_create(3)  Note: Integer defaults to Integer64
    Otherwise:
        print_string("[PARSER ERROR] Expected type name after 'as' at line ")
        Let line be memory_get_int32(current_token, 16)
        print_integer(line)
        print_newline()
        exit_with_code(1)
    End If
    Return 0  Note: Should never reach here
End Process

Note: Parser parse expression - entry point for expression parsing with PEMDAS precedence
Process called "parser_parse_expression" takes parser as Integer returns Integer:
    Return parser_parse_logical_or(parser)
End Process

Note: Parse logical OR expressions
Process called "parser_parse_logical_or" takes parser as Integer returns Integer:
    Let left be parser_parse_logical_and(parser)

    Let loop_or be 1
    While loop_or is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 31:  Note: TOKEN_OR
            parser_eat(parser, 31)
            Let right be parser_parse_logical_and(parser)
            Set left to expression_create_binary_op(left, 31, right)
        Otherwise:
            Set loop_or to 0
        End If
    End While

    Return left
End Process

Note: Parse logical AND expressions
Process called "parser_parse_logical_and" takes parser as Integer returns Integer:
    Let left be parser_parse_comparison_level(parser)

    Let loop_and be 1
    While loop_and is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 30:  Note: TOKEN_AND
            parser_eat(parser, 30)
            Let right be parser_parse_comparison_level(parser)
            Set left to expression_create_binary_op(left, 30, right)
        Otherwise:
            Set loop_and to 0
        End If
    End While

    Return left
End Process

Note: Parse comparison expressions (==, !=, <, >, etc.)
Process called "parser_parse_comparison_level" takes parser as Integer returns Integer:
    Return parser_parse_comparison(parser)
End Process

Note: Parse additive expressions (+ and -)
Process called "parser_parse_additive" takes parser as Integer returns Integer:
    Let left be parser_parse_multiplicative(parser)

    Let loop_additive be 1
    While loop_additive is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 16:  Note: TOKEN_PLUS
            Let operator be token_type
            parser_eat(parser, 16)
            Let right be parser_parse_multiplicative(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise:
            If token_type is equal to 17:  Note: TOKEN_MINUS
                Let operator be token_type
                parser_eat(parser, 17)
                Let right be parser_parse_multiplicative(parser)
                Set left to expression_create_binary_op(left, operator, right)
            Otherwise:
                Set loop_additive to 0
            End If
        End If
    End While

    Return left
End Process

Note: Parse multiplicative expressions (*, /, %)
Process called "parser_parse_multiplicative" takes parser as Integer returns Integer:
    Let left be parser_parse_primary_with_postfix(parser)

    Let loop_multiplicative be 1
    While loop_multiplicative is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 35:  Note: TOKEN_MULTIPLIED
            Let operator be token_type
            parser_eat(parser, 35)
            parser_eat(parser, 38)
            Let right be parser_parse_primary_with_postfix(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise:
            If token_type is equal to 36:  Note: TOKEN_DIVIDED
                Let operator be token_type
                parser_eat(parser, 36)
                parser_eat(parser, 38)
                Let right be parser_parse_primary_with_postfix(parser)
                Set left to expression_create_binary_op(left, operator, right)
            Otherwise:
                If token_type is equal to 37:  Note: TOKEN_MODULO
                    Let operator be token_type
                    parser_eat(parser, 37)
                    parser_eat(parser, 38)
                    Let right be parser_parse_primary_with_postfix(parser)
                    Set left to expression_create_binary_op(left, operator, right)
                Otherwise:
                    If token_type is equal to 42:  Note: TOKEN_BIT_SHIFT_LEFT
                        Let operator be token_type
                        parser_eat(parser, 42)
                        Let right be parser_parse_primary_with_postfix(parser)
                        Set left to expression_create_binary_op(left, operator, right)
                    Otherwise:
                        If token_type is equal to 43:  Note: TOKEN_BIT_SHIFT_RIGHT
                            Let operator be token_type
                            parser_eat(parser, 43)
                            Let right be parser_parse_primary_with_postfix(parser)
                            Set left to expression_create_binary_op(left, operator, right)
                        Otherwise:
                            If token_type is equal to 39:  Note: TOKEN_BIT_AND
                                Let operator be token_type
                                parser_eat(parser, 39)
                                Let right be parser_parse_primary_with_postfix(parser)
                                Set left to expression_create_binary_op(left, operator, right)
                            Otherwise:
                                If token_type is equal to 40:  Note: TOKEN_BIT_OR
                                    Let operator be token_type
                                    parser_eat(parser, 40)
                                    Let right be parser_parse_primary_with_postfix(parser)
                                    Set left to expression_create_binary_op(left, operator, right)
                                Otherwise:
                                    If token_type is equal to 41:  Note: TOKEN_BIT_XOR
                                        Let operator be token_type
                                        parser_eat(parser, 41)
                                        Let right be parser_parse_primary_with_postfix(parser)
                                        Set left to expression_create_binary_op(left, operator, right)
                                    Otherwise:
                                        Set loop_multiplicative to 0
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            End If
        End If
    End While

    Return left
End Process

Note: Parse primary expressions with postfix operators (function calls, field access, array indexing)
Process called "parser_parse_primary_with_postfix" takes parser as Integer returns Integer:
    Let left be parser_parse_primary(parser)

    Note: Check for function call (if primary was an identifier and followed by '(')
    Let current_token_fc be memory_get_pointer(parser, 8)
    Let token_type_fc be memory_get_integer(current_token_fc, 0)
    If token_type_fc is equal to 48:  Note: TOKEN_LPAREN (48)
        Note: Convert variable expression to function call
        Let expr_type be memory_get_integer(left, 0)
        If expr_type is equal to EXPR_VARIABLE:
            Note: Get the variable name from the EXPR_VARIABLE
            Let var_name be memory_get_pointer(left, 8)

            Note: Parse function arguments
            parser_eat(parser, 48)

            Note: Allocate space for arguments
            Let arguments be 0
            Let argument_count be 0
            Let argument_capacity be 4
            Let arg_ptr_size be 8
            Let arg_size be argument_capacity multiplied by arg_ptr_size
            Set arguments to memory_allocate(arg_size)

            Note: Parse arguments until we hit ')'
            Let continue_args be 1
            While continue_args is equal to 1:
                Let current_token_arg be memory_get_pointer(parser, 8)
                Let token_type_arg be memory_get_integer(current_token_arg, 0)

                If token_type_arg is equal to 49:  Note: TOKEN_RPAREN (49)
                    Set continue_args to 0
                Otherwise:
                    Note: Parse the argument expression
                    Let arg_expr be parser_parse_additive(parser)

                    Note: Store argument
                    Let arg_offset be argument_count multiplied by arg_ptr_size
                    Let arg_ptr be arguments plus arg_offset
                    memory_set_pointer(arg_ptr, 0, arg_expr)
                    Set argument_count to argument_count plus 1

                    Note: Check for comma
                    Let current_token_comma be memory_get_pointer(parser, 8)
                    Let token_type_comma be memory_get_integer(current_token_comma, 0)
                    If token_type_comma is equal to 52:  Note: TOKEN_COMMA (52)
                        parser_eat(parser, 52)
                    End If
                End If
            End While

            parser_eat(parser, 49)

            Note: Create function call expression
            Let func_call be expression_create_function_call(var_name, arguments, argument_count)
            deallocate(left)  Note: Free the old EXPR_VARIABLE
            Set left to func_call
        End If
    End If

    Note: Check for lambda call with "with" keyword (e.g., "double with 5" or "add with 3 and 5")
    Set current_token_fc to memory_get_pointer(parser, 8)
    Set token_type_fc to memory_get_integer(current_token_fc, 0)
    If token_type_fc is equal to 114:  Note: TOKEN_WITH (114)
        Note: This is a lambda invocation
        parser_eat(parser, 114)  Note: Eat "with"

        Note: Parse arguments (may be multiple with "and" separator)
        Let arguments be 0
        Let argument_count be 0
        Let arg_capacity be 4
        Let arg_size be arg_capacity multiplied by 8
        Set arguments to memory_allocate(arg_size)

        Note: Parse first argument
        Let arg_expr be parser_parse_additive(parser)
        memory_set_pointer(arguments, 0, arg_expr)
        Set argument_count to 1

        Note: Parse additional arguments with "and" keyword
        Let continue_args be 1
        While continue_args is equal to 1:
            Let next_arg_token be memory_get_pointer(parser, 8)
            Let next_arg_type be memory_get_int32(next_arg_token, 0)

            If next_arg_type is equal to 30:  Note: TOKEN_AND
                parser_eat(parser, 30)  Note: Eat "and"

                Note: Parse next argument
                Let arg_expr2 be parser_parse_additive(parser)

                Note: Store argument
                Let arg_offset be argument_count multiplied by 8
                memory_set_pointer(arguments plus arg_offset, 0, arg_expr2)
                Set argument_count to argument_count plus 1
            Otherwise:
                Set continue_args to 0
            End If
        End While

        Note: Create EXPR_LAMBDA_CALL expression
        Note: Structure: type(int32), lambda_expr(ptr at 8), arguments(ptr at 16), arg_count(int32 at 24)
        Let lambda_call be memory_allocate(32)
        memory_set_int32(lambda_call, 0, 24)  Note: EXPR_LAMBDA_CALL
        memory_set_pointer(lambda_call, 8, left)  Note: The lambda expression (closure)
        memory_set_pointer(lambda_call, 16, arguments)
        memory_set_int32(lambda_call, 24, argument_count)
        Set left to lambda_call
    End If

    Note: Handle field access and array indexing (highest precedence)
    Let loop_field be 1
    While loop_field is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 51:  Note: TOKEN_DOT
            parser_eat(parser, 51)

            Let current_token2 be memory_get_pointer(parser, 8)
            Let token_type2 be memory_get_integer(current_token2, 0)
            If token_type2 is not equal to 53:  Note: TOKEN_IDENTIFIER
                Let error_msg be "[PARSER ERROR] Expected field name after '.' at line "
                print_string(error_msg)
                Let line be memory_get_int32(current_token2, 16)
                print_integer(line)
                print_newline()
                exit_with_code(1)
            End If

            Let token_value be memory_get_pointer(current_token2, 8)
            Let field_name be string_duplicate_parser(token_value)
            parser_eat(parser, 53)

            Let field_access be memory_allocate(32)  Note: sizeof(Expression)
            memory_set_integer(field_access, 0, 10)  Note: EXPR_FIELD_ACCESS
            memory_set_pointer(field_access, 8, left)  Note: field_access.object
            memory_set_pointer(field_access, 16, field_name)  Note: field_access.field_name
            Set left to field_access
        End If

        If token_type is equal to 148:  Note: TOKEN_AT (canonical: "at index")
            Note: Peek ahead to check if "index" follows
            parser_eat(parser, 148)  Note: at
            Set current_token to memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Set token_type to memory_get_int32(current_token, TOKEN_TYPE_OFFSET)

            If token_type is equal to 149:  Note: TOKEN_INDEX
                parser_eat(parser, 149)  Note: index

                Note: Parse index expression
                Let index be parser_parse_additive(parser)

                Let array_index be memory_allocate(32)  Note: sizeof(Expression)
                memory_set_integer(array_index, 0, 16)  Note: EXPR_ARRAY_INDEX
                memory_set_pointer(array_index, 8, left)  Note: array_index.array
                memory_set_pointer(array_index, 16, index)  Note: array_index.index
                Set left to array_index
            Otherwise:
                Note: TOKEN_AT without "index" - syntax error
                print_string("[PARSER ERROR] Expected 'index' after 'at' at line ")
                Let error_line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                print_integer(error_line)
                print_newline()
                exit(1)
            End If
        End If

        If token_type is not equal to 51:
            If token_type is not equal to 148:
                Set loop_field to 0
            End If
        End If
    End While

    Note: Check for cast expression: "expression as Type"
    Let cast_token be memory_get_pointer(parser, 8)
    Let cast_token_type be memory_get_int32(cast_token, 0)
    If cast_token_type is equal to 34:  Note: TOKEN_AS
        parser_eat(parser, 34)
        Let target_type be parser_parse_type(parser)
        Return expression_create_cast(left, target_type)
    End If

    Return left
End Process

Note: Parser parse comparison - handles comparison operators
Process called "parser_parse_comparison" takes parser as Integer returns Integer:
    Let left be parser_parse_additive(parser)

    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_integer(current_token, 0)

    If token_type is equal to 21:  Note: TOKEN_IS
        parser_eat(parser, 21)

        Let current_token2 be memory_get_pointer(parser, 8)
        Let token_type2 be memory_get_integer(current_token2, 0)

        Note: Check for "not" negation
        Let is_negated be 0
        If token_type2 is equal to 29:  Note: TOKEN_NOT
            parser_eat(parser, 29)
            Set is_negated to 1
            Set current_token2 to memory_get_pointer(parser, 8)
            Set token_type2 to memory_get_integer(current_token2, 0)
        End If

        Let comparison_op be 0

        Note: Handle EQUAL / NOT EQUAL
        If token_type2 is equal to 22:  Note: TOKEN_EQUAL
            parser_eat(parser, 22)
            parser_eat(parser, 15)  Note: TOKEN_TO
            If is_negated is equal to 1:
                Let comparison_op be 23  Note: TOKEN_NOT_EQUAL
            Otherwise:
                Let comparison_op be 22  Note: TOKEN_EQUAL
            End If
        End If

        Note: Handle LESS THAN (and LESS EQUAL)
        If token_type2 is equal to 24:
            parser_eat(parser, 24)
            Let current_token3 be memory_get_pointer(parser, 8)
            Let token_type3 be memory_get_integer(current_token3, 0)
            If token_type3 is equal to 28:  Note: TOKEN_THAN
                parser_eat(parser, 28)
                Let current_token4 be memory_get_pointer(parser, 8)
                Let token_type4 be memory_get_integer(current_token4, 0)
                If token_type4 is equal to 31:  Note: TOKEN_OR (for "or equal to")
                    parser_eat(parser, 31)
                    parser_eat(parser, 22)
                    parser_eat(parser, 15)
                    Note: "is less than or equal to" vs "is not less than or equal to"
                    If is_negated is equal to 1:
                        Let comparison_op be 25  Note: TOKEN_GREATER (inverted)
                    Otherwise:
                        Let comparison_op be 27  Note: TOKEN_LESS_EQUAL
                    End If
                End If
                If token_type4 is not equal to 31:  Note: Not TOKEN_OR
                    Note: "is less than" vs "is not less than"
                    If is_negated is equal to 1:
                        Let comparison_op be 26  Note: TOKEN_GREATER_EQUAL (inverted)
                    Otherwise:
                        Let comparison_op be 24  Note: TOKEN_LESS
                    End If
                End If
            End If
            If token_type3 is not equal to 28:  Note: Not TOKEN_THAN
                Let error_msg be "[PARSER ERROR] Expected 'than' after 'less' at line "
                print_string(error_msg)
                Let line be memory_get_int32(current_token3, 16)
                print_integer(line)
                print_newline()
                exit_with_code(1)
            End If
        End If

        Note: Handle GREATER THAN (and GREATER EQUAL)
        If token_type2 is equal to 25:
            parser_eat(parser, 25)
            Let current_token3 be memory_get_pointer(parser, 8)
            Let token_type3 be memory_get_integer(current_token3, 0)
            If token_type3 is equal to 28:  Note: TOKEN_THAN
                parser_eat(parser, 28)
                Let current_token4 be memory_get_pointer(parser, 8)
                Let token_type4 be memory_get_integer(current_token4, 0)
                If token_type4 is equal to 31:  Note: TOKEN_OR (for "or equal to")
                    parser_eat(parser, 31)
                    parser_eat(parser, 22)
                    parser_eat(parser, 15)
                    Note: "is greater than or equal to" vs "is not greater than or equal to"
                    If is_negated is equal to 1:
                        Let comparison_op be 24  Note: TOKEN_LESS (inverted)
                    Otherwise:
                        Let comparison_op be 26  Note: TOKEN_GREATER_EQUAL
                    End If
                End If
                If token_type4 is not equal to 31:  Note: Not TOKEN_OR
                    Note: "is greater than" vs "is not greater than"
                    If is_negated is equal to 1:
                        Let comparison_op be 27  Note: TOKEN_LESS_EQUAL (inverted)
                    Otherwise:
                        Let comparison_op be 25  Note: TOKEN_GREATER
                    End If
                End If
            End If
            If token_type3 is not equal to 28:  Note: Not TOKEN_THAN
                Let error_msg be "[PARSER ERROR] Expected 'than' after 'greater' at line "
                print_string(error_msg)
                Let line be memory_get_int32(current_token3, 16)
                print_integer(line)
                print_newline()
                exit_with_code(1)
            End If
        End If

        Note: Check if we got a valid comparison operator
        If comparison_op is equal to 0:
            Let error_msg be "[PARSER ERROR] Expected 'equal', 'less', or 'greater' after 'is' at line "
            print_string(error_msg)
            Let line be memory_get_int32(current_token2, 16)
            print_integer(line)
            print_newline()
            exit_with_code(1)
        End If

        Let right be parser_parse_additive(parser)
        Return expression_create_comparison(left, comparison_op, right)
    End If

    Return left
End Process

Note: Parser parse let statement - handles "Let var be expression"
Process called "parser_parse_let_statement" takes parser as Integer returns Integer:
    Note: Debug check for NULL parser
    If parser is equal to 0:
        print_string("[PARSER ERROR] NULL parser in parser_parse_let_statement")
        print_newline()
        exit(1)
    End If
    parser_eat(parser, 12)  Note: TOKEN_LET

    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_integer(current_token, 0)
    Let can_be_id be token_can_be_identifier(token_type)
    If can_be_id is not equal to 1:
        Let error_msg be "[PARSER ERROR] Expected identifier after Let at line "
        print_string(error_msg)
        Let line be memory_get_int32(current_token, 16)
        print_integer(line)
        print_newline()
        exit_with_code(1)
    End If

    Let token_value be memory_get_pointer(current_token, 8)
    Let var_name be string_duplicate_parser(token_value)
    parser_eat(parser, token_type)

    parser_eat(parser, 13)  Note: TOKEN_BE

    Note: Debug check before expression parsing
    If parser is equal to 0:
        print_string("[PARSER ERROR] parser became NULL before expression parsing in Let")
        print_newline()
        exit(1)
    End If

    Let expr be parser_parse_expression(parser)

    Return statement_create_let(var_name, expr)
End Process

Note: Parser parse set statement - handles "Set target to expression"
Process called "parser_parse_implicit_compound_assign" takes parser as Integer, operation as Integer returns Integer:
    Note: Parse implicit compound assignment: Increase/Decrease/Multiply/Divide X by Y
    Note: operation: 0=add, 1=sub, 2=mul, 3=div

    Note: Eat the operation token (INCREASE/DECREASE/MULTIPLY/DIVIDE)
    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_int32(current_token, 0)
    parser_eat(parser, token_type)

    Note: Parse target variable/expression
    Let target be parser_parse_expression(parser)

    Note: Eat BY token (38)
    parser_eat(parser, 38)

    Note: Parse value expression
    Let expr be parser_parse_expression(parser)

    Note: Create compound assignment statement
    Let stmt be statement_create_compound_assign(target, operation, expr)
    Return stmt
End Process

Process called "parser_parse_set_statement" takes parser as Integer returns Integer:
    parser_eat(parser, 14)

    Note: Parse the target expression (could be variable or nested field access)
    Let target be parser_parse_expression(parser)

    Note: Check for compound assignment: gets [increased|decreased|multiplied|divided] by
    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_int32(current_token, 0)

    Note: TOKEN_GETS is 136
    If token_type is equal to 136:
        Note: This is a compound assignment: Set X gets [op] by Y
        parser_eat(parser, 136)

        Note: Get operation token
        Set current_token to memory_get_pointer(parser, 8)
        Set token_type to memory_get_int32(current_token, 0)

        Let operation be 0
        Note: TOKEN_INCREASED is 137, TOKEN_DECREASED is 138
        Note: TOKEN_MULTIPLIED is 35, TOKEN_DIVIDED is 36
        Note: TOKEN_MULTIPLY is 141, TOKEN_DIVIDE is 142
        If token_type is equal to 137:
            Set operation to 0
            parser_eat(parser, 137)
        End If
        If token_type is equal to 138:
            Set operation to 1
            parser_eat(parser, 138)
        End If
        If token_type is equal to 35:
            Set operation to 2
            parser_eat(parser, 35)
        End If
        If token_type is equal to 141:
            Set operation to 2
            parser_eat(parser, 141)
        End If
        If token_type is equal to 36:
            Set operation to 3
            parser_eat(parser, 36)
        End If
        If token_type is equal to 142:
            Set operation to 3
            parser_eat(parser, 142)
        End If
        If operation is equal to 0:
            If token_type is not equal to 137:
                print_string("Parser error: Expected operation after gets (got token ")
                print_integer(token_type)
                print_string(")")
                print_newline()
                exit_with_code(1)
            End If
        End If

        parser_eat(parser, 38)

        Let expr be parser_parse_expression(parser)

        Let stmt be statement_create_compound_assign(target, operation, expr)
        Return stmt
    End If

    Note: Normal set statement: Set X to Y
    parser_eat(parser, 15)

    Let expr be parser_parse_expression(parser)

    Let stmt be statement_create_set(target, expr)
    Return stmt
End Process

Note: token_destroy is provided by lexer module - use external reference
Note: Process called "token_destroy" is defined in lexer.runa

Note: Expression type constants
Let EXPR_INTEGER be 0
Let EXPR_VARIABLE be 1
Let EXPR_BINARY_OP be 2
Let EXPR_COMPARISON be 3
Let EXPR_FUNCTION_CALL be 4
Let EXPR_STRING_LITERAL be 5
Let EXPR_FIELD_ACCESS be 6
Let EXPR_TYPE_NAME be 7
Let EXPR_BUILTIN_CALL be 8
Let EXPR_VARIANT_CONSTRUCTOR be 9
Let EXPR_FUNCTION_POINTER be 10
Let EXPR_INDIRECT_CALL be 11
Let EXPR_ARRAY_INDEX be 16
Let EXPR_LIST_LITERAL be 17
Let EXPR_SET_LITERAL be 21
Let EXPR_DICT_LITERAL be 22
Let EXPR_STRUCT_CONSTRUCTION be 20
Let EXPR_LAMBDA be 23
Let EXPR_LAMBDA_CALL be 24
Let EXPR_CAST be 25

Note: Statement type constants - synchronized with codegen.runa
Let STMT_LET be 1
Let STMT_SET be 2
Let STMT_RETURN be 3
Let STMT_PRINT be 4
Let STMT_IF be 5
Let STMT_WHILE be 6
Let STMT_EXPRESSION be 7
Let STMT_MATCH be 8
Let STMT_BREAK be 9
Let STMT_CONTINUE be 10
Let STMT_FOR be 11
Let STMT_FOR_EACH be 12
Let STMT_IMPORT be 13
Let STMT_INLINE_ASSEMBLY be 16
Let STMT_COMPOUND_ASSIGN be 17

Note: Match statement structure offsets
Let STMT_MATCH_EXPR be 8
Let STMT_MATCH_WHEN_CLAUSES be 16
Let STMT_MATCH_WHEN_COUNT be 24

Note: When clause structure offsets (48 bytes per clause)
Let WHEN_PATTERN_TYPE be 0
Let WHEN_PATTERN_VALUE be 8
Let WHEN_FIELD_BINDINGS be 16
Let WHEN_FIELD_COUNT be 24
Let WHEN_BODY_STMTS be 32
Let WHEN_BODY_COUNT be 40

Note: Pattern type constants
Let PATTERN_LITERAL be 0
Let PATTERN_VARIANT be 1
Let PATTERN_WILDCARD be 2
Let PATTERN_TYPE be 3

Note: Type kind constants
Let TYPE_KIND_STRUCT be 0
Let TYPE_KIND_VARIANT be 1
Let TYPE_KIND_FUNCTION be 2
Let TYPE_KIND_ARRAY be 3

Note: TOKEN constants (from lexer.h enum - sequential numbering)
Note: These are defined in lexer.runa and will be available as external symbols
Note: DO NOT REDEFINE - use external references from lexer module
Note: Let TOKEN_EOF be 0
Note: Let TOKEN_PROCESS be 1
Note: Let TOKEN_CALLED be 2
Note: Let TOKEN_RETURNS be 3
Note: Let TOKEN_INTEGER_TYPE be 4
Note: Let TOKEN_STRING_TYPE be 5
Note: Let TOKEN_CHARACTER_TYPE be 6
Note: Let TOKEN_RETURN be 7
Note: Let TOKEN_END be 8
Note: Let TOKEN_COLON be 9
Note: Let TOKEN_STRING_LITERAL be 10
Note: Let TOKEN_INTEGER be 11
Note: Let TOKEN_LET be 12
Note: Let TOKEN_BE be 13
Note: Let TOKEN_SET be 14
Note: Let TOKEN_TO be 15
Note: Let TOKEN_PLUS be 16
Note: Let TOKEN_MINUS be 17
Note: Let TOKEN_IF be 18
Note: Let TOKEN_OTHERWISE be 19
Note: Let TOKEN_WHILE be 20
Note: Let TOKEN_IS be 21
Note: Let TOKEN_EQUAL be 22
Note: Let TOKEN_NOT_EQUAL be 23
Note: Let TOKEN_LESS be 24
Note: Let TOKEN_GREATER be 25
Note: Let TOKEN_GREATER_EQUAL be 26
Note: Let TOKEN_LESS_EQUAL be 27
Note: Let TOKEN_THAN be 28
Note: Let TOKEN_NOT be 29
Note: Let TOKEN_AND be 30
Note: Let TOKEN_OR be 31
Note: Let TOKEN_THAT be 32
Note: Let TOKEN_TAKES be 33
Note: Let TOKEN_AS be 34
Note: Let TOKEN_MULTIPLIED be 35
Note: Let TOKEN_DIVIDED be 36
Note: Let TOKEN_MODULO be 37
Note: Let TOKEN_BY be 38
Note: Let TOKEN_BIT_AND be 39
Note: Let TOKEN_BIT_OR be 40
Note: Let TOKEN_BIT_XOR be 41
Note: Let TOKEN_BIT_SHIFT_LEFT be 42
Note: Let TOKEN_BIT_SHIFT_RIGHT be 43
Note: Let TOKEN_BREAK be 44
Note: Let TOKEN_CONTINUE be 45
Note: Let TOKEN_OTHERWISE_IF be 46
Note: Let TOKEN_PRINT be 47
Note: Let TOKEN_LPAREN be 48
Note: Let TOKEN_RPAREN be 49
Note: Let TOKEN_TYPE be 50
Note: Let TOKEN_DOT be 51
Note: Let TOKEN_COMMA be 52
Note: Let TOKEN_IDENTIFIER be 53
Note: Let TOKEN_READ_FILE be 54
Note: Let TOKEN_WRITE_FILE be 55
Note: Let TOKEN_IMPORT be 56
Note: Let TOKEN_STRING_LENGTH be 57
Note: Let TOKEN_STRING_CHAR_AT be 58
Note: Let TOKEN_STRING_SUBSTRING be 59
Note: Let TOKEN_STRING_EQUALS be 60
Note: Let TOKEN_ASCII_VALUE_OF be 61
Note: Let TOKEN_IS_DIGIT be 62
Note: Let TOKEN_IS_ALPHA be 63
Note: Let TOKEN_IS_WHITESPACE be 64
Note: Let TOKEN_LIST_CREATE be 65
Note: Let TOKEN_LIST_APPEND be 66
Note: Let TOKEN_LIST_GET be 67
Note: Let TOKEN_LIST_GET_INTEGER be 68
Note: Let TOKEN_LIST_LENGTH be 69
Note: Let TOKEN_LIST_DESTROY be 70
Note: Let TOKEN_LIST_SET be 71
Note: Let TOKEN_LIST_INSERT be 72
Note: Let TOKEN_LIST_REMOVE be 73
Note: Let TOKEN_LIST_CLEAR be 74
Note: Let TOKEN_LIST_FIND be 75
Note: Let TOKEN_LIST_SORT be 76
Note: Let TOKEN_LIST_REVERSE be 77
Note: Let TOKEN_LIST_COPY be 78
Note: Let TOKEN_LIST_MERGE be 79
Note: Let TOKEN_STRING_CONCAT be 80
Note: Let TOKEN_STRING_COMPARE be 81
Note: Let TOKEN_STRING_TO_INTEGER be 82
Note: Let TOKEN_INTEGER_TO_STRING be 83
Note: Let TOKEN_STRING_FIND be 84
Note: Let TOKEN_STRING_REPLACE be 85
Note: Let TOKEN_STRING_TRIM be 86
Note: Let TOKEN_STRING_SPLIT be 87
Note: Let TOKEN_FILE_OPEN be 88
Note: Let TOKEN_FILE_CLOSE be 89
Note: Let TOKEN_FILE_READ_LINE be 90
Note: Let TOKEN_FILE_WRITE_LINE be 91
Note: Let TOKEN_FILE_EXISTS be 92
Note: Let TOKEN_FILE_DELETE be 93
Note: Let TOKEN_FILE_SIZE be 94
Note: Let TOKEN_FILE_SEEK be 95
Note: Let TOKEN_FILE_TELL be 96
Note: Let TOKEN_FILE_EOF be 97
Note: Let TOKEN_SIN be 98
Note: Let TOKEN_COS be 99
Note: Let TOKEN_TAN be 100
Note: Let TOKEN_SQRT be 101
Note: Let TOKEN_POW be 102
Note: Let TOKEN_ABS be 103
Note: Let TOKEN_FLOOR be 104
Note: Let TOKEN_CEIL be 105
Note: Let TOKEN_MIN be 106
Note: Let TOKEN_MAX be 107
Note: Let TOKEN_RANDOM be 108
Note: Let TOKEN_LOG be 109
Note: Let TOKEN_EXP be 110
Note: Let TOKEN_PIPE be 111
Note: Let TOKEN_MATCH be 112
Note: Let TOKEN_WHEN be 113
Note: Let TOKEN_WITH be 114
Note: Let TOKEN_GET_COMMAND_LINE_ARGS be 115
Note: Let TOKEN_EXIT_WITH_CODE be 116
Note: Let TOKEN_PANIC be 117
Note: Let TOKEN_ASSERT be 118
Note: Let TOKEN_ALLOCATE be 119
Note: Let TOKEN_DEALLOCATE be 120
Note: Let TOKEN_INLINE be 121
Note: Let TOKEN_ASSEMBLY be 122
Note: Let TOKEN_NOTE be 123
Note: Let TOKEN_POINTER be 124
Note: Let TOKEN_OF be 125
Note: Let TOKEN_ARRAY be 126
Note: Let TOKEN_LBRACKET be 127
Note: Let TOKEN_RBRACKET be 128
Note: Let TOKEN_ERROR be 129
Note: Let TOKEN_COUNT be 130

Note: TypeDefinition constants (matching C struct layout)
Let TypeDefinition_SIZE be 48
Let TYPEDEFINITION_NAME_OFFSET be 0
Let TYPEDEFINITION_KIND_OFFSET be 8
Let TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET be 16
Let TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET be 24
Let TYPEDEFINITION_SIZE_OFFSET be 40
Let TYPEDEFINITION_DATA_ARRAY_ELEMENT_TYPE_OFFSET be 16
Let TYPEDEFINITION_DATA_ARRAY_ELEMENT_SIZE_OFFSET be 24
Let TYPEDEFINITION_DATA_ARRAY_LENGTH_OFFSET be 28
Let TYPEDEFINITION_DATA_FUNCTION_PARAM_TYPES_OFFSET be 16
Let TYPEDEFINITION_DATA_FUNCTION_PARAM_COUNT_OFFSET be 24
Let TYPEDEFINITION_DATA_FUNCTION_RETURN_TYPE_OFFSET be 32
Let TYPEDEFINITION_DATA_VARIANT_VARIANTS_OFFSET be 16
Let TYPEDEFINITION_DATA_VARIANT_VARIANT_COUNT_OFFSET be 24

Note: TypeField constants (matching C struct layout)
Let TYPEFIELD_SIZE be 24
Let TYPEFIELD_NAME_OFFSET be 0
Let TYPEFIELD_TYPE_OFFSET be 8
Let TYPEFIELD_OFFSET_OFFSET be 16
Let TYPEFIELD_SIZE_OFFSET be 20

Note: Variant constants (matching C struct layout)
Let VARIANT_SIZE be 32
Let VARIANT_NAME_OFFSET be 0
Let VARIANT_FIELDS_OFFSET be 8
Let VARIANT_FIELD_COUNT_OFFSET be 16
Let VARIANT_TAG_OFFSET be 20

Note: Type kind constants already defined above

Note: Parser constants (definitions moved to bottom of file)
Let PARSER_CURRENT_TOKEN_OFFSET be 8
Let PARSER_CURRENT_PROGRAM_OFFSET be 16
Let EXPRESSION_TYPE_OFFSET be 0

Note: String duplicate helper (already in string_utils but needed locally)
Process called "string_duplicate_parser" takes str as Integer returns Integer:
    If str is equal to 0:
        Return 0
    End If
    Let len be string_length(str)
    Let one be 1
    Let size be len plus one
    Let dup be memory_allocate(size)
    string_copy(dup, str)
    Return dup
End Process

Note: Parser advance - moves to next token
Process called "parser_advance" takes parser as Integer returns Integer:
    Let current_token be memory_get_pointer(parser, 8)  Note: parser->current_token
    token_destroy(current_token)
    Let lexer be memory_get_pointer(parser, 0)  Note: parser->lexer
    Let next_token be lexer_next_token(lexer)
    memory_set_pointer(parser, 8, next_token)
    Return 0
End Process

Note: Parser eat - consume expected token
Process called "parser_eat" takes parser as Integer, expected_type as Integer returns Integer:
    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_integer(current_token, 0)

    If token_type is equal to expected_type:
        Let dummy be parser_advance(parser)
    Otherwise:
        Note: Print error message
        Let error_msg be "[PARSER ERROR] Expected token type "
        print_string(error_msg)
        print_integer(expected_type)
        Let got_msg be ", got "
        print_string(got_msg)
        print_integer(token_type)
        Let at_line_msg be " at line "
        print_string(at_line_msg)
        Let line be memory_get_int32(current_token, 16)
        print_integer(line)
        print_newline()
        exit_with_code(1)
    End If
    Return 0
End Process

Note: Check if token is builtin function
Process called "parser_is_builtin_function_token" takes type as Integer returns Integer:
    Note: All builtin functions in order (54-120, excluding non-builtin tokens)
    Note: File operations
    If type is equal to 54:  Note: TOKEN_READ_FILE
        Return 1
    Otherwise If type is equal to 55:  Note: TOKEN_WRITE_FILE
        Return 1
    Note: String operations
    Otherwise If type is equal to 57:  Note: TOKEN_STRING_LENGTH
        Return 1
    Otherwise If type is equal to 58:  Note: TOKEN_STRING_CHAR_AT
        Return 1
    Otherwise If type is equal to 59:  Note: TOKEN_STRING_SUBSTRING
        Return 1
    Otherwise If type is equal to 60:  Note: TOKEN_STRING_EQUALS
        Return 1
    Otherwise If type is equal to 61:  Note: TOKEN_ASCII_VALUE_OF
        Return 1
    Otherwise If type is equal to 62:  Note: TOKEN_IS_DIGIT
        Return 1
    Otherwise If type is equal to 63:  Note: TOKEN_IS_ALPHA
        Return 1
    Otherwise If type is equal to 64:  Note: TOKEN_IS_WHITESPACE
        Return 1
    Note: List operations
    Otherwise If type is equal to 65:  Note: TOKEN_LIST_CREATE
        Return 1
    Otherwise If type is equal to 66:  Note: TOKEN_LIST_APPEND
        Return 1
    Otherwise If type is equal to 67:  Note: TOKEN_LIST_GET
        Return 1
    Otherwise If type is equal to 68:  Note: TOKEN_LIST_GET_INTEGER
        Return 1
    Otherwise If type is equal to 69:  Note: TOKEN_LIST_LENGTH
        Return 1
    Otherwise If type is equal to 70:  Note: TOKEN_LIST_DESTROY
        Return 1
    Otherwise If type is equal to 71:  Note: TOKEN_LIST_SET
        Return 1
    Otherwise If type is equal to 72:  Note: TOKEN_LIST_INSERT
        Return 1
    Otherwise If type is equal to 73:  Note: TOKEN_LIST_REMOVE
        Return 1
    Otherwise If type is equal to 74:  Note: TOKEN_LIST_CLEAR
        Return 1
    Otherwise If type is equal to 75:  Note: TOKEN_LIST_FIND
        Return 1
    Otherwise If type is equal to 76:  Note: TOKEN_LIST_SORT
        Return 1
    Otherwise If type is equal to 77:  Note: TOKEN_LIST_REVERSE
        Return 1
    Otherwise If type is equal to 78:  Note: TOKEN_LIST_COPY
        Return 1
    Otherwise If type is equal to 79:  Note: TOKEN_LIST_MERGE
        Return 1
    Note: More string operations
    Otherwise If type is equal to 80:  Note: TOKEN_STRING_CONCAT
        Return 1
    Otherwise If type is equal to 81:  Note: TOKEN_STRING_COMPARE
        Return 1
    Otherwise If type is equal to 82:  Note: TOKEN_STRING_TO_INTEGER
        Return 1
    Otherwise If type is equal to 83:  Note: TOKEN_INTEGER_TO_STRING
        Return 1
    Otherwise If type is equal to 84:  Note: TOKEN_STRING_FIND
        Return 1
    Otherwise If type is equal to 85:  Note: TOKEN_STRING_REPLACE
        Return 1
    Otherwise If type is equal to 86:  Note: TOKEN_STRING_TRIM
        Return 1
    Otherwise If type is equal to 87:  Note: TOKEN_STRING_SPLIT
        Return 1
    Note: More file operations
    Otherwise If type is equal to 88:  Note: TOKEN_FILE_OPEN
        Return 1
    Otherwise If type is equal to 89:  Note: TOKEN_FILE_CLOSE
        Return 1
    Otherwise If type is equal to 90:  Note: TOKEN_FILE_READ_LINE
        Return 1
    Otherwise If type is equal to 91:  Note: TOKEN_FILE_WRITE_LINE
        Return 1
    Otherwise If type is equal to 92:  Note: TOKEN_FILE_EXISTS
        Return 1
    Otherwise If type is equal to 93:  Note: TOKEN_FILE_DELETE
        Return 1
    Otherwise If type is equal to 94:  Note: TOKEN_FILE_SIZE
        Return 1
    Otherwise If type is equal to 95:  Note: TOKEN_FILE_SEEK
        Return 1
    Otherwise If type is equal to 96:  Note: TOKEN_FILE_TELL
        Return 1
    Otherwise If type is equal to 97:  Note: TOKEN_FILE_EOF
        Return 1
    Note: Math operations
    Otherwise If type is equal to 98:  Note: TOKEN_SIN
        Return 1
    Otherwise If type is equal to 99:  Note: TOKEN_COS
        Return 1
    Otherwise If type is equal to 100:  Note: TOKEN_TAN
        Return 1
    Otherwise If type is equal to 101:  Note: TOKEN_SQRT
        Return 1
    Otherwise If type is equal to 102:  Note: TOKEN_POW
        Return 1
    Otherwise If type is equal to 103:  Note: TOKEN_ABS
        Return 1
    Otherwise If type is equal to 104:  Note: TOKEN_FLOOR
        Return 1
    Otherwise If type is equal to 105:  Note: TOKEN_CEIL
        Return 1
    Otherwise If type is equal to 106:  Note: TOKEN_MIN
        Return 1
    Otherwise If type is equal to 107:  Note: TOKEN_MAX
        Return 1
    Otherwise If type is equal to 108:  Note: TOKEN_RANDOM
        Return 1
    Otherwise If type is equal to 109:  Note: TOKEN_LOG
        Return 1
    Otherwise If type is equal to 110:  Note: TOKEN_EXP
        Return 1
    Note: System operations
    Otherwise If type is equal to 115:  Note: TOKEN_GET_COMMAND_LINE_ARGS
        Return 1
    Otherwise If type is equal to 116:  Note: TOKEN_EXIT_WITH_CODE
        Return 1
    Otherwise If type is equal to 117:  Note: TOKEN_PANIC
        Return 1
    Otherwise If type is equal to 118:  Note: TOKEN_ASSERT
        Return 1
    Otherwise If type is equal to 119:  Note: TOKEN_ALLOCATE
        Return 1
    Otherwise If type is equal to 120:  Note: TOKEN_DEALLOCATE
        Return 1
    Otherwise If type is equal to 130:  Note: TOKEN_MEMORY_GET_BYTE
        Return 1
    Otherwise If type is equal to 131:  Note: TOKEN_MEMORY_SET_BYTE
        Return 1
    End If
    Return 0
End Process

Note: Create integer expression
Process called "expression_create_integer" takes value as Integer returns Integer:
    Let expr_size be 32  Note: Ensure sufficient space: type(8) + value(8) + padding
    Let expr be memory_allocate(expr_size)
    memory_set_int32(expr, 0, EXPR_INTEGER)
    memory_set_integer(expr, 8, value)
    Return expr
End Process

Note: Create variable expression
Process called "expression_create_variable" takes name as Integer returns Integer:
    Let expr_size be 32  Note: Ensure sufficient space: type(8) + name_pointer(8) + padding
    Let expr be memory_allocate(expr_size)
    memory_set_int32(expr, 0, EXPR_VARIABLE)
    Let dup_name be string_duplicate_parser(name)
    memory_set_pointer(expr, 8, dup_name)
    Return expr
End Process

Note: Create binary operation expression
Process called "expression_create_binary_op" takes left as Integer, operator as Integer, right as Integer returns Integer:
    Let expr_size be 32  Note: type plus left plus right plusoperator
    Let expr be memory_allocate(expr_size)
    memory_set_int32(expr, 0, EXPR_BINARY_OP)
    memory_set_pointer(expr, 8, left)
    memory_set_pointer(expr, 16, right)
    memory_set_integer(expr, 24, operator)
    Return expr
End Process

Note: Create comparison expression
Process called "expression_create_comparison" takes left as Integer, comparison_op as Integer, right as Integer returns Integer:
    Let expr_size be 32
    Let expr be memory_allocate(expr_size)
    memory_set_int32(expr, 0, EXPR_COMPARISON)
    memory_set_pointer(expr, 8, left)
    memory_set_pointer(expr, 16, right)
    memory_set_integer(expr, 24, comparison_op)
    Return expr
End Process

Note: Create unary operator expression (for NOT)
Process called "expression_create_unary_op" takes operator as Integer, operand as Integer returns Integer:
    Let expr_size be 32
    Let expr be memory_allocate(expr_size)
    memory_set_int32(expr, 0, 12)  Note: Use 12 for EXPR_UNARY (11 conflicts with INDIRECT_CALL)
    memory_set_integer(expr, 8, operator)
    memory_set_pointer(expr, 16, operand)
    Return expr
End Process

Note: Create function call expression
Process called "expression_create_function_call" takes function_name as Integer, arguments as Integer, argument_count as Integer returns Integer:
    Let expr_size be 32
    Let expr be memory_allocate(expr_size)
    memory_set_int32(expr, 0, EXPR_FUNCTION_CALL)
    Let dup_name be string_duplicate_parser(function_name)
    memory_set_pointer(expr, 8, dup_name)
    memory_set_pointer(expr, 16, arguments)
    memory_set_integer(expr, 24, argument_count)
    Return expr
End Process

Note: Create string literal expression (takes ownership)
Process called "expression_create_string_literal_owned" takes string_value as Integer returns Integer:
    Let expr_size be 32  Note: Match other expression types for safety
    Let expr be memory_allocate(expr_size)
    memory_set_int32(expr, 0, EXPR_STRING_LITERAL)
    memory_set_pointer(expr, 8, string_value)  Note: Takes ownership

    Return expr
End Process

Note: Helper to check if a variable name is in a list
Process called "lambda_is_var_in_list" takes var_name as Integer, var_list as Integer, var_count as Integer returns Integer:
    Let i be 0
    While i is less than var_count:
        Let offset be i multiplied by 8
        Let list_var be memory_get_pointer(var_list, offset)
        If string_equals(var_name, list_var) is equal to 1:
            Return 1  Note: Found
        End If
        Let i be i plus 1
    End While
    Return 0  Note: Not found
End Process

Note: Add a free variable to the lambda's free variable list (if not already present)
Process called "lambda_add_free_var" takes lambda_expr as Integer, var_name as Integer returns Integer:
    Let free_vars be memory_get_pointer(lambda_expr, 32)
    Let free_var_count be memory_get_int32(lambda_expr, 40)
    Let free_var_capacity be memory_get_int32(lambda_expr, 44)

    Note: Check if variable is already in the list
    Let i be 0
    While i is less than free_var_count:
        Let offset be i multiplied by 8
        Let existing_var be memory_get_pointer(free_vars, offset)
        If string_equals(var_name, existing_var) is equal to 1:
            Return 0  Note: Already exists
        End If
        Let i be i plus 1
    End While

    Note: Expand capacity if needed
    If free_var_count is greater than or equal to free_var_capacity:
        Let new_capacity be 8
        If free_var_capacity is greater than 0:
            Let new_capacity be free_var_capacity multiplied by 2
        End If
        Let new_free_vars be allocate(new_capacity multiplied by 8)

        Note: Copy existing variables
        Let j be 0
        While j is less than free_var_count:
            Let src_offset be j multiplied by 8
            Let src_var be memory_get_pointer(free_vars, src_offset)
            memory_set_pointer(new_free_vars, src_offset, src_var)
            Let j be j plus 1
        End While

        If free_vars is not equal to 0:
            deallocate(free_vars)
        End If

        Let free_vars be new_free_vars
        memory_set_pointer(lambda_expr, 32, free_vars)
        memory_set_int32(lambda_expr, 44, new_capacity)
    End If

    Note: Add the variable
    Let offset be free_var_count multiplied by 8
    Let dup_var be string_duplicate_parser(var_name)
    memory_set_pointer(free_vars, offset, dup_var)
    memory_set_int32(lambda_expr, 40, free_var_count plus 1)

    Return 0
End Process

Note: Analyze expression to find free variables (variables not in param list or local scope)
Process called "lambda_collect_free_vars" takes lambda_expr as Integer, expr as Integer, param_names as Integer, param_count as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If

    Let expr_type be memory_get_int32(expr, 0)

    Note: EXPR_VARIABLE = 1
    If expr_type is equal to 1:
        Let var_name be memory_get_pointer(expr, 8)

        Note: Check if it's a parameter (skip if it is)
        Let is_param be lambda_is_var_in_list(var_name, param_names, param_count)
        If is_param is equal to 0:
            Note: Not a parameter, so it's a free variable
            lambda_add_free_var(lambda_expr, var_name)
        End If
        Return 0
    End If

    Note: EXPR_BINARY_OP = 2
    If expr_type is equal to 2:
        Let left be memory_get_pointer(expr, 8)
        Let right be memory_get_pointer(expr, 16)
        lambda_collect_free_vars(lambda_expr, left, param_names, param_count)
        lambda_collect_free_vars(lambda_expr, right, param_names, param_count)
        Return 0
    End If

    Note: EXPR_FUNCTION_CALL = 4
    If expr_type is equal to 4:
        Let arguments be memory_get_pointer(expr, 16)
        Let arg_count be memory_get_int32(expr, 24)
        Let i be 0
        While i is less than arg_count:
            Let arg_offset be i multiplied by 8
            Let arg_expr be memory_get_pointer(arguments, arg_offset)
            lambda_collect_free_vars(lambda_expr, arg_expr, param_names, param_count)
            Let i be i plus 1
        End While
        Return 0
    End If

    Note: EXPR_UNARY = 12
    If expr_type is equal to 12:
        Let operand be memory_get_pointer(expr, 16)
        lambda_collect_free_vars(lambda_expr, operand, param_names, param_count)
        Return 0
    End If

    Note: EXPR_ARRAY_INDEX = 16
    If expr_type is equal to 16:
        Let array_expr be memory_get_pointer(expr, 8)
        Let index_expr be memory_get_pointer(expr, 16)
        lambda_collect_free_vars(lambda_expr, array_expr, param_names, param_count)
        lambda_collect_free_vars(lambda_expr, index_expr, param_names, param_count)
        Return 0
    End If

    Note: EXPR_LAMBDA_CALL = 24
    If expr_type is equal to 24:
        Let lambda_call_expr be memory_get_pointer(expr, 8)
        Let arguments be memory_get_pointer(expr, 16)
        Let arg_count be memory_get_int32(expr, 24)
        lambda_collect_free_vars(lambda_expr, lambda_call_expr, param_names, param_count)
        Let i be 0
        While i is less than arg_count:
            Let arg_offset be i multiplied by 8
            Let arg_expr be memory_get_pointer(arguments, arg_offset)
            lambda_collect_free_vars(lambda_expr, arg_expr, param_names, param_count)
            Let i be i plus 1
        End While
        Return 0
    End If

    Note: Other expression types (literals, etc.) don't have free variables
    Return 0
End Process

Note: Create lambda expression (single parameter - deprecated, use multi version)
Process called "expression_create_lambda" takes param_name as Integer, body as Integer returns Integer:
    Let expr_size be 32
    Let expr be memory_allocate(expr_size)
    memory_set_int32(expr, 0, EXPR_LAMBDA)
    Let dup_param be string_duplicate_parser(param_name)
    memory_set_pointer(expr, 8, dup_param)  Note: Parameter name at offset 8
    memory_set_pointer(expr, 16, body)      Note: Body expression at offset 16
    Return expr
End Process

Note: Create lambda expression with multiple parameters
Process called "expression_create_lambda_multi" takes param_names as Integer, param_count as Integer, body as Integer returns Integer:
    Let expr_size be 48
    Let expr be memory_allocate(expr_size)
    memory_set_int32(expr, 0, EXPR_LAMBDA)
    Note: Structure: type(int32), param_names(ptr at 8), body(ptr at 16), param_count(int32 at 24)
    Note: Extended: free_vars(ptr at 32), free_var_count(int32 at 40), free_var_capacity(int32 at 44)
    memory_set_pointer(expr, 8, param_names)   Note: Array of parameter name pointers
    memory_set_pointer(expr, 16, body)         Note: Body expression
    memory_set_int32(expr, 24, param_count)    Note: Number of parameters

    Note: Initialize free variables array (will be populated during analysis)
    memory_set_pointer(expr, 32, 0)            Note: free_vars (initially NULL)
    memory_set_int32(expr, 40, 0)              Note: free_var_count
    memory_set_int32(expr, 44, 0)              Note: free_var_capacity

    Return expr
End Process

Note: Create cast expression
Note: Cast expression: type(int32 at 0), expr(ptr at 8), target_type(ptr at 16)
Process called "expression_create_cast" takes expr as Integer, target_type as Integer returns Integer:
    Let cast_expr be allocate(24)
    memory_set_int32(cast_expr, 0, EXPR_CAST)  Note: EXPR_CAST = 25
    memory_set_pointer(cast_expr, 8, expr)
    memory_set_pointer(cast_expr, 16, target_type)
    Return cast_expr
End Process

Note: Create type node
Note: Type structure: kind(int32 at 0), refinement_constraint(ptr at 8), name(ptr at 16)
Process called "type_create" takes kind as Integer returns Integer:
    Let type_size be 24
    Let type_node be memory_allocate(type_size)
    memory_set_int32(type_node, 0, kind)
    memory_set_pointer(type_node, 8, 0)     Note: No refinement constraint by default
    memory_set_pointer(type_node, 16, 0)    Note: No name for primitive types
    Return type_node
End Process

Note: Create let statement
Process called "statement_create_let" takes var_name as Integer, expr as Integer returns Integer:
    Let stmt_size be 24
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_LET)
    Let dup_name be string_duplicate_parser(var_name)
    memory_set_pointer(stmt, 8, dup_name)   Note: variable_name at offset 8
    memory_set_pointer(stmt, 16, expr)      Note: expression at offset 16
    Return stmt
End Process

Note: Create set statement
Process called "statement_create_set" takes target as Integer, expr as Integer returns Integer:
    Let stmt_size be 24
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_SET)
    memory_set_pointer(stmt, 8, target)  Note: target at offset 8
    memory_set_pointer(stmt, 16, expr)   Note: expression at offset 16
    Return stmt
End Process

Note: Create compound assignment statement
Process called "statement_create_compound_assign" takes target as Integer, operation as Integer, expr as Integer returns Integer:
    Let stmt_size be 32
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_COMPOUND_ASSIGN)
    memory_set_pointer(stmt, 8, target)      Note: target at offset 8
    memory_set_int32(stmt, 16, operation)    Note: operation (0=add, 1=sub, 2=mul, 3=div) at offset 16
    memory_set_pointer(stmt, 24, expr)       Note: expression at offset 24
    Return stmt
End Process

Note: Create for-range statement
Process called "statement_create_for_range" takes var_name as Integer, start_expr as Integer, end_expr as Integer, step_expr as Integer, body as Integer, body_count as Integer returns Integer:
    Let stmt_size be 56
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_FOR)
    memory_set_pointer(stmt, 8, var_name)       Note: loop variable name at offset 8
    memory_set_pointer(stmt, 16, start_expr)    Note: start expression at offset 16
    memory_set_pointer(stmt, 24, end_expr)      Note: end expression at offset 24
    memory_set_pointer(stmt, 32, step_expr)     Note: step expression at offset 32 (0 if not specified)
    memory_set_pointer(stmt, 40, body)          Note: body statements at offset 40
    memory_set_integer(stmt, 48, body_count)    Note: body count at offset 48
    Return stmt
End Process

Note: Create for-each statement
Process called "statement_create_for_each" takes var_name as Integer, collection_expr as Integer, body as Integer, body_count as Integer returns Integer:
    Let stmt_size be 40
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_FOR_EACH)
    memory_set_pointer(stmt, 8, var_name)          Note: loop variable name at offset 8
    memory_set_pointer(stmt, 16, collection_expr)  Note: collection expression at offset 16
    memory_set_pointer(stmt, 24, body)             Note: body statements at offset 24
    memory_set_integer(stmt, 32, body_count)       Note: body count at offset 32
    Return stmt
End Process

Note: Create return statement
Process called "statement_create_return" takes expr as Integer returns Integer:
    Let stmt_size be 24  Note: Match other statement types that have fields at offset 16
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_RETURN)
    memory_set_pointer(stmt, 8, expr)
    Return stmt
End Process

Note: Create print statement
Process called "statement_create_print" takes expr as Integer returns Integer:
    Let stmt_size be 24  Note: Match other statement types for consistency
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_PRINT)
    memory_set_pointer(stmt, 8, expr)
    Return stmt
End Process

Note: Create expression statement
Process called "statement_create_expression" takes expr as Integer returns Integer:
    Let stmt_size be 24  Note: Match other statement types for consistency
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_EXPRESSION)
    memory_set_pointer(stmt, 8, expr)
    Return stmt
End Process

Note: Create if statement
Process called "statement_create_if" takes condition as Integer, if_body as Integer, if_body_count as Integer, else_body as Integer, else_body_count as Integer returns Integer:
    Let stmt_size be 48
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_IF)
    memory_set_pointer(stmt, 8, condition)
    memory_set_pointer(stmt, 16, if_body)
    memory_set_integer(stmt, 24, if_body_count)
    memory_set_pointer(stmt, 32, else_body)
    memory_set_integer(stmt, 40, else_body_count)
    Return stmt
End Process

Note: Create while statement
Process called "statement_create_while" takes condition as Integer, body as Integer, body_count as Integer returns Integer:
    Let stmt_size be 32
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_WHILE)
    memory_set_pointer(stmt, 8, condition)
    memory_set_pointer(stmt, 16, body)
    memory_set_integer(stmt, 24, body_count)
    Return stmt
End Process

Note: Create break statement
Process called "statement_create_break" takes dummy as Integer returns Integer:
    Let stmt_size be 8
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_BREAK)
    Return stmt
End Process

Note: Create continue statement
Process called "statement_create_continue" takes dummy as Integer returns Integer:
    Let stmt_size be 8
    Let stmt be memory_allocate(stmt_size)
    memory_set_int32(stmt, 0, STMT_CONTINUE)
    Return stmt
End Process

Note: Create function
Process called "function_create" takes name as Integer, return_type as Integer returns Integer:
    Let func_size be 48  Note: name, parameters, parameter_count, return_type, statements, statement_count
    Let func be memory_allocate(func_size)
    Let dup_name be string_duplicate_parser(name)
    memory_set_pointer(func, 0, dup_name)
    memory_set_pointer(func, 8, 0)  Note: parameters = NULL
    memory_set_int32(func, 16, 0)  Note: parameter_count = 0
    Let dup_type be string_duplicate_parser(return_type)
    memory_set_pointer(func, 24, dup_type)
    memory_set_pointer(func, 32, 0)  Note: statements = NULL
    memory_set_int32(func, 40, 0)  Note: statement_count = 0
    Return func
End Process

Note: Add parameter to function
Process called "function_add_parameter" takes func as Integer, param_name as Integer, param_type as Integer returns Integer:
    Let parameter_count be memory_get_int32(func, 16)
    Let new_count be parameter_count plus 1
    Let param_size be 16  Note: sizeof(Parameter) = name plustype
    Let new_size be new_count multiplied by param_size

    Let parameters be memory_get_pointer(func, 8)
    Let new_parameters be memory_reallocate(parameters, new_size)

    Let offset be parameter_count multiplied by param_size
    Let param_ptr be new_parameters plus offset
    Let dup_name be string_duplicate_parser(param_name)
    memory_set_pointer(param_ptr, 0, dup_name)
    Let dup_type be string_duplicate_parser(param_type)
    memory_set_pointer(param_ptr, 8, dup_type)

    memory_set_pointer(func, 8, new_parameters)
    memory_set_integer(func, 16, new_count)
    Return 0
End Process

Note: Add statement to function
Process called "function_add_statement" takes func as Integer, stmt as Integer returns Integer:

    Let statement_count be memory_get_int32(func, 40)  Note: Changed from memory_get_integer
    Let new_count be statement_count plus 1
    Let ptr_size be 8
    Let new_size be new_count multiplied by ptr_size

    Let statements be memory_get_pointer(func, 32)

    Let new_statements be memory_reallocate(statements, new_size)

    Let offset be statement_count multiplied by ptr_size
    Let stmt_ptr be new_statements plus offset
    memory_set_pointer(stmt_ptr, 0, stmt)

    memory_set_pointer(func, 32, new_statements)
    memory_set_int32(func, 40, new_count)  Note: Changed from memory_set_integer

    Return 0
End Process

Note: Create program
Process called "program_create" takes dummy as Integer returns Integer:
    Let prog_size be 64  Note: 8 fields multiplied by 8 bytes each
    Let program be memory_allocate(prog_size)
    memory_set_pointer(program, 0, 0)   Note: functions = NULL
    memory_set_int32(program, 8, 0)   Note: function_count = 0
    memory_set_int32(program, 12, 0)  Note: function_capacity = 0
    memory_set_pointer(program, 16, 0)  Note: types = NULL
    memory_set_int32(program, 24, 0)  Note: type_count = 0
    memory_set_int32(program, 28, 0)  Note: type_capacity = 0
    memory_set_pointer(program, 32, 0)  Note: imports = NULL
    memory_set_int32(program, 40, 0)  Note: import_count = 0
    memory_set_int32(program, 44, 0)  Note: import_capacity = 0
    memory_set_pointer(program, 48, 0)  Note: globals = NULL
    memory_set_int32(program, 56, 0)  Note: global_count = 0
    memory_set_int32(program, 60, 0)  Note: global_capacity = 0
    Return program
End Process

Note: Add function to program
Process called "program_add_function" takes program as Integer, func as Integer returns Integer:
    Let function_count be memory_get_int32(program, 8)
    Let function_capacity be memory_get_int32(program, 12)

    If function_count is greater than or equal to function_capacity:
        If function_capacity is equal to 0:
            Note: INCREASED initial capacity from 4 to 128 for large files
            Set function_capacity to 128
        Otherwise:
            Set function_capacity to function_capacity multiplied by 2
        End If

        Let ptr_size be 8
        Let new_size be function_capacity multiplied by ptr_size
        Let functions be memory_get_pointer(program, 0)
        Let new_functions be memory_reallocate(functions, new_size)
        memory_set_pointer(program, 0, new_functions)
        memory_set_int32(program, 12, function_capacity)
    End If

    Let functions be memory_get_pointer(program, 0)
    Let func_offset be function_count multiplied by 8
    Let func_slot be functions plus func_offset
    memory_set_pointer(func_slot, 0, func)

    Let new_count be function_count plus 1
    memory_set_int32(program, 8, new_count)
    Return 0
End Process

Note: Add global variable to program
Process called "program_add_global" takes program as Integer, global as Integer returns Integer:
    Let global_count be memory_get_int32(program, 56)
    Let global_capacity be memory_get_int32(program, 60)

    If global_count is greater than or equal to global_capacity:
        If global_capacity is equal to 0:
            Set global_capacity to 4
        Otherwise:
            Set global_capacity to global_capacity multiplied by 2
        End If

        Let ptr_size be 8
        Let new_size be global_capacity multiplied by ptr_size
        Let globals be memory_get_pointer(program, 48)
        Let new_globals be memory_reallocate(globals, new_size)
        memory_set_pointer(program, 48, new_globals)
        memory_set_int32(program, 60, global_capacity)
    End If

    Let globals be memory_get_pointer(program, 48)
    Let global_offset be global_count multiplied by 8
    Let global_slot be globals plus global_offset
    memory_set_pointer(global_slot, 0, global)

    Let new_count be global_count plus 1
    memory_set_int32(program, 56, new_count)
    Return 0
End Process

Note: Add type to program
Process called "program_add_type" takes program as Integer, type as Integer returns Integer:
    Let type_count be memory_get_int32(program, 24)
    Let type_capacity be memory_get_int32(program, 28)

    If type_count is greater than or equal to type_capacity:
        If type_capacity is equal to 0:
            Set type_capacity to 4
        Otherwise:
            Set type_capacity to type_capacity multiplied by 2
        End If

        Let ptr_size be 8
        Let new_size be type_capacity multiplied by ptr_size
        Let types be memory_get_pointer(program, 16)
        Let new_types be memory_reallocate(types, new_size)
        memory_set_pointer(program, 16, new_types)
        memory_set_int32(program, 28, type_capacity)
    End If

    Let types be memory_get_pointer(program, 16)
    Let type_offset be type_count multiplied by 8
    Let type_slot be types plus type_offset
    memory_set_pointer(type_slot, 0, type)

    Let new_count be type_count plus 1
    memory_set_int32(program, 24, new_count)
    Return 0
End Process

Note: Add import to program
Process called "program_add_import" takes program as Integer, import as Integer returns Integer:
    Let import_count be memory_get_int32(program, 40)
    Let import_capacity be memory_get_int32(program, 44)

    If import_count is greater than or equal to import_capacity:
        If import_capacity is equal to 0:
            Set import_capacity to 4
        Otherwise:
            Set import_capacity to import_capacity multiplied by 2
        End If

        Let ptr_size be 8
        Let new_size be import_capacity multiplied by ptr_size
        Let imports be memory_get_pointer(program, 32)
        Let new_imports be memory_reallocate(imports, new_size)
        memory_set_pointer(program, 32, new_imports)
        memory_set_int32(program, 44, import_capacity)
    End If

    Let imports be memory_get_pointer(program, 32)
    Let import_offset be import_count multiplied by 8
    Let import_slot be imports plus import_offset
    memory_set_pointer(import_slot, 0, import)

    Let new_count be import_count plus 1
    memory_set_int32(program, 40, new_count)
    Return 0
End Process

Note: Parse primary expression
Process called "parser_parse_primary" takes parser as Integer returns Integer:
    Note: Add null check for parser
    If parser is equal to 0:
        print_string("[PARSER ERROR] Null parser in parse_primary")
        exit_with_code(1)
    End If

    Let current_token be memory_get_pointer(parser, 8)

    Note: Add null check for current_token
    If current_token is equal to 0:
        print_string("[PARSER ERROR] Null current_token in parse_primary")
        exit_with_code(1)
    End If

    Let token_type be memory_get_integer(current_token, 0)

    Note: Handle built-in functions
    Let is_builtin be parser_is_builtin_function_token(token_type)
    If is_builtin is equal to 1:
        Let builtin_type be token_type
        Let dummy be parser_eat(parser, builtin_type)

        Let dummy2 be parser_eat(parser, 48)  Note: TOKEN_LPAREN

        Note: Parse arguments
        Let arguments be 0
        Let argument_count be 0

        Let current_token2 be memory_get_pointer(parser, 8)
        Let token_type2 be memory_get_integer(current_token2, 0)

        If token_type2 is not equal to 49:  Note: TOKEN_RPAREN
            Let capacity be 2
            Let ptr_size be 8
            Let size be capacity multiplied by ptr_size
            Set arguments to memory_allocate(size)

            Let continue_args be 1
            While continue_args is equal to 1:
                Let current_token3 be memory_get_pointer(parser, 8)
                Let token_type3 be memory_get_integer(current_token3, 0)

                If token_type3 is equal to 52:  Note: TOKEN_COMMA
                    Let dummy3 be parser_eat(parser, 52)  Note: TOKEN_COMMA
                End If

                Let arg be parser_parse_additive(parser)

                If argument_count is greater than or equal to capacity:
                    Set capacity to capacity multiplied by 2
                    Let new_size be capacity multiplied by ptr_size
                    Set arguments to memory_reallocate(arguments, new_size)
                End If

                Let offset be argument_count multiplied by ptr_size
                Let arg_ptr be arguments plus offset
                memory_set_pointer(arg_ptr, 0, arg)
                Set argument_count to argument_count plus 1

                Let current_token4 be memory_get_pointer(parser, 8)
                Let token_type4 be memory_get_integer(current_token4, 0)
                If token_type4 is not equal to 52:  Note: TOKEN_COMMA
                    Set continue_args to 0
                End If
            End While
        End If

        Let dummy4 be parser_eat(parser, 49)  Note: TOKEN_RPAREN

        Note: Create builtin call expression
        Let expr_size be 32
        Let expr be memory_allocate(expr_size)
        memory_set_int32(expr, 0, 8)  Note: EXPR_BUILTIN_CALL
        memory_set_integer(expr, 8, builtin_type)
        memory_set_pointer(expr, 16, arguments)
        memory_set_integer(expr, 24, argument_count)
        Return expr
    End If

    Note: Handle integer literal
    If token_type is equal to 11:
        Let value_str be memory_get_pointer(current_token, 8)
        Let value be string_to_integer(value_str)
        Let dummy5 be parser_eat(parser, 11)
        Let expr be expression_create_integer(value)
        Return expr
    End If

    Note: Handle string literal
    If token_type is equal to 10:
        Let value_str be memory_get_pointer(current_token, 8)
        Let string_value be string_duplicate_parser(value_str)


        Note: Check if this string literal is a known type name
        Let is_type be 0
        Let prog be memory_get_pointer(parser, PARSER_CURRENT_PROGRAM_OFFSET)  Note: parser->current_program
        If prog is not equal to 0:
            Let type_count be memory_get_int32(prog, PROGRAM_TYPE_COUNT)
            Let types be memory_get_pointer(prog, PROGRAM_TYPES)
            Let i be 0
            While i is less than type_count:
                Let ptr_size be 8
                Let offset be i multiplied by ptr_size
                Let type_ptr be types plus offset
                Let type_def be memory_get_pointer(type_ptr, 0)
                Let type_name be memory_get_pointer(type_def, 0)
                Let result be string_equals(type_name, string_value)
                If result is equal to 1:
                    Set is_type to 1
                    Set i to type_count  Note: Break loop
                Otherwise:
                    Set i to i plus 1
                End If
            End While
        End If

        Let dummy6 be parser_eat(parser, 10)

        If is_type is equal to 1:
            Note: This is a type name, create a type expression
            Let expr_size be 32  Note: Match other expression types for safety
            Let expr be memory_allocate(expr_size)
            memory_set_int32(expr, 0, EXPR_TYPE_NAME)
            memory_set_pointer(expr, 8, string_value)
            Return expr
        Otherwise:
            Let expr be expression_create_string_literal_owned(string_value)
            Return expr
        End If
    End If

    Note: Handle function pointer ($identifier)
    If token_type is equal to 157:  Note: TOKEN_DOLLAR
        Let dummy_dollar be parser_eat(parser, 157)

        Note: Expect identifier after $
        Let func_token be memory_get_pointer(parser, 8)
        Let func_token_type be memory_get_integer(func_token, 0)
        If func_token_type is not equal to 53:  Note: TOKEN_IDENTIFIER
            print_string("[PARSER ERROR] Expected function name after $ at line ")
            Let err_line be memory_get_int32(func_token, 16)
            print_integer(err_line)
            print_newline()
            exit_with_code(1)
        End If

        Let func_name_str be memory_get_pointer(func_token, 8)
        Let func_name be string_duplicate_parser(func_name_str)
        Let dummy_ident be parser_eat(parser, 53)

        Note: Create EXPR_FUNCTION_POINTER
        Let expr_size be 32
        Let expr be memory_allocate(expr_size)
        memory_set_int32(expr, 0, 10)  Note: EXPR_FUNCTION_POINTER
        memory_set_pointer(expr, 8, func_name)
        Return expr
    End If

    Note: Handle parentheses for expression grouping
    If token_type is equal to 48:  Note: TOKEN_LPAREN
        parser_eat(parser, 48)  Note: Eat '('
        Let grouped_expr be parser_parse_expression(parser)
        parser_eat(parser, 49)  Note: Eat ')'
        Return grouped_expr
    End If

    Note: Handle unary minus for negative numbers
    If token_type is equal to 17:  Note: TOKEN_MINUS
        parser_eat(parser, 17)  Note: Eat '-'
        Let operand be parser_parse_primary(parser)
        Note: Create binary expression: 0 - operand
        Let zero_expr be expression_create_integer(0)
        Let neg_expr be expression_create_binary_op(zero_expr, 17, operand)  Note: TOKEN_MINUS (fixed parameter order)
        Return neg_expr
    End If

    Note: Handle field access: "the FIELD of OBJECT"
    If token_type is equal to 158:  Note: TOKEN_THE
        parser_eat(parser, 158)  Note: Eat 'the'

        Note: Next token should be field name
        Set current_token to memory_get_pointer(parser, 8)
        Set token_type to memory_get_int32(current_token, 0)
        If token_type is not equal to 53:  Note: TOKEN_IDENTIFIER
            print_string("[PARSER ERROR] Expected field name after 'the' at line ")
            Let line be memory_get_int32(current_token, 16)
            print_integer(line)
            print_newline()
            exit_with_code(1)
        End If

        Let token_value be memory_get_pointer(current_token, 8)
        Let field_name be string_duplicate_parser(token_value)
        parser_eat(parser, 53)  Note: Eat field name

        Note: Expect 'of' keyword
        Set current_token to memory_get_pointer(parser, 8)
        Set token_type to memory_get_int32(current_token, 0)
        If token_type is not equal to 125:  Note: TOKEN_OF
            print_string("[PARSER ERROR] Expected 'of' after field name at line ")
            Let line be memory_get_int32(current_token, 16)
            print_integer(line)
            print_newline()
            exit_with_code(1)
        End If
        parser_eat(parser, 125)  Note: Eat 'of'

        Note: Parse object expression
        Let object be parser_parse_primary(parser)

        Note: Create field access expression
        Let field_access be memory_allocate(32)  Note: sizeof(Expression)
        memory_set_int32(field_access, 0, 6)  Note: EXPR_FIELD_ACCESS
        memory_set_pointer(field_access, 8, object)
        memory_set_pointer(field_access, 16, field_name)
        Return field_access
    End If

    Note: Handle canonical collection literals: "a list containing..." or "an Array of..."
    Note: This must come BEFORE the general identifier handler
    Note: Check for pattern: identifier("a" or "an") followed by collection type
    If token_type is equal to 53:  Note: TOKEN_IDENTIFIER
        Let token_value be memory_get_pointer(current_token, 8)
        Let is_a be string_equals(token_value, "a")
        Let is_an be string_equals(token_value, "an")

        If is_a is equal to 1:
            Note: Peek ahead: get lexer position to check next token
            Let lexer_ptr be memory_get_pointer(parser, 0)  Note: parser->lexer
            Let lexer_position be memory_get_integer(lexer_ptr, 0)  Note: Save current position

            Note: Temporarily advance to peek at next token
            parser_eat(parser, 53)  Note: eat "a"
            Set current_token to memory_get_pointer(parser, 8)
            Set token_type to memory_get_integer(current_token, 0)

            Note: Check if next token is identifier "list"
            If token_type is equal to 53:  Note: TOKEN_IDENTIFIER
                Let next_value be memory_get_pointer(current_token, 8)
                Let is_list be string_equals(next_value, "list")

                If is_list is equal to 1:
                    Note: Confirmed "a list" pattern - continue parsing
                    parser_eat(parser, 53)  Note: eat "list"

                Note: Expect "containing"
                Set current_token to memory_get_pointer(parser, 8)
                Set token_type to memory_get_int32(current_token, 0)
                If token_type is not equal to 156:  Note: TOKEN_CONTAINING
                    print_string("[PARSER ERROR] Expected 'containing' after 'a list' at line ")
                    Let line be memory_get_int32(current_token, 16)
                    print_integer(line)
                    print_newline()
                    exit(1)
                End If
                parser_eat(parser, 156)  Note: containing

                Note: Parse list elements
                Let elements be 0
                Let element_count be 0
                Let capacity be 4
                Let ptr_size be 8
                Let size be capacity multiplied by ptr_size
                Set elements to memory_allocate(size)

                Note: Parse first element
                Let elem be parser_parse_expression(parser)
                memory_set_pointer(elements, 0, elem)
                Set element_count to 1

                Note: Parse remaining elements (comma or "and" separated)
                Let continue_parsing be 1
                While continue_parsing is equal to 1:
                    Set current_token to memory_get_pointer(parser, 8)
                    Set token_type to memory_get_integer(current_token, 0)

                    If token_type is equal to 52:  Note: TOKEN_COMMA
                        parser_eat(parser, 52)  Note: ,

                        Note: Check for optional "and" after comma
                        Set current_token to memory_get_pointer(parser, 8)
                        Set token_type to memory_get_integer(current_token, 0)
                        If token_type is equal to 30:  Note: TOKEN_AND
                            parser_eat(parser, 30)  Note: and
                        End If

                        Note: Parse next element
                        Let elem2 be parser_parse_expression(parser)

                        Note: Grow array if needed
                        If element_count is greater than or equal to capacity:
                            Set capacity to capacity multiplied by 2
                            Let new_size be capacity multiplied by ptr_size
                            Set elements to memory_reallocate(elements, new_size)
                        End If

                        Let offset be element_count multiplied by ptr_size
                        Let elem_ptr be elements plus offset
                        memory_set_pointer(elem_ptr, 0, elem2)
                        Set element_count to element_count plus 1
                    Otherwise:
                        Set continue_parsing to 0
                    End If
                End While

                Note: Create EXPR_LIST_LITERAL expression
                Let list_expr be memory_allocate(32)
                memory_set_int32(list_expr, 0, 17)  Note: EXPR_LIST_LITERAL
                memory_set_pointer(list_expr, 8, elements)
                memory_set_int32(list_expr, 16, element_count)
                Return list_expr
                Otherwise:
                    Note: Not "list" - check if this is "set"
                    Let is_set be string_equals(next_value, "set")

                    If is_set is equal to 1:
                        Note: Confirmed "a set" pattern - continue parsing
                        parser_eat(parser, 53)  Note: eat "set"

                        Note: Expect "containing"
                        Set current_token to memory_get_pointer(parser, 8)
                        Set token_type to memory_get_int32(current_token, 0)
                        If token_type is not equal to 156:  Note: TOKEN_CONTAINING
                            print_string("[PARSER ERROR] Expected 'containing' after 'a set' at line ")
                            Let line be memory_get_int32(current_token, 16)
                            print_integer(line)
                            print_newline()
                            exit(1)
                        End If
                        parser_eat(parser, 156)  Note: containing

                        Note: Parse set elements
                        Let elements be 0
                        Let element_count be 0
                        Let capacity be 4
                        Let ptr_size be 8
                        Let size be capacity multiplied by ptr_size
                        Set elements to memory_allocate(size)

                        Note: Parse first element
                        Let elem be parser_parse_expression(parser)
                        memory_set_pointer(elements, 0, elem)
                        Set element_count to 1

                        Note: Parse remaining elements (comma or "and" separated)
                        Let continue_parsing be 1
                        While continue_parsing is equal to 1:
                            Set current_token to memory_get_pointer(parser, 8)
                            Set token_type to memory_get_integer(current_token, 0)

                            If token_type is equal to 52:  Note: TOKEN_COMMA
                                parser_eat(parser, 52)  Note: ,

                                Note: Check for optional "and" after comma
                                Set current_token to memory_get_pointer(parser, 8)
                                Set token_type to memory_get_integer(current_token, 0)
                                If token_type is equal to 30:  Note: TOKEN_AND
                                    parser_eat(parser, 30)  Note: and
                                End If

                                Note: Parse next element
                                Let elem2 be parser_parse_expression(parser)

                                Note: Grow array if needed
                                If element_count is greater than or equal to capacity:
                                    Set capacity to capacity multiplied by 2
                                    Let new_size be capacity multiplied by ptr_size
                                    Set elements to memory_reallocate(elements, new_size)
                                End If

                                Let offset be element_count multiplied by ptr_size
                                Let elem_ptr be elements plus offset
                                memory_set_pointer(elem_ptr, 0, elem2)
                                Set element_count to element_count plus 1
                            Otherwise:
                                Set continue_parsing to 0
                            End If
                        End While

                        Note: Create EXPR_SET_LITERAL expression
                        Let set_expr be memory_allocate(32)
                        memory_set_int32(set_expr, 0, 21)  Note: EXPR_SET_LITERAL
                        memory_set_pointer(set_expr, 8, elements)
                        memory_set_int32(set_expr, 16, element_count)
                        Return set_expr
                    Otherwise:
                        Note: Not "list" or "set" - check if this is struct construction: "a TypeName with..."
                        Note: next_value already contains the type name candidate
                Let prog be memory_get_pointer(parser, 16)  Note: parser->current_program (PARSER_CURRENT_PROGRAM_OFFSET)
                Let is_struct_type be 0

                    If prog is not equal to 0:
                        Let type_count be memory_get_int32(prog, 24)  Note: program->type_count
                        Let types be memory_get_pointer(prog, 16)     Note: program->types

                        Let type_check_i be 0
                        While type_check_i is less than type_count:
                            Let type_offset be type_check_i multiplied by 8
                            Let type_ptr be memory_get_pointer(types, type_offset)
                            Let type_name be memory_get_pointer(type_ptr, 0)
                            If string_equals(type_name, next_value) is equal to 1:
                                Let is_struct_type be 1
                                Let type_check_i be type_count  Note: break
                            End If
                            Let type_check_i be type_check_i plus 1
                        End While
                    End If

                    If is_struct_type is equal to 1:
                        Note: This is struct construction: "a TypeName with field value and field value"
                        Let struct_type_name be string_duplicate_parser(next_value)
                        parser_eat(parser, 53)  Note: eat type name

                        Note: Expect "with"
                        Set current_token to memory_get_pointer(parser, 8)
                        Set token_type to memory_get_int32(current_token, 0)
                        If token_type is not equal to 114:  Note: TOKEN_WITH
                            print_string("[PARSER ERROR] Expected 'with' after struct type name at line ")
                            Let line be memory_get_int32(current_token, 16)
                            print_integer(line)
                            print_newline()
                            exit_with_code(1)
                        End If
                        parser_eat(parser, 114)  Note: eat "with"

                        Note: Parse field assignments: field value and field value...
                        Let field_names be 0
                        Let field_values be 0
                        Let field_count be 0
                        Let field_capacity be 4
                        Let ptr_size be 8
                        Let field_array_size be field_capacity multiplied by ptr_size
                        Set field_names to memory_allocate(field_array_size)
                        Set field_values to memory_allocate(field_array_size)

                        Let continue_fields be 1
                        While continue_fields is equal to 1:
                            Note: Parse field name (identifier)
                            Set current_token to memory_get_pointer(parser, 8)
                            Set token_type to memory_get_int32(current_token, 0)
                            If token_type is not equal to 53:  Note: TOKEN_IDENTIFIER
                                print_string("[PARSER ERROR] Expected field name at line ")
                                Let line be memory_get_int32(current_token, 16)
                                print_integer(line)
                                print_newline()
                                exit_with_code(1)
                            End If

                            Let field_name_token be memory_get_pointer(current_token, 8)
                            Let field_name be string_duplicate_parser(field_name_token)
                            parser_eat(parser, 53)  Note: eat field name

                            Note: Parse field value (expression)
                            Let field_value be parser_parse_additive(parser)

                            Note: Grow arrays if needed
                            If field_count is greater than or equal to field_capacity:
                                Set field_capacity to field_capacity multiplied by 2
                                Let new_field_array_size be field_capacity multiplied by ptr_size
                                Set field_names to memory_reallocate(field_names, new_field_array_size)
                                Set field_values to memory_reallocate(field_values, new_field_array_size)
                            End If

                            Note: Store field name and value
                            Let field_offset be field_count multiplied by ptr_size
                            Let name_ptr be field_names plus field_offset
                            Let value_ptr be field_values plus field_offset
                            memory_set_pointer(name_ptr, 0, field_name)
                            memory_set_pointer(value_ptr, 0, field_value)
                            Set field_count to field_count plus 1

                            Note: Check for "and" to continue or end
                            Set current_token to memory_get_pointer(parser, 8)
                            Set token_type to memory_get_int32(current_token, 0)
                            If token_type is equal to 30:  Note: TOKEN_AND
                                parser_eat(parser, 30)  Note: eat "and"
                            Otherwise:
                                Set continue_fields to 0
                            End If
                        End While

                        Note: Create EXPR_STRUCT_CONSTRUCTION expression
                        Note: Structure: type(int32), type_name(ptr at 8), field_names(ptr at 16), field_values(ptr at 24), field_count(int32 at 32)
                        Let struct_expr be memory_allocate(40)
                        memory_set_int32(struct_expr, 0, 20)  Note: EXPR_STRUCT_CONSTRUCTION
                        memory_set_pointer(struct_expr, 8, struct_type_name)
                        memory_set_pointer(struct_expr, 16, field_names)
                        memory_set_pointer(struct_expr, 24, field_values)
                        memory_set_int32(struct_expr, 32, field_count)
                        Return struct_expr
                    Otherwise:
                        Note: Not "a list", "a set", or struct - "a" is just a variable, already consumed
                        Note: Create string "a" for the variable name
                        Let var_name_a be memory_allocate(2)
                        memory_set_byte(var_name_a, 0, 97)  Note: 'a'
                        memory_set_byte(var_name_a, 1, 0)   Note: null terminator
                        Let var_expr be expression_create_variable(var_name_a)
                        Return var_expr
                    End If
                    End If
                End If
            Otherwise:
                Note: Next token after "a" is not an identifier
                Note: "a" is just a variable, already consumed
                Note: Create string "a" for the variable name
                Let var_name_a2 be memory_allocate(2)
                memory_set_byte(var_name_a2, 0, 97)  Note: 'a'
                memory_set_byte(var_name_a2, 1, 0)   Note: null terminator
                Let var_expr2 be expression_create_variable(var_name_a2)
                Return var_expr2
            End If
        End If

        Note: Check for "an Array" pattern
        If is_an is equal to 1:
            Note: Eat "an"
            parser_eat(parser, 53)
            Set current_token to memory_get_pointer(parser, 8)
            Set token_type to memory_get_integer(current_token, 0)

            If token_type is equal to 53:  Note: Next token might be "Array"
                Let next_value be memory_get_pointer(current_token, 8)
                Let is_array be string_equals(next_value, "Array")

                If is_array is equal to 1:
                    Note: Confirmed "an Array" pattern
                    parser_eat(parser, 53)  Note: eat "Array"

                    Note: Expect "of"
                    Set current_token to memory_get_pointer(parser, 8)
                    Set token_type to memory_get_integer(current_token, 0)
                    If token_type is not equal to 125:  Note: TOKEN_OF
                        print_string("[PARSER ERROR] Expected 'of' after 'an Array' at line ")
                        Let line be memory_get_int32(current_token, 16)
                        print_integer(line)
                        print_newline()
                        exit(1)
                    End If
                    parser_eat(parser, 125)  Note: of

                    Note: Parse array size (must be integer)
                    Set current_token to memory_get_pointer(parser, 8)
                    Set token_type to memory_get_integer(current_token, 0)
                    If token_type is not equal to 11:  Note: TOKEN_INTEGER
                        print_string("[PARSER ERROR] Expected integer size after 'an Array of' at line ")
                        Let line be memory_get_int32(current_token, 16)
                        print_integer(line)
                        print_newline()
                        exit(1)
                    End If
                    Let size_str be memory_get_pointer(current_token, 8)
                    Let array_size be string_to_integer(size_str)
                    parser_eat(parser, 11)  Note: eat size

                    Note: Parse element type (identifier)
                    Set current_token to memory_get_pointer(parser, 8)
                    Set token_type to memory_get_integer(current_token, 0)
                    If token_type is not equal to 53:  Note: TOKEN_IDENTIFIER
                        print_string("[PARSER ERROR] Expected type name after array size at line ")
                        Let line be memory_get_int32(current_token, 16)
                        print_integer(line)
                        print_newline()
                        exit(1)
                    End If
                    Let type_name_str be memory_get_pointer(current_token, 8)
                    Let elem_type be string_duplicate_parser(type_name_str)
                    parser_eat(parser, 53)  Note: eat type name

                    Note: Check for optional "containing"
                    Set current_token to memory_get_pointer(parser, 8)
                    Set token_type to memory_get_integer(current_token, 0)

                    If token_type is equal to 156:  Note: TOKEN_CONTAINING
                        parser_eat(parser, 156)  Note: containing

                        Note: Parse array elements (same as list)
                        Let elements be 0
                        Let element_count be 0
                        Let capacity be 4
                        Let ptr_size be 8
                        Let size be capacity multiplied by ptr_size
                        Set elements to memory_allocate(size)

                        Note: Parse first element
                        Let elem be parser_parse_expression(parser)
                        memory_set_pointer(elements, 0, elem)
                        Set element_count to 1

                        Note: Parse remaining elements
                        Let continue_parsing be 1
                        While continue_parsing is equal to 1:
                            Set current_token to memory_get_pointer(parser, 8)
                            Set token_type to memory_get_integer(current_token, 0)

                            If token_type is equal to 52:  Note: TOKEN_COMMA
                                parser_eat(parser, 52)

                                Note: Check for optional "and"
                                Set current_token to memory_get_pointer(parser, 8)
                                Set token_type to memory_get_integer(current_token, 0)
                                If token_type is equal to 30:  Note: TOKEN_AND
                                    parser_eat(parser, 30)
                                End If

                                Note: Parse next element
                                Let elem2 be parser_parse_expression(parser)

                                Note: Grow array if needed
                                If element_count is greater than or equal to capacity:
                                    Set capacity to capacity multiplied by 2
                                    Let new_size be capacity multiplied by ptr_size
                                    Set elements to memory_reallocate(elements, new_size)
                                End If

                                Let offset be element_count multiplied by ptr_size
                                Let elem_ptr be elements plus offset
                                memory_set_pointer(elem_ptr, 0, elem2)
                                Set element_count to element_count plus 1
                            Otherwise:
                                Set continue_parsing to 0
                            End If
                        End While

                        Note: Verify element count matches declared size
                        If element_count is not equal to array_size:
                            print_string("[PARSER ERROR] Array size mismatch: declared ")
                            print_integer(array_size)
                            print_string(" but got ")
                            print_integer(element_count)
                            print_string(" elements")
                            print_newline()
                            exit(1)
                        End If

                        Note: Create EXPR_ARRAY_LITERAL with elements
                        Let array_expr be memory_allocate(32)
                        memory_set_integer(array_expr, 0, 18)  Note: EXPR_ARRAY_LITERAL
                        memory_set_pointer(array_expr, 8, elements)
                        memory_set_integer(array_expr, 16, array_size)
                        memory_set_pointer(array_expr, 24, elem_type)
                        Return array_expr
                    Otherwise:
                        Note: No "containing" - just type declaration
                        Note: Create EXPR_ARRAY_TYPE (uninitialized array)
                        Let array_type be memory_allocate(32)
                        memory_set_integer(array_type, 0, 19)  Note: EXPR_ARRAY_TYPE
                        memory_set_integer(array_type, 8, array_size)
                        memory_set_pointer(array_type, 16, elem_type)
                        Return array_type
                    End If
                Otherwise:
                    Note: Not "an Array" - "an" is just a variable
                    Let var_name_an be string_duplicate_parser(token_value)
                    Let var_expr_an be expression_create_variable(var_name_an)
                    Return var_expr_an
                End If
            Otherwise:
                Note: Next token after "an" is not an identifier
                Let var_name_an2 be string_duplicate_parser(token_value)
                Let var_expr_an2 be expression_create_variable(var_name_an2)
                Return var_expr_an2
            End If
        End If
    End If

    Note: Handle identifier (including context-sensitive keywords and "list containing")
    Let can_be_id be token_can_be_identifier(token_type)
    If can_be_id is equal to 1:
        Let value_str be memory_get_pointer(current_token, 8)
        Let name be string_duplicate_parser(value_str)

        Note: Check for "list containing" syntax
        Let is_list_literal be string_equals(name, "list")
        If is_list_literal is equal to 1:
            Note: Peek at next token to see if it's "containing"
            parser_eat(parser, token_type)  Note: eat "list"
            Set current_token to memory_get_pointer(parser, 8)
            Let next_token_type be memory_get_int32(current_token, 0)

            If next_token_type is equal to 156:  Note: TOKEN_CONTAINING
                Note: This is "list containing" syntax
                parser_eat(parser, 156)  Note: eat "containing"

                Note: Parse list elements
                Let elements be 0
                Let element_count be 0
                Let capacity be 4
                Let ptr_size be 8
                Let size be capacity multiplied by ptr_size
                Set elements to memory_allocate(size)

                Note: Parse first element
                Let elem be parser_parse_expression(parser)
                memory_set_pointer(elements, 0, elem)
                Set element_count to 1

                Note: Parse remaining elements (comma or "and" separated)
                Let continue_parsing be 1
                While continue_parsing is equal to 1:
                    Set current_token to memory_get_pointer(parser, 8)
                    Set token_type to memory_get_integer(current_token, 0)

                    If token_type is equal to 52:  Note: TOKEN_COMMA
                        parser_eat(parser, 52)  Note: ,

                        Note: Check for optional "and" after comma
                        Set current_token to memory_get_pointer(parser, 8)
                        Set token_type to memory_get_integer(current_token, 0)
                        If token_type is equal to 30:  Note: TOKEN_AND
                            parser_eat(parser, 30)  Note: and
                        End If

                        Note: Parse next element
                        Let elem2 be parser_parse_expression(parser)

                        Note: Grow array if needed
                        If element_count is greater than or equal to capacity:
                            Set capacity to capacity multiplied by 2
                            Let new_size be capacity multiplied by ptr_size
                            Set elements to memory_reallocate(elements, new_size)
                        End If

                        Let offset be element_count multiplied by ptr_size
                        Let elem_ptr be elements plus offset
                        memory_set_pointer(elem_ptr, 0, elem2)
                        Set element_count to element_count plus 1
                    Otherwise:
                        Set continue_parsing to 0
                    End If
                End While

                Note: Create EXPR_LIST_LITERAL expression
                Let list_expr be memory_allocate(32)
                memory_set_int32(list_expr, 0, 17)  Note: EXPR_LIST_LITERAL
                memory_set_pointer(list_expr, 8, elements)
                memory_set_int32(list_expr, 16, element_count)
                deallocate(name)
                Return list_expr
            Otherwise:
                Note: "list" is just a variable name, not followed by "containing"
                Let var_expr be expression_create_variable(name)
                Return var_expr
            End If
        End If

        Note: Check for "set containing" syntax
        Let is_set_literal be string_equals(name, "set")
        If is_set_literal is equal to 1:
            Note: Peek at next token to see if it's "containing"
            parser_eat(parser, token_type)  Note: eat "set"
            Set current_token to memory_get_pointer(parser, 8)
            Let next_token_type be memory_get_int32(current_token, 0)

            If next_token_type is equal to 156:  Note: TOKEN_CONTAINING
                Note: This is "set containing" syntax
                parser_eat(parser, 156)  Note: eat "containing"

                Note: Parse set elements
                Let elements be 0
                Let element_count be 0
                Let capacity be 4
                Let ptr_size be 8
                Let size be capacity multiplied by ptr_size
                Set elements to memory_allocate(size)

                Note: Parse first element
                Let elem be parser_parse_expression(parser)
                memory_set_pointer(elements, 0, elem)
                Set element_count to 1

                Note: Parse remaining elements (comma or "and" separated)
                Let continue_parsing be 1
                While continue_parsing is equal to 1:
                    Set current_token to memory_get_pointer(parser, 8)
                    Set token_type to memory_get_integer(current_token, 0)

                    If token_type is equal to 52:  Note: TOKEN_COMMA
                        parser_eat(parser, 52)  Note: ,

                        Note: Check for optional "and" after comma
                        Set current_token to memory_get_pointer(parser, 8)
                        Set token_type to memory_get_integer(current_token, 0)
                        If token_type is equal to 30:  Note: TOKEN_AND
                            parser_eat(parser, 30)  Note: and
                        End If

                        Note: Parse next element
                        Let elem2 be parser_parse_expression(parser)

                        Note: Grow array if needed
                        If element_count is greater than or equal to capacity:
                            Set capacity to capacity multiplied by 2
                            Let new_size be capacity multiplied by ptr_size
                            Set elements to memory_reallocate(elements, new_size)
                        End If

                        Let offset be element_count multiplied by ptr_size
                        Let elem_ptr be elements plus offset
                        memory_set_pointer(elem_ptr, 0, elem2)
                        Set element_count to element_count plus 1
                    Otherwise:
                        Set continue_parsing to 0
                    End If
                End While

                Note: Create EXPR_SET_LITERAL expression
                Let set_expr be memory_allocate(32)
                memory_set_int32(set_expr, 0, 21)  Note: EXPR_SET_LITERAL
                memory_set_pointer(set_expr, 8, elements)
                memory_set_int32(set_expr, 16, element_count)
                deallocate(name)
                Return set_expr
            Otherwise:
                Note: "set" is just a variable name, not followed by "containing"
                Let var_expr be expression_create_variable(name)
                Return var_expr
            End If
        End If

        Note: Check for "dictionary with:" syntax
        Let is_dict_literal be string_equals(name, "dictionary")
        If is_dict_literal is equal to 1:
            Note: Peek at next token to see if it's "with"
            parser_eat(parser, token_type)  Note: eat "dictionary"
            Set current_token to memory_get_pointer(parser, 8)
            Let next_token_type be memory_get_int32(current_token, 0)

            If next_token_type is equal to 114:  Note: TOKEN_WITH
                Note: This is "dictionary with:" syntax
                parser_eat(parser, 114)  Note: eat "with"

                Note: Expect colon after "with"
                Set current_token to memory_get_pointer(parser, 8)
                Set token_type to memory_get_int32(current_token, 0)
                If token_type is not equal to 9:  Note: TOKEN_COLON
                    print_string("[PARSER ERROR] Expected ':' after 'dictionary with' at line ")
                    Let line be memory_get_int32(current_token, 16)
                    print_integer(line)
                    print_newline()
                    exit(1)
                End If
                parser_eat(parser, 9)  Note: eat ':'

                Note: Parse key-value pairs
                Let keys be 0
                Let values be 0
                Let pair_count be 0
                Let capacity be 4
                Let ptr_size be 8
                Let size be capacity multiplied by ptr_size
                Set keys to memory_allocate(size)
                Set values to memory_allocate(size)

                Note: Parse first key-value pair
                Let key_expr be parser_parse_additive(parser)

                Note: Expect "as"
                Set current_token to memory_get_pointer(parser, 8)
                Set token_type to memory_get_int32(current_token, 0)
                If token_type is not equal to 34:  Note: TOKEN_AS
                    print_string("[PARSER ERROR] Expected 'as' in dictionary literal at line ")
                    Let line be memory_get_int32(current_token, 16)
                    print_integer(line)
                    print_newline()
                    exit(1)
                End If
                parser_eat(parser, 34)  Note: eat "as"

                Let value_expr be parser_parse_additive(parser)

                memory_set_pointer(keys, 0, key_expr)
                memory_set_pointer(values, 0, value_expr)
                Set pair_count to 1

                Note: Parse remaining key-value pairs (separated by "and")
                Let continue_parsing be 1
                While continue_parsing is equal to 1:
                    Set current_token to memory_get_pointer(parser, 8)
                    Set token_type to memory_get_integer(current_token, 0)

                    If token_type is equal to 30:  Note: TOKEN_AND
                        parser_eat(parser, 30)  Note: and

                        Note: Parse next key
                        Let key_expr2 be parser_parse_additive(parser)

                        Note: Expect "as"
                        Set current_token to memory_get_pointer(parser, 8)
                        Set token_type to memory_get_int32(current_token, 0)
                        If token_type is not equal to 34:  Note: TOKEN_AS
                            print_string("[PARSER ERROR] Expected 'as' in dictionary literal at line ")
                            Let line be memory_get_int32(current_token, 16)
                            print_integer(line)
                            print_newline()
                            exit(1)
                        End If
                        parser_eat(parser, 34)  Note: eat "as"

                        Note: Parse next value
                        Let value_expr2 be parser_parse_additive(parser)

                        Note: Grow arrays if needed
                        If pair_count is greater than or equal to capacity:
                            Set capacity to capacity multiplied by 2
                            Let new_size be capacity multiplied by ptr_size
                            Set keys to memory_reallocate(keys, new_size)
                            Set values to memory_reallocate(values, new_size)
                        End If

                        Let offset be pair_count multiplied by ptr_size
                        Let key_ptr be keys plus offset
                        Let value_ptr be values plus offset
                        memory_set_pointer(key_ptr, 0, key_expr2)
                        memory_set_pointer(value_ptr, 0, value_expr2)
                        Set pair_count to pair_count plus 1
                    Otherwise:
                        Set continue_parsing to 0
                    End If
                End While

                Note: Create EXPR_DICT_LITERAL expression
                Note: Structure: type(int32), keys(ptr at 8), values(ptr at 16), pair_count(int32 at 24)
                Let dict_expr be memory_allocate(32)
                memory_set_int32(dict_expr, 0, 22)  Note: EXPR_DICT_LITERAL
                memory_set_pointer(dict_expr, 8, keys)
                memory_set_pointer(dict_expr, 16, values)
                memory_set_int32(dict_expr, 24, pair_count)
                deallocate(name)
                Return dict_expr
            Otherwise:
                Note: "dictionary" is just a variable name, not followed by "with"
                Let var_expr be expression_create_variable(name)
                Return var_expr
            End If
        End If

        Note: Check if this identifier is a known type name
        Let is_type be 0
        Let prog be memory_get_pointer(parser, PARSER_CURRENT_PROGRAM_OFFSET)
        If prog is equal to 0:
        End If
        If prog is not equal to 0:
            Let type_count be memory_get_int32(prog, PROGRAM_TYPE_COUNT)
            If type_count is equal to 0:
            Otherwise:
            End If
            Let types be memory_get_pointer(prog, PROGRAM_TYPES)
            If types is equal to 0:
            Otherwise:
            End If
            Let i be 0
            Let continue_type_search be 1
            While continue_type_search is equal to 1:
                Let search_done be 0
                If i is greater than or equal to type_count:
                    Let search_done be 1
                End If
                If search_done is equal to 1:
                    Let continue_type_search be 0
                End If
                If search_done is equal to 0:
                    Let ptr_size be 8
                    Let offset be i multiplied by ptr_size
                    Let type_ptr be types plus offset
                    Let type_def be memory_get_pointer(type_ptr, 0)
                    Let type_name be memory_get_pointer(type_def, 0)
                    Let result be string_equals(type_name, name)
                    If result is equal to 1:
                        Set is_type to 1
                        Let continue_type_search be 0  Note: Break loop
                    End If
                    Set i to i plus 1
                End If
            End While
        End If

        Note: Check if identifier is a variant name (for implicit construction)
        Let is_variant be 0
        Let variant_type_name be 0
        If is_type is equal to 0:
            If prog is not equal to 0:
                Let type_count be memory_get_int32(prog, PROGRAM_TYPE_COUNT)
                Let types be memory_get_pointer(prog, PROGRAM_TYPES)
                Let vi be 0
                While vi is less than type_count:
                    Let type_offset be vi multiplied by 8
                    Let type_ptr be types plus type_offset
                    Let type_def be memory_get_pointer(type_ptr, 0)
                    Let type_kind be memory_get_int32(type_def, TYPEDEFINITION_KIND_OFFSET)

                    Note: Check only variant types (TYPE_KIND_VARIANT = 1)
                    If type_kind is equal to TYPE_KIND_VARIANT:
                        Let variant_count be memory_get_int32(type_def, TYPEDEFINITION_DATA_VARIANT_VARIANT_COUNT_OFFSET)
                        Let variants be memory_get_pointer(type_def, TYPEDEFINITION_DATA_VARIANT_VARIANTS_OFFSET)

                        Let vj be 0
                        While vj is less than variant_count:
                            Let variant_offset be vj multiplied by VARIANT_SIZE
                            Let variant_ptr be variants plus variant_offset
                            Let vname be memory_get_pointer(variant_ptr, 0)

                            If string_equals(vname, name) is equal to 1:
                                Set is_variant to 1
                                Let type_def_name be memory_get_pointer(type_def, 0)
                                Set variant_type_name to string_duplicate_parser(type_def_name)
                                Set vi to type_count  Note: Break outer
                                Set vj to variant_count  Note: Break inner
                            End If
                            Set vj to vj plus 1
                        End While
                    End If
                    Set vi to vi plus 1
                End While
            End If
        End If

        Let dummy7 be parser_eat(parser, token_type)

        Note: Check for explicit variant syntax "TypeName as VariantName"
        Let current_token_as_check be memory_get_pointer(parser, 8)
        If current_token_as_check is not equal to 0:
            Let token_type_as_check be memory_get_int32(current_token_as_check, 0)
            If token_type_as_check is equal to 34:  Note: TOKEN_AS
                Note: Explicit syntax: name is the type, next identifier is the variant
                parser_eat(parser, 34)

                Let variant_token be memory_get_pointer(parser, 8)
                If variant_token is equal to 0:
                    print_string("[PARSER ERROR] Expected variant name after 'as'")
                    Return 0
                End If
                Let variant_token_type be memory_get_int32(variant_token, 0)
                If variant_token_type is not equal to 53:  Note: TOKEN_IDENTIFIER
                    print_string("[PARSER ERROR] Expected variant name after 'as'")
                    Return 0
                End If
                Let variant_name_explicit be string_duplicate_parser(memory_get_pointer(variant_token, 8))
                parser_eat(parser, 53)

                Note: Create variant constructor with type_name=name, variant_name=variant_name_explicit
                Let expr_size be 40
                Let expr be memory_allocate(expr_size)
                memory_set_int32(expr, 0, EXPR_VARIANT_CONSTRUCTOR)
                memory_set_pointer(expr, 8, string_duplicate_parser(name))  Note: FIX: duplicate type name too!
                memory_set_pointer(expr, 16, variant_name_explicit)
                memory_set_integer(expr, 24, 0)
                memory_set_int32(expr, 32, 0)

                Note: Check for optional "with" for fields
                Let with_token be memory_get_pointer(parser, 8)
                If with_token is not equal to 0:
                    Let with_token_type be memory_get_int32(with_token, 0)
                    If with_token_type is equal to 114:  Note: TOKEN_WITH
                        parser_eat(parser, 114)

                        Note: Parse field values: field_name as value_expr
                        Let field_values be 0
                        Let field_count be 0
                        Let field_capacity be 4
                        Set field_values to memory_allocate(field_capacity multiplied by 8)

                        Let continue_fields be 1
                        While continue_fields is equal to 1:
                            Note: Parse field name
                            Let field_token be memory_get_pointer(parser, 8)
                            Let field_token_type be memory_get_int32(field_token, 0)
                            If field_token_type is not equal to 53:
                                print_string("[PARSER ERROR] Expected field name after 'with'")
                                print_newline()
                                exit_with_code(1)
                            End If
                            parser_eat(parser, 53)

                            parser_eat(parser, 34)  Note: TOKEN_AS

                            Note: Parse field value expression (use comparison_level to avoid consuming 'and')
                            Let field_value_expr be parser_parse_comparison_level(parser)

                            Note: Grow array if needed
                            If field_count is greater than or equal to field_capacity:
                                Set field_capacity to field_capacity multiplied by 2
                                Set field_values to memory_reallocate(field_values, field_capacity multiplied by 8)
                            End If

                            Note: Store field value
                            Let field_offset be field_count multiplied by 8
                            memory_set_pointer(field_values, field_offset, field_value_expr)
                            Set field_count to field_count plus 1

                            Note: Check for "and" to continue
                            Let next_field_token be memory_get_pointer(parser, 8)
                            Let next_field_type be memory_get_int32(next_field_token, 0)
                            If next_field_type is equal to 30:  Note: TOKEN_AND
                                parser_eat(parser, 30)
                            Otherwise:
                                Set continue_fields to 0
                            End If
                        End While

                        Note: Update expr with field values
                        memory_set_pointer(expr, 24, field_values)
                        memory_set_int32(expr, 32, field_count)
                    End If
                End If

                Return expr
            End If
        End If

        Note: Handle implicit variant construction (only after checking explicit syntax)
        If is_variant is equal to 1:
            Note: Create implicit variant constructor
            Let expr be memory_allocate(40)
            memory_set_int32(expr, 0, EXPR_VARIANT_CONSTRUCTOR)
            memory_set_pointer(expr, 8, variant_type_name)  Note: Inferred type
            memory_set_pointer(expr, 16, string_duplicate_parser(name))  Note: Variant name
            memory_set_pointer(expr, 24, 0)  Note: Field values (none yet)
            memory_set_int32(expr, 32, 0)  Note: Field count = 0

            Note: Check for optional "with" for fields
            Let with_token be memory_get_pointer(parser, 8)
            If with_token is not equal to 0:
                Let with_token_type be memory_get_int32(with_token, 0)
                If with_token_type is equal to 114:  Note: TOKEN_WITH
                    parser_eat(parser, 114)

                    Note: Parse field values
                    Let field_values be 0
                    Let field_count be 0
                    Let field_capacity be 4
                    Set field_values to memory_allocate(field_capacity multiplied by 8)

                    Let continue_fields be 1
                    While continue_fields is equal to 1:
                        Note: Parse field name
                        Let field_token be memory_get_pointer(parser, 8)
                        Let field_token_type be memory_get_int32(field_token, 0)
                        If field_token_type is not equal to 53:
                            print_string("[PARSER ERROR] Expected field name after 'with'")
                            print_newline()
                            exit_with_code(1)
                        End If
                        parser_eat(parser, 53)

                        parser_eat(parser, 34)  Note: TOKEN_AS

                        Note: Parse field value expression
                        Let field_value_expr be parser_parse_comparison_level(parser)

                        Note: Grow array if needed
                        If field_count is greater than or equal to field_capacity:
                            Set field_capacity to field_capacity multiplied by 2
                            Set field_values to memory_reallocate(field_values, field_capacity multiplied by 8)
                        End If

                        Note: Store field value
                        Let field_offset be field_count multiplied by 8
                        memory_set_pointer(field_values, field_offset, field_value_expr)
                        Set field_count to field_count plus 1

                        Note: Check for "and" to continue
                        Let next_field_token be memory_get_pointer(parser, 8)
                        Let next_field_type be memory_get_int32(next_field_token, 0)
                        If next_field_type is equal to 30:  Note: TOKEN_AND
                            parser_eat(parser, 30)
                        Otherwise:
                            Set continue_fields to 0
                        End If
                    End While

                    Note: Update expr with field values
                    memory_set_pointer(expr, 24, field_values)
                    memory_set_int32(expr, 32, field_count)
                End If
            End If

            Return expr
        End If

        Note: Check if this identifier is itself a variant name (fieldless variant)
        Note: Only check if next token is NOT "with" (otherwise it's a variant constructor with fields)
        Let current_token_peek be memory_get_pointer(parser, 8)
        Let token_type_peek be memory_get_int32(current_token_peek, 0)
        Let variant_name_check be name
        Let adt_type_for_fieldless be 0
        Let should_check_fieldless be 1
        If token_type_peek is equal to 114:  Note: TOKEN_WITH
            Set should_check_fieldless to 0
        End If
        If should_check_fieldless is equal to 1:
            If prog is not equal to 0:
                Let type_count_check be memory_get_int32(prog, PROGRAM_TYPE_COUNT)
                Let types_check be memory_get_pointer(prog, PROGRAM_TYPES)
                Let ic be 0
                While ic is less than type_count_check:
                    Let type_ptr_check be types_check plus ic multiplied by 8
                    Let type_def_check be memory_get_pointer(type_ptr_check, 0)
                    Let type_kind_check be memory_get_int32(type_def_check, TYPEDEFINITION_KIND_OFFSET)
                    If type_kind_check is equal to TYPE_KIND_VARIANT:
                        Let variant_count_check be memory_get_int32(type_def_check, TYPEDEFINITION_DATA_VARIANT_VARIANT_COUNT_OFFSET)
                        Let variants_check be memory_get_pointer(type_def_check, TYPEDEFINITION_DATA_VARIANT_VARIANTS_OFFSET)
                        Let jc be 0
                        While jc is less than variant_count_check:
                            Let variant_ptr_check be variants_check plus jc multiplied by VARIANT_SIZE
                            Let vname_check be memory_get_pointer(variant_ptr_check, 0)
                            If string_equals(vname_check, variant_name_check) is equal to 1:
                                Set adt_type_for_fieldless to type_def_check
                                Set jc to variant_count_check  Note: Break
                                Set ic to type_count_check  Note: Break outer
                            End If
                            Set jc to jc plus 1
                        End While
                    End If
                    Set ic to ic plus 1
                End While
            End If
        End If

        If adt_type_for_fieldless is not equal to 0:
            Note: This is a fieldless variant constructor
            Let expr_size be 40
            Let expr be memory_allocate(expr_size)
            memory_set_int32(expr, 0, EXPR_VARIANT_CONSTRUCTOR)
            Let adt_type_name be memory_get_pointer(adt_type_for_fieldless, 0)
            memory_set_pointer(expr, 8, adt_type_name)  Note: type_name
            memory_set_pointer(expr, 16, variant_name_check)  Note: variant_name
            memory_set_integer(expr, 24, 0)  Note: field_values
            memory_set_int32(expr, 32, 0)  Note: field_count
            Return expr
        End If

        Note: Check if this is a variant constructor (with keyword)
        Let current_token5 be memory_get_pointer(parser, 8)
        Let token_type5 be memory_get_int32(current_token5, 0)

        If token_type5 is equal to 114:  Note: TOKEN_WITH
            Note: Check if this identifier is a variant name within any ADT type
            Let variant_name be name
            Let adt_type be 0

            Note: Find the ADT type that contains this variant
            If prog is not equal to 0:
                Let type_count be memory_get_integer(prog, PROGRAM_TYPE_COUNT)
                Let types be memory_get_pointer(prog, PROGRAM_TYPES)
                Let i be 0
                Let continue_outer be 1
                While continue_outer is equal to 1:
                    Let is_done be 0
                    If i is greater than or equal to type_count:
                        Let is_done be 1
                    End If
                    If is_done is equal to 1:
                        Let continue_outer be 0
                    End If
                    If is_done is equal to 0:
                        Let ptr_size be 8
                        Let offset be i multiplied by ptr_size
                        Let type_ptr be types plus offset
                        Let type_def be memory_get_pointer(type_ptr, 0)
                        Let type_kind be memory_get_integer(type_def, 8)

                        Note: Check if this is a variant type
                        Let is_variant_type be 0
                        If type_kind is equal to TYPE_KIND_VARIANT:
                            Let is_variant_type be 1
                        End If
                        If is_variant_type is equal to 1:
                            Let variant_count be memory_get_integer(type_def, 24)
                            Let variants be memory_get_pointer(type_def, 16)
                            Let j be 0
                            Let continue_inner be 1
                            While continue_inner is equal to 1:
                                Let inner_done be 0
                                If j is greater than or equal to variant_count:
                                    Let inner_done be 1
                                End If
                                If inner_done is equal to 1:
                                    Let continue_inner be 0
                                End If
                                If inner_done is equal to 0:
                                    Let variant_offset be j multiplied by VARIANT_SIZE
                                    Let variant_ptr be variants plus variant_offset
                                    Let variant_name_ptr be memory_get_pointer(variant_ptr, 0)
                                    Let variant_match be string_equals(variant_name_ptr, variant_name)
                                    If variant_match is equal to 1:
                                        Let adt_type be type_def
                                        Let continue_inner be 0  Note: Break inner loop
                                        Let continue_outer be 0  Note: Break outer loop
                                    End If
                                    Let j be j plus 1
                                End If
                            End While
                        End If
                        Let i be i plus 1
                    End If
                End While
            End If

            If adt_type is not equal to 0:
                Note: This is a variant constructor
                Let expr_size be 40
                Let expr be memory_allocate(expr_size)
                memory_set_int32(expr, 0, EXPR_VARIANT_CONSTRUCTOR)
                Let adt_type_name be memory_get_integer(adt_type, 0)
                memory_set_pointer(expr, 8, string_duplicate_parser(adt_type_name))  Note: type_name
                memory_set_pointer(expr, 16, string_duplicate_parser(variant_name))  Note: FIX: duplicate variant_name!
                memory_set_integer(expr, 24, 0)  Note: field_values
                memory_set_int32(expr, 32, 0)  Note: field_count

                Note: Check if there are fields (optional "with" keyword)
                Let current_token_check be memory_get_pointer(parser, 8)
                Let token_type_check be memory_get_int32(current_token_check, 0)
                If token_type_check is equal to 114:  Note: TOKEN_WITH
                    parser_eat(parser, 114)

                    Note: Parse field values: field_name as value_expr
                    Let field_values be 0
                    Let field_count be 0
                    Let field_capacity be 4
                    Set field_values to memory_allocate(field_capacity multiplied by 8)

                    Let continue_fields be 1
                    While continue_fields is equal to 1:
                        Note: Parse field name
                        Let field_token be memory_get_pointer(parser, 8)
                        Let field_token_type be memory_get_int32(field_token, 0)
                        If field_token_type is not equal to 53:
                            print_string("[PARSER ERROR] Expected field name after 'with'")
                            print_newline()
                            exit_with_code(1)
                        End If
                        parser_eat(parser, 53)

                        parser_eat(parser, 34)  Note: TOKEN_AS

                        Note: Parse field value expression (use comparison_level to avoid consuming 'and')
                        Let field_value_expr be parser_parse_comparison_level(parser)

                        Note: Grow array if needed
                        If field_count is greater than or equal to field_capacity:
                            Set field_capacity to field_capacity multiplied by 2
                            Set field_values to memory_reallocate(field_values, field_capacity multiplied by 8)
                        End If

                        Note: Store field value
                        Let field_offset be field_count multiplied by 8
                        memory_set_pointer(field_values, field_offset, field_value_expr)
                        Set field_count to field_count plus 1

                        Note: Check for "and" to continue
                        Let next_field_token be memory_get_pointer(parser, 8)
                        Let next_field_type be memory_get_int32(next_field_token, 0)
                        If next_field_type is equal to 30:  Note: TOKEN_AND
                            parser_eat(parser, 30)
                        Otherwise:
                            Set continue_fields to 0
                        End If
                    End While

                    Note: Update expr with field values
                    memory_set_pointer(expr, 24, field_values)
                    memory_set_int32(expr, 32, field_count)
                End If

                Return expr
            End If
        End If

        Note: Check if this is a function call - DISABLED to use postfix parsing instead
        Let check_func_call be 0
        Note: Completely bypass this problematic logic - all function calls use postfix parsing

        If check_func_call is equal to 1:
            Let dummy9 be parser_eat(parser, 51)

            Note: Parse arguments
            Let arguments be 0
            Let argument_count be 0
            Let argument_capacity be 0

            Let continue_loop be 1
            While continue_loop is equal to 1:
                Let current_token7 be memory_get_pointer(parser, 8)
                Let token_type7 be memory_get_integer(current_token7, 0)

                Note: Check for closing paren
                If token_type7 is equal to 49:
                    Set continue_loop to 0
                End If

                Note: Check for EOF
                If token_type7 is equal to 0:
                    Set continue_loop to 0
                End If

                Note: Process argument
                Let should_process_arg be 0
                If token_type7 is not equal to 49:
                    If token_type7 is not equal to 0:
                        Set should_process_arg to 1
                    End If
                End If

                If should_process_arg is equal to 1:
                    If argument_count is greater than or equal to argument_capacity:
                        If argument_capacity is equal to 0:
                            Set argument_capacity to 4
                        End If
                        If argument_capacity is not equal to 4:
                            Set argument_capacity to argument_capacity multiplied by 2
                        End If
                        Let ptr_size be 8
                        Let new_size be argument_capacity multiplied by ptr_size
                        Set arguments to memory_reallocate(arguments, new_size)
                    End If

                    Let arg be parser_parse_additive(parser)
                    Let ptr_size be 8
                    Let offset be argument_count multiplied by ptr_size
                    Let arg_ptr be arguments plus offset
                    memory_set_pointer(arg_ptr, 0, arg)
                    Set argument_count to argument_count plus 1

                    Let current_token8 be memory_get_pointer(parser, 8)
                    Let token_type8 be memory_get_integer(current_token8, 0)

                    Note: Check what comes after the argument
                    If token_type8 is equal to 49:
                        Set continue_loop to 0
                    Otherwise If token_type8 is equal to 52:
                        Let dummy10 be parser_eat(parser, 52)
                    Otherwise:
                        Note: Error: expected comma or closing paren
                        Let error_msg be "[PARSER ERROR] Expected ',' or ')' in function arguments at line "
                        print_string(error_msg)
                        Let line be memory_get_int32(current_token8, 16)
                        print_integer(line)
                        print_newline()
                        exit_with_code(1)
                    End If
                End If
            End While

            Let dummy16 be parser_eat(parser, 52)
            Let expr be expression_create_function_call(name, arguments, argument_count)
            Return expr
        End If

        Note: Handle type name
        If is_type is equal to 1:
            Note: This is a type name, create a type expression
            Let expr_size be 32  Note: Match other expression types for safety
            Let expr be memory_allocate(expr_size)
            memory_set_int32(expr, 0, EXPR_TYPE_NAME)
            memory_set_pointer(expr, 8, name)
            Return expr
        End If

        Note: Default case: variable expression
        Let expr be expression_create_variable(name)
        Return expr
    End If

    Note: Handle true literal
    If token_type is equal to 134:  Note: TOKEN_TRUE
        Let dummy8 be parser_eat(parser, 134)
        Let expr be expression_create_integer(1)
        Return expr
    End If

    Note: Handle false literal
    If token_type is equal to 135:  Note: TOKEN_FALSE
        Let dummy9 be parser_eat(parser, 135)
        Let expr be expression_create_integer(0)
        Return expr
    End If

    Note: Handle negative literal
    If token_type is equal to 133:  Note: TOKEN_NEGATIVE
        Let dummy10 be parser_eat(parser, 133)
        Note: Expect an integer after "negative"
        Let neg_token be memory_get_pointer(parser, 8)
        Let neg_token_type be memory_get_integer(neg_token, 0)
        If neg_token_type is not equal to 11:  Note: TOKEN_INTEGER
            print_string("[PARSER ERROR] Expected integer after 'negative' at line ")
            Let err_line be memory_get_int32(neg_token, 16)
            print_integer(err_line)
            print_newline()
            exit_with_code(1)
        End If
        Let value_str be memory_get_pointer(neg_token, 8)
        Let value be string_to_integer(value_str)
        Let negative_value be -value
        Let dummy11 be parser_eat(parser, 11)
        Let expr be expression_create_integer(negative_value)
        Return expr
    End If

    Note: Handle lambda expression
    If token_type is equal to 162:  Note: TOKEN_LAMBDA
        parser_eat(parser, 162)  Note: Eat "lambda"

        Note: Parse parameter list (single or multiple comma-separated)
        Let param_names be 0
        Let param_count be 0
        Let param_capacity be 4
        Let param_size be param_capacity multiplied by 8
        Set param_names to memory_allocate(param_size)

        Note: Parse first parameter
        Let param_token be memory_get_pointer(parser, 8)
        Let param_token_type be memory_get_int32(param_token, 0)
        If param_token_type is not equal to 53:  Note: TOKEN_IDENTIFIER
            print_string("[PARSER ERROR] Expected parameter name after 'lambda'")
            print_newline()
            exit_with_code(1)
        End If
        Let param_name_temp be memory_get_pointer(param_token, 8)
        Let param_name be string_duplicate_parser(param_name_temp)
        memory_set_pointer(param_names, 0, param_name)
        Set param_count to 1
        parser_eat(parser, 53)  Note: Eat parameter name

        Note: Parse additional parameters (comma-separated)
        Let continue_params be 1
        While continue_params is equal to 1:
            Let next_token be memory_get_pointer(parser, 8)
            Let next_token_type be memory_get_int32(next_token, 0)

            If next_token_type is equal to 52:  Note: TOKEN_COMMA
                parser_eat(parser, 52)  Note: Eat comma

                Note: Expect another parameter
                Let param_token2 be memory_get_pointer(parser, 8)
                Let param_token_type2 be memory_get_int32(param_token2, 0)
                If param_token_type2 is not equal to 53:  Note: TOKEN_IDENTIFIER
                    print_string("[PARSER ERROR] Expected parameter name after comma")
                    print_newline()
                    exit_with_code(1)
                End If

                Let param_name_temp2 be memory_get_pointer(param_token2, 8)
                Let param_name2 be string_duplicate_parser(param_name_temp2)

                Note: Store parameter
                Let param_offset be param_count multiplied by 8
                memory_set_pointer(param_names plus param_offset, 0, param_name2)
                Set param_count to param_count plus 1
                parser_eat(parser, 53)  Note: Eat parameter name
            Otherwise:
                Set continue_params to 0
            End If
        End While

        Note: Expect colon
        Let colon_token be memory_get_pointer(parser, 8)
        Let colon_token_type be memory_get_int32(colon_token, 0)
        If colon_token_type is not equal to 9:  Note: TOKEN_COLON
            print_string("[PARSER ERROR] Expected ':' after lambda parameters")
            print_newline()
            exit_with_code(1)
        End If
        parser_eat(parser, 9)  Note: Eat colon

        Note: Parse body expression
        Let body be parser_parse_expression(parser)

        Note: Create lambda expression with multiple parameters
        Let lambda_expr be expression_create_lambda_multi(param_names, param_count, body)

        Note: Analyze body to collect free variables (variables not in parameter list)
        lambda_collect_free_vars(lambda_expr, body, param_names, param_count)

        Return lambda_expr
    End If

    Note: Error: unexpected token
    Let error_msg be "[PARSER ERROR] Expected integer or identifier at line "
    print_string(error_msg)
    Let line be memory_get_int32(current_token, 16)
    print_integer(line)
    print_newline()
    exit_with_code(1)
    Return 0  Note: Unreachable
End Process

Note: Parser parse return statement - handles "Return expression"
Process called "parser_parse_return_statement" takes parser as Integer returns Integer:
    Let dummy be parser_eat(parser, 7)
    Let expr be parser_parse_expression(parser)
    Let stmt be statement_create_return(expr)
    Return stmt
End Process

Note: Parser parse break statement - handles "Break"
Process called "parser_parse_break_statement" takes parser as Integer returns Integer:
    Let dummy be parser_eat(parser, 44)
    Return statement_create_break(0)
End Process

Note: Parser parse continue statement - handles "Continue"
Process called "parser_parse_continue_statement" takes parser as Integer returns Integer:
    Let dummy be parser_eat(parser, 45)
    Return statement_create_continue(0)
End Process

Note: Parser parse print statement - handles "Print expression" or "Display expression"
Process called "parser_parse_print_statement" takes parser as Integer returns Integer:
    Let dummy be parser_eat(parser, 47)

    Note: Check if next token is LPAREN - Display/Print should NOT use function call syntax
    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_int32(current_token, 0)
    If token_type is equal to 48:  Note: TOKEN_LPAREN
        print_string("[PARSER ERROR] Display/Print is a statement and should not use parentheses. Use 'Display expression' not 'Display(expression)' at line ")
        Let err_line be memory_get_int32(current_token, 16)
        print_integer(err_line)
        print_newline()
        exit_with_code(1)
    End If

    Note: Parse first expression
    Let first_expr be parser_parse_expression(parser)

    Note: Check if there are more expressions separated by commas
    Let current_check be memory_get_pointer(parser, 8)
    Let check_type be memory_get_int32(current_check, 0)

    If check_type is equal to 52:  Note: TOKEN_COMMA - concatenate multiple expressions
        Note: Build concatenated string from comma-separated expressions
        Let concat_expr be first_expr

        While check_type is equal to 52:
            Let dummy_comma be parser_eat(parser, 52)  Note: Eat the comma
            Let next_expr be parser_parse_expression(parser)

            Note: Create string_concat(concat_expr, next_expr) manually
            Let args be allocate(16)  Note: Space for 2 pointer arguments
            memory_set_pointer(args, 0, concat_expr)
            memory_set_pointer(args, 8, next_expr)
            Let concat_call be expression_create_function_call("string_concat", args, 2)
            Let concat_expr be concat_call

            Let current_check be memory_get_pointer(parser, 8)
            Let check_type be memory_get_int32(current_check, 0)
        End While

        Return statement_create_print(concat_expr)
    Otherwise:
        Note: Single expression - return as-is
        Return statement_create_print(first_expr)
    End If
End Process

Note: Parser parse statement block - parses block of statements until END/OTHERWISE/EOF
Process called "parser_parse_statement_block" takes parser as Integer, count_ptr as Integer returns Integer:
    Let statements be 0
    Let capacity be 0
    memory_set_integer(count_ptr, 0, 0)

    Let continue_loop be 1
    While continue_loop is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_int32(current_token, 0)

        Note: Check for block termination conditions
        If token_type is equal to 8:
            Set continue_loop to 0
        End If
        If token_type is equal to 19:
            Set continue_loop to 0
        End If
        If token_type is equal to 113:  Note: TOKEN_WHEN
            Set continue_loop to 0
        End If
        If token_type is equal to 0:
            Set continue_loop to 0
        End If

        If continue_loop is equal to 1:
            Let stmt be 0

            Note: Parse different statement types
            If token_type is equal to 12:
                Set stmt to parser_parse_let_statement(parser)
            End If

            If token_type is equal to 14:
                Set stmt to parser_parse_set_statement(parser)
            End If

            If token_type is equal to 7:
                Set stmt to parser_parse_return_statement(parser)
            End If

            If token_type is equal to 44:
                Set stmt to parser_parse_break_statement(parser)
            End If

            If token_type is equal to 45:
                Set stmt to parser_parse_continue_statement(parser)
            End If

            If token_type is equal to 47:
                Set stmt to parser_parse_print_statement(parser)
            End If

            If token_type is equal to 18:
                Set stmt to parser_parse_if_statement(parser)
            End If

            If token_type is equal to 20:
                Set stmt to parser_parse_while_statement(parser)
            End If

            If token_type is equal to 121:
                Set stmt to parser_parse_inline_assembly_statement(parser)
            End If

            If token_type is equal to 112:
                Set stmt to parser_parse_match_statement(parser)
            End If

            If token_type is equal to 143:  Note: TOKEN_FOR
                Set stmt to parser_parse_for_range_statement(parser)
            End If

            Note: Handle implicit compound assignment: Increase/Decrease/Multiply/Divide X by Y
            Note: TOKEN_INCREASE is 139, TOKEN_DECREASE is 140
            Note: TOKEN_MULTIPLY is 141, TOKEN_DIVIDE is 142
            If token_type is equal to 139:
                Set stmt to parser_parse_implicit_compound_assign(parser, 0)
            End If

            If token_type is equal to 140:
                Set stmt to parser_parse_implicit_compound_assign(parser, 1)
            End If

            If token_type is equal to 141:
                Set stmt to parser_parse_implicit_compound_assign(parser, 2)
            End If

            If token_type is equal to 142:
                Set stmt to parser_parse_implicit_compound_assign(parser, 3)
            End If

            Note: Handle identifier - could be function call
            If token_type is equal to 53:
                Let expr be parser_parse_expression(parser)
                Let expr_type be memory_get_int32(expr, 0)
                If expr_type is equal to EXPR_FUNCTION_CALL:
                    Set stmt to statement_create_expression(expr)
                End If
                If expr_type is not equal to EXPR_FUNCTION_CALL:
                    Let error_msg be "[PARSER ERROR] Only function calls can be used as statements (expr_type="
                    print_string(error_msg)
                    print_integer(expr_type)
                    print_string(", expected ")
                    print_integer(EXPR_FUNCTION_CALL)
                    print_string(") at line ")
                    Let line be memory_get_int32(current_token, 16)
                    print_integer(line)
                    print_newline()
                    exit_with_code(1)
                End If
            End If

            Note: Handle builtin function calls
            Let is_builtin be parser_is_builtin_function_token(token_type)
            If is_builtin is equal to 1:
                Let expr be parser_parse_expression(parser)
                Let expr_type be memory_get_int32(expr, 0)
                If expr_type is equal to EXPR_BUILTIN_CALL:
                    Set stmt to statement_create_expression(expr)
                End If
                If expr_type is not equal to EXPR_BUILTIN_CALL:
                    Let error_msg be "[PARSER ERROR] Invalid builtin function statement at line "
                    print_string(error_msg)
                    Let line be memory_get_int32(current_token, 16)
                    print_integer(line)
                    print_newline()
                    exit_with_code(1)
                End If
            End If

            Note: If no statement was parsed, break
            If stmt is equal to 0:
                Set continue_loop to 0
            End If

            Note: Add statement to array if parsed
            If stmt is not equal to 0:
                Let current_count be memory_get_integer(count_ptr, 0)
                If current_count is greater than or equal to capacity:
                    If capacity is equal to 0:
                        Note: INCREASED initial capacity from 4 to 256 for large functions
                        Set capacity to 256
                    Otherwise:
                        Set capacity to capacity multiplied by 2
                    End If
                    Let ptr_size be 8
                    Let new_size be capacity multiplied by ptr_size
                    Set statements to memory_reallocate(statements, new_size)
                End If

                Let ptr_size be 8
                Let offset be current_count multiplied by ptr_size
                Let stmt_ptr be statements plus offset
                memory_set_pointer(stmt_ptr, 0, stmt)

                Let new_count be current_count plus 1
                memory_set_integer(count_ptr, 0, new_count)
            End If
        End If
    End While

    Return statements
End Process

Note: Parser parse while statement - handles "While condition: ... End While"
Process called "parser_parse_while_statement" takes parser as Integer returns Integer:
    Let dummy1 be parser_eat(parser, 20)
    Let condition be parser_parse_comparison(parser)
    Let dummy2 be parser_eat(parser, 9)

    Let body_count_ptr be memory_allocate(8)
    Let body be parser_parse_statement_block(parser, body_count_ptr)
    Let body_count be memory_get_integer(body_count_ptr, 0)
    deallocate(body_count_ptr)

    Let dummy3 be parser_eat(parser, 8)
    Let dummy4 be parser_eat(parser, 20)

    Let while_stmt be statement_create_while(condition, body, body_count)
    Return while_stmt
End Process

Note: Parser parse for-range statement - handles "For i from start to end by step: ... End For"
Note: Also handles "For each item in collection: ... End For"
Process called "parser_parse_for_range_statement" takes parser as Integer returns Integer:
    parser_eat(parser, 143)  Note: TOKEN_FOR

    Note: Check if this is "for each" or "for from" by looking at next token
    Let peek_token be memory_get_pointer(parser, 8)
    Let peek_token_type be memory_get_int32(peek_token, 0)

    Note: Handle "For each item in collection"
    If peek_token_type is equal to 145:  Note: TOKEN_EACH
        parser_eat(parser, 145)  Note: TOKEN_EACH

        Note: Parse loop variable name
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_int32(current_token, 0)
        Let var_name_temp be memory_get_pointer(current_token, 8)
        Let var_name be string_duplicate(var_name_temp)
        parser_eat(parser, token_type)

        parser_eat(parser, 152)  Note: TOKEN_IN
        Let collection_expr be parser_parse_expression(parser)
        parser_eat(parser, 9)    Note: TOKEN_COLON

        Let body_count_ptr be memory_allocate(8)
        Let body be parser_parse_statement_block(parser, body_count_ptr)
        Let body_count be memory_get_integer(body_count_ptr, 0)
        deallocate(body_count_ptr)

        parser_eat(parser, 8)    Note: TOKEN_END
        parser_eat(parser, 143)  Note: TOKEN_FOR

        Let foreach_stmt be statement_create_for_each(var_name, collection_expr, body, body_count)
        Return foreach_stmt
    End If

    Note: Handle "For i from start to end by step"
    Note: Parse loop variable name
    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_int32(current_token, 0)
    Let var_name_temp be memory_get_pointer(current_token, 8)
    Let var_name be string_duplicate(var_name_temp)
    parser_eat(parser, token_type)

    parser_eat(parser, 144)  Note: TOKEN_FROM
    Let start_expr be parser_parse_expression(parser)

    parser_eat(parser, 15)  Note: TOKEN_TO
    Let end_expr be parser_parse_expression(parser)

    Note: Check for optional "by step"
    Let current_token2 be memory_get_pointer(parser, 8)
    Let token_type2 be memory_get_int32(current_token2, 0)
    Let step_expr be 0
    If token_type2 is equal to 38:  Note: TOKEN_BY
        parser_eat(parser, 38)
        Set step_expr to parser_parse_expression(parser)
    End If

    parser_eat(parser, 9)  Note: TOKEN_COLON

    Let body_count_ptr be memory_allocate(8)
    Let body be parser_parse_statement_block(parser, body_count_ptr)
    Let body_count be memory_get_integer(body_count_ptr, 0)
    deallocate(body_count_ptr)

    parser_eat(parser, 8)   Note: TOKEN_END
    parser_eat(parser, 143)  Note: TOKEN_FOR

    Let for_stmt be statement_create_for_range(var_name, start_expr, end_expr, step_expr, body, body_count)
    Return for_stmt
End Process

Note: Parser parse if statement - handles "If condition: ... Otherwise If ... Otherwise ... End If"
Note: Handle elif/else chains with proper nesting
Process called "parser_parse_if_statement" takes parser as Integer returns Integer:
    Let dummy1 be parser_eat(parser, 18)
    Let condition be parser_parse_expression(parser)
    Let dummy2 be parser_eat(parser, 9)

    Let if_body_count_ptr be memory_allocate(8)
    Let if_body be parser_parse_statement_block(parser, if_body_count_ptr)
    Let if_body_count be memory_get_integer(if_body_count_ptr, 0)
    deallocate(if_body_count_ptr)

    Let else_body be 0
    Let else_body_count be 0

    Note: Handle elif/else chains
    Let continue_parsing be 1
    While continue_parsing is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 19:
            Let dummy3 be parser_eat(parser, 19)
            Let next_token be memory_get_pointer(parser, 8)
            Let next_token_type be memory_get_integer(next_token, 0)

            Note: Check if this is "Otherwise If" (elif)
            If next_token_type is equal to 18:
                Let dummy4 be parser_eat(parser, 18)
                Let elif_condition be parser_parse_expression(parser)
                Let dummy5 be parser_eat(parser, 9)

                Let elif_body_count_ptr be memory_allocate(8)
                Let elif_body be parser_parse_statement_block(parser, elif_body_count_ptr)
                Let elif_body_count be memory_get_integer(elif_body_count_ptr, 0)
                deallocate(elif_body_count_ptr)

                Note: Create nested if statement for elif
                Let elif_stmt be statement_create_if(elif_condition, elif_body, elif_body_count, 0, 0)

                Note: Chain elifs by nesting them
                Note: Save the current count to detect if this is the first elif
                Let prev_count be else_body_count

                If prev_count is equal to 0:
                    Note: First elif - create else body with one statement
                    Set else_body to memory_allocate(8)
                    memory_set_pointer(else_body, 0, elif_stmt)
                    Set else_body_count to 1
                End If

                If prev_count is greater than 0:
                    Note: Subsequent elif - traverse chain to find the last elif
                    Let current_elif be memory_get_pointer(else_body, 0)
                    Let current_elif_else be memory_get_pointer(current_elif, 32)

                    Note: Keep following the chain until we find an elif with no else
                    While current_elif_else is not equal to 0:
                        Set current_elif to memory_get_pointer(current_elif_else, 0)
                        Set current_elif_else to memory_get_pointer(current_elif, 32)
                    End While

                    Note: Now current_elif is the last elif in the chain
                    Note: Create new else body for the last elif with just this new elif
                    Let new_elif_else be memory_allocate(8)
                    memory_set_pointer(new_elif_else, 0, elif_stmt)

                    Note: Attach to last elif
                    memory_set_pointer(current_elif, 32, new_elif_else)
                    memory_set_integer(current_elif, 40, 1)
                End If
            End If

            Note: Handle regular "Otherwise" clause
            If next_token_type is not equal to 18:
                Let dummy6 be parser_eat(parser, 9)
                Let final_else_count_ptr be memory_allocate(8)
                Let final_else_body be parser_parse_statement_block(parser, final_else_count_ptr)
                Let final_else_count be memory_get_integer(final_else_count_ptr, 0)
                deallocate(final_else_count_ptr)

                If else_body is equal to 0:
                    Note: No previous elifs, simple else
                    Set else_body to final_else_body
                    Set else_body_count to final_else_count
                End If

                If else_body is not equal to 0:
                    If else_body is not equal to final_else_body:
                        Note: Attach final else to the last elif in the chain
                        Note: Traverse the chain to find the actual last elif
                        Let current_elif be memory_get_pointer(else_body, 0)
                        Let current_elif_else be memory_get_pointer(current_elif, 32)

                        Note: Keep following the chain until we find an elif with no else
                        While current_elif_else is not equal to 0:
                            Set current_elif to memory_get_pointer(current_elif_else, 0)
                            Set current_elif_else to memory_get_pointer(current_elif, 32)
                        End While

                        Note: Now current_elif is the last elif in the chain
                        memory_set_pointer(current_elif, 32, final_else_body)
                        memory_set_integer(current_elif, 40, final_else_count)
                    End If
                End If

                Set continue_parsing to 0  Note: Final else ends the chain
            End If
        End If

        If token_type is not equal to 19:
            Set continue_parsing to 0
        End If
    End While

    Let dummy7 be parser_eat(parser, 8)
    Let dummy8 be parser_eat(parser, 18)

    Return statement_create_if(condition, if_body, if_body_count, else_body, else_body_count)
End Process

Note: Parser parse match statement - handles "Match expr: When pattern: ... End Match"
Process called "parser_parse_match_statement" takes parser as Integer returns Integer:
    parser_eat(parser, 112)  Note: Eat TOKEN_MATCH
    Let match_expr be parser_parse_expression(parser)
    parser_eat(parser, 9)  Note: Eat colon

    Note: Parse When clauses
    Let when_capacity be 4
    Let when_clauses be memory_allocate(when_capacity multiplied by 48)  Note: Array of when clause structs (48 bytes each)
    Let when_count be 0

    Let continue_parsing be 1
    While continue_parsing is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        If current_token is equal to 0:
            Set continue_parsing to 0
        End If
        If current_token is not equal to 0:
            Let token_type be memory_get_int32(current_token, 0)

            If token_type is equal to 113:  Note: TOKEN_WHEN
                parser_eat(parser, 113)

                Note: Determine pattern type: literal expression, variant name, or wildcard
                Let pattern_token be memory_get_pointer(parser, 8)
                Let pattern_token_type be memory_get_int32(pattern_token, 0)

                Let pattern_type be PATTERN_LITERAL
                Let pattern_value be 0
                Let field_bindings be 0
                Let field_count be 0

                Note: Check if it's a wildcard
                If pattern_token_type is equal to 161:  Note: TOKEN_UNDERSCORE
                    Set pattern_type to PATTERN_WILDCARD
                    parser_eat(parser, 161)
                Otherwise If pattern_token_type is equal to 53:  Note: TOKEN_IDENTIFIER
                    Note: Peek ahead to see if this is "identifier of type" pattern
                    Let ident_value_temp be memory_get_pointer(pattern_token, 8)
                    Let ident_value be string_duplicate_parser(ident_value_temp)
                    parser_eat(parser, 53)

                    Let after_ident_token be memory_get_pointer(parser, 8)
                    Let after_ident_type be memory_get_int32(after_ident_token, 0)

                    If after_ident_type is equal to 125:  Note: TOKEN_OF
                        Note: This is "value of type TypeName" pattern
                        parser_eat(parser, 125)

                        Note: Next should be "type" keyword
                        Let type_kw_token be memory_get_pointer(parser, 8)
                        Let type_kw_type be memory_get_int32(type_kw_token, 0)
                        If type_kw_type is not equal to 50:  Note: TOKEN_TYPE
                            print_string("[PARSER ERROR] Expected 'type' keyword after 'of'")
                            print_newline()
                            exit_with_code(1)
                        End If
                        parser_eat(parser, 50)  Note: Eat TOKEN_TYPE

                        Note: Now get the actual type name (identifier or built-in type)
                        Let type_token be memory_get_pointer(parser, 8)
                        Let type_token_type be memory_get_int32(type_token, 0)

                        Note: Accept TOKEN_IDENTIFIER (53) or TOKEN_INTEGER_TYPE (4)
                        If type_token_type is not equal to 53:
                            If type_token_type is not equal to 4:
                                print_string("[PARSER ERROR] Expected type name after 'of Type'")
                                print_newline()
                                exit_with_code(1)
                            End If
                        End If

                        Let type_name_temp be memory_get_pointer(type_token, 8)
                        Let type_name_str be string_duplicate_parser(type_name_temp)
                        parser_eat(parser, type_token_type)

                        Set pattern_type to PATTERN_TYPE
                        Set pattern_value to type_name_str
                        Note: ident_value could be used for binding if needed
                    Otherwise:
                        Note: Not "of type" - could be variant or variable
                        Note: Use the already-duplicated identifier value
                        Let variant_name be ident_value

                        Note: Check next token
                        Let next_token be memory_get_pointer(parser, 8)
                        Let next_token_type be memory_get_int32(next_token, 0)

                        If next_token_type is equal to 9:  Note: TOKEN_COLON - fieldless variant
                            Set pattern_type to PATTERN_VARIANT
                            Set pattern_value to variant_name
                        Otherwise If next_token_type is equal to 114:  Note: TOKEN_WITH - variant with fields
                            Set pattern_type to PATTERN_VARIANT
                            Set pattern_value to variant_name
                            parser_eat(parser, 114)

                            Note: Parse field bindings
                            Let binding_capacity be 4
                            Set field_bindings to memory_allocate(binding_capacity multiplied by 8)

                            Let continue_bindings be 1
                            While continue_bindings is equal to 1:
                                Note: Parse: field_name as binding_name
                                Let field_token be memory_get_pointer(parser, 8)
                                Let field_token_type be memory_get_int32(field_token, 0)
                                If field_token_type is not equal to 53:
                                    print_string("[PARSER ERROR] Expected field name in When pattern")
                                    print_newline()
                                    exit_with_code(1)
                                End If
                                Let field_name_temp be memory_get_pointer(field_token, 8)
                                Let field_name be string_duplicate_parser(field_name_temp)
                                parser_eat(parser, 53)

                                parser_eat(parser, 34)  Note: TOKEN_AS

                                Let binding_token be memory_get_pointer(parser, 8)
                                Let binding_token_type be memory_get_int32(binding_token, 0)
                                If binding_token_type is not equal to 53:
                                    print_string("[PARSER ERROR] Expected binding name after 'as'")
                                    print_newline()
                                    exit_with_code(1)
                                End If
                                Let binding_name_temp be memory_get_pointer(binding_token, 8)
                                Let binding_name be string_duplicate_parser(binding_name_temp)
                                parser_eat(parser, 53)

                                Note: Grow bindings array if needed
                                If field_count is greater than or equal to binding_capacity:
                                    Set binding_capacity to binding_capacity multiplied by 2
                                    Set field_bindings to memory_reallocate(field_bindings, binding_capacity multiplied by 8)
                                End If

                                Note: Store binding name (field name not needed for now)
                                Let binding_offset be field_count multiplied by 8
                                memory_set_pointer(field_bindings, binding_offset, binding_name)
                                Set field_count to field_count plus 1

                                Note: Check for comma to continue or colon to end
                                Let next_binding_token be memory_get_pointer(parser, 8)
                                Let next_binding_type be memory_get_int32(next_binding_token, 0)
                                If next_binding_type is equal to 52:  Note: TOKEN_COMMA
                                    parser_eat(parser, 52)
                                Otherwise:
                                    Set continue_bindings to 0
                                End If
                            End While
                        Otherwise:
                            Note: Not a variant pattern, treat as literal expression
                            Note: Put the identifier back as an expression
                            Set pattern_value to expression_create_variable(variant_name)
                        End If
                    End If
                Otherwise:
                    Note: Parse as literal expression
                    Set pattern_value to parser_parse_expression(parser)
                End If

                parser_eat(parser, 9)  Note: Eat colon

                Note: Parse body statements
                Let body_count_ptr be memory_allocate(8)
                Let body_stmts be parser_parse_statement_block(parser, body_count_ptr)
                Let body_count be memory_get_integer(body_count_ptr, 0)
                deallocate(body_count_ptr)

                Note: Grow array if needed
                If when_count is greater than or equal to when_capacity:
                    Set when_capacity to when_capacity multiplied by 2
                    Set when_clauses to memory_reallocate(when_clauses, when_capacity multiplied by 48)
                End If

                Note: Store when clause (48 bytes)
                Let clause_offset be when_count multiplied by 48
                Let clause_ptr be when_clauses plus clause_offset
                memory_set_int32(clause_ptr, WHEN_PATTERN_TYPE, pattern_type)
                memory_set_pointer(clause_ptr, WHEN_PATTERN_VALUE, pattern_value)
                memory_set_pointer(clause_ptr, WHEN_FIELD_BINDINGS, field_bindings)
                memory_set_int32(clause_ptr, WHEN_FIELD_COUNT, field_count)
                memory_set_pointer(clause_ptr, WHEN_BODY_STMTS, body_stmts)
                memory_set_integer(clause_ptr, WHEN_BODY_COUNT, body_count)
                Set when_count to when_count plus 1
            Otherwise If token_type is equal to 8:  Note: TOKEN_END
                parser_eat(parser, 8)
                parser_eat(parser, 112)  Note: Eat TOKEN_MATCH
                Set continue_parsing to 0
            Otherwise:
                Set continue_parsing to 0
            End If
        End If
    End While

    Note: Exhaustiveness checking
    Note: Check if wildcard is present
    Let has_wildcard be 0
    Let wi be 0
    While wi is less than when_count:
        Let clause_offset be wi multiplied by 48
        Let clause_ptr be when_clauses plus clause_offset
        Let check_pattern_type be memory_get_int32(clause_ptr, WHEN_PATTERN_TYPE)
        If check_pattern_type is equal to 2:  Note: PATTERN_WILDCARD
            Set has_wildcard to 1
        End If
        Set wi to wi plus 1
    End While

    Note: If no wildcard, check for exhaustiveness on variant types
    If has_wildcard is equal to 0:
        Note: Collect all variant names from When clauses
        Let covered_variants_cap be 8
        Let covered_variants be memory_allocate(covered_variants_cap multiplied by 8)
        Let covered_count be 0

        Let ci be 0
        While ci is less than when_count:
            Let clause_offset be ci multiplied by 48
            Let clause_ptr be when_clauses plus clause_offset
            Let check_pattern_type be memory_get_int32(clause_ptr, WHEN_PATTERN_TYPE)

            If check_pattern_type is equal to 1:  Note: PATTERN_VARIANT
                Let variant_name_ptr be memory_get_pointer(clause_ptr, WHEN_PATTERN_VALUE)

                Note: Grow array if needed
                If covered_count is greater than or equal to covered_variants_cap:
                    Set covered_variants_cap to covered_variants_cap multiplied by 2
                    Set covered_variants to memory_reallocate(covered_variants, covered_variants_cap multiplied by 8)
                End If

                memory_set_pointer(covered_variants, covered_count multiplied by 8, variant_name_ptr)
                Set covered_count to covered_count plus 1
            End If
            Set ci to ci plus 1
        End While

        Note: If we have variant patterns, check exhaustiveness
        If covered_count is greater than 0:
            Note: Try to find the variant type definition to check all variants
            Let current_program be memory_get_pointer(parser, PARSER_CURRENT_PROGRAM_OFFSET)
            If current_program is equal to 0:
                Note: Program not set - skip exhaustiveness check
                Set covered_count to 0
            End If
            If current_program is not equal to 0:
                Let type_count be memory_get_int32(current_program, 24)
                Let types be memory_get_pointer(current_program, 16)

            Note: Find first covered variant to determine its parent type
            Let first_variant_name be memory_get_pointer(covered_variants, 0)
            Let found_type be 0
            Let total_variant_count be 0

            Let ti be 0
            While ti is less than type_count:
                Let type_ptr be memory_get_pointer_at_index(types, ti)
                Let type_kind be memory_get_int32(type_ptr, 8)

                If type_kind is equal to 1:  Note: TYPE_KIND_VARIANT
                    Let variant_count be memory_get_int32(type_ptr, 24)
                    Let variants be memory_get_pointer(type_ptr, 16)

                    Note: Check if this type contains our variant
                    Let vj be 0
                    While vj is less than variant_count:
                        Let variant_offset be vj multiplied by 32
                        Let variant_ptr be variants plus variant_offset
                        Let vname be memory_get_pointer(variant_ptr, 0)

                        If string_equals(vname, first_variant_name) is equal to 1:
                            Set found_type to type_ptr
                            Set total_variant_count to variant_count
                            Set ti to type_count  Note: Break outer loop
                            Set vj to variant_count  Note: Break inner loop
                        End If
                        Set vj to vj plus 1
                    End While
                End If
                Set ti to ti plus 1
            End While

            Note: If we found the type, check if all variants are covered
            If found_type is not equal to 0:
                Let variants be memory_get_pointer(found_type, 16)
                Let type_name be memory_get_pointer(found_type, 0)

                Note: Check each variant in the type
                Let missing_found be 0
                Let vi be 0
                While vi is less than total_variant_count:
                    Let variant_offset be vi multiplied by 32
                    Let variant_ptr be variants plus variant_offset
                    Let variant_name be memory_get_pointer(variant_ptr, 0)

                    Note: Check if this variant is covered
                    Let is_covered be 0
                    Let cj be 0
                    While cj is less than covered_count:
                        Let covered_name be memory_get_pointer(covered_variants, cj multiplied by 8)
                        If string_equals(variant_name, covered_name) is equal to 1:
                            Set is_covered to 1
                            Set cj to covered_count  Note: Break
                        End If
                        Set cj to cj plus 1
                    End While

                    If is_covered is equal to 0:
                        If missing_found is equal to 0:
                            print_string("[WARNING] Match on type '")
                            print_string(type_name)
                            print_string("' is not exhaustive. Missing variants:")
                            print_newline()
                            Set missing_found to 1
                        End If
                        print_string("  - ")
                        print_string(variant_name)
                        print_newline()
                    End If
                    Set vi to vi plus 1
                End While
            End If
            End If  Note: End if current_program is not equal to 0
        End If  Note: End if covered_count > 0

        deallocate(covered_variants)
    End If  Note: End if has_wildcard is equal to 0

    Note: Create match statement
    Let stmt be memory_allocate(32)
    memory_set_int32(stmt, 0, STMT_MATCH)
    memory_set_pointer(stmt, STMT_MATCH_EXPR, match_expr)
    memory_set_pointer(stmt, STMT_MATCH_WHEN_CLAUSES, when_clauses)
    memory_set_int32(stmt, STMT_MATCH_WHEN_COUNT, when_count)

    Return stmt
End Process

Note: Parser parse inline assembly statement - handles "Inline Assembly: ... End Assembly"
Note: NEW: Raw text mode - no string literals, no Note: comments, # comments allowed
Process called "parser_parse_inline_assembly_statement" takes parser as Integer returns Integer:
    Note: Inline Assembly:
    Note:     # This is an assembly comment
    Note:     movq $42, %rax
    Note:     syscall
    Note: End Assembly

    Let dummy1 be parser_eat(parser, 121)  Note: Eat "Inline"
    Let dummy2 be parser_eat(parser, 122)  Note: Eat "Assembly"

    Note: Don't eat ":" via parser - we need lexer to be right at it for raw reading
    Note: Get lexer from parser to read raw text
    Let lexer be memory_get_pointer(parser, 0)

    Note: Manually skip the ":" character
    Let colon_char be memory_get_byte(lexer, 20)  Note: Should be ':'
    Let dummy_colon be lexer_advance(lexer)

    Note: Allocate statement: type (4 bytes) + raw_text_ptr (8 bytes) + text_length (4 bytes) = 20 bytes
    Let stmt be allocate(32)
    Let stmt_type be 16  Note: STMT_INLINE_ASSEMBLY
    memory_set_int32(stmt, 0, stmt_type)

    Note: Read raw text until we hit "End Assembly"
    Let raw_text be parser_read_raw_assembly_until_end(parser, lexer)

    Note: Store raw text pointer and length
    Let text_length be string_length(raw_text)
    memory_set_pointer(stmt, 8, raw_text)
    memory_set_int32(stmt, 16, text_length)

    Note: After reading raw text, parser needs to get next token
    Note: The lexer has consumed up to and including "End Assembly"
    Note: We need to advance parser to next token after "End Assembly"
    Let dummy_advance be parser_advance(parser)

    Return stmt
End Process

Note: Read raw assembly text until "End Assembly" is encountered
Note: This reads character by character, preserving # comments and all whitespace
Process called "parser_read_raw_assembly_until_end" takes parser as Integer, lexer as Integer returns Integer:
    Note: Allocate buffer for raw text (max 8192 bytes)
    Let buffer_size be 8192
    Let buffer be allocate(buffer_size)
    Let buffer_pos be 0

    Note: Read characters until we see "End Assembly"
    Let continue_reading be 1
    While continue_reading is equal to 1:
        Let current_char be memory_get_byte(lexer, 20)  Note: lexer->current_char

        Note: Check for end of file
        If current_char is equal to 0:
            Set continue_reading to 0
        Otherwise:
            Note: Check if we're at potential "End Assembly"
            Let e_char be 69  Note: 'E'
            If current_char is equal to e_char:
                Note: Try to match "End Assembly"
                Let matches be parser_try_match_end_assembly(lexer)
                If matches is equal to 1:
                    Set continue_reading to 0
                Otherwise:
                    Note: Not "End Assembly", just store 'E' and continue
                    memory_set_byte(buffer, buffer_pos, current_char)
                    Set buffer_pos to buffer_pos plus 1
                    Let dummy be lexer_advance(lexer)
                End If
            Otherwise:
                Note: Regular character, store it
                memory_set_byte(buffer, buffer_pos, current_char)
                Set buffer_pos to buffer_pos plus 1
                Let dummy be lexer_advance(lexer)
            End If
        End If

        Note: Check buffer overflow
        If buffer_pos is greater than or equal to buffer_size minus 1:
            print_string("[PARSER ERROR] Inline assembly block too large (max 8192 bytes)\n")
            exit_with_code(1)
        End If
    End While

    Note: Null-terminate the buffer
    memory_set_byte(buffer, buffer_pos, 0)

    Note: Create final string
    Let final_string be string_duplicate_parser(buffer)
    deallocate(buffer)

    Return final_string
End Process

Note: Try to match "End Assembly" at current lexer position
Note: Returns 1 if match, 0 if not. Does NOT consume tokens if no match.
Process called "parser_try_match_end_assembly" takes lexer as Integer returns Integer:
    Note: Save current lexer position
    Let saved_pos be memory_get_integer(lexer, 0)  Note: lexer->position
    Let saved_char be memory_get_byte(lexer, 20)   Note: lexer->current_char

    Note: Try to match "End Assembly" (with optional whitespace)
    Note: Expected pattern: "End" + whitespace + "Assembly"

    Note: Match "End"
    Let matches_end be lexer_try_match_word(lexer, "End")
    If matches_end is equal to 0:
        Note: Restore position and return failure
        memory_set_integer(lexer, 0, saved_pos)
        memory_set_byte(lexer, 20, saved_char)
        Return 0
    End If

    Note: Skip whitespace
    Let dummy be lexer_skip_whitespace(lexer)

    Note: Match "Assembly"
    Let matches_assembly be lexer_try_match_word(lexer, "Assembly")
    If matches_assembly is equal to 0:
        Note: Restore position and return failure
        memory_set_integer(lexer, 0, saved_pos)
        memory_set_byte(lexer, 20, saved_char)
        Return 0
    End If

    Note: Success! Don't restore position, we consumed "End Assembly"
    Return 1
End Process

Note: Try to match a specific word at current position
Note: Returns 1 if match, 0 if not. Consumes characters on success.
Process called "lexer_try_match_word" takes lexer as Integer, word as Integer returns Integer:
    Let word_len be string_length(word)
    Let i be 0

    While i is less than word_len:
        Let expected_char be string_char_at(word, i)
        Let current_char be memory_get_byte(lexer, 20)

        If current_char is not equal to expected_char:
            Return 0
        End If

        Let dummy be lexer_advance(lexer)
        Set i to i plus 1
    End While

    Return 1
End Process

Note: Calculate size of a type in bytes (helper function)
Process called "calculate_type_size" takes type_name as Integer, program as Integer returns Integer:
    Note: Built-in types
    Let integer_str be "Integer"
    Let byte_str be "Byte"
    Let short_str be "Short"
    Let long_str be "Long"

    If string_equals(type_name, integer_str) is equal to 1:
        Return 8  Note: 64-bit integer
    Otherwise If string_equals(type_name, byte_str) is equal to 1:
        Return 1  Note: 8-bit byte
    Otherwise If string_equals(type_name, short_str) is equal to 1:
        Return 2  Note: 16-bit short
    Otherwise If string_equals(type_name, long_str) is equal to 1:
        Return 8  Note: 64-bit long
    End If

    Note: Custom types - look up in the program
    If program is not equal to 0:
        Let type_count be memory_get_int32(program, 24)
        Let types be memory_get_pointer(program, 16)
        Let i be 0
        Let continue_lookup be 1
        While continue_lookup is equal to 1:
            Let is_complete be 0
            If i is greater than or equal to type_count:
                Let is_complete be 1
            End If
            If is_complete is equal to 1:
                Let continue_lookup be 0
            End If
            If is_complete is equal to 0:
                Let ptr_size be 8
                Let offset be i multiplied by ptr_size
                Let type_ptr be types plus offset
                Let type_def be memory_get_pointer(type_ptr, 0)
                Let current_type_name be memory_get_pointer(type_def, 0)
                Let name_match be string_equals(current_type_name, type_name)
                If name_match is equal to 1:
                    Let type_size be memory_get_int32(type_def, 40)  Note: TypeDefinition.size offset
                    Return type_size
                End If
                Let i be i plus 1
            End If
        End While
    End If

    Note: Unknown type - default to 8 bytes and warn
    Let warning_msg be "[PARSER WARNING] Unknown type '"
    print_string(warning_msg)
    print_string(type_name)
    Let warning_msg2 be "', defaulting to 8 bytes"
    print_string(warning_msg2)
    print_newline()
    Return 8
End Process

Process called "parser_parse_type_definition" takes parser as Integer returns Integer:
    Note: Use global TypeDefinition and TypeField constants defined at top of file
    Note: TypeDefinition_SIZE = 48
    Note: TYPEFIELD_SIZE = 24

    Note: Parse: Type called "name": OR Type Name is
    parser_eat(parser, 50)

    Let type be memory_allocate(TypeDefinition_SIZE)

    Note: Check for "called" syntax for struct types
    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)

    If token_type is equal to 2:
        parser_eat(parser, 2)

        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
        If token_type is not equal to 10:
            print_string("[PARSER ERROR] Expected type name at line ")
            Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
            print_integer(line)
            print_newline()
            exit(1)
        End If

        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
        Let type_name be string_duplicate(token_value)
        memory_set_pointer(type, TYPEDEFINITION_NAME_OFFSET, type_name)
        parser_eat(parser, 10)
        parser_eat(parser, 9)

        Note: This is a struct type
        memory_set_int32(type, TYPEDEFINITION_KIND_OFFSET, TYPE_KIND_STRUCT)
        memory_set_pointer(type, TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET, 0)
        memory_set_int32(type, TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET, 0)
        Let current_offset be 0

        Note: Parse field declarations until "End Type"
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
        While token_type is not equal to 8:
            Note: Parse field: name as Type
            If token_type is not equal to 53:
                print_string("[PARSER ERROR] Expected field name at line ")
                Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                print_integer(line)
                print_string(" (got token type ")
                print_integer(token_type)
                print_string(")")
                print_newline()
                exit(1)
            End If

            Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
            Let field_name be string_duplicate(token_value)
            parser_eat(parser, 53)
            parser_eat(parser, 34)

            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
            If token_type is not equal to 4:
                If token_type is not equal to 5:
                    If token_type is not equal to 6:
                        If token_type is not equal to 53:
                            print_string("[PARSER ERROR] Expected field type at line ")
                            Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                            print_integer(line)
                            print_newline()
                            exit(1)
                        End If
                    End If
                End If
            End If

            Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
            Let field_type be string_duplicate(token_value)
            If token_type is equal to 4:
                parser_eat(parser, 4)
            End If
            If token_type is equal to 5:
                parser_eat(parser, 5)
            End If
            If token_type is equal to 6:
                parser_eat(parser, 6)
            End If
            If token_type is equal to 53:
                parser_eat(parser, 53)
            End If

            Note: Check for comma after field declaration (optional for last field)
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
            If token_type is equal to 52:
                parser_eat(parser, 52)
            End If

            Note: Add field to type
            Let field_count be memory_get_integer(type, TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET)
            Let new_field_count be field_count plus 1
            memory_set_int32(type, TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET, new_field_count)

            Let fields be memory_get_pointer(type, TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET)
            Let new_fields_size be new_field_count multiplied by TYPEFIELD_SIZE
            Let new_fields be 0
            If fields is equal to 0:
                Set new_fields to memory_allocate(new_fields_size)
            Otherwise:
                Set new_fields to memory_reallocate(fields, new_fields_size)
            End If
            memory_set_pointer(type, TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET, new_fields)

            Let field_index be new_field_count minus 1
            Let field_offset be field_index multiplied by TYPEFIELD_SIZE
            Let field be new_fields plus field_offset
            memory_set_pointer(field, TYPEFIELD_NAME_OFFSET, field_name)
            memory_set_pointer(field, TYPEFIELD_TYPE_OFFSET, field_type)
            memory_set_int32(field, TYPEFIELD_OFFSET_OFFSET, current_offset)

            Note: Calculate field size based on type
            Let current_program be memory_get_pointer(parser, PARSER_CURRENT_PROGRAM_OFFSET)
            Let field_size be calculate_type_size(field_type, current_program)
            memory_set_int32(field, TYPEFIELD_SIZE_OFFSET, field_size)
            Let current_offset be current_offset plus field_size

            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
        End While

        memory_set_int32(type, TYPEDEFINITION_SIZE_OFFSET, current_offset)

        parser_eat(parser, 8)
        parser_eat(parser, 50)
        Return type
    End If

    Note: Refresh current token after TOKEN_CALLED processing
    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)

    Note: Check for variant syntax: Type Name is | Variant1 ...
    If token_type is equal to 53:
        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
        Let type_name be string_duplicate(token_value)
        memory_set_pointer(type, TYPEDEFINITION_NAME_OFFSET, type_name)
        parser_eat(parser, 53)
        parser_eat(parser, 21)
        parser_eat(parser, 9)  Note: Require colon after "is"

        Note: Now check what kind of type definition follows the colon
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)

        Note: Array type: Type X is: array [size] of ElementType
        If token_type is equal to 126:
            parser_eat(parser, 126)
            parser_eat(parser, 127)

            Note: Parse array size
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
            If token_type is not equal to 11:
                print_string("[PARSER ERROR] Expected array size at line ")
                Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                print_integer(line)
                print_newline()
                exit(1)
            End If
            Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
            Let array_length be string_to_integer(token_value)
            parser_eat(parser, 11)
            parser_eat(parser, 128)
            parser_eat(parser, 125)

            Note: Parse element type
            Let element_type be 0
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
            If token_type is equal to 4:
                Let element_type be string_duplicate("Integer")
                parser_eat(parser, 4)
            End If
            If token_type is equal to 5:
                Let element_type be string_duplicate("String")
                parser_eat(parser, 5)
            End If
            If token_type is equal to 6:
                Let element_type be string_duplicate("Character")
                parser_eat(parser, 6)
            End If
            If token_type is equal to 53:
                Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
                Let element_type be string_duplicate(token_value)
                parser_eat(parser, 53)
            End If
            If element_type is equal to 0:
                print_string("[PARSER ERROR] Expected element type at line ")
                Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                print_integer(line)
                print_newline()
                exit(1)
            End If

            Note: Setup array type
            memory_set_int32(type, TYPEDEFINITION_KIND_OFFSET, TYPE_KIND_ARRAY)
            memory_set_pointer(type, TYPEDEFINITION_DATA_ARRAY_ELEMENT_TYPE_OFFSET, element_type)
            memory_set_int32(type, TYPEDEFINITION_DATA_ARRAY_LENGTH_OFFSET, array_length)

            Note: Calculate element size (8 bytes for Integer, custom types handled separately)
            memory_set_int32(type, TYPEDEFINITION_DATA_ARRAY_ELEMENT_SIZE_OFFSET, 8)
            Let total_size be array_length multiplied by 8
            memory_set_int32(type, TYPEDEFINITION_SIZE_OFFSET, total_size)

            Note: Parse "End Type" after array type definition
            parser_eat(parser, 8)
            parser_eat(parser, 50)
        Otherwise If token_type is equal to 124:
            Note: Function pointer type: Type X is: Pointer to Process ...
            parser_eat(parser, 124)
            parser_eat(parser, 15)
            parser_eat(parser, 1)

            Note: This is a function pointer type
            memory_set_int32(type, TYPEDEFINITION_KIND_OFFSET, TYPE_KIND_FUNCTION)
            memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_PARAM_TYPES_OFFSET, 0)
            memory_set_int32(type, TYPEDEFINITION_DATA_FUNCTION_PARAM_COUNT_OFFSET, 0)
            memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_RETURN_TYPE_OFFSET, 0)
            memory_set_int32(type, TYPEDEFINITION_SIZE_OFFSET, 8)  Note: Pointer size on x86_64

            Note: Parse optional parameters: [that] takes param1 as Type1, param2 as Type2
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
            If token_type is equal to 32:
                parser_eat(parser, 32)
                parser_eat(parser, 33)
            End If
            If token_type is equal to 33:
                parser_eat(parser, 33)
            End If

            Note: Parse parameters if we have takes
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
            If token_type is equal to 53:
                Let param_capacity be 2
                Let param_types be memory_allocate(param_capacity multiplied by 8)  Note: Array of char* pointers
                memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_PARAM_TYPES_OFFSET, param_types)

                Let continue_parsing be 1
                While continue_parsing is equal to 1:
                    Note: Skip parameter name (we only store types for function pointers)
                    If token_type is equal to 53:
                        parser_eat(parser, 53)
                        parser_eat(parser, 34)
                    End If

                    Note: Get parameter type
                    Let param_type be 0
                    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                    Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
                    If token_type is equal to 4:
                        Let param_type be string_duplicate("Integer")
                        parser_eat(parser, 4)
                    End If
                    If token_type is equal to 5:
                        Let param_type be string_duplicate("String")
                        parser_eat(parser, 5)
                    End If
                    If token_type is equal to 6:
                        Let param_type be string_duplicate("Character")
                        parser_eat(parser, 6)
                    End If
                    If token_type is equal to 53:
                        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
                        Let param_type be string_duplicate(token_value)
                        parser_eat(parser, 53)
                    End If
                    If param_type is equal to 0:
                        print_string("[PARSER ERROR] Expected parameter type at line ")
                        Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                        print_integer(line)
                        print_newline()
                        exit(1)
                    End If

                    Note: Expand array if needed
                    Let param_count be memory_get_integer(type, TYPEDEFINITION_DATA_FUNCTION_PARAM_COUNT_OFFSET)
                    If param_count is greater than or equal to param_capacity:
                        Let param_capacity be param_capacity multiplied by 2
                        Let new_param_types be memory_reallocate(param_types, param_capacity multiplied by 8)
                        memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_PARAM_TYPES_OFFSET, new_param_types)
                        Let param_types be new_param_types
                    End If

                    Let param_offset be param_count multiplied by 8
                    memory_set_pointer(param_types plus param_offset, 0, param_type)
                    Let new_param_count be param_count plus 1
                    memory_set_int32(type, TYPEDEFINITION_DATA_FUNCTION_PARAM_COUNT_OFFSET, new_param_count)

                    Note: Check for more parameters (comma or 'and')
                    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                    Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
                    If token_type is equal to 52:
                        parser_eat(parser, 52)
                    End If
                    If token_type is equal to 30:
                        parser_eat(parser, 30)
                    Otherwise:
                        Let continue_parsing be 0
                    End If
                End While
            End If

            Note: Parse return type: returns Type
            parser_eat(parser, 3)
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
            If token_type is equal to 4:
                Let return_type be string_duplicate("Integer")
                memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_RETURN_TYPE_OFFSET, return_type)
                parser_eat(parser, 4)
            End If
            If token_type is equal to 5:
                Let return_type be string_duplicate("String")
                memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_RETURN_TYPE_OFFSET, return_type)
                parser_eat(parser, 5)
            End If
            If token_type is equal to 6:
                Let return_type be string_duplicate("Character")
                memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_RETURN_TYPE_OFFSET, return_type)
                parser_eat(parser, 6)
            End If
            If token_type is equal to 53:
                Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
                Let return_type be string_duplicate(token_value)
                memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_RETURN_TYPE_OFFSET, return_type)
                parser_eat(parser, 53)
            Otherwise:
                print_string("[PARSER ERROR] Expected return type at line ")
                Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                print_integer(line)
                print_newline()
                exit(1)
            End If

            Note: Parse "End Type" after function pointer type definition
            parser_eat(parser, 8)
            parser_eat(parser, 50)
        Otherwise:
            Note: Otherwise this is a variant type
            memory_set_int32(type, TYPEDEFINITION_KIND_OFFSET, TYPE_KIND_VARIANT)
            memory_set_pointer(type, TYPEDEFINITION_DATA_VARIANT_VARIANTS_OFFSET, 0)
            memory_set_int32(type, TYPEDEFINITION_DATA_VARIANT_VARIANT_COUNT_OFFSET, 0)

            Note: Parse variants
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
            While token_type is equal to 111:
                parser_eat(parser, 111)

                Note: Parse variant name
                Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)

                Note: CRITICAL: Read token_value BEFORE any memory operations that could invalidate the token!
                Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)

                If token_type is not equal to 53:
                    print_string("[PARSER ERROR] Expected variant name at line ")
                    Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                    print_integer(line)
                    print_newline()
                    exit(1)
                End If

                Note: Add variant
                Let variant_count be memory_get_int32(type, TYPEDEFINITION_DATA_VARIANT_VARIANT_COUNT_OFFSET)
                Let new_variant_count be variant_count plus 1
                memory_set_int32(type, TYPEDEFINITION_DATA_VARIANT_VARIANT_COUNT_OFFSET, new_variant_count)

                Let variants be memory_get_pointer(type, TYPEDEFINITION_DATA_VARIANT_VARIANTS_OFFSET)
                Let new_variants_size be new_variant_count multiplied by VARIANT_SIZE
                Let new_variants be memory_reallocate(variants, new_variants_size)
                memory_set_pointer(type, TYPEDEFINITION_DATA_VARIANT_VARIANTS_OFFSET, new_variants)

                Let variant_index be new_variant_count minus 1
                Let variant_offset be variant_index multiplied by VARIANT_SIZE
                Let variant be new_variants plus variant_offset
                Let tag be new_variant_count minus 1  Note: Tag is 0-based index
                Let variant_name be string_duplicate_parser(token_value)  Note: FIX: Use parser string duplicate!
                memory_set_pointer(variant, VARIANT_NAME_OFFSET, variant_name)
                memory_set_pointer(variant, VARIANT_FIELDS_OFFSET, 0)
                memory_set_int32(variant, VARIANT_FIELD_COUNT_OFFSET, 0)
                memory_set_int32(variant, VARIANT_TAG_OFFSET, tag)

                parser_eat(parser, 53)

                Note: Parse optional variant fields
                Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
                If token_type is equal to 114:
                    parser_eat(parser, 114)

                    Let field_offset be 8  Note: Start after tag (8 bytes for tag)

                    Note: Parse fields: field1 as Type1 and field2 as Type2...
                    Let continue_parsing be 1
                    While continue_parsing is equal to 1:
                        Note: Parse field name
                        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                        Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
                        If token_type is not equal to 53:
                            print_string("[PARSER ERROR] Expected field name in variant at line ")
                            Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                            print_integer(line)
                            print_newline()
                            exit(1)
                        End If

                        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
                        Let field_name be string_duplicate(token_value)
                        parser_eat(parser, 53)
                        parser_eat(parser, 34)

                        Note: Parse field type
                        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                        Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
                        If token_type is not equal to 4:
                            If token_type is not equal to 5:
                                If token_type is not equal to 6:
                                    If token_type is not equal to 53:
                                        print_string("[PARSER ERROR] Expected field type at line ")
                                        Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                                        print_integer(line)
                                        print_newline()
                                        exit(1)
                                    End If
                                End If
                            End If
                        End If

                        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
                        Let field_type be string_duplicate(token_value)
                        If token_type is equal to 4:
                            parser_eat(parser, 4)
                        End If
                        If token_type is equal to 5:
                            parser_eat(parser, 5)
                        End If
                        If token_type is equal to 6:
                            parser_eat(parser, 6)
                        End If
                        If token_type is equal to 53:
                            parser_eat(parser, 53)
                        End If

                        Note: Add field to variant
                        Let variant_field_count be memory_get_int32(variant, VARIANT_FIELD_COUNT_OFFSET)
                        Let new_variant_field_count be variant_field_count plus 1
                        memory_set_int32(variant, VARIANT_FIELD_COUNT_OFFSET, new_variant_field_count)

                        Let variant_fields be memory_get_pointer(variant, VARIANT_FIELDS_OFFSET)
                        Let new_variant_fields_size be new_variant_field_count multiplied by TYPEFIELD_SIZE
                        Let new_variant_fields be memory_reallocate(variant_fields, new_variant_fields_size)
                        memory_set_pointer(variant, VARIANT_FIELDS_OFFSET, new_variant_fields)

                        Let variant_field_index be new_variant_field_count minus 1
                        Let variant_field_offset be variant_field_index multiplied by TYPEFIELD_SIZE
                        Let field be new_variant_fields plus variant_field_offset
                        memory_set_pointer(field, TYPEFIELD_NAME_OFFSET, field_name)
                        memory_set_pointer(field, TYPEFIELD_TYPE_OFFSET, field_type)
                        memory_set_int32(field, TYPEFIELD_OFFSET_OFFSET, field_offset)

                        Let current_program be memory_get_pointer(parser, PARSER_CURRENT_PROGRAM_OFFSET)
                        Let field_size be calculate_type_size(field_type, current_program)
                        memory_set_int32(field, TYPEFIELD_SIZE_OFFSET, field_size)
                        Let field_offset be field_offset plus field_size

                        Note: Check for "and" to continue with more fields
                        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                        Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
                        If token_type is equal to 30:
                            parser_eat(parser, 30)
                        Otherwise:
                            Let continue_parsing be 0
                        End If
                    End While
                End If

                Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
            End While

            Note: Calculate max size needed for any variant
            memory_set_int32(type, TYPEDEFINITION_SIZE_OFFSET, 8)  Note: At least tag size
            Let variant_count be memory_get_int32(type, TYPEDEFINITION_DATA_VARIANT_VARIANT_COUNT_OFFSET)
            Let variants be memory_get_pointer(type, TYPEDEFINITION_DATA_VARIANT_VARIANTS_OFFSET)
            Let i be 0
            While i is less than variant_count:
                Let variant_offset be i multiplied by VARIANT_SIZE
                Let variant be variants plus variant_offset
                Let variant_size be 8  Note: Tag size
                Let variant_field_count be memory_get_int32(variant, VARIANT_FIELD_COUNT_OFFSET)
                Let variant_fields be memory_get_pointer(variant, VARIANT_FIELDS_OFFSET)
                Let j be 0
                While j is less than variant_field_count:
                    Let field_offset be j multiplied by TYPEFIELD_SIZE
                    Let field be variant_fields plus field_offset
                    Let field_size be memory_get_int32(field, TYPEFIELD_SIZE_OFFSET)
                    Let variant_size be variant_size plus field_size
                    Let j be j plus 1
                End While
                Let current_type_size be memory_get_int32(type, TYPEDEFINITION_SIZE_OFFSET)
                If variant_size is greater than current_type_size:
                    memory_set_int32(type, TYPEDEFINITION_SIZE_OFFSET, variant_size)
                End If
                Let i be i plus 1
            End While

            Note: Parse "End Type" after variant type definition
            parser_eat(parser, 8)
            parser_eat(parser, 50)
        End If
    Otherwise:
        print_string("[PARSER ERROR] Expected 'called' or type name after 'Type' at line ")
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
        print_newline()
        exit(1)
    End If

    Return type
End Process

Process called "parser_parse_function" takes parser as Integer returns Integer:
    Note: Parse: Process called "name" [that takes param as Type] returns Type:
    parser_eat(parser, 1)
    parser_eat(parser, 2)

    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
    If token_type is not equal to 10:
        print_string("[PARSER ERROR] Expected function name string literal (type ")
        print_integer(10)
        print_string("), got type ")
        print_integer(token_type)
        print_string(" at line ")
        Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
        print_integer(line)
        print_newline()
        exit(1)
    End If

    Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
    If token_value is equal to 0:
        print_string("[PARSER ERROR] Function name is NULL!")
        exit(1)
    End If
    Let func_name be string_duplicate(token_value)
    parser_eat(parser, 10)

    Let default_return_type be string_duplicate("Integer")
    Let func be function_create(func_name, default_return_type)

    Note: Check for parameters: "takes param as Type" or "takes x as Type, y as Type"
    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
    If token_type is equal to 33:
        parser_eat(parser, 33)

        Note: Parse first parameter
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
        Let can_be_id be token_can_be_identifier(token_type)
        If can_be_id is not equal to 1:
            print_string("[PARSER ERROR] Expected parameter name at line ")
            Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
            print_integer(line)
            print_newline()
            exit(1)
        End If

        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
        Let param_name be string_duplicate(token_value)
        parser_eat(parser, token_type)
        parser_eat(parser, 34)

        Note: Accept built-in types or custom type names (for function pointers and structs)
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
        If token_type is not equal to 4:
            If token_type is not equal to 5:
                If token_type is not equal to 6:
                    If token_type is not equal to 53:
                        print_string("[PARSER ERROR] Expected parameter type at line ")
                        Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
                        print_integer(line)
                        print_newline()
                        exit(1)
                    End If
                End If
            End If
        End If

        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
        Let param_type be string_duplicate(token_value)
        If token_type is equal to 4:
            parser_eat(parser, 4)
        End If
        If token_type is equal to 5:
            parser_eat(parser, 5)
        End If
        If token_type is equal to 6:
            parser_eat(parser, 6)
        End If
        If token_type is equal to 53:
            Note: Custom type name (struct, variant, or function pointer)
            parser_eat(parser, 53)
        End If

        function_add_parameter(func, param_name, param_type)

        Note: Parse additional parameters separated by commas
        Let loop_current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let loop_token_type be memory_get_int32(loop_current_token, TOKEN_TYPE_OFFSET)
        While loop_token_type is equal to 52:
            parser_eat(parser, 52)

            Let param_current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let param_token_type be memory_get_int32(param_current_token, TOKEN_TYPE_OFFSET)
            Let param_can_be_id be token_can_be_identifier(param_token_type)
            If param_can_be_id is not equal to 1:
                print_string("[PARSER ERROR] Expected parameter name after comma at line ")
                Let param_line be memory_get_int32(param_current_token, TOKEN_LINE_OFFSET)
                print_integer(param_line)
                print_newline()
                exit(1)
            End If

            Let param_token_value be memory_get_pointer(param_current_token, TOKEN_VALUE_OFFSET)
            Let param_name be string_duplicate(param_token_value)
            parser_eat(parser, param_token_type)
            parser_eat(parser, 34)

            Note: Accept built-in types or custom type names (for function pointers and structs)
            Let paramtype_current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let paramtype_token_type be memory_get_int32(paramtype_current_token, TOKEN_TYPE_OFFSET)
            If paramtype_token_type is not equal to 4:
                If paramtype_token_type is not equal to 5:
                    If paramtype_token_type is not equal to 6:
                        If paramtype_token_type is not equal to 53:
                            print_string("[PARSER ERROR] Expected parameter type at line ")
                            Let paramtype_line be memory_get_int32(paramtype_current_token, TOKEN_LINE_OFFSET)
                            print_integer(paramtype_line)
                            print_newline()
                            exit(1)
                        End If
                    End If
                End If
            End If

            Let paramtype_token_value be memory_get_pointer(paramtype_current_token, TOKEN_VALUE_OFFSET)
            Let param_type be string_duplicate(paramtype_token_value)
            If paramtype_token_type is equal to 4:
                parser_eat(parser, 4)
            End If
            If paramtype_token_type is equal to 5:
                parser_eat(parser, 5)
            End If
            If paramtype_token_type is equal to 6:
                parser_eat(parser, 6)
            End If
            If paramtype_token_type is equal to 53:
                Note: Custom type name (struct, variant, or function pointer)
                parser_eat(parser, 53)
            End If

            function_add_parameter(func, param_name, param_type)

            Let loop_current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let loop_token_type be memory_get_int32(loop_current_token, TOKEN_TYPE_OFFSET)
        End While
    End If

    parser_eat(parser, 3)

    Note: Handle different return types
    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
    Let type_handled be 0
    If token_type is equal to 4:
        parser_eat(parser, 4)
        Let type_handled be 1
    Otherwise If token_type is equal to 5:
        parser_eat(parser, 5)
        Let type_handled be 1
    Otherwise If token_type is equal to 6:
        parser_eat(parser, 6)
        Let type_handled be 1
    Otherwise If token_type is equal to 53:
        Note: Custom type
        parser_eat(parser, 53)
        Let type_handled be 1
    End If
    If type_handled is equal to 0:
        print_string("[PARSER ERROR] Expected return type at line ")
        Let line be memory_get_int32(current_token, TOKEN_LINE_OFFSET)
        print_integer(line)
        print_newline()
        exit(1)
    End If

    parser_eat(parser, 9)

    Note: Parse function body statements
    Let body_current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let body_token_type be memory_get_int32(body_current_token, TOKEN_TYPE_OFFSET)
    While body_token_type is not equal to 7:
        If body_token_type is equal to 8:
            Note: Exit if we hit End Process before Return
            Break
        End If
        If body_token_type is equal to 0:
            Break
        End If

        Let stmt be 0

        If body_token_type is equal to 12:
            Set stmt to parser_parse_let_statement(parser)  Note: Changed from Let to Set
        End If
        If body_token_type is equal to 14:
            Set stmt to parser_parse_set_statement(parser)  Note: Changed from Let to Set
        End If
        If body_token_type is equal to 18:
            Set stmt to parser_parse_if_statement(parser)  Note: Changed from Let to Set
        End If
        If body_token_type is equal to 20:
            Set stmt to parser_parse_while_statement(parser)  Note: Changed from Let to Set
        End If
        If body_token_type is equal to 112:
            Set stmt to parser_parse_match_statement(parser)  Note: Changed from Let to Set
        End If
        If body_token_type is equal to 47:
            Set stmt to parser_parse_print_statement(parser)  Note: Changed from Let to Set
        End If
        If body_token_type is equal to 121:
            Set stmt to parser_parse_inline_assembly_statement(parser)  Note: Changed from Let to Set
        End If
        If body_token_type is equal to 143:  Note: TOKEN_FOR
            Set stmt to parser_parse_for_range_statement(parser)
        End If
        If body_token_type is equal to 139:  Note: TOKEN_INCREASE
            Set stmt to parser_parse_implicit_compound_assign(parser, 0)
        End If
        If body_token_type is equal to 140:  Note: TOKEN_DECREASE
            Set stmt to parser_parse_implicit_compound_assign(parser, 1)
        End If
        If body_token_type is equal to 141:  Note: TOKEN_MULTIPLY
            Set stmt to parser_parse_implicit_compound_assign(parser, 2)
        End If
        If body_token_type is equal to 142:  Note: TOKEN_DIVIDE
            Set stmt to parser_parse_implicit_compound_assign(parser, 3)
        End If
        If body_token_type is equal to 53:
            Note: Try to parse as expression (could be a function call)
            Let expr be parser_parse_expression(parser)
            Note: Only function calls are valid as standalone statements
            Let expr_type be memory_get_integer(expr, EXPRESSION_TYPE_OFFSET)
            If expr_type is equal to EXPR_FUNCTION_CALL:
                Set stmt to statement_create_expression(expr)  Note: Changed from Let to Set
            Otherwise:
                Note: Other expressions are not valid as statements
                print_string("[PARSER ERROR] Only function calls can be used as statements (got expr_type=")
                print_integer(expr_type)
                print_string(", expected ")
                print_integer(EXPR_FUNCTION_CALL)
                print_string(") at line ")
                Let error_line be memory_get_int32(body_current_token, TOKEN_LINE_OFFSET)
                print_integer(error_line)
                print_newline()
                exit(1)
            End If
        End If

        Let is_builtin be parser_is_builtin_function_token(body_token_type)
        If is_builtin is equal to 1:
            Note: Parse builtin function call as expression statement
            Let expr be parser_parse_expression(parser)
            Let expr_type be memory_get_integer(expr, EXPRESSION_TYPE_OFFSET)
            If expr_type is equal to EXPR_BUILTIN_CALL:
                Set stmt to statement_create_expression(expr)  Note: Changed from Let to Set
            Otherwise:
                print_string("[PARSER ERROR] Invalid builtin function statement at line ")
                Let builtin_error_line be memory_get_int32(body_current_token, TOKEN_LINE_OFFSET)
                print_integer(builtin_error_line)
                print_newline()
                exit(1)
            End If
        End If

        If stmt is equal to 0:
            print_string("[PARSER ERROR] Unexpected token ")
            print_integer(body_token_type)
            print_string(" in function body at line ")
            Let stmt_error_line be memory_get_int32(body_current_token, TOKEN_LINE_OFFSET)
            print_integer(stmt_error_line)
            print_newline()
            exit(1)
        End If

        function_add_statement(func, stmt)

        Let body_current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let body_token_type be memory_get_int32(body_current_token, TOKEN_TYPE_OFFSET)
    End While

    Note: Parse Return statement
    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
    If token_type is equal to 7:
        Let return_stmt be parser_parse_return_statement(parser)
        function_add_statement(func, return_stmt)
    End If

    Note: Parse: End Process
    parser_eat(parser, 8)
    parser_eat(parser, 1)

    Return func
End Process

Note: Size constants for structures
Let SIZEOF_PARSER be 24
Let SIZEOF_PROGRAM be 64

Note: Offsets for parser structure
Let PARSER_LEXER be 0           Note: Lexer *lexer
Let PARSER_CURRENT_TOKEN be 8   Note: Token *current_token
Note: PARSER_CURRENT_PROGRAM_OFFSET defined at top of file

Note: Program structure offsets already defined at the top of file

Note: Token structure offsets
Let TOKEN_TYPE_OFFSET be 0      Note: TokenType type
Let TOKEN_VALUE_OFFSET be 8     Note: char *value
Let TOKEN_LINE_OFFSET be 16     Note: int line_number

Note: Additional expression types missing
Let EXPR_UNARY be 11
Let EXPR_BINARY be 2  Note: Alias for EXPR_BINARY_OP
Let EXPR_CALL be 4    Note: Alias for EXPR_FUNCTION_CALL
Let EXPR_ARRAY_ACCESS be 16  Note: Alias for EXPR_ARRAY_INDEX
Let EXPR_IDENTIFIER be 1     Note: Alias for EXPR_VARIABLE

Note: Statement types already defined above

Note: Statement structure offsets
Let STMT_TYPE be 0
Let STMT_LET_NAME be 8
Let STMT_LET_VALUE be 16
Let STMT_LET_TYPE be 24
Let STMT_SET_NAME be 8
Let STMT_SET_VALUE be 16
Let STMT_IF_CONDITION be 8
Let STMT_IF_THEN_BODY be 16
Let STMT_IF_ELSE_BODY be 24
Let STMT_WHILE_CONDITION be 8
Let STMT_WHILE_BODY be 16
Let STMT_FOR_VAR be 8
Let STMT_FOR_START be 16
Let STMT_FOR_END be 24
Let STMT_FOR_BODY be 32
Let STMT_RETURN_VALUE be 8
Let STMT_EXPR_VALUE be 8

Note: Expression structure offsets
Let EXPR_TYPE be 0
Let EXPR_BINARY_LEFT be 8
Let EXPR_BINARY_RIGHT be 16
Let EXPR_UNARY_OPERAND be 8
Let EXPR_CALL_NAME be 8
Let EXPR_CALL_ARGS be 16
Let EXPR_FIELD_OBJECT be 8
Let EXPR_FIELD_NAME be 16
Let EXPR_ARRAY_OBJECT be 8
Let EXPR_ARRAY_INDEX_OFFSET be 16  Note: Renamed to avoid collision with EXPR_ARRAY_INDEX constant
Let EXPR_IDENTIFIER_NAME be 8
Let EXPR_STRING_VALUE be 8

Note: Type kinds for destroy functions
Let TYPE_PRIMITIVE be 0
Let TYPE_STRUCT be 1
Let TYPE_ARRAY be 2
Let TYPE_POINTER be 3

Note: Type structure offsets
Let TYPE_KIND be 0
Let TYPE_STRUCT_NAME be 8
Let TYPE_STRUCT_FIELDS be 16
Let TYPE_ARRAY_ELEMENT_TYPE be 8
Let TYPE_POINTER_TARGET_TYPE be 8

Note: Function structure offsets
Let FUNCTION_NAME be 0
Let FUNCTION_PARAMETERS be 8
Let FUNCTION_RETURN_TYPE be 16
Let FUNCTION_BODY be 24

Note: parser_create - Create new parser instance
Process called "parser_create" takes lexer as Integer returns Integer:
    Let parser be memory_allocate(SIZEOF_PARSER)
    memory_set_pointer(parser, PARSER_LEXER, lexer)
    Let first_token be lexer_next_token(lexer)
    If first_token is equal to 0:
        print_string("[ERROR] lexer_next_token returned NULL!")
    End If
    memory_set_pointer(parser, PARSER_CURRENT_TOKEN, first_token)
    Return parser
End Process

Note: parser_destroy - Destroy parser instance
Process called "parser_destroy" takes parser as Integer returns Integer:
    deallocate(parser)
    Return 0
End Process

Note: parser_parse_program - Main program parsing function
Process called "parser_parse_program" takes parser as Integer returns Integer:
    Let program be memory_allocate(SIZEOF_PROGRAM)
    Let test_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let test_type be memory_get_int32(test_token, TOKEN_TYPE_OFFSET)
    If test_type is equal to 0:
        print_string("[ERROR] First token is already EOF!")
    End If
    Note: Initialize pointers to NULL (0) - they will be allocated when needed
    memory_set_pointer(program, PROGRAM_IMPORTS, 0)
    memory_set_pointer(program, PROGRAM_TYPES, 0)
    memory_set_pointer(program, PROGRAM_FUNCTIONS, 0)
    memory_set_pointer(program, PROGRAM_GLOBAL_VARS, 0)

    Note: Initialize all count fields to 0
    memory_set_int32(program, PROGRAM_FUNCTION_COUNT, 0)
    memory_set_int32(program, PROGRAM_TYPE_COUNT, 0)
    memory_set_int32(program, PROGRAM_IMPORT_COUNT, 0)
    memory_set_int32(program, PROGRAM_GLOBAL_COUNT, 0)

    Note: Initialize all capacity fields to 0
    memory_set_int32(program, PROGRAM_FUNCTION_CAPACITY, 0)
    memory_set_int32(program, PROGRAM_TYPE_CAPACITY, 0)
    memory_set_int32(program, PROGRAM_IMPORT_CAPACITY, 0)
    memory_set_int32(program, PROGRAM_GLOBAL_CAPACITY, 0)

    Note: Set current program for type lookups
    memory_set_pointer(parser, PARSER_CURRENT_PROGRAM_OFFSET, program)

    Note: Parse imports, type definitions, and functions until EOF
    Note: Use goto-style loop to avoid If statements inside While
    Let continue_parsing be 1
    While continue_parsing is equal to 1:
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        If current_token is equal to 0:
            print_string("[ERROR] current_token is NULL!")
            Return 0
        End If
        Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)

        Note: Check if EOF
        Let is_eof be 0
        If token_type is equal to 0:
            Let is_eof be 1
        End If
        If is_eof is equal to 1:
            Let continue_parsing be 0
        End If

        Note: Process tokens when not EOF
        If is_eof is equal to 0:
            Note: Handle TOKEN_IMPORT
            Let is_import be 0
            If token_type is equal to 56:
                Let is_import be 1
            End If
            If is_import is equal to 1:
                Let import_stmt be parser_parse_import(parser)
                If import_stmt is equal to 0:
                    print_string("[ERROR] parser_parse_import returned NULL!")
                    Return 0
                End If
                program_add_import(program, import_stmt)
            End If

            Note: Handle TOKEN_TYPE
            Let is_type be 0
            If token_type is equal to 50:
                Let is_type be 1
            End If
            If is_type is equal to 1:
                Let type_def be parser_parse_type_definition(parser)
                program_add_type(program, type_def)
            End If

            Note: Handle TOKEN_PROCESS
            Let is_process be 0
            If token_type is equal to 1:
                Let is_process be 1
            End If
            If is_process is equal to 1:
                Let func be parser_parse_function(parser)
                If func is equal to 0:
                    print_string("[ERROR] parser_parse_function returned NULL!")
                    Return 0
                End If
                program_add_function(program, func)
            End If

            Note: Handle TOKEN_LET (global constants) - parse and store them properly
            Let is_let be 0
            If token_type is equal to 12:
                Let is_let be 1
            End If
            If is_let is equal to 1:
                parser_eat(parser, 12)  Note: Eat 'Let'
                Let global_current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                Let global_token_type be memory_get_int32(global_current_token, TOKEN_TYPE_OFFSET)

                If global_token_type is equal to 53:  Note: identifier
                    Let var_name be string_duplicate_parser(memory_get_pointer(global_current_token, TOKEN_VALUE_OFFSET))
                    parser_eat(parser, 53)

                    Let global_be_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                    Let global_be_type be memory_get_int32(global_be_token, TOKEN_TYPE_OFFSET)
                    If global_be_type is equal to 13:  Note: 'be'
                        parser_eat(parser, 13)

                        Let global_value_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                        Let global_value_type be memory_get_int32(global_value_token, TOKEN_TYPE_OFFSET)
                        If global_value_type is equal to 11:  Note: TOKEN_INTEGER
                            Let value_str be memory_get_pointer(global_value_token, TOKEN_VALUE_OFFSET)
                            Let int_value be string_to_integer(value_str)
                            Let initial_value be expression_create_integer(int_value)
                            parser_eat(parser, 11)

                            Note: Create global variable entry using exact GlobalVariable struct layout
                            Note: GlobalVariable: name(0), type(8), initial_value(16) - total 24 bytes
                            Let global be memory_allocate(24)
                            memory_set_pointer(global, 0, var_name)
                            memory_set_pointer(global, 8, string_duplicate_parser("Integer"))
                            memory_set_pointer(global, 16, initial_value)
                            program_add_global(program, global)
                        End If
                    End If
                End If
            End If


            Note: Handle unknown token
            Let handled_token be 0
            If is_import is equal to 1:
                Let handled_token be 1
            End If
            If is_type is equal to 1:
                Let handled_token be 1
            End If
            If is_process is equal to 1:
                Let handled_token be 1
            End If
            If is_let is equal to 1:
                Let handled_token be 1
            End If
            If handled_token is equal to 0:
                Note: parser_error_with_token(parser, "Unexpected token at top level", current_token)
                Return 0
            End If
        End If
    End While

    Return program
End Process

Note: expression_destroy - Clean up expression objects
Process called "expression_destroy" takes expr as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If

    Let expr_type be memory_get_integer(expr, EXPR_TYPE)

    If expr_type is equal to EXPR_BINARY:
        Let left be memory_get_pointer(expr, EXPR_BINARY_LEFT)
        Let right be memory_get_pointer(expr, EXPR_BINARY_RIGHT)
        expression_destroy(left)
        expression_destroy(right)
    Otherwise If expr_type is equal to EXPR_UNARY:
        Let operand be memory_get_pointer(expr, EXPR_UNARY_OPERAND)
        expression_destroy(operand)
    Otherwise If expr_type is equal to EXPR_CALL:
        Let name be memory_get_pointer(expr, EXPR_CALL_NAME)
        string_destroy(name)
        Note: list_destroy_with(memory_get_pointer(expr, EXPR_CALL_ARGS), expression_destroy)
    Otherwise If expr_type is equal to EXPR_FIELD_ACCESS:
        Let obj be memory_get_pointer(expr, EXPR_FIELD_OBJECT)
        Let field_name be memory_get_pointer(expr, EXPR_FIELD_NAME)
        expression_destroy(obj)
        string_destroy(field_name)
    Otherwise If expr_type is equal to EXPR_ARRAY_ACCESS:
        Let array_obj be memory_get_pointer(expr, EXPR_ARRAY_OBJECT)
        Let index be memory_get_pointer(expr, EXPR_ARRAY_INDEX_OFFSET)
        expression_destroy(array_obj)
        expression_destroy(index)
    Otherwise If expr_type is equal to EXPR_IDENTIFIER:
        Let ident_name be memory_get_pointer(expr, EXPR_IDENTIFIER_NAME)
        string_destroy(ident_name)
    Otherwise If expr_type is equal to EXPR_STRING_LITERAL:
        Let str_val be memory_get_pointer(expr, EXPR_STRING_VALUE)
        string_destroy(str_val)
    End If

    deallocate(expr)
    Return 0
End Process

Note: statement_destroy - Clean up statement objects
Process called "statement_destroy" takes stmt as Integer returns Integer:
    If stmt is equal to 0:
        Return 0
    End If

    Let stmt_type be memory_get_integer(stmt, STMT_TYPE)

    If stmt_type is equal to STMT_LET:
        Let name be memory_get_pointer(stmt, STMT_LET_NAME)
        Let value be memory_get_pointer(stmt, STMT_LET_VALUE)
        Let type_ptr be memory_get_pointer(stmt, STMT_LET_TYPE)
        string_destroy(name)
        expression_destroy(value)
        type_destroy(type_ptr)
    Otherwise If stmt_type is equal to STMT_SET:
        Let set_name be memory_get_pointer(stmt, STMT_SET_NAME)
        Let set_value be memory_get_pointer(stmt, STMT_SET_VALUE)
        string_destroy(set_name)
        expression_destroy(set_value)
    Otherwise If stmt_type is equal to STMT_IF:
        Let condition be memory_get_pointer(stmt, STMT_IF_CONDITION)
        expression_destroy(condition)
        Note: list_destroy_with(memory_get_pointer(stmt, STMT_IF_THEN_BODY), statement_destroy)
        Note: list_destroy_with(memory_get_pointer(stmt, STMT_IF_ELSE_BODY), statement_destroy)
    Otherwise If stmt_type is equal to STMT_WHILE:
        Let while_cond be memory_get_pointer(stmt, STMT_WHILE_CONDITION)
        expression_destroy(while_cond)
        Note: list_destroy_with(memory_get_pointer(stmt, STMT_WHILE_BODY), statement_destroy)
    Otherwise If stmt_type is equal to STMT_FOR:
        Let for_var be memory_get_pointer(stmt, STMT_FOR_VAR)
        Let for_start be memory_get_pointer(stmt, STMT_FOR_START)
        Let for_end be memory_get_pointer(stmt, STMT_FOR_END)
        string_destroy(for_var)
        expression_destroy(for_start)
        expression_destroy(for_end)
        Note: list_destroy_with(memory_get_pointer(stmt, STMT_FOR_BODY), statement_destroy)
    Otherwise If stmt_type is equal to STMT_FOR_EACH:
        Let foreach_var be memory_get_pointer(stmt, 8)
        Let foreach_collection be memory_get_pointer(stmt, 16)
        string_destroy(foreach_var)
        expression_destroy(foreach_collection)
        Note: list_destroy_with(memory_get_pointer(stmt, 24), statement_destroy)
    Otherwise If stmt_type is equal to STMT_RETURN:
        Let ret_value be memory_get_pointer(stmt, STMT_RETURN_VALUE)
        expression_destroy(ret_value)
    Otherwise If stmt_type is equal to STMT_EXPRESSION:
        Let expr_value be memory_get_pointer(stmt, STMT_EXPR_VALUE)
        expression_destroy(expr_value)
    Otherwise If stmt_type is equal to STMT_BREAK:
        Note: No cleanup needed for break
    Otherwise If stmt_type is equal to STMT_CONTINUE:
        Note: No cleanup needed for continue
    End If

    deallocate(stmt)
    Return 0
End Process

Note: function_destroy - Clean up function objects
Process called "function_destroy" takes func as Integer returns Integer:
    If func is equal to 0:
        Return 0
    End If

    string_destroy(memory_get_pointer(func, FUNCTION_NAME))
    Note: list_destroy_with(memory_get_pointer(func, FUNCTION_PARAMETERS), param_destroy)
    Note: NOTE: Don't destroy return type - it's owned by the program's types array
    Note: type_destroy(memory_get_pointer(func, FUNCTION_RETURN_TYPE))
    Note: list_destroy_with(memory_get_pointer(func, FUNCTION_BODY), statement_destroy)

    deallocate(func)
    Return 0
End Process

Note: type_destroy - Clean up type definition objects
Process called "type_destroy" takes type_obj as Integer returns Integer:
    If type_obj is equal to 0:
        Return 0
    End If

    Let type_kind be memory_get_integer(type_obj, TYPE_KIND)

    If type_kind is equal to TYPE_PRIMITIVE:
        Note: No additional cleanup for primitive types
    Otherwise If type_kind is equal to TYPE_STRUCT:
        Let struct_name be memory_get_pointer(type_obj, TYPE_STRUCT_NAME)
        string_destroy(struct_name)
        Note: list_destroy_with(memory_get_pointer(type_obj, TYPE_STRUCT_FIELDS), field_destroy)
    Otherwise If type_kind is equal to TYPE_ARRAY:
        Let elem_type be memory_get_pointer(type_obj, TYPE_ARRAY_ELEMENT_TYPE)
        type_destroy(elem_type)
    Otherwise If type_kind is equal to TYPE_POINTER:
        Let target_type be memory_get_pointer(type_obj, TYPE_POINTER_TARGET_TYPE)
        type_destroy(target_type)
    End If

    deallocate(type_obj)
    Return 0
End Process

Note: program_destroy - Clean up program objects
Process called "program_destroy" takes program as Integer returns Integer:
    If program is equal to 0:
        Return 0
    End If

    Note: Clean up functions array
    Let func_count be memory_get_int32(program, PROGRAM_FUNCTION_COUNT)
    Let functions be memory_get_pointer(program, PROGRAM_FUNCTIONS)
    If functions is not equal to 0:
        Let i be 0
        While i is less than func_count:
            Let ptr_size be 8
            Let offset be i multiplied by ptr_size
            Let func_ptr be functions plus offset
            Let func be memory_get_pointer(func_ptr, 0)
            If func is not equal to 0:
                function_destroy(func)
            End If
            Set i to i plus 1
        End While
        deallocate(functions)
    End If

    Note: Clean up types array
    Let type_count be memory_get_int32(program, PROGRAM_TYPE_COUNT)
    Let types be memory_get_pointer(program, PROGRAM_TYPES)
    If types is not equal to 0:
        Let j be 0
        While j is less than type_count:
            Let ptr_size be 8
            Let offset be j multiplied by ptr_size
            Let type_ptr be types plus offset
            Let type_obj be memory_get_pointer(type_ptr, 0)
            If type_obj is not equal to 0:
                type_destroy(type_obj)
            End If
            Set j to j plus 1
        End While
        deallocate(types)
    End If

    Note: Clean up imports array (if we add import_destroy later)
    Let import_count be memory_get_int32(program, PROGRAM_IMPORT_COUNT)
    Let imports be memory_get_pointer(program, PROGRAM_IMPORTS)
    If imports is not equal to 0:
        deallocate(imports)
    End If

    Note: Clean up global variables array
    Let global_count be memory_get_int32(program, PROGRAM_GLOBAL_COUNT)
    Let globals be memory_get_pointer(program, PROGRAM_GLOBAL_VARS)
    If globals is not equal to 0:
        Let k be 0
        While k is less than global_count:
            Let ptr_size be 8
            Let offset be k multiplied by ptr_size
            Let global_ptr be globals plus offset
            Let global_stmt be memory_get_pointer(global_ptr, 0)
            If global_stmt is not equal to 0:
                statement_destroy(global_stmt)
            End If
            Set k to k plus 1
        End While
        deallocate(globals)
    End If

    deallocate(program)
    Return 0
End Process

Note: string_destroy - String cleanup (alias for memory_free)
Process called "string_destroy" takes str as Integer returns Integer:
    If str is not equal to 0:
        deallocate(str)
    End If
    Return 0
End Process

Note: param_destroy - Clean up function parameter objects
Process called "param_destroy" takes param as Integer returns Integer:
    If param is equal to 0:
        Return 0
    End If

    Note: Parameter structure: name (offset 0), type (offset 8)
    string_destroy(memory_get_pointer(param, 0))  Note: param name
    string_destroy(memory_get_pointer(param, 8))  Note: param type
    deallocate(param)
    Return 0
End Process

Note: field_destroy - Clean up struct/variant field objects
Process called "field_destroy" takes field as Integer returns Integer:
    If field is equal to 0:
        Return 0
    End If

    Note: Field structure: name (offset 0), type (offset 8)
    string_destroy(memory_get_pointer(field, 0))  Note: field name
    string_destroy(memory_get_pointer(field, 8))  Note: field type
    deallocate(field)
    Return 0
End Process

Note: import_destroy - Clean up import statement objects
Process called "import_destroy" takes import_stmt as Integer returns Integer:
    If import_stmt is equal to 0:
        Return 0
    End If

    Note: Import structure: filename (offset 0), module_name (offset 8)
    string_destroy(memory_get_pointer(import_stmt, 0))  Note: filename
    string_destroy(memory_get_pointer(import_stmt, 8))  Note: module_name
    deallocate(import_stmt)
    Return 0
End Process

Note: parser_parse_import - Parse Import statement: Import "filename" as module_name
Process called "parser_parse_import" takes parser as Integer returns Integer:
    Note: Parse: Import "filename" as module_name
    Note: Skip the Import token
    Let dummy_import be parser_advance(parser)

    Note: Get filename (must be string literal)
    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_int32(current_token, TOKEN_TYPE_OFFSET)
    If token_type is not equal to 10:
        print_string("[PARSER ERROR] Expected string literal after Import, got token type ")
        print_integer(token_type)
        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
        print_string(", value: ")
        print_string(token_value)
        print_newline()
        exit_with_code(1)
    End If

    Let filename be string_duplicate_parser(memory_get_pointer(current_token, TOKEN_VALUE_OFFSET))
    Let dummy_str be parser_advance(parser)

    Note: Expect "as"
    Let as_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let as_token_type be memory_get_int32(as_token, TOKEN_TYPE_OFFSET)
    If as_token_type is not equal to 34:
        print_string("[PARSER ERROR] Expected 'as' after filename, got token type ")
        print_integer(as_token_type)
        Let as_value be memory_get_pointer(as_token, TOKEN_VALUE_OFFSET)
        print_string(", value: ")
        print_string(as_value)
        print_newline()
        exit_with_code(1)
    End If
    Let dummy_as be parser_advance(parser)

    Note: Get module name (must be identifier)
    Let name_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let name_token_type be memory_get_int32(name_token, TOKEN_TYPE_OFFSET)
    If name_token_type is not equal to 53:
        print_string("[PARSER ERROR] Expected module name after 'as', got token type ")
        print_integer(name_token_type)
        Let name_value be memory_get_pointer(name_token, TOKEN_VALUE_OFFSET)
        print_string(", value: ")
        print_string(name_value)
        print_newline()
        exit_with_code(1)
    End If

    Let module_name be string_duplicate_parser(memory_get_pointer(name_token, TOKEN_VALUE_OFFSET))
    Let dummy_name be parser_advance(parser)

    Note: Create import object
    Let import_stmt be memory_allocate(16)  Note: filename + module_name pointers
    memory_set_pointer(import_stmt, 0, filename)    Note: filename at offset 0
    memory_set_pointer(import_stmt, 8, module_name) Note: module_name at offset 8

    Return import_stmt
End Process
Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
Code Generator for x86-64 Assembly
Transliterated from codegen_x86.c (v0.0.7.3)
Generates x86-64 assembly from parsed AST
:End Note

Note: Program structure offsets (defined in parser.runa)
Note: Using numeric values to avoid duplicate symbol errors
Note: PROGRAM_FUNCTIONS = 0
Note: PROGRAM_FUNCTION_COUNT = 8
Note: PROGRAM_TYPES = 16
Note: PROGRAM_TYPE_COUNT = 24
Note: PROGRAM_IMPORTS = 32
Note: PROGRAM_IMPORT_COUNT = 40
Note: PROGRAM_GLOBAL_VARS = 48
Note: PROGRAM_GLOBAL_COUNT = 56

Note: Forward declarations for loop context management
Note: These will be implemented later in the file

Note: string_duplicate is provided by string_utils module

Note: Helper to emit a line with newline
Process called "emit_line" takes output_file as Integer, line as Integer returns Integer:
    file_write_buffered(output_file, line, 0)
    file_write_buffered(output_file, "\n", 0)
    Return 0
End Process

Note: DJB2 hash function for strings
Process called "codegen_hash_string" takes key as Integer returns Integer:
    Let str_ptr be key
    Let hash be 5381
    Let c be memory_get_byte(str_ptr, 0)
    Let offset be 0
    While c is not equal to 0:
        Let hash_shifted be hash multiplied by 32
        Set hash to hash_shifted plus hash
        Set hash to hash plus c
        Set offset to offset plus 1
        Set c to memory_get_byte(str_ptr, offset)
    End While
    Return hash
End Process

Note: String comparison for hash table
Process called "codegen_compare_strings" takes key1 as Integer, key2 as Integer returns Integer:
    Let result be string_compare(key1, key2)
    If result is equal to 0:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Note: Find variable in current scope - OPTIMIZED with first-char check
Process called "codegen_find_variable" takes codegen as Integer, name as Integer returns Integer:
    Let variable_count be memory_get_int32(codegen, 16)  Note: codegen->variable_count (int)
    Let variables be memory_get_pointer(codegen, 8)        Note: codegen->variables

    Note: Optimization: get first character of search name
    Let name_first_char be memory_get_byte(name, 0)

    Let i be 0
    While i is less than variable_count:
        Let var_offset be i multiplied by 32
        Let var_ptr be variables plus var_offset  Note: sizeof(Variable) = 32
        Let var_name be memory_get_pointer(var_ptr, 0)

        Note: Fast path: check first character before expensive string_equals
        Let var_first_char be memory_get_byte(var_name, 0)
        If var_first_char is equal to name_first_char:
            If string_equals(var_name, name) is equal to 1:
                Return i
            End If
        End If

        Let i be i plus 1
    End While
    Return -1  Note: -1 for not found
End Process

Note: Calculate size of a type in bytes - equivalent to codegen_calculate_type_size
Process called "codegen_calculate_type_size" takes type_name as Integer, program as Integer returns Integer:
    Note: Built-in types
    If string_equals(type_name, "Integer") is equal to 1:
        Return 8  Note: 64-bit integer
    Otherwise If string_equals(type_name, "Byte") is equal to 1:
        Return 1  Note: 8-bit byte
    Otherwise If string_equals(type_name, "Short") is equal to 1:
        Return 2  Note: 16-bit short
    Otherwise If string_equals(type_name, "Long") is equal to 1:
        Return 8  Note: 64-bit long
    End If

    Note: Custom types - look up in the program
    If program is not equal to 0:
        Let type_count be memory_get_int32(program, 24)  Note: PROGRAM_TYPE_COUNT - use int32
        Let types be memory_get_pointer(program, 16)       Note: PROGRAM_TYPES - use pointer
        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)  Note: type->name
            If string_equals(type_name_ptr, type_name) is equal to 1:
                Let type_size be memory_get_int32(type_ptr, 40)  Note: TYPEDEFINITION_SIZE_OFFSET
                Return type_size
            End If
            Let i be i plus 1
        End While
    End If

    Note: Unknown type - default to 8 bytes
    Return 8
End Process

Note: Add variable with type and parameter flag - equivalent to codegen_add_variable_with_type_and_param_flag
Process called "codegen_add_variable_with_type_and_param_flag" takes codegen as Integer, name as Integer, type_name as Integer, is_parameter as Integer returns Integer:
    Note: Get current counts and capacity

    Let variable_count be memory_get_int32(codegen, 16)      Note: codegen->variable_count (int)
    Let variable_capacity be memory_get_int32(codegen, 20)   Note: codegen->variable_capacity (int)
    Let variables be memory_get_pointer(codegen, 8)            Note: codegen->variables

    Note: DEBUG: Show what we read
    Note: print_integer(variable_count)
    Note: print_integer(variable_capacity)

    Note: Grow array if needed
    If variable_count is greater than or equal to variable_capacity:
        Let new_capacity be variable_capacity multiplied by 2
        Let new_size be new_capacity multiplied by 32  Note: sizeof(Variable)
        Let new_variables be allocate(new_size)

        Note: Copy existing variables
        Let i be 0
        While i is less than variable_count:
            Let var_offset be i multiplied by 32
            Let old_var be variables plus var_offset
            Let var_offset be i multiplied by 32
            Let new_var be new_variables plus var_offset
            Note: Copy Variable struct (32 bytes)
            memory_copy(new_var, old_var, 32)
            Let i be i plus 1
        End While

        Note: Free old array and update
        deallocate(variables)
        memory_set_pointer(codegen, 8, new_variables)      Note: codegen->variables
        memory_set_int32(codegen, 20, new_capacity)      Note: codegen->variable_capacity (int)
        Let variables be new_variables
    End If

    Note: Calculate size based on type
    Let current_program be memory_get_pointer(codegen, 48)  Note: codegen->current_program (pointer with padding)
    Let size be codegen_calculate_type_size(type_name, current_program)
    If type_name is equal to 0:
        Let size be codegen_calculate_type_size("Integer", current_program)
    End If

    Note: Update stack offset
    Let stack_offset be memory_get_int32(codegen, 24)  Note: codegen->stack_offset (int)
    Let new_stack_offset be stack_offset plus size
    memory_set_int32(codegen, 24, new_stack_offset)  Note: codegen->stack_offset (int)

    Note: Get variable index
    Let var_index be variable_count
    Let var_offset be var_index multiplied by 32  Note: Calculate offset separately
    Let var_ptr be variables plus var_offset      Note: Then add to base pointer


    Note: Set variable fields
    memory_set_pointer(var_ptr, 0, string_duplicate(name))       Note: name
    memory_set_int32(var_ptr, 8, new_stack_offset)            Note: stack_offset (int)
    If type_name is equal to 0:
        memory_set_pointer(var_ptr, 16, string_duplicate("Integer")) Note: type_name - use literal directly
    Otherwise:
        memory_set_pointer(var_ptr, 16, string_duplicate(type_name)) Note: type_name
    End If
    memory_set_int32(var_ptr, 24, is_parameter)               Note: is_parameter (int)

    Note: Increment count
    memory_set_int32(codegen, 16, variable_count plus 1)  Note: codegen->variable_count (int)

    Return var_index
End Process

Note: Add variable with type - equivalent to codegen_add_variable_with_type
Process called "codegen_add_variable_with_type" takes codegen as Integer, name as Integer, type_name as Integer returns Integer:
    Return codegen_add_variable_with_type_and_param_flag(codegen, name, type_name, 0)
End Process

Note: Add variable with default Integer type - equivalent to codegen_add_variable
Process called "codegen_add_variable" takes codegen as Integer, name as Integer returns Integer:
    Return codegen_add_variable_with_type(codegen, name, "Integer")
End Process

Note: Add string literal - equivalent to codegen_add_string_literal
Process called "codegen_add_string_literal" takes codegen as Integer, value as Integer returns Integer:
    Note: Get current counts and capacity
    Let string_count be memory_get_int32(codegen, 40)      Note: codegen->string_count (int)
    Let string_capacity be memory_get_int32(codegen, 44)   Note: codegen->string_capacity (int)
    Let strings be memory_get_pointer(codegen, 32)           Note: codegen->strings (pointer with padding)


    Note: Grow array if needed
    If string_count is greater than or equal to string_capacity:
        Let new_capacity be string_capacity multiplied by 2
        Let new_size be new_capacity multiplied by 16  Note: sizeof(StringLiteral)
        Let new_strings be allocate(new_size)

        Note: Copy existing strings
        Let i be 0
        While i is less than string_count:
            Let str_offset be i multiplied by 16
            Let old_str be strings plus str_offset
            Let str_offset be i multiplied by 16
            Let new_str be new_strings plus str_offset
            Note: Copy StringLiteral struct (16 bytes)
            memory_copy(new_str, old_str, 16)
            Let i be i plus 1
        End While

        Note: Free old array and update
        deallocate(strings)
        memory_set_pointer(codegen, 32, new_strings)      Note: codegen->strings (pointer)
        memory_set_int32(codegen, 44, new_capacity)     Note: codegen->string_capacity (int)
        Let strings be new_strings
    End If

    Let str_index be string_count
    Let str_offset be str_index multiplied by 16
    Let str_ptr be strings plus str_offset

    Note: Set string value
    memory_set_pointer(str_ptr, 0, string_duplicate(value))  Note: value

    Note: Generate unique label for this string
    Let label be string_concat(".STR", integer_to_string(str_index))
    memory_set_pointer(str_ptr, 8, label)  Note: label

    Note: Increment count
    memory_set_int32(codegen, 40, string_count plus 1)  Note: codegen->string_count (int)


    Return str_index
End Process

Note: Collect strings from expression - equivalent to codegen_collect_strings_from_expression
Process called "codegen_collect_strings_from_expression" takes codegen as Integer, expr as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If
    Note: Safety check for invalid pointers
    If expr is equal to 0:
        Return 0
    End If

    Let expr_type be memory_get_int32(expr, 0)  Note: expr->type (32-bit)


    If expr_type is equal to 5:  Note: EXPR_STRING_LITERAL
        Note: Check if string already exists
        Let string_count be memory_get_int32(codegen, 40)  Note: codegen->string_count (int)
        Let strings be memory_get_pointer(codegen, 32)  Note: codegen->strings (pointer)
        Let string_literal be memory_get_pointer(expr, 8)  Note: expr->data.string_literal (union at offset 4)

        Note: Safety check for string_literal
        If string_literal is equal to 0:
            Return 0
        End If
        If string_literal is equal to 0:
            Return 0
        End If

        Note: Safety check - string_count should be reasonable
        If string_count is less than 0:
            Return 0
        End If
        Note: Don't limit string count - allow as many as needed
        Note: If string_count is greater than 1000:
        Note:     Return 0
        Note: End If

        Let i be 0
        While i is less than string_count:
            Let str_offset be i multiplied by 16
            Let str_ptr be strings plus str_offset
            Let existing_value be memory_get_pointer(str_ptr, 0)  Note: Should be pointer, not integer!
            Note: Safety check for existing_value before comparison
            If existing_value is not equal to 0:
                If existing_value is greater than 65536:
                    If string_equals(existing_value, string_literal) is equal to 1:
                        Return 0  Note: Already added
                    End If
                End If
            End If
            Let i be i plus 1
        End While

        codegen_add_string_literal(codegen, string_literal)
        Return 0
    End If

    If expr_type is equal to 2:  Note: EXPR_BINARY_OP
        Let left be memory_get_pointer(expr, 8)   Note: binary_op.left
        Let right be memory_get_pointer(expr, 16) Note: binary_op.right
        codegen_collect_strings_from_expression(codegen, left)
        codegen_collect_strings_from_expression(codegen, right)
        Return 0
    End If

    If expr_type is equal to 3:  Note: EXPR_COMPARISON
        Let left be memory_get_pointer(expr, 8)   Note: comparison.left
        Let right be memory_get_pointer(expr, 16) Note: comparison.right
        codegen_collect_strings_from_expression(codegen, left)
        codegen_collect_strings_from_expression(codegen, right)
        Return 0
    End If

    If expr_type is equal to 4:  Note: EXPR_FUNCTION_CALL
        Let func_call_ptr be expr plus 8  Note: &expr->data.function_call
        Note: function_call structure: function_name (char*) at 0, arguments (Expression**) at 8, argument_count (int) at 16
        Let function_name be memory_get_pointer(func_call_ptr, 0)  Note: function_call.function_name
        Let arguments be memory_get_pointer(func_call_ptr, 8)      Note: function_call.arguments - this is a pointer!
        Let argument_count be memory_get_int32(func_call_ptr, 16) Note: function_call.argument_count


        Let i be 0
        While i is less than argument_count:
            Let arg_offset be i multiplied by 8
            Let arg_ptr be memory_get_pointer(arguments, arg_offset)


            codegen_collect_strings_from_expression(codegen, arg_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 6:  Note: EXPR_FIELD_ACCESS
        Let object be memory_get_pointer(expr, 8)  Note: field_access.object
        codegen_collect_strings_from_expression(codegen, object)
        Return 0
    End If

    If expr_type is equal to 8:  Note: EXPR_BUILTIN_CALL
        Let builtin_call_ptr be expr plus 8  Note: &expr->data.builtin_call
        Note: builtin_call structure: builtin_type (int) at 0, arguments (Expression**) at 8, argument_count (int) at 16
        Let builtin_type be memory_get_int32(builtin_call_ptr, 0)  Note: builtin_call.builtin_type
        Let arguments be memory_get_pointer(builtin_call_ptr, 8)      Note: builtin_call.arguments - this is a pointer!
        Let argument_count be memory_get_int32(builtin_call_ptr, 16) Note: builtin_call.argument_count

        Let i be 0
        While i is less than argument_count:
            Let arg_offset be i multiplied by 8
            Let arg_ptr be memory_get_pointer(arguments, arg_offset)
            codegen_collect_strings_from_expression(codegen, arg_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 9:  Note: EXPR_VARIANT_CONSTRUCTOR
        Let variant_constructor_ptr be expr plus 8  Note: &expr->data.variant_constructor
        Note: variant_constructor structure: type_name (char*) at 0, variant_name (char*) at 8, field_values (Expression**) at 16, field_count (int) at 24
        Let type_name be memory_get_pointer(variant_constructor_ptr, 0)     Note: variant_constructor.type_name
        Let variant_name be memory_get_pointer(variant_constructor_ptr, 8)  Note: variant_constructor.variant_name
        Let field_values be memory_get_pointer(variant_constructor_ptr, 16) Note: variant_constructor.field_values - this is a pointer!
        Let field_count be memory_get_int32(variant_constructor_ptr, 24)  Note: variant_constructor.field_count

        Let i be 0
        While i is less than field_count:
            Let field_offset be i multiplied by 8
            Let field_value_ptr be memory_get_pointer(field_values, field_offset)  Note: This is also a pointer!
            codegen_collect_strings_from_expression(codegen, field_value_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 16:  Note: EXPR_ARRAY_INDEX
        Let array_index_ptr be expr plus 8  Note: &expr->data.array_index
        Let arr be memory_get_pointer(array_index_ptr, 0)  Note: array_index.array (FIX: use memory_get_pointer, not _integer)
        Let index be memory_get_pointer(array_index_ptr, 8)  Note: array_index.index (FIX: use memory_get_pointer, not _integer)
        codegen_collect_strings_from_expression(codegen, arr)
        codegen_collect_strings_from_expression(codegen, index)
        Return 0
    End If

    If expr_type is equal to 20:  Note: EXPR_STRUCT_CONSTRUCTION
        Let field_values be memory_get_pointer(expr, 24)
        Let field_count be memory_get_int32(expr, 32)
        Let field_i be 0
        While field_i is less than field_count:
            Let field_ptr_offset be field_i multiplied by 8
            Let field_value_expr be memory_get_pointer(field_values, field_ptr_offset)
            codegen_collect_strings_from_expression(codegen, field_value_expr)
            Let field_i be field_i plus 1
        End While
        Return 0
    End If

    Note: Other expression types (INTEGER, VARIABLE, TYPE_NAME, FUNCTION_POINTER) have no strings to collect
    Return 0
End Process

Note: Collect strings from statement - equivalent to codegen_collect_strings_from_statement
Process called "codegen_collect_strings_from_statement" takes codegen as Integer, stmt as Integer returns Integer:
    If stmt is equal to 0:
        Return 0
    End If

    Note: Safety check - if stmt is NULL, skip it
    If stmt is equal to 0:
        Return 0
    End If

    Let stmt_type be memory_get_int32(stmt, 0)  Note: stmt->type


    Note: Safety check - statement types should be reasonable (0-17 for now, including STMT_COMPOUND_ASSIGN = 17)
    If stmt_type is less than 0:
        Return 0
    End If
    If stmt_type is greater than 17:
        Return 1
    End If

    If stmt_type is equal to 1:  Note: STMT_LET
        Note: Statement structure: type at 0, data union at 8
        Note: let_stmt in union: var_name at 0, expression at 8
        Let var_name be memory_get_pointer(stmt, 8)   Note: stmt+8 = let_stmt.var_name
        Let expression be memory_get_pointer(stmt, 16) Note: stmt+16 = let_stmt.expression


        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 2:  Note: STMT_SET
        Note: Statement structure: type at 0, data union at 8
        Note: set_stmt in union: target at 0, expression at 8
        Let target be memory_get_pointer(stmt, 8)      Note: stmt+8 = set_stmt.target
        Let expression be memory_get_pointer(stmt, 16) Note: stmt+16 = set_stmt.expression
        codegen_collect_strings_from_expression(codegen, target)
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 3:  Note: STMT_RETURN
        Let return_stmt_ptr be stmt plus 8  Note: &stmt->data.return_stmt
        Let expression be memory_get_pointer(return_stmt_ptr, 0)  Note: return_stmt.expression
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 4:  Note: STMT_PRINT
        Let print_stmt_ptr be stmt plus 8  Note: &stmt->data.print_stmt
        Let expression be memory_get_pointer(print_stmt_ptr, 0)  Note: print_stmt.expression
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 5:  Note: STMT_IF

        Let if_stmt_ptr be stmt plus 8  Note: &stmt->data.if_stmt
        Let condition be memory_get_pointer(if_stmt_ptr, 0)        Note: if_stmt.condition (offset 8)
        Let if_body be memory_get_pointer(if_stmt_ptr, 8)          Note: if_stmt.if_body (offset 16)
        Let if_body_count be memory_get_int32(if_stmt_ptr, 16)   Note: if_stmt.if_body_count (offset 24)
        Let else_body be memory_get_pointer(if_stmt_ptr, 24)       Note: if_stmt.else_body (offset 32)
        Let else_body_count be memory_get_int32(if_stmt_ptr, 32) Note: if_stmt.else_body_count (offset 40)


        codegen_collect_strings_from_expression(codegen, condition)

        Note: Process if body - add safety check
        If if_body is not equal to 0:  Note: NULL pointer check
            Let i be 0
            While i is less than if_body_count:
                Let stmt_offset be i multiplied by 8


                Let stmt_ptr be memory_get_pointer(if_body, stmt_offset)


                codegen_collect_strings_from_statement(codegen, stmt_ptr)
                Let i be i plus 1
            End While
        End If

        Note: Process else body - add safety check
        If else_body is not equal to 0:  Note: NULL pointer check
            Let i be 0
            While i is less than else_body_count:
                Let stmt_offset be i multiplied by 8
                Let stmt_ptr be memory_get_pointer(else_body, stmt_offset)
                codegen_collect_strings_from_statement(codegen, stmt_ptr)
                Let i be i plus 1
            End While
        End If
        Return 0
    End If

    If stmt_type is equal to 6:  Note: STMT_WHILE
        Let while_stmt_ptr be stmt plus 8  Note: &stmt->data.while_stmt
        Let condition be memory_get_pointer(while_stmt_ptr, 0)   Note: while_stmt.condition (offset 8)
        Let body be memory_get_pointer(while_stmt_ptr, 8)        Note: while_stmt.body (offset 16)
        Let body_count be memory_get_int32(while_stmt_ptr, 16) Note: while_stmt.body_count (offset 24)

        codegen_collect_strings_from_expression(codegen, condition)

        Note: Process body
        Let i be 0
        While i is less than body_count:
            Let stmt_offset be i multiplied by 8
            Let stmt_ptr be memory_get_pointer(body, stmt_offset)
            codegen_collect_strings_from_statement(codegen, stmt_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 6:  Note: STMT_WHILE
        Note: This is the duplicate WHILE check, should be removed but keeping for now
        Let while_stmt_ptr be stmt plus 8  Note: &stmt->data.while_stmt
        Let condition be memory_get_pointer(while_stmt_ptr, 0)   Note: while_stmt.condition (offset 8)
        Let body be memory_get_pointer(while_stmt_ptr, 8)        Note: while_stmt.body (offset 16)
        Let body_count be memory_get_int32(while_stmt_ptr, 16) Note: while_stmt.body_count (offset 24)

        codegen_collect_strings_from_expression(codegen, condition)

        Let i be 0
        While i is less than body_count:
            Let stmt_offset be i multiplied by 8
            Let stmt_ptr be memory_get_pointer(body, stmt_offset)
            codegen_collect_strings_from_statement(codegen, stmt_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 7:  Note: STMT_EXPRESSION
        Let expr_stmt_ptr be stmt plus 8  Note: &stmt->data.expr_stmt
        Let expression be memory_get_pointer(expr_stmt_ptr, 0)  Note: expr_stmt.expression - this is a pointer!
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 8:  Note: STMT_MATCH
        Note: Collect strings from match expression and when clause bodies
        Let match_expr be memory_get_pointer(stmt, 8)  Note: STMT_MATCH_EXPR
        codegen_collect_strings_from_expression(codegen, match_expr)

        Let when_clauses be memory_get_pointer(stmt, 16)  Note: STMT_MATCH_WHEN_CLAUSES
        Let when_count be memory_get_int32(stmt, 24)  Note: STMT_MATCH_WHEN_COUNT

        Note: Process each when clause (48 bytes each)
        Let i be 0
        While i is less than when_count:
            Let clause_offset be i multiplied by 48
            Let clause_ptr be when_clauses plus clause_offset
            Let pattern_type be memory_get_int32(clause_ptr, 0)
            Let pattern_value be memory_get_pointer(clause_ptr, 8)
            Let body_stmts be memory_get_pointer(clause_ptr, 32)
            Let body_count be memory_get_integer(clause_ptr, 40)

            Note: Collect strings from pattern value (expression for literals)
            If pattern_type is equal to 0:  Note: PATTERN_LITERAL
                codegen_collect_strings_from_expression(codegen, pattern_value)
            End If

            Note: Collect strings from body statements
            Let j be 0
            While j is less than body_count:
                Let stmt_offset be j multiplied by 8
                Let stmt_ptr be memory_get_pointer(body_stmts, stmt_offset)
                codegen_collect_strings_from_statement(codegen, stmt_ptr)
                Set j to j plus 1
            End While

            Set i to i plus 1
        End While
        Return 0
    End If

    Note: STMT_COMPOUND_ASSIGN: target at offset 8, expression at offset 24
    If stmt_type is equal to 17:
        Let target be memory_get_pointer(stmt, 8)
        Let expression be memory_get_pointer(stmt, 24)
        Let result1 be codegen_collect_strings_from_expression(codegen, target)
        Let result2 be codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    Note: STMT_FOR: start at offset 16, end at offset 24, step at offset 32, body at offset 40
    If stmt_type is equal to 11:
        Let start_expr be memory_get_pointer(stmt, 16)
        Let end_expr be memory_get_pointer(stmt, 24)
        Let step_expr be memory_get_pointer(stmt, 32)
        Let body be memory_get_pointer(stmt, 40)
        Let body_count be memory_get_integer(stmt, 48)

        Let result1 be codegen_collect_strings_from_expression(codegen, start_expr)
        Let result2 be codegen_collect_strings_from_expression(codegen, end_expr)
        If step_expr is not equal to 0:
            Let result3 be codegen_collect_strings_from_expression(codegen, step_expr)
        End If

        Let i be 0
        While i is less than body_count:
            Let body_stmt be memory_get_pointer(body, i multiplied by 8)
            Let result_body be codegen_collect_strings_from_statement(codegen, body_stmt)
            Set i to i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 12:  Note: STMT_FOR_EACH
        Let collection_expr be memory_get_pointer(stmt, 16)
        Let body be memory_get_pointer(stmt, 24)
        Let body_count be memory_get_integer(stmt, 32)

        Let result1 be codegen_collect_strings_from_expression(codegen, collection_expr)

        Let i be 0
        While i is less than body_count:
            Let body_stmt be memory_get_pointer(body, i multiplied by 8)
            Let result_body be codegen_collect_strings_from_statement(codegen, body_stmt)
            Set i to i plus 1
        End While
        Return 0
    End If

    Note: Other statement types (IMPORT, BREAK, CONTINUE, INLINE_ASSEMBLY) don't have strings to collect
    Return 0
End Process

Note: Helper function to determine the type name of an expression
Process called "codegen_get_expression_type" takes codegen as Integer, expr as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If

    Let expr_type be memory_get_int32(expr, 0)  Note: expr->type

    If expr_type is equal to 1:  Note: EXPR_VARIABLE
        Let variable_name be memory_get_pointer(expr, 8)  Note: expr->data.variable_name
        Let var_index be codegen_find_variable(codegen, variable_name)

        If var_index is less than 0:  Note: -1 for not found
            Note: Check if this is a global variable
            Let current_program be memory_get_pointer(codegen, 48)  Note: codegen->current_program (pointer with padding)
            If current_program is not equal to 0:
                Let global_count be memory_get_int32(current_program, 56)  Note: program->global_count (PROGRAM_GLOBAL_COUNT)
                Let globals be memory_get_pointer(current_program, 48)       Note: program->globals (PROGRAM_GLOBAL_VARS)

                Let j be 0
                While j is less than global_count:
                    Let global_offset be j multiplied by 8
                    Let global_ptr be memory_get_pointer(globals, global_offset)
                    Let global_name be memory_get_pointer(global_ptr, 0)  Note: global->name
                    If string_equals(global_name, variable_name) is equal to 1:
                        Let global_type be memory_get_integer(global_ptr, 8)  Note: global->type
                        Return global_type
                    End If
                    Let j be j plus 1
                End While
            End If
            Return 0
        End If

        Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
        Let var_offset be var_index multiplied by 32
        Let var_ptr be variables plus var_offset
        Let type_name be memory_get_pointer(var_ptr, 16)  Note: variable.type_name
        Return type_name
    End If

    If expr_type is equal to 6:  Note: EXPR_FIELD_ACCESS
        Let field_access_ptr be expr plus 8  Note: &expr->data.field_access
        Let object be memory_get_pointer(field_access_ptr, 0)       Note: field_access.object
        Let field_name be memory_get_pointer(field_access_ptr, 8)   Note: field_access.field_name

        Note: Get the type of the object
        Let object_type be codegen_get_expression_type(codegen, object)
        If object_type is equal to 0:
            Return 0
        End If

        Note: Find the type definition
        Let current_program be memory_get_pointer(codegen, 48)  Note: codegen->current_program (pointer with padding)
        Let type_count be memory_get_int32(current_program, 24)  Note: PROGRAM_TYPE_COUNT
        Let types be memory_get_pointer(current_program, 16)       Note: PROGRAM_TYPES
        Let type be 0

        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)  Note: type->name
            If string_equals(type_name_ptr, object_type) is equal to 1:
                Let type be type_ptr
                Let i be type_count  Note: break loop
            End If
            Let i be i plus 1
        End While

        If type is equal to 0:
            Return 0
        End If

        Note: Find the field and return its type
        Let kind be memory_get_int32(type, 8)  Note: type->kind
        If kind is equal to 0:  Note: TYPE_KIND_STRUCT
            Note: TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET is 24
            Note: TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET is 16
            Let field_count be memory_get_int32(type, 24)
            Let fields be memory_get_pointer(type, 16)

            Let i be 0
            While i is less than field_count:
                Let field_offset be i multiplied by 24
                Let field_ptr be fields plus field_offset  Note: sizeof(FieldDefinition)
                Let field_name_ptr be memory_get_pointer(field_ptr, 0)  Note: field.name
                If string_equals(field_name_ptr, field_name) is equal to 1:
                    Let field_type be memory_get_pointer(field_ptr, 8)  Note: field.type
                    Return field_type
                End If
                Let i be i plus 1
            End While
        End If

        Return 0
    End If

    If expr_type is equal to 20:  Note: EXPR_STRUCT_CONSTRUCTION
        Let struct_type_name be memory_get_pointer(expr, 8)
        Return struct_type_name
    End If

    Note: Other expression types don't have determinable types in this context
    Return 0
End Process

Note: Generate the address of an lvalue expression (result in %rbx)
Process called "codegen_generate_lvalue_address" takes codegen as Integer, expr as Integer returns Integer:
    Let expr_type be memory_get_int32(expr, 0)  Note: expr->type
    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file

    If expr_type is equal to 1:  Note: EXPR_VARIABLE
        Note: Find variable and generate its address
        Let variable_name be memory_get_pointer(expr, 8)  Note: expr->data.variable_name
        Let var_index be codegen_find_variable(codegen, variable_name)

        If var_index is less than 0:  Note: -1 for not found
            Note: Check if this is a global variable
            Let is_global be 0
            Let current_program be memory_get_pointer(codegen, 48)  Note: codegen->current_program (pointer with padding)

            If current_program is not equal to 0:
                Let global_count be memory_get_int32(current_program, 56)  Note: program->global_count (PROGRAM_GLOBAL_COUNT)
                Let globals be memory_get_pointer(current_program, 48)       Note: program->globals (PROGRAM_GLOBAL_VARS)

                Let j be 0
                While j is less than global_count:
                    Let global_offset be j multiplied by 8
                    Let global_ptr be memory_get_pointer(globals, global_offset)
                    Let global_name be memory_get_pointer(global_ptr, 0)  Note: global->name
                    If string_equals(global_name, variable_name) is equal to 1:
                        Let is_global be 1
                        Let j be global_count  Note: break loop
                    End If
                    Let j be j plus 1
                End While
            End If

            If is_global is equal to 1:
                Note: Generate address of global variable
                file_write_buffered(output_file, "    leaq ", 0)
                file_write_buffered(output_file, variable_name, 0)
                file_write_buffered(output_file, "(%rip), %rbx  # Address of global variable", 0)
            Otherwise:
                print_string("[CODEGEN ERROR] Unknown variable '")
                print_string(variable_name)
                print_string("'")
                exit_with_code(1)
            End If
        Otherwise:
            Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
            Let var_offset be var_index multiplied by 32
            Let var_ptr be variables plus var_offset
            Let offset be memory_get_int32(var_ptr, 8)  Note: variable.stack_offset

            Note: Generate address of variable on stack
            file_write_buffered(output_file, "    leaq -", 0)
            file_write_buffered(output_file, integer_to_string(offset), 0)
            file_write_buffered(output_file, "(%rbp), %rbx\n", 0)
        End If
        Return 0
    End If

    If expr_type is equal to 6:  Note: EXPR_FIELD_ACCESS
        Let field_access_ptr be expr plus 8  Note: &expr->data.field_access
        Let object be memory_get_pointer(field_access_ptr, 0)     Note: field_access.object
        Let field_name be memory_get_pointer(field_access_ptr, 8) Note: field_access.field_name

        Note: For field access, we need the POINTER VALUE, not the address of the pointer variable
        Note: If object is a variable, we need to load its value (the pointer)
        Let obj_type be memory_get_int32(object, 0)
        If obj_type is equal to 1:  Note: EXPR_VARIABLE - load the pointer value
            Let variable_name be memory_get_pointer(object, 8)
            Let var_index be codegen_find_variable(codegen, variable_name)
            If var_index is less than 0:
                print_string("[CODEGEN ERROR] Unknown variable in field access")
                exit_with_code(1)
            End If
            Let variables be memory_get_pointer(codegen, 8)
            Let var_offset be var_index multiplied by 32
            Let var_ptr be variables plus var_offset
            Let stack_offset be memory_get_int32(var_ptr, 8)
            file_write_buffered(output_file, "    movq -", 0)
            file_write_buffered(output_file, integer_to_string(stack_offset), 0)
            file_write_buffered(output_file, "(%rbp), %rbx  # Load struct pointer\n", 0)
        Otherwise:
            Note: For other expressions, generate their value and use that as the pointer
            codegen_generate_expression(codegen, object)
            file_write_buffered(output_file, "    movq %rax, %rbx  # Use expression result as pointer\n", 0)
        End If

        Note: Now %rbx contains the struct pointer value
        Note: We need to add the field offset to get the field address

        Note: Get the type of the object using our helper function
        Let object_type be codegen_get_expression_type(codegen, object)
        If object_type is equal to 0:
            print_string("[CODEGEN ERROR] Cannot determine type of object in field access")
            exit_with_code(1)
        End If

        Note: Find the type definition
        Let current_program be memory_get_pointer(codegen, 48)  Note: codegen->current_program (pointer with padding)
        Let type_count be memory_get_int32(current_program, 24)  Note: PROGRAM_TYPE_COUNT
        Let types be memory_get_pointer(current_program, 16)       Note: PROGRAM_TYPES
        Let type be 0

        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)  Note: type->name
            If string_equals(type_name_ptr, object_type) is equal to 1:
                Let type be type_ptr
                Let i be type_count  Note: break loop
            End If
            Let i be i plus 1
        End While

        If type is equal to 0:
            print_string("[CODEGEN ERROR] Unknown type '")
            print_string(object_type)
            print_string("'")
            exit_with_code(1)
        End If

        Note: Find field offset
        Let field_offset be -1  Note: -1 for not found
        Let kind be memory_get_int32(type, 8)  Note: type->kind

        If kind is equal to 0:  Note: TYPE_KIND_STRUCT
            Note: TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET is 24
            Note: TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET is 16
            Let field_count be memory_get_int32(type, 24)
            Let fields be memory_get_pointer(type, 16)

            Let i be 0
            While i is less than field_count:
                Let field_idx_offset be i multiplied by 24
                Let field_ptr be fields plus field_idx_offset  Note: sizeof(FieldDefinition)
                Let field_name_ptr be memory_get_pointer(field_ptr, 0)  Note: field.name
                If string_equals(field_name_ptr, field_name) is equal to 1:
                    Let field_offset be memory_get_int32(field_ptr, 16)  Note: field.offset
                    Let i be field_count  Note: break loop
                End If
                Let i be i plus 1
            End While
        End If

        If field_offset is less than 0:  Note: -1 for not found
            print_string("[CODEGEN ERROR] Type '")
            print_string(object_type)
            print_string("' has no field '")
            print_string(field_name)
            print_string("'")
            exit_with_code(1)
        End If

        Note: Add field offset to object address
        file_write_buffered(output_file, "    addq $", 0)
        file_write_buffered(output_file, integer_to_string(field_offset), 0)
        file_write_buffered(output_file, ", %rbx\n", 0)
        Return 0
    End If

    If expr_type is equal to 16:  Note: EXPR_ARRAY_INDEX
        Let array_index_ptr be expr plus 8  Note: &expr->data.array_index
        Let arr be memory_get_pointer(array_index_ptr, 0)  Note: array_index.array (FIX: use memory_get_pointer, not _integer)
        Let index be memory_get_pointer(array_index_ptr, 8)  Note: array_index.index (FIX: use memory_get_pointer, not _integer)

        Note: Check if the array is a parameter or local variable
        Let array_type be memory_get_int32(arr, 0)  Note: array->type
        If array_type is equal to 1:  Note: EXPR_VARIABLE
            Let array_variable_name be memory_get_pointer(arr, 8)  Note: array->data.variable_name
            Let var_index be codegen_find_variable(codegen, array_variable_name)

            If var_index is greater than or equal to 0:  Note: found variable
                Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
                Let var_offset be var_index multiplied by 32
                Let var_ptr be variables plus var_offset
                Let is_parameter be memory_get_int32(var_ptr, 24)  Note: variable.is_parameter

                If is_parameter is equal to 1:
                    Note: For array parameters, load the pointer value, not the address
                    Let offset be memory_get_int32(var_ptr, 8)  Note: variable.stack_offset
                    file_write_buffered(output_file, "    movq -", 0)
                    file_write_buffered(output_file, integer_to_string(offset), 0)
                    file_write_buffered(output_file, "(%rbp), %rbx  # Load array parameter pointer", 0)
                Otherwise:
                    Note: For local arrays, generate the address
                    codegen_generate_lvalue_address(codegen, arr)
                End If
            Otherwise:
                Note: For complex expressions, generate the address
                codegen_generate_lvalue_address(codegen, arr)
            End If
        Otherwise:
            Note: For complex expressions, generate the address
            codegen_generate_lvalue_address(codegen, arr)
        End If

        Note: Save base address
        emit_line(output_file, "    pushq %rbx")

        Note: Generate index expression
        codegen_generate_expression(codegen, index)

        Note: Pop base address
        emit_line(output_file, "    popq %rbx")

        Note: Calculate element address: base + (index * element_size)
        Note: For arrays, all elements are currently 8 bytes (Integer size)
        emit_line(output_file, "    imulq $8, %rax")
        emit_line(output_file, "    addq %rax, %rbx")
        Return 0
    End If

    Note: Invalid lvalue expression type
    print_string("[CODEGEN ERROR] Invalid lvalue expression type")
    exit_with_code(1)
    Return 0
End Process

Note: Helper function to generate integer literal expression
Process called "codegen_generate_integer_expr" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file
    Let integer_value be memory_get_pointer(expr, 8)  Note: expr->data.integer_value
    file_write_buffered(output_file, "    movq $", 0)
    file_write_buffered(output_file, integer_to_string(integer_value), 0)
    file_write_buffered(output_file, ", %rax\n", 0)
    Return 0
End Process

Note: Helper function to generate variable expression
Process called "codegen_generate_variable_expr" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let variable_name be memory_get_pointer(expr, 8)  Note: expr->data.variable_name
    Let var_index be codegen_find_variable(codegen, variable_name)

    If var_index is less than 0:  Note: -1 for not found
        Note: Check if this is a global variable
        Let is_global be 0
        Let current_program be memory_get_pointer(codegen, 48)

        If current_program is not equal to 0:
            Let global_count be memory_get_int32(current_program, 56)  Note: PROGRAM_GLOBAL_COUNT
            Let globals be memory_get_pointer(current_program, 48)  Note: PROGRAM_GLOBAL_VARS

            Let j be 0
            Let found_global_ptr be 0
            While j is less than global_count:
                Let global_offset be j multiplied by 8
                Let global_ptr be memory_get_pointer(globals, global_offset)
                Let global_name be memory_get_pointer(global_ptr, 0)
                If string_equals(global_name, variable_name) is equal to 1:
                    Let is_global be 1
                    Let found_global_ptr be global_ptr
                    Let j be global_count
                End If
                Let j be j plus 1
            End While
        End If

        If is_global is equal to 1:
            Note: Check if this global has an integer initial_value (compile-time constant)
            Let initial_value be memory_get_pointer(found_global_ptr, 16)  Note: global->initial_value
            If initial_value is not equal to 0:
                Let expr_type be memory_get_int32(initial_value, 0)  Note: initial_value->type
                If expr_type is equal to 0:  Note: EXPR_INTEGER (compile-time constant)
                    Let integer_value be memory_get_pointer(initial_value, 8)  Note: initial_value->data.integer_value
                    file_write_buffered(output_file, "    movq $", 0)
                    file_write_buffered(output_file, integer_to_string(integer_value), 0)
                    file_write_buffered(output_file, ", %rax  # Load compile-time constant ", 0)
                    file_write_buffered(output_file, variable_name, 0)
                    file_write_buffered(output_file, "\n", 0)
                    Return 0
                End If
            End If
            Note: Not a compile-time constant, generate runtime access
            file_write_buffered(output_file, "    movq ", 0)
            file_write_buffered(output_file, variable_name, 0)
            file_write_buffered(output_file, "(%rip), %rax  # Load global variable\n", 0)
            Return 0
        End If

        Note: Check if function name
        Let is_function be 0
        If current_program is not equal to 0:
            Let function_count be memory_get_int32(current_program, 8)  Note: PROGRAM_FUNCTION_COUNT
            Let functions be memory_get_pointer(current_program, 0)  Note: PROGRAM_FUNCTIONS

            Note: Optimization: get first character for fast filtering
            Let name_first_char be memory_get_byte(variable_name, 0)

            Let j be 0
            While j is less than function_count:
                Let func_offset be j multiplied by 8
                Let function_ptr be memory_get_pointer(functions, func_offset)
                Let function_name be memory_get_pointer(function_ptr, 0)

                Note: Fast path: check first character before expensive string_equals
                Let func_first_char be memory_get_byte(function_name, 0)
                If func_first_char is equal to name_first_char:
                    If string_equals(function_name, variable_name) is equal to 1:
                        Let is_function be 1
                        Let j be function_count
                    End If
                End If

                Let j be j plus 1
            End While
        End If

        If is_function is equal to 0:
            print_string("[CODEGEN ERROR] Undefined variable: ")
            print_string(variable_name)
            exit_with_code(1)
        End If

        file_write_buffered(output_file, "    leaq ", 0)
        file_write_buffered(output_file, variable_name, 0)
        file_write_buffered(output_file, "(%rip), %rax  # Load function address\n", 0)
        Return 0
    End If

    Note: Variable found in local scope
    Let variables be memory_get_pointer(codegen, 8)
    Let var_offset be var_index multiplied by 32
    Let var_ptr be variables plus var_offset
    Let offset be memory_get_integer(var_ptr, 8)
    Let var_type be memory_get_pointer(var_ptr, 16)

    Note: Check if this is a closure variable (offset == -1, appears as 4294967295 unsigned)
    If offset is equal to 4294967295:
        Note: This is a captured variable from closure environment
        Note: Environment pointer is at -8(%rbp), get actual offset from is_parameter field
        Let env_offset be memory_get_int32(var_ptr, 24)  Note: is_parameter field stores env offset
        emit_line(output_file, "    movq -8(%rbp), %rbx  # Load environment pointer")
        file_write_buffered(output_file, "    movq ", 0)
        file_write_buffered(output_file, integer_to_string(env_offset), 0)
        emit_line(output_file, "(%rbx), %rax  # Load captured variable from environment")
        Return 0
    End If

    Note: Check if array type
    Let is_array be 0
    Let current_program be memory_get_pointer(codegen, 48)

    If current_program is not equal to 0:
        Let type_count be memory_get_int32(current_program, 24)  Note: PROGRAM_TYPE_COUNT
        Let types be memory_get_pointer(current_program, 16)  Note: PROGRAM_TYPES

        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)
            If string_equals(type_name_ptr, var_type) is equal to 1:
                Let kind be memory_get_integer(type_ptr, 8)
                If kind is equal to 2:
                    Let is_array be 1
                End If
                Let i be type_count
            End If
            Let i be i plus 1
        End While
    End If

    If is_array is equal to 1:
        file_write_buffered(output_file, "    leaq -", 0)
        file_write_buffered(output_file, integer_to_string(offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax  # Load array address\n", 0)
    Otherwise:
        file_write_buffered(output_file, "    movq -", 0)
        file_write_buffered(output_file, integer_to_string(offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax\n", 0)
    End If

    Return 0
End Process

Note: Generate code for integer literal expressions
Process called "codegen_generate_integer_literal" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let integer_value be memory_get_pointer(expr, 8)  Note: expr->data.integer_value
    file_write_buffered(output_file, "    movq $", 0)
    file_write_buffered(output_file, integer_to_string(integer_value), 0)
    file_write_buffered(output_file, ", %rax\n", 0)
    Return 0
End Process

Note: Generate code for variable expressions
Process called "codegen_generate_variable_handler" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    codegen_generate_variable_expr(codegen, expr)  Note: Already extracted earlier
    Return 0
End Process

Note: Generate code for string literal expressions
Process called "codegen_generate_string_literal" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)

    Note: Safety check
    If expr is equal to 0:  Note: NULL pointer check
        print_string("[CODEGEN ERROR] Invalid string literal expression")
        exit_with_code(1)
    End If

    Let string_value be memory_get_pointer(expr, 8)  Note: expr->data.string_value

    Note: Find or add the string to the string table
    Let string_count be memory_get_int32(codegen, 40)  Note: codegen->string_count (after padding)
    Let string_literals be memory_get_pointer(codegen, 32)  Note: codegen->strings (pointer with padding)
    Let string_index be -1  Note: -1 for not found

    Let i be 0
    While i is less than string_count:
        Let str_offset be i multiplied by 16  Note: StringLiteral is 16 bytes
        Let stored_string be memory_get_pointer(string_literals, str_offset)
        If string_equals(stored_string, string_value) is equal to 1:
            Let string_index be i
            Let i be string_count  Note: break loop
        End If
        Let i be i plus 1
    End While

    If string_index is less than 0:
        Note: Add new string - this should call codegen_add_string_literal instead
        Let string_index be codegen_add_string_literal(codegen, string_value)
    End If

    Note: Generate reference to string
    file_write_buffered(output_file, "    leaq .STR", 0)
    file_write_buffered(output_file, integer_to_string(string_index), 0)
    file_write_buffered(output_file, "(%rip), %rax\n", 0)
    Return 0
End Process

Note: Generate code for binary operation expressions
Process called "codegen_generate_binary_op" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let left be memory_get_pointer(expr, 8)         Note: binary_op.left
    Let right be memory_get_pointer(expr, 16)       Note: binary_op.right
    Let operator be memory_get_integer(expr, 24)    Note: binary_op.operator

    Note: OPTIMIZATION: For simple right operands (variables/integers), use direct register operations
    Let right_type be memory_get_int32(right, 0)
    Let use_direct_op be 0

    Note: Check if right is a simple variable (EXPR_VARIABLE = 1)
    If right_type is equal to 1:
        Let use_direct_op be 1
    End If

    Note: Check if right is an integer literal (EXPR_INTEGER = 0)
    If right_type is equal to 0:
        Let use_direct_op be 1
    End If

    If use_direct_op is equal to 1:
        Note: OPTIMIZED PATH: Direct register operations (3 instructions instead of 6)
        Note: Generate left operand (result in %rax)
        codegen_generate_expression(codegen, left)

        Note: For simple operations, operate directly on right without stack
        If operator is equal to 16:  Note: TOKEN_PLUS
            If right_type is equal to 0:  Note: Integer literal
                Let int_val be memory_get_pointer(right, 8)
                file_write_buffered(output_file, "    addq $", 0)
                file_write_buffered(output_file, integer_to_string(int_val), 0)
                file_write_buffered(output_file, ", %rax\n", 0)
            Otherwise:  Note: Variable
                Let var_name be memory_get_pointer(right, 8)
                Let var_index be codegen_find_variable(codegen, var_name)
                If var_index is greater than or equal to 0:
                    Let variables be memory_get_pointer(codegen, 8)
                    Let var_offset be var_index multiplied by 32
                    Let var_ptr be variables plus var_offset
                    Let stack_offset be memory_get_integer(var_ptr, 8)
                    Note: Check if this is a closure variable (offset == -1, appears as 4294967295 unsigned)
                    If stack_offset is equal to 4294967295:
                        Note: Closure variable, use general expression path
                        emit_line(output_file, "    pushq %rax")
                        codegen_generate_expression(codegen, right)
                        emit_line(output_file, "    popq %rbx")
                        emit_line(output_file, "    addq %rbx, %rax")
                    Otherwise:
                        file_write_buffered(output_file, "    addq -", 0)
                        file_write_buffered(output_file, integer_to_string(stack_offset), 0)
                        file_write_buffered(output_file, "(%rbp), %rax\n", 0)
                    End If
                Otherwise:
                    Note: Fallback to stack-based for complex cases
                    emit_line(output_file, "    pushq %rax")
                    codegen_generate_expression(codegen, right)
                    emit_line(output_file, "    popq %rbx")
                    emit_line(output_file, "    addq %rbx, %rax")
                End If
            End If
        Otherwise If operator is equal to 17:  Note: TOKEN_MINUS
            If right_type is equal to 0:  Note: Integer literal
                Let int_val be memory_get_pointer(right, 8)
                file_write_buffered(output_file, "    subq $", 0)
                file_write_buffered(output_file, integer_to_string(int_val), 0)
                file_write_buffered(output_file, ", %rax\n", 0)
            Otherwise:  Note: Variable
                Let var_name be memory_get_pointer(right, 8)
                Let var_index be codegen_find_variable(codegen, var_name)
                If var_index is greater than or equal to 0:
                    Let variables be memory_get_pointer(codegen, 8)
                    Let var_offset be var_index multiplied by 32
                    Let var_ptr be variables plus var_offset
                    Let stack_offset be memory_get_integer(var_ptr, 8)
                    Note: Check if this is a closure variable (offset == -1, appears as 4294967295 unsigned)
                    If stack_offset is equal to 4294967295:
                        Note: Closure variable, use general expression path
                        emit_line(output_file, "    pushq %rax")
                        codegen_generate_expression(codegen, right)
                        emit_line(output_file, "    popq %rbx")
                        emit_line(output_file, "    subq %rax, %rbx")
                        emit_line(output_file, "    movq %rbx, %rax")
                    Otherwise:
                        file_write_buffered(output_file, "    subq -", 0)
                        file_write_buffered(output_file, integer_to_string(stack_offset), 0)
                        file_write_buffered(output_file, "(%rbp), %rax\n", 0)
                    End If
                Otherwise:
                    Note: Fallback to stack-based for complex cases
                    emit_line(output_file, "    pushq %rax")
                    codegen_generate_expression(codegen, right)
                    emit_line(output_file, "    popq %rbx")
                    emit_line(output_file, "    subq %rax, %rbx")
                    emit_line(output_file, "    movq %rbx, %rax")
                End If
            End If
        Otherwise If operator is equal to 35:  Note: TOKEN_MULTIPLIED
            Note: Multiply requires both operands in registers, use stack-based
            emit_line(output_file, "    pushq %rax")
            codegen_generate_expression(codegen, right)
            emit_line(output_file, "    popq %rbx")
            emit_line(output_file, "    imulq %rbx, %rax")
        Note: For operations that require %rbx (div, mod, bitwise, shifts), use stack-based
        Otherwise If operator is equal to 36:  Note: TOKEN_DIVIDED
            emit_line(output_file, "    pushq %rax")
            codegen_generate_expression(codegen, right)
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    popq %rax")
            emit_line(output_file, "    testq %rcx, %rcx")
            Let label_counter be memory_get_int32(codegen, 28)
            file_write_buffered(output_file, "    jz .Ldiv_by_zero_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, "\n", 0)
            emit_line(output_file, "    cqto")
            emit_line(output_file, "    idivq %rcx")
            file_write_buffered(output_file, "    jmp .Ldiv_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, "\n", 0)
            file_write_buffered(output_file, ".Ldiv_by_zero_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            emit_line(output_file, "    movq $0, %rax")
            file_write_buffered(output_file, ".Ldiv_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            memory_set_int32(codegen, 28, label_counter plus 1)
        Otherwise If operator is equal to 37:  Note: TOKEN_MODULO
            emit_line(output_file, "    pushq %rax")
            codegen_generate_expression(codegen, right)
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    popq %rax")
            emit_line(output_file, "    testq %rcx, %rcx")
            Let label_counter be memory_get_int32(codegen, 28)
            file_write_buffered(output_file, "    jz .Lmod_by_zero_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, "\n", 0)
            emit_line(output_file, "    cqto")
            emit_line(output_file, "    idivq %rcx")
            emit_line(output_file, "    movq %rdx, %rax")
            file_write_buffered(output_file, "    jmp .Lmod_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, "\n", 0)
            file_write_buffered(output_file, ".Lmod_by_zero_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            emit_line(output_file, "    movq $0, %rax")
            file_write_buffered(output_file, ".Lmod_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            memory_set_int32(codegen, 28, label_counter plus 1)
        Otherwise If operator is equal to 39:  Note: TOKEN_BIT_AND
            If right_type is equal to 0:  Note: Integer literal
                Let int_val be memory_get_pointer(right, 8)
                file_write_buffered(output_file, "    andq $", 0)
                file_write_buffered(output_file, integer_to_string(int_val), 0)
                file_write_buffered(output_file, ", %rax\n", 0)
            Otherwise:  Note: Variable or complex
                emit_line(output_file, "    pushq %rax")
                codegen_generate_expression(codegen, right)
                emit_line(output_file, "    popq %rbx")
                emit_line(output_file, "    andq %rbx, %rax")
            End If
        Otherwise If operator is equal to 40:  Note: TOKEN_BIT_OR
            If right_type is equal to 0:  Note: Integer literal
                Let int_val be memory_get_pointer(right, 8)
                file_write_buffered(output_file, "    orq $", 0)
                file_write_buffered(output_file, integer_to_string(int_val), 0)
                file_write_buffered(output_file, ", %rax\n", 0)
            Otherwise:  Note: Variable or complex
                emit_line(output_file, "    pushq %rax")
                codegen_generate_expression(codegen, right)
                emit_line(output_file, "    popq %rbx")
                emit_line(output_file, "    orq %rbx, %rax")
            End If
        Otherwise If operator is equal to 41:  Note: TOKEN_BIT_XOR
            If right_type is equal to 0:  Note: Integer literal
                Let int_val be memory_get_pointer(right, 8)
                file_write_buffered(output_file, "    xorq $", 0)
                file_write_buffered(output_file, integer_to_string(int_val), 0)
                file_write_buffered(output_file, ", %rax\n", 0)
            Otherwise:  Note: Variable or complex
                emit_line(output_file, "    pushq %rax")
                codegen_generate_expression(codegen, right)
                emit_line(output_file, "    popq %rbx")
                emit_line(output_file, "    xorq %rbx, %rax")
            End If
        Otherwise If operator is equal to 42:  Note: TOKEN_BIT_SHIFT_LEFT
            emit_line(output_file, "    pushq %rax")
            codegen_generate_expression(codegen, right)
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    popq %rax")
            emit_line(output_file, "    salq %cl, %rax")
        Otherwise If operator is equal to 43:  Note: TOKEN_BIT_SHIFT_RIGHT
            emit_line(output_file, "    pushq %rax")
            codegen_generate_expression(codegen, right)
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    popq %rax")
            emit_line(output_file, "    sarq %cl, %rax")
        End If
    Otherwise:
        Note: FALLBACK PATH: Complex expressions use stack-based evaluation
        Note: Generate left operand (result in %rax)
        codegen_generate_expression(codegen, left)
        emit_line(output_file, "    pushq %rax")
        Note: Generate right operand (result in %rax)
        codegen_generate_expression(codegen, right)
        emit_line(output_file, "    popq %rbx")

        Note: Perform the operation based on operator
        If operator is equal to 16:  Note: TOKEN_PLUS
            emit_line(output_file, "    addq %rbx, %rax")
        Otherwise If operator is equal to 17:  Note: TOKEN_MINUS
            emit_line(output_file, "    subq %rax, %rbx")
            emit_line(output_file, "    movq %rbx, %rax")
        Otherwise If operator is equal to 35:  Note: TOKEN_MULTIPLIED
            emit_line(output_file, "    imulq %rbx, %rax")
        Otherwise If operator is equal to 36:  Note: TOKEN_DIVIDED
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    movq %rbx, %rax")
            emit_line(output_file, "    testq %rcx, %rcx")
            Let label_counter be memory_get_int32(codegen, 28)
            Let jz_label be string_concat("    jz .Ldiv_by_zero_", integer_to_string(label_counter))
            emit_line(output_file, jz_label)
            emit_line(output_file, "    cqto")
            emit_line(output_file, "    idivq %rcx")
            Note: Use file_write_buffered instead of string_concat to avoid allocations
            file_write_buffered(output_file, "    jmp .Ldiv_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, "\n", 0)
            file_write_buffered(output_file, ".Ldiv_by_zero_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            emit_line(output_file, "    movq $0, %rax")
            file_write_buffered(output_file, ".Ldiv_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            memory_set_int32(codegen, 28, label_counter plus 1)
        Otherwise If operator is equal to 37:  Note: TOKEN_MODULO
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    movq %rbx, %rax")
            emit_line(output_file, "    testq %rcx, %rcx")
            Let label_counter be memory_get_int32(codegen, 28)
            Let jz_label be string_concat("    jz .Lmod_by_zero_", integer_to_string(label_counter))
            emit_line(output_file, jz_label)
            emit_line(output_file, "    cqto")
            emit_line(output_file, "    idivq %rcx")
            emit_line(output_file, "    movq %rdx, %rax")
            Note: Use file_write_buffered instead of string_concat to avoid allocations
            file_write_buffered(output_file, "    jmp .Lmod_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, "\n", 0)
            file_write_buffered(output_file, ".Lmod_by_zero_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            emit_line(output_file, "    movq $0, %rax")
            file_write_buffered(output_file, ".Lmod_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            memory_set_int32(codegen, 28, label_counter plus 1)
        Otherwise If operator is equal to 39:  Note: TOKEN_BIT_AND
            emit_line(output_file, "    andq %rbx, %rax")
        Otherwise If operator is equal to 40:  Note: TOKEN_BIT_OR
            emit_line(output_file, "    orq %rbx, %rax")
        Otherwise If operator is equal to 41:  Note: TOKEN_BIT_XOR
            emit_line(output_file, "    xorq %rbx, %rax")
        Otherwise If operator is equal to 42:  Note: TOKEN_BIT_SHIFT_LEFT
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    movq %rbx, %rax")
            emit_line(output_file, "    salq %cl, %rax")
        Otherwise If operator is equal to 43:  Note: TOKEN_BIT_SHIFT_RIGHT
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    movq %rbx, %rax")
            emit_line(output_file, "    sarq %cl, %rax")
        Otherwise If operator is equal to 30:  Note: TOKEN_AND
            emit_line(output_file, "    andq %rbx, %rax")
        Otherwise If operator is equal to 31:  Note: TOKEN_OR
            emit_line(output_file, "    orq %rbx, %rax")
        End If
    End If
    Return 0
End Process

Note: Generate code for unary operators (NOT)
Process called "codegen_generate_unary_op" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let operator be memory_get_integer(expr, 8)
    Let operand be memory_get_pointer(expr, 16)

    codegen_generate_expression(codegen, operand)

    If operator is equal to 29:  Note: TOKEN_NOT
        emit_line(output_file, "    testq %rax, %rax")
        emit_line(output_file, "    setz %al")
        emit_line(output_file, "    movzbq %al, %rax")
    End If

    Return 0
End Process

Note: Generate code for comparison expressions
Process called "codegen_generate_comparison" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let left be memory_get_pointer(expr, 8)           Note: comparison.left
    Let right be memory_get_pointer(expr, 16)         Note: comparison.right
    Let comparison_op be memory_get_integer(expr, 24) Note: comparison.comparison_op

    Note: Generate left operand (result in %rax)
    codegen_generate_expression(codegen, left)
    emit_line(output_file, "    pushq %rax")
    Note: Generate right operand (result in %rax)
    codegen_generate_expression(codegen, right)
    emit_line(output_file, "    popq %rbx")

    Note: Compare and set result
    emit_line(output_file, "    cmpq %rax, %rbx")
    If comparison_op is equal to 22:  Note: TOKEN_EQUAL
        emit_line(output_file, "    sete %al")
    Otherwise If comparison_op is equal to 23:  Note: TOKEN_NOT_EQUAL
        emit_line(output_file, "    setne %al")
    Otherwise If comparison_op is equal to 24:  Note: TOKEN_LESS
        emit_line(output_file, "    setl %al")
    Otherwise If comparison_op is equal to 25:  Note: TOKEN_GREATER
        emit_line(output_file, "    setg %al")
    Otherwise If comparison_op is equal to 27:  Note: TOKEN_LESS_EQUAL
        emit_line(output_file, "    setle %al")
    Otherwise If comparison_op is equal to 26:  Note: TOKEN_GREATER_EQUAL
        emit_line(output_file, "    setge %al")
    End If
    emit_line(output_file, "    movzbq %al, %rax")
    Return 0
End Process

Note: Generate code for function call expressions
Process called "codegen_generate_function_call" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let function_call_ptr be expr plus 8  Note: &expr->data.function_call
    Let function_name be memory_get_pointer(function_call_ptr, 0)  Note: function_call.function_name
    Let arguments be memory_get_pointer(function_call_ptr, 8)      Note: function_call.arguments
    Let arg_count be memory_get_int32(function_call_ptr, 16)     Note: function_call.argument_count

    Note: Safety check for function_name
    If function_name is equal to 0:  Note: NULL pointer check
        exit_with_code(1)
    End If

    Note: Generate argument values in reverse order (right-to-left evaluation)
    Let i be arg_count minus 1
    While i is greater than or equal to 0:
        Let arg_offset be i multiplied by 8
        Let arg_expr be memory_get_pointer(arguments, arg_offset)

        Note: Debug check
        If arg_expr is equal to 0:
            print_string("[CODEGEN ERROR] NULL argument expression pointer: ")
            print_integer(arg_expr)
            exit_with_code(1)
        End If

        codegen_generate_expression(codegen, arg_expr)
        file_write_buffered(output_file, "    pushq %rax\n", 0)
        Let i be i minus 1
    End While

    Note: Pop arguments into registers
    If arg_count is greater than or equal to 1:
        file_write_buffered(output_file, "    popq %rdi\n", 0)
    End If
    If arg_count is greater than or equal to 2:
        file_write_buffered(output_file, "    popq %rsi\n", 0)
    End If
    If arg_count is greater than or equal to 3:
        file_write_buffered(output_file, "    popq %rdx\n", 0)
    End If
    If arg_count is greater than or equal to 4:
        file_write_buffered(output_file, "    popq %rcx\n", 0)
    End If
    If arg_count is greater than or equal to 5:
        file_write_buffered(output_file, "    popq %r8\n", 0)
    End If
    If arg_count is greater than or equal to 6:
        file_write_buffered(output_file, "    popq %r9\n", 0)
    End If

    Note: Call the function - add @PLT for external runtime functions
    file_write_buffered(output_file, "    call ", 0)
    file_write_buffered(output_file, function_name, 0)

    Note: Check if this is a runtime function that needs @PLT
    Let needs_plt be 0
    If string_equals(function_name, "allocate") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "deallocate") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_allocate") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_reallocate") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "string_length") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "string_char_at") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "string_equals") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "string_compare") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "string_find") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "string_substring") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "string_duplicate") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "string_concat") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "integer_to_string") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "ascii_value_of") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "is_digit") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "is_whitespace") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "file_open_buffered") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "file_write_buffered") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "file_close_buffered") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_get_byte") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_set_byte") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_get_int32") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_set_int32") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_get_integer") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_set_integer") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_get_pointer") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_set_pointer") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_set_pointer_at_index") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "exit_with_code") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "read_file_internal") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "get_command_line_arg") is equal to 1: Let needs_plt be 1
    End If
    Note: Note: print_string, print_integer, string_copy_n, string_set_char are Runa functions - no @PLT

    If needs_plt is equal to 1:
        file_write_buffered(output_file, "@PLT", 0)
    End If
    file_write_buffered(output_file, "\n", 0)

    Note: Result is now in %rax (x86_64 calling convention)
    Note: The function result is left in %rax for the calling code to use
    Return 0
End Process

Note: Generate code for indirect function call expressions (function pointers)
Process called "codegen_generate_indirect_call" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let function_call_ptr be expr plus 8  Note: &expr->data.function_call (same structure)
    Let function_expr be memory_get_pointer(function_call_ptr, 0)  Note: Expression that evaluates to function pointer
    Let arguments be memory_get_pointer(function_call_ptr, 8)      Note: function_call.arguments
    Let arg_count be memory_get_int32(function_call_ptr, 16)     Note: function_call.argument_count

    Note: Generate argument values in reverse order (right-to-left evaluation)
    Let i be arg_count minus 1
    While i is greater than or equal to 0:
        Let arg_offset be i multiplied by 8
        Let arg_expr be memory_get_pointer(arguments, arg_offset)
        codegen_generate_expression(codegen, arg_expr)
        file_write_buffered(output_file, "    pushq %rax\n", 0)
        Let i be i minus 1
    End While

    Note: Pop arguments into registers
    If arg_count is greater than or equal to 1:
        file_write_buffered(output_file, "    popq %rdi\n", 0)
    End If
    If arg_count is greater than or equal to 2:
        file_write_buffered(output_file, "    popq %rsi\n", 0)
    End If
    If arg_count is greater than or equal to 3:
        file_write_buffered(output_file, "    popq %rdx\n", 0)
    End If
    If arg_count is greater than or equal to 4:
        file_write_buffered(output_file, "    popq %rcx\n", 0)
    End If
    If arg_count is greater than or equal to 5:
        file_write_buffered(output_file, "    popq %r8\n", 0)
    End If
    If arg_count is greater than or equal to 6:
        file_write_buffered(output_file, "    popq %r9\n", 0)
    End If

    Note: Save function pointer expression - evaluate it into a temporary register
    Note: We need to be careful not to clobber argument registers
    file_write_buffered(output_file, "    pushq %rdi\n", 0)  Note: Save args if present
    If arg_count is greater than or equal to 2:
        file_write_buffered(output_file, "    pushq %rsi\n", 0)
    End If
    If arg_count is greater than or equal to 3:
        file_write_buffered(output_file, "    pushq %rdx\n", 0)
    End If
    If arg_count is greater than or equal to 4:
        file_write_buffered(output_file, "    pushq %rcx\n", 0)
    End If
    If arg_count is greater than or equal to 5:
        file_write_buffered(output_file, "    pushq %r8\n", 0)
    End If
    If arg_count is greater than or equal to 6:
        file_write_buffered(output_file, "    pushq %r9\n", 0)
    End If

    Note: Evaluate function pointer expression into %rax
    codegen_generate_expression(codegen, function_expr)
    file_write_buffered(output_file, "    movq %rax, %r10  # Save function pointer\n", 0)

    Note: Restore argument registers
    If arg_count is greater than or equal to 6:
        file_write_buffered(output_file, "    popq %r9\n", 0)
    End If
    If arg_count is greater than or equal to 5:
        file_write_buffered(output_file, "    popq %r8\n", 0)
    End If
    If arg_count is greater than or equal to 4:
        file_write_buffered(output_file, "    popq %rcx\n", 0)
    End If
    If arg_count is greater than or equal to 3:
        file_write_buffered(output_file, "    popq %rdx\n", 0)
    End If
    If arg_count is greater than or equal to 2:
        file_write_buffered(output_file, "    popq %rsi\n", 0)
    End If
    file_write_buffered(output_file, "    popq %rdi\n", 0)

    Note: Make indirect call through function pointer in %r10
    file_write_buffered(output_file, "    call *%r10  # Indirect call through function pointer\n", 0)

    Note: Result is now in %rax
    Return 0
End Process

Note: Generate code for field access expressions
Process called "codegen_generate_field_access" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let field_access_ptr be expr plus 8  Note: Union at offset 8
    Let obj be memory_get_pointer(field_access_ptr, 0)
    Let field_name be memory_get_pointer(field_access_ptr, 8)

    Note: Get the type of the object
    Let object_type be codegen_get_expression_type(codegen, obj)
    If object_type is equal to 0:
        print_string("[CODEGEN ERROR] Cannot determine type of object in field access")
        exit_with_code(1)
    End If

    Note: Find the type definition
    Let current_program be memory_get_pointer(codegen, 48)  Note: codegen->current_program
    Let type_count be memory_get_int32(current_program, 24)  Note: PROGRAM_TYPE_COUNT
    Let types be memory_get_pointer(current_program, 16)     Note: PROGRAM_TYPES
    Let type be 0

    Let i be 0
    While i is less than type_count:
        Let type_offset be i multiplied by 8
        Let type_ptr be memory_get_pointer(types, type_offset)
        Let type_name_ptr be memory_get_pointer(type_ptr, 0)  Note: type->name
        If string_equals(type_name_ptr, object_type) is equal to 1:
            Let type be type_ptr
            Let i be type_count  Note: break loop
        End If
        Let i be i plus 1
    End While

    If type is equal to 0:
        print_string("[CODEGEN ERROR] Unknown type '")
        print_string(object_type)
        print_string("'")
        exit_with_code(1)
    End If


    Note: Find field offset
    Let field_offset be -1  Note: -1 for not found
    Let kind be memory_get_int32(type, 8)  Note: type->kind

    If kind is equal to 0:  Note: TYPE_KIND_STRUCT
        Note: TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET is 24
        Note: TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET is 16
        Let field_count be memory_get_int32(type, 24)
        Let fields be memory_get_pointer(type, 16)

        Let j be 0
        While j is less than field_count:
            Let field_idx_offset be j multiplied by 24
            Let field_ptr be fields plus field_idx_offset  Note: sizeof(FieldDefinition)
            Let field_name_ptr be memory_get_pointer(field_ptr, 0)  Note: field.name
            If string_equals(field_name_ptr, field_name) is equal to 1:
                Let field_offset be memory_get_int32(field_ptr, 16)  Note: field.offset
                Let j be field_count  Note: break loop
            End If
            Let j be j plus 1
        End While
    End If

    If field_offset is less than 0:  Note: -1 for not found
        print_string("[CODEGEN ERROR] Type '")
        print_string(object_type)
        print_string("' has no field '")
        print_string(field_name)
        print_string("'")
        exit_with_code(1)
    End If

    Note: Generate code to load object address and access field
    Let obj_type be memory_get_int32(obj, 0)

    If obj_type is equal to 1:  Note: EXPR_VARIABLE
        Let obj_variable_name be memory_get_pointer(obj, 8)
        Let var_index be codegen_find_variable(codegen, obj_variable_name)
        If var_index is less than 0:
            print_string("[CODEGEN ERROR] Unknown variable")
            exit_with_code(1)
        End If

        Let variables be memory_get_pointer(codegen, 8)
        Let var_offset be var_index multiplied by 32
        Let var_ptr be variables plus var_offset
        Let stack_offset be memory_get_int32(var_ptr, 8)

        file_write_buffered(output_file, "    movq -", 0)
        file_write_buffered(output_file, integer_to_string(stack_offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax\n", 0)

        Note: Add field offset and dereference
        file_write_buffered(output_file, "    movq ", 0)
        file_write_buffered(output_file, integer_to_string(field_offset), 0)
        file_write_buffered(output_file, "(%rax), %rax\n", 0)
    Otherwise:
        Note: For complex expressions, generate the expression first
        codegen_generate_expression(codegen, obj)
        file_write_buffered(output_file, "    movq ", 0)
        file_write_buffered(output_file, integer_to_string(field_offset), 0)
        file_write_buffered(output_file, "(%rax), %rax\n", 0)
    End If

    Return 0
End Process

Note: Handle builtin call expressions
Process called "codegen_generate_builtin_call" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file
    Let builtin_call_ptr be expr plus 8  Note: &expr->data.builtin_call
    Let builtin_type be memory_get_int32(builtin_call_ptr, 0)  Note: builtin_call.builtin_type
    Let arguments be memory_get_pointer(builtin_call_ptr, 8)     Note: builtin_call.arguments
    Let arg_count be memory_get_int32(builtin_call_ptr, 16)    Note: builtin_call.argument_count

    Note: Map builtin types to function names - split into ranges to avoid deep nesting limits
    Let func_name be ""

    Note: First generate all argument values onto stack
    Let i be arg_count minus 1
    While i is greater than or equal to 0:
        Let arg_offset be i multiplied by 8
        Let arg_expr be memory_get_pointer(arguments, arg_offset)
        codegen_generate_expression(codegen, arg_expr)
        file_write_buffered(output_file, "    pushq %rax\n", 0)
        Let i be i minus 1
    End While

    Note: Pop arguments into the correct registers based on calling convention
    If arg_count is greater than or equal to 1:
        file_write_buffered(output_file, "    popq %rdi\n", 0)
    End If
    If arg_count is greater than or equal to 2:
        file_write_buffered(output_file, "    popq %rsi\n", 0)
    End If
    If arg_count is greater than or equal to 3:
        file_write_buffered(output_file, "    popq %rdx\n", 0)
    End If
    If arg_count is greater than or equal to 4:
        file_write_buffered(output_file, "    popq %rcx\n", 0)
    End If
    If arg_count is greater than or equal to 5:
        file_write_buffered(output_file, "    popq %r8\n", 0)
    End If
    If arg_count is greater than or equal to 6:
        file_write_buffered(output_file, "    popq %r9\n", 0)
    End If

    Note: Map builtin_type to function name
    Note: Since we don't have all builtins implemented, generate a generic name
    Note: This allows compilation to proceed but these calls won't work at runtime
    file_write_buffered(output_file, "    # Unimplemented builtin type ", 0)
    file_write_buffered(output_file, integer_to_string(builtin_type), 0)
    file_write_buffered(output_file, "\n", 0)
    file_write_buffered(output_file, "    movq $0, %rax  # Placeholder return value\n", 0)

    Return 0
End Process

Note: Generate code for expression - equivalent to codegen_generate_expression
Note: Simplified codegen_generate_expression that replaces the massive 1155-line function
Note: This will be inserted into codegen.runa to replace lines 1276-2431

Process called "codegen_generate_expression" takes codegen as Integer, expr as Integer returns Integer:
    Note: Safety check
    If expr is equal to 0:  Note: NULL pointer check
        print_string("[CODEGEN ERROR] NULL expression pointer")
        exit_with_code(1)
    End If

    Let expr_type be memory_get_int32(expr, 0)  Note: expr->type
    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file

    Note: Simple dispatcher without deep nesting
    If expr_type is equal to 0:  Note: EXPR_INTEGER_LITERAL
        Let integer_value be memory_get_integer(expr, 8)
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(integer_value), 0)
        file_write_buffered(output_file, ", %rax\n", 0)
        Return 0
    Otherwise If expr_type is equal to 1:  Note: EXPR_VARIABLE
        codegen_generate_variable_expr(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 2:  Note: EXPR_BINARY_OP
        codegen_generate_binary_op(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 3:  Note: EXPR_COMPARISON
        codegen_generate_comparison(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 4:  Note: EXPR_FUNCTION_CALL
        codegen_generate_function_call(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 11:  Note: EXPR_INDIRECT_CALL
        codegen_generate_indirect_call(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 12:  Note: EXPR_UNARY (NOT operator)
        codegen_generate_unary_op(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 5:  Note: EXPR_STRING_LITERAL
        codegen_generate_string_literal(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 6:  Note: EXPR_FIELD_ACCESS
        codegen_generate_field_access(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 7:  Note: EXPR_TYPE_CAST
        Let cast_expr be memory_get_pointer(expr, 16)
        codegen_generate_expression(codegen, cast_expr)
        Return 0
    Otherwise If expr_type is equal to 8:  Note: EXPR_BUILTIN_CALL
        Note: Simplified builtin call for Stage 1
        Let builtin_call_ptr be expr plus 8  Note: Union at offset 4
        Let arguments be memory_get_pointer(builtin_call_ptr, 8)
        Let arg_count be memory_get_integer(builtin_call_ptr, 16)

        Note: Generate arguments in reverse
        Let i be arg_count minus 1
        While i is greater than or equal to 0:
            Let arg_offset be i multiplied by 8
            Let arg_expr be memory_get_pointer(arguments, arg_offset)
            codegen_generate_expression(codegen, arg_expr)
            file_write_buffered(output_file, "    pushq %rax\n", 0)
            Let i be i minus 1
        End While

        Note: Pop into registers
        If arg_count is greater than 0:
            file_write_buffered(output_file, "    popq %rdi\n", 0)
        End If
        If arg_count is greater than 1:
            file_write_buffered(output_file, "    popq %rsi\n", 0)
        End If
        If arg_count is greater than 2:
            file_write_buffered(output_file, "    popq %rdx\n", 0)
        End If

        Note: Get builtin type token and map to function name
        Let builtin_type be memory_get_int32(builtin_call_ptr, 0)
        Let func_name be 0  Note: Will be set based on token

        Note: Map TOKEN to runtime function name
        If builtin_type is equal to 57: Let func_name be "string_length"  Note: TOKEN_STRING_LENGTH
        Otherwise If builtin_type is equal to 58: Let func_name be "string_char_at"  Note: TOKEN_STRING_CHAR_AT
        Otherwise If builtin_type is equal to 59: Let func_name be "string_substring"  Note: TOKEN_STRING_SUBSTRING
        Otherwise If builtin_type is equal to 60: Let func_name be "string_equals"  Note: TOKEN_STRING_EQUALS
        Otherwise If builtin_type is equal to 61: Let func_name be "ascii_value_of"  Note: TOKEN_ASCII_VALUE_OF
        Otherwise If builtin_type is equal to 62: Let func_name be "is_digit"  Note: TOKEN_IS_DIGIT
        Otherwise If builtin_type is equal to 64: Let func_name be "is_whitespace"  Note: TOKEN_IS_WHITESPACE
        Otherwise If builtin_type is equal to 72: Let func_name be "string_find"  Note: TOKEN_STRING_FIND
        Otherwise If builtin_type is equal to 73: Let func_name be "string_compare"  Note: TOKEN_STRING_COMPARE
        Otherwise If builtin_type is equal to 74: Let func_name be "string_concat"  Note: TOKEN_STRING_CONCAT
        Otherwise If builtin_type is equal to 75: Let func_name be "string_duplicate"  Note: TOKEN_STRING_DUPLICATE
        Otherwise If builtin_type is equal to 76: Let func_name be "integer_to_string"  Note: TOKEN_INTEGER_TO_STRING
        Otherwise If builtin_type is equal to 119: Let func_name be "allocate"  Note: TOKEN_ALLOCATE
        Otherwise If builtin_type is equal to 120: Let func_name be "deallocate"  Note: TOKEN_DEALLOCATE
        Otherwise If builtin_type is equal to 130: Let func_name be "memory_get_byte"  Note: TOKEN_MEMORY_GET_BYTE
        Otherwise If builtin_type is equal to 131: Let func_name be "memory_set_byte"  Note: TOKEN_MEMORY_SET_BYTE
        End If

        Note: Generate the call
        file_write_buffered(output_file, "    call ", 0)
        If func_name is equal to 0:
            file_write_buffered(output_file, "unknown_builtin_", 0)
            file_write_buffered(output_file, integer_to_string(builtin_type), 0)
        Otherwise:
            file_write_buffered(output_file, func_name, 0)
            file_write_buffered(output_file, "@PLT", 0)
        End If
        file_write_buffered(output_file, "\n", 0)
        Return 0
    Otherwise If expr_type is equal to 9:  Note: EXPR_VARIANT_CONSTRUCTOR
        Note: Get variant details
        Let type_name be memory_get_pointer(expr, 8)
        Let variant_name be memory_get_pointer(expr, 16)
        Let field_count be memory_get_int32(expr, 32)

        Note: Find the variant definition to get the tag
        Let current_program be memory_get_pointer(codegen, 48)
        Let type_count be memory_get_int32(current_program, 24)
        Let types be memory_get_pointer(current_program, 16)

        Let variant_tag be 0
        Let i be 0
        While i is less than type_count:
            Let type_ptr be memory_get_pointer_at_index(types, i)
            Let type_def_name be memory_get_pointer(type_ptr, 0)
            If string_equals(type_def_name, type_name) is equal to 1:
                Note: Found the type, now find the variant
                Let variant_count be memory_get_int32(type_ptr, 24)
                Let variants be memory_get_pointer(type_ptr, 16)

                Note: Loop through all variants to find match
                Let vi be 0
                Let found_match be 0
                While vi is less than variant_count:
                    Let variant_offset be vi multiplied by 32
                    Let variant_ptr be variants plus variant_offset
                    Let vname be memory_get_pointer(variant_ptr, 0)

                    If string_equals(vname, variant_name) is equal to 1:
                        Set variant_tag to memory_get_int32(variant_ptr, 20)
                        Set found_match to 1
                        Set vi to variant_count  Note: Break
                    Otherwise:
                        Set vi to vi plus 1
                    End If
                End While

                Note: If no match found, default to first variant (temporary workaround)
                If found_match is equal to 0:
                    If variant_count is greater than 0:
                        Let first_variant_ptr be variants
                        Set variant_tag to memory_get_int32(first_variant_ptr, 20)
                    End If
                End If
                Set i to type_count  Note: Break
            End If
            Set i to i plus 1
        End While

        Note: Allocate variant (8 bytes for tag + field storage)
        Let alloc_size be 8  Note: Just tag for fieldless variants
        If field_count is greater than 0:
            Let field_storage be field_count multiplied by 8
            Set alloc_size to alloc_size plus field_storage
        End If

        emit_line(output_file, "    # Allocate variant")
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(alloc_size), 0)
        file_write_buffered(output_file, ", %rdi\n", 0)
        emit_line(output_file, "    call allocate")

        Note: Store discriminator tag at offset 0
        file_write_buffered(output_file, "    movl $", 0)
        file_write_buffered(output_file, integer_to_string(variant_tag), 0)
        file_write_buffered(output_file, ", (%rax)  # Store variant tag\n", 0)

        Note: Store field values if field_count > 0
        If field_count is greater than 0:
            file_write_buffered(output_file, "    pushq %rax  # Save variant pointer\n", 0)

            Let field_values be memory_get_pointer(expr, 24)
            Let k be 0
            While k is less than field_count:
                Note: Generate field value expression
                Let field_value_expr be memory_get_pointer(field_values, k multiplied by 8)
                codegen_generate_expression(codegen, field_value_expr)

                Note: Store field value at offset 8 + (k * 8)
                Let field_offset be 8 plus k multiplied by 8
                file_write_buffered(output_file, "    movq (%rsp), %rbx  # Load variant pointer\n", 0)
                file_write_buffered(output_file, "    movq %rax, ", 0)
                file_write_buffered(output_file, integer_to_string(field_offset), 0)
                file_write_buffered(output_file, "(%rbx)  # Store field ", 0)
                file_write_buffered(output_file, integer_to_string(k), 0)
                file_write_buffered(output_file, "\n", 0)

                Set k to k plus 1
            End While

            file_write_buffered(output_file, "    popq %rax  # Restore variant pointer\n", 0)
        End If

        Return 0
    Otherwise If expr_type is equal to 10:  Note: EXPR_FUNCTION_POINTER
        Let function_pointer_ptr be expr plus 8  Note: Union at offset 4
        Let func_name be memory_get_pointer(function_pointer_ptr, 0)
        file_write_buffered(output_file, "    leaq ", 0)
        file_write_buffered(output_file, func_name, 0)
        file_write_buffered(output_file, "(%rip), %rax\n", 0)
        Return 0
    Otherwise If expr_type is equal to 16:  Note: EXPR_ARRAY_INDEX
        Note: Array indexing: array[index]
        Let array_expr be memory_get_pointer(expr, 8)
        Let index_expr be memory_get_pointer(expr, 16)

        Note: COMPILE-TIME BOUNDS CHECKING
        Note: If index is a constant integer literal, check bounds at compile time
        Let index_type be memory_get_int32(index_expr, 0)
        If index_type is equal to 0:  Note: EXPR_INTEGER_LITERAL
            Let constant_index be memory_get_int32(index_expr, 8)

            Note: Check if index is negative (always invalid)
            If constant_index is less than 0:
                print_string("[SAFETY ERROR] Array index ")
                print_integer(constant_index)
                print_string(" is negative - arrays cannot have negative indices\n")
                exit(1)
            End If

            Note: Check if array is an array literal (we know the size at compile time)
            Let array_type be memory_get_int32(array_expr, 0)
            If array_type is equal to 18:  Note: EXPR_ARRAY_LITERAL
                Let array_size be memory_get_int32(array_expr, 16)
                If constant_index is greater than or equal to array_size:
                    print_string("[SAFETY ERROR] Array index ")
                    print_integer(constant_index)
                    print_string(" is out of bounds (array size is ")
                    print_integer(array_size)
                    print_string(")\n")
                    exit(1)
                End If
                print_string("[SAFETY] Compile-time bounds check PASSED: index ")
                print_integer(constant_index)
                print_string(" is within array bounds [0..")
                print_integer(array_size)
                print_string(")\n")
            End If
        End If

        Note: Generate code for index (result in %rax)
        codegen_generate_expression(codegen, index_expr)
        file_write_buffered(output_file, "    pushq %rax  # Save index\n", 0)

        Note: Generate code for array (result in %rax)
        codegen_generate_expression(codegen, array_expr)

        Note: Pop index into %rbx, array pointer is in %rax
        file_write_buffered(output_file, "    popq %rbx  # Load index\n", 0)

        Note: RUNTIME BOUNDS CHECKING (always enabled for safety)
        Note: Runa arrays store their size in the first 8 bytes (at offset -8 from data pointer)
        Note: Check if index is negative
        file_write_buffered(output_file, "    # Runtime bounds check: ensure index >= 0\n", 0)
        file_write_buffered(output_file, "    cmpq $0, %rbx\n", 0)
        file_write_buffered(output_file, "    jl .bounds_error_negative\n", 0)

        Note: Load array size from metadata (stored at offset -8 from data pointer)
        file_write_buffered(output_file, "    # Runtime bounds check: ensure index < size\n", 0)
        file_write_buffered(output_file, "    movq -8(%rax), %rcx  # Load array size from metadata\n", 0)
        file_write_buffered(output_file, "    cmpq %rcx, %rbx  # Compare index with size\n", 0)
        file_write_buffered(output_file, "    jge .bounds_error_overflow\n", 0)

        Note: Calculate offset: index * 8 (pointer size)
        file_write_buffered(output_file, "    imulq $8, %rbx  # Multiply index by 8\n", 0)

        Note: Add offset to array pointer
        file_write_buffered(output_file, "    addq %rbx, %rax  # Add offset to array pointer\n", 0)

        Note: Load value from array[index]
        file_write_buffered(output_file, "    movq (%rax), %rax  # Load value from array\n", 0)

        Return 0
    End If

    If expr_type is equal to 17:  Note: EXPR_LIST_LITERAL
        Note: Get list elements and count
        Let elements be memory_get_pointer(expr, 8)
        Let element_count be memory_get_integer(expr, 16)

        Note: Create list using list_create()
        emit_line(output_file, "    call list_create")
        emit_line(output_file, "    pushq %rax  # Save list pointer")

        Note: Append each element using list_append()
        Let i be 0
        While i is less than element_count:
            Let elem_offset be i multiplied by 8
            Let elem_expr be memory_get_pointer(elements, elem_offset)

            Note: Generate element value
            codegen_generate_expression(codegen, elem_expr)
            emit_line(output_file, "    pushq %rax  # Save element value")

            Note: Call list_append(list, value)
            emit_line(output_file, "    movq 8(%rsp), %rdi  # Load list pointer")
            emit_line(output_file, "    movq (%rsp), %rsi   # Load element value")
            emit_line(output_file, "    call list_append")
            emit_line(output_file, "    popq %rax  # Clean up element value")

            Set i to i plus 1
        End While

        Note: Pop list pointer into %rax as result
        emit_line(output_file, "    popq %rax  # List pointer as result")
        Return 0
    Otherwise If expr_type is equal to 25:  Note: EXPR_CAST
        Note: Cast expression: type(int32), expr(ptr at 8), target_type(ptr at 16)
        Let inner_expr be memory_get_pointer(expr, 8)
        Let target_type be memory_get_pointer(expr, 16)
        Let type_kind be memory_get_int32(target_type, 0)

        Note: Generate inner expression
        codegen_generate_expression(codegen, inner_expr)

        Note: Type conversions based on target type
        Note: TYPE_INTEGER8=0, TYPE_INTEGER16=1, TYPE_INTEGER32=2, TYPE_INTEGER64=3
        Note: TYPE_UNSIGNED_INTEGER8=5, TYPE_UNSIGNED_INTEGER16=6, etc.

        If type_kind is equal to 0:  Note: INTEGER8
            Note: Sign-extend byte to quad
            file_write_buffered(output_file, "    movsbq %al, %rax  # Cast to Integer8\n", 0)
        Otherwise If type_kind is equal to 1:  Note: INTEGER16
            Note: Sign-extend word to quad
            file_write_buffered(output_file, "    movswq %ax, %rax  # Cast to Integer16\n", 0)
        Otherwise If type_kind is equal to 2:  Note: INTEGER32
            Note: Sign-extend long to quad
            file_write_buffered(output_file, "    movslq %eax, %rax  # Cast to Integer32\n", 0)
        Otherwise If type_kind is equal to 5:  Note: UNSIGNED_INTEGER8
            Note: Zero-extend byte to quad
            file_write_buffered(output_file, "    movzbq %al, %rax  # Cast to UnsignedInteger8\n", 0)
        Otherwise If type_kind is equal to 6:  Note: UNSIGNED_INTEGER16
            Note: Zero-extend word to quad
            file_write_buffered(output_file, "    movzwq %ax, %rax  # Cast to UnsignedInteger16\n", 0)
        Otherwise If type_kind is equal to 7:  Note: UNSIGNED_INTEGER32
            Note: Zero-extend long to quad (mov %eax, %eax zeros upper 32 bits)
            file_write_buffered(output_file, "    mov %eax, %eax  # Cast to UnsignedInteger32\n", 0)
        Otherwise:
            Note: INTEGER64, INTEGER128, FLOAT, FLOAT64, POINTER - no conversion needed
            Note: Value already in %rax
        End If

        Return 0
    End If

    If expr_type is equal to 18:  Note: EXPR_ARRAY_LITERAL
        Note: Get array elements, size, and type
        Let elements be memory_get_pointer(expr, 8)
        Let array_size be memory_get_integer(expr, 16)

        Note: Calculate size: array_size * 8 (assuming pointer-sized elements for now)
        Let total_size be array_size multiplied by 8

        Note: Allocate memory for array + 8 bytes for size metadata
        Let allocation_size be total_size plus 8
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(allocation_size), 0)
        file_write_buffered(output_file, ", %rdi\n", 0)
        file_write_buffered(output_file, "    call memory_allocate\n", 0)

        Note: Store array size in metadata at offset 0
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(array_size), 0)
        file_write_buffered(output_file, ", (%rax)  # Store array size in metadata\n", 0)

        Note: Adjust pointer to point to data (after metadata)
        file_write_buffered(output_file, "    addq $8, %rax  # Move pointer past metadata\n", 0)
        file_write_buffered(output_file, "    pushq %rax  # Save array data pointer\n", 0)

        Note: Generate code for each element and store
        Let i be 0
        While i is less than array_size:
            Let elem_offset be i multiplied by 8
            Let elem_expr be memory_get_pointer(elements, elem_offset)

            Note: Generate element value
            codegen_generate_expression(codegen, elem_expr)

            Note: Store in array
            file_write_buffered(output_file, "    movq (%rsp), %rbx  # Load array data pointer\n", 0)
            file_write_buffered(output_file, "    movq %rax, ", 0)
            file_write_buffered(output_file, integer_to_string(elem_offset), 0)
            file_write_buffered(output_file, "(%rbx)\n", 0)

            Set i to i plus 1
        End While

        Note: Pop array data pointer into %rax as result
        file_write_buffered(output_file, "    popq %rax  # Array data pointer as result\n", 0)
        Return 0
    End If

    If expr_type is equal to 19:  Note: EXPR_ARRAY_TYPE (uninitialized)
        Note: Get array size
        Let array_size be memory_get_integer(expr, 8)

        Note: Calculate size: array_size * 8
        Let total_size be array_size multiplied by 8

        Note: Allocate zeroed memory + 8 bytes for size metadata
        Let allocation_size be total_size plus 8
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(allocation_size), 0)
        file_write_buffered(output_file, ", %rdi\n", 0)
        file_write_buffered(output_file, "    call memory_allocate\n", 0)

        Note: Store array size in metadata at offset 0
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(array_size), 0)
        file_write_buffered(output_file, ", (%rax)  # Store array size in metadata\n", 0)

        Note: Adjust pointer to point to data (after metadata)
        file_write_buffered(output_file, "    addq $8, %rax  # Move pointer past metadata\n", 0)
        Return 0
    End If

    If expr_type is equal to 20:  Note: EXPR_STRUCT_CONSTRUCTION
        Note: Get struct construction data
        Let struct_type_name be memory_get_pointer(expr, 8)
        Let field_names be memory_get_pointer(expr, 16)
        Let field_values be memory_get_pointer(expr, 24)
        Let field_count be memory_get_int32(expr, 32)

        Note: Find the struct type definition to get size and field offsets
        Let current_program be memory_get_pointer(codegen, 48)
        Let type_count be memory_get_int32(current_program, 24)  Note: PROGRAM_TYPE_COUNT
        Let types be memory_get_pointer(current_program, 16)      Note: PROGRAM_TYPES
        Let type be 0

        Let type_i be 0
        While type_i is less than type_count:
            Let type_offset be type_i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name be memory_get_pointer(type_ptr, 0)
            If string_equals(type_name, struct_type_name) is equal to 1:
                Let type be type_ptr
                Let type_i be type_count  Note: break
            End If
            Let type_i be type_i plus 1
        End While

        If type is equal to 0:
            print_string("[CODEGEN ERROR] Unknown struct type '")
            print_string(struct_type_name)
            print_string("'")
            exit_with_code(1)
        End If

        Note: Calculate struct size from type definition
        Note: TYPEDEFINITION_SIZE_OFFSET is 40
        Let struct_size be memory_get_int32(type, 40)  Note: TYPEDEFINITION_SIZE_OFFSET

        Note: Allocate memory for struct
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(struct_size), 0)
        file_write_buffered(output_file, ", %rdi\n", 0)
        file_write_buffered(output_file, "    call allocate@PLT\n", 0)
        file_write_buffered(output_file, "    pushq %rax  # Save struct pointer\n", 0)

        Note: Set each field value
        Let field_i be 0
        While field_i is less than field_count:
            Let field_ptr_offset be field_i multiplied by 8
            Let field_name be memory_get_pointer(field_names, field_ptr_offset)
            Let field_value_expr be memory_get_pointer(field_values, field_ptr_offset)

            Note: Find field offset in type definition
            Note: TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET is 24
            Note: TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET is 16
            Let struct_field_count be memory_get_int32(type, 24)
            Let fields be memory_get_pointer(type, 16)
            Let field_offset be -1

            Let field_j be 0
            While field_j is less than struct_field_count:
                Let field_def_offset be field_j multiplied by 24
                Let field_def_ptr be fields plus field_def_offset
                Let field_def_name be memory_get_pointer(field_def_ptr, 0)
                If string_equals(field_def_name, field_name) is equal to 1:
                    Let field_offset be memory_get_int32(field_def_ptr, 16)
                    Let field_j be struct_field_count  Note: break
                End If
                Let field_j be field_j plus 1
            End While

            If field_offset is less than 0:
                print_string("[CODEGEN ERROR] Unknown field '")
                print_string(field_name)
                print_string("' in struct '")
                print_string(struct_type_name)
                print_string("'")
                exit_with_code(1)
            End If

            Note: Generate field value expression
            codegen_generate_expression(codegen, field_value_expr)

            Note: Store value in struct field
            file_write_buffered(output_file, "    movq (%rsp), %rbx  # Load struct pointer\n", 0)
            file_write_buffered(output_file, "    movq %rax, ", 0)
            file_write_buffered(output_file, integer_to_string(field_offset), 0)
            file_write_buffered(output_file, "(%rbx)  # Store field value\n", 0)

            Let field_i be field_i plus 1
        End While

        Note: Pop struct pointer into %rax as result
        file_write_buffered(output_file, "    popq %rax  # Struct pointer as result\n", 0)
        Return 0
    End If

    If expr_type is equal to 21:  Note: EXPR_SET_LITERAL
        Note: Get set elements and count
        Let elements be memory_get_pointer(expr, 8)
        Let element_count be memory_get_integer(expr, 16)

        Note: Create set using set_create()
        emit_line(output_file, "    call set_create")
        emit_line(output_file, "    pushq %rax  # Save set pointer")

        Note: Add each element using set_add()
        Let i be 0
        While i is less than element_count:
            Let elem_offset be i multiplied by 8
            Let elem_expr be memory_get_pointer(elements, elem_offset)

            Note: Generate element value
            codegen_generate_expression(codegen, elem_expr)
            emit_line(output_file, "    pushq %rax  # Save element value")

            Note: Call set_add(set, value)
            emit_line(output_file, "    movq 8(%rsp), %rdi  # Load set pointer")
            emit_line(output_file, "    movq (%rsp), %rsi   # Load element value")
            emit_line(output_file, "    call set_add")
            emit_line(output_file, "    popq %rax  # Clean up element value")

            Set i to i plus 1
        End While

        Note: Pop set pointer into %rax as result
        emit_line(output_file, "    popq %rax  # Set pointer as result")
        Return 0
    End If

    If expr_type is equal to 22:  Note: EXPR_DICT_LITERAL
        Note: Get dictionary keys, values, and pair count
        Let keys be memory_get_pointer(expr, 8)
        Let values be memory_get_pointer(expr, 16)
        Let pair_count be memory_get_integer(expr, 24)

        Note: Create dictionary using dict_create()
        emit_line(output_file, "    call dict_create")
        emit_line(output_file, "    pushq %rax  # Save dict pointer")

        Note: Add each key-value pair using dict_set()
        Let i be 0
        While i is less than pair_count:
            Let pair_offset be i multiplied by 8
            Let key_expr be memory_get_pointer(keys, pair_offset)
            Let value_expr be memory_get_pointer(values, pair_offset)

            Note: Generate key expression
            codegen_generate_expression(codegen, key_expr)
            emit_line(output_file, "    pushq %rax  # Save key")

            Note: Generate value expression
            codegen_generate_expression(codegen, value_expr)
            emit_line(output_file, "    pushq %rax  # Save value")

            Note: Call dict_set(dict, key, value)
            emit_line(output_file, "    movq 16(%rsp), %rdi  # Load dict pointer")
            emit_line(output_file, "    movq 8(%rsp), %rsi   # Load key")
            emit_line(output_file, "    movq (%rsp), %rdx    # Load value")
            emit_line(output_file, "    call dict_set")
            emit_line(output_file, "    addq $16, %rsp  # Clean up key and value")

            Set i to i plus 1
        End While

        Note: Pop dict pointer into %rax as result
        emit_line(output_file, "    popq %rax  # Dict pointer as result")
        Return 0
    End If

    If expr_type is equal to 23:  Note: EXPR_LAMBDA
        Note: Generate lambda closure (no free variables yet)

        Note: Get lambda parameters and body
        Note: Check if multi-parameter (param_count at offset 24) or single parameter
        Let param_count be memory_get_int32(expr, 24)
        Let body_expr be memory_get_pointer(expr, 16)
        Let param_names be memory_get_pointer(expr, 8)

        Note: Generate unique lambda function name
        Let lambda_counter be memory_get_int32(codegen, 28)  Note: label_counter
        memory_set_int32(codegen, 28, lambda_counter plus 1)

        Note: Build lambda function name: __lambda_N
        Let lambda_name be "__lambda_"
        Let counter_str be integer_to_string(lambda_counter)
        Let full_lambda_name be string_concat(lambda_name, counter_str)

        Note: Save current function context
        Let saved_variables be memory_get_pointer(codegen, 8)
        Let saved_var_count be memory_get_int32(codegen, 16)
        Let saved_var_capacity be memory_get_int32(codegen, 20)
        Let saved_stack_offset be memory_get_int32(codegen, 24)

        Note: Create new variable context for lambda
        Let lambda_variables be allocate(16 multiplied by 32)
        memory_set_pointer(codegen, 8, lambda_variables)
        memory_set_int32(codegen, 16, 0)
        memory_set_int32(codegen, 20, 16)
        memory_set_int32(codegen, 24, 0)

        Note: Get free variables for closure support
        Let free_vars be memory_get_pointer(expr, 32)
        Let free_var_count be memory_get_int32(expr, 40)

        Note: Add free variables FIRST (mark them as closure variables)
        Note: Store the environment array index directly (0, 8, 16, etc.)
        Let i be 0
        While i is less than free_var_count:
            Let var_offset be i multiplied by 8
            Let free_var_name be memory_get_pointer(free_vars, var_offset)
            codegen_add_variable(codegen, free_var_name)
            Note: Mark this variable as a closure variable
            Let var_index be memory_get_int32(codegen, 16) minus 1
            Let variables be memory_get_pointer(codegen, 8)
            Let var_struct_offset be var_index multiplied by 32
            Let var_ptr be variables plus var_struct_offset
            Note: Store -1 as stack offset to mark as closure variable
            Note: Store actual environment offset in is_parameter field (reusing it)
            memory_set_int32(var_ptr, 8, -1)
            memory_set_int32(var_ptr, 24, var_offset)  Note: Environment offset in is_parameter field
            Let i be i plus 1
        End While

        Note: Reset stack offset before adding parameters
        Note: Free variables don't use stack space, so reset to base offset
        memory_set_int32(codegen, 24, 8)

        Note: Add parameters as local variables
        If param_count is equal to 0:
            Note: Single parameter (old format) - param_names is a string pointer
            codegen_add_variable(codegen, param_names)
            Let param_count be 1
        Otherwise:
            Note: Multiple parameters - param_names is an array of string pointers
            Let i be 0
            While i is less than param_count:
                Let param_offset be i multiplied by 8
                Let param_name be memory_get_pointer(param_names, param_offset)
                codegen_add_variable(codegen, param_name)
                Let i be i plus 1
            End While
        End If

        Note: Generate lambda function in assembly
        Note: First, emit a jump to skip over the lambda function code
        Let skip_label be "__skip_lambda_"
        Let skip_label_full be string_concat(skip_label, counter_str)
        file_write_buffered(output_file, "    jmp ", 0)
        emit_line(output_file, skip_label_full)

        emit_line(output_file, "")
        emit_line(output_file, "# Lambda function")
        file_write_buffered(output_file, full_lambda_name, 0)
        emit_line(output_file, ":")
        emit_line(output_file, "    pushq %rbp")
        emit_line(output_file, "    movq %rsp, %rbp")

        Note: Calculate stack space needed for parameters + environment pointer
        Let stack_space be param_count multiplied by 8 plus 8
        Let stack_space_aligned be stack_space plus 8
        file_write_buffered(output_file, "    subq $", 0)
        file_write_buffered(output_file, integer_to_string(stack_space_aligned), 0)
        emit_line(output_file, ", %rsp  # Allocate space for environment + parameters")

        Note: CRITICAL: First parameter in %rdi is the environment pointer (from closure)
        Note: Store environment pointer at a fixed location we can reference
        emit_line(output_file, "    movq %rdi, -8(%rbp)  # Store environment pointer")

        Note: Store parameters on stack from registers (shifted by one)
        Note: Real parameters start at %rsi, %rdx, %rcx, %r8, %r9, stack
        If param_count is greater than 0:
            emit_line(output_file, "    movq %rsi, -16(%rbp)  # Store parameter 1")
        End If
        If param_count is greater than 1:
            emit_line(output_file, "    movq %rdx, -24(%rbp)  # Store parameter 2")
        End If
        If param_count is greater than 2:
            emit_line(output_file, "    movq %rcx, -32(%rbp)  # Store parameter 3")
        End If
        If param_count is greater than 3:
            emit_line(output_file, "    movq %r8, -40(%rbp)  # Store parameter 4")
        End If
        If param_count is greater than 4:
            emit_line(output_file, "    movq %r9, -48(%rbp)  # Store parameter 5")
        End If
        If param_count is greater than 5:
            emit_line(output_file, "    movq 16(%rbp), -56(%rbp)  # Store parameter 6 (from stack)")
        End If

        Note: Generate body expression
        codegen_generate_expression(codegen, body_expr)

        Note: Result is in %rax, clean up and return
        emit_line(output_file, "    leave")
        emit_line(output_file, "    ret")
        emit_line(output_file, "")

        Note: Emit skip label
        file_write_buffered(output_file, skip_label_full, 0)
        emit_line(output_file, ":")

        Note: Restore original function context
        deallocate(lambda_variables)
        memory_set_pointer(codegen, 8, saved_variables)
        memory_set_int32(codegen, 16, saved_var_count)
        memory_set_int32(codegen, 20, saved_var_capacity)
        memory_set_int32(codegen, 24, saved_stack_offset)

        Note: Get free variables for closure environment
        Let free_vars be memory_get_pointer(expr, 32)
        Let free_var_count be memory_get_int32(expr, 40)

        Note: Allocate environment struct if there are free variables
        Let env_ptr be 0
        If free_var_count is greater than 0:
            Note: Environment struct: array of pointers to captured values
            Let env_size be free_var_count multiplied by 8
            file_write_buffered(output_file, "    # Allocate environment for ", 0)
            file_write_buffered(output_file, integer_to_string(free_var_count), 0)
            emit_line(output_file, " captured variables")
            file_write_buffered(output_file, "    movq $", 0)
            file_write_buffered(output_file, integer_to_string(env_size), 0)
            emit_line(output_file, ", %rdi")
            emit_line(output_file, "    call allocate")
            emit_line(output_file, "    pushq %rax  # Save environment pointer")

            Note: Populate environment with current values of free variables
            Let i be 0
            While i is less than free_var_count:
                Let var_offset be i multiplied by 8
                Let var_name be memory_get_pointer(free_vars, var_offset)

                Note: Find variable in current scope
                Let var_index be codegen_find_variable(codegen, var_name)
                If var_index is less than 0:
                    print_string("[CODEGEN ERROR] Free variable not found in scope: ")
                    print_string(var_name)
                    print_newline()
                    exit(1)
                End If

                Note: Load variable value into %rbx
                Let variables be memory_get_pointer(codegen, 8)
                Let var_struct_offset be var_index multiplied by 32
                Let var_ptr be variables plus var_struct_offset
                Let stack_offset_u be memory_get_integer(var_ptr, 8)
                Note: Check if this variable is itself a closure variable (shouldn't happen in normal cases)
                If stack_offset_u is equal to 4294967295:
                    print_string("[CODEGEN ERROR] Attempting to capture a closure variable - this indicates a compiler bug")
                    exit(1)
                End If
                file_write_buffered(output_file, "    movq -", 0)
                file_write_buffered(output_file, integer_to_string(stack_offset_u), 0)
                emit_line(output_file, "(%rbp), %rbx  # Load captured variable")

                Note: Store in environment at correct offset
                emit_line(output_file, "    popq %rax  # Get environment pointer")
                file_write_buffered(output_file, "    movq %rbx, ", 0)
                file_write_buffered(output_file, integer_to_string(var_offset), 0)
                emit_line(output_file, "(%rax)  # Store in environment")
                emit_line(output_file, "    pushq %rax  # Save environment pointer again")

                Let i be i plus 1
            End While

            emit_line(output_file, "    popq %rcx  # Final environment pointer in %rcx")
        End If

        Note: Now allocate closure struct (16 bytes: function_ptr + environment)
        emit_line(output_file, "    # Allocate closure struct")
        Note: Save %rcx across allocate call (it's caller-saved and will be clobbered)
        If free_var_count is greater than 0:
            emit_line(output_file, "    pushq %rcx  # Save environment pointer across call")
        End If
        emit_line(output_file, "    movq $16, %rdi")
        emit_line(output_file, "    call allocate")
        emit_line(output_file, "    pushq %rax  # Save closure pointer")

        Note: Store function pointer in closure at offset 0
        file_write_buffered(output_file, "    leaq ", 0)
        file_write_buffered(output_file, full_lambda_name, 0)
        emit_line(output_file, "(%rip), %rbx  # Load function address")
        emit_line(output_file, "    popq %rax  # Restore closure pointer")
        emit_line(output_file, "    movq %rbx, 0(%rax)  # Store function_ptr")

        Note: Store environment pointer at offset 8
        If free_var_count is greater than 0:
            emit_line(output_file, "    popq %rcx  # Restore environment pointer")
            emit_line(output_file, "    movq %rcx, 8(%rax)  # Store environment pointer")
        Otherwise:
            emit_line(output_file, "    movq $0, 8(%rax)  # NULL environment")
        End If

        Note: Closure pointer is now in %rax as result
        Return 0
    End If

    If expr_type is equal to 24:  Note: EXPR_LAMBDA_CALL
        Note: Phase 4: Invoke lambda with multiple arguments
        Note: Structure: lambda_expr at offset 8, arguments at offset 16, arg_count at offset 24

        Note: Get lambda expression (should evaluate to closure pointer)
        Let lambda_expr be memory_get_pointer(expr, 8)
        Let arguments be memory_get_pointer(expr, 16)
        Let arg_count be memory_get_int32(expr, 24)

        Note: Evaluate all arguments and save on stack
        Note: Must evaluate in reverse order to push correctly
        Let i be 0
        While i is less than arg_count:
            Let arg_offset be i multiplied by 8
            Let arg_expr be memory_get_pointer(arguments, arg_offset)
            codegen_generate_expression(codegen, arg_expr)
            emit_line(output_file, "    pushq %rax  # Save argument on stack")
            Let i be i plus 1
        End While

        Note: Generate code to evaluate lambda expression to get closure pointer
        codegen_generate_expression(codegen, lambda_expr)
        Note: Result is closure pointer in %rax

        Note: Save closure pointer in non-argument register
        emit_line(output_file, "    movq %rax, %r10  # Save closure pointer in r10")

        Note: Load environment pointer from closure (offset 8) - this goes in %rdi
        emit_line(output_file, "    movq 8(%r10), %rdi  # Load environment pointer (first param)")

        Note: Pop arguments from stack into argument registers (reverse order, SHIFTED BY ONE)
        Note: x86-64 calling convention: %rdi=env, %rsi=arg1, %rdx=arg2, %rcx=arg3, %r8=arg4, %r9=arg5
        If arg_count is greater than 5:
            print_string("[CODEGEN ERROR] Lambda calls support max 5 arguments (6th register used for environment)")
            print_newline()
            exit_with_code(1)
        End If

        Note: Arguments are on stack in order arg1, arg2, ..., argN (argN on top)
        Note: Pop in reverse to get them into registers (shifted: %rsi, %rdx, %rcx, %r8, %r9)
        If arg_count is greater than 4:
            emit_line(output_file, "    popq %r9  # Pop argument 5")
        End If
        If arg_count is greater than 3:
            emit_line(output_file, "    popq %r8  # Pop argument 4")
        End If
        If arg_count is greater than 2:
            emit_line(output_file, "    popq %rcx  # Pop argument 3")
        End If
        If arg_count is greater than 1:
            emit_line(output_file, "    popq %rdx  # Pop argument 2")
        End If
        If arg_count is greater than 0:
            emit_line(output_file, "    popq %rsi  # Pop argument 1")
        End If

        Note: Load function pointer from closure (offset 0)
        emit_line(output_file, "    movq 0(%r10), %rbx  # Load function pointer from closure")

        Note: Call the lambda function (environment already in %rdi)
        emit_line(output_file, "    call *%rbx  # Invoke lambda")

        Note: Result is in %rax
        Return 0
    End If

    Note: Default case
    print_string("[CODEGEN ERROR] Unsupported expression type: ")
    print_integer(expr_type)
    print_newline()
    exit_with_code(1)
    Return 0
End Process
Process called "codegen_generate_statement" takes codegen as Integer, stmt as Integer returns Integer:
    Let stmt_type be memory_get_int32(stmt, 0)  Note: stmt->type - use int32 not integer
    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file

    If stmt_type is equal to 1:  Note: STMT_LET
        Note: Get the variable name first - it's always needed
        Let variable_name be memory_get_pointer(stmt, 8)  Note: stmt->data.let_stmt.variable_name at offset 8

        Note: Check if this is a type allocation
        Let let_expr be memory_get_pointer(stmt, 16)  Note: stmt->data.let_stmt.expression at offset 16
        If let_expr is not equal to 0:
            Let expr_type be memory_get_int32(let_expr, 0)  Note: expr->type
            If expr_type is equal to 7:  Note: EXPR_TYPE_NAME
                Note: This is a struct allocation - find the type
                Let type_name be memory_get_pointer(let_expr, 8)  Note: expr->data.type_name
                Let current_program be memory_get_pointer(codegen, 48)  Note: codegen->current_program (pointer with padding)
                Let type_count be memory_get_int32(current_program, 24)  Note: PROGRAM_TYPE_COUNT
                Let types be memory_get_pointer(current_program, 16)  Note: PROGRAM_TYPES

                Let type_found be 0
                Let type_def be 0
                Let i be 0
                While i is less than type_count:
                    Let current_type be memory_get_pointer(types, i multiplied by 8)
                    Let current_type_name be memory_get_pointer(current_type, 0)  Note: type->name
                    If string_equals(current_type_name, type_name) is equal to 1:
                        Let type_found be 1
                        Let type_def be current_type
                        Let i be type_count  Note: Break
                    End If
                    Let i be i plus 1
                End While

                If type_found is equal to 0:
                    exit_with_code(1)
                    Return 1
                End If

                Note: Add variable with type information
                codegen_add_variable_with_type(codegen, variable_name, type_name)

                Note: Get variable info
                Let var_index be codegen_find_variable(codegen, variable_name)
                Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
                Let offset be memory_get_int32(variables, var_index multiplied by 32 plus 8)  Note: variables[var_index].stack_offset

                Note: Handle different type kinds
                Let type_kind be memory_get_int32(type_def, 8)  Note: type->kind
                Let type_size be memory_get_int32(type_def, 16)  Note: type->size

                If type_kind is equal to 3:  Note: TYPE_KIND_ARRAY
                    Note: For arrays, allocate space for all elements and zero out memory
                    Let i be 0
                    While i is less than type_size:
                        file_write_buffered(output_file, "    movq $0, -", 0)
                        file_write_buffered(output_file, integer_to_string(offset minus i), 0)
                        file_write_buffered(output_file, "(%rbp)  # Zero array element", 0)
                        Let i be i plus 8
                    End While

                    Note: Update stack offset to account for full array size
                    Let current_stack_offset be memory_get_int32(codegen, 24)  Note: codegen->stack_offset
                    memory_set_integer(codegen, 16, current_stack_offset plus type_size)
                Otherwise:
                    Note: For structs, zero out the struct memory
                    Let i be 0
                    While i is less than type_size:
                        file_write_buffered(output_file, "    movq $0, -", 0)
                        file_write_buffered(output_file, integer_to_string(offset minus i), 0)
                        file_write_buffered(output_file, "(%rbp)\n", 0)
                        Let i be i plus 8
                    End While
                End If
            Otherwise:
                Note: Regular expression - check if the expression returns a string or list
                If expr_type is equal to 8:  Note: EXPR_BUILTIN_CALL
                    Let builtin_call_ptr be let_expr plus 8  Note: &expr->data.builtin_call
                    Let builtin_type be memory_get_int32(builtin_call_ptr, 0)  Note: builtin_call.builtin_type

                    Note: Check for string-returning builtins (read_file, string_substring, string_concat, integer_to_string, string_replace, string_trim)
                    Let is_string_builtin be 0
                    If builtin_type is equal to 37:
                        Let is_string_builtin be 1
                    Otherwise If builtin_type is equal to 42:
                        Let is_string_builtin be 1
                    Otherwise If builtin_type is equal to 48:
                        Let is_string_builtin be 1
                    Otherwise If builtin_type is equal to 49:
                        Let is_string_builtin be 1
                    Otherwise If builtin_type is equal to 52:
                        Let is_string_builtin be 1
                    Otherwise If builtin_type is equal to 54:
                        Let is_string_builtin be 1
                    End If
                    If is_string_builtin is equal to 1:
                        codegen_add_variable_with_type(codegen, variable_name, "String")
                    Otherwise:
                        Note: Check for list-returning builtins (list_create, list_copy, list_merge)
                        Let is_list_builtin be 0
                        If builtin_type is equal to 19:
                            Let is_list_builtin be 1
                        Otherwise If builtin_type is equal to 31:
                            Let is_list_builtin be 1
                        Otherwise If builtin_type is equal to 32:
                            Let is_list_builtin be 1
                        End If
                        If is_list_builtin is equal to 1:
                            codegen_add_variable_with_type(codegen, variable_name, "List")
                        Otherwise:
                            Note: Regular integer/other builtin expression
                            Note: Try to infer type from expression
                            Let inferred_type be codegen_get_expression_type(codegen, let_expr)
                            If inferred_type is equal to 0:
                                codegen_add_variable(codegen, variable_name)
                            Otherwise:
                                codegen_add_variable_with_type(codegen, variable_name, inferred_type)
                            End If
                        End If
                    End If
                Otherwise:
                    Note: Regular integer/other expression (non-builtin) - infer type
                    Let inferred_type be codegen_get_expression_type(codegen, let_expr)
                    If inferred_type is equal to 0:
                        codegen_add_variable(codegen, variable_name)
                    Otherwise:
                        codegen_add_variable_with_type(codegen, variable_name, inferred_type)
                    End If
                End If

                Note: Generate expression (result in %rax)
                codegen_generate_expression(codegen, let_expr)

                Note: Store value in variable's stack slot
                Let var_index be codegen_find_variable(codegen, variable_name)
                Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
                Let offset be memory_get_int32(variables, var_index multiplied by 32 plus 8)  Note: variables[var_index].stack_offset
                file_write_buffered(output_file, "    movq %rax, -", 0)
                file_write_buffered(output_file, integer_to_string(offset), 0)
                file_write_buffered(output_file, "(%rbp)\n", 0)
            End If
        End If
        Return 0
    End If

    If stmt_type is equal to 2:  Note: STMT_SET
        Note: Generate value expression (result in %rax)
        Let set_expr be memory_get_pointer(stmt, 16)  Note: stmt->data.set_stmt.expression
        codegen_generate_expression(codegen, set_expr)

        Note: Save the value on the stack
        emit_line(output_file, "    pushq %rax")

        Note: Generate the address of the target (result in %rbx)
        Let set_target be memory_get_pointer(stmt, 8)  Note: stmt->data.set_stmt.target
        codegen_generate_lvalue_address(codegen, set_target)

        Note: Restore value and store to target address
        emit_line(output_file, "    popq %rax")
        emit_line(output_file, "    movq %rax, (%rbx)")
        Return 0
    End If

    If stmt_type is equal to 17:  Note: STMT_COMPOUND_ASSIGN
        Note: Generate RHS expression (result in %rax)
        Let compound_expr be memory_get_pointer(stmt, 24)  Note: expression at offset 24
        codegen_generate_expression(codegen, compound_expr)

        Note: Save RHS value on stack
        emit_line(output_file, "    pushq %rax")

        Note: Generate the address of the target (result in %rbx)
        Let compound_target be memory_get_pointer(stmt, 8)  Note: target at offset 8
        codegen_generate_lvalue_address(codegen, compound_target)

        Note: Load current value from target into %rcx
        emit_line(output_file, "    movq (%rbx), %rcx")

        Note: Pop RHS value into %rax
        emit_line(output_file, "    popq %rax")

        Note: Get operation type: 0=add, 1=sub, 2=mul, 3=div
        Let operation be memory_get_int32(stmt, 16)  Note: operation at offset 16

        Note: Perform operation: %rcx = %rcx op %rax
        If operation is equal to 0:
            emit_line(output_file, "    addq %rax, %rcx")
        End If
        If operation is equal to 1:
            emit_line(output_file, "    subq %rax, %rcx")
        End If
        If operation is equal to 2:
            emit_line(output_file, "    imulq %rax, %rcx")
        End If
        If operation is equal to 3:
            Note: Division: %rcx / %rax
            Note: Move dividend to %rax, save divisor
            emit_line(output_file, "    pushq %rax")
            emit_line(output_file, "    movq %rcx, %rax")
            emit_line(output_file, "    cqto")
            emit_line(output_file, "    popq %rcx")
            emit_line(output_file, "    idivq %rcx")
            emit_line(output_file, "    movq %rax, %rcx")
        End If

        Note: Store result back to target
        emit_line(output_file, "    movq %rcx, (%rbx)")
        Return 0
    End If

    If stmt_type is equal to 11:  Note: STMT_FOR
        Let label_counter be memory_get_int32(codegen, 28)
        Let label_num be label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)

        Let loop_start_label be label_num multiplied by 10 plus 1
        Let loop_end_label be label_num multiplied by 10 plus 2

        Note: Get loop components
        Let var_name be memory_get_pointer(stmt, 8)
        Let start_expr be memory_get_pointer(stmt, 16)
        Let end_expr be memory_get_pointer(stmt, 24)
        Let step_expr be memory_get_pointer(stmt, 32)
        Let body be memory_get_pointer(stmt, 40)
        Let body_count be memory_get_integer(stmt, 48)

        Note: Allocate loop variable on stack
        codegen_add_variable(codegen, var_name)
        Let var_index be codegen_find_variable(codegen, var_name)
        Let variables be memory_get_pointer(codegen, 8)
        Let var_offset be memory_get_int32(variables, var_index multiplied by 32 plus 8)

        Note: Generate start expression and store in loop variable
        codegen_generate_expression(codegen, start_expr)
        file_write_buffered(output_file, "    movq %rax, -", 0)
        file_write_buffered(output_file, integer_to_string(var_offset), 0)
        file_write_buffered(output_file, "(%rbp)\n", 0)

        Note: Generate end expression and save on stack
        codegen_generate_expression(codegen, end_expr)
        emit_line(output_file, "    pushq %rax")

        Note: Loop start label
        Let loop_start_str be string_concat(".L", integer_to_string(loop_start_label))
        Let loop_start_label_line be string_concat(loop_start_str, ":")
        emit_line(output_file, loop_start_label_line)

        Note: Load loop variable and end value, compare
        file_write_buffered(output_file, "    movq -", 0)
        file_write_buffered(output_file, integer_to_string(var_offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax\n", 0)
        emit_line(output_file, "    movq (%rsp), %rcx")
        emit_line(output_file, "    cmpq %rcx, %rax")
        Let jg_instruction be string_concat("    jg .L", integer_to_string(loop_end_label))
        emit_line(output_file, jg_instruction)

        Note: Generate loop body
        Let i be 0
        While i is less than body_count:
            Let body_stmt be memory_get_pointer(body, i multiplied by 8)
            codegen_generate_statement(codegen, body_stmt)
            Set i to i plus 1
        End While

        Note: Increment loop variable by step
        If step_expr is not equal to 0:
            codegen_generate_expression(codegen, step_expr)
            emit_line(output_file, "    pushq %rax")
        End If
        If step_expr is equal to 0:
            emit_line(output_file, "    movq $1, %rax")
            emit_line(output_file, "    pushq %rax")
        End If
        file_write_buffered(output_file, "    movq -", 0)
        file_write_buffered(output_file, integer_to_string(var_offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax\n", 0)
        emit_line(output_file, "    popq %rcx")
        emit_line(output_file, "    addq %rcx, %rax")
        file_write_buffered(output_file, "    movq %rax, -", 0)
        file_write_buffered(output_file, integer_to_string(var_offset), 0)
        file_write_buffered(output_file, "(%rbp)\n", 0)

        Note: Jump back to loop start
        Let jmp_instruction be string_concat("    jmp .L", integer_to_string(loop_start_label))
        emit_line(output_file, jmp_instruction)

        Note: Loop end label
        Let loop_end_str be string_concat(".L", integer_to_string(loop_end_label))
        Let loop_end_label_line be string_concat(loop_end_str, ":")
        emit_line(output_file, loop_end_label_line)

        Note: Pop end value from stack
        emit_line(output_file, "    popq %rax")

        Return 0
    End If

    If stmt_type is equal to 12:  Note: STMT_FOR_EACH
        Let label_counter be memory_get_int32(codegen, 28)
        Let label_num be label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)

        Let loop_start_label be label_num multiplied by 10 plus 1
        Let loop_end_label be label_num multiplied by 10 plus 2

        Note: Get loop components
        Let var_name be memory_get_pointer(stmt, 8)
        Let collection_expr be memory_get_pointer(stmt, 16)
        Let body be memory_get_pointer(stmt, 24)
        Let body_count be memory_get_integer(stmt, 32)

        Note: Evaluate collection expression (result in %rax)
        codegen_generate_expression(codegen, collection_expr)
        emit_line(output_file, "    pushq %rax")  Note: Save collection pointer on stack

        Note: Get collection length by calling list_length
        emit_line(output_file, "    movq %rax, %rdi")
        emit_line(output_file, "    call list_length")
        emit_line(output_file, "    pushq %rax")  Note: Save length on stack

        Note: Initialize loop counter to 0
        emit_line(output_file, "    movq $0, %rax")
        emit_line(output_file, "    pushq %rax")  Note: Save counter on stack

        Note: Allocate loop variable on stack for the item value
        codegen_add_variable(codegen, var_name)
        Let var_index be codegen_find_variable(codegen, var_name)
        Let variables be memory_get_pointer(codegen, 8)
        Let var_offset be memory_get_int32(variables, var_index multiplied by 32 plus 8)

        Note: Loop start label
        Let loop_start_str be string_concat(".L", integer_to_string(loop_start_label))
        Let loop_start_label_line be string_concat(loop_start_str, ":")
        emit_line(output_file, loop_start_label_line)

        Note: Compare counter with length
        emit_line(output_file, "    movq (%rsp), %rax")       Note: Load counter
        emit_line(output_file, "    movq 8(%rsp), %rcx")      Note: Load length
        emit_line(output_file, "    cmpq %rcx, %rax")
        Let jge_instruction be string_concat("    jge .L", integer_to_string(loop_end_label))
        emit_line(output_file, jge_instruction)

        Note: Get item at current index: list_get(collection, counter)
        emit_line(output_file, "    movq 16(%rsp), %rdi")     Note: Load collection pointer
        emit_line(output_file, "    movq (%rsp), %rsi")       Note: Load counter as index
        emit_line(output_file, "    call list_get")

        Note: Store item in loop variable
        file_write_buffered(output_file, "    movq %rax, -", 0)
        file_write_buffered(output_file, integer_to_string(var_offset), 0)
        file_write_buffered(output_file, "(%rbp)\n", 0)

        Note: Generate loop body
        Let i be 0
        While i is less than body_count:
            Let body_stmt be memory_get_pointer(body, i multiplied by 8)
            codegen_generate_statement(codegen, body_stmt)
            Set i to i plus 1
        End While

        Note: Increment counter
        emit_line(output_file, "    movq (%rsp), %rax")
        emit_line(output_file, "    addq $1, %rax")
        emit_line(output_file, "    movq %rax, (%rsp)")

        Note: Jump back to loop start
        Let jmp_instruction be string_concat("    jmp .L", integer_to_string(loop_start_label))
        emit_line(output_file, jmp_instruction)

        Note: Loop end label
        Let loop_end_str be string_concat(".L", integer_to_string(loop_end_label))
        Let loop_end_label_line be string_concat(loop_end_str, ":")
        emit_line(output_file, loop_end_label_line)

        Note: Clean up stack (counter, length, collection)
        emit_line(output_file, "    addq $24, %rsp")

        Return 0
    End If

    If stmt_type is equal to 3:  Note: STMT_RETURN
        Note: Generate expression (result in %rax)
        Let return_expr be memory_get_pointer(stmt, 8)  Note: stmt->data.return_stmt.expression - use pointer
        codegen_generate_expression(codegen, return_expr)

        Note: Function epilogue
        file_write_buffered(output_file, "    movq %rbp, %rsp\n", 0)
        file_write_buffered(output_file, "    popq %rbp\n", 0)
        file_write_buffered(output_file, "    ret\n", 0)
        Return 0
    End If

    If stmt_type is equal to 5:  Note: STMT_IF
        Let label_counter be memory_get_int32(codegen, 28)  Note: codegen->label_counter (int)
        Let label_num be label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)  Note: codegen->label_counter++ (int)

        Let else_label be label_num multiplied by 10 plus 1
        Let end_label be label_num multiplied by 10 plus 2

        Note: Generate condition (result in %rax)
        Let condition_expr be memory_get_pointer(stmt, 8)  Note: stmt->data.if_stmt.condition - use pointer
        codegen_generate_expression(codegen, condition_expr)

        Note: Test if condition is false (0)
        emit_line(output_file, "    testq %rax, %rax")
        Let jz_instruction be string_concat("    jz .L", integer_to_string(else_label))
        emit_line(output_file, jz_instruction)

        Note: Generate if body
        Let if_body be memory_get_pointer(stmt, 16)  Note: stmt->data.if_stmt.if_body
        Let if_body_count be memory_get_int32(stmt, 24)  Note: stmt->data.if_stmt.if_body_count
        Let ifbody_i be 0
        While ifbody_i is less than if_body_count:
            Let ifbody_stmt be memory_get_pointer(if_body, ifbody_i multiplied by 8)
            codegen_generate_statement(codegen, ifbody_stmt)
            Let ifbody_i be ifbody_i plus 1
        End While

        file_write_buffered(output_file, "    jmp .L", 0)
        file_write_buffered(output_file, integer_to_string(end_label), 0)
        file_write_buffered(output_file, "\n", 0)

        Note: Generate else body
        Let else_label_str be string_concat(".L", integer_to_string(else_label))
        Let else_label_line be string_concat(else_label_str, ":")
        emit_line(output_file, else_label_line)
        deallocate(else_label_str)
        deallocate(else_label_line)

        Let else_body be memory_get_pointer(stmt, 32)  Note: stmt->data.if_stmt.else_body
        Let else_body_count be memory_get_int32(stmt, 40)  Note: stmt->data.if_stmt.else_body_count
        Let elsebody_i be 0
        While elsebody_i is less than else_body_count:
            Let elsebody_stmt be memory_get_pointer(else_body, elsebody_i multiplied by 8)
            codegen_generate_statement(codegen, elsebody_stmt)
            Let elsebody_i be elsebody_i plus 1
        End While

        Let end_label_str be string_concat(".L", integer_to_string(end_label))
        Let end_label_line be string_concat(end_label_str, ":")
        emit_line(output_file, end_label_line)
        deallocate(end_label_str)
        deallocate(end_label_line)
        Return 0
    End If

    If stmt_type is equal to 6:  Note: STMT_WHILE
        Let label_counter be memory_get_int32(codegen, 28)  Note: codegen->label_counter (int)
        Note: Try to use it without printing to see if it works
        If label_counter is greater than 1000000:
        End If
        Let label_num be label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)  Note: codegen->label_counter++ (int)

        Let loop_start be label_num multiplied by 10 plus 1
        Let loop_end be label_num multiplied by 10 plus 2

        Note: Push loop context for break/continue statements
        codegen_push_loop_context(codegen, loop_start, loop_end)

        Note: Loop start label
        file_write_buffered(output_file, ".L", 0)
        Let loop_start_str be integer_to_string(loop_start)
        file_write_buffered(output_file, loop_start_str, 0)
        file_write_buffered(output_file, ":", 0)

        Note: Generate condition (result in %rax)
        Let condition_expr be memory_get_pointer(stmt, 8)  Note: stmt->data.while_stmt.condition
        codegen_generate_expression(codegen, condition_expr)

        Note: Test if condition is false (0)
        emit_line(output_file, "    testq %rax, %rax")
        Let jz_instruction be string_concat("    jz .L", integer_to_string(loop_end))
        emit_line(output_file, jz_instruction)

        Note: Generate loop body
        Let whilebody be memory_get_pointer(stmt, 16)  Note: stmt->data.while_stmt.body
        Let whilebody_count be memory_get_int32(stmt, 24)  Note: stmt->data.while_stmt.body_count
        Let whilebody_i be 0
        While whilebody_i is less than whilebody_count:
            Let whilebody_stmt be memory_get_pointer(whilebody, whilebody_i multiplied by 8)
            codegen_generate_statement(codegen, whilebody_stmt)
            Let whilebody_i be whilebody_i plus 1
        End While

        Note: Jump back to loop start
        file_write_buffered(output_file, "    jmp .L", 0)
        file_write_buffered(output_file, integer_to_string(loop_start), 0)
        file_write_buffered(output_file, "\n", 0)

        Note: Loop end label
        Let loop_end_str be string_concat(".L", integer_to_string(loop_end))
        Let loop_end_line be string_concat(loop_end_str, ":")
        emit_line(output_file, loop_end_line)
        deallocate(loop_end_str)
        deallocate(loop_end_line)

        Note: Pop loop context
        codegen_pop_loop_context(codegen)
        Return 0
    End If

    If stmt_type is equal to 9:  Note: STMT_BREAK
        Let loop_ctx be codegen_current_loop_context(codegen)
        If loop_ctx is not equal to 0:
            Let break_label be memory_get_int32(loop_ctx, 8)  Note: loop_ctx->break_label
            file_write_buffered(output_file, "    jmp .L", 0)
            file_write_buffered(output_file, integer_to_string(break_label), 0)
            file_write_buffered(output_file, "\n", 0)
        Otherwise:
            exit_with_code(1)
        End If
        Return 0
    End If

    If stmt_type is equal to 10:  Note: STMT_CONTINUE
        Let loop_ctx be codegen_current_loop_context(codegen)
        If loop_ctx is not equal to 0:
            Let continue_label be memory_get_int32(loop_ctx, 0)  Note: loop_ctx->continue_label
            file_write_buffered(output_file, "    jmp .L", 0)
            file_write_buffered(output_file, integer_to_string(continue_label), 0)
            file_write_buffered(output_file, "\n", 0)
        Otherwise:
            exit_with_code(1)
        End If
        Return 0
    End If

    Note: Inline assembly: emit raw assembly text
    If stmt_type is equal to 16:  Note: STMT_INLINE_ASSEMBLY
        Note: Get raw assembly text (single string, not array)
        Let raw_text be memory_get_pointer(stmt, 8)
        Let text_length be memory_get_int32(stmt, 16)

        Note: Write raw text directly to output, character by character
        Note: Add 4-space indentation to each line for proper assembly formatting
        Let char_idx be 0
        Let at_line_start be 1  Note: Track if we're at the start of a line

        While char_idx is less than text_length:
            Let current_char be string_char_at(raw_text, char_idx)
            Let newline be 10  Note: ASCII for '\n'

            Note: Add indentation at start of each line
            If at_line_start is equal to 1:
                Note: Check if line is not empty (not just newline)
                If current_char is not equal to newline:
                    file_write_buffered(output_file, "    ", 0)
                End If
                Set at_line_start to 0
            End If

            Note: Write character
            Let char_str_len be 2
            Let char_str be memory_allocate(char_str_len)
            memory_set_byte(char_str, 0, current_char)
            memory_set_byte(char_str, 1, 0)  Note: null terminator
            file_write_buffered(output_file, char_str, 0)
            deallocate(char_str)

            Note: Track newlines for indentation
            If current_char is equal to newline:
                Set at_line_start to 1
            End If

            Set char_idx to char_idx plus 1
        End While

        Note: Ensure we end with a newline
        If at_line_start is equal to 0:
            file_write_buffered(output_file, "\n", 0)
        End If

        Return 0
    End If

    If stmt_type is equal to 4:  Note: STMT_PRINT
        Note: Generate expression (result in %rax)
        Let print_expr be memory_get_pointer(stmt, 8)  Note: stmt->data.print_stmt.expression
        codegen_generate_expression(codegen, print_expr)

        Note: Call appropriate print function based on expression type
        Let expr_type be memory_get_int32(print_expr, 0)  Note: expr->type
        If expr_type is equal to 5:  Note: EXPR_STRING_LITERAL
            Note: String literal - call print_string
            file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
            file_write_buffered(output_file, "    call print_string\n", 0)
        Otherwise:
            If expr_type is equal to 8:  Note: EXPR_BUILTIN_CALL
                Let builtin_call_ptr be print_expr plus 8  Note: &expr->data.builtin_call
                Let builtin_type be memory_get_int32(builtin_call_ptr, 0)  Note: builtin_call.builtin_type
                Note: Check for string-returning builtins (read_file, string_substring, string_concat, integer_to_string, string_replace, string_trim)
                Let is_string_builtin be 0
                If builtin_type is equal to 37:
                    Let is_string_builtin be 1
                Otherwise If builtin_type is equal to 42:
                    Let is_string_builtin be 1
                Otherwise If builtin_type is equal to 48:
                    Let is_string_builtin be 1
                Otherwise If builtin_type is equal to 49:
                    Let is_string_builtin be 1
                Otherwise If builtin_type is equal to 52:
                    Let is_string_builtin be 1
                Otherwise If builtin_type is equal to 54:
                    Let is_string_builtin be 1
                End If
                If is_string_builtin is equal to 1:
                    Note: These functions return strings - call print_string
                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                    file_write_buffered(output_file, "    call print_string\n", 0)
                Otherwise:
                    Note: Integer expression - call print_integer
                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                    file_write_buffered(output_file, "    call print_integer\n", 0)
                End If
            Otherwise:
                If expr_type is equal to 4:  Note: EXPR_FUNCTION_CALL
                    Note: Check if function returns a string
                    Let function_call_ptr be print_expr plus 8  Note: &expr->data.function_call
                    Let function_name be memory_get_pointer(function_call_ptr, 0)  Note: function_call.function_name

                    Note: List of string-returning functions
                    Let is_string_function be 0
                    If string_equals(function_name, "string_concat") is equal to 1:
                        Let is_string_function be 1
                    Otherwise If string_equals(function_name, "string_duplicate") is equal to 1:
                        Let is_string_function be 1
                    Otherwise If string_equals(function_name, "string_substring") is equal to 1:
                        Let is_string_function be 1
                    Otherwise If string_equals(function_name, "integer_to_string") is equal to 1:
                        Let is_string_function be 1
                    Otherwise If string_equals(function_name, "string_replace") is equal to 1:
                        Let is_string_function be 1
                    Otherwise If string_equals(function_name, "string_trim") is equal to 1:
                        Let is_string_function be 1
                    Otherwise If string_equals(function_name, "read_file") is equal to 1:
                        Let is_string_function be 1
                    Otherwise If string_equals(function_name, "char_to_string") is equal to 1:
                        Let is_string_function be 1
                    End If

                    If is_string_function is equal to 1:
                        Note: Function returns string - call print_string
                        file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                        file_write_buffered(output_file, "    call print_string\n", 0)
                    Otherwise:
                        Note: Function returns integer - call print_integer
                        file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                        file_write_buffered(output_file, "    call print_integer\n", 0)
                    End If
                Otherwise If expr_type is equal to 1:  Note: EXPR_VARIABLE
                    Note: Check variable type to determine appropriate print function
                    Let variable_name be memory_get_pointer(print_expr, 8)  Note: expr->data.variable_name
                    Let var_index be codegen_find_variable(codegen, variable_name)
                    If var_index is greater than or equal to 0:
                        Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
                        Let type_name be memory_get_pointer(variables, var_index multiplied by 32 plus 16)  Note: variables[var_index].type_name
                        If type_name is not equal to 0:
                            If string_equals(type_name, "String") is equal to 1:
                                Note: This variable contains a string - call print_string
                                file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                                file_write_buffered(output_file, "    call print_string\n", 0)
                            Otherwise:
                                If string_equals(type_name, "List") is equal to 1:
                                    Note: This variable contains a list pointer - print as integer address
                                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                                    file_write_buffered(output_file, "    call print_integer\n", 0)
                                Otherwise:
                                    Note: Assume integer for other variables
                                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                                    file_write_buffered(output_file, "    call print_integer\n", 0)
                                End If
                            End If
                        Otherwise:
                            Note: Assume integer for untyped variables
                            file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                            file_write_buffered(output_file, "    call print_integer\n", 0)
                        End If
                    Otherwise:
                        Note: Variable not found, assume integer
                        file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                        file_write_buffered(output_file, "    call print_integer\n", 0)
                    End If
                Otherwise:
                    Note: Integer expression (literal, arithmetic) - call print_integer
                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                    file_write_buffered(output_file, "    call print_integer\n", 0)
                End If
            End If
        End If
        Return 0
    End If

    If stmt_type is equal to 7:  Note: STMT_EXPRESSION
        Note: Generate the expression and ignore its result
        Let expr_stmt_expr be memory_get_pointer(stmt, 8)  Note: stmt->data.expr_stmt.expression
        codegen_generate_expression(codegen, expr_stmt_expr)
        Return 0
    End If

    If stmt_type is equal to 13:  Note: STMT_IMPORT
        Note: Imports are handled at program level, no code generation needed
        Return 0
    End If

    If stmt_type is equal to 8:  Note: STMT_MATCH
        Note: Generate code for Match statement with literal patterns
        Note: Evaluate match expression once and store in temp
        Let match_expr be memory_get_pointer(stmt, 8)  Note: STMT_MATCH_EXPR
        codegen_generate_expression(codegen, match_expr)
        file_write_buffered(output_file, "    pushq %rax  # Save match value\n", 0)

        Note: Get unique label for end of match
        Let label_counter be memory_get_int32(codegen, 28)
        Let match_id be label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)

        Note: Get when clauses
        Let when_clauses be memory_get_pointer(stmt, 16)  Note: STMT_MATCH_WHEN_CLAUSES
        Let when_count be memory_get_int32(stmt, 24)  Note: STMT_MATCH_WHEN_COUNT

        Note: Generate if-else chain for each When clause
        Let i be 0
        While i is less than when_count:
            Note: Get when clause data (48 bytes per clause)
            Let clause_offset be i multiplied by 48
            Let clause_ptr be when_clauses plus clause_offset
            Let pattern_type be memory_get_int32(clause_ptr, 0)
            Let pattern_value be memory_get_pointer(clause_ptr, 8)
            Let field_bindings be memory_get_pointer(clause_ptr, 16)
            Let field_count be memory_get_int32(clause_ptr, 24)
            Let body_stmts be memory_get_pointer(clause_ptr, 32)
            Let body_count be memory_get_integer(clause_ptr, 40)

            Note: Generate label for this case
            file_write_buffered(output_file, ".match_", 0)
            file_write_buffered(output_file, integer_to_string(match_id), 0)
            file_write_buffered(output_file, "_case_", 0)
            file_write_buffered(output_file, integer_to_string(i), 0)
            file_write_buffered(output_file, ":\n", 0)

            Note: Handle pattern based on type
            If pattern_type is equal to 2:  Note: PATTERN_WILDCARD
                Note: Wildcard always matches - no comparison needed
                Note: Just fall through to execute the body
            Otherwise If pattern_type is equal to 3:  Note: PATTERN_TYPE
                Note: Type pattern - check if value matches the specified type
                Note: pattern_value contains the type name string
                Let type_name_to_check be pattern_value

                Note: Pop match value for type checking
                file_write_buffered(output_file, "    popq %rax  # Get match value\n", 0)
                file_write_buffered(output_file, "    pushq %rax  # Keep for next comparison\n", 0)

                Note: Check if type is a primitive (Integer, Byte, etc.)
                If string_equals(type_name_to_check, "Integer") is equal to 1:
                    Note: For Integer type: check if value is small (not a pointer)
                    Note: Assume pointers are > 0x1000, integers are small values
                    file_write_buffered(output_file, "    movq $4096, %rbx  # Pointer threshold\n", 0)
                    file_write_buffered(output_file, "    cmpq %rbx, %rax  # Compare value with threshold\n", 0)
                    Note: If value >= threshold, it's a pointer (not Integer) - jump to next case
                    Let next_case be i plus 1
                    If next_case is less than when_count:
                        file_write_buffered(output_file, "    jge .match_", 0)
                        file_write_buffered(output_file, integer_to_string(match_id), 0)
                        file_write_buffered(output_file, "_case_", 0)
                        file_write_buffered(output_file, integer_to_string(next_case), 0)
                        file_write_buffered(output_file, "  # Not Integer, try next case\n", 0)
                    Otherwise:
                        file_write_buffered(output_file, "    jge .match_", 0)
                        file_write_buffered(output_file, integer_to_string(match_id), 0)
                        file_write_buffered(output_file, "_end  # Not Integer, no match\n", 0)
                    End If
                Otherwise:
                    Note: For named types (variants/structs): check if it's a valid pointer
                    Note: This is a simplified check - just verify it's a pointer-like value
                    file_write_buffered(output_file, "    movq $4096, %rbx  # Pointer threshold\n", 0)
                    file_write_buffered(output_file, "    cmpq %rbx, %rax  # Check if pointer-like\n", 0)
                    Note: If value < threshold, it's not a pointer (not this type) - jump to next case
                    Let next_case be i plus 1
                    If next_case is less than when_count:
                        file_write_buffered(output_file, "    jl .match_", 0)
                        file_write_buffered(output_file, integer_to_string(match_id), 0)
                        file_write_buffered(output_file, "_case_", 0)
                        file_write_buffered(output_file, integer_to_string(next_case), 0)
                        file_write_buffered(output_file, "  # Not pointer type, try next case\n", 0)
                    Otherwise:
                        file_write_buffered(output_file, "    jl .match_", 0)
                        file_write_buffered(output_file, integer_to_string(match_id), 0)
                        file_write_buffered(output_file, "_end  # Not pointer type, no match\n", 0)
                    End If
                End If
            Otherwise If pattern_type is equal to 0:  Note: PATTERN_LITERAL
                Note: Pop match value and compare with pattern
                file_write_buffered(output_file, "    popq %rax  # Get match value\n", 0)
                file_write_buffered(output_file, "    pushq %rax  # Keep for next comparison\n", 0)

                Note: Generate pattern expression
                codegen_generate_expression(codegen, pattern_value)

                Note: Compare: match value in stack, pattern value in %rax
                file_write_buffered(output_file, "    movq %rax, %rbx  # Pattern value to %rbx\n", 0)
                file_write_buffered(output_file, "    movq (%rsp), %rax  # Match value to %rax\n", 0)
                file_write_buffered(output_file, "    cmpq %rbx, %rax  # Compare\n", 0)
            Otherwise:  Note: PATTERN_VARIANT
                Note: Variant pattern matching
                Note: pattern_value is the variant name string
                Note: field_bindings is array of binding variable names
                Note: field_count is number of fields to extract

                Note: Get variant tag for this pattern
                Let variant_name be pattern_value
                Let variant_tag_to_match be 0
                Let variant_field_count be 0

                Note: Look up variant in program's type definitions
                Let current_program be memory_get_pointer(codegen, 48)
                Let type_count be memory_get_int32(current_program, 24)
                Let types be memory_get_pointer(current_program, 16)

                Let found_variant be 0
                Let vi be 0
                While vi is less than type_count:
                    Let type_ptr be memory_get_pointer_at_index(types, vi)
                    Let type_kind be memory_get_int32(type_ptr, 8)

                    Note: Check if this is a variant type (TYPE_KIND_VARIANT = 1)
                    If type_kind is equal to 1:
                        Let variant_count be memory_get_int32(type_ptr, 24)
                        Let variants be memory_get_pointer(type_ptr, 16)

                        Note: Loop through all variants to find match
                        Let vj be 0
                        While vj is less than variant_count:
                            Let variant_offset be vj multiplied by 32
                            Let variant_ptr be variants plus variant_offset
                            Let vname be memory_get_pointer(variant_ptr, 0)

                            If string_equals(vname, variant_name) is equal to 1:
                                Set variant_tag_to_match to memory_get_int32(variant_ptr, 20)
                                Set variant_field_count to memory_get_int32(variant_ptr, 16)
                                Set found_variant to 1
                                Set vi to type_count  Note: Break outer loop
                                Set vj to variant_count  Note: Break inner loop
                            Otherwise:
                                Set vj to vj plus 1
                            End If
                        End While
                    End If
                    Set vi to vi plus 1
                End While

                Note: Generate tag comparison
                file_write_buffered(output_file, "    movq (%rsp), %rax  # Get match value pointer\n", 0)
                file_write_buffered(output_file, "    movl (%rax), %ebx  # Load variant tag\n", 0)
                file_write_buffered(output_file, "    cmpl $", 0)
                file_write_buffered(output_file, integer_to_string(variant_tag_to_match), 0)
                file_write_buffered(output_file, ", %ebx  # Compare with expected tag\n", 0)
            End If

            Note: Jump to next case if not equal (unless wildcard or type pattern)
            If pattern_type is not equal to 2:  Note: Not wildcard
                If pattern_type is not equal to 3:  Note: Not type pattern - generate conditional jump
                    Let next_case be i plus 1
                    If next_case is less than when_count:
                        file_write_buffered(output_file, "    jne .match_", 0)
                        file_write_buffered(output_file, integer_to_string(match_id), 0)
                        file_write_buffered(output_file, "_case_", 0)
                        file_write_buffered(output_file, integer_to_string(next_case), 0)
                        file_write_buffered(output_file, "  # Try next case\n", 0)
                    Otherwise:
                        file_write_buffered(output_file, "    jne .match_", 0)
                        file_write_buffered(output_file, integer_to_string(match_id), 0)
                        file_write_buffered(output_file, "_end  # No match\n", 0)
                    End If
                End If
            End If

            Note: Generate body if matched
            Note: Handle field extraction for variant patterns
            If pattern_type is equal to 0:  Note: PATTERN_LITERAL
                file_write_buffered(output_file, "    popq %rax  # Matched, clean up stack\n", 0)
            Otherwise If pattern_type is equal to 2:  Note: PATTERN_WILDCARD
                file_write_buffered(output_file, "    popq %rax  # Matched, clean up stack\n", 0)
            Otherwise If pattern_type is equal to 3:  Note: PATTERN_TYPE
                file_write_buffered(output_file, "    popq %rax  # Matched, clean up stack\n", 0)
            Otherwise:  Note: PATTERN_VARIANT
                Note: Extract fields and bind to variables
                file_write_buffered(output_file, "    popq %rax  # Get match value pointer\n", 0)

                Note: Extract each field
                Let fk be 0
                While fk is less than field_count:
                    Note: Get field binding name
                    Let binding_name be memory_get_pointer(field_bindings, fk multiplied by 8)

                    Note: Add variable for this binding
                    codegen_add_variable(codegen, binding_name)

                    Note: Find the variable to get its stack offset
                    Let var_index be codegen_find_variable(codegen, binding_name)
                    Let variables be memory_get_pointer(codegen, 8)
                    Let var_offset be memory_get_int32(variables, var_index multiplied by 32 plus 8)

                    Note: Load field from variant at offset 8 + (fk * 8)
                    Let field_offset be 8 plus fk multiplied by 8
                    file_write_buffered(output_file, "    movq ", 0)
                    file_write_buffered(output_file, integer_to_string(field_offset), 0)
                    file_write_buffered(output_file, "(%rax), %rbx  # Load field ", 0)
                    file_write_buffered(output_file, integer_to_string(fk), 0)
                    file_write_buffered(output_file, "\n", 0)

                    Note: Store field in local variable
                    file_write_buffered(output_file, "    movq %rbx, -", 0)
                    file_write_buffered(output_file, integer_to_string(var_offset), 0)
                    file_write_buffered(output_file, "(%rbp)  # Store in binding ", 0)
                    file_write_buffered(output_file, binding_name, 0)
                    file_write_buffered(output_file, "\n", 0)

                    Set fk to fk plus 1
                End While
            End If

            Note: Generate body statements
            Let j be 0
            While j is less than body_count:
                Let stmt_offset be j multiplied by 8
                Let body_stmt be memory_get_pointer(body_stmts, stmt_offset)
                codegen_generate_statement(codegen, body_stmt)
                Set j to j plus 1
            End While

            Note: Jump to end after body
            file_write_buffered(output_file, "    jmp .match_", 0)
            file_write_buffered(output_file, integer_to_string(match_id), 0)
            file_write_buffered(output_file, "_end\n", 0)

            Set i to i plus 1
        End While

        Note: End label
        file_write_buffered(output_file, ".match_", 0)
        file_write_buffered(output_file, integer_to_string(match_id), 0)
        file_write_buffered(output_file, "_end:\n", 0)
        file_write_buffered(output_file, "    addq $8, %rsp  # Clean up match value if still on stack\n", 0)

        Return 0
    End If

    If stmt_type is equal to 7:  Note: OLD_STMT_MATCH (unused)
        Note: Evaluate the expression to match on
        Let match_expr be memory_get_pointer(stmt, 8)  Note: stmt->data.match_stmt.expression
        codegen_generate_expression(codegen, match_expr)
        file_write_buffered(output_file, "    pushq %rax  # Save match expression value", 0)

        Note: Generate unique labels for each case and the end
        Let label_counter be memory_get_int32(codegen, 28)  Note: codegen->label_counter (int)
        Let match_id be label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)  Note: codegen->label_counter++ (int)

        Let end_label be string_concat(".match_end_", integer_to_string(match_id))

        Note: Generate code for each case
        Let case_count be memory_get_int32(stmt, 16)  Note: stmt->data.match_stmt.case_count
        Let cases be memory_get_pointer(stmt, 24)  Note: stmt->data.match_stmt.cases

        Let i be 0
        While i is less than case_count:
            Let case_offset be i multiplied by 64
            Let match_case be cases plus case_offset  Note: sizeof(MatchCase) estimate
            Let variant_name be memory_get_pointer(match_case, 0)  Note: match_case->variant_name
            Let field_count be memory_get_int32(match_case, 8)  Note: match_case->field_count
            Let field_names be memory_get_pointer(match_case, 16)  Note: match_case->field_names
            Let body_count be memory_get_int32(match_case, 24)  Note: match_case->body_count
            Let body be memory_get_pointer(match_case, 32)  Note: match_case->body

            Let next_case_id be i plus 1

            Note: Check if this case matches - write label directly without string_concat
            file_write_buffered(output_file, ".match_case_", 0)
            file_write_buffered(output_file, integer_to_string(match_id), 0)
            file_write_buffered(output_file, "_", 0)
            file_write_buffered(output_file, integer_to_string(i), 0)
            file_write_buffered(output_file, ":", 0)
            file_write_buffered(output_file, "    popq %rax  # Get match expression\n", 0)
            file_write_buffered(output_file, "    pushq %rax  # Keep on stack", 0)

            Note: Load the tag from the variant
            file_write_buffered(output_file, "    movq (%rax), %rdx  # Load variant tag", 0)

            Note: Find the tag value for this variant name - ADT variant tags are sequential starting from 0
            file_write_buffered(output_file, "    cmpq $", 0)
            file_write_buffered(output_file, integer_to_string(i), 0)
            file_write_buffered(output_file, ", %rdx  # Check tag for ", 0)
            file_write_buffered(output_file, variant_name, 0)
            file_write_buffered(output_file, "\n", 0)

            If i is less than case_count minus 1:
                file_write_buffered(output_file, "    jne .match_case_", 0)
                file_write_buffered(output_file, integer_to_string(match_id), 0)
                file_write_buffered(output_file, "_", 0)
                file_write_buffered(output_file, integer_to_string(next_case_id), 0)
                file_write_buffered(output_file, "  # Jump to next case", 0)
            Otherwise:
                file_write_buffered(output_file, "    jne ", 0)
                file_write_buffered(output_file, end_label, 0)
                file_write_buffered(output_file, "  # No match, exit", 0)
            End If

            Note: If we matched, extract fields and bind to local variables
            If field_count is greater than 0:
                Note: Pop the variant pointer
                file_write_buffered(output_file, "    popq %rax  # Get variant pointer\n", 0)
                file_write_buffered(output_file, "    pushq %rax  # Keep on stack", 0)

                Note: ADT fields start at offset 8 (after tag) with 8 bytes per field
                Let j be 0
                While j is less than field_count:
                    Let field_offset_value be j multiplied by 8
                    Let field_offset be 8 plus field_offset_value
                    file_write_buffered(output_file, "    movq ", 0)
                    file_write_buffered(output_file, integer_to_string(field_offset), 0)
                    file_write_buffered(output_file, "(%rax), %rdx  # Load field ", 0)
                    file_write_buffered(output_file, integer_to_string(j), 0)
                    file_write_buffered(output_file, "\n", 0)

                    Note: Create a local variable for the binding - allocate stack space properly
                    Let current_stack_offset be memory_get_int32(codegen, 24)  Note: codegen->stack_offset
                    Let new_stack_offset be current_stack_offset plus 8
                    memory_set_integer(codegen, 16, new_stack_offset)

                    file_write_buffered(output_file, "    movq %rdx, -", 0)
                    file_write_buffered(output_file, integer_to_string(new_stack_offset), 0)
                    Let field_name be memory_get_pointer(field_names, j multiplied by 8)
                    file_write_buffered(output_file, "(%rbp, 0)  # Store ", 0)
                    file_write_buffered(output_file, field_name, 0)
                    file_write_buffered(output_file, " at stack offset", 0)

                    Note: Add the binding to the variable table with correct offset
                    Let variable_count be memory_get_int32(codegen, 16)  Note: codegen->variable_count (int)
                    Let variable_capacity be memory_get_int32(codegen, 24)  Note: codegen->variable_capacity
                    If variable_count is greater than or equal to variable_capacity:
                        Let new_capacity be variable_capacity multiplied by 2
                        memory_set_integer(codegen, 24, new_capacity)
                        Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
                        Let new_variables be reallocate(variables, new_capacity multiplied by 32)  Note: sizeof(Variable) = 32
                        memory_set_pointer(codegen, 8, new_variables)
                    End If

                    Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
                    Let var_idx_offset be variable_count multiplied by 32  Note: sizeof(Variable) = 32
                    memory_set_pointer(variables, var_idx_offset, string_duplicate(field_name))  Note: name
                    memory_set_integer(variables, var_idx_offset plus 8, new_stack_offset)  Note: stack_offset
                    memory_set_pointer(variables, var_idx_offset plus 16, string_duplicate("Integer"))  Note: type_name
                    memory_set_int32(codegen, 12, variable_count plus 1)  Note: Increment variable_count

                    Let j be j plus 1
                End While
            End If

            Note: Generate the case body
            Let k be 0
            While k is less than body_count:
                Let current_stmt be memory_get_pointer(body, k multiplied by 8)
                codegen_generate_statement(codegen, current_stmt)
                Let k be k plus 1
            End While

            Note: Clean up bindings from variable table but keep stack offset
            If field_count is greater than 0:
                Note: Free the variable names we allocated
                Let j be 0
                While j is less than field_count:
                    Let variable_count be memory_get_int32(codegen, 16)  Note: codegen->variable_count (int)
                    Let var_idx be variable_count minus field_count plus j
                    Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
                    Let var_name be memory_get_integer(variables, var_idx multiplied by 24)
                    Let var_type_name be memory_get_integer(variables, var_idx multiplied by 24 plus 16)
                    deallocate(var_name)
                    deallocate(var_type_name)
                    Let j be j plus 1
                End While
                Note: Remove from variable table
                Let variable_count be memory_get_int32(codegen, 16)  Note: codegen->variable_count (int)
                memory_set_integer(codegen, 12, variable_count minus field_count)
            End If

            Note: Jump to end
            file_write_buffered(output_file, "    jmp ", 0)
            file_write_buffered(output_file, end_label, 0)
            file_write_buffered(output_file, "\n", 0)

            Let i be i plus 1
        End While

        file_write_buffered(output_file, end_label, 0)
        file_write_buffered(output_file, ":", 0)
        file_write_buffered(output_file, "    popq %rax  # Clean up match expression\n", 0)
        Return 0
    End If

    Return 0
End Process

Note: Create a new code generator - equivalent to codegen_create
Process called "codegen_create" takes output_filename as Integer returns Integer:
    Let codegen be allocate(88)  Note: sizeof(CodeGenerator) - expanded for call_graph at offset 80

    Note: Note: allocate() uses calloc() which already zeros the memory,
    Note: so no explicit initialization loop is needed

    Let output_file be file_open_buffered(output_filename, 1)  Note: 1 = write mode (O_WRONLY | O_CREAT | O_TRUNC)
    If output_file is less than 0:  Note: Negative indicates error
        Note: Failed to open output file
        deallocate(codegen)
        Return 0
    End If
    memory_set_integer(codegen, 0, output_file)  Note: codegen->output_file

    Let variables be allocate(16 multiplied by 32)  Note: 16 * sizeof(Variable) - Variable is 32 bytes
    memory_set_pointer(codegen, 8, variables)  Note: codegen->variables
    memory_set_int32(codegen, 16, 0)  Note: codegen->variable_count (int)
    memory_set_int32(codegen, 20, 16)  Note: codegen->variable_capacity (int) - Start with space for 16 variables


    memory_set_int32(codegen, 24, 0)  Note: codegen->stack_offset (int)
    memory_set_int32(codegen, 28, 0)  Note: codegen->label_counter (int)
    memory_set_int32(codegen, 40, 0)  Note: codegen->string_count (int)
    memory_set_int32(codegen, 44, 512)  Note: codegen->string_capacity (int) - Start with space for 512 strings

    Let strings be allocate(512 multiplied by 16)  Note: 512 * sizeof(StringLiteral)
    memory_set_pointer(codegen, 32, strings)  Note: codegen->strings (pointer with padding)
    memory_set_pointer(codegen, 48, 0)  Note: codegen->current_program (pointer with padding)
    memory_set_int32(codegen, 64, 0)  Note: codegen->loop_depth (int)
    memory_set_int32(codegen, 68, 8)  Note: codegen->loop_capacity (int) - Start with space for 8 nested loops

    Let loop_stack be allocate(8 multiplied by 16)  Note: 8 * sizeof(LoopContext)
    memory_set_pointer(codegen, 56, loop_stack)  Note: codegen->loop_stack (pointer)

    Note: Hash table will be created on first use (function pointers not available yet)
    memory_set_pointer(codegen, 72, 0)  Note: codegen->var_hashtable (initially NULL)

    If output_file is equal to 0:
        deallocate(variables)
        deallocate(strings)
        deallocate(loop_stack)
        deallocate(codegen)
        Return 0
    End If

    Return codegen
End Process

Note: Destroy a code generator - equivalent to codegen_destroy
Process called "codegen_destroy" takes codegen as Integer returns Integer:
    If codegen is not equal to 0:
        Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file
        If output_file is not equal to 0:
            file_close_fd(output_file)
        End If

        Note: Free variable names and type names
        Note: Read 32-bit variable_count correctly
        Let byte0 be memory_get_byte(codegen, 16)
        Let byte1 be memory_get_byte(codegen, 17)
        Let byte2 be memory_get_byte(codegen, 18)
        Let byte3 be memory_get_byte(codegen, 19)
        Let temp1 be byte1 multiplied by 256
        Let temp2 be byte2 multiplied by 65536
        Let temp3 be byte3 multiplied by 16777216
        Let variable_count be byte0 plus temp1 plus temp2 plus temp3

        Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
        If variables is not equal to 0:
            Let i be 0
            While i is less than variable_count:
                Let var_offset be i multiplied by 32  Note: sizeof(Variable) = 32
                Let var_ptr be variables plus var_offset
                Let var_name be memory_get_pointer(var_ptr, 0)  Note: Variable.name at offset 0
                Let var_type_name be memory_get_pointer(var_ptr, 16)  Note: Variable.type_name at offset 16
                If var_name is not equal to 0:
                    deallocate(var_name)
                End If
                If var_type_name is not equal to 0:
                    deallocate(var_type_name)
                End If
                Let i be i plus 1
            End While
        End If

        Note: Free string literal values and labels
        Note: Read 32-bit string_count correctly
        Let byte0 be memory_get_byte(codegen, 40)
        Let byte1 be memory_get_byte(codegen, 41)
        Let byte2 be memory_get_byte(codegen, 42)
        Let byte3 be memory_get_byte(codegen, 43)
        Let temp1 be byte1 multiplied by 256
        Let temp2 be byte2 multiplied by 65536
        Let temp3 be byte3 multiplied by 16777216
        Let string_count be byte0 plus temp1 plus temp2 plus temp3

        Let strings be memory_get_pointer(codegen, 32)  Note: codegen->strings (pointer with padding)
        If strings is not equal to 0:
            Let i be 0
            While i is less than string_count:
                Let str_offset be i multiplied by 16  Note: sizeof(StringLiteral) = 16
                Let str_ptr be strings plus str_offset
                Let str_value be memory_get_pointer(str_ptr, 0)  Note: StringLiteral.value at offset 0
                Let str_label be memory_get_pointer(str_ptr, 8)  Note: StringLiteral.label at offset 8
                If str_value is not equal to 0:
                    deallocate(str_value)
                End If
                If str_label is not equal to 0:
                    deallocate(str_label)
                End If
                Let i be i plus 1
            End While
        End If

        If variables is not equal to 0:
            deallocate(variables)
        End If
        If strings is not equal to 0:
            deallocate(strings)
        End If
        Let loop_stack be memory_get_pointer(codegen, 56)  Note: codegen->loop_stack (pointer)
        If loop_stack is not equal to 0:
            deallocate(loop_stack)
        End If
        Note: Destroy hash table
        Let var_hashtable be memory_get_pointer(codegen, 72)
        If var_hashtable is not equal to 0:
            hashtable_destroy(var_hashtable)
        End If
        Note: Destroy call graph (at offset 80)
        Let call_graph be memory_get_pointer(codegen, 80)
        If call_graph is not equal to 0:
            callgraph_destroy(call_graph)
        End If
        deallocate(codegen)
    End If
    Return 0
End Process

Note: Push a new loop context for break/continue handling - equivalent to codegen_push_loop_context
Process called "codegen_push_loop_context" takes codegen as Integer, continue_label as Integer, break_label as Integer returns Integer:
    Let loop_depth be memory_get_int32(codegen, 64)  Note: codegen->loop_depth (int)
    Let loop_capacity be memory_get_int32(codegen, 68)  Note: codegen->loop_capacity (int)

    Note: Expand loop stack if necessary
    If loop_depth is greater than or equal to loop_capacity:
        Let new_capacity be loop_capacity multiplied by 2
        memory_set_int32(codegen, 68, new_capacity)  Note: codegen->loop_capacity (int)
        Let loop_stack be memory_get_pointer(codegen, 56)  Note: codegen->loop_stack (pointer)
        Let new_loop_stack be memory_reallocate(loop_stack, 16 multiplied by new_capacity)  Note: sizeof(LoopContext) * new_capacity
        memory_set_pointer(codegen, 56, new_loop_stack)  Note: codegen->loop_stack (pointer)
    End If

    Let loop_stack be memory_get_pointer(codegen, 56)  Note: codegen->loop_stack
    Let context_offset be loop_depth multiplied by 16  Note: sizeof(LoopContext)
    memory_set_integer(loop_stack, context_offset, continue_label)  Note: continue_label
    memory_set_integer(loop_stack, context_offset plus 8, break_label)  Note: break_label
    memory_set_int32(codegen, 64, loop_depth plus 1)  Note: Increment loop_depth (int)
    Return 0
End Process

Note: Pop the current loop context - equivalent to codegen_pop_loop_context
Process called "codegen_pop_loop_context" takes codegen as Integer returns Integer:
    Let loop_depth be memory_get_int32(codegen, 64)  Note: codegen->loop_depth (int)
    If loop_depth is greater than 0:
        memory_set_int32(codegen, 64, loop_depth minus 1)  Note: codegen->loop_depth (int)
    End If
    Return 0
End Process

Note: Get the current loop context - equivalent to codegen_current_loop_context
Process called "codegen_current_loop_context" takes codegen as Integer returns Integer:
    Let loop_depth be memory_get_int32(codegen, 64)  Note: codegen->loop_depth (int)
    If loop_depth is greater than 0:
        Let loop_stack be memory_get_pointer(codegen, 56)  Note: codegen->loop_stack (pointer)
        Let loop_index be loop_depth minus 1
        Let context_offset be loop_index multiplied by 16  Note: sizeof(LoopContext)
        Return loop_stack plus context_offset
    End If
    Return 0  Note: NULL
End Process

Note: Generate code for a function - equivalent to codegen_generate_function
Process called "codegen_generate_function" takes codegen as Integer, func as Integer returns Integer:
    Note: Reset variable state for each function
    memory_set_int32(codegen, 16, 0)  Note: codegen->variable_count = 0
    memory_set_int32(codegen, 24, 0)  Note: codegen->stack_offset = 0
    memory_set_int32(codegen, 64, 0)  Note: codegen->loop_depth = 0 (int)

    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file
    Let func_name be memory_get_pointer(func, 0)  Note: func->name

    Note: Export function as global symbol for cross-module linking
    file_write_buffered(output_file, ".globl ", 0)
    file_write_buffered(output_file, func_name, 0)
    file_write_buffered(output_file, "\n", 0)

    Note: Function label
    file_write_buffered(output_file, func_name, 0)
    file_write_buffered(output_file, ":\n", 0)

    Note: Function prologue
    emit_line(output_file, "    pushq %rbp")
    emit_line(output_file, "    movq %rsp, %rbp")

    Note: ========================================================================
    Note: STACK SAFETY: Inject stack probe for recursive functions
    Note: ========================================================================
    Let call_graph be memory_get_pointer(codegen, 80)  Note: codegen->call_graph (offset 80, NOT 72)
    If call_graph is not equal to 0:
        Let node be callgraph_find_node(call_graph, func_name)
        If node is not equal to 0:
            Let is_recursive be memory_get_int32(node, 28)
            codegen_inject_stack_probe(output_file, func_name, is_recursive)
        End If
    End If
    Note: ========================================================================

    Note: Handle parameters (System V ABI: %rdi, %rsi, %rdx, %rcx, %r8, %r9)
    Let param_registers be allocate(6 multiplied by 8)  Note: Array of 6 string pointers
    memory_set_pointer(param_registers, 0, "%rdi")
    memory_set_pointer(param_registers, 8, "%rsi")
    memory_set_pointer(param_registers, 16, "%rdx")
    memory_set_pointer(param_registers, 24, "%rcx")
    memory_set_pointer(param_registers, 32, "%r8")
    memory_set_pointer(param_registers, 40, "%r9")
    Let max_register_params be 6

    Let parameter_count be memory_get_int32(func, 16)  Note: func->parameter_count

    Note: If this is main function with argc/argv parameters, initialize command line args
    If string_equals(func_name, "main") is equal to 1:
        If parameter_count is greater than or equal to 2:
            Note: Store original argc and argv before processing them as Runa parameters
            emit_line(output_file, "    # Initialize command line arguments")
            emit_line(output_file, "    pushq %rdi  # Save argc")
            emit_line(output_file, "    pushq %rsi  # Save argv")
            emit_line(output_file, "    call runtime_set_command_line_args@PLT")
            emit_line(output_file, "    popq %rsi   # Restore argv")
            emit_line(output_file, "    popq %rdi   # Restore argc")
        End If
    End If

    Note: CRITICAL FIX: Allocate stack space BEFORE any stack access to prevent Valgrind violations
    Note: Pre-allocate generous stack space for all function variables and temporaries
    Note: Increased from 512 to 2048 to handle parser functions with many locals
    emit_line(output_file, "    subq $2048, %rsp  # Pre-allocate generous stack space")

    Let parameters be memory_get_pointer(func, 8)  Note: func->parameters (Parameter*)
    Let i be 0
    Let should_continue be 1
    While should_continue is equal to 1:
        If i is greater than or equal to parameter_count:
            Let should_continue be 0
        End If
        If i is greater than or equal to max_register_params:
            Let should_continue be 0
        End If
        If should_continue is equal to 1:
        Note: Add parameter as a variable and store from appropriate register
        Note: Use the parameter type from the function definition
        Let param_offset be i multiplied by 16  Note: sizeof(Parameter)
        Let param_name be memory_get_pointer(parameters, param_offset)  Note: parameters[i].name
        Let param_type be memory_get_pointer(parameters, param_offset plus 8)  Note: parameters[i].type
        If param_type is equal to 0:
            Let param_type be "Integer"  Note: Default type
        End If

        Let param_index be codegen_add_variable_with_type_and_param_flag(codegen, param_name, param_type, 1)  Note: Mark as parameter
        Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
        Let var_offset be param_index multiplied by 32  Note: sizeof(Variable) = 32, not 24!
        Let var_ptr be variables plus var_offset
        Let param_stack_offset be memory_get_int32(var_ptr, 8)  Note: variables[param_index].stack_offset
        Let register_name be memory_get_pointer(param_registers, i multiplied by 8)
        file_write_buffered(output_file, "    movq ", 0)
        file_write_buffered(output_file, register_name, 0)
        file_write_buffered(output_file, ", -", 0)
        file_write_buffered(output_file, integer_to_string(param_stack_offset), 0)
        file_write_buffered(output_file, "(%rbp)\n", 0)

        Let i be i plus 1
        End If  Note: End of should_continue check
    End While

    Note: Handle parameters beyond 6 (passed on stack in System V ABI)
    Let i be max_register_params
    While i is less than parameter_count:
        Let param_offset be i multiplied by 16  Note: sizeof(Parameter)
        Let param_name be memory_get_pointer(parameters, param_offset)  Note: parameters[i].name
        Let param_type be memory_get_pointer(parameters, param_offset plus 8)  Note: parameters[i].type
        Let param_index be codegen_add_variable_with_type_and_param_flag(codegen, param_name, param_type, 1)  Note: Mark as parameter
        Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
        Let var_offset be param_index multiplied by 32  Note: sizeof(Variable) = 32, not 24!
        Let var_ptr be variables plus var_offset
        Let param_stack_offset be memory_get_int32(var_ptr, 8)  Note: variables[param_index].stack_offset

        Note: Stack parameters are at positive offsets from rbp: 16(%rbp), 24(%rbp), etc.
        Let stack_param_index be i minus max_register_params
        Let stack_param_offset_value be stack_param_index multiplied by 8
        Let stack_param_offset be 16 plus stack_param_offset_value
        file_write_buffered(output_file, "    movq ", 0)
        file_write_buffered(output_file, integer_to_string(stack_param_offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax\n", 0)
        file_write_buffered(output_file, "    movq %rax, -", 0)
        file_write_buffered(output_file, integer_to_string(param_stack_offset), 0)
        file_write_buffered(output_file, "(%rbp)", 0)

        Let i be i plus 1
    End While

    Note: Generate function body statements
    Note: Function structure has:
    Note: offset 24: return_type (string)
    Note: offset 32: statements (Statement** array)
    Note: offset 40: statement_count (int)
    Let statement_count be memory_get_int32(func, 40)  Note: func->statement_count
    Let statements be memory_get_pointer(func, 32)     Note: func->statements

    If statements is not equal to 0:
        Let stmt_idx be 0
        While stmt_idx is less than statement_count:
            Let stmt_offset be stmt_idx multiplied by 8
            Let stmt be memory_get_pointer(statements, stmt_offset)  Note: statements[stmt_idx]
            If stmt is not equal to 0:
                codegen_generate_statement(codegen, stmt)
            End If
            Let stmt_idx be stmt_idx plus 1
        End While
    End If

    Note: Add function epilogue ONLY if function doesn't end with explicit return
    Let needs_epilogue be 1
    If statement_count is greater than 0:
        Let last_stmt_offset be statement_count minus 1
        Set last_stmt_offset to last_stmt_offset multiplied by 8
        Let last_stmt be memory_get_pointer(statements, last_stmt_offset)
        If last_stmt is not equal to 0:
            Let last_stmt_type be memory_get_int32(last_stmt, 0)
            If last_stmt_type is equal to 3:  Note: STMT_RETURN
                Set needs_epilogue to 0
            End If
        End If
    End If

    If needs_epilogue is equal to 1:
        emit_line(output_file, "    movq %rbp, %rsp")
        emit_line(output_file, "    popq %rbp")
        emit_line(output_file, "    ret")
    End If

    deallocate(param_registers)
    Return 0
End Process

Note: Main code generation entry point - equivalent to codegen_generate
Process called "codegen_generate" takes codegen as Integer, program as Integer returns Integer:

    Note: Store program reference for type lookups
    memory_set_pointer(codegen, 48, program)  Note: codegen->current_program = program (pointer with padding)

    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file

    Note: Check if program is initialized properly
    Let import_count be memory_get_int32(program, 40)  Note: PROGRAM_IMPORT_COUNT - use int32 not integer
    Note: Instead check if it's a reasonable value first
    If import_count is equal to 0:
    Otherwise:
    End If

    Note: Safety check to prevent accessing invalid memory
    If import_count is less than 0:
        Let import_count be 0
    End If
    If import_count is greater than 1000:
        Let import_count be 0
    End If

    Note: Generate import comments (for documentation)
    If import_count is greater than 0:
        file_write_buffered(output_file, "# Imports:", 0)
        Let imports be memory_get_pointer(program, 32)  Note: PROGRAM_IMPORTS - should be pointer not integer
        Let i be 0
        While i is less than import_count:
            Let import be memory_get_pointer(imports, i multiplied by 8)
            Let import_filename be memory_get_integer(import, 0)  Note: import->filename
            Let module_name be memory_get_integer(import, 8)  Note: import->module_name
            file_write_buffered(output_file, "#   Import ", 0)
            file_write_buffered(output_file, import_filename, 0)
            file_write_buffered(output_file, " as ", 0)
            file_write_buffered(output_file, module_name, 0)
            file_write_buffered(output_file, "\n", 0)
            Let i be i plus 1
        End While
        file_write_buffered(output_file, "\n", 0)
    End If

    Note: First pass: collect all string literals by analyzing the AST
    Let function_count be memory_get_int32(program, 8)   Note: PROGRAM_FUNCTION_COUNT - use int32

    Note: Safety check: if function_count is negative or too large, assume no functions
    If function_count is less than 0:
        Let function_count be 0
    End If
    If function_count is greater than 10000:  Note: Sanity check
        Let function_count be 0
    End If

    Let functions be memory_get_pointer(program, 0)        Note: PROGRAM_FUNCTIONS - use pointer

    Note: Safety check - if functions is NULL, return error
    If functions is equal to 0:
        print_string("[ERROR] codegen_generate: functions pointer is NULL")
        Return 0
    End If

    Let i be 0
    While i is less than function_count:
        Let func be memory_get_pointer(functions, i multiplied by 8)



        Note: Safety check for function pointer - skip NULL pointers
        If func is not equal to 0:
                Note: Function structure in parser.runa has:
                Note: FUNCTION_STATEMENTS at 32 (Statement** - array of statements)
                Note: FUNCTION_STATEMENT_COUNT at 40

                Let func_name be memory_get_pointer(func, 0)  Note: func->name
                Let statements_array be memory_get_pointer(func, 32)  Note: func->statements (Statement**)

                Let statement_count be memory_get_int32(func, 40)  Note: func->statement_count

                Note: Process each statement in the function

                If statements_array is not equal to 0:
                    If statement_count is greater than 0:
                        Note: Process ALL statements in the function body

                        Let stmt_idx be 0
                        While stmt_idx is less than statement_count:

                            Note: Get the statement at index stmt_idx
                            Let stmt_offset be stmt_idx multiplied by 8  Note: pointer size
                            Let body_statement be memory_get_pointer(statements_array, stmt_offset)


                            Note: Process the statement
                            Let result be 0
                            If body_statement is not equal to 0:
                                Let result be codegen_collect_strings_from_statement(codegen, body_statement)

                                Note: Check if function reported critical error
                                If result is not equal to 0:
                                    Return 0
                                End If
                            End If

                            Note: Move to next statement
                            Let stmt_idx be stmt_idx plus 1
                        End While
                End If
            End If
        End If
        Let i be i plus 1
    End While

    Note: WORKAROUND removed - string collection is now working!

    Note: OLD orphaned code for rodata generation - REMOVED (now done in codegen main function)

    Note: Generate .data section for initialized global variables
    Let global_count be memory_get_int32(program, 56)  Note: PROGRAM_GLOBAL_COUNT - use int32
    Let globals be memory_get_pointer(program, 48)       Note: PROGRAM_GLOBAL_VARS - use pointer
    Let has_initialized_globals be 0
    Let i be 0
    While i is less than global_count:
        Let global be memory_get_pointer(globals, i multiplied by 8)
        Let initial_value be memory_get_pointer(global, 16)  Note: global->initial_value
        If initial_value is not equal to 0:
            Let has_initialized_globals be 1
            Let i be global_count  Note: Break
        End If
        Let i be i plus 1
    End While

    If has_initialized_globals is equal to 1:
        emit_line(output_file, ".section .data")
        Let i be 0
        While i is less than global_count:
            Let global be memory_get_pointer(globals, i multiplied by 8)
            Let global_name be memory_get_pointer(global, 0)  Note: global->name
            Let initial_value be memory_get_pointer(global, 16)  Note: global->initial_value
            If initial_value is not equal to 0:
                file_write_buffered(output_file, ".globl ", 0)
                file_write_buffered(output_file, global_name, 0)
                file_write_buffered(output_file, "\n", 0)
                file_write_buffered(output_file, global_name, 0)
                file_write_buffered(output_file, ":", 0)

                Note: Handle global variable initialization values
                Let expr_type be memory_get_int32(initial_value, 0)  Note: initial_value->type
                If expr_type is equal to 0:  Note: EXPR_INTEGER
                    Let integer_value be memory_get_pointer(initial_value, 8)  Note: initial_value->data.integer_value
                    file_write_buffered(output_file, "    .quad ", 0)
                    file_write_buffered(output_file, integer_to_string(integer_value), 0)
                    file_write_buffered(output_file, "\n", 0)
                Otherwise:
                    Note: Non-constant expressions default to zero initialization
                    file_write_buffered(output_file, "    .quad 0  # Non-constant initializer defaults to 0", 0)
                End If
            End If
            Let i be i plus 1
        End While
        file_write_buffered(output_file, "\n", 0)
    End If

    Note: Generate .bss section for uninitialized global variables
    Let has_uninitialized_globals be 0
    Let i be 0
    While i is less than global_count:
        Let global be memory_get_pointer(globals, i multiplied by 8)
        Let initial_value be memory_get_pointer(global, 16)  Note: global->initial_value
        If initial_value is equal to 0:
            Let has_uninitialized_globals be 1
            Let i be global_count  Note: Break
        End If
        Let i be i plus 1
    End While

    If has_uninitialized_globals is equal to 1:
        emit_line(output_file, ".section .bss")
        Let i be 0
        While i is less than global_count:
            Let global be memory_get_pointer(globals, i multiplied by 8)
            Let global_name be memory_get_pointer(global, 0)  Note: global->name
            Let initial_value be memory_get_pointer(global, 16)  Note: global->initial_value
            If initial_value is equal to 0:
                file_write_buffered(output_file, ".globl ", 0)
                file_write_buffered(output_file, global_name, 0)
                file_write_buffered(output_file, "\n", 0)
                file_write_buffered(output_file, global_name, 0)
                file_write_buffered(output_file, ":", 0)
                file_write_buffered(output_file, "    .zero 8  # 8 bytes for Integer", 0)
            End If
            Let i be i plus 1
        End While
        file_write_buffered(output_file, "\n", 0)
    End If

    Note: Generate .text section
    emit_line(output_file, ".text")

    Note: Add print_string runtime function
    emit_line(output_file, "print_string:")
    emit_line(output_file, "    pushq %rbp")
    emit_line(output_file, "    movq %rsp, %rbp")
    emit_line(output_file, "")
    emit_line(output_file, "    # Calculate string length")
    emit_line(output_file, "    movq %rdi, %rsi  # Save string pointer")
    emit_line(output_file, "    movq %rdi, %rcx  # Counter for strlen")
    emit_line(output_file, "    xorq %rax, %rax  # Length accumulator")
    emit_line(output_file, ".strlen_loop:")
    emit_line(output_file, "    cmpb $0, (%rcx)")
    emit_line(output_file, "    je .strlen_done")
    emit_line(output_file, "    incq %rcx")
    emit_line(output_file, "    incq %rax")
    emit_line(output_file, "    jmp .strlen_loop")
    emit_line(output_file, ".strlen_done:")
    emit_line(output_file, "")
    emit_line(output_file, "    # Call write syscall (sys_write = 1)")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    movq %rsi, %rsi   # buf = string pointer (already in rsi)")
    emit_line(output_file, "    movq %rax, %rdx   # count = string length")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    # Print newline")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    leaq .newline(%rip), %rsi  # newline string")
    emit_line(output_file, "    movq $1, %rdx     # count = 1")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    popq %rbp")
    emit_line(output_file, "    ret")
    emit_line(output_file, "\n")

    Note: Add print_integer runtime function
    emit_line(output_file, "print_integer:")
    emit_line(output_file, "    pushq %rbp")
    emit_line(output_file, "    movq %rsp, %rbp")
    emit_line(output_file, "    subq $32, %rsp  # Space for string buffer (20 digits + null)")
    emit_line(output_file, "")
    emit_line(output_file, "    # Convert integer to string")
    emit_line(output_file, "    movq %rdi, %rax  # integer value")
    emit_line(output_file, "    leaq -32(%rbp), %rsi  # buffer pointer")
    emit_line(output_file, "    addq $19, %rsi  # point to end of buffer (for reverse building)")
    emit_line(output_file, "    movb $0, (%rsi)  # null terminator")
    emit_line(output_file, "    decq %rsi")
    emit_line(output_file, "")
    emit_line(output_file, "    # Handle zero case")
    emit_line(output_file, "    testq %rax, %rax")
    emit_line(output_file, "    jnz .convert_loop")
    emit_line(output_file, "    movb $48, (%rsi)  # '0' character")
    emit_line(output_file, "    jmp .convert_done")
    emit_line(output_file, "")
    emit_line(output_file, ".convert_loop:")
    emit_line(output_file, "    testq %rax, %rax")
    emit_line(output_file, "    jz .convert_done")
    emit_line(output_file, "    movq %rax, %rcx")
    emit_line(output_file, "    movq $10, %rbx")
    emit_line(output_file, "    xorq %rdx, %rdx")
    emit_line(output_file, "    divq %rbx  # %rax = quotient, %rdx = remainder")
    emit_line(output_file, "    addq $48, %rdx  # convert remainder to ASCII")
    emit_line(output_file, "    movb %dl, (%rsi)  # store digit")
    emit_line(output_file, "    decq %rsi")
    emit_line(output_file, "    jmp .convert_loop")
    emit_line(output_file, "")
    emit_line(output_file, ".convert_done:")
    emit_line(output_file, "    incq %rsi  # point to first character")
    emit_line(output_file, "")
    emit_line(output_file, "    # Calculate string length")
    emit_line(output_file, "    movq %rsi, %rcx  # Counter for strlen")
    emit_line(output_file, "    xorq %rax, %rax  # Length accumulator")
    emit_line(output_file, ".int_strlen_loop:")
    emit_line(output_file, "    cmpb $0, (%rcx)")
    emit_line(output_file, "    je .int_strlen_done")
    emit_line(output_file, "    incq %rcx")
    emit_line(output_file, "    incq %rax")
    emit_line(output_file, "    jmp .int_strlen_loop")
    emit_line(output_file, ".int_strlen_done:")
    emit_line(output_file, "")
    emit_line(output_file, "    # Call write syscall (sys_write = 1)")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    # %rsi already points to string")
    emit_line(output_file, "    movq %rax, %rdx   # count = string length")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    # Print newline")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    leaq .newline(%rip), %rsi  # newline string")
    emit_line(output_file, "    movq $1, %rdx     # count = 1")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    movq %rbp, %rsp")
    emit_line(output_file, "    popq %rbp")
    emit_line(output_file, "    ret")
    emit_line(output_file, "\n")
    emit_line(output_file, ".section .rodata")
    emit_line(output_file, ".newline:")
    Note: Output newline string literal using ASCII byte value
    emit_line(output_file, "    .byte 10  # newline character")

    Note: Output string literals from string table
    Let byte0 be memory_get_byte(codegen, 40)
    Let byte1 be memory_get_byte(codegen, 41)
    Let byte2 be memory_get_byte(codegen, 42)
    Let byte3 be memory_get_byte(codegen, 43)
    Let temp1 be byte1 multiplied by 256
    Let temp2 be byte2 multiplied by 65536
    Let temp3 be byte3 multiplied by 16777216
    Let string_count be byte0 plus temp1 plus temp2 plus temp3

    print_integer(string_count)

    If string_count is greater than 0:
        Let strings be memory_get_pointer(codegen, 32)
        Let i be 0
        While i is less than string_count:
            Let str_label be memory_get_pointer(strings, i multiplied by 16 plus 8)
            Let str_value be memory_get_pointer(strings, i multiplied by 16)
            file_write_buffered(output_file, str_label, 0)
            file_write_buffered(output_file, ":", 0)
            file_write_buffered(output_file, "    .string ", 0)
            Let quote_bytes be memory_allocate(2)
            memory_set_byte(quote_bytes, 0, 34)
            memory_set_byte(quote_bytes, 1, 0)
            file_write_buffered(output_file, quote_bytes, 0)
            file_write_buffered(output_file, str_value, 0)
            file_write_buffered(output_file, quote_bytes, 0)
            file_write_buffered(output_file, "\n", 0)
            deallocate(quote_bytes)
            Let i be i plus 1
        End While
    End If

    emit_line(output_file, ".text")

    Note: ========================================================================
    Note: STACK SAFETY ANALYSIS PHASE - RE-ENABLED
    Note: ========================================================================
    Note: Build call graph for recursion detection and stack safety
    Let call_graph be callgraph_create(program, codegen)
    memory_set_pointer(codegen, 80, call_graph)
    callgraph_build(call_graph)
    callgraph_detect_recursion(call_graph)
    callgraph_print_warnings(call_graph)
    Note: ========================================================================

    Note: Generate all functions
    Let i be 0
    While i is less than function_count:
        Let func be memory_get_pointer(functions, i multiplied by 8)

        Note: Safety check for function pointer - skip NULL pointers
        If func is not equal to 0:
            Let func_name be memory_get_pointer(func, 0)  Note: func->name

            Note: Make main function global
            If string_equals(func_name, "main") is equal to 1:
                emit_line(output_file, ".globl main")
            End If

            emit_line(output_file, "\n")
            codegen_generate_function(codegen, func)
        End If
        Let i be i plus 1
    End While

    Note: Generate stack overflow handler if any recursive functions exist
    If call_graph is not equal to 0:
        Let nodes be memory_get_pointer(call_graph, 0)
        Let node_count be memory_get_int32(call_graph, 8)
        Let has_recursive be 0
        Let i be 0
        While i is less than node_count:
            Let node be memory_get_pointer(nodes, i multiplied by 8)
            Let is_recursive be memory_get_int32(node, 28)
            If is_recursive is equal to 1:
                Let has_recursive be 1
                Let i be node_count  Note: Break
            End If
            Let i be i plus 1
        End While

        If has_recursive is equal to 1:
            codegen_generate_stack_overflow_handler(output_file)
        End If
    End If

    Note: Add a main function wrapper if no main function exists
    Let has_main be 0
    Let i be 0
    While i is less than function_count:
        Let func be memory_get_pointer(functions, i multiplied by 8)

        Note: Safety check for function pointer - skip NULL pointers
        If func is not equal to 0:
            Let func_name be memory_get_pointer(func, 0)  Note: func->name
            If string_equals(func_name, "main") is equal to 1:
                Let has_main be 1
                Let i be function_count  Note: Break
            End If
        End If
        Let i be i plus 1
    End While

    Note: Disable automatic main wrapper generation to allow modular compilation
    Note: Each module should define its own main() if needed
    Note: This prevents multiple main() definitions when linking modules
    Note: If has_main is equal to 0:
    Note:     Note: Wrapper generation disabled for library modules
    Note: End If

    Note: Add memory safety error handlers BEFORE .note.GNU-stack
    file_write_buffered(output_file, "\n", 0)

    Note: Null pointer dereference handler
    emit_line(output_file, ".null_pointer_error:")
    emit_line(output_file, "    # Print error message for null pointer")
    emit_line(output_file, "    leaq .null_pointer_msg(%rip), %rdi")
    emit_line(output_file, "    call print_string@PLT")
    emit_line(output_file, "    # Exit with error code")
    emit_line(output_file, "    movq $1, %rdi")
    emit_line(output_file, "    call exit_with_code@PLT")
    file_write_buffered(output_file, "\n", 0)

    emit_line(output_file, ".bounds_error_negative:")
    emit_line(output_file, "    # Print error message for negative index")
    emit_line(output_file, "    leaq .bounds_error_negative_msg(%rip), %rdi")
    emit_line(output_file, "    call print_string@PLT")
    emit_line(output_file, "    # Print the negative index value")
    emit_line(output_file, "    movq %rbx, %rdi  # Index value")
    emit_line(output_file, "    call print_integer@PLT")
    emit_line(output_file, "    # Exit with error code")
    emit_line(output_file, "    movq $1, %rdi")
    emit_line(output_file, "    call exit_with_code@PLT")
    file_write_buffered(output_file, "\n", 0)

    emit_line(output_file, ".bounds_error_overflow:")
    emit_line(output_file, "    # Save registers that will be clobbered")
    emit_line(output_file, "    pushq %rcx  # Save array size")
    emit_line(output_file, "    pushq %rbx  # Save index")
    emit_line(output_file, "    # Print error message for out-of-bounds index")
    emit_line(output_file, "    leaq .bounds_error_overflow_msg(%rip), %rdi")
    emit_line(output_file, "    call print_string@PLT")
    emit_line(output_file, "    # Print the index value")
    emit_line(output_file, "    popq %rdi  # Restore and use index")
    emit_line(output_file, "    pushq %rdi  # Save again for later")
    emit_line(output_file, "    call print_integer@PLT")
    emit_line(output_file, "    # Print size message")
    emit_line(output_file, "    leaq .bounds_error_size_msg(%rip), %rdi")
    emit_line(output_file, "    call print_string@PLT")
    emit_line(output_file, "    # Print the array size")
    emit_line(output_file, "    movq 8(%rsp), %rdi  # Get saved array size from stack")
    emit_line(output_file, "    call print_integer@PLT")
    emit_line(output_file, "    # Clean up stack")
    emit_line(output_file, "    addq $16, %rsp")
    emit_line(output_file, "    # Exit with error code")
    emit_line(output_file, "    movq $1, %rdi")
    emit_line(output_file, "    call exit_with_code@PLT")
    file_write_buffered(output_file, "\n", 0)

    Note: Add error message strings to .rodata
    emit_line(output_file, ".section .rodata")

    emit_line(output_file, ".null_pointer_msg:")
    emit_line(output_file, "    .byte 70,65,84,65,76,32,69,82,82,79,82,58,32")  Note: "FATAL ERROR: "
    emit_line(output_file, "    .byte 78,117,108,108,32,112,111,105,110,116,101,114,32")  Note: "Null pointer "
    emit_line(output_file, "    .byte 100,101,114,101,102,101,114,101,110,99,101")  Note: "dereference"
    emit_line(output_file, "    .byte 10,0")  Note: "\n"
    file_write_buffered(output_file, "\n", 0)

    emit_line(output_file, ".bounds_error_negative_msg:")
    emit_line(output_file, "    .byte 70,65,84,65,76,32,69,82,82,79,82,58,32")  Note: "FATAL ERROR: "
    emit_line(output_file, "    .byte 65,114,114,97,121,32,105,110,100,101,120,32")  Note: "Array index "
    emit_line(output_file, "    .byte 105,115,32,110,101,103,97,116,105,118,101,58,32")  Note: "is negative: "
    emit_line(output_file, "    .byte 0")
    file_write_buffered(output_file, "\n", 0)

    emit_line(output_file, ".bounds_error_overflow_msg:")
    emit_line(output_file, "    .byte 70,65,84,65,76,32,69,82,82,79,82,58,32")  Note: "FATAL ERROR: "
    emit_line(output_file, "    .byte 65,114,114,97,121,32,105,110,100,101,120,32")  Note: "Array index "
    emit_line(output_file, "    .byte 111,117,116,32,111,102,32,98,111,117,110,100,115,58,32")  Note: "out of bounds: "
    emit_line(output_file, "    .byte 0")
    file_write_buffered(output_file, "\n", 0)

    emit_line(output_file, ".bounds_error_size_msg:")
    emit_line(output_file, "    .byte 32,40,97,114,114,97,121,32,115,105,122,101,32,105,115,32")  Note: " (array size is "
    emit_line(output_file, "    .byte 41,10,0")  Note: ")\n"
    file_write_buffered(output_file, "\n", 0)

    Note: Add GNU stack note to prevent executable stack warning
    file_write_buffered(output_file, "\n", 0)
    Note: Output the GNU stack section (MUST BE LAST)
    emit_line(output_file, ".section .note.GNU-stack")

    Return 0
End Process

Note: ========================================================================
Note: STACK SAFETY & MEMORY FOUNDATION
Note: ========================================================================
Note: This section implements critical compiler safety features:
Note: 1. Call graph analysis for recursion detection
Note: 2. Stack overflow protection via stack probes
Note: 3. Tail call optimization (TCO) for tail-recursive functions
Note: 4. Stack size calculation and warnings
Note: ========================================================================

Note: Data Structures for Call Graph Analysis
Note: CallGraphNode structure (40 bytes):
Note:   offset 0:  function_name (pointer)
Note:   offset 8:  function_ptr (pointer to Function AST node)
Note:   offset 16: callees (pointer array - functions this calls)
Note:   offset 24: callee_count (int32)
Note:   offset 28: is_recursive (int32) - 1 if recursively calls itself
Note:   offset 32: callee_capacity (int32) - allocated capacity for callees array

Note: CallGraph structure (32 bytes):
Note:   offset 0:  nodes (CallGraphNode** array)
Note:   offset 8:  node_count (int32)
Note:   offset 12: node_capacity (int32)
Note:   offset 16: program (pointer to Program AST)
Note:   offset 24: codegen (pointer to CodeGen state)

Note: Create a new call graph for analysis
Process called "callgraph_create" takes program as Integer, codegen as Integer returns Integer:
    Let graph be allocate(32)

    Note: Initialize with capacity for 64 functions
    Let initial_capacity be 64
    memory_set_pointer(graph, 0, allocate(initial_capacity multiplied by 8))
    memory_set_int32(graph, 8, 0)
    memory_set_int32(graph, 12, initial_capacity)
    memory_set_pointer(graph, 16, program)
    memory_set_pointer(graph, 24, codegen)

    Return graph
End Process

Note: Destroy a call graph and free all resources
Process called "callgraph_destroy" takes graph as Integer returns Integer:
    If graph is equal to 0:
        Return 0
    End If

    Note: Get nodes array and count
    Let nodes be memory_get_pointer(graph, 0)
    Let node_count be memory_get_int32(graph, 8)

    Note: Free each node
    If nodes is not equal to 0:
        Let i be 0
        While i is less than node_count:
            Let node be memory_get_pointer(nodes, i multiplied by 8)
            If node is not equal to 0:
                Note: Free node's function name
                Let func_name be memory_get_pointer(node, 0)
                If func_name is not equal to 0:
                    deallocate(func_name)
                End If

                Note: Free node's callees array
                Let callees be memory_get_pointer(node, 16)
                If callees is not equal to 0:
                    deallocate(callees)
                End If

                Note: Free the node itself
                deallocate(node)
            End If
            Let i be i plus 1
        End While

        Note: Free the nodes array
        deallocate(nodes)
    End If

    Note: Free the graph itself
    deallocate(graph)
    Return 0
End Process

Note: Create a new call graph node for a function
Process called "callgraph_node_create" takes function_name as Integer, function_ptr as Integer returns Integer:
    Let node be allocate(40)

    memory_set_pointer(node, 0, string_duplicate(function_name))
    memory_set_pointer(node, 8, function_ptr)

    Note: Initialize with capacity for 16 callees
    Let initial_callees_capacity be 16
    memory_set_pointer(node, 16, allocate(initial_callees_capacity multiplied by 8))
    memory_set_int32(node, 24, 0)  Note: callee_count
    memory_set_int32(node, 28, 0)  Note: is_recursive = false
    memory_set_int32(node, 32, initial_callees_capacity)  Note: callee_capacity

    Return node
End Process

Note: Add a callee to a call graph node
Process called "callgraph_node_add_callee" takes node as Integer, callee_name as Integer returns Integer:
    Let callees be memory_get_pointer(node, 16)
    Let callee_count be memory_get_int32(node, 24)
    Let callee_capacity be memory_get_int32(node, 32)

    Note: Check if callee already exists
    Let i be 0
    While i is less than callee_count:
        Let existing_callee be memory_get_pointer(callees, i multiplied by 8)
        If string_equals(existing_callee, callee_name) is equal to 1:
            Return 0  Note: Already exists, don't add duplicate
        End If
        Let i be i plus 1
    End While

    Note: Resize array if full
    If callee_count is greater than or equal to callee_capacity:
        Let new_capacity be callee_capacity multiplied by 2
        Let new_callees be allocate(new_capacity multiplied by 8)

        Note: Copy existing callees
        Let i be 0
        While i is less than callee_count:
            Let old_callee be memory_get_pointer(callees, i multiplied by 8)
            memory_set_pointer(new_callees, i multiplied by 8, old_callee)
            Let i be i plus 1
        End While

        deallocate(callees)
        Set callees to new_callees
        memory_set_pointer(node, 16, new_callees)
        memory_set_int32(node, 32, new_capacity)
    End If

    Note: Add new callee
    memory_set_pointer(callees, callee_count multiplied by 8, string_duplicate(callee_name))
    memory_set_int32(node, 24, callee_count plus 1)

    Return 0
End Process

Note: Add a node to the call graph
Process called "callgraph_add_node" takes graph as Integer, node as Integer returns Integer:
    Let nodes be memory_get_pointer(graph, 0)
    Let node_count be memory_get_int32(graph, 8)
    Let capacity be memory_get_int32(graph, 12)

    Note: Resize array if full
    If node_count is greater than or equal to capacity:
        Let new_capacity be capacity multiplied by 2
        Let new_nodes be allocate(new_capacity multiplied by 8)

        Note: Copy existing nodes
        Let i be 0
        While i is less than node_count:
            Let old_node be memory_get_pointer(nodes, i multiplied by 8)
            memory_set_pointer(new_nodes, i multiplied by 8, old_node)
            Let i be i plus 1
        End While

        deallocate(nodes)
        Set nodes to new_nodes
        memory_set_pointer(graph, 0, new_nodes)
        memory_set_int32(graph, 12, new_capacity)
    End If

    Note: Store the node
    memory_set_pointer(nodes, node_count multiplied by 8, node)
    memory_set_int32(graph, 8, node_count plus 1)

    Return 0
End Process

Note: Find a node in the call graph by function name
Process called "callgraph_find_node" takes graph as Integer, function_name as Integer returns Integer:
    Let nodes be memory_get_pointer(graph, 0)
    Let node_count be memory_get_int32(graph, 8)

    Let i be 0
    While i is less than node_count:
        Let node be memory_get_pointer(nodes, i multiplied by 8)
        Let node_name be memory_get_pointer(node, 0)

        If string_equals(node_name, function_name) is equal to 1:
            Return node
        End If

        Let i be i plus 1
    End While

    Return 0  Note: Not found
End Process

Note: Traverse expression to find function calls
Process called "callgraph_collect_calls_from_expr" takes graph as Integer, node as Integer, expr as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If

    Note: Sanity check: expr should be a valid heap pointer (> 4096)
    If expr is less than 4096:
        Return 0
    End If

    Let expr_type be memory_get_int32(expr, 0)

    Note: Sanity check: expr_type should be in valid range (0-30)
    If expr_type is less than 0:
        Return 0
    End If
    If expr_type is greater than 30:
        Return 0
    End If

    Note: EXPR_INTEGER_LITERAL = 0 (leaf node, no traversal)
    Note: EXPR_STRING_LITERAL = 5 (leaf node, no traversal)
    Note: EXPR_VARIABLE = 1 (leaf node, no traversal)
    Note: EXPR_FUNCTION_POINTER = 10 (leaf node, no traversal)

    Note: EXPR_FUNCTION_CALL = 4
    If expr_type is equal to 4:
        Let function_call_ptr be expr plus 8
        Let function_name be memory_get_pointer(function_call_ptr, 0)

        Note: Add this function to the callees
        callgraph_node_add_callee(node, function_name)

        Note: Also traverse arguments
        Let arguments be memory_get_pointer(function_call_ptr, 8)
        Let arg_count be memory_get_int32(function_call_ptr, 16)

        Note: Safety check: only traverse if arguments array exists
        If arguments is not equal to 0:
            Let i be 0
            While i is less than arg_count:
                Let arg_expr be memory_get_pointer(arguments, i multiplied by 8)
                callgraph_collect_calls_from_expr(graph, node, arg_expr)
                Let i be i plus 1
            End While
        End If
    End If

    Note: EXPR_BINARY_OP = 2
    If expr_type is equal to 2:
        Let binary_op_ptr be expr plus 8
        Let left be memory_get_pointer(binary_op_ptr, 0)
        Let right be memory_get_pointer(binary_op_ptr, 8)

        callgraph_collect_calls_from_expr(graph, node, left)
        callgraph_collect_calls_from_expr(graph, node, right)
    End If

    Note: EXPR_COMPARISON = 3
    If expr_type is equal to 3:
        Let comparison_ptr be expr plus 8
        Let left be memory_get_pointer(comparison_ptr, 0)
        Let right be memory_get_pointer(comparison_ptr, 8)

        callgraph_collect_calls_from_expr(graph, node, left)
        callgraph_collect_calls_from_expr(graph, node, right)
    End If

    Note: EXPR_UNARY = 12 (NOT operator)
    If expr_type is equal to 12:
        Let unary_ptr be expr plus 8
        Let operand be memory_get_pointer(unary_ptr, 8)

        callgraph_collect_calls_from_expr(graph, node, operand)
    End If

    Note: EXPR_BUILTIN_CALL = 8
    If expr_type is equal to 8:
        Let builtin_call_ptr be expr plus 8
        Let arguments be memory_get_pointer(builtin_call_ptr, 8)
        Let arg_count be memory_get_int32(builtin_call_ptr, 16)

        Note: Traverse arguments for nested calls (safety check for NULL)
        If arguments is not equal to 0:
            Let i be 0
            While i is less than arg_count:
                Let arg_expr be memory_get_pointer(arguments, i multiplied by 8)
                callgraph_collect_calls_from_expr(graph, node, arg_expr)
                Let i be i plus 1
            End While
        End If
    End If

    Note: EXPR_INDIRECT_CALL = 11 (function pointer call)
    If expr_type is equal to 11:
        Let indirect_call_ptr be expr plus 8
        Let func_ptr_expr be memory_get_pointer(indirect_call_ptr, 0)
        Let arguments be memory_get_pointer(indirect_call_ptr, 8)
        Let arg_count be memory_get_int32(indirect_call_ptr, 16)

        Note: Traverse function pointer expression
        callgraph_collect_calls_from_expr(graph, node, func_ptr_expr)

        Note: Traverse arguments (safety check for NULL)
        If arguments is not equal to 0:
            Let i be 0
            While i is less than arg_count:
                Let arg_expr be memory_get_pointer(arguments, i multiplied by 8)
                callgraph_collect_calls_from_expr(graph, node, arg_expr)
                Let i be i plus 1
            End While
        End If
    End If

    Note: EXPR_FIELD_ACCESS = 6
    If expr_type is equal to 6:
        Let field_access_ptr be expr plus 8
        Let object_expr be memory_get_pointer(field_access_ptr, 0)

        callgraph_collect_calls_from_expr(graph, node, object_expr)
    End If

    Note: EXPR_VARIANT_CONSTRUCTOR = 9
    If expr_type is equal to 9:
        Let field_values be memory_get_pointer(expr, 24)
        Let field_count be memory_get_int32(expr, 32)

        Note: Variant may have field value expressions
        If field_values is not equal to 0:
            Let i be 0
            While i is less than field_count:
                Let field_expr be memory_get_pointer(field_values, i multiplied by 8)
                callgraph_collect_calls_from_expr(graph, node, field_expr)
                Let i be i plus 1
            End While
        End If
    End If

    Note: EXPR_STRUCT_CONSTRUCTION = 20
    If expr_type is equal to 20:
        Let struct_ptr be expr plus 8
        Let field_values be memory_get_pointer(struct_ptr, 16)
        Let field_count be memory_get_int32(struct_ptr, 24)

        Note: Traverse all field value expressions (safety check for NULL)
        If field_values is not equal to 0:
            Let i be 0
            While i is less than field_count:
                Let field_value_expr be memory_get_pointer(field_values, i multiplied by 8)
                callgraph_collect_calls_from_expr(graph, node, field_value_expr)
                Let i be i plus 1
            End While
        End If
    End If

    Note: EXPR_TYPE_CAST = 7 (cast expression)
    If expr_type is equal to 7:
        Let cast_ptr be expr plus 8
        Let value_expr be memory_get_pointer(cast_ptr, 8)

        callgraph_collect_calls_from_expr(graph, node, value_expr)
    End If

    Note: EXPR_ARRAY_INDEX = 16
    If expr_type is equal to 16:
        Let array_index_ptr be expr plus 8
        Let array_expr be memory_get_pointer(array_index_ptr, 0)
        Let index_expr be memory_get_pointer(array_index_ptr, 8)

        callgraph_collect_calls_from_expr(graph, node, array_expr)
        callgraph_collect_calls_from_expr(graph, node, index_expr)
    End If

    Return 0
End Process

Note: Traverse statement to find function calls
Process called "callgraph_collect_calls_from_stmt" takes graph as Integer, node as Integer, stmt as Integer returns Integer:
    If stmt is equal to 0:
        Return 0
    End If

    Let stmt_type be memory_get_int32(stmt, 0)

    Note: STMT_EXPRESSION = 7
    If stmt_type is equal to 7:
        Let expr be memory_get_pointer(stmt, 8)
        callgraph_collect_calls_from_expr(graph, node, expr)
    End If

    Note: STMT_RETURN = 3
    If stmt_type is equal to 3:
        Let return_expr be memory_get_pointer(stmt, 8)
        callgraph_collect_calls_from_expr(graph, node, return_expr)
    End If

    Note: STMT_PRINT = 4
    If stmt_type is equal to 4:
        Let expr be memory_get_pointer(stmt, 8)
        callgraph_collect_calls_from_expr(graph, node, expr)
    End If

    Note: STMT_IF = 5
    If stmt_type is equal to 5:
        Let if_ptr be stmt plus 8
        Let condition be memory_get_pointer(if_ptr, 0)
        Let then_stmts be memory_get_pointer(if_ptr, 8)
        Let then_count be memory_get_int32(if_ptr, 16)
        Let else_stmts be memory_get_pointer(if_ptr, 24)
        Let else_count be memory_get_int32(if_ptr, 32)

        callgraph_collect_calls_from_expr(graph, node, condition)

        Let i be 0
        While i is less than then_count:
            Let then_stmt be memory_get_pointer(then_stmts, i multiplied by 8)
            callgraph_collect_calls_from_stmt(graph, node, then_stmt)
            Let i be i plus 1
        End While

        Let i be 0
        While i is less than else_count:
            Let else_stmt be memory_get_pointer(else_stmts, i multiplied by 8)
            callgraph_collect_calls_from_stmt(graph, node, else_stmt)
            Let i be i plus 1
        End While
    End If

    Note: STMT_WHILE = 6
    If stmt_type is equal to 6:
        Let while_ptr be stmt plus 8
        Let condition be memory_get_pointer(while_ptr, 0)
        Let body_stmts be memory_get_pointer(while_ptr, 8)
        Let body_count be memory_get_int32(while_ptr, 16)

        callgraph_collect_calls_from_expr(graph, node, condition)

        Let i be 0
        While i is less than body_count:
            Let body_stmt be memory_get_pointer(body_stmts, i multiplied by 8)
            callgraph_collect_calls_from_stmt(graph, node, body_stmt)
            Let i be i plus 1
        End While
    End If

    Note: STMT_FOR = 11 (For-range: For var from start to end by step)
    If stmt_type is equal to 11:
        Let start_expr be memory_get_pointer(stmt, 16)
        Let end_expr be memory_get_pointer(stmt, 24)
        Let step_expr be memory_get_pointer(stmt, 32)
        Let body_stmts be memory_get_pointer(stmt, 40)
        Let body_count be memory_get_int32(stmt, 48)

        callgraph_collect_calls_from_expr(graph, node, start_expr)
        callgraph_collect_calls_from_expr(graph, node, end_expr)

        Note: step_expr can be 0 if no step specified
        If step_expr is not equal to 0:
            callgraph_collect_calls_from_expr(graph, node, step_expr)
        End If

        Let i be 0
        While i is less than body_count:
            Let body_stmt be memory_get_pointer(body_stmts, i multiplied by 8)
            callgraph_collect_calls_from_stmt(graph, node, body_stmt)
            Let i be i plus 1
        End While
    End If

    Note: STMT_MATCH = 8
    If stmt_type is equal to 8:
        Let match_ptr be stmt plus 8
        Let expr be memory_get_pointer(match_ptr, 0)
        Let arms be memory_get_pointer(match_ptr, 8)
        Let arm_count be memory_get_int32(match_ptr, 16)

        callgraph_collect_calls_from_expr(graph, node, expr)

        Let i be 0
        While i is less than arm_count:
            Let arm_offset be i multiplied by 48  Note: sizeof(WhenClause) = 48 bytes
            Let arm be arms plus arm_offset
            Let body_stmts be memory_get_pointer(arm, 32)  Note: WHEN_BODY_STMTS = 32
            Let body_count be memory_get_int32(arm, 40)    Note: WHEN_BODY_COUNT = 40

            Let j be 0
            While j is less than body_count:
                Let body_stmt be memory_get_pointer(body_stmts, j multiplied by 8)
                callgraph_collect_calls_from_stmt(graph, node, body_stmt)
                Let j be j plus 1
            End While

            Let i be i plus 1
        End While
    End If

    Note: STMT_FOR_EACH = 12
    If stmt_type is equal to 12:
        Let for_each_ptr be stmt plus 8
        Let collection_expr be memory_get_pointer(for_each_ptr, 8)
        Let body_stmts be memory_get_pointer(for_each_ptr, 16)
        Let body_count be memory_get_int32(for_each_ptr, 24)

        callgraph_collect_calls_from_expr(graph, node, collection_expr)

        Let i be 0
        While i is less than body_count:
            Let body_stmt be memory_get_pointer(body_stmts, i multiplied by 8)
            callgraph_collect_calls_from_stmt(graph, node, body_stmt)
            Let i be i plus 1
        End While
    End If

    Note: STMT_LET = 1
    If stmt_type is equal to 1:
        Let let_expr be memory_get_pointer(stmt, 16)
        callgraph_collect_calls_from_expr(graph, node, let_expr)
    End If

    Note: STMT_SET = 2
    If stmt_type is equal to 2:
        Let set_expr be memory_get_pointer(stmt, 16)
        callgraph_collect_calls_from_expr(graph, node, set_expr)
    End If

    Note: STMT_COMPOUND_ASSIGN = 17
    If stmt_type is equal to 17:
        Let compound_expr be memory_get_pointer(stmt, 24)
        callgraph_collect_calls_from_expr(graph, node, compound_expr)
    End If

    Note: STMT_BREAK = 9 and STMT_CONTINUE = 10 have no expressions to traverse

    Return 0
End Process

Note: Build call graph from program AST
Process called "callgraph_build" takes graph as Integer returns Integer:
    Let program be memory_get_pointer(graph, 16)
    Let functions be memory_get_pointer(program, 0)
    Let function_count be memory_get_int32(program, 8)

    Note: First pass: create nodes for all functions
    Let i be 0
    While i is less than function_count:
        Let func be memory_get_pointer(functions, i multiplied by 8)

        If func is not equal to 0:
            Let func_name be memory_get_pointer(func, 0)
            Let node be callgraph_node_create(func_name, func)
            callgraph_add_node(graph, node)
        End If

        Let i be i plus 1
    End While

    Note: Second pass: traverse function bodies to collect calls
    Let nodes be memory_get_pointer(graph, 0)
    Let node_count be memory_get_int32(graph, 8)

    Note: Safety check for null nodes array
    If nodes is equal to 0:
        Return 0
    End If

    Let i be 0
    While i is less than node_count:
        Let node be memory_get_pointer(nodes, i multiplied by 8)
        Let should_skip be 0

        Note: Check if node is null
        If node is equal to 0:
            Let should_skip be 1
        End If

        Note: Check if func is null
        Let func be 0
        If should_skip is equal to 0:
            Set func to memory_get_pointer(node, 8)
            If func is equal to 0:
                Let should_skip be 1
            End If
        End If

        Note: Process node if not skipped
        If should_skip is equal to 0:
            Let statements be memory_get_pointer(func, 32)
            Let stmt_count be memory_get_int32(func, 40)

            Let j be 0
            While j is less than stmt_count:
                Let stmt be memory_get_pointer(statements, j multiplied by 8)
                If stmt is not equal to 0:
                    callgraph_collect_calls_from_stmt(graph, node, stmt)
                End If
                Let j be j plus 1
            End While
        End If

        Let i be i plus 1
    End While

    Return 0
End Process

Note: Detect direct recursion (function calls itself)
Process called "callgraph_detect_direct_recursion" takes graph as Integer, node as Integer returns Integer:
    Let function_name be memory_get_pointer(node, 0)
    Let callees be memory_get_pointer(node, 16)
    Let callee_count be memory_get_int32(node, 24)

    Let i be 0
    While i is less than callee_count:
        Let callee_name be memory_get_pointer(callees, i multiplied by 8)

        If string_equals(function_name, callee_name) is equal to 1:
            memory_set_int32(node, 28, 1)  Note: Mark as recursive
            Return 1
        End If

        Let i be i plus 1
    End While

    Return 0
End Process

Note: Detect mutual recursion using depth-first search
Note: Uses a visited array to track function visit state during DFS
Note: visited states: 0 = unvisited, 1 = visiting (on stack), 2 = visited
Process called "callgraph_detect_mutual_recursion_dfs" takes graph as Integer, node as Integer, visited as Integer, node_index as Integer returns Integer:
    Note: Mark as visiting (on stack)
    memory_set_int32(visited, node_index multiplied by 4, 1)

    Let callees be memory_get_pointer(node, 16)
    Let callee_count be memory_get_int32(node, 24)

    Let found_cycle be 0

    Let i be 0
    While i is less than callee_count:
        Let callee_name be memory_get_pointer(callees, i multiplied by 8)
        Let callee_node be callgraph_find_node(graph, callee_name)

        If callee_node is not equal to 0:
            Note: Find callee's index
            Let nodes be memory_get_pointer(graph, 0)
            Let node_count be memory_get_int32(graph, 8)

            Let callee_idx be 0
            Let j be 0
            While j is less than node_count:
                Let check_node be memory_get_pointer(nodes, j multiplied by 8)
                If check_node is equal to callee_node:
                    Let callee_idx be j
                    Let j be node_count  Note: Break
                End If
                Let j be j plus 1
            End While

            Let callee_state be memory_get_int32(visited, callee_idx multiplied by 4)

            Note: If callee is currently being visited, we found a cycle
            If callee_state is equal to 1:
                memory_set_int32(node, 28, 1)  Note: Mark current as recursive
                memory_set_int32(callee_node, 28, 1)  Note: Mark callee as recursive
                Let found_cycle be 1
            End If

            Note: If callee is unvisited, recurse
            If callee_state is equal to 0:
                Let cycle_found be callgraph_detect_mutual_recursion_dfs(graph, callee_node, visited, callee_idx)
                If cycle_found is equal to 1:
                    Let found_cycle be 1
                End If
            End If
        End If

        Let i be i plus 1
    End While

    Note: Mark as visited (done)
    memory_set_int32(visited, node_index multiplied by 4, 2)

    Return found_cycle
End Process

Note: Detect all recursion (direct and mutual)
Process called "callgraph_detect_recursion" takes graph as Integer returns Integer:
    Let nodes be memory_get_pointer(graph, 0)
    Let node_count be memory_get_int32(graph, 8)

    Note: First detect direct recursion
    Let i be 0
    While i is less than node_count:
        Let node be memory_get_pointer(nodes, i multiplied by 8)
        callgraph_detect_direct_recursion(graph, node)
        Let i be i plus 1
    End While

    Note: Then detect mutual recursion using DFS
    Let visited be allocate(node_count multiplied by 4)  Note: Array of int32

    Note: Initialize all to unvisited (0)
    Let i be 0
    While i is less than node_count:
        memory_set_int32(visited, i multiplied by 4, 0)
        Let i be i plus 1
    End While

    Note: Run DFS from each unvisited node
    Let i be 0
    While i is less than node_count:
        Let state be memory_get_int32(visited, i multiplied by 4)
        If state is equal to 0:
            Let node be memory_get_pointer(nodes, i multiplied by 8)
            callgraph_detect_mutual_recursion_dfs(graph, node, visited, i)
        End If
        Let i be i plus 1
    End While

    deallocate(visited)
    Return 0
End Process

Note: Check if a return statement is a tail call
Process called "is_tail_call" takes stmt as Integer, function_name as Integer returns Integer:
    If stmt is equal to 0:
        Return 0
    End If

    Let stmt_type be memory_get_int32(stmt, 0)

    Note: STMT_RETURN = 3
    If stmt_type is not equal to 3:
        Return 0
    End If

    Let return_expr be memory_get_pointer(stmt, 8)
    If return_expr is equal to 0:
        Return 0
    End If

    Let expr_type be memory_get_int32(return_expr, 0)

    Note: EXPR_FUNCTION_CALL = 9
    If expr_type is not equal to 9:
        Return 0
    End If

    Let function_call_ptr be return_expr plus 8
    Let called_function_name be memory_get_pointer(function_call_ptr, 0)

    Note: Check if it's calling itself
    If string_equals(function_name, called_function_name) is equal to 1:
        Return 1
    End If

    Return 0
End Process

Note: Calculate stack size needed for a function
Note: This includes local variables and call depth estimation
Process called "callgraph_calculate_stack_size" takes node as Integer returns Integer:
    Let func be memory_get_pointer(node, 8)

    Note: Base stack size: 2048 bytes (conservative estimate)
    Let stack_size be 2048

    Note: Check if recursive - if so, needs unlimited stack
    Let is_recursive be memory_get_int32(node, 28)
    If is_recursive is equal to 1:
        Return -1  Note: -1 indicates unbounded/recursive
    End If

    Note: Add 256 bytes per callee (conservative estimate for call overhead)
    Let callee_count be memory_get_int32(node, 24)
    Let stack_size be stack_size plus callee_count multiplied by 256

    Return stack_size
End Process

Note: Print recursion warnings for all recursive functions
Process called "callgraph_print_warnings" takes graph as Integer returns Integer:
    Let nodes be memory_get_pointer(graph, 0)
    Let node_count be memory_get_int32(graph, 8)

    Let i be 0
    While i is less than node_count:
        Let node be memory_get_pointer(nodes, i multiplied by 8)
        Let is_recursive be memory_get_int32(node, 28)

        If is_recursive is equal to 1:
            Let function_name be memory_get_pointer(node, 0)

            print_string("[WARNING] Recursive function detected: ")
            print_string(function_name)
            print_string("\n")
            print_string("          Stack overflow possible. Consider tail call optimization or iterative approach.\n")
        End If

        Let i be i plus 1
    End While

    Return 0
End Process

Note: Inject stack probe at function prologue
Note: This checks if stack pointer is within safe bounds before proceeding
Process called "codegen_inject_stack_probe" takes output_file as Integer, function_name as Integer, is_recursive as Integer returns Integer:
    Note: Only inject probes for recursive functions or in debug mode
    If is_recursive is equal to 0:
        Return 0
    End If

    emit_line(output_file, "    # Stack overflow protection")
    emit_line(output_file, "    movq %rsp, %rax")
    emit_line(output_file, "    subq $16384, %rax  # Check if we have 16KB stack space")

    Note: Compare against a conservative stack limit
    Note: In a full implementation, this would check against __stack_limit
    emit_line(output_file, "    cmpq $0x100000, %rax  # Compare against 1MB limit")
    emit_line(output_file, "    jb .stack_overflow_panic")

    Return 0
End Process

Note: Generate stack overflow panic handler
Process called "codegen_generate_stack_overflow_handler" takes output_file as Integer returns Integer:
    file_write_buffered(output_file, "\n", 0)
    emit_line(output_file, "# Stack overflow panic handler")
    emit_line(output_file, ".stack_overflow_panic:")
    emit_line(output_file, "    # Print error message")
    emit_line(output_file, "    leaq .stack_overflow_msg(%rip), %rdi")
    emit_line(output_file, "    call print_string@PLT")
    emit_line(output_file, "    # Exit with error code")
    emit_line(output_file, "    movq $1, %rdi")
    emit_line(output_file, "    call exit_with_code@PLT")
    file_write_buffered(output_file, "\n", 0)
    emit_line(output_file, ".section .rodata")
    emit_line(output_file, ".stack_overflow_msg:")
    emit_line(output_file, "    .byte 70,65,84,65,76,32,69,82,82,79,82,58,32")  Note: "FATAL ERROR: "
    emit_line(output_file, "    .byte 83,116,97,99,107,32,111,118,101,114,102,108,111,119,32")  Note: "Stack overflow "
    emit_line(output_file, "    .byte 100,101,116,101,99,116,101,100")  Note: "detected"
    emit_line(output_file, "    .byte 10,0")
    emit_line(output_file, ".text")
    file_write_buffered(output_file, "\n", 0)

    Return 0
End Process

Note: ========================================================================
Note: END OF STACK SAFETY & MEMORY FOUNDATION
Note: ========================================================================

Note: ===== TYPE INFERENCE INTEGRATION =====

Note: Wrapper for code generation with type inference results
Process called "codegen_generate_with_types" takes codegen as Integer, program as Integer, func_table as Integer returns Integer:
    Note: Store function table in codegen for later use
    Note: We'll use offset 56 (after program at 48)
    memory_set_pointer(codegen, 56, func_table)

    Note: Call original codegen_generate
    Return codegen_generate(codegen, program)
End Process

Note: Get inferred type for a variable based on its range
Note: Returns type kind (0=Integer8, 1=Integer16, etc.) or -1 if not inferred
Process called "codegen_get_inferred_type" takes codegen as Integer, var_name as Integer returns Integer:
    Note: Get function table from codegen
    Let func_table be memory_get_pointer(codegen, 56)

    Note: If no function table, return unknown (-1)
    If func_table is equal to 0:
        Return 0 minus 1
    End If

    Note: TODO: For now, we need to track variable ranges per function
    Note: This requires extending the analysis to store variable ranges
    Note: For initial integration, return -1 (use default Integer64)
    Return 0 minus 1
End Process

Note: Insert runtime overflow check for addition
Process called "emit_overflow_check_add" takes codegen as Integer, left_range as Integer, right_range as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)

    Note: Check if operation can overflow
    Let left_is_unknown be range_is_unknown(left_range)
    Let right_is_unknown be range_is_unknown(right_range)

    If left_is_unknown is equal to 1:
        Note: Unknown range - emit runtime check
        emit_line(output_file, "    # Runtime overflow check for addition")
        emit_line(output_file, "    movq %rax, %r10  # Save left operand")
        emit_line(output_file, "    movq %rbx, %r11  # Save right operand")
        emit_line(output_file, "    addq %rbx, %rax")
        emit_line(output_file, "    jo .overflow_panic  # Jump if overflow")
        Return 1
    End If

    If right_is_unknown is equal to 1:
        Note: Unknown range - emit runtime check
        emit_line(output_file, "    # Runtime overflow check for addition")
        emit_line(output_file, "    addq %rbx, %rax")
        emit_line(output_file, "    jo .overflow_panic  # Jump if overflow")
        Return 1
    End If

    Note: Check if mathematically proven safe
    Let left_min be range_get_min(left_range)
    Let left_max be range_get_max(left_range)
    Let right_min be range_get_min(right_range)
    Let right_max be range_get_max(right_range)

    Note: Compute result range
    Let result_min be left_min plus right_min
    Let result_max be left_max plus right_max

    Note: Check if fits in Integer64
    Let INTEGER64_MIN be 0 minus 9223372036854775807  Note: -2^63 + 1 (avoid literal overflow)
    Let INTEGER64_MIN be INTEGER64_MIN minus 1
    Let INTEGER64_MAX be 9223372036854775807

    If result_min is less than INTEGER64_MIN:
        Note: Can overflow - emit check
        emit_line(output_file, "    # Runtime overflow check for addition")
        emit_line(output_file, "    addq %rbx, %rax")
        emit_line(output_file, "    jo .overflow_panic")
        Return 1
    End If

    If result_max is greater than INTEGER64_MAX:
        Note: Can overflow - emit check
        emit_line(output_file, "    # Runtime overflow check for addition")
        emit_line(output_file, "    addq %rbx, %rax")
        emit_line(output_file, "    jo .overflow_panic")
        Return 1
    End If

    Note: Proven safe - no check needed
    emit_line(output_file, "    # Proven safe addition (no check needed)")
    emit_line(output_file, "    addq %rbx, %rax")
    Return 0
End Process

Note: Define overflow panic handler label
Process called "emit_overflow_panic_handler" takes codegen as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)

    file_write_buffered(output_file, "\n", 0)
    emit_line(output_file, "# Overflow panic handler")
    emit_line(output_file, ".overflow_panic:")
    emit_line(output_file, "    leaq .overflow_msg(%rip), %rdi")
    emit_line(output_file, "    call print_string@PLT")
    emit_line(output_file, "    movq $1, %rdi")
    emit_line(output_file, "    call exit_with_code@PLT")
    file_write_buffered(output_file, "\n", 0)

    emit_line(output_file, ".section .rodata")
    emit_line(output_file, ".overflow_msg:")
    emit_line(output_file, "    .byte 70,65,84,65,76,32,69,82,82,79,82,58,32")  Note: "FATAL ERROR: "
    emit_line(output_file, "    .byte 73,110,116,101,103,101,114,32,111,118,101,114,102,108,111,119,32")  Note: "Integer overflow "
    emit_line(output_file, "    .byte 100,101,116,101,99,116,101,100")  Note: "detected"
    emit_line(output_file, "    .byte 10,0")
    emit_line(output_file, ".text")
    file_write_buffered(output_file, "\n", 0)

    Return 0
End Process
Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Main Compiler for Runa v0.0.7.5
Note: Line-by-line transliteration from v0.0.7.3 main.c (64 LOC)

Note: Process to read entire file contents into memory
Note: Equivalent to C static char* read_file(const char *filename)
Process called "read_file_internal" takes filename as Integer returns Integer:
    Note: Read entire file using runtime function (handles file open failure internally)
    Let content be runtime_read_file(filename)

    Note: Check if reading failed (equivalent to fopen() returning NULL)
    If content is equal to 0:
        Note: print_string(error message (equivalent to fprintf(stderr, "[MAIN ERROR] Could not open input file '%s'\n", filename))
        Let error_msg_temp be string_concat("[MAIN ERROR] Could not open input file '", filename)
        Let error_msg be string_concat(error_msg_temp, "'")
        deallocate(error_msg_temp)
        print_string(error_msg)
        deallocate(error_msg)
        Return 0
    End If

    Return content
End Process

Note: Process imports: load and merge imported files
Note: Takes program pointer, returns 0 on success, 1 on failure
Process called "process_imports" takes program as Integer returns Integer:
    Note: Get import count and imports array
    Let import_count be memory_get_int32(program, 40)  Note: PROGRAM_IMPORT_COUNT

    If import_count is equal to 0:
        Return 0  Note: No imports to process
    End If

    Let imports be memory_get_pointer(program, 32)  Note: PROGRAM_IMPORTS

    Note: Iterate through each import
    Let i be 0
    While i is less than import_count:
        Note: Get import statement pointer
        Let ptr_size be 8
        Let import_offset be i multiplied by ptr_size
        Let import_ptr be imports plus import_offset
        Let import_stmt be memory_get_pointer(import_ptr, 0)

        Note: Get filename from import statement (offset 0 is filename)
        Let import_filename be memory_get_pointer(import_stmt, 0)

        Note: Read the imported file
        Let import_source be read_file_internal(import_filename)
        If import_source is equal to 0:
            Let error_msg_temp be string_concat("[IMPORT ERROR] Failed to read import file: ", import_filename)
            print_string(error_msg_temp)
            deallocate(error_msg_temp)
            Return 1
        End If

        Note: Create lexer for imported file
        Let import_lexer be lexer_create(import_source)

        Note: Create parser for imported file
        Let import_parser be parser_create(import_lexer)

        Note: Parse the imported file
        Let import_program be parser_parse_program(import_parser)

        If import_program is equal to 0:
            Let error_msg_temp be string_concat("[IMPORT ERROR] Failed to parse import file: ", import_filename)
            print_string(error_msg_temp)
            deallocate(error_msg_temp)
            parser_destroy(import_parser)
            lexer_destroy(import_lexer)
            deallocate(import_source)
            Return 1
        End If

        Note: Merge functions from imported program into main program
        Let import_func_count be memory_get_int32(import_program, 8)  Note: function_count
        Let import_functions be memory_get_pointer(import_program, 0)  Note: functions array

        Let j be 0
        While j is less than import_func_count:
            Let func_offset be j multiplied by ptr_size
            Let func_ptr be import_functions plus func_offset
            Let func be memory_get_pointer(func_ptr, 0)
            program_add_function(program, func)
            Set j to j plus 1
        End While

        Note: Merge types from imported program into main program
        Let import_type_count be memory_get_int32(import_program, 32)  Note: type_count
        Let import_types be memory_get_pointer(import_program, 40)  Note: types array

        Let k be 0
        While k is less than import_type_count:
            Let type_offset be k multiplied by ptr_size
            Let type_ptr be import_types plus type_offset
            Let type_def be memory_get_pointer(type_ptr, 0)
            program_add_type(program, type_def)
            Set k to k plus 1
        End While

        Note: Cleanup import parsing resources (but not the AST nodes - they're now in main program)
        parser_destroy(import_parser)
        lexer_destroy(import_lexer)
        deallocate(import_source)

        Set i to i plus 1
    End While

    Return 0
End Process

Note: Main compiler entry point
Note: Equivalent to C int main(int argc, char **argv)
Process called "main" takes argc as Integer, argv as Integer returns Integer:
    Note: Check command line arguments (argc != 3)
    If argc is not equal to 3:
        Note: print_string(usage message (equivalent to fprintf(stderr, "Usage: %s <input.runa> <output.s>\n", argv[0]))
        Let prog_name be get_command_line_arg(0)
        Let usage_msg_temp be string_concat("Usage: ", prog_name)
        Let usage_msg be string_concat(usage_msg_temp, " <input.runa> <output.s>")
        deallocate(usage_msg_temp)
        print_string(usage_msg)
        deallocate(usage_msg)
        deallocate(prog_name)
        Return 1
    End If

    Note: Get command line arguments (equivalent to input_filename = argv[1])
    Let input_filename be get_command_line_arg(1)
    Let output_filename be get_command_line_arg(2)

    Note: Read source file (equivalent to char *source = read_file(input_filename))
    Let source be read_file_internal(input_filename)

    Note: Check if reading failed (equivalent to !source)
    If source is equal to 0:
        print_string("[ERROR] Failed to read source file")
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Create lexer (equivalent to Lexer *lexer = lexer_create(source))
    Let lexer be lexer_create(source)

    Note: Create parser (equivalent to Parser *parser = parser_create(lexer))
    Let parser be parser_create(lexer)

    Note: Parse program (equivalent to Program *program = parser_parse_program(parser))
    Let program be parser_parse_program(parser)

    Note: Check if parsing failed (equivalent to !program)
    If program is equal to 0:
        print_string("[ERROR] main: Parsing failed - program is NULL")
        Note: Cleanup parser and lexer before returning
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source)
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Process imports: load and merge imported files
    Let import_result be process_imports(program)
    If import_result is not equal to 0:
        Note: Import processing failed
        program_destroy(program)
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source)
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: ===== TYPE INFERENCE ANALYSIS =====
    Note: TODO: Type inference disabled for stage1 build (modules not linked yet)
    Note:    Note: Run range analysis and type inference on the program
    Note:    Display "[TYPE INFERENCE] Running range analysis..."

    Note:     Note: Build call graph from AST
    Note:     Let callgraph be build_callgraph_from_ast(program)

    Note:     Note: Create function table for return ranges
    Note:     Let func_table be func_table_create()

    Note:     Note: Analyze each function bottom-up
    Note:     Let functions be memory_get_pointer(program, 0)
    Note:     Let func_count be memory_get_int32(program, 8)

    Note:     Let i be 0
    Note:     While i is less than func_count:
    Note:         Let func_offset be i multiplied by 8
    Note:         Let func_ptr be functions plus func_offset
    Note:         Let func be memory_get_pointer(func_ptr, 0)

    Note:         Note: Analyze function and compute return range
    Note:         Let return_range be analyze_function_range(func, func_table, callgraph)

    Note:         Set i to i plus 1
    Note:     End While

    Note:     Display "[TYPE INFERENCE] Range analysis complete"

    Note: Create code generator (equivalent to CodeGenerator *codegen = codegen_create(output_filename))
    Let codegen be codegen_create(output_filename)

    Note: Check if codegen creation failed (equivalent to !codegen)
    If codegen is equal to 0:
        Note: Cleanup resources before returning
        program_destroy(program)
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source)
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Generate code with type inference results (equivalent to codegen_generate(codegen, program))
    codegen_generate_with_types(codegen, program, func_table)

    Note: Close output file to ensure content is written (flushes buffer)
    Let output_file be memory_get_integer(codegen, 0)
    file_close_buffered(output_file)

    Note: Print success message (equivalent to printf("Successfully compiled '%s' to '%s'\n", input_filename, output_filename))
    Let success_msg_temp be string_concat("Successfully compiled '", input_filename)
    Let success_msg_temp2 be string_concat(success_msg_temp, "' to '")
    deallocate(success_msg_temp)
    Let success_msg be string_concat(success_msg_temp2, output_filename)
    deallocate(success_msg_temp2)
    Let success_msg_final be string_concat(success_msg, "'")
    deallocate(success_msg)
    print_string(success_msg_final)
    deallocate(success_msg_final)

    Note: Cleanup resources (equivalent to C cleanup code)
    codegen_destroy(codegen)
    program_destroy(program)
    parser_destroy(parser)
    lexer_destroy(lexer)
    deallocate(source)
    deallocate(input_filename)
    deallocate(output_filename)

    Return 0
End Process