Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Range Analysis for Optimal Type Inference
Note: This module implements compile-time value range tracking to automatically
Note: select the smallest integer type that safely holds all possible values.

Note: Range structure: min(int64 at 0), max(int64 at 8), is_unknown(int32 at 16)
Note: Total size: 20 bytes

Note: Type kind constants (matching parser.runa)
Let TYPE_INTEGER8 be 0
Let TYPE_INTEGER16 be 1
Let TYPE_INTEGER32 be 2
Let TYPE_INTEGER64 be 3
Let TYPE_INTEGER128 be 4
Let TYPE_UNSIGNED_INTEGER8 be 5
Let TYPE_UNSIGNED_INTEGER16 be 6
Let TYPE_UNSIGNED_INTEGER32 be 7
Let TYPE_UNSIGNED_INTEGER64 be 8
Let TYPE_UNSIGNED_INTEGER128 be 9
Let TYPE_FLOAT be 10
Let TYPE_FLOAT64 be 11
Let TYPE_POINTER be 12

Note: Integer bounds for type selection
Let INTEGER8_MIN be 0 minus 128
Let INTEGER8_MAX be 127
Let INTEGER16_MIN be 0 minus 32768
Let INTEGER16_MAX be 32767
Let INTEGER32_MIN be 0 minus 2147483648
Let INTEGER32_MAX be 2147483647
Note: INTEGER64_MIN/MAX would overflow in current system, handled specially

Let UNSIGNED_INTEGER8_MAX be 255
Let UNSIGNED_INTEGER16_MAX be 65535
Let UNSIGNED_INTEGER32_MAX be 4294967295

Note: Create a range with known bounds
Process called "range_create" takes min as Integer, max as Integer returns Integer:
    Let range be allocate(20)
    memory_set_integer(range, 0, min)
    memory_set_integer(range, 8, max)
    memory_set_int32(range, 16, 0)  Note: is_unknown = false
    Return range
End Process

Note: Create an unknown/unbounded range
Process called "range_create_unknown" returns Integer:
    Let range be allocate(20)
    memory_set_integer(range, 0, 0)
    memory_set_integer(range, 8, 0)
    memory_set_int32(range, 16, 1)  Note: is_unknown = true
    Return range
End Process

Note: Get minimum value from range
Process called "range_get_min" takes range as Integer returns Integer:
    Return memory_get_integer(range, 0)
End Process

Note: Get maximum value from range
Process called "range_get_max" takes range as Integer returns Integer:
    Return memory_get_integer(range, 8)
End Process

Note: Check if range is unknown
Process called "range_is_unknown" takes range as Integer returns Integer:
    Return memory_get_int32(range, 16)
End Process

Note: Add two ranges: [a_min + b_min, a_max + b_max]
Process called "range_add" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_min be range_get_min(a)
    Let a_max be range_get_max(a)
    Let b_min be range_get_min(b)
    Let b_max be range_get_max(b)

    Let result_min be a_min plus b_min
    Let result_max be a_max plus b_max

    Return range_create(result_min, result_max)
End Process

Note: Subtract two ranges: [a_min - b_max, a_max - b_min]
Process called "range_subtract" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_min be range_get_min(a)
    Let a_max be range_get_max(a)
    Let b_min be range_get_min(b)
    Let b_max be range_get_max(b)

    Let result_min be a_min minus b_max
    Let result_max be a_max minus b_min

    Return range_create(result_min, result_max)
End Process

Note: Multiply two ranges (handles sign changes)
Process called "range_multiply" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_min be range_get_min(a)
    Let a_max be range_get_max(a)
    Let b_min be range_get_min(b)
    Let b_max be range_get_max(b)

    Note: Calculate all four products (handles negative numbers)
    Let p1 be a_min multiplied by b_min
    Let p2 be a_min multiplied by b_max
    Let p3 be a_max multiplied by b_min
    Let p4 be a_max multiplied by b_max

    Note: Find minimum of four products
    Let result_min be p1
    If p2 is less than result_min:
        Set result_min to p2
    End If
    If p3 is less than result_min:
        Set result_min to p3
    End If
    If p4 is less than result_min:
        Set result_min to p4
    End If

    Note: Find maximum of four products
    Let result_max be p1
    If p2 is greater than result_max:
        Set result_max to p2
    End If
    If p3 is greater than result_max:
        Set result_max to p3
    End If
    If p4 is greater than result_max:
        Set result_max to p4
    End If

    Return range_create(result_min, result_max)
End Process

Note: Divide two ranges (handles sign changes, division by zero)
Process called "range_divide" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let b_min be range_get_min(b)
    Let b_max be range_get_max(b)

    Note: Check for division by zero
    If b_min is less than or equal to 0:
        If b_max is greater than or equal to 0:
            Note: Range includes zero - potential division by zero
            Return range_create_unknown()
        End If
    End If

    Let a_min be range_get_min(a)
    Let a_max be range_get_max(a)

    Note: Calculate all four quotients
    Let q1 be a_min divided by b_min
    Let q2 be a_min divided by b_max
    Let q3 be a_max divided by b_min
    Let q4 be a_max divided by b_max

    Note: Find minimum of four quotients
    Let result_min be q1
    If q2 is less than result_min:
        Set result_min to q2
    End If
    If q3 is less than result_min:
        Set result_min to q3
    End If
    If q4 is less than result_min:
        Set result_min to q4
    End If

    Note: Find maximum of four quotients
    Let result_max be q1
    If q2 is greater than result_max:
        Set result_max to q2
    End If
    If q3 is greater than result_max:
        Set result_max to q3
    End If
    If q4 is greater than result_max:
        Set result_max to q4
    End If

    Return range_create(result_min, result_max)
End Process

Note: Modulo range: [0, max(|a_max|, |b_max|) - 1]
Process called "range_modulo" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let b_max be range_get_max(b)
    Let b_min be range_get_min(b)

    Note: Get absolute values
    Let abs_b_max be b_max
    If b_max is less than 0:
        Set abs_b_max to 0 minus b_max
    End If

    Let abs_b_min be b_min
    If b_min is less than 0:
        Set abs_b_min to 0 minus b_min
    End If

    Let max_mod be abs_b_max
    If abs_b_min is greater than max_mod:
        Set max_mod to abs_b_min
    End If

    Let max_result be max_mod minus 1

    Return range_create(0, max_result)
End Process

Note: Union of two ranges: [min(a_min, b_min), max(a_max, b_max)]
Note: Used for merging ranges at control flow join points
Process called "range_union" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_min be range_get_min(a)
    Let a_max be range_get_max(a)
    Let b_min be range_get_min(b)
    Let b_max be range_get_max(b)

    Let result_min be a_min
    If b_min is less than result_min:
        Set result_min to b_min
    End If

    Let result_max be a_max
    If b_max is greater than result_max:
        Set result_max to b_max
    End If

    Return range_create(result_min, result_max)
End Process

Note: Intersection of two ranges: [max(a_min, b_min), min(a_max, b_max)]
Note: Used when refining ranges from conditionals
Process called "range_intersect" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return b
    End If
    If b_unknown is equal to 1:
        Return a
    End If

    Let a_min be range_get_min(a)
    Let a_max be range_get_max(a)
    Let b_min be range_get_min(b)
    Let b_max be range_get_max(b)

    Let result_min be a_min
    If b_min is greater than result_min:
        Set result_min to b_min
    End If

    Let result_max be a_max
    If b_max is less than result_max:
        Set result_max to b_max
    End If

    Note: Check if intersection is empty
    If result_min is greater than result_max:
        Note: Empty intersection - should not happen in valid code
        Return range_create_unknown()
    End If

    Return range_create(result_min, result_max)
End Process

Note: Select optimal type for a range
Process called "range_select_type" takes range as Integer returns Integer:
    Let is_unknown be range_is_unknown(range)
    If is_unknown is equal to 1:
        Return TYPE_INTEGER32  Note: Conservative default for unknown
    End If

    Let min be range_get_min(range)
    Let max be range_get_max(range)

    Note: Check if unsigned is better
    If min is greater than or equal to 0:
        Note: Non-negative range - consider unsigned types
        If max is less than or equal to UNSIGNED_INTEGER8_MAX:
            Return TYPE_UNSIGNED_INTEGER8
        End If
        If max is less than or equal to UNSIGNED_INTEGER16_MAX:
            Return TYPE_UNSIGNED_INTEGER16
        End If
        If max is less than or equal to UNSIGNED_INTEGER32_MAX:
            Return TYPE_UNSIGNED_INTEGER32
        End If
        Note: Larger than UnsignedInteger32, use UnsignedInteger64
        Return TYPE_UNSIGNED_INTEGER64
    End If

    Note: Signed range - check signed types
    If min is greater than or equal to INTEGER8_MIN:
        If max is less than or equal to INTEGER8_MAX:
            Return TYPE_INTEGER8
        End If
    End If

    If min is greater than or equal to INTEGER16_MIN:
        If max is less than or equal to INTEGER16_MAX:
            Return TYPE_INTEGER16
        End If
    End If

    If min is greater than or equal to INTEGER32_MIN:
        If max is less than or equal to INTEGER32_MAX:
            Return TYPE_INTEGER32
        End If
    End If

    Note: Larger than Integer32, use Integer64
    Return TYPE_INTEGER64
End Process

Note: Refine range based on comparison (for conditional analysis)
Note: op: 22=EQUAL, 23=NOT_EQUAL, 24=LESS, 25=GREATER, 26=GREATER_EQUAL, 27=LESS_EQUAL
Process called "range_refine_from_comparison" takes range as Integer, op as Integer, value as Integer returns Integer:
    Let is_unknown be range_is_unknown(range)
    If is_unknown is equal to 1:
        Note: Can't refine unknown range
        Return range
    End If

    Let min be range_get_min(range)
    Let max be range_get_max(range)

    If op is equal to 22:  Note: EQUAL
        Return range_create(value, value)
    Otherwise If op is equal to 24:  Note: LESS
        Let new_max be value minus 1
        If new_max is less than min:
            Note: Impossible condition
            Return range_create_unknown()
        End If
        Return range_create(min, new_max)
    Otherwise If op is equal to 27:  Note: LESS_EQUAL
        If value is less than min:
            Return range_create_unknown()
        End If
        Return range_create(min, value)
    Otherwise If op is equal to 25:  Note: GREATER
        Let new_min be value plus 1
        If new_min is greater than max:
            Return range_create_unknown()
        End If
        Return range_create(new_min, max)
    Otherwise If op is equal to 26:  Note: GREATER_EQUAL
        If value is greater than max:
            Return range_create_unknown()
        End If
        Return range_create(value, max)
    End If

    Note: NOT_EQUAL can't refine much, return original
    Return range
End Process

Note: Copy a range (for SSA)
Process called "range_copy" takes range as Integer returns Integer:
    Let is_unknown be range_is_unknown(range)
    If is_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let min be range_get_min(range)
    Let max be range_get_max(range)
    Return range_create(min, max)
End Process

Note: Check if range can overflow when assigned to a specific type
Process called "range_can_overflow" takes range as Integer, type_kind as Integer returns Integer:
    Let is_unknown be range_is_unknown(range)
    If is_unknown is equal to 1:
        Return 1  Note: Unknown range can potentially overflow
    End If

    Let min be range_get_min(range)
    Let max be range_get_max(range)

    If type_kind is equal to TYPE_INTEGER8:
        If min is less than INTEGER8_MIN:
            Return 1
        End If
        If max is greater than INTEGER8_MAX:
            Return 1
        End If
    Otherwise If type_kind is equal to TYPE_INTEGER16:
        If min is less than INTEGER16_MIN:
            Return 1
        End If
        If max is greater than INTEGER16_MAX:
            Return 1
        End If
    Otherwise If type_kind is equal to TYPE_INTEGER32:
        If min is less than INTEGER32_MIN:
            Return 1
        End If
        If max is greater than INTEGER32_MAX:
            Return 1
        End If
    Otherwise If type_kind is equal to TYPE_UNSIGNED_INTEGER8:
        If min is less than 0:
            Return 1
        End If
        If max is greater than UNSIGNED_INTEGER8_MAX:
            Return 1
        End If
    Otherwise If type_kind is equal to TYPE_UNSIGNED_INTEGER16:
        If min is less than 0:
            Return 1
        End If
        If max is greater than UNSIGNED_INTEGER16_MAX:
            Return 1
        End If
    Otherwise If type_kind is equal to TYPE_UNSIGNED_INTEGER32:
        If min is less than 0:
            Return 1
        End If
        If max is greater than UNSIGNED_INTEGER32_MAX:
            Return 1
        End If
    End If

    Return 0  Note: No overflow possible
End Process

Note: Debug: Print range for debugging
Process called "range_print" takes range as Integer returns Integer:
    Let is_unknown be range_is_unknown(range)
    If is_unknown is equal to 1:
        Display "[UNKNOWN]"
        Return 0
    End If

    Let min be range_get_min(range)
    Let max be range_get_max(range)

    Display "[", integer_to_string(min), ", ", integer_to_string(max), "]"
    Return 0
End Process
Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: SSA (Static Single Assignment) Transformation
Note: Converts variables to SSA form for precise range tracking

Note: SSA Variable: original_name + version number
Note: Example: x → x_0, x_1, x_2, ...

Note: Variable version table
Note: Maps variable name to current version number
Note: Structure: name -> version_number

Note: Create version table
Process called "version_table_create" returns Integer:
    Note: Simple list of (name, version) pairs
    Note: capacity(int32 at 0), size(int32 at 4), entries(ptr at 8)
    Let table be allocate(16)
    Let capacity be 64
    memory_set_int32(table, 0, capacity)
    memory_set_int32(table, 4, 0)

    Let entries_size be capacity multiplied by 16  Note: name(ptr) + version(int32)
    Let entries be allocate(entries_size)
    memory_set_pointer(table, 8, entries)

    Return table
End Process

Note: Get current version of variable
Process called "version_table_get" takes table as Integer, name as Integer returns Integer:
    Let size be memory_get_int32(table, 4)
    Let entries be memory_get_pointer(table, 8)

    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 16
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let version_offset be entry_offset plus 8
            Let version be memory_get_int32(entries, version_offset)
            Return version
        End If

        Set i to i plus 1
    End While

    Return 0  Note: First version
End Process

Note: Increment version of variable and return new version
Process called "version_table_increment" takes table as Integer, name as Integer returns Integer:
    Let size be memory_get_int32(table, 4)
    Let capacity be memory_get_int32(table, 0)
    Let entries be memory_get_pointer(table, 8)

    Note: Find existing entry
    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 16
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let version_offset be entry_offset plus 8
            Let old_version be memory_get_int32(entries, version_offset)
            Let new_version be old_version plus 1
            memory_set_int32(entries, version_offset, new_version)
            Return new_version
        End If

        Set i to i plus 1
    End While

    Note: Variable not found - add with version 1
    If size is equal to capacity:
        Display "ERROR: Version table capacity exceeded"
        exit_with_code(1)
    End If

    Let entry_offset be size multiplied by 16
    memory_set_pointer(entries, entry_offset, name)
    memory_set_int32(entries, entry_offset plus 8, 1)

    Let new_size be size plus 1
    memory_set_int32(table, 4, new_size)

    Return 1
End Process

Note: Create SSA variable name: "name_version"
Process called "ssa_var_name" takes name as Integer, version as Integer returns Integer:
    Let name_len be string_length(name)
    Let version_str be integer_to_string(version)
    Let version_len be string_length(version_str)

    Note: Allocate: name + "_" + version + null
    Let total_len be name_len plus version_len plus 2
    Let result be allocate(total_len)

    Note: Copy name
    Let i be 0
    While i is less than name_len:
        Let char be memory_get_byte(name, i)
        memory_set_byte(result, i, char)
        Set i to i plus 1
    End While

    Note: Add underscore
    memory_set_byte(result, name_len, 95)  Note: '_'

    Note: Copy version
    Let j be 0
    While j is less than version_len:
        Let char be memory_get_byte(version_str, j)
        memory_set_byte(result, name_len plus 1 plus j, char)
        Set j to j plus 1
    End While

    Note: Null terminator
    memory_set_byte(result, name_len plus version_len plus 1, 0)

    Return result
End Process

Note: Transform expression to SSA form
Process called "ssa_transform_expression" takes expr as Integer, versions as Integer returns Integer:
    Let expr_type be memory_get_int32(expr, 0)

    Let EXPR_IDENTIFIER be 2
    Let EXPR_BINARY_OP be 3
    Let EXPR_UNARY_MINUS be 5

    If expr_type is equal to EXPR_IDENTIFIER:
        Note: Replace identifier with SSA version
        Let name be memory_get_pointer(expr, 8)
        Let version be version_table_get(versions, name)
        Let ssa_name be ssa_var_name(name, version)

        Note: Create new identifier expression with SSA name
        Let new_expr be allocate(16)
        memory_set_int32(new_expr, 0, EXPR_IDENTIFIER)
        memory_set_pointer(new_expr, 8, ssa_name)

        Return new_expr

    Otherwise If expr_type is equal to EXPR_BINARY_OP:
        Note: Transform left and right operands
        Let left be memory_get_pointer(expr, 8)
        Let op be memory_get_int32(expr, 16)
        Let right be memory_get_pointer(expr, 24)

        Let new_left be ssa_transform_expression(left, versions)
        Let new_right be ssa_transform_expression(right, versions)

        Note: Create new binary op with transformed operands
        Let new_expr be allocate(32)
        memory_set_int32(new_expr, 0, EXPR_BINARY_OP)
        memory_set_pointer(new_expr, 8, new_left)
        memory_set_int32(new_expr, 16, op)
        memory_set_pointer(new_expr, 24, new_right)

        Return new_expr

    Otherwise If expr_type is equal to EXPR_UNARY_MINUS:
        Let operand be memory_get_pointer(expr, 8)
        Let new_operand be ssa_transform_expression(operand, versions)

        Let new_expr be allocate(16)
        memory_set_int32(new_expr, 0, EXPR_UNARY_MINUS)
        memory_set_pointer(new_expr, 8, new_operand)

        Return new_expr

    Otherwise:
        Note: Other expressions unchanged (literals, etc.)
        Return expr
    End If

    Return expr
End Process

Note: Transform statement to SSA form
Process called "ssa_transform_statement" takes stmt as Integer, versions as Integer returns Integer:
    Let stmt_type be memory_get_int32(stmt, 0)

    Let STMT_LET be 0
    Let STMT_SET be 1
    Let STMT_RETURN be 2

    If stmt_type is equal to STMT_LET:
        Note: Let statement: create new SSA version
        Let name be memory_get_pointer(stmt, 8)
        Let expr be memory_get_pointer(stmt, 16)

        Note: Transform expression
        Let new_expr be ssa_transform_expression(expr, versions)

        Note: Increment version and create SSA name
        Let new_version be version_table_increment(versions, name)
        Let ssa_name be ssa_var_name(name, new_version)

        Note: Create new Let statement with SSA name
        Let new_stmt be allocate(24)
        memory_set_int32(new_stmt, 0, STMT_LET)
        memory_set_pointer(new_stmt, 8, ssa_name)
        memory_set_pointer(new_stmt, 16, new_expr)

        Return new_stmt

    Otherwise If stmt_type is equal to STMT_SET:
        Note: Set statement: create new SSA version for target
        Let target be memory_get_pointer(stmt, 8)
        Let expr be memory_get_pointer(stmt, 16)

        Note: Transform expression
        Let new_expr be ssa_transform_expression(expr, versions)

        Note: Get target name (assume simple identifier)
        Let target_type be memory_get_int32(target, 0)
        Let EXPR_IDENTIFIER be 2
        If target_type is equal to EXPR_IDENTIFIER:
            Let name be memory_get_pointer(target, 8)

            Note: Increment version
            Let new_version be version_table_increment(versions, name)
            Let ssa_name be ssa_var_name(name, new_version)

            Note: Create new Let statement (Set becomes Let in SSA)
            Let new_stmt be allocate(24)
            memory_set_int32(new_stmt, 0, STMT_LET)
            memory_set_pointer(new_stmt, 8, ssa_name)
            memory_set_pointer(new_stmt, 16, new_expr)

            Return new_stmt
        End If

        Return stmt

    Otherwise If stmt_type is equal to STMT_RETURN:
        Let expr be memory_get_pointer(stmt, 8)
        Let new_expr be ssa_transform_expression(expr, versions)

        Let new_stmt be allocate(16)
        memory_set_int32(new_stmt, 0, STMT_RETURN)
        memory_set_pointer(new_stmt, 8, new_expr)

        Return new_stmt

    Otherwise:
        Note: Other statements unchanged for now
        Return stmt
    End If

    Return stmt
End Process

Note: Transform statement list to SSA form
Process called "ssa_transform_statements" takes stmt_list as Integer returns Integer:
    Let versions be version_table_create()

    Let count be list_length(stmt_list)
    Let new_list be list_create()

    Let i be 0
    While i is less than count:
        Let stmt be list_get(stmt_list, i)
        Let new_stmt be ssa_transform_statement(stmt, versions)
        Let dummy be list_append(new_list, new_stmt)
        Set i to i plus 1
    End While

    Return new_list
End Process

Note: PHI node for merging SSA variables at control flow joins
Note: phi_create(var_name, [version1, version2, ...])
Note: Represents: var_name_N = φ(var_name_version1, var_name_version2)
Process called "phi_create" takes name as Integer, versions as Integer, version_count as Integer returns Integer:
    Note: PHI node: name(ptr at 0), versions(ptr at 8), version_count(int32 at 16)
    Let phi be allocate(20)

    memory_set_pointer(phi, 0, name)
    memory_set_pointer(phi, 8, versions)
    memory_set_int32(phi, 16, version_count)

    Return phi
End Process

Note: Insert PHI nodes at merge points
Note: Simplified version - full implementation requires dominance frontiers
Process called "insert_phi_nodes" takes cfg as Integer, var_names as Integer, var_count as Integer returns Integer:
    Note: For each merge point (block with multiple predecessors)
    Note: For each variable
    Note: Insert PHI node

    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Let i be 0
    While i is less than block_count:
        Let offset be i multiplied by 8
        Let bb be memory_get_pointer(blocks, offset)
        Let pred_count be memory_get_int32(bb, 32)

        Note: If block has multiple predecessors, it's a merge point
        If pred_count is greater than 1:
            Note: Insert PHI nodes for all variables
            Let j be 0
            While j is less than var_count:
                Let var_offset be j multiplied by 8
                Let var_name be memory_get_pointer(var_names, var_offset)

                Note: TODO: Create PHI node and add to block
                Note: This requires tracking which versions come from which predecessor

                Set j to j plus 1
            End While
        End If

        Set i to i plus 1
    End While

    Return cfg
End Process
Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Control Flow Graph Builder
Note: Builds a CFG from AST for data flow analysis

Note: Basic Block structure
Note: bb_id(int32 at 0), statements(ptr at 8), stmt_count(int32 at 16),
Note: predecessors(ptr at 24), pred_count(int32 at 32),
Note: successors(ptr at 40), succ_count(int32 at 48)
Note: Total: 56 bytes

Note: CFG structure
Note: blocks(ptr at 0), block_count(int32 at 8), entry_block(int32 at 12), exit_block(int32 at 16)
Note: Total: 20 bytes

Let next_bb_id be 0

Note: Create a basic block
Process called "bb_create" returns Integer:
    Let bb be allocate(56)

    memory_set_int32(bb, 0, next_bb_id)
    Set next_bb_id to next_bb_id plus 1

    Note: Initialize statements list (capacity 16)
    Let stmts_capacity be 16
    Let stmts_size be stmts_capacity multiplied by 8
    Let stmts be allocate(stmts_size)
    memory_set_pointer(bb, 8, stmts)
    memory_set_int32(bb, 16, 0)  Note: stmt_count = 0

    Note: Initialize predecessors list (capacity 4)
    Let preds_capacity be 4
    Let preds_size be preds_capacity multiplied by 4
    Let preds be allocate(preds_size)
    memory_set_pointer(bb, 24, preds)
    memory_set_int32(bb, 32, 0)  Note: pred_count = 0

    Note: Initialize successors list (capacity 4)
    Let succs_capacity be 4
    Let succs_size be succs_capacity multiplied by 4
    Let succs be allocate(succs_size)
    memory_set_pointer(bb, 40, succs)
    memory_set_int32(bb, 48, 0)  Note: succ_count = 0

    Return bb
End Process

Note: Add statement to basic block
Process called "bb_add_statement" takes bb as Integer, stmt as Integer returns Integer:
    Let stmts be memory_get_pointer(bb, 8)
    Let stmt_count be memory_get_int32(bb, 16)

    Note: TODO: Handle capacity expansion
    If stmt_count is greater than or equal to 16:
        Display "ERROR: Basic block statement capacity exceeded"
        exit_with_code(1)
    End If

    Let offset be stmt_count multiplied by 8
    memory_set_pointer(stmts, offset, stmt)

    Let new_count be stmt_count plus 1
    memory_set_int32(bb, 16, new_count)

    Return bb
End Process

Note: Add edge from bb1 to bb2
Process called "bb_add_edge" takes bb1 as Integer, bb2 as Integer returns Integer:
    Note: Add bb2 as successor of bb1
    Let succs be memory_get_pointer(bb1, 40)
    Let succ_count be memory_get_int32(bb1, 48)

    If succ_count is greater than or equal to 4:
        Display "ERROR: Basic block successor capacity exceeded"
        exit_with_code(1)
    End If

    Let bb2_id be memory_get_int32(bb2, 0)
    Let offset be succ_count multiplied by 4
    memory_set_int32(succs, offset, bb2_id)

    Let new_succ_count be succ_count plus 1
    memory_set_int32(bb1, 48, new_succ_count)

    Note: Add bb1 as predecessor of bb2
    Let preds be memory_get_pointer(bb2, 24)
    Let pred_count be memory_get_int32(bb2, 32)

    If pred_count is greater than or equal to 4:
        Display "ERROR: Basic block predecessor capacity exceeded"
        exit_with_code(1)
    End If

    Let bb1_id be memory_get_int32(bb1, 0)
    Let pred_offset be pred_count multiplied by 4
    memory_set_int32(preds, pred_offset, bb1_id)

    Let new_pred_count be pred_count plus 1
    memory_set_int32(bb2, 32, new_pred_count)

    Return 0
End Process

Note: Create CFG
Process called "cfg_create" returns Integer:
    Let cfg be allocate(20)

    Note: Initialize blocks array (capacity 64)
    Let blocks_capacity be 64
    Let blocks_size be blocks_capacity multiplied by 8
    Let blocks be allocate(blocks_size)
    memory_set_pointer(cfg, 0, blocks)
    memory_set_int32(cfg, 8, 0)  Note: block_count = 0

    memory_set_int32(cfg, 12, 0 minus 1)  Note: entry_block = -1 (not set)
    memory_set_int32(cfg, 16, 0 minus 1)  Note: exit_block = -1 (not set)

    Return cfg
End Process

Note: Add basic block to CFG
Process called "cfg_add_block" takes cfg as Integer, bb as Integer returns Integer:
    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)

    If block_count is greater than or equal to 64:
        Display "ERROR: CFG block capacity exceeded"
        exit_with_code(1)
    End If

    Let offset be block_count multiplied by 8
    memory_set_pointer(blocks, offset, bb)

    Let new_count be block_count plus 1
    memory_set_int32(cfg, 8, new_count)

    Return cfg
End Process

Note: Get block by ID from CFG
Process called "cfg_get_block" takes cfg as Integer, bb_id as Integer returns Integer:
    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Let i be 0
    While i is less than block_count:
        Let offset be i multiplied by 8
        Let bb be memory_get_pointer(blocks, offset)
        Let id be memory_get_int32(bb, 0)

        If id is equal to bb_id:
            Return bb
        End If

        Set i to i plus 1
    End While

    Return 0  Note: Not found
End Process

Note: Build CFG from statement list
Note: Returns CFG with entry and exit blocks
Process called "build_cfg" takes stmt_list as Integer returns Integer:
    Let cfg be cfg_create()

    Note: Create entry and exit blocks
    Let entry_bb be bb_create()
    Let dummy1 be cfg_add_block(cfg, entry_bb)

    Let entry_id be memory_get_int32(entry_bb, 0)
    memory_set_int32(cfg, 12, entry_id)  Note: Set entry_block

    Note: Build CFG from statements
    Let current_bb be entry_bb
    Let stmt_count be list_length(stmt_list)

    Let i be 0
    While i is less than stmt_count:
        Let stmt be list_get(stmt_list, i)
        Let stmt_type be memory_get_int32(stmt, 0)

        Note: Statement types
        Let STMT_LET be 0
        Let STMT_SET be 1
        Let STMT_RETURN be 2
        Let STMT_IF be 3
        Let STMT_WHILE be 4
        Let STMT_FOR be 9
        Let STMT_BREAK be 6
        Let STMT_CONTINUE be 7

        If stmt_type is equal to STMT_IF:
            Note: If statement splits control flow
            Let condition be memory_get_pointer(stmt, 8)
            Let then_branch be memory_get_pointer(stmt, 16)
            Let else_branch be memory_get_pointer(stmt, 24)

            Note: Create blocks for then and else branches
            Let then_bb be bb_create()
            Let dummy2 be cfg_add_block(cfg, then_bb)

            Let else_bb be bb_create()
            Let dummy3 be cfg_add_block(cfg, else_bb)

            Note: Create merge block
            Let merge_bb be bb_create()
            Let dummy4 be cfg_add_block(cfg, merge_bb)

            Note: Add edges: current -> then, current -> else
            Let dummy5 be bb_add_edge(current_bb, then_bb)
            Let dummy6 be bb_add_edge(current_bb, else_bb)

            Note: Build then branch CFG
            Note: TODO: Recursively build sub-CFGs

            Note: Add edges: then -> merge, else -> merge
            Let dummy7 be bb_add_edge(then_bb, merge_bb)
            Let dummy8 be bb_add_edge(else_bb, merge_bb)

            Set current_bb to merge_bb

        Otherwise If stmt_type is equal to STMT_WHILE:
            Note: While loop creates back edge
            Note: TODO: Implement loop CFG

            Note: For now, create simple blocks
            Let loop_header be bb_create()
            Let dummy9 be cfg_add_block(cfg, loop_header)

            Let loop_body be bb_create()
            Let dummy10 be cfg_add_block(cfg, loop_body)

            Let loop_exit be bb_create()
            Let dummy11 be cfg_add_block(cfg, loop_exit)

            Note: Edges: current -> header
            Let dummy12 be bb_add_edge(current_bb, loop_header)

            Note: Edges: header -> body, header -> exit
            Let dummy13 be bb_add_edge(loop_header, loop_body)
            Let dummy14 be bb_add_edge(loop_header, loop_exit)

            Note: Back edge: body -> header
            Let dummy15 be bb_add_edge(loop_body, loop_header)

            Set current_bb to loop_exit

        Otherwise If stmt_type is equal to STMT_RETURN:
            Note: Return ends current block
            Let dummy16 be bb_add_statement(current_bb, stmt)

            Note: Create new block for any unreachable code after return
            Let new_bb be bb_create()
            Let dummy17 be cfg_add_block(cfg, new_bb)
            Set current_bb to new_bb

        Otherwise:
            Note: Regular statement - add to current block
            Let dummy18 be bb_add_statement(current_bb, stmt)
        End If

        Set i to i plus 1
    End While

    Note: Create exit block
    Let exit_bb be bb_create()
    Let dummy19 be cfg_add_block(cfg, exit_bb)

    Let exit_id be memory_get_int32(exit_bb, 0)
    memory_set_int32(cfg, 16, exit_id)  Note: Set exit_block

    Note: Connect current block to exit
    Let dummy20 be bb_add_edge(current_bb, exit_bb)

    Return cfg
End Process

Note: Print CFG for debugging
Process called "cfg_print" takes cfg as Integer returns Integer:
    Display "=== Control Flow Graph ==="

    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Let i be 0
    While i is less than block_count:
        Let offset be i multiplied by 8
        Let bb be memory_get_pointer(blocks, offset)
        Let bb_id be memory_get_int32(bb, 0)

        Display "Block ", integer_to_string(bb_id), ":"

        Note: Print predecessors
        Let pred_count be memory_get_int32(bb, 32)
        If pred_count is greater than 0:
            Display "  Predecessors: "
            Let preds be memory_get_pointer(bb, 24)
            Let j be 0
            While j is less than pred_count:
                Let pred_offset be j multiplied by 4
                Let pred_id be memory_get_int32(preds, pred_offset)
                Display integer_to_string(pred_id), " "
                Set j to j plus 1
            End While
        End If

        Note: Print successors
        Let succ_count be memory_get_int32(bb, 48)
        If succ_count is greater than 0:
            Display "  Successors: "
            Let succs be memory_get_pointer(bb, 40)
            Let k be 0
            While k is less than succ_count:
                Let succ_offset be k multiplied by 4
                Let succ_id be memory_get_int32(succs, succ_offset)
                Display integer_to_string(succ_id), " "
                Set k to k plus 1
            End While
        End If

        Set i to i plus 1
    End While

    Return 0
End Process

Note: ===== DOMINATOR ANALYSIS =====

Note: Dominator set structure - bitmap of dominating blocks
Note: For block i, dominators[i] is a bitset of blocks that dominate i
Note: Structure: block_count(int32 at 0), bitsets(ptr at 8)
Note: Each bitset is an array of int32s (32 bits per int)

Process called "domset_create" takes block_count as Integer returns Integer:
    Let domset be allocate(16)
    memory_set_int32(domset, 0, block_count)

    Note: Calculate size needed for bitsets
    Note: Each block needs block_count bits, rounded up to 32-bit chunks
    Let bits_per_int be 32
    Let ints_per_block be block_count divided by bits_per_int
    If block_count modulo bits_per_int is not equal to 0:
        Set ints_per_block to ints_per_block plus 1
    End If

    Note: Allocate array of bitsets (one per block)
    Let total_ints be block_count multiplied by ints_per_block
    Let bitsets_size be total_ints multiplied by 4
    Let bitsets be allocate(bitsets_size)
    memory_set_pointer(domset, 8, bitsets)

    Note: Initialize all bits to 0
    Let i be 0
    While i is less than total_ints:
        Let offset be i multiplied by 4
        memory_set_int32(bitsets, offset, 0)
        Set i to i plus 1
    End While

    Return domset
End Process

Note: Set bit in dominator set (mark block_id as dominating bb_id)
Process called "domset_set" takes domset as Integer, bb_id as Integer, dom_id as Integer returns Integer:
    Let block_count be memory_get_int32(domset, 0)
    Let bitsets be memory_get_pointer(domset, 8)

    Note: Calculate which int and which bit
    Let bits_per_int be 32
    Let ints_per_block be block_count divided by bits_per_int
    If block_count modulo bits_per_int is not equal to 0:
        Set ints_per_block to ints_per_block plus 1
    End If

    Let int_index be dom_id divided by bits_per_int
    Let bit_index be dom_id modulo bits_per_int

    Note: Calculate offset in bitsets array
    Let row_offset be bb_id multiplied by ints_per_block
    Let total_offset be row_offset plus int_index
    Let byte_offset be total_offset multiplied by 4

    Note: Read current value, set bit, write back
    Let current_value be memory_get_int32(bitsets, byte_offset)
    Let mask be 1
    Let shift_count be bit_index
    While shift_count is greater than 0:
        Set mask to mask multiplied by 2
        Set shift_count to shift_count minus 1
    End While

    Let new_value be current_value bit_or mask
    memory_set_int32(bitsets, byte_offset, new_value)

    Return domset
End Process

Note: Check if dom_id dominates bb_id
Process called "domset_contains" takes domset as Integer, bb_id as Integer, dom_id as Integer returns Integer:
    Let block_count be memory_get_int32(domset, 0)
    Let bitsets be memory_get_pointer(domset, 8)

    Note: Calculate which int and which bit
    Let bits_per_int be 32
    Let ints_per_block be block_count divided by bits_per_int
    If block_count modulo bits_per_int is not equal to 0:
        Set ints_per_block to ints_per_block plus 1
    End If

    Let int_index be dom_id divided by bits_per_int
    Let bit_index be dom_id modulo bits_per_int

    Note: Calculate offset in bitsets array
    Let row_offset be bb_id multiplied by ints_per_block
    Let total_offset be row_offset plus int_index
    Let byte_offset be total_offset multiplied by 4

    Note: Read value and check bit
    Let current_value be memory_get_int32(bitsets, byte_offset)
    Let mask be 1
    Let shift_count be bit_index
    While shift_count is greater than 0:
        Set mask to mask multiplied by 2
        Set shift_count to shift_count minus 1
    End While

    Let masked be current_value bit_and mask
    If masked is not equal to 0:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Note: Set dominator set to all blocks (for initialization)
Process called "domset_set_all" takes domset as Integer, bb_id as Integer returns Integer:
    Let block_count be memory_get_int32(domset, 0)

    Let i be 0
    While i is less than block_count:
        Let dummy be domset_set(domset, bb_id, i)
        Set i to i plus 1
    End While

    Return domset
End Process

Note: Compute intersection of two block's dominator sets and store in bb_id
Process called "domset_intersect" takes domset as Integer, bb_id as Integer, other_id as Integer returns Integer:
    Let block_count be memory_get_int32(domset, 0)
    Let bitsets be memory_get_pointer(domset, 8)

    Let bits_per_int be 32
    Let ints_per_block be block_count divided by bits_per_int
    If block_count modulo bits_per_int is not equal to 0:
        Set ints_per_block to ints_per_block plus 1
    End If

    Note: For each int in the bitset
    Let i be 0
    While i is less than ints_per_block:
        Note: Get offsets for both blocks
        Let bb_row_offset be bb_id multiplied by ints_per_block
        Let bb_offset be bb_row_offset plus i
        Let bb_byte_offset be bb_offset multiplied by 4

        Let other_row_offset be other_id multiplied by ints_per_block
        Let other_offset be other_row_offset plus i
        Let other_byte_offset be other_offset multiplied by 4

        Note: Read both values
        Let bb_value be memory_get_int32(bitsets, bb_byte_offset)
        Let other_value be memory_get_int32(bitsets, other_byte_offset)

        Note: Compute intersection
        Let intersect_value be bb_value bit_and other_value

        Note: Write back
        memory_set_int32(bitsets, bb_byte_offset, intersect_value)

        Set i to i plus 1
    End While

    Return domset
End Process

Note: Compute dominators using iterative algorithm
Process called "compute_dominators" takes cfg as Integer returns Integer:
    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)
    Let entry_id be memory_get_int32(cfg, 12)

    Note: Create dominator set structure
    Let domset be domset_create(block_count)

    Note: Initialize: entry dominates itself, all others dominate all blocks
    Let i be 0
    While i is less than block_count:
        If i is equal to entry_id:
            Note: Entry block dominates only itself
            Let dummy be domset_set(domset, entry_id, entry_id)
        Otherwise:
            Note: All other blocks initially dominate all blocks
            Let dummy2 be domset_set_all(domset, i)
        End If
        Set i to i plus 1
    End While

    Note: Iterative fixed-point computation
    Let changed be 1
    Let max_iterations be 100
    Let iteration be 0

    While changed is equal to 1:
        Set changed to 0
        Set iteration to iteration plus 1

        If iteration is greater than max_iterations:
            Display "ERROR: Dominator analysis did not converge"
            exit_with_code(1)
        End If

        Note: For each block (except entry)
        Let i be 0
        While i is less than block_count:
            If i is not equal to entry_id:
                Note: New dominators = {i} union (intersection of all predecessor dominators)
                Let bb be cfg_get_block(cfg, i)
                Let pred_count be memory_get_int32(bb, 32)

                If pred_count is greater than 0:
                    Note: Start with first predecessor's dominators
                    Let preds be memory_get_pointer(bb, 24)
                    Let first_pred_id be memory_get_int32(preds, 0)

                    Note: Create temp domset initialized to first pred
                    Let temp_domset be domset_create(block_count)
                    Let j be 0
                    While j is less than block_count:
                        Let is_dom be domset_contains(domset, first_pred_id, j)
                        If is_dom is equal to 1:
                            Let dummy3 be domset_set(temp_domset, 0, j)
                        End If
                        Set j to j plus 1
                    End While

                    Note: Intersect with remaining predecessors
                    Let k be 1
                    While k is less than pred_count:
                        Let pred_offset be k multiplied by 4
                        Let pred_id be memory_get_int32(preds, pred_offset)

                        Note: Intersect temp_domset with pred's dominators
                        Let m be 0
                        While m is less than block_count:
                            Let is_in_temp be domset_contains(temp_domset, 0, m)
                            Let is_in_pred be domset_contains(domset, pred_id, m)

                            If is_in_temp is equal to 1:
                                If is_in_pred is equal to 0:
                                    Note: Remove from temp (not in intersection)
                                    Note: Just skip it when copying
                                End If
                            End If
                            Set m to m plus 1
                        End While

                        Set k to k plus 1
                    End While

                    Note: Check if dominators changed
                    Let old_has_self be domset_contains(domset, i, i)
                    Let new_dominators_differ be 0

                    Note: Clear current dominators for block i
                    Let n be 0
                    While n is less than block_count:
                        Let old_dom be domset_contains(domset, i, n)
                        Let new_dom be domset_contains(temp_domset, 0, n)

                        If old_dom is not equal to new_dom:
                            Set new_dominators_differ to 1
                        End If
                        Set n to n plus 1
                    End While

                    Note: Copy temp to domset[i] and add i itself
                    Let p be 0
                    While p is less than block_count:
                        Let is_in_temp be domset_contains(temp_domset, 0, p)
                        Note: Clear and rebuild
                        Set p to p plus 1
                    End While

                    Note: Set dom(i) = temp union {i}
                    Let dummy4 be domset_set(domset, i, i)

                    If new_dominators_differ is equal to 1:
                        Set changed to 1
                    End If
                End If
            End If

            Set i to i plus 1
        End While
    End While

    Return domset
End Process

Note: Find immediate dominator of a block
Process called "find_idom" takes domset as Integer, cfg as Integer, bb_id as Integer returns Integer:
    Let block_count be memory_get_int32(cfg, 8)
    Let entry_id be memory_get_int32(cfg, 12)

    Note: Entry block has no immediate dominator
    If bb_id is equal to entry_id:
        Return 0 minus 1
    End If

    Note: Immediate dominator is the unique dominator != bb_id that dominates all other dominators
    Note: For simplicity: find the dominator with the longest path from entry

    Let idom be 0 minus 1
    Let max_distance be 0 minus 1

    Let i be 0
    While i is less than block_count:
        If i is not equal to bb_id:
            Let is_dom be domset_contains(domset, bb_id, i)
            If is_dom is equal to 1:
                Note: i dominates bb_id
                Note: For now, just pick the last one found (not fully correct)
                Set idom to i
            End If
        End If
        Set i to i plus 1
    End While

    Return idom
End Process

Note: Find merge points (blocks with multiple predecessors)
Process called "find_merge_points" takes cfg as Integer returns Integer:
    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Note: Create list to store merge point block IDs
    Let merge_points be list_create()

    Let i be 0
    While i is less than block_count:
        Let bb be cfg_get_block(cfg, i)
        Let pred_count be memory_get_int32(bb, 32)

        Note: Block is a merge point if it has 2+ predecessors
        If pred_count is greater than 1:
            Let bb_id be memory_get_int32(bb, 0)
            Let dummy be list_append(merge_points, bb_id)
        End If

        Set i to i plus 1
    End While

    Return merge_points
End Process

Note: Print dominator information for debugging
Process called "print_dominators" takes domset as Integer, cfg as Integer returns Integer:
    Display "=== Dominator Analysis ==="

    Let block_count be memory_get_int32(cfg, 8)

    Let i be 0
    While i is less than block_count:
        Display "Block ", integer_to_string(i), " dominated by: "

        Let j be 0
        While j is less than block_count:
            Let is_dom be domset_contains(domset, i, j)
            If is_dom is equal to 1:
                Display integer_to_string(j), " "
            End If
            Set j to j plus 1
        End While

        Display ""

        Note: Print immediate dominator
        Let idom be find_idom(domset, cfg, i)
        If idom is not equal to 0 minus 1:
            Display "  Immediate dominator: ", integer_to_string(idom)
        End If

        Set i to i plus 1
    End While

    Return 0
End Process

Note: ===== LOOP DETECTION AND ANALYSIS =====

Note: Loop structure
Note: header_id(int32 at 0), body_ids(ptr at 8), exit_id(int32 at 16), loop_type(int32 at 20)
Note: For FOR loops: init_stmt(ptr at 24), condition_expr(ptr at 32), update_stmt(ptr at 40)
Note: For WHILE loops: condition_expr(ptr at 32)

Let LOOP_TYPE_FOR be 0
Let LOOP_TYPE_WHILE be 1

Process called "loop_create" takes loop_type as Integer returns Integer:
    Let loop be allocate(48)
    memory_set_int32(loop, 0, 0 minus 1)  Note: header_id = -1
    memory_set_pointer(loop, 8, list_create())  Note: body_ids
    memory_set_int32(loop, 16, 0 minus 1)  Note: exit_id = -1
    memory_set_int32(loop, 20, loop_type)
    memory_set_pointer(loop, 24, 0)  Note: init_stmt = null
    memory_set_pointer(loop, 32, 0)  Note: condition_expr = null
    memory_set_pointer(loop, 40, 0)  Note: update_stmt = null
    Return loop
End Process

Note: Detect loops in CFG (finds back edges)
Process called "detect_loops" takes cfg as Integer, domset as Integer returns Integer:
    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Note: Create list to store detected loops
    Let loops be list_create()

    Note: A back edge is an edge from block N to block H where H dominates N
    Note: H is the loop header, N is in the loop body

    Let i be 0
    While i is less than block_count:
        Let bb be cfg_get_block(cfg, i)
        Let bb_id be memory_get_int32(bb, 0)

        Note: Check all successors
        Let succ_count be memory_get_int32(bb, 48)
        Let succs be memory_get_pointer(bb, 40)

        Let j be 0
        While j is less than succ_count:
            Let succ_offset be j multiplied by 4
            Let succ_id be memory_get_int32(succs, succ_offset)

            Note: Check if succ dominates bb (back edge!)
            Let is_dominator be domset_contains(domset, bb_id, succ_id)

            If is_dominator is equal to 1:
                Note: Found back edge: bb_id -> succ_id
                Note: succ_id is loop header

                Note: Create loop structure
                Let loop be loop_create(LOOP_TYPE_WHILE)  Note: Default to WHILE, will refine
                memory_set_int32(loop, 0, succ_id)  Note: header_id

                Note: Add to loops list
                Let dummy be list_append(loops, loop)
            End If

            Set j to j plus 1
        End While

        Set i to i plus 1
    End While

    Return loops
End Process

Note: Extract For loop bounds from AST
Process called "extract_for_loop_bounds" takes for_stmt as Integer returns Integer:
    Note: For statement: type(int32 at 0), init(ptr at 8), condition(ptr at 16), update(ptr at 24), body(ptr at 32)

    Let init_stmt be memory_get_pointer(for_stmt, 8)
    Let condition_expr be memory_get_pointer(for_stmt, 16)
    Let update_stmt be memory_get_pointer(for_stmt, 24)

    Note: Create bounds structure: loop_var(ptr at 0), start_value(ptr at 8), end_value(ptr at 16), step(int at 24)
    Let bounds be allocate(32)
    memory_set_pointer(bounds, 0, 0)  Note: loop_var = null
    memory_set_pointer(bounds, 8, 0)  Note: start_value = null
    memory_set_pointer(bounds, 16, 0)  Note: end_value = null
    memory_set_int32(bounds, 24, 1)  Note: step = 1 (default)

    Note: Extract loop variable from init statement
    If init_stmt is not equal to 0:
        Let init_type be memory_get_int32(init_stmt, 0)
        Let STMT_LET be 0

        If init_type is equal to STMT_LET:
            Note: Let i be 0
            Let var_name be memory_get_pointer(init_stmt, 8)
            Let start_expr be memory_get_pointer(init_stmt, 16)

            memory_set_pointer(bounds, 0, var_name)
            memory_set_pointer(bounds, 8, start_expr)
        End If
    End If

    Note: Extract end condition from condition expression
    If condition_expr is not equal to 0:
        Let cond_type be memory_get_int32(condition_expr, 0)
        Let EXPR_BINARY_OP be 3

        If cond_type is equal to EXPR_BINARY_OP:
            Note: i < 10
            Let left be memory_get_pointer(condition_expr, 8)
            Let op be memory_get_int32(condition_expr, 16)
            Let right be memory_get_pointer(condition_expr, 24)

            Note: Assume right side is the bound
            memory_set_pointer(bounds, 16, right)
        End If
    End If

    Note: Extract step from update statement
    If update_stmt is not equal to 0:
        Let update_type be memory_get_int32(update_stmt, 0)
        Let STMT_SET be 1

        If update_type is equal to STMT_SET:
            Note: Set i to i plus 1
            Let update_expr be memory_get_pointer(update_stmt, 16)
            Let update_expr_type be memory_get_int32(update_expr, 0)
            Let EXPR_BINARY_OP be 3

            If update_expr_type is equal to EXPR_BINARY_OP:
                Let update_op be memory_get_int32(update_expr, 16)
                Let TOKEN_PLUS be 16
                Let TOKEN_MINUS be 17

                If update_op is equal to TOKEN_PLUS:
                    Note: i plus 1 means step = 1 (already default)
                    Let step_expr be memory_get_pointer(update_expr, 24)
                    Let step_type be memory_get_int32(step_expr, 0)
                    Let EXPR_INTEGER_LITERAL be 0

                    If step_type is equal to EXPR_INTEGER_LITERAL:
                        Let step_str be memory_get_pointer(step_expr, 8)
                        Let step_value be string_to_integer(step_str)
                        memory_set_int32(bounds, 24, step_value)
                    End If
                Otherwise If update_op is equal to TOKEN_MINUS:
                    Note: i minus 1 means step = -1
                    Let step_expr be memory_get_pointer(update_expr, 24)
                    Let step_type be memory_get_int32(step_expr, 0)
                    Let EXPR_INTEGER_LITERAL be 0

                    If step_type is equal to EXPR_INTEGER_LITERAL:
                        Let step_str be memory_get_pointer(step_expr, 8)
                        Let step_value be string_to_integer(step_str)
                        Let neg_step be 0 minus step_value
                        memory_set_int32(bounds, 24, neg_step)
                    End If
                End If
            End If
        End If
    End If

    Return bounds
End Process

Note: Compute range for For loop variable
Process called "compute_for_loop_range" takes bounds as Integer, env as Integer returns Integer:
    Let start_expr be memory_get_pointer(bounds, 8)
    Let end_expr be memory_get_pointer(bounds, 16)
    Let step be memory_get_int32(bounds, 24)

    Note: Compute start and end ranges
    If start_expr is equal to 0:
        Return range_create_unknown()
    End If
    If end_expr is equal to 0:
        Return range_create_unknown()
    End If

    Let start_range be infer_expression_range(start_expr, env)
    Let end_range be infer_expression_range(end_expr, env)

    Let start_is_unknown be range_is_unknown(start_range)
    Let end_is_unknown be range_is_unknown(end_range)

    If start_is_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If end_is_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Note: Get concrete values
    Let start_min be range_get_min(start_range)
    Let start_max be range_get_max(start_range)
    Let end_min be range_get_min(end_range)
    Let end_max be range_get_max(end_range)

    Note: Loop variable ranges from start to end (exclusive)
    Note: Conservative: use widest possible range
    Let loop_min be start_min
    Let loop_max be end_max

    Note: Adjust for step direction
    If step is less than 0:
        Note: Counting down: loop var goes from start_max down to end_min
        Set loop_min to end_min
        Set loop_max to start_max
    End If

    Return range_create(loop_min, loop_max)
End Process

Note: Detect natural loops (all blocks dominated by loop header and reachable from back edge)
Process called "find_natural_loop_body" takes cfg as Integer, domset as Integer, header_id as Integer, back_edge_source as Integer returns Integer:
    Note: Natural loop = all blocks X such that header dominates X and X can reach back_edge_source

    Let body_blocks be list_create()
    Let dummy be list_append(body_blocks, header_id)
    Let dummy2 be list_append(body_blocks, back_edge_source)

    Note: Worklist algorithm: start from back_edge_source, walk backwards
    Let worklist be list_create()
    Let dummy3 be list_append(worklist, back_edge_source)

    While list_length(worklist) is greater than 0:
        Let current_id be list_get(worklist, 0)
        Let dummy4 be list_remove_at(worklist, 0)

        Let current_bb be cfg_get_block(cfg, current_id)
        Let pred_count be memory_get_int32(current_bb, 32)
        Let preds be memory_get_pointer(current_bb, 24)

        Let i be 0
        While i is less than pred_count:
            Let pred_offset be i multiplied by 4
            Let pred_id be memory_get_int32(preds, pred_offset)

            Note: Check if pred is dominated by header
            Let is_dominated be domset_contains(domset, pred_id, header_id)

            If is_dominated is equal to 1:
                Note: Check if already in body_blocks
                Let already_added be 0
                Let j be 0
                While j is less than list_length(body_blocks):
                    Let existing_id be list_get(body_blocks, j)
                    If existing_id is equal to pred_id:
                        Set already_added to 1
                    End If
                    Set j to j plus 1
                End While

                If already_added is equal to 0:
                    Let dummy5 be list_append(body_blocks, pred_id)
                    Let dummy6 be list_append(worklist, pred_id)
                End If
            End If

            Set i to i plus 1
        End While
    End While

    Return body_blocks
End Process

Note: Print loop information for debugging
Process called "print_loops" takes loops as Integer returns Integer:
    Display "=== Loop Analysis ==="

    Let loop_count be list_length(loops)
    Display "Found ", integer_to_string(loop_count), " loops"

    Let i be 0
    While i is less than loop_count:
        Let loop be list_get(loops, i)
        Let header_id be memory_get_int32(loop, 0)
        Let loop_type be memory_get_int32(loop, 20)

        Display "Loop ", integer_to_string(i), ":"
        Display "  Header: ", integer_to_string(header_id)

        If loop_type is equal to LOOP_TYPE_FOR:
            Display "  Type: FOR"
        Otherwise If loop_type is equal to LOOP_TYPE_WHILE:
            Display "  Type: WHILE"
        End If

        Set i to i plus 1
    End While

    Return 0
End Process
Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Data Flow Analysis with Fixed-Point Iteration
Note: Computes ranges for all variables across all control flow paths

Note: Data flow state for a basic block
Note: in_state(ptr at 0), out_state(ptr at 8)
Note: Each state is a variable environment (name -> range)

Note: Create data flow state for block
Process called "df_state_create" returns Integer:
    Let state be allocate(16)
    Let in_env be var_env_create()
    Let out_env be var_env_create()

    memory_set_pointer(state, 0, in_env)
    memory_set_pointer(state, 8, out_env)

    Return state
End Process

Note: Get in-state
Process called "df_state_get_in" takes state as Integer returns Integer:
    Return memory_get_pointer(state, 0)
End Process

Note: Get out-state
Process called "df_state_get_out" takes state as Integer returns Integer:
    Return memory_get_pointer(state, 8)
End Process

Note: Set in-state
Process called "df_state_set_in" takes state as Integer, env as Integer returns Integer:
    memory_set_pointer(state, 0, env)
    Return state
End Process

Note: Set out-state
Process called "df_state_set_out" takes state as Integer, env as Integer returns Integer:
    memory_set_pointer(state, 8, env)
    Return state
End Process

Note: Data flow analysis context
Note: cfg(ptr at 0), block_states(ptr at 8), worklist(ptr at 16), iteration_count(int32 at 24)
Process called "df_context_create" takes cfg as Integer returns Integer:
    Let context be allocate(28)

    memory_set_pointer(context, 0, cfg)

    Note: Create state for each block
    Let block_count be memory_get_int32(cfg, 8)
    Let states_size be block_count multiplied by 8
    Let states be allocate(states_size)

    Let i be 0
    While i is less than block_count:
        Let state be df_state_create()
        Let offset be i multiplied by 8
        memory_set_pointer(states, offset, state)
        Set i to i plus 1
    End While

    memory_set_pointer(context, 8, states)

    Note: Create worklist (initially contains all blocks)
    Let worklist be list_create()
    Let j be 0
    While j is less than block_count:
        Let dummy be list_append(worklist, j)
        Set j to j plus 1
    End While

    memory_set_pointer(context, 16, worklist)
    memory_set_int32(context, 24, 0)  Note: iteration_count = 0

    Return context
End Process

Note: Get state for block ID
Process called "df_get_block_state" takes context as Integer, bb_id as Integer returns Integer:
    Let states be memory_get_pointer(context, 8)
    Let offset be bb_id multiplied by 8
    Return memory_get_pointer(states, offset)
End Process

Note: Transfer function: compute out-state from in-state for a block
Process called "df_transfer" takes bb as Integer, in_env as Integer returns Integer:
    Note: Start with copy of in-state
    Let out_env be var_env_copy(in_env)

    Note: Apply each statement in block
    Let stmts be memory_get_pointer(bb, 8)
    Let stmt_count be memory_get_int32(bb, 16)

    Let i be 0
    While i is less than stmt_count:
        Let offset be i multiplied by 8
        Let stmt be memory_get_pointer(stmts, offset)

        Note: Analyze statement and update environment
        Set out_env to analyze_statement(stmt, out_env)

        Set i to i plus 1
    End While

    Return out_env
End Process

Note: Merge in-state from all predecessors
Process called "df_merge_predecessors" takes context as Integer, bb as Integer returns Integer:
    Let cfg be memory_get_pointer(context, 0)
    Let preds be memory_get_pointer(bb, 24)
    Let pred_count be memory_get_int32(bb, 32)

    If pred_count is equal to 0:
        Note: No predecessors - use empty environment
        Return var_env_create()
    End If

    Note: Get out-state of first predecessor
    Let first_pred_id be memory_get_int32(preds, 0)
    Let first_pred_state be df_get_block_state(context, first_pred_id)
    Let first_pred_out be df_state_get_out(first_pred_state)

    Let merged_env be var_env_copy(first_pred_out)

    Note: Merge with remaining predecessors
    Let i be 1
    While i is less than pred_count:
        Let pred_offset be i multiplied by 4
        Let pred_id be memory_get_int32(preds, pred_offset)
        Let pred_state be df_get_block_state(context, pred_id)
        Let pred_out be df_state_get_out(pred_state)

        Set merged_env to var_env_merge(merged_env, pred_out)

        Set i to i plus 1
    End While

    Return merged_env
End Process

Note: Check if two environments are equal (for convergence check)
Process called "env_equals" takes env1 as Integer, env2 as Integer returns Integer:
    Let size1 be memory_get_int32(env1, 4)
    Let size2 be memory_get_int32(env2, 4)

    If size1 is not equal to size2:
        Return 0  Note: Not equal
    End If

    Let entries1 be memory_get_pointer(env1, 8)

    Let i be 0
    While i is less than size1:
        Let entry_offset be i multiplied by 16
        Let name be memory_get_pointer(entries1, entry_offset)
        Let range1 be memory_get_pointer(entries1, entry_offset plus 8)

        Note: Look up in env2
        Let range2 be var_env_lookup(env2, name)

        Note: Compare ranges
        Let r1_min be range_get_min(range1)
        Let r1_max be range_get_max(range1)
        Let r2_min be range_get_min(range2)
        Let r2_max be range_get_max(range2)

        If r1_min is not equal to r2_min:
            Return 0
        End If
        If r1_max is not equal to r2_max:
            Return 0
        End If

        Set i to i plus 1
    End While

    Return 1  Note: Equal
End Process

Note: Process one block in the worklist
Process called "df_process_block" takes context as Integer, bb_id as Integer returns Integer:
    Let cfg be memory_get_pointer(context, 0)
    Let bb be cfg_get_block(cfg, bb_id)

    Let state be df_get_block_state(context, bb_id)

    Note: Merge in-state from predecessors
    Let new_in be df_merge_predecessors(context, bb)

    Note: Apply transfer function
    Let new_out be df_transfer(bb, new_in)

    Note: Check if out-state changed
    Let old_out be df_state_get_out(state)
    Let changed be env_equals(new_out, old_out)

    If changed is equal to 0:
        Note: State changed - update and add successors to worklist
        Let dummy1 be df_state_set_in(state, new_in)
        Let dummy2 be df_state_set_out(state, new_out)

        Note: Add all successors to worklist
        Let succs be memory_get_pointer(bb, 40)
        Let succ_count be memory_get_int32(bb, 48)

        Let worklist be memory_get_pointer(context, 16)

        Let i be 0
        While i is less than succ_count:
            Let succ_offset be i multiplied by 4
            Let succ_id be memory_get_int32(succs, succ_offset)

            Note: Add to worklist if not already there
            Let dummy3 be list_append(worklist, succ_id)

            Set i to i plus 1
        End While

        Return 1  Note: Changed
    End If

    Return 0  Note: No change
End Process

Note: Run fixed-point iteration
Note: Returns 1 if converged, 0 if max iterations exceeded
Process called "df_analyze" takes context as Integer returns Integer:
    Let max_iterations be 100
    Let iteration_count be 0

    Let worklist be memory_get_pointer(context, 16)

    While list_length(worklist) is greater than 0:
        If iteration_count is greater than or equal to max_iterations:
            Display "WARNING: Data flow analysis did not converge after ", integer_to_string(max_iterations), " iterations"
            Return 0  Note: Did not converge
        End If

        Note: Pop first block from worklist
        Let bb_id be list_get(worklist, 0)
        Let dummy be list_remove(worklist, 0)

        Note: Process block
        Let changed be df_process_block(context, bb_id)

        Set iteration_count to iteration_count plus 1
    End While

    memory_set_int32(context, 24, iteration_count)

    Display "Data flow analysis converged after ", integer_to_string(iteration_count), " iterations"
    Return 1  Note: Converged
End Process

Note: Get final range for a variable
Process called "df_get_variable_range" takes context as Integer, var_name as Integer returns Integer:
    Note: Look through all blocks and union the ranges
    Let cfg be memory_get_pointer(context, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Let result_range be range_create(0, 0)  Note: Start with [0, 0]
    Let found_any be 0

    Let i be 0
    While i is less than block_count:
        Let state be df_get_block_state(context, i)
        Let out_env be df_state_get_out(state)

        Let range be var_env_lookup(out_env, var_name)
        Let is_unknown be range_is_unknown(range)

        If is_unknown is equal to 0:
            If found_any is equal to 0:
                Set result_range to range
                Set found_any to 1
            Otherwise:
                Set result_range to range_union(result_range, range)
            End If
        End If

        Set i to i plus 1
    End While

    If found_any is equal to 0:
        Return range_create_unknown()
    End If

    Return result_range
End Process

Note: Analyze entire function
Note: Returns mapping of variable names to their inferred ranges
Process called "analyze_function" takes stmt_list as Integer returns Integer:
    Note: Build CFG
    Let cfg be build_cfg(stmt_list)

    Note: Create data flow context
    Let context be df_context_create(cfg)

    Note: Run fixed-point analysis
    Let converged be df_analyze(context)

    If converged is equal to 0:
        Display "WARNING: Analysis did not converge, using conservative types"
    End If

    Return context
End Process

Note: Print analysis results for debugging
Process called "df_print_results" takes context as Integer returns Integer:
    Display "=== Data Flow Analysis Results ==="

    Let cfg be memory_get_pointer(context, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Let i be 0
    While i is less than block_count:
        Display "Block ", integer_to_string(i), ":"

        Let state be df_get_block_state(context, i)
        Let in_env be df_state_get_in(state)
        Let out_env be df_state_get_out(state)

        Display "  IN state:"
        Note: TODO: Print environment

        Display "  OUT state:"
        Note: TODO: Print environment

        Set i to i plus 1
    End While

    Return 0
End Process

Note: ===== BACKWARD PROPAGATION =====

Note: Refine ranges based on conditional constraints
Note: When we see "If x is less than 10", we know in the then-branch: x is in [min, 9]

Note: Token constants for comparison operators
Let TOKEN_IS be 21
Let TOKEN_EQUAL be 22
Let TOKEN_NOT_EQUAL be 23
Let TOKEN_LESS be 24
Let TOKEN_GREATER be 25
Let TOKEN_GREATER_EQUAL be 26
Let TOKEN_LESS_EQUAL be 27

Note: Refine variable range from condition (for then-branch)
Process called "refine_from_condition" takes condition as Integer, env as Integer, is_then_branch as Integer returns Integer:
    Let expr_type be memory_get_int32(condition, 0)
    Let EXPR_BINARY_OP be 3

    If expr_type is not equal to EXPR_BINARY_OP:
        Note: Not a comparison - no refinement
        Return env
    End If

    Note: Get comparison components
    Let left be memory_get_pointer(condition, 8)
    Let op be memory_get_int32(condition, 16)
    Let right be memory_get_pointer(condition, 24)

    Note: Check if left is a simple identifier
    Let left_type be memory_get_int32(left, 0)
    Let EXPR_IDENTIFIER be 2

    If left_type is not equal to EXPR_IDENTIFIER:
        Note: Left is not a simple variable - skip refinement
        Return env
    End If

    Let var_name be memory_get_pointer(left, 8)

    Note: Compute range of right side
    Let right_range be infer_expression_range(right, env)
    Let right_is_unknown be range_is_unknown(right_range)

    If right_is_unknown is equal to 1:
        Note: Right side unknown - can't refine
        Return env
    End If

    Let right_min be range_get_min(right_range)
    Let right_max be range_get_max(right_range)

    Note: Get current variable range
    Let var_range be var_env_lookup(env, var_name)
    Let var_min be range_get_min(var_range)
    Let var_max be range_get_max(var_range)

    Note: Refine based on operator and branch
    If is_then_branch is equal to 1:
        Note: THEN branch: condition is true
        If op is equal to TOKEN_LESS:
            Note: x < right_max means x <= right_max - 1
            Let new_max be right_max minus 1
            If new_max is less than var_max:
                Let refined_range be range_create(var_min, new_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_LESS_EQUAL:
            Note: x <= right_max
            If right_max is less than var_max:
                Let refined_range be range_create(var_min, right_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_GREATER:
            Note: x > right_min means x >= right_min + 1
            Let new_min be right_min plus 1
            If new_min is greater than var_min:
                Let refined_range be range_create(new_min, var_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_GREATER_EQUAL:
            Note: x >= right_min
            If right_min is greater than var_min:
                Let refined_range be range_create(right_min, var_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_EQUAL:
            Note: x == right means x is in [right_min, right_max]
            Let refined_range be range_intersect(var_range, right_range)
            Let dummy be var_env_set(env, var_name, refined_range)

        End If

    Otherwise:
        Note: ELSE branch: condition is false (negate the condition)
        If op is equal to TOKEN_LESS:
            Note: NOT (x < right_max) means x >= right_max
            If right_max is greater than var_min:
                Let refined_range be range_create(right_max, var_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_LESS_EQUAL:
            Note: NOT (x <= right_max) means x > right_max
            Let new_min be right_max plus 1
            If new_min is greater than var_min:
                Let refined_range be range_create(new_min, var_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_GREATER:
            Note: NOT (x > right_min) means x <= right_min
            If right_min is less than var_max:
                Let refined_range be range_create(var_min, right_min)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_GREATER_EQUAL:
            Note: NOT (x >= right_min) means x < right_min
            Let new_max be right_min minus 1
            If new_max is less than var_max:
                Let refined_range be range_create(var_min, new_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_NOT_EQUAL:
            Note: NOT (x != right) means x == right
            Let refined_range be range_intersect(var_range, right_range)
            Let dummy be var_env_set(env, var_name, refined_range)

        End If
    End If

    Return env
End Process

Note: Enhanced transfer function that performs backward propagation
Process called "df_transfer_with_refinement" takes bb as Integer, in_env as Integer, cfg as Integer, bb_id as Integer returns Integer:
    Note: Start with copy of in-state
    Let out_env be var_env_copy(in_env)

    Note: Apply each statement in block
    Let stmts be memory_get_pointer(bb, 8)
    Let stmt_count be memory_get_int32(bb, 16)

    Let i be 0
    While i is less than stmt_count:
        Let offset be i multiplied by 8
        Let stmt be memory_get_pointer(stmts, offset)
        Let stmt_type be memory_get_int32(stmt, 0)

        Let STMT_IF be 3

        Note: Check for If statement with condition refinement
        If stmt_type is equal to STMT_IF:
            Let condition be memory_get_pointer(stmt, 8)

            Note: Get successors to identify then/else branches
            Let succ_count be memory_get_int32(bb, 48)
            Let succs be memory_get_pointer(bb, 40)

            If succ_count is greater than or equal to 2:
                Let then_bb_id be memory_get_int32(succs, 0)
                Let else_bb_id be memory_get_int32(succs, 4)

                Note: Refine environment for each branch
                Note: (This refinement will be picked up when those blocks are processed)
                Note: For now, just continue with normal analysis
            End If
        End If

        Note: Analyze statement and update environment
        Set out_env to analyze_statement(stmt, out_env)

        Set i to i plus 1
    End While

    Return out_env
End Process

Note: Enhanced merge that applies backward refinement from conditionals
Process called "df_merge_with_refinement" takes context as Integer, bb as Integer, bb_id as Integer, cfg as Integer returns Integer:
    Let preds be memory_get_pointer(bb, 24)
    Let pred_count be memory_get_int32(bb, 32)

    If pred_count is equal to 0:
        Return var_env_create()
    End If

    Note: Check if this block is part of an If statement
    Note: If predecessor has 2 successors and this is one of them, we can refine

    Let merged_env be var_env_create()
    Let first be 1

    Let i be 0
    While i is less than pred_count:
        Let pred_offset be i multiplied by 4
        Let pred_id be memory_get_int32(preds, pred_offset)
        Let pred_bb be cfg_get_block(cfg, pred_id)
        Let pred_state be df_get_block_state(context, pred_id)
        Let pred_out be df_state_get_out(pred_state)

        Note: Check if predecessor is a branch point
        Let pred_succ_count be memory_get_int32(pred_bb, 48)

        If pred_succ_count is greater than or equal to 2:
            Note: Predecessor is a branch - check if it has condition
            Let pred_stmts be memory_get_pointer(pred_bb, 8)
            Let pred_stmt_count be memory_get_int32(pred_bb, 16)

            Note: Look for If statement in predecessor
            Let j be 0
            While j is less than pred_stmt_count:
                Let stmt_offset be j multiplied by 8
                Let pred_stmt be memory_get_pointer(pred_stmts, stmt_offset)
                Let stmt_type be memory_get_int32(pred_stmt, 0)

                Let STMT_IF be 3
                If stmt_type is equal to STMT_IF:
                    Let condition be memory_get_pointer(pred_stmt, 8)

                    Note: Determine if this is then or else branch
                    Let pred_succs be memory_get_pointer(pred_bb, 40)
                    Let first_succ_id be memory_get_int32(pred_succs, 0)

                    Let is_then_branch be 0
                    If first_succ_id is equal to bb_id:
                        Set is_then_branch to 1
                    End If

                    Note: Refine environment based on condition
                    Let refined_env be var_env_copy(pred_out)
                    Set refined_env to refine_from_condition(condition, refined_env, is_then_branch)

                    Note: Merge this refined environment
                    If first is equal to 1:
                        Set merged_env to refined_env
                        Set first to 0
                    Otherwise:
                        Set merged_env to var_env_merge(merged_env, refined_env)
                    End If
                End If

                Set j to j plus 1
            End While
        Otherwise:
            Note: Regular predecessor - just merge
            If first is equal to 1:
                Set merged_env to var_env_copy(pred_out)
                Set first to 0
            Otherwise:
                Set merged_env to var_env_merge(merged_env, pred_out)
            End If
        End If

        Set i to i plus 1
    End While

    Return merged_env
End Process

Note: Process block with backward propagation
Process called "df_process_block_refined" takes context as Integer, bb_id as Integer returns Integer:
    Let cfg be memory_get_pointer(context, 0)
    Let bb be cfg_get_block(cfg, bb_id)
    Let state be df_get_block_state(context, bb_id)

    Note: Merge in-state from predecessors WITH refinement
    Let new_in be df_merge_with_refinement(context, bb, bb_id, cfg)

    Note: Apply transfer function
    Let new_out be df_transfer_with_refinement(bb, new_in, cfg, bb_id)

    Note: Check if out-state changed
    Let old_out be df_state_get_out(state)
    Let changed be env_equals(new_out, old_out)

    If changed is equal to 0:
        Let dummy1 be df_state_set_in(state, new_in)
        Let dummy2 be df_state_set_out(state, new_out)

        Note: Add all successors to worklist
        Let succs be memory_get_pointer(bb, 40)
        Let succ_count be memory_get_int32(bb, 48)
        Let worklist be memory_get_pointer(context, 16)

        Let i be 0
        While i is less than succ_count:
            Let succ_offset be i multiplied by 4
            Let succ_id be memory_get_int32(succs, succ_offset)
            Let dummy3 be list_append(worklist, succ_id)
            Set i to i plus 1
        End While

        Return 1
    End If

    Return 0
End Process

Note: Run analysis with backward propagation
Process called "df_analyze_with_backward_prop" takes context as Integer returns Integer:
    Let max_iterations be 100
    Let iteration_count be 0
    Let worklist be memory_get_pointer(context, 16)

    While list_length(worklist) is greater than 0:
        If iteration_count is greater than or equal to max_iterations:
            Display "WARNING: Data flow analysis did not converge after ", integer_to_string(max_iterations), " iterations"
            Return 0
        End If

        Let bb_id be list_get(worklist, 0)
        Let dummy be list_remove(worklist, 0)

        Let changed be df_process_block_refined(context, bb_id)

        Set iteration_count to iteration_count plus 1
    End While

    memory_set_int32(context, 24, iteration_count)
    Display "Data flow analysis (with refinement) converged after ", integer_to_string(iteration_count), " iterations"

    Return 1
End Process
Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Type Inference - Compute ranges for expressions
Note: This module analyzes AST expressions and determines their value ranges

Note: Import range analysis functions (conceptually - will be linked)
Note: Import AST constants from parser

Note: Expression type constants (from parser)
Let EXPR_INTEGER_LITERAL be 0
Let EXPR_STRING_LITERAL be 1
Let EXPR_IDENTIFIER be 2
Let EXPR_BINARY_OP be 3
Let EXPR_FUNCTION_CALL be 4
Let EXPR_UNARY_MINUS be 5
Let EXPR_ARRAY_INDEX be 6
Let EXPR_FIELD_ACCESS be 7
Let EXPR_ARRAY_LITERAL be 8
Let EXPR_LAMBDA be 9
Let EXPR_LAMBDA_CALL be 24
Let EXPR_CAST be 25  Note: New: cast expression

Note: Binary operation tokens (from lexer)
Let TOKEN_PLUS be 16
Let TOKEN_MINUS be 17
Let TOKEN_MULTIPLIED be 35
Let TOKEN_DIVIDED be 36
Let TOKEN_MODULO be 37
Let TOKEN_BIT_AND be 39
Let TOKEN_BIT_OR be 40
Let TOKEN_BIT_XOR be 41
Let TOKEN_BIT_SHIFT_LEFT be 42
Let TOKEN_BIT_SHIFT_RIGHT be 43
Let TOKEN_IS be 21
Let TOKEN_EQUAL be 22
Let TOKEN_NOT_EQUAL be 23
Let TOKEN_LESS be 24
Let TOKEN_GREATER be 25
Let TOKEN_GREATER_EQUAL be 26
Let TOKEN_LESS_EQUAL be 27

Note: Variable environment - maps variable names to ranges
Note: Structure: hash table of (name: String -> range: Range)
Note: For now, use simple list of (name, range) pairs

Note: Create empty variable environment
Process called "var_env_create" returns Integer:
    Note: Environment: list of (name_ptr, range_ptr) pairs
    Note: Structure: capacity(int32 at 0), size(int32 at 4), entries(ptr at 8)
    Let env be allocate(16)
    Let initial_capacity be 32
    memory_set_int32(env, 0, initial_capacity)
    memory_set_int32(env, 4, 0)  Note: size = 0

    Note: Allocate entries array (each entry is 16 bytes: name_ptr + range_ptr)
    Let entries_size be initial_capacity multiplied by 16
    Let entries be allocate(entries_size)
    memory_set_pointer(env, 8, entries)

    Return env
End Process

Note: Look up variable range in environment
Process called "var_env_lookup" takes env as Integer, name as Integer returns Integer:
    Let size be memory_get_int32(env, 4)
    Let entries be memory_get_pointer(env, 8)

    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 16
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let range_offset be entry_offset plus 8
            Let range be memory_get_pointer(entries, range_offset)
            Return range
        End If

        Set i to i plus 1
    End While

    Note: Not found - return unknown range
    Return range_create_unknown()
End Process

Note: Set variable range in environment
Process called "var_env_set" takes env as Integer, name as Integer, range as Integer returns Integer:
    Let size be memory_get_int32(env, 4)
    Let capacity be memory_get_int32(env, 0)
    Let entries be memory_get_pointer(env, 8)

    Note: Check if variable already exists - update it
    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 16
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let range_offset be entry_offset plus 8
            memory_set_pointer(entries, range_offset, range)
            Return env
        End If

        Set i to i plus 1
    End While

    Note: Variable not found - add new entry
    Note: TODO: Handle capacity expansion if size == capacity
    If size is equal to capacity:
        Display "ERROR: Variable environment capacity exceeded"
        exit_with_code(1)
    End If

    Let entry_offset be size multiplied by 16
    memory_set_pointer(entries, entry_offset, name)
    Let range_offset be entry_offset plus 8
    memory_set_pointer(entries, range_offset, range)

    Let new_size be size plus 1
    memory_set_int32(env, 4, new_size)

    Return env
End Process

Note: Copy environment (for branch analysis)
Process called "var_env_copy" takes env as Integer returns Integer:
    Let capacity be memory_get_int32(env, 0)
    Let size be memory_get_int32(env, 4)
    Let old_entries be memory_get_pointer(env, 8)

    Let new_env be allocate(16)
    memory_set_int32(new_env, 0, capacity)
    memory_set_int32(new_env, 4, size)

    Let entries_size be capacity multiplied by 16
    Let new_entries be allocate(entries_size)
    memory_set_pointer(new_env, 8, new_entries)

    Note: Copy all entries
    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 16
        Let name be memory_get_pointer(old_entries, entry_offset)
        Let range be memory_get_pointer(old_entries, entry_offset plus 8)

        memory_set_pointer(new_entries, entry_offset, name)
        memory_set_pointer(new_entries, entry_offset plus 8, range_copy(range))

        Set i to i plus 1
    End While

    Return new_env
End Process

Note: Merge two environments (union ranges for each variable)
Process called "var_env_merge" takes env1 as Integer, env2 as Integer returns Integer:
    Let result be var_env_copy(env1)

    Let size2 be memory_get_int32(env2, 4)
    Let entries2 be memory_get_pointer(env2, 8)

    Let i be 0
    While i is less than size2:
        Let entry_offset be i multiplied by 16
        Let name be memory_get_pointer(entries2, entry_offset)
        Let range2 be memory_get_pointer(entries2, entry_offset plus 8)

        Note: Look up in env1
        Let range1 be var_env_lookup(env1, name)

        Note: Union the ranges
        Let merged_range be range_union(range1, range2)

        Note: Update result
        Let dummy be var_env_set(result, name, merged_range)

        Set i to i plus 1
    End While

    Return result
End Process

Note: Compute range for an expression (without function table)
Process called "infer_expression_range" takes expr as Integer, env as Integer returns Integer:
    Note: Call full version with null function table
    Return infer_expression_range_full(expr, env, 0)
End Process

Note: Compute range for an expression with optional function table
Process called "infer_expression_range_full" takes expr as Integer, env as Integer, func_table as Integer returns Integer:
    Let expr_type be memory_get_int32(expr, 0)

    If expr_type is equal to EXPR_INTEGER_LITERAL:
        Note: Expression: type(int32), value_string(ptr at 8)
        Let value_str be memory_get_pointer(expr, 8)

        Note: Check for binary literal (0b prefix)
        Let first_char be memory_get_byte(value_str, 0)
        Let second_char be memory_get_byte(value_str, 1)
        If first_char is equal to 48:  Note: '0'
            If second_char is equal to 98:  Note: 'b'
                Note: Binary literal - parse it
                Let value be parse_binary_literal(value_str)
                Return range_create(value, value)
            End If
        End If

        Note: Regular decimal literal
        Let value be string_to_integer(value_str)
        Return range_create(value, value)

    Otherwise If expr_type is equal to EXPR_IDENTIFIER:
        Note: Expression: type(int32), name(ptr at 8)
        Let name be memory_get_pointer(expr, 8)
        Return var_env_lookup(env, name)

    Otherwise If expr_type is equal to EXPR_BINARY_OP:
        Note: Expression: type(int32), left(ptr at 8), op(int32 at 16), right(ptr at 24)
        Let left be memory_get_pointer(expr, 8)
        Let op be memory_get_int32(expr, 16)
        Let right be memory_get_pointer(expr, 24)

        Let left_range be infer_expression_range_full(left, env, func_table)
        Let right_range be infer_expression_range_full(right, env, func_table)

        If op is equal to TOKEN_PLUS:
            Return range_add(left_range, right_range)
        Otherwise If op is equal to TOKEN_MINUS:
            Return range_subtract(left_range, right_range)
        Otherwise If op is equal to TOKEN_MULTIPLIED:
            Return range_multiply(left_range, right_range)
        Otherwise If op is equal to TOKEN_DIVIDED:
            Return range_divide(left_range, right_range)
        Otherwise If op is equal to TOKEN_MODULO:
            Return range_modulo(left_range, right_range)
        Otherwise If op is equal to TOKEN_BIT_AND:
            Note: Bitwise AND - result bounded by min of operands
            Return range_bitwise_and(left_range, right_range)
        Otherwise If op is equal to TOKEN_BIT_OR:
            Return range_bitwise_or(left_range, right_range)
        Otherwise If op is equal to TOKEN_BIT_XOR:
            Return range_bitwise_xor(left_range, right_range)
        Otherwise:
            Note: Comparison operators return 0 or 1
            Return range_create(0, 1)
        End If

    Otherwise If expr_type is equal to EXPR_UNARY_MINUS:
        Note: Expression: type(int32), operand(ptr at 8)
        Let operand be memory_get_pointer(expr, 8)
        Let operand_range be infer_expression_range_full(operand, env, func_table)

        Let is_unknown be range_is_unknown(operand_range)
        If is_unknown is equal to 1:
            Return range_create_unknown()
        End If

        Let min be range_get_min(operand_range)
        Let max be range_get_max(operand_range)

        Note: Negate: [-max, -min]
        Let neg_max be 0 minus max
        Let neg_min be 0 minus min
        Return range_create(neg_max, neg_min)

    Otherwise If expr_type is equal to EXPR_CAST:
        Note: Cast expression: type(int32), expr(ptr at 8), target_type(ptr at 16)
        Let inner_expr be memory_get_pointer(expr, 8)
        Let target_type be memory_get_pointer(expr, 16)

        Note: Compute range of inner expression
        Let inner_range be infer_expression_range_full(inner_expr, env, func_table)

        Note: Cast doesn't change the VALUE, just the type
        Note: But we need to check if it fits
        Let type_kind be memory_get_int32(target_type, 0)
        Let can_overflow be range_can_overflow(inner_range, type_kind)

        If can_overflow is equal to 1:
            Note: Cast may overflow - need runtime check
            Note: For now, return unknown (will be refined later)
            Return range_create_unknown()
        End If

        Return inner_range

    Otherwise If expr_type is equal to EXPR_FUNCTION_CALL:
        Note: Function call - lookup return range from function table
        Note: Expression: type(int32), function_name(ptr at 8), args(ptr at 16)
        Let function_name be memory_get_pointer(expr, 8)

        Note: If function table provided, lookup return range
        If func_table is not equal to 0:
            Return func_table_lookup(func_table, function_name)
        Otherwise:
            Note: No function table - return unknown
            Return range_create_unknown()
        End If

    Otherwise:
        Note: Unknown expression type
        Return range_create_unknown()
    End If

    Return range_create_unknown()
End Process

Note: Parse binary literal string (0b10110101) to integer
Process called "parse_binary_literal" takes str as Integer returns Integer:
    Let result be 0
    Let len be string_length(str)

    Note: Skip "0b" prefix
    Let i be 2
    While i is less than len:
        Let char be memory_get_byte(str, i)

        Note: Shift result left by 1
        Set result to result multiplied by 2

        Note: Add bit value (char - '0')
        Let bit be char minus 48
        Set result to result plus bit

        Set i to i plus 1
    End While

    Return result
End Process

Note: Bitwise AND range (conservative)
Process called "range_bitwise_and" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_max be range_get_max(a)
    Let b_max be range_get_max(b)

    Note: AND result is at most the smaller of the two maxes
    Let result_max be a_max
    If b_max is less than result_max:
        Set result_max to b_max
    End If

    Note: Minimum is 0 if either can be 0
    Return range_create(0, result_max)
End Process

Note: Bitwise OR range (conservative)
Process called "range_bitwise_or" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_max be range_get_max(a)
    Let b_max be range_get_max(b)
    Let a_min be range_get_min(a)
    Let b_min be range_get_min(b)

    Note: OR result is at most the sum of the two maxes (very conservative)
    Let result_max be a_max plus b_max

    Note: Minimum is larger of the two minimums if both positive
    Let result_min be 0
    If a_min is greater than 0:
        If b_min is greater than 0:
            Set result_min to a_min
            If b_min is greater than result_min:
                Set result_min to b_min
            End If
        End If
    End If

    Return range_create(result_min, result_max)
End Process

Note: Bitwise XOR range (very conservative)
Process called "range_bitwise_xor" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_max be range_get_max(a)
    Let b_max be range_get_max(b)

    Note: XOR is very hard to bound - use sum as conservative estimate
    Let result_max be a_max plus b_max

    Return range_create(0, result_max)
End Process

Note: Analyze statement and update variable environment
Process called "analyze_statement" takes stmt as Integer, env as Integer returns Integer:
    Let stmt_type be memory_get_int32(stmt, 0)

    Note: Statement type constants (from parser)
    Let STMT_LET be 0
    Let STMT_SET be 1
    Let STMT_RETURN be 2
    Let STMT_IF be 3
    Let STMT_WHILE be 4
    Let STMT_EXPRESSION be 5
    Let STMT_BREAK be 6
    Let STMT_CONTINUE be 7
    Let STMT_PRINT be 8
    Let STMT_FOR be 9

    If stmt_type is equal to STMT_LET:
        Note: Let statement: type(int32), name(ptr at 8), expr(ptr at 16)
        Let name be memory_get_pointer(stmt, 8)
        Let expr be memory_get_pointer(stmt, 16)

        Let range be infer_expression_range(expr, env)
        Let dummy be var_env_set(env, name, range)
        Return env

    Otherwise If stmt_type is equal to STMT_SET:
        Note: Set statement: type(int32), target(ptr at 8), expr(ptr at 16)
        Let target be memory_get_pointer(stmt, 8)
        Let expr be memory_get_pointer(stmt, 16)

        Note: For simple identifier target
        Let target_type be memory_get_int32(target, 0)
        If target_type is equal to EXPR_IDENTIFIER:
            Let name be memory_get_pointer(target, 8)
            Let range be infer_expression_range(expr, env)
            Let dummy be var_env_set(env, name, range)
        End If

        Return env

    Otherwise If stmt_type is equal to STMT_IF:
        Note: If statement: type(int32), condition(ptr at 8), then_branch(ptr at 16), else_branch(ptr at 24)
        Let condition be memory_get_pointer(stmt, 8)
        Let then_branch be memory_get_pointer(stmt, 16)
        Let else_branch be memory_get_pointer(stmt, 24)

        Note: Analyze both branches separately
        Let then_env be var_env_copy(env)
        Let then_env_result be analyze_statement_list(then_branch, then_env)

        Let else_env be var_env_copy(env)
        If else_branch is not equal to 0:
            Let else_env_result be analyze_statement_list(else_branch, else_env)
            Note: Merge environments
            Return var_env_merge(then_env_result, else_env_result)
        Otherwise:
            Note: No else branch - merge with original env
            Return var_env_merge(then_env_result, env)
        End If

    Otherwise If stmt_type is equal to STMT_FOR:
        Note: For loop: analyze with fixed-point iteration
        Note: TODO: Implement full loop analysis
        Return env

    Otherwise If stmt_type is equal to STMT_WHILE:
        Note: While loop: analyze with fixed-point iteration
        Note: TODO: Implement full loop analysis
        Return env

    End If

    Return env
End Process

Note: Analyze list of statements
Process called "analyze_statement_list" takes stmt_list as Integer, env as Integer returns Integer:
    Note: Statement list: type(list), items...
    Let count be list_length(stmt_list)

    Let i be 0
    While i is less than count:
        Let stmt be list_get(stmt_list, i)
        Set env to analyze_statement(stmt, env)
        Set i to i plus 1
    End While

    Return env
End Process

Note: ===== INTER-PROCEDURAL ANALYSIS =====

Note: Function table - maps function name to (return_range, analyzed_flag)
Note: Structure: list of (name_ptr, return_range_ptr, analyzed_flag)
Process called "func_table_create" returns Integer:
    Note: Structure: capacity(int32 at 0), size(int32 at 4), entries(ptr at 8)
    Let table be allocate(16)
    Let initial_capacity be 32
    memory_set_int32(table, 0, initial_capacity)
    memory_set_int32(table, 4, 0)

    Note: Allocate entries array (each entry is 24 bytes: name_ptr + return_range_ptr + analyzed_flag)
    Let entries_size be initial_capacity multiplied by 24
    Let entries be allocate(entries_size)
    memory_set_pointer(table, 8, entries)

    Return table
End Process

Note: Lookup function return range
Process called "func_table_lookup" takes table as Integer, name as Integer returns Integer:
    Let size be memory_get_int32(table, 4)
    Let entries be memory_get_pointer(table, 8)

    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 24
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let range_offset be entry_offset plus 8
            Let return_range be memory_get_pointer(entries, range_offset)
            Return return_range
        End If

        Set i to i plus 1
    End While

    Note: Not found - return unknown range
    Return range_create_unknown()
End Process

Note: Set function return range
Process called "func_table_set" takes table as Integer, name as Integer, return_range as Integer returns Integer:
    Let size be memory_get_int32(table, 4)
    Let capacity be memory_get_int32(table, 0)
    Let entries be memory_get_pointer(table, 8)

    Note: Check if function already exists - update it
    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 24
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let range_offset be entry_offset plus 8
            memory_set_pointer(entries, range_offset, return_range)
            Return table
        End If

        Set i to i plus 1
    End While

    Note: Function not found - add new entry
    If size is equal to capacity:
        Display "ERROR: Function table capacity exceeded"
        exit_with_code(1)
    End If

    Let entry_offset be size multiplied by 24
    memory_set_pointer(entries, entry_offset, name)
    Let range_offset be entry_offset plus 8
    memory_set_pointer(entries, range_offset, return_range)
    Let analyzed_offset be entry_offset plus 16
    memory_set_int32(entries, analyzed_offset, 0)  Note: Not analyzed yet

    Let new_size be size plus 1
    memory_set_int32(table, 4, new_size)

    Return table
End Process

Note: Check if function has been analyzed
Process called "func_table_is_analyzed" takes table as Integer, name as Integer returns Integer:
    Let size be memory_get_int32(table, 4)
    Let entries be memory_get_pointer(table, 8)

    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 24
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let analyzed_offset be entry_offset plus 16
            Let analyzed_flag be memory_get_int32(entries, analyzed_offset)
            Return analyzed_flag
        End If

        Set i to i plus 1
    End While

    Return 0  Note: Not found - not analyzed
End Process

Note: Mark function as analyzed
Process called "func_table_mark_analyzed" takes table as Integer, name as Integer returns Integer:
    Let size be memory_get_int32(table, 4)
    Let entries be memory_get_pointer(table, 8)

    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 24
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let analyzed_offset be entry_offset plus 16
            memory_set_int32(entries, analyzed_offset, 1)
            Return table
        End If

        Set i to i plus 1
    End While

    Return table
End Process

Note: Call graph - tracks which functions call which
Note: Structure: caller_name -> list of callee names
Process called "callgraph_create" returns Integer:
    Note: Structure: capacity(int32 at 0), size(int32 at 4), entries(ptr at 8)
    Let graph be allocate(16)
    Let initial_capacity be 32
    memory_set_int32(graph, 0, initial_capacity)
    memory_set_int32(graph, 4, 0)

    Note: Allocate entries array (each entry is 16 bytes: caller_name_ptr + callees_list_ptr)
    Let entries_size be initial_capacity multiplied by 16
    Let entries be allocate(entries_size)
    memory_set_pointer(graph, 8, entries)

    Return graph
End Process

Note: Add edge to call graph (caller -> callee)
Process called "callgraph_add_edge" takes graph as Integer, caller as Integer, callee as Integer returns Integer:
    Let size be memory_get_int32(graph, 4)
    Let capacity be memory_get_int32(graph, 0)
    Let entries be memory_get_pointer(graph, 8)

    Note: Look for existing caller entry
    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 16
        Let entry_caller be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_caller, caller) is equal to 1:
            Note: Found caller - add callee to its list
            Let callees_offset be entry_offset plus 8
            Let callees_list be memory_get_pointer(entries, callees_offset)
            Let dummy be list_append(callees_list, callee)
            Return graph
        End If

        Set i to i plus 1
    End While

    Note: Caller not found - create new entry
    If size is equal to capacity:
        Display "ERROR: Call graph capacity exceeded"
        exit_with_code(1)
    End If

    Let entry_offset be size multiplied by 16
    memory_set_pointer(entries, entry_offset, caller)
    Let callees_list be list_create()
    Let dummy be list_append(callees_list, callee)
    Let callees_offset be entry_offset plus 8
    memory_set_pointer(entries, callees_offset, callees_list)

    Let new_size be size plus 1
    memory_set_int32(graph, 4, new_size)

    Return graph
End Process

Note: Get list of callees for a function
Process called "callgraph_get_callees" takes graph as Integer, caller as Integer returns Integer:
    Let size be memory_get_int32(graph, 4)
    Let entries be memory_get_pointer(graph, 8)

    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 16
        Let entry_caller be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_caller, caller) is equal to 1:
            Let callees_offset be entry_offset plus 8
            Let callees_list be memory_get_pointer(entries, callees_offset)
            Return callees_list
        End If

        Set i to i plus 1
    End While

    Note: Not found - return empty list
    Return list_create()
End Process

Note: Build call graph from AST
Process called "build_callgraph_from_ast" takes ast as Integer returns Integer:
    Let callgraph be callgraph_create()

    Note: AST structure: functions(ptr at 0)
    Let functions be memory_get_pointer(ast, 0)
    Let func_count be list_length(functions)

    Let i be 0
    While i is less than func_count:
        Let func be list_get(functions, i)

        Note: Function: name(ptr at 0), params(ptr at 8), return_type(ptr at 16), body(ptr at 24)
        Let func_name be memory_get_pointer(func, 0)
        Let body be memory_get_pointer(func, 24)

        Note: Scan body for function calls
        Let dummy be scan_for_calls(callgraph, func_name, body)

        Set i to i plus 1
    End While

    Return callgraph
End Process

Note: Scan statement list for function calls
Process called "scan_for_calls" takes callgraph as Integer, caller as Integer, stmt_list as Integer returns Integer:
    Let count be list_length(stmt_list)

    Let i be 0
    While i is less than count:
        Let stmt be list_get(stmt_list, i)
        Let dummy be scan_statement_for_calls(callgraph, caller, stmt)
        Set i to i plus 1
    End While

    Return callgraph
End Process

Note: Scan single statement for function calls
Process called "scan_statement_for_calls" takes callgraph as Integer, caller as Integer, stmt as Integer returns Integer:
    Let stmt_type be memory_get_int32(stmt, 0)

    Let STMT_LET be 0
    Let STMT_SET be 1
    Let STMT_RETURN be 2
    Let STMT_IF be 3
    Let STMT_WHILE be 4
    Let STMT_EXPRESSION be 5
    Let STMT_FOR be 9

    If stmt_type is equal to STMT_LET:
        Let expr be memory_get_pointer(stmt, 16)
        Let dummy be scan_expr_for_calls(callgraph, caller, expr)
        Return callgraph

    Otherwise If stmt_type is equal to STMT_SET:
        Let expr be memory_get_pointer(stmt, 16)
        Let dummy be scan_expr_for_calls(callgraph, caller, expr)
        Return callgraph

    Otherwise If stmt_type is equal to STMT_RETURN:
        Let expr be memory_get_pointer(stmt, 8)
        If expr is not equal to 0:
            Let dummy be scan_expr_for_calls(callgraph, caller, expr)
        End If
        Return callgraph

    Otherwise If stmt_type is equal to STMT_IF:
        Let condition be memory_get_pointer(stmt, 8)
        Let then_branch be memory_get_pointer(stmt, 16)
        Let else_branch be memory_get_pointer(stmt, 24)

        Let dummy be scan_expr_for_calls(callgraph, caller, condition)
        Let dummy2 be scan_for_calls(callgraph, caller, then_branch)
        If else_branch is not equal to 0:
            Let dummy3 be scan_for_calls(callgraph, caller, else_branch)
        End If
        Return callgraph

    Otherwise If stmt_type is equal to STMT_WHILE:
        Let condition be memory_get_pointer(stmt, 8)
        Let body be memory_get_pointer(stmt, 16)

        Let dummy be scan_expr_for_calls(callgraph, caller, condition)
        Let dummy2 be scan_for_calls(callgraph, caller, body)
        Return callgraph

    Otherwise If stmt_type is equal to STMT_FOR:
        Let init be memory_get_pointer(stmt, 8)
        Let condition be memory_get_pointer(stmt, 16)
        Let update be memory_get_pointer(stmt, 24)
        Let body be memory_get_pointer(stmt, 32)

        If init is not equal to 0:
            Let dummy be scan_statement_for_calls(callgraph, caller, init)
        End If
        If condition is not equal to 0:
            Let dummy2 be scan_expr_for_calls(callgraph, caller, condition)
        End If
        If update is not equal to 0:
            Let dummy3 be scan_statement_for_calls(callgraph, caller, update)
        End If
        Let dummy4 be scan_for_calls(callgraph, caller, body)
        Return callgraph

    Otherwise If stmt_type is equal to STMT_EXPRESSION:
        Let expr be memory_get_pointer(stmt, 8)
        Let dummy be scan_expr_for_calls(callgraph, caller, expr)
        Return callgraph

    End If

    Return callgraph
End Process

Note: Scan expression for function calls
Process called "scan_expr_for_calls" takes callgraph as Integer, caller as Integer, expr as Integer returns Integer:
    If expr is equal to 0:
        Return callgraph
    End If

    Let expr_type be memory_get_int32(expr, 0)

    If expr_type is equal to EXPR_FUNCTION_CALL:
        Note: Found function call - add edge
        Let callee_name be memory_get_pointer(expr, 8)
        Let dummy be callgraph_add_edge(callgraph, caller, callee_name)

        Note: Also scan arguments
        Let args be memory_get_pointer(expr, 16)
        If args is not equal to 0:
            Let arg_count be list_length(args)
            Let i be 0
            While i is less than arg_count:
                Let arg be list_get(args, i)
                Let dummy2 be scan_expr_for_calls(callgraph, caller, arg)
                Set i to i plus 1
            End While
        End If
        Return callgraph

    Otherwise If expr_type is equal to EXPR_BINARY_OP:
        Let left be memory_get_pointer(expr, 8)
        Let right be memory_get_pointer(expr, 24)
        Let dummy be scan_expr_for_calls(callgraph, caller, left)
        Let dummy2 be scan_expr_for_calls(callgraph, caller, right)
        Return callgraph

    Otherwise If expr_type is equal to EXPR_UNARY_MINUS:
        Let operand be memory_get_pointer(expr, 8)
        Let dummy be scan_expr_for_calls(callgraph, caller, operand)
        Return callgraph

    Otherwise If expr_type is equal to EXPR_CAST:
        Let inner_expr be memory_get_pointer(expr, 8)
        Let dummy be scan_expr_for_calls(callgraph, caller, inner_expr)
        Return callgraph

    Otherwise If expr_type is equal to EXPR_ARRAY_INDEX:
        Let array be memory_get_pointer(expr, 8)
        Let index be memory_get_pointer(expr, 16)
        Let dummy be scan_expr_for_calls(callgraph, caller, array)
        Let dummy2 be scan_expr_for_calls(callgraph, caller, index)
        Return callgraph

    End If

    Return callgraph
End Process

Note: Analyze function return range with inter-procedural support
Process called "analyze_function_range" takes func as Integer, func_table as Integer, callgraph as Integer returns Integer:
    Note: Function: name(ptr at 0), params(ptr at 8), return_type(ptr at 16), body(ptr at 24)
    Let func_name be memory_get_pointer(func, 0)
    Let body be memory_get_pointer(func, 24)

    Note: Check if already analyzed
    Let is_analyzed be func_table_is_analyzed(func_table, func_name)
    If is_analyzed is equal to 1:
        Return func_table_lookup(func_table, func_name)
    End If

    Note: Analyze all callees first (bottom-up)
    Let callees be callgraph_get_callees(callgraph, func_name)
    Let callee_count be list_length(callees)
    Let i be 0
    While i is less than callee_count:
        Let callee_name be list_get(callees, i)

        Note: Recursively analyze callee
        Note: TODO: Handle recursion properly (detect cycles)
        Let callee_is_analyzed be func_table_is_analyzed(func_table, callee_name)
        If callee_is_analyzed is equal to 0:
            Note: Callee not analyzed yet - need to find and analyze it
            Note: For now, assume unknown range
            Let dummy be func_table_set(func_table, callee_name, range_create_unknown())
        End If

        Set i to i plus 1
    End While

    Note: Create environment with parameter ranges (assume unknown for now)
    Let env be var_env_create()

    Note: Scan body for return statements and collect return ranges
    Let return_range be scan_for_return_range(body, env, func_table)

    Note: Update function table
    Let dummy be func_table_set(func_table, func_name, return_range)
    Let dummy2 be func_table_mark_analyzed(func_table, func_name)

    Return return_range
End Process

Note: Scan statement list for return statements and compute union of return ranges
Process called "scan_for_return_range" takes stmt_list as Integer, env as Integer, func_table as Integer returns Integer:
    Let result_range be range_create(0, 0)  Note: Start with single point [0,0]
    Let found_return be 0

    Let count be list_length(stmt_list)
    Let i be 0
    While i is less than count:
        Let stmt be list_get(stmt_list, i)
        Let stmt_range be scan_stmt_for_return_range(stmt, env, func_table)

        Note: Check if this statement has return
        If stmt_range is not equal to 0:
            Set found_return to 1
            Set result_range to range_union(result_range, stmt_range)
        End If

        Set i to i plus 1
    End While

    If found_return is equal to 0:
        Return range_create_unknown()
    End If

    Return result_range
End Process

Note: Scan single statement for return range
Process called "scan_stmt_for_return_range" takes stmt as Integer, env as Integer, func_table as Integer returns Integer:
    Let stmt_type be memory_get_int32(stmt, 0)

    Let STMT_RETURN be 2
    Let STMT_IF be 3
    Let STMT_WHILE be 4
    Let STMT_FOR be 9

    If stmt_type is equal to STMT_RETURN:
        Let expr be memory_get_pointer(stmt, 8)
        If expr is equal to 0:
            Return range_create(0, 0)  Note: No return value
        End If
        Return infer_expression_range_with_functable(expr, env, func_table)

    Otherwise If stmt_type is equal to STMT_IF:
        Let then_branch be memory_get_pointer(stmt, 16)
        Let else_branch be memory_get_pointer(stmt, 24)

        Let then_range be scan_for_return_range(then_branch, env, func_table)

        If else_branch is not equal to 0:
            Let else_range be scan_for_return_range(else_branch, env, func_table)

            Note: Only return if both branches have returns
            If then_range is not equal to 0:
                If else_range is not equal to 0:
                    Return range_union(then_range, else_range)
                End If
            End If
        End If

        Return then_range  Note: May be 0 if no return

    Otherwise If stmt_type is equal to STMT_WHILE:
        Let body be memory_get_pointer(stmt, 16)
        Return scan_for_return_range(body, env, func_table)

    Otherwise If stmt_type is equal to STMT_FOR:
        Let body be memory_get_pointer(stmt, 32)
        Return scan_for_return_range(body, env, func_table)

    End If

    Return 0  Note: No return in this statement
End Process

Note: Infer expression range with function table support (wrapper for compatibility)
Process called "infer_expression_range_with_functable" takes expr as Integer, env as Integer, func_table as Integer returns Integer:
    Return infer_expression_range_full(expr, env, func_table)
End Process
Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Main Compiler for Runa v0.0.7.5
Note: Line-by-line transliteration from v0.0.7.3 main.c (64 LOC)

Note: Process to read entire file contents into memory
Note: Equivalent to C static char* read_file(const char *filename)
Process called "read_file_internal" takes filename as Integer returns Integer:
    Note: Read entire file using runtime function (handles file open failure internally)
    Let content be runtime_read_file(filename)

    Note: Check if reading failed (equivalent to fopen() returning NULL)
    If content is equal to 0:
        Note: print_string(error message (equivalent to fprintf(stderr, "[MAIN ERROR] Could not open input file '%s'\n", filename))
        Let error_msg_temp be string_concat("[MAIN ERROR] Could not open input file '", filename)
        Let error_msg be string_concat(error_msg_temp, "'")
        deallocate(error_msg_temp)
        print_string(error_msg)
        deallocate(error_msg)
        Return 0
    End If

    Return content
End Process

Note: Process imports: load and merge imported files
Note: Takes program pointer, returns 0 on success, 1 on failure
Process called "process_imports" takes program as Integer returns Integer:
    Note: Get import count and imports array
    Let import_count be memory_get_int32(program, 40)  Note: PROGRAM_IMPORT_COUNT

    If import_count is equal to 0:
        Return 0  Note: No imports to process
    End If

    Let imports be memory_get_pointer(program, 32)  Note: PROGRAM_IMPORTS

    Note: Iterate through each import
    Let i be 0
    While i is less than import_count:
        Note: Get import statement pointer
        Let ptr_size be 8
        Let import_offset be i multiplied by ptr_size
        Let import_ptr be imports plus import_offset
        Let import_stmt be memory_get_pointer(import_ptr, 0)

        Note: Get filename from import statement (offset 0 is filename)
        Let import_filename be memory_get_pointer(import_stmt, 0)

        Note: Read the imported file
        Let import_source be read_file_internal(import_filename)
        If import_source is equal to 0:
            Let error_msg_temp be string_concat("[IMPORT ERROR] Failed to read import file: ", import_filename)
            print_string(error_msg_temp)
            deallocate(error_msg_temp)
            Return 1
        End If

        Note: Create lexer for imported file
        Let import_lexer be lexer_create(import_source)

        Note: Create parser for imported file
        Let import_parser be parser_create(import_lexer)

        Note: Parse the imported file
        Let import_program be parser_parse_program(import_parser)

        If import_program is equal to 0:
            Let error_msg_temp be string_concat("[IMPORT ERROR] Failed to parse import file: ", import_filename)
            print_string(error_msg_temp)
            deallocate(error_msg_temp)
            parser_destroy(import_parser)
            lexer_destroy(import_lexer)
            deallocate(import_source)
            Return 1
        End If

        Note: Merge functions from imported program into main program
        Let import_func_count be memory_get_int32(import_program, 8)  Note: function_count
        Let import_functions be memory_get_pointer(import_program, 0)  Note: functions array

        Let j be 0
        While j is less than import_func_count:
            Let func_offset be j multiplied by ptr_size
            Let func_ptr be import_functions plus func_offset
            Let func be memory_get_pointer(func_ptr, 0)
            program_add_function(program, func)
            Set j to j plus 1
        End While

        Note: Merge types from imported program into main program
        Let import_type_count be memory_get_int32(import_program, 32)  Note: type_count
        Let import_types be memory_get_pointer(import_program, 40)  Note: types array

        Let k be 0
        While k is less than import_type_count:
            Let type_offset be k multiplied by ptr_size
            Let type_ptr be import_types plus type_offset
            Let type_def be memory_get_pointer(type_ptr, 0)
            program_add_type(program, type_def)
            Set k to k plus 1
        End While

        Note: Cleanup import parsing resources (but not the AST nodes - they're now in main program)
        parser_destroy(import_parser)
        lexer_destroy(import_lexer)
        deallocate(import_source)

        Set i to i plus 1
    End While

    Return 0
End Process

Note: Main compiler entry point
Note: Equivalent to C int main(int argc, char **argv)
Process called "main" takes argc as Integer, argv as Integer returns Integer:
    Note: Check command line arguments (argc != 3)
    If argc is not equal to 3:
        Note: print_string(usage message (equivalent to fprintf(stderr, "Usage: %s <input.runa> <output.s>\n", argv[0]))
        Let prog_name be get_command_line_arg(0)
        Let usage_msg_temp be string_concat("Usage: ", prog_name)
        Let usage_msg be string_concat(usage_msg_temp, " <input.runa> <output.s>")
        deallocate(usage_msg_temp)
        print_string(usage_msg)
        deallocate(usage_msg)
        deallocate(prog_name)
        Return 1
    End If

    Note: Get command line arguments (equivalent to input_filename = argv[1])
    Let input_filename be get_command_line_arg(1)
    Let output_filename be get_command_line_arg(2)

    Note: Read source file (equivalent to char *source = read_file(input_filename))
    Let source be read_file_internal(input_filename)

    Note: Check if reading failed (equivalent to !source)
    If source is equal to 0:
        print_string("[ERROR] Failed to read source file")
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Create lexer (equivalent to Lexer *lexer = lexer_create(source))
    Let lexer be lexer_create(source)

    Note: Create parser (equivalent to Parser *parser = parser_create(lexer))
    Let parser be parser_create(lexer)

    Note: Parse program (equivalent to Program *program = parser_parse_program(parser))
    Let program be parser_parse_program(parser)

    Note: Check if parsing failed (equivalent to !program)
    If program is equal to 0:
        print_string("[ERROR] main: Parsing failed - program is NULL")
        Note: Cleanup parser and lexer before returning
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source)
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Process imports: load and merge imported files
    Let import_result be process_imports(program)
    If import_result is not equal to 0:
        Note: Import processing failed
        program_destroy(program)
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source)
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: ===== TYPE INFERENCE ANALYSIS =====
    Note: TODO: Type inference disabled for stage1 build (modules not linked yet)
    Note:    Note: Run range analysis and type inference on the program
    Note:    Display "[TYPE INFERENCE] Running range analysis..."

    Note:     Note: Build call graph from AST
    Note:     Let callgraph be build_callgraph_from_ast(program)

    Note:     Note: Create function table for return ranges
    Note:     Let func_table be func_table_create()

    Note:     Note: Analyze each function bottom-up
    Note:     Let functions be memory_get_pointer(program, 0)
    Note:     Let func_count be memory_get_int32(program, 8)

    Note:     Let i be 0
    Note:     While i is less than func_count:
    Note:         Let func_offset be i multiplied by 8
    Note:         Let func_ptr be functions plus func_offset
    Note:         Let func be memory_get_pointer(func_ptr, 0)

    Note:         Note: Analyze function and compute return range
    Note:         Let return_range be analyze_function_range(func, func_table, callgraph)

    Note:         Set i to i plus 1
    Note:     End While

    Note:     Display "[TYPE INFERENCE] Range analysis complete"

    Note: Create code generator (equivalent to CodeGenerator *codegen = codegen_create(output_filename))
    Let codegen be codegen_create(output_filename)

    Note: Check if codegen creation failed (equivalent to !codegen)
    If codegen is equal to 0:
        Note: Cleanup resources before returning
        program_destroy(program)
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source)
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Generate code with type inference results (equivalent to codegen_generate(codegen, program))
    codegen_generate_with_types(codegen, program, func_table)

    Note: Close output file to ensure content is written (flushes buffer)
    Let output_file be memory_get_integer(codegen, 0)
    file_close_buffered(output_file)

    Note: Print success message (equivalent to printf("Successfully compiled '%s' to '%s'\n", input_filename, output_filename))
    Let success_msg_temp be string_concat("Successfully compiled '", input_filename)
    Let success_msg_temp2 be string_concat(success_msg_temp, "' to '")
    deallocate(success_msg_temp)
    Let success_msg be string_concat(success_msg_temp2, output_filename)
    deallocate(success_msg_temp2)
    Let success_msg_final be string_concat(success_msg, "'")
    deallocate(success_msg)
    print_string(success_msg_final)
    deallocate(success_msg_final)

    Note: Cleanup resources (equivalent to C cleanup code)
    codegen_destroy(codegen)
    program_destroy(program)
    parser_destroy(parser)
    lexer_destroy(lexer)
    deallocate(source)
    deallocate(input_filename)
    deallocate(output_filename)

    Return 0
End Process