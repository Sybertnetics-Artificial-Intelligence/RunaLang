Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Range Analysis for Optimal Type Inference
Note: This module implements compile-time value range tracking to automatically
Note: select the smallest integer type that safely holds all possible values.

Note: Range structure: min(int64 at 0), max(int64 at 8), is_unknown(int32 at 16)
Note: Total size: 20 bytes

Note: Type kind constants (matching parser.runa)
Let TYPE_INTEGER8 be 0
Let TYPE_INTEGER16 be 1
Let TYPE_INTEGER32 be 2
Let TYPE_INTEGER64 be 3
Let TYPE_INTEGER128 be 4
Let TYPE_UNSIGNED_INTEGER8 be 5
Let TYPE_UNSIGNED_INTEGER16 be 6
Let TYPE_UNSIGNED_INTEGER32 be 7
Let TYPE_UNSIGNED_INTEGER64 be 8
Let TYPE_UNSIGNED_INTEGER128 be 9
Let TYPE_FLOAT be 10
Let TYPE_FLOAT64 be 11
Let TYPE_POINTER be 12

Note: Integer bounds for type selection
Let INTEGER8_MIN be negative 128
Let INTEGER8_MAX be 127
Let INTEGER16_MIN be negative 32768
Let INTEGER16_MAX be 32767
Let INTEGER32_MIN be negative 2147483648
Let INTEGER32_MAX be 2147483647
Note: INTEGER64_MIN/MAX would overflow in current system, handled specially

Let UNSIGNED_INTEGER8_MAX be 255
Let UNSIGNED_INTEGER16_MAX be 65535
Let UNSIGNED_INTEGER32_MAX be 4294967295

Note: Create a range with known bounds
Process called "range_create" takes min as Integer, max as Integer returns Integer:
    Let range be allocate(20)
    memory_set_integer(range, 0, min)
    memory_set_integer(range, 8, max)
    memory_set_int32(range, 16, 0)  Note: is_unknown = false
    Return range
End Process

Note: Create an unknown/unbounded range
Process called "range_create_unknown" returns Integer:
    Let range be allocate(20)
    memory_set_integer(range, 0, 0)
    memory_set_integer(range, 8, 0)
    memory_set_int32(range, 16, 1)  Note: is_unknown = true
    Return range
End Process

Note: Get minimum value from range
Process called "range_get_min" takes range as Integer returns Integer:
    Return memory_get_integer(range, 0)
End Process

Note: Get maximum value from range
Process called "range_get_max" takes range as Integer returns Integer:
    Return memory_get_integer(range, 8)
End Process

Note: Check if range is unknown
Process called "range_is_unknown" takes range as Integer returns Integer:
    Return memory_get_int32(range, 16)
End Process

Note: Add two ranges: [a_min + b_min, a_max + b_max]
Process called "range_add" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_min be range_get_min(a)
    Let a_max be range_get_max(a)
    Let b_min be range_get_min(b)
    Let b_max be range_get_max(b)

    Let result_min be a_min plus b_min
    Let result_max be a_max plus b_max

    Return range_create(result_min, result_max)
End Process

Note: Subtract two ranges: [a_min - b_max, a_max - b_min]
Process called "range_subtract" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_min be range_get_min(a)
    Let a_max be range_get_max(a)
    Let b_min be range_get_min(b)
    Let b_max be range_get_max(b)

    Let result_min be a_min minus b_max
    Let result_max be a_max minus b_min

    Return range_create(result_min, result_max)
End Process

Note: Multiply two ranges (handles sign changes)
Process called "range_multiply" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_min be range_get_min(a)
    Let a_max be range_get_max(a)
    Let b_min be range_get_min(b)
    Let b_max be range_get_max(b)

    Note: Calculate all four products (handles negative numbers)
    Let p1 be a_min multiplied by b_min
    Let p2 be a_min multiplied by b_max
    Let p3 be a_max multiplied by b_min
    Let p4 be a_max multiplied by b_max

    Note: Find minimum of four products
    Let result_min be p1
    If p2 is less than result_min:
        Set result_min to p2
    End If
    If p3 is less than result_min:
        Set result_min to p3
    End If
    If p4 is less than result_min:
        Set result_min to p4
    End If

    Note: Find maximum of four products
    Let result_max be p1
    If p2 is greater than result_max:
        Set result_max to p2
    End If
    If p3 is greater than result_max:
        Set result_max to p3
    End If
    If p4 is greater than result_max:
        Set result_max to p4
    End If

    Return range_create(result_min, result_max)
End Process

Note: Divide two ranges (handles sign changes, division by zero)
Process called "range_divide" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let b_min be range_get_min(b)
    Let b_max be range_get_max(b)

    Note: Check for division by zero
    If b_min is less than or equal to 0:
        If b_max is greater than or equal to 0:
            Note: Range includes zero - potential division by zero
            Return range_create_unknown()
        End If
    End If

    Let a_min be range_get_min(a)
    Let a_max be range_get_max(a)

    Note: Calculate all four quotients
    Let q1 be a_min divided by b_min
    Let q2 be a_min divided by b_max
    Let q3 be a_max divided by b_min
    Let q4 be a_max divided by b_max

    Note: Find minimum of four quotients
    Let result_min be q1
    If q2 is less than result_min:
        Set result_min to q2
    End If
    If q3 is less than result_min:
        Set result_min to q3
    End If
    If q4 is less than result_min:
        Set result_min to q4
    End If

    Note: Find maximum of four quotients
    Let result_max be q1
    If q2 is greater than result_max:
        Set result_max to q2
    End If
    If q3 is greater than result_max:
        Set result_max to q3
    End If
    If q4 is greater than result_max:
        Set result_max to q4
    End If

    Return range_create(result_min, result_max)
End Process

Note: Modulo range: [0, max(|a_max|, |b_max|) - 1]
Process called "range_modulo" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let b_max be range_get_max(b)
    Let b_min be range_get_min(b)

    Note: Get absolute values
    Let abs_b_max be b_max
    If b_max is less than 0:
        Set abs_b_max to 0 minus b_max
    End If

    Let abs_b_min be b_min
    If b_min is less than 0:
        Set abs_b_min to 0 minus b_min
    End If

    Let max_mod be abs_b_max
    If abs_b_min is greater than max_mod:
        Set max_mod to abs_b_min
    End If

    Let max_result be max_mod minus 1

    Return range_create(0, max_result)
End Process

Note: Union of two ranges: [min(a_min, b_min), max(a_max, b_max)]
Note: Used for merging ranges at control flow join points
Process called "range_union" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_min be range_get_min(a)
    Let a_max be range_get_max(a)
    Let b_min be range_get_min(b)
    Let b_max be range_get_max(b)

    Let result_min be a_min
    If b_min is less than result_min:
        Set result_min to b_min
    End If

    Let result_max be a_max
    If b_max is greater than result_max:
        Set result_max to b_max
    End If

    Return range_create(result_min, result_max)
End Process

Note: Intersection of two ranges: [max(a_min, b_min), min(a_max, b_max)]
Note: Used when refining ranges from conditionals
Process called "range_intersect" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return b
    End If
    If b_unknown is equal to 1:
        Return a
    End If

    Let a_min be range_get_min(a)
    Let a_max be range_get_max(a)
    Let b_min be range_get_min(b)
    Let b_max be range_get_max(b)

    Let result_min be a_min
    If b_min is greater than result_min:
        Set result_min to b_min
    End If

    Let result_max be a_max
    If b_max is less than result_max:
        Set result_max to b_max
    End If

    Note: Check if intersection is empty
    If result_min is greater than result_max:
        Note: Empty intersection - should not happen in valid code
        Return range_create_unknown()
    End If

    Return range_create(result_min, result_max)
End Process

Note: Select optimal type for a range
Process called "range_select_type" takes range as Integer returns Integer:
    Let is_unknown be range_is_unknown(range)
    If is_unknown is equal to 1:
        Return TYPE_INTEGER32  Note: Conservative default for unknown
    End If

    Let min be range_get_min(range)
    Let max be range_get_max(range)

    Note: Check if unsigned is better
    If min is greater than or equal to 0:
        Note: Non-negative range - consider unsigned types
        If max is less than or equal to UNSIGNED_INTEGER8_MAX:
            Return TYPE_UNSIGNED_INTEGER8
        End If
        If max is less than or equal to UNSIGNED_INTEGER16_MAX:
            Return TYPE_UNSIGNED_INTEGER16
        End If
        If max is less than or equal to UNSIGNED_INTEGER32_MAX:
            Return TYPE_UNSIGNED_INTEGER32
        End If
        Note: Larger than UnsignedInteger32, use UnsignedInteger64
        Return TYPE_UNSIGNED_INTEGER64
    End If

    Note: Signed range - check signed types
    If min is greater than or equal to INTEGER8_MIN:
        If max is less than or equal to INTEGER8_MAX:
            Return TYPE_INTEGER8
        End If
    End If

    If min is greater than or equal to INTEGER16_MIN:
        If max is less than or equal to INTEGER16_MAX:
            Return TYPE_INTEGER16
        End If
    End If

    If min is greater than or equal to INTEGER32_MIN:
        If max is less than or equal to INTEGER32_MAX:
            Return TYPE_INTEGER32
        End If
    End If

    Note: Larger than Integer32, use Integer64
    Return TYPE_INTEGER64
End Process

Note: Refine range based on comparison (for conditional analysis)
Note: op: 22=EQUAL, 23=NOT_EQUAL, 24=LESS, 25=GREATER, 26=GREATER_EQUAL, 27=LESS_EQUAL
Process called "range_refine_from_comparison" takes range as Integer, op as Integer, value as Integer returns Integer:
    Let is_unknown be range_is_unknown(range)
    If is_unknown is equal to 1:
        Note: Can't refine unknown range
        Return range
    End If

    Let min be range_get_min(range)
    Let max be range_get_max(range)

    If op is equal to 22:  Note: EQUAL
        Return range_create(value, value)
    Otherwise If op is equal to 24:  Note: LESS
        Let new_max be value minus 1
        If new_max is less than min:
            Note: Impossible condition
            Return range_create_unknown()
        End If
        Return range_create(min, new_max)
    Otherwise If op is equal to 27:  Note: LESS_EQUAL
        If value is less than min:
            Return range_create_unknown()
        End If
        Return range_create(min, value)
    Otherwise If op is equal to 25:  Note: GREATER
        Let new_min be value plus 1
        If new_min is greater than max:
            Return range_create_unknown()
        End If
        Return range_create(new_min, max)
    Otherwise If op is equal to 26:  Note: GREATER_EQUAL
        If value is greater than max:
            Return range_create_unknown()
        End If
        Return range_create(value, max)
    End If

    Note: NOT_EQUAL can't refine much, return original
    Return range
End Process

Note: Copy a range (for SSA)
Process called "range_copy" takes range as Integer returns Integer:
    Let is_unknown be range_is_unknown(range)
    If is_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let min be range_get_min(range)
    Let max be range_get_max(range)
    Return range_create(min, max)
End Process

Note: Check if range can overflow when assigned to a specific type
Process called "range_can_overflow" takes range as Integer, type_kind as Integer returns Integer:
    Let is_unknown be range_is_unknown(range)
    If is_unknown is equal to 1:
        Return 1  Note: Unknown range can potentially overflow
    End If

    Let min be range_get_min(range)
    Let max be range_get_max(range)

    If type_kind is equal to TYPE_INTEGER8:
        If min is less than INTEGER8_MIN:
            Return 1
        End If
        If max is greater than INTEGER8_MAX:
            Return 1
        End If
    Otherwise If type_kind is equal to TYPE_INTEGER16:
        If min is less than INTEGER16_MIN:
            Return 1
        End If
        If max is greater than INTEGER16_MAX:
            Return 1
        End If
    Otherwise If type_kind is equal to TYPE_INTEGER32:
        If min is less than INTEGER32_MIN:
            Return 1
        End If
        If max is greater than INTEGER32_MAX:
            Return 1
        End If
    Otherwise If type_kind is equal to TYPE_UNSIGNED_INTEGER8:
        If min is less than 0:
            Return 1
        End If
        If max is greater than UNSIGNED_INTEGER8_MAX:
            Return 1
        End If
    Otherwise If type_kind is equal to TYPE_UNSIGNED_INTEGER16:
        If min is less than 0:
            Return 1
        End If
        If max is greater than UNSIGNED_INTEGER16_MAX:
            Return 1
        End If
    Otherwise If type_kind is equal to TYPE_UNSIGNED_INTEGER32:
        If min is less than 0:
            Return 1
        End If
        If max is greater than UNSIGNED_INTEGER32_MAX:
            Return 1
        End If
    End If

    Return 0  Note: No overflow possible
End Process

Note: Debug: Print range for debugging
Process called "range_print" takes range as Integer returns Integer:
    Let is_unknown be range_is_unknown(range)
    If is_unknown is equal to 1:
        Display "[UNKNOWN]"
        Return 0
    End If

    Let min be range_get_min(range)
    Let max be range_get_max(range)

    Note: Would print range here but integer_to_string requires linking string_utils
    Note: Display "[", integer_to_string(min), ", ", integer_to_string(max), "]"
    Return 0
End Process
