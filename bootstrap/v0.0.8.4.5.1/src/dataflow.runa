Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Data Flow Analysis with Fixed-Point Iteration
Note: Computes ranges for all variables across all control flow paths

Note: Data flow state for a basic block
Note: in_state(ptr at 0), out_state(ptr at 8)
Note: Each state is a variable environment (name -> range)

Note: Create data flow state for block
Process called "df_state_create" returns Integer:
    Let state be allocate(16)
    Let in_env be var_env_create()
    Let out_env be var_env_create()

    memory_set_pointer(state, 0, in_env)
    memory_set_pointer(state, 8, out_env)

    Return state
End Process

Note: Get in-state
Process called "df_state_get_in" takes state as Integer returns Integer:
    Return memory_get_pointer(state, 0)
End Process

Note: Get out-state
Process called "df_state_get_out" takes state as Integer returns Integer:
    Return memory_get_pointer(state, 8)
End Process

Note: Set in-state
Process called "df_state_set_in" takes state as Integer, env as Integer returns Integer:
    memory_set_pointer(state, 0, env)
    Return state
End Process

Note: Set out-state
Process called "df_state_set_out" takes state as Integer, env as Integer returns Integer:
    memory_set_pointer(state, 8, env)
    Return state
End Process

Note: Data flow analysis context
Note: cfg(ptr at 0), block_states(ptr at 8), worklist(ptr at 16), iteration_count(int32 at 24)
Process called "df_context_create" takes cfg as Integer returns Integer:
    Let context be allocate(28)

    memory_set_pointer(context, 0, cfg)

    Note: Create state for each block
    Let block_count be memory_get_int32(cfg, 8)
    Let states_size be block_count multiplied by 8
    Let states be allocate(states_size)

    Let i be 0
    While i is less than block_count:
        Let state be df_state_create()
        Let offset be i multiplied by 8
        memory_set_pointer(states, offset, state)
        Set i to i plus 1
    End While

    memory_set_pointer(context, 8, states)

    Note: Create worklist (initially contains all blocks)
    Let worklist be list_create()
    Let j be 0
    While j is less than block_count:
        Let dummy be list_append(worklist, j)
        Set j to j plus 1
    End While

    memory_set_pointer(context, 16, worklist)
    memory_set_int32(context, 24, 0)  Note: iteration_count = 0

    Return context
End Process

Note: Get state for block ID
Process called "df_get_block_state" takes context as Integer, bb_id as Integer returns Integer:
    Let states be memory_get_pointer(context, 8)
    Let offset be bb_id multiplied by 8
    Return memory_get_pointer(states, offset)
End Process

Note: Transfer function: compute out-state from in-state for a block
Process called "df_transfer" takes bb as Integer, in_env as Integer returns Integer:
    Note: Start with copy of in-state
    Let out_env be var_env_copy(in_env)

    Note: Apply each statement in block
    Let stmts be memory_get_pointer(bb, 8)
    Let stmt_count be memory_get_int32(bb, 16)

    Let i be 0
    While i is less than stmt_count:
        Let offset be i multiplied by 8
        Let stmt be memory_get_pointer(stmts, offset)

        Note: Analyze statement and update environment
        Set out_env to analyze_statement(stmt, out_env)

        Set i to i plus 1
    End While

    Return out_env
End Process

Note: Merge in-state from all predecessors
Process called "df_merge_predecessors" takes context as Integer, bb as Integer returns Integer:
    Let cfg be memory_get_pointer(context, 0)
    Let preds be memory_get_pointer(bb, 24)
    Let pred_count be memory_get_int32(bb, 32)

    If pred_count is equal to 0:
        Note: No predecessors - use empty environment
        Return var_env_create()
    End If

    Note: Get out-state of first predecessor
    Let first_pred_id be memory_get_int32(preds, 0)
    Let first_pred_state be df_get_block_state(context, first_pred_id)
    Let first_pred_out be df_state_get_out(first_pred_state)

    Let merged_env be var_env_copy(first_pred_out)

    Note: Merge with remaining predecessors
    Let i be 1
    While i is less than pred_count:
        Let pred_offset be i multiplied by 4
        Let pred_id be memory_get_int32(preds, pred_offset)
        Let pred_state be df_get_block_state(context, pred_id)
        Let pred_out be df_state_get_out(pred_state)

        Set merged_env to var_env_merge(merged_env, pred_out)

        Set i to i plus 1
    End While

    Return merged_env
End Process

Note: Check if two environments are equal (for convergence check)
Process called "env_equals" takes env1 as Integer, env2 as Integer returns Integer:
    Let size1 be memory_get_int32(env1, 4)
    Let size2 be memory_get_int32(env2, 4)

    If size1 is not equal to size2:
        Return 0  Note: Not equal
    End If

    Let entries1 be memory_get_pointer(env1, 8)

    Let i be 0
    While i is less than size1:
        Let entry_offset be i multiplied by 16
        Let name be memory_get_pointer(entries1, entry_offset)
        Let range1 be memory_get_pointer(entries1, entry_offset plus 8)

        Note: Look up in env2
        Let range2 be var_env_lookup(env2, name)

        Note: Compare ranges
        Let r1_min be range_get_min(range1)
        Let r1_max be range_get_max(range1)
        Let r2_min be range_get_min(range2)
        Let r2_max be range_get_max(range2)

        If r1_min is not equal to r2_min:
            Return 0
        End If
        If r1_max is not equal to r2_max:
            Return 0
        End If

        Set i to i plus 1
    End While

    Return 1  Note: Equal
End Process

Note: Process one block in the worklist
Process called "df_process_block" takes context as Integer, bb_id as Integer returns Integer:
    Let cfg be memory_get_pointer(context, 0)
    Let bb be cfg_get_block(cfg, bb_id)

    Let state be df_get_block_state(context, bb_id)

    Note: Merge in-state from predecessors
    Let new_in be df_merge_predecessors(context, bb)

    Note: Apply transfer function
    Let new_out be df_transfer(bb, new_in)

    Note: Check if out-state changed
    Let old_out be df_state_get_out(state)
    Let changed be env_equals(new_out, old_out)

    If changed is equal to 0:
        Note: State changed - update and add successors to worklist
        Let dummy1 be df_state_set_in(state, new_in)
        Let dummy2 be df_state_set_out(state, new_out)

        Note: Add all successors to worklist
        Let succs be memory_get_pointer(bb, 40)
        Let succ_count be memory_get_int32(bb, 48)

        Let worklist be memory_get_pointer(context, 16)

        Let i be 0
        While i is less than succ_count:
            Let succ_offset be i multiplied by 4
            Let succ_id be memory_get_int32(succs, succ_offset)

            Note: Add to worklist if not already there
            Let dummy3 be list_append(worklist, succ_id)

            Set i to i plus 1
        End While

        Return 1  Note: Changed
    End If

    Return 0  Note: No change
End Process

Note: Run fixed-point iteration
Note: Returns 1 if converged, 0 if max iterations exceeded
Process called "df_analyze" takes context as Integer returns Integer:
    Let max_iterations be 100
    Let iteration_count be 0

    Let worklist be memory_get_pointer(context, 16)

    While list_length(worklist) is greater than 0:
        If iteration_count is greater than or equal to max_iterations:
            Display "WARNING: Data flow analysis did not converge after ", integer_to_string(max_iterations), " iterations"
            Return 0  Note: Did not converge
        End If

        Note: Pop first block from worklist
        Let bb_id be list_get(worklist, 0)
        Let dummy be list_remove(worklist, 0)

        Note: Process block
        Let changed be df_process_block(context, bb_id)

        Set iteration_count to iteration_count plus 1
    End While

    memory_set_int32(context, 24, iteration_count)

    Display "Data flow analysis converged after ", integer_to_string(iteration_count), " iterations"
    Return 1  Note: Converged
End Process

Note: Get final range for a variable
Process called "df_get_variable_range" takes context as Integer, var_name as Integer returns Integer:
    Note: Look through all blocks and union the ranges
    Let cfg be memory_get_pointer(context, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Let result_range be range_create(0, 0)  Note: Start with [0, 0]
    Let found_any be 0

    Let i be 0
    While i is less than block_count:
        Let state be df_get_block_state(context, i)
        Let out_env be df_state_get_out(state)

        Let range be var_env_lookup(out_env, var_name)
        Let is_unknown be range_is_unknown(range)

        If is_unknown is equal to 0:
            If found_any is equal to 0:
                Set result_range to range
                Set found_any to 1
            Otherwise:
                Set result_range to range_union(result_range, range)
            End If
        End If

        Set i to i plus 1
    End While

    If found_any is equal to 0:
        Return range_create_unknown()
    End If

    Return result_range
End Process

Note: Analyze entire function
Note: Returns mapping of variable names to their inferred ranges
Process called "analyze_function" takes stmt_list as Integer returns Integer:
    Note: Build CFG
    Let cfg be build_cfg(stmt_list)

    Note: Create data flow context
    Let context be df_context_create(cfg)

    Note: Run fixed-point analysis
    Let converged be df_analyze(context)

    If converged is equal to 0:
        Display "WARNING: Analysis did not converge, using conservative types"
    End If

    Return context
End Process

Note: Print analysis results for debugging
Process called "df_print_results" takes context as Integer returns Integer:
    Display "=== Data Flow Analysis Results ==="

    Let cfg be memory_get_pointer(context, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Let i be 0
    While i is less than block_count:
        Display "Block ", integer_to_string(i), ":"

        Let state be df_get_block_state(context, i)
        Let in_env be df_state_get_in(state)
        Let out_env be df_state_get_out(state)

        Display "  IN state:"
        Note: TODO: Print environment

        Display "  OUT state:"
        Note: TODO: Print environment

        Set i to i plus 1
    End While

    Return 0
End Process

Note: ===== BACKWARD PROPAGATION =====

Note: Refine ranges based on conditional constraints
Note: When we see "If x is less than 10", we know in the then-branch: x is in [min, 9]

Note: Token constants for comparison operators
Let TOKEN_IS be 21
Let TOKEN_EQUAL be 22
Let TOKEN_NOT_EQUAL be 23
Let TOKEN_LESS be 24
Let TOKEN_GREATER be 25
Let TOKEN_GREATER_EQUAL be 26
Let TOKEN_LESS_EQUAL be 27

Note: Refine variable range from condition (for then-branch)
Process called "refine_from_condition" takes condition as Integer, env as Integer, is_then_branch as Integer returns Integer:
    Let expr_type be memory_get_int32(condition, 0)
    Let EXPR_BINARY_OP be 3

    If expr_type is not equal to EXPR_BINARY_OP:
        Note: Not a comparison - no refinement
        Return env
    End If

    Note: Get comparison components
    Let left be memory_get_pointer(condition, 8)
    Let op be memory_get_int32(condition, 16)
    Let right be memory_get_pointer(condition, 24)

    Note: Check if left is a simple identifier
    Let left_type be memory_get_int32(left, 0)
    Let EXPR_IDENTIFIER be 2

    If left_type is not equal to EXPR_IDENTIFIER:
        Note: Left is not a simple variable - skip refinement
        Return env
    End If

    Let var_name be memory_get_pointer(left, 8)

    Note: Compute range of right side
    Let right_range be infer_expression_range(right, env)
    Let right_is_unknown be range_is_unknown(right_range)

    If right_is_unknown is equal to 1:
        Note: Right side unknown - can't refine
        Return env
    End If

    Let right_min be range_get_min(right_range)
    Let right_max be range_get_max(right_range)

    Note: Get current variable range
    Let var_range be var_env_lookup(env, var_name)
    Let var_min be range_get_min(var_range)
    Let var_max be range_get_max(var_range)

    Note: Refine based on operator and branch
    If is_then_branch is equal to 1:
        Note: THEN branch: condition is true
        If op is equal to TOKEN_LESS:
            Note: x < right_max means x <= right_max - 1
            Let new_max be right_max minus 1
            If new_max is less than var_max:
                Let refined_range be range_create(var_min, new_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_LESS_EQUAL:
            Note: x <= right_max
            If right_max is less than var_max:
                Let refined_range be range_create(var_min, right_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_GREATER:
            Note: x > right_min means x >= right_min + 1
            Let new_min be right_min plus 1
            If new_min is greater than var_min:
                Let refined_range be range_create(new_min, var_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_GREATER_EQUAL:
            Note: x >= right_min
            If right_min is greater than var_min:
                Let refined_range be range_create(right_min, var_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_EQUAL:
            Note: x == right means x is in [right_min, right_max]
            Let refined_range be range_intersect(var_range, right_range)
            Let dummy be var_env_set(env, var_name, refined_range)

        End If

    Otherwise:
        Note: ELSE branch: condition is false (negate the condition)
        If op is equal to TOKEN_LESS:
            Note: NOT (x < right_max) means x >= right_max
            If right_max is greater than var_min:
                Let refined_range be range_create(right_max, var_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_LESS_EQUAL:
            Note: NOT (x <= right_max) means x > right_max
            Let new_min be right_max plus 1
            If new_min is greater than var_min:
                Let refined_range be range_create(new_min, var_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_GREATER:
            Note: NOT (x > right_min) means x <= right_min
            If right_min is less than var_max:
                Let refined_range be range_create(var_min, right_min)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_GREATER_EQUAL:
            Note: NOT (x >= right_min) means x < right_min
            Let new_max be right_min minus 1
            If new_max is less than var_max:
                Let refined_range be range_create(var_min, new_max)
                Let dummy be var_env_set(env, var_name, refined_range)
            End If

        Otherwise If op is equal to TOKEN_NOT_EQUAL:
            Note: NOT (x != right) means x == right
            Let refined_range be range_intersect(var_range, right_range)
            Let dummy be var_env_set(env, var_name, refined_range)

        End If
    End If

    Return env
End Process

Note: Enhanced transfer function that performs backward propagation
Process called "df_transfer_with_refinement" takes bb as Integer, in_env as Integer, cfg as Integer, bb_id as Integer returns Integer:
    Note: Start with copy of in-state
    Let out_env be var_env_copy(in_env)

    Note: Apply each statement in block
    Let stmts be memory_get_pointer(bb, 8)
    Let stmt_count be memory_get_int32(bb, 16)

    Let i be 0
    While i is less than stmt_count:
        Let offset be i multiplied by 8
        Let stmt be memory_get_pointer(stmts, offset)
        Let stmt_type be memory_get_int32(stmt, 0)

        Let STMT_IF be 3

        Note: Check for If statement with condition refinement
        If stmt_type is equal to STMT_IF:
            Let condition be memory_get_pointer(stmt, 8)

            Note: Get successors to identify then/else branches
            Let succ_count be memory_get_int32(bb, 48)
            Let succs be memory_get_pointer(bb, 40)

            If succ_count is greater than or equal to 2:
                Let then_bb_id be memory_get_int32(succs, 0)
                Let else_bb_id be memory_get_int32(succs, 4)

                Note: Refine environment for each branch
                Note: (This refinement will be picked up when those blocks are processed)
                Note: For now, just continue with normal analysis
            End If
        End If

        Note: Analyze statement and update environment
        Set out_env to analyze_statement(stmt, out_env)

        Set i to i plus 1
    End While

    Return out_env
End Process

Note: Enhanced merge that applies backward refinement from conditionals
Process called "df_merge_with_refinement" takes context as Integer, bb as Integer, bb_id as Integer, cfg as Integer returns Integer:
    Let preds be memory_get_pointer(bb, 24)
    Let pred_count be memory_get_int32(bb, 32)

    If pred_count is equal to 0:
        Return var_env_create()
    End If

    Note: Check if this block is part of an If statement
    Note: If predecessor has 2 successors and this is one of them, we can refine

    Let merged_env be var_env_create()
    Let first be 1

    Let i be 0
    While i is less than pred_count:
        Let pred_offset be i multiplied by 4
        Let pred_id be memory_get_int32(preds, pred_offset)
        Let pred_bb be cfg_get_block(cfg, pred_id)
        Let pred_state be df_get_block_state(context, pred_id)
        Let pred_out be df_state_get_out(pred_state)

        Note: Check if predecessor is a branch point
        Let pred_succ_count be memory_get_int32(pred_bb, 48)

        If pred_succ_count is greater than or equal to 2:
            Note: Predecessor is a branch - check if it has condition
            Let pred_stmts be memory_get_pointer(pred_bb, 8)
            Let pred_stmt_count be memory_get_int32(pred_bb, 16)

            Note: Look for If statement in predecessor
            Let j be 0
            While j is less than pred_stmt_count:
                Let stmt_offset be j multiplied by 8
                Let pred_stmt be memory_get_pointer(pred_stmts, stmt_offset)
                Let stmt_type be memory_get_int32(pred_stmt, 0)

                Let STMT_IF be 3
                If stmt_type is equal to STMT_IF:
                    Let condition be memory_get_pointer(pred_stmt, 8)

                    Note: Determine if this is then or else branch
                    Let pred_succs be memory_get_pointer(pred_bb, 40)
                    Let first_succ_id be memory_get_int32(pred_succs, 0)

                    Let is_then_branch be 0
                    If first_succ_id is equal to bb_id:
                        Set is_then_branch to 1
                    End If

                    Note: Refine environment based on condition
                    Let refined_env be var_env_copy(pred_out)
                    Set refined_env to refine_from_condition(condition, refined_env, is_then_branch)

                    Note: Merge this refined environment
                    If first is equal to 1:
                        Set merged_env to refined_env
                        Set first to 0
                    Otherwise:
                        Set merged_env to var_env_merge(merged_env, refined_env)
                    End If
                End If

                Set j to j plus 1
            End While
        Otherwise:
            Note: Regular predecessor - just merge
            If first is equal to 1:
                Set merged_env to var_env_copy(pred_out)
                Set first to 0
            Otherwise:
                Set merged_env to var_env_merge(merged_env, pred_out)
            End If
        End If

        Set i to i plus 1
    End While

    Return merged_env
End Process

Note: Process block with backward propagation
Process called "df_process_block_refined" takes context as Integer, bb_id as Integer returns Integer:
    Let cfg be memory_get_pointer(context, 0)
    Let bb be cfg_get_block(cfg, bb_id)
    Let state be df_get_block_state(context, bb_id)

    Note: Merge in-state from predecessors WITH refinement
    Let new_in be df_merge_with_refinement(context, bb, bb_id, cfg)

    Note: Apply transfer function
    Let new_out be df_transfer_with_refinement(bb, new_in, cfg, bb_id)

    Note: Check if out-state changed
    Let old_out be df_state_get_out(state)
    Let changed be env_equals(new_out, old_out)

    If changed is equal to 0:
        Let dummy1 be df_state_set_in(state, new_in)
        Let dummy2 be df_state_set_out(state, new_out)

        Note: Add all successors to worklist
        Let succs be memory_get_pointer(bb, 40)
        Let succ_count be memory_get_int32(bb, 48)
        Let worklist be memory_get_pointer(context, 16)

        Let i be 0
        While i is less than succ_count:
            Let succ_offset be i multiplied by 4
            Let succ_id be memory_get_int32(succs, succ_offset)
            Let dummy3 be list_append(worklist, succ_id)
            Set i to i plus 1
        End While

        Return 1
    End If

    Return 0
End Process

Note: Run analysis with backward propagation
Process called "df_analyze_with_backward_prop" takes context as Integer returns Integer:
    Let max_iterations be 100
    Let iteration_count be 0
    Let worklist be memory_get_pointer(context, 16)

    While list_length(worklist) is greater than 0:
        If iteration_count is greater than or equal to max_iterations:
            Display "WARNING: Data flow analysis did not converge after ", integer_to_string(max_iterations), " iterations"
            Return 0
        End If

        Let bb_id be list_get(worklist, 0)
        Let dummy be list_remove(worklist, 0)

        Let changed be df_process_block_refined(context, bb_id)

        Set iteration_count to iteration_count plus 1
    End While

    memory_set_int32(context, 24, iteration_count)
    Display "Data flow analysis (with refinement) converged after ", integer_to_string(iteration_count), " iterations"

    Return 1
End Process
