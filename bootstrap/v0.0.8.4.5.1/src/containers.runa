Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Container implementations
Note: Transliterated from containers.c - line-by-line preservation

Note: ==== Vector Implementation ====

Note: Vector structure:
Note: offset 0: items (pointer to array of pointers)
Note: offset 8: capacity
Note: offset 16: size
Note: offset 24: free_item function pointer

Process called "vector_create" takes dummy as Integer returns Integer:
    Let initial_cap be 16
    Let result be vector_create_with_capacity(initial_cap)
    Return result
End Process

Process called "vector_create_with_capacity" takes initial_capacity as Integer returns Integer:
    Let vec be memory_allocate(32)  Note: sizeof(Vector) = 32
    If vec is equal to 0:
        Return 0
    End If

    Let items_size be initial_capacity multiplied by 8  Note: sizeof(void*) = 8
    Let items be memory_allocate(items_size)
    If items is equal to 0:
        deallocate(vec)
        Return 0
    End If

    memory_set_pointer(vec, 0, items)           Note: vec->items = items
    memory_set_int32(vec, 8, initial_capacity) Note: vec->capacity = initial_capacity
    memory_set_int32(vec, 16, 0)              Note: vec->size = 0
    memory_set_pointer(vec, 24, 0)              Note: vec->free_item = NULL
    Return vec
End Process

Process called "vector_create_with_destructor" takes free_item as Integer returns Integer:
    Let vec be vector_create()
    If vec is not equal to 0:
        memory_set_integer(vec, 24, free_item)  Note: vec->free_item = free_item
    End If
    Return vec
End Process

Process called "vector_destroy" takes vec as Integer returns Integer:
    If vec is equal to 0:
        Return 0
    End If

    Let free_item be memory_get_pointer(vec, 24)
    If free_item is not equal to 0:
        Let size be memory_get_integer(vec, 16)
        Let items be memory_get_pointer(vec, 0)
        Let i be 0
        While i is less than size:
            Let item_offset be i multiplied by 8
            Let item be memory_get_pointer(items, item_offset)
            If item is not equal to 0:
                Note: call_function_pointer(free_item, item)
            End If
            Set i to i plus 1
        End While
    End If

    Let items be memory_get_pointer(vec, 0)
    deallocate(items)
    deallocate(vec)
    Return 0
End Process

Process called "vector_push" takes vec as Integer, item as Integer returns Integer:
    If vec is equal to 0:
        Return 0  Note: false
    End If

    Let size be memory_get_integer(vec, 16)
    Let capacity be memory_get_integer(vec, 8)

    If size is greater than or equal to capacity:
        Let new_capacity be capacity multiplied by 2
        Let new_size be new_capacity multiplied by 8
        Let items be memory_get_pointer(vec, 0)
        Let new_items be memory_reallocate(items, new_size)
        If new_items is equal to 0:
            Return 0  Note: false
        End If

        memory_set_pointer(vec, 0, new_items)       Note: vec->items = new_items
        memory_set_int32(vec, 8, new_capacity)    Note: vec->capacity = new_capacity
    End If

    Let items be memory_get_pointer(vec, 0)
    Let item_offset be size multiplied by 8
    memory_set_pointer(items, item_offset, item)    Note: vec->items[size] = item

    Set size to size plus 1
    memory_set_int32(vec, 16, size)               Note: vec->size++
    Return 1  Note: true
End Process

Process called "vector_pop" takes vec as Integer returns Integer:
    If vec is equal to 0:
        Return 0
    End If

    Let size be memory_get_integer(vec, 16)
    If size is equal to 0:
        Return 0
    End If

    Set size to size minus 1
    memory_set_int32(vec, 16, size)    Note: --vec->size

    Let items be memory_get_pointer(vec, 0)
    Let item_offset be size multiplied by 8
    Let item be memory_get_pointer(items, item_offset)
    Return item
End Process

Process called "vector_get" takes vec as Integer, index as Integer returns Integer:
    If vec is equal to 0:
        Return 0
    End If

    Let size be memory_get_integer(vec, 16)
    If index is greater than or equal to size:
        Return 0
    End If

    Let items be memory_get_pointer(vec, 0)
    Let item_offset be index multiplied by 8
    Let item be memory_get_pointer(items, item_offset)
    Return item
End Process

Process called "vector_set" takes vec as Integer, index as Integer, item as Integer returns Integer:
    If vec is equal to 0:
        Return 0  Note: false
    End If

    Let size be memory_get_integer(vec, 16)
    If index is greater than or equal to size:
        Return 0  Note: false
    End If

    Let free_item be memory_get_pointer(vec, 24)
    Let items be memory_get_pointer(vec, 0)
    Let item_offset be index multiplied by 8

    If free_item is not equal to 0:
        Let old_item be memory_get_pointer(items, item_offset)
        If old_item is not equal to 0:
            Note: call_function_pointer(free_item, old_item)
        End If
    End If

    memory_set_pointer(items, item_offset, item)
    Return 1  Note: true
End Process

Process called "vector_insert" takes vec as Integer, index as Integer, item as Integer returns Integer:
    If vec is equal to 0:
        Return 0  Note: false
    End If

    Let size be memory_get_integer(vec, 16)
    If index is greater than size:
        Return 0  Note: false
    End If

    Let capacity be memory_get_integer(vec, 8)
    If size is greater than or equal to capacity:
        Let new_capacity be capacity multiplied by 2
        Let new_size be new_capacity multiplied by 8
        Let items be memory_get_pointer(vec, 0)
        Let new_items be memory_reallocate(items, new_size)
        If new_items is equal to 0:
            Return 0  Note: false
        End If

        memory_set_pointer(vec, 0, new_items)
        memory_set_integer(vec, 8, new_capacity)
    End If

    Note: Shift elements to the right
    Let items be memory_get_pointer(vec, 0)
    Let i be size
    While i is greater than index:
        Let i_minus_1 be i minus 1
        Let src_offset be i_minus_1 multiplied by 8
        Let dst_offset be i multiplied by 8
        Let value be memory_get_pointer(items, src_offset)
        memory_set_pointer(items, dst_offset, value)
        Set i to i minus 1
    End While

    Let item_offset be index multiplied by 8
    memory_set_pointer(items, item_offset, item)

    Set size to size plus 1
    memory_set_integer(vec, 16, size)
    Return 1  Note: true
End Process

Process called "vector_remove" takes vec as Integer, index as Integer returns Integer:
    If vec is equal to 0:
        Return 0  Note: false
    End If

    Let size be memory_get_integer(vec, 16)
    If index is greater than or equal to size:
        Return 0  Note: false
    End If

    Let free_item be memory_get_pointer(vec, 24)
    Let items be memory_get_pointer(vec, 0)

    If free_item is not equal to 0:
        Let item_offset be index multiplied by 8
        Let old_item be memory_get_pointer(items, item_offset)
        If old_item is not equal to 0:
            Note: call_function_pointer(free_item, old_item)
        End If
    End If

    Note: Shift elements to the left
    Let size_minus_1 be size minus 1
    Let i be index
    While i is less than size_minus_1:
        Let i_plus_1 be i plus 1
        Let src_offset be i_plus_1 multiplied by 8
        Let dst_offset be i multiplied by 8
        Let value be memory_get_pointer(items, src_offset)
        memory_set_pointer(items, dst_offset, value)
        Set i to i plus 1
    End While

    Set size to size_minus_1
    memory_set_integer(vec, 16, size)
    Return 1  Note: true
End Process

Process called "vector_clear" takes vec as Integer returns Integer:
    If vec is equal to 0:
        Return 0
    End If

    Let free_item be memory_get_pointer(vec, 24)
    If free_item is not equal to 0:
        Let size be memory_get_integer(vec, 16)
        Let items be memory_get_pointer(vec, 0)
        Let i be 0
        While i is less than size:
            Let item_offset be i multiplied by 8
            Let item be memory_get_pointer(items, item_offset)
            If item is not equal to 0:
                Note: call_function_pointer(free_item, item)
            End If
            Set i to i plus 1
        End While
    End If

    memory_set_int32(vec, 16, 0)  Note: vec->size = 0
    Return 0
End Process

Process called "vector_size" takes vec as Integer returns Integer:
    If vec is not equal to 0:
        Return memory_get_integer(vec, 16)
    Otherwise:
        Return 0
    End If
End Process

Process called "vector_capacity" takes vec as Integer returns Integer:
    If vec is not equal to 0:
        Return memory_get_integer(vec, 8)
    Otherwise:
        Return 0
    End If
End Process

Process called "vector_is_empty" takes vec as Integer returns Integer:
    If vec is equal to 0:
        Return 1  Note: true
    End If

    Let size be memory_get_integer(vec, 16)
    If size is equal to 0:
        Return 1  Note: true
    Otherwise:
        Return 0  Note: false
    End If
End Process

Process called "vector_reserve" takes vec as Integer, new_capacity as Integer returns Integer:
    If vec is equal to 0:
        Return 0  Note: false
    End If

    Let capacity be memory_get_integer(vec, 8)
    If new_capacity is less than or equal to capacity:
        Return 0  Note: false
    End If

    Let new_size be new_capacity multiplied by 8
    Let items be memory_get_pointer(vec, 0)
    Let new_items be memory_reallocate(items, new_size)
    If new_items is equal to 0:
        Return 0  Note: false
    End If

    memory_set_pointer(vec, 0, new_items)
    memory_set_integer(vec, 8, new_capacity)
    Return 1  Note: true
End Process

Process called "vector_shrink_to_fit" takes vec as Integer returns Integer:
    If vec is equal to 0:
        Return 1  Note: true
    End If

    Let size be memory_get_integer(vec, 16)
    Let capacity be memory_get_integer(vec, 8)
    If size is equal to capacity:
        Return 1  Note: true
    End If

    Let new_size be size multiplied by 8
    Let items be memory_get_pointer(vec, 0)
    Let new_items be memory_reallocate(items, new_size)

    Note: Check if realloc failed and size > 0
    Let failed be 0
    If new_items is equal to 0:
        If size is greater than 0:
            Set failed to 1
        End If
    End If

    If failed is equal to 1:
        Return 0  Note: false
    End If

    memory_set_pointer(vec, 0, new_items)
    memory_set_integer(vec, 8, size)
    Return 1  Note: true
End Process

Process called "vector_begin" takes vec as Integer returns Integer:
    If vec is not equal to 0:
        Return memory_get_pointer(vec, 0)
    Otherwise:
        Return 0
    End If
End Process

Process called "vector_end" takes vec as Integer returns Integer:
    If vec is not equal to 0:
        Let items be memory_get_pointer(vec, 0)
        Let size be memory_get_integer(vec, 16)
        Let offset be size multiplied by 8
        Return items plus offset
    Otherwise:
        Return 0
    End If
End Process

Process called "vector_foreach" takes vec as Integer, callback as Integer returns Integer:
    If vec is equal to 0:
        Return 0
    End If
    If callback is equal to 0:
        Return 0
    End If

    Let size be memory_get_integer(vec, 16)
    Let items be memory_get_pointer(vec, 0)
    Let i be 0
    While i is less than size:
        Let item_offset be i multiplied by 8
        Let item be memory_get_pointer(items, item_offset)
        Note: call_function_pointer(callback, item)
        Set i to i plus 1
    End While
    Return 0
End Process

Note: ==== Stack Implementation ====

Note: Stack structure:
Note: offset 0: vec (pointer to Vector)

Process called "stack_create" takes dummy as Integer returns Integer:
    Let stack be memory_allocate(8)  Note: sizeof(Stack) = 8
    If stack is equal to 0:
        Return 0
    End If

    Let vec be vector_create()
    If vec is equal to 0:
        deallocate(stack)
        Return 0
    End If

    memory_set_pointer(stack, 0, vec)
    Return stack
End Process

Process called "stack_create_with_destructor" takes free_item as Integer returns Integer:
    Let stack be memory_allocate(8)
    If stack is equal to 0:
        Return 0
    End If

    Let vec be vector_create_with_destructor(free_item)
    If vec is equal to 0:
        deallocate(stack)
        Return 0
    End If

    memory_set_pointer(stack, 0, vec)
    Return stack
End Process

Process called "stack_destroy" takes stack as Integer returns Integer:
    If stack is equal to 0:
        Return 0
    End If

    Let vec be memory_get_pointer(stack, 0)
    vector_destroy(vec)
    deallocate(stack)
    Return 0
End Process

Process called "stack_push" takes stack as Integer, item as Integer returns Integer:
    If stack is not equal to 0:
        Let vec be memory_get_pointer(stack, 0)
        Let result be vector_push(vec, item)
        Return result
    Otherwise:
        Return 0  Note: false
    End If
End Process

Process called "stack_pop" takes stack as Integer returns Integer:
    If stack is not equal to 0:
        Let vec be memory_get_pointer(stack, 0)
        Let result be vector_pop(vec)
        Return result
    Otherwise:
        Return 0
    End If
End Process

Process called "stack_peek" takes stack as Integer returns Integer:
    If stack is equal to 0:
        Return 0
    End If

    Let vec be memory_get_pointer(stack, 0)
    Let is_empty be vector_is_empty(vec)
    If is_empty is equal to 1:
        Return 0
    End If

    Let size be memory_get_integer(vec, 16)
    Let index be size minus 1
    Let result be vector_get(vec, index)
    Return result
End Process

Process called "stack_size" takes stack as Integer returns Integer:
    If stack is not equal to 0:
        Let vec be memory_get_pointer(stack, 0)
        Let result be vector_size(vec)
        Return result
    Otherwise:
        Return 0
    End If
End Process

Process called "stack_is_empty" takes stack as Integer returns Integer:
    If stack is equal to 0:
        Return 1  Note: true
    End If

    Let vec be memory_get_pointer(stack, 0)
    Let result be vector_is_empty(vec)
    Return result
End Process

Process called "stack_clear" takes stack as Integer returns Integer:
    If stack is not equal to 0:
        Let vec be memory_get_pointer(stack, 0)
        vector_clear(vec)
    End If
    Return 0
End Process

Note: ==== Queue Implementation ====

Note: Queue structure:
Note: offset 0: items (pointer to array)
Note: offset 8: capacity
Note: offset 16: front
Note: offset 24: rear
Note: offset 32: size
Note: offset 40: free_item function pointer

Process called "queue_create" takes dummy as Integer returns Integer:
    Let initial_cap be 16
    Let result be queue_create_with_capacity(initial_cap)
    Return result
End Process

Process called "queue_create_with_capacity" takes initial_capacity as Integer returns Integer:
    Let queue be memory_allocate(48)  Note: sizeof(Queue) = 48
    If queue is equal to 0:
        Return 0
    End If

    Let items_size be initial_capacity multiplied by 8
    Let items be memory_allocate(items_size)
    If items is equal to 0:
        deallocate(queue)
        Return 0
    End If

    memory_set_integer(queue, 0, items)            Note: queue->items = items
    memory_set_int32(queue, 8, initial_capacity) Note: queue->capacity = initial_capacity
    memory_set_integer(queue, 16, 0)               Note: queue->front = 0
    memory_set_integer(queue, 24, 0)               Note: queue->rear = 0
    memory_set_int32(queue, 32, 0)               Note: queue->size = 0
    memory_set_integer(queue, 40, 0)               Note: queue->free_item = NULL
    Return queue
End Process

Process called "queue_create_with_destructor" takes free_item as Integer returns Integer:
    Let queue be queue_create()
    If queue is not equal to 0:
        memory_set_integer(queue, 40, free_item)
    End If
    Return queue
End Process

Process called "queue_destroy" takes queue as Integer returns Integer:
    If queue is equal to 0:
        Return 0
    End If

    queue_clear(queue)
    Let items be memory_get_pointer(queue, 0)
    deallocate(items)
    deallocate(queue)
    Return 0
End Process

Process called "queue_enqueue" takes queue as Integer, item as Integer returns Integer:
    If queue is equal to 0:
        Return 0  Note: false
    End If

    Let size be memory_get_integer(queue, 32)
    Let capacity be memory_get_integer(queue, 8)
    If size is greater than or equal to capacity:
        Return 0  Note: false
    End If

    Let items be memory_get_pointer(queue, 0)
    Let rear be memory_get_integer(queue, 24)
    Let item_offset be rear multiplied by 8
    memory_set_pointer(items, item_offset, item)

    Note: queue->rear = (queue->rear + 1) % queue->capacity
    Let rear_plus_1 be rear plus 1
    Note: rear_plus_1 modulo capacity = rear_plus_1 - (rear_plus_1 / capacity) * capacity
    Let rear_div_cap be rear_plus_1 divided by capacity
    Let rear_mult_cap be rear_div_cap multiplied by capacity
    Let new_rear be rear_plus_1 minus rear_mult_cap
    memory_set_integer(queue, 24, new_rear)

    Set size to size plus 1
    memory_set_integer(queue, 32, size)
    Return 1  Note: true
End Process

Process called "queue_dequeue" takes queue as Integer returns Integer:
    If queue is equal to 0:
        Return 0
    End If

    Let size be memory_get_integer(queue, 32)
    If size is equal to 0:
        Return 0
    End If

    Let items be memory_get_pointer(queue, 0)
    Let front be memory_get_integer(queue, 16)
    Let item_offset be front multiplied by 8
    Let item be memory_get_pointer(items, item_offset)

    Note: queue->front = (queue->front + 1) % queue->capacity
    Let front_plus_1 be front plus 1
    Let capacity be memory_get_int32(queue, 8)
    Note: front_plus_1 modulo capacity = front_plus_1 - (front_plus_1 / capacity) * capacity
    Let front_div_cap be front_plus_1 divided by capacity
    Let front_mult_cap be front_div_cap multiplied by capacity
    Let new_front be front_plus_1 minus front_mult_cap
    memory_set_integer(queue, 16, new_front)

    Set size to size minus 1
    memory_set_integer(queue, 32, size)
    Return item
End Process

Process called "queue_peek" takes queue as Integer returns Integer:
    If queue is equal to 0:
        Return 0
    End If

    Let size be memory_get_integer(queue, 32)
    If size is equal to 0:
        Return 0
    End If

    Let items be memory_get_pointer(queue, 0)
    Let front be memory_get_integer(queue, 16)
    Let item_offset be front multiplied by 8
    Return memory_get_pointer(items, item_offset)
End Process

Process called "queue_size" takes queue as Integer returns Integer:
    If queue is not equal to 0:
        Return memory_get_integer(queue, 32)
    Otherwise:
        Return 0
    End If
End Process

Process called "queue_is_empty" takes queue as Integer returns Integer:
    If queue is equal to 0:
        Return 1  Note: true
    End If

    Let size be memory_get_integer(queue, 32)
    If size is equal to 0:
        Return 1  Note: true
    Otherwise:
        Return 0  Note: false
    End If
End Process

Process called "queue_is_full" takes queue as Integer returns Integer:
    If queue is equal to 0:
        Return 0  Note: false
    End If

    Let size be memory_get_integer(queue, 32)
    Let capacity be memory_get_integer(queue, 8)
    If size is greater than or equal to capacity:
        Return 1  Note: true
    Otherwise:
        Return 0  Note: false
    End If
End Process

Process called "queue_clear" takes queue as Integer returns Integer:
    If queue is equal to 0:
        Return 0
    End If

    Let free_item be memory_get_pointer(queue, 40)
    If free_item is not equal to 0:
        Let continue_loop be 1
        While continue_loop is equal to 1:
            Let size be memory_get_integer(queue, 32)
            If size is greater than 0:
                Let item be queue_dequeue(queue)
                If item is not equal to 0:
                    Note: call_function_pointer(free_item, item)
                End If
            Otherwise:
                Set continue_loop to 0
            End If
        End While
    Otherwise:
        memory_set_int32(queue, 32, 0)  Note: queue->size = 0
        memory_set_integer(queue, 16, 0)  Note: queue->front = 0
        memory_set_integer(queue, 24, 0)  Note: queue->rear = 0
    End If
    Return 0
End Process

Note: ==== Linked List Implementation ====

Note: ListNode structure:
Note: offset 0: data
Note: offset 8: prev
Note: offset 16: next

Note: LinkedList structure:
Note: offset 0: head
Note: offset 8: tail
Note: offset 16: size
Note: offset 24: free_item

Process called "container_list_create" takes dummy as Integer returns Integer:
    Let list be memory_allocate(32)  Note: sizeof(LinkedList) = 32
    If list is equal to 0:
        Return 0
    End If

    memory_set_pointer(list, 0, 0)   Note: list->head = NULL
    memory_set_pointer(list, 8, 0)   Note: list->tail = NULL
    memory_set_int32(list, 16, 0)  Note: list->size = 0
    memory_set_pointer(list, 24, 0)  Note: list->free_item = NULL
    Return list
End Process

Process called "list_create_with_destructor" takes free_item as Integer returns Integer:
    Let list be container_list_create()
    If list is not equal to 0:
        memory_set_integer(list, 24, free_item)
    End If
    Return list
End Process

Process called "container_list_destroy" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If

    container_list_clear(list)
    deallocate(list)
    Return 0
End Process

Process called "list_push_front" takes list as Integer, item as Integer returns Integer:
    If list is equal to 0:
        Return 0  Note: false
    End If

    Let new_node be memory_allocate(24)  Note: sizeof(ListNode) = 24
    If new_node is equal to 0:
        Return 0  Note: false
    End If

    memory_set_pointer(new_node, 0, item)  Note: new_node->data = item
    memory_set_pointer(new_node, 8, 0)     Note: new_node->prev = NULL

    Let head be memory_get_pointer(list, 0)
    memory_set_pointer(new_node, 16, head)  Note: new_node->next = list->head

    If head is not equal to 0:
        memory_set_pointer(head, 8, new_node)  Note: list->head->prev = new_node
    Otherwise:
        memory_set_pointer(list, 8, new_node)  Note: list->tail = new_node
    End If

    memory_set_pointer(list, 0, new_node)  Note: list->head = new_node

    Let size be memory_get_integer(list, 16)
    Set size to size plus 1
    memory_set_integer(list, 16, size)
    Return 1  Note: true
End Process

Process called "list_push_back" takes list as Integer, item as Integer returns Integer:
    If list is equal to 0:
        Return 0  Note: false
    End If

    Let new_node be memory_allocate(24)
    If new_node is equal to 0:
        Return 0  Note: false
    End If

    memory_set_pointer(new_node, 0, item)   Note: new_node->data = item
    memory_set_pointer(new_node, 16, 0)     Note: new_node->next = NULL

    Let tail be memory_get_pointer(list, 8)
    memory_set_pointer(new_node, 8, tail)   Note: new_node->prev = list->tail

    If tail is not equal to 0:
        memory_set_pointer(tail, 16, new_node)  Note: list->tail->next = new_node
    Otherwise:
        memory_set_pointer(list, 0, new_node)   Note: list->head = new_node
    End If

    memory_set_pointer(list, 8, new_node)  Note: list->tail = new_node

    Let size be memory_get_integer(list, 16)
    Set size to size plus 1
    memory_set_integer(list, 16, size)
    Return 1  Note: true
End Process

Process called "list_pop_front" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If

    Let head be memory_get_pointer(list, 0)
    If head is equal to 0:
        Return 0
    End If

    Let data be memory_get_pointer(head, 0)
    Let next be memory_get_pointer(head, 16)

    memory_set_pointer(list, 0, next)  Note: list->head = node->next
    If next is not equal to 0:
        memory_set_integer(next, 8, 0)  Note: list->head->prev = NULL
    Otherwise:
        memory_set_pointer(list, 8, 0)  Note: list->tail = NULL
    End If

    deallocate(head)

    Let size be memory_get_integer(list, 16)
    Set size to size minus 1
    memory_set_integer(list, 16, size)
    Return data
End Process

Process called "list_pop_back" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If

    Let tail be memory_get_pointer(list, 8)
    If tail is equal to 0:
        Return 0
    End If

    Let data be memory_get_pointer(tail, 0)
    Let prev be memory_get_pointer(tail, 8)

    memory_set_pointer(list, 8, prev)  Note: list->tail = node->prev
    If prev is not equal to 0:
        memory_set_integer(prev, 16, 0)  Note: list->tail->next = NULL
    Otherwise:
        memory_set_pointer(list, 0, 0)   Note: list->head = NULL
    End If

    deallocate(tail)

    Let size be memory_get_integer(list, 16)
    Set size to size minus 1
    memory_set_integer(list, 16, size)
    Return data
End Process

Process called "list_front" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If

    Let head be memory_get_pointer(list, 0)
    If head is not equal to 0:
        Return memory_get_pointer(head, 0)
    Otherwise:
        Return 0
    End If
End Process

Process called "list_back" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If

    Let tail be memory_get_pointer(list, 8)
    If tail is not equal to 0:
        Return memory_get_pointer(tail, 0)
    Otherwise:
        Return 0
    End If
End Process

Process called "list_insert_after" takes list as Integer, node as Integer, item as Integer returns Integer:
    If list is equal to 0:
        Return 0  Note: false
    End If
    If node is equal to 0:
        Return 0  Note: false
    End If

    Let new_node be memory_allocate(24)
    If new_node is equal to 0:
        Return 0  Note: false
    End If

    memory_set_pointer(new_node, 0, item)    Note: new_node->data = item
    memory_set_pointer(new_node, 8, node)    Note: new_node->prev = node

    Let node_next be memory_get_pointer(node, 16)
    memory_set_pointer(new_node, 16, node_next)  Note: new_node->next = node->next

    If node_next is not equal to 0:
        memory_set_pointer(node_next, 8, new_node)  Note: node->next->prev = new_node
    Otherwise:
        memory_set_pointer(list, 8, new_node)       Note: list->tail = new_node
    End If

    memory_set_pointer(node, 16, new_node)  Note: node->next = new_node

    Let size be memory_get_integer(list, 16)
    Set size to size plus 1
    memory_set_integer(list, 16, size)
    Return 1  Note: true
End Process

Process called "list_insert_before" takes list as Integer, node as Integer, item as Integer returns Integer:
    If list is equal to 0:
        Return 0  Note: false
    End If
    If node is equal to 0:
        Return 0  Note: false
    End If

    Let new_node be memory_allocate(24)
    If new_node is equal to 0:
        Return 0  Note: false
    End If

    memory_set_pointer(new_node, 0, item)     Note: new_node->data = item
    memory_set_pointer(new_node, 16, node)    Note: new_node->next = node

    Let node_prev be memory_get_pointer(node, 8)
    memory_set_pointer(new_node, 8, node_prev)  Note: new_node->prev = node->prev

    If node_prev is not equal to 0:
        memory_set_pointer(node_prev, 16, new_node)  Note: node->prev->next = new_node
    Otherwise:
        memory_set_pointer(list, 0, new_node)        Note: list->head = new_node
    End If

    memory_set_pointer(node, 8, new_node)  Note: node->prev = new_node

    Let size be memory_get_integer(list, 16)
    Set size to size plus 1
    memory_set_integer(list, 16, size)
    Return 1  Note: true
End Process

Process called "list_remove_node" takes list as Integer, node as Integer returns Integer:
    If list is equal to 0:
        Return 0  Note: false
    End If
    If node is equal to 0:
        Return 0  Note: false
    End If

    Let prev be memory_get_pointer(node, 8)
    Let next be memory_get_pointer(node, 16)

    If prev is not equal to 0:
        memory_set_pointer(prev, 16, next)  Note: node->prev->next = node->next
    Otherwise:
        memory_set_pointer(list, 0, next)   Note: list->head = node->next
    End If

    If next is not equal to 0:
        memory_set_pointer(next, 8, prev)   Note: node->next->prev = node->prev
    Otherwise:
        memory_set_pointer(list, 8, prev)   Note: list->tail = node->prev
    End If

    Let free_item be memory_get_pointer(list, 24)
    If free_item is not equal to 0:
        Let data be memory_get_pointer(node, 0)
        If data is not equal to 0:
            Note: call_function_pointer(free_item, data)
        End If
    End If

    deallocate(node)

    Let size be memory_get_integer(list, 16)
    Set size to size minus 1
    memory_set_integer(list, 16, size)
    Return 1  Note: true
End Process

Process called "container_list_find" takes list as Integer, item as Integer, compare as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If
    If compare is equal to 0:
        Return 0
    End If

    Let current be memory_get_pointer(list, 0)
    While current is not equal to 0:
        Let data be memory_get_pointer(current, 0)
        Let result be call_function_pointer_2args(compare, data, item)
        If result is not equal to 0:
            Return current
        End If
        Set current to memory_get_pointer(current, 16)
    End While

    Return 0
End Process

Process called "list_size" takes list as Integer returns Integer:
    If list is not equal to 0:
        Return memory_get_integer(list, 16)
    Otherwise:
        Return 0
    End If
End Process

Process called "list_is_empty" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 1  Note: true
    End If

    Let size be memory_get_integer(list, 16)
    If size is equal to 0:
        Return 1  Note: true
    Otherwise:
        Return 0  Note: false
    End If
End Process

Process called "container_list_clear" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If

    Let free_item be memory_get_pointer(list, 24)
    Let current be memory_get_pointer(list, 0)

    While current is not equal to 0:
        Let next be memory_get_pointer(current, 16)

        If free_item is not equal to 0:
            Let data be memory_get_pointer(current, 0)
            If data is not equal to 0:
                Note: call_function_pointer(free_item, data)
            End If
        End If

        deallocate(current)
        Set current to next
    End While

    memory_set_pointer(list, 0, 0)   Note: list->head = NULL
    memory_set_pointer(list, 8, 0)   Note: list->tail = NULL
    memory_set_int32(list, 16, 0)  Note: list->size = 0
    Return 0
End Process

Process called "list_begin" takes list as Integer returns Integer:
    If list is not equal to 0:
        Return memory_get_pointer(list, 0)
    Otherwise:
        Return 0
    End If
End Process

Process called "list_end" takes list as Integer returns Integer:
    Note: End is represented as NULL
    Return 0
End Process

Process called "list_next" takes node as Integer returns Integer:
    If node is not equal to 0:
        Return memory_get_pointer(node, 16)
    Otherwise:
        Return 0
    End If
End Process

Process called "list_prev" takes node as Integer returns Integer:
    If node is not equal to 0:
        Return memory_get_pointer(node, 8)
    Otherwise:
        Return 0
    End If
End Process

Process called "list_foreach" takes list as Integer, callback as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If
    If callback is equal to 0:
        Return 0
    End If

    Let current be memory_get_pointer(list, 0)
    While current is not equal to 0:
        Let data be memory_get_pointer(current, 0)
        Note: call_function_pointer(callback, data)
        Set current to memory_get_pointer(current, 16)
    End While
    Return 0
End Process

Note: ==== Set Implementation ====
Note: Note: Set is implemented using hashtable
Note: Set structure:
Note: offset 0: table (hashtable pointer)
Note: offset 8: free_item

Process called "set_create" takes hash_func as Integer, compare_func as Integer returns Integer:
    Let set be memory_allocate(16)  Note: sizeof(Set) = 16
    If set is equal to 0:
        Return 0
    End If

    Let initial_buckets be 256
    Let table be hashtable_create(initial_buckets, hash_func, compare_func)
    If table is equal to 0:
        deallocate(set)
        Return 0
    End If

    memory_set_pointer(set, 0, table)
    memory_set_integer(set, 8, 0)     Note: set->free_item = NULL
    Return set
End Process

Process called "set_create_with_destructor" takes hash_func as Integer, compare_func as Integer, free_item as Integer returns Integer:
    Let set be set_create(hash_func, compare_func)
    If set is not equal to 0:
        memory_set_integer(set, 8, free_item)
        Note: Update hash table to use destructor
        Let table be memory_get_pointer(set, 0)
        memory_set_pointer(table, 40, free_item)  Note: table->free_key = free_item
    End If
    Return set
End Process

Process called "set_destroy" takes set as Integer returns Integer:
    If set is equal to 0:
        Return 0
    End If

    Let table be memory_get_pointer(set, 0)
    hashtable_destroy(table)
    deallocate(set)
    Return 0
End Process

Process called "set_add" takes set as Integer, item as Integer returns Integer:
    If set is equal to 0:
        Return 0  Note: false
    End If

    Let table be memory_get_pointer(set, 0)
    Note: In a set, key and value are the same
    Let result be hashtable_put(table, item, item)
    Return result
End Process

Process called "set_remove" takes set as Integer, item as Integer returns Integer:
    If set is not equal to 0:
        Let table be memory_get_pointer(set, 0)
        Let result be hashtable_remove(table, item)
        Return result
    Otherwise:
        Return 0  Note: false
    End If
End Process

Process called "set_contains" takes set as Integer, item as Integer returns Integer:
    If set is not equal to 0:
        Let table be memory_get_pointer(set, 0)
        Let result be hashtable_contains(table, item)
        Return result
    Otherwise:
        Return 0  Note: false
    End If
End Process

Process called "set_size" takes set as Integer returns Integer:
    If set is not equal to 0:
        Let table be memory_get_pointer(set, 0)
        Let result be hashtable_size(table)
        Return result
    Otherwise:
        Return 0
    End If
End Process

Process called "set_is_empty" takes set as Integer returns Integer:
    If set is equal to 0:
        Return 1  Note: true
    End If

    Let table be memory_get_pointer(set, 0)
    Let size be hashtable_size(table)
    If size is equal to 0:
        Return 1  Note: true
    Otherwise:
        Return 0  Note: false
    End If
End Process

Process called "set_clear" takes set as Integer returns Integer:
    If set is not equal to 0:
        Let table be memory_get_pointer(set, 0)
        hashtable_clear(table)
    End If
    Return 0
End Process

Note: Note: Set union/intersection/difference operations would require hashtable_iterator
Note: which isn't available in v0.0.7.3. These would need to be added later.

Note: ==== Utility Functions ====

Process called "free_string_item" takes item as Integer returns Integer:
    deallocate(item)
    Return 0
End Process

Process called "free_integer_item" takes item as Integer returns Integer:
    deallocate(item)
    Return 0
End Process