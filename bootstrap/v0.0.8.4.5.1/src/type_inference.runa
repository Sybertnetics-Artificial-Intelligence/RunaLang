Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Type Inference - Compute ranges for expressions
Note: This module analyzes AST expressions and determines their value ranges

Note: Import range analysis functions (conceptually - will be linked)
Note: Import AST constants from parser

Note: Expression type constants (from parser)
Let EXPR_INTEGER_LITERAL be 0
Let EXPR_STRING_LITERAL be 1
Let EXPR_IDENTIFIER be 2
Let EXPR_BINARY_OP be 3
Let EXPR_FUNCTION_CALL be 4
Let EXPR_UNARY_MINUS be 5
Let EXPR_ARRAY_INDEX be 6
Let EXPR_FIELD_ACCESS be 7
Let EXPR_ARRAY_LITERAL be 8
Let EXPR_LAMBDA be 9
Let EXPR_LAMBDA_CALL be 24
Let EXPR_CAST be 25  Note: New: cast expression

Note: Binary operation tokens (from lexer)
Let TOKEN_PLUS be 16
Let TOKEN_MINUS be 17
Let TOKEN_MULTIPLIED be 35
Let TOKEN_DIVIDED be 36
Let TOKEN_MODULO be 37
Let TOKEN_BIT_AND be 39
Let TOKEN_BIT_OR be 40
Let TOKEN_BIT_XOR be 41
Let TOKEN_BIT_SHIFT_LEFT be 42
Let TOKEN_BIT_SHIFT_RIGHT be 43
Let TOKEN_IS be 21
Let TOKEN_EQUAL be 22
Let TOKEN_NOT_EQUAL be 23
Let TOKEN_LESS be 24
Let TOKEN_GREATER be 25
Let TOKEN_GREATER_EQUAL be 26
Let TOKEN_LESS_EQUAL be 27

Note: Variable environment - maps variable names to ranges
Note: Structure: hash table of (name: String -> range: Range)
Note: For now, use simple list of (name, range) pairs

Note: Create empty variable environment
Process called "var_env_create" returns Integer:
    Note: Environment: list of (name_ptr, range_ptr) pairs
    Note: Structure: capacity(int32 at 0), size(int32 at 4), entries(ptr at 8)
    Let env be allocate(16)
    Let initial_capacity be 32
    memory_set_int32(env, 0, initial_capacity)
    memory_set_int32(env, 4, 0)  Note: size = 0

    Note: Allocate entries array (each entry is 16 bytes: name_ptr + range_ptr)
    Let entries_size be initial_capacity multiplied by 16
    Let entries be allocate(entries_size)
    memory_set_pointer(env, 8, entries)

    Return env
End Process

Note: Look up variable range in environment
Process called "var_env_lookup" takes env as Integer, name as Integer returns Integer:
    Let size be memory_get_int32(env, 4)
    Let entries be memory_get_pointer(env, 8)

    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 16
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let range_offset be entry_offset plus 8
            Let range be memory_get_pointer(entries, range_offset)
            Return range
        End If

        Set i to i plus 1
    End While

    Note: Not found - return unknown range
    Return range_create_unknown()
End Process

Note: Set variable range in environment
Process called "var_env_set" takes env as Integer, name as Integer, range as Integer returns Integer:
    Let size be memory_get_int32(env, 4)
    Let capacity be memory_get_int32(env, 0)
    Let entries be memory_get_pointer(env, 8)

    Note: Check if variable already exists - update it
    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 16
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let range_offset be entry_offset plus 8
            memory_set_pointer(entries, range_offset, range)
            Return env
        End If

        Set i to i plus 1
    End While

    Note: Variable not found - add new entry
    Note: TODO: Handle capacity expansion if size == capacity
    If size is equal to capacity:
        Display "ERROR: Variable environment capacity exceeded"
        exit_with_code(1)
    End If

    Let entry_offset be size multiplied by 16
    memory_set_pointer(entries, entry_offset, name)
    Let range_offset be entry_offset plus 8
    memory_set_pointer(entries, range_offset, range)

    Let new_size be size plus 1
    memory_set_int32(env, 4, new_size)

    Return env
End Process

Note: Copy environment (for branch analysis)
Process called "var_env_copy" takes env as Integer returns Integer:
    Let capacity be memory_get_int32(env, 0)
    Let size be memory_get_int32(env, 4)
    Let old_entries be memory_get_pointer(env, 8)

    Let new_env be allocate(16)
    memory_set_int32(new_env, 0, capacity)
    memory_set_int32(new_env, 4, size)

    Let entries_size be capacity multiplied by 16
    Let new_entries be allocate(entries_size)
    memory_set_pointer(new_env, 8, new_entries)

    Note: Copy all entries
    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 16
        Let name be memory_get_pointer(old_entries, entry_offset)
        Let range be memory_get_pointer(old_entries, entry_offset plus 8)

        memory_set_pointer(new_entries, entry_offset, name)
        memory_set_pointer(new_entries, entry_offset plus 8, range_copy(range))

        Set i to i plus 1
    End While

    Return new_env
End Process

Note: Merge two environments (union ranges for each variable)
Process called "var_env_merge" takes env1 as Integer, env2 as Integer returns Integer:
    Let result be var_env_copy(env1)

    Let size2 be memory_get_int32(env2, 4)
    Let entries2 be memory_get_pointer(env2, 8)

    Let i be 0
    While i is less than size2:
        Let entry_offset be i multiplied by 16
        Let name be memory_get_pointer(entries2, entry_offset)
        Let range2 be memory_get_pointer(entries2, entry_offset plus 8)

        Note: Look up in env1
        Let range1 be var_env_lookup(env1, name)

        Note: Union the ranges
        Let merged_range be range_union(range1, range2)

        Note: Update result
        Let dummy be var_env_set(result, name, merged_range)

        Set i to i plus 1
    End While

    Return result
End Process

Note: Compute range for an expression (without function table)
Process called "infer_expression_range" takes expr as Integer, env as Integer returns Integer:
    Note: Call full version with null function table
    Return infer_expression_range_full(expr, env, 0)
End Process

Note: Compute range for an expression with optional function table
Process called "infer_expression_range_full" takes expr as Integer, env as Integer, func_table as Integer returns Integer:
    Let expr_type be memory_get_int32(expr, 0)

    If expr_type is equal to EXPR_INTEGER_LITERAL:
        Note: Expression: type(int32), value_string(ptr at 8)
        Let value_str be memory_get_pointer(expr, 8)

        Note: Check for binary literal (0b prefix)
        Let first_char be memory_get_byte(value_str, 0)
        Let second_char be memory_get_byte(value_str, 1)
        If first_char is equal to 48:  Note: '0'
            If second_char is equal to 98:  Note: 'b'
                Note: Binary literal - parse it
                Let value be parse_binary_literal(value_str)
                Return range_create(value, value)
            End If
        End If

        Note: Regular decimal literal
        Let value be string_to_integer(value_str)
        Return range_create(value, value)

    Otherwise If expr_type is equal to EXPR_IDENTIFIER:
        Note: Expression: type(int32), name(ptr at 8)
        Let name be memory_get_pointer(expr, 8)
        Return var_env_lookup(env, name)

    Otherwise If expr_type is equal to EXPR_BINARY_OP:
        Note: Expression: type(int32), left(ptr at 8), op(int32 at 16), right(ptr at 24)
        Let left be memory_get_pointer(expr, 8)
        Let op be memory_get_int32(expr, 16)
        Let right be memory_get_pointer(expr, 24)

        Let left_range be infer_expression_range_full(left, env, func_table)
        Let right_range be infer_expression_range_full(right, env, func_table)

        If op is equal to TOKEN_PLUS:
            Return range_add(left_range, right_range)
        Otherwise If op is equal to TOKEN_MINUS:
            Return range_subtract(left_range, right_range)
        Otherwise If op is equal to TOKEN_MULTIPLIED:
            Return range_multiply(left_range, right_range)
        Otherwise If op is equal to TOKEN_DIVIDED:
            Return range_divide(left_range, right_range)
        Otherwise If op is equal to TOKEN_MODULO:
            Return range_modulo(left_range, right_range)
        Otherwise If op is equal to TOKEN_BIT_AND:
            Note: Bitwise AND - result bounded by min of operands
            Return range_bitwise_and(left_range, right_range)
        Otherwise If op is equal to TOKEN_BIT_OR:
            Return range_bitwise_or(left_range, right_range)
        Otherwise If op is equal to TOKEN_BIT_XOR:
            Return range_bitwise_xor(left_range, right_range)
        Otherwise:
            Note: Comparison operators return 0 or 1
            Return range_create(0, 1)
        End If

    Otherwise If expr_type is equal to EXPR_UNARY_MINUS:
        Note: Expression: type(int32), operand(ptr at 8)
        Let operand be memory_get_pointer(expr, 8)
        Let operand_range be infer_expression_range_full(operand, env, func_table)

        Let is_unknown be range_is_unknown(operand_range)
        If is_unknown is equal to 1:
            Return range_create_unknown()
        End If

        Let min be range_get_min(operand_range)
        Let max be range_get_max(operand_range)

        Note: Negate: [-max, -min]
        Let neg_max be 0 minus max
        Let neg_min be 0 minus min
        Return range_create(neg_max, neg_min)

    Otherwise If expr_type is equal to EXPR_CAST:
        Note: Cast expression: type(int32), expr(ptr at 8), target_type(ptr at 16)
        Let inner_expr be memory_get_pointer(expr, 8)
        Let target_type be memory_get_pointer(expr, 16)

        Note: Compute range of inner expression
        Let inner_range be infer_expression_range_full(inner_expr, env, func_table)

        Note: Cast doesn't change the VALUE, just the type
        Note: But we need to check if it fits
        Let type_kind be memory_get_int32(target_type, 0)
        Let can_overflow be range_can_overflow(inner_range, type_kind)

        If can_overflow is equal to 1:
            Note: Cast may overflow - need runtime check
            Note: For now, return unknown (will be refined later)
            Return range_create_unknown()
        End If

        Return inner_range

    Otherwise If expr_type is equal to EXPR_FUNCTION_CALL:
        Note: Function call - lookup return range from function table
        Note: Expression: type(int32), function_name(ptr at 8), args(ptr at 16)
        Let function_name be memory_get_pointer(expr, 8)

        Note: If function table provided, lookup return range
        If func_table is not equal to 0:
            Return func_table_lookup(func_table, function_name)
        Otherwise:
            Note: No function table - return unknown
            Return range_create_unknown()
        End If

    Otherwise:
        Note: Unknown expression type
        Return range_create_unknown()
    End If

    Return range_create_unknown()
End Process

Note: Parse binary literal string (0b10110101) to integer
Process called "parse_binary_literal" takes str as Integer returns Integer:
    Let result be 0
    Let len be string_length(str)

    Note: Skip "0b" prefix
    Let i be 2
    While i is less than len:
        Let char be memory_get_byte(str, i)

        Note: Shift result left by 1
        Set result to result multiplied by 2

        Note: Add bit value (char - '0')
        Let bit be char minus 48
        Set result to result plus bit

        Set i to i plus 1
    End While

    Return result
End Process

Note: Bitwise AND range (conservative)
Process called "range_bitwise_and" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_max be range_get_max(a)
    Let b_max be range_get_max(b)

    Note: AND result is at most the smaller of the two maxes
    Let result_max be a_max
    If b_max is less than result_max:
        Set result_max to b_max
    End If

    Note: Minimum is 0 if either can be 0
    Return range_create(0, result_max)
End Process

Note: Bitwise OR range (conservative)
Process called "range_bitwise_or" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_max be range_get_max(a)
    Let b_max be range_get_max(b)
    Let a_min be range_get_min(a)
    Let b_min be range_get_min(b)

    Note: OR result is at most the sum of the two maxes (very conservative)
    Let result_max be a_max plus b_max

    Note: Minimum is larger of the two minimums if both positive
    Let result_min be 0
    If a_min is greater than 0:
        If b_min is greater than 0:
            Set result_min to a_min
            If b_min is greater than result_min:
                Set result_min to b_min
            End If
        End If
    End If

    Return range_create(result_min, result_max)
End Process

Note: Bitwise XOR range (very conservative)
Process called "range_bitwise_xor" takes a as Integer, b as Integer returns Integer:
    Let a_unknown be range_is_unknown(a)
    Let b_unknown be range_is_unknown(b)

    If a_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If b_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Let a_max be range_get_max(a)
    Let b_max be range_get_max(b)

    Note: XOR is very hard to bound - use sum as conservative estimate
    Let result_max be a_max plus b_max

    Return range_create(0, result_max)
End Process

Note: Analyze statement and update variable environment
Process called "analyze_statement" takes stmt as Integer, env as Integer returns Integer:
    Let stmt_type be memory_get_int32(stmt, 0)

    Note: Statement type constants (from parser)
    Let STMT_LET be 0
    Let STMT_SET be 1
    Let STMT_RETURN be 2
    Let STMT_IF be 3
    Let STMT_WHILE be 4
    Let STMT_EXPRESSION be 5
    Let STMT_BREAK be 6
    Let STMT_CONTINUE be 7
    Let STMT_PRINT be 8
    Let STMT_FOR be 9

    If stmt_type is equal to STMT_LET:
        Note: Let statement: type(int32), name(ptr at 8), expr(ptr at 16)
        Let name be memory_get_pointer(stmt, 8)
        Let expr be memory_get_pointer(stmt, 16)

        Let range be infer_expression_range(expr, env)
        Let dummy be var_env_set(env, name, range)
        Return env

    Otherwise If stmt_type is equal to STMT_SET:
        Note: Set statement: type(int32), target(ptr at 8), expr(ptr at 16)
        Let target be memory_get_pointer(stmt, 8)
        Let expr be memory_get_pointer(stmt, 16)

        Note: For simple identifier target
        Let target_type be memory_get_int32(target, 0)
        If target_type is equal to EXPR_IDENTIFIER:
            Let name be memory_get_pointer(target, 8)
            Let range be infer_expression_range(expr, env)
            Let dummy be var_env_set(env, name, range)
        End If

        Return env

    Otherwise If stmt_type is equal to STMT_IF:
        Note: If statement: type(int32), condition(ptr at 8), then_branch(ptr at 16), else_branch(ptr at 24)
        Let condition be memory_get_pointer(stmt, 8)
        Let then_branch be memory_get_pointer(stmt, 16)
        Let else_branch be memory_get_pointer(stmt, 24)

        Note: Analyze both branches separately
        Let then_env be var_env_copy(env)
        Let then_env_result be analyze_statement_list(then_branch, then_env)

        Let else_env be var_env_copy(env)
        If else_branch is not equal to 0:
            Let else_env_result be analyze_statement_list(else_branch, else_env)
            Note: Merge environments
            Return var_env_merge(then_env_result, else_env_result)
        Otherwise:
            Note: No else branch - merge with original env
            Return var_env_merge(then_env_result, env)
        End If

    Otherwise If stmt_type is equal to STMT_FOR:
        Note: For loop: analyze with fixed-point iteration
        Note: TODO: Implement full loop analysis
        Return env

    Otherwise If stmt_type is equal to STMT_WHILE:
        Note: While loop: analyze with fixed-point iteration
        Note: TODO: Implement full loop analysis
        Return env

    End If

    Return env
End Process

Note: Analyze list of statements
Process called "analyze_statement_list" takes stmt_list as Integer, env as Integer returns Integer:
    Note: Statement list: type(list), items...
    Let count be list_length(stmt_list)

    Let i be 0
    While i is less than count:
        Let stmt be list_get(stmt_list, i)
        Set env to analyze_statement(stmt, env)
        Set i to i plus 1
    End While

    Return env
End Process

Note: ===== INTER-PROCEDURAL ANALYSIS =====

Note: Function table - maps function name to (return_range, analyzed_flag)
Note: Structure: list of (name_ptr, return_range_ptr, analyzed_flag)
Process called "func_table_create" returns Integer:
    Note: Structure: capacity(int32 at 0), size(int32 at 4), entries(ptr at 8)
    Let table be allocate(16)
    Let initial_capacity be 32
    memory_set_int32(table, 0, initial_capacity)
    memory_set_int32(table, 4, 0)

    Note: Allocate entries array (each entry is 24 bytes: name_ptr + return_range_ptr + analyzed_flag)
    Let entries_size be initial_capacity multiplied by 24
    Let entries be allocate(entries_size)
    memory_set_pointer(table, 8, entries)

    Return table
End Process

Note: Lookup function return range
Process called "func_table_lookup" takes table as Integer, name as Integer returns Integer:
    Let size be memory_get_int32(table, 4)
    Let entries be memory_get_pointer(table, 8)

    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 24
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let range_offset be entry_offset plus 8
            Let return_range be memory_get_pointer(entries, range_offset)
            Return return_range
        End If

        Set i to i plus 1
    End While

    Note: Not found - return unknown range
    Return range_create_unknown()
End Process

Note: Set function return range
Process called "func_table_set" takes table as Integer, name as Integer, return_range as Integer returns Integer:
    Let size be memory_get_int32(table, 4)
    Let capacity be memory_get_int32(table, 0)
    Let entries be memory_get_pointer(table, 8)

    Note: Check if function already exists - update it
    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 24
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let range_offset be entry_offset plus 8
            memory_set_pointer(entries, range_offset, return_range)
            Return table
        End If

        Set i to i plus 1
    End While

    Note: Function not found - add new entry
    If size is equal to capacity:
        Display "ERROR: Function table capacity exceeded"
        exit_with_code(1)
    End If

    Let entry_offset be size multiplied by 24
    memory_set_pointer(entries, entry_offset, name)
    Let range_offset be entry_offset plus 8
    memory_set_pointer(entries, range_offset, return_range)
    Let analyzed_offset be entry_offset plus 16
    memory_set_int32(entries, analyzed_offset, 0)  Note: Not analyzed yet

    Let new_size be size plus 1
    memory_set_int32(table, 4, new_size)

    Return table
End Process

Note: Check if function has been analyzed
Process called "func_table_is_analyzed" takes table as Integer, name as Integer returns Integer:
    Let size be memory_get_int32(table, 4)
    Let entries be memory_get_pointer(table, 8)

    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 24
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let analyzed_offset be entry_offset plus 16
            Let analyzed_flag be memory_get_int32(entries, analyzed_offset)
            Return analyzed_flag
        End If

        Set i to i plus 1
    End While

    Return 0  Note: Not found - not analyzed
End Process

Note: Mark function as analyzed
Process called "func_table_mark_analyzed" takes table as Integer, name as Integer returns Integer:
    Let size be memory_get_int32(table, 4)
    Let entries be memory_get_pointer(table, 8)

    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 24
        Let entry_name be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_name, name) is equal to 1:
            Let analyzed_offset be entry_offset plus 16
            memory_set_int32(entries, analyzed_offset, 1)
            Return table
        End If

        Set i to i plus 1
    End While

    Return table
End Process

Note: Call graph - tracks which functions call which
Note: Structure: caller_name -> list of callee names
Process called "callgraph_create" returns Integer:
    Note: Structure: capacity(int32 at 0), size(int32 at 4), entries(ptr at 8)
    Let graph be allocate(16)
    Let initial_capacity be 32
    memory_set_int32(graph, 0, initial_capacity)
    memory_set_int32(graph, 4, 0)

    Note: Allocate entries array (each entry is 16 bytes: caller_name_ptr + callees_list_ptr)
    Let entries_size be initial_capacity multiplied by 16
    Let entries be allocate(entries_size)
    memory_set_pointer(graph, 8, entries)

    Return graph
End Process

Note: Add edge to call graph (caller -> callee)
Process called "callgraph_add_edge" takes graph as Integer, caller as Integer, callee as Integer returns Integer:
    Let size be memory_get_int32(graph, 4)
    Let capacity be memory_get_int32(graph, 0)
    Let entries be memory_get_pointer(graph, 8)

    Note: Look for existing caller entry
    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 16
        Let entry_caller be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_caller, caller) is equal to 1:
            Note: Found caller - add callee to its list
            Let callees_offset be entry_offset plus 8
            Let callees_list be memory_get_pointer(entries, callees_offset)
            Let dummy be list_append(callees_list, callee)
            Return graph
        End If

        Set i to i plus 1
    End While

    Note: Caller not found - create new entry
    If size is equal to capacity:
        Display "ERROR: Call graph capacity exceeded"
        exit_with_code(1)
    End If

    Let entry_offset be size multiplied by 16
    memory_set_pointer(entries, entry_offset, caller)
    Let callees_list be list_create()
    Let dummy be list_append(callees_list, callee)
    Let callees_offset be entry_offset plus 8
    memory_set_pointer(entries, callees_offset, callees_list)

    Let new_size be size plus 1
    memory_set_int32(graph, 4, new_size)

    Return graph
End Process

Note: Get list of callees for a function
Process called "callgraph_get_callees" takes graph as Integer, caller as Integer returns Integer:
    Let size be memory_get_int32(graph, 4)
    Let entries be memory_get_pointer(graph, 8)

    Let i be 0
    While i is less than size:
        Let entry_offset be i multiplied by 16
        Let entry_caller be memory_get_pointer(entries, entry_offset)

        If string_equals(entry_caller, caller) is equal to 1:
            Let callees_offset be entry_offset plus 8
            Let callees_list be memory_get_pointer(entries, callees_offset)
            Return callees_list
        End If

        Set i to i plus 1
    End While

    Note: Not found - return empty list
    Return list_create()
End Process

Note: Build call graph from AST
Process called "build_callgraph_from_ast" takes ast as Integer returns Integer:
    Let callgraph be callgraph_create()

    Note: AST structure: functions(ptr at 0)
    Let functions be memory_get_pointer(ast, 0)
    Let func_count be list_length(functions)

    Let i be 0
    While i is less than func_count:
        Let func be list_get(functions, i)

        Note: Function: name(ptr at 0), params(ptr at 8), return_type(ptr at 16), body(ptr at 24)
        Let func_name be memory_get_pointer(func, 0)
        Let body be memory_get_pointer(func, 24)

        Note: Scan body for function calls
        Let dummy be scan_for_calls(callgraph, func_name, body)

        Set i to i plus 1
    End While

    Return callgraph
End Process

Note: Scan statement list for function calls
Process called "scan_for_calls" takes callgraph as Integer, caller as Integer, stmt_list as Integer returns Integer:
    Let count be list_length(stmt_list)

    Let i be 0
    While i is less than count:
        Let stmt be list_get(stmt_list, i)
        Let dummy be scan_statement_for_calls(callgraph, caller, stmt)
        Set i to i plus 1
    End While

    Return callgraph
End Process

Note: Scan single statement for function calls
Process called "scan_statement_for_calls" takes callgraph as Integer, caller as Integer, stmt as Integer returns Integer:
    Let stmt_type be memory_get_int32(stmt, 0)

    Let STMT_LET be 0
    Let STMT_SET be 1
    Let STMT_RETURN be 2
    Let STMT_IF be 3
    Let STMT_WHILE be 4
    Let STMT_EXPRESSION be 5
    Let STMT_FOR be 9

    If stmt_type is equal to STMT_LET:
        Let expr be memory_get_pointer(stmt, 16)
        Let dummy be scan_expr_for_calls(callgraph, caller, expr)
        Return callgraph

    Otherwise If stmt_type is equal to STMT_SET:
        Let expr be memory_get_pointer(stmt, 16)
        Let dummy be scan_expr_for_calls(callgraph, caller, expr)
        Return callgraph

    Otherwise If stmt_type is equal to STMT_RETURN:
        Let expr be memory_get_pointer(stmt, 8)
        If expr is not equal to 0:
            Let dummy be scan_expr_for_calls(callgraph, caller, expr)
        End If
        Return callgraph

    Otherwise If stmt_type is equal to STMT_IF:
        Let condition be memory_get_pointer(stmt, 8)
        Let then_branch be memory_get_pointer(stmt, 16)
        Let else_branch be memory_get_pointer(stmt, 24)

        Let dummy be scan_expr_for_calls(callgraph, caller, condition)
        Let dummy2 be scan_for_calls(callgraph, caller, then_branch)
        If else_branch is not equal to 0:
            Let dummy3 be scan_for_calls(callgraph, caller, else_branch)
        End If
        Return callgraph

    Otherwise If stmt_type is equal to STMT_WHILE:
        Let condition be memory_get_pointer(stmt, 8)
        Let body be memory_get_pointer(stmt, 16)

        Let dummy be scan_expr_for_calls(callgraph, caller, condition)
        Let dummy2 be scan_for_calls(callgraph, caller, body)
        Return callgraph

    Otherwise If stmt_type is equal to STMT_FOR:
        Let init be memory_get_pointer(stmt, 8)
        Let condition be memory_get_pointer(stmt, 16)
        Let update be memory_get_pointer(stmt, 24)
        Let body be memory_get_pointer(stmt, 32)

        If init is not equal to 0:
            Let dummy be scan_statement_for_calls(callgraph, caller, init)
        End If
        If condition is not equal to 0:
            Let dummy2 be scan_expr_for_calls(callgraph, caller, condition)
        End If
        If update is not equal to 0:
            Let dummy3 be scan_statement_for_calls(callgraph, caller, update)
        End If
        Let dummy4 be scan_for_calls(callgraph, caller, body)
        Return callgraph

    Otherwise If stmt_type is equal to STMT_EXPRESSION:
        Let expr be memory_get_pointer(stmt, 8)
        Let dummy be scan_expr_for_calls(callgraph, caller, expr)
        Return callgraph

    End If

    Return callgraph
End Process

Note: Scan expression for function calls
Process called "scan_expr_for_calls" takes callgraph as Integer, caller as Integer, expr as Integer returns Integer:
    If expr is equal to 0:
        Return callgraph
    End If

    Let expr_type be memory_get_int32(expr, 0)

    If expr_type is equal to EXPR_FUNCTION_CALL:
        Note: Found function call - add edge
        Let callee_name be memory_get_pointer(expr, 8)
        Let dummy be callgraph_add_edge(callgraph, caller, callee_name)

        Note: Also scan arguments
        Let args be memory_get_pointer(expr, 16)
        If args is not equal to 0:
            Let arg_count be list_length(args)
            Let i be 0
            While i is less than arg_count:
                Let arg be list_get(args, i)
                Let dummy2 be scan_expr_for_calls(callgraph, caller, arg)
                Set i to i plus 1
            End While
        End If
        Return callgraph

    Otherwise If expr_type is equal to EXPR_BINARY_OP:
        Let left be memory_get_pointer(expr, 8)
        Let right be memory_get_pointer(expr, 24)
        Let dummy be scan_expr_for_calls(callgraph, caller, left)
        Let dummy2 be scan_expr_for_calls(callgraph, caller, right)
        Return callgraph

    Otherwise If expr_type is equal to EXPR_UNARY_MINUS:
        Let operand be memory_get_pointer(expr, 8)
        Let dummy be scan_expr_for_calls(callgraph, caller, operand)
        Return callgraph

    Otherwise If expr_type is equal to EXPR_CAST:
        Let inner_expr be memory_get_pointer(expr, 8)
        Let dummy be scan_expr_for_calls(callgraph, caller, inner_expr)
        Return callgraph

    Otherwise If expr_type is equal to EXPR_ARRAY_INDEX:
        Let array be memory_get_pointer(expr, 8)
        Let index be memory_get_pointer(expr, 16)
        Let dummy be scan_expr_for_calls(callgraph, caller, array)
        Let dummy2 be scan_expr_for_calls(callgraph, caller, index)
        Return callgraph

    End If

    Return callgraph
End Process

Note: Analyze function return range with inter-procedural support
Process called "analyze_function_range" takes func as Integer, func_table as Integer, callgraph as Integer returns Integer:
    Note: Function: name(ptr at 0), params(ptr at 8), return_type(ptr at 16), body(ptr at 24)
    Let func_name be memory_get_pointer(func, 0)
    Let body be memory_get_pointer(func, 24)

    Note: Check if already analyzed
    Let is_analyzed be func_table_is_analyzed(func_table, func_name)
    If is_analyzed is equal to 1:
        Return func_table_lookup(func_table, func_name)
    End If

    Note: Analyze all callees first (bottom-up)
    Let callees be callgraph_get_callees(callgraph, func_name)
    Let callee_count be list_length(callees)
    Let i be 0
    While i is less than callee_count:
        Let callee_name be list_get(callees, i)

        Note: Recursively analyze callee
        Note: TODO: Handle recursion properly (detect cycles)
        Let callee_is_analyzed be func_table_is_analyzed(func_table, callee_name)
        If callee_is_analyzed is equal to 0:
            Note: Callee not analyzed yet - need to find and analyze it
            Note: For now, assume unknown range
            Let dummy be func_table_set(func_table, callee_name, range_create_unknown())
        End If

        Set i to i plus 1
    End While

    Note: Create environment with parameter ranges (assume unknown for now)
    Let env be var_env_create()

    Note: Scan body for return statements and collect return ranges
    Let return_range be scan_for_return_range(body, env, func_table)

    Note: Update function table
    Let dummy be func_table_set(func_table, func_name, return_range)
    Let dummy2 be func_table_mark_analyzed(func_table, func_name)

    Return return_range
End Process

Note: Scan statement list for return statements and compute union of return ranges
Process called "scan_for_return_range" takes stmt_list as Integer, env as Integer, func_table as Integer returns Integer:
    Let result_range be range_create(0, 0)  Note: Start with single point [0,0]
    Let found_return be 0

    Let count be list_length(stmt_list)
    Let i be 0
    While i is less than count:
        Let stmt be list_get(stmt_list, i)
        Let stmt_range be scan_stmt_for_return_range(stmt, env, func_table)

        Note: Check if this statement has return
        If stmt_range is not equal to 0:
            Set found_return to 1
            Set result_range to range_union(result_range, stmt_range)
        End If

        Set i to i plus 1
    End While

    If found_return is equal to 0:
        Return range_create_unknown()
    End If

    Return result_range
End Process

Note: Scan single statement for return range
Process called "scan_stmt_for_return_range" takes stmt as Integer, env as Integer, func_table as Integer returns Integer:
    Let stmt_type be memory_get_int32(stmt, 0)

    Let STMT_RETURN be 2
    Let STMT_IF be 3
    Let STMT_WHILE be 4
    Let STMT_FOR be 9

    If stmt_type is equal to STMT_RETURN:
        Let expr be memory_get_pointer(stmt, 8)
        If expr is equal to 0:
            Return range_create(0, 0)  Note: No return value
        End If
        Return infer_expression_range_with_functable(expr, env, func_table)

    Otherwise If stmt_type is equal to STMT_IF:
        Let then_branch be memory_get_pointer(stmt, 16)
        Let else_branch be memory_get_pointer(stmt, 24)

        Let then_range be scan_for_return_range(then_branch, env, func_table)

        If else_branch is not equal to 0:
            Let else_range be scan_for_return_range(else_branch, env, func_table)

            Note: Only return if both branches have returns
            If then_range is not equal to 0:
                If else_range is not equal to 0:
                    Return range_union(then_range, else_range)
                End If
            End If
        End If

        Return then_range  Note: May be 0 if no return

    Otherwise If stmt_type is equal to STMT_WHILE:
        Let body be memory_get_pointer(stmt, 16)
        Return scan_for_return_range(body, env, func_table)

    Otherwise If stmt_type is equal to STMT_FOR:
        Let body be memory_get_pointer(stmt, 32)
        Return scan_for_return_range(body, env, func_table)

    End If

    Return 0  Note: No return in this statement
End Process

Note: Infer expression range with function table support (wrapper for compatibility)
Process called "infer_expression_range_with_functable" takes expr as Integer, env as Integer, func_table as Integer returns Integer:
    Return infer_expression_range_full(expr, env, func_table)
End Process
