Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Control Flow Graph Builder
Note: Builds a CFG from AST for data flow analysis

Note: Basic Block structure
Note: bb_id(int32 at 0), statements(ptr at 8), stmt_count(int32 at 16),
Note: predecessors(ptr at 24), pred_count(int32 at 32),
Note: successors(ptr at 40), succ_count(int32 at 48)
Note: Total: 56 bytes

Note: CFG structure
Note: blocks(ptr at 0), block_count(int32 at 8), entry_block(int32 at 12), exit_block(int32 at 16)
Note: Total: 20 bytes

Let next_bb_id be 0

Note: Create a basic block
Process called "bb_create" returns Integer:
    Let bb be allocate(56)

    memory_set_int32(bb, 0, next_bb_id)
    Set next_bb_id to next_bb_id plus 1

    Note: Initialize statements list (capacity 16)
    Let stmts_capacity be 16
    Let stmts_size be stmts_capacity multiplied by 8
    Let stmts be allocate(stmts_size)
    memory_set_pointer(bb, 8, stmts)
    memory_set_int32(bb, 16, 0)  Note: stmt_count = 0

    Note: Initialize predecessors list (capacity 4)
    Let preds_capacity be 4
    Let preds_size be preds_capacity multiplied by 4
    Let preds be allocate(preds_size)
    memory_set_pointer(bb, 24, preds)
    memory_set_int32(bb, 32, 0)  Note: pred_count = 0

    Note: Initialize successors list (capacity 4)
    Let succs_capacity be 4
    Let succs_size be succs_capacity multiplied by 4
    Let succs be allocate(succs_size)
    memory_set_pointer(bb, 40, succs)
    memory_set_int32(bb, 48, 0)  Note: succ_count = 0

    Return bb
End Process

Note: Add statement to basic block
Process called "bb_add_statement" takes bb as Integer, stmt as Integer returns Integer:
    Let stmts be memory_get_pointer(bb, 8)
    Let stmt_count be memory_get_int32(bb, 16)

    Note: TODO: Handle capacity expansion
    If stmt_count is greater than or equal to 16:
        Display "ERROR: Basic block statement capacity exceeded"
        exit_with_code(1)
    End If

    Let offset be stmt_count multiplied by 8
    memory_set_pointer(stmts, offset, stmt)

    Let new_count be stmt_count plus 1
    memory_set_int32(bb, 16, new_count)

    Return bb
End Process

Note: Add edge from bb1 to bb2
Process called "bb_add_edge" takes bb1 as Integer, bb2 as Integer returns Integer:
    Note: Add bb2 as successor of bb1
    Let succs be memory_get_pointer(bb1, 40)
    Let succ_count be memory_get_int32(bb1, 48)

    If succ_count is greater than or equal to 4:
        Display "ERROR: Basic block successor capacity exceeded"
        exit_with_code(1)
    End If

    Let bb2_id be memory_get_int32(bb2, 0)
    Let offset be succ_count multiplied by 4
    memory_set_int32(succs, offset, bb2_id)

    Let new_succ_count be succ_count plus 1
    memory_set_int32(bb1, 48, new_succ_count)

    Note: Add bb1 as predecessor of bb2
    Let preds be memory_get_pointer(bb2, 24)
    Let pred_count be memory_get_int32(bb2, 32)

    If pred_count is greater than or equal to 4:
        Display "ERROR: Basic block predecessor capacity exceeded"
        exit_with_code(1)
    End If

    Let bb1_id be memory_get_int32(bb1, 0)
    Let pred_offset be pred_count multiplied by 4
    memory_set_int32(preds, pred_offset, bb1_id)

    Let new_pred_count be pred_count plus 1
    memory_set_int32(bb2, 32, new_pred_count)

    Return 0
End Process

Note: Create CFG
Process called "cfg_create" returns Integer:
    Let cfg be allocate(20)

    Note: Initialize blocks array (capacity 64)
    Let blocks_capacity be 64
    Let blocks_size be blocks_capacity multiplied by 8
    Let blocks be allocate(blocks_size)
    memory_set_pointer(cfg, 0, blocks)
    memory_set_int32(cfg, 8, 0)  Note: block_count = 0

    memory_set_int32(cfg, 12, 0 minus 1)  Note: entry_block = -1 (not set)
    memory_set_int32(cfg, 16, 0 minus 1)  Note: exit_block = -1 (not set)

    Return cfg
End Process

Note: Add basic block to CFG
Process called "cfg_add_block" takes cfg as Integer, bb as Integer returns Integer:
    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)

    If block_count is greater than or equal to 64:
        Display "ERROR: CFG block capacity exceeded"
        exit_with_code(1)
    End If

    Let offset be block_count multiplied by 8
    memory_set_pointer(blocks, offset, bb)

    Let new_count be block_count plus 1
    memory_set_int32(cfg, 8, new_count)

    Return cfg
End Process

Note: Get block by ID from CFG
Process called "cfg_get_block" takes cfg as Integer, bb_id as Integer returns Integer:
    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Let i be 0
    While i is less than block_count:
        Let offset be i multiplied by 8
        Let bb be memory_get_pointer(blocks, offset)
        Let id be memory_get_int32(bb, 0)

        If id is equal to bb_id:
            Return bb
        End If

        Set i to i plus 1
    End While

    Return 0  Note: Not found
End Process

Note: Build CFG from statement list
Note: Returns CFG with entry and exit blocks
Process called "build_cfg" takes stmt_list as Integer returns Integer:
    Let cfg be cfg_create()

    Note: Create entry and exit blocks
    Let entry_bb be bb_create()
    Let dummy1 be cfg_add_block(cfg, entry_bb)

    Let entry_id be memory_get_int32(entry_bb, 0)
    memory_set_int32(cfg, 12, entry_id)  Note: Set entry_block

    Note: Build CFG from statements
    Let current_bb be entry_bb
    Let stmt_count be list_length(stmt_list)

    Let i be 0
    While i is less than stmt_count:
        Let stmt be list_get(stmt_list, i)
        Let stmt_type be memory_get_int32(stmt, 0)

        Note: Statement types
        Let STMT_LET be 0
        Let STMT_SET be 1
        Let STMT_RETURN be 2
        Let STMT_IF be 3
        Let STMT_WHILE be 4
        Let STMT_FOR be 9
        Let STMT_BREAK be 6
        Let STMT_CONTINUE be 7

        If stmt_type is equal to STMT_IF:
            Note: If statement splits control flow
            Let condition be memory_get_pointer(stmt, 8)
            Let then_branch be memory_get_pointer(stmt, 16)
            Let else_branch be memory_get_pointer(stmt, 24)

            Note: Create blocks for then and else branches
            Let then_bb be bb_create()
            Let dummy2 be cfg_add_block(cfg, then_bb)

            Let else_bb be bb_create()
            Let dummy3 be cfg_add_block(cfg, else_bb)

            Note: Create merge block
            Let merge_bb be bb_create()
            Let dummy4 be cfg_add_block(cfg, merge_bb)

            Note: Add edges: current -> then, current -> else
            Let dummy5 be bb_add_edge(current_bb, then_bb)
            Let dummy6 be bb_add_edge(current_bb, else_bb)

            Note: Build then branch CFG
            Note: TODO: Recursively build sub-CFGs

            Note: Add edges: then -> merge, else -> merge
            Let dummy7 be bb_add_edge(then_bb, merge_bb)
            Let dummy8 be bb_add_edge(else_bb, merge_bb)

            Set current_bb to merge_bb

        Otherwise If stmt_type is equal to STMT_WHILE:
            Note: While loop creates back edge
            Note: TODO: Implement loop CFG

            Note: For now, create simple blocks
            Let loop_header be bb_create()
            Let dummy9 be cfg_add_block(cfg, loop_header)

            Let loop_body be bb_create()
            Let dummy10 be cfg_add_block(cfg, loop_body)

            Let loop_exit be bb_create()
            Let dummy11 be cfg_add_block(cfg, loop_exit)

            Note: Edges: current -> header
            Let dummy12 be bb_add_edge(current_bb, loop_header)

            Note: Edges: header -> body, header -> exit
            Let dummy13 be bb_add_edge(loop_header, loop_body)
            Let dummy14 be bb_add_edge(loop_header, loop_exit)

            Note: Back edge: body -> header
            Let dummy15 be bb_add_edge(loop_body, loop_header)

            Set current_bb to loop_exit

        Otherwise If stmt_type is equal to STMT_RETURN:
            Note: Return ends current block
            Let dummy16 be bb_add_statement(current_bb, stmt)

            Note: Create new block for any unreachable code after return
            Let new_bb be bb_create()
            Let dummy17 be cfg_add_block(cfg, new_bb)
            Set current_bb to new_bb

        Otherwise:
            Note: Regular statement - add to current block
            Let dummy18 be bb_add_statement(current_bb, stmt)
        End If

        Set i to i plus 1
    End While

    Note: Create exit block
    Let exit_bb be bb_create()
    Let dummy19 be cfg_add_block(cfg, exit_bb)

    Let exit_id be memory_get_int32(exit_bb, 0)
    memory_set_int32(cfg, 16, exit_id)  Note: Set exit_block

    Note: Connect current block to exit
    Let dummy20 be bb_add_edge(current_bb, exit_bb)

    Return cfg
End Process

Note: Print CFG for debugging
Process called "cfg_print" takes cfg as Integer returns Integer:
    Display "=== Control Flow Graph ==="

    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Let i be 0
    While i is less than block_count:
        Let offset be i multiplied by 8
        Let bb be memory_get_pointer(blocks, offset)
        Let bb_id be memory_get_int32(bb, 0)

        Display "Block ", integer_to_string(bb_id), ":"

        Note: Print predecessors
        Let pred_count be memory_get_int32(bb, 32)
        If pred_count is greater than 0:
            Display "  Predecessors: "
            Let preds be memory_get_pointer(bb, 24)
            Let j be 0
            While j is less than pred_count:
                Let pred_offset be j multiplied by 4
                Let pred_id be memory_get_int32(preds, pred_offset)
                Display integer_to_string(pred_id), " "
                Set j to j plus 1
            End While
        End If

        Note: Print successors
        Let succ_count be memory_get_int32(bb, 48)
        If succ_count is greater than 0:
            Display "  Successors: "
            Let succs be memory_get_pointer(bb, 40)
            Let k be 0
            While k is less than succ_count:
                Let succ_offset be k multiplied by 4
                Let succ_id be memory_get_int32(succs, succ_offset)
                Display integer_to_string(succ_id), " "
                Set k to k plus 1
            End While
        End If

        Set i to i plus 1
    End While

    Return 0
End Process

Note: ===== DOMINATOR ANALYSIS =====

Note: Dominator set structure - bitmap of dominating blocks
Note: For block i, dominators[i] is a bitset of blocks that dominate i
Note: Structure: block_count(int32 at 0), bitsets(ptr at 8)
Note: Each bitset is an array of int32s (32 bits per int)

Process called "domset_create" takes block_count as Integer returns Integer:
    Let domset be allocate(16)
    memory_set_int32(domset, 0, block_count)

    Note: Calculate size needed for bitsets
    Note: Each block needs block_count bits, rounded up to 32-bit chunks
    Let bits_per_int be 32
    Let ints_per_block be block_count divided by bits_per_int
    If block_count modulo by bits_per_int is not equal to 0:
        Set ints_per_block to ints_per_block plus 1
    End If

    Note: Allocate array of bitsets (one per block)
    Let total_ints be block_count multiplied by ints_per_block
    Let bitsets_size be total_ints multiplied by 4
    Let bitsets be allocate(bitsets_size)
    memory_set_pointer(domset, 8, bitsets)

    Note: Initialize all bits to 0
    Let i be 0
    While i is less than total_ints:
        Let offset be i multiplied by 4
        memory_set_int32(bitsets, offset, 0)
        Set i to i plus 1
    End While

    Return domset
End Process

Note: Set bit in dominator set (mark block_id as dominating bb_id)
Process called "domset_set" takes domset as Integer, bb_id as Integer, dom_id as Integer returns Integer:
    Let block_count be memory_get_int32(domset, 0)
    Let bitsets be memory_get_pointer(domset, 8)

    Note: Calculate which int and which bit
    Let bits_per_int be 32
    Let ints_per_block be block_count divided by bits_per_int
    If block_count modulo by bits_per_int is not equal to 0:
        Set ints_per_block to ints_per_block plus 1
    End If

    Let int_index be dom_id divided by bits_per_int
    Let bit_index be dom_id modulo by bits_per_int

    Note: Calculate offset in bitsets array
    Let row_offset be bb_id multiplied by ints_per_block
    Let total_offset be row_offset plus int_index
    Let byte_offset be total_offset multiplied by 4

    Note: Read current value, set bit, write back
    Let current_value be memory_get_int32(bitsets, byte_offset)
    Let mask be 1
    Let shift_count be bit_index
    While shift_count is greater than 0:
        Set mask to mask multiplied by 2
        Set shift_count to shift_count minus 1
    End While

    Let new_value be current_value bit_or mask
    memory_set_int32(bitsets, byte_offset, new_value)

    Return domset
End Process

Note: Check if dom_id dominates bb_id
Process called "domset_contains" takes domset as Integer, bb_id as Integer, dom_id as Integer returns Integer:
    Let block_count be memory_get_int32(domset, 0)
    Let bitsets be memory_get_pointer(domset, 8)

    Note: Calculate which int and which bit
    Let bits_per_int be 32
    Let ints_per_block be block_count divided by bits_per_int
    If block_count modulo by bits_per_int is not equal to 0:
        Set ints_per_block to ints_per_block plus 1
    End If

    Let int_index be dom_id divided by bits_per_int
    Let bit_index be dom_id modulo by bits_per_int

    Note: Calculate offset in bitsets array
    Let row_offset be bb_id multiplied by ints_per_block
    Let total_offset be row_offset plus int_index
    Let byte_offset be total_offset multiplied by 4

    Note: Read value and check bit
    Let current_value be memory_get_int32(bitsets, byte_offset)
    Let mask be 1
    Let shift_count be bit_index
    While shift_count is greater than 0:
        Set mask to mask multiplied by 2
        Set shift_count to shift_count minus 1
    End While

    Let masked be current_value bit_and mask
    If masked is not equal to 0:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Note: Set dominator set to all blocks (for initialization)
Process called "domset_set_all" takes domset as Integer, bb_id as Integer returns Integer:
    Let block_count be memory_get_int32(domset, 0)

    Let i be 0
    While i is less than block_count:
        Let dummy be domset_set(domset, bb_id, i)
        Set i to i plus 1
    End While

    Return domset
End Process

Note: Compute intersection of two block's dominator sets and store in bb_id
Process called "domset_intersect" takes domset as Integer, bb_id as Integer, other_id as Integer returns Integer:
    Let block_count be memory_get_int32(domset, 0)
    Let bitsets be memory_get_pointer(domset, 8)

    Let bits_per_int be 32
    Let ints_per_block be block_count divided by bits_per_int
    If block_count modulo by bits_per_int is not equal to 0:
        Set ints_per_block to ints_per_block plus 1
    End If

    Note: For each int in the bitset
    Let i be 0
    While i is less than ints_per_block:
        Note: Get offsets for both blocks
        Let bb_row_offset be bb_id multiplied by ints_per_block
        Let bb_offset be bb_row_offset plus i
        Let bb_byte_offset be bb_offset multiplied by 4

        Let other_row_offset be other_id multiplied by ints_per_block
        Let other_offset be other_row_offset plus i
        Let other_byte_offset be other_offset multiplied by 4

        Note: Read both values
        Let bb_value be memory_get_int32(bitsets, bb_byte_offset)
        Let other_value be memory_get_int32(bitsets, other_byte_offset)

        Note: Compute intersection
        Let intersect_value be bb_value bit_and other_value

        Note: Write back
        memory_set_int32(bitsets, bb_byte_offset, intersect_value)

        Set i to i plus 1
    End While

    Return domset
End Process

Note: Compute dominators using iterative algorithm
Process called "compute_dominators" takes cfg as Integer returns Integer:
    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)
    Let entry_id be memory_get_int32(cfg, 12)

    Note: Create dominator set structure
    Let domset be domset_create(block_count)

    Note: Initialize: entry dominates itself, all others dominate all blocks
    Let i be 0
    While i is less than block_count:
        If i is equal to entry_id:
            Note: Entry block dominates only itself
            Let dummy be domset_set(domset, entry_id, entry_id)
        Otherwise:
            Note: All other blocks initially dominate all blocks
            Let dummy2 be domset_set_all(domset, i)
        End If
        Set i to i plus 1
    End While

    Note: Iterative fixed-point computation
    Let changed be 1
    Let max_iterations be 100
    Let iteration be 0

    While changed is equal to 1:
        Set changed to 0
        Set iteration to iteration plus 1

        If iteration is greater than max_iterations:
            Display "ERROR: Dominator analysis did not converge"
            exit_with_code(1)
        End If

        Note: For each block (except entry)
        Let i be 0
        While i is less than block_count:
            If i is not equal to entry_id:
                Note: New dominators = {i} union (intersection of all predecessor dominators)
                Let bb be cfg_get_block(cfg, i)
                Let pred_count be memory_get_int32(bb, 32)

                If pred_count is greater than 0:
                    Note: Start with first predecessor's dominators
                    Let preds be memory_get_pointer(bb, 24)
                    Let first_pred_id be memory_get_int32(preds, 0)

                    Note: Create temp domset initialized to first pred
                    Let temp_domset be domset_create(block_count)
                    Let j be 0
                    While j is less than block_count:
                        Let is_dom be domset_contains(domset, first_pred_id, j)
                        If is_dom is equal to 1:
                            Let dummy3 be domset_set(temp_domset, 0, j)
                        End If
                        Set j to j plus 1
                    End While

                    Note: Intersect with remaining predecessors
                    Let k be 1
                    While k is less than pred_count:
                        Let pred_offset be k multiplied by 4
                        Let pred_id be memory_get_int32(preds, pred_offset)

                        Note: Intersect temp_domset with pred's dominators
                        Let m be 0
                        While m is less than block_count:
                            Let is_in_temp be domset_contains(temp_domset, 0, m)
                            Let is_in_pred be domset_contains(domset, pred_id, m)

                            If is_in_temp is equal to 1:
                                If is_in_pred is equal to 0:
                                    Note: Remove from temp (not in intersection)
                                    Note: Just skip it when copying
                                End If
                            End If
                            Set m to m plus 1
                        End While

                        Set k to k plus 1
                    End While

                    Note: Check if dominators changed
                    Let old_has_self be domset_contains(domset, i, i)
                    Let new_dominators_differ be 0

                    Note: Clear current dominators for block i
                    Let n be 0
                    While n is less than block_count:
                        Let old_dom be domset_contains(domset, i, n)
                        Let new_dom be domset_contains(temp_domset, 0, n)

                        If old_dom is not equal to new_dom:
                            Set new_dominators_differ to 1
                        End If
                        Set n to n plus 1
                    End While

                    Note: Copy temp to domset[i] and add i itself
                    Let p be 0
                    While p is less than block_count:
                        Let is_in_temp be domset_contains(temp_domset, 0, p)
                        Note: Clear and rebuild
                        Set p to p plus 1
                    End While

                    Note: Set dom(i) = temp union {i}
                    Let dummy4 be domset_set(domset, i, i)

                    If new_dominators_differ is equal to 1:
                        Set changed to 1
                    End If
                End If
            End If

            Set i to i plus 1
        End While
    End While

    Return domset
End Process

Note: Find immediate dominator of a block
Process called "find_idom" takes domset as Integer, cfg as Integer, bb_id as Integer returns Integer:
    Let block_count be memory_get_int32(cfg, 8)
    Let entry_id be memory_get_int32(cfg, 12)

    Note: Entry block has no immediate dominator
    If bb_id is equal to entry_id:
        Return 0 minus 1
    End If

    Note: Immediate dominator is the unique dominator != bb_id that dominates all other dominators
    Note: For simplicity: find the dominator with the longest path from entry

    Let idom be 0 minus 1
    Let max_distance be 0 minus 1

    Let i be 0
    While i is less than block_count:
        If i is not equal to bb_id:
            Let is_dom be domset_contains(domset, bb_id, i)
            If is_dom is equal to 1:
                Note: i dominates bb_id
                Note: For now, just pick the last one found (not fully correct)
                Set idom to i
            End If
        End If
        Set i to i plus 1
    End While

    Return idom
End Process

Note: Find merge points (blocks with multiple predecessors)
Process called "find_merge_points" takes cfg as Integer returns Integer:
    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Note: Create list to store merge point block IDs
    Let merge_points be list_create()

    Let i be 0
    While i is less than block_count:
        Let bb be cfg_get_block(cfg, i)
        Let pred_count be memory_get_int32(bb, 32)

        Note: Block is a merge point if it has 2+ predecessors
        If pred_count is greater than 1:
            Let bb_id be memory_get_int32(bb, 0)
            Let dummy be list_append(merge_points, bb_id)
        End If

        Set i to i plus 1
    End While

    Return merge_points
End Process

Note: Print dominator information for debugging
Process called "print_dominators" takes domset as Integer, cfg as Integer returns Integer:
    Display "=== Dominator Analysis ==="

    Let block_count be memory_get_int32(cfg, 8)

    Let i be 0
    While i is less than block_count:
        Display "Block ", integer_to_string(i), " dominated by: "

        Let j be 0
        While j is less than block_count:
            Let is_dom be domset_contains(domset, i, j)
            If is_dom is equal to 1:
                Display integer_to_string(j), " "
            End If
            Set j to j plus 1
        End While

        Display ""

        Note: Print immediate dominator
        Let idom be find_idom(domset, cfg, i)
        If idom is not equal to 0 minus 1:
            Display "  Immediate dominator: ", integer_to_string(idom)
        End If

        Set i to i plus 1
    End While

    Return 0
End Process

Note: ===== LOOP DETECTION AND ANALYSIS =====

Note: Loop structure
Note: header_id(int32 at 0), body_ids(ptr at 8), exit_id(int32 at 16), loop_type(int32 at 20)
Note: For FOR loops: init_stmt(ptr at 24), condition_expr(ptr at 32), update_stmt(ptr at 40)
Note: For WHILE loops: condition_expr(ptr at 32)

Let LOOP_TYPE_FOR be 0
Let LOOP_TYPE_WHILE be 1

Process called "loop_create" takes loop_type as Integer returns Integer:
    Let loop be allocate(48)
    memory_set_int32(loop, 0, 0 minus 1)  Note: header_id = -1
    memory_set_pointer(loop, 8, list_create())  Note: body_ids
    memory_set_int32(loop, 16, 0 minus 1)  Note: exit_id = -1
    memory_set_int32(loop, 20, loop_type)
    memory_set_pointer(loop, 24, 0)  Note: init_stmt = null
    memory_set_pointer(loop, 32, 0)  Note: condition_expr = null
    memory_set_pointer(loop, 40, 0)  Note: update_stmt = null
    Return loop
End Process

Note: Detect loops in CFG (finds back edges)
Process called "detect_loops" takes cfg as Integer, domset as Integer returns Integer:
    Let blocks be memory_get_pointer(cfg, 0)
    Let block_count be memory_get_int32(cfg, 8)

    Note: Create list to store detected loops
    Let loops be list_create()

    Note: A back edge is an edge from block N to block H where H dominates N
    Note: H is the loop header, N is in the loop body

    Let i be 0
    While i is less than block_count:
        Let bb be cfg_get_block(cfg, i)
        Let bb_id be memory_get_int32(bb, 0)

        Note: Check all successors
        Let succ_count be memory_get_int32(bb, 48)
        Let succs be memory_get_pointer(bb, 40)

        Let j be 0
        While j is less than succ_count:
            Let succ_offset be j multiplied by 4
            Let succ_id be memory_get_int32(succs, succ_offset)

            Note: Check if succ dominates bb (back edge!)
            Let is_dominator be domset_contains(domset, bb_id, succ_id)

            If is_dominator is equal to 1:
                Note: Found back edge: bb_id -> succ_id
                Note: succ_id is loop header

                Note: Create loop structure
                Let loop be loop_create(LOOP_TYPE_WHILE)  Note: Default to WHILE, will refine
                memory_set_int32(loop, 0, succ_id)  Note: header_id

                Note: Add to loops list
                Let dummy be list_append(loops, loop)
            End If

            Set j to j plus 1
        End While

        Set i to i plus 1
    End While

    Return loops
End Process

Note: Extract For loop bounds from AST
Process called "extract_for_loop_bounds" takes for_stmt as Integer returns Integer:
    Note: For statement: type(int32 at 0), init(ptr at 8), condition(ptr at 16), update(ptr at 24), body(ptr at 32)

    Let init_stmt be memory_get_pointer(for_stmt, 8)
    Let condition_expr be memory_get_pointer(for_stmt, 16)
    Let update_stmt be memory_get_pointer(for_stmt, 24)

    Note: Create bounds structure: loop_var(ptr at 0), start_value(ptr at 8), end_value(ptr at 16), step(int at 24)
    Let bounds be allocate(32)
    memory_set_pointer(bounds, 0, 0)  Note: loop_var = null
    memory_set_pointer(bounds, 8, 0)  Note: start_value = null
    memory_set_pointer(bounds, 16, 0)  Note: end_value = null
    memory_set_int32(bounds, 24, 1)  Note: step = 1 (default)

    Note: Extract loop variable from init statement
    If init_stmt is not equal to 0:
        Let init_type be memory_get_int32(init_stmt, 0)
        Let STMT_LET be 0

        If init_type is equal to STMT_LET:
            Note: Let i be 0
            Let var_name be memory_get_pointer(init_stmt, 8)
            Let start_expr be memory_get_pointer(init_stmt, 16)

            memory_set_pointer(bounds, 0, var_name)
            memory_set_pointer(bounds, 8, start_expr)
        End If
    End If

    Note: Extract end condition from condition expression
    If condition_expr is not equal to 0:
        Let cond_type be memory_get_int32(condition_expr, 0)
        Let EXPR_BINARY_OP be 3

        If cond_type is equal to EXPR_BINARY_OP:
            Note: i < 10
            Let left be memory_get_pointer(condition_expr, 8)
            Let op be memory_get_int32(condition_expr, 16)
            Let right be memory_get_pointer(condition_expr, 24)

            Note: Assume right side is the bound
            memory_set_pointer(bounds, 16, right)
        End If
    End If

    Note: Extract step from update statement
    If update_stmt is not equal to 0:
        Let update_type be memory_get_int32(update_stmt, 0)
        Let STMT_SET be 1

        If update_type is equal to STMT_SET:
            Note: Set i to i plus 1
            Let update_expr be memory_get_pointer(update_stmt, 16)
            Let update_expr_type be memory_get_int32(update_expr, 0)
            Let EXPR_BINARY_OP be 3

            If update_expr_type is equal to EXPR_BINARY_OP:
                Let update_op be memory_get_int32(update_expr, 16)
                Let TOKEN_PLUS be 16
                Let TOKEN_MINUS be 17

                If update_op is equal to TOKEN_PLUS:
                    Note: i plus 1 means step = 1 (already default)
                    Let step_expr be memory_get_pointer(update_expr, 24)
                    Let step_type be memory_get_int32(step_expr, 0)
                    Let EXPR_INTEGER_LITERAL be 0

                    If step_type is equal to EXPR_INTEGER_LITERAL:
                        Let step_str be memory_get_pointer(step_expr, 8)
                        Let step_value be string_to_integer(step_str)
                        memory_set_int32(bounds, 24, step_value)
                    End If
                Otherwise If update_op is equal to TOKEN_MINUS:
                    Note: i minus 1 means step = -1
                    Let step_expr be memory_get_pointer(update_expr, 24)
                    Let step_type be memory_get_int32(step_expr, 0)
                    Let EXPR_INTEGER_LITERAL be 0

                    If step_type is equal to EXPR_INTEGER_LITERAL:
                        Let step_str be memory_get_pointer(step_expr, 8)
                        Let step_value be string_to_integer(step_str)
                        Let neg_step be 0 minus step_value
                        memory_set_int32(bounds, 24, neg_step)
                    End If
                End If
            End If
        End If
    End If

    Return bounds
End Process

Note: Compute range for For loop variable
Process called "compute_for_loop_range" takes bounds as Integer, env as Integer returns Integer:
    Let start_expr be memory_get_pointer(bounds, 8)
    Let end_expr be memory_get_pointer(bounds, 16)
    Let step be memory_get_int32(bounds, 24)

    Note: Compute start and end ranges
    If start_expr is equal to 0:
        Return range_create_unknown()
    End If
    If end_expr is equal to 0:
        Return range_create_unknown()
    End If

    Let start_range be infer_expression_range(start_expr, env)
    Let end_range be infer_expression_range(end_expr, env)

    Let start_is_unknown be range_is_unknown(start_range)
    Let end_is_unknown be range_is_unknown(end_range)

    If start_is_unknown is equal to 1:
        Return range_create_unknown()
    End If
    If end_is_unknown is equal to 1:
        Return range_create_unknown()
    End If

    Note: Get concrete values
    Let start_min be range_get_min(start_range)
    Let start_max be range_get_max(start_range)
    Let end_min be range_get_min(end_range)
    Let end_max be range_get_max(end_range)

    Note: Loop variable ranges from start to end (exclusive)
    Note: Conservative: use widest possible range
    Let loop_min be start_min
    Let loop_max be end_max

    Note: Adjust for step direction
    If step is less than 0:
        Note: Counting down: loop var goes from start_max down to end_min
        Set loop_min to end_min
        Set loop_max to start_max
    End If

    Return range_create(loop_min, loop_max)
End Process

Note: Detect natural loops (all blocks dominated by loop header and reachable from back edge)
Process called "find_natural_loop_body" takes cfg as Integer, domset as Integer, header_id as Integer, back_edge_source as Integer returns Integer:
    Note: Natural loop = all blocks X such that header dominates X and X can reach back_edge_source

    Let body_blocks be list_create()
    Let dummy be list_append(body_blocks, header_id)
    Let dummy2 be list_append(body_blocks, back_edge_source)

    Note: Worklist algorithm: start from back_edge_source, walk backwards
    Let worklist be list_create()
    Let dummy3 be list_append(worklist, back_edge_source)

    While list_length(worklist) is greater than 0:
        Let current_id be list_get(worklist, 0)
        Let dummy4 be list_remove_at(worklist, 0)

        Let current_bb be cfg_get_block(cfg, current_id)
        Let pred_count be memory_get_int32(current_bb, 32)
        Let preds be memory_get_pointer(current_bb, 24)

        Let i be 0
        While i is less than pred_count:
            Let pred_offset be i multiplied by 4
            Let pred_id be memory_get_int32(preds, pred_offset)

            Note: Check if pred is dominated by header
            Let is_dominated be domset_contains(domset, pred_id, header_id)

            If is_dominated is equal to 1:
                Note: Check if already in body_blocks
                Let already_added be 0
                Let j be 0
                While j is less than list_length(body_blocks):
                    Let existing_id be list_get(body_blocks, j)
                    If existing_id is equal to pred_id:
                        Set already_added to 1
                    End If
                    Set j to j plus 1
                End While

                If already_added is equal to 0:
                    Let dummy5 be list_append(body_blocks, pred_id)
                    Let dummy6 be list_append(worklist, pred_id)
                End If
            End If

            Set i to i plus 1
        End While
    End While

    Return body_blocks
End Process

Note: Print loop information for debugging
Process called "print_loops" takes loops as Integer returns Integer:
    Display "=== Loop Analysis ==="

    Let loop_count be list_length(loops)
    Display "Found ", integer_to_string(loop_count), " loops"

    Let i be 0
    While i is less than loop_count:
        Let loop be list_get(loops, i)
        Let header_id be memory_get_int32(loop, 0)
        Let loop_type be memory_get_int32(loop, 20)

        Display "Loop ", integer_to_string(i), ":"
        Display "  Header: ", integer_to_string(header_id)

        If loop_type is equal to LOOP_TYPE_FOR:
            Display "  Type: FOR"
        Otherwise If loop_type is equal to LOOP_TYPE_WHILE:
            Display "  Type: WHILE"
        End If

        Set i to i plus 1
    End While

    Return 0
End Process
