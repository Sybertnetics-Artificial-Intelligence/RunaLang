Note:
bootstrap/partial-runa/diagnostic_system.runa
Diagnostic and Error Reporting System for Partial Self-Hosting

This module provides comprehensive error handling, diagnostic reporting, and
error recovery mechanisms for the partial Runa compiler.

Key features and capabilities:
- Multi-level error severity (error, warning, note, help)
- Source location tracking with line/column information
- Context-aware error messages with code snippets
- Error recovery strategies for continued parsing
- Diagnostic accumulation and deduplication
- Suggested fixes and helpful hints
- Color-coded terminal output support
- Machine-readable diagnostic output (JSON)
- Integration with all compiler phases
- Error handling approach
- Memory management considerations
- Performance impact minimization
:End Note

Import module "core_libs" as Core

Note: Parser types defined locally since parser_frontend not yet available
Type called "Token":
    type as String                      Note: Token type identifier
    value as String                     Note: Token value/content
    position as Integer                 Note: Position in source
End Type

Type called "TokenStream":
    tokens as List[Token]               Note: Token sequence
    position as Integer                 Note: Current position
End Type

Note: =====================================================================
Note: DIAGNOSTIC DATA STRUCTURES
Note: =====================================================================

Type called "SourceLocation":
    file_path as String                 Note: Source file path
    line as Integer                     Note: Line number (1-based)
    column as Integer                   Note: Column number (1-based)
    offset as Integer                   Note: Byte offset in file
    length as Integer                   Note: Length of the span
End Type

Type called "Diagnostic":
    severity as String                  Note: error, warning, note, help
    code as String                      Note: Error code (e.g., E0001)
    message as String                   Note: Primary diagnostic message
    location as SourceLocation          Note: Where the issue occurred
    secondary_locations as List[SourceLocation] Note: Related locations
    notes as List[String]               Note: Additional notes
    suggestions as List[Suggestion]     Note: Suggested fixes
    context_lines as List[String]       Note: Source code context
End Type

Type called "Suggestion":
    message as String                   Note: Description of the fix
    location as SourceLocation          Note: Where to apply the fix
    replacement as String               Note: Suggested replacement text
    applicability as String             Note: machine-applicable, maybe-incorrect, etc.
End Type

Type called "DiagnosticContext":
    diagnostics as List[Diagnostic]     Note: Accumulated diagnostics
    error_count as Integer              Note: Number of errors
    warning_count as Integer            Note: Number of warnings
    max_errors as Integer               Note: Maximum errors before stopping
    source_cache as Dictionary[String, List[String]] Note: Cached source files
    color_output as Boolean             Note: Enable colored output
    output_format as String             Note: text, json, etc.
End Type

Type called "ErrorRecoveryStrategy":
    strategy_type as String             Note: panic, synchronize, insertion
    sync_tokens as List[String]         Note: Tokens to synchronize on
    max_lookahead as Integer            Note: Maximum tokens to skip
    recovery_point as Integer           Note: Where to resume parsing
End Type

Type called "DiagnosticResult":
    has_errors as Boolean               Note: Whether any errors occurred
    can_continue as Boolean             Note: Whether compilation can proceed
    diagnostics as List[Diagnostic]     Note: All diagnostics
    recovery_actions as List[String]    Note: Recovery actions taken
End Type

Note: =====================================================================
Note: DIAGNOSTIC CREATION OPERATIONS
Note: =====================================================================

Process called "create_diagnostic_context" returns DiagnosticContext:
    Note: Initialize diagnostic collection system
    Note: Sets up source cache and configuration
    Note: Detects terminal capabilities for color
    
    Let empty_diagnostics be Core.create_list()
    Let empty_source_cache be Core.create_dictionary()
    Let context be DiagnosticContext with 
        diagnostics as empty_diagnostics, 
        error_count as 0, 
        warning_count as 0, 
        max_errors as 100,
        source_cache as empty_source_cache,
        color_output as true,
        output_format as "text"
    
    Return context
End Process

Process called "report_error" that takes context as DiagnosticContext, code as String, message as String, location as SourceLocation returns Diagnostic:
    Note: Report a compilation error
    Note: Increments error count
    Note: May trigger compilation termination
    
    Let empty_secondary as Core.create_list()
    Let empty_notes as Core.create_list()
    Let empty_suggestions as Core.create_list()
    Let empty_context as Core.create_list()
    
    Let diagnostic be Diagnostic with
        severity as "error",
        code as code,
        message as message,
        location as location,
        secondary_locations as empty_secondary,
        notes as empty_notes,
        suggestions as empty_suggestions,
        context_lines as empty_context
    
    Core.list_append(context.diagnostics, diagnostic)
    Set context.error_count to Core.add(context.error_count, 1)
    
    Return diagnostic
End Process

Process called "report_warning" that takes context as DiagnosticContext, code as String, message as String, location as SourceLocation returns Diagnostic:
    Note: Report a compilation warning
    Note: Does not affect compilation success
    Note: Can be promoted to error with flags
    
    Let empty_secondary as Core.create_list()
    Let empty_notes as Core.create_list()
    Let empty_suggestions as Core.create_list()
    Let empty_context as Core.create_list()
    
    Let diagnostic be Diagnostic with
        severity as "warning",
        code as code,
        message as message,
        location as location,
        secondary_locations as empty_secondary,
        notes as empty_notes,
        suggestions as empty_suggestions,
        context_lines as empty_context
    
    Core.list_append(context.diagnostics, diagnostic)
    Set context.warning_count to Core.add(context.warning_count, 1)
    
    Return diagnostic
End Process

Process called "add_note" that takes diagnostic as Diagnostic, message as String, location as Optional[SourceLocation] returns Diagnostic:
    Note: Add explanatory note to diagnostic
    Note: Provides additional context
    Note: Can have its own location
    
    Core.list_append(diagnostic.notes, message)
    
    If location is not null:
        Core.list_append(diagnostic.secondary_locations, location)
    End If
    
    Return diagnostic
End Process

Process called "suggest_fix" that takes diagnostic as Diagnostic, suggestion as Suggestion returns Diagnostic:
    Note: Add suggested fix to diagnostic
    Note: May be automatically applicable
    Note: Helps users resolve issues
    
    Core.list_append(diagnostic.suggestions, suggestion)
    Return diagnostic
End Process

Note: =====================================================================
Note: SOURCE LOCATION OPERATIONS
Note: =====================================================================

Process called "create_source_location" that takes file as String, line as Integer, column as Integer, length as Integer returns SourceLocation:
    Note: Create source location descriptor
    Note: Validates location parameters
    Note: Calculates byte offset if needed
    
    If line is less than 1:
        Let error be Core.ValueError with message as "Line number must be positive", value as line
        Throw error
    End If
    
    If column is less than 1:
        Let error be Core.ValueError with message as "Column number must be positive", value as column
        Throw error
    End If
    
    If length is less than 0:
        Let error be Core.ValueError with message as "Length cannot be negative", value as length
        Throw error
    End If
    
    Let offset be Core.multiply(Core.subtract(line, 1), 80)
    Set offset to Core.add(offset, Core.subtract(column, 1))
    
    Let location be SourceLocation with
        file_path as file,
        line as line,
        column as column,
        offset as offset,
        length as length
    
    Return location
End Process

Process called "expand_location" that takes start as SourceLocation, end as SourceLocation returns SourceLocation:
    Note: Create spanning location from two points
    Note: Used for multi-token constructs
    Note: Validates locations are in same file
    
    If Core.string_compare(start.file_path, end.file_path) is not equal to 0:
        Let error be Core.ValueError with 
            message as "Cannot expand locations across different files", 
            value as start.file_path
        Throw error
    End If
    
    Let start_offset be start.offset
    Let end_offset be Core.add(end.offset, end.length)
    Let total_length be Core.subtract(end_offset, start_offset)
    
    Let expanded be SourceLocation with
        file_path as start.file_path,
        line as start.line,
        column as start.column,
        offset as start_offset,
        length as total_length
    
    Return expanded
End Process

Process called "get_source_context" that takes context as DiagnosticContext, location as SourceLocation, lines_before as Integer, lines_after as Integer returns List[String]:
    Note: Extract source code context around location
    Note: Caches file contents for efficiency
    Note: Handles file boundaries gracefully
    
    Let file_lines be Core.dictionary_get(context.source_cache, location.file_path)
    
    If file_lines is null:
        Note: File not cached, create empty context for now
        Let empty_result be Core.create_list()
        Return empty_result
    End If
    
    Let result_lines be Core.create_list()
    Let start_line be Core.max(1, Core.subtract(location.line, lines_before))
    Let end_line be Core.min(Core.list_length(file_lines), Core.add(location.line, lines_after))
    
    Let current_line be start_line
    While current_line is less than or equal to end_line:
        Let line_content be Core.list_get(file_lines, Core.subtract(current_line, 1))
        Core.list_append(result_lines, line_content)
        Set current_line to Core.add(current_line, 1)
    End While
    
    Return result_lines
End Process

Note: =====================================================================
Note: ERROR RECOVERY OPERATIONS
Note: =====================================================================

Process called "create_recovery_strategy" that takes error_type as String, current_token as Token returns ErrorRecoveryStrategy:
    Note: Determine recovery strategy for error type
    Note: Selects appropriate synchronization tokens
    Note: Configures recovery parameters
    
    Let sync_tokens be Core.create_list()
    Let strategy_type be "panic"
    Let max_lookahead be 10
    
    If Core.string_compare(error_type, "syntax") is equal to 0:
        Core.list_append(sync_tokens, "semicolon")
        Core.list_append(sync_tokens, "end")
        Core.list_append(sync_tokens, "process")
        Core.list_append(sync_tokens, "type")
        Set max_lookahead to 5
    Otherwise if Core.string_compare(error_type, "type") is equal to 0:
        Core.list_append(sync_tokens, "end")
        Core.list_append(sync_tokens, "returns")
        Set max_lookahead to 3
        Set strategy_type to "synchronize"
    Otherwise if Core.string_compare(error_type, "expression") is equal to 0:
        Core.list_append(sync_tokens, "semicolon")
        Core.list_append(sync_tokens, "end")
        Set strategy_type to "insertion"
        Set max_lookahead to 2
    Otherwise:
        Core.list_append(sync_tokens, "end")
        Set max_lookahead to 10
    End If
    
    Let strategy be ErrorRecoveryStrategy with
        strategy_type as strategy_type,
        sync_tokens as sync_tokens,
        max_lookahead as max_lookahead,
        recovery_point as current_token.position
    
    Return strategy
End Process

Process called "synchronize_parser" that takes tokens as TokenStream, strategy as ErrorRecoveryStrategy returns Integer:
    Note: Skip tokens until synchronization point
    Note: Implements panic mode recovery
    Note: Returns position to resume parsing
    
    Let current_pos be tokens.position
    Let tokens_skipped be 0
    
    While current_pos is less than Core.list_length(tokens.tokens):
        If tokens_skipped is greater than or equal to strategy.max_lookahead:
            Break
        End If
        
        Let current_token be Core.list_get(tokens.tokens, current_pos)
        
        Let token_index be 0
        Let found_sync be false
        While token_index is less than Core.list_length(strategy.sync_tokens):
            Let sync_token be Core.list_get(strategy.sync_tokens, token_index)
            If Core.string_compare(current_token.type, sync_token) is equal to 0:
                Set found_sync to true
                Break
            End If
            Set token_index to Core.add(token_index, 1)
        End While
        
        If found_sync is equal to true:
            Return current_pos
        End If
        
        Set current_pos to Core.add(current_pos, 1)
        Set tokens_skipped to Core.add(tokens_skipped, 1)
    End While
    
    Return current_pos
End Process

Process called "insert_missing_token" that takes expected as String, location as SourceLocation returns Token:
    Note: Create synthetic token for recovery
    Note: Used for insertion-based recovery
    Note: Maintains parse tree structure
    
    Let synthetic_value be expected
    If Core.string_compare(expected, "semicolon") is equal to 0:
        Set synthetic_value to ";"
    Otherwise if Core.string_compare(expected, "end") is equal to 0:
        Set synthetic_value to "End"
    Otherwise if Core.string_compare(expected, "identifier") is equal to 0:
        Set synthetic_value to "_missing_identifier"
    End If
    
    Let synthetic_token be Token with
        type as expected,
        value as synthetic_value,
        position as location.offset
    
    Return synthetic_token
End Process

Process called "can_recover_from" that takes diagnostic as Diagnostic returns Boolean:
    Note: Determine if error is recoverable
    Note: Some errors require immediate termination
    Note: Considers error severity and type
    
    If Core.string_compare(diagnostic.severity, "error") is not equal to 0:
        Return true
    End If
    
    If Core.string_starts_with(diagnostic.code, "F"):
        Note: Fatal errors are not recoverable
        Return false
    End If
    
    If Core.string_starts_with(diagnostic.code, "E001"):
        Note: Internal compiler errors are not recoverable
        Return false
    End If
    
    If Core.string_contains(diagnostic.message, "out of memory"):
        Return false
    End If
    
    If Core.string_contains(diagnostic.message, "stack overflow"):
        Return false
    End If
    
    Return true
End Process

Note: =====================================================================
Note: DIAGNOSTIC FORMATTING OPERATIONS
Note: =====================================================================

Process called "format_diagnostic" that takes diagnostic as Diagnostic, context as DiagnosticContext returns String:
    Note: Format diagnostic for display
    Note: Includes source context and highlighting
    Note: Applies color coding if enabled
    
    Let result be ""
    
    If context.color_output is equal to true:
        If Core.string_compare(diagnostic.severity, "error") is equal to 0:
            Set result to Core.string_concat(result, "\033[31m")  Note: Red color
        Otherwise if Core.string_compare(diagnostic.severity, "warning") is equal to 0:
            Set result to Core.string_concat(result, "\033[33m")  Note: Yellow color
        Otherwise:
            Set result to Core.string_concat(result, "\033[36m")  Note: Cyan color
        End If
    End If
    
    Set result to Core.string_concat(result, diagnostic.severity)
    Set result to Core.string_concat(result, "[")
    Set result to Core.string_concat(result, diagnostic.code)
    Set result to Core.string_concat(result, "]: ")
    Set result to Core.string_concat(result, diagnostic.message)
    
    If context.color_output is equal to true:
        Set result to Core.string_concat(result, "\033[0m")  Note: Reset color
    End If
    
    Set result to Core.string_concat(result, " at ")
    Set result to Core.string_concat(result, diagnostic.location.file_path)
    Set result to Core.string_concat(result, ":")
    Set result to Core.string_concat(result, Core.integer_to_string(diagnostic.location.line))
    Set result to Core.string_concat(result, ":")
    Set result to Core.string_concat(result, Core.integer_to_string(diagnostic.location.column))
    Set result to Core.string_concat(result, "\n")
    
    Return result
End Process

Process called "format_source_snippet" that takes lines as List[String], location as SourceLocation, highlight_color as String returns String:
    Note: Format source code snippet with highlighting
    Note: Shows line numbers and error markers
    Note: Underlines problematic code
    
    Let result be ""
    Let line_index be 0
    Let base_line be Core.subtract(location.line, Core.divide(Core.list_length(lines), 2))
    
    While line_index is less than Core.list_length(lines):
        Let current_line be Core.add(base_line, line_index)
        Let line_content be Core.list_get(lines, line_index)
        
        Let line_prefix be Core.integer_to_string(current_line)
        Set line_prefix to Core.string_pad_left(line_prefix, 4, " ")
        Set line_prefix to Core.string_concat(line_prefix, " | ")
        
        Set result to Core.string_concat(result, line_prefix)
        Set result to Core.string_concat(result, line_content)
        Set result to Core.string_concat(result, "\n")
        
        If current_line is equal to location.line:
            Let spaces be Core.string_repeat(" ", Core.add(Core.string_length(line_prefix), Core.subtract(location.column, 1)))
            Set result to Core.string_concat(result, spaces)
            Set result to Core.string_concat(result, highlight_color)
            Set result to Core.string_concat(result, Core.string_repeat("^", location.length))
            Set result to Core.string_concat(result, "\033[0m")
            Set result to Core.string_concat(result, "\n")
        End If
        
        Set line_index to Core.add(line_index, 1)
    End While
    
    Return result
End Process

Process called "format_json_diagnostic" that takes diagnostic as Diagnostic returns String:
    Note: Format diagnostic as JSON
    Note: Machine-readable format for tools
    Note: Includes all diagnostic information
    
    Let json be "{"
    Set json to Core.string_concat(json, "\"severity\":\"")
    Set json to Core.string_concat(json, diagnostic.severity)
    Set json to Core.string_concat(json, "\",\"code\":\"")
    Set json to Core.string_concat(json, diagnostic.code)
    Set json to Core.string_concat(json, "\",\"message\":\"")
    Set json to Core.string_concat(json, Core.string_escape_json(diagnostic.message))
    Set json to Core.string_concat(json, "\",\"location\":{")
    Set json to Core.string_concat(json, "\"file\":\"")
    Set json to Core.string_concat(json, Core.string_escape_json(diagnostic.location.file_path))
    Set json to Core.string_concat(json, "\",\"line\":")
    Set json to Core.string_concat(json, Core.integer_to_string(diagnostic.location.line))
    Set json to Core.string_concat(json, ",\"column\":")
    Set json to Core.string_concat(json, Core.integer_to_string(diagnostic.location.column))
    Set json to Core.string_concat(json, ",\"length\":")
    Set json to Core.string_concat(json, Core.integer_to_string(diagnostic.location.length))
    Set json to Core.string_concat(json, "}}")
    
    Return json
End Process

Note: =====================================================================
Note: DIAGNOSTIC MANAGEMENT OPERATIONS
Note: =====================================================================

Process called "deduplicate_diagnostics" that takes context as DiagnosticContext returns Integer:
    Note: Remove duplicate diagnostics
    Note: Identifies same error reported multiple times
    Note: Returns number of duplicates removed
    
    Let unique_diagnostics be Core.create_list()
    Let duplicates_removed be 0
    Let outer_index be 0
    
    While outer_index is less than Core.list_length(context.diagnostics):
        Let current_diagnostic be Core.list_get(context.diagnostics, outer_index)
        Let is_duplicate be false
        Let inner_index be 0
        
        While inner_index is less than Core.list_length(unique_diagnostics):
            Let existing_diagnostic be Core.list_get(unique_diagnostics, inner_index)
            
            If Core.string_compare(current_diagnostic.code, existing_diagnostic.code) is equal to 0:
                If Core.string_compare(current_diagnostic.message, existing_diagnostic.message) is equal to 0:
                    If current_diagnostic.location.line is equal to existing_diagnostic.location.line:
                        If current_diagnostic.location.column is equal to existing_diagnostic.location.column:
                            Set is_duplicate to true
                            Break
                        End If
                    End If
                End If
            End If
            
            Set inner_index to Core.add(inner_index, 1)
        End While
        
        If is_duplicate is equal to false:
            Core.list_append(unique_diagnostics, current_diagnostic)
        Otherwise:
            Set duplicates_removed to Core.add(duplicates_removed, 1)
        End If
        
        Set outer_index to Core.add(outer_index, 1)
    End While
    
    Set context.diagnostics to unique_diagnostics
    Return duplicates_removed
End Process

Process called "sort_diagnostics" that takes diagnostics as List[Diagnostic] returns List[Diagnostic]:
    Note: Sort diagnostics by location
    Note: Groups related diagnostics together
    Note: Improves readability of output
    
    Let sorted_diagnostics be Core.create_list()
    Let input_count be Core.list_length(diagnostics)
    
    Note: Simple insertion sort for small diagnostic lists
    Let source_index be 0
    While source_index is less than input_count:
        Let current_diagnostic be Core.list_get(diagnostics, source_index)
        Let insert_position be 0
        
        Note: Find correct insertion position
        Let sorted_count be Core.list_length(sorted_diagnostics)
        While insert_position is less than sorted_count:
            Let existing_diagnostic be Core.list_get(sorted_diagnostics, insert_position)
            
            Note: Compare file paths first
            Let file_compare be Core.string_compare(current_diagnostic.location.file_path, existing_diagnostic.location.file_path)
            
            If file_compare is less than 0:
                Break
            Otherwise if file_compare is equal to 0:
                Note: Same file, compare line numbers
                If current_diagnostic.location.line is less than existing_diagnostic.location.line:
                    Break
                Otherwise if current_diagnostic.location.line is equal to existing_diagnostic.location.line:
                    Note: Same line, compare column numbers
                    If current_diagnostic.location.column is less than existing_diagnostic.location.column:
                        Break
                    End If
                End If
            End If
            
            Set insert_position to Core.add(insert_position, 1)
        End While
        
        Core.list_insert(sorted_diagnostics, insert_position, current_diagnostic)
        Set source_index to Core.add(source_index, 1)
    End While
    
    Return sorted_diagnostics
End Process

Process called "should_continue_compilation" that takes context as DiagnosticContext returns Boolean:
    Note: Decide if compilation should continue
    Note: Considers error count and severity
    Note: Respects max error limit
    
    If context.error_count is greater than or equal to context.max_errors:
        Return false
    End If
    
    Note: Check for fatal errors in diagnostics
    Let diagnostic_index be 0
    While diagnostic_index is less than Core.list_length(context.diagnostics):
        Let diagnostic be Core.list_get(context.diagnostics, diagnostic_index)
        
        If can_recover_from(diagnostic) is equal to false:
            Return false
        End If
        
        Set diagnostic_index to Core.add(diagnostic_index, 1)
    End While
    
    Return true
End Process

Note: =====================================================================
Note: DIAGNOSTIC OUTPUT OPERATIONS
Note: =====================================================================

Process called "emit_diagnostics" that takes context as DiagnosticContext, output_stream as Core.Stream returns Boolean:
    Note: Output all diagnostics to stream
    Note: Formats according to output settings
    Note: Returns success status
    
    Let sorted_diagnostics be sort_diagnostics(context.diagnostics)
    Let diagnostic_index be 0
    Let success be true
    
    While diagnostic_index is less than Core.list_length(sorted_diagnostics):
        Let diagnostic be Core.list_get(sorted_diagnostics, diagnostic_index)
        Let formatted_output be ""
        
        If Core.string_compare(context.output_format, "json") is equal to 0:
            Set formatted_output to format_json_diagnostic(diagnostic)
        Otherwise:
            Set formatted_output to format_diagnostic(diagnostic, context)
        End If
        
        Let write_result be Core.stream_write(output_stream, formatted_output)
        If write_result is equal to false:
            Set success to false
            Break
        End If
        
        Set diagnostic_index to Core.add(diagnostic_index, 1)
    End While
    
    Return success
End Process

Process called "emit_summary" that takes context as DiagnosticContext, output_stream as Core.Stream returns String:
    Note: Output diagnostic summary
    Note: Shows error and warning counts
    Note: Indicates compilation success/failure
    
    Let summary be ""
    
    If context.error_count is equal to 0:
        If context.warning_count is equal to 0:
            Set summary to "Compilation completed successfully with no diagnostics.\n"
        Otherwise:
            Set summary to "Compilation completed successfully with "
            Set summary to Core.string_concat(summary, Core.integer_to_string(context.warning_count))
            Set summary to Core.string_concat(summary, " warning")
            If context.warning_count is not equal to 1:
                Set summary to Core.string_concat(summary, "s")
            End If
            Set summary to Core.string_concat(summary, ".\n")
        End If
    Otherwise:
        Set summary to "Compilation failed with "
        Set summary to Core.string_concat(summary, Core.integer_to_string(context.error_count))
        Set summary to Core.string_concat(summary, " error")
        If context.error_count is not equal to 1:
            Set summary to Core.string_concat(summary, "s")
        End If
        
        If context.warning_count is greater than 0:
            Set summary to Core.string_concat(summary, " and ")
            Set summary to Core.string_concat(summary, Core.integer_to_string(context.warning_count))
            Set summary to Core.string_concat(summary, " warning")
            If context.warning_count is not equal to 1:
                Set summary to Core.string_concat(summary, "s")
            End If
        End If
        
        Set summary to Core.string_concat(summary, ".\n")
    End If
    
    Core.stream_write(output_stream, summary)
    Return summary
End Process