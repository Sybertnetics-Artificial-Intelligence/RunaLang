Note:
test_inline_assembly.runa - Test inline assembly support in partial-runa compiler

This test verifies that the bootstrap compiler can parse and handle inline Assembly statements.
These will be used to implement zero-dependency primitives for true self-hosting.
:End Note

Process called "test_add_with_assembly" that takes a as Integer64, b as Integer64 returns Integer64:
    Note: Test inline assembly for addition
    Assembly "add %[result], %[a], %[b]"
End Process

Process called "test_mul_with_assembly" that takes a as Integer64, b as Integer64 returns Integer64:
    Note: Test inline assembly for multiplication
    Assembly "imul %[result], %[a], %[b]"
End Process

Process called "test_bitwise_with_assembly" that takes a as Integer64, b as Integer64 returns Integer64:
    Note: Test inline assembly for bitwise AND
    Assembly "and %[result], %[a], %[b]"
End Process

Process called "test_compare_with_assembly" that takes a as Integer64, b as Integer64 returns Boolean:
    Note: Test inline assembly for comparison
    Assembly "cmp %[a], %[b]; sete %[result]"
End Process

Process called "test_memory_with_assembly" that takes ptr as Pointer returns Integer64:
    Note: Test inline assembly for memory load
    Assembly "mov %[result], [%[ptr]]"
End Process

Process called "test_stack_with_assembly" returns Pointer:
    Note: Test inline assembly for stack pointer access
    Assembly "mov %[result], rsp"
End Process

Process called "main" returns Integer:
    Note: Main test function
    
    Note: Test arithmetic operations
    Let sum be test_add_with_assembly(5, 3)
    Let product be test_mul_with_assembly(4, 7)
    
    Note: Test bitwise operations
    Let bit_result be test_bitwise_with_assembly(12, 5)
    
    Note: Test comparison
    Let are_equal be test_compare_with_assembly(10, 10)
    
    Note: Test stack access
    Let stack_ptr be test_stack_with_assembly()
    
    Note: If we get here, inline assembly parsing works
    Return 0
End Process