Note: Test diagnostic system interfaces for compiler integration
Note: Validates data structures and APIs other components will use

Import module "core_libs" as Core
Import module "diagnostic_system" as Diag

Process called "test_diagnostic_data_structures" returns Boolean:
    Note: Validate that all diagnostic data structures are properly constructed
    
    Let context be Diag.create_diagnostic_context()
    Let location be Diag.create_source_location("test.runa", 1, 1, 1)
    
    Note: Test Diagnostic structure completeness
    Let diagnostic be Diag.report_error(context, "E001", "Test error", location)
    
    Note: Verify all required fields exist and are accessible
    If diagnostic.severity is null:
        Core.print_string("FAIL: Diagnostic.severity is null\n")
        Return false
    End If
    
    If diagnostic.code is null:
        Core.print_string("FAIL: Diagnostic.code is null\n")
        Return false
    End If
    
    If diagnostic.message is null:
        Core.print_string("FAIL: Diagnostic.message is null\n")
        Return false
    End If
    
    If diagnostic.location is null:
        Core.print_string("FAIL: Diagnostic.location is null\n")
        Return false
    End If
    
    If diagnostic.secondary_locations is null:
        Core.print_string("FAIL: Diagnostic.secondary_locations is null\n")
        Return false
    End If
    
    If diagnostic.notes is null:
        Core.print_string("FAIL: Diagnostic.notes is null\n")
        Return false
    End If
    
    If diagnostic.suggestions is null:
        Core.print_string("FAIL: Diagnostic.suggestions is null\n")
        Return false
    End If
    
    If diagnostic.context_lines is null:
        Core.print_string("FAIL: Diagnostic.context_lines is null\n")
        Return false
    End If
    
    Note: Test SourceLocation structure
    If diagnostic.location.file_path is null:
        Core.print_string("FAIL: SourceLocation.file_path is null\n")
        Return false
    End If
    
    If diagnostic.location.line is less than 1:
        Core.print_string("FAIL: SourceLocation.line is invalid\n")
        Return false
    End If
    
    If diagnostic.location.column is less than 1:
        Core.print_string("FAIL: SourceLocation.column is invalid\n")
        Return false
    End If
    
    Note: Test DiagnosticContext structure
    If context.diagnostics is null:
        Core.print_string("FAIL: DiagnosticContext.diagnostics is null\n")
        Return false
    End If
    
    If context.source_cache is null:
        Core.print_string("FAIL: DiagnosticContext.source_cache is null\n")
        Return false
    End If
    
    Core.print_string("PASS: Data structures\n")
    Return true
End Process

Process called "test_compiler_integration_apis" returns Boolean:
    Note: Test APIs that will be used by parser, semantic analyzer, etc.
    
    Let context be Diag.create_diagnostic_context()
    
    Note: Test APIs for reporting different error types (what parser will use)
    Let syntax_loc be Diag.create_source_location("parser_test.runa", 5, 10, 3)
    Let syntax_error be Diag.report_error(context, "E101", "Expected 'End Process' but found 'End If'", syntax_loc)
    
    Let semantic_loc be Diag.create_source_location("semantic_test.runa", 12, 5, 8)
    Let semantic_error be Diag.report_error(context, "E201", "Type mismatch: expected Integer, got String", semantic_loc)
    
    Let warning_loc be Diag.create_source_location("warning_test.runa", 8, 15, 4)
    Let unused_warning be Diag.report_warning(context, "W101", "Unused variable 'result'", warning_loc)
    
    Note: Test error recovery (what parser will use for error recovery)
    Let parser_token be Diag.Token with type as "identifier", value as "foo", position as 100
    Let recovery_strategy be Diag.create_recovery_strategy("syntax", parser_token)
    
    If Core.string_compare(recovery_strategy.strategy_type, "panic") is not equal to 0:
        Core.print_string("FAIL: Recovery strategy type incorrect\n")
        Return false
    End If
    
    If Core.list_length(recovery_strategy.sync_tokens) is equal to 0:
        Core.print_string("FAIL: Recovery strategy has no sync tokens\n")
        Return false
    End If
    
    Note: Test token stream for recovery
    Let tokens be Core.create_list()
    Core.list_append(tokens, Diag.Token with type as "identifier", value as "bad", position as 0)
    Core.list_append(tokens, Diag.Token with type as "semicolon", value as ";", position as 1)
    Core.list_append(tokens, Diag.Token with type as "end", value as "End", position as 2)
    
    Let token_stream be Diag.TokenStream with tokens as tokens, position as 0
    Let recovery_pos be Diag.synchronize_parser(token_stream, recovery_strategy)
    
    If recovery_pos is less than 0:
        Core.print_string("FAIL: Recovery position is invalid\n")
        Return false
    End If
    
    Note: Test compilation continuation (what driver will use)
    Let can_continue be Diag.should_continue_compilation(context)
    If can_continue is not equal to true:
        Core.print_string("FAIL: Should be able to continue with recoverable errors\n")
        Return false
    End If
    
    Note: Test diagnostic output (what driver will use for final output)
    Let stdout_stream be Core.create_stream(1, "write")  Note: stdout
    Let emit_success be Diag.emit_diagnostics(context, stdout_stream)
    
    If emit_success is not equal to true:
        Core.print_string("FAIL: Failed to emit diagnostics\n")
        Return false
    End If
    
    Let summary be Diag.emit_summary(context, stdout_stream)
    If Core.string_length(summary) is equal to 0:
        Core.print_string("FAIL: Summary is empty\n")
        Return false
    End If
    
    Core.print_string("PASS: Compiler integration APIs\n")
    Return true
End Process

Process called "test_performance_characteristics" returns Boolean:
    Note: Test that diagnostic system can handle typical compiler workloads
    
    Let context be Diag.create_diagnostic_context()
    
    Note: Create many diagnostics (simulate large file with many errors)
    Let error_count be 0
    While error_count is less than 50:
        Let loc be Diag.create_source_location("large_file.runa", error_count, 1, 1)
        Let msg be Core.string_concat("Error number ", Core.integer_to_string(error_count))
        Let diag be Diag.report_error(context, "E999", msg, loc)
        Set error_count to Core.add(error_count, 1)
    End While
    
    Note: Test deduplication performance
    Let duplicates_removed be Diag.deduplicate_diagnostics(context)
    If duplicates_removed is less than 0:
        Core.print_string("FAIL: Deduplication returned negative value\n")
        Return false
    End If
    
    Note: Test sorting performance
    Let sorted_diagnostics be Diag.sort_diagnostics(context.diagnostics)
    If Core.list_length(sorted_diagnostics) is not equal to Core.list_length(context.diagnostics):
        Core.print_string("FAIL: Sorting changed number of diagnostics\n")
        Return false
    End If
    
    Note: Verify error count is still correct
    If context.error_count is not equal to Core.subtract(50, duplicates_removed):
        Core.print_string("FAIL: Error count incorrect after operations\n")
        Return false
    End If
    
    Core.print_string("PASS: Performance characteristics\n")
    Return true
End Process

Process called "main" returns Integer:
    Note: Run interface validation tests
    
    Core.print_string("=== Diagnostic Interface Tests ===\n")
    
    Let all_passed be true
    
    If test_diagnostic_data_structures() is equal to false:
        Set all_passed to false
    End If
    
    If test_compiler_integration_apis() is equal to false:
        Set all_passed to false
    End If
    
    If test_performance_characteristics() is equal to false:
        Set all_passed to false
    End If
    
    If all_passed is equal to true:
        Core.print_string("=== ALL INTERFACE TESTS PASSED ===\n")
        Return 0
    Otherwise:
        Core.print_string("=== INTERFACE TESTS FAILED ===\n")
        Return 1
    End If
End Process