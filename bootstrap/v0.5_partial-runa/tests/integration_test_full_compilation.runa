Note: Full compilation integration test
Note: Tests the complete pipeline from Runa source to executable via compiler_driver

Import module "../compiler_driver" as Driver
Import module "../core_libs" as Core

External Process called "rust_print_string" that takes text as String

Process called "test_simple_program_compilation" returns Boolean:
    Note: Test complete compilation of a simple Runa program
    
    rust_print_string("[TEST] Simple Program Full Compilation\n")
    
    Let test_program be "Process called \"main\" returns Nothing:\n    rust_print_string(\"Hello from compiled Runa!\\n\")\nEnd Process"
    
    Note: Create compilation request
    Let compilation_request be Driver.create_compilation_request()
    Set compilation_request.source_code to test_program
    Set compilation_request.output_name to "test_simple"
    Set compilation_request.optimization_level to "O1"
    Set compilation_request.target_platform to "x86_64-linux"
    
    Note: Run full compilation
    Let compilation_result be Driver.compile_program(compilation_request)
    
    If compilation_result.success is equal to false:
        rust_print_string("  ✗ Full compilation failed\n")
        For Each error in compilation_result.errors:
            rust_print_string("    Error: ")
            rust_print_string(error)
            rust_print_string("\n")
        End For
        Return false
    End If
    
    Note: Verify output files were generated
    If Core.file_exists(compilation_result.executable_path) is equal to false:
        rust_print_string("  ✗ Executable file was not generated\n")
        Return false
    End If
    
    rust_print_string("  ✓ Simple program compilation passed\n")
    Return true
End Process

Process called "test_multi_function_compilation" returns Boolean:
    Note: Test compilation of a program with multiple functions
    
    rust_print_string("[TEST] Multi-Function Compilation\n")
    
    Let test_program be "Process called \"add\" that takes a as Integer, b as Integer returns Integer:\n    Return a plus b\nEnd Process\n\nProcess called \"main\" returns Nothing:\n    Let result be add(10, 20)\n    rust_print_string(\"Result: \")\n    rust_print_string(Core.integer_to_string(result))\n    rust_print_string(\"\\n\")\nEnd Process"
    
    Let compilation_request be Driver.create_compilation_request()
    Set compilation_request.source_code to test_program
    Set compilation_request.output_name to "test_multi_func"
    Set compilation_request.optimization_level to "O2"
    Set compilation_request.target_platform to "x86_64-linux"
    
    Let compilation_result be Driver.compile_program(compilation_request)
    
    If compilation_result.success is equal to false:
        rust_print_string("  ✗ Multi-function compilation failed\n")
        For Each error in compilation_result.errors:
            rust_print_string("    Error: ")
            rust_print_string(error)
            rust_print_string("\n")
        End For
        Return false
    End If
    
    If Core.file_exists(compilation_result.executable_path) is equal to false:
        rust_print_string("  ✗ Multi-function executable was not generated\n")
        Return false
    End If
    
    rust_print_string("  ✓ Multi-function compilation passed\n")
    Return true
End Process

Process called "test_type_definition_compilation" returns Boolean:
    Note: Test compilation of programs with custom type definitions
    
    rust_print_string("[TEST] Type Definition Compilation\n")
    
    Let test_program be "Type called \"Person\":\n    name as String\n    age as Integer\nEnd Type\n\nProcess called \"create_person\" that takes name as String, age as Integer returns Person:\n    Return Person with name = name, age = age\nEnd Process\n\nProcess called \"main\" returns Nothing:\n    Let person be create_person(\"Alice\", 30)\n    rust_print_string(\"Created person\\n\")\nEnd Process"
    
    Let compilation_request be Driver.create_compilation_request()
    Set compilation_request.source_code to test_program
    Set compilation_request.output_name to "test_types"
    Set compilation_request.optimization_level to "O1"
    Set compilation_request.target_platform to "x86_64-linux"
    
    Let compilation_result be Driver.compile_program(compilation_request)
    
    If compilation_result.success is equal to false:
        rust_print_string("  ✗ Type definition compilation failed\n")
        For Each error in compilation_result.errors:
            rust_print_string("    Error: ")
            rust_print_string(error)
            rust_print_string("\n")
        End For
        Return false
    End If
    
    If Core.file_exists(compilation_result.executable_path) is equal to false:
        rust_print_string("  ✗ Type definition executable was not generated\n")
        Return false
    End If
    
    rust_print_string("  ✓ Type definition compilation passed\n")
    Return true
End Process

Process called "test_control_flow_compilation" returns Boolean:
    Note: Test compilation of programs with control flow
    
    rust_print_string("[TEST] Control Flow Compilation\n")
    
    Let test_program be "Process called \"main\" returns Nothing:\n    Let x be 10\n    If x greater than 5:\n        rust_print_string(\"x is greater than 5\\n\")\n    Otherwise:\n        rust_print_string(\"x is not greater than 5\\n\")\n    End If\n    \n    Let i be 0\n    While i less than 3:\n        rust_print_string(\"Loop iteration\\n\")\n        Set i to i plus 1\n    End While\nEnd Process"
    
    Let compilation_request be Driver.create_compilation_request()
    Set compilation_request.source_code to test_program
    Set compilation_request.output_name to "test_control_flow"
    Set compilation_request.optimization_level to "O2"
    Set compilation_request.target_platform to "x86_64-linux"
    
    Let compilation_result be Driver.compile_program(compilation_request)
    
    If compilation_result.success is equal to false:
        rust_print_string("  ✗ Control flow compilation failed\n")
        For Each error in compilation_result.errors:
            rust_print_string("    Error: ")
            rust_print_string(error)
            rust_print_string("\n")
        End For
        Return false
    End If
    
    If Core.file_exists(compilation_result.executable_path) is equal to false:
        rust_print_string("  ✗ Control flow executable was not generated\n")
        Return false
    End If
    
    rust_print_string("  ✓ Control flow compilation passed\n")
    Return true
End Process

Process called "test_optimization_levels" returns Boolean:
    Note: Test different optimization levels
    
    rust_print_string("[TEST] Optimization Levels\n")
    
    Let test_program be "Process called \"factorial\" that takes n as Integer returns Integer:\n    If n less than or equal to 1:\n        Return 1\n    Otherwise:\n        Return n times factorial(n minus 1)\n    End If\nEnd Process\n\nProcess called \"main\" returns Nothing:\n    Let result be factorial(5)\n    rust_print_string(\"Factorial result computed\\n\")\nEnd Process"
    
    Note: Test O0 optimization
    Let compilation_request be Driver.create_compilation_request()
    Set compilation_request.source_code to test_program
    Set compilation_request.output_name to "test_opt_o0"
    Set compilation_request.optimization_level to "O0"
    Set compilation_request.target_platform to "x86_64-linux"
    
    Let o0_result be Driver.compile_program(compilation_request)
    If o0_result.success is equal to false:
        rust_print_string("  ✗ O0 optimization compilation failed\n")
        Return false
    End If
    
    Note: Test O3 optimization
    Set compilation_request.output_name to "test_opt_o3"
    Set compilation_request.optimization_level to "O3"
    
    Let o3_result be Driver.compile_program(compilation_request)
    If o3_result.success is equal to false:
        rust_print_string("  ✗ O3 optimization compilation failed\n")
        Return false
    End If
    
    rust_print_string("  ✓ Optimization levels passed\n")
    Return true
End Process

Process called "test_incremental_compilation" returns Boolean:
    Note: Test incremental compilation with caching
    
    rust_print_string("[TEST] Incremental Compilation\n")
    
    Let test_program be "Process called \"helper\" returns String:\n    Return \"Helper function\"\nEnd Process\n\nProcess called \"main\" returns Nothing:\n    Let msg be helper()\n    rust_print_string(msg)\n    rust_print_string(\"\\n\")\nEnd Process"
    
    Note: First compilation - should cache results
    Let compilation_request be Driver.create_compilation_request()
    Set compilation_request.source_code to test_program
    Set compilation_request.output_name to "test_incremental_1"
    Set compilation_request.optimization_level to "O1"
    Set compilation_request.target_platform to "x86_64-linux"
    Set compilation_request.use_incremental to true
    
    Let first_result be Driver.compile_program(compilation_request)
    If first_result.success is equal to false:
        rust_print_string("  ✗ First incremental compilation failed\n")
        Return false
    End If
    
    Note: Second compilation with minor change - should use cache
    Let modified_program be "Process called \"helper\" returns String:\n    Return \"Modified helper function\"\nEnd Process\n\nProcess called \"main\" returns Nothing:\n    Let msg be helper()\n    rust_print_string(msg)\n    rust_print_string(\"\\n\")\nEnd Process"
    
    Set compilation_request.source_code to modified_program
    Set compilation_request.output_name to "test_incremental_2"
    
    Let second_result be Driver.compile_program(compilation_request)
    If second_result.success is equal to false:
        rust_print_string("  ✗ Second incremental compilation failed\n")
        Return false
    End If
    
    rust_print_string("  ✓ Incremental compilation passed\n")
    Return true
End Process

Process called "test_parallel_compilation" returns Boolean:
    Note: Test parallel compilation of multiple units
    
    rust_print_string("[TEST] Parallel Compilation\n")
    
    Let module1 be "Process called \"func1\" returns String:\n    Return \"Module 1\"\nEnd Process"
    Let module2 be "Process called \"func2\" returns String:\n    Return \"Module 2\"\nEnd Process"
    Let main_module be "Import module \"module1\" as M1\nImport module \"module2\" as M2\n\nProcess called \"main\" returns Nothing:\n    rust_print_string(M1.func1())\n    rust_print_string(M2.func2())\nEnd Process"
    
    Note: Create multi-module compilation request
    Let compilation_request be Driver.create_compilation_request()
    Set compilation_request.output_name to "test_parallel"
    Set compilation_request.optimization_level to "O2"
    Set compilation_request.target_platform to "x86_64-linux"
    Set compilation_request.parallel_compilation to true
    
    Note: Add multiple source modules
    Driver.add_source_module(compilation_request, "module1.runa", module1)
    Driver.add_source_module(compilation_request, "module2.runa", module2)
    Driver.add_source_module(compilation_request, "main.runa", main_module)
    
    Let compilation_result be Driver.compile_program(compilation_request)
    If compilation_result.success is equal to false:
        rust_print_string("  ✗ Parallel compilation failed\n")
        For Each error in compilation_result.errors:
            rust_print_string("    Error: ")
            rust_print_string(error)
            rust_print_string("\n")
        End For
        Return false
    End If
    
    rust_print_string("  ✓ Parallel compilation passed\n")
    Return true
End Process

Process called "test_compilation_error_handling" returns Boolean:
    Note: Test that compilation errors are properly handled and reported
    
    rust_print_string("[TEST] Compilation Error Handling\n")
    
    Let invalid_program be "Process called \"test\" returns Integer:\n    Let x be \"string\"\n    Return x plus 42  Note: Type error\nEnd Process"
    
    Let compilation_request be Driver.create_compilation_request()
    Set compilation_request.source_code to invalid_program
    Set compilation_request.output_name to "test_error"
    Set compilation_request.optimization_level to "O1"
    Set compilation_request.target_platform to "x86_64-linux"
    
    Let compilation_result be Driver.compile_program(compilation_request)
    
    Note: This should fail with type errors
    If compilation_result.success is equal to true:
        rust_print_string("  ✗ Invalid program should have failed compilation\n")
        Return false
    End If
    
    Note: Check that error messages are present
    If Core.list_length(compilation_result.errors) is equal to 0:
        rust_print_string("  ✗ No error messages reported for invalid program\n")
        Return false
    End If
    
    rust_print_string("  ✓ Compilation error handling passed\n")
    Return true
End Process

Process called "test_diagnostic_information" returns Boolean:
    Note: Test that diagnostic information is properly collected
    
    rust_print_string("[TEST] Diagnostic Information\n")
    
    Let test_program be "Process called \"main\" returns Nothing:\n    rust_print_string(\"Diagnostic test\\n\")\nEnd Process"
    
    Let compilation_request be Driver.create_compilation_request()
    Set compilation_request.source_code to test_program
    Set compilation_request.output_name to "test_diagnostics"
    Set compilation_request.optimization_level to "O2"
    Set compilation_request.target_platform to "x86_64-linux"
    Set compilation_request.generate_diagnostics to true
    
    Let compilation_result be Driver.compile_program(compilation_request)
    
    If compilation_result.success is equal to false:
        rust_print_string("  ✗ Diagnostic compilation failed\n")
        Return false
    End If
    
    Note: Check that diagnostic information was collected
    If compilation_result.diagnostics is equal to null:
        rust_print_string("  ✗ No diagnostic information generated\n")
        Return false
    End If
    
    rust_print_string("  ✓ Diagnostic information passed\n")
    Return true
End Process

Process called "run_all_full_compilation_tests" returns Boolean:
    Note: Run all full compilation integration tests
    
    Let tests_passed be 0
    Let tests_failed be 0
    
    If test_simple_program_compilation():
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_multi_function_compilation():
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_type_definition_compilation():
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_control_flow_compilation():
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_optimization_levels():
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_incremental_compilation():
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_parallel_compilation():
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_compilation_error_handling():
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    If test_diagnostic_information():
        Set tests_passed to tests_passed plus 1
    Otherwise:
        Set tests_failed to tests_failed plus 1
    End If
    
    rust_print_string("\n=== FULL COMPILATION INTEGRATION TEST RESULTS ===\n")
    rust_print_string("Passed: ")
    rust_print_string(Core.integer_to_string(tests_passed))
    rust_print_string("\nFailed: ")
    rust_print_string(Core.integer_to_string(tests_failed))
    rust_print_string("\n")
    
    If tests_failed is equal to 0:
        rust_print_string("✓ ALL FULL COMPILATION TESTS PASSED\n")
        Return true
    Otherwise:
        rust_print_string("✗ SOME FULL COMPILATION TESTS FAILED\n")
        Return false
    End If
End Process

Process called "main":
    rust_print_string("=== FULL COMPILATION INTEGRATION TEST ===\n\n")
    run_all_full_compilation_tests()
End Process