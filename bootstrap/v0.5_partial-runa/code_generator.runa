Note: Simplified code generation interface for bootstrap compiler compatibility
Note: Uses external Rust functions to bridge to LLVM backend (Stage 0.2)
Note: In Stage 1.0, this will be reimplemented in pure Runa

Note: =====================================================================
Note: EXTERNAL RUST FUNCTIONS FOR CODE GENERATION
Note: =====================================================================

External Process called "rust_create_llvm_context" returns Integer
External Process called "rust_create_llvm_module" that takes context as Integer, module_name as String returns Integer
External Process called "rust_generate_code_from_ir" that takes backend as Integer, ir_module as Integer returns Integer
External Process called "rust_emit_inline_assembly_code" that takes backend as Integer, asm_string as String returns Integer
External Process called "rust_write_object_file" that takes backend as Integer, path as String returns Integer
External Process called "rust_write_assembly_file" that takes backend as Integer, path as String, opt_level as Integer returns Integer
External Process called "rust_write_llvm_ir" that takes backend as Integer, path as String returns Integer
External Process called "rust_verify_module" that takes backend as Integer returns Boolean
External Process called "rust_set_target_triple" that takes backend as Integer, triple as String returns Integer
External Process called "rust_set_optimization_level" that takes backend as Integer, level as Integer returns Integer
External Process called "rust_enable_debug_info" that takes backend as Integer returns Integer
External Process called "rust_add_function_pass" that takes backend as Integer, pass_name as String returns Integer
External Process called "rust_run_optimization_passes" that takes backend as Integer returns Integer
External Process called "rust_get_native_target" returns String
External Process called "rust_create_target_machine" that takes backend as Integer, triple as String, cpu as String, features as String returns Integer
External Process called "rust_dispose_backend" that takes backend as Integer returns Integer

Import module "ir_generator" as IR
Import module "core_libs" as Core

Note: =====================================================================
Note: TARGET PLATFORM DATA STRUCTURES
Note: =====================================================================

Type called "TargetPlatform":
    architecture as String               Note: x86_64, aarch64, wasm32, etc.
    operating_system as String           Note: linux, windows, macos, wasi
    abi as String                       Note: Application Binary Interface
    cpu_features as List[String]        Note: Available CPU features
    pointer_size as Integer             Note: Pointer size in bytes
    endianness as String                Note: little or big endian
    calling_convention as String        Note: Default calling convention
End Type

Type called "CodegenOptions":
    optimization_level as Integer        Note: 0=none, 1=basic, 2=standard, 3=aggressive
    debug_info as Boolean               Note: Generate debug information
    output_type as String               Note: object, assembly, llvm-ir, wasm
    pic as Boolean                      Note: Position Independent Code
    link_time_optimization as Boolean   Note: Enable LTO
    target_features as List[String]     Note: Specific features to enable
    code_model as String                Note: small, medium, large
End Type

Type called "CodegenContext":
    target as TargetPlatform            Note: Target platform configuration
    options as CodegenOptions           Note: Generation options
    output_path as String               Note: Output file path
    module_name as String               Note: Module being compiled
    symbol_table as Dictionary[String, String] Note: Symbol addresses
    relocations as List[Relocation]    Note: Relocation entries
    debug_context as Optional[DebugContext] Note: Debug information context
End Type

Type called "Relocation":
    offset as Integer                   Note: Offset in output
    symbol as String                    Note: Symbol to relocate
    reloc_type as String               Note: Relocation type
    addend as Integer                  Note: Relocation addend
End Type

Type called "DebugContext":
    source_files as List[String]       Note: Source file paths
    line_mappings as Dictionary[Integer, Integer] Note: IR to source line mapping
    variable_info as List[DebugVariable] Note: Variable debug information
    type_info as List[DebugType]      Note: Type debug information
End Type

Type called "DebugVariable":
    name as String                      Note: Variable name
    var_type as String                 Note: Variable type
    location as String                 Note: Storage location
    scope_start as Integer             Note: Scope start address
    scope_end as Integer               Note: Scope end address
End Type

Type called "DebugType":
    name as String                      Note: Type name
    size as Integer                    Note: Size in bytes
    alignment as Integer               Note: Alignment requirement
    fields as List[String]             Note: Field names for structs
End Type

Type called "CodegenResult":
    success as Boolean                  Note: Generation success
    output_data as Core.ByteArray      Note: Generated code bytes
    symbols as Dictionary[String, Integer] Note: Symbol addresses
    relocations as List[Relocation]    Note: Relocations needed
    errors as List[String]             Note: Generation errors
    warnings as List[String]           Note: Generation warnings
End Type

Note: =====================================================================
Note: BACKEND INTERFACE OPERATIONS
Note: =====================================================================

Process called "create_codegen_context" that takes target as TargetPlatform, options as CodegenOptions returns CodegenContext:
    Note: Initialize code generation context
    Note: Sets up target-specific configuration
    Note: Prepares output buffers and tables
    
    Let context be CodegenContext with 
        target as target,
        options as options,
        output_path as "",
        module_name as "main",
        symbol_table as Core.create_dictionary(),
        relocations as Core.create_list(),
        debug_context as Core.create_optional_none()
    
    Return context
End Process

Process called "generate_code" that takes ir_module as Integer, context as CodegenContext returns CodegenResult:
    Note: Main code generation entry point
    Note: Dispatches to appropriate backend (LLVM for Stage 0.2)
    
    Note: Create LLVM context and module
    Let llvm_context be rust_create_llvm_context()
    Let llvm_module be rust_create_llvm_module(llvm_context, context.module_name)
    
    Note: Configure target and optimization
    Let target_triple be create_target_triple(context.target)
    Let set_result be rust_set_target_triple(llvm_module, target_triple)
    Let opt_result be rust_set_optimization_level(llvm_module, context.options.optimization_level)
    
    If context.options.debug_info:
        Let debug_result be rust_enable_debug_info(llvm_module)
    End If
    
    Note: Generate code from IR
    Let gen_result be rust_generate_code_from_ir(llvm_module, ir_module)
    
    If gen_result is equal to 0:
        Return CodegenResult with
            success as false,
            output_data as Core.create_byte_array(0),
            symbols as Core.create_dictionary(),
            relocations as Core.create_list(),
            errors as Core.create_list_with_item("Code generation failed"),
            warnings as Core.create_list()
    End If
    
    Note: Write output based on format
    Let write_result be 0
    If context.options.output_type is equal to "object":
        Set write_result to rust_write_object_file(llvm_module, context.output_path)
    Otherwise If context.options.output_type is equal to "assembly":
        Set write_result to rust_write_assembly_file(llvm_module, context.output_path, context.options.optimization_level)
    Otherwise If context.options.output_type is equal to "llvm-ir":
        Set write_result to rust_write_llvm_ir(llvm_module, context.output_path)
    End If
    
    Note: Cleanup
    Let dispose_result be rust_dispose_backend(llvm_module)
    
    Return CodegenResult with
        success as true,
        output_data as Core.create_byte_array(0),
        symbols as Core.create_dictionary(),
        relocations as context.relocations,
        errors as Core.create_list(),
        warnings as Core.create_list()
End Process

Process called "emit_inline_assembly" that takes backend as Integer, asm_string as String returns Integer:
    Note: Emit inline assembly code
    Note: Passes assembly string directly to backend
    Return rust_emit_inline_assembly_code(backend, asm_string)
End Process

Process called "select_backend" that takes target as TargetPlatform returns String:
    Note: Select appropriate backend for target
    Note: For Stage 0.2, we only support LLVM backend
    
    If target.architecture is equal to "wasm32":
        Return "wasm"
    End If
    
    Note: Default to LLVM for all native targets
    Return "llvm"
End Process

Note: =====================================================================
Note: TARGET PLATFORM OPERATIONS  
Note: =====================================================================

Process called "get_native_target" returns TargetPlatform:
    Note: Detect and return native platform
    Note: Queries system for architecture and OS
    
    Let triple be rust_get_native_target()
    Return parse_target_triple(triple)
End Process

Process called "parse_target_triple" that takes triple as String returns TargetPlatform:
    Note: Parse target triple string (e.g., x86_64-unknown-linux-gnu)
    Note: Extracts architecture, vendor, OS, and ABI
    
    Let parts be Core.split_string(triple, "-")
    
    Let arch be ""
    Let os be ""
    Let abi be ""
    
    If Core.list_length(parts) is greater than or equal to 1:
        Set arch to Core.list_get(parts, 0)
    End If
    
    If Core.list_length(parts) is greater than or equal to 3:
        Set os to Core.list_get(parts, 2)
    End If
    
    If Core.list_length(parts) is greater than or equal to 4:
        Set abi to Core.list_get(parts, 3)
    End If
    
    Let pointer_size be 8
    If arch is equal to "i386" or arch is equal to "i686" or arch is equal to "wasm32":
        Set pointer_size to 4
    End If
    
    Return TargetPlatform with
        architecture as arch,
        operating_system as os,
        abi as abi,
        cpu_features as Core.create_list(),
        pointer_size as pointer_size,
        endianness as "little",
        calling_convention as "cdecl"
End Process

Process called "create_target_triple" that takes target as TargetPlatform returns String:
    Note: Create target triple string from platform
    
    If target.abi is equal to "":
        Return Core.concat_strings(target.architecture, "-unknown-", target.operating_system)
    End If
    
    Return Core.concat_strings(target.architecture, "-unknown-", target.operating_system, "-", target.abi)
End Process

Process called "validate_target" that takes target as TargetPlatform returns List[String]:
    Note: Validate target platform configuration
    Note: Checks for supported combinations
    
    Let errors be Core.create_list()
    
    Note: Check architecture
    Let valid_arch be false
    If target.architecture is equal to "x86_64" or target.architecture is equal to "aarch64":
        Set valid_arch to true
    Otherwise If target.architecture is equal to "wasm32" or target.architecture is equal to "riscv64":
        Set valid_arch to true
    End If
    
    If valid_arch is equal to false:
        Core.list_append(errors, Core.concat_strings("Unsupported architecture: ", target.architecture))
    End If
    
    Note: Check OS
    Let valid_os be false
    If target.operating_system is equal to "linux" or target.operating_system is equal to "windows":
        Set valid_os to true
    Otherwise If target.operating_system is equal to "macos" or target.operating_system is equal to "wasi":
        Set valid_os to true
    End If
    
    If valid_os is equal to false:
        Core.list_append(errors, Core.concat_strings("Unsupported OS: ", target.operating_system))
    End If
    
    Return errors
End Process

Note: =====================================================================
Note: CODE EMISSION OPERATIONS
Note: =====================================================================
Note: These are handled internally by the LLVM backend in Stage 0.2
Note: Exposed here for compatibility but delegated to Rust

External Process called "rust_emit_function_prologue" that takes backend as Integer, func_handle as Integer returns Integer
External Process called "rust_emit_function_epilogue" that takes backend as Integer, func_handle as Integer returns Integer
External Process called "rust_emit_instruction" that takes backend as Integer, instruction as Integer returns Integer
External Process called "rust_allocate_registers" that takes backend as Integer, func_handle as Integer returns Integer

Process called "emit_function_prologue" that takes context as CodegenContext, func as Integer returns Core.ByteArray:
    Note: Generate function entry code via LLVM backend
    Note: Handled internally by LLVM in Stage 0.2
    
    Return Core.create_byte_array(0)  Note: LLVM handles this internally
End Process

Process called "emit_function_epilogue" that takes context as CodegenContext, func as Integer returns Core.ByteArray:
    Note: Generate function exit code via LLVM backend
    Note: Handled internally by LLVM in Stage 0.2
    
    Return Core.create_byte_array(0)  Note: LLVM handles this internally
End Process

Process called "emit_instruction" that takes context as CodegenContext, ir_node as Integer returns Core.ByteArray:
    Note: Generate code for single IR instruction via LLVM
    Note: Handled internally by LLVM in Stage 0.2
    
    Return Core.create_byte_array(0)  Note: LLVM handles this internally
End Process

Process called "allocate_registers" that takes func as Integer, target as TargetPlatform returns Dictionary[String, String]:
    Note: Register allocation handled by LLVM backend
    Note: Returns empty mapping as LLVM manages this
    
    Return Core.create_dictionary()  Note: LLVM handles register allocation
End Process

Note: =====================================================================
Note: OUTPUT GENERATION OPERATIONS
Note: =====================================================================
Note: These operations delegate to the LLVM backend via FFI

Process called "generate_object_file" that takes backend as Integer, context as CodegenContext returns Core.ByteArray:
    Note: Package code into object file format via LLVM
    Note: The LLVM backend handles format-specific details
    
    Let result be rust_write_object_file(backend, context.output_path)
    If result is equal to 0:
        Return Core.create_byte_array(0)
    End If
    
    Return Core.read_file_bytes(context.output_path)
End Process

Process called "generate_assembly" that takes backend as Integer, context as CodegenContext returns String:
    Note: Generate assembly language output via LLVM
    
    Let asm_path be Core.concat_strings(context.output_path, ".s")
    Let result be rust_write_assembly_file(backend, asm_path, context.options.optimization_level)
    
    If result is equal to 0:
        Return ""
    End If
    
    Return Core.read_file_text(asm_path)
End Process

Process called "generate_llvm_ir" that takes backend as Integer, context as CodegenContext returns String:
    Note: Generate LLVM IR text representation
    
    Let ir_path be Core.concat_strings(context.output_path, ".ll")
    Let result be rust_write_llvm_ir(backend, ir_path)
    
    If result is equal to 0:
        Return ""
    End If
    
    Return Core.read_file_text(ir_path)
End Process

Note: =====================================================================
Note: OPTIMIZATION CONTROL
Note: =====================================================================
Note: LLVM handles optimizations internally based on optimization level

Process called "apply_backend_optimizations" that takes backend as Integer, level as Integer returns Boolean:
    Note: Apply backend-specific optimizations via LLVM
    
    Let opt_result be rust_set_optimization_level(backend, level)
    Let pass_result be rust_run_optimization_passes(backend)
    
    Return pass_result is greater than 0
End Process

Process called "optimize_for_size" that takes backend as Integer returns Boolean:
    Note: Configure LLVM to optimize for size
    Note: Uses -Os equivalent settings
    
    Let result be rust_add_function_pass(backend, "optimize-for-size")
    Return result is greater than 0
End Process

Note: =====================================================================
Note: DEBUG INFORMATION GENERATION
Note: =====================================================================
Note: Debug info is handled by LLVM when enabled

Process called "generate_debug_info" that takes backend as Integer, context as CodegenContext returns DebugContext:
    Note: Enable debug info generation in LLVM
    
    Let result be rust_enable_debug_info(backend)
    
    Return DebugContext with
        source_files as Core.create_list(),
        line_mappings as Core.create_dictionary(),
        variable_info as Core.create_list(),
        type_info as Core.create_list()
End Process

Process called "emit_source_mapping" that takes ir_pos as Integer, source_line as Integer, context as DebugContext returns Boolean:
    Note: Record IR to source line mapping
    Note: In Stage 0.2, LLVM handles this internally
    
    Core.dictionary_set(context.line_mappings, Core.integer_to_string(ir_pos), source_line)
    Return true
End Process