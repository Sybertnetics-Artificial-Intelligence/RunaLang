# Parser for Runa v0.0.7.5
# Line-by-line transliteration from v0.0.7.3 parser.c

# Offsets for program structure (based on C struct layout)
Let PROGRAM_FUNCTIONS be 0      # Function **functions
Let PROGRAM_FUNCTION_COUNT be 8 # int function_count
Let PROGRAM_FUNCTION_CAPACITY be 12 # int function_capacity
Let PROGRAM_TYPES be 16         # TypeDefinition **types
Let PROGRAM_TYPE_COUNT be 24    # int type_count
Let PROGRAM_TYPE_CAPACITY be 28 # int type_capacity
Let PROGRAM_IMPORTS be 32       # Import **imports
Let PROGRAM_IMPORT_COUNT be 40  # int import_count
Let PROGRAM_IMPORT_CAPACITY be 44 # int import_capacity
Let PROGRAM_GLOBAL_VARS be 48   # GlobalVariable **globals
Let PROGRAM_GLOBAL_COUNT be 56  # int global_count
Let PROGRAM_GLOBAL_CAPACITY be 60 # int global_capacity

# Parser parse expression - entry point for expression parsing with PEMDAS precedence
Process called "parser_parse_expression" takes parser as Integer returns Integer:
    Return parser_parse_comparison_level(parser)
End Process

# Parse comparison expressions (==, !=, <, >, etc.)
Process called "parser_parse_comparison_level" takes parser as Integer returns Integer:
    Return parser_parse_comparison(parser)
End Process

# Parse additive expressions (+ and -)
Process called "parser_parse_additive" takes parser as Integer returns Integer:
    Let left be parser_parse_multiplicative(parser)

    Let loop_additive be 1
    While loop_additive is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 16:  # TOKEN_PLUS
            Let operator be token_type
            parser_eat(parser, 16)
            Let right be parser_parse_multiplicative(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise If token_type is equal to 17:  # TOKEN_MINUS
            Let operator be token_type
            parser_eat(parser, 17)
            Let right be parser_parse_multiplicative(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise:
            Set loop_additive to 0
        End If
    End While

    Return left
End Process

# Parse multiplicative expressions (*, /, %)
Process called "parser_parse_multiplicative" takes parser as Integer returns Integer:
    Let left be parser_parse_primary_with_postfix(parser)

    Let loop_multiplicative be 1
    While loop_multiplicative is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 35:  # TOKEN_MULTIPLIED
            Let operator be token_type
            parser_eat(parser, 35)
            parser_eat(parser, 38)
            Let right be parser_parse_primary_with_postfix(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise If token_type is equal to 36:  # TOKEN_DIVIDED
            Let operator be token_type
            parser_eat(parser, 36)
            parser_eat(parser, 38)
            Let right be parser_parse_primary_with_postfix(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise If token_type is equal to 37:  # TOKEN_MODULO
            Let operator be token_type
            parser_eat(parser, 37)
            parser_eat(parser, 38)
            Let right be parser_parse_primary_with_postfix(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise If token_type is equal to 42:  # TOKEN_BIT_SHIFT_LEFT
            Let operator be token_type
            parser_eat(parser, 42)
            parser_eat(parser, 38)  # TOKEN_BY
            Let right be parser_parse_primary_with_postfix(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise:
            Set loop_multiplicative to 0
        End If
    End While

    Return left
End Process

# Parse primary expressions with postfix operators (function calls, field access, array indexing)
Process called "parser_parse_primary_with_postfix" takes parser as Integer returns Integer:
    Let left be parser_parse_primary(parser)

    # Check for function call (if primary was an identifier and followed by '(')
    Let current_token_fc be memory_get_pointer(parser, 8)
    Let token_type_fc be memory_get_integer(current_token_fc, 0)
    If token_type_fc is equal to 48:  # TOKEN_LPAREN (48)
        # Convert variable expression to function call
        Let expr_type be memory_get_integer(left, 0)
        If expr_type is equal to EXPR_VARIABLE:
            # Get the variable name from the EXPR_VARIABLE
            Let var_name be memory_get_pointer(left, 8)

            # Parse function arguments
            parser_eat(parser, 48)

            # Allocate space for arguments
            Let arguments be 0
            Let argument_count be 0
            Let argument_capacity be 4
            Let arg_ptr_size be 8
            Let arg_size be argument_capacity multiplied by arg_ptr_size
            Set arguments to memory_allocate(arg_size)

            # Parse arguments until we hit ')'
            Let continue_args be 1
            While continue_args is equal to 1:
                Let current_token_arg be memory_get_pointer(parser, 8)
                Let token_type_arg be memory_get_integer(current_token_arg, 0)

                If token_type_arg is equal to 49:  # TOKEN_RPAREN (49)
                    Set continue_args to 0
                Otherwise:
                    # Parse the argument expression
                    Let arg_expr be parser_parse_additive(parser)

                    # Store argument
                    Let arg_offset be argument_count multiplied by arg_ptr_size
                    Let arg_ptr be arguments plus arg_offset
                    memory_set_pointer(arg_ptr, 0, arg_expr)
                    Set argument_count to argument_count plus 1

                    # Check for comma
                    Let current_token_comma be memory_get_pointer(parser, 8)
                    Let token_type_comma be memory_get_integer(current_token_comma, 0)
                    If token_type_comma is equal to 52:  # TOKEN_COMMA (52)
                        parser_eat(parser, 52)
                    End If
                End If
            End While

            parser_eat(parser, 49)

            # Create function call expression
            Let func_call be expression_create_function_call(var_name, arguments, argument_count)
            deallocate(left)  # Free the old EXPR_VARIABLE
            Set left to func_call
        End If
    End If

    # Handle field access and array indexing (highest precedence)
    Let loop_field be 1
    While loop_field is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 51:  # TOKEN_DOT
            parser_eat(parser, 51)

            Let current_token2 be memory_get_pointer(parser, 8)
            Let token_type2 be memory_get_integer(current_token2, 0)
            If token_type2 is not equal to 53:  # TOKEN_IDENTIFIER
                Let error_msg be "[PARSER ERROR] Expected field name after '.' at line "
                print_string(error_msg)
                Let line be memory_get_integer(current_token2, 16)
                print_integer(line)
                print_newline()
                exit_with_code(1)
            End If

            Let token_value be memory_get_pointer(current_token2, 8)
            Let field_name be string_duplicate_parser(token_value)
            parser_eat(parser, 53)

            Let field_access be memory_allocate(32)  # sizeof(Expression)
            memory_set_integer(field_access, 0, 10)  # EXPR_FIELD_ACCESS
            memory_set_pointer(field_access, 8, left)  # field_access.object
            memory_set_pointer(field_access, 16, field_name)  # field_access.field_name
            Set left to field_access
        Otherwise If token_type is equal to 127:  # TOKEN_LBRACKET
            parser_eat(parser, 127)

            # Parse index expression
            Let index be parser_parse_additive(parser)

            parser_eat(parser, 49)

            Let array_index be memory_allocate(32)  # sizeof(Expression)
            memory_set_integer(array_index, 0, 16)  # EXPR_ARRAY_INDEX
            memory_set_pointer(array_index, 8, left)  # array_index.array
            memory_set_pointer(array_index, 16, index)  # array_index.index
            Set left to array_index
        Otherwise:
            Set loop_field to 0
        End If
    End While

    Return left
End Process

# Parser parse comparison - handles comparison operators
Process called "parser_parse_comparison" takes parser as Integer returns Integer:
    Let left be parser_parse_additive(parser)

    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_integer(current_token, 0)

    If token_type is equal to 21:  # TOKEN_IS
        parser_eat(parser, 21)

        Let current_token2 be memory_get_pointer(parser, 8)
        Let token_type2 be memory_get_integer(current_token2, 0)

        Let comparison_op be 0
        # Handle NOT EQUAL
        If token_type2 is equal to 29:
            parser_eat(parser, 29)
            parser_eat(parser, 22)
            parser_eat(parser, 15)
            Let comparison_op be 23  # TOKEN_NOT_EQUAL
        End If

        # Handle EQUAL
        If token_type2 is equal to 22:
            parser_eat(parser, 22)
            parser_eat(parser, 15)
            Let comparison_op be 22  # TOKEN_EQUAL
        End If

        # Handle LESS THAN (and LESS EQUAL)
        If token_type2 is equal to 24:
            parser_eat(parser, 24)
            Let current_token3 be memory_get_pointer(parser, 8)
            Let token_type3 be memory_get_integer(current_token3, 0)
            If token_type3 is equal to 28:  # TOKEN_THAN
                parser_eat(parser, 28)
                Let current_token4 be memory_get_pointer(parser, 8)
                Let token_type4 be memory_get_integer(current_token4, 0)
                If token_type4 is equal to 31:
                    parser_eat(parser, 31)
                    parser_eat(parser, 22)
                    parser_eat(parser, 15)
                    Let comparison_op be 27  # TOKEN_LESS_EQUAL
                End If
                If token_type4 is not equal to 31:  # Not TOKEN_OR
                    Let comparison_op be 24  # TOKEN_LESS
                End If
            End If
            If token_type3 is not equal to 28:  # Not TOKEN_THAN
                Let error_msg be "[PARSER ERROR] Expected 'than' after 'less' at line "
                print_string(error_msg)
                Let line be memory_get_integer(current_token3, 16)
                print_integer(line)
                print_newline()
                exit_with_code(1)
            End If
        End If

        # Handle GREATER THAN (and GREATER EQUAL)
        If token_type2 is equal to 25:
            parser_eat(parser, 25)
            Let current_token3 be memory_get_pointer(parser, 8)
            Let token_type3 be memory_get_integer(current_token3, 0)
            If token_type3 is equal to 28:  # TOKEN_THAN
                parser_eat(parser, 28)
                Let current_token4 be memory_get_pointer(parser, 8)
                Let token_type4 be memory_get_integer(current_token4, 0)
                If token_type4 is equal to 31:
                    parser_eat(parser, 31)
                    parser_eat(parser, 22)
                    parser_eat(parser, 15)
                    Let comparison_op be 26  # TOKEN_GREATER_EQUAL
                End If
                If token_type4 is not equal to 31:  # Not TOKEN_OR
                    Let comparison_op be 25  # TOKEN_GREATER
                End If
            End If
            If token_type3 is not equal to 28:  # Not TOKEN_THAN
                Let error_msg be "[PARSER ERROR] Expected 'than' after 'greater' at line "
                print_string(error_msg)
                Let line be memory_get_integer(current_token3, 16)
                print_integer(line)
                print_newline()
                exit_with_code(1)
            End If
        End If

        # Check if we got a valid comparison operator
        If comparison_op is equal to 0:
            Let error_msg be "[PARSER ERROR] Expected 'equal', 'less', or 'greater' after 'is' at line "
            print_string(error_msg)
            Let line be memory_get_integer(current_token2, 16)
            print_integer(line)
            print_newline()
            exit_with_code(1)
        End If

        Let right be parser_parse_additive(parser)
        Return expression_create_comparison(left, comparison_op, right)
    End If

    Return left
End Process

# Parser parse let statement - handles "Let var be expression"
Process called "parser_parse_let_statement" takes parser as Integer returns Integer:
    parser_eat(parser, 12)  # TOKEN_LET

    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_integer(current_token, 0)
    If token_type is not equal to 53:  # TOKEN_IDENTIFIER
        Let error_msg be "[PARSER ERROR] Expected identifier after Let at line "
        print_string(error_msg)
        Let line be memory_get_integer(current_token, 16)
        print_integer(line)
        print_newline()
        exit_with_code(1)
    End If

    Let token_value be memory_get_pointer(current_token, 8)
    Let var_name be string_duplicate_parser(token_value)
    parser_eat(parser, 53)  # TOKEN_IDENTIFIER

    parser_eat(parser, 13)

    Let expr be parser_parse_expression(parser)

    Return statement_create_let(var_name, expr)
End Process

# Parser parse set statement - handles "Set target to expression"
Process called "parser_parse_set_statement" takes parser as Integer returns Integer:
    parser_eat(parser, 14)

    # Parse the target expression (could be variable or nested field access)
    Let target be parser_parse_expression(parser)

    parser_eat(parser, 15)

    Let expr be parser_parse_expression(parser)

    Let stmt be statement_create_set(target, expr)
    Return stmt
End Process

Process called "token_destroy" takes token as Integer returns Integer:
    # Clean up token memory
    If token is not equal to 0:
        Let value be memory_get_pointer(token, 8)
        If value is not equal to 0:
            deallocate(value)
        End If
        deallocate(token)
    End If
    Return 0
End Process

# Expression type constants
Let EXPR_INTEGER be 0
Let EXPR_VARIABLE be 1
Let EXPR_BINARY_OP be 2
Let EXPR_COMPARISON be 3
Let EXPR_FUNCTION_CALL be 4
Let EXPR_STRING_LITERAL be 5
Let EXPR_FIELD_ACCESS be 6
Let EXPR_TYPE_NAME be 7
Let EXPR_BUILTIN_CALL be 8
Let EXPR_VARIANT_CONSTRUCTOR be 9
Let EXPR_FUNCTION_POINTER be 10
Let EXPR_ARRAY_INDEX be 16

# Statement type constants - synchronized with codegen.runa
Let STMT_LET be 1
Let STMT_SET be 2
Let STMT_RETURN be 3
Let STMT_PRINT be 4
Let STMT_IF be 5
Let STMT_WHILE be 6
Let STMT_EXPRESSION be 7
Let STMT_MATCH be 8
Let STMT_IMPORT be 8
Let STMT_BREAK be 9
Let STMT_CONTINUE be 10
Let STMT_FOR be 11
Let STMT_INLINE_ASSEMBLY be 16

# Type kind constants
Let TYPE_KIND_STRUCT be 0
Let TYPE_KIND_VARIANT be 1
Let TYPE_KIND_FUNCTION be 2
Let TYPE_KIND_ARRAY be 3

# TOKEN constants (from lexer.h enum - sequential numbering)
# Authoritative token constants from lexer.runa - DO NOT MODIFY
Let TOKEN_EOF be 0
Let TOKEN_PROCESS be 1
Let TOKEN_CALLED be 2
Let TOKEN_RETURNS be 3
Let TOKEN_INTEGER_TYPE be 4
Let TOKEN_STRING_TYPE be 5
Let TOKEN_CHARACTER_TYPE be 6
Let TOKEN_RETURN be 7
Let TOKEN_END be 8
Let TOKEN_COLON be 9
Let TOKEN_STRING_LITERAL be 10
Let TOKEN_INTEGER be 11
Let TOKEN_LET be 12
Let TOKEN_BE be 13
Let TOKEN_SET be 14
Let TOKEN_TO be 15
Let TOKEN_PLUS be 16
Let TOKEN_MINUS be 17
Let TOKEN_IF be 18
Let TOKEN_OTHERWISE be 19
Let TOKEN_WHILE be 20
Let TOKEN_IS be 21
Let TOKEN_EQUAL be 22
Let TOKEN_NOT_EQUAL be 23
Let TOKEN_LESS be 24
Let TOKEN_GREATER be 25
Let TOKEN_GREATER_EQUAL be 26
Let TOKEN_LESS_EQUAL be 27
Let TOKEN_THAN be 28
Let TOKEN_NOT be 29
Let TOKEN_AND be 30
Let TOKEN_OR be 31
Let TOKEN_THAT be 32
Let TOKEN_TAKES be 33
Let TOKEN_AS be 34
Let TOKEN_MULTIPLIED be 35
Let TOKEN_DIVIDED be 36
Let TOKEN_MODULO be 37
Let TOKEN_BY be 38
Let TOKEN_BIT_AND be 39
Let TOKEN_BIT_OR be 40
Let TOKEN_BIT_XOR be 41
Let TOKEN_BIT_SHIFT_LEFT be 42
Let TOKEN_BIT_SHIFT_RIGHT be 43
Let TOKEN_BREAK be 44
Let TOKEN_CONTINUE be 45
Let TOKEN_OTHERWISE_IF be 46
Let TOKEN_PRINT be 47
Let TOKEN_LPAREN be 48
Let TOKEN_RPAREN be 49
Let TOKEN_TYPE be 50
Let TOKEN_DOT be 51
Let TOKEN_COMMA be 52
Let TOKEN_IDENTIFIER be 53
Let TOKEN_READ_FILE be 54
Let TOKEN_WRITE_FILE be 55
Let TOKEN_IMPORT be 56
Let TOKEN_STRING_LENGTH be 57
Let TOKEN_STRING_CHAR_AT be 58
Let TOKEN_STRING_SUBSTRING be 59
Let TOKEN_STRING_EQUALS be 60
Let TOKEN_ASCII_VALUE_OF be 61
Let TOKEN_IS_DIGIT be 62
Let TOKEN_IS_ALPHA be 63
Let TOKEN_IS_WHITESPACE be 64
Let TOKEN_LIST_CREATE be 65
Let TOKEN_LIST_APPEND be 66
Let TOKEN_LIST_GET be 67
Let TOKEN_LIST_GET_INTEGER be 68
Let TOKEN_LIST_LENGTH be 69
Let TOKEN_LIST_DESTROY be 70
Let TOKEN_LIST_SET be 71
Let TOKEN_LIST_INSERT be 72
Let TOKEN_LIST_REMOVE be 73
Let TOKEN_LIST_CLEAR be 74
Let TOKEN_LIST_FIND be 75
Let TOKEN_LIST_SORT be 76
Let TOKEN_LIST_REVERSE be 77
Let TOKEN_LIST_COPY be 78
Let TOKEN_LIST_MERGE be 79
Let TOKEN_STRING_CONCAT be 80
Let TOKEN_STRING_COMPARE be 81
Let TOKEN_STRING_TO_INTEGER be 82
Let TOKEN_INTEGER_TO_STRING be 83
Let TOKEN_STRING_FIND be 84
Let TOKEN_STRING_REPLACE be 85
Let TOKEN_STRING_TRIM be 86
Let TOKEN_STRING_SPLIT be 87
Let TOKEN_FILE_OPEN be 88
Let TOKEN_FILE_CLOSE be 89
Let TOKEN_FILE_READ_LINE be 90
Let TOKEN_FILE_WRITE_LINE be 91
Let TOKEN_FILE_EXISTS be 92
Let TOKEN_FILE_DELETE be 93
Let TOKEN_FILE_SIZE be 94
Let TOKEN_FILE_SEEK be 95
Let TOKEN_FILE_TELL be 96
Let TOKEN_FILE_EOF be 97
Let TOKEN_SIN be 98
Let TOKEN_COS be 99
