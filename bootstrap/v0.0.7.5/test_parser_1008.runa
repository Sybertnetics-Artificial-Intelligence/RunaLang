# Parser for Runa v0.0.7.5
# Line-by-line transliteration from v0.0.7.3 parser.c

# Offsets for program structure (based on C struct layout)
Let PROGRAM_FUNCTIONS be 0      # Function **functions
Let PROGRAM_FUNCTION_COUNT be 8 # int function_count
Let PROGRAM_FUNCTION_CAPACITY be 12 # int function_capacity
Let PROGRAM_TYPES be 16         # TypeDefinition **types
Let PROGRAM_TYPE_COUNT be 24    # int type_count
Let PROGRAM_TYPE_CAPACITY be 28 # int type_capacity
Let PROGRAM_IMPORTS be 32       # Import **imports
Let PROGRAM_IMPORT_COUNT be 40  # int import_count
Let PROGRAM_IMPORT_CAPACITY be 44 # int import_capacity
Let PROGRAM_GLOBAL_VARS be 48   # GlobalVariable **globals
Let PROGRAM_GLOBAL_COUNT be 56  # int global_count
Let PROGRAM_GLOBAL_CAPACITY be 60 # int global_capacity

# Parser parse expression - entry point for expression parsing with PEMDAS precedence
Process called "parser_parse_expression" takes parser as Integer returns Integer:
    Return parser_parse_comparison_level(parser)
End Process

# Parse comparison expressions (==, !=, <, >, etc.)
Process called "parser_parse_comparison_level" takes parser as Integer returns Integer:
    Return parser_parse_comparison(parser)
End Process

# Parse additive expressions (+ and -)
Process called "parser_parse_additive" takes parser as Integer returns Integer:
    Let left be parser_parse_multiplicative(parser)

    Let loop_additive be 1
    While loop_additive is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 16:  # TOKEN_PLUS
            Let operator be token_type
            parser_eat(parser, 16)
            Let right be parser_parse_multiplicative(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise If token_type is equal to 17:  # TOKEN_MINUS
            Let operator be token_type
            parser_eat(parser, 17)
            Let right be parser_parse_multiplicative(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise:
            Set loop_additive to 0
        End If
    End While

    Return left
End Process

# Parse multiplicative expressions (*, /, %)
Process called "parser_parse_multiplicative" takes parser as Integer returns Integer:
    Let left be parser_parse_primary_with_postfix(parser)

    Let loop_multiplicative be 1
    While loop_multiplicative is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 35:  # TOKEN_MULTIPLIED
            Let operator be token_type
            parser_eat(parser, 35)
            parser_eat(parser, 38)
            Let right be parser_parse_primary_with_postfix(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise If token_type is equal to 36:  # TOKEN_DIVIDED
            Let operator be token_type
            parser_eat(parser, 36)
            parser_eat(parser, 38)
            Let right be parser_parse_primary_with_postfix(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise If token_type is equal to 37:  # TOKEN_MODULO
            Let operator be token_type
            parser_eat(parser, 37)
            parser_eat(parser, 38)
            Let right be parser_parse_primary_with_postfix(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise If token_type is equal to 42:  # TOKEN_BIT_SHIFT_LEFT
            Let operator be token_type
            parser_eat(parser, 42)
            parser_eat(parser, 38)  # TOKEN_BY
            Let right be parser_parse_primary_with_postfix(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise:
            Set loop_multiplicative to 0
        End If
    End While

    Return left
End Process

# Parse primary expressions with postfix operators (function calls, field access, array indexing)
Process called "parser_parse_primary_with_postfix" takes parser as Integer returns Integer:
    Let left be parser_parse_primary(parser)

    # Check for function call (if primary was an identifier and followed by '(')
    Let current_token_fc be memory_get_pointer(parser, 8)
    Let token_type_fc be memory_get_integer(current_token_fc, 0)
    If token_type_fc is equal to 48:  # TOKEN_LPAREN (48)
        # Convert variable expression to function call
        Let expr_type be memory_get_integer(left, 0)
        If expr_type is equal to EXPR_VARIABLE:
            # Get the variable name from the EXPR_VARIABLE
            Let var_name be memory_get_pointer(left, 8)

            # Parse function arguments
            parser_eat(parser, 48)

            # Allocate space for arguments
            Let arguments be 0
            Let argument_count be 0
            Let argument_capacity be 4
            Let arg_ptr_size be 8
            Let arg_size be argument_capacity multiplied by arg_ptr_size
            Set arguments to memory_allocate(arg_size)

            # Parse arguments until we hit ')'
            Let continue_args be 1
            While continue_args is equal to 1:
                Let current_token_arg be memory_get_pointer(parser, 8)
                Let token_type_arg be memory_get_integer(current_token_arg, 0)

                If token_type_arg is equal to 49:  # TOKEN_RPAREN (49)
                    Set continue_args to 0
                Otherwise:
                    # Parse the argument expression
                    Let arg_expr be parser_parse_additive(parser)

                    # Store argument
                    Let arg_offset be argument_count multiplied by arg_ptr_size
                    Let arg_ptr be arguments plus arg_offset
                    memory_set_pointer(arg_ptr, 0, arg_expr)
                    Set argument_count to argument_count plus 1

                    # Check for comma
                    Let current_token_comma be memory_get_pointer(parser, 8)
                    Let token_type_comma be memory_get_integer(current_token_comma, 0)
                    If token_type_comma is equal to 52:  # TOKEN_COMMA (52)
                        parser_eat(parser, 52)
                    End If
                End If
            End While

            parser_eat(parser, 49)

            # Create function call expression
            Let func_call be expression_create_function_call(var_name, arguments, argument_count)
            deallocate(left)  # Free the old EXPR_VARIABLE
            Set left to func_call
        End If
    End If

    # Handle field access and array indexing (highest precedence)
    Let loop_field be 1
    While loop_field is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 51:  # TOKEN_DOT
            parser_eat(parser, 51)

            Let current_token2 be memory_get_pointer(parser, 8)
            Let token_type2 be memory_get_integer(current_token2, 0)
            If token_type2 is not equal to 53:  # TOKEN_IDENTIFIER
                Let error_msg be "[PARSER ERROR] Expected field name after '.' at line "
                print_string(error_msg)
                Let line be memory_get_integer(current_token2, 16)
                print_integer(line)
                print_newline()
                exit_with_code(1)
            End If

            Let token_value be memory_get_pointer(current_token2, 8)
            Let field_name be string_duplicate_parser(token_value)
            parser_eat(parser, 53)

            Let field_access be memory_allocate(32)  # sizeof(Expression)
            memory_set_integer(field_access, 0, 10)  # EXPR_FIELD_ACCESS
            memory_set_pointer(field_access, 8, left)  # field_access.object
            memory_set_pointer(field_access, 16, field_name)  # field_access.field_name
            Set left to field_access
        Otherwise If token_type is equal to 127:  # TOKEN_LBRACKET
            parser_eat(parser, 127)

            # Parse index expression
            Let index be parser_parse_additive(parser)

            parser_eat(parser, 49)

            Let array_index be memory_allocate(32)  # sizeof(Expression)
            memory_set_integer(array_index, 0, 16)  # EXPR_ARRAY_INDEX
            memory_set_pointer(array_index, 8, left)  # array_index.array
            memory_set_pointer(array_index, 16, index)  # array_index.index
            Set left to array_index
        Otherwise:
            Set loop_field to 0
        End If
    End While

    Return left
End Process

# Parser parse comparison - handles comparison operators
Process called "parser_parse_comparison" takes parser as Integer returns Integer:
    Let left be parser_parse_additive(parser)

    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_integer(current_token, 0)

    If token_type is equal to 21:  # TOKEN_IS
        parser_eat(parser, 21)

        Let current_token2 be memory_get_pointer(parser, 8)
        Let token_type2 be memory_get_integer(current_token2, 0)

        Let comparison_op be 0
        # Handle NOT EQUAL
        If token_type2 is equal to 29:
            parser_eat(parser, 29)
            parser_eat(parser, 22)
            parser_eat(parser, 15)
            Let comparison_op be 23  # TOKEN_NOT_EQUAL
        End If

        # Handle EQUAL
        If token_type2 is equal to 22:
            parser_eat(parser, 22)
            parser_eat(parser, 15)
            Let comparison_op be 22  # TOKEN_EQUAL
        End If

        # Handle LESS THAN (and LESS EQUAL)
        If token_type2 is equal to 24:
            parser_eat(parser, 24)
            Let current_token3 be memory_get_pointer(parser, 8)
            Let token_type3 be memory_get_integer(current_token3, 0)
            If token_type3 is equal to 28:  # TOKEN_THAN
                parser_eat(parser, 28)
                Let current_token4 be memory_get_pointer(parser, 8)
                Let token_type4 be memory_get_integer(current_token4, 0)
                If token_type4 is equal to 31:
                    parser_eat(parser, 31)
                    parser_eat(parser, 22)
                    parser_eat(parser, 15)
                    Let comparison_op be 27  # TOKEN_LESS_EQUAL
                End If
                If token_type4 is not equal to 31:  # Not TOKEN_OR
                    Let comparison_op be 24  # TOKEN_LESS
                End If
            End If
            If token_type3 is not equal to 28:  # Not TOKEN_THAN
                Let error_msg be "[PARSER ERROR] Expected 'than' after 'less' at line "
                print_string(error_msg)
                Let line be memory_get_integer(current_token3, 16)
                print_integer(line)
                print_newline()
                exit_with_code(1)
            End If
        End If

        # Handle GREATER THAN (and GREATER EQUAL)
        If token_type2 is equal to 25:
            parser_eat(parser, 25)
            Let current_token3 be memory_get_pointer(parser, 8)
            Let token_type3 be memory_get_integer(current_token3, 0)
            If token_type3 is equal to 28:  # TOKEN_THAN
                parser_eat(parser, 28)
                Let current_token4 be memory_get_pointer(parser, 8)
                Let token_type4 be memory_get_integer(current_token4, 0)
                If token_type4 is equal to 31:
                    parser_eat(parser, 31)
                    parser_eat(parser, 22)
                    parser_eat(parser, 15)
                    Let comparison_op be 26  # TOKEN_GREATER_EQUAL
                End If
                If token_type4 is not equal to 31:  # Not TOKEN_OR
                    Let comparison_op be 25  # TOKEN_GREATER
                End If
            End If
            If token_type3 is not equal to 28:  # Not TOKEN_THAN
                Let error_msg be "[PARSER ERROR] Expected 'than' after 'greater' at line "
                print_string(error_msg)
                Let line be memory_get_integer(current_token3, 16)
                print_integer(line)
                print_newline()
                exit_with_code(1)
            End If
        End If

        # Check if we got a valid comparison operator
        If comparison_op is equal to 0:
            Let error_msg be "[PARSER ERROR] Expected 'equal', 'less', or 'greater' after 'is' at line "
            print_string(error_msg)
            Let line be memory_get_integer(current_token2, 16)
            print_integer(line)
            print_newline()
            exit_with_code(1)
        End If

        Let right be parser_parse_additive(parser)
        Return expression_create_comparison(left, comparison_op, right)
    End If

    Return left
End Process

# Parser parse let statement - handles "Let var be expression"
Process called "parser_parse_let_statement" takes parser as Integer returns Integer:
    parser_eat(parser, 12)  # TOKEN_LET

    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_integer(current_token, 0)
    If token_type is not equal to 53:  # TOKEN_IDENTIFIER
        Let error_msg be "[PARSER ERROR] Expected identifier after Let at line "
        print_string(error_msg)
        Let line be memory_get_integer(current_token, 16)
        print_integer(line)
        print_newline()
        exit_with_code(1)
    End If

    Let token_value be memory_get_pointer(current_token, 8)
    Let var_name be string_duplicate_parser(token_value)
    parser_eat(parser, 53)  # TOKEN_IDENTIFIER

    parser_eat(parser, 13)

    Let expr be parser_parse_expression(parser)

    Return statement_create_let(var_name, expr)
End Process

# Parser parse set statement - handles "Set target to expression"
Process called "parser_parse_set_statement" takes parser as Integer returns Integer:
    parser_eat(parser, 14)

    # Parse the target expression (could be variable or nested field access)
    Let target be parser_parse_expression(parser)

    parser_eat(parser, 15)

    Let expr be parser_parse_expression(parser)

    Let stmt be statement_create_set(target, expr)
    Return stmt
End Process

Process called "token_destroy" takes token as Integer returns Integer:
    # Clean up token memory
    If token is not equal to 0:
        Let value be memory_get_pointer(token, 8)
        If value is not equal to 0:
            deallocate(value)
        End If
        deallocate(token)
    End If
    Return 0
End Process

# Expression type constants
Let EXPR_INTEGER be 0
Let EXPR_VARIABLE be 1
Let EXPR_BINARY_OP be 2
Let EXPR_COMPARISON be 3
Let EXPR_FUNCTION_CALL be 4
Let EXPR_STRING_LITERAL be 5
Let EXPR_FIELD_ACCESS be 6
Let EXPR_TYPE_NAME be 7
Let EXPR_BUILTIN_CALL be 8
Let EXPR_VARIANT_CONSTRUCTOR be 9
Let EXPR_FUNCTION_POINTER be 10
Let EXPR_ARRAY_INDEX be 16

# Statement type constants - synchronized with codegen.runa
Let STMT_LET be 1
Let STMT_SET be 2
Let STMT_RETURN be 3
Let STMT_PRINT be 4
Let STMT_IF be 5
Let STMT_WHILE be 6
Let STMT_EXPRESSION be 7
Let STMT_MATCH be 8
Let STMT_IMPORT be 8
Let STMT_BREAK be 9
Let STMT_CONTINUE be 10
Let STMT_FOR be 11
Let STMT_INLINE_ASSEMBLY be 16

# Type kind constants
Let TYPE_KIND_STRUCT be 0
Let TYPE_KIND_VARIANT be 1
Let TYPE_KIND_FUNCTION be 2
Let TYPE_KIND_ARRAY be 3

# TOKEN constants (from lexer.h enum - sequential numbering)
# Authoritative token constants from lexer.runa - DO NOT MODIFY
Let TOKEN_EOF be 0
Let TOKEN_PROCESS be 1
Let TOKEN_CALLED be 2
Let TOKEN_RETURNS be 3
Let TOKEN_INTEGER_TYPE be 4
Let TOKEN_STRING_TYPE be 5
Let TOKEN_CHARACTER_TYPE be 6
Let TOKEN_RETURN be 7
Let TOKEN_END be 8
Let TOKEN_COLON be 9
Let TOKEN_STRING_LITERAL be 10
Let TOKEN_INTEGER be 11
Let TOKEN_LET be 12
Let TOKEN_BE be 13
Let TOKEN_SET be 14
Let TOKEN_TO be 15
Let TOKEN_PLUS be 16
Let TOKEN_MINUS be 17
Let TOKEN_IF be 18
Let TOKEN_OTHERWISE be 19
Let TOKEN_WHILE be 20
Let TOKEN_IS be 21
Let TOKEN_EQUAL be 22
Let TOKEN_NOT_EQUAL be 23
Let TOKEN_LESS be 24
Let TOKEN_GREATER be 25
Let TOKEN_GREATER_EQUAL be 26
Let TOKEN_LESS_EQUAL be 27
Let TOKEN_THAN be 28
Let TOKEN_NOT be 29
Let TOKEN_AND be 30
Let TOKEN_OR be 31
Let TOKEN_THAT be 32
Let TOKEN_TAKES be 33
Let TOKEN_AS be 34
Let TOKEN_MULTIPLIED be 35
Let TOKEN_DIVIDED be 36
Let TOKEN_MODULO be 37
Let TOKEN_BY be 38
Let TOKEN_BIT_AND be 39
Let TOKEN_BIT_OR be 40
Let TOKEN_BIT_XOR be 41
Let TOKEN_BIT_SHIFT_LEFT be 42
Let TOKEN_BIT_SHIFT_RIGHT be 43
Let TOKEN_BREAK be 44
Let TOKEN_CONTINUE be 45
Let TOKEN_OTHERWISE_IF be 46
Let TOKEN_PRINT be 47
Let TOKEN_LPAREN be 48
Let TOKEN_RPAREN be 49
Let TOKEN_TYPE be 50
Let TOKEN_DOT be 51
Let TOKEN_COMMA be 52
Let TOKEN_IDENTIFIER be 53
Let TOKEN_READ_FILE be 54
Let TOKEN_WRITE_FILE be 55
Let TOKEN_IMPORT be 56
Let TOKEN_STRING_LENGTH be 57
Let TOKEN_STRING_CHAR_AT be 58
Let TOKEN_STRING_SUBSTRING be 59
Let TOKEN_STRING_EQUALS be 60
Let TOKEN_ASCII_VALUE_OF be 61
Let TOKEN_IS_DIGIT be 62
Let TOKEN_IS_ALPHA be 63
Let TOKEN_IS_WHITESPACE be 64
Let TOKEN_LIST_CREATE be 65
Let TOKEN_LIST_APPEND be 66
Let TOKEN_LIST_GET be 67
Let TOKEN_LIST_GET_INTEGER be 68
Let TOKEN_LIST_LENGTH be 69
Let TOKEN_LIST_DESTROY be 70
Let TOKEN_LIST_SET be 71
Let TOKEN_LIST_INSERT be 72
Let TOKEN_LIST_REMOVE be 73
Let TOKEN_LIST_CLEAR be 74
Let TOKEN_LIST_FIND be 75
Let TOKEN_LIST_SORT be 76
Let TOKEN_LIST_REVERSE be 77
Let TOKEN_LIST_COPY be 78
Let TOKEN_LIST_MERGE be 79
Let TOKEN_STRING_CONCAT be 80
Let TOKEN_STRING_COMPARE be 81
Let TOKEN_STRING_TO_INTEGER be 82
Let TOKEN_INTEGER_TO_STRING be 83
Let TOKEN_STRING_FIND be 84
Let TOKEN_STRING_REPLACE be 85
Let TOKEN_STRING_TRIM be 86
Let TOKEN_STRING_SPLIT be 87
Let TOKEN_FILE_OPEN be 88
Let TOKEN_FILE_CLOSE be 89
Let TOKEN_FILE_READ_LINE be 90
Let TOKEN_FILE_WRITE_LINE be 91
Let TOKEN_FILE_EXISTS be 92
Let TOKEN_FILE_DELETE be 93
Let TOKEN_FILE_SIZE be 94
Let TOKEN_FILE_SEEK be 95
Let TOKEN_FILE_TELL be 96
Let TOKEN_FILE_EOF be 97
Let TOKEN_SIN be 98
Let TOKEN_COS be 99
Let TOKEN_TAN be 100
Let TOKEN_SQRT be 101
Let TOKEN_POW be 102
Let TOKEN_ABS be 103
Let TOKEN_FLOOR be 104
Let TOKEN_CEIL be 105
Let TOKEN_MIN be 106
Let TOKEN_MAX be 107
Let TOKEN_RANDOM be 108
Let TOKEN_LOG be 109
Let TOKEN_EXP be 110
Let TOKEN_PIPE be 111
Let TOKEN_MATCH be 112
Let TOKEN_WHEN be 113
Let TOKEN_WITH be 114
Let TOKEN_GET_COMMAND_LINE_ARGS be 115
Let TOKEN_EXIT_WITH_CODE be 116
Let TOKEN_PANIC be 117
Let TOKEN_ASSERT be 118
Let TOKEN_ALLOCATE be 119
Let TOKEN_DEALLOCATE be 120
Let TOKEN_INLINE be 121
Let TOKEN_ASSEMBLY be 122
Let TOKEN_NOTE be 123
Let TOKEN_POINTER be 124
Let TOKEN_OF be 125
Let TOKEN_ARRAY be 126
Let TOKEN_LBRACKET be 127
Let TOKEN_RBRACKET be 128
Let TOKEN_ERROR be 129
Let TOKEN_COUNT be 130

# TypeDefinition constants
Let TypeDefinition_SIZE be 80
Let TYPEDEFINITION_NAME_OFFSET be 0
Let TYPEDEFINITION_KIND_OFFSET be 8
Let TYPEDEFINITION_SIZE_OFFSET be 16
Let TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET be 24
Let TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET be 32
Let TYPEDEFINITION_DATA_ARRAY_ELEMENT_TYPE_OFFSET be 24
Let TYPEDEFINITION_DATA_ARRAY_LENGTH_OFFSET be 32
Let TYPEDEFINITION_DATA_ARRAY_ELEMENT_SIZE_OFFSET be 40
Let TYPEDEFINITION_DATA_FUNCTION_PARAM_TYPES_OFFSET be 24
Let TYPEDEFINITION_DATA_FUNCTION_PARAM_COUNT_OFFSET be 32
Let TYPEDEFINITION_DATA_FUNCTION_RETURN_TYPE_OFFSET be 40
Let TYPEDEFINITION_DATA_VARIANT_VARIANTS_OFFSET be 24
Let TYPEDEFINITION_DATA_VARIANT_VARIANT_COUNT_OFFSET be 32

# TypeField constants
Let TYPEFIELD_SIZE be 32
Let TYPEFIELD_NAME_OFFSET be 0
Let TYPEFIELD_TYPE_OFFSET be 8
Let TYPEFIELD_OFFSET_OFFSET be 16
Let TYPEFIELD_SIZE_OFFSET be 24

# Variant constants
Let VARIANT_SIZE be 32
Let VARIANT_NAME_OFFSET be 0
Let VARIANT_FIELDS_OFFSET be 8
Let VARIANT_FIELD_COUNT_OFFSET be 16
Let VARIANT_TAG_OFFSET be 24

# Type kind constants already defined above

# Parser constants (definitions moved to bottom of file)
Let PARSER_CURRENT_TOKEN_OFFSET be 8
Let EXPRESSION_TYPE_OFFSET be 0

# String duplicate helper (already in string_utils but needed locally)
Process called "string_duplicate_parser" takes str as Integer returns Integer:
    If str is equal to 0:
        Return 0
    End If
    Let len be string_length(str)
    Let one be 1
    Let size be len plus one
    Let dup be memory_allocate(size)
    string_copy(dup, str)
    Return dup
End Process

# Parser advance - moves to next token
Process called "parser_advance" takes parser as Integer returns Integer:
    Let current_token be memory_get_pointer(parser, 8)  # parser->current_token
    token_destroy(current_token)
    Let lexer be memory_get_pointer(parser, 0)  # parser->lexer
    Let next_token be lexer_next_token(lexer)
    memory_set_pointer(parser, 8, next_token)
    Return 0
End Process

# Parser eat - consume expected token
Process called "parser_eat" takes parser as Integer, expected_type as Integer returns Integer:
    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_integer(current_token, 0)

    If token_type is equal to expected_type:
        Let dummy be parser_advance(parser)
    Otherwise:
        # Print error message
        Let error_msg be "[PARSER ERROR] Expected token type "
        print_string(error_msg)
        print_integer(expected_type)
        Let got_msg be ", got "
        print_string(got_msg)
        print_integer(token_type)
        Let at_line_msg be " at line "
        print_string(at_line_msg)
        Let line be memory_get_integer(current_token, 16)
        print_integer(line)
        print_newline()
        exit_with_code(1)
    End If
    Return 0
End Process

# Check if token is builtin function
Process called "parser_is_builtin_function_token" takes type as Integer returns Integer:
    # All builtin functions in order (54-120, excluding non-builtin tokens)
    # File operations
    If type is equal to 54:  # TOKEN_READ_FILE
        Return 1
    End If
    If type is equal to 55:  # TOKEN_WRITE_FILE
        Return 1
    End If
    # String operations
    If type is equal to 57:  # TOKEN_STRING_LENGTH
        Return 1
    End If
    If type is equal to 58:  # TOKEN_STRING_CHAR_AT
        Return 1
    End If
    If type is equal to 59:  # TOKEN_STRING_SUBSTRING
        Return 1
    End If
    If type is equal to 60:  # TOKEN_STRING_EQUALS
        Return 1
    End If
    If type is equal to 61:  # TOKEN_ASCII_VALUE_OF
        Return 1
    End If
    If type is equal to 62:  # TOKEN_IS_DIGIT
        Return 1
    End If
    If type is equal to 63:  # TOKEN_IS_ALPHA
        Return 1
    End If
    If type is equal to 64:  # TOKEN_IS_WHITESPACE
        Return 1
    End If
    # List operations
    If type is equal to 65:  # TOKEN_LIST_CREATE
        Return 1
    End If
    If type is equal to 66:  # TOKEN_LIST_APPEND
        Return 1
    End If
    If type is equal to 67:  # TOKEN_LIST_GET
        Return 1
    End If
    If type is equal to 68:  # TOKEN_LIST_GET_INTEGER
        Return 1
    End If
    If type is equal to 69:  # TOKEN_LIST_LENGTH
        Return 1
    End If
    If type is equal to 70:  # TOKEN_LIST_DESTROY
        Return 1
    End If
    If type is equal to 71:  # TOKEN_LIST_SET
        Return 1
    End If
    If type is equal to 72:  # TOKEN_LIST_INSERT
        Return 1
    End If
    If type is equal to 73:  # TOKEN_LIST_REMOVE
        Return 1
    End If
    If type is equal to 74:  # TOKEN_LIST_CLEAR
        Return 1
    End If
    If type is equal to 75:  # TOKEN_LIST_FIND
        Return 1
    End If
    If type is equal to 76:  # TOKEN_LIST_SORT
        Return 1
    End If
    If type is equal to 77:  # TOKEN_LIST_REVERSE
        Return 1
    End If
    If type is equal to 78:  # TOKEN_LIST_COPY
        Return 1
    End If
    If type is equal to 79:  # TOKEN_LIST_MERGE
        Return 1
    End If
    # More string operations
    If type is equal to 80:  # TOKEN_STRING_CONCAT
        Return 1
    End If
    If type is equal to 81:  # TOKEN_STRING_COMPARE
        Return 1
    End If
    If type is equal to 82:  # TOKEN_STRING_TO_INTEGER
        Return 1
    End If
    If type is equal to 83:  # TOKEN_INTEGER_TO_STRING
        Return 1
    End If
    If type is equal to 84:  # TOKEN_STRING_FIND
        Return 1
    End If
    If type is equal to 85:  # TOKEN_STRING_REPLACE
        Return 1
    End If
    If type is equal to 86:  # TOKEN_STRING_TRIM
        Return 1
    End If
    If type is equal to 87:  # TOKEN_STRING_SPLIT
        Return 1
    End If
    # More file operations
    If type is equal to 88:  # TOKEN_FILE_OPEN
        Return 1
    End If
    If type is equal to 89:  # TOKEN_FILE_CLOSE
        Return 1
    End If
    If type is equal to 90:  # TOKEN_FILE_READ_LINE
        Return 1
    End If
    If type is equal to 91:  # TOKEN_FILE_WRITE_LINE
        Return 1
    End If
    If type is equal to 92:  # TOKEN_FILE_EXISTS
        Return 1
    End If
    If type is equal to 93:  # TOKEN_FILE_DELETE
        Return 1
    End If
    If type is equal to 94:  # TOKEN_FILE_SIZE
        Return 1
    End If
    If type is equal to 95:  # TOKEN_FILE_SEEK
        Return 1
    End If
    If type is equal to 96:  # TOKEN_FILE_TELL
        Return 1
    End If
    If type is equal to 97:  # TOKEN_FILE_EOF
        Return 1
    End If
    # Math operations
    If type is equal to 98:  # TOKEN_SIN
        Return 1
    End If
    If type is equal to 99:  # TOKEN_COS
        Return 1
    End If
    If type is equal to 100:  # TOKEN_TAN
        Return 1
    End If
    If type is equal to 101:  # TOKEN_SQRT
        Return 1
    End If
    If type is equal to 102:  # TOKEN_POW
        Return 1
    End If
    If type is equal to 103:  # TOKEN_ABS
        Return 1
    End If
    If type is equal to 104:  # TOKEN_FLOOR
        Return 1
    End If
    If type is equal to 105:  # TOKEN_CEIL
        Return 1
    End If
    If type is equal to 106:  # TOKEN_MIN
        Return 1
    End If
    If type is equal to 107:  # TOKEN_MAX
        Return 1
    End If
    If type is equal to 108:  # TOKEN_RANDOM
        Return 1
    End If
    If type is equal to 109:  # TOKEN_LOG
        Return 1
    End If
    If type is equal to 110:  # TOKEN_EXP
        Return 1
    End If
    # System operations
    If type is equal to 115:  # TOKEN_GET_COMMAND_LINE_ARGS
        Return 1
    End If
    If type is equal to 116:  # TOKEN_EXIT_WITH_CODE
        Return 1
    End If
    If type is equal to 117:  # TOKEN_PANIC
        Return 1
    End If
    If type is equal to 118:  # TOKEN_ASSERT
        Return 1
    End If
    If type is equal to 119:  # TOKEN_ALLOCATE
        Return 1
    End If
    If type is equal to 120:  # TOKEN_DEALLOCATE
        Return 1
    End If
    If type is equal to 130:  # TOKEN_MEMORY_GET_BYTE
        Return 1
    End If
    If type is equal to 131:  # TOKEN_MEMORY_SET_BYTE
        Return 1
    End If
    Return 0
End Process

# Create integer expression
Process called "expression_create_integer" takes value as Integer returns Integer:
    Let expr_size be 32  # Ensure sufficient space: type(8) + value(8) + padding
    Let expr be memory_allocate(expr_size)
    memory_set_integer(expr, 0, EXPR_INTEGER)
    memory_set_integer(expr, 8, value)
    Return expr
End Process

# Create variable expression
Process called "expression_create_variable" takes name as Integer returns Integer:
    Let expr_size be 32  # Ensure sufficient space: type(8) + name_pointer(8) + padding
    Let expr be memory_allocate(expr_size)
    memory_set_integer(expr, 0, EXPR_VARIABLE)
    Let dup_name be string_duplicate_parser(name)
    memory_set_pointer(expr, 8, dup_name)
    Return expr
End Process

# Create binary operation expression
Process called "expression_create_binary_op" takes left as Integer, operator as Integer, right as Integer returns Integer:
    Let expr_size be 32  # type plus left plus right plusoperator
    Let expr be memory_allocate(expr_size)
    memory_set_integer(expr, 0, EXPR_BINARY_OP)
    memory_set_pointer(expr, 8, left)
    memory_set_pointer(expr, 16, right)
    memory_set_integer(expr, 24, operator)
    Return expr
End Process

# Create comparison expression
Process called "expression_create_comparison" takes left as Integer, comparison_op as Integer, right as Integer returns Integer:
    Let expr_size be 32
    Let expr be memory_allocate(expr_size)
    memory_set_integer(expr, 0, EXPR_COMPARISON)
    memory_set_pointer(expr, 8, left)
    memory_set_pointer(expr, 16, right)
    memory_set_integer(expr, 24, comparison_op)
    Return expr
End Process

# Create function call expression
Process called "expression_create_function_call" takes function_name as Integer, arguments as Integer, argument_count as Integer returns Integer:
    Let expr_size be 32
    Let expr be memory_allocate(expr_size)
    memory_set_integer(expr, 0, EXPR_FUNCTION_CALL)
    Let dup_name be string_duplicate_parser(function_name)
    memory_set_pointer(expr, 8, dup_name)
    memory_set_pointer(expr, 16, arguments)
    memory_set_integer(expr, 24, argument_count)
    Return expr
End Process

# Create string literal expression (takes ownership)
Process called "expression_create_string_literal_owned" takes string_value as Integer returns Integer:
    Let expr_size be 32  # Match other expression types for safety
    Let expr be memory_allocate(expr_size)
    memory_set_integer(expr, 0, EXPR_STRING_LITERAL)
    memory_set_pointer(expr, 8, string_value)  # Takes ownership

    Return expr
End Process

# Create let statement
Process called "statement_create_let" takes var_name as Integer, expr as Integer returns Integer:
    Let stmt_size be 24
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_LET)
    Let dup_name be string_duplicate_parser(var_name)
    memory_set_pointer(stmt, 8, dup_name)   # variable_name at offset 8
    memory_set_pointer(stmt, 16, expr)      # expression at offset 16
    Return stmt
End Process

# Create set statement
Process called "statement_create_set" takes target as Integer, expr as Integer returns Integer:
    Let stmt_size be 24
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_SET)
    memory_set_pointer(stmt, 8, target)  # target at offset 8
    memory_set_pointer(stmt, 16, expr)   # expression at offset 16
    Return stmt
End Process

# Create return statement
Process called "statement_create_return" takes expr as Integer returns Integer:
    Let stmt_size be 24  # Match other statement types that have fields at offset 16
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_RETURN)
    memory_set_pointer(stmt, 8, expr)
    Return stmt
End Process

# Create print statement
Process called "statement_create_print" takes expr as Integer returns Integer:
    Let stmt_size be 24  # Match other statement types for consistency
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_PRINT)
    memory_set_pointer(stmt, 8, expr)
    Return stmt
End Process

# Create expression statement
Process called "statement_create_expression" takes expr as Integer returns Integer:
    Let stmt_size be 24  # Match other statement types for consistency
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_EXPRESSION)
    memory_set_pointer(stmt, 8, expr)
    Return stmt
End Process

# Create if statement
Process called "statement_create_if" takes condition as Integer, if_body as Integer, if_body_count as Integer, else_body as Integer, else_body_count as Integer returns Integer:
    Let stmt_size be 48
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_IF)
    memory_set_pointer(stmt, 8, condition)
    memory_set_pointer(stmt, 16, if_body)
    memory_set_integer(stmt, 24, if_body_count)
    memory_set_pointer(stmt, 32, else_body)
    memory_set_integer(stmt, 40, else_body_count)
    Return stmt
End Process

# Create while statement
Process called "statement_create_while" takes condition as Integer, body as Integer, body_count as Integer returns Integer:
    Let stmt_size be 32
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_WHILE)
    memory_set_pointer(stmt, 8, condition)
    memory_set_pointer(stmt, 16, body)
    memory_set_integer(stmt, 24, body_count)
    Return stmt
End Process

# Create break statement
Process called "statement_create_break" takes dummy as Integer returns Integer:
    Let stmt_size be 8
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_BREAK)
    Return stmt
End Process

# Create continue statement
Process called "statement_create_continue" takes dummy as Integer returns Integer:
    Let stmt_size be 8
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_CONTINUE)
    Return stmt
End Process

# Create function
Process called "function_create" takes name as Integer, return_type as Integer returns Integer:
    Let func_size be 48  # name, parameters, parameter_count, return_type, statements, statement_count
    Let func be memory_allocate(func_size)
    Let dup_name be string_duplicate_parser(name)
    memory_set_pointer(func, 0, dup_name)
    memory_set_pointer(func, 8, 0)  # parameters = NULL
    memory_set_integer(func, 16, 0)  # parameter_count = 0
    Let dup_type be string_duplicate_parser(return_type)
    memory_set_pointer(func, 24, dup_type)
    memory_set_pointer(func, 32, 0)  # statements = NULL
    memory_set_integer(func, 40, 0)  # statement_count = 0
    Return func
End Process

# Add parameter to function
Process called "function_add_parameter" takes func as Integer, param_name as Integer, param_type as Integer returns Integer:
    Let parameter_count be memory_get_integer(func, 16)
    Let new_count be parameter_count plus 1
    Let param_size be 16  # sizeof(Parameter) = name plustype
    Let new_size be new_count multiplied by param_size

    Let parameters be memory_get_pointer(func, 8)
    Let new_parameters be memory_reallocate(parameters, new_size)

    Let offset be parameter_count multiplied by param_size
    Let param_ptr be new_parameters plus offset
    Let dup_name be string_duplicate_parser(param_name)
    memory_set_pointer(param_ptr, 0, dup_name)
    Let dup_type be string_duplicate_parser(param_type)
    memory_set_pointer(param_ptr, 8, dup_type)

    memory_set_pointer(func, 8, new_parameters)
    memory_set_integer(func, 16, new_count)
    Return 0
End Process
