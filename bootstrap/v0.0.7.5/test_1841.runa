# Code Generator for x86-64 Assembly
# Transliterated from codegen_x86.c (v0.0.7.3)
# Generates x86-64 assembly from parsed AST

# Program structure offsets (defined in parser.runa)
# Using numeric values to avoid duplicate symbol errors
# PROGRAM_FUNCTIONS = 0
# PROGRAM_FUNCTION_COUNT = 8
# PROGRAM_TYPES = 16
# PROGRAM_TYPE_COUNT = 24
# PROGRAM_IMPORTS = 32
# PROGRAM_IMPORT_COUNT = 40
# PROGRAM_GLOBAL_VARS = 48
# PROGRAM_GLOBAL_COUNT = 56

# Forward declarations for loop context management
# These will be implemented later in the file

# Note: string_duplicate is provided by string_utils module

# Helper to emit a line with newline
Process called "emit_line" takes output_file as Integer, line as Integer returns Integer:
    file_write_fd(output_file, line)
    file_write_fd(output_file, "\n")
    Return 0
End Process

# Find variable in current scope - equivalent to codegen_find_variable
Process called "codegen_find_variable" takes codegen as Integer, name as Integer returns Integer:
    Let variable_count be memory_get_integer(codegen, 16)  # codegen->variable_count (int)
    Let variables be memory_get_pointer(codegen, 8)        # codegen->variables
    Let i be 0
    While i is less than variable_count:
        Let var_offset be i multiplied by 32
        Let var_ptr be variables plus var_offset  # sizeof(Variable) = 32
        Let var_name be memory_get_pointer(var_ptr, 0)
        If string_equals(var_name, name) is equal to 1:
            Return i
        End If
        Let i be i plus 1
    End While
    Return 0 minus 1  # -1 for not found
End Process

# Calculate size of a type in bytes - equivalent to codegen_calculate_type_size
Process called "codegen_calculate_type_size" takes type_name as Integer, program as Integer returns Integer:
    # Built-in types
    If string_equals(type_name, "Integer") is equal to 1:
        Return 8  # 64-bit integer
    End If
    If string_equals(type_name, "Byte") is equal to 1:
        Return 1  # 8-bit byte
    End If
    If string_equals(type_name, "Short") is equal to 1:
        Return 2  # 16-bit short
    End If
    If string_equals(type_name, "Long") is equal to 1:
        Return 8  # 64-bit long
    End If

    # Custom types - look up in the program
    If program is not equal to 0:
        Let type_count be memory_get_integer(program, 24)  # PROGRAM_TYPE_COUNT - use int32
        Let types be memory_get_pointer(program, 16)       # PROGRAM_TYPES - use pointer
        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)  # type->name
            If string_equals(type_name_ptr, type_name) is equal to 1:
                Let type_size be memory_get_integer(type_ptr, 16)  # type->size
                Return type_size
            End If
            Let i be i plus 1
        End While
    End If

    # Unknown type - default to 8 bytes
    Return 8
End Process

# Add variable with type and parameter flag - equivalent to codegen_add_variable_with_type_and_param_flag
Process called "codegen_add_variable_with_type_and_param_flag" takes codegen as Integer, name as Integer, type_name as Integer, is_parameter as Integer returns Integer:
    # Get current counts and capacity

    Let variable_count be memory_get_integer(codegen, 16)      # codegen->variable_count (int)
    Let variable_capacity be memory_get_integer(codegen, 20)   # codegen->variable_capacity (int)
    Let variables be memory_get_pointer(codegen, 8)            # codegen->variables

    # DEBUG: Show what we read
    # print_integer(variable_count)
    # print_integer(variable_capacity)

    # Grow array if needed
    If variable_count is greater than or equal to variable_capacity:
        Let new_capacity be variable_capacity multiplied by 2
        Let new_size be new_capacity multiplied by 32  # sizeof(Variable)
        Let new_variables be allocate(new_size)

        # Copy existing variables
        Let i be 0
        While i is less than variable_count:
            Let var_offset be i multiplied by 32
            Let old_var be variables plus var_offset
            Let var_offset be i multiplied by 32
            Let new_var be new_variables plus var_offset
            # Copy Variable struct (32 bytes)
            Let j be 0
            While j is less than 32:
                Let byte_val be memory_get_byte(old_var plus j, 0)
                memory_set_byte(new_var plus j, 0, byte_val)
                Let j be j plus 1
            End While
            Let i be i plus 1
        End While

        # Free old array and update
        deallocate(variables)
        memory_set_pointer(codegen, 8, new_variables)      # codegen->variables
        memory_set_integer(codegen, 20, new_capacity)      # codegen->variable_capacity (int)
        Let variables be new_variables
    End If

    # Calculate size based on type
    Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)
    Let size be codegen_calculate_type_size(type_name, current_program)
    If type_name is equal to 0:
        Let size be codegen_calculate_type_size("Integer", current_program)
    End If

    # Update stack offset
    Let stack_offset be memory_get_integer(codegen, 24)  # codegen->stack_offset (int)
    Let new_stack_offset be stack_offset plus size
    memory_set_integer(codegen, 24, new_stack_offset)  # codegen->stack_offset (int)

    # Get variable index
    Let var_index be variable_count
    Let var_offset be var_index multiplied by 32  # Calculate offset separately
    Let var_ptr be variables plus var_offset      # Then add to base pointer


    # Set variable fields
    memory_set_pointer(var_ptr, 0, string_duplicate(name))       # name
    memory_set_integer(var_ptr, 8, new_stack_offset)            # stack_offset (int)
    If type_name is equal to 0:
        memory_set_pointer(var_ptr, 16, string_duplicate("Integer")) # type_name - use literal directly
    Otherwise:
        memory_set_pointer(var_ptr, 16, string_duplicate(type_name)) # type_name
    End If
    memory_set_integer(var_ptr, 24, is_parameter)               # is_parameter (int)

    # Increment count
    memory_set_integer(codegen, 16, variable_count plus 1)  # codegen->variable_count (int)

    Return var_index
End Process

# Add variable with type - equivalent to codegen_add_variable_with_type
Process called "codegen_add_variable_with_type" takes codegen as Integer, name as Integer, type_name as Integer returns Integer:
    Return codegen_add_variable_with_type_and_param_flag(codegen, name, type_name, 0)
End Process

# Add variable with default Integer type - equivalent to codegen_add_variable
Process called "codegen_add_variable" takes codegen as Integer, name as Integer returns Integer:
    Return codegen_add_variable_with_type(codegen, name, "Integer")
End Process

# Add string literal - equivalent to codegen_add_string_literal
Process called "codegen_add_string_literal" takes codegen as Integer, value as Integer returns Integer:
    # Get current counts and capacity
    Let string_count be memory_get_integer(codegen, 40)      # codegen->string_count (int)
    Let string_capacity be memory_get_integer(codegen, 44)   # codegen->string_capacity (int)
    Let strings be memory_get_pointer(codegen, 32)           # codegen->strings (pointer with padding)


    # Grow array if needed
    If string_count is greater than or equal to string_capacity:
        Let new_capacity be string_capacity multiplied by 2
        Let new_size be new_capacity multiplied by 16  # sizeof(StringLiteral)
        Let new_strings be allocate(new_size)

        # Copy existing strings
        Let i be 0
        While i is less than string_count:
            Let str_offset be i multiplied by 16
            Let old_str be strings plus str_offset
            Let str_offset be i multiplied by 16
            Let new_str be new_strings plus str_offset
            # Copy StringLiteral struct (16 bytes)
            Let j be 0
            While j is less than 16:
                Let byte_val be memory_get_byte(old_str plus j, 0)
                memory_set_byte(new_str plus j, 0, byte_val)
                Let j be j plus 1
            End While
            Let i be i plus 1
        End While

        # Free old array and update
        deallocate(strings)
        memory_set_pointer(codegen, 32, new_strings)      # codegen->strings (pointer)
        memory_set_integer(codegen, 44, new_capacity)     # codegen->string_capacity (int)
        Let strings be new_strings
    End If

    Let str_index be string_count
    Let str_offset be str_index multiplied by 16
    Let str_ptr be strings plus str_offset

    # Set string value
    memory_set_pointer(str_ptr, 0, string_duplicate(value))  # value

    # Generate unique label for this string
    Let label be string_concat(".STR", integer_to_string(str_index))
    memory_set_pointer(str_ptr, 8, label)  # label

    # Increment count
    memory_set_integer(codegen, 40, string_count plus 1)  # codegen->string_count (int)


    Return str_index
End Process

# Collect strings from expression - equivalent to codegen_collect_strings_from_expression
Process called "codegen_collect_strings_from_expression" takes codegen as Integer, expr as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If
    # Safety check for invalid pointers
    If expr is less than 65536:
        Return 0
    End If

    Let expr_type be memory_get_integer(expr, 0)  # expr->type


    If expr_type is equal to 5:  # EXPR_STRING_LITERAL
        # Check if string already exists
        Let string_count be memory_get_integer(codegen, 40)  # codegen->string_count (int)
        Let strings be memory_get_pointer(codegen, 32)  # codegen->strings (pointer)
        Let string_literal be memory_get_pointer(expr, 8)  # expr->data.string_literal

        # Safety check for string_literal
        If string_literal is equal to 0:
            Return 0
        End If
        If string_literal is less than 65536:
            Return 0
        End If

        # Safety check - string_count should be reasonable
        If string_count is less than 0:
            Return 0
        End If
        If string_count is greater than 1000:
            Return 0
        End If

        Let i be 0
        While i is less than string_count:
            Let str_offset be i multiplied by 16
            Let str_ptr be strings plus str_offset
            Let existing_value be memory_get_pointer(str_ptr, 0)  # Should be pointer, not integer!
            # Safety check for existing_value before comparison
            If existing_value is not equal to 0:
                If existing_value is greater than 65536:
                    If string_equals(existing_value, string_literal) is equal to 1:
                        Return 0  # Already added
                    End If
                End If
            End If
            Let i be i plus 1
        End While

        codegen_add_string_literal(codegen, string_literal)
        Return 0
    End If

    If expr_type is equal to 2:  # EXPR_BINARY_OP
        Let left be memory_get_pointer(expr, 8)   # binary_op.left
        Let right be memory_get_pointer(expr, 16) # binary_op.right
        codegen_collect_strings_from_expression(codegen, left)
        codegen_collect_strings_from_expression(codegen, right)
        Return 0
    End If

    If expr_type is equal to 3:  # EXPR_COMPARISON
        Let left be memory_get_pointer(expr, 8)   # comparison.left
        Let right be memory_get_pointer(expr, 16) # comparison.right
        codegen_collect_strings_from_expression(codegen, left)
        codegen_collect_strings_from_expression(codegen, right)
        Return 0
    End If

    If expr_type is equal to 4:  # EXPR_FUNCTION_CALL
        Let func_call_ptr be expr plus 8  # &expr->data.function_call
        # function_call structure: function_name (char*) at 0, arguments (Expression**) at 8, argument_count (int) at 16
        Let function_name be memory_get_pointer(func_call_ptr, 0)  # function_call.function_name
        Let arguments be memory_get_pointer(func_call_ptr, 8)      # function_call.arguments - this is a pointer!
        Let argument_count be memory_get_integer(func_call_ptr, 16) # function_call.argument_count


        Let i be 0
        While i is less than argument_count:
            Let arg_offset be i multiplied by 8
            Let arg_ptr be memory_get_pointer(arguments, arg_offset)


            codegen_collect_strings_from_expression(codegen, arg_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 6:  # EXPR_FIELD_ACCESS
        Let object be memory_get_pointer(expr, 8)  # field_access.object
        codegen_collect_strings_from_expression(codegen, object)
        Return 0
    End If

    If expr_type is equal to 8:  # EXPR_BUILTIN_CALL
        Let builtin_call_ptr be expr plus 8  # &expr->data.builtin_call
        # builtin_call structure: builtin_type (int) at 0, arguments (Expression**) at 8, argument_count (int) at 16
        Let builtin_type be memory_get_integer(builtin_call_ptr, 0)  # builtin_call.builtin_type
        Let arguments be memory_get_pointer(builtin_call_ptr, 8)      # builtin_call.arguments - this is a pointer!
        Let argument_count be memory_get_integer(builtin_call_ptr, 16) # builtin_call.argument_count

        Let i be 0
        While i is less than argument_count:
            Let arg_offset be i multiplied by 8
            Let arg_ptr be memory_get_pointer(arguments, arg_offset)
            codegen_collect_strings_from_expression(codegen, arg_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 9:  # EXPR_VARIANT_CONSTRUCTOR
        Let variant_constructor_ptr be expr plus 8  # &expr->data.variant_constructor
        # variant_constructor structure: type_name (char*) at 0, variant_name (char*) at 8, field_values (Expression**) at 16, field_count (int) at 24
        Let type_name be memory_get_pointer(variant_constructor_ptr, 0)     # variant_constructor.type_name
        Let variant_name be memory_get_pointer(variant_constructor_ptr, 8)  # variant_constructor.variant_name
        Let field_values be memory_get_pointer(variant_constructor_ptr, 16) # variant_constructor.field_values - this is a pointer!
        Let field_count be memory_get_integer(variant_constructor_ptr, 24)  # variant_constructor.field_count

        Let i be 0
        While i is less than field_count:
            Let field_offset be i multiplied by 8
            Let field_value_ptr be memory_get_pointer(field_values, field_offset)  # This is also a pointer!
            codegen_collect_strings_from_expression(codegen, field_value_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 16:  # EXPR_ARRAY_INDEX
        Let array_index_ptr be expr plus 8  # &expr->data.array_index
        Let arr be memory_get_integer(array_index_ptr, 0)  # array_index.array
        Let index be memory_get_integer(array_index_ptr, 8)  # array_index.index
        codegen_collect_strings_from_expression(codegen, arr)
        codegen_collect_strings_from_expression(codegen, index)
        Return 0
    End If

    # Other expression types (INTEGER, VARIABLE, TYPE_NAME, FUNCTION_POINTER) have no strings to collect
    Return 0
End Process

# Collect strings from statement - equivalent to codegen_collect_strings_from_statement
Process called "codegen_collect_strings_from_statement" takes codegen as Integer, stmt as Integer returns Integer:
    If stmt is equal to 0:
        Return 0
    End If

    # Safety check - if stmt is a small number, it's likely corrupt
    If stmt is less than 65536:  # 0x10000 - reasonable minimum address
        Return 0
    End If

    Let stmt_type be memory_get_integer(stmt, 0)  # stmt->type


    # Safety check - statement types should be 0-12
    If stmt_type is less than 0:
        Return 0
    End If
    If stmt_type is greater than 12:
        Return 1
    End If

    If stmt_type is equal to 1:  # STMT_LET
        # Statement structure: type at 0, data union at 8
        # let_stmt in union: var_name at 0, expression at 8
        Let var_name be memory_get_pointer(stmt, 8)   # stmt+8 = let_stmt.var_name
        Let expression be memory_get_pointer(stmt, 16) # stmt+16 = let_stmt.expression


        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 2:  # STMT_SET
        # Statement structure: type at 0, data union at 8
        # set_stmt in union: target at 0, expression at 8
        Let target be memory_get_pointer(stmt, 8)      # stmt+8 = set_stmt.target
        Let expression be memory_get_pointer(stmt, 16) # stmt+16 = set_stmt.expression
        codegen_collect_strings_from_expression(codegen, target)
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 3:  # STMT_RETURN
        Let return_stmt_ptr be stmt plus 8  # &stmt->data.return_stmt
        Let expression be memory_get_pointer(return_stmt_ptr, 0)  # return_stmt.expression
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 4:  # STMT_PRINT
        Let print_stmt_ptr be stmt plus 8  # &stmt->data.print_stmt
        Let expression be memory_get_pointer(print_stmt_ptr, 0)  # print_stmt.expression
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 5:  # STMT_IF

        Let if_stmt_ptr be stmt plus 8  # &stmt->data.if_stmt
        Let condition be memory_get_pointer(if_stmt_ptr, 0)        # if_stmt.condition (offset 8)
        Let if_body be memory_get_pointer(if_stmt_ptr, 8)          # if_stmt.if_body (offset 16)
        Let if_body_count be memory_get_integer(if_stmt_ptr, 16)   # if_stmt.if_body_count (offset 24)
        Let else_body be memory_get_pointer(if_stmt_ptr, 24)       # if_stmt.else_body (offset 32)
        Let else_body_count be memory_get_integer(if_stmt_ptr, 32) # if_stmt.else_body_count (offset 40)


        codegen_collect_strings_from_expression(codegen, condition)

        # Process if body - add safety check
        If if_body is greater than 65536:  # Valid pointer check
            Let i be 0
            While i is less than if_body_count:
                Let stmt_offset be i multiplied by 8


                Let stmt_ptr be memory_get_pointer(if_body, stmt_offset)


                codegen_collect_strings_from_statement(codegen, stmt_ptr)
                Let i be i plus 1
            End While
        End If

        # Process else body - add safety check
        If else_body is greater than 65536:  # Valid pointer check
            Let i be 0
            While i is less than else_body_count:
                Let stmt_offset be i multiplied by 8
                Let stmt_ptr be memory_get_pointer(else_body, stmt_offset)
                codegen_collect_strings_from_statement(codegen, stmt_ptr)
                Let i be i plus 1
            End While
        End If
        Return 0
    End If

    If stmt_type is equal to 6:  # STMT_WHILE
        Let while_stmt_ptr be stmt plus 8  # &stmt->data.while_stmt
        Let condition be memory_get_pointer(while_stmt_ptr, 0)   # while_stmt.condition (offset 8)
        Let body be memory_get_pointer(while_stmt_ptr, 8)        # while_stmt.body (offset 16)
        Let body_count be memory_get_integer(while_stmt_ptr, 16) # while_stmt.body_count (offset 24)

        codegen_collect_strings_from_expression(codegen, condition)

        # Process body
        Let i be 0
        While i is less than body_count:
            Let stmt_offset be i multiplied by 8
            Let stmt_ptr be memory_get_pointer(body, stmt_offset)
            codegen_collect_strings_from_statement(codegen, stmt_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 6:  # STMT_WHILE
        # This is the duplicate WHILE check, should be removed but keeping for now
        Let while_stmt_ptr be stmt plus 8  # &stmt->data.while_stmt
        Let condition be memory_get_pointer(while_stmt_ptr, 0)   # while_stmt.condition (offset 8)
        Let body be memory_get_pointer(while_stmt_ptr, 8)        # while_stmt.body (offset 16)
        Let body_count be memory_get_integer(while_stmt_ptr, 16) # while_stmt.body_count (offset 24)

        codegen_collect_strings_from_expression(codegen, condition)

        Let i be 0
        While i is less than body_count:
            Let stmt_offset be i multiplied by 8
            Let stmt_ptr be memory_get_pointer(body, stmt_offset)
            codegen_collect_strings_from_statement(codegen, stmt_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 7:  # STMT_EXPRESSION
        Let expr_stmt_ptr be stmt plus 8  # &stmt->data.expr_stmt
        Let expression be memory_get_pointer(expr_stmt_ptr, 0)  # expr_stmt.expression - this is a pointer!
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 8:  # STMT_MATCH
        Let match_stmt_ptr be stmt plus 8  # &stmt->data.match_stmt
        Let expression be memory_get_pointer(match_stmt_ptr, 0)   # match_stmt.expression - this is a pointer!
        Let case_count be memory_get_integer(match_stmt_ptr, 8)   # match_stmt.case_count
        Let cases be memory_get_pointer(match_stmt_ptr, 16)       # match_stmt.cases - this is a pointer!

        codegen_collect_strings_from_expression(codegen, expression)

        # Process each match case
        Let i be 0
        While i is less than case_count:
            Let case_offset be i multiplied by 32
            Let match_case_ptr be cases plus case_offset  # sizeof(MatchCase)
            Let body_count be memory_get_integer(match_case_ptr, 16)  # match_case.body_count
            Let body be memory_get_pointer(match_case_ptr, 24)        # match_case.body - this is a pointer!

            Let j be 0
            While j is less than body_count:
                Let stmt_offset be j multiplied by 8
                Let stmt_ptr be memory_get_pointer(body, stmt_offset)
                codegen_collect_strings_from_statement(codegen, stmt_ptr)
                Let j be j plus 1
            End While
            Let i be i plus 1
        End While
        Return 0
    End If

    # Other statement types (IMPORT, BREAK, CONTINUE, INLINE_ASSEMBLY) don't have strings to collect
    Return 0
End Process

# Helper function to determine the type name of an expression
Process called "codegen_get_expression_type" takes codegen as Integer, expr as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If

    Let expr_type be memory_get_integer(expr, 0)  # expr->type

    If expr_type is equal to 1:  # EXPR_VARIABLE
        Let variable_name be memory_get_pointer(expr, 8)  # expr->data.variable_name
        Let var_index be codegen_find_variable(codegen, variable_name)

        If var_index is equal to 0 minus 1:  # -1 for not found
            # Check if this is a global variable
            Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)
            If current_program is not equal to 0:
                Let global_count be memory_get_integer(current_program, 56)  # program->global_count (PROGRAM_GLOBAL_COUNT)
                Let globals be memory_get_pointer(current_program, 48)       # program->globals (PROGRAM_GLOBAL_VARS)

                Let j be 0
                While j is less than global_count:
                    Let global_offset be j multiplied by 8
                    Let global_ptr be memory_get_pointer(globals, global_offset)
                    Let global_name be memory_get_pointer(global_ptr, 0)  # global->name
                    If string_equals(global_name, variable_name) is equal to 1:
                        Let global_type be memory_get_integer(global_ptr, 8)  # global->type
                        Return global_type
                    End If
                    Let j be j plus 1
                End While
            End If
            Return 0
        End If

        Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
        Let var_offset be var_index multiplied by 32
        Let var_ptr be variables plus var_offset
        Let type_name be memory_get_pointer(var_ptr, 16)  # variable.type_name
        Return type_name
    End If

    If expr_type is equal to 6:  # EXPR_FIELD_ACCESS
        Let field_access_ptr be expr plus 8  # &expr->data.field_access
        Let object be memory_get_integer(field_access_ptr, 0)       # field_access.object
        Let field_name be memory_get_pointer(field_access_ptr, 8)   # field_access.field_name

        # Get the type of the object
        Let object_type be codegen_get_expression_type(codegen, object)
        If object_type is equal to 0:
            Return 0
        End If

        # Find the type definition
        Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)
        Let type_count be memory_get_integer(current_program, 32)  # program->type_count
        Let types be memory_get_pointer(current_program, 24)       # program->types
        Let type be 0

        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)  # type->name
            If string_equals(type_name_ptr, object_type) is equal to 1:
                Let type be type_ptr
                Let i be type_count  # break loop
            End If
            Let i be i plus 1
        End While

        If type is equal to 0:
            Return 0
        End If

        # Find the field and return its type
        Let kind be memory_get_integer(type, 8)  # type->kind
        If kind is equal to 1:  # TYPE_KIND_STRUCT
            Let struct_type_ptr be type plus 16  # &type->data.struct_type
            Let field_count be memory_get_integer(struct_type_ptr, 0)  # struct_type.field_count
            Let fields be memory_get_pointer(struct_type_ptr, 8)       # struct_type.fields

            Let i be 0
            While i is less than field_count:
                Let field_offset be i multiplied by 24
                Let field_ptr be fields plus field_offset  # sizeof(FieldDefinition)
                Let field_name_ptr be memory_get_pointer(field_ptr, 0)  # field.name
                If string_equals(field_name_ptr, field_name) is equal to 1:
                    Let field_type be memory_get_integer(field_ptr, 8)  # field.type
                    Return field_type
                End If
                Let i be i plus 1
            End While
        End If

        Return 0
    End If

    # Other expression types don't have determinable types in this context
    Return 0
End Process

# Generate the address of an lvalue expression (result in %rbx)
Process called "codegen_generate_lvalue_address" takes codegen as Integer, expr as Integer returns Integer:
    Let expr_type be memory_get_integer(expr, 0)  # expr->type
    Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file

    If expr_type is equal to 1:  # EXPR_VARIABLE
        # Find variable and generate its address
        Let variable_name be memory_get_pointer(expr, 8)  # expr->data.variable_name
        Let var_index be codegen_find_variable(codegen, variable_name)

        If var_index is equal to 0 minus 1:  # -1 for not found
            # Check if this is a global variable
            Let is_global be 0
            Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)

            If current_program is not equal to 0:
                Let global_count be memory_get_integer(current_program, 56)  # program->global_count (PROGRAM_GLOBAL_COUNT)
                Let globals be memory_get_pointer(current_program, 48)       # program->globals (PROGRAM_GLOBAL_VARS)

                Let j be 0
                While j is less than global_count:
                    Let global_offset be j multiplied by 8
                    Let global_ptr be memory_get_pointer(globals, global_offset)
                    Let global_name be memory_get_pointer(global_ptr, 0)  # global->name
                    If string_equals(global_name, variable_name) is equal to 1:
                        Let is_global be 1
                        Let j be global_count  # break loop
                    End If
                    Let j be j plus 1
                End While
            End If

            If is_global is equal to 1:
                # Generate address of global variable
                file_write_fd(output_file, "    leaq ")
                file_write_fd(output_file, variable_name)
                file_write_fd(output_file, "(%rip), %rbx  # Address of global variable")
            Otherwise:
                print_string("[CODEGEN ERROR] Unknown variable '")
                print_string(variable_name)
                print_string("'")
                exit_with_code(1)
            End If
        Otherwise:
            Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
            Let var_offset be var_index multiplied by 32
            Let var_ptr be variables plus var_offset
            Let offset be memory_get_integer(var_ptr, 8)  # variable.stack_offset

            # Generate address of variable on stack
            file_write_fd(output_file, "    leaq -")
            file_write_fd(output_file, integer_to_string(offset))
            file_write_fd(output_file, "(%rbp), %rbx")
        End If
        Return 0
    End If

    If expr_type is equal to 6:  # EXPR_FIELD_ACCESS
        Let field_access_ptr be expr plus 8  # &expr->data.field_access
        Let object be memory_get_integer(field_access_ptr, 0)     # field_access.object
        Let field_name be memory_get_pointer(field_access_ptr, 8) # field_access.field_name

        # Generate address of object
        codegen_generate_lvalue_address(codegen, object)

        # Now %rbx contains the address of the object
        # We need to add the field offset to get the field address

        # Get the type of the object using our helper function
        Let object_type be codegen_get_expression_type(codegen, object)
        If object_type is equal to 0:
            print_string("[CODEGEN ERROR] Cannot determine type of object in field access")
            exit_with_code(1)
        End If

        # Find the type definition
        Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)
        Let type_count be memory_get_integer(current_program, 32)  # program->type_count
        Let types be memory_get_pointer(current_program, 24)       # program->types
        Let type be 0

        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)  # type->name
            If string_equals(type_name_ptr, object_type) is equal to 1:
                Let type be type_ptr
                Let i be type_count  # break loop
            End If
            Let i be i plus 1
        End While

        If type is equal to 0:
            print_string("[CODEGEN ERROR] Unknown type '")
            print_string(object_type)
            print_string("'")
            exit_with_code(1)
        End If

        # Find field offset
        Let field_offset be 0 minus 1  # -1 for not found
        Let kind be memory_get_integer(type, 8)  # type->kind

        If kind is equal to 1:  # TYPE_KIND_STRUCT
            Let struct_type_ptr be type plus 16  # &type->data.struct_type
            Let field_count be memory_get_integer(struct_type_ptr, 0)  # struct_type.field_count
            Let fields be memory_get_pointer(struct_type_ptr, 8)       # struct_type.fields

            Let i be 0
            While i is less than field_count:
                Let field_offset be i multiplied by 24
                Let field_ptr be fields plus field_offset  # sizeof(FieldDefinition)
                Let field_name_ptr be memory_get_pointer(field_ptr, 0)  # field.name
                If string_equals(field_name_ptr, field_name) is equal to 1:
                    Let field_offset be memory_get_integer(field_ptr, 16)  # field.offset
                    Let i be field_count  # break loop
                End If
                Let i be i plus 1
            End While
        End If

        If field_offset is equal to 0 minus 1:  # -1 for not found
            print_string("[CODEGEN ERROR] Type '")
            print_string(object_type)
            print_string("' has no field '")
            print_string(field_name)
            print_string("'")
            exit_with_code(1)
        End If

        # Add field offset to object address
        file_write_fd(output_file, "    addq $")
        file_write_fd(output_file, integer_to_string(field_offset))
        file_write_fd(output_file, ", %rbx")
        Return 0
    End If

    If expr_type is equal to 16:  # EXPR_ARRAY_INDEX
        Let array_index_ptr be expr plus 8  # &expr->data.array_index
        Let arr be memory_get_integer(array_index_ptr, 0)  # array_index.array
        Let index be memory_get_integer(array_index_ptr, 8)  # array_index.index

        # Check if the array is a parameter or local variable
        Let array_type be memory_get_integer(arr, 0)  # array->type
        If array_type is equal to 1:  # EXPR_VARIABLE
            Let array_variable_name be memory_get_pointer(arr, 8)  # array->data.variable_name
            Let var_index be codegen_find_variable(codegen, array_variable_name)

            If var_index is not equal to 0 minus 1:  # found variable
                Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
                Let var_offset be var_index multiplied by 32
                Let var_ptr be variables plus var_offset
                Let is_parameter be memory_get_integer(var_ptr, 24)  # variable.is_parameter

                If is_parameter is equal to 1:
                    # For array parameters, load the pointer value, not the address
                    Let offset be memory_get_integer(var_ptr, 8)  # variable.stack_offset
                    file_write_fd(output_file, "    movq -")
                    file_write_fd(output_file, integer_to_string(offset))
                    file_write_fd(output_file, "(%rbp), %rbx  # Load array parameter pointer")
                Otherwise:
                    # For local arrays, generate the address
                    codegen_generate_lvalue_address(codegen, arr)
                End If
            Otherwise:
                # For complex expressions, generate the address
                codegen_generate_lvalue_address(codegen, arr)
            End If
        Otherwise:
            # For complex expressions, generate the address
            codegen_generate_lvalue_address(codegen, arr)
        End If

        # Save base address
        emit_line(output_file, "    pushq %rbx")

        # Generate index expression
        codegen_generate_expression(codegen, index)

        # Pop base address
        emit_line(output_file, "    popq %rbx")

        # Calculate element address: base + (index * element_size)
        # For arrays, all elements are currently 8 bytes (Integer size)
        emit_line(output_file, "    imulq $8, %rax")
        emit_line(output_file, "    addq %rax, %rbx")
        Return 0
    End If

    # Invalid lvalue expression type
    print_string("[CODEGEN ERROR] Invalid lvalue expression type")
    exit_with_code(1)
    Return 0
End Process

# Generate code for expression - equivalent to codegen_generate_expression
Process called "codegen_generate_expression" takes codegen as Integer, expr as Integer returns Integer:
    Let expr_type be memory_get_integer(expr, 0)  # expr->type
    Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file

    If expr_type is equal to 0:  # EXPR_INTEGER
        Let integer_value be memory_get_integer(expr, 8)  # expr->data.integer_value
        file_write_fd(output_file, "    movq $")
        file_write_fd(output_file, integer_to_string(integer_value))
        file_write_fd(output_file, ", %rax\n")
        Return 0
    End If

    If expr_type is equal to 1:  # EXPR_VARIABLE
        Let variable_name be memory_get_pointer(expr, 8)  # expr->data.variable_name
        Let var_index be codegen_find_variable(codegen, variable_name)

        If var_index is equal to 0 minus 1:  # -1 for not found
            # Check if this is a global variable
            Let is_global be 0
            Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)

            If current_program is not equal to 0:
                Let global_count be memory_get_integer(current_program, 56)  # program->global_count (PROGRAM_GLOBAL_COUNT)
                Let globals be memory_get_pointer(current_program, 48)       # program->globals (PROGRAM_GLOBAL_VARS)

                Let j be 0
                While j is less than global_count:
                    Let global_offset be j multiplied by 8
                    Let global_ptr be memory_get_pointer(globals, global_offset)
                    Let global_name be memory_get_pointer(global_ptr, 0)  # global->name
                    If string_equals(global_name, variable_name) is equal to 1:
                        Let is_global be 1
                        Let j be global_count  # break loop
                    End If
                    Let j be j plus 1
                End While
            End If

            If is_global is equal to 1:
                # Load global variable value
                file_write_fd(output_file, "    movq ")
                file_write_fd(output_file, variable_name)
                file_write_fd(output_file, "(%rip), %rax  # Load global variable")
            Otherwise:
                # Check if this is a function name being used as a function pointer
                Let is_function be 0
                If current_program is not equal to 0:
                    Let function_count be memory_get_integer(current_program, 16)  # program->function_count
                    Let functions be memory_get_pointer(current_program, 8)        # program->functions

                    Let j be 0
                    While j is less than function_count:
                        Let func_offset be j multiplied by 8
                        Let function_ptr be memory_get_pointer(functions, func_offset)
                        Let function_name be memory_get_pointer(function_ptr, 0)  # function->name
                        If string_equals(function_name, variable_name) is equal to 1:
                            Let is_function be 1
                            Let j be function_count  # break loop
                        End If
                        Let j be j plus 1
                    End While
                End If

                If is_function is equal to 0:
                    print_string("[CODEGEN ERROR] Undefined variable: ")
                    print_string(variable_name)
                    exit_with_code(1)
                End If

                file_write_fd(output_file, "    leaq ")
                file_write_fd(output_file, variable_name)
                file_write_fd(output_file, "(%rip), %rax  # Load function address")
            End If
        Otherwise:
            Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
            Let var_offset be var_index multiplied by 32
            Let var_ptr be variables plus var_offset
            Let offset be memory_get_integer(var_ptr, 8)     # variable.stack_offset
            Let var_type be memory_get_integer(var_ptr, 16)  # variable.type_name

            # Check if this variable is an array type
            Let is_array be 0
            Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)

            If current_program is not equal to 0:
                Let type_count be memory_get_integer(current_program, 32)  # program->type_count
                Let types be memory_get_pointer(current_program, 24)       # program->types

                Let i be 0
                While i is less than type_count:
                    Let type_offset be i multiplied by 8
                    Let type_ptr be memory_get_pointer(types, type_offset)
                    Let type_name_ptr be memory_get_pointer(type_ptr, 0)  # type->name
                    If string_equals(type_name_ptr, var_type) is equal to 1:
                        Let kind be memory_get_integer(type_ptr, 8)  # type->kind
                        If kind is equal to 2:  # TYPE_KIND_ARRAY
                            Let is_array be 1
                        End If
                        Let i be type_count  # break loop
                    End If
                    Let i be i plus 1
                End While
            End If

            If is_array is equal to 1:
                # For arrays, load the address not the value
                file_write_fd(output_file, "    leaq -")
                file_write_fd(output_file, integer_to_string(offset))
                file_write_fd(output_file, "(%rbp), %rax  # Load array address\n")
            Otherwise:
                file_write_fd(output_file, "    movq -")
                file_write_fd(output_file, integer_to_string(offset))
                file_write_fd(output_file, "(%rbp), %rax\n")
            End If
        End If
        Return 0
    End If

    If expr_type is equal to 2:  # EXPR_BINARY_OP
        Let left be memory_get_pointer(expr, 8)      # binary_op.left
        Let right be memory_get_pointer(expr, 16)    # binary_op.right
        Let operator be memory_get_integer(expr, 24) # binary_op.operator


        # Generate left operand (result in %rax)
        codegen_generate_expression(codegen, left)
        # Push left operand to stack
        emit_line(output_file, "    pushq %rax")
        # Generate right operand (result in %rax)
        codegen_generate_expression(codegen, right)
        # Pop left operand from stack to %rbx
        emit_line(output_file, "    popq %rbx")


        If operator is equal to 16:  # TOKEN_PLUS
            emit_line(output_file, "    addq %rbx, %rax")
        End If
        If operator is equal to 17:  # TOKEN_MINUS
            emit_line(output_file, "    subq %rax, %rbx")
            emit_line(output_file, "    movq %rbx, %rax")
        End If
        If operator is equal to 35:  # TOKEN_MULTIPLIED
            emit_line(output_file, "    imulq %rbx, %rax")
        End If
        If operator is equal to 36:  # TOKEN_DIVIDED
            # Division: dividend in %rax, divisor in %rbx
            # Move divisor to %rcx to preserve %rbx
            emit_line(output_file, "    movq %rax, %rcx")  # Save divisor in %rcx
            emit_line(output_file, "    movq %rbx, %rax")  # Move dividend to %rax

            # Check for divide by zero
            emit_line(output_file, "    testq %rcx, %rcx")
            Let label_counter be memory_get_integer(codegen, 28)  # codegen->label_counter (int)
            Let jz_line be string_concat("    jz .Ldiv_by_zero_", integer_to_string(label_counter))
            emit_line(output_file, jz_line)

            # Sign extend %rax to %rdx:%rax
            emit_line(output_file, "    cqto")
            # Divide by %rcx, quotient in %rax, remainder in %rdx
            emit_line(output_file, "    idivq %rcx")
            Let jmp_line be string_concat("    jmp .Ldiv_done_", integer_to_string(label_counter))
            emit_line(output_file, jmp_line)

            # Divide by zero handler
            Let div_zero_label be string_concat(".Ldiv_by_zero_", integer_to_string(label_counter))
            Let div_zero_line be string_concat(div_zero_label, ":")
            emit_line(output_file, div_zero_line)
            emit_line(output_file, "    movq $0, %rax")
            Let div_done_label be string_concat(".Ldiv_done_", integer_to_string(label_counter))
            Let div_done_line be string_concat(div_done_label, ":")
            emit_line(output_file, div_done_line)
            memory_set_integer(codegen, 28, label_counter plus 1)  # codegen->label_counter++ (int)
        End If
        If operator is equal to 37:  # TOKEN_MODULO
            # Modulo: dividend in %rax, divisor in %rbx
            # Move divisor to %rcx to preserve %rbx
            emit_line(output_file, "    movq %rax, %rcx")  # Save divisor in %rcx
            emit_line(output_file, "    movq %rbx, %rax")  # Move dividend to %rax

            # Check for modulo by zero
            emit_line(output_file, "    testq %rcx, %rcx")
            Let label_counter be memory_get_integer(codegen, 28)  # codegen->label_counter (int)
            Let jz_instruction be string_concat("    jz .Lmod_by_zero_", integer_to_string(label_counter))
            emit_line(output_file, jz_instruction)

            # Sign extend %rax to %rdx:%rax
            emit_line(output_file, "    cqto")
            # Divide by %rcx, quotient in %rax, remainder in %rdx
            emit_line(output_file, "    idivq %rcx")
            # Move remainder to %rax
            emit_line(output_file, "    movq %rdx, %rax")
            Let jmp_instruction be string_concat("    jmp .Lmod_done_", integer_to_string(label_counter))
            emit_line(output_file, jmp_instruction)

            # Modulo by zero handler
            Let mod_by_zero_label be string_concat(".Lmod_by_zero_", integer_to_string(label_counter))
            Let mod_by_zero_label_with_colon be string_concat(mod_by_zero_label, ":")
            emit_line(output_file, mod_by_zero_label_with_colon)
            emit_line(output_file, "    movq $0, %rax")
            Let mod_done_label be string_concat(".Lmod_done_", integer_to_string(label_counter))
            Let mod_done_label_with_colon be string_concat(mod_done_label, ":")
            emit_line(output_file, mod_done_label_with_colon)
            memory_set_integer(codegen, 28, label_counter plus 1)  # codegen->label_counter++ (int)
        End If
        If operator is equal to 39:  # TOKEN_BIT_AND
            emit_line(output_file, "    andq %rbx, %rax")
        End If
        If operator is equal to 40:  # TOKEN_BIT_OR
            emit_line(output_file, "    orq %rbx, %rax")
        End If
        If operator is equal to 41:  # TOKEN_BIT_XOR
            emit_line(output_file, "    xorq %rbx, %rax")
        End If
        If operator is equal to 42:  # TOKEN_BIT_SHIFT_LEFT
            # For left shift, we need the shift amount in %rcx (cl register)
            emit_line(output_file, "    movq %rax, %rcx")  # Move shift amount to %rcx
            emit_line(output_file, "    movq %rbx, %rax")  # Move value to be shifted to %rax
            emit_line(output_file, "    salq %cl, %rax")   # Shift left by %cl bits
        End If
        If operator is equal to 43:  # TOKEN_BIT_SHIFT_RIGHT
            # For right shift, we need the shift amount in %rcx (cl register)
            emit_line(output_file, "    movq %rax, %rcx")  # Move shift amount to %rcx
            emit_line(output_file, "    movq %rbx, %rax")  # Move value to be shifted to %rax
            emit_line(output_file, "    sarq %cl, %rax")   # Arithmetic shift right by %cl bits
        End If
        Return 0
    End If

    If expr_type is equal to 3:  # EXPR_COMPARISON
        Let left be memory_get_pointer(expr, 8)           # comparison.left
        Let right be memory_get_pointer(expr, 16)         # comparison.right
        Let comparison_op be memory_get_integer(expr, 24) # comparison.comparison_op

        # Generate left operand (result in %rax)
        codegen_generate_expression(codegen, left)
        # Push left operand to stack
        emit_line(output_file, "    pushq %rax")
        # Generate right operand (result in %rax)
        codegen_generate_expression(codegen, right)
        # Pop left operand from stack to %rbx
        emit_line(output_file, "    popq %rbx")

        # Compare and set result (0 or 1)
        emit_line(output_file, "    cmpq %rax, %rbx")
        If comparison_op is equal to 22:  # TOKEN_EQUAL
            emit_line(output_file, "    sete %al")
        End If
        If comparison_op is equal to 23:  # TOKEN_NOT_EQUAL
            emit_line(output_file, "    setne %al")
        End If
        If comparison_op is equal to 24:  # TOKEN_LESS
            emit_line(output_file, "    setl %al")
        End If
        If comparison_op is equal to 25:  # TOKEN_GREATER
            emit_line(output_file, "    setg %al")
        End If
        If comparison_op is equal to 27:  # TOKEN_LESS_EQUAL
            emit_line(output_file, "    setle %al")
        End If
        If comparison_op is equal to 26:  # TOKEN_GREATER_EQUAL
            emit_line(output_file, "    setge %al")
        End If
        emit_line(output_file, "    movzbq %al, %rax")
        Return 0
    End If

    If expr_type is equal to 4:  # EXPR_FUNCTION_CALL
        Let function_call_ptr be expr plus 8  # &expr->data.function_call
        Let function_name be memory_get_pointer(function_call_ptr, 0)  # function_call.function_name
        Let arguments be memory_get_pointer(function_call_ptr, 8)      # function_call.arguments
        Let arg_count be memory_get_integer(function_call_ptr, 16)     # function_call.argument_count

        # Safety check for function_name
        If function_name is less than 65536:  # Invalid pointer
            exit_with_code(1)
        End If

        # Check if this is a list runtime function
        Let is_list_function be 0
        If string_equals(function_name, "list_create") is equal to 1:
            Let is_list_function be 1
        End If
        If string_equals(function_name, "list_append") is equal to 1:
            Let is_list_function be 1
        End If
        If string_equals(function_name, "list_get") is equal to 1:
            Let is_list_function be 1
        End If
        If string_equals(function_name, "list_get_integer") is equal to 1:
            Let is_list_function be 1
        End If
        If string_equals(function_name, "list_length") is equal to 1:
            Let is_list_function be 1
        End If
        If string_equals(function_name, "list_destroy") is equal to 1:
            Let is_list_function be 1
        End If

        # System V ABI: arguments go in %rdi, %rsi, %rdx, %rcx, %r8, %r9
        Let max_register_args be 6
        Let register_arg_count be arg_count
        If arg_count is greater than max_register_args:
            Let register_arg_count be max_register_args
        End If

        # Evaluate arguments in reverse order and push them to stack to preserve order
        Let i be register_arg_count minus 1
        While i is greater than or equal to 0:
            Let arg_offset be i multiplied by 8
            Let arg_ptr be memory_get_pointer(arguments, arg_offset)
            codegen_generate_expression(codegen, arg_ptr)
            file_write_fd(output_file, "    pushq %rax\n")
            Let i be i minus 1
        End While

        # Pop arguments into correct registers
        # Work around Stage 1 compiler bug: avoid function calls in Otherwise If branches
        Let i be 0
        While i is less than register_arg_count:
            If i is equal to 0:
                file_write_fd(output_file, "    popq %rdi\n")
            End If
            If i is equal to 1:
                file_write_fd(output_file, "    popq %rsi\n")
            End If
            If i is equal to 2:
                file_write_fd(output_file, "    popq %rdx\n")
            End If
            If i is equal to 3:
                file_write_fd(output_file, "    popq %rcx\n")
            End If
            If i is equal to 4:
                file_write_fd(output_file, "    popq %r8\n")
            End If
            If i is equal to 5:
                file_write_fd(output_file, "    popq %r9\n")
            End If
            Let i be i plus 1
        End While

        # Handle arguments beyond 6 (push to stack) - not fully implemented
        If arg_count is greater than max_register_args:
            print_string("[CODEGEN WARNING] Functions with more than 6 arguments not fully supported yet")
        End If

        # Check if this is an indirect call through a function pointer variable
        Let var_index be codegen_find_variable(codegen, function_name)
        If var_index is not equal to 0 minus 1:  # found variable
            # This is a function pointer variable - load it and call indirectly
            Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
            Let var_offset be var_index multiplied by 32
            Let var_ptr be variables plus var_offset
            Let offset be memory_get_integer(var_ptr, 8)  # variable.stack_offset
            file_write_fd(output_file, "    movq -")
            file_write_fd(output_file, integer_to_string(offset))
            file_write_fd(output_file, "(%rbp), %rax  # Load function pointer")
            file_write_fd(output_file, "    call *%rax  # Indirect call")
        Otherwise:
            If is_list_function is equal to 1:
                # For list runtime functions, call the C function directly
                file_write_fd(output_file, "    call ")
                file_write_fd(output_file, function_name)
                file_write_fd(output_file, "@PLT\n")
            Otherwise:
                # For user-defined functions - direct call
                file_write_fd(output_file, "    call ")
                file_write_fd(output_file, function_name)
                file_write_fd(output_file, "\n")
            End If
        End If
        # Result is already in %rax
        Return 0
    End If

    If expr_type is equal to 5:  # EXPR_STRING_LITERAL
        Let string_literal be memory_get_pointer(expr, 8)  # expr->data.string_literal

        # Add string to string literals table if not already present
        Let str_index be 0 minus 1  # -1 for not found
        Let string_count be memory_get_integer(codegen, 40)  # codegen->string_count (int)
        Let strings be memory_get_pointer(codegen, 32)  # codegen->strings (pointer)

        Let i be 0
        While i is less than string_count:
            Let str_offset be i multiplied by 16
            Let str_ptr be strings plus str_offset
            Let existing_value be memory_get_pointer(str_ptr, 0)  # This is a string pointer!
            If string_equals(existing_value, string_literal) is equal to 1:
                Let str_index be i
                Let i be string_count  # break loop
            End If
            Let i be i plus 1
        End While

        If str_index is equal to 0 minus 1:  # not found
            Let str_index be codegen_add_string_literal(codegen, string_literal)
        End If

        # Load address of string literal into %rax
        Let strings be memory_get_pointer(codegen, 32)  # refresh after potential realloc
        Let str_offset be str_index multiplied by 16
        Let str_ptr be strings plus str_offset
        Let label be memory_get_pointer(str_ptr, 8)  # strings[str_index].label
        file_write_fd(output_file, "    leaq ")
        file_write_fd(output_file, label)
        file_write_fd(output_file, "(%rip), %rax\n")
        Return 0
    End If

    If expr_type is equal to 6:  # EXPR_FIELD_ACCESS
        Let field_access_ptr be expr plus 8  # &expr->data.field_access
        Let obj be memory_get_integer(field_access_ptr, 0)     # field_access.object
        Let field_name be memory_get_integer(field_access_ptr, 8)  # field_access.field_name

        # For field access, we need the address of the struct
        Let obj_type be memory_get_integer(obj, 0)  # obj->type

        If obj_type is equal to 1:  # EXPR_VARIABLE
            Let obj_variable_name be memory_get_pointer(obj, 8)  # obj->data.variable_name
            Let var_index be codegen_find_variable(codegen, obj_variable_name)
            If var_index is equal to 0 minus 1:  # -1 for not found
                print_string("[CODEGEN ERROR] Unknown variable '")
                print_string(obj_variable_name)
                print_string("'")
                exit_with_code(1)
            End If

            # Find the field offset based on the variable's type
            Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
            Let var_offset be var_index multiplied by 32
            Let var_ptr be variables plus var_offset
            Let type_name be memory_get_pointer(var_ptr, 16)  # variable.type_name
            Let offset be memory_get_integer(var_ptr, 8)      # variable.stack_offset

            If type_name is equal to 0:
                # Variable is untyped - treat as raw pointer
                # Load the pointer value
                file_write_fd(output_file, "    movq -")
                file_write_fd(output_file, integer_to_string(offset))
                file_write_fd(output_file, "(%rbp), %rax")

                # For raw pointer access, we need to determine field offset
                # Calculate field offset based on struct definition
                Let field_offset be 0

                # Common field patterns from our transliterated code
                # Work around Stage 1 compiler bug: pre-compute string_equals results
                Let is_type be string_equals(field_name, "type")
                Let is_value be string_equals(field_name, "value")
                Let is_line be string_equals(field_name, "line")
                Let is_column be string_equals(field_name, "column")
                Let is_source be string_equals(field_name, "source")
                Let is_position be string_equals(field_name, "position")
                Let is_current_char be string_equals(field_name, "current_char")

                If is_type is equal to 1:
                    Let field_offset be 0
                Otherwise If is_value is equal to 1:
                    Let field_offset be 8
                Otherwise If is_line is equal to 1:
                    Let field_offset be 16
                Otherwise If is_column is equal to 1:
                    Let field_offset be 24
                Otherwise If is_source is equal to 1:
                    Let field_offset be 0
                Otherwise If is_position is equal to 1:
                    Let field_offset be 8
                Otherwise If is_current_char is equal to 1:
                    Let field_offset be 32
                Otherwise:
                    # Default to sequential 8-byte offsets
                    Let field_offset be 0
                End If

                # Load the field value
                file_write_fd(output_file, "    movq ")
                file_write_fd(output_file, integer_to_string(field_offset))
                file_write_fd(output_file, "(%rax), %rax")
            Otherwise:
                If string_equals(type_name, "Integer") is equal to 1:
                    # Variable is Integer type - treat as raw pointer
                    # Load the pointer value
                    file_write_fd(output_file, "    movq -")
                    file_write_fd(output_file, integer_to_string(offset))
                    file_write_fd(output_file, "(%rbp), %rax")

                    # For raw pointer access, use default field offset
                    # Work around Stage 1 compiler bug: pre-compute string_equals results
                    Let is_type2 be string_equals(field_name, "type")
                    Let is_value2 be string_equals(field_name, "value")
                    Let is_line2 be string_equals(field_name, "line")
                    Let is_column2 be string_equals(field_name, "column")

                    Let field_offset be 0
                    If is_type2 is equal to 1:
                        Let field_offset be 0
                    Otherwise If is_value2 is equal to 1:
                        Let field_offset be 8
                    Otherwise If is_line2 is equal to 1:
                        Let field_offset be 16
                    Otherwise If is_column2 is equal to 1:
                        Let field_offset be 24
                    End If

                    # Load the field value
                    file_write_fd(output_file, "    movq ")
                    file_write_fd(output_file, integer_to_string(field_offset))
                    file_write_fd(output_file, "(%rax), %rax")
                Otherwise:
                # Variable has a type - use type information
                # Load the address of the struct
                file_write_fd(output_file, "    leaq -")
                file_write_fd(output_file, integer_to_string(offset))
                file_write_fd(output_file, "(%rbp), %rax")

                Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)
                Let type_count be memory_get_integer(current_program, 32)  # program->type_count
                Let types be memory_get_pointer(current_program, 24)       # program->types
                Let type be 0

                Let i be 0
                While i is less than type_count:
                    Let type_offset be i multiplied by 8
                    Let type_ptr be memory_get_pointer(types, type_offset)
                    Let type_name_ptr be memory_get_pointer(type_ptr, 0)  # type->name
                    If string_equals(type_name_ptr, type_name) is equal to 1:
                        Let type be type_ptr
                        Let i be type_count  # break loop
                    End If
                    Let i be i plus 1
                End While

                If type is equal to 0:
                    print_string("[CODEGEN ERROR] Unknown type '")
                    print_string(type_name)
                    print_string("'")
                    exit_with_code(1)
                End If

                Let field_offset be 0 minus 1  # -1 for not found
                Let kind be memory_get_integer(type, 8)  # type->kind
                If kind is equal to 1:  # TYPE_KIND_STRUCT
                    Let struct_type_ptr be type plus 16  # &type->data.struct_type
                    Let field_count be memory_get_integer(struct_type_ptr, 0)  # struct_type.field_count
                    Let fields be memory_get_pointer(struct_type_ptr, 8)       # struct_type.fields

                    Let i be 0
                    While i is less than field_count:
                        Let field_offset be i multiplied by 24
                        Let field_ptr be fields plus field_offset  # sizeof(FieldDefinition)
                        Let field_name_ptr be memory_get_pointer(field_ptr, 0)  # field.name
                        If string_equals(field_name_ptr, field_name) is equal to 1:
                            Let field_offset be memory_get_integer(field_ptr, 16)  # field.offset
                            Let i be field_count  # break loop
                        End If
                        Let i be i plus 1
                    End While
                End If

                If field_offset is equal to 0 minus 1:  # -1 for not found
                    print_string("[CODEGEN ERROR] Type '")
                    print_string(type_name)
                    print_string("' has no field '")
                    print_string(field_name)
                    print_string("'")
                    exit_with_code(1)
                End If

                # Load the field value
                file_write_fd(output_file, "    movq ")
                file_write_fd(output_file, integer_to_string(field_offset))
                file_write_fd(output_file, "(%rax), %rax")
                End If
            End If
        Otherwise:
            # Handle complex field access expressions (nested access)
            # For nested access, we need the ADDRESS of the intermediate object,
            # not its value. Use the lvalue addressing logic.
            codegen_generate_lvalue_address(codegen, obj)

            # Now %rbx contains the address of the object, copy to %rax
            emit_line(output_file, "    movq %rbx, %rax")
            # Get the type of the object expression
            Let object_type be codegen_get_expression_type(codegen, obj)
            If object_type is equal to 0:
                print_string("[CODEGEN ERROR] Cannot determine type of complex field access object")
                exit_with_code(1)
            End If

            # Find the type definition for the object type
            Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)
            Let type_count be memory_get_integer(current_program, 32)  # program->type_count
            Let types be memory_get_pointer(current_program, 24)       # program->types
            Let type be 0

            Let i be 0
            While i is less than type_count:
                Let type_offset be i multiplied by 8
                Let type_ptr be memory_get_pointer(types, type_offset)
                Let type_name_ptr be memory_get_pointer(type_ptr, 0)  # type->name
                If string_equals(type_name_ptr, object_type) is equal to 1:
                    Let type be type_ptr
                    Let i be type_count  # break loop
                End If
                Let i be i plus 1
            End While

            If type is equal to 0:
                print_string("[CODEGEN ERROR] Unknown type '")
                print_string(object_type)
                print_string("' in complex field access")
                exit_with_code(1)
            End If

            # Find the field offset
            Let field_offset be 0 minus 1  # -1 for not found
            Let kind be memory_get_integer(type, 8)  # type->kind
            If kind is equal to 1:  # TYPE_KIND_STRUCT
                Let struct_type_ptr be type plus 16  # &type->data.struct_type
                Let field_count be memory_get_integer(struct_type_ptr, 0)  # struct_type.field_count
                Let fields be memory_get_pointer(struct_type_ptr, 8)       # struct_type.fields

                Let i be 0
                While i is less than field_count:
                    Let field_offset be i multiplied by 24
                    Let field_ptr be fields plus field_offset  # sizeof(FieldDefinition)
                    Let field_name_ptr be memory_get_pointer(field_ptr, 0)  # field.name
                    If string_equals(field_name_ptr, field_name) is equal to 1:
                        Let field_offset be memory_get_integer(field_ptr, 16)  # field.offset
                        Let i be field_count  # break loop
                    End If
                    Let i be i plus 1
                End While
            End If

            If field_offset is equal to 0 minus 1:  # -1 for not found
                print_string("[CODEGEN ERROR] Type '")
                print_string(object_type)
                print_string("' has no field '")
                print_string(field_name)
                print_string("'")
                exit_with_code(1)
            End If

            # Add the field offset to the address in %rax
            If field_offset is greater than 0:
                file_write_fd(output_file, "    addq $")
                file_write_fd(output_file, integer_to_string(field_offset))
                file_write_fd(output_file, ", %rax")
            End If

            # Load the field value
            emit_line(output_file, "    movq (%rax), %rax")
        End If
        Return 0
    End If

    # Other expression types (TYPE_NAME should cause error, VARIANT_CONSTRUCTOR, FUNCTION_POINTER, ARRAY_INDEX)
    If expr_type is equal to 7:  # EXPR_TYPE_NAME
        # Type names don't generate code directly - they're handled in LET statements
        # This shouldn't be reached in normal execution
        print_string("[CODEGEN ERROR] Type names should only appear in LET statements")
        exit_with_code(1)
        Return 0
    End If

    If expr_type is equal to 8:  # EXPR_BUILTIN_CALL
        Let builtin_call_ptr be expr plus 8  # &expr->data.builtin_call
        Let builtin_type be memory_get_integer(builtin_call_ptr, 0)  # builtin_call.builtin_type
        Let arguments be memory_get_pointer(builtin_call_ptr, 8)     # builtin_call.arguments
        Let arg_count be memory_get_integer(builtin_call_ptr, 16)    # builtin_call.argument_count

        # Map builtin types to function names - split into ranges to avoid deep nesting limits
        Let func_name be ""

        # DEBUG: Print the builtin_type being processed
        print_string("[DEBUG] Processing builtin_type: ")
        print_integer(builtin_type)

        # Range 1: Core functions (54-80)
        print_string("[DEBUG] Entering Range 1 check")

        # Special debug for token 57
        If builtin_type is equal to 57:
            print_string("[DEBUG] SPECIAL: builtin_type == 57 is TRUE!")
        End If

        If builtin_type is equal to 54:  # TOKEN_READ_FILE
            print_string("[DEBUG] Found in Range 1: TOKEN_READ_FILE")
            Let func_name be "runtime_read_file"
        Otherwise If builtin_type is equal to 55:  # TOKEN_WRITE_FILE
            print_string("[DEBUG] Found in Range 1: TOKEN_WRITE_FILE")
            Let func_name be "runtime_write_file"
        End If

        # Separate check for token 57 due to Otherwise If chain issue
        If builtin_type is equal to 57:  # TOKEN_STRING_LENGTH
            print_string("[DEBUG] STANDALONE: Found token 57")
            Let func_name be "string_length"
        End If

        If builtin_type is equal to 58:  # TOKEN_STRING_CHAR_AT
            Let func_name be "string_char_at"
        Otherwise If builtin_type is equal to 59:  # TOKEN_STRING_SUBSTRING
            Let func_name be "string_substring"
        Otherwise If builtin_type is equal to 60:  # TOKEN_STRING_EQUALS
            Let func_name be "string_equals"
        Otherwise If builtin_type is equal to 61:  # TOKEN_ASCII_VALUE_OF
            Let func_name be "ascii_value_of"
        Otherwise If builtin_type is equal to 62:  # TOKEN_IS_DIGIT
            Let func_name be "is_digit"
        Otherwise If builtin_type is equal to 63:  # TOKEN_IS_ALPHA
            Let func_name be "is_alpha"
        Otherwise If builtin_type is equal to 64:  # TOKEN_IS_WHITESPACE
            Let func_name be "is_whitespace"
        Otherwise If builtin_type is equal to 65:  # TOKEN_LIST_CREATE
            Let func_name be "list_create"
        Otherwise If builtin_type is equal to 66:  # TOKEN_LIST_APPEND
            Let func_name be "list_append"
        Otherwise If builtin_type is equal to 67:  # TOKEN_LIST_GET
            Let func_name be "list_get"
        Otherwise If builtin_type is equal to 68:  # TOKEN_LIST_GET_INTEGER
            Let func_name be "list_get_integer"
        Otherwise If builtin_type is equal to 69:  # TOKEN_LIST_LENGTH
            Let func_name be "list_length"
        Otherwise If builtin_type is equal to 70:  # TOKEN_LIST_DESTROY
            Let func_name be "list_destroy"
        Otherwise If builtin_type is equal to 71:  # TOKEN_LIST_SET
            Let func_name be "list_set"
        Otherwise If builtin_type is equal to 72:  # TOKEN_LIST_INSERT
            Let func_name be "list_insert"
        Otherwise If builtin_type is equal to 73:  # TOKEN_LIST_REMOVE
            Let func_name be "list_remove"
        Otherwise If builtin_type is equal to 74:  # TOKEN_LIST_CLEAR
            Let func_name be "list_clear"
        Otherwise If builtin_type is equal to 75:  # TOKEN_LIST_FIND
            Let func_name be "list_find"
        Otherwise If builtin_type is equal to 76:  # TOKEN_LIST_SORT
            Let func_name be "list_sort"
        Otherwise If builtin_type is equal to 77:  # TOKEN_LIST_REVERSE
            Let func_name be "list_reverse"
        Otherwise If builtin_type is equal to 78:  # TOKEN_LIST_COPY
            Let func_name be "list_copy"
        Otherwise If builtin_type is equal to 79:  # TOKEN_LIST_MERGE
            Let func_name be "list_merge"
        Otherwise If builtin_type is equal to 80:  # TOKEN_STRING_CONCAT
            Let func_name be "string_concat"
        End If

        # Range 2: Extended functions (81-110)
        If builtin_type is equal to 81:  # TOKEN_STRING_COMPARE
            Let func_name be "string_compare"
        Otherwise If builtin_type is equal to 82:  # TOKEN_STRING_TO_INTEGER
            Let func_name be "string_to_integer"
        Otherwise If builtin_type is equal to 83:  # TOKEN_INTEGER_TO_STRING
            Let func_name be "integer_to_string"
        Otherwise If builtin_type is equal to 84:  # TOKEN_STRING_FIND
            Let func_name be "string_find"
        Otherwise If builtin_type is equal to 85:  # TOKEN_STRING_REPLACE
            Let func_name be "string_replace"
        Otherwise If builtin_type is equal to 86:  # TOKEN_STRING_TRIM
            Let func_name be "string_trim"
        Otherwise If builtin_type is equal to 87:  # TOKEN_STRING_SPLIT
            Let func_name be "string_split"
        Otherwise If builtin_type is equal to 88:  # TOKEN_FILE_OPEN
            Let func_name be "runtime_file_open"
        Otherwise If builtin_type is equal to 89:  # TOKEN_FILE_CLOSE
            Let func_name be "runtime_file_close"
        Otherwise If builtin_type is equal to 90:  # TOKEN_FILE_READ_LINE
            Let func_name be "runtime_file_read_line"
        Otherwise If builtin_type is equal to 91:  # TOKEN_FILE_WRITE_LINE
            Let func_name be "runtime_file_write_line"
        Otherwise If builtin_type is equal to 92:  # TOKEN_FILE_EXISTS
            Let func_name be "runtime_file_exists"
        Otherwise If builtin_type is equal to 93:  # TOKEN_FILE_DELETE
            Let func_name be "runtime_file_delete"
        Otherwise If builtin_type is equal to 94:  # TOKEN_FILE_SIZE
            Let func_name be "runtime_file_size"
        Otherwise If builtin_type is equal to 95:  # TOKEN_FILE_SEEK
            Let func_name be "runtime_file_seek"
        Otherwise If builtin_type is equal to 96:  # TOKEN_FILE_TELL
            Let func_name be "runtime_file_tell"
        Otherwise If builtin_type is equal to 97:  # TOKEN_FILE_EOF
            Let func_name be "runtime_file_eof"
        Otherwise If builtin_type is equal to 98:  # TOKEN_SIN
            Let func_name be "runtime_sin"
        Otherwise If builtin_type is equal to 99:  # TOKEN_COS
            Let func_name be "runtime_cos"
        Otherwise If builtin_type is equal to 100:  # TOKEN_TAN
            Let func_name be "runtime_tan"
        Otherwise If builtin_type is equal to 101:  # TOKEN_SQRT
            Let func_name be "runtime_sqrt"
        Otherwise If builtin_type is equal to 102:  # TOKEN_POW
            Let func_name be "runtime_pow"
        Otherwise If builtin_type is equal to 103:  # TOKEN_ABS
            Let func_name be "runtime_abs"
        Otherwise If builtin_type is equal to 104:  # TOKEN_FLOOR
            Let func_name be "runtime_floor"
        Otherwise If builtin_type is equal to 105:  # TOKEN_CEIL
            Let func_name be "runtime_ceil"
        Otherwise If builtin_type is equal to 106:  # TOKEN_MIN
            Let func_name be "runtime_min"
        Otherwise If builtin_type is equal to 107:  # TOKEN_MAX
            Let func_name be "runtime_max"
        Otherwise If builtin_type is equal to 108:  # TOKEN_RANDOM
            Let func_name be "runtime_random"
        Otherwise If builtin_type is equal to 109:  # TOKEN_LOG
            Let func_name be "runtime_log"
        Otherwise If builtin_type is equal to 110:  # TOKEN_EXP
            Let func_name be "runtime_exp"
        End If

        # Range 3: System functions (115-131)
        If builtin_type is equal to 115:  # TOKEN_GET_COMMAND_LINE_ARGS
            Let func_name be "get_command_line_args_count"
        Otherwise If builtin_type is equal to 116:  # TOKEN_EXIT_WITH_CODE
            Let func_name be "exit_with_code"
        Otherwise If builtin_type is equal to 117:  # TOKEN_PANIC
            Let func_name be "panic"
        Otherwise If builtin_type is equal to 118:  # TOKEN_ASSERT
            Let func_name be "assert"
        Otherwise If builtin_type is equal to 119:  # TOKEN_ALLOCATE
            Let func_name be "allocate"
        Otherwise If builtin_type is equal to 120:  # TOKEN_DEALLOCATE
            Let func_name be "deallocate"
        End If

        # Range 4: Memory functions (130-131)
        If builtin_type is equal to 130:  # TOKEN_MEMORY_GET_BYTE
            print_string("[DEBUG] Found in Range 4: TOKEN_MEMORY_GET_BYTE")
            Let func_name be "memory_get_byte"
        Otherwise If builtin_type is equal to 131:  # TOKEN_MEMORY_SET_BYTE
            print_string("[DEBUG] Found in Range 4: TOKEN_MEMORY_SET_BYTE")
            Let func_name be "memory_set_byte"
        End If

        # Check if we found a match by testing if func_name is still empty
        # We avoid string_equals to prevent circular dependency
        Let first_char be memory_get_byte(func_name, 0)
        If first_char is equal to 0:  # Empty string (null terminator at start)
            print_string("[CODEGEN ERROR] Unknown built-in function type: ")
            print_integer(builtin_type)
            exit_with_code(1)
        End If

        # Validate argument count for each builtin type - complete validation from C code
        # (Extensive argument validation logic preserved from original...)
        Let expected_args be 0 minus 1  # -1 means variable args
        If builtin_type is equal to 54:  # TOKEN_READ_FILE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 55:  # TOKEN_WRITE_FILE
            Let expected_args be 2
        Otherwise If builtin_type is equal to 57:  # TOKEN_STRING_LENGTH
            Let expected_args be 1
        Otherwise If builtin_type is equal to 58:  # TOKEN_STRING_CHAR_AT
            Let expected_args be 2
        Otherwise If builtin_type is equal to 59:  # TOKEN_STRING_SUBSTRING
            Let expected_args be 3
        Otherwise If builtin_type is equal to 60:  # TOKEN_STRING_EQUALS
            Let expected_args be 2
        Otherwise If builtin_type is equal to 61:  # TOKEN_ASCII_VALUE_OF
            Let expected_args be 1
        Otherwise If builtin_type is equal to 62:  # TOKEN_IS_DIGIT
            Let expected_args be 1
        Otherwise If builtin_type is equal to 63:  # TOKEN_IS_ALPHA
            Let expected_args be 1
        Otherwise If builtin_type is equal to 64:  # TOKEN_IS_WHITESPACE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 65:  # TOKEN_LIST_CREATE
            Let expected_args be 0
        Otherwise If builtin_type is equal to 66:  # TOKEN_LIST_APPEND
            Let expected_args be 2
        Otherwise If builtin_type is equal to 67:  # TOKEN_LIST_GET
            Let expected_args be 2
        Otherwise If builtin_type is equal to 68:  # TOKEN_LIST_GET_INTEGER
            Let expected_args be 2
        Otherwise If builtin_type is equal to 69:  # TOKEN_LIST_LENGTH
            Let expected_args be 1
        Otherwise If builtin_type is equal to 70:  # TOKEN_LIST_DESTROY
            Let expected_args be 1
        Otherwise If builtin_type is equal to 88:  # TOKEN_FILE_OPEN
            Let expected_args be 2
        Otherwise If builtin_type is equal to 89:  # TOKEN_FILE_CLOSE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 90:  # TOKEN_FILE_READ_LINE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 91:  # TOKEN_FILE_WRITE_LINE
            Let expected_args be 2
        Otherwise If builtin_type is equal to 92:  # TOKEN_FILE_EXISTS
            Let expected_args be 1
        Otherwise If builtin_type is equal to 93:  # TOKEN_FILE_DELETE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 94:  # TOKEN_FILE_SIZE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 95:  # TOKEN_FILE_SEEK
            Let expected_args be 3
        Otherwise If builtin_type is equal to 96:  # TOKEN_FILE_TELL
            Let expected_args be 1
        Otherwise If builtin_type is equal to 97:  # TOKEN_FILE_EOF
            Let expected_args be 1
        Otherwise If builtin_type is equal to 98:  # TOKEN_SIN
            Let expected_args be 1
        Otherwise If builtin_type is equal to 99:  # TOKEN_COS
            Let expected_args be 1
        Otherwise If builtin_type is equal to 100:  # TOKEN_TAN
            Let expected_args be 1
        Otherwise If builtin_type is equal to 101:  # TOKEN_SQRT
            Let expected_args be 1
        Otherwise If builtin_type is equal to 102:  # TOKEN_POW
            Let expected_args be 2
        Otherwise If builtin_type is equal to 103:  # TOKEN_ABS
            Let expected_args be 1
        Otherwise If builtin_type is equal to 104:  # TOKEN_FLOOR
            Let expected_args be 1
        Otherwise If builtin_type is equal to 105:  # TOKEN_CEIL
            Let expected_args be 1
        Otherwise If builtin_type is equal to 106:  # TOKEN_MIN
            Let expected_args be 2
        Otherwise If builtin_type is equal to 107:  # TOKEN_MAX
            Let expected_args be 2
        Otherwise If builtin_type is equal to 108:  # TOKEN_RANDOM
            Let expected_args be 0
        Otherwise If builtin_type is equal to 109:  # TOKEN_LOG
            Let expected_args be 1
        Otherwise If builtin_type is equal to 110:  # TOKEN_EXP
            Let expected_args be 1
        Otherwise If builtin_type is equal to 115:  # TOKEN_GET_COMMAND_LINE_ARGS
            Let expected_args be 0
        Otherwise If builtin_type is equal to 116:  # TOKEN_EXIT_WITH_CODE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 117:  # TOKEN_PANIC
            Let expected_args be 1
        Otherwise If builtin_type is equal to 118:  # TOKEN_ASSERT
            Let expected_args be 2
        Otherwise If builtin_type is equal to 119:  # TOKEN_ALLOCATE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 120:  # TOKEN_DEALLOCATE
            Let expected_args be 1
        End If

        # Range 4 argument validation: Memory functions (130-131)
        If builtin_type is equal to 130:  # TOKEN_MEMORY_GET_BYTE
            Let expected_args be 2
        Otherwise If builtin_type is equal to 131:  # TOKEN_MEMORY_SET_BYTE
            Let expected_args be 3
        End If

        If expected_args is not equal to 0 minus 1:  # not variable args
            If arg_count is not equal to expected_args:
                print_string("[CODEGEN ERROR] ")
                print_string(func_name)
                print_string(" expects ")
                print_string(integer_to_string(expected_args))
                print_string(" arguments, got ")
                print_string(integer_to_string(arg_count))
                exit_with_code(1)
            End If
        End If

        # Evaluate arguments in reverse order and push them to stack
        Let i be arg_count minus 1
        While i is greater than or equal to 0:
            Let arg_offset be i multiplied by 8
            Let arg_ptr be memory_get_pointer(arguments, arg_offset)
            codegen_generate_expression(codegen, arg_ptr)
            file_write_fd(output_file, "    pushq %rax\n")
            Let i be i minus 1
        End While

        # Pop arguments into correct registers
        # Work around Stage 1 compiler bug: avoid function calls in Otherwise If branches
        Let i be 0
        While i is less than arg_count:
            If i is equal to 0:
                file_write_fd(output_file, "    popq %rdi\n")
            End If
            If i is equal to 1:
                file_write_fd(output_file, "    popq %rsi\n")
            End If
            If i is equal to 2:
                file_write_fd(output_file, "    popq %rdx\n")
            End If
            If i is equal to 3:
                file_write_fd(output_file, "    popq %rcx\n")
            End If
            If i is equal to 4:
                file_write_fd(output_file, "    popq %r8\n")
            End If
            If i is equal to 5:
                file_write_fd(output_file, "    popq %r9\n")
            End If
            Let i be i plus 1
        End While

        # Call the runtime function
        file_write_fd(output_file, "    call ")
        file_write_fd(output_file, func_name)
        file_write_fd(output_file, "@PLT\n")
        # Result is in %rax
        Return 0
    End If

    Return 0
End Process

Process called "main" takes argc as Integer, argv as Integer returns Integer:
    Return 0
End Process
