# String Utilities for Runa v0.0.7.5 Bootstrap Compiler
# Refactored to work within v0.0.7.3 compiler limitations
# - No Character type (use Integer for ASCII values)
# - No complex boolean expressions in While loops
# - No function calls in conditions

# ==== Basic String Functions ====

Process called "string_length" takes str as Integer returns Integer:
    If str is equal to 0:
        Return 0
    End If
    Let len be 0
    Let continue_loop be 1
    While continue_loop is equal to 1:
        Let char be memory_get_byte(str, len)
        If char is equal to 0:
            Set continue_loop to 0
        Otherwise:
            Set len to len plus 1
        End If
    End While
    Return len
End Process

Process called "string_char_at" takes str as Integer, index as Integer returns Integer:
    If str is equal to 0:
        Return 0
    End If
    Let char be memory_get_byte(str, index)
    Return char
End Process

Process called "string_equals" takes str1 as Integer, str2 as Integer returns Integer:
    If str1 is equal to 0:
        If str2 is equal to 0:
            Return 1
        End If
        Return 0
    End If
    If str2 is equal to 0:
        Return 0
    End If

    Let i be 0
    Let continue_loop be 1
    While continue_loop is equal to 1:
        Let char1 be memory_get_byte(str1, i)
        Let char2 be memory_get_byte(str2, i)
        If char1 is not equal to char2:
            Return 0
        End If
        If char1 is equal to 0:
            Set continue_loop to 0
        Otherwise:
            Set i to i plus 1
        End If
    End While
    Return 1
End Process

Process called "is_digit" takes char as Integer returns Integer:
    Let zero be 48  # ASCII '0'
    Let nine be 57  # ASCII '9'
    If char is greater than or equal to zero:
        If char is less than or equal to nine:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "is_alpha" takes char as Integer returns Integer:
    Let upper_a be 65  # ASCII 'A'
    Let upper_z be 90  # ASCII 'Z'
    Let lower_a be 97  # ASCII 'a'
    Let lower_z be 122 # ASCII 'z'

    If char is greater than or equal to upper_a:
        If char is less than or equal to upper_z:
            Return 1
        End If
    End If

    If char is greater than or equal to lower_a:
        If char is less than or equal to lower_z:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "is_whitespace" takes char as Integer returns Integer:
    Let space be 32     # ASCII space
    Let tab be 9        # ASCII tab
    Let newline be 10   # ASCII newline
    Let cr be 13        # ASCII carriage return

    If char is equal to space:
        Return 1
    End If
    If char is equal to tab:
        Return 1
    End If
    If char is equal to newline:
        Return 1
    End If
    If char is equal to cr:
        Return 1
    End If
    Return 0
End Process

Process called "integer_to_string" takes value as Integer returns Integer:
    # Handle special case of 0
    If value is equal to 0:
        Let str be memory_allocate(2)
        memory_set_byte(str, 0, 48)  # ASCII '0'
        memory_set_byte(str, 1, 0)   # null terminator
        Return str
    End If

    # Handle negative numbers
    Let is_negative be 0
    Let num be value
    If value is less than 0:
        Set is_negative to 1
        Set num to 0 minus value
    End If

    # Count digits
    Let digit_count be 0
    Let temp be num
    While temp is greater than 0:
        Set digit_count to digit_count plus 1
        Set temp to temp divided by 10
    End While

    # Allocate string (digits + sign + null)
    Let size be digit_count plus 1
    If is_negative is equal to 1:
        Set size to size plus 1
    End If
    Let str be memory_allocate(size)

    # Fill from the end
    Let pos be digit_count
    If is_negative is equal to 1:
        Set pos to pos plus 1
    End If
    memory_set_byte(str, pos, 0)  # null terminator

    # Add digits from right to left
    Set temp to num
    Set pos to digit_count minus 1
    If is_negative is equal to 1:
        Set pos to pos plus 1
    End If

    While temp is greater than 0:
        Let digit be temp modulo by 10
        Let ascii_digit be digit plus 48  # Convert to ASCII
        memory_set_byte(str, pos, ascii_digit)
        Set pos to pos minus 1
        Set temp to temp divided by 10
    End While

    # Add minus sign if negative
    If is_negative is equal to 1:
        memory_set_byte(str, 0, 45)  # ASCII '-'
    End If

    Return str
End Process

# memory_get_byte and memory_set_byte are provided as externs from runtime

Process called "bit_not" takes value as Integer returns Integer:
    # Bitwise NOT operation
    Let neg_one be 0 minus 1  # All bits set
    Let result be value bit_xor neg_one
    Return result
End Process

# memory_set_pointer and memory_get_pointer are provided by runtime

Process called "system_write" takes fd as Integer, buffer as Integer, count as Integer returns Integer:
    # System call for write (syscall number 1)
    Let syscall_write be 1
    Let result be system_call(syscall_write, fd, buffer, count)
    Return result
End Process

Process called "string_to_integer" takes str as Integer returns Integer:
    # Convert string to integer
    If str is equal to 0:
        Return 0
    End If

    Let result be 0
    Let i be 0
    Let is_negative be 0

    # Check for negative sign
    Let first_char be memory_get_byte(str, 0)
    Let minus_char be 45  # ASCII '-'
    If first_char is equal to minus_char:
        Set is_negative to 1
        Set i to 1
    End If

    # Parse digits
    Let continue_loop be 1
    While continue_loop is equal to 1:
        Let char be memory_get_byte(str, i)
        If char is equal to 0:
            Set continue_loop to 0
        Otherwise:
            Let is_dig be is_digit(char)
            If is_dig is equal to 1:
                Set result to result multiplied by 10
                Let zero_char be 48  # ASCII '0'
                Let digit be char minus zero_char
                Set result to result plus digit
                Set i to i plus 1
            Otherwise:
                Set continue_loop to 0
            End If
        End If
    End While

    If is_negative is equal to 1:
        Set result to 0 minus result
    End If

    Return result
End Process

Process called "memory_reallocate" takes ptr as Integer, new_size as Integer returns Integer:
    # Wrapper for runtime reallocate function
    Return reallocate(ptr, new_size)
End Process

# ==== Type Definitions ====

Type called "StringBuilder":
    buffer as Integer,      # Pointer to char buffer
    capacity as Integer,
    length as Integer
End Type

Type called "StringTokenizer":
    string as Integer,      # Pointer to string
    current as Integer,     # Current position pointer
    delimiters as Integer,  # Pointer to delimiters string
    own_string as Integer   # Boolean flag
End Type

Type called "StringArray":
    strings as Integer,     # Pointer to string arr
    count as Integer,
    capacity as Integer
End Type

# ==== String Builder Implementation ====

Process called "string_builder_create" returns Integer:
    Return string_builder_create_with_capacity(256)
End Process

Process called "string_builder_create_with_capacity" takes initial_capacity as Integer returns Integer:
    Let sb be allocate(24)  # sizeof(StringBuilder) = 3 * 8 bytes
    If sb is equal to 0:
        Return 0
    End If

    Let buffer be allocate(initial_capacity)
    If buffer is equal to 0:
        deallocate(sb)
        Return 0
    End If

    # Initialize buffer with null terminator
    memory_set_byte(buffer, 0, 0)

    # Set StringBuilder fields
    memory_set_pointer(sb, 0, buffer)           # sb->buffer = buffer
    memory_set_integer(sb, 8, initial_capacity)  # sb->capacity = initial_capacity
    memory_set_integer(sb, 16, 0)               # sb->length = 0

    Return sb
End Process

Process called "string_builder_destroy" takes sb as Integer returns Integer:
    If sb is not equal to 0:
        Let buffer be memory_get_pointer(sb, 0)
        deallocate(buffer)
        deallocate(sb)
    End If
    Return 0
End Process

Process called "string_builder_ensure_capacity" takes sb as Integer, needed as Integer returns Integer:
    Let current_length be memory_get_integer(sb, 16)
    Let current_capacity be memory_get_integer(sb, 8)
    Let total_needed be current_length plus needed

    If total_needed is greater than or equal to current_capacity:
        Let new_capacity be current_capacity multiplied by 2

        # Keep doubling capacity until it's large enough
        Let capacity_ok be 0
        While capacity_ok is equal to 0:
            If new_capacity is greater than total_needed:
                Set capacity_ok to 1
            Otherwise:
                Set new_capacity to new_capacity multiplied by 2
            End If
        End While

        Let old_buffer be memory_get_pointer(sb, 0)
        Let new_buffer be reallocate(old_buffer, new_capacity)
        If new_buffer is equal to 0:
            Return 0  # false
        End If

        memory_set_pointer(sb, 0, new_buffer)
        memory_set_integer(sb, 8, new_capacity)
    End If
    Return 1  # true
End Process

Process called "string_builder_append" takes sb as Integer, str as String returns Integer:
    If sb is equal to 0:
        Return 0  # false
    End If

    Let len be string_length(str)
    If len is equal to 0:
        Return 1  # true - empty string append succeeds
    End If

    Let ensure_result be string_builder_ensure_capacity(sb, len)
    If ensure_result is equal to 0:
        Return 0  # false
    End If

    Let buffer be memory_get_pointer(sb, 0)
    Let current_length be memory_get_integer(sb, 16)

    # Copy string to buffer at current position
    memory_copy_string(buffer, current_length, str)

    # Update length
    memory_set_integer(sb, 16, current_length plus len)

    Return 1  # true
End Process

Process called "string_builder_append_char" takes sb as Integer, c as Integer returns Integer:
    # c is ASCII value instead of Character
    If sb is equal to 0:
        Return 0  # false
    End If

    Let ensure_result be string_builder_ensure_capacity(sb, 1)
    If ensure_result is equal to 0:
        Return 0  # false
    End If

    Let buffer be memory_get_pointer(sb, 0)
    Let current_length be memory_get_integer(sb, 16)

    # Set character at current position
    memory_set_byte(buffer, current_length, c)
    Set current_length to current_length plus 1

    # Add null terminator
    memory_set_byte(buffer, current_length, 0)

    # Update length
    memory_set_integer(sb, 16, current_length)

    Return 1  # true
End Process

Process called "string_builder_append_int" takes sb as Integer, value as Integer returns Integer:
    Let buffer_str be integer_to_string(value)
    Return string_builder_append(sb, buffer_str)
End Process

Process called "string_builder_to_string" takes sb as Integer returns String:
    If sb is equal to 0:
        Return ""
    End If

    Let result_buffer be memory_get_pointer(sb, 0)
    Let result_str be memory_pointer_to_string(result_buffer)

    # Reset StringBuilder to empty state
    Let new_buffer be allocate(1)
    memory_set_byte(new_buffer, 0, 0)
    memory_set_pointer(sb, 0, new_buffer)
    memory_set_integer(sb, 8, 1)
    memory_set_integer(sb, 16, 0)

    Return result_str
End Process

Process called "string_builder_get_string" takes sb as Integer returns String:
    If sb is equal to 0:
        Return ""
    End If
    Let buffer be memory_get_pointer(sb, 0)
    Return memory_pointer_to_string(buffer)
End Process

Process called "string_builder_length" takes sb as Integer returns Integer:
    If sb is equal to 0:
        Return 0
    End If
    Return memory_get_integer(sb, 16)
End Process

Process called "string_builder_clear" takes sb as Integer returns Integer:
    If sb is not equal to 0:
        Let buffer be memory_get_pointer(sb, 0)
        memory_set_byte(buffer, 0, 0)
        memory_set_integer(sb, 16, 0)
    End If
    Return 0
End Process

# ==== String Tokenizer Implementation ====

Process called "string_tokenizer_create" takes str as String, delimiters as String returns Integer:
    If string_length(str) is equal to 0:
        Return 0
    End If
    If string_length(delimiters) is equal to 0:
        Return 0
    End If

    Let tokenizer be allocate(32)  # sizeof(StringTokenizer)
    If tokenizer is equal to 0:
        Return 0
    End If

    Let str_copy be string_duplicate(str)
    If str_copy is equal to 0:
        deallocate(tokenizer)
        Return 0
    End If

    memory_set_pointer(tokenizer, 0, str_copy)
    memory_set_pointer(tokenizer, 8, str_copy)

    # Store delimiters as a duplicated string pointer
    Let delim_copy be string_duplicate(delimiters)
    memory_set_pointer(tokenizer, 16, delim_copy)
    memory_set_integer(tokenizer, 24, 1)

    Return tokenizer
End Process

Process called "string_tokenizer_next" takes tokenizer as Integer returns String:
    If tokenizer is equal to 0:
        Return ""
    End If

    Let current_ptr be memory_get_pointer(tokenizer, 8)
    If current_ptr is equal to 0:
        Return ""
    End If

    Let delimiters_ptr be memory_get_pointer(tokenizer, 16)
    Let delimiters be memory_pointer_to_string(delimiters_ptr)

    # Skip leading delimiters
    Let offset be 0
    Let continue_skip be 1
    While continue_skip is equal to 1:
        Let current_char be memory_get_byte(current_ptr, offset)
        If current_char is equal to 0:
            Set continue_skip to 0
        Otherwise:
            Let is_delim be string_contains_char_value(delimiters, current_char)
            If is_delim is equal to 0:
                Set continue_skip to 0
            Otherwise:
                Set offset to offset plus 1
            End If
        End If
    End While

    # Check if we reached end of string
    Let current_char be memory_get_byte(current_ptr, offset)
    If current_char is equal to 0:
        memory_set_pointer(tokenizer, 8, 0)
        Return ""
    End If

    Let token_start_offset be offset

    # Find next delimiter
    Let continue_scan be 1
    While continue_scan is equal to 1:
        Let current_char be memory_get_byte(current_ptr, offset)
        If current_char is equal to 0:
            Set continue_scan to 0
        Otherwise:
            Let is_delim be string_contains_char_value(delimiters, current_char)
            If is_delim is equal to 1:
                Set continue_scan to 0
            Otherwise:
                Set offset to offset plus 1
            End If
        End If
    End While

    # Extract token
    Let token_length be offset minus token_start_offset
    Let token be memory_get_substring(current_ptr, token_start_offset, token_length)

    # Update current position
    Let current_char be memory_get_byte(current_ptr, offset)
    If current_char is not equal to 0:
        memory_set_byte(current_ptr, offset, 0)
        Let new_current be memory_pointer_offset(current_ptr, offset plus 1)
        memory_set_pointer(tokenizer, 8, new_current)
    Otherwise:
        memory_set_pointer(tokenizer, 8, 0)
    End If

    Return token
End Process

Process called "string_tokenizer_has_next" takes tokenizer as Integer returns Integer:
    If tokenizer is equal to 0:
        Return 0
    End If

    Let current_ptr be memory_get_pointer(tokenizer, 8)
    If current_ptr is equal to 0:
        Return 0
    End If

    Let delimiters_ptr be memory_get_pointer(tokenizer, 16)
    Let delimiters be memory_pointer_to_string(delimiters_ptr)

    # Skip delimiters to check if there's a token
    Let offset be 0
    Let continue_check be 1
    While continue_check is equal to 1:
        Let temp_char be memory_get_byte(current_ptr, offset)
        If temp_char is equal to 0:
            Set continue_check to 0
        Otherwise:
            Let is_delim be string_contains_char_value(delimiters, temp_char)
            If is_delim is equal to 0:
                Set continue_check to 0
            Otherwise:
                Set offset to offset plus 1
            End If
        End If
    End While

    Let temp_char be memory_get_byte(current_ptr, offset)
    If temp_char is equal to 0:
        Return 0
    Otherwise:
        Return 1
    End If
End Process

Process called "string_tokenizer_destroy" takes tokenizer as Integer returns Integer:
    If tokenizer is not equal to 0:
        Let own_string be memory_get_integer(tokenizer, 24)
        If own_string is equal to 1:
            Let string_ptr be memory_get_pointer(tokenizer, 0)
            deallocate(string_ptr)
            Let delimiters_ptr be memory_get_pointer(tokenizer, 16)
            deallocate(delimiters_ptr)
        End If
        deallocate(tokenizer)
    End If
    Return 0
End Process

# ==== String Array Implementation ====

Process called "string_array_create" returns Integer:
    Let arr be allocate(24)  # sizeof(StringArray)
    If arr is equal to 0:
        Return 0
    End If

    Let initial_capacity be 8
    Let strings_ptr be allocate(initial_capacity multiplied by 8)
    If strings_ptr is equal to 0:
        deallocate(arr)
        Return 0
    End If

    memory_set_pointer(arr, 0, strings_ptr)
    memory_set_integer(arr, 8, 0)
    memory_set_integer(arr, 16, initial_capacity)

    Return arr
End Process

Process called "string_array_add" takes arr as Integer, str as String returns Integer:
    If arr is equal to 0:
        Return 0
    End If

    Let count be memory_get_integer(arr, 8)
    Let capacity be memory_get_integer(arr, 16)

    # Resize if needed
    If count is greater than or equal to capacity:
        Let new_capacity be capacity multiplied by 2
        Let old_strings be memory_get_pointer(arr, 0)
        Let new_strings be reallocate(old_strings, new_capacity multiplied by 8)
        If new_strings is equal to 0:
            Return 0
        End If
        memory_set_pointer(arr, 0, new_strings)
        memory_set_integer(arr, 16, new_capacity)
    End If

    # Add string
    Let strings_ptr be memory_get_pointer(arr, 0)
    Let str_copy be string_duplicate(str)
    Let offset be count multiplied by 8
    memory_set_pointer(strings_ptr, offset, str_copy)

    # Update count
    memory_set_integer(arr, 8, count plus 1)

    Return 1
End Process

Process called "string_array_destroy" takes arr as Integer returns Integer:
    If arr is not equal to 0:
        Let count be memory_get_integer(arr, 8)
        Let strings_ptr be memory_get_pointer(arr, 0)

        # Free all strings
        Let i be 0
        While i is less than count:
            Let offset be i multiplied by 8
            Let str_ptr be memory_get_pointer(strings_ptr, offset)
            deallocate(str_ptr)
            Set i to i plus 1
        End While

        deallocate(strings_ptr)
        deallocate(arr)
    End If
    Return 0
End Process

# ==== Basic String Utilities ====

Process called "string_duplicate" takes str as String returns Integer:
    Let len be string_length(str)
    Let result be allocate(len plus 1)
    If result is equal to 0:
        Return 0
    End If

    memory_copy_string_to_buffer(result, str)
    Return result
End Process

Process called "string_starts_with" takes str as String, prefix as String returns Integer:
    Let str_len be string_length(str)
    Let prefix_len be string_length(prefix)

    If prefix_len is greater than str_len:
        Return 0
    End If

    Let str_prefix be string_substring(str, 0, prefix_len)
    If string_equals(str_prefix, prefix):
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Process called "string_ends_with" takes str as String, suffix as String returns Integer:
    Let str_len be string_length(str)
    Let suffix_len be string_length(suffix)

    If suffix_len is greater than str_len:
        Return 0
    End If

    Let start_pos be str_len minus suffix_len
    Let str_suffix be string_substring(str, start_pos, suffix_len)
    If string_equals(str_suffix, suffix):
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Process called "string_contains" takes str as String, substring as String returns Integer:
    Let pos be string_find(str, substring)
    Let not_found be 0 minus 1
    If pos is equal to not_found:
        Return 0
    Otherwise:
        Return 1
    End If
End Process

Process called "string_is_empty" takes str as String returns Integer:
    If string_length(str) is equal to 0:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Process called "string_is_whitespace" takes str as String returns Integer:
    Let len be string_length(str)
    If len is equal to 0:
        Return 1
    End If

    Let i be 0
    While i is less than len:
        Let ch be string_char_at(str, i)
        Let ch_value be ascii_value_of(ch)
        # Check for space (32), tab (9), newline (10), carriage return (13)
        Let is_ws be 0
        If ch_value is equal to 32:
            Set is_ws to 1
        End If
        If ch_value is equal to 9:
            Set is_ws to 1
        End If
        If ch_value is equal to 10:
            Set is_ws to 1
        End If
        If ch_value is equal to 13:
            Set is_ws to 1
        End If

        If is_ws is equal to 0:
            Return 0  # Found non-whitespace
        End If
        Set i to i plus 1
    End While

    Return 1  # All whitespace
End Process

Process called "string_is_numeric" takes str as String returns Integer:
    Let len be string_length(str)
    If len is equal to 0:
        Return 0
    End If

    Let i be 0
    # Check for optional leading minus
    Let ch be string_char_at(str, 0)
    Let ch_value be ascii_value_of(ch)
    If ch_value is equal to 45:  # '-'
        Set i to 1
        If len is equal to 1:
            Return 0  # Just "-" is not numeric
        End If
    End If

    While i is less than len:
        Set ch to string_char_at(str, i)
        Let is_d be is_digit(ch)
        If is_d is equal to 0:
            Return 0
        End If
        Set i to i plus 1
    End While

    Return 1
End Process

# ==== Helper Functions ====

Process called "string_contains_char_value" takes str as String, char_value as Integer returns Integer:
    Let len be string_length(str)
    Let i be 0
    While i is less than len:
        Let ch be string_char_at(str, i)
        Let ch_val be ascii_value_of(ch)
        If ch_val is equal to char_value:
            Return 1
        End If
        Set i to i plus 1
    End While
    Return 0
End Process

Process called "string_util_split" takes str as String, delimiter as String returns Integer:
    Let arr be string_array_create()
    If arr is equal to 0:
        Return 0
    End If

    Let tokenizer be string_tokenizer_create(str, delimiter)
    If tokenizer is equal to 0:
        string_array_destroy(arr)
        Return 0
    End If

    Let has_more be string_tokenizer_has_next(tokenizer)
    While has_more is equal to 1:
        Let token be string_tokenizer_next(tokenizer)
        string_array_add(arr, token)
        Set has_more to string_tokenizer_has_next(tokenizer)
    End While

    string_tokenizer_destroy(tokenizer)
    Return arr
End Process

# ==== Memory Helper Functions ====
# Memory functions are implemented above (lines 177-201) or provided by runtime

Process called "memory_copy_string" takes ptr as Integer, offset as Integer, str as String returns Integer:
    # Copy string to ptr + offset
    Let dest be ptr plus offset
    Let src be str  # String is already a pointer
    Let i be 0
    Let continue_loop be 1

    While continue_loop is equal to 1:
        Let char be memory_get_byte(src, i)
        memory_set_byte(dest, i, char)
        If char is equal to 0:
            Set continue_loop to 0
        Otherwise:
            Set i to i plus 1
        End If
    End While

    Return i  # Return number of bytes copied (excluding null)
End Process

Process called "memory_copy_string_to_buffer" takes ptr as Integer, str as String returns Integer:
    # Copy string to buffer at ptr, return bytes copied
    Let src be str  # String is already a pointer
    Let i be 0
    Let continue_loop be 1

    While continue_loop is equal to 1:
        Let char be memory_get_byte(src, i)
        memory_set_byte(ptr, i, char)
        If char is equal to 0:
            Set continue_loop to 0
        Otherwise:
            Set i to i plus 1
        End If
    End While

    Return i  # Return number of bytes copied (excluding null)
End Process

Process called "memory_pointer_offset" takes ptr as Integer, offset as Integer returns Integer:
    # Runtime function to calculate ptr + offset
    Return ptr plus offset
End Process

# Additional helper functions needed by string_utils

Process called "memory_allocate" takes size as Integer returns Integer:
    # Wrapper for runtime allocate function
    Return allocate(size)
End Process

# system_call, memory_pointer_to_string, memory_get_substring are provided by runtime

# memory_set_pointer_at_index and memory_get_pointer_at_index removed - not needed

# reallocate is provided by the runtime (runtime_system.c)
# It properly copies old data to the new location