# Parser for Runa v0.0.7.5
# Line-by-line transliteration from v0.0.7.3 parser.c

# Offsets for program structure (based on C struct layout)
Let PROGRAM_FUNCTIONS be 0      # Function **functions
Let PROGRAM_FUNCTION_COUNT be 8 # int function_count
Let PROGRAM_FUNCTION_CAPACITY be 12 # int function_capacity
Let PROGRAM_TYPES be 16         # TypeDefinition **types
Let PROGRAM_TYPE_COUNT be 24    # int type_count
Let PROGRAM_TYPE_CAPACITY be 28 # int type_capacity
Let PROGRAM_IMPORTS be 32       # Import **imports
Let PROGRAM_IMPORT_COUNT be 40  # int import_count
Let PROGRAM_IMPORT_CAPACITY be 44 # int import_capacity
Let PROGRAM_GLOBAL_VARS be 48   # GlobalVariable **globals
Let PROGRAM_GLOBAL_COUNT be 56  # int global_count
Let PROGRAM_GLOBAL_CAPACITY be 60 # int global_capacity

# Parser parse expression - entry point for expression parsing with PEMDAS precedence
Process called "parser_parse_expression" takes parser as Integer returns Integer:
    Return parser_parse_comparison_level(parser)
End Process

# Parse comparison expressions (==, !=, <, >, etc.)
Process called "parser_parse_comparison_level" takes parser as Integer returns Integer:
    Return parser_parse_comparison(parser)
End Process

# Parse additive expressions (+ and -)
Process called "parser_parse_additive" takes parser as Integer returns Integer:
    Let left be parser_parse_multiplicative(parser)

    Let loop_additive be 1
    While loop_additive is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 16:  # TOKEN_PLUS
            Let operator be token_type
            parser_eat(parser, 16)
            Let right be parser_parse_multiplicative(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise If token_type is equal to 17:  # TOKEN_MINUS
            Let operator be token_type
            parser_eat(parser, 17)
            Let right be parser_parse_multiplicative(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise:
            Set loop_additive to 0
        End If
    End While

    Return left
End Process

# Parse multiplicative expressions (*, /, %)
Process called "parser_parse_multiplicative" takes parser as Integer returns Integer:
    Let left be parser_parse_primary_with_postfix(parser)

    Let loop_multiplicative be 1
    While loop_multiplicative is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 35:  # TOKEN_MULTIPLIED
            Let operator be token_type
            parser_eat(parser, 35)
            parser_eat(parser, 38)
            Let right be parser_parse_primary_with_postfix(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise If token_type is equal to 36:  # TOKEN_DIVIDED
            Let operator be token_type
            parser_eat(parser, 36)
            parser_eat(parser, 38)
            Let right be parser_parse_primary_with_postfix(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise If token_type is equal to 37:  # TOKEN_MODULO
            Let operator be token_type
            parser_eat(parser, 37)
            parser_eat(parser, 38)
            Let right be parser_parse_primary_with_postfix(parser)
            Set left to expression_create_binary_op(left, operator, right)
        Otherwise:
            Set loop_multiplicative to 0
        End If
    End While

    Return left
End Process

# Parse primary expressions with postfix operators (function calls, field access, array indexing)
Process called "parser_parse_primary_with_postfix" takes parser as Integer returns Integer:
    Let left be parser_parse_primary(parser)

    # Check for function call (if primary was an identifier and followed by '(')
    Let current_token_fc be memory_get_pointer(parser, 8)
    Let token_type_fc be memory_get_integer(current_token_fc, 0)
    If token_type_fc is equal to 48:  # TOKEN_LPAREN (48)
        # Convert variable expression to function call
        Let expr_type be memory_get_integer(left, 0)
        If expr_type is equal to EXPR_VARIABLE:
            # Get the variable name from the EXPR_VARIABLE
            Let var_name be memory_get_pointer(left, 8)

            # Parse function arguments
            parser_eat(parser, 48)

            # Allocate space for arguments
            Let arguments be 0
            Let argument_count be 0
            Let argument_capacity be 4
            Let arg_ptr_size be 8
            Let arg_size be argument_capacity multiplied by arg_ptr_size
            Set arguments to memory_allocate(arg_size)

            # Parse arguments until we hit ')'
            Let continue_args be 1
            While continue_args is equal to 1:
                Let current_token_arg be memory_get_pointer(parser, 8)
                Let token_type_arg be memory_get_integer(current_token_arg, 0)

                If token_type_arg is equal to 49:  # TOKEN_RPAREN (49)
                    Set continue_args to 0
                Otherwise:
                    # Parse the argument expression
                    Let arg_expr be parser_parse_additive(parser)

                    # Store argument
                    Let arg_offset be argument_count multiplied by arg_ptr_size
                    Let arg_ptr be arguments plus arg_offset
                    memory_set_pointer(arg_ptr, 0, arg_expr)
                    Set argument_count to argument_count plus 1

                    # Check for comma
                    Let current_token_comma be memory_get_pointer(parser, 8)
                    Let token_type_comma be memory_get_integer(current_token_comma, 0)
                    If token_type_comma is equal to 52:  # TOKEN_COMMA (52)
                        parser_eat(parser, 52)
                    End If
                End If
            End While

            parser_eat(parser, 49)

            # Create function call expression
            Let func_call be expression_create_function_call(var_name, arguments, argument_count)
            deallocate(left)  # Free the old EXPR_VARIABLE
            Set left to func_call
        End If
    End If

    # Handle field access and array indexing (highest precedence)
    Let loop_field be 1
    While loop_field is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 51:  # TOKEN_DOT
            parser_eat(parser, 51)

            Let current_token2 be memory_get_pointer(parser, 8)
            Let token_type2 be memory_get_integer(current_token2, 0)
            If token_type2 is not equal to 53:  # TOKEN_IDENTIFIER
                Let error_msg be "[PARSER ERROR] Expected field name after '.' at line "
                print_string(error_msg)
                Let line be memory_get_integer(current_token2, 16)
                print_integer(line)
                print_newline()
                exit_with_code(1)
            End If

            Let token_value be memory_get_pointer(current_token2, 8)
            Let field_name be string_duplicate_parser(token_value)
            parser_eat(parser, 53)

            Let field_access be memory_allocate(32)  # sizeof(Expression)
            memory_set_integer(field_access, 0, 10)  # EXPR_FIELD_ACCESS
            memory_set_pointer(field_access, 8, left)  # field_access.object
            memory_set_pointer(field_access, 16, field_name)  # field_access.field_name
            Set left to field_access
        Otherwise If token_type is equal to 127:  # TOKEN_LBRACKET
            parser_eat(parser, 127)

            # Parse index expression
            Let index be parser_parse_additive(parser)

            parser_eat(parser, 49)

            Let array_index be memory_allocate(32)  # sizeof(Expression)
            memory_set_integer(array_index, 0, 16)  # EXPR_ARRAY_INDEX
            memory_set_pointer(array_index, 8, left)  # array_index.array
            memory_set_pointer(array_index, 16, index)  # array_index.index
            Set left to array_index
        Otherwise:
            Set loop_field to 0
        End If
    End While

    Return left
End Process

# Parser parse comparison - handles comparison operators
Process called "parser_parse_comparison" takes parser as Integer returns Integer:
    Let left be parser_parse_additive(parser)

    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_integer(current_token, 0)

    If token_type is equal to 21:  # TOKEN_IS
        parser_eat(parser, 21)

        Let current_token2 be memory_get_pointer(parser, 8)
        Let token_type2 be memory_get_integer(current_token2, 0)

        Let comparison_op be 0
        # Handle NOT EQUAL
        If token_type2 is equal to 29:
            parser_eat(parser, 29)
            parser_eat(parser, 22)
            parser_eat(parser, 15)
            Let comparison_op be 23  # TOKEN_NOT_EQUAL
        End If

        # Handle EQUAL
        If token_type2 is equal to 22:
            parser_eat(parser, 22)
            parser_eat(parser, 15)
            Let comparison_op be 22  # TOKEN_EQUAL
        End If

        # Handle LESS THAN (and LESS EQUAL)
        If token_type2 is equal to 24:
            parser_eat(parser, 24)
            Let current_token3 be memory_get_pointer(parser, 8)
            Let token_type3 be memory_get_integer(current_token3, 0)
            If token_type3 is equal to 28:  # TOKEN_THAN
                parser_eat(parser, 28)
                Let current_token4 be memory_get_pointer(parser, 8)
                Let token_type4 be memory_get_integer(current_token4, 0)
                If token_type4 is equal to 31:
                    parser_eat(parser, 31)
                    parser_eat(parser, 22)
                    parser_eat(parser, 15)
                    Let comparison_op be 27  # TOKEN_LESS_EQUAL
                End If
                If token_type4 is not equal to 31:  # Not TOKEN_OR
                    Let comparison_op be 24  # TOKEN_LESS
                End If
            End If
            If token_type3 is not equal to 28:  # Not TOKEN_THAN
                Let error_msg be "[PARSER ERROR] Expected 'than' after 'less' at line "
                print_string(error_msg)
                Let line be memory_get_integer(current_token3, 16)
                print_integer(line)
                print_newline()
                exit_with_code(1)
            End If
        End If

        # Handle GREATER THAN (and GREATER EQUAL)
        If token_type2 is equal to 25:
            parser_eat(parser, 25)
            Let current_token3 be memory_get_pointer(parser, 8)
            Let token_type3 be memory_get_integer(current_token3, 0)
            If token_type3 is equal to 28:  # TOKEN_THAN
                parser_eat(parser, 28)
                Let current_token4 be memory_get_pointer(parser, 8)
                Let token_type4 be memory_get_integer(current_token4, 0)
                If token_type4 is equal to 31:
                    parser_eat(parser, 31)
                    parser_eat(parser, 22)
                    parser_eat(parser, 15)
                    Let comparison_op be 26  # TOKEN_GREATER_EQUAL
                End If
                If token_type4 is not equal to 31:  # Not TOKEN_OR
                    Let comparison_op be 25  # TOKEN_GREATER
                End If
            End If
            If token_type3 is not equal to 28:  # Not TOKEN_THAN
                Let error_msg be "[PARSER ERROR] Expected 'than' after 'greater' at line "
                print_string(error_msg)
                Let line be memory_get_integer(current_token3, 16)
                print_integer(line)
                print_newline()
                exit_with_code(1)
            End If
        End If

        # Check if we got a valid comparison operator
        If comparison_op is equal to 0:
            Let error_msg be "[PARSER ERROR] Expected 'equal', 'less', or 'greater' after 'is' at line "
            print_string(error_msg)
            Let line be memory_get_integer(current_token2, 16)
            print_integer(line)
            print_newline()
            exit_with_code(1)
        End If

        Let right be parser_parse_additive(parser)
        Return expression_create_comparison(left, comparison_op, right)
    End If

    Return left
End Process

# Parser parse let statement - handles "Let var be expression"
Process called "parser_parse_let_statement" takes parser as Integer returns Integer:
    parser_eat(parser, 12)  # TOKEN_LET

    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_integer(current_token, 0)
    If token_type is not equal to 53:  # TOKEN_IDENTIFIER
        Let error_msg be "[PARSER ERROR] Expected identifier after Let at line "
        print_string(error_msg)
        Let line be memory_get_integer(current_token, 16)
        print_integer(line)
        print_newline()
        exit_with_code(1)
    End If

    Let token_value be memory_get_pointer(current_token, 8)
    Let var_name be string_duplicate_parser(token_value)
    parser_eat(parser, 53)  # TOKEN_IDENTIFIER

    parser_eat(parser, 13)

    Let expr be parser_parse_expression(parser)

    Return statement_create_let(var_name, expr)
End Process

# Parser parse set statement - handles "Set target to expression"
Process called "parser_parse_set_statement" takes parser as Integer returns Integer:
    parser_eat(parser, 14)

    # Parse the target expression (could be variable or nested field access)
    Let target be parser_parse_expression(parser)

    parser_eat(parser, 15)

    Let expr be parser_parse_expression(parser)

    Let stmt be statement_create_set(target, expr)
    Return stmt
End Process

Process called "token_destroy" takes token as Integer returns Integer:
    # Clean up token memory
    If token is not equal to 0:
        Let value be memory_get_pointer(token, 8)
        If value is not equal to 0:
            deallocate(value)
        End If
        deallocate(token)
    End If
    Return 0
End Process

# Expression type constants
Let EXPR_INTEGER be 0
Let EXPR_VARIABLE be 1
Let EXPR_BINARY_OP be 2
Let EXPR_COMPARISON be 3
Let EXPR_FUNCTION_CALL be 4
Let EXPR_STRING_LITERAL be 5
Let EXPR_FIELD_ACCESS be 6
Let EXPR_TYPE_NAME be 7
Let EXPR_BUILTIN_CALL be 8
Let EXPR_VARIANT_CONSTRUCTOR be 9
Let EXPR_FUNCTION_POINTER be 10
Let EXPR_ARRAY_INDEX be 16

# Statement type constants - synchronized with codegen.runa
Let STMT_LET be 1
Let STMT_SET be 2
Let STMT_RETURN be 3
Let STMT_PRINT be 4
Let STMT_IF be 5
Let STMT_WHILE be 6
Let STMT_EXPRESSION be 7
Let STMT_MATCH be 8
Let STMT_IMPORT be 8
Let STMT_BREAK be 9
Let STMT_CONTINUE be 10
Let STMT_INLINE_ASSEMBLY be 16

# Type kind constants
Let TYPE_KIND_STRUCT be 0
Let TYPE_KIND_VARIANT be 1
Let TYPE_KIND_FUNCTION be 2
Let TYPE_KIND_ARRAY be 3

# TOKEN constants (from lexer.h enum - sequential numbering)
# Authoritative token constants from lexer.runa - DO NOT MODIFY
Let TOKEN_EOF be 0
Let TOKEN_PROCESS be 1
Let TOKEN_CALLED be 2
Let TOKEN_RETURNS be 3
Let TOKEN_INTEGER_TYPE be 4
Let TOKEN_STRING_TYPE be 5
Let TOKEN_CHARACTER_TYPE be 6
Let TOKEN_RETURN be 7
Let TOKEN_END be 8
Let TOKEN_COLON be 9
Let TOKEN_STRING_LITERAL be 10
Let TOKEN_INTEGER be 11
Let TOKEN_LET be 12
Let TOKEN_BE be 13
Let TOKEN_SET be 14
Let TOKEN_TO be 15
Let TOKEN_PLUS be 16
Let TOKEN_MINUS be 17
Let TOKEN_IF be 18
Let TOKEN_OTHERWISE be 19
Let TOKEN_WHILE be 20
Let TOKEN_IS be 21
Let TOKEN_EQUAL be 22
Let TOKEN_NOT_EQUAL be 23
Let TOKEN_LESS be 24
Let TOKEN_GREATER be 25
Let TOKEN_GREATER_EQUAL be 26
Let TOKEN_LESS_EQUAL be 27
Let TOKEN_THAN be 28
Let TOKEN_NOT be 29
Let TOKEN_AND be 30
Let TOKEN_OR be 31
Let TOKEN_THAT be 32
Let TOKEN_TAKES be 33
Let TOKEN_AS be 34
Let TOKEN_MULTIPLIED be 35
Let TOKEN_DIVIDED be 36
Let TOKEN_MODULO be 37
Let TOKEN_BY be 38
Let TOKEN_BIT_AND be 39
Let TOKEN_BIT_OR be 40
Let TOKEN_BIT_XOR be 41
Let TOKEN_BIT_SHIFT_LEFT be 42
Let TOKEN_BIT_SHIFT_RIGHT be 43
Let TOKEN_BREAK be 44
Let TOKEN_CONTINUE be 45
Let TOKEN_OTHERWISE_IF be 46
Let TOKEN_PRINT be 47
Let TOKEN_LPAREN be 48
Let TOKEN_RPAREN be 49
Let TOKEN_TYPE be 50
Let TOKEN_DOT be 51
Let TOKEN_COMMA be 52
Let TOKEN_IDENTIFIER be 53
Let TOKEN_READ_FILE be 54
Let TOKEN_WRITE_FILE be 55
Let TOKEN_IMPORT be 56
Let TOKEN_STRING_LENGTH be 57
Let TOKEN_STRING_CHAR_AT be 58
Let TOKEN_STRING_SUBSTRING be 59
Let TOKEN_STRING_EQUALS be 60
Let TOKEN_ASCII_VALUE_OF be 61
Let TOKEN_IS_DIGIT be 62
Let TOKEN_IS_ALPHA be 63
Let TOKEN_IS_WHITESPACE be 64
Let TOKEN_LIST_CREATE be 65
Let TOKEN_LIST_APPEND be 66
Let TOKEN_LIST_GET be 67
Let TOKEN_LIST_GET_INTEGER be 68
Let TOKEN_LIST_LENGTH be 69
Let TOKEN_LIST_DESTROY be 70
Let TOKEN_LIST_SET be 71
Let TOKEN_LIST_INSERT be 72
Let TOKEN_LIST_REMOVE be 73
Let TOKEN_LIST_CLEAR be 74
Let TOKEN_LIST_FIND be 75
Let TOKEN_LIST_SORT be 76
Let TOKEN_LIST_REVERSE be 77
Let TOKEN_LIST_COPY be 78
Let TOKEN_LIST_MERGE be 79
Let TOKEN_STRING_CONCAT be 80
Let TOKEN_STRING_COMPARE be 81
Let TOKEN_STRING_TO_INTEGER be 82
Let TOKEN_INTEGER_TO_STRING be 83
Let TOKEN_STRING_FIND be 84
Let TOKEN_STRING_REPLACE be 85
Let TOKEN_STRING_TRIM be 86
Let TOKEN_STRING_SPLIT be 87
Let TOKEN_FILE_OPEN be 88
Let TOKEN_FILE_CLOSE be 89
Let TOKEN_FILE_READ_LINE be 90
Let TOKEN_FILE_WRITE_LINE be 91
Let TOKEN_FILE_EXISTS be 92
Let TOKEN_FILE_DELETE be 93
Let TOKEN_FILE_SIZE be 94
Let TOKEN_FILE_SEEK be 95
Let TOKEN_FILE_TELL be 96
Let TOKEN_FILE_EOF be 97
Let TOKEN_SIN be 98
Let TOKEN_COS be 99
Let TOKEN_TAN be 100
Let TOKEN_SQRT be 101
Let TOKEN_POW be 102
Let TOKEN_ABS be 103
Let TOKEN_FLOOR be 104
Let TOKEN_CEIL be 105
Let TOKEN_MIN be 106
Let TOKEN_MAX be 107
Let TOKEN_RANDOM be 108
Let TOKEN_LOG be 109
Let TOKEN_EXP be 110
Let TOKEN_PIPE be 111
Let TOKEN_MATCH be 112
Let TOKEN_WHEN be 113
Let TOKEN_WITH be 114
Let TOKEN_GET_COMMAND_LINE_ARGS be 115
Let TOKEN_EXIT_WITH_CODE be 116
Let TOKEN_PANIC be 117
Let TOKEN_ASSERT be 118
Let TOKEN_ALLOCATE be 119
Let TOKEN_DEALLOCATE be 120
Let TOKEN_INLINE be 121
Let TOKEN_ASSEMBLY be 122
Let TOKEN_NOTE be 123
Let TOKEN_POINTER be 124
Let TOKEN_OF be 125
Let TOKEN_ARRAY be 126
Let TOKEN_LBRACKET be 127
Let TOKEN_RBRACKET be 128
Let TOKEN_ERROR be 129
Let TOKEN_COUNT be 130

# TypeDefinition constants
Let TypeDefinition_SIZE be 80
Let TYPEDEFINITION_NAME_OFFSET be 0
Let TYPEDEFINITION_KIND_OFFSET be 8
Let TYPEDEFINITION_SIZE_OFFSET be 16
Let TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET be 24
Let TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET be 32
Let TYPEDEFINITION_DATA_ARRAY_ELEMENT_TYPE_OFFSET be 24
Let TYPEDEFINITION_DATA_ARRAY_LENGTH_OFFSET be 32
Let TYPEDEFINITION_DATA_ARRAY_ELEMENT_SIZE_OFFSET be 40
Let TYPEDEFINITION_DATA_FUNCTION_PARAM_TYPES_OFFSET be 24
Let TYPEDEFINITION_DATA_FUNCTION_PARAM_COUNT_OFFSET be 32
Let TYPEDEFINITION_DATA_FUNCTION_RETURN_TYPE_OFFSET be 40
Let TYPEDEFINITION_DATA_VARIANT_VARIANTS_OFFSET be 24
Let TYPEDEFINITION_DATA_VARIANT_VARIANT_COUNT_OFFSET be 32

# TypeField constants
Let TYPEFIELD_SIZE be 32
Let TYPEFIELD_NAME_OFFSET be 0
Let TYPEFIELD_TYPE_OFFSET be 8
Let TYPEFIELD_OFFSET_OFFSET be 16
Let TYPEFIELD_SIZE_OFFSET be 24

# Variant constants
Let VARIANT_SIZE be 32
Let VARIANT_NAME_OFFSET be 0
Let VARIANT_FIELDS_OFFSET be 8
Let VARIANT_FIELD_COUNT_OFFSET be 16
Let VARIANT_TAG_OFFSET be 24

# Type kind constants already defined above

# Parser constants (definitions moved to bottom of file)
Let PARSER_CURRENT_TOKEN_OFFSET be 8
Let EXPRESSION_TYPE_OFFSET be 0

# String duplicate helper (already in string_utils but needed locally)
Process called "string_duplicate_parser" takes str as Integer returns Integer:
    If str is equal to 0:
        Return 0
    End If
    Let len be string_length(str)
    Let one be 1
    Let size be len plus one
    Let dup be memory_allocate(size)
    string_copy(dup, str)
    Return dup
End Process

# Parser advance - moves to next token
Process called "parser_advance" takes parser as Integer returns Integer:
    Let current_token be memory_get_pointer(parser, 8)  # parser->current_token
    token_destroy(current_token)
    Let lexer be memory_get_pointer(parser, 0)  # parser->lexer
    Let next_token be lexer_next_token(lexer)
    memory_set_pointer(parser, 8, next_token)
    Return 0
End Process

# Parser eat - consume expected token
Process called "parser_eat" takes parser as Integer, expected_type as Integer returns Integer:
    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_integer(current_token, 0)

    If token_type is equal to expected_type:
        Let dummy be parser_advance(parser)
    Otherwise:
        # Print error message
        Let error_msg be "[PARSER ERROR] Expected token type "
        print_string(error_msg)
        print_integer(expected_type)
        Let got_msg be ", got "
        print_string(got_msg)
        print_integer(token_type)
        Let at_line_msg be " at line "
        print_string(at_line_msg)
        Let line be memory_get_integer(current_token, 16)
        print_integer(line)
        print_newline()
        exit_with_code(1)
    End If
    Return 0
End Process

# Check if token is builtin function
Process called "parser_is_builtin_function_token" takes type as Integer returns Integer:
    # All builtin functions in order (54-120, excluding non-builtin tokens)
    # File operations
    If type is equal to 54:  # TOKEN_READ_FILE
        Return 1
    End If
    If type is equal to 55:  # TOKEN_WRITE_FILE
        Return 1
    End If
    # String operations
    If type is equal to 57:  # TOKEN_STRING_LENGTH
        Return 1
    End If
    If type is equal to 58:  # TOKEN_STRING_CHAR_AT
        Return 1
    End If
    If type is equal to 59:  # TOKEN_STRING_SUBSTRING
        Return 1
    End If
    If type is equal to 60:  # TOKEN_STRING_EQUALS
        Return 1
    End If
    If type is equal to 61:  # TOKEN_ASCII_VALUE_OF
        Return 1
    End If
    If type is equal to 62:  # TOKEN_IS_DIGIT
        Return 1
    End If
    If type is equal to 63:  # TOKEN_IS_ALPHA
        Return 1
    End If
    If type is equal to 64:  # TOKEN_IS_WHITESPACE
        Return 1
    End If
    # List operations
    If type is equal to 65:  # TOKEN_LIST_CREATE
        Return 1
    End If
    If type is equal to 66:  # TOKEN_LIST_APPEND
        Return 1
    End If
    If type is equal to 67:  # TOKEN_LIST_GET
        Return 1
    End If
    If type is equal to 68:  # TOKEN_LIST_GET_INTEGER
        Return 1
    End If
    If type is equal to 69:  # TOKEN_LIST_LENGTH
        Return 1
    End If
    If type is equal to 70:  # TOKEN_LIST_DESTROY
        Return 1
    End If
    If type is equal to 71:  # TOKEN_LIST_SET
        Return 1
    End If
    If type is equal to 72:  # TOKEN_LIST_INSERT
        Return 1
    End If
    If type is equal to 73:  # TOKEN_LIST_REMOVE
        Return 1
    End If
    If type is equal to 74:  # TOKEN_LIST_CLEAR
        Return 1
    End If
    If type is equal to 75:  # TOKEN_LIST_FIND
        Return 1
    End If
    If type is equal to 76:  # TOKEN_LIST_SORT
        Return 1
    End If
    If type is equal to 77:  # TOKEN_LIST_REVERSE
        Return 1
    End If
    If type is equal to 78:  # TOKEN_LIST_COPY
        Return 1
    End If
    If type is equal to 79:  # TOKEN_LIST_MERGE
        Return 1
    End If
    # More string operations
    If type is equal to 80:  # TOKEN_STRING_CONCAT
        Return 1
    End If
    If type is equal to 81:  # TOKEN_STRING_COMPARE
        Return 1
    End If
    If type is equal to 82:  # TOKEN_STRING_TO_INTEGER
        Return 1
    End If
    If type is equal to 83:  # TOKEN_INTEGER_TO_STRING
        Return 1
    End If
    If type is equal to 84:  # TOKEN_STRING_FIND
        Return 1
    End If
    If type is equal to 85:  # TOKEN_STRING_REPLACE
        Return 1
    End If
    If type is equal to 86:  # TOKEN_STRING_TRIM
        Return 1
    End If
    If type is equal to 87:  # TOKEN_STRING_SPLIT
        Return 1
    End If
    # More file operations
    If type is equal to 88:  # TOKEN_FILE_OPEN
        Return 1
    End If
    If type is equal to 89:  # TOKEN_FILE_CLOSE
        Return 1
    End If
    If type is equal to 90:  # TOKEN_FILE_READ_LINE
        Return 1
    End If
    If type is equal to 91:  # TOKEN_FILE_WRITE_LINE
        Return 1
    End If
    If type is equal to 92:  # TOKEN_FILE_EXISTS
        Return 1
    End If
    If type is equal to 93:  # TOKEN_FILE_DELETE
        Return 1
    End If
    If type is equal to 94:  # TOKEN_FILE_SIZE
        Return 1
    End If
    If type is equal to 95:  # TOKEN_FILE_SEEK
        Return 1
    End If
    If type is equal to 96:  # TOKEN_FILE_TELL
        Return 1
    End If
    If type is equal to 97:  # TOKEN_FILE_EOF
        Return 1
    End If
    # Math operations
    If type is equal to 98:  # TOKEN_SIN
        Return 1
    End If
    If type is equal to 99:  # TOKEN_COS
        Return 1
    End If
    If type is equal to 100:  # TOKEN_TAN
        Return 1
    End If
    If type is equal to 101:  # TOKEN_SQRT
        Return 1
    End If
    If type is equal to 102:  # TOKEN_POW
        Return 1
    End If
    If type is equal to 103:  # TOKEN_ABS
        Return 1
    End If
    If type is equal to 104:  # TOKEN_FLOOR
        Return 1
    End If
    If type is equal to 105:  # TOKEN_CEIL
        Return 1
    End If
    If type is equal to 106:  # TOKEN_MIN
        Return 1
    End If
    If type is equal to 107:  # TOKEN_MAX
        Return 1
    End If
    If type is equal to 108:  # TOKEN_RANDOM
        Return 1
    End If
    If type is equal to 109:  # TOKEN_LOG
        Return 1
    End If
    If type is equal to 110:  # TOKEN_EXP
        Return 1
    End If
    # System operations
    If type is equal to 115:  # TOKEN_GET_COMMAND_LINE_ARGS
        Return 1
    End If
    If type is equal to 116:  # TOKEN_EXIT_WITH_CODE
        Return 1
    End If
    If type is equal to 117:  # TOKEN_PANIC
        Return 1
    End If
    If type is equal to 118:  # TOKEN_ASSERT
        Return 1
    End If
    If type is equal to 119:  # TOKEN_ALLOCATE
        Return 1
    End If
    If type is equal to 120:  # TOKEN_DEALLOCATE
        Return 1
    End If
    Return 0
End Process

# Create integer expression
Process called "expression_create_integer" takes value as Integer returns Integer:
    Let expr_size be 32  # Ensure sufficient space: type(8) + value(8) + padding
    Let expr be memory_allocate(expr_size)
    memory_set_integer(expr, 0, EXPR_INTEGER)
    memory_set_integer(expr, 8, value)
    Return expr
End Process

# Create variable expression
Process called "expression_create_variable" takes name as Integer returns Integer:
    Let expr_size be 32  # Ensure sufficient space: type(8) + name_pointer(8) + padding
    Let expr be memory_allocate(expr_size)
    memory_set_integer(expr, 0, EXPR_VARIABLE)
    Let dup_name be string_duplicate_parser(name)
    memory_set_pointer(expr, 8, dup_name)
    Return expr
End Process

# Create binary operation expression
Process called "expression_create_binary_op" takes left as Integer, operator as Integer, right as Integer returns Integer:
    Let expr_size be 32  # type plus left plus right plusoperator
    Let expr be memory_allocate(expr_size)
    memory_set_integer(expr, 0, EXPR_BINARY_OP)
    memory_set_pointer(expr, 8, left)
    memory_set_pointer(expr, 16, right)
    memory_set_integer(expr, 24, operator)
    Return expr
End Process

# Create comparison expression
Process called "expression_create_comparison" takes left as Integer, comparison_op as Integer, right as Integer returns Integer:
    Let expr_size be 32
    Let expr be memory_allocate(expr_size)
    memory_set_integer(expr, 0, EXPR_COMPARISON)
    memory_set_pointer(expr, 8, left)
    memory_set_pointer(expr, 16, right)
    memory_set_integer(expr, 24, comparison_op)
    Return expr
End Process

# Create function call expression
Process called "expression_create_function_call" takes function_name as Integer, arguments as Integer, argument_count as Integer returns Integer:
    Let expr_size be 32
    Let expr be memory_allocate(expr_size)
    memory_set_integer(expr, 0, EXPR_FUNCTION_CALL)
    Let dup_name be string_duplicate_parser(function_name)
    memory_set_pointer(expr, 8, dup_name)
    memory_set_pointer(expr, 16, arguments)
    memory_set_integer(expr, 24, argument_count)
    Return expr
End Process

# Create string literal expression (takes ownership)
Process called "expression_create_string_literal_owned" takes string_value as Integer returns Integer:
    Let expr_size be 32  # Match other expression types for safety
    Let expr be memory_allocate(expr_size)
    memory_set_integer(expr, 0, EXPR_STRING_LITERAL)
    memory_set_pointer(expr, 8, string_value)  # Takes ownership

    Return expr
End Process

# Create let statement
Process called "statement_create_let" takes var_name as Integer, expr as Integer returns Integer:
    Let stmt_size be 24
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_LET)
    Let dup_name be string_duplicate_parser(var_name)
    memory_set_pointer(stmt, 8, dup_name)   # variable_name at offset 8
    memory_set_pointer(stmt, 16, expr)      # expression at offset 16
    Return stmt
End Process

# Create set statement
Process called "statement_create_set" takes target as Integer, expr as Integer returns Integer:
    Let stmt_size be 24
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_SET)
    memory_set_pointer(stmt, 8, target)  # target at offset 8
    memory_set_pointer(stmt, 16, expr)   # expression at offset 16
    Return stmt
End Process

# Create return statement
Process called "statement_create_return" takes expr as Integer returns Integer:
    Let stmt_size be 24  # Match other statement types that have fields at offset 16
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_RETURN)
    memory_set_pointer(stmt, 8, expr)
    Return stmt
End Process

# Create print statement
Process called "statement_create_print" takes expr as Integer returns Integer:
    Let stmt_size be 24  # Match other statement types for consistency
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_PRINT)
    memory_set_pointer(stmt, 8, expr)
    Return stmt
End Process

# Create expression statement
Process called "statement_create_expression" takes expr as Integer returns Integer:
    Let stmt_size be 24  # Match other statement types for consistency
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_EXPRESSION)
    memory_set_pointer(stmt, 8, expr)
    Return stmt
End Process

# Create if statement
Process called "statement_create_if" takes condition as Integer, if_body as Integer, if_body_count as Integer, else_body as Integer, else_body_count as Integer returns Integer:
    Let stmt_size be 48
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_IF)
    memory_set_pointer(stmt, 8, condition)
    memory_set_pointer(stmt, 16, if_body)
    memory_set_integer(stmt, 24, if_body_count)
    memory_set_pointer(stmt, 32, else_body)
    memory_set_integer(stmt, 40, else_body_count)
    Return stmt
End Process

# Create while statement
Process called "statement_create_while" takes condition as Integer, body as Integer, body_count as Integer returns Integer:
    Let stmt_size be 32
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_WHILE)
    memory_set_pointer(stmt, 8, condition)
    memory_set_pointer(stmt, 16, body)
    memory_set_integer(stmt, 24, body_count)
    Return stmt
End Process

# Create break statement
Process called "statement_create_break" takes dummy as Integer returns Integer:
    Let stmt_size be 8
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_BREAK)
    Return stmt
End Process

# Create continue statement
Process called "statement_create_continue" takes dummy as Integer returns Integer:
    Let stmt_size be 8
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_CONTINUE)
    Return stmt
End Process

# Create function
Process called "function_create" takes name as Integer, return_type as Integer returns Integer:
    Let func_size be 48  # name, parameters, parameter_count, return_type, statements, statement_count
    Let func be memory_allocate(func_size)
    Let dup_name be string_duplicate_parser(name)
    memory_set_pointer(func, 0, dup_name)
    memory_set_pointer(func, 8, 0)  # parameters = NULL
    memory_set_integer(func, 16, 0)  # parameter_count = 0
    Let dup_type be string_duplicate_parser(return_type)
    memory_set_pointer(func, 24, dup_type)
    memory_set_pointer(func, 32, 0)  # statements = NULL
    memory_set_integer(func, 40, 0)  # statement_count = 0
    Return func
End Process

# Add parameter to function
Process called "function_add_parameter" takes func as Integer, param_name as Integer, param_type as Integer returns Integer:
    Let parameter_count be memory_get_integer(func, 16)
    Let new_count be parameter_count plus 1
    Let param_size be 16  # sizeof(Parameter) = name plustype
    Let new_size be new_count multiplied by param_size

    Let parameters be memory_get_pointer(func, 8)
    Let new_parameters be memory_reallocate(parameters, new_size)

    Let offset be parameter_count multiplied by param_size
    Let param_ptr be new_parameters plus offset
    Let dup_name be string_duplicate_parser(param_name)
    memory_set_pointer(param_ptr, 0, dup_name)
    Let dup_type be string_duplicate_parser(param_type)
    memory_set_pointer(param_ptr, 8, dup_type)

    memory_set_pointer(func, 8, new_parameters)
    memory_set_integer(func, 16, new_count)
    Return 0
End Process

# Add statement to function
Process called "function_add_statement" takes func as Integer, stmt as Integer returns Integer:

    Let statement_count be memory_get_integer(func, 40)
    Let new_count be statement_count plus 1
    Let ptr_size be 8
    Let new_size be new_count multiplied by ptr_size

    Let statements be memory_get_pointer(func, 32)
    Let new_statements be memory_reallocate(statements, new_size)

    Let offset be statement_count multiplied by ptr_size
    Let stmt_ptr be new_statements plus offset
    memory_set_pointer(stmt_ptr, 0, stmt)

    memory_set_pointer(func, 32, new_statements)
    memory_set_integer(func, 40, new_count)

    Return 0
End Process

# Create program
Process called "program_create" takes dummy as Integer returns Integer:
    Let prog_size be 64  # 8 fields multiplied by 8 bytes each
    Let program be memory_allocate(prog_size)
    memory_set_pointer(program, 0, 0)   # functions = NULL
    memory_set_integer(program, 8, 0)   # function_count = 0
    memory_set_integer(program, 12, 0)  # function_capacity = 0
    memory_set_pointer(program, 16, 0)  # types = NULL
    memory_set_integer(program, 24, 0)  # type_count = 0
    memory_set_integer(program, 28, 0)  # type_capacity = 0
    memory_set_pointer(program, 32, 0)  # imports = NULL
    memory_set_integer(program, 40, 0)  # import_count = 0
    memory_set_integer(program, 44, 0)  # import_capacity = 0
    memory_set_pointer(program, 48, 0)  # globals = NULL
    memory_set_integer(program, 56, 0)  # global_count = 0
    memory_set_integer(program, 60, 0)  # global_capacity = 0
    Return program
End Process

# Add function to program
Process called "program_add_function" takes program as Integer, func as Integer returns Integer:
    Let function_count be memory_get_integer(program, 8)
    Let function_capacity be memory_get_integer(program, 12)

    If function_count is greater than or equal to function_capacity:
        If function_capacity is equal to 0:
            Set function_capacity to 4
        Otherwise:
            Set function_capacity to function_capacity multiplied by 2
        End If

        Let ptr_size be 8
        Let new_size be function_capacity multiplied by ptr_size
        Let functions be memory_get_pointer(program, 0)
        Let new_functions be memory_reallocate(functions, new_size)
        memory_set_pointer(program, 0, new_functions)
        memory_set_integer(program, 12, function_capacity)
    End If

    Let functions be memory_get_pointer(program, 0)
    Let ptr_size be 8
    Let offset be function_count multiplied by ptr_size
    Let func_ptr be functions plus offset
    memory_set_pointer(func_ptr, 0, func)

    Let new_count be function_count plus 1
    memory_set_integer(program, 8, new_count)
    Return 0
End Process

# Add global variable to program
Process called "program_add_global" takes program as Integer, global as Integer returns Integer:
    Let global_count be memory_get_integer(program, 56)
    Let global_capacity be memory_get_integer(program, 60)

    If global_count is greater than or equal to global_capacity:
        If global_capacity is equal to 0:
            Set global_capacity to 4
        Otherwise:
            Set global_capacity to global_capacity multiplied by 2
        End If

        Let ptr_size be 8
        Let new_size be global_capacity multiplied by ptr_size
        Let globals be memory_get_pointer(program, 48)
        Let new_globals be memory_reallocate(globals, new_size)
        memory_set_pointer(program, 48, new_globals)
        memory_set_integer(program, 60, global_capacity)
    End If

    Let globals be memory_get_pointer(program, 48)
    Let ptr_size be 8
    Let offset be global_count multiplied by ptr_size
    Let global_ptr be globals plus offset
    memory_set_integer(global_ptr, 0, global)

    Let new_count be global_count plus 1
    memory_set_integer(program, 56, new_count)
    Return 0
End Process

# Add type to program
Process called "program_add_type" takes program as Integer, type as Integer returns Integer:
    Let type_count be memory_get_integer(program, 24)
    Let type_capacity be memory_get_integer(program, 28)

    If type_count is greater than or equal to type_capacity:
        If type_capacity is equal to 0:
            Set type_capacity to 4
        Otherwise:
            Set type_capacity to type_capacity multiplied by 2
        End If

        Let ptr_size be 8
        Let new_size be type_capacity multiplied by ptr_size
        Let types be memory_get_pointer(program, 16)
        Let new_types be memory_reallocate(types, new_size)
        memory_set_pointer(program, 16, new_types)
        memory_set_integer(program, 28, type_capacity)
    End If

    Let types be memory_get_pointer(program, 16)
    Let ptr_size be 8
    Let offset be type_count multiplied by ptr_size
    Let type_ptr be types plus offset
    memory_set_integer(type_ptr, 0, type)

    Let new_count be type_count plus 1
    memory_set_integer(program, 24, new_count)
    Return 0
End Process

# Add import to program
Process called "program_add_import" takes program as Integer, import as Integer returns Integer:
    Let import_count be memory_get_integer(program, 40)
    Let import_capacity be memory_get_integer(program, 44)

    If import_count is greater than or equal to import_capacity:
        If import_capacity is equal to 0:
            Set import_capacity to 4
        Otherwise:
            Set import_capacity to import_capacity multiplied by 2
        End If

        Let ptr_size be 8
        Let new_size be import_capacity multiplied by ptr_size
        Let imports be memory_get_pointer(program, 32)
        Let new_imports be memory_reallocate(imports, new_size)
        memory_set_pointer(program, 32, new_imports)
        memory_set_integer(program, 44, import_capacity)
    End If

    Let imports be memory_get_pointer(program, 32)
    Let ptr_size be 8
    Let offset be import_count multiplied by ptr_size
    Let import_ptr be imports plus offset
    memory_set_integer(import_ptr, 0, import)

    Let new_count be import_count plus 1
    memory_set_integer(program, 40, new_count)
    Return 0
End Process

# Parse primary expression
Process called "parser_parse_primary" takes parser as Integer returns Integer:
    Let current_token be memory_get_pointer(parser, 8)
    Let token_type be memory_get_integer(current_token, 0)

    # Handle built-in functions
    Let is_builtin be parser_is_builtin_function_token(token_type)
    If is_builtin is equal to 1:
        Let builtin_type be token_type
        Let dummy be parser_eat(parser, builtin_type)

        Let dummy2 be parser_eat(parser, 48)  # TOKEN_LPAREN

        # Parse arguments
        Let arguments be 0
        Let argument_count be 0

        Let current_token2 be memory_get_pointer(parser, 8)
        Let token_type2 be memory_get_integer(current_token2, 0)

        If token_type2 is not equal to 49:  # TOKEN_RPAREN
            Let capacity be 2
            Let ptr_size be 8
            Let size be capacity multiplied by ptr_size
            Set arguments to memory_allocate(size)

            Let continue_args be 1
            While continue_args is equal to 1:
                Let current_token3 be memory_get_pointer(parser, 8)
                Let token_type3 be memory_get_integer(current_token3, 0)

                If token_type3 is equal to 52:  # TOKEN_COMMA
                    Let dummy3 be parser_eat(parser, 52)  # TOKEN_COMMA
                End If

                Let arg be parser_parse_additive(parser)

                If argument_count is greater than or equal to capacity:
                    Set capacity to capacity multiplied by 2
                    Let new_size be capacity multiplied by ptr_size
                    Set arguments to memory_reallocate(arguments, new_size)
                End If

                Let offset be argument_count multiplied by ptr_size
                Let arg_ptr be arguments plus offset
                memory_set_integer(arg_ptr, 0, arg)
                Set argument_count to argument_count plus 1

                Let current_token4 be memory_get_pointer(parser, 8)
                Let token_type4 be memory_get_integer(current_token4, 0)
                If token_type4 is not equal to 52:  # TOKEN_COMMA
                    Set continue_args to 0
                End If
            End While
        End If

        Let dummy4 be parser_eat(parser, 49)  # TOKEN_RPAREN

        # Create builtin call expression
        Let expr_size be 32
        Let expr be memory_allocate(expr_size)
        memory_set_integer(expr, 0, 8)  # EXPR_BUILTIN_CALL
        memory_set_integer(expr, 8, builtin_type)
        memory_set_integer(expr, 16, arguments)
        memory_set_integer(expr, 24, argument_count)
        Return expr
    End If

    # Handle integer literal
    If token_type is equal to 11:
        Let value_str be memory_get_pointer(current_token, 8)
        Let value be string_to_integer(value_str)
        Let dummy5 be parser_eat(parser, 11)
        Let expr be expression_create_integer(value)
        Return expr
    End If

    # Handle string literal
    If token_type is equal to 10:
        Let value_str be memory_get_pointer(current_token, 8)
        Let string_value be string_duplicate_parser(value_str)


        # Check if this string literal is a known type name
        Let is_type be 0
        Let prog be memory_get_pointer(parser, 16)  # parser->current_program
        If prog is not equal to 0:
            Let type_count be memory_get_integer(prog, PROGRAM_TYPE_COUNT)
            Let types be memory_get_pointer(prog, PROGRAM_TYPES)
            Let i be 0
            While i is less than type_count:
                Let ptr_size be 8
                Let offset be i multiplied by ptr_size
                Let type_ptr be types plus offset
                Let type_def be memory_get_integer(type_ptr, 0)
                Let type_name be memory_get_pointer(type_def, 0)
                Let result be string_equals(type_name, string_value)
                If result is equal to 1:
                    Set is_type to 1
                    Set i to type_count  # Break loop
                Otherwise:
                    Set i to i plus 1
                End If
            End While
        End If

        Let dummy6 be parser_eat(parser, 10)

        If is_type is equal to 1:
            # This is a type name, create a type expression
            Let expr_size be 32  # Match other expression types for safety
            Let expr be memory_allocate(expr_size)
            memory_set_integer(expr, 0, EXPR_TYPE_NAME)
            memory_set_pointer(expr, 8, string_value)
            Return expr
        Otherwise:
            Let expr be expression_create_string_literal_owned(string_value)
            Return expr
        End If
    End If

    # Handle identifier
    If token_type is equal to 53:
        Let value_str be memory_get_pointer(current_token, 8)
        Let name be string_duplicate_parser(value_str)

        # Check if this identifier is a known type name
        Let is_type be 0
        Let prog be memory_get_pointer(parser, 16)
        If prog is not equal to 0:
            Let type_count be memory_get_integer(prog, PROGRAM_TYPE_COUNT)
            Let types be memory_get_pointer(prog, PROGRAM_TYPES)
            Let i be 0
            Let continue_type_search be 1
            While continue_type_search is equal to 1:
                Let search_done be 0
                If i is greater than or equal to type_count:
                    Let search_done be 1
                End If
                If search_done is equal to 1:
                    Let continue_type_search be 0
                End If
                If search_done is equal to 0:
                    Let ptr_size be 8
                    Let offset be i multiplied by ptr_size
                    Let type_ptr be types plus offset
                    Let type_def be memory_get_integer(type_ptr, 0)
                    Let type_name be memory_get_pointer(type_def, 0)
                    Let result be string_equals(type_name, name)
                    If result is equal to 1:
                        Set is_type to 1
                        Let continue_type_search be 0  # Break loop
                    End If
                    Set i to i plus 1
                End If
            End While
        End If

        Let dummy7 be parser_eat(parser, 53)

        # Check if this is a variant constructor (with keyword)
        Let current_token5 be memory_get_pointer(parser, 8)
        Let token_type5 be memory_get_integer(current_token5, 0)

        If token_type5 is equal to 124:
            # Check if this identifier is a variant name within any ADT type
            Let variant_name be name
            Let adt_type be 0

            # Find the ADT type that contains this variant
            If prog is not equal to 0:
                Let type_count be memory_get_integer(prog, PROGRAM_TYPE_COUNT)
                Let types be memory_get_pointer(prog, PROGRAM_TYPES)
                Let i be 0
                Let continue_outer be 1
                While continue_outer is equal to 1:
                    Let is_done be 0
                    If i is greater than or equal to type_count:
                        Let is_done be 1
                    End If
                    If is_done is equal to 1:
                        Let continue_outer be 0
                    End If
                    If is_done is equal to 0:
                        Let ptr_size be 8
                        Let offset be i multiplied by ptr_size
                        Let type_ptr be types plus offset
                        Let type_def be memory_get_integer(type_ptr, 0)
                        Let type_kind be memory_get_integer(type_def, 8)

                        # Check if this is a variant type
                        Let is_variant_type be 0
                        If type_kind is equal to TYPE_KIND_VARIANT:
                            Let is_variant_type be 1
                        End If
                        If is_variant_type is equal to 1:
                            Let variant_count be memory_get_integer(type_def, 24)
                            Let variants be memory_get_pointer(type_def, 16)
                            Let j be 0
                            Let continue_inner be 1
                            While continue_inner is equal to 1:
                                Let inner_done be 0
                                If j is greater than or equal to variant_count:
                                    Let inner_done be 1
                                End If
                                If inner_done is equal to 1:
                                    Let continue_inner be 0
                                End If
                                If inner_done is equal to 0:
                                    Let variant_offset be j multiplied by 16
                                    Let variant_ptr be variants plus variant_offset
                                    Let variant_name_ptr be memory_get_integer(variant_ptr, 0)
                                    Let variant_match be string_equals(variant_name_ptr, variant_name)
                                    If variant_match is equal to 1:
                                        Let adt_type be type_def
                                        Let continue_inner be 0  # Break inner loop
                                        Let continue_outer be 0  # Break outer loop
                                    End If
                                    Let j be j plus 1
                                End If
                            End While
                        End If
                        Let i be i plus 1
                    End If
                End While
            End If

            If adt_type is not equal to 0:
                # This is a variant constructor
                parser_eat(parser, 114)

                Let expr_size be 40
                Let expr be memory_allocate(expr_size)
                memory_set_integer(expr, 0, EXPR_VARIANT_CONSTRUCTOR)
                Let adt_type_name be memory_get_integer(adt_type, 0)
                memory_set_pointer(expr, 8, string_duplicate_parser(adt_type_name))  # type_name
                memory_set_integer(expr, 16, variant_name)  # variant_name
                memory_set_integer(expr, 24, 0)  # field_values
                memory_set_integer(expr, 32, 0)  # field_count
                Return expr
            End If
        End If

        # Check if this is a function call
        Let check_func_call be 0
        If is_type is equal to 0:
            Let current_token6 be memory_get_pointer(parser, 8)
            Let token_type6 be memory_get_integer(current_token6, 0)
            If token_type6 is equal to 53:
                Set check_func_call to 1
            End If
        End If

        If check_func_call is equal to 1:
            Let dummy9 be parser_eat(parser, 51)

            # Parse arguments
            Let arguments be 0
            Let argument_count be 0
            Let argument_capacity be 0

            Let continue_loop be 1
            While continue_loop is equal to 1:
                Let current_token7 be memory_get_pointer(parser, 8)
                Let token_type7 be memory_get_integer(current_token7, 0)

                # Check for closing paren
                If token_type7 is equal to 49:
                    Set continue_loop to 0
                End If

                # Check for EOF
                If token_type7 is equal to 0:
                    Set continue_loop to 0
                End If

                # Process argument
                Let should_process_arg be 0
                If token_type7 is not equal to 49:
                    If token_type7 is not equal to 0:
                        Set should_process_arg to 1
                    End If
                End If

                If should_process_arg is equal to 1:
                    If argument_count is greater than or equal to argument_capacity:
                        If argument_capacity is equal to 0:
                            Set argument_capacity to 4
                        End If
                        If argument_capacity is not equal to 4:
                            Set argument_capacity to argument_capacity multiplied by 2
                        End If
                        Let ptr_size be 8
                        Let new_size be argument_capacity multiplied by ptr_size
                        Set arguments to memory_reallocate(arguments, new_size)
                    End If

                    Let arg be parser_parse_additive(parser)
                    Let ptr_size be 8
                    Let offset be argument_count multiplied by ptr_size
                    Let arg_ptr be arguments plus offset
                    memory_set_integer(arg_ptr, 0, arg)
                    Set argument_count to argument_count plus 1

                    Let current_token8 be memory_get_pointer(parser, 8)
                    Let token_type8 be memory_get_integer(current_token8, 0)

                    # Check what comes after the argument
                    If token_type8 is equal to 49:
                        Set continue_loop to 0
                    End If
                    If token_type8 is equal to 52:
                        Let dummy10 be parser_eat(parser, 52)
                    End If
                    If token_type8 is not equal to 49:
                        If token_type8 is not equal to 52:
                            # Error: expected comma or closing paren
                            Let error_msg be "[PARSER ERROR] Expected ',' or ')' in function arguments at line "
                            print_string(error_msg)
                            Let line be memory_get_integer(current_token8, 16)
                            print_integer(line)
                            print_newline()
                            exit_with_code(1)
                        End If
                    End If
                End If
            End While

            Let dummy16 be parser_eat(parser, 52)
            Let expr be expression_create_function_call(name, arguments, argument_count)
            Return expr
        End If

        # Handle type name
        If is_type is equal to 1:
            # This is a type name, create a type expression
            Let expr_size be 32  # Match other expression types for safety
            Let expr be memory_allocate(expr_size)
            memory_set_integer(expr, 0, EXPR_TYPE_NAME)
            memory_set_integer(expr, 8, name)
            Return expr
        End If

        # Default case: variable expression
        Let expr be expression_create_variable(name)
        Return expr
    End If

    # Error: unexpected token
    Let error_msg be "[PARSER ERROR] Expected integer or identifier at line "
    print_string(error_msg)
    Let line be memory_get_integer(current_token, 16)
    print_newline()
    exit_with_code(1)
    Return 0  # Unreachable
End Process

# Parser parse return statement - handles "Return expression"
Process called "parser_parse_return_statement" takes parser as Integer returns Integer:
    Let dummy be parser_eat(parser, 7)
    Let expr be parser_parse_expression(parser)
    Let stmt be statement_create_return(expr)
    Return stmt
End Process

# Parser parse break statement - handles "Break"
Process called "parser_parse_break_statement" takes parser as Integer returns Integer:
    Let dummy be parser_eat(parser, 44)
    Return statement_create_break(0)
End Process

# Parser parse continue statement - handles "Continue"
Process called "parser_parse_continue_statement" takes parser as Integer returns Integer:
    Let dummy be parser_eat(parser, 45)
    Return statement_create_continue(0)
End Process

# Parser parse print statement - handles "Print expression"
Process called "parser_parse_print_statement" takes parser as Integer returns Integer:
    Let dummy be parser_eat(parser, 47)
    Let expr be parser_parse_expression(parser)
    Return statement_create_print(expr)
End Process

# Parser parse statement block - parses block of statements until END/OTHERWISE/EOF
Process called "parser_parse_statement_block" takes parser as Integer, count_ptr as Integer returns Integer:
    Let statements be 0
    Let capacity be 0
    memory_set_integer(count_ptr, 0, 0)

    Let continue_loop be 1
    While continue_loop is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        # Check for block termination conditions
        If token_type is equal to 8:
            Set continue_loop to 0
        End If
        If token_type is equal to 19:
            Set continue_loop to 0
        End If
        If token_type is equal to 0:
            Set continue_loop to 0
        End If

        If continue_loop is equal to 1:
            Let stmt be 0

            # Parse different statement types
            If token_type is equal to 12:
                Set stmt to parser_parse_let_statement(parser)
            End If

            If token_type is equal to 14:
                Set stmt to parser_parse_set_statement(parser)
            End If

            If token_type is equal to 7:
                Set stmt to parser_parse_return_statement(parser)
            End If

            If token_type is equal to 44:
                Set stmt to parser_parse_break_statement(parser)
            End If

            If token_type is equal to 45:
                Set stmt to parser_parse_continue_statement(parser)
            End If

            If token_type is equal to 47:
                Set stmt to parser_parse_print_statement(parser)
            End If

            If token_type is equal to 18:
                Set stmt to parser_parse_if_statement(parser)
            End If

            If token_type is equal to 20:
                Set stmt to parser_parse_while_statement(parser)
            End If

            If token_type is equal to 121:
                Set stmt to parser_parse_inline_assembly_statement(parser)
            End If

            If token_type is equal to 112:
                Set stmt to parser_parse_match_statement(parser)
            End If

            # Handle identifier - could be function call
            If token_type is equal to 53:
                Let expr be parser_parse_expression(parser)
                Let expr_type be memory_get_integer(expr, 0)
                If expr_type is equal to EXPR_FUNCTION_CALL:
                    Set stmt to statement_create_expression(expr)
                End If
                If expr_type is not equal to EXPR_FUNCTION_CALL:
                    Let error_msg be "[PARSER ERROR] Only function calls can be used as statements (expr_type="
                    print_string(error_msg)
                    print_integer(expr_type)
                    print_string(", expected ")
                    print_integer(EXPR_FUNCTION_CALL)
                    print_string(") at line ")
                    Let line be memory_get_integer(current_token, 16)
                    print_integer(line)
                    print_newline()
                    exit_with_code(1)
                End If
            End If

            # Handle builtin function calls
            Let is_builtin be parser_is_builtin_function_token(token_type)
            If is_builtin is equal to 1:
                Let expr be parser_parse_expression(parser)
                Let expr_type be memory_get_integer(expr, 0)
                If expr_type is equal to EXPR_BUILTIN_CALL:
                    Set stmt to statement_create_expression(expr)
                End If
                If expr_type is not equal to EXPR_BUILTIN_CALL:
                    Let error_msg be "[PARSER ERROR] Invalid builtin function statement at line "
                    print_string(error_msg)
                    Let line be memory_get_integer(current_token, 16)
                    print_integer(line)
                    print_newline()
                    exit_with_code(1)
                End If
            End If

            # If no statement was parsed, break
            If stmt is equal to 0:
                Set continue_loop to 0
            End If

            # Add statement to array if parsed
            If stmt is not equal to 0:
                Let current_count be memory_get_integer(count_ptr, 0)
                If current_count is greater than or equal to capacity:
                    If capacity is equal to 0:
                        Set capacity to 4
                    Otherwise:
                        Set capacity to capacity multiplied by 2
                    End If
                    Let ptr_size be 8
                    Let new_size be capacity multiplied by ptr_size
                    Set statements to memory_reallocate(statements, new_size)
                End If

                Let ptr_size be 8
                Let offset be current_count multiplied by ptr_size
                Let stmt_ptr be statements plus offset
                memory_set_pointer(stmt_ptr, 0, stmt)

                Let new_count be current_count plus 1
                memory_set_integer(count_ptr, 0, new_count)
            End If
        End If
    End While

    Return statements
End Process

# Parser parse while statement - handles "While condition: ... End While"
Process called "parser_parse_while_statement" takes parser as Integer returns Integer:
    Let dummy1 be parser_eat(parser, 20)
    Let condition be parser_parse_comparison(parser)
    Let dummy2 be parser_eat(parser, 9)

    Let body_count_ptr be memory_allocate(8)
    Let body be parser_parse_statement_block(parser, body_count_ptr)
    Let body_count be memory_get_integer(body_count_ptr, 0)
    deallocate(body_count_ptr)

    Let dummy3 be parser_eat(parser, 8)
    Let dummy4 be parser_eat(parser, 20)

    Let while_stmt be statement_create_while(condition, body, body_count)
    Return while_stmt
End Process

# Parser parse if statement - handles "If condition: ... Otherwise If ... Otherwise ... End If"
# Handle elif/else chains with proper nesting
Process called "parser_parse_if_statement" takes parser as Integer returns Integer:
    Let dummy1 be parser_eat(parser, 18)
    Let condition be parser_parse_comparison(parser)
    Let dummy2 be parser_eat(parser, 9)

    Let if_body_count_ptr be memory_allocate(8)
    Let if_body be parser_parse_statement_block(parser, if_body_count_ptr)
    Let if_body_count be memory_get_integer(if_body_count_ptr, 0)
    deallocate(if_body_count_ptr)

    Let else_body be 0
    Let else_body_count be 0

    # Handle elif/else chains
    Let continue_parsing be 1
    While continue_parsing is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 19:
            Let dummy3 be parser_eat(parser, 19)
            Let next_token be memory_get_pointer(parser, 8)
            Let next_token_type be memory_get_integer(next_token, 0)

            # Check if this is "Otherwise If" (elif)
            If next_token_type is equal to 18:
                Let dummy4 be parser_eat(parser, 18)
                Let elif_condition be parser_parse_comparison(parser)
                Let dummy5 be parser_eat(parser, 9)

                Let elif_body_count_ptr be memory_allocate(8)
                Let elif_body be parser_parse_statement_block(parser, elif_body_count_ptr)
                Let elif_body_count be memory_get_integer(elif_body_count_ptr, 0)
                deallocate(elif_body_count_ptr)

                # Create nested if statement for elif
                Let elif_stmt be statement_create_if(elif_condition, elif_body, elif_body_count, 0, 0)

                If else_body is equal to 0:
                    # First elif - create else body
                    Set else_body to memory_allocate(8)
                    memory_set_pointer(else_body, 0, elif_stmt)
                    Set else_body_count to 1
                End If

                # Chain elifs
                If else_body is not equal to 0:
                    # Create a linear chain structure
                    Let old_else_body be else_body
                    Let old_else_count be else_body_count

                    # Create new else body with both old and new statements
                    Let new_count be old_else_count plus 1
                    Let ptr_size be 8
                    Let new_size be new_count multiplied by ptr_size
                    Set else_body to memory_allocate(new_size)

                    # Copy old statements
                    Let i be 0
                    While i is less than old_else_count:
                        Let src_offset be i multiplied by ptr_size
                        Let dst_offset be i multiplied by ptr_size
                        Let src_ptr be old_else_body plus src_offset
                        Let dst_ptr be else_body plus dst_offset
                        Let stmt_val be memory_get_integer(src_ptr, 0)
                        memory_set_integer(dst_ptr, 0, stmt_val)
                        Set i to i plus 1
                    End While

                    # Add new elif statement
                    Let last_offset be old_else_count multiplied by ptr_size
                    Let last_ptr be else_body plus last_offset
                    memory_set_pointer(last_ptr, 0, elif_stmt)
                    Set else_body_count to new_count
                    deallocate(old_else_body)
                End If
            End If

            # Handle regular "Otherwise" clause
            If next_token_type is not equal to 18:
                Let dummy6 be parser_eat(parser, 9)
                Let final_else_count_ptr be memory_allocate(8)
                Let final_else_body be parser_parse_statement_block(parser, final_else_count_ptr)
                Let final_else_count be memory_get_integer(final_else_count_ptr, 0)
                deallocate(final_else_count_ptr)

                If else_body is equal to 0:
                    # No previous elifs, simple else
                    Set else_body to final_else_body
                    Set else_body_count to final_else_count
                End If

                If else_body is not equal to final_else_body:
                    # Attach to existing elif chain
                    Set else_body to final_else_body
                    Set else_body_count to final_else_count
                End If

                Set continue_parsing to 0  # Final else ends the chain
            End If
        End If

        If token_type is not equal to 19:
            Set continue_parsing to 0
        End If
    End While

    Let dummy7 be parser_eat(parser, 8)
    Let dummy8 be parser_eat(parser, 18)

    Return statement_create_if(condition, if_body, if_body_count, else_body, else_body_count)
End Process

# Parser parse inline assembly statement - handles "Inline Assembly: ... End Assembly"
Process called "parser_parse_inline_assembly_statement" takes parser as Integer returns Integer:
    Let dummy1 be parser_eat(parser, 121)
    Let dummy2 be parser_eat(parser, 122)
    Let dummy3 be parser_eat(parser, 9)

    # Create statement structure
    Let stmt_size be 128  # sizeof(Statement) - large enough for inline assembly data
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_INLINE_ASSEMBLY)

    # Initialize arrays (struct offsets for inline_assembly_stmt)
    Let assembly_lines_offset be 8
    Let assembly_notes_offset be 16
    Let assembly_line_count_offset be 24
    Let output_constraints_offset be 32
    Let output_count_offset be 40
    Let input_constraints_offset be 48
    Let input_count_offset be 56
    Let clobber_list_offset be 64
    Let clobber_count_offset be 72

    memory_set_integer(stmt, assembly_lines_offset, 0)      # assembly_lines = NULL
    memory_set_integer(stmt, assembly_notes_offset, 0)      # assembly_notes = NULL
    memory_set_integer(stmt, assembly_line_count_offset, 0) # assembly_line_count = 0
    memory_set_integer(stmt, output_constraints_offset, 0)  # output_constraints = NULL
    memory_set_integer(stmt, output_count_offset, 0)        # output_count = 0
    memory_set_integer(stmt, input_constraints_offset, 0)   # input_constraints = NULL
    memory_set_integer(stmt, input_count_offset, 0)         # input_count = 0
    memory_set_integer(stmt, clobber_list_offset, 0)        # clobber_list = NULL
    memory_set_integer(stmt, clobber_count_offset, 0)       # clobber_count = 0

    # Parse assembly instruction lines
    Let capacity be 0
    Let continue_assembly be 1
    While continue_assembly is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 10:
            Let line_count be memory_get_integer(stmt, assembly_line_count_offset)

            # Expand arrays if needed
            If line_count is greater than or equal to capacity:
                If capacity is equal to 0:
                    Set capacity to 4
                Otherwise:
                    Set capacity to capacity multiplied by 2
                End If

                Let ptr_size be 8
                Let lines_size be capacity multiplied by ptr_size
                Let old_lines be memory_get_integer(stmt, assembly_lines_offset)
                Let new_lines be memory_reallocate(old_lines, lines_size)
                memory_set_integer(stmt, assembly_lines_offset, new_lines)

                Let old_notes be memory_get_integer(stmt, assembly_notes_offset)
                Let new_notes be memory_reallocate(old_notes, lines_size)
                memory_set_integer(stmt, assembly_notes_offset, new_notes)
            End If

            # Parse assembly instruction string
            Let token_value be memory_get_pointer(current_token, 8)
            Let instruction_str be string_duplicate_parser(token_value)

            Let assembly_lines be memory_get_integer(stmt, assembly_lines_offset)
            Let line_offset be line_count multiplied by 8
            Let line_ptr be assembly_lines plus line_offset
            memory_set_integer(line_ptr, 0, instruction_str)

            Let dummy4 be parser_advance(parser)

            # Expect "Note:" comment
            Let note_token be memory_get_pointer(parser, 8)
            Let note_token_type be memory_get_integer(note_token, 0)
            If note_token_type is not equal to 123:
                Let error_msg be "[PARSER ERROR] Expected Note: comment after assembly instruction at line "
                print_string(error_msg)
                Let line be memory_get_integer(note_token, 16)
                print_integer(line)
                print_newline()
                exit_with_code(1)
            End If
            Let dummy5 be parser_eat(parser, 123)
            Let dummy6 be parser_eat(parser, 9)

            # Parse note text
            Let note_str be string_duplicate_parser("Assembly instruction")
            Let next_token be memory_get_pointer(parser, 8)
            Let next_token_type be memory_get_integer(next_token, 0)
            If next_token_type is equal to 53:
                Let note_value be memory_get_pointer(next_token, 8)
                deallocate(note_str)
                Set note_str to string_duplicate_parser(note_value)
                Let dummy7 be parser_advance(parser)
            End If

            Let assembly_notes be memory_get_integer(stmt, assembly_notes_offset)
            Let note_ptr be assembly_notes plus line_offset
            memory_set_integer(note_ptr, 0, note_str)

            Let new_line_count be line_count plus 1
            memory_set_integer(stmt, assembly_line_count_offset, new_line_count)
        Otherwise:
            Set continue_assembly to 0
        End If
    End While

    # Parse constraints
    Let constraint_token be memory_get_pointer(parser, 8)
    Let constraint_token_type be memory_get_integer(constraint_token, 0)
    While constraint_token_type is not equal to 8:
        Let dummy8 be parser_advance(parser)
        Set constraint_token to memory_get_pointer(parser, 8)
        Set constraint_token_type to memory_get_integer(constraint_token, 0)
    End While

    Let dummy9 be parser_eat(parser, 8)
    Let dummy10 be parser_eat(parser, 122)

    Return stmt
End Process

# Parser parse match statement - handles "Match expression: When variant: ... End When ... End Match"
Process called "parser_parse_match_statement" takes parser as Integer returns Integer:
    Let dummy1 be parser_eat(parser, 112)
    Let expression be parser_parse_expression(parser)
    Let dummy2 be parser_eat(parser, 9)

    # Create match statement structure
    Let stmt_size be 32
    Let stmt be memory_allocate(stmt_size)
    memory_set_integer(stmt, 0, STMT_MATCH)
    memory_set_integer(stmt, 8, expression)     # match_stmt.expression
    memory_set_integer(stmt, 16, 0)             # match_stmt.cases = NULL
    memory_set_integer(stmt, 24, 0)             # match_stmt.case_count = 0

    # Parse match cases
    Let continue_cases be 1
    While continue_cases is equal to 1:
        Let current_token be memory_get_pointer(parser, 8)
        Let token_type be memory_get_integer(current_token, 0)

        If token_type is equal to 113:
            Let dummy3 be parser_eat(parser, 113)

            # Parse variant name
            Let variant_token be memory_get_pointer(parser, 8)
            Let variant_token_type be memory_get_integer(variant_token, 0)
            If variant_token_type is not equal to 53:
                Let error_msg be "[PARSER ERROR] Expected variant name after 'When' at line "
                print_string(error_msg)
                Let line be memory_get_integer(variant_token, 16)
                print_integer(line)
                print_newline()
                exit_with_code(1)
            End If

            Let variant_name_value be memory_get_pointer(variant_token, 8)
            Let variant_name be string_duplicate_parser(variant_name_value)
            Let dummy4 be parser_eat(parser, 53)

            # Parse optional field bindings
            Let field_names be 0
            Let field_count be 0
            Let with_token be memory_get_pointer(parser, 8)
            Let with_token_type be memory_get_integer(with_token, 0)
            If with_token_type is equal to 114:
                Let dummy5 be parser_eat(parser, 114)

                # Parse field bindings
                Let field_capacity be 10
                Let ptr_size be 8
                Let field_array_size be field_capacity multiplied by ptr_size
                Set field_names to memory_allocate(field_array_size)

                Let continue_fields be 1
                While continue_fields is equal to 1:
                    # Parse field name (consume)
                    Let field_token be memory_get_pointer(parser, 8)
                    Let field_token_type be memory_get_integer(field_token, 0)
                    If field_token_type is not equal to 53:
                        Let error_msg2 be "[PARSER ERROR] Expected field name in match case at line "
                        print_string(error_msg2)
                        Let line2 be memory_get_integer(field_token, 16)
                        print_integer(line2)
                        print_newline()
                        exit_with_code(1)
                    End If
                    Let dummy6 be parser_eat(parser, 53)
                    Let dummy7 be parser_eat(parser, 34)

                    # Parse binding variable
                    Let binding_token be memory_get_pointer(parser, 8)
                    Let binding_token_type be memory_get_integer(binding_token, 0)
                    If binding_token_type is not equal to 53:
                        Let error_msg3 be "[PARSER ERROR] Expected binding variable name at line "
                        print_string(error_msg3)
                        Let line3 be memory_get_integer(binding_token, 16)
                        print_integer(line3)
                        print_newline()
                        exit_with_code(1)
                    End If

                    Let binding_value be memory_get_pointer(binding_token, 8)
                    Let binding_name be string_duplicate_parser(binding_value)
                    Let field_offset be field_count multiplied by ptr_size
                    Let field_ptr be field_names plus field_offset
                    memory_set_integer(field_ptr, 0, binding_name)
                    Set field_count to field_count plus 1

                    Let dummy8 be parser_eat(parser, 53)

                    # Check for "and" to continue
                    Let and_token be memory_get_pointer(parser, 8)
                    Let and_token_type be memory_get_integer(and_token, 0)
                    If and_token_type is equal to 30:
                        Let dummy9 be parser_eat(parser, 30)
                    Otherwise:
                        Set continue_fields to 0
                    End If
                End While
            End If

            Let dummy10 be parser_eat(parser, 9)

            # Parse case body
            Let body_count_ptr be memory_allocate(8)
            Let body be parser_parse_statement_block(parser, body_count_ptr)
            Let body_count be memory_get_integer(body_count_ptr, 0)
            deallocate(body_count_ptr)

            Let dummy11 be parser_eat(parser, 8)
            Let dummy12 be parser_eat(parser, 113)

            # Add match case
            Let current_case_count be memory_get_integer(stmt, 24)
            Let new_case_count be current_case_count plus 1
            memory_set_integer(stmt, 24, new_case_count)

            Let case_size be 32  # sizeof(MatchCase)
            Let cases_size be new_case_count multiplied by case_size
            Let old_cases be memory_get_pointer(stmt, 16)
            Let new_cases be memory_reallocate(old_cases, cases_size)
            memory_set_pointer(stmt, 16, new_cases)

            # Fill in the new case
            Let case_offset be current_case_count multiplied by case_size
            Let case_ptr be new_cases plus case_offset
            memory_set_pointer(case_ptr, 0, variant_name)      # variant_name
            memory_set_integer(case_ptr, 8, field_names)       # field_names
            memory_set_integer(case_ptr, 16, field_count)      # field_count
            memory_set_integer(case_ptr, 24, body)             # body
            # Note: body_count stored in variant_name offset plus4
        Otherwise:
            Set continue_cases to 0
        End If
    End While

    Let dummy13 be parser_eat(parser, 8)
    Let dummy14 be parser_eat(parser, 112)

    Return stmt
End Process

# Calculate size of a type in bytes (helper function)
Process called "calculate_type_size" takes type_name as Integer, program as Integer returns Integer:
    # Built-in types
    Let integer_str be "Integer"
    If string_equals(type_name, integer_str) is equal to 1:
        Return 8  # 64-bit integer
    End If

    Let byte_str be "Byte"
    If string_equals(type_name, byte_str) is equal to 1:
        Return 1  # 8-bit byte
    End If

    Let short_str be "Short"
    If string_equals(type_name, short_str) is equal to 1:
        Return 2  # 16-bit short
    End If

    Let long_str be "Long"
    If string_equals(type_name, long_str) is equal to 1:
        Return 8  # 64-bit long
    End If

    # Custom types - look up in the program
    If program is not equal to 0:
        Let type_count be memory_get_integer(program, 24)
        Let types be memory_get_pointer(program, 16)
        Let i be 0
        Let continue_lookup be 1
        While continue_lookup is equal to 1:
            Let is_complete be 0
            If i is greater than or equal to type_count:
                Let is_complete be 1
            End If
            If is_complete is equal to 1:
                Let continue_lookup be 0
            End If
            If is_complete is equal to 0:
                Let ptr_size be 8
                Let offset be i multiplied by ptr_size
                Let type_ptr be types plus offset
                Let type_def be memory_get_integer(type_ptr, 0)
                Let current_type_name be memory_get_pointer(type_def, 0)
                Let name_match be string_equals(current_type_name, type_name)
                If name_match is equal to 1:
                    Let type_size be memory_get_integer(type_def, 40)  # TypeDefinition.size offset
                    Return type_size
                End If
                Let i be i plus 1
            End If
        End While
    End If

    # Unknown type - default to 8 bytes and warn
    Let warning_msg be "[PARSER WARNING] Unknown type '"
    print_string(warning_msg)
    print_string(type_name)
    Let warning_msg2 be "', defaulting to 8 bytes"
    print_string(warning_msg2)
    print_newline()
    Return 8
End Process

Process called "parser_parse_type_definition" takes parser as Integer returns Integer:
    # Parse: Type called "name": OR Type Name is
    parser_eat(parser, 50)

    Let type be memory_allocate(TypeDefinition_SIZE)

    # Check for "called" syntax for struct types
    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)

    If token_type is equal to 2:
        parser_eat(parser, 2)

        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
        If token_type is not equal to 10:
            print_string("[PARSER ERROR] Expected type name at line ")
            Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
            print_integer(line)
            print_newline()
            exit(1)
        End If

        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
        Let type_name be string_duplicate(token_value)
        memory_set_pointer(type, TYPEDEFINITION_NAME_OFFSET, type_name)
        parser_eat(parser, 10)
        parser_eat(parser, 9)

        # This is a struct type
        memory_set_integer(type, TYPEDEFINITION_KIND_OFFSET, TYPE_KIND_STRUCT)
        memory_set_pointer(type, TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET, 0)
        memory_set_integer(type, TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET, 0)
        Let current_offset be 0

        # Parse field declarations until "End Type"
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
        While token_type is not equal to 8:
            # Parse field: name as Type
            If token_type is not equal to 53:
                print_string("[PARSER ERROR] Expected field name at line ")
                Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
                print_integer(line)
                print_string(" (got token type ")
                print_integer(token_type)
                print_string(")")
                print_newline()
                exit(1)
            End If

            Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
            Let field_name be string_duplicate(token_value)
            parser_eat(parser, 53)
            parser_eat(parser, 34)

            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
            If token_type is not equal to 4:
                If token_type is not equal to 5:
                    If token_type is not equal to 6:
                        If token_type is not equal to 53:
                            print_string("[PARSER ERROR] Expected field type at line ")
                            Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
                            print_integer(line)
                            print_newline()
                            exit(1)
                        End If
                    End If
                End If
            End If

            Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
            Let field_type be string_duplicate(token_value)
            If token_type is equal to 4:
                parser_eat(parser, 4)
            End If
            If token_type is equal to 5:
                parser_eat(parser, 5)
            End If
            If token_type is equal to 6:
                parser_eat(parser, 6)
            End If
            If token_type is equal to 53:
                parser_eat(parser, 53)
            End If

            # Check for comma after field declaration (optional for last field)
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
            If token_type is equal to 52:
                parser_eat(parser, 52)
            End If

            # Add field to type
            Let field_count be memory_get_integer(type, TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET)
            Let new_field_count be field_count plus 1
            memory_set_integer(type, TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET, new_field_count)

            Let fields be memory_get_pointer(type, TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET)
            Let new_fields_size be new_field_count multiplied by TYPEFIELD_SIZE
            Let new_fields be memory_reallocate(fields, new_fields_size)
            memory_set_pointer(type, TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET, new_fields)

            Let field_index be new_field_count minus 1
            Let field_offset be field_index multiplied by TYPEFIELD_SIZE
            Let field be new_fields plus field_offset
            memory_set_pointer(field, TYPEFIELD_NAME_OFFSET, field_name)
            memory_set_pointer(field, TYPEFIELD_TYPE_OFFSET, field_type)
            memory_set_integer(field, TYPEFIELD_OFFSET_OFFSET, current_offset)

            # Calculate field size based on type
            Let current_program be memory_get_pointer(parser, PARSER_CURRENT_PROGRAM_OFFSET)
            Let field_size be calculate_type_size(field_type, current_program)
            memory_set_integer(field, TYPEFIELD_SIZE_OFFSET, field_size)
            Let current_offset be current_offset plus field_size

            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
        End While

        memory_set_integer(type, TYPEDEFINITION_SIZE_OFFSET, current_offset)

        parser_eat(parser, 8)
        parser_eat(parser, 50)
    End If

    # Check for variant syntax: Type Name is | Variant1 ...
    If token_type is equal to 53:
        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
        Let type_name be string_duplicate(token_value)
        memory_set_pointer(type, TYPEDEFINITION_NAME_OFFSET, type_name)
        parser_eat(parser, 53)
        parser_eat(parser, 21)

        # Check for array type: Type X is: array[size] of ElementType
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
        If token_type is equal to 9:
            parser_eat(parser, 9)

            # Now check if it's an array type
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
            If token_type is equal to 126:
                parser_eat(parser, 126)
                parser_eat(parser, 127)

                # Parse array size
                Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
                If token_type is not equal to 11:
                    print_string("[PARSER ERROR] Expected array size at line ")
                    Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
                    print_integer(line)
                    print_newline()
                    exit(1)
                End If
                Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
                Let array_length be string_to_integer(token_value)
                parser_eat(parser, 11)
                parser_eat(parser, 128)
                parser_eat(parser, 125)

                # Parse element type
                Let element_type be 0
                Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
                If token_type is equal to 4:
                    Let element_type be string_duplicate("Integer")
                    parser_eat(parser, 4)
                End If
                If token_type is equal to 5:
                    Let element_type be string_duplicate("String")
                    parser_eat(parser, 5)
                End If
                If token_type is equal to 6:
                    Let element_type be string_duplicate("Character")
                    parser_eat(parser, 6)
                End If
                If token_type is equal to 53:
                    Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
                    Let element_type be string_duplicate(token_value)
                    parser_eat(parser, 53)
                End If
                If element_type is equal to 0:
                    print_string("[PARSER ERROR] Expected element type at line ")
                    Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
                    print_integer(line)
                    print_newline()
                    exit(1)
                End If

                # Setup array type
                memory_set_integer(type, TYPEDEFINITION_KIND_OFFSET, TYPE_KIND_ARRAY)
                memory_set_pointer(type, TYPEDEFINITION_DATA_ARRAY_ELEMENT_TYPE_OFFSET, element_type)
                memory_set_integer(type, TYPEDEFINITION_DATA_ARRAY_LENGTH_OFFSET, array_length)

                # Calculate element size (8 bytes for Integer, custom types handled separately)
                memory_set_integer(type, TYPEDEFINITION_DATA_ARRAY_ELEMENT_SIZE_OFFSET, 8)
                Let total_size be array_length multiplied by 8
                memory_set_integer(type, TYPEDEFINITION_SIZE_OFFSET, total_size)

                # Parse "End Type" after array type definition
                parser_eat(parser, 8)
                parser_eat(parser, 50)
            Otherwise:
                print_string("[PARSER ERROR] Expected array or variant declaration after colon at line ")
                Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
                print_integer(line)
                print_newline()
                exit(1)
            End If
        End If

        # Check for function pointer type: Type X is Pointer to Process ...
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
        If token_type is equal to 124:
            parser_eat(parser, 124)
            parser_eat(parser, 15)
            parser_eat(parser, 1)

            # This is a function pointer type
            memory_set_integer(type, TYPEDEFINITION_KIND_OFFSET, TYPE_KIND_FUNCTION)
            memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_PARAM_TYPES_OFFSET, 0)
            memory_set_integer(type, TYPEDEFINITION_DATA_FUNCTION_PARAM_COUNT_OFFSET, 0)
            memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_RETURN_TYPE_OFFSET, 0)
            memory_set_integer(type, TYPEDEFINITION_SIZE_OFFSET, 8)  # Pointer size on x86_64

            # Parse optional parameters: [that] takes param1 as Type1, param2 as Type2
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
            If token_type is equal to 32:
                parser_eat(parser, 32)
                parser_eat(parser, 33)
            End If
            If token_type is equal to 33:
                parser_eat(parser, 33)
            End If

            # Parse parameters if we have takes
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
            If token_type is equal to 53:
                Let param_capacity be 2
                Let param_types be memory_allocate(param_capacity multiplied by 8)  # Array of char* pointers
                memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_PARAM_TYPES_OFFSET, param_types)

                Let continue_parsing be 1
                While continue_parsing is equal to 1:
                    # Skip parameter name (we only store types for function pointers)
                    If token_type is equal to 53:
                        parser_eat(parser, 53)
                        parser_eat(parser, 34)
                    End If

                    # Get parameter type
                    Let param_type be 0
                    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                    Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
                    If token_type is equal to 4:
                        Let param_type be string_duplicate("Integer")
                        parser_eat(parser, 4)
                    End If
                    If token_type is equal to 5:
                        Let param_type be string_duplicate("String")
                        parser_eat(parser, 5)
                    End If
                    If token_type is equal to 6:
                        Let param_type be string_duplicate("Character")
                        parser_eat(parser, 6)
                    End If
                    If token_type is equal to 53:
                        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
                        Let param_type be string_duplicate(token_value)
                        parser_eat(parser, 53)
                    End If
                    If param_type is equal to 0:
                        print_string("[PARSER ERROR] Expected parameter type at line ")
                        Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
                        print_integer(line)
                        print_newline()
                        exit(1)
                    End If

                    # Expand array if needed
                    Let param_count be memory_get_integer(type, TYPEDEFINITION_DATA_FUNCTION_PARAM_COUNT_OFFSET)
                    If param_count is greater than or equal to param_capacity:
                        Let param_capacity be param_capacity multiplied by 2
                        Let new_param_types be memory_reallocate(param_types, param_capacity multiplied by 8)
                        memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_PARAM_TYPES_OFFSET, new_param_types)
                        Let param_types be new_param_types
                    End If

                    Let param_offset be param_count multiplied by 8
                    memory_set_pointer(param_types plus param_offset, 0, param_type)
                    Let new_param_count be param_count plus 1
                    memory_set_integer(type, TYPEDEFINITION_DATA_FUNCTION_PARAM_COUNT_OFFSET, new_param_count)

                    # Check for more parameters (comma or 'and')
                    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                    Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
                    If token_type is equal to 52:
                        parser_eat(parser, 52)
                    End If
                    If token_type is equal to 30:
                        parser_eat(parser, 30)
                    Otherwise:
                        Let continue_parsing be 0
                    End If
                End While
            End If

            # Parse return type: returns Type
            parser_eat(parser, 3)
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
            If token_type is equal to 4:
                Let return_type be string_duplicate("Integer")
                memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_RETURN_TYPE_OFFSET, return_type)
                parser_eat(parser, 4)
            End If
            If token_type is equal to 5:
                Let return_type be string_duplicate("String")
                memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_RETURN_TYPE_OFFSET, return_type)
                parser_eat(parser, 5)
            End If
            If token_type is equal to 6:
                Let return_type be string_duplicate("Character")
                memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_RETURN_TYPE_OFFSET, return_type)
                parser_eat(parser, 6)
            End If
            If token_type is equal to 53:
                Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
                Let return_type be string_duplicate(token_value)
                memory_set_pointer(type, TYPEDEFINITION_DATA_FUNCTION_RETURN_TYPE_OFFSET, return_type)
                parser_eat(parser, 53)
            Otherwise:
                print_string("[PARSER ERROR] Expected return type at line ")
                Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
                print_integer(line)
                print_newline()
                exit(1)
            End If
        Otherwise:
            # Otherwise this is a variant type
            memory_set_integer(type, TYPEDEFINITION_KIND_OFFSET, TYPE_KIND_VARIANT)
            memory_set_pointer(type, TYPEDEFINITION_DATA_VARIANT_VARIANTS_OFFSET, 0)
            memory_set_integer(type, TYPEDEFINITION_DATA_VARIANT_VARIANT_COUNT_OFFSET, 0)

            # Parse variants
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
            While token_type is equal to 111:
                parser_eat(parser, 111)

                # Parse variant name
                Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
                If token_type is not equal to 53:
                    print_string("[PARSER ERROR] Expected variant name at line ")
                    Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
                    print_integer(line)
                    print_newline()
                    exit(1)
                End If

                # Add variant
                Let variant_count be memory_get_integer(type, TYPEDEFINITION_DATA_VARIANT_VARIANT_COUNT_OFFSET)
                Let new_variant_count be variant_count plus 1
                memory_set_integer(type, TYPEDEFINITION_DATA_VARIANT_VARIANT_COUNT_OFFSET, new_variant_count)

                Let variants be memory_get_pointer(type, TYPEDEFINITION_DATA_VARIANT_VARIANTS_OFFSET)
                Let new_variants_size be new_variant_count multiplied by VARIANT_SIZE
                Let new_variants be memory_reallocate(variants, new_variants_size)
                memory_set_pointer(type, TYPEDEFINITION_DATA_VARIANT_VARIANTS_OFFSET, new_variants)

                Let variant_index be new_variant_count minus 1
                Let variant_offset be variant_index multiplied by VARIANT_SIZE
                Let variant be new_variants plus variant_offset
                Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
                Let variant_name be string_duplicate(token_value)
                memory_set_pointer(variant, VARIANT_NAME_OFFSET, variant_name)
                memory_set_pointer(variant, VARIANT_FIELDS_OFFSET, 0)
                memory_set_integer(variant, VARIANT_FIELD_COUNT_OFFSET, 0)
                Let tag be new_variant_count minus 1  # Tag is 0-based index
                memory_set_integer(variant, VARIANT_TAG_OFFSET, tag)

                parser_eat(parser, 53)

                # Parse optional variant fields
                Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
                If token_type is equal to 114:
                    parser_eat(parser, 114)

                    Let field_offset be 8  # Start after tag (8 bytes for tag)

                    # Parse fields: field1 as Type1 and field2 as Type2...
                    Let continue_parsing be 1
                    While continue_parsing is equal to 1:
                        # Parse field name
                        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                        Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
                        If token_type is not equal to 53:
                            print_string("[PARSER ERROR] Expected field name in variant at line ")
                            Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
                            print_integer(line)
                            print_newline()
                            exit(1)
                        End If

                        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
                        Let field_name be string_duplicate(token_value)
                        parser_eat(parser, 53)
                        parser_eat(parser, 34)

                        # Parse field type
                        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                        Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
                        If token_type is not equal to 4:
                            If token_type is not equal to 5:
                                If token_type is not equal to 6:
                                    If token_type is not equal to 53:
                                        print_string("[PARSER ERROR] Expected field type at line ")
                                        Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
                                        print_integer(line)
                                        print_newline()
                                        exit(1)
                                    End If
                                End If
                            End If
                        End If

                        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
                        Let field_type be string_duplicate(token_value)
                        If token_type is equal to 4:
                            parser_eat(parser, 4)
                        End If
                        If token_type is equal to 5:
                            parser_eat(parser, 5)
                        End If
                        If token_type is equal to 6:
                            parser_eat(parser, 6)
                        End If
                        If token_type is equal to 53:
                            parser_eat(parser, 53)
                        End If

                        # Add field to variant
                        Let variant_field_count be memory_get_integer(variant, VARIANT_FIELD_COUNT_OFFSET)
                        Let new_variant_field_count be variant_field_count plus 1
                        memory_set_integer(variant, VARIANT_FIELD_COUNT_OFFSET, new_variant_field_count)

                        Let variant_fields be memory_get_pointer(variant, VARIANT_FIELDS_OFFSET)
                        Let new_variant_fields_size be new_variant_field_count multiplied by TYPEFIELD_SIZE
                        Let new_variant_fields be memory_reallocate(variant_fields, new_variant_fields_size)
                        memory_set_pointer(variant, VARIANT_FIELDS_OFFSET, new_variant_fields)

                        Let variant_field_index be new_variant_field_count minus 1
                        Let variant_field_offset be variant_field_index multiplied by TYPEFIELD_SIZE
                        Let field be new_variant_fields plus variant_field_offset
                        memory_set_pointer(field, TYPEFIELD_NAME_OFFSET, field_name)
                        memory_set_pointer(field, TYPEFIELD_TYPE_OFFSET, field_type)
                        memory_set_integer(field, TYPEFIELD_OFFSET_OFFSET, field_offset)

                        Let current_program be memory_get_pointer(parser, PARSER_CURRENT_PROGRAM_OFFSET)
                        Let field_size be calculate_type_size(field_type, current_program)
                        memory_set_integer(field, TYPEFIELD_SIZE_OFFSET, field_size)
                        Let field_offset be field_offset plus field_size

                        # Check for "and" to continue with more fields
                        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                        Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
                        If token_type is equal to 30:
                            parser_eat(parser, 30)
                        Otherwise:
                            Let continue_parsing be 0
                        End If
                    End While
                End If

                Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
            End While

            # Calculate max size needed for any variant
            memory_set_integer(type, TYPEDEFINITION_SIZE_OFFSET, 8)  # At least tag size
            Let variant_count be memory_get_integer(type, TYPEDEFINITION_DATA_VARIANT_VARIANT_COUNT_OFFSET)
            Let variants be memory_get_pointer(type, TYPEDEFINITION_DATA_VARIANT_VARIANTS_OFFSET)
            Let i be 0
            While i is less than variant_count:
                Let variant_offset be i multiplied by VARIANT_SIZE
                Let variant be variants plus variant_offset
                Let variant_size be 8  # Tag size
                Let variant_field_count be memory_get_integer(variant, VARIANT_FIELD_COUNT_OFFSET)
                Let variant_fields be memory_get_pointer(variant, VARIANT_FIELDS_OFFSET)
                Let j be 0
                While j is less than variant_field_count:
                    Let field_offset be j multiplied by TYPEFIELD_SIZE
                    Let field be variant_fields plus field_offset
                    Let field_size be memory_get_integer(field, TYPEFIELD_SIZE_OFFSET)
                    Let variant_size be variant_size plus field_size
                    Let j be j plus 1
                End While
                Let current_type_size be memory_get_integer(type, TYPEDEFINITION_SIZE_OFFSET)
                If variant_size is greater than current_type_size:
                    memory_set_integer(type, TYPEDEFINITION_SIZE_OFFSET, variant_size)
                End If
                Let i be i plus 1
            End While
        End If
    Otherwise:
        print_string("[PARSER ERROR] Expected 'called' or type name after 'Type' at line ")
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
        print_newline()
        exit(1)
    End If

    Return type
End Process

Process called "parser_parse_function" takes parser as Integer returns Integer:
    # Parse: Process called "name" [that takes param as Type] returns Type:
    parser_eat(parser, 1)
    parser_eat(parser, 2)

    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
    If token_type is not equal to 10:
        print_string("[PARSER ERROR] Expected function name string literal (type ")
        print_integer(10)
        print_string("), got type ")
        print_integer(token_type)
        print_string(" at line ")
        Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
        print_integer(line)
        print_newline()
        exit(1)
    End If

    Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
    Let func_name be string_duplicate(token_value)
    parser_eat(parser, 10)

    Let default_return_type be string_duplicate("Integer")
    Let func be function_create(func_name, default_return_type)

    # Check for parameters: "takes param as Type" or "takes x as Type, y as Type"
    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
    If token_type is equal to 33:
        parser_eat(parser, 33)

        # Parse first parameter
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
        If token_type is not equal to 53:
            print_string("[PARSER ERROR] Expected parameter name at line ")
            Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
            print_integer(line)
            print_newline()
            exit(1)
        End If

        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
        Let param_name be string_duplicate(token_value)
        parser_eat(parser, 53)
        parser_eat(parser, 34)

        # Accept built-in types or custom type names (for function pointers and structs)
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
        If token_type is not equal to 4:
            If token_type is not equal to 5:
                If token_type is not equal to 6:
                    If token_type is not equal to 53:
                        print_string("[PARSER ERROR] Expected parameter type at line ")
                        Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
                        print_integer(line)
                        print_newline()
                        exit(1)
                    End If
                End If
            End If
        End If

        Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
        Let param_type be string_duplicate(token_value)
        If token_type is equal to 4:
            parser_eat(parser, 4)
        End If
        If token_type is equal to 5:
            parser_eat(parser, 5)
        End If
        If token_type is equal to 6:
            parser_eat(parser, 6)
        End If
        If token_type is equal to 53:
            # Custom type name (struct, variant, or function pointer)
            parser_eat(parser, 53)
        End If

        function_add_parameter(func, param_name, param_type)

        # Parse additional parameters separated by commas
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
        While token_type is equal to 52:
            parser_eat(parser, 52)

            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
            If token_type is not equal to 53:
                print_string("[PARSER ERROR] Expected parameter name after comma at line ")
                Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
                print_integer(line)
                print_newline()
                exit(1)
            End If

            Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
            Let param_name be string_duplicate(token_value)
            parser_eat(parser, 53)
            parser_eat(parser, 34)

            # Accept built-in types or custom type names (for function pointers and structs)
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
            If token_type is not equal to 4:
                If token_type is not equal to 5:
                    If token_type is not equal to 6:
                        If token_type is not equal to 53:
                            print_string("[PARSER ERROR] Expected parameter type at line ")
                            Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
                            print_integer(line)
                            print_newline()
                            exit(1)
                        End If
                    End If
                End If
            End If

            Let token_value be memory_get_pointer(current_token, TOKEN_VALUE_OFFSET)
            Let param_type be string_duplicate(token_value)
            If token_type is equal to 4:
                parser_eat(parser, 4)
            End If
            If token_type is equal to 5:
                parser_eat(parser, 5)
            End If
            If token_type is equal to 6:
                parser_eat(parser, 6)
            End If
            If token_type is equal to 53:
                # Custom type name (struct, variant, or function pointer)
                parser_eat(parser, 53)
            End If

            function_add_parameter(func, param_name, param_type)

            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
        End While
    End If

    parser_eat(parser, 3)

    # Handle different return types
    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
    Let type_handled be 0
    If token_type is equal to 4:
        parser_eat(parser, 4)
        Let type_handled be 1
    End If
    If type_handled is equal to 0:
        If token_type is equal to 5:
            parser_eat(parser, 5)
            Let type_handled be 1
        End If
    End If
    If type_handled is equal to 0:
        If token_type is equal to 6:
            parser_eat(parser, 6)
            Let type_handled be 1
        End If
    End If
    If type_handled is equal to 0:
        If token_type is equal to 53:
            # Custom type
            parser_eat(parser, 53)
            Let type_handled be 1
        End If
    End If
    If type_handled is equal to 0:
        print_string("[PARSER ERROR] Expected return type at line ")
        Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
        print_integer(line)
        print_newline()
        exit(1)
    End If

    parser_eat(parser, 9)

    # Parse function body statements
    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
    While token_type is not equal to 7:
        If token_type is equal to 8:
            # Exit if we hit End Process before Return
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
            Break
        End If
        If token_type is equal to 0:
            Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
            Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
            Break
        End If

        Let stmt be 0

        If token_type is equal to 12:
            Let stmt be parser_parse_let_statement(parser)
        End If
        If token_type is equal to 14:
            Let stmt be parser_parse_set_statement(parser)
        End If
        If token_type is equal to 18:
            Let stmt be parser_parse_if_statement(parser)
        End If
        If token_type is equal to 20:
            Let stmt be parser_parse_while_statement(parser)
        End If
        If token_type is equal to 112:
            Let stmt be parser_parse_match_statement(parser)
        End If
        If token_type is equal to 47:
            Let stmt be parser_parse_print_statement(parser)
        End If
        If token_type is equal to 121:
            Let stmt be parser_parse_inline_assembly_statement(parser)
        End If
        If token_type is equal to 53:
            # Try to parse as expression (could be a function call)
            Let expr be parser_parse_expression(parser)
            # Only function calls are valid as standalone statements
            Let expr_type be memory_get_integer(expr, EXPRESSION_TYPE_OFFSET)
            If expr_type is equal to EXPR_FUNCTION_CALL:
                Let stmt be statement_create_expression(expr)
            Otherwise:
                # Other expressions are not valid as statements
                print_string("[PARSER ERROR] Only function calls can be used as statements (got expr_type=")
                print_integer(expr_type)
                print_string(", expected ")
                print_integer(EXPR_FUNCTION_CALL)
                print_string(") at line ")
                Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
                print_integer(line)
                print_newline()
                exit(1)
            End If
        End If

        Let is_builtin be parser_is_builtin_function_token(token_type)
        If is_builtin is equal to 1:
            # Parse builtin function call as expression statement
            Let expr be parser_parse_expression(parser)
            Let expr_type be memory_get_integer(expr, EXPRESSION_TYPE_OFFSET)
            If expr_type is equal to EXPR_BUILTIN_CALL:
                Let stmt be statement_create_expression(expr)
            Otherwise:
                print_string("[PARSER ERROR] Invalid builtin function statement at line ")
                Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
                print_integer(line)
                print_newline()
                exit(1)
            End If
        End If

        If stmt is equal to 0:
            print_string("[PARSER ERROR] Unexpected token in function body at line ")
            Let line be memory_get_integer(current_token, TOKEN_LINE_OFFSET)
            print_integer(line)
            print_newline()
            exit(1)
        End If

        function_add_statement(func, stmt)

        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
    End While

    # Parse Return statement
    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
    If token_type is equal to 7:
        Let return_stmt be parser_parse_return_statement(parser)
        function_add_statement(func, return_stmt)
    End If

    # Parse: End Process
    parser_eat(parser, 8)
    parser_eat(parser, 1)

    Return func
End Process

# Size constants for structures
Let SIZEOF_PARSER be 24
Let SIZEOF_PROGRAM be 64

# Offsets for parser structure
Let PARSER_LEXER be 0           # Lexer *lexer
Let PARSER_CURRENT_TOKEN be 8   # Token *current_token
Let PARSER_CURRENT_PROGRAM_OFFSET be 16 # Program *current_program

# Program structure offsets already defined at the top of file

# Token structure offsets
Let TOKEN_TYPE_OFFSET be 0      # TokenType type
Let TOKEN_VALUE_OFFSET be 8     # char *value
Let TOKEN_LINE_OFFSET be 16     # int line_number

# Additional expression types missing
Let EXPR_UNARY be 11
Let EXPR_BINARY be 2  # Alias for EXPR_BINARY_OP
Let EXPR_CALL be 4    # Alias for EXPR_FUNCTION_CALL
Let EXPR_ARRAY_ACCESS be 16  # Alias for EXPR_ARRAY_INDEX
Let EXPR_IDENTIFIER be 1     # Alias for EXPR_VARIABLE

# Statement types already defined above

# Statement structure offsets
Let STMT_TYPE be 0
Let STMT_LET_NAME be 8
Let STMT_LET_VALUE be 16
Let STMT_LET_TYPE be 24
Let STMT_SET_NAME be 8
Let STMT_SET_VALUE be 16
Let STMT_IF_CONDITION be 8
Let STMT_IF_THEN_BODY be 16
Let STMT_IF_ELSE_BODY be 24
Let STMT_WHILE_CONDITION be 8
Let STMT_WHILE_BODY be 16
Let STMT_FOR_VAR be 8
Let STMT_FOR_START be 16
Let STMT_FOR_END be 24
Let STMT_FOR_BODY be 32
Let STMT_RETURN_VALUE be 8
Let STMT_EXPR_VALUE be 8

# Expression structure offsets
Let EXPR_TYPE be 0
Let EXPR_BINARY_LEFT be 8
Let EXPR_BINARY_RIGHT be 16
Let EXPR_UNARY_OPERAND be 8
Let EXPR_CALL_NAME be 8
Let EXPR_CALL_ARGS be 16
Let EXPR_FIELD_OBJECT be 8
Let EXPR_FIELD_NAME be 16
Let EXPR_ARRAY_OBJECT be 8
Let EXPR_ARRAY_INDEX_OFFSET be 16  # Renamed to avoid collision with EXPR_ARRAY_INDEX constant
Let EXPR_IDENTIFIER_NAME be 8
Let EXPR_STRING_VALUE be 8

# Type kinds for destroy functions
Let TYPE_PRIMITIVE be 0
Let TYPE_STRUCT be 1
Let TYPE_ARRAY be 2
Let TYPE_POINTER be 3

# Type structure offsets
Let TYPE_KIND be 0
Let TYPE_STRUCT_NAME be 8
Let TYPE_STRUCT_FIELDS be 16
Let TYPE_ARRAY_ELEMENT_TYPE be 8
Let TYPE_POINTER_TARGET_TYPE be 8

# Function structure offsets
Let FUNCTION_NAME be 0
Let FUNCTION_PARAMETERS be 8
Let FUNCTION_RETURN_TYPE be 16
Let FUNCTION_BODY be 24

# parser_create - Create new parser instance
Process called "parser_create" takes lexer as Integer returns Integer:
    Let parser be memory_allocate(SIZEOF_PARSER)
    memory_set_pointer(parser, PARSER_LEXER, lexer)
    memory_set_pointer(parser, PARSER_CURRENT_TOKEN, lexer_next_token(lexer))
    Return parser
End Process

# parser_destroy - Destroy parser instance
Process called "parser_destroy" takes parser as Integer returns Integer:
    deallocate(parser)
    Return 0
End Process

# parser_parse_program - Main program parsing function
Process called "parser_parse_program" takes parser as Integer returns Integer:
    Let program be memory_allocate(SIZEOF_PROGRAM)
    # Initialize pointers to NULL (0) - they will be allocated when needed
    memory_set_pointer(program, PROGRAM_IMPORTS, 0)
    memory_set_pointer(program, PROGRAM_TYPES, 0)
    memory_set_pointer(program, PROGRAM_FUNCTIONS, 0)
    memory_set_pointer(program, PROGRAM_GLOBAL_VARS, 0)

    # Initialize all count fields to 0
    memory_set_integer(program, PROGRAM_FUNCTION_COUNT, 0)
    memory_set_integer(program, PROGRAM_TYPE_COUNT, 0)
    memory_set_integer(program, PROGRAM_IMPORT_COUNT, 0)
    memory_set_integer(program, PROGRAM_GLOBAL_COUNT, 0)

    # Initialize all capacity fields to 0
    memory_set_integer(program, PROGRAM_FUNCTION_CAPACITY, 0)
    memory_set_integer(program, PROGRAM_TYPE_CAPACITY, 0)
    memory_set_integer(program, PROGRAM_IMPORT_CAPACITY, 0)
    memory_set_integer(program, PROGRAM_GLOBAL_CAPACITY, 0)

    # Set current program for type lookups
    memory_set_pointer(parser, PARSER_CURRENT_PROGRAM_OFFSET, program)

    # Parse imports, type definitions, and functions until EOF
    # Use goto-style loop to avoid If statements inside While
    Let continue_parsing be 1
    While continue_parsing is equal to 1:
        Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
        Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)

        # Check if EOF
        Let is_eof be 0
        If token_type is equal to 0:
            Let is_eof be 1
        End If
        If is_eof is equal to 1:
            Let continue_parsing be 0
        End If

        # Process tokens when not EOF
        If is_eof is equal to 0:
            # Handle TOKEN_IMPORT
            Let is_import be 0
            If token_type is equal to 56:
                Let is_import be 1
            End If
            If is_import is equal to 1:
                Let import_stmt be parser_parse_import(parser)
                program_add_import(program, import_stmt)
            End If

            # Handle TOKEN_TYPE
            Let is_type be 0
            If token_type is equal to 50:
                Let is_type be 1
            End If
            If is_type is equal to 1:
                Let type_def be parser_parse_type_definition(parser)
                program_add_type(program, type_def)
            End If

            # Handle TOKEN_PROCESS
            Let is_process be 0
            If token_type is equal to 1:
                Let is_process be 1
            End If
            If is_process is equal to 1:
                Let func be parser_parse_function(parser)
                program_add_function(program, func)
                # Get current token after adding function
                Let current_after be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                Let type_after be memory_get_integer(current_after, TOKEN_TYPE_OFFSET)
            End If

            # Handle 12
            Let is_let be 0
            If token_type is equal to 12:
                Let is_let be 1
            End If
            If is_let is equal to 1:
                parser_eat(parser, 12)
                Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
                Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)

                Let is_identifier be 0
                If token_type is equal to 53:
                    Let is_identifier be 1
                End If
                If is_identifier is equal to 0:
                    # parser_error_with_token(parser, "Expected identifier after Let", current_token)
                    Return 0
                End If

                Let var_name be string_duplicate_parser(memory_get_pointer(current_token, TOKEN_VALUE_OFFSET))
                parser_eat(parser, 53)
                parser_eat(parser, 13)
                Let initial_value be parser_parse_expression(parser)
                Let global be memory_allocate(24)
                memory_set_pointer(global, 0, var_name)
                memory_set_pointer(global, 8, string_duplicate_parser("Integer"))
                memory_set_pointer(global, 16, initial_value)
                program_add_global(program, global)
            End If

            # Handle unknown token
            Let handled_token be 0
            If is_import is equal to 1:
                Let handled_token be 1
            End If
            If is_type is equal to 1:
                Let handled_token be 1
            End If
            If is_process is equal to 1:
                Let handled_token be 1
            End If
            If is_let is equal to 1:
                Let handled_token be 1
            End If
            If handled_token is equal to 0:
                # parser_error_with_token(parser, "Unexpected token at top level", current_token)
                Return 0
            End If
        End If
    End While

    Return program
End Process

# expression_destroy - Clean up expression objects
Process called "expression_destroy" takes expr as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If

    Let expr_type be memory_get(expr, EXPR_TYPE)

    If expr_type is equal to EXPR_BINARY:
        expression_destroy(memory_get(expr, EXPR_BINARY_LEFT))
        expression_destroy(memory_get(expr, EXPR_BINARY_RIGHT))
    Otherwise If expr_type is equal to EXPR_UNARY:
        expression_destroy(memory_get(expr, EXPR_UNARY_OPERAND))
    Otherwise If expr_type is equal to EXPR_CALL:
        string_destroy(memory_get(expr, EXPR_CALL_NAME))
        # list_destroy_with(memory_get(expr, EXPR_CALL_ARGS), expression_destroy)
    Otherwise If expr_type is equal to EXPR_FIELD_ACCESS:
        expression_destroy(memory_get(expr, EXPR_FIELD_OBJECT))
        string_destroy(memory_get(expr, EXPR_FIELD_NAME))
    Otherwise If expr_type is equal to EXPR_ARRAY_ACCESS:
        expression_destroy(memory_get(expr, EXPR_ARRAY_OBJECT))
        expression_destroy(memory_get(expr, EXPR_ARRAY_INDEX_OFFSET))
    Otherwise If expr_type is equal to EXPR_IDENTIFIER:
        string_destroy(memory_get(expr, EXPR_IDENTIFIER_NAME))
    Otherwise If expr_type is equal to EXPR_STRING_LITERAL:
        string_destroy(memory_get(expr, EXPR_STRING_VALUE))
    End If

    deallocate(expr)
    Return 0
End Process

# statement_destroy - Clean up statement objects
Process called "statement_destroy" takes stmt as Integer returns Integer:
    If stmt is equal to 0:
        Return 0
    End If

    Let stmt_type be memory_get(stmt, STMT_TYPE)

    If stmt_type is equal to STMT_LET:
        string_destroy(memory_get(stmt, STMT_LET_NAME))
        expression_destroy(memory_get(stmt, STMT_LET_VALUE))
        type_destroy(memory_get(stmt, STMT_LET_TYPE))
    Otherwise If stmt_type is equal to STMT_SET:
        string_destroy(memory_get(stmt, STMT_SET_NAME))
        expression_destroy(memory_get(stmt, STMT_SET_VALUE))
    Otherwise If stmt_type is equal to STMT_IF:
        expression_destroy(memory_get(stmt, STMT_IF_CONDITION))
        # list_destroy_with(memory_get(stmt, STMT_IF_THEN_BODY), statement_destroy)
        # list_destroy_with(memory_get(stmt, STMT_IF_ELSE_BODY), statement_destroy)
    Otherwise If stmt_type is equal to STMT_WHILE:
        expression_destroy(memory_get(stmt, STMT_WHILE_CONDITION))
        # list_destroy_with(memory_get(stmt, STMT_WHILE_BODY), statement_destroy)
    Otherwise If stmt_type is equal to STMT_FOR:
        string_destroy(memory_get(stmt, STMT_FOR_VAR))
        expression_destroy(memory_get(stmt, STMT_FOR_START))
        expression_destroy(memory_get(stmt, STMT_FOR_END))
        # list_destroy_with(memory_get(stmt, STMT_FOR_BODY), statement_destroy)
    Otherwise If stmt_type is equal to STMT_RETURN:
        expression_destroy(memory_get(stmt, STMT_RETURN_VALUE))
    Otherwise If stmt_type is equal to STMT_EXPRESSION:
        expression_destroy(memory_get(stmt, STMT_EXPR_VALUE))
    Otherwise If stmt_type is equal to STMT_BREAK:
        # No cleanup needed for break
    Otherwise If stmt_type is equal to STMT_CONTINUE:
        # No cleanup needed for continue
    End If

    deallocate(stmt)
    Return 0
End Process

# function_destroy - Clean up function objects
Process called "function_destroy" takes func as Integer returns Integer:
    If func is equal to 0:
        Return 0
    End If

    string_destroy(memory_get(func, FUNCTION_NAME))
    # list_destroy_with(memory_get(func, FUNCTION_PARAMETERS), param_destroy)
    type_destroy(memory_get(func, FUNCTION_RETURN_TYPE))
    # list_destroy_with(memory_get(func, FUNCTION_BODY), statement_destroy)

    deallocate(func)
    Return 0
End Process

# type_destroy - Clean up type definition objects
Process called "type_destroy" takes type_obj as Integer returns Integer:
    If type_obj is equal to 0:
        Return 0
    End If

    Let type_kind be memory_get(type_obj, TYPE_KIND)

    If type_kind is equal to TYPE_PRIMITIVE:
        # No additional cleanup for primitive types
    Otherwise If type_kind is equal to TYPE_STRUCT:
        string_destroy(memory_get(type_obj, TYPE_STRUCT_NAME))
        # list_destroy_with(memory_get(type_obj, TYPE_STRUCT_FIELDS), field_destroy)
    Otherwise If type_kind is equal to TYPE_ARRAY:
        type_destroy(memory_get(type_obj, TYPE_ARRAY_ELEMENT_TYPE))
    Otherwise If type_kind is equal to TYPE_POINTER:
        type_destroy(memory_get(type_obj, TYPE_POINTER_TARGET_TYPE))
    End If

    deallocate(type_obj)
    Return 0
End Process

# program_destroy - Clean up program objects
Process called "program_destroy" takes program as Integer returns Integer:
    If program is equal to 0:
        Return 0
    End If

    # list_destroy_with(memory_get(program, PROGRAM_IMPORTS), import_destroy)
    # list_destroy_with(memory_get(program, PROGRAM_TYPES), type_destroy)
    # list_destroy_with(memory_get(program, PROGRAM_FUNCTIONS), function_destroy)
    # list_destroy_with(memory_get(program, PROGRAM_GLOBAL_VARS), statement_destroy)

    deallocate(program)
    Return 0
End Process

# string_destroy - String cleanup (alias for memory_free)
Process called "string_destroy" takes str as Integer returns Integer:
    If str is not equal to 0:
        deallocate(str)
    End If
    Return 0
End Process

# param_destroy - Clean up function parameter objects
Process called "param_destroy" takes param as Integer returns Integer:
    If param is equal to 0:
        Return 0
    End If

    # Parameter structure: name (offset 0), type (offset 8)
    string_destroy(memory_get(param, 0))  # param name
    string_destroy(memory_get(param, 8))  # param type
    deallocate(param)
    Return 0
End Process

# field_destroy - Clean up struct/variant field objects
Process called "field_destroy" takes field as Integer returns Integer:
    If field is equal to 0:
        Return 0
    End If

    # Field structure: name (offset 0), type (offset 8)
    string_destroy(memory_get(field, 0))  # field name
    string_destroy(memory_get(field, 8))  # field type
    deallocate(field)
    Return 0
End Process

# import_destroy - Clean up import statement objects
Process called "import_destroy" takes import_stmt as Integer returns Integer:
    If import_stmt is equal to 0:
        Return 0
    End If

    # Import structure: filename (offset 0), module_name (offset 8)
    string_destroy(memory_get(import_stmt, 0))  # filename
    string_destroy(memory_get(import_stmt, 8))  # module_name
    deallocate(import_stmt)
    Return 0
End Process

# parser_parse_import - Parse Import statement: Import "filename" as module_name
Process called "parser_parse_import" takes parser as Integer returns Integer:
    # Parse: Import "filename" as module_name
    parser_eat(parser, 56)

    # Get filename (must be string literal)
    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
    If token_type is not equal to 10:
        # parser_error_with_token(parser, "Expected string literal after Import", current_token)
        Return 0
    End If

    Let filename be string_duplicate_parser(memory_get_pointer(current_token, TOKEN_VALUE_OFFSET))
    parser_eat(parser, 10)

    # Expect "as"
    parser_eat(parser, 34)

    # Get module name (must be identifier)
    Let current_token be memory_get_pointer(parser, PARSER_CURRENT_TOKEN_OFFSET)
    Let token_type be memory_get_integer(current_token, TOKEN_TYPE_OFFSET)
    If token_type is not equal to 53:
        # parser_error_with_token(parser, "Expected module name after 'as'", current_token)
        Return 0
    End If

    Let module_name be string_duplicate_parser(memory_get_pointer(current_token, TOKEN_VALUE_OFFSET))
    parser_eat(parser, 53)

    # Create import object
    Let import_stmt be memory_allocate(16)  # filename + module_name pointers
    memory_set_pointer(import_stmt, 0, filename)    # filename at offset 0
    memory_set_pointer(import_stmt, 8, module_name) # module_name at offset 8

    Return import_stmt
End Process
