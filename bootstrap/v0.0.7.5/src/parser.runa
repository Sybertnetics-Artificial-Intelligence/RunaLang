Import "lexer.runa" as Lexer

Type called "ExpressionType":
    EXPR_INTEGER
    EXPR_VARIABLE
    EXPR_BINARY_OP
    EXPR_COMPARISON
    EXPR_FUNCTION_CALL
    EXPR_STRING_LITERAL
    EXPR_FIELD_ACCESS
    EXPR_TYPE_NAME
    EXPR_READ_FILE
    EXPR_WRITE_FILE
End Type

Type called "BinaryOpData":
    left as Expression
    right as Expression
    operator as TokenType
End Type

Type called "ComparisonData":
    left as Expression
    right as Expression
    comparison_op as TokenType
End Type

Type called "FunctionCallData":
    function_name as String
    arguments as Expression
    argument_count as Integer
End Type

Type called "FieldAccessData":
    object as Expression
    field_name as String
End Type

Type called "ReadFileData":
    filename_expr as Expression
End Type

Type called "WriteFileData":
    filename_expr as Expression
    content_expr as Expression
End Type

Type called "Expression":
    expr_type as ExpressionType
    integer_value as Integer
    variable_name as String
    binary_op as BinaryOpData
    comparison as ComparisonData
    function_call as FunctionCallData
    string_literal as String
    field_access as FieldAccessData
    type_name as String
    file_read as ReadFileData
    file_write as WriteFileData
End Type

Type called "StatementType":
    STMT_LET
    STMT_SET
    STMT_RETURN
    STMT_IF
    STMT_WHILE
    STMT_PRINT
    STMT_EXPRESSION
    STMT_IMPORT
End Type

Type called "LetStatementData":
    variable_name as String
    expression as Expression
End Type

Type called "SetStatementData":
    variable_name as String
    field_name as String
    expression as Expression
End Type

Type called "ReturnStatementData":
    expression as Expression
End Type

Type called "IfStatementData":
    condition as Expression
    if_body as Statement
    if_body_count as Integer
    else_body as Statement
    else_body_count as Integer
End Type

Type called "WhileStatementData":
    condition as Expression
    body as Statement
    body_count as Integer
End Type

Type called "PrintStatementData":
    expression as Expression
End Type

Type called "ExpressionStatementData":
    expression as Expression
End Type

Type called "ImportStatementData":
    module_path as String
    module_name as String
End Type

Type called "Statement":
    stmt_type as StatementType
    let_stmt as LetStatementData
    set_stmt as SetStatementData
    return_stmt as ReturnStatementData
    if_stmt as IfStatementData
    while_stmt as WhileStatementData
    print_stmt as PrintStatementData
    expr_stmt as ExpressionStatementData
    import_stmt as ImportStatementData
End Type

Type called "Parameter":
    name as String
    param_type as String
End Type

Type called "TypeField":
    name as String
    field_type as String
    offset as Integer
    size as Integer
End Type

Type called "TypeDefinition":
    name as String
    fields as TypeField
    field_count as Integer
    size as Integer
End Type

Type called "Function":
    name as String
    parameters as Parameter
    parameter_count as Integer
    return_type as String
    statements as Statement
    statement_count as Integer
End Type

Type called "Module":
    name as String
    file_path as String
    program as Program
    dependencies as Module
    dependency_count as Integer
    dependency_capacity as Integer
End Type

Type called "ModuleManager":
    modules as Module
    module_count as Integer
    module_capacity as Integer
    search_paths as String
    search_path_count as Integer
    search_path_capacity as Integer
End Type

Type called "Program":
    functions as Function
    function_count as Integer
    function_capacity as Integer
    types as TypeDefinition
    type_count as Integer
    type_capacity as Integer
    module_manager as ModuleManager
End Type

Type called "Parser":
    lexer as Lexer
    current_token as Token
    current_program as Program
End Type

Process called "string_duplicate" takes str as String returns String:
    If str is equal to null:
        Return null
    End If
    Let len be strlen(str)
    Let dup be malloc(len plus 1)
    strcpy(dup, str)
    Return dup
End Process

Process called "parser_advance" takes parser as Parser returns Integer:
    token_destroy(current_token of parser)
    Set current_token of parser to lexer_next_token(lexer of parser)
    Return 0
End Process

Process called "parser_eat" takes parser as Parser, expected_type as TokenType returns Integer:
    If token_type of current_token of parser is equal to expected_type:
        parser_advance(parser)
    Otherwise:
        Print "[PARSER ERROR] Expected token type "
        Print expected_type
        Print ", got "
        Print token_type of current_token of parser
        Print " at line "
        Print line of current_token of parser
        exit(1)
    End If
    Return 0
End Process

Process called "expression_create_integer" takes value as Integer returns Expression:
    Let expr be malloc(sizeof_Expression())
    Set expr_type of expr to EXPR_INTEGER
    Set integer_value of expr to value
    Return expr
End Process

Process called "expression_create_variable" takes name as String returns Expression:
    Let expr be malloc(sizeof_Expression())
    Set expr_type of expr to EXPR_VARIABLE
    Set variable_name of expr to name
    Return expr
End Process

Process called "expression_create_binary_op" takes left as Expression, operator as TokenType, right as Expression returns Expression:
    Let expr be malloc(sizeof_Expression())
    Set expr_type of expr to EXPR_BINARY_OP
    Set left of binary_op of expr to left
    Set right of binary_op of expr to right
    Set operator of binary_op of expr to operator
    Return expr
End Process

Process called "expression_create_comparison" takes left as Expression, comparison_op as TokenType, right as Expression returns Expression:
    Let expr be malloc(sizeof_Expression())
    Set expr_type of expr to EXPR_COMPARISON
    Set left of comparison of expr to left
    Set right of comparison of expr to right
    Set comparison_op of comparison of expr to comparison_op
    Return expr
End Process

Process called "expression_create_function_call" takes function_name as String, arguments as Expression, argument_count as Integer returns Expression:
    Let expr be malloc(sizeof_Expression())
    Set expr_type of expr to EXPR_FUNCTION_CALL
    Set function_name of function_call of expr to function_name
    Set arguments of function_call of expr to arguments
    Set argument_count of function_call of expr to argument_count
    Return expr
End Process

Process called "expression_create_string_literal_owned" takes string_value as String returns Expression:
    Let expr be malloc(sizeof_Expression())
    Set expr_type of expr to EXPR_STRING_LITERAL
    Set string_literal of expr to string_value
    Return expr
End Process

Process called "expression_create_read_file" takes filename_expr as Expression returns Expression:
    Let expr be malloc(sizeof_Expression())
    Set expr_type of expr to EXPR_READ_FILE
    Set filename_expr of file_read of expr to filename_expr
    Return expr
End Process

Process called "expression_create_write_file" takes filename_expr as Expression, content_expr as Expression returns Expression:
    Let expr be malloc(sizeof_Expression())
    Set expr_type of expr to EXPR_WRITE_FILE
    Set filename_expr of file_write of expr to filename_expr
    Set content_expr of file_write of expr to content_expr
    Return expr
End Process

Process called "statement_create_let" takes var_name as String, expr as Expression returns Statement:
    Let stmt be malloc(sizeof_Statement())
    Set stmt_type of stmt to STMT_LET
    Set variable_name of let_stmt of stmt to var_name
    Set expression of let_stmt of stmt to expr
    Return stmt
End Process

Process called "statement_create_set" takes var_name as String, expr as Expression returns Statement:
    Let stmt be malloc(sizeof_Statement())
    Set stmt_type of stmt to STMT_SET
    Set variable_name of set_stmt of stmt to var_name
    Set field_name of set_stmt of stmt to null
    Set expression of set_stmt of stmt to expr
    Return stmt
End Process

Process called "statement_create_return" takes expr as Expression returns Statement:
    Let stmt be malloc(sizeof_Statement())
    Set stmt_type of stmt to STMT_RETURN
    Set expression of return_stmt of stmt to expr
    Return stmt
End Process

Process called "statement_create_print" takes expr as Expression returns Statement:
    Let stmt be malloc(sizeof_Statement())
    Set stmt_type of stmt to STMT_PRINT
    Set expression of print_stmt of stmt to expr
    Return stmt
End Process

Process called "statement_create_expression" takes expr as Expression returns Statement:
    Let stmt be malloc(sizeof_Statement())
    Set stmt_type of stmt to STMT_EXPRESSION
    Set expression of expr_stmt of stmt to expr
    Return stmt
End Process

Process called "statement_create_if" takes condition as Expression, if_body as Statement, if_body_count as Integer, else_body as Statement, else_body_count as Integer returns Statement:
    Let stmt be malloc(sizeof_Statement())
    Set stmt_type of stmt to STMT_IF
    Set condition of if_stmt of stmt to condition
    Set if_body of if_stmt of stmt to if_body
    Set if_body_count of if_stmt of stmt to if_body_count
    Set else_body of if_stmt of stmt to else_body
    Set else_body_count of if_stmt of stmt to else_body_count
    Return stmt
End Process

Process called "statement_create_while" takes condition as Expression, body as Statement, body_count as Integer returns Statement:
    Let stmt be malloc(sizeof_Statement())
    Set stmt_type of stmt to STMT_WHILE
    Set condition of while_stmt of stmt to condition
    Set body of while_stmt of stmt to body
    Set body_count of while_stmt of stmt to body_count
    Return stmt
End Process

Process called "statement_create_import" takes module_path as String, module_name as String returns Statement:
    Let stmt be malloc(sizeof_Statement())
    Set stmt_type of stmt to STMT_IMPORT
    Set module_path of import_stmt of stmt to module_path
    Set module_name of import_stmt of stmt to module_name
    Return stmt
End Process

Process called "function_create" takes name as String, return_type as String returns Function:
    Let func be malloc(sizeof_Function())
    Set name of func to string_duplicate(name)
    Set parameters of func to null
    Set parameter_count of func to 0
    Set return_type of func to return_type
    Set statements of func to null
    Set statement_count of func to 0
    Return func
End Process

Process called "function_add_parameter" takes func as Function, param_name as String, param_type as String returns Integer:
    Set parameter_count of func to parameter_count of func plus 1
    Set parameters of func to realloc(parameters of func, parameter_count of func multiplied by sizeof_Parameter())
    Set name of parameters of func[parameter_count of func minus 1] to string_duplicate(param_name)
    Set param_type of parameters of func[parameter_count of func minus 1] to string_duplicate(param_type)
    Return 0
End Process

Process called "function_add_statement" takes func as Function, stmt as Statement returns Integer:
    Set statement_count of func to statement_count of func plus 1
    Set statements of func to realloc(statements of func, statement_count of func multiplied by sizeof_Statement_ptr())
    Set statements of func[statement_count of func minus 1] to stmt
    Return 0
End Process

Process called "module_create" takes name as String, file_path as String returns Module:
    Let module be malloc(sizeof_Module())
    Set name of module to string_duplicate(name)
    Set file_path of module to string_duplicate(file_path)
    Set program of module to null
    Set dependencies of module to null
    Set dependency_count of module to 0
    Set dependency_capacity of module to 0
    Return module
End Process

Process called "module_destroy" takes module as Module returns Integer:
    If module is not equal to null:
        free(name of module)
        free(file_path of module)
        If program of module is not equal to null:
            program_destroy(program of module)
        End If
        If dependencies of module is not equal to null:
            Let i be 0
            While i is less than dependency_count of module:
                module_destroy(dependencies of module[i])
                Set i to i plus 1
            End While
            free(dependencies of module)
        End If
        free(module)
    End If
    Return 0
End Process

Process called "module_manager_create" returns ModuleManager:
    Let manager be malloc(sizeof_ModuleManager())
    Set modules of manager to malloc(10 multiplied by sizeof_Module_ptr())
    Set module_count of manager to 0
    Set module_capacity of manager to 10
    Set search_paths of manager to malloc(10 multiplied by sizeof_String_ptr())
    Set search_path_count of manager to 0
    Set search_path_capacity of manager to 10
    Return manager
End Process

Process called "module_manager_destroy" takes manager as ModuleManager returns Integer:
    If manager is not equal to null:
        Let i be 0
        While i is less than module_count of manager:
            module_destroy(modules of manager[i])
            Set i to i plus 1
        End While
        free(modules of manager)

        Set i to 0
        While i is less than search_path_count of manager:
            free(search_paths of manager[i])
            Set i to i plus 1
        End While
        free(search_paths of manager)
        free(manager)
    End If
    Return 0
End Process

Process called "module_manager_add_search_path" takes manager as ModuleManager, path as String returns Integer:
    If search_path_count of manager is greater than or equal to search_path_capacity of manager:
        Set search_path_capacity of manager to search_path_capacity of manager multiplied by 2
        Set search_paths of manager to realloc(search_paths of manager, search_path_capacity of manager multiplied by sizeof_String_ptr())
    End If
    Set search_paths of manager[search_path_count of manager] to string_duplicate(path)
    Set search_path_count of manager to search_path_count of manager plus 1
    Return 0
End Process

Process called "module_manager_find_module" takes manager as ModuleManager, module_name as String returns Module:
    Let i be 0
    While i is less than module_count of manager:
        If strcmp(name of modules of manager[i], module_name) is equal to 0:
            Return modules of manager[i]
        End If
        Set i to i plus 1
    End While
    Return null
End Process

Process called "resolve_module_path" takes manager as ModuleManager, module_path as String returns String:
    Let file_exists be access(module_path, 0)
    If file_exists is equal to 0:
        Return string_duplicate(module_path)
    End If

    Let i be 0
    While i is less than search_path_count of manager:
        Let len be strlen(search_paths of manager[i]) plus strlen(module_path) plus 2
        Let full_path be malloc(len)
        strcpy(full_path, search_paths of manager[i])
        strcat(full_path, "/")
        strcat(full_path, module_path)

        Set file_exists to access(full_path, 0)
        If file_exists is equal to 0:
            Return full_path
        End If
        free(full_path)
        Set i to i plus 1
    End While

    Return null
End Process

Process called "module_manager_load_module" takes manager as ModuleManager, module_path as String, module_name as String returns Module:
    Let existing_module be module_manager_find_module(manager, module_name)
    If existing_module is not equal to null:
        Return existing_module
    End If

    Let resolved_path be resolve_module_path(manager, module_path)
    If resolved_path is equal to null:
        Print "[MODULE ERROR] Could not find module file: "
        Print module_path
        Return null
    End If

    Let module_source be read_file(resolved_path)
    If module_source is equal to null or strcmp(module_source, "") is equal to 0:
        Print "[MODULE ERROR] Could not read module file: "
        Print resolved_path
        free(resolved_path)
        Return null
    End If

    Let module_lexer be lexer_create(module_source)
    Let module_parser be parser_create(module_lexer)
    Set current_program of module_parser to current_program of parser

    Let module be module_create(module_name, resolved_path)
    Set program of module to parser_parse_program(module_parser)

    If module_count of manager is greater than or equal to module_capacity of manager:
        Set module_capacity of manager to module_capacity of manager multiplied by 2
        Set modules of manager to realloc(modules of manager, module_capacity of manager multiplied by sizeof_Module_ptr())
    End If
    Set modules of manager[module_count of manager] to module
    Set module_count of manager to module_count of manager plus 1

    lexer_destroy(module_lexer)
    parser_destroy(module_parser)
    free(module_source)
    free(resolved_path)

    Return module
End Process

Process called "program_create" returns Program:
    Let program be malloc(sizeof_Program())
    Set functions of program to malloc(10 multiplied by sizeof_Function_ptr())
    Set function_count of program to 0
    Set function_capacity of program to 10
    Set types of program to malloc(10 multiplied by sizeof_TypeDefinition_ptr())
    Set type_count of program to 0
    Set type_capacity of program to 10
    Set module_manager of program to module_manager_create()
    Return program
End Process

Process called "program_add_function" takes program as Program, func as Function returns Integer:
    If function_count of program is greater than or equal to function_capacity of program:
        Set function_capacity of program to function_capacity of program multiplied by 2
        Set functions of program to realloc(functions of program, function_capacity of program multiplied by sizeof_Function_ptr())
    End If
    Set functions of program[function_count of program] to func
    Set function_count of program to function_count of program plus 1
    Return 0
End Process

Process called "program_add_type" takes program as Program, type_def as TypeDefinition returns Integer:
    If type_count of program is greater than or equal to type_capacity of program:
        Set type_capacity of program to type_capacity of program multiplied by 2
        Set types of program to realloc(types of program, type_capacity of program multiplied by sizeof_TypeDefinition_ptr())
    End If
    Set types of program[type_count of program] to type_def
    Set type_count of program to type_count of program plus 1
    Return 0
End Process

Process called "parser_parse_primary" takes parser as Parser returns Expression:
    If token_type of current_token of parser is equal to TOKEN_INTEGER:
        Let value be atoi(value of current_token of parser)
        parser_advance(parser)
        Return expression_create_integer(value)
    End If

    If token_type of current_token of parser is equal to TOKEN_STRING_LITERAL:
        Let string_value be string_duplicate(value of current_token of parser)
        parser_advance(parser)
        Return expression_create_string_literal_owned(string_value)
    End If

    If token_type of current_token of parser is equal to TOKEN_READ_FILE:
        parser_advance(parser)
        parser_eat(parser, TOKEN_LPAREN)
        Let filename_expr be parser_parse_expression(parser)
        parser_eat(parser, TOKEN_RPAREN)
        Return expression_create_read_file(filename_expr)
    End If

    If token_type of current_token of parser is equal to TOKEN_WRITE_FILE:
        parser_advance(parser)
        parser_eat(parser, TOKEN_LPAREN)
        Let filename_expr be parser_parse_expression(parser)
        parser_eat(parser, TOKEN_COMMA)
        Let content_expr be parser_parse_expression(parser)
        parser_eat(parser, TOKEN_RPAREN)
        Return expression_create_write_file(filename_expr, content_expr)
    End If

    If token_type of current_token of parser is equal to TOKEN_IDENTIFIER:
        Let name be string_duplicate(value of current_token of parser)
        parser_advance(parser)

        If token_type of current_token of parser is equal to TOKEN_LPAREN:
            parser_advance(parser)
            Let arguments be malloc(10 multiplied by sizeof_Expression_ptr())
            Let argument_count be 0
            Let argument_capacity be 10

            While token_type of current_token of parser is not equal to TOKEN_RPAREN:
                If argument_count is greater than or equal to argument_capacity:
                    Set argument_capacity to argument_capacity multiplied by 2
                    Set arguments to realloc(arguments, argument_capacity multiplied by sizeof_Expression_ptr())
                End If

                Set arguments[argument_count] to parser_parse_expression(parser)
                Set argument_count to argument_count plus 1

                If token_type of current_token of parser is equal to TOKEN_COMMA:
                    parser_advance(parser)
                End If
            End While

            parser_eat(parser, TOKEN_RPAREN)
            Return expression_create_function_call(name, arguments, argument_count)
        Otherwise:
            Return expression_create_variable(name)
        End If
    End If

    Print "[PARSER ERROR] Unexpected token in expression: "
    Print token_type of current_token of parser
    Print " at line "
    Print line of current_token of parser
    exit(1)
    Return null
End Process

Process called "parser_parse_expression" takes parser as Parser returns Expression:
    Let left be parser_parse_comparison(parser)

    While token_type of current_token of parser is equal to TOKEN_PLUS or token_type of current_token of parser is equal to TOKEN_MINUS or token_type of current_token of parser is equal to TOKEN_MULTIPLIED or token_type of current_token of parser is equal to TOKEN_DIVIDED:
        Let op be token_type of current_token of parser
        parser_advance(parser)

        If op is equal to TOKEN_MULTIPLIED:
            If token_type of current_token of parser is equal to TOKEN_BY:
                parser_advance(parser)
            End If
        Otherwise If op is equal to TOKEN_DIVIDED:
            If token_type of current_token of parser is equal to TOKEN_BY:
                parser_advance(parser)
            End If
        End If

        Let right be parser_parse_comparison(parser)
        Set left to expression_create_binary_op(left, op, right)
    End While

    Return left
End Process

Process called "parser_parse_comparison" takes parser as Parser returns Expression:
    Let left be parser_parse_primary(parser)

    If token_type of current_token of parser is equal to TOKEN_IS:
        parser_advance(parser)

        If token_type of current_token of parser is equal to TOKEN_EQUAL:
            parser_advance(parser)
            If token_type of current_token of parser is equal to TOKEN_TO:
                parser_advance(parser)
            End If
            Let right be parser_parse_primary(parser)
            Return expression_create_comparison(left, TOKEN_EQUAL, right)
        Otherwise If token_type of current_token of parser is equal to TOKEN_LESS:
            parser_advance(parser)
            If token_type of current_token of parser is equal to TOKEN_THAN:
                parser_advance(parser)
            End If
            Let right be parser_parse_primary(parser)
            Return expression_create_comparison(left, TOKEN_LESS, right)
        End If
    End If

    Return left
End Process

Process called "parser_parse_let_statement" takes parser as Parser returns Statement:
    parser_advance(parser)

    If token_type of current_token of parser is not equal to TOKEN_IDENTIFIER:
        Print "[PARSER ERROR] Expected variable name after Let"
        exit(1)
    End If

    Let variable_name be string_duplicate(value of current_token of parser)
    parser_advance(parser)

    parser_eat(parser, TOKEN_BE)
    Let expr be parser_parse_expression(parser)

    Return statement_create_let(variable_name, expr)
End Process

Process called "parser_parse_set_statement" takes parser as Parser returns Statement:
    parser_advance(parser)

    If token_type of current_token of parser is not equal to TOKEN_IDENTIFIER:
        Print "[PARSER ERROR] Expected variable name after Set"
        exit(1)
    End If

    Let variable_name be string_duplicate(value of current_token of parser)
    parser_advance(parser)

    parser_eat(parser, TOKEN_TO)
    Let expr be parser_parse_expression(parser)

    Return statement_create_set(variable_name, expr)
End Process

Process called "parser_parse_return_statement" takes parser as Parser returns Statement:
    parser_advance(parser)
    Let expr be parser_parse_expression(parser)
    Return statement_create_return(expr)
End Process

Process called "parser_parse_print_statement" takes parser as Parser returns Statement:
    parser_advance(parser)
    Let expr be parser_parse_expression(parser)
    Return statement_create_print(expr)
End Process

Process called "parser_parse_import_statement" takes parser as Parser returns Statement:
    parser_advance(parser)

    If token_type of current_token of parser is not equal to TOKEN_STRING_LITERAL:
        Print "[PARSER ERROR] Expected module path after Import"
        exit(1)
    End If

    Let module_path be string_duplicate(value of current_token of parser)
    parser_advance(parser)

    parser_eat(parser, TOKEN_AS)

    If token_type of current_token of parser is not equal to TOKEN_IDENTIFIER:
        Print "[PARSER ERROR] Expected module name after as"
        exit(1)
    End If

    Let module_name be string_duplicate(value of current_token of parser)
    parser_advance(parser)

    Let module be module_manager_load_module(module_manager of current_program of parser, module_path, module_name)
    If module is not equal to null:
        Let i be 0
        While i is less than function_count of program of module:
            program_add_function(current_program of parser, functions of program of module[i])
            Set functions of program of module[i] to null
            Set i to i plus 1
        End While

        Set i to 0
        While i is less than type_count of program of module:
            program_add_type(current_program of parser, types of program of module[i])
            Set types of program of module[i] to null
            Set i to i plus 1
        End While

        Set function_count of program of module to 0
        Set type_count of program of module to 0

        If module_manager of program of module is not equal to null:
            module_manager_destroy(module_manager of program of module)
            Set module_manager of program of module to null
        End If

        Print "[MODULE INFO] Successfully loaded and parsed module '"
        Print module_name
        Print "' from '"
        Print module_path
        Print "'"
    Otherwise:
        Print "[MODULE ERROR] Failed to load module '"
        Print module_name
        Print "' from '"
        Print module_path
        Print "'"
        exit(1)
    End If

    Return statement_create_import(module_path, module_name)
End Process

Process called "parser_parse_statement_block" takes parser as Parser, count as Integer returns Statement:
    Let statements be malloc(10 multiplied by sizeof_Statement_ptr())
    Set count to 0
    Let capacity be 10

    While token_type of current_token of parser is not equal to TOKEN_END and token_type of current_token of parser is not equal to TOKEN_OTHERWISE and token_type of current_token of parser is not equal to TOKEN_EOF:
        If count is greater than or equal to capacity:
            Set capacity to capacity multiplied by 2
            Set statements to realloc(statements, capacity multiplied by sizeof_Statement_ptr())
        End If

        If token_type of current_token of parser is equal to TOKEN_LET:
            Set statements[count] to parser_parse_let_statement(parser)
        Otherwise If token_type of current_token of parser is equal to TOKEN_SET:
            Set statements[count] to parser_parse_set_statement(parser)
        Otherwise If token_type of current_token of parser is equal to TOKEN_RETURN:
            Set statements[count] to parser_parse_return_statement(parser)
        Otherwise If token_type of current_token of parser is equal to TOKEN_PRINT:
            Set statements[count] to parser_parse_print_statement(parser)
        Otherwise If token_type of current_token of parser is equal to TOKEN_IF:
            Set statements[count] to parser_parse_if_statement(parser)
        Otherwise If token_type of current_token of parser is equal to TOKEN_WHILE:
            Set statements[count] to parser_parse_while_statement(parser)
        Otherwise If token_type of current_token of parser is equal to TOKEN_IMPORT:
            Set statements[count] to parser_parse_import_statement(parser)
        Otherwise:
            Let expr be parser_parse_expression(parser)
            Set statements[count] to statement_create_expression(expr)
        End If

        Set count to count plus 1
    End While

    Return statements
End Process

Process called "parser_parse_if_statement" takes parser as Parser returns Statement:
    parser_advance(parser)
    Let condition be parser_parse_expression(parser)
    parser_eat(parser, TOKEN_COLON)

    Let if_body_count be 0
    Let if_body be parser_parse_statement_block(parser, if_body_count)

    Let else_body_count be 0
    Let else_body be null

    If token_type of current_token of parser is equal to TOKEN_OTHERWISE:
        parser_advance(parser)
        parser_eat(parser, TOKEN_COLON)
        Set else_body to parser_parse_statement_block(parser, else_body_count)
    End If

    parser_eat(parser, TOKEN_END)
    parser_eat(parser, TOKEN_IF)

    Return statement_create_if(condition, if_body, if_body_count, else_body, else_body_count)
End Process

Process called "parser_parse_while_statement" takes parser as Parser returns Statement:
    parser_advance(parser)
    Let condition be parser_parse_expression(parser)
    parser_eat(parser, TOKEN_COLON)

    Let body_count be 0
    Let body be parser_parse_statement_block(parser, body_count)

    parser_eat(parser, TOKEN_END)
    parser_eat(parser, TOKEN_WHILE)

    Return statement_create_while(condition, body, body_count)
End Process

Process called "calculate_type_size" takes type_name as String, program as Program returns Integer:
    If strcmp(type_name, "Integer") is equal to 0:
        Return 8
    Otherwise If strcmp(type_name, "String") is equal to 0:
        Return 8
    Otherwise If strcmp(type_name, "Boolean") is equal to 0:
        Return 1
    End If

    Let i be 0
    While i is less than type_count of program:
        If strcmp(name of types of program[i], type_name) is equal to 0:
            Return size of types of program[i]
        End If
        Set i to i plus 1
    End While

    Return 8
End Process

Process called "parser_parse_type_definition" takes parser as Parser returns TypeDefinition:
    parser_advance(parser)
    parser_eat(parser, TOKEN_CALLED)

    If token_type of current_token of parser is not equal to TOKEN_STRING_LITERAL:
        Print "[PARSER ERROR] Expected type name after Type called"
        exit(1)
    End If

    Let type_name be string_duplicate(value of current_token of parser)
    parser_advance(parser)
    parser_eat(parser, TOKEN_COLON)

    Let fields be malloc(10 multiplied by sizeof_TypeField())
    Let field_count be 0
    Let field_capacity be 10
    Let current_offset be 0

    While token_type of current_token of parser is not equal to TOKEN_END:
        If field_count is greater than or equal to field_capacity:
            Set field_capacity to field_capacity multiplied by 2
            Set fields to realloc(fields, field_capacity multiplied by sizeof_TypeField())
        End If

        If token_type of current_token of parser is not equal to TOKEN_IDENTIFIER:
            Print "[PARSER ERROR] Expected field name in type definition"
            exit(1)
        End If

        Let field_name be string_duplicate(value of current_token of parser)
        parser_advance(parser)
        parser_eat(parser, TOKEN_AS)

        If token_type of current_token of parser is not equal to TOKEN_IDENTIFIER:
            Print "[PARSER ERROR] Expected field type after as"
            exit(1)
        End If

        Let field_type be string_duplicate(value of current_token of parser)
        parser_advance(parser)

        Let field_size be calculate_type_size(field_type, current_program of parser)

        Set name of fields[field_count] to field_name
        Set field_type of fields[field_count] to field_type
        Set offset of fields[field_count] to current_offset
        Set size of fields[field_count] to field_size

        Set current_offset to current_offset plus field_size
        Set field_count to field_count plus 1
    End While

    parser_eat(parser, TOKEN_END)
    parser_eat(parser, TOKEN_TYPE)

    Let type_def be malloc(sizeof_TypeDefinition())
    Set name of type_def to type_name
    Set fields of type_def to fields
    Set field_count of type_def to field_count
    Set size of type_def to current_offset

    Return type_def
End Process

Process called "parser_parse_function" takes parser as Parser returns Function:
    parser_advance(parser)
    parser_eat(parser, TOKEN_CALLED)

    If token_type of current_token of parser is not equal to TOKEN_STRING_LITERAL:
        Print "[PARSER ERROR] Expected function name after Process called"
        exit(1)
    End If

    Let function_name be string_duplicate(value of current_token of parser)
    parser_advance(parser)

    Let func be function_create(function_name, "Integer")

    If token_type of current_token of parser is equal to TOKEN_TAKES:
        parser_advance(parser)

        While token_type of current_token of parser is equal to TOKEN_IDENTIFIER:
            Let param_name be string_duplicate(value of current_token of parser)
            parser_advance(parser)
            parser_eat(parser, TOKEN_AS)

            If token_type of current_token of parser is not equal to TOKEN_IDENTIFIER:
                Print "[PARSER ERROR] Expected parameter type after as"
                exit(1)
            End If

            Let param_type be string_duplicate(value of current_token of parser)
            parser_advance(parser)

            function_add_parameter(func, param_name, param_type)

            If token_type of current_token of parser is equal to TOKEN_COMMA:
                parser_advance(parser)
            End If
        End While
    End If

    If token_type of current_token of parser is equal to TOKEN_RETURNS:
        parser_advance(parser)

        If token_type of current_token of parser is not equal to TOKEN_IDENTIFIER:
            Print "[PARSER ERROR] Expected return type after returns"
            exit(1)
        End If

        free(return_type of func)
        Set return_type of func to string_duplicate(value of current_token of parser)
        parser_advance(parser)
    End If

    parser_eat(parser, TOKEN_COLON)

    While token_type of current_token of parser is not equal to TOKEN_END and token_type of current_token of parser is not equal to TOKEN_EOF:
        Let stmt be null

        If token_type of current_token of parser is equal to TOKEN_LET:
            Set stmt to parser_parse_let_statement(parser)
        Otherwise If token_type of current_token of parser is equal to TOKEN_SET:
            Set stmt to parser_parse_set_statement(parser)
        Otherwise If token_type of current_token of parser is equal to TOKEN_RETURN:
            Set stmt to parser_parse_return_statement(parser)
        Otherwise If token_type of current_token of parser is equal to TOKEN_PRINT:
            Set stmt to parser_parse_print_statement(parser)
        Otherwise If token_type of current_token of parser is equal to TOKEN_IF:
            Set stmt to parser_parse_if_statement(parser)
        Otherwise If token_type of current_token of parser is equal to TOKEN_WHILE:
            Set stmt to parser_parse_while_statement(parser)
        Otherwise:
            Let expr be parser_parse_expression(parser)
            Set stmt to statement_create_expression(expr)
        End If

        function_add_statement(func, stmt)
    End While

    parser_eat(parser, TOKEN_END)
    parser_eat(parser, TOKEN_PROCESS)

    Return func
End Process

Process called "parser_create" takes lexer as Lexer returns Parser:
    Let parser be malloc(sizeof_Parser())
    Set lexer of parser to lexer
    Set current_token of parser to lexer_next_token(lexer)
    Set current_program of parser to null
    Return parser
End Process

Process called "parser_destroy" takes parser as Parser returns Integer:
    If parser is not equal to null:
        If current_token of parser is not equal to null:
            token_destroy(current_token of parser)
        End If
        free(parser)
    End If
    Return 0
End Process

Process called "parser_parse_program" takes parser as Parser returns Program:
    Let program be program_create()
    Set current_program of parser to program

    While token_type of current_token of parser is not equal to TOKEN_EOF:
        If token_type of current_token of parser is equal to TOKEN_IMPORT:
            Let import_stmt be parser_parse_import_statement(parser)
        Otherwise If token_type of current_token of parser is equal to TOKEN_TYPE:
            Let type_def be parser_parse_type_definition(parser)
            program_add_type(program, type_def)
        Otherwise If token_type of current_token of parser is equal to TOKEN_PROCESS:
            Let func be parser_parse_function(parser)
            program_add_function(program, func)
        Otherwise:
            Print "[PARSER ERROR] Unexpected token at top level at line "
            Print line of current_token of parser
            exit(1)
        End If
    End While

    Return program
End Process

Process called "expression_destroy" takes expr as Expression returns Integer:
    If expr is not equal to null:
        If expr_type of expr is equal to EXPR_VARIABLE:
            free(variable_name of expr)
        Otherwise If expr_type of expr is equal to EXPR_BINARY_OP:
            expression_destroy(left of binary_op of expr)
            expression_destroy(right of binary_op of expr)
        Otherwise If expr_type of expr is equal to EXPR_COMPARISON:
            expression_destroy(left of comparison of expr)
            expression_destroy(right of comparison of expr)
        Otherwise If expr_type of expr is equal to EXPR_FUNCTION_CALL:
            free(function_name of function_call of expr)
            Let i be 0
            While i is less than argument_count of function_call of expr:
                expression_destroy(arguments of function_call of expr[i])
                Set i to i plus 1
            End While
            free(arguments of function_call of expr)
        Otherwise If expr_type of expr is equal to EXPR_STRING_LITERAL:
            free(string_literal of expr)
        Otherwise If expr_type of expr is equal to EXPR_FIELD_ACCESS:
            expression_destroy(object of field_access of expr)
            free(field_name of field_access of expr)
        Otherwise If expr_type of expr is equal to EXPR_TYPE_NAME:
            free(type_name of expr)
        Otherwise If expr_type of expr is equal to EXPR_READ_FILE:
            expression_destroy(filename_expr of file_read of expr)
        Otherwise If expr_type of expr is equal to EXPR_WRITE_FILE:
            expression_destroy(filename_expr of file_write of expr)
            expression_destroy(content_expr of file_write of expr)
        End If
        free(expr)
    End If
    Return 0
End Process

Process called "statement_destroy" takes stmt as Statement returns Integer:
    If stmt is not equal to null:
        If stmt_type of stmt is equal to STMT_LET:
            free(variable_name of let_stmt of stmt)
            expression_destroy(expression of let_stmt of stmt)
        Otherwise If stmt_type of stmt is equal to STMT_SET:
            free(variable_name of set_stmt of stmt)
            free(field_name of set_stmt of stmt)
            expression_destroy(expression of set_stmt of stmt)
        Otherwise If stmt_type of stmt is equal to STMT_RETURN:
            expression_destroy(expression of return_stmt of stmt)
        Otherwise If stmt_type of stmt is equal to STMT_IF:
            expression_destroy(condition of if_stmt of stmt)
            Let i be 0
            While i is less than if_body_count of if_stmt of stmt:
                statement_destroy(if_body of if_stmt of stmt[i])
                Set i to i plus 1
            End While
            free(if_body of if_stmt of stmt)
            Set i to 0
            While i is less than else_body_count of if_stmt of stmt:
                statement_destroy(else_body of if_stmt of stmt[i])
                Set i to i plus 1
            End While
            free(else_body of if_stmt of stmt)
        Otherwise If stmt_type of stmt is equal to STMT_WHILE:
            expression_destroy(condition of while_stmt of stmt)
            Let i be 0
            While i is less than body_count of while_stmt of stmt:
                statement_destroy(body of while_stmt of stmt[i])
                Set i to i plus 1
            End While
            free(body of while_stmt of stmt)
        Otherwise If stmt_type of stmt is equal to STMT_PRINT:
            expression_destroy(expression of print_stmt of stmt)
        Otherwise If stmt_type of stmt is equal to STMT_EXPRESSION:
            expression_destroy(expression of expr_stmt of stmt)
        Otherwise If stmt_type of stmt is equal to STMT_IMPORT:
            free(module_path of import_stmt of stmt)
            free(module_name of import_stmt of stmt)
        End If
        free(stmt)
    End If
    Return 0
End Process

Process called "function_destroy" takes func as Function returns Integer:
    If func is not equal to null:
        free(name of func)
        Let i be 0
        While i is less than parameter_count of func:
            free(name of parameters of func[i])
            free(param_type of parameters of func[i])
            Set i to i plus 1
        End While
        free(parameters of func)
        free(return_type of func)
        Set i to 0
        While i is less than statement_count of func:
            statement_destroy(statements of func[i])
            Set i to i plus 1
        End While
        free(statements of func)
        free(func)
    End If
    Return 0
End Process

Process called "type_destroy" takes type_def as TypeDefinition returns Integer:
    If type_def is not equal to null:
        free(name of type_def)
        Let i be 0
        While i is less than field_count of type_def:
            free(name of fields of type_def[i])
            free(field_type of fields of type_def[i])
            Set i to i plus 1
        End While
        free(fields of type_def)
        free(type_def)
    End If
    Return 0
End Process

Process called "program_destroy" takes program as Program returns Integer:
    If program is not equal to null:
        Let i be 0
        While i is less than function_count of program:
            function_destroy(functions of program[i])
            Set i to i plus 1
        End While
        free(functions of program)
        Set i to 0
        While i is less than type_count of program:
            type_destroy(types of program[i])
            Set i to i plus 1
        End While
        free(types of program)
        If module_manager of program is not equal to null:
            module_manager_destroy(module_manager of program)
        End If
        free(program)
    End If
    Return 0
End Process