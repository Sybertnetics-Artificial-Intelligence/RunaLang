# Copyright 2025 Sybertnetics Artificial Intelligence Solutions
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Code Generator for x86-64 Assembly
# Transliterated from codegen_x86.c (v0.0.7.3)
# Generates x86-64 assembly from parsed AST

# Program structure offsets (defined in parser.runa)
# Using numeric values to avoid duplicate symbol errors
# PROGRAM_FUNCTIONS = 0
# PROGRAM_FUNCTION_COUNT = 8
# PROGRAM_TYPES = 16
# PROGRAM_TYPE_COUNT = 24
# PROGRAM_IMPORTS = 32
# PROGRAM_IMPORT_COUNT = 40
# PROGRAM_GLOBAL_VARS = 48
# PROGRAM_GLOBAL_COUNT = 56

# Forward declarations for loop context management
# These will be implemented later in the file

# Note: string_duplicate is provided by string_utils module

# Helper to emit a line with newline
Process called "emit_line" takes output_file as Integer, line as Integer returns Integer:
    file_write_buffered(output_file, line, 0)
    file_write_buffered(output_file, "\n", 0)
    Return 0
End Process

# Find variable in current scope - equivalent to codegen_find_variable
Process called "codegen_find_variable" takes codegen as Integer, name as Integer returns Integer:
    Let variable_count be memory_get_int32(codegen, 16)  # codegen->variable_count (int)
    Let variables be memory_get_pointer(codegen, 8)        # codegen->variables
    Let i be 0
    While i is less than variable_count:
        Let var_offset be i multiplied by 32
        Let var_ptr be variables plus var_offset  # sizeof(Variable) = 32
        Let var_name be memory_get_pointer(var_ptr, 0)
        If string_equals(var_name, name) is equal to 1:
            Return i
        End If
        Let i be i plus 1
    End While
    Return 0 minus 1  # -1 for not found
End Process

# Calculate size of a type in bytes - equivalent to codegen_calculate_type_size
Process called "codegen_calculate_type_size" takes type_name as Integer, program as Integer returns Integer:
    # Built-in types
    If string_equals(type_name, "Integer") is equal to 1:
        Return 8  # 64-bit integer
    End If
    If string_equals(type_name, "Byte") is equal to 1:
        Return 1  # 8-bit byte
    End If
    If string_equals(type_name, "Short") is equal to 1:
        Return 2  # 16-bit short
    End If
    If string_equals(type_name, "Long") is equal to 1:
        Return 8  # 64-bit long
    End If

    # Custom types - look up in the program
    If program is not equal to 0:
        Let type_count be memory_get_int32(program, 24)  # PROGRAM_TYPE_COUNT - use int32
        Let types be memory_get_pointer(program, 16)       # PROGRAM_TYPES - use pointer
        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)  # type->name
            If string_equals(type_name_ptr, type_name) is equal to 1:
                Let type_size be memory_get_int32(type_ptr, 16)  # type->size
                Return type_size
            End If
            Let i be i plus 1
        End While
    End If

    # Unknown type - default to 8 bytes
    Return 8
End Process

# Add variable with type and parameter flag - equivalent to codegen_add_variable_with_type_and_param_flag
Process called "codegen_add_variable_with_type_and_param_flag" takes codegen as Integer, name as Integer, type_name as Integer, is_parameter as Integer returns Integer:
    # Get current counts and capacity

    Let variable_count be memory_get_int32(codegen, 16)      # codegen->variable_count (int)
    Let variable_capacity be memory_get_int32(codegen, 20)   # codegen->variable_capacity (int)
    Let variables be memory_get_pointer(codegen, 8)            # codegen->variables

    # DEBUG: Show what we read
    # print_integer(variable_count)
    # print_integer(variable_capacity)

    # Grow array if needed
    If variable_count is greater than or equal to variable_capacity:
        Let new_capacity be variable_capacity multiplied by 2
        Let new_size be new_capacity multiplied by 32  # sizeof(Variable)
        Let new_variables be allocate(new_size)

        # Copy existing variables
        Let i be 0
        While i is less than variable_count:
            Let var_offset be i multiplied by 32
            Let old_var be variables plus var_offset
            Let var_offset be i multiplied by 32
            Let new_var be new_variables plus var_offset
            # Copy Variable struct (32 bytes)
            memory_copy(new_var, old_var, 32)
            Let i be i plus 1
        End While

        # Free old array and update
        deallocate(variables)
        memory_set_pointer(codegen, 8, new_variables)      # codegen->variables
        memory_set_int32(codegen, 20, new_capacity)      # codegen->variable_capacity (int)
        Let variables be new_variables
    End If

    # Calculate size based on type
    Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)
    Let size be codegen_calculate_type_size(type_name, current_program)
    If type_name is equal to 0:
        Let size be codegen_calculate_type_size("Integer", current_program)
    End If

    # Update stack offset
    Let stack_offset be memory_get_int32(codegen, 24)  # codegen->stack_offset (int)
    Let new_stack_offset be stack_offset plus size
    memory_set_int32(codegen, 24, new_stack_offset)  # codegen->stack_offset (int)

    # Get variable index
    Let var_index be variable_count
    Let var_offset be var_index multiplied by 32  # Calculate offset separately
    Let var_ptr be variables plus var_offset      # Then add to base pointer


    # Set variable fields
    memory_set_pointer(var_ptr, 0, string_duplicate(name))       # name
    memory_set_int32(var_ptr, 8, new_stack_offset)            # stack_offset (int)
    If type_name is equal to 0:
        memory_set_pointer(var_ptr, 16, string_duplicate("Integer")) # type_name - use literal directly
    Otherwise:
        memory_set_pointer(var_ptr, 16, string_duplicate(type_name)) # type_name
    End If
    memory_set_int32(var_ptr, 24, is_parameter)               # is_parameter (int)

    # Increment count
    memory_set_int32(codegen, 16, variable_count plus 1)  # codegen->variable_count (int)

    Return var_index
End Process

# Add variable with type - equivalent to codegen_add_variable_with_type
Process called "codegen_add_variable_with_type" takes codegen as Integer, name as Integer, type_name as Integer returns Integer:
    Return codegen_add_variable_with_type_and_param_flag(codegen, name, type_name, 0)
End Process

# Add variable with default Integer type - equivalent to codegen_add_variable
Process called "codegen_add_variable" takes codegen as Integer, name as Integer returns Integer:
    Return codegen_add_variable_with_type(codegen, name, "Integer")
End Process

# Add string literal - equivalent to codegen_add_string_literal
Process called "codegen_add_string_literal" takes codegen as Integer, value as Integer returns Integer:
    # Get current counts and capacity
    Let string_count be memory_get_int32(codegen, 40)      # codegen->string_count (int)
    Let string_capacity be memory_get_int32(codegen, 44)   # codegen->string_capacity (int)
    Let strings be memory_get_pointer(codegen, 32)           # codegen->strings (pointer with padding)


    # Grow array if needed
    If string_count is greater than or equal to string_capacity:
        Let new_capacity be string_capacity multiplied by 2
        Let new_size be new_capacity multiplied by 16  # sizeof(StringLiteral)
        Let new_strings be allocate(new_size)

        # Copy existing strings
        Let i be 0
        While i is less than string_count:
            Let str_offset be i multiplied by 16
            Let old_str be strings plus str_offset
            Let str_offset be i multiplied by 16
            Let new_str be new_strings plus str_offset
            # Copy StringLiteral struct (16 bytes)
            memory_copy(new_str, old_str, 16)
            Let i be i plus 1
        End While

        # Free old array and update
        deallocate(strings)
        memory_set_pointer(codegen, 32, new_strings)      # codegen->strings (pointer)
        memory_set_int32(codegen, 44, new_capacity)     # codegen->string_capacity (int)
        Let strings be new_strings
    End If

    Let str_index be string_count
    Let str_offset be str_index multiplied by 16
    Let str_ptr be strings plus str_offset

    # Set string value
    memory_set_pointer(str_ptr, 0, string_duplicate(value))  # value

    # Generate unique label for this string
    Let label be string_concat(".STR", integer_to_string(str_index))
    memory_set_pointer(str_ptr, 8, label)  # label

    # Increment count
    memory_set_int32(codegen, 40, string_count plus 1)  # codegen->string_count (int)


    Return str_index
End Process

# Helper to read 32-bit integer from memory (since memory_get_integer reads 64 bits)
# WORKAROUND: Commented out because memory_get_byte is not implemented in v0.0.7.3's codegen
# Using C runtime implementation instead
# Process called "memory_get_int32" takes base as Integer, offset as Integer returns Integer:
#     Let byte0 be memory_get_byte(base, offset)
#     Let byte1 be memory_get_byte(base, offset plus 1)
#     Let byte2 be memory_get_byte(base, offset plus 2)
#     Let byte3 be memory_get_byte(base, offset plus 3)
#     Let temp1 be byte1 multiplied by 256
#     Let temp2 be byte2 multiplied by 65536
#     Let temp3 be byte3 multiplied by 16777216
#     Let result be byte0 plus temp1 plus temp2 plus temp3
#     Return result
# End Process

# Collect strings from expression - equivalent to codegen_collect_strings_from_expression
Process called "codegen_collect_strings_from_expression" takes codegen as Integer, expr as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If
    # Safety check for invalid pointers
    If expr is equal to 0:
        Return 0
    End If

    Let expr_type be memory_get_int32(expr, 0)  # expr->type (32-bit)


    If expr_type is equal to 5:  # EXPR_STRING_LITERAL
        # Check if string already exists
        Let string_count be memory_get_int32(codegen, 40)  # codegen->string_count (int)
        Let strings be memory_get_pointer(codegen, 32)  # codegen->strings (pointer)
        Let string_literal be memory_get_pointer(expr, 8)  # expr->data.string_literal (union at offset 4)

        # Safety check for string_literal
        If string_literal is equal to 0:
            Return 0
        End If
        If string_literal is equal to 0:
            Return 0
        End If

        # Safety check - string_count should be reasonable
        If string_count is less than 0:
            Return 0
        End If
        # Don't limit string count - allow as many as needed
        # If string_count is greater than 1000:
        #     Return 0
        # End If

        Let i be 0
        While i is less than string_count:
            Let str_offset be i multiplied by 16
            Let str_ptr be strings plus str_offset
            Let existing_value be memory_get_pointer(str_ptr, 0)  # Should be pointer, not integer!
            # Safety check for existing_value before comparison
            If existing_value is not equal to 0:
                If existing_value is greater than 65536:
                    If string_equals(existing_value, string_literal) is equal to 1:
                        Return 0  # Already added
                    End If
                End If
            End If
            Let i be i plus 1
        End While

        codegen_add_string_literal(codegen, string_literal)
        Return 0
    End If

    If expr_type is equal to 2:  # EXPR_BINARY_OP
        Let left be memory_get_pointer(expr, 8)   # binary_op.left
        Let right be memory_get_pointer(expr, 16) # binary_op.right
        codegen_collect_strings_from_expression(codegen, left)
        codegen_collect_strings_from_expression(codegen, right)
        Return 0
    End If

    If expr_type is equal to 3:  # EXPR_COMPARISON
        Let left be memory_get_pointer(expr, 8)   # comparison.left
        Let right be memory_get_pointer(expr, 16) # comparison.right
        codegen_collect_strings_from_expression(codegen, left)
        codegen_collect_strings_from_expression(codegen, right)
        Return 0
    End If

    If expr_type is equal to 4:  # EXPR_FUNCTION_CALL
        Let func_call_ptr be expr plus 8  # &expr->data.function_call
        # function_call structure: function_name (char*) at 0, arguments (Expression**) at 8, argument_count (int) at 16
        Let function_name be memory_get_pointer(func_call_ptr, 0)  # function_call.function_name
        Let arguments be memory_get_pointer(func_call_ptr, 8)      # function_call.arguments - this is a pointer!
        Let argument_count be memory_get_int32(func_call_ptr, 16) # function_call.argument_count


        Let i be 0
        While i is less than argument_count:
            Let arg_offset be i multiplied by 8
            Let arg_ptr be memory_get_pointer(arguments, arg_offset)


            codegen_collect_strings_from_expression(codegen, arg_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 6:  # EXPR_FIELD_ACCESS
        Let object be memory_get_pointer(expr, 8)  # field_access.object
        codegen_collect_strings_from_expression(codegen, object)
        Return 0
    End If

    If expr_type is equal to 8:  # EXPR_BUILTIN_CALL
        Let builtin_call_ptr be expr plus 8  # &expr->data.builtin_call
        # builtin_call structure: builtin_type (int) at 0, arguments (Expression**) at 8, argument_count (int) at 16
        Let builtin_type be memory_get_int32(builtin_call_ptr, 0)  # builtin_call.builtin_type
        Let arguments be memory_get_pointer(builtin_call_ptr, 8)      # builtin_call.arguments - this is a pointer!
        Let argument_count be memory_get_int32(builtin_call_ptr, 16) # builtin_call.argument_count

        Let i be 0
        While i is less than argument_count:
            Let arg_offset be i multiplied by 8
            Let arg_ptr be memory_get_pointer(arguments, arg_offset)
            codegen_collect_strings_from_expression(codegen, arg_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 9:  # EXPR_VARIANT_CONSTRUCTOR
        Let variant_constructor_ptr be expr plus 8  # &expr->data.variant_constructor
        # variant_constructor structure: type_name (char*) at 0, variant_name (char*) at 8, field_values (Expression**) at 16, field_count (int) at 24
        Let type_name be memory_get_pointer(variant_constructor_ptr, 0)     # variant_constructor.type_name
        Let variant_name be memory_get_pointer(variant_constructor_ptr, 8)  # variant_constructor.variant_name
        Let field_values be memory_get_pointer(variant_constructor_ptr, 16) # variant_constructor.field_values - this is a pointer!
        Let field_count be memory_get_int32(variant_constructor_ptr, 24)  # variant_constructor.field_count

        Let i be 0
        While i is less than field_count:
            Let field_offset be i multiplied by 8
            Let field_value_ptr be memory_get_pointer(field_values, field_offset)  # This is also a pointer!
            codegen_collect_strings_from_expression(codegen, field_value_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 16:  # EXPR_ARRAY_INDEX
        Let array_index_ptr be expr plus 8  # &expr->data.array_index
        Let arr be memory_get_integer(array_index_ptr, 0)  # array_index.array
        Let index be memory_get_integer(array_index_ptr, 8)  # array_index.index
        codegen_collect_strings_from_expression(codegen, arr)
        codegen_collect_strings_from_expression(codegen, index)
        Return 0
    End If

    # Other expression types (INTEGER, VARIABLE, TYPE_NAME, FUNCTION_POINTER) have no strings to collect
    Return 0
End Process

# Collect strings from statement - equivalent to codegen_collect_strings_from_statement
Process called "codegen_collect_strings_from_statement" takes codegen as Integer, stmt as Integer returns Integer:
    If stmt is equal to 0:
        Return 0
    End If

    # Safety check - if stmt is NULL, skip it
    If stmt is equal to 0:
        Return 0
    End If

    Let stmt_type be memory_get_int32(stmt, 0)  # stmt->type


    # Safety check - statement types should be 0-12
    If stmt_type is less than 0:
        Return 0
    End If
    If stmt_type is greater than 12:
        Return 1
    End If

    If stmt_type is equal to 1:  # STMT_LET
        # Statement structure: type at 0, data union at 8
        # let_stmt in union: var_name at 0, expression at 8
        Let var_name be memory_get_pointer(stmt, 8)   # stmt+8 = let_stmt.var_name
        Let expression be memory_get_pointer(stmt, 16) # stmt+16 = let_stmt.expression


        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 2:  # STMT_SET
        # Statement structure: type at 0, data union at 8
        # set_stmt in union: target at 0, expression at 8
        Let target be memory_get_pointer(stmt, 8)      # stmt+8 = set_stmt.target
        Let expression be memory_get_pointer(stmt, 16) # stmt+16 = set_stmt.expression
        codegen_collect_strings_from_expression(codegen, target)
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 3:  # STMT_RETURN
        Let return_stmt_ptr be stmt plus 8  # &stmt->data.return_stmt
        Let expression be memory_get_pointer(return_stmt_ptr, 0)  # return_stmt.expression
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 4:  # STMT_PRINT
        Let print_stmt_ptr be stmt plus 8  # &stmt->data.print_stmt
        Let expression be memory_get_pointer(print_stmt_ptr, 0)  # print_stmt.expression
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 5:  # STMT_IF

        Let if_stmt_ptr be stmt plus 8  # &stmt->data.if_stmt
        Let condition be memory_get_pointer(if_stmt_ptr, 0)        # if_stmt.condition (offset 8)
        Let if_body be memory_get_pointer(if_stmt_ptr, 8)          # if_stmt.if_body (offset 16)
        Let if_body_count be memory_get_int32(if_stmt_ptr, 16)   # if_stmt.if_body_count (offset 24)
        Let else_body be memory_get_pointer(if_stmt_ptr, 24)       # if_stmt.else_body (offset 32)
        Let else_body_count be memory_get_int32(if_stmt_ptr, 32) # if_stmt.else_body_count (offset 40)


        codegen_collect_strings_from_expression(codegen, condition)

        # Process if body - add safety check
        If if_body is not equal to 0:  # NULL pointer check
            Let i be 0
            While i is less than if_body_count:
                Let stmt_offset be i multiplied by 8


                Let stmt_ptr be memory_get_pointer(if_body, stmt_offset)


                codegen_collect_strings_from_statement(codegen, stmt_ptr)
                Let i be i plus 1
            End While
        End If

        # Process else body - add safety check
        If else_body is not equal to 0:  # NULL pointer check
            Let i be 0
            While i is less than else_body_count:
                Let stmt_offset be i multiplied by 8
                Let stmt_ptr be memory_get_pointer(else_body, stmt_offset)
                codegen_collect_strings_from_statement(codegen, stmt_ptr)
                Let i be i plus 1
            End While
        End If
        Return 0
    End If

    If stmt_type is equal to 6:  # STMT_WHILE
        Let while_stmt_ptr be stmt plus 8  # &stmt->data.while_stmt
        Let condition be memory_get_pointer(while_stmt_ptr, 0)   # while_stmt.condition (offset 8)
        Let body be memory_get_pointer(while_stmt_ptr, 8)        # while_stmt.body (offset 16)
        Let body_count be memory_get_int32(while_stmt_ptr, 16) # while_stmt.body_count (offset 24)

        codegen_collect_strings_from_expression(codegen, condition)

        # Process body
        Let i be 0
        While i is less than body_count:
            Let stmt_offset be i multiplied by 8
            Let stmt_ptr be memory_get_pointer(body, stmt_offset)
            codegen_collect_strings_from_statement(codegen, stmt_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 6:  # STMT_WHILE
        # This is the duplicate WHILE check, should be removed but keeping for now
        Let while_stmt_ptr be stmt plus 8  # &stmt->data.while_stmt
        Let condition be memory_get_pointer(while_stmt_ptr, 0)   # while_stmt.condition (offset 8)
        Let body be memory_get_pointer(while_stmt_ptr, 8)        # while_stmt.body (offset 16)
        Let body_count be memory_get_int32(while_stmt_ptr, 16) # while_stmt.body_count (offset 24)

        codegen_collect_strings_from_expression(codegen, condition)

        Let i be 0
        While i is less than body_count:
            Let stmt_offset be i multiplied by 8
            Let stmt_ptr be memory_get_pointer(body, stmt_offset)
            codegen_collect_strings_from_statement(codegen, stmt_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 7:  # STMT_EXPRESSION
        Let expr_stmt_ptr be stmt plus 8  # &stmt->data.expr_stmt
        Let expression be memory_get_pointer(expr_stmt_ptr, 0)  # expr_stmt.expression - this is a pointer!
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 8:  # STMT_MATCH
        Let match_stmt_ptr be stmt plus 8  # &stmt->data.match_stmt
        Let expression be memory_get_pointer(match_stmt_ptr, 0)   # match_stmt.expression - this is a pointer!
        Let case_count be memory_get_int32(match_stmt_ptr, 8)   # match_stmt.case_count
        Let cases be memory_get_pointer(match_stmt_ptr, 16)       # match_stmt.cases - this is a pointer!

        codegen_collect_strings_from_expression(codegen, expression)

        # Process each match case
        Let i be 0
        While i is less than case_count:
            Let case_offset be i multiplied by 32
            Let match_case_ptr be cases plus case_offset  # sizeof(MatchCase)
            Let body_count be memory_get_int32(match_case_ptr, 16)  # match_case.body_count
            Let body be memory_get_pointer(match_case_ptr, 24)        # match_case.body - this is a pointer!

            Let j be 0
            While j is less than body_count:
                Let stmt_offset be j multiplied by 8
                Let stmt_ptr be memory_get_pointer(body, stmt_offset)
                codegen_collect_strings_from_statement(codegen, stmt_ptr)
                Let j be j plus 1
            End While
            Let i be i plus 1
        End While
        Return 0
    End If

    # Other statement types (IMPORT, BREAK, CONTINUE, INLINE_ASSEMBLY) don't have strings to collect
    Return 0
End Process

# Helper function to determine the type name of an expression
Process called "codegen_get_expression_type" takes codegen as Integer, expr as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If

    Let expr_type be memory_get_int32(expr, 0)  # expr->type

    If expr_type is equal to 1:  # EXPR_VARIABLE
        Let variable_name be memory_get_pointer(expr, 8)  # expr->data.variable_name
        Let var_index be codegen_find_variable(codegen, variable_name)

        If var_index is less than 0:  # -1 for not found
            # Check if this is a global variable
            Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)
            If current_program is not equal to 0:
                Let global_count be memory_get_int32(current_program, 56)  # program->global_count (PROGRAM_GLOBAL_COUNT)
                Let globals be memory_get_pointer(current_program, 48)       # program->globals (PROGRAM_GLOBAL_VARS)

                Let j be 0
                While j is less than global_count:
                    Let global_offset be j multiplied by 8
                    Let global_ptr be memory_get_pointer(globals, global_offset)
                    Let global_name be memory_get_pointer(global_ptr, 0)  # global->name
                    If string_equals(global_name, variable_name) is equal to 1:
                        Let global_type be memory_get_integer(global_ptr, 8)  # global->type
                        Return global_type
                    End If
                    Let j be j plus 1
                End While
            End If
            Return 0
        End If

        Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
        Let var_offset be var_index multiplied by 32
        Let var_ptr be variables plus var_offset
        Let type_name be memory_get_pointer(var_ptr, 16)  # variable.type_name
        Return type_name
    End If

    If expr_type is equal to 6:  # EXPR_FIELD_ACCESS
        Let field_access_ptr be expr plus 8  # &expr->data.field_access
        Let object be memory_get_pointer(field_access_ptr, 0)       # field_access.object
        Let field_name be memory_get_pointer(field_access_ptr, 8)   # field_access.field_name

        # Get the type of the object
        Let object_type be codegen_get_expression_type(codegen, object)
        If object_type is equal to 0:
            Return 0
        End If

        # Find the type definition
        Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)
        Let type_count be memory_get_int32(current_program, 32)  # program->type_count
        Let types be memory_get_pointer(current_program, 24)       # program->types
        Let type be 0

        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)  # type->name
            If string_equals(type_name_ptr, object_type) is equal to 1:
                Let type be type_ptr
                Let i be type_count  # break loop
            End If
            Let i be i plus 1
        End While

        If type is equal to 0:
            Return 0
        End If

        # Find the field and return its type
        Let kind be memory_get_int32(type, 8)  # type->kind
        If kind is equal to 1:  # TYPE_KIND_STRUCT
            Let struct_type_ptr be type plus 16  # &type->data.struct_type
            Let field_count be memory_get_int32(struct_type_ptr, 0)  # struct_type.field_count
            Let fields be memory_get_pointer(struct_type_ptr, 8)       # struct_type.fields

            Let i be 0
            While i is less than field_count:
                Let field_offset be i multiplied by 24
                Let field_ptr be fields plus field_offset  # sizeof(FieldDefinition)
                Let field_name_ptr be memory_get_pointer(field_ptr, 0)  # field.name
                If string_equals(field_name_ptr, field_name) is equal to 1:
                    Let field_type be memory_get_pointer(field_ptr, 8)  # field.type
                    Return field_type
                End If
                Let i be i plus 1
            End While
        End If

        Return 0
    End If

    # Other expression types don't have determinable types in this context
    Return 0
End Process

# Generate the address of an lvalue expression (result in %rbx)
Process called "codegen_generate_lvalue_address" takes codegen as Integer, expr as Integer returns Integer:
    Let expr_type be memory_get_int32(expr, 0)  # expr->type
    Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file

    If expr_type is equal to 1:  # EXPR_VARIABLE
        # Find variable and generate its address
        Let variable_name be memory_get_pointer(expr, 8)  # expr->data.variable_name
        Let var_index be codegen_find_variable(codegen, variable_name)

        If var_index is less than 0:  # -1 for not found
            # Check if this is a global variable
            Let is_global be 0
            Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)

            If current_program is not equal to 0:
                Let global_count be memory_get_int32(current_program, 56)  # program->global_count (PROGRAM_GLOBAL_COUNT)
                Let globals be memory_get_pointer(current_program, 48)       # program->globals (PROGRAM_GLOBAL_VARS)

                Let j be 0
                While j is less than global_count:
                    Let global_offset be j multiplied by 8
                    Let global_ptr be memory_get_pointer(globals, global_offset)
                    Let global_name be memory_get_pointer(global_ptr, 0)  # global->name
                    If string_equals(global_name, variable_name) is equal to 1:
                        Let is_global be 1
                        Let j be global_count  # break loop
                    End If
                    Let j be j plus 1
                End While
            End If

            If is_global is equal to 1:
                # Generate address of global variable
                file_write_buffered(output_file, "    leaq ", 0)
                file_write_buffered(output_file, variable_name, 0)
                file_write_buffered(output_file, "(%rip), %rbx  # Address of global variable", 0)
            Otherwise:
                print_string("[CODEGEN ERROR] Unknown variable '")
                print_string(variable_name)
                print_string("'")
                exit_with_code(1)
            End If
        Otherwise:
            Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
            Let var_offset be var_index multiplied by 32
            Let var_ptr be variables plus var_offset
            Let offset be memory_get_int32(var_ptr, 8)  # variable.stack_offset

            # Generate address of variable on stack
            file_write_buffered(output_file, "    leaq -", 0)
            file_write_buffered(output_file, integer_to_string(offset), 0)
            file_write_buffered(output_file, "(%rbp), %rbx\n", 0)
        End If
        Return 0
    End If

    If expr_type is equal to 6:  # EXPR_FIELD_ACCESS
        Let field_access_ptr be expr plus 8  # &expr->data.field_access
        Let object be memory_get_pointer(field_access_ptr, 0)     # field_access.object
        Let field_name be memory_get_pointer(field_access_ptr, 8) # field_access.field_name

        # Generate address of object
        codegen_generate_lvalue_address(codegen, object)

        # Now %rbx contains the address of the object
        # We need to add the field offset to get the field address

        # Get the type of the object using our helper function
        Let object_type be codegen_get_expression_type(codegen, object)
        If object_type is equal to 0:
            print_string("[CODEGEN ERROR] Cannot determine type of object in field access")
            exit_with_code(1)
        End If

        # Find the type definition
        Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)
        Let type_count be memory_get_int32(current_program, 32)  # program->type_count
        Let types be memory_get_pointer(current_program, 24)       # program->types
        Let type be 0

        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)  # type->name
            If string_equals(type_name_ptr, object_type) is equal to 1:
                Let type be type_ptr
                Let i be type_count  # break loop
            End If
            Let i be i plus 1
        End While

        If type is equal to 0:
            print_string("[CODEGEN ERROR] Unknown type '")
            print_string(object_type)
            print_string("'")
            exit_with_code(1)
        End If

        # Find field offset
        Let field_offset be 0 minus 1  # -1 for not found
        Let kind be memory_get_int32(type, 8)  # type->kind

        If kind is equal to 1:  # TYPE_KIND_STRUCT
            Let struct_type_ptr be type plus 16  # &type->data.struct_type
            Let field_count be memory_get_int32(struct_type_ptr, 0)  # struct_type.field_count
            Let fields be memory_get_pointer(struct_type_ptr, 8)       # struct_type.fields

            Let i be 0
            While i is less than field_count:
                Let field_offset be i multiplied by 24
                Let field_ptr be fields plus field_offset  # sizeof(FieldDefinition)
                Let field_name_ptr be memory_get_pointer(field_ptr, 0)  # field.name
                If string_equals(field_name_ptr, field_name) is equal to 1:
                    Let field_offset be memory_get_int32(field_ptr, 16)  # field.offset
                    Let i be field_count  # break loop
                End If
                Let i be i plus 1
            End While
        End If

        If field_offset is less than 0:  # -1 for not found
            print_string("[CODEGEN ERROR] Type '")
            print_string(object_type)
            print_string("' has no field '")
            print_string(field_name)
            print_string("'")
            exit_with_code(1)
        End If

        # Add field offset to object address
        file_write_buffered(output_file, "    addq $", 0)
        file_write_buffered(output_file, integer_to_string(field_offset), 0)
        file_write_buffered(output_file, ", %rbx", 0)
        Return 0
    End If

    If expr_type is equal to 16:  # EXPR_ARRAY_INDEX
        Let array_index_ptr be expr plus 8  # &expr->data.array_index
        Let arr be memory_get_integer(array_index_ptr, 0)  # array_index.array
        Let index be memory_get_integer(array_index_ptr, 8)  # array_index.index

        # Check if the array is a parameter or local variable
        Let array_type be memory_get_int32(arr, 0)  # array->type
        If array_type is equal to 1:  # EXPR_VARIABLE
            Let array_variable_name be memory_get_pointer(arr, 8)  # array->data.variable_name
            Let var_index be codegen_find_variable(codegen, array_variable_name)

            If var_index is greater than or equal to 0:  # found variable
                Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
                Let var_offset be var_index multiplied by 32
                Let var_ptr be variables plus var_offset
                Let is_parameter be memory_get_int32(var_ptr, 24)  # variable.is_parameter

                If is_parameter is equal to 1:
                    # For array parameters, load the pointer value, not the address
                    Let offset be memory_get_int32(var_ptr, 8)  # variable.stack_offset
                    file_write_buffered(output_file, "    movq -", 0)
                    file_write_buffered(output_file, integer_to_string(offset), 0)
                    file_write_buffered(output_file, "(%rbp), %rbx  # Load array parameter pointer", 0)
                Otherwise:
                    # For local arrays, generate the address
                    codegen_generate_lvalue_address(codegen, arr)
                End If
            Otherwise:
                # For complex expressions, generate the address
                codegen_generate_lvalue_address(codegen, arr)
            End If
        Otherwise:
            # For complex expressions, generate the address
            codegen_generate_lvalue_address(codegen, arr)
        End If

        # Save base address
        emit_line(output_file, "    pushq %rbx")

        # Generate index expression
        codegen_generate_expression(codegen, index)

        # Pop base address
        emit_line(output_file, "    popq %rbx")

        # Calculate element address: base + (index * element_size)
        # For arrays, all elements are currently 8 bytes (Integer size)
        emit_line(output_file, "    imulq $8, %rax")
        emit_line(output_file, "    addq %rax, %rbx")
        Return 0
    End If

    # Invalid lvalue expression type
    print_string("[CODEGEN ERROR] Invalid lvalue expression type")
    exit_with_code(1)
    Return 0
End Process

# Helper function to generate integer literal expression
Process called "codegen_generate_integer_expr" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file
    Let integer_value be memory_get_pointer(expr, 8)  # expr->data.integer_value
    file_write_buffered(output_file, "    movq $", 0)
    file_write_buffered(output_file, integer_to_string(integer_value), 0)
    file_write_buffered(output_file, ", %rax\n", 0)
    Return 0
End Process

# Helper function to generate variable expression
Process called "codegen_generate_variable_expr" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let variable_name be memory_get_pointer(expr, 8)  # expr->data.variable_name
    Let var_index be codegen_find_variable(codegen, variable_name)

    If var_index is less than 0:  # -1 for not found
        # Check if this is a global variable
        Let is_global be 0
        Let current_program be memory_get_pointer(codegen, 48)

        If current_program is not equal to 0:
            Let global_count be memory_get_integer(current_program, 56)
            Let globals be memory_get_pointer(current_program, 48)

            Let j be 0
            Let found_global_ptr be 0
            While j is less than global_count:
                Let global_offset be j multiplied by 8
                Let global_ptr be memory_get_pointer(globals, global_offset)
                Let global_name be memory_get_pointer(global_ptr, 0)
                If string_equals(global_name, variable_name) is equal to 1:
                    Let is_global be 1
                    Let found_global_ptr be global_ptr
                    Let j be global_count
                End If
                Let j be j plus 1
            End While
        End If

        If is_global is equal to 1:
            # Check if this global has an integer initial_value (compile-time constant)
            Let initial_value be memory_get_pointer(found_global_ptr, 16)  # global->initial_value
            If initial_value is not equal to 0:
                Let expr_type be memory_get_int32(initial_value, 0)  # initial_value->type
                If expr_type is equal to 0:  # EXPR_INTEGER (compile-time constant)
                    Let integer_value be memory_get_pointer(initial_value, 8)  # initial_value->data.integer_value
                    file_write_buffered(output_file, "    movq $", 0)
                    file_write_buffered(output_file, integer_to_string(integer_value), 0)
                    file_write_buffered(output_file, ", %rax  # Load compile-time constant ", 0)
                    file_write_buffered(output_file, variable_name, 0)
                    file_write_buffered(output_file, "\n", 0)
                    Return 0
                End If
            End If
            # Not a compile-time constant, generate runtime access
            file_write_buffered(output_file, "    movq ", 0)
            file_write_buffered(output_file, variable_name, 0)
            file_write_buffered(output_file, "(%rip), %rax  # Load global variable\n", 0)
            Return 0
        End If

        # Check if function name
        Let is_function be 0
        If current_program is not equal to 0:
            Let function_count be memory_get_integer(current_program, 16)
            Let functions be memory_get_pointer(current_program, 8)

            Let j be 0
            While j is less than function_count:
                Let func_offset be j multiplied by 8
                Let function_ptr be memory_get_pointer(functions, func_offset)
                Let function_name be memory_get_pointer(function_ptr, 0)
                If string_equals(function_name, variable_name) is equal to 1:
                    Let is_function be 1
                    Let j be function_count
                End If
                Let j be j plus 1
            End While
        End If

        If is_function is equal to 0:
            print_string("[CODEGEN ERROR] Undefined variable: ")
            print_string(variable_name)
            exit_with_code(1)
        End If

        file_write_buffered(output_file, "    leaq ", 0)
        file_write_buffered(output_file, variable_name, 0)
        file_write_buffered(output_file, "(%rip), %rax  # Load function address\n", 0)
        Return 0
    End If

    # Variable found in local scope
    Let variables be memory_get_pointer(codegen, 8)
    Let var_offset be var_index multiplied by 32
    Let var_ptr be variables plus var_offset
    Let offset be memory_get_integer(var_ptr, 8)
    Let var_type be memory_get_pointer(var_ptr, 16)

    # Check if array type
    Let is_array be 0
    Let current_program be memory_get_pointer(codegen, 48)

    If current_program is not equal to 0:
        Let type_count be memory_get_integer(current_program, 32)
        Let types be memory_get_pointer(current_program, 24)

        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)
            If string_equals(type_name_ptr, var_type) is equal to 1:
                Let kind be memory_get_integer(type_ptr, 8)
                If kind is equal to 2:
                    Let is_array be 1
                End If
                Let i be type_count
            End If
            Let i be i plus 1
        End While
    End If

    If is_array is equal to 1:
        file_write_buffered(output_file, "    leaq -", 0)
        file_write_buffered(output_file, integer_to_string(offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax  # Load array address\n", 0)
    Otherwise:
        file_write_buffered(output_file, "    movq -", 0)
        file_write_buffered(output_file, integer_to_string(offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax\n", 0)
    End If

    Return 0
End Process

# Generate code for integer literal expressions
Process called "codegen_generate_integer_literal" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let integer_value be memory_get_pointer(expr, 8)  # expr->data.integer_value
    file_write_buffered(output_file, "    movq $", 0)
    file_write_buffered(output_file, integer_to_string(integer_value), 0)
    file_write_buffered(output_file, ", %rax\n", 0)
    Return 0
End Process

# Generate code for variable expressions
Process called "codegen_generate_variable_handler" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    codegen_generate_variable_expr(codegen, expr)  # Already extracted earlier
    Return 0
End Process

# Generate code for string literal expressions
Process called "codegen_generate_string_literal" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)

    # Safety check
    If expr is equal to 0:  # NULL pointer check
        print_string("[CODEGEN ERROR] Invalid string literal expression")
        exit_with_code(1)
    End If

    Let string_value be memory_get_pointer(expr, 8)  # expr->data.string_value

    # Find or add the string to the string table
    Let string_count be memory_get_int32(codegen, 40)  # codegen->string_count (after padding)
    Let string_literals be memory_get_pointer(codegen, 32)  # codegen->strings (pointer with padding)
    Let string_index be 0 minus 1  # -1 for not found

    Let i be 0
    While i is less than string_count:
        Let str_offset be i multiplied by 16  # StringLiteral is 16 bytes
        Let stored_string be memory_get_pointer(string_literals, str_offset)
        If string_equals(stored_string, string_value) is equal to 1:
            Let string_index be i
            Let i be string_count  # break loop
        End If
        Let i be i plus 1
    End While

    If string_index is less than 0:
        # Add new string - this should call codegen_add_string_literal instead
        Let string_index be codegen_add_string_literal(codegen, string_value)
    End If

    # Generate reference to string
    file_write_buffered(output_file, "    leaq .STR", 0)
    file_write_buffered(output_file, integer_to_string(string_index), 0)
    file_write_buffered(output_file, "(%rip), %rax\n", 0)
    Return 0
End Process

# Generate code for binary operation expressions
Process called "codegen_generate_binary_op" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let left be memory_get_pointer(expr, 8)         # binary_op.left
    Let right be memory_get_pointer(expr, 16)       # binary_op.right
    Let operator be memory_get_integer(expr, 24)    # binary_op.operator

    # Generate left operand (result in %rax)
    codegen_generate_expression(codegen, left)
    emit_line(output_file, "    pushq %rax")
    # Generate right operand (result in %rax)
    codegen_generate_expression(codegen, right)
    emit_line(output_file, "    popq %rbx")

    # Perform the operation based on operator
    If operator is equal to 16:  # TOKEN_PLUS
        emit_line(output_file, "    addq %rbx, %rax")
    End If
    If operator is equal to 17:  # TOKEN_MINUS
        emit_line(output_file, "    subq %rax, %rbx")
        emit_line(output_file, "    movq %rbx, %rax")
    End If
    If operator is equal to 35:  # TOKEN_MULTIPLIED
        emit_line(output_file, "    imulq %rbx, %rax")
    End If
    If operator is equal to 36:  # TOKEN_DIVIDED
        emit_line(output_file, "    movq %rax, %rcx")
        emit_line(output_file, "    movq %rbx, %rax")
        emit_line(output_file, "    testq %rcx, %rcx")
        Let label_counter be memory_get_int32(codegen, 28)
        Let jz_label be string_concat("    jz .Ldiv_by_zero_", integer_to_string(label_counter))
        emit_line(output_file, jz_label)
        emit_line(output_file, "    cqto")
        emit_line(output_file, "    idivq %rcx")
        Let jmp_label be string_concat("    jmp .Ldiv_done_", integer_to_string(label_counter))
        emit_line(output_file, jmp_label)
        Let div_by_zero be string_concat(".Ldiv_by_zero_", integer_to_string(label_counter))
        emit_line(output_file, string_concat(div_by_zero, ":"))
        emit_line(output_file, "    movq $0, %rax")
        Let div_done be string_concat(".Ldiv_done_", integer_to_string(label_counter))
        emit_line(output_file, string_concat(div_done, ":"))
        memory_set_int32(codegen, 28, label_counter plus 1)
    End If
    If operator is equal to 37:  # TOKEN_MODULO
        emit_line(output_file, "    movq %rax, %rcx")
        emit_line(output_file, "    movq %rbx, %rax")
        emit_line(output_file, "    testq %rcx, %rcx")
        Let label_counter be memory_get_int32(codegen, 28)
        Let jz_label be string_concat("    jz .Lmod_by_zero_", integer_to_string(label_counter))
        emit_line(output_file, jz_label)
        emit_line(output_file, "    cqto")
        emit_line(output_file, "    idivq %rcx")
        emit_line(output_file, "    movq %rdx, %rax")
        Let jmp_label be string_concat("    jmp .Lmod_done_", integer_to_string(label_counter))
        emit_line(output_file, jmp_label)
        Let mod_by_zero be string_concat(".Lmod_by_zero_", integer_to_string(label_counter))
        emit_line(output_file, string_concat(mod_by_zero, ":"))
        emit_line(output_file, "    movq $0, %rax")
        Let mod_done be string_concat(".Lmod_done_", integer_to_string(label_counter))
        emit_line(output_file, string_concat(mod_done, ":"))
        memory_set_int32(codegen, 28, label_counter plus 1)
    End If
    If operator is equal to 39:  # TOKEN_BIT_AND
        emit_line(output_file, "    andq %rbx, %rax")
    End If
    If operator is equal to 40:  # TOKEN_BIT_OR
        emit_line(output_file, "    orq %rbx, %rax")
    End If
    If operator is equal to 41:  # TOKEN_BIT_XOR
        emit_line(output_file, "    xorq %rbx, %rax")
    End If
    If operator is equal to 42:  # TOKEN_BIT_SHIFT_LEFT
        emit_line(output_file, "    movq %rax, %rcx")
        emit_line(output_file, "    movq %rbx, %rax")
        emit_line(output_file, "    salq %cl, %rax")
    End If
    If operator is equal to 43:  # TOKEN_BIT_SHIFT_RIGHT
        emit_line(output_file, "    movq %rax, %rcx")
        emit_line(output_file, "    movq %rbx, %rax")
        emit_line(output_file, "    sarq %cl, %rax")
    End If
    Return 0
End Process

# Generate code for comparison expressions
Process called "codegen_generate_comparison" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let left be memory_get_pointer(expr, 8)           # comparison.left
    Let right be memory_get_pointer(expr, 16)         # comparison.right
    Let comparison_op be memory_get_integer(expr, 24) # comparison.comparison_op

    # Generate left operand (result in %rax)
    codegen_generate_expression(codegen, left)
    emit_line(output_file, "    pushq %rax")
    # Generate right operand (result in %rax)
    codegen_generate_expression(codegen, right)
    emit_line(output_file, "    popq %rbx")

    # Compare and set result
    emit_line(output_file, "    cmpq %rax, %rbx")
    If comparison_op is equal to 22:  # TOKEN_EQUAL
        emit_line(output_file, "    sete %al")
    End If
    If comparison_op is equal to 23:  # TOKEN_NOT_EQUAL
        emit_line(output_file, "    setne %al")
    End If
    If comparison_op is equal to 24:  # TOKEN_LESS
        emit_line(output_file, "    setl %al")
    End If
    If comparison_op is equal to 25:  # TOKEN_GREATER
        emit_line(output_file, "    setg %al")
    End If
    If comparison_op is equal to 27:  # TOKEN_LESS_EQUAL
        emit_line(output_file, "    setle %al")
    End If
    If comparison_op is equal to 26:  # TOKEN_GREATER_EQUAL
        emit_line(output_file, "    setge %al")
    End If
    emit_line(output_file, "    movzbq %al, %rax")
    Return 0
End Process

# Generate code for function call expressions
Process called "codegen_generate_function_call" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let function_call_ptr be expr plus 8  # &expr->data.function_call
    Let function_name be memory_get_pointer(function_call_ptr, 0)  # function_call.function_name
    Let arguments be memory_get_pointer(function_call_ptr, 8)      # function_call.arguments
    Let arg_count be memory_get_int32(function_call_ptr, 16)     # function_call.argument_count

    # Safety check for function_name
    If function_name is equal to 0:  # NULL pointer check
        exit_with_code(1)
    End If

    # Generate argument values in reverse order (right-to-left evaluation)
    Let i be arg_count minus 1
    While i is greater than or equal to 0:
        Let arg_offset be i multiplied by 8
        Let arg_expr be memory_get_pointer(arguments, arg_offset)

        # Debug check
        If arg_expr is equal to 0:
            print_string("[CODEGEN ERROR] NULL argument expression pointer: ")
            print_integer(arg_expr)
            exit_with_code(1)
        End If

        codegen_generate_expression(codegen, arg_expr)
        file_write_buffered(output_file, "    pushq %rax\n", 0)
        Let i be i minus 1
    End While

    # Pop arguments into registers
    If arg_count is greater than or equal to 1:
        file_write_buffered(output_file, "    popq %rdi\n", 0)
    End If
    If arg_count is greater than or equal to 2:
        file_write_buffered(output_file, "    popq %rsi\n", 0)
    End If
    If arg_count is greater than or equal to 3:
        file_write_buffered(output_file, "    popq %rdx\n", 0)
    End If
    If arg_count is greater than or equal to 4:
        file_write_buffered(output_file, "    popq %rcx\n", 0)
    End If
    If arg_count is greater than or equal to 5:
        file_write_buffered(output_file, "    popq %r8\n", 0)
    End If
    If arg_count is greater than or equal to 6:
        file_write_buffered(output_file, "    popq %r9\n", 0)
    End If

    # Call the function - add @PLT for external runtime functions
    file_write_buffered(output_file, "    call ", 0)
    file_write_buffered(output_file, function_name, 0)

    # Check if this is a runtime function that needs @PLT
    Let needs_plt be 0
    If string_equals(function_name, "allocate") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "deallocate") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "memory_allocate") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "memory_reallocate") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "string_length") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "string_char_at") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "string_equals") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "string_compare") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "string_find") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "string_substring") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "string_duplicate") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "string_concat") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "integer_to_string") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "ascii_value_of") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "is_digit") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "is_whitespace") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "file_open_buffered") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "file_write_buffered") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "file_close_buffered") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "memory_get_byte") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "memory_set_byte") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "memory_get_int32") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "memory_set_int32") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "memory_get_integer") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "memory_set_integer") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "memory_get_pointer") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "memory_set_pointer") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "memory_set_pointer_at_index") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "exit_with_code") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "read_file_internal") is equal to 1: Let needs_plt be 1 End If
    If string_equals(function_name, "get_command_line_arg") is equal to 1: Let needs_plt be 1 End If
    # Note: print_string, print_integer, string_copy_n, string_set_char are Runa functions - no @PLT

    If needs_plt is equal to 1:
        file_write_buffered(output_file, "@PLT", 0)
    End If
    file_write_buffered(output_file, "\n", 0)

    # Result is now in %rax (x86_64 calling convention)
    # The function result is left in %rax for the calling code to use
    Return 0
End Process

# Generate code for field access expressions
Process called "codegen_generate_field_access" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let field_access_ptr be expr plus 8  # Union at offset 4
    Let obj be memory_get_pointer(field_access_ptr, 0)
    Let field_name be memory_get_pointer(field_access_ptr, 8)

    # For simplicity in Stage 1, generate basic field access
    Let obj_type be memory_get_integer(obj, 0)

    If obj_type is equal to 1:  # EXPR_VARIABLE
        Let obj_variable_name be memory_get_pointer(obj, 8)
        Let var_index be codegen_find_variable(codegen, obj_variable_name)
        If var_index is less than 0:
            print_string("[CODEGEN ERROR] Unknown variable")
            exit_with_code(1)
        End If

        # Generate simplified field access
        Let variables be memory_get_pointer(codegen, 8)
        Let var_offset be var_index multiplied by 32
        Let var_ptr be variables plus var_offset
        Let offset be memory_get_integer(var_ptr, 8)

        file_write_buffered(output_file, "    movq -", 0)
        file_write_buffered(output_file, integer_to_string(offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax\n", 0)

        # Default field offset to 0 for simplicity
        file_write_buffered(output_file, "    movq (%rax), %rax\n", 0)
    Otherwise:
        # For complex field access, use lvalue addressing
        codegen_generate_lvalue_address(codegen, obj)
        file_write_buffered(output_file, "    movq %rbx, %rax\n", 0)
        file_write_buffered(output_file, "    movq (%rax), %rax\n", 0)
    End If

    Return 0
End Process

# Handle builtin call expressions
Process called "codegen_generate_builtin_call" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file
    Let builtin_call_ptr be expr plus 8  # &expr->data.builtin_call
    Let builtin_type be memory_get_int32(builtin_call_ptr, 0)  # builtin_call.builtin_type
    Let arguments be memory_get_pointer(builtin_call_ptr, 8)     # builtin_call.arguments
    Let arg_count be memory_get_int32(builtin_call_ptr, 16)    # builtin_call.argument_count

    # Map builtin types to function names - split into ranges to avoid deep nesting limits
    Let func_name be ""

    # First generate all argument values onto stack
    Let i be arg_count minus 1
    While i is greater than or equal to 0:
        Let arg_offset be i multiplied by 8
        Let arg_expr be memory_get_pointer(arguments, arg_offset)
        codegen_generate_expression(codegen, arg_expr)
        file_write_buffered(output_file, "    pushq %rax\n", 0)
        Let i be i minus 1
    End While

    # Pop arguments into the correct registers based on calling convention
    If arg_count is greater than or equal to 1:
        file_write_buffered(output_file, "    popq %rdi\n", 0)
    End If
    If arg_count is greater than or equal to 2:
        file_write_buffered(output_file, "    popq %rsi\n", 0)
    End If
    If arg_count is greater than or equal to 3:
        file_write_buffered(output_file, "    popq %rdx\n", 0)
    End If
    If arg_count is greater than or equal to 4:
        file_write_buffered(output_file, "    popq %rcx\n", 0)
    End If
    If arg_count is greater than or equal to 5:
        file_write_buffered(output_file, "    popq %r8\n", 0)
    End If
    If arg_count is greater than or equal to 6:
        file_write_buffered(output_file, "    popq %r9\n", 0)
    End If

    # Map builtin_type to function name
    # Since we don't have all builtins implemented, generate a generic name
    # This allows compilation to proceed but these calls won't work at runtime
    file_write_buffered(output_file, "    # Unimplemented builtin type ", 0)
    file_write_buffered(output_file, integer_to_string(builtin_type), 0)
    file_write_buffered(output_file, "\n", 0)
    file_write_buffered(output_file, "    movq $0, %rax  # Placeholder return value\n", 0)

    Return 0
End Process

# Generate code for expression - equivalent to codegen_generate_expression
# Simplified codegen_generate_expression that replaces the massive 1155-line function
# This will be inserted into codegen.runa to replace lines 1276-2431

Process called "codegen_generate_expression" takes codegen as Integer, expr as Integer returns Integer:
    # Safety check
    If expr is equal to 0:  # NULL pointer check
        print_string("[CODEGEN ERROR] NULL expression pointer")
        exit_with_code(1)
    End If

    Let expr_type be memory_get_int32(expr, 0)  # expr->type
    Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file

    # Simple dispatcher without deep nesting
    If expr_type is equal to 0:  # EXPR_INTEGER_LITERAL
        Let integer_value be memory_get_integer(expr, 8)
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(integer_value), 0)
        file_write_buffered(output_file, ", %rax\n", 0)
        Return 0
    End If

    If expr_type is equal to 1:  # EXPR_VARIABLE
        codegen_generate_variable_expr(codegen, expr)
        Return 0
    End If

    If expr_type is equal to 2:  # EXPR_BINARY_OP
        codegen_generate_binary_op(codegen, expr)
        Return 0
    End If

    If expr_type is equal to 3:  # EXPR_COMPARISON
        codegen_generate_comparison(codegen, expr)
        Return 0
    End If

    If expr_type is equal to 4:  # EXPR_FUNCTION_CALL
        codegen_generate_function_call(codegen, expr)
        Return 0
    End If

    If expr_type is equal to 5:  # EXPR_STRING_LITERAL
        codegen_generate_string_literal(codegen, expr)
        Return 0
    End If

    If expr_type is equal to 6:  # EXPR_FIELD_ACCESS
        codegen_generate_field_access(codegen, expr)
        Return 0
    End If

    If expr_type is equal to 7:  # EXPR_TYPE_CAST
        Let cast_expr be memory_get_pointer(expr, 16)
        codegen_generate_expression(codegen, cast_expr)
        Return 0
    End If

    If expr_type is equal to 8:  # EXPR_BUILTIN_CALL
        # Simplified builtin call for Stage 1
        Let builtin_call_ptr be expr plus 8  # Union at offset 4
        Let arguments be memory_get_pointer(builtin_call_ptr, 8)
        Let arg_count be memory_get_integer(builtin_call_ptr, 16)

        # Generate arguments in reverse
        Let i be arg_count minus 1
        While i is greater than or equal to 0:
            Let arg_offset be i multiplied by 8
            Let arg_expr be memory_get_pointer(arguments, arg_offset)
            codegen_generate_expression(codegen, arg_expr)
            file_write_buffered(output_file, "    pushq %rax\n", 0)
            Let i be i minus 1
        End While

        # Pop into registers
        If arg_count is greater than 0:
            file_write_buffered(output_file, "    popq %rdi\n", 0)
        End If
        If arg_count is greater than 1:
            file_write_buffered(output_file, "    popq %rsi\n", 0)
        End If
        If arg_count is greater than 2:
            file_write_buffered(output_file, "    popq %rdx\n", 0)
        End If

        # Get builtin type token and map to function name
        Let builtin_type be memory_get_int32(builtin_call_ptr, 0)
        Let func_name be 0  # Will be set based on token

        # Map TOKEN to runtime function name
        If builtin_type is equal to 57: Let func_name be "string_length" End If  # TOKEN_STRING_LENGTH
        If builtin_type is equal to 58: Let func_name be "string_char_at" End If  # TOKEN_STRING_CHAR_AT
        If builtin_type is equal to 59: Let func_name be "string_substring" End If  # TOKEN_STRING_SUBSTRING
        If builtin_type is equal to 60: Let func_name be "string_equals" End If  # TOKEN_STRING_EQUALS
        If builtin_type is equal to 61: Let func_name be "ascii_value_of" End If  # TOKEN_ASCII_VALUE_OF
        If builtin_type is equal to 62: Let func_name be "is_digit" End If  # TOKEN_IS_DIGIT
        If builtin_type is equal to 64: Let func_name be "is_whitespace" End If  # TOKEN_IS_WHITESPACE
        If builtin_type is equal to 72: Let func_name be "string_find" End If  # TOKEN_STRING_FIND
        If builtin_type is equal to 73: Let func_name be "string_compare" End If  # TOKEN_STRING_COMPARE
        If builtin_type is equal to 74: Let func_name be "string_concat" End If  # TOKEN_STRING_CONCAT
        If builtin_type is equal to 75: Let func_name be "string_duplicate" End If  # TOKEN_STRING_DUPLICATE
        If builtin_type is equal to 76: Let func_name be "integer_to_string" End If  # TOKEN_INTEGER_TO_STRING
        If builtin_type is equal to 119: Let func_name be "allocate" End If  # TOKEN_ALLOCATE
        If builtin_type is equal to 120: Let func_name be "deallocate" End If  # TOKEN_DEALLOCATE
        If builtin_type is equal to 130: Let func_name be "memory_get_byte" End If  # TOKEN_MEMORY_GET_BYTE
        If builtin_type is equal to 131: Let func_name be "memory_set_byte" End If  # TOKEN_MEMORY_SET_BYTE

        # Generate the call
        file_write_buffered(output_file, "    call ", 0)
        If func_name is equal to 0:
            file_write_buffered(output_file, "unknown_builtin_", 0)
            file_write_buffered(output_file, integer_to_string(builtin_type), 0)
        Otherwise:
            file_write_buffered(output_file, func_name, 0)
            file_write_buffered(output_file, "@PLT", 0)
        End If
        file_write_buffered(output_file, "\n", 0)
        Return 0
    End If

    If expr_type is equal to 9:  # EXPR_VARIANT_CONSTRUCTOR
        # Simplified variant for Stage 1
        file_write_buffered(output_file, "    movq $0, %rax\n", 0)
        Return 0
    End If

    If expr_type is equal to 10:  # EXPR_FUNCTION_POINTER
        Let function_pointer_ptr be expr plus 8  # Union at offset 4
        Let func_name be memory_get_pointer(function_pointer_ptr, 0)
        file_write_buffered(output_file, "    leaq ", 0)
        file_write_buffered(output_file, func_name, 0)
        file_write_buffered(output_file, "(%rip), %rax\n", 0)
        Return 0
    End If

    If expr_type is equal to 16:  # EXPR_ARRAY_INDEX
        # Simplified array indexing
        file_write_buffered(output_file, "    movq $0, %rax\n", 0)
        Return 0
    End If

    # Default case
    print_string("[CODEGEN ERROR] Unsupported expression type")
    exit_with_code(1)
    Return 0
End Process
Process called "codegen_generate_statement" takes codegen as Integer, stmt as Integer returns Integer:
    Let stmt_type be memory_get_int32(stmt, 0)  # stmt->type - use int32 not integer
    Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file

    If stmt_type is equal to 1:  # STMT_LET
        # Get the variable name first - it's always needed
        Let variable_name be memory_get_pointer(stmt, 8)  # stmt->data.let_stmt.variable_name at offset 8

        # Check if this is a type allocation
        Let let_expr be memory_get_pointer(stmt, 16)  # stmt->data.let_stmt.expression at offset 16
        If let_expr is not equal to 0:
            Let expr_type be memory_get_int32(let_expr, 0)  # expr->type
            If expr_type is equal to 7:  # EXPR_TYPE_NAME
                # This is a struct allocation - find the type
                Let type_name be memory_get_pointer(let_expr, 8)  # expr->data.type_name
                Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)
                Let type_count be memory_get_int32(current_program, 32)  # program->type_count
                Let types be memory_get_pointer(current_program, 40)  # program->types

                Let type_found be 0
                Let type_def be 0
                Let i be 0
                While i is less than type_count:
                    Let current_type be memory_get_pointer(types, i multiplied by 8)
                    Let current_type_name be memory_get_pointer(current_type, 0)  # type->name
                    If string_equals(current_type_name, type_name) is equal to 1:
                        Let type_found be 1
                        Let type_def be current_type
                        Let i be type_count  # Break
                    End If
                    Let i be i plus 1
                End While

                If type_found is equal to 0:
                    exit_with_code(1)
                    Return 1
                End If

                # Add variable with type information
                codegen_add_variable_with_type(codegen, variable_name, type_name)

                # Get variable info
                Let var_index be codegen_find_variable(codegen, variable_name)
                Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
                Let offset be memory_get_integer(variables, var_index multiplied by 32 plus 8)  # variables[var_index].stack_offset

                # Handle different type kinds
                Let type_kind be memory_get_int32(type_def, 8)  # type->kind
                Let type_size be memory_get_int32(type_def, 16)  # type->size

                If type_kind is equal to 2:  # TYPE_KIND_ARRAY
                    # For arrays, allocate space for all elements and zero out memory
                    Let i be 0
                    While i is less than type_size:
                        file_write_buffered(output_file, "    movq $0, -", 0)
                        file_write_buffered(output_file, integer_to_string(offset minus i), 0)
                        file_write_buffered(output_file, "(%rbp)  # Zero array element", 0)
                        Let i be i plus 8
                    End While

                    # Update stack offset to account for full array size
                    Let current_stack_offset be memory_get_int32(codegen, 24)  # codegen->stack_offset
                    memory_set_integer(codegen, 16, current_stack_offset plus type_size)
                Otherwise:
                    # For structs, zero out the struct memory
                    Let i be 0
                    While i is less than type_size:
                        file_write_buffered(output_file, "    movq $0, -", 0)
                        file_write_buffered(output_file, integer_to_string(offset minus i), 0)
                        file_write_buffered(output_file, "(%rbp)\n", 0)
                        Let i be i plus 8
                    End While
                End If
            Otherwise:
                # Regular expression - check if the expression returns a string or list
                If expr_type is equal to 8:  # EXPR_BUILTIN_CALL
                    Let builtin_call_ptr be let_expr plus 8  # &expr->data.builtin_call
                    Let builtin_type be memory_get_int32(builtin_call_ptr, 0)  # builtin_call.builtin_type

                    # Check for string-returning builtins (read_file, string_substring, string_concat, integer_to_string, string_replace, string_trim)
                    Let is_string_builtin be 0
                    If builtin_type is equal to 37:
                        Let is_string_builtin be 1
                    End If
                    If builtin_type is equal to 42:
                        Let is_string_builtin be 1
                    End If
                    If builtin_type is equal to 48:
                        Let is_string_builtin be 1
                    End If
                    If builtin_type is equal to 49:
                        Let is_string_builtin be 1
                    End If
                    If builtin_type is equal to 52:
                        Let is_string_builtin be 1
                    End If
                    If builtin_type is equal to 54:
                        Let is_string_builtin be 1
                    End If
                    If is_string_builtin is equal to 1:
                        codegen_add_variable_with_type(codegen, variable_name, "String")
                    Otherwise:
                        # Check for list-returning builtins (list_create, list_copy, list_merge)
                        Let is_list_builtin be 0
                        If builtin_type is equal to 19:
                            Let is_list_builtin be 1
                        End If
                        If builtin_type is equal to 31:
                            Let is_list_builtin be 1
                        End If
                        If builtin_type is equal to 32:
                            Let is_list_builtin be 1
                        End If
                        If is_list_builtin is equal to 1:
                            codegen_add_variable_with_type(codegen, variable_name, "List")
                        Otherwise:
                            # Regular integer/other builtin expression
                            codegen_add_variable(codegen, variable_name)
                        End If
                    End If
                Otherwise:
                    # Regular integer/other expression (non-builtin)
                    codegen_add_variable(codegen, variable_name)
                End If

                # Generate expression (result in %rax)
                codegen_generate_expression(codegen, let_expr)

                # Store value in variable's stack slot
                Let var_index be codegen_find_variable(codegen, variable_name)
                Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
                Let offset be memory_get_integer(variables, var_index multiplied by 32 plus 8)  # variables[var_index].stack_offset
                file_write_buffered(output_file, "    movq %rax, -", 0)
                file_write_buffered(output_file, integer_to_string(offset), 0)
                file_write_buffered(output_file, "(%rbp)\n", 0)
            End If
        End If
        Return 0
    End If

    If stmt_type is equal to 2:  # STMT_SET
        # Generate value expression (result in %rax)
        Let set_expr be memory_get_pointer(stmt, 16)  # stmt->data.set_stmt.expression
        codegen_generate_expression(codegen, set_expr)

        # Save the value on the stack
        emit_line(output_file, "    pushq %rax")

        # Generate the address of the target (result in %rbx)
        Let set_target be memory_get_pointer(stmt, 8)  # stmt->data.set_stmt.target
        codegen_generate_lvalue_address(codegen, set_target)

        # Restore value and store to target address
        emit_line(output_file, "    popq %rax")
        emit_line(output_file, "    movq %rax, (%rbx)")
        Return 0
    End If

    If stmt_type is equal to 3:  # STMT_RETURN
        # Generate expression (result in %rax)
        Let return_expr be memory_get_pointer(stmt, 8)  # stmt->data.return_stmt.expression - use pointer
        codegen_generate_expression(codegen, return_expr)

        # Function epilogue
        file_write_buffered(output_file, "    movq %rbp, %rsp\n", 0)
        file_write_buffered(output_file, "    popq %rbp\n", 0)
        file_write_buffered(output_file, "    ret\n", 0)
        Return 0
    End If

    If stmt_type is equal to 5:  # STMT_IF
        Let label_counter be memory_get_int32(codegen, 28)  # codegen->label_counter (int)
        Let label_num be label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)  # codegen->label_counter++ (int)

        Let else_label be label_num multiplied by 10 plus 1
        Let end_label be label_num multiplied by 10 plus 2

        # Generate condition (result in %rax)
        Let condition_expr be memory_get_pointer(stmt, 8)  # stmt->data.if_stmt.condition - use pointer
        codegen_generate_expression(codegen, condition_expr)

        # Test if condition is false (0)
        emit_line(output_file, "    testq %rax, %rax")
        Let jz_instruction be string_concat("    jz .L", integer_to_string(else_label))
        emit_line(output_file, jz_instruction)

        # Generate if body
        Let if_body be memory_get_pointer(stmt, 16)  # stmt->data.if_stmt.if_body
        Let if_body_count be memory_get_int32(stmt, 24)  # stmt->data.if_stmt.if_body_count
        Let ifbody_i be 0
        While ifbody_i is less than if_body_count:
            Let ifbody_stmt be memory_get_pointer(if_body, ifbody_i multiplied by 8)
            codegen_generate_statement(codegen, ifbody_stmt)
            Let ifbody_i be ifbody_i plus 1
        End While

        file_write_buffered(output_file, "    jmp .L", 0)
        file_write_buffered(output_file, integer_to_string(end_label), 0)
        file_write_buffered(output_file, "\n", 0)

        # Generate else body
        Let else_label_str be string_concat(".L", integer_to_string(else_label))
        Let else_label_line be string_concat(else_label_str, ":")
        emit_line(output_file, else_label_line)
        deallocate(else_label_str)
        deallocate(else_label_line)

        Let else_body be memory_get_pointer(stmt, 32)  # stmt->data.if_stmt.else_body
        Let else_body_count be memory_get_int32(stmt, 40)  # stmt->data.if_stmt.else_body_count
        Let elsebody_i be 0
        While elsebody_i is less than else_body_count:
            Let elsebody_stmt be memory_get_pointer(else_body, elsebody_i multiplied by 8)
            codegen_generate_statement(codegen, elsebody_stmt)
            Let elsebody_i be elsebody_i plus 1
        End While

        Let end_label_str be string_concat(".L", integer_to_string(end_label))
        Let end_label_line be string_concat(end_label_str, ":")
        emit_line(output_file, end_label_line)
        deallocate(end_label_str)
        deallocate(end_label_line)
        Return 0
    End If

    If stmt_type is equal to 6:  # STMT_WHILE
        Let label_counter be memory_get_int32(codegen, 28)  # codegen->label_counter (int)
        # Try to use it without printing to see if it works
        If label_counter is greater than 1000000:
        End If
        Let label_num be label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)  # codegen->label_counter++ (int)

        Let loop_start be label_num multiplied by 10 plus 1
        Let loop_end be label_num multiplied by 10 plus 2

        # Push loop context for break/continue statements
        codegen_push_loop_context(codegen, loop_start, loop_end)

        # Loop start label
        file_write_buffered(output_file, ".L", 0)
        Let loop_start_str be integer_to_string(loop_start)
        file_write_buffered(output_file, loop_start_str, 0)
        file_write_buffered(output_file, ":", 0)

        # Generate condition (result in %rax)
        Let condition_expr be memory_get_pointer(stmt, 8)  # stmt->data.while_stmt.condition
        codegen_generate_expression(codegen, condition_expr)

        # Test if condition is false (0)
        emit_line(output_file, "    testq %rax, %rax")
        Let jz_instruction be string_concat("    jz .L", integer_to_string(loop_end))
        emit_line(output_file, jz_instruction)

        # Generate loop body
        Let whilebody be memory_get_pointer(stmt, 16)  # stmt->data.while_stmt.body
        Let whilebody_count be memory_get_int32(stmt, 24)  # stmt->data.while_stmt.body_count
        Let whilebody_i be 0
        While whilebody_i is less than whilebody_count:
            Let whilebody_stmt be memory_get_pointer(whilebody, whilebody_i multiplied by 8)
            codegen_generate_statement(codegen, whilebody_stmt)
            Let whilebody_i be whilebody_i plus 1
        End While

        # Jump back to loop start
        file_write_buffered(output_file, "    jmp .L", 0)
        file_write_buffered(output_file, integer_to_string(loop_start), 0)
        file_write_buffered(output_file, "\n", 0)

        # Loop end label
        Let loop_end_str be string_concat(".L", integer_to_string(loop_end))
        Let loop_end_line be string_concat(loop_end_str, ":")
        emit_line(output_file, loop_end_line)
        deallocate(loop_end_str)
        deallocate(loop_end_line)

        # Pop loop context
        codegen_pop_loop_context(codegen)
        Return 0
    End If

    If stmt_type is equal to 9:  # STMT_BREAK
        Let loop_ctx be codegen_current_loop_context(codegen)
        If loop_ctx is not equal to 0:
            Let break_label be memory_get_int32(loop_ctx, 8)  # loop_ctx->break_label
            file_write_buffered(output_file, "    jmp .L", 0)
            file_write_buffered(output_file, integer_to_string(break_label), 0)
            file_write_buffered(output_file, "\n", 0)
        Otherwise:
            exit_with_code(1)
        End If
        Return 0
    End If

    If stmt_type is equal to 10:  # STMT_CONTINUE
        Let loop_ctx be codegen_current_loop_context(codegen)
        If loop_ctx is not equal to 0:
            Let continue_label be memory_get_int32(loop_ctx, 0)  # loop_ctx->continue_label
            file_write_buffered(output_file, "    jmp .L", 0)
            file_write_buffered(output_file, integer_to_string(continue_label), 0)
            file_write_buffered(output_file, "\n", 0)
        Otherwise:
            exit_with_code(1)
        End If
        Return 0
    End If

    If stmt_type is equal to 16:  # STMT_INLINE_ASSEMBLY
        # Generate raw assembly instructions
        Let assembly_line_count be memory_get_int32(stmt, 8)  # stmt->data.inline_assembly_stmt.assembly_line_count
        Let assembly_lines be memory_get_pointer(stmt, 16)  # stmt->data.inline_assembly_stmt.assembly_lines

        Let i be 0
        While i is less than assembly_line_count:
            Let instruction be memory_get_pointer(assembly_lines, i multiplied by 8)

            # Process escape sequences (especially \n)
            Let instruction_len be string_length(instruction)
            Let processed be allocate(instruction_len plus 1)
            Let src be 0
            Let dst be 0
            While src is less than instruction_len:
                Let current_char be string_char_at(instruction, src)
                If current_char is equal to 92:  # '\' character
                    If src plus 1 is less than instruction_len:
                        Let next_char be string_char_at(instruction, src plus 1)
                        If next_char is equal to 110:  # 'n' character
                            # Skip the \n escape sequence - we don't need newlines in assembly instructions
                            Let src be src plus 2
                        Otherwise:
                            If next_char is equal to 116:  # 't' character
                                memory_set_byte(processed, dst, 9)  # Tab character
                                Let dst be dst plus 1
                                Let src be src plus 2
                            Otherwise:
                                If next_char is equal to 92:  # '\' character
                                    memory_set_byte(processed, dst, 92)  # '\' character
                                    Let dst be dst plus 1
                                    Let src be src plus 2
                                Otherwise:
                                    memory_set_byte(processed, dst, current_char)
                                    Let dst be dst plus 1
                                    Let src be src plus 1
                                End If
                            End If
                        End If
                    Otherwise:
                        memory_set_byte(processed, dst, current_char)
                        Let dst be dst plus 1
                        Let src be src plus 1
                    End If
                Otherwise:
                    memory_set_byte(processed, dst, current_char)
                    Let dst be dst plus 1
                    Let src be src plus 1
                End If
            End While
            memory_set_byte(processed, dst, 0)  # Null terminator

            emit_line(output_file, "")
            file_write_buffered(output_file, processed, 0)
            file_write_buffered(output_file, "\n", 0)

            deallocate(processed)
            Let i be i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 4:  # STMT_PRINT
        # Generate expression (result in %rax)
        Let print_expr be memory_get_pointer(stmt, 8)  # stmt->data.print_stmt.expression
        codegen_generate_expression(codegen, print_expr)

        # Call appropriate print function based on expression type
        Let expr_type be memory_get_int32(print_expr, 0)  # expr->type
        If expr_type is equal to 5:  # EXPR_STRING_LITERAL
            # String literal - call print_string
            file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
            file_write_buffered(output_file, "    call print_string\n", 0)
        Otherwise:
            If expr_type is equal to 8:  # EXPR_BUILTIN_CALL
                Let builtin_call_ptr be print_expr plus 8  # &expr->data.builtin_call
                Let builtin_type be memory_get_int32(builtin_call_ptr, 0)  # builtin_call.builtin_type
                # Check for string-returning builtins (read_file, string_substring, string_concat, integer_to_string, string_replace, string_trim)
                Let is_string_builtin be 0
                If builtin_type is equal to 37:
                    Let is_string_builtin be 1
                End If
                If builtin_type is equal to 42:
                    Let is_string_builtin be 1
                End If
                If builtin_type is equal to 48:
                    Let is_string_builtin be 1
                End If
                If builtin_type is equal to 49:
                    Let is_string_builtin be 1
                End If
                If builtin_type is equal to 52:
                    Let is_string_builtin be 1
                End If
                If builtin_type is equal to 54:
                    Let is_string_builtin be 1
                End If
                If is_string_builtin is equal to 1:
                    # These functions return strings - call print_string
                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                    file_write_buffered(output_file, "    call print_string\n", 0)
                Otherwise:
                    # Integer expression - call print_integer
                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                    file_write_buffered(output_file, "    call print_integer\n", 0)
                End If
            Otherwise:
                If expr_type is equal to 1:  # EXPR_VARIABLE
                    # Check variable type to determine appropriate print function
                    Let variable_name be memory_get_pointer(print_expr, 8)  # expr->data.variable_name
                    Let var_index be codegen_find_variable(codegen, variable_name)
                    If var_index is greater than or equal to 0:
                        Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
                        Let type_name be memory_get_pointer(variables, var_index multiplied by 32 plus 16)  # variables[var_index].type_name
                        If type_name is not equal to 0:
                            If string_equals(type_name, "String") is equal to 1:
                                # This variable contains a string - call print_string
                                file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                                file_write_buffered(output_file, "    call print_string\n", 0)
                            Otherwise:
                                If string_equals(type_name, "List") is equal to 1:
                                    # This variable contains a list pointer - print as integer address
                                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                                    file_write_buffered(output_file, "    call print_integer\n", 0)
                                Otherwise:
                                    # Assume integer for other variables
                                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                                    file_write_buffered(output_file, "    call print_integer\n", 0)
                                End If
                            End If
                        Otherwise:
                            # Assume integer for untyped variables
                            file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                            file_write_buffered(output_file, "    call print_integer\n", 0)
                        End If
                    Otherwise:
                        # Variable not found, assume integer
                        file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                        file_write_buffered(output_file, "    call print_integer\n", 0)
                    End If
                Otherwise:
                    # Integer expression (literal, arithmetic) - call print_integer
                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                    file_write_buffered(output_file, "    call print_integer\n", 0)
                End If
            End If
        End If
        Return 0
    End If

    If stmt_type is equal to 7:  # STMT_EXPRESSION
        # Generate the expression and ignore its result
        Let expr_stmt_expr be memory_get_pointer(stmt, 8)  # stmt->data.expr_stmt.expression
        codegen_generate_expression(codegen, expr_stmt_expr)
        Return 0
    End If

    If stmt_type is equal to 8:  # STMT_IMPORT
        # Imports are handled at program level, no code generation needed
        Return 0
    End If

    If stmt_type is equal to 7:  # STMT_MATCH
        # Evaluate the expression to match on
        Let match_expr be memory_get_pointer(stmt, 8)  # stmt->data.match_stmt.expression
        codegen_generate_expression(codegen, match_expr)
        file_write_buffered(output_file, "    pushq %rax  # Save match expression value", 0)

        # Generate unique labels for each case and the end
        Let label_counter be memory_get_int32(codegen, 28)  # codegen->label_counter (int)
        Let match_id be label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)  # codegen->label_counter++ (int)

        Let end_label be string_concat(".match_end_", integer_to_string(match_id))

        # Generate code for each case
        Let case_count be memory_get_int32(stmt, 16)  # stmt->data.match_stmt.case_count
        Let cases be memory_get_pointer(stmt, 24)  # stmt->data.match_stmt.cases

        Let i be 0
        While i is less than case_count:
            Let case_offset be i multiplied by 64
            Let match_case be cases plus case_offset  # sizeof(MatchCase) estimate
            Let variant_name be memory_get_pointer(match_case, 0)  # match_case->variant_name
            Let field_count be memory_get_int32(match_case, 8)  # match_case->field_count
            Let field_names be memory_get_pointer(match_case, 16)  # match_case->field_names
            Let body_count be memory_get_int32(match_case, 24)  # match_case->body_count
            Let body be memory_get_pointer(match_case, 32)  # match_case->body

            Let case_label be string_concat(".match_case_", string_concat(integer_to_string(match_id), string_concat("_", integer_to_string(i))))
            Let next_case_id be i plus 1
            Let next_label be string_concat(".match_case_", string_concat(integer_to_string(match_id), string_concat("_", integer_to_string(next_case_id))))

            # Check if this case matches
            file_write_buffered(output_file, case_label, 0)
            file_write_buffered(output_file, ":", 0)
            file_write_buffered(output_file, "    popq %rax  # Get match expression\n", 0)
            file_write_buffered(output_file, "    pushq %rax  # Keep on stack", 0)

            # Load the tag from the variant
            file_write_buffered(output_file, "    movq (%rax), %rdx  # Load variant tag", 0)

            # Find the tag value for this variant name - ADT variant tags are sequential starting from 0
            file_write_buffered(output_file, "    cmpq $", 0)
            file_write_buffered(output_file, integer_to_string(i), 0)
            file_write_buffered(output_file, ", %rdx  # Check tag for ", 0)
            file_write_buffered(output_file, variant_name, 0)
            file_write_buffered(output_file, "\n", 0)

            If i is less than case_count minus 1:
                file_write_buffered(output_file, "    jne ", 0)
                file_write_buffered(output_file, next_label, 0)
                file_write_buffered(output_file, "  # Jump to next case", 0)
            Otherwise:
                file_write_buffered(output_file, "    jne ", 0)
                file_write_buffered(output_file, end_label, 0)
                file_write_buffered(output_file, "  # No match, exit", 0)
            End If

            # If we matched, extract fields and bind to local variables
            If field_count is greater than 0:
                # Pop the variant pointer
                file_write_buffered(output_file, "    popq %rax  # Get variant pointer\n", 0)
                file_write_buffered(output_file, "    pushq %rax  # Keep on stack", 0)

                # ADT fields start at offset 8 (after tag) with 8 bytes per field
                Let j be 0
                While j is less than field_count:
                    Let field_offset_value be j multiplied by 8
                    Let field_offset be 8 plus field_offset_value
                    file_write_buffered(output_file, "    movq ", 0)
                    file_write_buffered(output_file, integer_to_string(field_offset), 0)
                    file_write_buffered(output_file, "(%rax), %rdx  # Load field ", 0)
                    file_write_buffered(output_file, integer_to_string(j), 0)
                    file_write_buffered(output_file, "\n", 0)

                    # Create a local variable for the binding - allocate stack space properly
                    Let current_stack_offset be memory_get_int32(codegen, 24)  # codegen->stack_offset
                    Let new_stack_offset be current_stack_offset plus 8
                    memory_set_integer(codegen, 16, new_stack_offset)

                    file_write_buffered(output_file, "    movq %rdx, -", 0)
                    file_write_buffered(output_file, integer_to_string(new_stack_offset), 0)
                    Let field_name be memory_get_pointer(field_names, j multiplied by 8)
                    file_write_buffered(output_file, "(%rbp, 0)  # Store ", 0)
                    file_write_buffered(output_file, field_name, 0)
                    file_write_buffered(output_file, " at stack offset", 0)

                    # Add the binding to the variable table with correct offset
                    Let variable_count be memory_get_int32(codegen, 16)  # codegen->variable_count (int)
                    Let variable_capacity be memory_get_int32(codegen, 24)  # codegen->variable_capacity
                    If variable_count is greater than or equal to variable_capacity:
                        Let new_capacity be variable_capacity multiplied by 2
                        memory_set_integer(codegen, 24, new_capacity)
                        Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
                        Let new_variables be reallocate(variables, new_capacity multiplied by 32)  # sizeof(Variable) = 32
                        memory_set_pointer(codegen, 8, new_variables)
                    End If

                    Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
                    Let var_idx_offset be variable_count multiplied by 32  # sizeof(Variable) = 32
                    memory_set_pointer(variables, var_idx_offset, string_duplicate(field_name))  # name
                    memory_set_integer(variables, var_idx_offset plus 8, new_stack_offset)  # stack_offset
                    memory_set_pointer(variables, var_idx_offset plus 16, string_duplicate("Integer"))  # type_name
                    memory_set_int32(codegen, 12, variable_count plus 1)  # Increment variable_count

                    Let j be j plus 1
                End While
            End If

            # Generate the case body
            Let k be 0
            While k is less than body_count:
                Let current_stmt be memory_get_pointer(body, k multiplied by 8)
                codegen_generate_statement(codegen, current_stmt)
                Let k be k plus 1
            End While

            # Clean up bindings from variable table but keep stack offset
            If field_count is greater than 0:
                # Free the variable names we allocated
                Let j be 0
                While j is less than field_count:
                    Let variable_count be memory_get_int32(codegen, 16)  # codegen->variable_count (int)
                    Let var_idx be variable_count minus field_count plus j
                    Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
                    Let var_name be memory_get_integer(variables, var_idx multiplied by 24)
                    Let var_type_name be memory_get_integer(variables, var_idx multiplied by 24 plus 16)
                    deallocate(var_name)
                    deallocate(var_type_name)
                    Let j be j plus 1
                End While
                # Remove from variable table
                Let variable_count be memory_get_int32(codegen, 16)  # codegen->variable_count (int)
                memory_set_integer(codegen, 12, variable_count minus field_count)
            End If

            # Jump to end
            file_write_buffered(output_file, "    jmp ", 0)
            file_write_buffered(output_file, end_label, 0)
            file_write_buffered(output_file, "\n", 0)

            Let i be i plus 1
        End While

        file_write_buffered(output_file, end_label, 0)
        file_write_buffered(output_file, ":", 0)
        file_write_buffered(output_file, "    popq %rax  # Clean up match expression\n", 0)
        Return 0
    End If

    Return 0
End Process

# Create a new code generator - equivalent to codegen_create
Process called "codegen_create" takes output_filename as Integer returns Integer:
    Let codegen be allocate(72)  # sizeof(CodeGenerator)

    # Note: allocate() uses calloc() which already zeros the memory,
    # so no explicit initialization loop is needed

    Let output_file be file_open_buffered(output_filename, 1)  # 1 = write mode (O_WRONLY | O_CREAT | O_TRUNC)
    If output_file is less than 0:  # Negative indicates error
        # Failed to open output file
        deallocate(codegen)
        Return 0
    End If
    memory_set_integer(codegen, 0, output_file)  # codegen->output_file

    Let variables be allocate(16 multiplied by 32)  # 16 * sizeof(Variable) - Variable is 32 bytes
    memory_set_pointer(codegen, 8, variables)  # codegen->variables
    memory_set_int32(codegen, 16, 0)  # codegen->variable_count (int)
    memory_set_int32(codegen, 20, 16)  # codegen->variable_capacity (int) - Start with space for 16 variables


    memory_set_int32(codegen, 24, 0)  # codegen->stack_offset (int)
    memory_set_int32(codegen, 28, 0)  # codegen->label_counter (int)
    memory_set_int32(codegen, 40, 0)  # codegen->string_count (int)
    memory_set_int32(codegen, 44, 512)  # codegen->string_capacity (int) - Start with space for 512 strings

    Let strings be allocate(512 multiplied by 16)  # 512 * sizeof(StringLiteral)
    memory_set_pointer(codegen, 32, strings)  # codegen->strings (pointer with padding)
    memory_set_pointer(codegen, 48, 0)  # codegen->current_program (pointer with padding)
    memory_set_int32(codegen, 64, 0)  # codegen->loop_depth (int)
    memory_set_int32(codegen, 68, 8)  # codegen->loop_capacity (int) - Start with space for 8 nested loops

    Let loop_stack be allocate(8 multiplied by 16)  # 8 * sizeof(LoopContext)
    memory_set_pointer(codegen, 56, loop_stack)  # codegen->loop_stack (pointer)

    If output_file is equal to 0:
        deallocate(variables)
        deallocate(strings)
        deallocate(loop_stack)
        deallocate(codegen)
        Return 0
    End If

    Return codegen
End Process

# Destroy a code generator - equivalent to codegen_destroy
Process called "codegen_destroy" takes codegen as Integer returns Integer:
    If codegen is not equal to 0:
        Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file
        If output_file is not equal to 0:
            file_close_fd(output_file)
        End If

        # Free variable names and type names
        # Read 32-bit variable_count correctly
        Let byte0 be memory_get_byte(codegen, 16)
        Let byte1 be memory_get_byte(codegen, 17)
        Let byte2 be memory_get_byte(codegen, 18)
        Let byte3 be memory_get_byte(codegen, 19)
        Let temp1 be byte1 multiplied by 256
        Let temp2 be byte2 multiplied by 65536
        Let temp3 be byte3 multiplied by 16777216
        Let variable_count be byte0 plus temp1 plus temp2 plus temp3

        Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
        If variables is not equal to 0:
            Let i be 0
            While i is less than variable_count:
                Let var_offset be i multiplied by 32  # sizeof(Variable) = 32
                Let var_ptr be variables plus var_offset
                Let var_name be memory_get_pointer(var_ptr, 0)  # Variable.name at offset 0
                Let var_type_name be memory_get_pointer(var_ptr, 16)  # Variable.type_name at offset 16
                If var_name is not equal to 0:
                    deallocate(var_name)
                End If
                If var_type_name is not equal to 0:
                    deallocate(var_type_name)
                End If
                Let i be i plus 1
            End While
        End If

        # Free string literal values and labels
        # Read 32-bit string_count correctly
        Let byte0 be memory_get_byte(codegen, 40)
        Let byte1 be memory_get_byte(codegen, 41)
        Let byte2 be memory_get_byte(codegen, 42)
        Let byte3 be memory_get_byte(codegen, 43)
        Let temp1 be byte1 multiplied by 256
        Let temp2 be byte2 multiplied by 65536
        Let temp3 be byte3 multiplied by 16777216
        Let string_count be byte0 plus temp1 plus temp2 plus temp3

        Let strings be memory_get_pointer(codegen, 32)  # codegen->strings (pointer with padding)
        If strings is not equal to 0:
            Let i be 0
            While i is less than string_count:
                Let str_offset be i multiplied by 16  # sizeof(StringLiteral) = 16
                Let str_ptr be strings plus str_offset
                Let str_value be memory_get_pointer(str_ptr, 0)  # StringLiteral.value at offset 0
                Let str_label be memory_get_pointer(str_ptr, 8)  # StringLiteral.label at offset 8
                If str_value is not equal to 0:
                    deallocate(str_value)
                End If
                If str_label is not equal to 0:
                    deallocate(str_label)
                End If
                Let i be i plus 1
            End While
        End If

        If variables is not equal to 0:
            deallocate(variables)
        End If
        If strings is not equal to 0:
            deallocate(strings)
        End If
        Let loop_stack be memory_get_pointer(codegen, 56)  # codegen->loop_stack (pointer)
        If loop_stack is not equal to 0:
            deallocate(loop_stack)
        End If
        deallocate(codegen)
    End If
    Return 0
End Process

# Push a new loop context for break/continue handling - equivalent to codegen_push_loop_context
Process called "codegen_push_loop_context" takes codegen as Integer, continue_label as Integer, break_label as Integer returns Integer:
    Let loop_depth be memory_get_int32(codegen, 64)  # codegen->loop_depth (int)
    Let loop_capacity be memory_get_int32(codegen, 68)  # codegen->loop_capacity (int)

    # Expand loop stack if necessary
    If loop_depth is greater than or equal to loop_capacity:
        Let new_capacity be loop_capacity multiplied by 2
        memory_set_int32(codegen, 68, new_capacity)  # codegen->loop_capacity (int)
        Let loop_stack be memory_get_pointer(codegen, 56)  # codegen->loop_stack (pointer)
        Let new_loop_stack be memory_reallocate(loop_stack, 16 multiplied by new_capacity)  # sizeof(LoopContext) * new_capacity
        memory_set_pointer(codegen, 56, new_loop_stack)  # codegen->loop_stack (pointer)
    End If

    Let loop_stack be memory_get_pointer(codegen, 56)  # codegen->loop_stack
    Let context_offset be loop_depth multiplied by 16  # sizeof(LoopContext)
    memory_set_integer(loop_stack, context_offset, continue_label)  # continue_label
    memory_set_integer(loop_stack, context_offset plus 8, break_label)  # break_label
    memory_set_int32(codegen, 64, loop_depth plus 1)  # Increment loop_depth (int)
    Return 0
End Process

# Pop the current loop context - equivalent to codegen_pop_loop_context
Process called "codegen_pop_loop_context" takes codegen as Integer returns Integer:
    Let loop_depth be memory_get_int32(codegen, 64)  # codegen->loop_depth (int)
    If loop_depth is greater than 0:
        memory_set_int32(codegen, 64, loop_depth minus 1)  # codegen->loop_depth (int)
    End If
    Return 0
End Process

# Get the current loop context - equivalent to codegen_current_loop_context
Process called "codegen_current_loop_context" takes codegen as Integer returns Integer:
    Let loop_depth be memory_get_int32(codegen, 64)  # codegen->loop_depth (int)
    If loop_depth is greater than 0:
        Let loop_stack be memory_get_pointer(codegen, 56)  # codegen->loop_stack (pointer)
        Let loop_index be loop_depth minus 1
        Let context_offset be loop_index multiplied by 16  # sizeof(LoopContext)
        Return loop_stack plus context_offset
    End If
    Return 0  # NULL
End Process

# Generate code for a function - equivalent to codegen_generate_function
Process called "codegen_generate_function" takes codegen as Integer, func as Integer returns Integer:
    # Reset variable state for each function
    memory_set_int32(codegen, 16, 0)  # codegen->variable_count = 0
    memory_set_int32(codegen, 24, 0)  # codegen->stack_offset = 0
    memory_set_int32(codegen, 64, 0)  # codegen->loop_depth = 0 (int)

    Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file
    Let func_name be memory_get_pointer(func, 0)  # func->name

    # Export function as global symbol for cross-module linking
    file_write_buffered(output_file, ".globl ", 0)
    file_write_buffered(output_file, func_name, 0)
    file_write_buffered(output_file, "\n", 0)

    # Function label
    file_write_buffered(output_file, func_name, 0)
    file_write_buffered(output_file, ":\n", 0)

    # Function prologue
    emit_line(output_file, "    pushq %rbp")
    emit_line(output_file, "    movq %rsp, %rbp")

    # Handle parameters (System V ABI: %rdi, %rsi, %rdx, %rcx, %r8, %r9)
    Let param_registers be allocate(6 multiplied by 8)  # Array of 6 string pointers
    memory_set_pointer(param_registers, 0, "%rdi")
    memory_set_pointer(param_registers, 8, "%rsi")
    memory_set_pointer(param_registers, 16, "%rdx")
    memory_set_pointer(param_registers, 24, "%rcx")
    memory_set_pointer(param_registers, 32, "%r8")
    memory_set_pointer(param_registers, 40, "%r9")
    Let max_register_params be 6

    Let parameter_count be memory_get_int32(func, 16)  # func->parameter_count

    # If this is main function with argc/argv parameters, initialize command line args
    If string_equals(func_name, "main") is equal to 1:
        If parameter_count is greater than or equal to 2:
            # Store original argc and argv before processing them as Runa parameters
            emit_line(output_file, "    # Initialize command line arguments")
            emit_line(output_file, "    pushq %rdi  # Save argc")
            emit_line(output_file, "    pushq %rsi  # Save argv")
            emit_line(output_file, "    call runtime_set_command_line_args@PLT")
            emit_line(output_file, "    popq %rsi   # Restore argv")
            emit_line(output_file, "    popq %rdi   # Restore argc")
        End If
    End If

    # CRITICAL FIX: Allocate stack space BEFORE any stack access to prevent Valgrind violations
    # Pre-allocate generous stack space for all function variables and temporaries
    # Increased from 512 to 2048 to handle parser functions with many locals
    emit_line(output_file, "    subq $2048, %rsp  # Pre-allocate generous stack space")

    Let parameters be memory_get_pointer(func, 8)  # func->parameters (Parameter*)
    Let i be 0
    Let should_continue be 1
    While should_continue is equal to 1:
        If i is greater than or equal to parameter_count:
            Let should_continue be 0
        End If
        If i is greater than or equal to max_register_params:
            Let should_continue be 0
        End If
        If should_continue is equal to 1:
        # Add parameter as a variable and store from appropriate register
        # Use the parameter type from the function definition
        Let param_offset be i multiplied by 16  # sizeof(Parameter)
        Let param_name be memory_get_pointer(parameters, param_offset)  # parameters[i].name
        Let param_type be memory_get_pointer(parameters, param_offset plus 8)  # parameters[i].type
        If param_type is equal to 0:
            Let param_type be "Integer"  # Default type
        End If

        Let param_index be codegen_add_variable_with_type_and_param_flag(codegen, param_name, param_type, 1)  # Mark as parameter
        Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
        Let var_offset be param_index multiplied by 32  # sizeof(Variable) = 32, not 24!
        Let var_ptr be variables plus var_offset
        Let param_stack_offset be memory_get_int32(var_ptr, 8)  # variables[param_index].stack_offset
        Let register_name be memory_get_pointer(param_registers, i multiplied by 8)
        file_write_buffered(output_file, "    movq ", 0)
        file_write_buffered(output_file, register_name, 0)
        file_write_buffered(output_file, ", -", 0)
        file_write_buffered(output_file, integer_to_string(param_stack_offset), 0)
        file_write_buffered(output_file, "(%rbp)\n", 0)

        Let i be i plus 1
        End If  # End of should_continue check
    End While

    # Handle parameters beyond 6 (passed on stack in System V ABI)
    Let i be max_register_params
    While i is less than parameter_count:
        Let param_offset be i multiplied by 16  # sizeof(Parameter)
        Let param_name be memory_get_pointer(parameters, param_offset)  # parameters[i].name
        Let param_type be memory_get_pointer(parameters, param_offset plus 8)  # parameters[i].type
        Let param_index be codegen_add_variable_with_type_and_param_flag(codegen, param_name, param_type, 1)  # Mark as parameter
        Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
        Let var_offset be param_index multiplied by 32  # sizeof(Variable) = 32, not 24!
        Let var_ptr be variables plus var_offset
        Let param_stack_offset be memory_get_int32(var_ptr, 8)  # variables[param_index].stack_offset

        # Stack parameters are at positive offsets from rbp: 16(%rbp), 24(%rbp), etc.
        Let stack_param_index be i minus max_register_params
        Let stack_param_offset_value be stack_param_index multiplied by 8
        Let stack_param_offset be 16 plus stack_param_offset_value
        file_write_buffered(output_file, "    movq ", 0)
        file_write_buffered(output_file, integer_to_string(stack_param_offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax\n", 0)
        file_write_buffered(output_file, "    movq %rax, -", 0)
        file_write_buffered(output_file, integer_to_string(param_stack_offset), 0)
        file_write_buffered(output_file, "(%rbp)", 0)

        Let i be i plus 1
    End While

    # Generate function body statements
    # Function structure has:
    # offset 24: return_type (string)
    # offset 32: statements (Statement** array)
    # offset 40: statement_count (int)
    Let statement_count be memory_get_int32(func, 40)  # func->statement_count
    Let statements be memory_get_pointer(func, 32)     # func->statements

    If statements is not equal to 0:
        Let stmt_idx be 0
        While stmt_idx is less than statement_count:
            Let stmt_offset be stmt_idx multiplied by 8
            Let stmt be memory_get_pointer(statements, stmt_offset)  # statements[stmt_idx]
            If stmt is not equal to 0:
                codegen_generate_statement(codegen, stmt)
            End If
            Let stmt_idx be stmt_idx plus 1
        End While
    End If

    # Add function epilogue if function doesn't end with explicit return
    emit_line(output_file, "    movq %rbp, %rsp")
    emit_line(output_file, "    popq %rbp")
    emit_line(output_file, "    ret")

    deallocate(param_registers)
    Return 0
End Process

# Main code generation entry point - equivalent to codegen_generate
Process called "codegen_generate" takes codegen as Integer, program as Integer returns Integer:

    # Store program reference for type lookups
    memory_set_pointer(codegen, 48, program)  # codegen->current_program = program (pointer with padding)

    Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file

    # Check if program is initialized properly
    Let import_count be memory_get_int32(program, 40)  # PROGRAM_IMPORT_COUNT - use int32 not integer
    # Instead check if it's a reasonable value first
    If import_count is equal to 0:
    Otherwise:
    End If

    # Safety check to prevent accessing invalid memory
    If import_count is less than 0:
        Let import_count be 0
    End If
    If import_count is greater than 1000:
        Let import_count be 0
    End If

    # Generate import comments (for documentation)
    If import_count is greater than 0:
        file_write_buffered(output_file, "# Imports:", 0)
        Let imports be memory_get_pointer(program, 32)  # PROGRAM_IMPORTS - should be pointer not integer
        Let i be 0
        While i is less than import_count:
            Let import be memory_get_pointer(imports, i multiplied by 8)
            Let import_filename be memory_get_integer(import, 0)  # import->filename
            Let module_name be memory_get_integer(import, 8)  # import->module_name
            file_write_buffered(output_file, "#   Import ", 0)
            file_write_buffered(output_file, import_filename, 0)
            file_write_buffered(output_file, " as ", 0)
            file_write_buffered(output_file, module_name, 0)
            file_write_buffered(output_file, "\n", 0)
            Let i be i plus 1
        End While
        file_write_buffered(output_file, "\n", 0)
    End If

    # First pass: collect all string literals by analyzing the AST
    Let function_count be memory_get_int32(program, 8)   # PROGRAM_FUNCTION_COUNT - use int32

    # Safety check: if function_count is negative or too large, assume no functions
    If function_count is less than 0:
        Let function_count be 0
    End If
    If function_count is greater than 10000:  # Sanity check
        Let function_count be 0
    End If

    Let functions be memory_get_pointer(program, 0)        # PROGRAM_FUNCTIONS - use pointer

    # Safety check - if functions is NULL, return error
    If functions is equal to 0:
        print_string("[ERROR] codegen_generate: functions pointer is NULL")
        Return 0
    End If

    Let i be 0
    While i is less than function_count:

        Let func be memory_get_pointer(functions, i multiplied by 8)



        # Safety check for function pointer - skip NULL pointers
        If func is not equal to 0:
                # Function structure in parser.runa has:
                # FUNCTION_STATEMENTS at 32 (Statement** - array of statements)
                # FUNCTION_STATEMENT_COUNT at 40

                Let func_name be memory_get_pointer(func, 0)  # func->name
                Let statements_array be memory_get_pointer(func, 32)  # func->statements (Statement**)

                Let statement_count be memory_get_int32(func, 40)  # func->statement_count

                # Process each statement in the function

                If statements_array is not equal to 0:
                    If statement_count is greater than 0:
                        # Process ALL statements in the function body

                        Let stmt_idx be 0
                        While stmt_idx is less than statement_count:

                            # Get the statement at index stmt_idx
                            Let stmt_offset be stmt_idx multiplied by 8  # pointer size
                            Let body_statement be memory_get_pointer(statements_array, stmt_offset)


                            # Process the statement
                            Let result be 0
                            If body_statement is not equal to 0:
                                Let result be codegen_collect_strings_from_statement(codegen, body_statement)

                                # Check if function reported critical error
                                If result is not equal to 0:
                                    Return 0
                                End If
                            End If

                            # Move to next statement
                            Let stmt_idx be stmt_idx plus 1
                        End While
                End If
            End If
        End If
        Let i be i plus 1
    End While


    # WORKAROUND removed - string collection is now working!

    # Generate .rodata section with string literals

    # WORKAROUND: memory_get_integer reads 64 bits but we stored 32-bit values
    # Read just the 32-bit value by reading 4 bytes as individual bytes
    Let byte0 be memory_get_byte(codegen, 40)
    Let byte1 be memory_get_byte(codegen, 41)
    Let byte2 be memory_get_byte(codegen, 42)
    Let byte3 be memory_get_byte(codegen, 43)

    Let temp1 be byte1 multiplied by 256
    Let temp2 be byte2 multiplied by 65536
    Let temp3 be byte3 multiplied by 16777216
    Let string_count be byte0 plus temp1 plus temp2 plus temp3



    # Safety check - string_count should be reasonable (0-1000)
    If string_count is less than 0:
        Let string_count be 0
    End If
    # Don't limit string literals - allow as many as needed
    # If string_count is greater than 1000:
    #     Let string_count be 0
    # End If

    print_integer(string_count)
    If string_count is greater than 0:
        emit_line(output_file, ".section .rodata")
        Let strings be memory_get_pointer(codegen, 32)  # codegen->strings (pointer with padding)
        Let i be 0
        While i is less than string_count:
            Let str_label be memory_get_pointer(strings, i multiplied by 16 plus 8)  # strings[i].label
            Let str_value be memory_get_pointer(strings, i multiplied by 16)  # strings[i].value
            # Format: .STR0:    .string "value"
            # FIXME: Quotes are currently omitted because Runa doesn't support escape sequences
            # The assembler accepts strings without quotes in some cases, though it's non-standard
            file_write_buffered(output_file, str_label, 0)
            file_write_buffered(output_file, ":", 0)
            file_write_buffered(output_file, "    .string ", 0)
            # Write a quote byte directly
            Let quote_bytes be memory_allocate(2)
            memory_set_byte(quote_bytes, 0, 34)  # ASCII for double quote
            memory_set_byte(quote_bytes, 1, 0)   # Null terminator
            file_write_buffered(output_file, quote_bytes, 0)
            file_write_buffered(output_file, str_value, 0)
            file_write_buffered(output_file, quote_bytes, 0)
            file_write_buffered(output_file, "\n", 0)
            deallocate(quote_bytes)
            Let i be i plus 1
        End While
        emit_line(output_file, "")  # Just a blank line for readability
    End If

    # Generate .data section for initialized global variables
    Let global_count be memory_get_int32(program, 56)  # PROGRAM_GLOBAL_COUNT - use int32
    Let globals be memory_get_pointer(program, 48)       # PROGRAM_GLOBAL_VARS - use pointer
    Let has_initialized_globals be 0
    Let i be 0
    While i is less than global_count:
        Let global be memory_get_pointer(globals, i multiplied by 8)
        Let initial_value be memory_get_pointer(global, 16)  # global->initial_value
        If initial_value is not equal to 0:
            Let has_initialized_globals be 1
            Let i be global_count  # Break
        End If
        Let i be i plus 1
    End While

    If has_initialized_globals is equal to 1:
        emit_line(output_file, ".section .data")
        Let i be 0
        While i is less than global_count:
            Let global be memory_get_pointer(globals, i multiplied by 8)
            Let global_name be memory_get_pointer(global, 0)  # global->name
            Let initial_value be memory_get_pointer(global, 16)  # global->initial_value
            If initial_value is not equal to 0:
                file_write_buffered(output_file, ".globl ", 0)
                file_write_buffered(output_file, global_name, 0)
                file_write_buffered(output_file, "\n", 0)
                file_write_buffered(output_file, global_name, 0)
                file_write_buffered(output_file, ":", 0)

                # Handle global variable initialization values
                Let expr_type be memory_get_int32(initial_value, 0)  # initial_value->type
                If expr_type is equal to 0:  # EXPR_INTEGER
                    Let integer_value be memory_get_pointer(initial_value, 8)  # initial_value->data.integer_value
                    file_write_buffered(output_file, "    .quad ", 0)
                    file_write_buffered(output_file, integer_to_string(integer_value), 0)
                    file_write_buffered(output_file, "\n", 0)
                Otherwise:
                    # Non-constant expressions default to zero initialization
                    file_write_buffered(output_file, "    .quad 0  # Non-constant initializer defaults to 0", 0)
                End If
            End If
            Let i be i plus 1
        End While
        file_write_buffered(output_file, "\n", 0)
    End If

    # Generate .bss section for uninitialized global variables
    Let has_uninitialized_globals be 0
    Let i be 0
    While i is less than global_count:
        Let global be memory_get_pointer(globals, i multiplied by 8)
        Let initial_value be memory_get_pointer(global, 16)  # global->initial_value
        If initial_value is equal to 0:
            Let has_uninitialized_globals be 1
            Let i be global_count  # Break
        End If
        Let i be i plus 1
    End While

    If has_uninitialized_globals is equal to 1:
        emit_line(output_file, ".section .bss")
        Let i be 0
        While i is less than global_count:
            Let global be memory_get_pointer(globals, i multiplied by 8)
            Let global_name be memory_get_pointer(global, 0)  # global->name
            Let initial_value be memory_get_pointer(global, 16)  # global->initial_value
            If initial_value is equal to 0:
                file_write_buffered(output_file, ".globl ", 0)
                file_write_buffered(output_file, global_name, 0)
                file_write_buffered(output_file, "\n", 0)
                file_write_buffered(output_file, global_name, 0)
                file_write_buffered(output_file, ":", 0)
                file_write_buffered(output_file, "    .zero 8  # 8 bytes for Integer", 0)
            End If
            Let i be i plus 1
        End While
        file_write_buffered(output_file, "\n", 0)
    End If

    # Generate .text section
    emit_line(output_file, ".text")

    # Add print_string runtime function
    emit_line(output_file, "print_string:")
    emit_line(output_file, "    pushq %rbp")
    emit_line(output_file, "    movq %rsp, %rbp")
    emit_line(output_file, "")
    emit_line(output_file, "    # Calculate string length")
    emit_line(output_file, "    movq %rdi, %rsi  # Save string pointer")
    emit_line(output_file, "    movq %rdi, %rcx  # Counter for strlen")
    emit_line(output_file, "    xorq %rax, %rax  # Length accumulator")
    emit_line(output_file, ".strlen_loop:")
    emit_line(output_file, "    cmpb $0, (%rcx)")
    emit_line(output_file, "    je .strlen_done")
    emit_line(output_file, "    incq %rcx")
    emit_line(output_file, "    incq %rax")
    emit_line(output_file, "    jmp .strlen_loop")
    emit_line(output_file, ".strlen_done:")
    emit_line(output_file, "")
    emit_line(output_file, "    # Call write syscall (sys_write = 1)")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    movq %rsi, %rsi   # buf = string pointer (already in rsi)")
    emit_line(output_file, "    movq %rax, %rdx   # count = string length")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    # Print newline")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    leaq .newline(%rip), %rsi  # newline string")
    emit_line(output_file, "    movq $1, %rdx     # count = 1")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    popq %rbp")
    emit_line(output_file, "    ret")
    emit_line(output_file, "\n")

    # Add print_integer runtime function
    emit_line(output_file, "print_integer:")
    emit_line(output_file, "    pushq %rbp")
    emit_line(output_file, "    movq %rsp, %rbp")
    emit_line(output_file, "    subq $32, %rsp  # Space for string buffer (20 digits + null)")
    emit_line(output_file, "")
    emit_line(output_file, "    # Convert integer to string")
    emit_line(output_file, "    movq %rdi, %rax  # integer value")
    emit_line(output_file, "    leaq -32(%rbp), %rsi  # buffer pointer")
    emit_line(output_file, "    addq $19, %rsi  # point to end of buffer (for reverse building)")
    emit_line(output_file, "    movb $0, (%rsi)  # null terminator")
    emit_line(output_file, "    decq %rsi")
    emit_line(output_file, "")
    emit_line(output_file, "    # Handle zero case")
    emit_line(output_file, "    testq %rax, %rax")
    emit_line(output_file, "    jnz .convert_loop")
    emit_line(output_file, "    movb $48, (%rsi)  # '0' character")
    emit_line(output_file, "    jmp .convert_done")
    emit_line(output_file, "")
    emit_line(output_file, ".convert_loop:")
    emit_line(output_file, "    testq %rax, %rax")
    emit_line(output_file, "    jz .convert_done")
    emit_line(output_file, "    movq %rax, %rcx")
    emit_line(output_file, "    movq $10, %rbx")
    emit_line(output_file, "    xorq %rdx, %rdx")
    emit_line(output_file, "    divq %rbx  # %rax = quotient, %rdx = remainder")
    emit_line(output_file, "    addq $48, %rdx  # convert remainder to ASCII")
    emit_line(output_file, "    movb %dl, (%rsi)  # store digit")
    emit_line(output_file, "    decq %rsi")
    emit_line(output_file, "    jmp .convert_loop")
    emit_line(output_file, "")
    emit_line(output_file, ".convert_done:")
    emit_line(output_file, "    incq %rsi  # point to first character")
    emit_line(output_file, "")
    emit_line(output_file, "    # Calculate string length")
    emit_line(output_file, "    movq %rsi, %rcx  # Counter for strlen")
    emit_line(output_file, "    xorq %rax, %rax  # Length accumulator")
    emit_line(output_file, ".int_strlen_loop:")
    emit_line(output_file, "    cmpb $0, (%rcx)")
    emit_line(output_file, "    je .int_strlen_done")
    emit_line(output_file, "    incq %rcx")
    emit_line(output_file, "    incq %rax")
    emit_line(output_file, "    jmp .int_strlen_loop")
    emit_line(output_file, ".int_strlen_done:")
    emit_line(output_file, "")
    emit_line(output_file, "    # Call write syscall (sys_write = 1)")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    # %rsi already points to string")
    emit_line(output_file, "    movq %rax, %rdx   # count = string length")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    # Print newline")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    leaq .newline(%rip), %rsi  # newline string")
    emit_line(output_file, "    movq $1, %rdx     # count = 1")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    movq %rbp, %rsp")
    emit_line(output_file, "    popq %rbp")
    emit_line(output_file, "    ret")
    emit_line(output_file, "\n")
    emit_line(output_file, ".section .rodata")
    emit_line(output_file, ".newline:")
    # Output newline string literal using ASCII byte value
    emit_line(output_file, "    .byte 10  # newline character")
    emit_line(output_file, ".text")

    # Generate all functions
    Let i be 0
    While i is less than function_count:
        Let func be memory_get_pointer(functions, i multiplied by 8)

        # Safety check for function pointer - skip NULL pointers
        If func is not equal to 0:
            Let func_name be memory_get_pointer(func, 0)  # func->name


            # Make main function global
            If string_equals(func_name, "main") is equal to 1:
                emit_line(output_file, ".globl main")
            End If

            emit_line(output_file, "\n")
            codegen_generate_function(codegen, func)
        End If
        Let i be i plus 1
    End While

    # Add a main function wrapper if no main function exists
    Let has_main be 0
    Let i be 0
    While i is less than function_count:
        Let func be memory_get_pointer(functions, i multiplied by 8)

        # Safety check for function pointer - skip NULL pointers
        If func is not equal to 0:
            Let func_name be memory_get_pointer(func, 0)  # func->name
            If string_equals(func_name, "main") is equal to 1:
                Let has_main be 1
                Let i be function_count  # Break
            End If
        End If
        Let i be i plus 1
    End While

    # Disable automatic main wrapper generation to allow modular compilation
    # Each module should define its own main() if needed
    # This prevents multiple main() definitions when linking modules
    # If has_main is equal to 0:
    #     # Wrapper generation disabled for library modules
    # End If

    # Add GNU stack note to prevent executable stack warning
    file_write_buffered(output_file, "\n", 0)
    # Output the GNU stack section
    emit_line(output_file, ".section .note.GNU-stack")

    Return 0
End Process
