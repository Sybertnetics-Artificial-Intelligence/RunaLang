# Code Generator for x86-64 Assembly
# Transliterated from codegen_x86.c (v0.0.7.3)
# Generates x86-64 assembly from parsed AST

# Program structure offsets (defined in parser.runa)
# Using numeric values to avoid duplicate symbol errors
# PROGRAM_FUNCTIONS = 0
# PROGRAM_FUNCTION_COUNT = 8
# PROGRAM_TYPES = 16
# PROGRAM_TYPE_COUNT = 24
# PROGRAM_IMPORTS = 32
# PROGRAM_IMPORT_COUNT = 40
# PROGRAM_GLOBAL_VARS = 48
# PROGRAM_GLOBAL_COUNT = 56

# Forward declarations for loop context management
# These will be implemented later in the file

# Note: string_duplicate is provided by string_utils module

# Helper to emit a line with newline
Process called "emit_line" takes output_file as Integer, line as Integer returns Integer:
    file_write_fd(output_file, line)
    file_write_fd(output_file, "\n")
    Return 0
End Process

# Find variable in current scope - equivalent to codegen_find_variable
Process called "codegen_find_variable" takes codegen as Integer, name as Integer returns Integer:
    Let variable_count be memory_get_integer(codegen, 16)  # codegen->variable_count (int)
    Let variables be memory_get_pointer(codegen, 8)        # codegen->variables
    Let i be 0
    While i is less than variable_count:
        Let var_offset be i multiplied by 32
        Let var_ptr be variables plus var_offset  # sizeof(Variable) = 32
        Let var_name be memory_get_pointer(var_ptr, 0)
        If string_equals(var_name, name) is equal to 1:
            Return i
        End If
        Let i be i plus 1
    End While
    Return 0 minus 1  # -1 for not found
End Process

# Calculate size of a type in bytes - equivalent to codegen_calculate_type_size
Process called "codegen_calculate_type_size" takes type_name as Integer, program as Integer returns Integer:
    # Built-in types
    If string_equals(type_name, "Integer") is equal to 1:
        Return 8  # 64-bit integer
    End If
    If string_equals(type_name, "Byte") is equal to 1:
        Return 1  # 8-bit byte
    End If
    If string_equals(type_name, "Short") is equal to 1:
        Return 2  # 16-bit short
    End If
    If string_equals(type_name, "Long") is equal to 1:
        Return 8  # 64-bit long
    End If

    # Custom types - look up in the program
    If program is not equal to 0:
        Let type_count be memory_get_integer(program, 24)  # PROGRAM_TYPE_COUNT - use int32
        Let types be memory_get_pointer(program, 16)       # PROGRAM_TYPES - use pointer
        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)  # type->name
            If string_equals(type_name_ptr, type_name) is equal to 1:
                Let type_size be memory_get_integer(type_ptr, 16)  # type->size
                Return type_size
            End If
            Let i be i plus 1
        End While
    End If

    # Unknown type - default to 8 bytes
    Return 8
End Process

# Add variable with type and parameter flag - equivalent to codegen_add_variable_with_type_and_param_flag
Process called "codegen_add_variable_with_type_and_param_flag" takes codegen as Integer, name as Integer, type_name as Integer, is_parameter as Integer returns Integer:
    # Get current counts and capacity
    file_write_fd(2, "[DEBUG] add_variable: name=")
    file_write_fd(2, name)
    file_write_fd(2, "\n")

    Let variable_count be memory_get_integer(codegen, 16)      # codegen->variable_count (int)
    file_write_fd(2, "[DEBUG] Got variable_count=")
    file_write_fd(2, integer_to_string(variable_count))
    file_write_fd(2, "\n")
    Let variable_capacity be memory_get_integer(codegen, 20)   # codegen->variable_capacity (int)
    file_write_fd(2, "[DEBUG] Got variable_capacity=")
    file_write_fd(2, integer_to_string(variable_capacity))
    file_write_fd(2, "\n")
    Let variables be memory_get_pointer(codegen, 8)            # codegen->variables
    file_write_fd(2, "[DEBUG] Got variables pointer=")
    file_write_fd(2, integer_to_string(variables))
    file_write_fd(2, "\n")

    # DEBUG: Show what we read
    # print_string("[DEBUG] variable_count=")
    # print_integer(variable_count)
    # print_string("[DEBUG] variable_capacity=")
    # print_integer(variable_capacity)

    # Grow array if needed
    If variable_count is greater than or equal to variable_capacity:
        Let new_capacity be variable_capacity multiplied by 2
        Let new_size be new_capacity multiplied by 32  # sizeof(Variable)
        Let new_variables be allocate(new_size)

        # Copy existing variables
        Let i be 0
        While i is less than variable_count:
            Let var_offset be i multiplied by 32
            Let old_var be variables plus var_offset
            Let var_offset be i multiplied by 32
            Let new_var be new_variables plus var_offset
            # Copy Variable struct (32 bytes)
            Let j be 0
            While j is less than 32:
                Let byte_val be memory_get_byte(old_var plus j, 0)
                memory_set_byte(new_var plus j, 0, byte_val)
                Let j be j plus 1
            End While
            Let i be i plus 1
        End While

        # Free old array and update
        deallocate(variables)
        memory_set_pointer(codegen, 8, new_variables)      # codegen->variables
        memory_set_integer(codegen, 20, new_capacity)      # codegen->variable_capacity (int)
        Let variables be new_variables
    End If

    # Calculate size based on type
    Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)
    file_write_fd(2, "[DEBUG] Got current_program=")
    file_write_fd(2, integer_to_string(current_program))
    file_write_fd(2, "\n")
    file_write_fd(2, "[DEBUG] About to call codegen_calculate_type_size\n")
    Let size be codegen_calculate_type_size(type_name, current_program)
    file_write_fd(2, "[DEBUG] Returned from codegen_calculate_type_size, size=")
    file_write_fd(2, integer_to_string(size))
    file_write_fd(2, "\n")
    If type_name is equal to 0:
        Let size be codegen_calculate_type_size("Integer", current_program)
    End If

    # Update stack offset
    Let stack_offset be memory_get_integer(codegen, 24)  # codegen->stack_offset (int)
    Let new_stack_offset be stack_offset plus size
    memory_set_integer(codegen, 24, new_stack_offset)  # codegen->stack_offset (int)

    # Get variable index
    Let var_index be variable_count
    Let var_offset be var_index multiplied by 32  # Calculate offset separately
    Let var_ptr be variables plus var_offset      # Then add to base pointer


    # Set variable fields
    memory_set_pointer(var_ptr, 0, string_duplicate(name))       # name
    memory_set_integer(var_ptr, 8, new_stack_offset)            # stack_offset (int)
    If type_name is equal to 0:
        memory_set_pointer(var_ptr, 16, string_duplicate("Integer")) # type_name - use literal directly
    Otherwise:
        memory_set_pointer(var_ptr, 16, string_duplicate(type_name)) # type_name
    End If
    memory_set_integer(var_ptr, 24, is_parameter)               # is_parameter (int)

    # Increment count
    memory_set_integer(codegen, 16, variable_count plus 1)  # codegen->variable_count (int)

    Return var_index
End Process

# Add variable with type - equivalent to codegen_add_variable_with_type
Process called "codegen_add_variable_with_type" takes codegen as Integer, name as Integer, type_name as Integer returns Integer:
    Return codegen_add_variable_with_type_and_param_flag(codegen, name, type_name, 0)
End Process

# Add variable with default Integer type - equivalent to codegen_add_variable
Process called "codegen_add_variable" takes codegen as Integer, name as Integer returns Integer:
    Return codegen_add_variable_with_type(codegen, name, "Integer")
End Process

# Add string literal - equivalent to codegen_add_string_literal
Process called "codegen_add_string_literal" takes codegen as Integer, value as Integer returns Integer:
    # Get current counts and capacity
    Let string_count be memory_get_integer(codegen, 40)      # codegen->string_count (int)
    Let string_capacity be memory_get_integer(codegen, 44)   # codegen->string_capacity (int)
    Let strings be memory_get_pointer(codegen, 32)           # codegen->strings (pointer with padding)

    # Grow array if needed
    If string_count is greater than or equal to string_capacity:
        Let new_capacity be string_capacity multiplied by 2
        Let new_size be new_capacity multiplied by 16  # sizeof(StringLiteral)
        Let new_strings be allocate(new_size)

        # Copy existing strings
        Let i be 0
        While i is less than string_count:
            Let str_offset be i multiplied by 16
            Let old_str be strings plus str_offset
            Let str_offset be i multiplied by 16
            Let new_str be new_strings plus str_offset
            # Copy StringLiteral struct (16 bytes)
            Let j be 0
            While j is less than 16:
                Let byte_val be memory_get_byte(old_str plus j, 0)
                memory_set_byte(new_str plus j, 0, byte_val)
                Let j be j plus 1
            End While
            Let i be i plus 1
        End While

        # Free old array and update
        deallocate(strings)
        memory_set_pointer(codegen, 32, new_strings)      # codegen->strings (pointer)
        memory_set_integer(codegen, 44, new_capacity)     # codegen->string_capacity (int)
        Let strings be new_strings
    End If

    Let str_index be string_count
    Let str_offset be str_index multiplied by 16
    Let str_ptr be strings plus str_offset

    # Set string value
    memory_set_pointer(str_ptr, 0, string_duplicate(value))  # value

    # Generate unique label for this string
    Let label be string_concat(".STR", integer_to_string(str_index))
    memory_set_pointer(str_ptr, 8, label)  # label

    # Increment count
    memory_set_integer(codegen, 40, string_count plus 1)  # codegen->string_count (int)

    Return str_index
End Process

# Collect strings from expression - equivalent to codegen_collect_strings_from_expression
Process called "codegen_collect_strings_from_expression" takes codegen as Integer, expr as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If

    file_write_fd(2, "[DEBUG] In codegen_collect_strings_from_expression, expr=")
    file_write_fd(2, integer_to_string(expr))
    file_write_fd(2, "\n")
    Let expr_type be memory_get_integer(expr, 0)  # expr->type
    file_write_fd(2, "[DEBUG] expr_type=")
    file_write_fd(2, integer_to_string(expr_type))
    file_write_fd(2, "\n")

    If expr_type is equal to 5:  # EXPR_STRING_LITERAL
        # Check if string already exists
        Let string_count be memory_get_integer(codegen, 40)  # codegen->string_count (int)
        Let strings be memory_get_pointer(codegen, 32)  # codegen->strings (pointer)
        Let string_literal be memory_get_pointer(expr, 8)  # expr->data.string_literal

        Let i be 0
        While i is less than string_count:
            Let str_offset be i multiplied by 16
            Let str_ptr be strings plus str_offset
            Let existing_value be memory_get_integer(str_ptr, 0)
            If string_equals(existing_value, string_literal) is equal to 1:
                Return 0  # Already added
            End If
            Let i be i plus 1
        End While

        codegen_add_string_literal(codegen, string_literal)
        Return 0
    End If

    If expr_type is equal to 2:  # EXPR_BINARY_OP
        Let left be memory_get_pointer(expr, 8)   # binary_op.left
        Let right be memory_get_pointer(expr, 16) # binary_op.right
        codegen_collect_strings_from_expression(codegen, left)
        codegen_collect_strings_from_expression(codegen, right)
        Return 0
    End If

    If expr_type is equal to 3:  # EXPR_COMPARISON
        Let left be memory_get_pointer(expr, 8)   # comparison.left
        Let right be memory_get_pointer(expr, 16) # comparison.right
        codegen_collect_strings_from_expression(codegen, left)
        codegen_collect_strings_from_expression(codegen, right)
        Return 0
    End If

    If expr_type is equal to 4:  # EXPR_FUNCTION_CALL
        file_write_fd(2, "[DEBUG] Processing EXPR_FUNCTION_CALL\n")
        Let func_call_ptr be expr plus 8  # &expr->data.function_call
        # function_call structure: function_name (char*) at 0, arguments (Expression**) at 8, argument_count (int) at 16
        Let function_name be memory_get_pointer(func_call_ptr, 0)  # function_call.function_name
        Let arguments be memory_get_pointer(func_call_ptr, 8)      # function_call.arguments - this is a pointer!
        Let argument_count be memory_get_integer(func_call_ptr, 16) # function_call.argument_count
        file_write_fd(2, "[DEBUG] arguments ptr=")
        file_write_fd(2, integer_to_string(arguments))
        file_write_fd(2, "\n")

        Let i be 0
        While i is less than argument_count:
            file_write_fd(2, "[DEBUG] Processing arg ")
            file_write_fd(2, integer_to_string(i))
            file_write_fd(2, "\n")
            Let arg_offset be i multiplied by 8
            Let arg_ptr be memory_get_pointer(arguments, arg_offset)
            file_write_fd(2, "[DEBUG] arg_ptr=")
            file_write_fd(2, integer_to_string(arg_ptr))
            file_write_fd(2, "\n")
            codegen_collect_strings_from_expression(codegen, arg_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 6:  # EXPR_FIELD_ACCESS
        Let object be memory_get_pointer(expr, 8)  # field_access.object
        codegen_collect_strings_from_expression(codegen, object)
        Return 0
    End If

    If expr_type is equal to 8:  # EXPR_BUILTIN_CALL
        Let builtin_call_ptr be expr plus 8  # &expr->data.builtin_call
        # builtin_call structure: builtin_type (int) at 0, arguments (Expression**) at 8, argument_count (int) at 16
        Let builtin_type be memory_get_integer(builtin_call_ptr, 0)  # builtin_call.builtin_type
        Let arguments be memory_get_pointer(builtin_call_ptr, 8)      # builtin_call.arguments - this is a pointer!
        Let argument_count be memory_get_integer(builtin_call_ptr, 16) # builtin_call.argument_count

        Let i be 0
        While i is less than argument_count:
            Let arg_offset be i multiplied by 8
            Let arg_ptr be memory_get_pointer(arguments, arg_offset)
            codegen_collect_strings_from_expression(codegen, arg_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 9:  # EXPR_VARIANT_CONSTRUCTOR
        Let variant_constructor_ptr be expr plus 8  # &expr->data.variant_constructor
        # variant_constructor structure: type_name (char*) at 0, variant_name (char*) at 8, field_values (Expression**) at 16, field_count (int) at 24
        Let type_name be memory_get_pointer(variant_constructor_ptr, 0)     # variant_constructor.type_name
        Let variant_name be memory_get_pointer(variant_constructor_ptr, 8)  # variant_constructor.variant_name
        Let field_values be memory_get_pointer(variant_constructor_ptr, 16) # variant_constructor.field_values - this is a pointer!
        Let field_count be memory_get_integer(variant_constructor_ptr, 24)  # variant_constructor.field_count

        Let i be 0
        While i is less than field_count:
            Let field_offset be i multiplied by 8
            Let field_value_ptr be memory_get_pointer(field_values, field_offset)  # This is also a pointer!
            codegen_collect_strings_from_expression(codegen, field_value_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 16:  # EXPR_ARRAY_INDEX
        Let array_index_ptr be expr plus 8  # &expr->data.array_index
        Let arr be memory_get_integer(array_index_ptr, 0)  # array_index.array
        Let index be memory_get_integer(array_index_ptr, 8)  # array_index.index
        codegen_collect_strings_from_expression(codegen, arr)
        codegen_collect_strings_from_expression(codegen, index)
        Return 0
    End If

    # Other expression types (INTEGER, VARIABLE, TYPE_NAME, FUNCTION_POINTER) have no strings to collect
    Return 0
End Process

# Collect strings from statement - equivalent to codegen_collect_strings_from_statement
Process called "codegen_collect_strings_from_statement" takes codegen as Integer, stmt as Integer returns Integer:
    If stmt is equal to 0:
        Return 0
    End If

    # Safety check - if stmt is a small number, it's likely corrupt
    If stmt is less than 65536:  # 0x10000 - reasonable minimum address
        file_write_fd(2, "[ERROR] Invalid statement pointer (too small): ")
        file_write_fd(2, integer_to_string(stmt))
        file_write_fd(2, "\n")
        Return 0
    End If

    Let stmt_type be memory_get_integer(stmt, 0)  # stmt->type

    # Safety check - statement types should be 0-12
    If stmt_type is less than 0:
        file_write_fd(2, "[ERROR] Invalid negative statement type\n")
        Return 0
    End If
    If stmt_type is greater than 12:
        file_write_fd(2, "[ERROR] Invalid statement type too large: ")
        file_write_fd(2, integer_to_string(stmt_type))
        file_write_fd(2, "\n")
        Return 1
    End If

    If stmt_type is equal to 1:  # STMT_LET
        Let let_stmt_ptr be stmt plus 8  # &stmt->data.let_stmt
        Let expression be memory_get_pointer(let_stmt_ptr, 8)  # let_stmt.expression - this is a pointer!
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 2:  # STMT_SET
        Let set_stmt_ptr be stmt plus 8  # &stmt->data.set_stmt
        Let target be memory_get_pointer(set_stmt_ptr, 0)      # set_stmt.target - this is a pointer!
        Let expression be memory_get_pointer(set_stmt_ptr, 8)  # set_stmt.expression - this is a pointer!
        codegen_collect_strings_from_expression(codegen, target)
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 3:  # STMT_RETURN
        Let return_stmt_ptr be stmt plus 8  # &stmt->data.return_stmt
        Let expression be memory_get_pointer(return_stmt_ptr, 0)  # return_stmt.expression
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 4:  # STMT_PRINT
        Let print_stmt_ptr be stmt plus 8  # &stmt->data.print_stmt
        Let expression be memory_get_integer(print_stmt_ptr, 0)  # print_stmt.expression
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 5:  # STMT_IF
        file_write_fd(2, "[DEBUG IF collect] Processing IF statement, stmt=")
        file_write_fd(2, integer_to_string(stmt))
        file_write_fd(2, "\n")

        Let if_stmt_ptr be stmt plus 8  # &stmt->data.if_stmt
        Let condition be memory_get_pointer(if_stmt_ptr, 0)        # if_stmt.condition (offset 8)
        Let if_body be memory_get_pointer(if_stmt_ptr, 8)          # if_stmt.if_body (offset 16)
        Let if_body_count be memory_get_integer(if_stmt_ptr, 16)   # if_stmt.if_body_count (offset 24)
        Let else_body be memory_get_pointer(if_stmt_ptr, 24)       # if_stmt.else_body (offset 32)
        Let else_body_count be memory_get_integer(if_stmt_ptr, 32) # if_stmt.else_body_count (offset 40)

        file_write_fd(2, "[DEBUG IF collect] if_body=")
        file_write_fd(2, integer_to_string(if_body))
        file_write_fd(2, ", if_body_count=")
        file_write_fd(2, integer_to_string(if_body_count))
        file_write_fd(2, "\n")

        codegen_collect_strings_from_expression(codegen, condition)

        # Process if body - add safety check
        If if_body is greater than 65536:  # Valid pointer check
            Let i be 0
            While i is less than if_body_count:
                Let stmt_offset be i multiplied by 8

                file_write_fd(2, "[DEBUG IF collect] Getting statement ")
                file_write_fd(2, integer_to_string(i))
                file_write_fd(2, " at offset ")
                file_write_fd(2, integer_to_string(stmt_offset))
                file_write_fd(2, " from if_body=")
                file_write_fd(2, integer_to_string(if_body))
                file_write_fd(2, "\n")

                Let stmt_ptr be memory_get_pointer(if_body, stmt_offset)

                file_write_fd(2, "[DEBUG IF collect] Got stmt_ptr=")
                file_write_fd(2, integer_to_string(stmt_ptr))
                file_write_fd(2, "\n")

                codegen_collect_strings_from_statement(codegen, stmt_ptr)
                Let i be i plus 1
            End While
        End If

        # Process else body - add safety check
        If else_body is greater than 65536:  # Valid pointer check
            Let i be 0
            While i is less than else_body_count:
                Let stmt_offset be i multiplied by 8
                Let stmt_ptr be memory_get_pointer(else_body, stmt_offset)
                codegen_collect_strings_from_statement(codegen, stmt_ptr)
                Let i be i plus 1
            End While
        End If
        Return 0
    End If

    If stmt_type is equal to 6:  # STMT_WHILE
        Let while_stmt_ptr be stmt plus 8  # &stmt->data.while_stmt
        Let condition be memory_get_pointer(while_stmt_ptr, 0)   # while_stmt.condition (offset 8)
        Let body be memory_get_pointer(while_stmt_ptr, 8)        # while_stmt.body (offset 16)
        Let body_count be memory_get_integer(while_stmt_ptr, 16) # while_stmt.body_count (offset 24)

        codegen_collect_strings_from_expression(codegen, condition)

        # Process body
        Let i be 0
        While i is less than body_count:
            Let stmt_offset be i multiplied by 8
            Let stmt_ptr be memory_get_pointer(body, stmt_offset)
            codegen_collect_strings_from_statement(codegen, stmt_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 6:  # STMT_WHILE
        # This is the duplicate WHILE check, should be removed but keeping for now
        Let while_stmt_ptr be stmt plus 8  # &stmt->data.while_stmt
        Let condition be memory_get_pointer(while_stmt_ptr, 0)   # while_stmt.condition (offset 8)
        Let body be memory_get_pointer(while_stmt_ptr, 8)        # while_stmt.body (offset 16)
        Let body_count be memory_get_integer(while_stmt_ptr, 16) # while_stmt.body_count (offset 24)

        codegen_collect_strings_from_expression(codegen, condition)

        Let i be 0
        While i is less than body_count:
            Let stmt_offset be i multiplied by 8
            Let stmt_ptr be memory_get_pointer(body, stmt_offset)
            codegen_collect_strings_from_statement(codegen, stmt_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 7:  # STMT_EXPRESSION
        file_write_fd(2, "[DEBUG] Found STMT_EXPRESSION\n")
        Let expr_stmt_ptr be stmt plus 8  # &stmt->data.expr_stmt
        Let expression be memory_get_pointer(expr_stmt_ptr, 0)  # expr_stmt.expression - this is a pointer!
        file_write_fd(2, "[DEBUG] About to call codegen_collect_strings_from_expression\n")
        codegen_collect_strings_from_expression(codegen, expression)
        file_write_fd(2, "[DEBUG] Returned from codegen_collect_strings_from_expression\n")
        Return 0
    End If

    If stmt_type is equal to 8:  # STMT_MATCH
        Let match_stmt_ptr be stmt plus 8  # &stmt->data.match_stmt
        Let expression be memory_get_pointer(match_stmt_ptr, 0)   # match_stmt.expression - this is a pointer!
        Let case_count be memory_get_integer(match_stmt_ptr, 8)   # match_stmt.case_count
        Let cases be memory_get_pointer(match_stmt_ptr, 16)       # match_stmt.cases - this is a pointer!

        codegen_collect_strings_from_expression(codegen, expression)

        # Process each match case
        Let i be 0
        While i is less than case_count:
            Let case_offset be i multiplied by 32
            Let match_case_ptr be cases plus case_offset  # sizeof(MatchCase)
            Let body_count be memory_get_integer(match_case_ptr, 16)  # match_case.body_count
            Let body be memory_get_pointer(match_case_ptr, 24)        # match_case.body - this is a pointer!

            Let j be 0
            While j is less than body_count:
                Let stmt_offset be j multiplied by 8
                Let stmt_ptr be memory_get_pointer(body, stmt_offset)
                codegen_collect_strings_from_statement(codegen, stmt_ptr)
                Let j be j plus 1
            End While
            Let i be i plus 1
        End While
        Return 0
    End If

    # Other statement types (IMPORT, BREAK, CONTINUE, INLINE_ASSEMBLY) don't have strings to collect
    Return 0
End Process

# Helper function to determine the type name of an expression
Process called "codegen_get_expression_type" takes codegen as Integer, expr as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If

    Let expr_type be memory_get_integer(expr, 0)  # expr->type

    If expr_type is equal to 1:  # EXPR_VARIABLE
        Let variable_name be memory_get_pointer(expr, 8)  # expr->data.variable_name
        Let var_index be codegen_find_variable(codegen, variable_name)

        If var_index is equal to 0 minus 1:  # -1 for not found
            # Check if this is a global variable
            Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)
            If current_program is not equal to 0:
                Let global_count be memory_get_integer(current_program, 48)  # program->global_count
                Let globals be memory_get_integer(current_program, 40)       # program->globals

                Let j be 0
                While j is less than global_count:
                    Let global_offset be j multiplied by 8
                    Let global_ptr be memory_get_integer(globals plus global_offset, 0)
                    Let global_name be memory_get_pointer(global_ptr, 0)  # global->name
                    If string_equals(global_name, variable_name) is equal to 1:
                        Let global_type be memory_get_integer(global_ptr, 8)  # global->type
                        Return global_type
                    End If
                    Let j be j plus 1
                End While
            End If
            Return 0
        End If

        Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
        Let var_offset be var_index multiplied by 32
        Let var_ptr be variables plus var_offset
        Let type_name be memory_get_pointer(var_ptr, 16)  # variable.type_name
        Return type_name
    End If

    If expr_type is equal to 6:  # EXPR_FIELD_ACCESS
        Let field_access_ptr be expr plus 8  # &expr->data.field_access
        Let object be memory_get_integer(field_access_ptr, 0)       # field_access.object
        Let field_name be memory_get_pointer(field_access_ptr, 8)   # field_access.field_name

        # Get the type of the object
        Let object_type be codegen_get_expression_type(codegen, object)
        If object_type is equal to 0:
            Return 0
        End If

        # Find the type definition
        Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)
        Let type_count be memory_get_integer(current_program, 32)  # program->type_count
        Let types be memory_get_integer(current_program, 24)       # program->types
        Let type be 0

        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)  # type->name
            If string_equals(type_name_ptr, object_type) is equal to 1:
                Let type be type_ptr
                Let i be type_count  # break loop
            End If
            Let i be i plus 1
        End While

        If type is equal to 0:
            Return 0
        End If

        # Find the field and return its type
        Let kind be memory_get_integer(type, 8)  # type->kind
        If kind is equal to 1:  # TYPE_KIND_STRUCT
            Let struct_type_ptr be type plus 16  # &type->data.struct_type
            Let field_count be memory_get_integer(struct_type_ptr, 0)  # struct_type.field_count
            Let fields be memory_get_integer(struct_type_ptr, 8)       # struct_type.fields

            Let i be 0
            While i is less than field_count:
                Let field_offset be i multiplied by 24
                Let field_ptr be fields plus field_offset  # sizeof(FieldDefinition)
                Let field_name_ptr be memory_get_pointer(field_ptr, 0)  # field.name
                If string_equals(field_name_ptr, field_name) is equal to 1:
                    Let field_type be memory_get_integer(field_ptr, 8)  # field.type
                    Return field_type
                End If
                Let i be i plus 1
            End While
        End If

        Return 0
    End If

    # Other expression types don't have determinable types in this context
    Return 0
End Process

# Generate the address of an lvalue expression (result in %rbx)
Process called "codegen_generate_lvalue_address" takes codegen as Integer, expr as Integer returns Integer:
    Let expr_type be memory_get_integer(expr, 0)  # expr->type
    Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file

    If expr_type is equal to 1:  # EXPR_VARIABLE
        # Find variable and generate its address
        Let variable_name be memory_get_pointer(expr, 8)  # expr->data.variable_name
        Let var_index be codegen_find_variable(codegen, variable_name)

        If var_index is equal to 0 minus 1:  # -1 for not found
            # Check if this is a global variable
            Let is_global be 0
            Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)

            If current_program is not equal to 0:
                Let global_count be memory_get_integer(current_program, 48)  # program->global_count
                Let globals be memory_get_integer(current_program, 40)       # program->globals

                Let j be 0
                While j is less than global_count:
                    Let global_offset be j multiplied by 8
                    Let global_ptr be memory_get_integer(globals plus global_offset, 0)
                    Let global_name be memory_get_pointer(global_ptr, 0)  # global->name
                    If string_equals(global_name, variable_name) is equal to 1:
                        Let is_global be 1
                        Let j be global_count  # break loop
                    End If
                    Let j be j plus 1
                End While
            End If

            If is_global is equal to 1:
                # Generate address of global variable
                file_write_fd(output_file, "    leaq ")
                file_write_fd(output_file, variable_name)
                file_write_fd(output_file, "(%rip), %rbx  # Address of global variable")
            Otherwise:
                print_string("[CODEGEN ERROR] Unknown variable '")
                print_string(variable_name)
                print_string("'")
                exit_with_code(1)
            End If
        Otherwise:
            Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
            Let var_offset be var_index multiplied by 32
            Let var_ptr be variables plus var_offset
            Let offset be memory_get_integer(var_ptr, 8)  # variable.stack_offset

            # Generate address of variable on stack
            file_write_fd(output_file, "    leaq -")
            file_write_fd(output_file, integer_to_string(offset))
            file_write_fd(output_file, "(%rbp), %rbx")
        End If
        Return 0
    End If

    If expr_type is equal to 6:  # EXPR_FIELD_ACCESS
        Let field_access_ptr be expr plus 8  # &expr->data.field_access
        Let object be memory_get_integer(field_access_ptr, 0)     # field_access.object
        Let field_name be memory_get_pointer(field_access_ptr, 8) # field_access.field_name

        # Generate address of object
        codegen_generate_lvalue_address(codegen, object)

        # Now %rbx contains the address of the object
        # We need to add the field offset to get the field address

        # Get the type of the object using our helper function
        Let object_type be codegen_get_expression_type(codegen, object)
        If object_type is equal to 0:
            print_string("[CODEGEN ERROR] Cannot determine type of object in field access")
            exit_with_code(1)
        End If

        # Find the type definition
        Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)
        Let type_count be memory_get_integer(current_program, 32)  # program->type_count
        Let types be memory_get_integer(current_program, 24)       # program->types
        Let type be 0

        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)  # type->name
            If string_equals(type_name_ptr, object_type) is equal to 1:
                Let type be type_ptr
                Let i be type_count  # break loop
            End If
            Let i be i plus 1
        End While

        If type is equal to 0:
            print_string("[CODEGEN ERROR] Unknown type '")
            print_string(object_type)
            print_string("'")
            exit_with_code(1)
        End If

        # Find field offset
        Let field_offset be 0 minus 1  # -1 for not found
        Let kind be memory_get_integer(type, 8)  # type->kind

        If kind is equal to 1:  # TYPE_KIND_STRUCT
            Let struct_type_ptr be type plus 16  # &type->data.struct_type
            Let field_count be memory_get_integer(struct_type_ptr, 0)  # struct_type.field_count
            Let fields be memory_get_integer(struct_type_ptr, 8)       # struct_type.fields

            Let i be 0
            While i is less than field_count:
                Let field_offset be i multiplied by 24
                Let field_ptr be fields plus field_offset  # sizeof(FieldDefinition)
                Let field_name_ptr be memory_get_pointer(field_ptr, 0)  # field.name
                If string_equals(field_name_ptr, field_name) is equal to 1:
                    Let field_offset be memory_get_integer(field_ptr, 16)  # field.offset
                    Let i be field_count  # break loop
                End If
                Let i be i plus 1
            End While
        End If

        If field_offset is equal to 0 minus 1:  # -1 for not found
            print_string("[CODEGEN ERROR] Type '")
            print_string(object_type)
            print_string("' has no field '")
            print_string(field_name)
            print_string("'")
            exit_with_code(1)
        End If

        # Add field offset to object address
        file_write_fd(output_file, "    addq $")
        file_write_fd(output_file, integer_to_string(field_offset))
        file_write_fd(output_file, ", %rbx")
        Return 0
    End If

    If expr_type is equal to 16:  # EXPR_ARRAY_INDEX
        Let array_index_ptr be expr plus 8  # &expr->data.array_index
        Let arr be memory_get_integer(array_index_ptr, 0)  # array_index.array
        Let index be memory_get_integer(array_index_ptr, 8)  # array_index.index

        # Check if the array is a parameter or local variable
        Let array_type be memory_get_integer(arr, 0)  # array->type
        If array_type is equal to 1:  # EXPR_VARIABLE
            Let array_variable_name be memory_get_pointer(arr, 8)  # array->data.variable_name
            Let var_index be codegen_find_variable(codegen, array_variable_name)

            If var_index is not equal to 0 minus 1:  # found variable
                Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
                Let var_offset be var_index multiplied by 32
                Let var_ptr be variables plus var_offset
                Let is_parameter be memory_get_integer(var_ptr, 24)  # variable.is_parameter

                If is_parameter is equal to 1:
                    # For array parameters, load the pointer value, not the address
                    Let offset be memory_get_integer(var_ptr, 8)  # variable.stack_offset
                    file_write_fd(output_file, "    movq -")
                    file_write_fd(output_file, integer_to_string(offset))
                    file_write_fd(output_file, "(%rbp), %rbx  # Load array parameter pointer")
                Otherwise:
                    # For local arrays, generate the address
                    codegen_generate_lvalue_address(codegen, arr)
                End If
            Otherwise:
                # For complex expressions, generate the address
                codegen_generate_lvalue_address(codegen, arr)
            End If
        Otherwise:
            # For complex expressions, generate the address
            codegen_generate_lvalue_address(codegen, arr)
        End If

        # Save base address
        file_write_fd(output_file, "    pushq %rbx")

        # Generate index expression
        codegen_generate_expression(codegen, index)

        # Pop base address
        file_write_fd(output_file, "    popq %rbx")

        # Calculate element address: base + (index * element_size)
        # For arrays, all elements are currently 8 bytes (Integer size)
        file_write_fd(output_file, "    imulq $8, %rax")
        file_write_fd(output_file, "    addq %rax, %rbx")
        Return 0
    End If

    # Invalid lvalue expression type
    print_string("[CODEGEN ERROR] Invalid lvalue expression type")
    exit_with_code(1)
    Return 0
End Process

# Generate code for expression - equivalent to codegen_generate_expression
Process called "codegen_generate_expression" takes codegen as Integer, expr as Integer returns Integer:
    file_write_fd(2, "[DEBUG] codegen_generate_expression: codegen=")
    file_write_fd(2, integer_to_string(codegen))
    file_write_fd(2, ", expr=")
    file_write_fd(2, integer_to_string(expr))
    file_write_fd(2, "\n")
    Let expr_type be memory_get_integer(expr, 0)  # expr->type
    file_write_fd(2, "[DEBUG] expr_type=")
    file_write_fd(2, integer_to_string(expr_type))
    file_write_fd(2, "\n")
    Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file

    If expr_type is equal to 0:  # EXPR_INTEGER
        Let integer_value be memory_get_integer(expr, 8)  # expr->data.integer_value
        file_write_fd(output_file, "    movq $")
        file_write_fd(output_file, integer_to_string(integer_value))
        file_write_fd(output_file, ", %rax\n")
        Return 0
    End If

    If expr_type is equal to 1:  # EXPR_VARIABLE
        Let variable_name be memory_get_pointer(expr, 8)  # expr->data.variable_name
        Let var_index be codegen_find_variable(codegen, variable_name)

        If var_index is equal to 0 minus 1:  # -1 for not found
            # Check if this is a global variable
            Let is_global be 0
            Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)

            If current_program is not equal to 0:
                Let global_count be memory_get_integer(current_program, 48)  # program->global_count
                Let globals be memory_get_integer(current_program, 40)       # program->globals

                Let j be 0
                While j is less than global_count:
                    Let global_offset be j multiplied by 8
                    Let global_ptr be memory_get_integer(globals plus global_offset, 0)
                    Let global_name be memory_get_pointer(global_ptr, 0)  # global->name
                    If string_equals(global_name, variable_name) is equal to 1:
                        Let is_global be 1
                        Let j be global_count  # break loop
                    End If
                    Let j be j plus 1
                End While
            End If

            If is_global is equal to 1:
                # Load global variable value
                file_write_fd(output_file, "    movq ")
                file_write_fd(output_file, variable_name)
                file_write_fd(output_file, "(%rip), %rax  # Load global variable")
            Otherwise:
                # Check if this is a function name being used as a function pointer
                Let is_function be 0
                If current_program is not equal to 0:
                    Let function_count be memory_get_integer(current_program, 16)  # program->function_count
                    Let functions be memory_get_integer(current_program, 8)        # program->functions

                    Let j be 0
                    While j is less than function_count:
                        Let func_offset be j multiplied by 8
                        Let function_ptr be memory_get_integer(functions plus func_offset, 0)
                        Let function_name be memory_get_pointer(function_ptr, 0)  # function->name
                        If string_equals(function_name, variable_name) is equal to 1:
                            Let is_function be 1
                            Let j be function_count  # break loop
                        End If
                        Let j be j plus 1
                    End While
                End If

                If is_function is equal to 0:
                    print_string("[CODEGEN ERROR] Undefined variable: ")
                    print_string(variable_name)
                    exit_with_code(1)
                End If

                file_write_fd(output_file, "    leaq ")
                file_write_fd(output_file, variable_name)
                file_write_fd(output_file, "(%rip), %rax  # Load function address")
            End If
        Otherwise:
            Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
            Let var_offset be var_index multiplied by 32
            Let var_ptr be variables plus var_offset
            Let offset be memory_get_integer(var_ptr, 8)     # variable.stack_offset
            Let var_type be memory_get_integer(var_ptr, 16)  # variable.type_name

            # Check if this variable is an array type
            Let is_array be 0
            Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)

            If current_program is not equal to 0:
                Let type_count be memory_get_integer(current_program, 32)  # program->type_count
                Let types be memory_get_integer(current_program, 24)       # program->types

                Let i be 0
                While i is less than type_count:
                    Let type_offset be i multiplied by 8
                    Let type_ptr be memory_get_pointer(types, type_offset)
                    Let type_name_ptr be memory_get_pointer(type_ptr, 0)  # type->name
                    If string_equals(type_name_ptr, var_type) is equal to 1:
                        Let kind be memory_get_integer(type_ptr, 8)  # type->kind
                        If kind is equal to 2:  # TYPE_KIND_ARRAY
                            Let is_array be 1
                        End If
                        Let i be type_count  # break loop
                    End If
                    Let i be i plus 1
                End While
            End If

            If is_array is equal to 1:
                # For arrays, load the address not the value
                file_write_fd(output_file, "    leaq -")
                file_write_fd(output_file, integer_to_string(offset))
                file_write_fd(output_file, "(%rbp), %rax  # Load array address\n")
            Otherwise:
                file_write_fd(output_file, "    movq -")
                file_write_fd(output_file, integer_to_string(offset))
                file_write_fd(output_file, "(%rbp), %rax\n")
            End If
        End If
        Return 0
    End If

    If expr_type is equal to 2:  # EXPR_BINARY_OP
        Let left be memory_get_pointer(expr, 8)      # binary_op.left
        Let right be memory_get_pointer(expr, 16)    # binary_op.right
        Let operator be memory_get_integer(expr, 24) # binary_op.operator

        file_write_fd(2, "[DEBUG] EXPR_BINARY_OP operator=")
        file_write_fd(2, integer_to_string(operator))
        file_write_fd(2, "\n")

        # Generate left operand (result in %rax)
        codegen_generate_expression(codegen, left)
        # Push left operand to stack
        emit_line(output_file, "    pushq %rax")
        # Generate right operand (result in %rax)
        codegen_generate_expression(codegen, right)
        # Pop left operand from stack to %rbx
        emit_line(output_file, "    popq %rbx")

        file_write_fd(2, "[DEBUG] Checking operator conditions\n")
        file_write_fd(2, "[DEBUG] operator=")
        file_write_fd(2, integer_to_string(operator))
        file_write_fd(2, "\n")

        If operator is equal to 16:  # TOKEN_PLUS
            file_write_fd(2, "[DEBUG] Emitting addq for TOKEN_PLUS\n")
            emit_line(output_file, "    addq %rbx, %rax")
        End If
        If operator is equal to 17:  # TOKEN_MINUS
            file_write_fd(2, "[DEBUG] Emitting subq for TOKEN_MINUS\n")
            emit_line(output_file, "    subq %rax, %rbx")
            emit_line(output_file, "    movq %rbx, %rax")
        End If
        If operator is equal to 35:  # TOKEN_MULTIPLIED
            file_write_fd(2, "[DEBUG] Emitting imulq for TOKEN_MULTIPLIED\n")
            emit_line(output_file, "    imulq %rbx, %rax")
        End If
        If operator is equal to 36:  # TOKEN_DIVIDED
            # Division: dividend in %rax, divisor in %rbx
            # Move divisor to %rcx to preserve %rbx
            emit_line(output_file, "    movq %rax, %rcx")  # Save divisor in %rcx
            emit_line(output_file, "    movq %rbx, %rax")  # Move dividend to %rax

            # Check for divide by zero
            emit_line(output_file, "    testq %rcx, %rcx")
            Let label_counter be memory_get_integer(codegen, 28)  # codegen->label_counter (int)
            Let jz_line be string_concat("    jz .Ldiv_by_zero_", integer_to_string(label_counter))
            emit_line(output_file, jz_line)

            # Sign extend %rax to %rdx:%rax
            emit_line(output_file, "    cqto")
            # Divide by %rcx, quotient in %rax, remainder in %rdx
            emit_line(output_file, "    idivq %rcx")
            Let jmp_line be string_concat("    jmp .Ldiv_done_", integer_to_string(label_counter))
            emit_line(output_file, jmp_line)

            # Divide by zero handler
            Let div_zero_label be string_concat(".Ldiv_by_zero_", integer_to_string(label_counter))
            Let div_zero_line be string_concat(div_zero_label, ":")
            emit_line(output_file, div_zero_line)
            emit_line(output_file, "    movq $0, %rax")
            Let div_done_label be string_concat(".Ldiv_done_", integer_to_string(label_counter))
            Let div_done_line be string_concat(div_done_label, ":")
            emit_line(output_file, div_done_line)
            memory_set_integer(codegen, 28, label_counter plus 1)  # codegen->label_counter++ (int)
        End If
        If operator is equal to 37:  # TOKEN_MODULO
            # Modulo: dividend in %rax, divisor in %rbx
            # Move divisor to %rcx to preserve %rbx
            file_write_fd(output_file, "    movq %rax, %rcx")  # Save divisor in %rcx
            file_write_fd(output_file, "    movq %rbx, %rax")  # Move dividend to %rax

            # Check for modulo by zero
            emit_line(output_file, "    testq %rcx, %rcx")
            Let label_counter be memory_get_integer(codegen, 28)  # codegen->label_counter (int)
            Let jz_instruction be string_concat("    jz .Lmod_by_zero_", integer_to_string(label_counter))
            emit_line(output_file, jz_instruction)

            # Sign extend %rax to %rdx:%rax
            file_write_fd(output_file, "    cqto")
            # Divide by %rcx, quotient in %rax, remainder in %rdx
            file_write_fd(output_file, "    idivq %rcx")
            # Move remainder to %rax
            file_write_fd(output_file, "    movq %rdx, %rax")
            file_write_fd(output_file, "    jmp .Lmod_done_")
            file_write_fd(output_file, integer_to_string(label_counter))

            # Modulo by zero handler
            file_write_fd(output_file, ".Lmod_by_zero_")
            file_write_fd(output_file, integer_to_string(label_counter))
            file_write_fd(output_file, ":")
            file_write_fd(output_file, "    movq $0, %rax")
            file_write_fd(output_file, ".Lmod_done_")
            file_write_fd(output_file, integer_to_string(label_counter))
            file_write_fd(output_file, ":")
            memory_set_integer(codegen, 28, label_counter plus 1)  # codegen->label_counter++ (int)
        End If
        If operator is equal to 39:  # TOKEN_BIT_AND
            file_write_fd(output_file, "    andq %rbx, %rax")
        End If
        If operator is equal to 40:  # TOKEN_BIT_OR
            file_write_fd(output_file, "    orq %rbx, %rax")
        End If
        If operator is equal to 41:  # TOKEN_BIT_XOR
            file_write_fd(output_file, "    xorq %rbx, %rax")
        End If
        If operator is equal to 42:  # TOKEN_BIT_SHIFT_LEFT
            # For left shift, we need the shift amount in %rcx (cl register)
            file_write_fd(output_file, "    movq %rax, %rcx")  # Move shift amount to %rcx
            file_write_fd(output_file, "    movq %rbx, %rax")  # Move value to be shifted to %rax
            file_write_fd(output_file, "    salq %cl, %rax")   # Shift left by %cl bits
        End If
        If operator is equal to 43:  # TOKEN_BIT_SHIFT_RIGHT
            # For right shift, we need the shift amount in %rcx (cl register)
            file_write_fd(output_file, "    movq %rax, %rcx")  # Move shift amount to %rcx
            file_write_fd(output_file, "    movq %rbx, %rax")  # Move value to be shifted to %rax
            file_write_fd(output_file, "    sarq %cl, %rax")   # Arithmetic shift right by %cl bits
        End If
        file_write_fd(2, "[DEBUG] Completed EXPR_BINARY_OP, returning\n")
        Return 0
    End If

    If expr_type is equal to 3:  # EXPR_COMPARISON
        Let left be memory_get_pointer(expr, 8)           # comparison.left
        Let right be memory_get_pointer(expr, 16)         # comparison.right
        Let comparison_op be memory_get_integer(expr, 24) # comparison.comparison_op

        # Generate left operand (result in %rax)
        codegen_generate_expression(codegen, left)
        # Push left operand to stack
        emit_line(output_file, "    pushq %rax")
        # Generate right operand (result in %rax)
        codegen_generate_expression(codegen, right)
        # Pop left operand from stack to %rbx
        emit_line(output_file, "    popq %rbx")

        # Compare and set result (0 or 1)
        emit_line(output_file, "    cmpq %rax, %rbx")
        file_write_fd(2, "[DEBUG] comparison_op=")
        file_write_fd(2, integer_to_string(comparison_op))
        file_write_fd(2, "\n")
        If comparison_op is equal to 22:  # TOKEN_EQUAL
            emit_line(output_file, "    sete %al")
        End If
        If comparison_op is equal to 23:  # TOKEN_NOT_EQUAL
            emit_line(output_file, "    setne %al")
        End If
        If comparison_op is equal to 24:  # TOKEN_LESS
            emit_line(output_file, "    setl %al")
        End If
        If comparison_op is equal to 25:  # TOKEN_GREATER
            emit_line(output_file, "    setg %al")
        End If
        If comparison_op is equal to 27:  # TOKEN_LESS_EQUAL
            file_write_fd(2, "[DEBUG] Emitting setle for LESS_EQUAL\n")
            emit_line(output_file, "    setle %al")
        End If
        If comparison_op is equal to 26:  # TOKEN_GREATER_EQUAL
            emit_line(output_file, "    setge %al")
        End If
        emit_line(output_file, "    movzbq %al, %rax")
        Return 0
    End If

    If expr_type is equal to 4:  # EXPR_FUNCTION_CALL
        Let function_call_ptr be expr plus 8  # &expr->data.function_call
        Let function_name be memory_get_pointer(function_call_ptr, 0)  # function_call.function_name
        Let arguments be memory_get_pointer(function_call_ptr, 8)      # function_call.arguments
        Let arg_count be memory_get_integer(function_call_ptr, 16)     # function_call.argument_count

        # Safety check for function_name
        If function_name is less than 65536:  # Invalid pointer
            file_write_fd(2, "[CODEGEN ERROR] Invalid function_name pointer: ")
            file_write_fd(2, integer_to_string(function_name))
            file_write_fd(2, "\n")
            exit_with_code(1)
        End If

        # Check if this is a list runtime function
        Let is_list_function be 0
        If string_equals(function_name, "list_create") is equal to 1:
            Let is_list_function be 1
        End If
        If string_equals(function_name, "list_append") is equal to 1:
            Let is_list_function be 1
        End If
        If string_equals(function_name, "list_get") is equal to 1:
            Let is_list_function be 1
        End If
        If string_equals(function_name, "list_get_integer") is equal to 1:
            Let is_list_function be 1
        End If
        If string_equals(function_name, "list_length") is equal to 1:
            Let is_list_function be 1
        End If
        If string_equals(function_name, "list_destroy") is equal to 1:
            Let is_list_function be 1
        End If

        # System V ABI: arguments go in %rdi, %rsi, %rdx, %rcx, %r8, %r9
        Let max_register_args be 6
        Let register_arg_count be arg_count
        If arg_count is greater than max_register_args:
            Let register_arg_count be max_register_args
        End If

        # Evaluate arguments in reverse order and push them to stack to preserve order
        file_write_fd(2, "[DEBUG] About to generate arguments, arg_count=")
        file_write_fd(2, integer_to_string(arg_count))
        file_write_fd(2, ", register_arg_count=")
        file_write_fd(2, integer_to_string(register_arg_count))
        file_write_fd(2, "\n")
        Let i be register_arg_count minus 1
        While i is greater than or equal to 0:
            file_write_fd(2, "[DEBUG] Generating arg ")
            file_write_fd(2, integer_to_string(i))
            file_write_fd(2, "\n")
            Let arg_offset be i multiplied by 8
            Let arg_ptr be memory_get_pointer(arguments, arg_offset)
            codegen_generate_expression(codegen, arg_ptr)
            file_write_fd(output_file, "    pushq %rax\n")
            Let i be i minus 1
        End While

        # Pop arguments into correct registers
        file_write_fd(2, "[DEBUG] Popping arguments into registers\n")
        Let i be 0
        While i is less than register_arg_count:
            If i is equal to 0:
                file_write_fd(output_file, "    popq %rdi\n")
            Otherwise If i is equal to 1:
                file_write_fd(output_file, "    popq %rsi\n")
            Otherwise If i is equal to 2:
                file_write_fd(output_file, "    popq %rdx\n")
            Otherwise If i is equal to 3:
                file_write_fd(output_file, "    popq %rcx\n")
            Otherwise If i is equal to 4:
                file_write_fd(output_file, "    popq %r8\n")
            Otherwise If i is equal to 5:
                file_write_fd(output_file, "    popq %r9\n")
            End If
            Let i be i plus 1
        End While

        # Handle arguments beyond 6 (push to stack) - not fully implemented
        If arg_count is greater than max_register_args:
            print_string("[CODEGEN WARNING] Functions with more than 6 arguments not fully supported yet")
        End If

        # Check if this is an indirect call through a function pointer variable
        Let var_index be codegen_find_variable(codegen, function_name)
        If var_index is not equal to 0 minus 1:  # found variable
            # This is a function pointer variable - load it and call indirectly
            Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
            Let var_offset be var_index multiplied by 32
            Let var_ptr be variables plus var_offset
            Let offset be memory_get_integer(var_ptr, 8)  # variable.stack_offset
            file_write_fd(output_file, "    movq -")
            file_write_fd(output_file, integer_to_string(offset))
            file_write_fd(output_file, "(%rbp), %rax  # Load function pointer")
            file_write_fd(output_file, "    call *%rax  # Indirect call")
        Otherwise:
            If is_list_function is equal to 1:
                # For list runtime functions, call the C function directly
                file_write_fd(output_file, "    call ")
                file_write_fd(output_file, function_name)
                file_write_fd(output_file, "@PLT\n")
            Otherwise:
                # For user-defined functions - direct call
                file_write_fd(output_file, "    call ")
                file_write_fd(output_file, function_name)
                file_write_fd(output_file, "\n")
            End If
        End If
        # Result is already in %rax
        Return 0
    End If

    If expr_type is equal to 5:  # EXPR_STRING_LITERAL
        Let string_literal be memory_get_pointer(expr, 8)  # expr->data.string_literal

        # Add string to string literals table if not already present
        Let str_index be 0 minus 1  # -1 for not found
        Let string_count be memory_get_integer(codegen, 40)  # codegen->string_count (int)
        Let strings be memory_get_pointer(codegen, 32)  # codegen->strings (pointer)

        Let i be 0
        While i is less than string_count:
            Let str_offset be i multiplied by 16
            Let str_ptr be strings plus str_offset
            Let existing_value be memory_get_pointer(str_ptr, 0)  # This is a string pointer!
            If string_equals(existing_value, string_literal) is equal to 1:
                Let str_index be i
                Let i be string_count  # break loop
            End If
            Let i be i plus 1
        End While

        If str_index is equal to 0 minus 1:  # not found
            Let str_index be codegen_add_string_literal(codegen, string_literal)
        End If

        # Load address of string literal into %rax
        Let strings be memory_get_pointer(codegen, 32)  # refresh after potential realloc
        Let str_offset be str_index multiplied by 16
        Let str_ptr be strings plus str_offset
        Let label be memory_get_pointer(str_ptr, 8)  # strings[str_index].label
        file_write_fd(output_file, "    leaq ")
        file_write_fd(output_file, label)
        file_write_fd(output_file, "(%rip), %rax\n")
        Return 0
    End If

    If expr_type is equal to 6:  # EXPR_FIELD_ACCESS
        Let field_access_ptr be expr plus 8  # &expr->data.field_access
        Let obj be memory_get_integer(field_access_ptr, 0)     # field_access.object
        Let field_name be memory_get_integer(field_access_ptr, 8)  # field_access.field_name

        # For field access, we need the address of the struct
        Let obj_type be memory_get_integer(obj, 0)  # obj->type

        If obj_type is equal to 1:  # EXPR_VARIABLE
            Let obj_variable_name be memory_get_integer(obj, 8)  # obj->data.variable_name
            Let var_index be codegen_find_variable(codegen, obj_variable_name)
            If var_index is equal to 0 minus 1:  # -1 for not found
                print_string("[CODEGEN ERROR] Unknown variable '")
                print_string(obj_variable_name)
                print_string("'")
                exit_with_code(1)
            End If

            # Find the field offset based on the variable's type
            Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
            Let var_offset be var_index multiplied by 32
            Let var_ptr be variables plus var_offset
            Let type_name be memory_get_pointer(var_ptr, 16)  # variable.type_name
            Let offset be memory_get_integer(var_ptr, 8)      # variable.stack_offset

            If type_name is equal to 0:
                # Variable is untyped - treat as raw pointer
                # Load the pointer value
                file_write_fd(output_file, "    movq -")
                file_write_fd(output_file, integer_to_string(offset))
                file_write_fd(output_file, "(%rbp), %rax")

                # For raw pointer access, we need to determine field offset
                # Calculate field offset based on struct definition
                Let field_offset be 0

                # Common field patterns from our transliterated code
                If string_equals(field_name, "type") is equal to 1:
                    Let field_offset be 0
                Otherwise If string_equals(field_name, "value") is equal to 1:
                    Let field_offset be 8
                Otherwise If string_equals(field_name, "line") is equal to 1:
                    Let field_offset be 16
                Otherwise If string_equals(field_name, "column") is equal to 1:
                    Let field_offset be 24
                Otherwise If string_equals(field_name, "source") is equal to 1:
                    Let field_offset be 0
                Otherwise If string_equals(field_name, "position") is equal to 1:
                    Let field_offset be 8
                Otherwise If string_equals(field_name, "current_char") is equal to 1:
                    Let field_offset be 32
                Otherwise:
                    # Default to sequential 8-byte offsets
                    Let field_offset be 0
                End If

                # Load the field value
                file_write_fd(output_file, "    movq ")
                file_write_fd(output_file, integer_to_string(field_offset))
                file_write_fd(output_file, "(%rax), %rax")
            Otherwise:
                If string_equals(type_name, "Integer") is equal to 1:
                    # Variable is Integer type - treat as raw pointer
                    # Load the pointer value
                    file_write_fd(output_file, "    movq -")
                    file_write_fd(output_file, integer_to_string(offset))
                    file_write_fd(output_file, "(%rbp), %rax")

                    # For raw pointer access, use default field offset
                    Let field_offset be 0
                    If string_equals(field_name, "type") is equal to 1:
                        Let field_offset be 0
                    Otherwise If string_equals(field_name, "value") is equal to 1:
                        Let field_offset be 8
                    Otherwise If string_equals(field_name, "line") is equal to 1:
                        Let field_offset be 16
                    Otherwise If string_equals(field_name, "column") is equal to 1:
                        Let field_offset be 24
                    End If

                    # Load the field value
                    file_write_fd(output_file, "    movq ")
                    file_write_fd(output_file, integer_to_string(field_offset))
                    file_write_fd(output_file, "(%rax), %rax")
                Otherwise:
                # Variable has a type - use type information
                # Load the address of the struct
                file_write_fd(output_file, "    leaq -")
                file_write_fd(output_file, integer_to_string(offset))
                file_write_fd(output_file, "(%rbp), %rax")

                Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)
                Let type_count be memory_get_integer(current_program, 32)  # program->type_count
                Let types be memory_get_integer(current_program, 24)       # program->types
                Let type be 0

                Let i be 0
                While i is less than type_count:
                    Let type_offset be i multiplied by 8
                    Let type_ptr be memory_get_pointer(types, type_offset)
                    Let type_name_ptr be memory_get_pointer(type_ptr, 0)  # type->name
                    If string_equals(type_name_ptr, type_name) is equal to 1:
                        Let type be type_ptr
                        Let i be type_count  # break loop
                    End If
                    Let i be i plus 1
                End While

                If type is equal to 0:
                    print_string("[CODEGEN ERROR] Unknown type '")
                    print_string(type_name)
                    print_string("'")
                    exit_with_code(1)
                End If

                Let field_offset be 0 minus 1  # -1 for not found
                Let kind be memory_get_integer(type, 8)  # type->kind
                If kind is equal to 1:  # TYPE_KIND_STRUCT
                    Let struct_type_ptr be type plus 16  # &type->data.struct_type
                    Let field_count be memory_get_integer(struct_type_ptr, 0)  # struct_type.field_count
                    Let fields be memory_get_integer(struct_type_ptr, 8)       # struct_type.fields

                    Let i be 0
                    While i is less than field_count:
                        Let field_offset be i multiplied by 24
                        Let field_ptr be fields plus field_offset  # sizeof(FieldDefinition)
                        Let field_name_ptr be memory_get_pointer(field_ptr, 0)  # field.name
                        If string_equals(field_name_ptr, field_name) is equal to 1:
                            Let field_offset be memory_get_integer(field_ptr, 16)  # field.offset
                            Let i be field_count  # break loop
                        End If
                        Let i be i plus 1
                    End While
                End If

                If field_offset is equal to 0 minus 1:  # -1 for not found
                    print_string("[CODEGEN ERROR] Type '")
                    print_string(type_name)
                    print_string("' has no field '")
                    print_string(field_name)
                    print_string("'")
                    exit_with_code(1)
                End If

                # Load the field value
                file_write_fd(output_file, "    movq ")
                file_write_fd(output_file, integer_to_string(field_offset))
                file_write_fd(output_file, "(%rax), %rax")
                End If
            End If
        Otherwise:
            # Handle complex field access expressions (nested access)
            # For nested access, we need the ADDRESS of the intermediate object,
            # not its value. Use the lvalue addressing logic.
            codegen_generate_lvalue_address(codegen, obj)

            # Now %rbx contains the address of the object, copy to %rax
            file_write_fd(output_file, "    movq %rbx, %rax")
            # Get the type of the object expression
            Let object_type be codegen_get_expression_type(codegen, obj)
            If object_type is equal to 0:
                print_string("[CODEGEN ERROR] Cannot determine type of complex field access object")
                exit_with_code(1)
            End If

            # Find the type definition for the object type
            Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)
            Let type_count be memory_get_integer(current_program, 32)  # program->type_count
            Let types be memory_get_integer(current_program, 24)       # program->types
            Let type be 0

            Let i be 0
            While i is less than type_count:
                Let type_offset be i multiplied by 8
                Let type_ptr be memory_get_pointer(types, type_offset)
                Let type_name_ptr be memory_get_pointer(type_ptr, 0)  # type->name
                If string_equals(type_name_ptr, object_type) is equal to 1:
                    Let type be type_ptr
                    Let i be type_count  # break loop
                End If
                Let i be i plus 1
            End While

            If type is equal to 0:
                print_string("[CODEGEN ERROR] Unknown type '")
                print_string(object_type)
                print_string("' in complex field access")
                exit_with_code(1)
            End If

            # Find the field offset
            Let field_offset be 0 minus 1  # -1 for not found
            Let kind be memory_get_integer(type, 8)  # type->kind
            If kind is equal to 1:  # TYPE_KIND_STRUCT
                Let struct_type_ptr be type plus 16  # &type->data.struct_type
                Let field_count be memory_get_integer(struct_type_ptr, 0)  # struct_type.field_count
                Let fields be memory_get_integer(struct_type_ptr, 8)       # struct_type.fields

                Let i be 0
                While i is less than field_count:
                    Let field_offset be i multiplied by 24
                    Let field_ptr be fields plus field_offset  # sizeof(FieldDefinition)
                    Let field_name_ptr be memory_get_pointer(field_ptr, 0)  # field.name
                    If string_equals(field_name_ptr, field_name) is equal to 1:
                        Let field_offset be memory_get_integer(field_ptr, 16)  # field.offset
                        Let i be field_count  # break loop
                    End If
                    Let i be i plus 1
                End While
            End If

            If field_offset is equal to 0 minus 1:  # -1 for not found
                print_string("[CODEGEN ERROR] Type '")
                print_string(object_type)
                print_string("' has no field '")
                print_string(field_name)
                print_string("'")
                exit_with_code(1)
            End If

            # Add the field offset to the address in %rax
            If field_offset is greater than 0:
                file_write_fd(output_file, "    addq $")
                file_write_fd(output_file, integer_to_string(field_offset))
                file_write_fd(output_file, ", %rax")
            End If

            # Load the field value
            file_write_fd(output_file, "    movq (%rax), %rax")
        End If
        Return 0
    End If

    # Other expression types (TYPE_NAME should cause error, VARIANT_CONSTRUCTOR, FUNCTION_POINTER, ARRAY_INDEX)
    If expr_type is equal to 7:  # EXPR_TYPE_NAME
        # Type names don't generate code directly - they're handled in LET statements
        # This shouldn't be reached in normal execution
        print_string("[CODEGEN ERROR] Type names should only appear in LET statements")
        exit_with_code(1)
        Return 0
    End If

    If expr_type is equal to 8:  # EXPR_BUILTIN_CALL
        Let builtin_call_ptr be expr plus 8  # &expr->data.builtin_call
        Let builtin_type be memory_get_integer(builtin_call_ptr, 0)  # builtin_call.builtin_type
        Let arg_count be memory_get_integer(builtin_call_ptr, 8)     # builtin_call.argument_count
        Let arguments be memory_get_integer(builtin_call_ptr, 16)    # builtin_call.arguments

        # Map builtin types to function names - complete mapping from C code
        Let func_name be ""
        If builtin_type is equal to 100:  # TOKEN_READ_FILE
            Let func_name be "runtime_read_file"
        Otherwise If builtin_type is equal to 101:  # TOKEN_WRITE_FILE
            Let func_name be "runtime_write_file"
        Otherwise If builtin_type is equal to 102:  # TOKEN_STRING_LENGTH
            Let func_name be "string_length"
        Otherwise If builtin_type is equal to 103:  # TOKEN_STRING_CHAR_AT
            Let func_name be "string_char_at"
        Otherwise If builtin_type is equal to 104:  # TOKEN_STRING_SUBSTRING
            Let func_name be "string_substring"
        Otherwise If builtin_type is equal to 105:  # TOKEN_STRING_EQUALS
            Let func_name be "string_equals"
        Otherwise If builtin_type is equal to 106:  # TOKEN_ASCII_VALUE_OF
            Let func_name be "ascii_value_of"
        Otherwise If builtin_type is equal to 107:  # TOKEN_IS_DIGIT
            Let func_name be "is_digit"
        Otherwise If builtin_type is equal to 108:  # TOKEN_IS_ALPHA
            Let func_name be "is_alpha"
        Otherwise If builtin_type is equal to 109:  # TOKEN_IS_WHITESPACE
            Let func_name be "is_whitespace"
        Otherwise If builtin_type is equal to 110:  # TOKEN_LIST_CREATE
            Let func_name be "list_create"
        Otherwise If builtin_type is equal to 111:  # TOKEN_LIST_APPEND
            Let func_name be "list_append"
        Otherwise If builtin_type is equal to 112:  # TOKEN_LIST_GET
            Let func_name be "list_get"
        Otherwise If builtin_type is equal to 113:  # TOKEN_LIST_GET_INTEGER
            Let func_name be "list_get_integer"
        Otherwise If builtin_type is equal to 114:  # TOKEN_LIST_LENGTH
            Let func_name be "list_length"
        Otherwise If builtin_type is equal to 115:  # TOKEN_LIST_DESTROY
            Let func_name be "list_destroy"
        Otherwise If builtin_type is equal to 116:  # TOKEN_LIST_SET
            Let func_name be "list_set"
        Otherwise If builtin_type is equal to 117:  # TOKEN_LIST_INSERT
            Let func_name be "list_insert"
        Otherwise If builtin_type is equal to 118:  # TOKEN_LIST_REMOVE
            Let func_name be "list_remove"
        Otherwise If builtin_type is equal to 119:  # TOKEN_LIST_CLEAR
            Let func_name be "list_clear"
        Otherwise If builtin_type is equal to 120:  # TOKEN_LIST_FIND
            Let func_name be "list_find"
        Otherwise If builtin_type is equal to 121:  # TOKEN_LIST_SORT
            Let func_name be "list_sort"
        Otherwise If builtin_type is equal to 122:  # TOKEN_LIST_REVERSE
            Let func_name be "list_reverse"
        Otherwise If builtin_type is equal to 123:  # TOKEN_LIST_COPY
            Let func_name be "list_copy"
        Otherwise If builtin_type is equal to 124:  # TOKEN_LIST_MERGE
            Let func_name be "list_merge"
        Otherwise If builtin_type is equal to 125:  # TOKEN_STRING_CONCAT
            Let func_name be "string_concat"
        Otherwise If builtin_type is equal to 126:  # TOKEN_STRING_COMPARE
            Let func_name be "string_compare"
        Otherwise If builtin_type is equal to 127:  # TOKEN_STRING_TO_INTEGER
            Let func_name be "string_to_integer"
        Otherwise If builtin_type is equal to 128:  # TOKEN_INTEGER_TO_STRING
            Let func_name be "integer_to_string"
        Otherwise If builtin_type is equal to 129:  # TOKEN_STRING_FIND
            Let func_name be "string_find"
        Otherwise If builtin_type is equal to 130:  # TOKEN_STRING_REPLACE
            Let func_name be "string_replace"
        Otherwise If builtin_type is equal to 131:  # TOKEN_STRING_TRIM
            Let func_name be "string_trim"
        Otherwise If builtin_type is equal to 132:  # TOKEN_STRING_SPLIT
            Let func_name be "string_split"
        Otherwise If builtin_type is equal to 133:  # TOKEN_FILE_OPEN
            Let func_name be "runtime_file_open"
        Otherwise If builtin_type is equal to 134:  # TOKEN_FILE_CLOSE
            Let func_name be "runtime_file_close"
        Otherwise If builtin_type is equal to 135:  # TOKEN_FILE_READ_LINE
            Let func_name be "runtime_file_read_line"
        Otherwise If builtin_type is equal to 136:  # TOKEN_FILE_WRITE_LINE
            Let func_name be "runtime_file_write_line"
        Otherwise If builtin_type is equal to 137:  # TOKEN_FILE_EXISTS
            Let func_name be "runtime_file_exists"
        Otherwise If builtin_type is equal to 138:  # TOKEN_FILE_DELETE
            Let func_name be "runtime_file_delete"
        Otherwise If builtin_type is equal to 139:  # TOKEN_FILE_SIZE
            Let func_name be "runtime_file_size"
        Otherwise If builtin_type is equal to 140:  # TOKEN_FILE_SEEK
            Let func_name be "runtime_file_seek"
        Otherwise If builtin_type is equal to 141:  # TOKEN_FILE_TELL
            Let func_name be "runtime_file_tell"
        Otherwise If builtin_type is equal to 142:  # TOKEN_FILE_EOF
            Let func_name be "runtime_file_eof"
        Otherwise If builtin_type is equal to 143:  # TOKEN_SIN
            Let func_name be "runtime_sin"
        Otherwise If builtin_type is equal to 144:  # TOKEN_COS
            Let func_name be "runtime_cos"
        Otherwise If builtin_type is equal to 145:  # TOKEN_TAN
            Let func_name be "runtime_tan"
        Otherwise If builtin_type is equal to 146:  # TOKEN_SQRT
            Let func_name be "runtime_sqrt"
        Otherwise If builtin_type is equal to 147:  # TOKEN_POW
            Let func_name be "runtime_pow"
        Otherwise If builtin_type is equal to 148:  # TOKEN_ABS
            Let func_name be "runtime_abs"
        Otherwise If builtin_type is equal to 149:  # TOKEN_FLOOR
            Let func_name be "runtime_floor"
        Otherwise If builtin_type is equal to 150:  # TOKEN_CEIL
            Let func_name be "runtime_ceil"
        Otherwise If builtin_type is equal to 151:  # TOKEN_MIN
            Let func_name be "runtime_min"
        Otherwise If builtin_type is equal to 152:  # TOKEN_MAX
            Let func_name be "runtime_max"
        Otherwise If builtin_type is equal to 153:  # TOKEN_RANDOM
            Let func_name be "runtime_random"
        Otherwise If builtin_type is equal to 154:  # TOKEN_LOG
            Let func_name be "runtime_log"
        Otherwise If builtin_type is equal to 155:  # TOKEN_EXP
            Let func_name be "runtime_exp"
        Otherwise If builtin_type is equal to 156:  # TOKEN_GET_COMMAND_LINE_ARGS
            Let func_name be "get_command_line_args_count"
        Otherwise If builtin_type is equal to 157:  # TOKEN_EXIT_WITH_CODE
            Let func_name be "exit_with_code"
        Otherwise If builtin_type is equal to 158:  # TOKEN_PANIC
            Let func_name be "panic"
        Otherwise If builtin_type is equal to 159:  # TOKEN_ASSERT
            Let func_name be "assert"
        Otherwise If builtin_type is equal to 160:  # TOKEN_ALLOCATE
            Let func_name be "allocate"
        Otherwise If builtin_type is equal to 161:  # TOKEN_DEALLOCATE
            Let func_name be "deallocate"
        Otherwise:
            If 1 is equal to 1:  # Always true - workaround for parser bug
                print_string("[CODEGEN ERROR] Unknown built-in function type")
                exit_with_code(1)
            End If
        End If

        # Validate argument count for each builtin type - complete validation from C code
        # (Extensive argument validation logic preserved from original...)
        Let expected_args be 0 minus 1  # -1 means variable args
        If builtin_type is equal to 100:  # TOKEN_READ_FILE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 101:  # TOKEN_WRITE_FILE
            Let expected_args be 2
        Otherwise If builtin_type is equal to 102:  # TOKEN_STRING_LENGTH
            Let expected_args be 1
        Otherwise If builtin_type is equal to 103:  # TOKEN_STRING_CHAR_AT
            Let expected_args be 2
        Otherwise If builtin_type is equal to 104:  # TOKEN_STRING_SUBSTRING
            Let expected_args be 3
        Otherwise If builtin_type is equal to 105:  # TOKEN_STRING_EQUALS
            Let expected_args be 2
        Otherwise If builtin_type is equal to 106:  # TOKEN_ASCII_VALUE_OF
            Let expected_args be 1
        Otherwise If builtin_type is equal to 107:  # TOKEN_IS_DIGIT
            Let expected_args be 1
        Otherwise If builtin_type is equal to 108:  # TOKEN_IS_ALPHA
            Let expected_args be 1
        Otherwise If builtin_type is equal to 109:  # TOKEN_IS_WHITESPACE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 110:  # TOKEN_LIST_CREATE
            Let expected_args be 0
        Otherwise If builtin_type is equal to 111:  # TOKEN_LIST_APPEND
            Let expected_args be 2
        Otherwise If builtin_type is equal to 112:  # TOKEN_LIST_GET
            Let expected_args be 2
        Otherwise If builtin_type is equal to 113:  # TOKEN_LIST_GET_INTEGER
            Let expected_args be 2
        Otherwise If builtin_type is equal to 114:  # TOKEN_LIST_LENGTH
            Let expected_args be 1
        Otherwise If builtin_type is equal to 115:  # TOKEN_LIST_DESTROY
            Let expected_args be 1
        Otherwise If builtin_type is equal to 133:  # TOKEN_FILE_OPEN
            Let expected_args be 2
        Otherwise If builtin_type is equal to 134:  # TOKEN_FILE_CLOSE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 135:  # TOKEN_FILE_READ_LINE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 136:  # TOKEN_FILE_WRITE_LINE
            Let expected_args be 2
        Otherwise If builtin_type is equal to 137:  # TOKEN_FILE_EXISTS
            Let expected_args be 1
        Otherwise If builtin_type is equal to 138:  # TOKEN_FILE_DELETE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 139:  # TOKEN_FILE_SIZE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 140:  # TOKEN_FILE_SEEK
            Let expected_args be 3
        Otherwise If builtin_type is equal to 141:  # TOKEN_FILE_TELL
            Let expected_args be 1
        Otherwise If builtin_type is equal to 142:  # TOKEN_FILE_EOF
            Let expected_args be 1
        Otherwise If builtin_type is equal to 143:  # TOKEN_SIN
            Let expected_args be 1
        Otherwise If builtin_type is equal to 144:  # TOKEN_COS
            Let expected_args be 1
        Otherwise If builtin_type is equal to 145:  # TOKEN_TAN
            Let expected_args be 1
        Otherwise If builtin_type is equal to 146:  # TOKEN_SQRT
            Let expected_args be 1
        Otherwise If builtin_type is equal to 147:  # TOKEN_POW
            Let expected_args be 2
        Otherwise If builtin_type is equal to 148:  # TOKEN_ABS
            Let expected_args be 1
        Otherwise If builtin_type is equal to 149:  # TOKEN_FLOOR
            Let expected_args be 1
        Otherwise If builtin_type is equal to 150:  # TOKEN_CEIL
            Let expected_args be 1
        Otherwise If builtin_type is equal to 151:  # TOKEN_MIN
            Let expected_args be 2
        Otherwise If builtin_type is equal to 152:  # TOKEN_MAX
            Let expected_args be 2
        Otherwise If builtin_type is equal to 153:  # TOKEN_RANDOM
            Let expected_args be 0
        Otherwise If builtin_type is equal to 154:  # TOKEN_LOG
            Let expected_args be 1
        Otherwise If builtin_type is equal to 155:  # TOKEN_EXP
            Let expected_args be 1
        Otherwise If builtin_type is equal to 156:  # TOKEN_GET_COMMAND_LINE_ARGS
            Let expected_args be 0
        Otherwise If builtin_type is equal to 157:  # TOKEN_EXIT_WITH_CODE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 158:  # TOKEN_PANIC
            Let expected_args be 1
        Otherwise If builtin_type is equal to 159:  # TOKEN_ASSERT
            Let expected_args be 2
        Otherwise If builtin_type is equal to 160:  # TOKEN_ALLOCATE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 161:  # TOKEN_DEALLOCATE
            Let expected_args be 1
        End If

        If expected_args is not equal to 0 minus 1:  # not variable args
            If arg_count is not equal to expected_args:
                print_string("[CODEGEN ERROR] ")
                print_string(func_name)
                print_string(" expects ")
                print_string(integer_to_string(expected_args))
                print_string(" arguments, got ")
                print_string(integer_to_string(arg_count))
                exit_with_code(1)
            End If
        End If

        # Evaluate arguments in reverse order and push them to stack
        Let i be arg_count minus 1
        While i is greater than or equal to 0:
            Let arg_offset be i multiplied by 8
            Let arg_ptr be memory_get_pointer(arguments, arg_offset)
            codegen_generate_expression(codegen, arg_ptr)
            file_write_fd(output_file, "    pushq %rax")
            Let i be i minus 1
        End While

        # Pop arguments into correct registers
        Let i be 0
        While i is less than arg_count:
            If i is equal to 0:
                file_write_fd(output_file, "    popq %rdi")
            Otherwise If i is equal to 1:
                file_write_fd(output_file, "    popq %rsi")
            Otherwise If i is equal to 2:
                file_write_fd(output_file, "    popq %rdx")
            Otherwise If i is equal to 3:
                file_write_fd(output_file, "    popq %rcx")
            Otherwise If i is equal to 4:
                file_write_fd(output_file, "    popq %r8")
            Otherwise If i is equal to 5:
                file_write_fd(output_file, "    popq %r9")
            End If
            Let i be i plus 1
        End While

        # Call the runtime function
        file_write_fd(output_file, "    call ")
        file_write_fd(output_file, func_name)
        file_write_fd(output_file, "@PLT")
        # Result is in %rax
        Return 0
    End If

    If expr_type is equal to 9:  # EXPR_VARIANT_CONSTRUCTOR
        Let variant_constructor_ptr be expr plus 8  # &expr->data.variant_constructor
        Let type_name be memory_get_integer(variant_constructor_ptr, 0)     # variant_constructor.type_name
        Let variant_name be memory_get_integer(variant_constructor_ptr, 8)  # variant_constructor.variant_name
        Let field_count be memory_get_integer(variant_constructor_ptr, 16)  # variant_constructor.field_count
        Let field_values be memory_get_integer(variant_constructor_ptr, 24) # variant_constructor.field_values

        # Find the type definition
        Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)
        Let type_count be memory_get_integer(current_program, 32)  # program->type_count
        Let types be memory_get_integer(current_program, 24)       # program->types
        Let type be 0

        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)  # type->name
            If string_equals(type_name_ptr, type_name) is equal to 1:
                Let type be type_ptr
                Let i be type_count  # break loop
            End If
            Let i be i plus 1
        End While

        If type is equal to 0:
            print_string("[CODEGEN ERROR] Unknown variant type '")
            print_string(type_name)
            print_string("'")
            exit_with_code(1)
        End If

        Let kind be memory_get_integer(type, 8)  # type->kind
        If kind is not equal to 3:  # TYPE_KIND_VARIANT
            print_string("[CODEGEN ERROR] Type '")
            print_string(type_name)
            print_string("' is not a variant type")
            exit_with_code(1)
        End If

        # Find the variant
        Let variant_type_ptr be type plus 16  # &type->data.variant_type
        Let variant_count be memory_get_integer(variant_type_ptr, 0)  # variant_type.variant_count
        Let variants be memory_get_integer(variant_type_ptr, 8)       # variant_type.variants
        Let variant be 0

        Let i be 0
        While i is less than variant_count:
            Let var_offset be i multiplied by 32
            Let variant_ptr be variants plus var_offset  # sizeof(Variant)
            Let variant_name_ptr be memory_get_integer(variant_ptr, 0)  # variant.name
            If string_equals(variant_name_ptr, variant_name) is equal to 1:
                Let variant be variant_ptr
                Let i be variant_count  # break loop
            End If
            Let i be i plus 1
        End While

        If variant is equal to 0:
            print_string("[CODEGEN ERROR] Unknown variant '")
            print_string(variant_name)
            print_string("' in type '")
            print_string(type_name)
            print_string("'")
            exit_with_code(1)
        End If

        # Allocate memory for the variant
        Let type_size be memory_get_integer(type, 16)  # type->size
        file_write_fd(output_file, "    # Construct variant ")
        file_write_fd(output_file, type_name)
        file_write_fd(output_file, "::")
        file_write_fd(output_file, variant_name)
        file_write_fd(output_file, "    movq $")
        file_write_fd(output_file, integer_to_string(type_size))
        file_write_fd(output_file, ", %rdi")
        file_write_fd(output_file, "    call malloc")
        file_write_fd(output_file, "    pushq %rax  # Save variant pointer")

        # Store the tag (variant index)
        Let tag be memory_get_integer(variant, 8)  # variant.tag
        file_write_fd(output_file, "    movq $")
        file_write_fd(output_file, integer_to_string(tag))
        file_write_fd(output_file, ", (%rax)  # Store variant tag")

        # Store field values
        Let variant_fields be memory_get_integer(variant, 16)  # variant.fields
        Let i be 0
        While i is less than field_count:
            # Evaluate field value
            Let field_offset be i multiplied by 8
            Let field_value_ptr be memory_get_integer(field_values plus field_offset, 0)
            codegen_generate_expression(codegen, field_value_ptr)

            # Store in the variant at the right offset
            file_write_fd(output_file, "    popq %rdi  # Restore variant pointer")
            file_write_fd(output_file, "    pushq %rdi  # Keep it on stack")

            Let field_offset be i multiplied by 24
            Let field_ptr be variant_fields plus field_offset  # sizeof(FieldDefinition)
            Let field_offset be memory_get_integer(field_ptr, 16)  # field.offset
            file_write_fd(output_file, "    movq %rax, ")
            file_write_fd(output_file, integer_to_string(field_offset))
            file_write_fd(output_file, "(%rdi)  # Store field at offset ")
            file_write_fd(output_file, integer_to_string(field_offset))
            Let i be i plus 1
        End While

        # Leave the variant pointer in %rax
        file_write_fd(output_file, "    popq %rax  # Final variant pointer")
        Return 0
    End If

    If expr_type is equal to 10:  # EXPR_FUNCTION_POINTER
        Let function_pointer_ptr be expr plus 8  # &expr->data.function_pointer
        Let func_name be memory_get_pointer(function_pointer_ptr, 0)  # function_pointer.function_name

        # Load the address of the named function
        file_write_fd(output_file, "    leaq ")
        file_write_fd(output_file, func_name)
        file_write_fd(output_file, "(%rip), %rax  # Load function address for pointer")
        Return 0
    End If

    If expr_type is equal to 16:  # EXPR_ARRAY_INDEX
        Let array_index_ptr be expr plus 8  # &expr->data.array_index
        Let arr be memory_get_integer(array_index_ptr, 0)  # array_index.array
        Let index be memory_get_integer(array_index_ptr, 8)  # array_index.index

        # Generate code for array indexing with bounds checking
        # Evaluate index expression
        codegen_generate_expression(codegen, index)
        file_write_fd(output_file, "    pushq %rax  # Save index")

        # Get array base address
        Let array_type be memory_get_integer(arr, 0)  # array->type
        If array_type is equal to 1:  # EXPR_VARIABLE
            Let array_variable_name be memory_get_pointer(arr, 8)  # array->data.variable_name
            Let var_index be codegen_find_variable(codegen, array_variable_name)
            If var_index is equal to 0 minus 1:  # -1 for not found
                print_string("[CODEGEN ERROR] Undefined array '")
                print_string(array_variable_name)
                print_string("'")
                exit_with_code(1)
            End If

            Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
            Let var_offset be var_index multiplied by 32
            Let var_ptr be variables plus var_offset
            Let offset be memory_get_integer(var_ptr, 8)          # variable.stack_offset
            Let is_parameter be memory_get_integer(var_ptr, 24)   # variable.is_parameter

            # Check if this is an array parameter or local array
            If is_parameter is equal to 1:
                # For array parameters, load the pointer value
                file_write_fd(output_file, "    movq -")
                file_write_fd(output_file, integer_to_string(offset))
                file_write_fd(output_file, "(%rbp), %rdi  # Load array parameter pointer")
            Otherwise:
                # For local arrays, get the address
                file_write_fd(output_file, "    leaq -")
                file_write_fd(output_file, integer_to_string(offset))
                file_write_fd(output_file, "(%rbp), %rdi  # Array base address")
            End If
        Otherwise:
            # Handle complex array expressions (e.g., function return)
            codegen_generate_expression(codegen, arr)
            file_write_fd(output_file, "    movq %rax, %rdi  # Array base from expression")
        End If

        # Calculate element offset (index * element_size)
        file_write_fd(output_file, "    popq %rax  # Restore index")

        # For arrays, all elements are currently 8 bytes (Integer size)
        file_write_fd(output_file, "    imulq $8, %rax  # index * element_size")

        # Add offset to base address
        file_write_fd(output_file, "    addq %rdi, %rax  # base + offset")

        # Load value from array
        file_write_fd(output_file, "    movq (%rax), %rax  # Load array element")
        Return 0
    End If

    # Unknown expression type
    print_string("[CODEGEN ERROR] Unknown expression type")
    exit_with_code(1)
    Return 0
End Process

# Generate code for statement - equivalent to codegen_generate_statement
Process called "codegen_generate_statement" takes codegen as Integer, stmt as Integer returns Integer:
    file_write_fd(2, "[DEBUG] codegen_generate_statement called, stmt=")
    file_write_fd(2, integer_to_string(stmt))
    file_write_fd(2, "\n")
    Let stmt_type be memory_get_integer(stmt, 0)  # stmt->type - use int32 not integer
    file_write_fd(2, "[DEBUG] Got stmt_type=")
    file_write_fd(2, integer_to_string(stmt_type))
    file_write_fd(2, "\n")
    Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file
    file_write_fd(2, "[DEBUG] Got output_file=")
    file_write_fd(2, integer_to_string(output_file))
    file_write_fd(2, "\n")

    If stmt_type is equal to 1:  # STMT_LET
        file_write_fd(2, "[DEBUG] Processing STMT_LET\n")
        # Check if this is a type allocation
        Let let_expr be memory_get_pointer(stmt, 8)  # stmt->data.let_stmt.expression - use pointer
        file_write_fd(2, "[DEBUG] Got let_expr=")
        file_write_fd(2, integer_to_string(let_expr))
        file_write_fd(2, "\n")
        If let_expr is not equal to 0:
            file_write_fd(2, "[DEBUG] let_expr is not 0\n")
            Let expr_type be memory_get_integer(let_expr, 0)  # expr->type
            file_write_fd(2, "[DEBUG] Got expr_type=")
            file_write_fd(2, integer_to_string(expr_type))
            file_write_fd(2, "\n")
            If expr_type is equal to 7:  # EXPR_TYPE_NAME
                file_write_fd(2, "[DEBUG] expr_type is EXPR_TYPE_NAME\n")
                # This is a struct allocation - find the type
                Let type_name be memory_get_pointer(let_expr, 8)  # expr->data.type_name
                Let current_program be memory_get_pointer(codegen, 48)  # codegen->current_program (pointer with padding)
                Let type_count be memory_get_integer(current_program, 32)  # program->type_count
                Let types be memory_get_pointer(current_program, 40)  # program->types

                Let type_found be 0
                Let type_def be 0
                Let i be 0
                While i is less than type_count:
                    Let current_type be memory_get_pointer(types, i multiplied by 8)
                    Let current_type_name be memory_get_pointer(current_type, 0)  # type->name
                    If string_equals(current_type_name, type_name) is equal to 1:
                        Let type_found be 1
                        Let type_def be current_type
                        Let i be type_count  # Break
                    End If
                    Let i be i plus 1
                End While

                If type_found is equal to 0:
                    file_write_fd(2, "[CODEGEN ERROR] Unknown type '")  # stderr
                    file_write_fd(2, type_name)
                    file_write_fd(2, "'")
                    exit_with_code(1)
                    Return 1
                End If

                # Add variable with type information
                Let variable_name be memory_get_pointer(stmt, 16)  # stmt->data.let_stmt.variable_name
                codegen_add_variable_with_type(codegen, variable_name, type_name)

                # Get variable info
                Let var_index be codegen_find_variable(codegen, variable_name)
                Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
                Let offset be memory_get_integer(variables, var_index multiplied by 32 plus 8)  # variables[var_index].stack_offset

                # Handle different type kinds
                Let type_kind be memory_get_integer(type_def, 8)  # type->kind
                Let type_size be memory_get_integer(type_def, 16)  # type->size

                If type_kind is equal to 2:  # TYPE_KIND_ARRAY
                    # For arrays, allocate space for all elements and zero out memory
                    Let i be 0
                    While i is less than type_size:
                        file_write_fd(output_file, "    movq $0, -")
                        file_write_fd(output_file, integer_to_string(offset minus i))
                        file_write_fd(output_file, "(%rbp)  # Zero array element")
                        Let i be i plus 8
                    End While

                    # Update stack offset to account for full array size
                    Let current_stack_offset be memory_get_integer(codegen, 24)  # codegen->stack_offset
                    memory_set_integer(codegen, 16, current_stack_offset plus type_size)
                Otherwise:
                    # For structs, zero out the struct memory
                    Let i be 0
                    While i is less than type_size:
                        file_write_fd(output_file, "    movq $0, -")
                        file_write_fd(output_file, integer_to_string(offset minus i))
                        file_write_fd(output_file, "(%rbp)\n")
                        Let i be i plus 8
                    End While
                End If
            Otherwise:
                file_write_fd(2, "[DEBUG] Not EXPR_TYPE_NAME, expr_type=")
                file_write_fd(2, integer_to_string(expr_type))
                file_write_fd(2, "\n")
                # Regular expression - add variable to symbol table
                # Check if the expression returns a string or list
                If expr_type is equal to 8:  # EXPR_BUILTIN_CALL
                    file_write_fd(2, "[DEBUG] Processing EXPR_BUILTIN_CALL\n")
                    Let builtin_type be memory_get_integer(let_expr, 8)  # expr->data.builtin_call.builtin_type

                    # Check for string-returning builtins (read_file, string_substring, string_concat, integer_to_string, string_replace, string_trim)
                    Let is_string_builtin be 0
                    If builtin_type is equal to 37:
                        Let is_string_builtin be 1
                    End If
                    If builtin_type is equal to 42:
                        Let is_string_builtin be 1
                    End If
                    If builtin_type is equal to 48:
                        Let is_string_builtin be 1
                    End If
                    If builtin_type is equal to 49:
                        Let is_string_builtin be 1
                    End If
                    If builtin_type is equal to 52:
                        Let is_string_builtin be 1
                    End If
                    If builtin_type is equal to 54:
                        Let is_string_builtin be 1
                    End If
                    If is_string_builtin is equal to 1:
                        Let variable_name be memory_get_pointer(stmt, 16)  # stmt->data.let_stmt.variable_name
                        codegen_add_variable_with_type(codegen, variable_name, "String")
                    Otherwise:
                        # Check for list-returning builtins (list_create, list_copy, list_merge)
                        Let is_list_builtin be 0
                        If builtin_type is equal to 19:
                            Let is_list_builtin be 1
                        End If
                        If builtin_type is equal to 31:
                            Let is_list_builtin be 1
                        End If
                        If builtin_type is equal to 32:
                            Let is_list_builtin be 1
                        End If
                        If is_list_builtin is equal to 1:
                            Let variable_name be memory_get_pointer(stmt, 16)  # stmt->data.let_stmt.variable_name
                            codegen_add_variable_with_type(codegen, variable_name, "List")
                        Otherwise:
                            # Regular integer/other expression
                            Let variable_name be memory_get_pointer(stmt, 16)  # stmt->data.let_stmt.variable_name
                            codegen_add_variable(codegen, variable_name)
                        End If
                    End If
                Otherwise:
                    file_write_fd(2, "[DEBUG] Regular expression, adding variable\n")
                    # Regular integer/other expression
                    Let variable_name be memory_get_pointer(stmt, 16)  # stmt->data.let_stmt.variable_name
                    file_write_fd(2, "[DEBUG] Got variable_name=")
                    file_write_fd(2, variable_name)
                    file_write_fd(2, "\n")
                    file_write_fd(2, "[DEBUG] About to call codegen_add_variable\n")
                    codegen_add_variable(codegen, variable_name)
                    file_write_fd(2, "[DEBUG] Returned from codegen_add_variable\n")
                End If

                # Generate expression (result in %rax)
                file_write_fd(2, "[DEBUG] About to call codegen_generate_expression\n")
                codegen_generate_expression(codegen, let_expr)
                file_write_fd(2, "[DEBUG] Returned from codegen_generate_expression\n")

                # Store value in variable's stack slot
                Let variable_name be memory_get_pointer(stmt, 16)  # stmt->data.let_stmt.variable_name
                file_write_fd(2, "[DEBUG] Got variable_name for store=")
                file_write_fd(2, variable_name)
                file_write_fd(2, "\n")
                Let var_index be codegen_find_variable(codegen, variable_name)
                file_write_fd(2, "[DEBUG] Got var_index=")
                file_write_fd(2, integer_to_string(var_index))
                file_write_fd(2, "\n")
                Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
                Let offset be memory_get_integer(variables, var_index multiplied by 32 plus 8)  # variables[var_index].stack_offset
                file_write_fd(output_file, "    movq %rax, -")
                file_write_fd(output_file, integer_to_string(offset))
                file_write_fd(output_file, "(%rbp)\n")
            End If
        End If
        Return 0
    End If

    If stmt_type is equal to 2:  # STMT_SET
        # Generate value expression (result in %rax)
        Let set_expr be memory_get_pointer(stmt, 16)  # stmt->data.set_stmt.expression
        codegen_generate_expression(codegen, set_expr)

        # Save the value on the stack
        file_write_fd(output_file, "    pushq %rax")

        # Generate the address of the target (result in %rbx)
        Let set_target be memory_get_pointer(stmt, 8)  # stmt->data.set_stmt.target
        codegen_generate_lvalue_address(codegen, set_target)

        # Restore value and store to target address
        file_write_fd(output_file, "    popq %rax")
        file_write_fd(output_file, "    movq %rax, (%rbx)")
        Return 0
    End If

    If stmt_type is equal to 3:  # STMT_RETURN
        # Generate expression (result in %rax)
        Let return_expr be memory_get_pointer(stmt, 8)  # stmt->data.return_stmt.expression - use pointer
        codegen_generate_expression(codegen, return_expr)

        # Function epilogue
        file_write_fd(output_file, "    movq %rbp, %rsp\n")
        file_write_fd(output_file, "    popq %rbp\n")
        file_write_fd(output_file, "    ret\n")
        Return 0
    End If

    If stmt_type is equal to 5:  # STMT_IF
        Let label_counter be memory_get_integer(codegen, 28)  # codegen->label_counter (int)
        Let label_num be label_counter
        memory_set_integer(codegen, 28, label_counter plus 1)  # codegen->label_counter++ (int)

        Let else_label be label_num multiplied by 10 plus 1
        Let end_label be label_num multiplied by 10 plus 2

        # Generate condition (result in %rax)
        Let condition_expr be memory_get_pointer(stmt, 8)  # stmt->data.if_stmt.condition - use pointer
        codegen_generate_expression(codegen, condition_expr)

        # Test if condition is false (0)
        emit_line(output_file, "    testq %rax, %rax")
        Let jz_instruction be string_concat("    jz .L", integer_to_string(else_label))
        emit_line(output_file, jz_instruction)

        # Generate if body
        Let if_body be memory_get_pointer(stmt, 16)  # stmt->data.if_stmt.if_body
        Let if_body_count be memory_get_integer(stmt, 24)  # stmt->data.if_stmt.if_body_count
        Let i be 0
        While i is less than if_body_count:
            Let current_stmt be memory_get_pointer(if_body, i multiplied by 8)
            codegen_generate_statement(codegen, current_stmt)
            Let i be i plus 1
        End While

        file_write_fd(output_file, "    jmp .L")
        file_write_fd(output_file, integer_to_string(end_label))
        file_write_fd(output_file, "\n")

        # Generate else body
        Let else_label_str be string_concat(".L", integer_to_string(else_label))
        Let else_label_line be string_concat(else_label_str, ":")
        emit_line(output_file, else_label_line)
        deallocate(else_label_str)
        deallocate(else_label_line)

        Let else_body be memory_get_pointer(stmt, 32)  # stmt->data.if_stmt.else_body
        Let else_body_count be memory_get_integer(stmt, 40)  # stmt->data.if_stmt.else_body_count
        Let i be 0
        While i is less than else_body_count:
            Let current_stmt be memory_get_pointer(else_body, i multiplied by 8)
            codegen_generate_statement(codegen, current_stmt)
            Let i be i plus 1
        End While

        Let end_label_str be string_concat(".L", integer_to_string(end_label))
        Let end_label_line be string_concat(end_label_str, ":")
        emit_line(output_file, end_label_line)
        deallocate(end_label_str)
        deallocate(end_label_line)
        Return 0
    End If

    If stmt_type is equal to 6:  # STMT_WHILE
        Let label_counter be memory_get_integer(codegen, 28)  # codegen->label_counter (int)
        Let label_num be label_counter
        memory_set_integer(codegen, 28, label_counter plus 1)  # codegen->label_counter++ (int)

        Let loop_start be label_num multiplied by 10 plus 1
        Let loop_end be label_num multiplied by 10 plus 2

        # Push loop context for break/continue statements
        codegen_push_loop_context(codegen, loop_start, loop_end)

        # Loop start label
        file_write_fd(output_file, ".L")
        file_write_fd(output_file, integer_to_string(loop_start))
        file_write_fd(output_file, ":")

        # Generate condition (result in %rax)
        Let condition_expr be memory_get_pointer(stmt, 8)  # stmt->data.while_stmt.condition
        codegen_generate_expression(codegen, condition_expr)

        # Test if condition is false (0)
        emit_line(output_file, "    testq %rax, %rax")
        Let jz_instruction be string_concat("    jz .L", integer_to_string(loop_end))
        emit_line(output_file, jz_instruction)

        # Generate loop body
        Let body be memory_get_pointer(stmt, 16)  # stmt->data.while_stmt.body
        Let body_count be memory_get_integer(stmt, 24)  # stmt->data.while_stmt.body_count
        Let i be 0
        While i is less than body_count:
            Let current_stmt be memory_get_pointer(body, i multiplied by 8)
            codegen_generate_statement(codegen, current_stmt)
            Let i be i plus 1
        End While

        # Jump back to loop start
        file_write_fd(output_file, "    jmp .L")
        file_write_fd(output_file, integer_to_string(loop_start))
        file_write_fd(output_file, "\n")

        # Loop end label
        Let loop_end_str be string_concat(".L", integer_to_string(loop_end))
        Let loop_end_line be string_concat(loop_end_str, ":")
        emit_line(output_file, loop_end_line)
        deallocate(loop_end_str)
        deallocate(loop_end_line)

        # Pop loop context
        codegen_pop_loop_context(codegen)
        Return 0
    End If

    If stmt_type is equal to 9:  # STMT_BREAK
        Let loop_ctx be codegen_current_loop_context(codegen)
        If loop_ctx is not equal to 0:
            Let break_label be memory_get_integer(loop_ctx, 8)  # loop_ctx->break_label
            file_write_fd(output_file, "    jmp .L")
            file_write_fd(output_file, integer_to_string(break_label))
            file_write_fd(output_file, "\n")
        Otherwise:
            file_write_fd(2, "[CODEGEN ERROR] Break statement outside of loop")  # stderr
            exit_with_code(1)
        End If
        Return 0
    End If

    If stmt_type is equal to 10:  # STMT_CONTINUE
        Let loop_ctx be codegen_current_loop_context(codegen)
        If loop_ctx is not equal to 0:
            Let continue_label be memory_get_integer(loop_ctx, 0)  # loop_ctx->continue_label
            file_write_fd(output_file, "    jmp .L")
            file_write_fd(output_file, integer_to_string(continue_label))
            file_write_fd(output_file, "\n")
        Otherwise:
            file_write_fd(2, "[CODEGEN ERROR] Continue statement outside of loop")  # stderr
            exit_with_code(1)
        End If
        Return 0
    End If

    If stmt_type is equal to 16:  # STMT_INLINE_ASSEMBLY
        # Generate raw assembly instructions
        Let assembly_line_count be memory_get_integer(stmt, 8)  # stmt->data.inline_assembly_stmt.assembly_line_count
        Let assembly_lines be memory_get_pointer(stmt, 16)  # stmt->data.inline_assembly_stmt.assembly_lines

        Let i be 0
        While i is less than assembly_line_count:
            Let instruction be memory_get_pointer(assembly_lines, i multiplied by 8)

            # Process escape sequences (especially \n)
            Let instruction_len be string_length(instruction)
            Let processed be allocate(instruction_len plus 1)
            Let src be 0
            Let dst be 0
            While src is less than instruction_len:
                Let current_char be string_char_at(instruction, src)
                If current_char is equal to 92:  # '\' character
                    If src plus 1 is less than instruction_len:
                        Let next_char be string_char_at(instruction, src plus 1)
                        If next_char is equal to 110:  # 'n' character
                            # Skip the \n escape sequence - we don't need newlines in assembly instructions
                            Let src be src plus 2
                        Otherwise:
                            If next_char is equal to 116:  # 't' character
                                memory_set_byte(processed, dst, 9)  # Tab character
                                Let dst be dst plus 1
                                Let src be src plus 2
                            Otherwise:
                                If next_char is equal to 92:  # '\' character
                                    memory_set_byte(processed, dst, 92)  # '\' character
                                    Let dst be dst plus 1
                                    Let src be src plus 2
                                Otherwise:
                                    memory_set_byte(processed, dst, current_char)
                                    Let dst be dst plus 1
                                    Let src be src plus 1
                                End If
                            End If
                        End If
                    Otherwise:
                        memory_set_byte(processed, dst, current_char)
                        Let dst be dst plus 1
                        Let src be src plus 1
                    End If
                Otherwise:
                    memory_set_byte(processed, dst, current_char)
                    Let dst be dst plus 1
                    Let src be src plus 1
                End If
            End While
            memory_set_byte(processed, dst, 0)  # Null terminator

            emit_line(output_file, "")
            file_write_fd(output_file, processed)
            file_write_fd(output_file, "\n")

            deallocate(processed)
            Let i be i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 4:  # STMT_PRINT
        # Generate expression (result in %rax)
        Let print_expr be memory_get_pointer(stmt, 8)  # stmt->data.print_stmt.expression
        codegen_generate_expression(codegen, print_expr)

        # Call appropriate print function based on expression type
        Let expr_type be memory_get_integer(print_expr, 0)  # expr->type
        If expr_type is equal to 5:  # EXPR_STRING_LITERAL
            # String literal - call print_string
            file_write_fd(output_file, "    movq %rax, %rdi")
            file_write_fd(output_file, "    call print_string")
        Otherwise:
            If expr_type is equal to 8:  # EXPR_BUILTIN_CALL
                Let builtin_type be memory_get_integer(print_expr, 8)  # expr->data.builtin_call.builtin_type
                # Check for string-returning builtins (read_file, string_substring, string_concat, integer_to_string, string_replace, string_trim)
                Let is_string_builtin be 0
                If builtin_type is equal to 37:
                    Let is_string_builtin be 1
                End If
                If builtin_type is equal to 42:
                    Let is_string_builtin be 1
                End If
                If builtin_type is equal to 48:
                    Let is_string_builtin be 1
                End If
                If builtin_type is equal to 49:
                    Let is_string_builtin be 1
                End If
                If builtin_type is equal to 52:
                    Let is_string_builtin be 1
                End If
                If builtin_type is equal to 54:
                    Let is_string_builtin be 1
                End If
                If is_string_builtin is equal to 1:
                    # These functions return strings - call print_string
                    file_write_fd(output_file, "    movq %rax, %rdi\n")
                    file_write_fd(output_file, "    call print_string\n")
                Otherwise:
                    # Integer expression - call print_integer
                    file_write_fd(output_file, "    movq %rax, %rdi\n")
                    file_write_fd(output_file, "    call print_integer\n")
                End If
            Otherwise:
                If expr_type is equal to 1:  # EXPR_VARIABLE
                    # Check variable type to determine appropriate print function
                    Let variable_name be memory_get_integer(print_expr, 8)  # expr->data.variable_name
                    Let var_index be codegen_find_variable(codegen, variable_name)
                    If var_index is not equal to 0 minus 1:
                        Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
                        Let type_name be memory_get_pointer(variables, var_index multiplied by 32 plus 16)  # variables[var_index].type_name
                        If type_name is not equal to 0:
                            If string_equals(type_name, "String") is equal to 1:
                                # This variable contains a string - call print_string
                                file_write_fd(output_file, "    movq %rax, %rdi\n")
                                file_write_fd(output_file, "    call print_string\n")
                            Otherwise:
                                If string_equals(type_name, "List") is equal to 1:
                                    # This variable contains a list pointer - print as integer address
                                    file_write_fd(output_file, "    movq %rax, %rdi\n")
                                    file_write_fd(output_file, "    call print_integer\n")
                                Otherwise:
                                    # Assume integer for other variables
                                    file_write_fd(output_file, "    movq %rax, %rdi\n")
                                    file_write_fd(output_file, "    call print_integer\n")
                                End If
                            End If
                        Otherwise:
                            # Assume integer for untyped variables
                            file_write_fd(output_file, "    movq %rax, %rdi\n")
                            file_write_fd(output_file, "    call print_integer\n")
                        End If
                    Otherwise:
                        # Variable not found, assume integer
                        file_write_fd(output_file, "    movq %rax, %rdi\n")
                        file_write_fd(output_file, "    call print_integer\n")
                    End If
                Otherwise:
                    # Integer expression (literal, arithmetic) - call print_integer
                    file_write_fd(output_file, "    movq %rax, %rdi\n")
                    file_write_fd(output_file, "    call print_integer\n")
                End If
            End If
        End If
        Return 0
    End If

    If stmt_type is equal to 7:  # STMT_EXPRESSION
        # Generate the expression and ignore its result
        file_write_fd(2, "[DEBUG] Processing STMT_EXPRESSION\n")
        Let expr_stmt_expr be memory_get_pointer(stmt, 8)  # stmt->data.expr_stmt.expression
        file_write_fd(2, "[DEBUG] Got expr_stmt_expr=")
        file_write_fd(2, integer_to_string(expr_stmt_expr))
        file_write_fd(2, "\n")
        file_write_fd(2, "[DEBUG] About to call codegen_generate_expression\n")
        codegen_generate_expression(codegen, expr_stmt_expr)
        file_write_fd(2, "[DEBUG] Returned from codegen_generate_expression\n")
        Return 0
    End If

    If stmt_type is equal to 8:  # STMT_IMPORT
        # Imports are handled at program level, no code generation needed
        Return 0
    End If

    If stmt_type is equal to 7:  # STMT_MATCH
        # Evaluate the expression to match on
        Let match_expr be memory_get_pointer(stmt, 8)  # stmt->data.match_stmt.expression
        codegen_generate_expression(codegen, match_expr)
        file_write_fd(output_file, "    pushq %rax  # Save match expression value")

        # Generate unique labels for each case and the end
        Let label_counter be memory_get_integer(codegen, 28)  # codegen->label_counter (int)
        Let match_id be label_counter
        memory_set_integer(codegen, 28, label_counter plus 1)  # codegen->label_counter++ (int)

        Let end_label be string_concat(".match_end_", integer_to_string(match_id))

        # Generate code for each case
        Let case_count be memory_get_integer(stmt, 16)  # stmt->data.match_stmt.case_count
        Let cases be memory_get_pointer(stmt, 24)  # stmt->data.match_stmt.cases

        Let i be 0
        While i is less than case_count:
            Let case_offset be i multiplied by 64
            Let match_case be cases plus case_offset  # sizeof(MatchCase) estimate
            Let variant_name be memory_get_pointer(match_case, 0)  # match_case->variant_name
            Let field_count be memory_get_integer(match_case, 8)  # match_case->field_count
            Let field_names be memory_get_pointer(match_case, 16)  # match_case->field_names
            Let body_count be memory_get_integer(match_case, 24)  # match_case->body_count
            Let body be memory_get_pointer(match_case, 32)  # match_case->body

            Let case_label be string_concat(".match_case_", string_concat(integer_to_string(match_id), string_concat("_", integer_to_string(i))))
            Let next_case_id be i plus 1
            Let next_label be string_concat(".match_case_", string_concat(integer_to_string(match_id), string_concat("_", integer_to_string(next_case_id))))

            # Check if this case matches
            file_write_fd(output_file, case_label)
            file_write_fd(output_file, ":")
            file_write_fd(output_file, "    popq %rax  # Get match expression")
            file_write_fd(output_file, "    pushq %rax  # Keep on stack")

            # Load the tag from the variant
            file_write_fd(output_file, "    movq (%rax), %rdx  # Load variant tag")

            # Find the tag value for this variant name - ADT variant tags are sequential starting from 0
            file_write_fd(output_file, "    cmpq $")
            file_write_fd(output_file, integer_to_string(i))
            file_write_fd(output_file, ", %rdx  # Check tag for ")
            file_write_fd(output_file, variant_name)
            file_write_fd(output_file, "\n")

            If i is less than case_count minus 1:
                file_write_fd(output_file, "    jne ")
                file_write_fd(output_file, next_label)
                file_write_fd(output_file, "  # Jump to next case")
            Otherwise:
                file_write_fd(output_file, "    jne ")
                file_write_fd(output_file, end_label)
                file_write_fd(output_file, "  # No match, exit")
            End If

            # If we matched, extract fields and bind to local variables
            If field_count is greater than 0:
                # Pop the variant pointer
                file_write_fd(output_file, "    popq %rax  # Get variant pointer")
                file_write_fd(output_file, "    pushq %rax  # Keep on stack")

                # ADT fields start at offset 8 (after tag) with 8 bytes per field
                Let j be 0
                While j is less than field_count:
                    Let field_offset_value be j multiplied by 8
                    Let field_offset be 8 plus field_offset_value
                    file_write_fd(output_file, "    movq ")
                    file_write_fd(output_file, integer_to_string(field_offset))
                    file_write_fd(output_file, "(%rax), %rdx  # Load field ")
                    file_write_fd(output_file, integer_to_string(j))
                    file_write_fd(output_file, "\n")

                    # Create a local variable for the binding - allocate stack space properly
                    Let current_stack_offset be memory_get_integer(codegen, 24)  # codegen->stack_offset
                    Let new_stack_offset be current_stack_offset plus 8
                    memory_set_integer(codegen, 16, new_stack_offset)

                    file_write_fd(output_file, "    movq %rdx, -")
                    file_write_fd(output_file, integer_to_string(new_stack_offset))
                    Let field_name be memory_get_pointer(field_names, j multiplied by 8)
                    file_write_fd(output_file, "(%rbp)  # Store ")
                    file_write_fd(output_file, field_name)
                    file_write_fd(output_file, " at stack offset")

                    # Add the binding to the variable table with correct offset
                    Let variable_count be memory_get_integer(codegen, 16)  # codegen->variable_count (int)
                    Let variable_capacity be memory_get_integer(codegen, 24)  # codegen->variable_capacity
                    If variable_count is greater than or equal to variable_capacity:
                        Let new_capacity be variable_capacity multiplied by 2
                        memory_set_integer(codegen, 24, new_capacity)
                        Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
                        Let new_variables be reallocate(variables, new_capacity multiplied by 32)  # sizeof(Variable) = 32
                        memory_set_pointer(codegen, 8, new_variables)
                    End If

                    Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
                    Let var_idx_offset be variable_count multiplied by 32  # sizeof(Variable) = 32
                    memory_set_pointer(variables, var_idx_offset, string_duplicate(field_name))  # name
                    memory_set_integer(variables, var_idx_offset plus 8, new_stack_offset)  # stack_offset
                    memory_set_pointer(variables, var_idx_offset plus 16, string_duplicate("Integer"))  # type_name
                    memory_set_integer(codegen, 12, variable_count plus 1)  # Increment variable_count

                    Let j be j plus 1
                End While
            End If

            # Generate the case body
            Let k be 0
            While k is less than body_count:
                Let current_stmt be memory_get_pointer(body, k multiplied by 8)
                codegen_generate_statement(codegen, current_stmt)
                Let k be k plus 1
            End While

            # Clean up bindings from variable table but keep stack offset
            If field_count is greater than 0:
                # Free the variable names we allocated
                Let j be 0
                While j is less than field_count:
                    Let variable_count be memory_get_integer(codegen, 16)  # codegen->variable_count (int)
                    Let var_idx be variable_count minus field_count plus j
                    Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
                    Let var_name be memory_get_integer(variables, var_idx multiplied by 24)
                    Let var_type_name be memory_get_integer(variables, var_idx multiplied by 24 plus 16)
                    deallocate(var_name)
                    deallocate(var_type_name)
                    Let j be j plus 1
                End While
                # Remove from variable table
                Let variable_count be memory_get_integer(codegen, 16)  # codegen->variable_count (int)
                memory_set_integer(codegen, 12, variable_count minus field_count)
            End If

            # Jump to end
            file_write_fd(output_file, "    jmp ")
            file_write_fd(output_file, end_label)
            file_write_fd(output_file, "\n")

            Let i be i plus 1
        End While

        file_write_fd(output_file, end_label)
        file_write_fd(output_file, ":")
        file_write_fd(output_file, "    popq %rax  # Clean up match expression")
        Return 0
    End If

    Return 0
End Process

# Create a new code generator - equivalent to codegen_create
Process called "codegen_create" takes output_filename as Integer returns Integer:
    print_string("[DEBUG] codegen_create called")
    Let codegen be allocate(104)  # sizeof(CodeGenerator) - need more space for all fields
    print_string("[DEBUG] codegen pointer=")
    print_integer(codegen)

    Let output_file be file_open_fd(output_filename, "w")
    If output_file is equal to 0 minus 1:  # -1 indicates error
        # Failed to open output file
        deallocate(codegen)
        Return 0
    End If
    memory_set_integer(codegen, 0, output_file)  # codegen->output_file

    Let variables be allocate(16 multiplied by 32)  # 16 * sizeof(Variable) - Variable is 32 bytes
    memory_set_pointer(codegen, 8, variables)  # codegen->variables
    memory_set_integer(codegen, 16, 0)  # codegen->variable_count (int)
    memory_set_integer(codegen, 20, 16)  # codegen->variable_capacity (int) - Start with space for 16 variables

    # DEBUG: Verify it was set
    Let test_capacity be memory_get_integer(codegen, 20)
    print_string("[DEBUG] After setting, variable_capacity=")
    print_integer(test_capacity)

    memory_set_integer(codegen, 24, 0)  # codegen->stack_offset (int)
    memory_set_integer(codegen, 28, 0)  # codegen->label_counter (int)
    memory_set_integer(codegen, 40, 0)  # codegen->string_count (int)
    memory_set_integer(codegen, 44, 32)  # codegen->string_capacity (int) - Start with space for 32 strings

    Let strings be allocate(32 multiplied by 16)  # 32 * sizeof(StringLiteral)
    memory_set_pointer(codegen, 32, strings)  # codegen->strings (pointer with padding)
    memory_set_pointer(codegen, 48, 0)  # codegen->current_program (pointer with padding)
    memory_set_integer(codegen, 64, 0)  # codegen->loop_depth (int)
    memory_set_integer(codegen, 68, 8)  # codegen->loop_capacity (int) - Start with space for 8 nested loops

    Let loop_stack be allocate(8 multiplied by 16)  # 8 * sizeof(LoopContext)
    memory_set_pointer(codegen, 56, loop_stack)  # codegen->loop_stack (pointer)

    If output_file is equal to 0:
        file_write_fd(2, "[CODEGEN ERROR] Could not open output file '")  # stderr
        file_write_fd(2, output_filename)
        file_write_fd(2, "'")
        deallocate(variables)
        deallocate(strings)
        deallocate(loop_stack)
        deallocate(codegen)
        Return 0
    End If

    Return codegen
End Process

# Destroy a code generator - equivalent to codegen_destroy
Process called "codegen_destroy" takes codegen as Integer returns Integer:
    If codegen is not equal to 0:
        Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file
        If output_file is not equal to 0:
            file_close_fd(output_file)
        End If

        # Free variable names and type names
        Let variable_count be memory_get_integer(codegen, 16)  # codegen->variable_count (int)
        Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
        If variables is not equal to 0:
            Let i be 0
            While i is less than variable_count:
                Let var_offset be i multiplied by 32  # sizeof(Variable) = 32
                Let var_ptr be variables plus var_offset
                Let var_name be memory_get_pointer(var_ptr, 0)  # Variable.name at offset 0
                Let var_type_name be memory_get_pointer(var_ptr, 16)  # Variable.type_name at offset 16
                If var_name is not equal to 0:
                    deallocate(var_name)
                End If
                If var_type_name is not equal to 0:
                    deallocate(var_type_name)
                End If
                Let i be i plus 1
            End While
        End If

        # Free string literal values and labels
        Let string_count be memory_get_integer(codegen, 40)  # codegen->string_count (int)
        Let strings be memory_get_pointer(codegen, 32)  # codegen->strings (pointer with padding)
        If strings is not equal to 0:
            Let i be 0
            While i is less than string_count:
                Let str_offset be i multiplied by 16  # sizeof(StringLiteral) = 16
                Let str_ptr be strings plus str_offset
                Let str_value be memory_get_pointer(str_ptr, 0)  # StringLiteral.value at offset 0
                Let str_label be memory_get_pointer(str_ptr, 8)  # StringLiteral.label at offset 8
                If str_value is not equal to 0:
                    deallocate(str_value)
                End If
                If str_label is not equal to 0:
                    deallocate(str_label)
                End If
                Let i be i plus 1
            End While
        End If

        If variables is not equal to 0:
            deallocate(variables)
        End If
        If strings is not equal to 0:
            deallocate(strings)
        End If
        Let loop_stack be memory_get_pointer(codegen, 56)  # codegen->loop_stack (pointer)
        If loop_stack is not equal to 0:
            deallocate(loop_stack)
        End If
        deallocate(codegen)
    End If
    Return 0
End Process

# Push a new loop context for break/continue handling - equivalent to codegen_push_loop_context
Process called "codegen_push_loop_context" takes codegen as Integer, continue_label as Integer, break_label as Integer returns Integer:
    Let loop_depth be memory_get_integer(codegen, 64)  # codegen->loop_depth (int)
    Let loop_capacity be memory_get_integer(codegen, 68)  # codegen->loop_capacity (int)

    # Expand loop stack if necessary
    If loop_depth is greater than or equal to loop_capacity:
        Let new_capacity be loop_capacity multiplied by 2
        memory_set_integer(codegen, 44, new_capacity)  # codegen->string_capacity (int)
        Let loop_stack be memory_get_pointer(codegen, 56)  # codegen->loop_stack (pointer)
        Let new_loop_stack be reallocate(loop_stack, 16 multiplied by new_capacity)  # sizeof(LoopContext) * new_capacity
        memory_set_pointer(codegen, 56, new_loop_stack)  # codegen->loop_stack (pointer)
    End If

    Let loop_stack be memory_get_integer(codegen, 96)  # codegen->loop_stack
    Let context_offset be loop_depth multiplied by 16  # sizeof(LoopContext)
    memory_set_integer(loop_stack, context_offset, continue_label)  # continue_label
    memory_set_integer(loop_stack, context_offset plus 8, break_label)  # break_label
    memory_set_integer(codegen, 64, loop_depth plus 1)  # Increment loop_depth (int)
    Return 0
End Process

# Pop the current loop context - equivalent to codegen_pop_loop_context
Process called "codegen_pop_loop_context" takes codegen as Integer returns Integer:
    Let loop_depth be memory_get_integer(codegen, 64)  # codegen->loop_depth (int)
    If loop_depth is greater than 0:
        memory_set_integer(codegen, 64, loop_depth minus 1)  # codegen->loop_depth (int)
    End If
    Return 0
End Process

# Get the current loop context - equivalent to codegen_current_loop_context
Process called "codegen_current_loop_context" takes codegen as Integer returns Integer:
    Let loop_depth be memory_get_integer(codegen, 64)  # codegen->loop_depth (int)
    If loop_depth is greater than 0:
        Let loop_stack be memory_get_pointer(codegen, 56)  # codegen->loop_stack (pointer)
        Let context_offset be loop_depth minus 1 multiplied by 16  # sizeof(LoopContext)
        Return loop_stack plus context_offset
    End If
    Return 0  # NULL
End Process

# Generate code for a function - equivalent to codegen_generate_function
Process called "codegen_generate_function" takes codegen as Integer, func as Integer returns Integer:
    file_write_fd(2, "[DEBUG] codegen_generate_function called with func=")
    file_write_fd(2, integer_to_string(func))
    file_write_fd(2, "\n")
    # Reset variable state for each function
    memory_set_integer(codegen, 16, 0)  # codegen->variable_count = 0
    memory_set_integer(codegen, 24, 0)  # codegen->stack_offset = 0
    memory_set_integer(codegen, 64, 0)  # codegen->loop_depth = 0 (int)

    Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file
    Let func_name be memory_get_pointer(func, 0)  # func->name
    file_write_fd(2, "[DEBUG] Got func_name=")
    file_write_fd(2, func_name)
    file_write_fd(2, "\n")

    # Export function as global symbol for cross-module linking
    file_write_fd(output_file, ".globl ")
    file_write_fd(output_file, func_name)
    file_write_fd(output_file, "\n")

    # Function label
    file_write_fd(output_file, func_name)
    file_write_fd(output_file, ":\n")

    # Function prologue
    emit_line(output_file, "    pushq %rbp")
    emit_line(output_file, "    movq %rsp, %rbp")

    file_write_fd(2, "[DEBUG] About to handle parameters\n")
    # Handle parameters (System V ABI: %rdi, %rsi, %rdx, %rcx, %r8, %r9)
    Let param_registers be allocate(6 multiplied by 8)  # Array of 6 string pointers
    file_write_fd(2, "[DEBUG] Allocated param_registers\n")
    memory_set_pointer(param_registers, 0, "%rdi")
    memory_set_pointer(param_registers, 8, "%rsi")
    memory_set_pointer(param_registers, 16, "%rdx")
    memory_set_pointer(param_registers, 24, "%rcx")
    memory_set_pointer(param_registers, 32, "%r8")
    memory_set_pointer(param_registers, 40, "%r9")
    Let max_register_params be 6

    Let parameter_count be memory_get_integer(func, 16)  # func->parameter_count
    file_write_fd(2, "[DEBUG] Got parameter_count=")
    file_write_fd(2, integer_to_string(parameter_count))
    file_write_fd(2, "\n")

    # If this is main function with argc/argv parameters, initialize command line args
    If string_equals(func_name, "main") is equal to 1:
        If parameter_count is greater than or equal to 2:
            # Store original argc and argv before processing them as Runa parameters
            file_write_fd(output_file, "    # Initialize command line arguments")
            file_write_fd(output_file, "    pushq %rdi  # Save argc")
            file_write_fd(output_file, "    pushq %rsi  # Save argv")
            file_write_fd(output_file, "    call runtime_set_command_line_args@PLT")
            file_write_fd(output_file, "    popq %rsi   # Restore argv")
            file_write_fd(output_file, "    popq %rdi   # Restore argc")
            file_write_fd(output_file, "\n")
        End If
    End If

    file_write_fd(2, "[DEBUG] Done with main function check\n")
    # CRITICAL FIX: Allocate stack space BEFORE any stack access to prevent Valgrind violations
    # Pre-allocate generous stack space for all function variables and temporaries
    emit_line(output_file, "    subq $512, %rsp  # Pre-allocate generous stack space")
    file_write_fd(2, "[DEBUG] Allocated stack space\n")

    Let parameters be memory_get_pointer(func, 8)  # func->parameters (Parameter*)
    file_write_fd(2, "[DEBUG] Got parameters pointer\n")
    Let i be 0
    Let should_continue be 1
    While should_continue is equal to 1:
        If i is greater than or equal to parameter_count:
            Let should_continue be 0
        End If
        If i is greater than or equal to max_register_params:
            Let should_continue be 0
        End If
        If should_continue is equal to 1:
        # Add parameter as a variable and store from appropriate register
        # Use the parameter type from the function definition
        Let param_offset be i multiplied by 16  # sizeof(Parameter)
        Let param_name be memory_get_pointer(parameters, param_offset)  # parameters[i].name
        Let param_type be memory_get_pointer(parameters, param_offset plus 8)  # parameters[i].type
        If param_type is equal to 0:
            Let param_type be "Integer"  # Default type
        End If

        Let param_index be codegen_add_variable_with_type_and_param_flag(codegen, param_name, param_type, 1)  # Mark as parameter
        Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
        Let var_offset be param_index multiplied by 32  # sizeof(Variable) = 32, not 24!
        Let var_ptr be variables plus var_offset
        Let param_stack_offset be memory_get_integer(var_ptr, 8)  # variables[param_index].stack_offset
        Let register_name be memory_get_pointer(param_registers, i multiplied by 8)
        file_write_fd(output_file, "    movq ")
        file_write_fd(output_file, register_name)
        file_write_fd(output_file, ", -")
        file_write_fd(output_file, integer_to_string(param_stack_offset))
        file_write_fd(output_file, "(%rbp)\n")

        Let i be i plus 1
        End If  # End of should_continue check
    End While

    # Handle parameters beyond 6 (passed on stack in System V ABI)
    Let i be max_register_params
    While i is less than parameter_count:
        Let param_offset be i multiplied by 16  # sizeof(Parameter)
        Let param_name be memory_get_pointer(parameters, param_offset)  # parameters[i].name
        Let param_type be memory_get_pointer(parameters, param_offset plus 8)  # parameters[i].type
        Let param_index be codegen_add_variable_with_type_and_param_flag(codegen, param_name, param_type, 1)  # Mark as parameter
        Let variables be memory_get_pointer(codegen, 8)  # codegen->variables
        Let var_offset be param_index multiplied by 32  # sizeof(Variable) = 32, not 24!
        Let var_ptr be variables plus var_offset
        Let param_stack_offset be memory_get_integer(var_ptr, 8)  # variables[param_index].stack_offset

        # Stack parameters are at positive offsets from rbp: 16(%rbp), 24(%rbp), etc.
        Let stack_param_index be i minus max_register_params
        Let stack_param_offset_value be stack_param_index multiplied by 8
        Let stack_param_offset be 16 plus stack_param_offset_value
        file_write_fd(output_file, "    movq ")
        file_write_fd(output_file, integer_to_string(stack_param_offset))
        file_write_fd(output_file, "(%rbp), %rax")
        file_write_fd(output_file, "    movq %rax, -")
        file_write_fd(output_file, integer_to_string(param_stack_offset))
        file_write_fd(output_file, "(%rbp)")

        Let i be i plus 1
    End While

    file_write_fd(2, "[DEBUG] About to generate function body statements\n")
    # Generate function body statements
    # Function structure has:
    # offset 24: return_type (string)
    # offset 32: statements (Statement** array)
    # offset 40: statement_count (int)
    Let statement_count be memory_get_integer(func, 40)  # func->statement_count
    file_write_fd(2, "[DEBUG] Got statement_count=")
    file_write_fd(2, integer_to_string(statement_count))
    file_write_fd(2, "\n")
    Let statements be memory_get_pointer(func, 32)     # func->statements
    file_write_fd(2, "[DEBUG] Got statements pointer\n")

    If statements is not equal to 0:
        file_write_fd(2, "[DEBUG] Entering statement loop\n")
        Let stmt_idx be 0
        While stmt_idx is less than statement_count:
            file_write_fd(2, "[DEBUG] Processing statement ")
            file_write_fd(2, integer_to_string(stmt_idx))
            file_write_fd(2, "\n")
            Let stmt be memory_get_pointer(statements, stmt_idx multiplied by 8)  # statements[stmt_idx]
            file_write_fd(2, "[DEBUG] Got stmt pointer\n")
            If stmt is not equal to 0:
                file_write_fd(2, "[DEBUG] About to call codegen_generate_statement\n")
                codegen_generate_statement(codegen, stmt)
                file_write_fd(2, "[DEBUG] Returned from codegen_generate_statement\n")
            End If
            Let stmt_idx be stmt_idx plus 1
        End While
    End If

    # Add function epilogue if function doesn't end with explicit return
    emit_line(output_file, "    movq %rbp, %rsp")
    emit_line(output_file, "    popq %rbp")
    emit_line(output_file, "    ret")

    deallocate(param_registers)
    Return 0
End Process

# Main code generation entry point - equivalent to codegen_generate
Process called "codegen_generate" takes codegen as Integer, program as Integer returns Integer:
    # Store program reference for type lookups
    memory_set_pointer(codegen, 48, program)  # codegen->current_program = program (pointer with padding)

    Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file

    # Check if program is initialized properly
    Let import_count be memory_get_integer(program, 40)  # PROGRAM_IMPORT_COUNT - use int32 not integer
    # Instead check if it's a reasonable value first
    If import_count is equal to 0:
    Otherwise:
    End If

    # Safety check to prevent accessing invalid memory
    If import_count is less than 0:
        Set import_count to 0
    End If
    If import_count is greater than 1000:
        Set import_count to 0
    End If

    # Generate import comments (for documentation)
    If import_count is greater than 0:
        file_write_fd(output_file, "# Imports:")
        Let imports be memory_get_pointer(program, 32)  # PROGRAM_IMPORTS - should be pointer not integer
        Let i be 0
        While i is less than import_count:
            Let import be memory_get_pointer(imports, i multiplied by 8)
            Let import_filename be memory_get_integer(import, 0)  # import->filename
            Let module_name be memory_get_integer(import, 8)  # import->module_name
            file_write_fd(output_file, "#   Import ")
            file_write_fd(output_file, import_filename)
            file_write_fd(output_file, " as ")
            file_write_fd(output_file, module_name)
            file_write_fd(output_file, "\n")
            Let i be i plus 1
        End While
        file_write_fd(output_file, "\n")
    End If

    # First pass: collect all string literals by analyzing the AST
    file_write_fd(2, "[DEBUG] About to read function_count from program+8\n")
    Let function_count be memory_get_integer(program, 8)   # PROGRAM_FUNCTION_COUNT - use int32
    file_write_fd(2, "[DEBUG] function_count=")
    file_write_fd(2, integer_to_string(function_count))
    file_write_fd(2, "\n")

    # Safety check: if function_count is negative or too large, assume no functions
    If function_count is less than 0:
        Let function_count be 0
    End If
    If function_count is greater than 10000:  # Sanity check
        Let function_count be 0
    End If

    file_write_fd(2, "[DEBUG] About to read functions pointer from program+0\n")
    Let functions be memory_get_pointer(program, 0)        # PROGRAM_FUNCTIONS - use pointer
    file_write_fd(2, "[DEBUG] functions=")
    file_write_fd(2, integer_to_string(functions))
    file_write_fd(2, "\n")

    # Safety check - if functions is a small number, it's likely corrupt
    If functions is less than 65536:  # 0x10000 - reasonable minimum address
        file_write_fd(2, "[CODEGEN ERROR] Invalid functions pointer: ")
        file_write_fd(2, integer_to_string(functions))
        Return 0
    End If

    Let i be 0
    file_write_fd(2, "[DEBUG] Starting function loop with i=0\n")
    While i is less than function_count:
        file_write_fd(2, "[DEBUG] While loop check: i=")
        file_write_fd(2, integer_to_string(i))
        file_write_fd(2, ", function_count=")
        file_write_fd(2, integer_to_string(function_count))
        file_write_fd(2, "\n")
        file_write_fd(2, "[DEBUG] Loop iteration i=")
        file_write_fd(2, integer_to_string(i))
        file_write_fd(2, ", about to call memory_get_pointer(functions=")
        file_write_fd(2, integer_to_string(functions))
        file_write_fd(2, ", offset=")
        file_write_fd(2, integer_to_string(i multiplied by 8))
        file_write_fd(2, ")\n")

        Let func be memory_get_pointer(functions, i multiplied by 8)

        file_write_fd(2, "[DEBUG] Got func=")
        file_write_fd(2, integer_to_string(func))
        file_write_fd(2, "\n")

        # Safety check for function pointer - skip invalid pointers
        If func is less than 65536:
            file_write_fd(2, "[ERROR] Invalid function pointer (too small): ")
            file_write_fd(2, integer_to_string(func))
            file_write_fd(2, "\n")
        Otherwise:
            If func is equal to 0:
                file_write_fd(2, "[ERROR] Function pointer is null\n")
            Otherwise:
                # Function structure in parser.runa has:
                # FUNCTION_STATEMENTS at 32 (Statement** - array of statements)
                # FUNCTION_STATEMENT_COUNT at 40

                file_write_fd(2, "[DEBUG] About to access statements_array at func+32\n")
                Let statements_array be memory_get_pointer(func, 32)  # func->statements (Statement**)
                file_write_fd(2, "[DEBUG] Got statements_array, about to access statement_count at func+40\n")
                Let statement_count be memory_get_integer(func, 40)  # func->statement_count
                file_write_fd(2, "[DEBUG] Got statement_count successfully\n")

                # Process each statement in the function
                file_write_fd(2, "[DEBUG] About to process statements, statements_array=")
                file_write_fd(2, integer_to_string(statements_array))
                file_write_fd(2, ", statement_count=")
                file_write_fd(2, integer_to_string(statement_count))
                file_write_fd(2, "\n")

                If statements_array is not equal to 0:
                    If statement_count is greater than 0:
                        # Process ALL statements in the function body
                        file_write_fd(2, "[DEBUG] Processing all ")
                        file_write_fd(2, integer_to_string(statement_count))
                        file_write_fd(2, " statements in function\n")

                        Let stmt_idx be 0
                        While stmt_idx is less than statement_count:
                            file_write_fd(2, "[DEBUG] Processing statement ")
                            file_write_fd(2, integer_to_string(stmt_idx))
                            file_write_fd(2, " of ")
                            file_write_fd(2, integer_to_string(statement_count))
                            file_write_fd(2, "\n")

                            # Get the statement at index stmt_idx
                            Let stmt_offset be stmt_idx multiplied by 8  # pointer size
                            Let body_statement be memory_get_pointer(statements_array, stmt_offset)

                            file_write_fd(2, "[DEBUG] Got body_statement=")
                            file_write_fd(2, integer_to_string(body_statement))
                            file_write_fd(2, "\n")

                            # Process the statement
                            Let result be 0
                            If body_statement is not equal to 0:
                                file_write_fd(2, "[DEBUG] About to call codegen_collect_strings_from_statement\n")
                                Set result to codegen_collect_strings_from_statement(codegen, body_statement)
                                file_write_fd(2, "[DEBUG] Returned from codegen_collect_strings_from_statement\n")

                                # Check if function reported critical error
                                If result is not equal to 0:
                                    file_write_fd(2, "[ERROR] Critical error in statement processing, terminating compilation\n")
                                    Return 0
                                End If
                                file_write_fd(2, "[DEBUG] After result check\n")
                            End If
                            file_write_fd(2, "[DEBUG] After body_statement if block\n")

                            # Move to next statement
                            Let stmt_idx be stmt_idx plus 1
                        End While
                        file_write_fd(2, "[DEBUG] Finished processing all statements\n")
                End If
                file_write_fd(2, "[DEBUG] After statement_count check\n")
            End If
            file_write_fd(2, "[DEBUG] After statements_array check\n")
        End If
        file_write_fd(2, "[DEBUG] After func check\n")
        End If  # End safety check
        file_write_fd(2, "[DEBUG] About to increment i\n")
        Let i be i plus 1
        file_write_fd(2, "[DEBUG] i incremented to ")
        file_write_fd(2, integer_to_string(i))
        file_write_fd(2, "\n")
        file_write_fd(2, "[DEBUG] About to check While condition again, i=")
        file_write_fd(2, integer_to_string(i))
        file_write_fd(2, ", function_count=")
        file_write_fd(2, integer_to_string(function_count))
        file_write_fd(2, "\n")
    End While
    file_write_fd(2, "[DEBUG] Exited While loop\n")

    # Generate .rodata section with string literals
    file_write_fd(2, "[DEBUG] About to read string_count from codegen+40\n")
    Let string_count be memory_get_integer(codegen, 40)  # codegen->string_count (int)
    file_write_fd(2, "[DEBUG] Got string_count=")
    file_write_fd(2, integer_to_string(string_count))
    file_write_fd(2, "\n")

    # Safety check - string_count should be reasonable (0-1000)
    If string_count is less than 0:
        file_write_fd(2, "[ERROR] Invalid negative string_count: ")
        file_write_fd(2, integer_to_string(string_count))
        file_write_fd(2, "\n")
        Let string_count be 0
    End If
    If string_count is greater than 1000:
        file_write_fd(2, "[ERROR] Suspiciously large string_count: ")
        file_write_fd(2, integer_to_string(string_count))
        file_write_fd(2, " - likely corruption, setting to 0\n")
        Let string_count be 0
    End If

    file_write_fd(2, "[DEBUG] Checking if string_count > 0\n")
    If string_count is greater than 0:
        file_write_fd(2, "[DEBUG] string_count > 0, writing .rodata section\n")
        emit_line(output_file, ".section .rodata")
        Let strings be memory_get_pointer(codegen, 32)  # codegen->strings (pointer with padding)
        Let i be 0
        While i is less than string_count:
            Let str_label be memory_get_pointer(strings, i multiplied by 16 plus 8)  # strings[i].label
            Let str_value be memory_get_pointer(strings, i multiplied by 16)  # strings[i].value
            # Format: .STR0:    .string "value"
            # FIXME: Quotes are currently omitted because Runa doesn't support escape sequences
            # The assembler accepts strings without quotes in some cases, though it's non-standard
            file_write_fd(output_file, str_label)
            file_write_fd(output_file, ":")
            file_write_fd(output_file, "    .string ")
            # Write a quote byte directly
            Let quote_bytes be memory_allocate(2)
            memory_set_byte(quote_bytes, 0, 34)  # ASCII for double quote
            memory_set_byte(quote_bytes, 1, 0)   # Null terminator
            file_write_fd(output_file, quote_bytes)
            file_write_fd(output_file, str_value)
            file_write_fd(output_file, quote_bytes)
            file_write_fd(output_file, "\n")
            deallocate(quote_bytes)
            Let i be i plus 1
        End While
        emit_line(output_file, "")  # Just a blank line for readability
    End If
    file_write_fd(2, "[DEBUG] After string generation section\n")

    # Generate .data section for initialized global variables
    file_write_fd(2, "[DEBUG] About to read global_count from program+56\n")
    Let global_count be memory_get_integer(program, 56)  # PROGRAM_GLOBAL_COUNT - use int32
    file_write_fd(2, "[DEBUG] Got global_count=")
    file_write_fd(2, integer_to_string(global_count))
    file_write_fd(2, "\n")
    file_write_fd(2, "[DEBUG] About to read globals pointer from program+48\n")
    Let globals be memory_get_pointer(program, 48)       # PROGRAM_GLOBAL_VARS - use pointer
    file_write_fd(2, "[DEBUG] Got globals=")
    file_write_fd(2, integer_to_string(globals))
    file_write_fd(2, "\n")
    Let has_initialized_globals be 0
    Let i be 0
    While i is less than global_count:
        Let global be memory_get_pointer(globals, i multiplied by 8)
        Let initial_value be memory_get_integer(global, 16)  # global->initial_value
        If initial_value is not equal to 0:
            Let has_initialized_globals be 1
            Let i be global_count  # Break
        End If
        Let i be i plus 1
    End While

    If has_initialized_globals is equal to 1:
        emit_line(output_file, ".section .data")
        Let i be 0
        While i is less than global_count:
            Let global be memory_get_pointer(globals, i multiplied by 8)
            Let global_name be memory_get_integer(global, 0)  # global->name
            Let initial_value be memory_get_integer(global, 16)  # global->initial_value
            If initial_value is not equal to 0:
                file_write_fd(output_file, ".globl ")
                file_write_fd(output_file, global_name)
                file_write_fd(output_file, "\n")
                file_write_fd(output_file, global_name)
                file_write_fd(output_file, ":")

                # Handle global variable initialization values
                Let expr_type be memory_get_integer(initial_value, 0)  # initial_value->type
                If expr_type is equal to 0:  # EXPR_INTEGER
                    Let integer_value be memory_get_integer(initial_value, 8)  # initial_value->data.integer_value
                    file_write_fd(output_file, "    .quad ")
                    file_write_fd(output_file, integer_to_string(integer_value))
                    file_write_fd(output_file, "\n")
                Otherwise:
                    # Non-constant expressions default to zero initialization
                    file_write_fd(output_file, "    .quad 0  # Non-constant initializer defaults to 0")
                End If
            End If
            Let i be i plus 1
        End While
        file_write_fd(output_file, "\n")
    End If

    # Generate .bss section for uninitialized global variables
    Let has_uninitialized_globals be 0
    Let i be 0
    While i is less than global_count:
        Let global be memory_get_pointer(globals, i multiplied by 8)
        Let initial_value be memory_get_integer(global, 16)  # global->initial_value
        If initial_value is equal to 0:
            Let has_uninitialized_globals be 1
            Let i be global_count  # Break
        End If
        Let i be i plus 1
    End While

    If has_uninitialized_globals is equal to 1:
        emit_line(output_file, ".section .bss")
        Let i be 0
        While i is less than global_count:
            Let global be memory_get_pointer(globals, i multiplied by 8)
            Let global_name be memory_get_integer(global, 0)  # global->name
            Let initial_value be memory_get_integer(global, 16)  # global->initial_value
            If initial_value is equal to 0:
                file_write_fd(output_file, ".globl ")
                file_write_fd(output_file, global_name)
                file_write_fd(output_file, "\n")
                file_write_fd(output_file, global_name)
                file_write_fd(output_file, ":")
                file_write_fd(output_file, "    .zero 8  # 8 bytes for Integer")
            End If
            Let i be i plus 1
        End While
        file_write_fd(output_file, "\n")
    End If
    file_write_fd(2, "[DEBUG] After .bss section\n")

    # Generate .text section
    file_write_fd(2, "[DEBUG] About to emit .text section\n")
    emit_line(output_file, ".text")
    file_write_fd(2, "[DEBUG] Emitted .text section\n")

    # Add print_string runtime function
    file_write_fd(2, "[DEBUG] About to emit print_string function\n")
    emit_line(output_file, "print_string:")
    file_write_fd(2, "[DEBUG] Emitted print_string label\n")
    emit_line(output_file, "    pushq %rbp")
    file_write_fd(2, "[DEBUG] Emitted pushq %rbp\n")
    emit_line(output_file, "    movq %rsp, %rbp")
    emit_line(output_file, "")
    emit_line(output_file, "    # Calculate string length")
    emit_line(output_file, "    movq %rdi, %rsi  # Save string pointer")
    emit_line(output_file, "    movq %rdi, %rcx  # Counter for strlen")
    emit_line(output_file, "    xorq %rax, %rax  # Length accumulator")
    emit_line(output_file, ".strlen_loop:")
    emit_line(output_file, "    cmpb $0, (%rcx)")
    emit_line(output_file, "    je .strlen_done")
    emit_line(output_file, "    incq %rcx")
    emit_line(output_file, "    incq %rax")
    emit_line(output_file, "    jmp .strlen_loop")
    emit_line(output_file, ".strlen_done:")
    emit_line(output_file, "")
    emit_line(output_file, "    # Call write syscall (sys_write = 1)")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    movq %rsi, %rsi   # buf = string pointer (already in rsi)")
    emit_line(output_file, "    movq %rax, %rdx   # count = string length")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    # Print newline")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    leaq .newline(%rip), %rsi  # newline string")
    emit_line(output_file, "    movq $1, %rdx     # count = 1")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    popq %rbp")
    emit_line(output_file, "    ret")
    emit_line(output_file, "\n")

    # Add print_integer runtime function
    emit_line(output_file, "print_integer:")
    emit_line(output_file, "    pushq %rbp")
    emit_line(output_file, "    movq %rsp, %rbp")
    emit_line(output_file, "    subq $32, %rsp  # Space for string buffer (20 digits + null)")
    emit_line(output_file, "")
    emit_line(output_file, "    # Convert integer to string")
    emit_line(output_file, "    movq %rdi, %rax  # integer value")
    emit_line(output_file, "    leaq -32(%rbp), %rsi  # buffer pointer")
    emit_line(output_file, "    addq $19, %rsi  # point to end of buffer (for reverse building)")
    emit_line(output_file, "    movb $0, (%rsi)  # null terminator")
    emit_line(output_file, "    decq %rsi")
    emit_line(output_file, "")
    emit_line(output_file, "    # Handle zero case")
    emit_line(output_file, "    testq %rax, %rax")
    emit_line(output_file, "    jnz .convert_loop")
    emit_line(output_file, "    movb $48, (%rsi)  # '0' character")
    emit_line(output_file, "    jmp .convert_done")
    emit_line(output_file, "")
    emit_line(output_file, ".convert_loop:")
    emit_line(output_file, "    testq %rax, %rax")
    emit_line(output_file, "    jz .convert_done")
    emit_line(output_file, "    movq %rax, %rcx")
    emit_line(output_file, "    movq $10, %rbx")
    emit_line(output_file, "    xorq %rdx, %rdx")
    emit_line(output_file, "    divq %rbx  # %rax = quotient, %rdx = remainder")
    emit_line(output_file, "    addq $48, %rdx  # convert remainder to ASCII")
    emit_line(output_file, "    movb %dl, (%rsi)  # store digit")
    emit_line(output_file, "    decq %rsi")
    emit_line(output_file, "    jmp .convert_loop")
    emit_line(output_file, "")
    emit_line(output_file, ".convert_done:")
    emit_line(output_file, "    incq %rsi  # point to first character")
    emit_line(output_file, "")
    emit_line(output_file, "    # Calculate string length")
    emit_line(output_file, "    movq %rsi, %rcx  # Counter for strlen")
    emit_line(output_file, "    xorq %rax, %rax  # Length accumulator")
    emit_line(output_file, ".int_strlen_loop:")
    emit_line(output_file, "    cmpb $0, (%rcx)")
    emit_line(output_file, "    je .int_strlen_done")
    emit_line(output_file, "    incq %rcx")
    emit_line(output_file, "    incq %rax")
    emit_line(output_file, "    jmp .int_strlen_loop")
    emit_line(output_file, ".int_strlen_done:")
    emit_line(output_file, "")
    emit_line(output_file, "    # Call write syscall (sys_write = 1)")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    # %rsi already points to string")
    emit_line(output_file, "    movq %rax, %rdx   # count = string length")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    # Print newline")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    leaq .newline(%rip), %rsi  # newline string")
    emit_line(output_file, "    movq $1, %rdx     # count = 1")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    movq %rbp, %rsp")
    emit_line(output_file, "    popq %rbp")
    emit_line(output_file, "    ret")
    emit_line(output_file, "\n")
    emit_line(output_file, ".section .rodata")
    emit_line(output_file, ".newline:")
    # Output newline string literal using ASCII byte value
    emit_line(output_file, "    .byte 10  # newline character")
    emit_line(output_file, ".text")
    file_write_fd(2, "[DEBUG] About to generate all functions\n")

    # Generate all functions
    Let i be 0
    file_write_fd(2, "[DEBUG] Starting function generation loop\n")
    While i is less than function_count:
        file_write_fd(2, "[DEBUG] Generating function ")
        file_write_fd(2, integer_to_string(i))
        file_write_fd(2, "\n")
        Let func be memory_get_pointer(functions, i multiplied by 8)

        # Safety check for function pointer - skip invalid pointers
        If func is greater than or equal to 65536:
        Let func_name be memory_get_pointer(func, 0)  # func->name

        # Make main function global
        If string_equals(func_name, "main") is equal to 1:
            emit_line(output_file, ".globl main")
        End If

        emit_line(output_file, "\n")
        codegen_generate_function(codegen, func)
        End If  # End safety check
        Let i be i plus 1
    End While

    # Add a main function wrapper if no main function exists
    Let has_main be 0
    Let i be 0
    While i is less than function_count:
        Let func be memory_get_pointer(functions, i multiplied by 8)

        # Safety check for function pointer - skip invalid pointers
        If func is greater than or equal to 65536:
        Let func_name be memory_get_pointer(func, 0)  # func->name
        If string_equals(func_name, "main") is equal to 1:
            Let has_main be 1
            Let i be function_count  # Break
        End If
        End If  # End safety check
        Let i be i plus 1
    End While

    # If no main function exists, generate one that calls the first Process
    If has_main is equal to 0:
        If function_count is greater than 0:
        file_write_fd(output_file, "\n")
        emit_line(output_file, ".globl main")
        emit_line(output_file, "main:")
        emit_line(output_file, "    # Call the first Process function")
        Let first_func be memory_get_pointer(functions, 0)
        Let first_func_name be memory_get_pointer(first_func, 0)  # functions[0]->name
        Let call_instruction be string_concat("    call ", first_func_name)
        emit_line(output_file, call_instruction)
        deallocate(call_instruction)
        file_write_fd(output_file, "\n")
        emit_line(output_file, "    # Exit with the return value")
        emit_line(output_file, "    movq %rax, %rdi")
        emit_line(output_file, "    movq $60, %rax")
        emit_line(output_file, "    syscall")
        End If  # End function_count > 0
    End If  # End has_main == 0

    # Add GNU stack note to prevent executable stack warning
    file_write_fd(output_file, "\n")
    # Output the GNU stack section
    emit_line(output_file, ".section .note.GNU-stack")
    Return 0
End Process