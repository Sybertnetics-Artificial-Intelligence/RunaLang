Import "parser.runa" as Parser

Type called "Variable":
    name as String
    stack_offset as Integer
    type_name as String
End Type

Type called "StringLiteral":
    value as String
    label as String
End Type

Type called "CodeGenerator":
    output_file as String
    variables as Variable
    variable_count as Integer
    variable_capacity as Integer
    stack_offset as Integer
    label_counter as Integer
    strings as StringLiteral
    string_count as Integer
    string_capacity as Integer
    current_program as Parser.Program
End Type

Process called "string_duplicate" takes str as String returns String:
    If str is equal to null:
        Return null
    End If
    Let len be strlen(str)
    Let dup be malloc(len plus 1)
    strcpy(dup, str)
    Return dup
End Process

Process called "codegen_find_variable" takes codegen as CodeGenerator, name as String returns Integer:
    Let i be 0
    While i is less than variable_count of codegen:
        If strcmp(name of variables of codegen[i], name) is equal to 0:
            Return i
        End If
        Set i to i plus 1
    End While
    Return -1
End Process

Process called "codegen_calculate_type_size" takes type_name as String, program as Parser.Program returns Integer:
    If strcmp(type_name, "Integer") is equal to 0:
        Return 8
    End If
    If strcmp(type_name, "Byte") is equal to 0:
        Return 1
    End If
    If strcmp(type_name, "Short") is equal to 0:
        Return 2
    End If
    If strcmp(type_name, "Long") is equal to 0:
        Return 8
    End If

    If program is not equal to null:
        Let i be 0
        While i is less than type_count of program:
            If strcmp(name of types of program[i], type_name) is equal to 0:
                Return size of types of program[i]
            End If
            Set i to i plus 1
        End While
    End If

    Return 8
End Process

Process called "codegen_add_variable" takes codegen as CodeGenerator, name as String returns Integer:
    Return codegen_add_variable_with_type(codegen, name, "Integer")
End Process

Process called "codegen_add_variable_with_type" takes codegen as CodeGenerator, name as String, type_name as String returns Integer:
    If variable_count of codegen is greater than or equal to variable_capacity of codegen:
        Set variable_capacity of codegen to variable_capacity of codegen multiplied by 2
        Set variables of codegen to realloc(variables of codegen, sizeof_Variable() multiplied by variable_capacity of codegen)
        If variables of codegen is equal to null:
            Print "[CODEGEN ERROR] Out of memory allocating variables"
            exit(1)
        End If
    End If

    Let size be codegen_calculate_type_size(type_name, current_program of codegen)
    Set stack_offset of codegen to stack_offset of codegen plus size
    Let var_index be variable_count of codegen
    Set name of variables of codegen[var_index] to string_duplicate(name)
    Set stack_offset of variables of codegen[var_index] to stack_offset of codegen
    Set type_name of variables of codegen[var_index] to string_duplicate(type_name)
    Set variable_count of codegen to variable_count of codegen plus 1

    Return var_index
End Process

Process called "codegen_add_string_literal" takes codegen as CodeGenerator, value as String returns Integer:
    If string_count of codegen is greater than or equal to string_capacity of codegen:
        Set string_capacity of codegen to string_capacity of codegen multiplied by 2
        Set strings of codegen to realloc(strings of codegen, sizeof_StringLiteral() multiplied by string_capacity of codegen)
        If strings of codegen is equal to null:
            Print "[CODEGEN ERROR] Out of memory allocating strings"
            exit(1)
        End If
    End If

    Let str_index be string_count of codegen
    Set value of strings of codegen[str_index] to string_duplicate(value)

    Let label_len be snprintf(null, 0, ".STR%d", str_index) plus 1
    Set label of strings of codegen[str_index] to malloc(label_len)
    snprintf(label of strings of codegen[str_index], label_len, ".STR%d", str_index)

    Set string_count of codegen to string_count of codegen plus 1
    Return str_index
End Process

Process called "codegen_collect_strings_from_expression" takes codegen as CodeGenerator, expr as Parser.Expression returns Integer:
    If expr is equal to null:
        Return 0
    End If

    If expr_type of expr is equal to Parser.EXPR_STRING_LITERAL:
        codegen_add_string_literal(codegen, string_literal of expr)
    Otherwise If expr_type of expr is equal to Parser.EXPR_BINARY_OP:
        codegen_collect_strings_from_expression(codegen, left of binary_op of expr)
        codegen_collect_strings_from_expression(codegen, right of binary_op of expr)
    Otherwise If expr_type of expr is equal to Parser.EXPR_COMPARISON:
        codegen_collect_strings_from_expression(codegen, left of comparison of expr)
        codegen_collect_strings_from_expression(codegen, right of comparison of expr)
    Otherwise If expr_type of expr is equal to Parser.EXPR_FUNCTION_CALL:
        Let i be 0
        While i is less than argument_count of function_call of expr:
            codegen_collect_strings_from_expression(codegen, arguments of function_call of expr[i])
            Set i to i plus 1
        End While
    Otherwise If expr_type of expr is equal to Parser.EXPR_FIELD_ACCESS:
        codegen_collect_strings_from_expression(codegen, object of field_access of expr)
    Otherwise If expr_type of expr is equal to Parser.EXPR_READ_FILE:
        codegen_collect_strings_from_expression(codegen, filename_expr of file_read of expr)
    Otherwise If expr_type of expr is equal to Parser.EXPR_WRITE_FILE:
        codegen_collect_strings_from_expression(codegen, filename_expr of file_write of expr)
        codegen_collect_strings_from_expression(codegen, content_expr of file_write of expr)
    End If

    Return 0
End Process

Process called "codegen_collect_strings_from_statement" takes codegen as CodeGenerator, stmt as Parser.Statement returns Integer:
    If stmt is equal to null:
        Return 0
    End If

    If stmt_type of stmt is equal to Parser.STMT_LET:
        codegen_collect_strings_from_expression(codegen, expression of let_stmt of stmt)
    Otherwise If stmt_type of stmt is equal to Parser.STMT_SET:
        codegen_collect_strings_from_expression(codegen, expression of set_stmt of stmt)
    Otherwise If stmt_type of stmt is equal to Parser.STMT_RETURN:
        codegen_collect_strings_from_expression(codegen, expression of return_stmt of stmt)
    Otherwise If stmt_type of stmt is equal to Parser.STMT_PRINT:
        codegen_collect_strings_from_expression(codegen, expression of print_stmt of stmt)
    Otherwise If stmt_type of stmt is equal to Parser.STMT_IF:
        codegen_collect_strings_from_expression(codegen, condition of if_stmt of stmt)
        Let i be 0
        While i is less than if_body_count of if_stmt of stmt:
            codegen_collect_strings_from_statement(codegen, if_body of if_stmt of stmt[i])
            Set i to i plus 1
        End While
        Set i to 0
        While i is less than else_body_count of if_stmt of stmt:
            codegen_collect_strings_from_statement(codegen, else_body of if_stmt of stmt[i])
            Set i to i plus 1
        End While
    Otherwise If stmt_type of stmt is equal to Parser.STMT_WHILE:
        codegen_collect_strings_from_expression(codegen, condition of while_stmt of stmt)
        Let i be 0
        While i is less than body_count of while_stmt of stmt:
            codegen_collect_strings_from_statement(codegen, body of while_stmt of stmt[i])
            Set i to i plus 1
        End While
    Otherwise If stmt_type of stmt is equal to Parser.STMT_EXPRESSION:
        codegen_collect_strings_from_expression(codegen, expression of expr_stmt of stmt)
    Otherwise If stmt_type of stmt is equal to Parser.STMT_IMPORT:
        Pass
    End If

    Return 0
End Process

Process called "codegen_generate_expression" takes codegen as CodeGenerator, expr as Parser.Expression returns Integer:
    If expr is equal to null:
        Return 0
    End If

    If expr_type of expr is equal to Parser.EXPR_INTEGER:
        fprintf(output_file of codegen, "    movq $%d, %%rax\n", integer_value of expr)
    Otherwise If expr_type of expr is equal to Parser.EXPR_VARIABLE:
        Let var_index be codegen_find_variable(codegen, variable_name of expr)
        If var_index is equal to -1:
            Print "[CODEGEN ERROR] Unknown variable '"
            Print variable_name of expr
            Print "'"
            exit(1)
        End If
        Let offset be stack_offset of variables of codegen[var_index]
        fprintf(output_file of codegen, "    movq -%d(%%rbp), %%rax\n", offset)
    Otherwise If expr_type of expr is equal to Parser.EXPR_BINARY_OP:
        codegen_generate_expression(codegen, left of binary_op of expr)
        fprintf(output_file of codegen, "    pushq %%rax\n")
        codegen_generate_expression(codegen, right of binary_op of expr)
        fprintf(output_file of codegen, "    popq %%rbx\n")

        If operator of binary_op of expr is equal to TOKEN_PLUS:
            fprintf(output_file of codegen, "    addq %%rbx, %%rax\n")
        Otherwise If operator of binary_op of expr is equal to TOKEN_MINUS:
            fprintf(output_file of codegen, "    subq %%rax, %%rbx\n")
            fprintf(output_file of codegen, "    movq %%rbx, %%rax\n")
        Otherwise If operator of binary_op of expr is equal to TOKEN_MULTIPLIED:
            fprintf(output_file of codegen, "    imulq %%rbx, %%rax\n")
        Otherwise If operator of binary_op of expr is equal to TOKEN_DIVIDED:
            fprintf(output_file of codegen, "    movq %%rax, %%rcx\n")
            fprintf(output_file of codegen, "    movq %%rbx, %%rax\n")

            fprintf(output_file of codegen, "    testq %%rcx, %%rcx\n")
            fprintf(output_file of codegen, "    jz .Ldiv_by_zero_%d\n", label_counter of codegen)

            fprintf(output_file of codegen, "    cqto\n")
            fprintf(output_file of codegen, "    idivq %%rcx\n")
            fprintf(output_file of codegen, "    jmp .Ldiv_done_%d\n", label_counter of codegen)

            fprintf(output_file of codegen, ".Ldiv_by_zero_%d:\n", label_counter of codegen)
            fprintf(output_file of codegen, "    movq $0, %%rax\n")
            fprintf(output_file of codegen, ".Ldiv_done_%d:\n", label_counter of codegen)
            Set label_counter of codegen to label_counter of codegen plus 1
        End If
    Otherwise If expr_type of expr is equal to Parser.EXPR_COMPARISON:
        codegen_generate_expression(codegen, left of comparison of expr)
        fprintf(output_file of codegen, "    pushq %%rax\n")
        codegen_generate_expression(codegen, right of comparison of expr)
        fprintf(output_file of codegen, "    popq %%rbx\n")

        fprintf(output_file of codegen, "    cmpq %%rax, %%rbx\n")
        If comparison_op of comparison of expr is equal to TOKEN_EQUAL:
            fprintf(output_file of codegen, "    sete %%al\n")
        Otherwise If comparison_op of comparison of expr is equal to TOKEN_LESS:
            fprintf(output_file of codegen, "    setl %%al\n")
        End If
        fprintf(output_file of codegen, "    movzbq %%al, %%rax\n")
    Otherwise If expr_type of expr is equal to Parser.EXPR_FUNCTION_CALL:
        Let func_name be function_name of function_call of expr
        Let is_list_function be 0
        If strcmp(func_name, "list_create") is equal to 0:
            Set is_list_function to 1
        Otherwise If strcmp(func_name, "list_append") is equal to 0:
            Set is_list_function to 1
        Otherwise If strcmp(func_name, "list_get") is equal to 0:
            Set is_list_function to 1
        Otherwise If strcmp(func_name, "list_get_integer") is equal to 0:
            Set is_list_function to 1
        Otherwise If strcmp(func_name, "list_length") is equal to 0:
            Set is_list_function to 1
        Otherwise If strcmp(func_name, "list_destroy") is equal to 0:
            Set is_list_function to 1
        End If

        Let arg_count be argument_count of function_call of expr
        Let max_register_args be 6
        Let register_arg_count be arg_count
        If arg_count is greater than max_register_args:
            Set register_arg_count to max_register_args
        End If

        Let i be register_arg_count minus 1
        While i is greater than or equal to 0:
            codegen_generate_expression(codegen, arguments of function_call of expr[i])
            fprintf(output_file of codegen, "    pushq %%rax\n")
            Set i to i minus 1
        End While

        Set i to 0
        While i is less than register_arg_count:
            If i is equal to 0:
                fprintf(output_file of codegen, "    popq %%rdi\n")
            Otherwise If i is equal to 1:
                fprintf(output_file of codegen, "    popq %%rsi\n")
            Otherwise If i is equal to 2:
                fprintf(output_file of codegen, "    popq %%rdx\n")
            Otherwise If i is equal to 3:
                fprintf(output_file of codegen, "    popq %%rcx\n")
            Otherwise If i is equal to 4:
                fprintf(output_file of codegen, "    popq %%r8\n")
            Otherwise If i is equal to 5:
                fprintf(output_file of codegen, "    popq %%r9\n")
            End If
            Set i to i plus 1
        End While

        If arg_count is greater than max_register_args:
            Print "[CODEGEN WARNING] Functions with more than 6 arguments not fully supported yet"
        End If

        If is_list_function is equal to 1:
            fprintf(output_file of codegen, "    call %s@PLT\n", func_name)
        Otherwise:
            fprintf(output_file of codegen, "    call %s\n", func_name)
        End If
    Otherwise If expr_type of expr is equal to Parser.EXPR_STRING_LITERAL:
        Let str_index be -1
        Let i be 0
        While i is less than string_count of codegen:
            If strcmp(value of strings of codegen[i], string_literal of expr) is equal to 0:
                Set str_index to i
                Break
            End If
            Set i to i plus 1
        End While
        If str_index is equal to -1:
            Set str_index to codegen_add_string_literal(codegen, string_literal of expr)
        End If

        fprintf(output_file of codegen, "    leaq %s(%%rip), %%rax\n", label of strings of codegen[str_index])
    Otherwise If expr_type of expr is equal to Parser.EXPR_FIELD_ACCESS:
        Let obj be object of field_access of expr

        If obj.expr_type is equal to Parser.EXPR_VARIABLE:
            Let var_index be codegen_find_variable(codegen, variable_name of obj)
            If var_index is equal to -1:
                Print "[CODEGEN ERROR] Unknown variable '"
                Print variable_name of obj
                Print "'"
                exit(1)
            End If

            Let offset be stack_offset of variables of codegen[var_index]
            fprintf(output_file of codegen, "    leaq -%d(%%rbp), %%rax\n", offset)

            Let type_name be type_name of variables of codegen[var_index]
            If type_name is equal to null:
                Print "[CODEGEN ERROR] Variable '"
                Print variable_name of obj
                Print "' has no type"
                exit(1)
            End If

            Let type be null
            Let i be 0
            While i is less than type_count of current_program of codegen:
                If strcmp(name of types of current_program of codegen[i], type_name) is equal to 0:
                    Set type to types of current_program of codegen[i]
                    Break
                End If
                Set i to i plus 1
            End While

            If type is equal to null:
                Print "[CODEGEN ERROR] Unknown type '"
                Print type_name
                Print "'"
                exit(1)
            End If

            Let field_offset be -1
            Set i to 0
            While i is less than field_count of type:
                If strcmp(name of fields of type[i], field_name of field_access of expr) is equal to 0:
                    Set field_offset to offset of fields of type[i]
                    Break
                End If
                Set i to i plus 1
            End While

            If field_offset is equal to -1:
                Print "[CODEGEN ERROR] Type '"
                Print type_name
                Print "' has no field '"
                Print field_name of field_access of expr
                Print "'"
                exit(1)
            End If

            fprintf(output_file of codegen, "    movq %d(%%rax), %%rax\n", field_offset)
        Otherwise:
            Print "[CODEGEN ERROR] Complex field access expressions not implemented"
            exit(1)
        End If
    Otherwise If expr_type of expr is equal to Parser.EXPR_TYPE_NAME:
        Print "[CODEGEN ERROR] Type names should only appear in LET statements"
        exit(1)
    Otherwise If expr_type of expr is equal to Parser.EXPR_READ_FILE:
        codegen_generate_expression(codegen, filename_expr of file_read of expr)
        fprintf(output_file of codegen, "    movq %%rax, %%rdi\n")
        fprintf(output_file of codegen, "    call read_file@PLT\n")
    Otherwise If expr_type of expr is equal to Parser.EXPR_WRITE_FILE:
        codegen_generate_expression(codegen, filename_expr of file_write of expr)
        fprintf(output_file of codegen, "    pushq %%rax\n")
        codegen_generate_expression(codegen, content_expr of file_write of expr)
        fprintf(output_file of codegen, "    movq %%rax, %%rsi\n")
        fprintf(output_file of codegen, "    popq %%rdi\n")
        fprintf(output_file of codegen, "    call write_file@PLT\n")
    End If

    Return 0
End Process

Process called "codegen_generate_statement" takes codegen as CodeGenerator, stmt as Parser.Statement returns Integer:
    If stmt is equal to null:
        Return 0
    End If

    If stmt_type of stmt is equal to Parser.STMT_LET:
        Let expr be expression of let_stmt of stmt
        If expr is not equal to null and expr_type of expr is equal to Parser.EXPR_TYPE_NAME:
            Let type be null
            Let i be 0
            While i is less than type_count of current_program of codegen:
                If strcmp(name of types of current_program of codegen[i], type_name of expr) is equal to 0:
                    Set type to types of current_program of codegen[i]
                    Break
                End If
                Set i to i plus 1
            End While

            If type is equal to null:
                Print "[CODEGEN ERROR] Unknown type '"
                Print type_name of expr
                Print "'"
                exit(1)
            End If

            codegen_add_variable_with_type(codegen, variable_name of let_stmt of stmt, type_name of expr)

            Let var_index be codegen_find_variable(codegen, variable_name of let_stmt of stmt)
            Let offset be stack_offset of variables of codegen[var_index]

            Let i be 0
            While i is less than size of type:
                fprintf(output_file of codegen, "    movq $0, -%d(%%rbp)\n", offset minus i)
                Set i to i plus 8
            End While
        Otherwise:
            codegen_add_variable(codegen, variable_name of let_stmt of stmt)

            codegen_generate_expression(codegen, expression of let_stmt of stmt)

            Let var_index be codegen_find_variable(codegen, variable_name of let_stmt of stmt)
            Let offset be stack_offset of variables of codegen[var_index]
            fprintf(output_file of codegen, "    movq %%rax, -%d(%%rbp)\n", offset)
        End If
    Otherwise If stmt_type of stmt is equal to Parser.STMT_SET:
        codegen_generate_expression(codegen, expression of set_stmt of stmt)

        Let var_index be codegen_find_variable(codegen, variable_name of set_stmt of stmt)
        If var_index is equal to -1:
            Print "[CODEGEN ERROR] Unknown variable '"
            Print variable_name of set_stmt of stmt
            Print "'"
            exit(1)
        End If
        Let offset be stack_offset of variables of codegen[var_index]

        If field_name of set_stmt of stmt is not equal to null:
            fprintf(output_file of codegen, "    pushq %%rax\n")
            fprintf(output_file of codegen, "    leaq -%d(%%rbp), %%rbx\n", offset)

            Let type_name be type_name of variables of codegen[var_index]
            If type_name is equal to null:
                Print "[CODEGEN ERROR] Variable '"
                Print variable_name of set_stmt of stmt
                Print "' has no type"
                exit(1)
            End If

            Let type be null
            Let i be 0
            While i is less than type_count of current_program of codegen:
                If strcmp(name of types of current_program of codegen[i], type_name) is equal to 0:
                    Set type to types of current_program of codegen[i]
                    Break
                End If
                Set i to i plus 1
            End While

            If type is equal to null:
                Print "[CODEGEN ERROR] Unknown type '"
                Print type_name
                Print "'"
                exit(1)
            End If

            Let field_offset be -1
            Set i to 0
            While i is less than field_count of type:
                If strcmp(name of fields of type[i], field_name of set_stmt of stmt) is equal to 0:
                    Set field_offset to offset of fields of type[i]
                    Break
                End If
                Set i to i plus 1
            End While

            If field_offset is equal to -1:
                Print "[CODEGEN ERROR] Type '"
                Print type_name
                Print "' has no field '"
                Print field_name of set_stmt of stmt
                Print "'"
                exit(1)
            End If

            fprintf(output_file of codegen, "    popq %%rax\n")
            fprintf(output_file of codegen, "    movq %%rax, %d(%%rbx)\n", field_offset)
        Otherwise:
            fprintf(output_file of codegen, "    movq %%rax, -%d(%%rbp)\n", offset)
        End If
    Otherwise If stmt_type of stmt is equal to Parser.STMT_RETURN:
        codegen_generate_expression(codegen, expression of return_stmt of stmt)
        fprintf(output_file of codegen, "    movq %%rbp, %%rsp\n")
        fprintf(output_file of codegen, "    popq %%rbp\n")
        fprintf(output_file of codegen, "    ret\n")
    Otherwise If stmt_type of stmt is equal to Parser.STMT_IF:
        Let label_num be label_counter of codegen
        Set label_counter of codegen to label_counter of codegen plus 1
        Let else_label be label_num multiplied by 10 plus 1
        Let end_label be label_num multiplied by 10 plus 2

        codegen_generate_expression(codegen, condition of if_stmt of stmt)
        fprintf(output_file of codegen, "    testq %%rax, %%rax\n")
        fprintf(output_file of codegen, "    jz .L%d\n", else_label)

        Let i be 0
        While i is less than if_body_count of if_stmt of stmt:
            codegen_generate_statement(codegen, if_body of if_stmt of stmt[i])
            Set i to i plus 1
        End While
        fprintf(output_file of codegen, "    jmp .L%d\n", end_label)

        fprintf(output_file of codegen, ".L%d:\n", else_label)
        Set i to 0
        While i is less than else_body_count of if_stmt of stmt:
            codegen_generate_statement(codegen, else_body of if_stmt of stmt[i])
            Set i to i plus 1
        End While

        fprintf(output_file of codegen, ".L%d:\n", end_label)
    Otherwise If stmt_type of stmt is equal to Parser.STMT_WHILE:
        Let label_num be label_counter of codegen
        Set label_counter of codegen to label_counter of codegen plus 1
        Let loop_start be label_num multiplied by 10 plus 1
        Let loop_end be label_num multiplied by 10 plus 2

        fprintf(output_file of codegen, ".L%d:\n", loop_start)

        codegen_generate_expression(codegen, condition of while_stmt of stmt)
        fprintf(output_file of codegen, "    testq %%rax, %%rax\n")
        fprintf(output_file of codegen, "    jz .L%d\n", loop_end)

        Let i be 0
        While i is less than body_count of while_stmt of stmt:
            codegen_generate_statement(codegen, body of while_stmt of stmt[i])
            Set i to i plus 1
        End While

        fprintf(output_file of codegen, "    jmp .L%d\n", loop_start)
        fprintf(output_file of codegen, ".L%d:\n", loop_end)
    Otherwise If stmt_type of stmt is equal to Parser.STMT_PRINT:
        codegen_generate_expression(codegen, expression of print_stmt of stmt)

        Let expr be expression of print_stmt of stmt
        If expr_type of expr is equal to Parser.EXPR_STRING_LITERAL:
            fprintf(output_file of codegen, "    movq %%rax, %%rdi\n")
            fprintf(output_file of codegen, "    call print_string\n")
        Otherwise:
            fprintf(output_file of codegen, "    movq %%rax, %%rdi\n")
            fprintf(output_file of codegen, "    call print_integer\n")
        End If
    Otherwise If stmt_type of stmt is equal to Parser.STMT_EXPRESSION:
        codegen_generate_expression(codegen, expression of expr_stmt of stmt)
    Otherwise If stmt_type of stmt is equal to Parser.STMT_IMPORT:
        fprintf(output_file of codegen, "    # Import statement: module_path='%s' module_name='%s'\n", module_path of import_stmt of stmt, module_name of import_stmt of stmt)
    End If

    Return 0
End Process

Process called "codegen_create" takes output_filename as String returns CodeGenerator:
    Let codegen be malloc(sizeof_CodeGenerator())
    Set output_file of codegen to fopen(output_filename, "w")
    Set variable_count of codegen to 0
    Set variable_capacity of codegen to 16
    Set variables of codegen to malloc(sizeof_Variable() multiplied by variable_capacity of codegen)
    Set stack_offset of codegen to 0
    Set label_counter of codegen to 0
    Set string_count of codegen to 0
    Set string_capacity of codegen to 32
    Set strings of codegen to malloc(sizeof_StringLiteral() multiplied by string_capacity of codegen)
    Set current_program of codegen to null

    If output_file of codegen is equal to null:
        Print "[CODEGEN ERROR] Could not open output file '"
        Print output_filename
        Print "'"
        free(variables of codegen)
        free(strings of codegen)
        free(codegen)
        Return null
    End If

    Return codegen
End Process

Process called "codegen_destroy" takes codegen as CodeGenerator returns Integer:
    If codegen is not equal to null:
        If output_file of codegen is not equal to null:
            fclose(output_file of codegen)
        End If
        Let i be 0
        While i is less than variable_count of codegen:
            free(name of variables of codegen[i])
            free(type_name of variables of codegen[i])
            Set i to i plus 1
        End While
        Set i to 0
        While i is less than string_count of codegen:
            free(value of strings of codegen[i])
            free(label of strings of codegen[i])
            Set i to i plus 1
        End While
        free(variables of codegen)
        free(strings of codegen)
        free(codegen)
    End If
    Return 0
End Process

Process called "codegen_generate_function" takes codegen as CodeGenerator, func as Parser.Function returns Integer:
    Let i be 0
    While i is less than variable_count of codegen:
        free(name of variables of codegen[i])
        free(type_name of variables of codegen[i])
        Set i to i plus 1
    End While

    Set variable_count of codegen to 0
    Set stack_offset of codegen to 0

    fprintf(output_file of codegen, "%s:\n", name of func)

    fprintf(output_file of codegen, "    pushq %%rbp\n")
    fprintf(output_file of codegen, "    movq %%rsp, %%rbp\n")

    Let max_register_params be 6

    Set i to 0
    While i is less than parameter_count of func and i is less than max_register_params:
        Let param_index be codegen_add_variable(codegen, name of parameters of func[i])
        Let param_offset be stack_offset of variables of codegen[param_index]
        If i is equal to 0:
            fprintf(output_file of codegen, "    movq %%rdi, -%d(%%rbp)\n", param_offset)
        Otherwise If i is equal to 1:
            fprintf(output_file of codegen, "    movq %%rsi, -%d(%%rbp)\n", param_offset)
        Otherwise If i is equal to 2:
            fprintf(output_file of codegen, "    movq %%rdx, -%d(%%rbp)\n", param_offset)
        Otherwise If i is equal to 3:
            fprintf(output_file of codegen, "    movq %%rcx, -%d(%%rbp)\n", param_offset)
        Otherwise If i is equal to 4:
            fprintf(output_file of codegen, "    movq %%r8, -%d(%%rbp)\n", param_offset)
        Otherwise If i is equal to 5:
            fprintf(output_file of codegen, "    movq %%r9, -%d(%%rbp)\n", param_offset)
        End If
        Set i to i plus 1
    End While

    If parameter_count of func is greater than max_register_params:
        Print "[CODEGEN WARNING] Functions with more than 6 parameters not fully supported yet"
    End If

    Let stack_reservation_pos be ftell(output_file of codegen)
    fprintf(output_file of codegen, "    subq $%d, %%rsp           \n", 0)

    Set i to 0
    While i is less than statement_count of func:
        codegen_generate_statement(codegen, statements of func[i])
        Set i to i plus 1
    End While

    Let current_pos be ftell(output_file of codegen)
    fseek(output_file of codegen, stack_reservation_pos, SEEK_SET)
    If stack_offset of codegen is greater than 0:
        fprintf(output_file of codegen, "    subq $%d, %%rsp\n", (stack_offset of codegen plus 15) bitwise_and complement 15)
    End If
    fseek(output_file of codegen, current_pos, SEEK_SET)

    Return 0
End Process

Process called "codegen_generate" takes codegen as CodeGenerator, program as Parser.Program returns Integer:
    Set current_program of codegen to program

    Let i be 0
    While i is less than function_count of program:
        Let func be functions of program[i]
        Let j be 0
        While j is less than statement_count of func:
            codegen_collect_strings_from_statement(codegen, statements of func[j])
            Set j to j plus 1
        End While
        Set i to i plus 1
    End While

    If string_count of codegen is greater than 0:
        fprintf(output_file of codegen, ".section .rodata\n")
        Set i to 0
        While i is less than string_count of codegen:
            fprintf(output_file of codegen, "%s:\n", label of strings of codegen[i])
            fprintf(output_file of codegen, "    .string \"%s\"\n", value of strings of codegen[i])
            Set i to i plus 1
        End While
        fprintf(output_file of codegen, "\n")
    End If

    fprintf(output_file of codegen, ".text\n")

    fprintf(output_file of codegen, "print_string:\n")
    fprintf(output_file of codegen, "    pushq %%rbp\n")
    fprintf(output_file of codegen, "    movq %%rsp, %%rbp\n")
    fprintf(output_file of codegen, "    \n")
    fprintf(output_file of codegen, "    # Calculate string length\n")
    fprintf(output_file of codegen, "    movq %%rdi, %%rsi  # Save string pointer\n")
    fprintf(output_file of codegen, "    movq %%rdi, %%rcx  # Counter for strlen\n")
    fprintf(output_file of codegen, "    xorq %%rax, %%rax  # Length accumulator\n")
    fprintf(output_file of codegen, ".strlen_loop:\n")
    fprintf(output_file of codegen, "    cmpb $0, (%%rcx)\n")
    fprintf(output_file of codegen, "    je .strlen_done\n")
    fprintf(output_file of codegen, "    incq %%rcx\n")
    fprintf(output_file of codegen, "    incq %%rax\n")
    fprintf(output_file of codegen, "    jmp .strlen_loop\n")
    fprintf(output_file of codegen, ".strlen_done:\n")
    fprintf(output_file of codegen, "    \n")
    fprintf(output_file of codegen, "    # Call write syscall (sys_write = 1)\n")
    fprintf(output_file of codegen, "    movq $1, %%rdi     # fd = stdout\n")
    fprintf(output_file of codegen, "    movq %%rsi, %%rsi   # buf = string pointer (already in rsi)\n")
    fprintf(output_file of codegen, "    movq %%rax, %%rdx   # count = string length\n")
    fprintf(output_file of codegen, "    movq $1, %%rax     # syscall number for write\n")
    fprintf(output_file of codegen, "    syscall\n")
    fprintf(output_file of codegen, "    \n")
    fprintf(output_file of codegen, "    # Print newline\n")
    fprintf(output_file of codegen, "    movq $1, %%rdi     # fd = stdout\n")
    fprintf(output_file of codegen, "    leaq .newline(%%rip), %%rsi  # newline string\n")
    fprintf(output_file of codegen, "    movq $1, %%rdx     # count = 1\n")
    fprintf(output_file of codegen, "    movq $1, %%rax     # syscall number for write\n")
    fprintf(output_file of codegen, "    syscall\n")
    fprintf(output_file of codegen, "    \n")
    fprintf(output_file of codegen, "    popq %%rbp\n")
    fprintf(output_file of codegen, "    ret\n")
    fprintf(output_file of codegen, "\n")

    fprintf(output_file of codegen, "print_integer:\n")
    fprintf(output_file of codegen, "    pushq %%rbp\n")
    fprintf(output_file of codegen, "    movq %%rsp, %%rbp\n")
    fprintf(output_file of codegen, "    subq $32, %%rsp  # Space for string buffer (20 digits + null)\n")
    fprintf(output_file of codegen, "    \n")
    fprintf(output_file of codegen, "    # Convert integer to string\n")
    fprintf(output_file of codegen, "    movq %%rdi, %%rax  # integer value\n")
    fprintf(output_file of codegen, "    leaq -32(%%rbp), %%rsi  # buffer pointer\n")
    fprintf(output_file of codegen, "    addq $19, %%rsi  # point to end of buffer (for reverse building)\n")
    fprintf(output_file of codegen, "    movb $0, (%%rsi)  # null terminator\n")
    fprintf(output_file of codegen, "    decq %%rsi\n")
    fprintf(output_file of codegen, "    \n")
    fprintf(output_file of codegen, "    # Handle zero case\n")
    fprintf(output_file of codegen, "    testq %%rax, %%rax\n")
    fprintf(output_file of codegen, "    jnz .convert_loop\n")
    fprintf(output_file of codegen, "    movb $48, (%%rsi)  # '0' character\n")
    fprintf(output_file of codegen, "    jmp .convert_done\n")
    fprintf(output_file of codegen, "    \n")
    fprintf(output_file of codegen, ".convert_loop:\n")
    fprintf(output_file of codegen, "    testq %%rax, %%rax\n")
    fprintf(output_file of codegen, "    jz .convert_done\n")
    fprintf(output_file of codegen, "    movq %%rax, %%rcx\n")
    fprintf(output_file of codegen, "    movq $10, %%rbx\n")
    fprintf(output_file of codegen, "    xorq %%rdx, %%rdx\n")
    fprintf(output_file of codegen, "    divq %%rbx  # %%rax = quotient, %%rdx = remainder\n")
    fprintf(output_file of codegen, "    addq $48, %%rdx  # convert remainder to ASCII\n")
    fprintf(output_file of codegen, "    movb %%dl, (%%rsi)  # store digit\n")
    fprintf(output_file of codegen, "    decq %%rsi\n")
    fprintf(output_file of codegen, "    jmp .convert_loop\n")
    fprintf(output_file of codegen, "    \n")
    fprintf(output_file of codegen, ".convert_done:\n")
    fprintf(output_file of codegen, "    incq %%rsi  # point to first character\n")
    fprintf(output_file of codegen, "    \n")
    fprintf(output_file of codegen, "    # Calculate string length\n")
    fprintf(output_file of codegen, "    movq %%rsi, %%rcx  # Counter for strlen\n")
    fprintf(output_file of codegen, "    xorq %%rax, %%rax  # Length accumulator\n")
    fprintf(output_file of codegen, ".int_strlen_loop:\n")
    fprintf(output_file of codegen, "    cmpb $0, (%%rcx)\n")
    fprintf(output_file of codegen, "    je .int_strlen_done\n")
    fprintf(output_file of codegen, "    incq %%rcx\n")
    fprintf(output_file of codegen, "    incq %%rax\n")
    fprintf(output_file of codegen, "    jmp .int_strlen_loop\n")
    fprintf(output_file of codegen, ".int_strlen_done:\n")
    fprintf(output_file of codegen, "    \n")
    fprintf(output_file of codegen, "    # Call write syscall (sys_write = 1)\n")
    fprintf(output_file of codegen, "    movq $1, %%rdi     # fd = stdout\n")
    fprintf(output_file of codegen, "    # %%rsi already points to string\n")
    fprintf(output_file of codegen, "    movq %%rax, %%rdx   # count = string length\n")
    fprintf(output_file of codegen, "    movq $1, %%rax     # syscall number for write\n")
    fprintf(output_file of codegen, "    syscall\n")
    fprintf(output_file of codegen, "    \n")
    fprintf(output_file of codegen, "    # Print newline\n")
    fprintf(output_file of codegen, "    movq $1, %%rdi     # fd = stdout\n")
    fprintf(output_file of codegen, "    leaq .newline(%%rip), %%rsi  # newline string\n")
    fprintf(output_file of codegen, "    movq $1, %%rdx     # count = 1\n")
    fprintf(output_file of codegen, "    movq $1, %%rax     # syscall number for write\n")
    fprintf(output_file of codegen, "    syscall\n")
    fprintf(output_file of codegen, "    \n")
    fprintf(output_file of codegen, "    movq %%rbp, %%rsp\n")
    fprintf(output_file of codegen, "    popq %%rbp\n")
    fprintf(output_file of codegen, "    ret\n")
    fprintf(output_file of codegen, "\n")
    fprintf(output_file of codegen, ".section .rodata\n")
    fprintf(output_file of codegen, ".newline:\n")
    fprintf(output_file of codegen, "    .string \"\\n\"\n")
    fprintf(output_file of codegen, "\n")
    fprintf(output_file of codegen, ".text\n")

    Set i to 0
    While i is less than function_count of program:
        Let func be functions of program[i]

        If strcmp(name of func, "main") is equal to 0:
            fprintf(output_file of codegen, ".globl main\n")
        End If

        fprintf(output_file of codegen, "\n")
        codegen_generate_function(codegen, func)
        Set i to i plus 1
    End While

    fprintf(output_file of codegen, "\n.section .note.GNU-stack,\"\",@progbits\n")

    Return 0
End Process