# Code Generator for x86-64 Assembly
# Transliterated from codegen_x86.c (v0.0.7.3)
# Generates x86-64 assembly from parsed AST

# Forward declarations for loop context management
# These will be implemented later in the file

# String duplication helper - equivalent to C string_duplicate
Process called "string_duplicate" takes str as Integer returns Integer:
    If str is equal to 0:
        Return 0
    End If
    Let len be string_length(str)
    Let dup be allocate(len plus 1)
    Let i be 0
    While i is less than len:
        Let char_val be memory_get_byte(str plus i, 0)
        memory_set_byte(dup plus i, 0, char_val)
        Let i be i plus 1
    End While
    memory_set_byte(dup plus len, 0, 0)  # null terminator
    Return dup
End Process

# Find variable in current scope - equivalent to codegen_find_variable
Process called "codegen_find_variable" takes codegen as Integer, name as Integer returns Integer:
    Let variable_count be memory_get_integer(codegen, 16)  # codegen->variable_count
    Let variables be memory_get_integer(codegen, 8)        # codegen->variables
    Let i be 0
    While i is less than variable_count:
        Let var_ptr be variables plus i multiplied by 32  # sizeof(Variable) = 32
        Let var_name be memory_get_integer(var_ptr, 0)
        If string_equals(var_name, name) is equal to 1:
            Return i
        End If
        Let i be i plus 1
    End While
    Return 0 minus 1  # -1 for not found
End Process

# Calculate size of a type in bytes - equivalent to codegen_calculate_type_size
Process called "codegen_calculate_type_size" takes type_name as Integer, program as Integer returns Integer:
    # Built-in types
    If string_equals(type_name, "Integer") is equal to 1:
        Return 8  # 64-bit integer
    End If
    If string_equals(type_name, "Byte") is equal to 1:
        Return 1  # 8-bit byte
    End If
    If string_equals(type_name, "Short") is equal to 1:
        Return 2  # 16-bit short
    End If
    If string_equals(type_name, "Long") is equal to 1:
        Return 8  # 64-bit long
    End If

    # Custom types - look up in the program
    If program is not equal to 0:
        Let type_count be memory_get_integer(program, 32)  # program->type_count
        Let types be memory_get_integer(program, 24)       # program->types
        Let i be 0
        While i is less than type_count:
            Let type_ptr be memory_get_integer(types plus i multiplied by 8, 0)
            Let type_name_ptr be memory_get_integer(type_ptr, 0)  # type->name
            If string_equals(type_name_ptr, type_name) is equal to 1:
                Let type_size be memory_get_integer(type_ptr, 16)  # type->size
                Return type_size
            End If
            Let i be i plus 1
        End While
    End If

    # Unknown type - default to 8 bytes
    Return 8
End Process

# Add variable with type and parameter flag - equivalent to codegen_add_variable_with_type_and_param_flag
Process called "codegen_add_variable_with_type_and_param_flag" takes codegen as Integer, name as Integer, type_name as Integer, is_parameter as Integer returns Integer:
    # Get current counts and capacity
    Let variable_count be memory_get_integer(codegen, 16)      # codegen->variable_count
    Let variable_capacity be memory_get_integer(codegen, 24)   # codegen->variable_capacity
    Let variables be memory_get_integer(codegen, 8)            # codegen->variables

    # Grow array if needed
    If variable_count is greater than or equal to variable_capacity:
        Let new_capacity be variable_capacity multiplied by 2
        Let new_size be new_capacity multiplied by 32  # sizeof(Variable)
        Let new_variables be allocate(new_size)

        # Copy existing variables
        Let i be 0
        While i is less than variable_count:
            Let old_var be variables plus i multiplied by 32
            Let new_var be new_variables plus i multiplied by 32
            # Copy Variable struct (32 bytes)
            Let j be 0
            While j is less than 32:
                Let byte_val be memory_get_byte(old_var plus j, 0)
                memory_set_byte(new_var plus j, 0, byte_val)
                Let j be j plus 1
            End While
            Let i be i plus 1
        End While

        # Free old array and update
        deallocate(variables)
        memory_set_integer(codegen, 8, new_variables)      # codegen->variables
        memory_set_integer(codegen, 24, new_capacity)      # codegen->variable_capacity
        Let variables be new_variables
    End If

    # Calculate size based on type
    Let current_program be memory_get_integer(codegen, 40)  # codegen->current_program
    Let size be codegen_calculate_type_size(type_name, current_program)
    If type_name is equal to 0:
        Let size be codegen_calculate_type_size("Integer", current_program)
    End If

    # Update stack offset
    Let stack_offset be memory_get_integer(codegen, 32)  # codegen->stack_offset
    Let new_stack_offset be stack_offset plus size
    memory_set_integer(codegen, 32, new_stack_offset)

    # Get variable index
    Let var_index be variable_count
    Let var_ptr be variables plus var_index multiplied by 32

    # Set variable fields
    memory_set_integer(var_ptr, 0, string_duplicate(name))       # name
    memory_set_integer(var_ptr, 8, new_stack_offset)            # stack_offset
    memory_set_integer(var_ptr, 16, string_duplicate(type_name)) # type_name
    memory_set_integer(var_ptr, 24, is_parameter)               # is_parameter

    # Increment count
    memory_set_integer(codegen, 16, variable_count plus 1)

    Return var_index
End Process

# Add variable with type - equivalent to codegen_add_variable_with_type
Process called "codegen_add_variable_with_type" takes codegen as Integer, name as Integer, type_name as Integer returns Integer:
    Return codegen_add_variable_with_type_and_param_flag(codegen, name, type_name, 0)
End Process

# Add variable with default Integer type - equivalent to codegen_add_variable
Process called "codegen_add_variable" takes codegen as Integer, name as Integer returns Integer:
    Return codegen_add_variable_with_type(codegen, name, "Integer")
End Process

# Add string literal - equivalent to codegen_add_string_literal
Process called "codegen_add_string_literal" takes codegen as Integer, value as Integer returns Integer:
    # Get current counts and capacity
    Let string_count be memory_get_integer(codegen, 48)      # codegen->string_count
    Let string_capacity be memory_get_integer(codegen, 56)   # codegen->string_capacity
    Let strings be memory_get_integer(codegen, 64)           # codegen->strings

    # Grow array if needed
    If string_count is greater than or equal to string_capacity:
        Let new_capacity be string_capacity multiplied by 2
        Let new_size be new_capacity multiplied by 16  # sizeof(StringLiteral)
        Let new_strings be allocate(new_size)

        # Copy existing strings
        Let i be 0
        While i is less than string_count:
            Let old_str be strings plus i multiplied by 16
            Let new_str be new_strings plus i multiplied by 16
            # Copy StringLiteral struct (16 bytes)
            Let j be 0
            While j is less than 16:
                Let byte_val be memory_get_byte(old_str plus j, 0)
                memory_set_byte(new_str plus j, 0, byte_val)
                Let j be j plus 1
            End While
            Let i be i plus 1
        End While

        # Free old array and update
        deallocate(strings)
        memory_set_integer(codegen, 64, new_strings)      # codegen->strings
        memory_set_integer(codegen, 56, new_capacity)     # codegen->string_capacity
        Let strings be new_strings
    End If

    Let str_index be string_count
    Let str_ptr be strings plus str_index multiplied by 16

    # Set string value
    memory_set_integer(str_ptr, 0, string_duplicate(value))  # value

    # Generate unique label for this string
    Let label be string_concat(".STR", integer_to_string(str_index))
    memory_set_integer(str_ptr, 8, label)  # label

    # Increment count
    memory_set_integer(codegen, 48, string_count plus 1)

    Return str_index
End Process

# Collect strings from expression - equivalent to codegen_collect_strings_from_expression
Process called "codegen_collect_strings_from_expression" takes codegen as Integer, expr as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If

    Let expr_type be memory_get_integer(expr, 0)  # expr->type

    If expr_type is equal to 7:  # EXPR_STRING_LITERAL
        # Check if string already exists
        Let string_count be memory_get_integer(codegen, 48)
        Let strings be memory_get_integer(codegen, 64)
        Let string_literal be memory_get_integer(expr, 8)  # expr->data.string_literal

        Let i be 0
        While i is less than string_count:
            Let str_ptr be strings plus i multiplied by 16
            Let existing_value be memory_get_integer(str_ptr, 0)
            If string_equals(existing_value, string_literal) is equal to 1:
                Return 0  # Already added
            End If
            Let i be i plus 1
        End While

        codegen_add_string_literal(codegen, string_literal)
        Return 0
    End If

    If expr_type is equal to 3:  # EXPR_BINARY_OP
        Let binary_op_ptr be expr plus 8  # &expr->data.binary_op
        Let left be memory_get_integer(binary_op_ptr, 8)   # binary_op.left
        Let right be memory_get_integer(binary_op_ptr, 16) # binary_op.right
        codegen_collect_strings_from_expression(codegen, left)
        codegen_collect_strings_from_expression(codegen, right)
        Return 0
    End If

    If expr_type is equal to 4:  # EXPR_COMPARISON
        Let comparison_ptr be expr plus 8  # &expr->data.comparison
        Let left be memory_get_integer(comparison_ptr, 8)   # comparison.left
        Let right be memory_get_integer(comparison_ptr, 16) # comparison.right
        codegen_collect_strings_from_expression(codegen, left)
        codegen_collect_strings_from_expression(codegen, right)
        Return 0
    End If

    If expr_type is equal to 5:  # EXPR_FUNCTION_CALL
        Let func_call_ptr be expr plus 8  # &expr->data.function_call
        Let argument_count be memory_get_integer(func_call_ptr, 8)  # function_call.argument_count
        Let arguments be memory_get_integer(func_call_ptr, 16)      # function_call.arguments

        Let i be 0
        While i is less than argument_count:
            Let arg_ptr be memory_get_integer(arguments plus i multiplied by 8, 0)
            codegen_collect_strings_from_expression(codegen, arg_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 10:  # EXPR_FIELD_ACCESS
        Let field_access_ptr be expr plus 8  # &expr->data.field_access
        Let object be memory_get_integer(field_access_ptr, 0)  # field_access.object
        codegen_collect_strings_from_expression(codegen, object)
        Return 0
    End If

    If expr_type is equal to 11:  # EXPR_BUILTIN_CALL
        Let builtin_call_ptr be expr plus 8  # &expr->data.builtin_call
        Let argument_count be memory_get_integer(builtin_call_ptr, 8)  # builtin_call.argument_count
        Let arguments be memory_get_integer(builtin_call_ptr, 16)      # builtin_call.arguments

        Let i be 0
        While i is less than argument_count:
            Let arg_ptr be memory_get_integer(arguments plus i multiplied by 8, 0)
            codegen_collect_strings_from_expression(codegen, arg_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 12:  # EXPR_VARIANT_CONSTRUCTOR
        Let variant_constructor_ptr be expr plus 8  # &expr->data.variant_constructor
        Let field_count be memory_get_integer(variant_constructor_ptr, 16)  # variant_constructor.field_count
        Let field_values be memory_get_integer(variant_constructor_ptr, 24) # variant_constructor.field_values

        Let i be 0
        While i is less than field_count:
            Let field_value_ptr be memory_get_integer(field_values plus i multiplied by 8, 0)
            codegen_collect_strings_from_expression(codegen, field_value_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 16:  # EXPR_ARRAY_INDEX
        Let array_index_ptr be expr plus 8  # &expr->data.array_index
        Let arr be memory_get_integer(array_index_ptr, 0)  # array_index.array
        Let index be memory_get_integer(array_index_ptr, 8)  # array_index.index
        codegen_collect_strings_from_expression(codegen, arr)
        codegen_collect_strings_from_expression(codegen, index)
        Return 0
    End If

    # Other expression types (INTEGER, VARIABLE, TYPE_NAME, FUNCTION_POINTER) have no strings to collect
    Return 0
End Process

# Collect strings from statement - equivalent to codegen_collect_strings_from_statement
Process called "codegen_collect_strings_from_statement" takes codegen as Integer, stmt as Integer returns Integer:
    If stmt is equal to 0:
        Return 0
    End If

    Let stmt_type be memory_get_integer(stmt, 0)  # stmt->type

    If stmt_type is equal to 1:  # STMT_LET
        Let let_stmt_ptr be stmt plus 8  # &stmt->data.let_stmt
        Let expression be memory_get_integer(let_stmt_ptr, 8)  # let_stmt.expression
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 2:  # STMT_SET
        Let set_stmt_ptr be stmt plus 8  # &stmt->data.set_stmt
        Let target be memory_get_integer(set_stmt_ptr, 0)      # set_stmt.target
        Let expression be memory_get_integer(set_stmt_ptr, 8)  # set_stmt.expression
        codegen_collect_strings_from_expression(codegen, target)
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 3:  # STMT_RETURN
        Let return_stmt_ptr be stmt plus 8  # &stmt->data.return_stmt
        Let expression be memory_get_integer(return_stmt_ptr, 0)  # return_stmt.expression
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 4:  # STMT_PRINT
        Let print_stmt_ptr be stmt plus 8  # &stmt->data.print_stmt
        Let expression be memory_get_integer(print_stmt_ptr, 0)  # print_stmt.expression
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 5:  # STMT_IF
        Let if_stmt_ptr be stmt plus 8  # &stmt->data.if_stmt
        Let condition be memory_get_integer(if_stmt_ptr, 0)        # if_stmt.condition
        Let if_body_count be memory_get_integer(if_stmt_ptr, 8)    # if_stmt.if_body_count
        Let if_body be memory_get_integer(if_stmt_ptr, 16)         # if_stmt.if_body
        Let else_body_count be memory_get_integer(if_stmt_ptr, 24) # if_stmt.else_body_count
        Let else_body be memory_get_integer(if_stmt_ptr, 32)       # if_stmt.else_body

        codegen_collect_strings_from_expression(codegen, condition)

        # Process if body
        Let i be 0
        While i is less than if_body_count:
            Let stmt_ptr be memory_get_integer(if_body plus i multiplied by 8, 0)
            codegen_collect_strings_from_statement(codegen, stmt_ptr)
            Let i be i plus 1
        End While

        # Process else body
        Let i be 0
        While i is less than else_body_count:
            Let stmt_ptr be memory_get_integer(else_body plus i multiplied by 8, 0)
            codegen_collect_strings_from_statement(codegen, stmt_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 6:  # STMT_WHILE
        Let while_stmt_ptr be stmt plus 8  # &stmt->data.while_stmt
        Let condition be memory_get_integer(while_stmt_ptr, 0)   # while_stmt.condition
        Let body_count be memory_get_integer(while_stmt_ptr, 8)  # while_stmt.body_count
        Let body be memory_get_integer(while_stmt_ptr, 16)       # while_stmt.body

        codegen_collect_strings_from_expression(codegen, condition)

        # Process body
        Let i be 0
        While i is less than body_count:
            Let stmt_ptr be memory_get_integer(body plus i multiplied by 8, 0)
            codegen_collect_strings_from_statement(codegen, stmt_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 7:  # STMT_EXPRESSION
        Let expr_stmt_ptr be stmt plus 8  # &stmt->data.expr_stmt
        Let expression be memory_get_integer(expr_stmt_ptr, 0)  # expr_stmt.expression
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 14:  # STMT_MATCH
        Let match_stmt_ptr be stmt plus 8  # &stmt->data.match_stmt
        Let expression be memory_get_integer(match_stmt_ptr, 0)   # match_stmt.expression
        Let case_count be memory_get_integer(match_stmt_ptr, 8)   # match_stmt.case_count
        Let cases be memory_get_integer(match_stmt_ptr, 16)       # match_stmt.cases

        codegen_collect_strings_from_expression(codegen, expression)

        # Process each match case
        Let i be 0
        While i is less than case_count:
            Let match_case_ptr be cases plus i multiplied by 32  # sizeof(MatchCase)
            Let body_count be memory_get_integer(match_case_ptr, 16)  # match_case.body_count
            Let body be memory_get_integer(match_case_ptr, 24)        # match_case.body

            Let j be 0
            While j is less than body_count:
                Let stmt_ptr be memory_get_integer(body plus j multiplied by 8, 0)
                codegen_collect_strings_from_statement(codegen, stmt_ptr)
                Let j be j plus 1
            End While
            Let i be i plus 1
        End While
        Return 0
    End If

    # Other statement types (IMPORT, BREAK, CONTINUE, INLINE_ASSEMBLY) don't have strings to collect
    Return 0
End Process

# Helper function to determine the type name of an expression
Process called "codegen_get_expression_type" takes codegen as Integer, expr as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If

    Let expr_type be memory_get_integer(expr, 0)  # expr->type

    If expr_type is equal to 1:  # EXPR_VARIABLE
        Let variable_name be memory_get_integer(expr, 8)  # expr->data.variable_name
        Let var_index be codegen_find_variable(codegen, variable_name)

        If var_index is equal to 0 minus 1:  # -1 for not found
            # Check if this is a global variable
            Let current_program be memory_get_integer(codegen, 40)  # codegen->current_program
            If current_program is not equal to 0:
                Let global_count be memory_get_integer(current_program, 48)  # program->global_count
                Let globals be memory_get_integer(current_program, 40)       # program->globals

                Let j be 0
                While j is less than global_count:
                    Let global_ptr be memory_get_integer(globals plus j multiplied by 8, 0)
                    Let global_name be memory_get_integer(global_ptr, 0)  # global->name
                    If string_equals(global_name, variable_name) is equal to 1:
                        Let global_type be memory_get_integer(global_ptr, 8)  # global->type
                        Return global_type
                    End If
                    Let j be j plus 1
                End While
            End If
            Return 0
        End If

        Let variables be memory_get_integer(codegen, 8)  # codegen->variables
        Let var_ptr be variables plus var_index multiplied by 32
        Let type_name be memory_get_integer(var_ptr, 16)  # variable.type_name
        Return type_name
    End If

    If expr_type is equal to 10:  # EXPR_FIELD_ACCESS
        Let field_access_ptr be expr plus 8  # &expr->data.field_access
        Let object be memory_get_integer(field_access_ptr, 0)       # field_access.object
        Let field_name be memory_get_integer(field_access_ptr, 8)   # field_access.field_name

        # Get the type of the object
        Let object_type be codegen_get_expression_type(codegen, object)
        If object_type is equal to 0:
            Return 0
        End If

        # Find the type definition
        Let current_program be memory_get_integer(codegen, 40)  # codegen->current_program
        Let type_count be memory_get_integer(current_program, 32)  # program->type_count
        Let types be memory_get_integer(current_program, 24)       # program->types
        Let type be 0

        Let i be 0
        While i is less than type_count:
            Let type_ptr be memory_get_integer(types plus i multiplied by 8, 0)
            Let type_name_ptr be memory_get_integer(type_ptr, 0)  # type->name
            If string_equals(type_name_ptr, object_type) is equal to 1:
                Let type be type_ptr
                Let i be type_count  # break loop
            End If
            Let i be i plus 1
        End While

        If type is equal to 0:
            Return 0
        End If

        # Find the field and return its type
        Let kind be memory_get_integer(type, 8)  # type->kind
        If kind is equal to 1:  # TYPE_KIND_STRUCT
            Let struct_type_ptr be type plus 16  # &type->data.struct_type
            Let field_count be memory_get_integer(struct_type_ptr, 0)  # struct_type.field_count
            Let fields be memory_get_integer(struct_type_ptr, 8)       # struct_type.fields

            Let i be 0
            While i is less than field_count:
                Let field_ptr be fields plus i multiplied by 24  # sizeof(FieldDefinition)
                Let field_name_ptr be memory_get_integer(field_ptr, 0)  # field.name
                If string_equals(field_name_ptr, field_name) is equal to 1:
                    Let field_type be memory_get_integer(field_ptr, 8)  # field.type
                    Return field_type
                End If
                Let i be i plus 1
            End While
        End If

        Return 0
    End If

    # Other expression types don't have determinable types in this context
    Return 0
End Process

# Generate the address of an lvalue expression (result in %rbx)
Process called "codegen_generate_lvalue_address" takes codegen as Integer, expr as Integer returns Integer:
    Let expr_type be memory_get_integer(expr, 0)  # expr->type
    Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file

    If expr_type is equal to 1:  # EXPR_VARIABLE
        # Find variable and generate its address
        Let variable_name be memory_get_integer(expr, 8)  # expr->data.variable_name
        Let var_index be codegen_find_variable(codegen, variable_name)

        If var_index is equal to 0 minus 1:  # -1 for not found
            # Check if this is a global variable
            Let is_global be 0
            Let current_program be memory_get_integer(codegen, 40)  # codegen->current_program

            If current_program is not equal to 0:
                Let global_count be memory_get_integer(current_program, 48)  # program->global_count
                Let globals be memory_get_integer(current_program, 40)       # program->globals

                Let j be 0
                While j is less than global_count:
                    Let global_ptr be memory_get_integer(globals plus j multiplied by 8, 0)
                    Let global_name be memory_get_integer(global_ptr, 0)  # global->name
                    If string_equals(global_name, variable_name) is equal to 1:
                        Let is_global be 1
                        Let j be global_count  # break loop
                    End If
                    Let j be j plus 1
                End While
            End If

            If is_global is equal to 1:
                # Generate address of global variable
                file_write(output_file, "    leaq ")
                file_write(output_file, variable_name)
                file_write_line(output_file, "(%rip), %rbx  # Address of global variable")
            Otherwise:
                print_string("[CODEGEN ERROR] Unknown variable '")
                print_string(variable_name)
                print_string("'")
                print_newline()
                exit_with_code(1)
            End If
        Otherwise:
            Let variables be memory_get_integer(codegen, 8)  # codegen->variables
            Let var_ptr be variables plus var_index multiplied by 32
            Let offset be memory_get_integer(var_ptr, 8)  # variable.stack_offset

            # Generate address of variable on stack
            file_write(output_file, "    leaq -")
            file_write(output_file, integer_to_string(offset))
            file_write_line(output_file, "(%rbp), %rbx")
        End If
        Return 0
    End If

    If expr_type is equal to 10:  # EXPR_FIELD_ACCESS
        Let field_access_ptr be expr plus 8  # &expr->data.field_access
        Let object be memory_get_integer(field_access_ptr, 0)     # field_access.object
        Let field_name be memory_get_integer(field_access_ptr, 8) # field_access.field_name

        # Generate address of object
        codegen_generate_lvalue_address(codegen, object)

        # Now %rbx contains the address of the object
        # We need to add the field offset to get the field address

        # Get the type of the object using our helper function
        Let object_type be codegen_get_expression_type(codegen, object)
        If object_type is equal to 0:
            print_string("[CODEGEN ERROR] Cannot determine type of object in field access")
            print_newline()
            exit_with_code(1)
        End If

        # Find the type definition
        Let current_program be memory_get_integer(codegen, 40)  # codegen->current_program
        Let type_count be memory_get_integer(current_program, 32)  # program->type_count
        Let types be memory_get_integer(current_program, 24)       # program->types
        Let type be 0

        Let i be 0
        While i is less than type_count:
            Let type_ptr be memory_get_integer(types plus i multiplied by 8, 0)
            Let type_name_ptr be memory_get_integer(type_ptr, 0)  # type->name
            If string_equals(type_name_ptr, object_type) is equal to 1:
                Let type be type_ptr
                Let i be type_count  # break loop
            End If
            Let i be i plus 1
        End While

        If type is equal to 0:
            print_string("[CODEGEN ERROR] Unknown type '")
            print_string(object_type)
            print_string("'")
            print_newline()
            exit_with_code(1)
        End If

        # Find field offset
        Let field_offset be 0 minus 1  # -1 for not found
        Let kind be memory_get_integer(type, 8)  # type->kind

        If kind is equal to 1:  # TYPE_KIND_STRUCT
            Let struct_type_ptr be type plus 16  # &type->data.struct_type
            Let field_count be memory_get_integer(struct_type_ptr, 0)  # struct_type.field_count
            Let fields be memory_get_integer(struct_type_ptr, 8)       # struct_type.fields

            Let i be 0
            While i is less than field_count:
                Let field_ptr be fields plus i multiplied by 24  # sizeof(FieldDefinition)
                Let field_name_ptr be memory_get_integer(field_ptr, 0)  # field.name
                If string_equals(field_name_ptr, field_name) is equal to 1:
                    Let field_offset be memory_get_integer(field_ptr, 16)  # field.offset
                    Let i be field_count  # break loop
                End If
                Let i be i plus 1
            End While
        End If

        If field_offset is equal to 0 minus 1:  # -1 for not found
            print_string("[CODEGEN ERROR] Type '")
            print_string(object_type)
            print_string("' has no field '")
            print_string(field_name)
            print_string("'")
            print_newline()
            exit_with_code(1)
        End If

        # Add field offset to object address
        file_write(output_file, "    addq $")
        file_write(output_file, integer_to_string(field_offset))
        file_write_line(output_file, ", %rbx")
        Return 0
    End If

    If expr_type is equal to 16:  # EXPR_ARRAY_INDEX
        Let array_index_ptr be expr plus 8  # &expr->data.array_index
        Let arr be memory_get_integer(array_index_ptr, 0)  # array_index.array
        Let index be memory_get_integer(array_index_ptr, 8)  # array_index.index

        # Check if the array is a parameter or local variable
        Let array_type be memory_get_integer(arr, 0)  # array->type
        If array_type is equal to 1:  # EXPR_VARIABLE
            Let array_variable_name be memory_get_integer(arr, 8)  # array->data.variable_name
            Let var_index be codegen_find_variable(codegen, array_variable_name)

            If var_index is not equal to 0 minus 1:  # found variable
                Let variables be memory_get_integer(codegen, 8)  # codegen->variables
                Let var_ptr be variables plus var_index multiplied by 32
                Let is_parameter be memory_get_integer(var_ptr, 24)  # variable.is_parameter

                If is_parameter is equal to 1:
                    # For array parameters, load the pointer value, not the address
                    Let offset be memory_get_integer(var_ptr, 8)  # variable.stack_offset
                    file_write(output_file, "    movq -")
                    file_write(output_file, integer_to_string(offset))
                    file_write_line(output_file, "(%rbp), %rbx  # Load array parameter pointer")
                Otherwise:
                    # For local arrays, generate the address
                    codegen_generate_lvalue_address(codegen, arr)
                End If
            Otherwise:
                # For complex expressions, generate the address
                codegen_generate_lvalue_address(codegen, arr)
            End If
        Otherwise:
            # For complex expressions, generate the address
            codegen_generate_lvalue_address(codegen, arr)
        End If

        # Save base address
        file_write_line(output_file, "    pushq %rbx")

        # Generate index expression
        codegen_generate_expression(codegen, index)

        # Pop base address
        file_write_line(output_file, "    popq %rbx")

        # Calculate element address: base + (index * element_size)
        # For arrays, all elements are currently 8 bytes (Integer size)
        file_write_line(output_file, "    imulq $8, %rax")
        file_write_line(output_file, "    addq %rax, %rbx")
        Return 0
    End If

    # Invalid lvalue expression type
    print_string("[CODEGEN ERROR] Invalid lvalue expression type")
    print_newline()
    exit_with_code(1)
    Return 0
End Process

# Generate code for expression - equivalent to codegen_generate_expression
Process called "codegen_generate_expression" takes codegen as Integer, expr as Integer returns Integer:
    Let expr_type be memory_get_integer(expr, 0)  # expr->type
    Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file

    If expr_type is equal to 0:  # EXPR_INTEGER
        Let integer_value be memory_get_integer(expr, 8)  # expr->data.integer_value
        file_write(output_file, "    movq $")
        file_write(output_file, integer_to_string(integer_value))
        file_write_line(output_file, ", %rax")
        Return 0
    End If

    If expr_type is equal to 1:  # EXPR_VARIABLE
        Let variable_name be memory_get_integer(expr, 8)  # expr->data.variable_name
        Let var_index be codegen_find_variable(codegen, variable_name)

        If var_index is equal to 0 minus 1:  # -1 for not found
            # Check if this is a global variable
            Let is_global be 0
            Let current_program be memory_get_integer(codegen, 40)  # codegen->current_program

            If current_program is not equal to 0:
                Let global_count be memory_get_integer(current_program, 48)  # program->global_count
                Let globals be memory_get_integer(current_program, 40)       # program->globals

                Let j be 0
                While j is less than global_count:
                    Let global_ptr be memory_get_integer(globals plus j multiplied by 8, 0)
                    Let global_name be memory_get_integer(global_ptr, 0)  # global->name
                    If string_equals(global_name, variable_name) is equal to 1:
                        Let is_global be 1
                        Let j be global_count  # break loop
                    End If
                    Let j be j plus 1
                End While
            End If

            If is_global is equal to 1:
                # Load global variable value
                file_write(output_file, "    movq ")
                file_write(output_file, variable_name)
                file_write_line(output_file, "(%rip), %rax  # Load global variable")
            Otherwise:
                # Check if this is a function name being used as a function pointer
                Let is_function be 0
                If current_program is not equal to 0:
                    Let function_count be memory_get_integer(current_program, 16)  # program->function_count
                    Let functions be memory_get_integer(current_program, 8)        # program->functions

                    Let j be 0
                    While j is less than function_count:
                        Let function_ptr be memory_get_integer(functions plus j multiplied by 8, 0)
                        Let function_name be memory_get_integer(function_ptr, 0)  # function->name
                        If string_equals(function_name, variable_name) is equal to 1:
                            Let is_function be 1
                            Let j be function_count  # break loop
                        End If
                        Let j be j plus 1
                    End While
                End If

                If is_function is equal to 0:
                    print_string("[CODEGEN ERROR] Undefined variable: ")
                    print_string(variable_name)
                    print_newline()
                    exit_with_code(1)
                End If

                file_write(output_file, "    leaq ")
                file_write(output_file, variable_name)
                file_write_line(output_file, "(%rip), %rax  # Load function address")
            End If
        Otherwise:
            Let variables be memory_get_integer(codegen, 8)  # codegen->variables
            Let var_ptr be variables plus var_index multiplied by 32
            Let offset be memory_get_integer(var_ptr, 8)     # variable.stack_offset
            Let var_type be memory_get_integer(var_ptr, 16)  # variable.type_name

            # Check if this variable is an array type
            Let is_array be 0
            Let current_program be memory_get_integer(codegen, 40)  # codegen->current_program

            If current_program is not equal to 0:
                Let type_count be memory_get_integer(current_program, 32)  # program->type_count
                Let types be memory_get_integer(current_program, 24)       # program->types

                Let i be 0
                While i is less than type_count:
                    Let type_ptr be memory_get_integer(types plus i multiplied by 8, 0)
                    Let type_name_ptr be memory_get_integer(type_ptr, 0)  # type->name
                    If string_equals(type_name_ptr, var_type) is equal to 1:
                        Let kind be memory_get_integer(type_ptr, 8)  # type->kind
                        If kind is equal to 2:  # TYPE_KIND_ARRAY
                            Let is_array be 1
                        End If
                        Let i be type_count  # break loop
                    End If
                    Let i be i plus 1
                End While
            End If

            If is_array is equal to 1:
                # For arrays, load the address not the value
                file_write(output_file, "    leaq -")
                file_write(output_file, integer_to_string(offset))
                file_write_line(output_file, "(%rbp), %rax  # Load array address")
            Otherwise:
                file_write(output_file, "    movq -")
                file_write(output_file, integer_to_string(offset))
                file_write_line(output_file, "(%rbp), %rax")
            End If
        End If
        Return 0
    End If

    If expr_type is equal to 3:  # EXPR_BINARY_OP
        Let binary_op_ptr be expr plus 8  # &expr->data.binary_op
        Let operator be memory_get_integer(binary_op_ptr, 0)  # binary_op.operator
        Let left be memory_get_integer(binary_op_ptr, 8)      # binary_op.left
        Let right be memory_get_integer(binary_op_ptr, 16)    # binary_op.right

        # Generate left operand (result in %rax)
        codegen_generate_expression(codegen, left)
        # Push left operand to stack
        file_write_line(output_file, "    pushq %rax")
        # Generate right operand (result in %rax)
        codegen_generate_expression(codegen, right)
        # Pop left operand from stack to %rbx
        file_write_line(output_file, "    popq %rbx")

        If operator is equal to 61:  # TOKEN_PLUS
            file_write_line(output_file, "    addq %rbx, %rax")
        Otherwise If operator is equal to 62:  # TOKEN_MINUS
            file_write_line(output_file, "    subq %rax, %rbx")
            file_write_line(output_file, "    movq %rbx, %rax")
        Otherwise If operator is equal to 63:  # TOKEN_MULTIPLIED
            file_write_line(output_file, "    imulq %rbx, %rax")
        Otherwise If operator is equal to 64:  # TOKEN_DIVIDED
            # Division: dividend in %rax, divisor in %rbx
            # Move divisor to %rcx to preserve %rbx
            file_write_line(output_file, "    movq %rax, %rcx")  # Save divisor in %rcx
            file_write_line(output_file, "    movq %rbx, %rax")  # Move dividend to %rax

            # Check for divide by zero
            file_write_line(output_file, "    testq %rcx, %rcx")
            Let label_counter be memory_get_integer(codegen, 72)  # codegen->label_counter
            file_write(output_file, "    jz .Ldiv_by_zero_")
            file_write_line(output_file, integer_to_string(label_counter))

            # Sign extend %rax to %rdx:%rax
            file_write_line(output_file, "    cqto")
            # Divide by %rcx, quotient in %rax, remainder in %rdx
            file_write_line(output_file, "    idivq %rcx")
            file_write(output_file, "    jmp .Ldiv_done_")
            file_write_line(output_file, integer_to_string(label_counter))

            # Divide by zero handler
            file_write(output_file, ".Ldiv_by_zero_")
            file_write(output_file, integer_to_string(label_counter))
            file_write_line(output_file, ":")
            file_write_line(output_file, "    movq $0, %rax")
            file_write(output_file, ".Ldiv_done_")
            file_write(output_file, integer_to_string(label_counter))
            file_write_line(output_file, ":")
            memory_set_integer(codegen, 72, label_counter plus 1)  # codegen->label_counter++
        Otherwise If operator is equal to 65:  # TOKEN_MODULO
            # Modulo: dividend in %rax, divisor in %rbx
            # Move divisor to %rcx to preserve %rbx
            file_write_line(output_file, "    movq %rax, %rcx")  # Save divisor in %rcx
            file_write_line(output_file, "    movq %rbx, %rax")  # Move dividend to %rax

            # Check for modulo by zero
            file_write_line(output_file, "    testq %rcx, %rcx")
            Let label_counter be memory_get_integer(codegen, 72)  # codegen->label_counter
            file_write(output_file, "    jz .Lmod_by_zero_")
            file_write_line(output_file, integer_to_string(label_counter))

            # Sign extend %rax to %rdx:%rax
            file_write_line(output_file, "    cqto")
            # Divide by %rcx, quotient in %rax, remainder in %rdx
            file_write_line(output_file, "    idivq %rcx")
            # Move remainder to %rax
            file_write_line(output_file, "    movq %rdx, %rax")
            file_write(output_file, "    jmp .Lmod_done_")
            file_write_line(output_file, integer_to_string(label_counter))

            # Modulo by zero handler
            file_write(output_file, ".Lmod_by_zero_")
            file_write(output_file, integer_to_string(label_counter))
            file_write_line(output_file, ":")
            file_write_line(output_file, "    movq $0, %rax")
            file_write(output_file, ".Lmod_done_")
            file_write(output_file, integer_to_string(label_counter))
            file_write_line(output_file, ":")
            memory_set_integer(codegen, 72, label_counter plus 1)  # codegen->label_counter++
        Otherwise If operator is equal to 75:  # TOKEN_BIT_AND
            file_write_line(output_file, "    andq %rbx, %rax")
        Otherwise If operator is equal to 76:  # TOKEN_BIT_OR
            file_write_line(output_file, "    orq %rbx, %rax")
        Otherwise If operator is equal to 77:  # TOKEN_BIT_XOR
            file_write_line(output_file, "    xorq %rbx, %rax")
        Otherwise If operator is equal to 78:  # TOKEN_BIT_SHIFT_LEFT
            # For left shift, we need the shift amount in %rcx (cl register)
            file_write_line(output_file, "    movq %rax, %rcx")  # Move shift amount to %rcx
            file_write_line(output_file, "    movq %rbx, %rax")  # Move value to be shifted to %rax
            file_write_line(output_file, "    salq %cl, %rax")   # Shift left by %cl bits
        Otherwise If operator is equal to 79:  # TOKEN_BIT_SHIFT_RIGHT
            # For right shift, we need the shift amount in %rcx (cl register)
            file_write_line(output_file, "    movq %rax, %rcx")  # Move shift amount to %rcx
            file_write_line(output_file, "    movq %rbx, %rax")  # Move value to be shifted to %rax
            file_write_line(output_file, "    sarq %cl, %rax")   # Arithmetic shift right by %cl bits
        End If
        Return 0
    End If

    If expr_type is equal to 4:  # EXPR_COMPARISON
        Let comparison_ptr be expr plus 8  # &expr->data.comparison
        Let comparison_op be memory_get_integer(comparison_ptr, 0)  # comparison.comparison_op
        Let left be memory_get_integer(comparison_ptr, 8)           # comparison.left
        Let right be memory_get_integer(comparison_ptr, 16)         # comparison.right

        # Generate left operand (result in %rax)
        codegen_generate_expression(codegen, left)
        # Push left operand to stack
        file_write_line(output_file, "    pushq %rax")
        # Generate right operand (result in %rax)
        codegen_generate_expression(codegen, right)
        # Pop left operand from stack to %rbx
        file_write_line(output_file, "    popq %rbx")

        # Compare and set result (0 or 1)
        file_write_line(output_file, "    cmpq %rax, %rbx")
        If comparison_op is equal to 49:  # TOKEN_EQUAL
            file_write_line(output_file, "    sete %al")
        Otherwise If comparison_op is equal to 50:  # TOKEN_NOT_EQUAL
            file_write_line(output_file, "    setne %al")
        Otherwise If comparison_op is equal to 51:  # TOKEN_LESS
            file_write_line(output_file, "    setl %al")
        Otherwise If comparison_op is equal to 52:  # TOKEN_GREATER
            file_write_line(output_file, "    setg %al")
        Otherwise If comparison_op is equal to 53:  # TOKEN_LESS_EQUAL
            file_write_line(output_file, "    setle %al")
        Otherwise If comparison_op is equal to 54:  # TOKEN_GREATER_EQUAL
            file_write_line(output_file, "    setge %al")
        End If
        file_write_line(output_file, "    movzbq %al, %rax")
        Return 0
    End If

    If expr_type is equal to 5:  # EXPR_FUNCTION_CALL
        Let function_call_ptr be expr plus 8  # &expr->data.function_call
        Let function_name be memory_get_integer(function_call_ptr, 0)  # function_call.function_name
        Let arg_count be memory_get_integer(function_call_ptr, 8)      # function_call.argument_count
        Let arguments be memory_get_integer(function_call_ptr, 16)     # function_call.arguments

        # Check if this is a list runtime function
        Let is_list_function be 0
        If string_equals(function_name, "list_create") is equal to 1:
            Let is_list_function be 1
        End If
        If string_equals(function_name, "list_append") is equal to 1:
            Let is_list_function be 1
        End If
        If string_equals(function_name, "list_get") is equal to 1:
            Let is_list_function be 1
        End If
        If string_equals(function_name, "list_get_integer") is equal to 1:
            Let is_list_function be 1
        End If
        If string_equals(function_name, "list_length") is equal to 1:
            Let is_list_function be 1
        End If
        If string_equals(function_name, "list_destroy") is equal to 1:
            Let is_list_function be 1
        End If

        # System V ABI: arguments go in %rdi, %rsi, %rdx, %rcx, %r8, %r9
        Let max_register_args be 6
        Let register_arg_count be arg_count
        If arg_count is greater than max_register_args:
            Let register_arg_count be max_register_args
        End If

        # Evaluate arguments in reverse order and push them to stack to preserve order
        Let i be register_arg_count minus 1
        While i is greater than or equal to 0:
            Let arg_ptr be memory_get_integer(arguments plus i multiplied by 8, 0)
            codegen_generate_expression(codegen, arg_ptr)
            file_write_line(output_file, "    pushq %rax")
            Let i be i minus 1
        End While

        # Pop arguments into correct registers
        Let i be 0
        While i is less than register_arg_count:
            If i is equal to 0:
                file_write_line(output_file, "    popq %rdi")
            Otherwise If i is equal to 1:
                file_write_line(output_file, "    popq %rsi")
            Otherwise If i is equal to 2:
                file_write_line(output_file, "    popq %rdx")
            Otherwise If i is equal to 3:
                file_write_line(output_file, "    popq %rcx")
            Otherwise If i is equal to 4:
                file_write_line(output_file, "    popq %r8")
            Otherwise If i is equal to 5:
                file_write_line(output_file, "    popq %r9")
            End If
            Let i be i plus 1
        End While

        # Handle arguments beyond 6 (push to stack) - not fully implemented
        If arg_count is greater than max_register_args:
            print_string("[CODEGEN WARNING] Functions with more than 6 arguments not fully supported yet")
            print_newline()
        End If

        # Check if this is an indirect call through a function pointer variable
        Let var_index be codegen_find_variable(codegen, function_name)
        If var_index is not equal to 0 minus 1:  # found variable
            # This is a function pointer variable - load it and call indirectly
            Let variables be memory_get_integer(codegen, 8)  # codegen->variables
            Let var_ptr be variables plus var_index multiplied by 32
            Let offset be memory_get_integer(var_ptr, 8)  # variable.stack_offset
            file_write(output_file, "    movq -")
            file_write(output_file, integer_to_string(offset))
            file_write_line(output_file, "(%rbp), %rax  # Load function pointer")
            file_write_line(output_file, "    call *%rax  # Indirect call")
        Otherwise:
            If is_list_function is equal to 1:
                # For list runtime functions, call the C function directly
                file_write(output_file, "    call ")
                file_write(output_file, function_name)
                file_write_line(output_file, "@PLT")
            Otherwise:
                # For user-defined functions - direct call
                file_write(output_file, "    call ")
                file_write_line(output_file, function_name)
            End If
        End If
        # Result is already in %rax
        Return 0
    End If

    If expr_type is equal to 7:  # EXPR_STRING_LITERAL
        Let string_literal be memory_get_integer(expr, 8)  # expr->data.string_literal

        # Add string to string literals table if not already present
        Let str_index be 0 minus 1  # -1 for not found
        Let string_count be memory_get_integer(codegen, 48)
        Let strings be memory_get_integer(codegen, 64)

        Let i be 0
        While i is less than string_count:
            Let str_ptr be strings plus i multiplied by 16
            Let existing_value be memory_get_integer(str_ptr, 0)
            If string_equals(existing_value, string_literal) is equal to 1:
                Let str_index be i
                Let i be string_count  # break loop
            End If
            Let i be i plus 1
        End While

        If str_index is equal to 0 minus 1:  # not found
            Let str_index be codegen_add_string_literal(codegen, string_literal)
        End If

        # Load address of string literal into %rax
        Let strings be memory_get_integer(codegen, 64)  # refresh after potential realloc
        Let str_ptr be strings plus str_index multiplied by 16
        Let label be memory_get_integer(str_ptr, 8)  # strings[str_index].label
        file_write(output_file, "    leaq ")
        file_write(output_file, label)
        file_write_line(output_file, "(%rip), %rax")
        Return 0
    End If

    If expr_type is equal to 10:  # EXPR_FIELD_ACCESS
        Let field_access_ptr be expr plus 8  # &expr->data.field_access
        Let obj be memory_get_integer(field_access_ptr, 0)     # field_access.object
        Let field_name be memory_get_integer(field_access_ptr, 8)  # field_access.field_name

        # For field access, we need the address of the struct
        Let obj_type be memory_get_integer(obj, 0)  # obj->type

        If obj_type is equal to 1:  # EXPR_VARIABLE
            Let obj_variable_name be memory_get_integer(obj, 8)  # obj->data.variable_name
            Let var_index be codegen_find_variable(codegen, obj_variable_name)
            If var_index is equal to 0 minus 1:  # -1 for not found
                print_string("[CODEGEN ERROR] Unknown variable '")
                print_string(obj_variable_name)
                print_string("'")
                print_newline()
                exit_with_code(1)
            End If

            # Find the field offset based on the variable's type
            Let variables be memory_get_integer(codegen, 8)  # codegen->variables
            Let var_ptr be variables plus var_index multiplied by 32
            Let type_name be memory_get_integer(var_ptr, 16)  # variable.type_name
            Let offset be memory_get_integer(var_ptr, 8)      # variable.stack_offset

            If type_name is equal to 0:
                # Variable is untyped - treat as raw pointer
                # Load the pointer value
                file_write(output_file, "    movq -")
                file_write(output_file, integer_to_string(offset))
                file_write_line(output_file, "(%rbp), %rax")

                # For raw pointer access, we need to determine field offset
                # Calculate field offset based on struct definition
                Let field_offset be 0

                # Common field patterns from our transliterated code
                If string_equals(field_name, "type") is equal to 1:
                    Let field_offset be 0
                Otherwise If string_equals(field_name, "value") is equal to 1:
                    Let field_offset be 8
                Otherwise If string_equals(field_name, "line") is equal to 1:
                    Let field_offset be 16
                Otherwise If string_equals(field_name, "column") is equal to 1:
                    Let field_offset be 24
                Otherwise If string_equals(field_name, "source") is equal to 1:
                    Let field_offset be 0
                Otherwise If string_equals(field_name, "position") is equal to 1:
                    Let field_offset be 8
                Otherwise If string_equals(field_name, "current_char") is equal to 1:
                    Let field_offset be 32
                Otherwise:
                    # Default to sequential 8-byte offsets
                    Let field_offset be 0
                End If

                # Load the field value
                file_write(output_file, "    movq ")
                file_write(output_file, integer_to_string(field_offset))
                file_write_line(output_file, "(%rax), %rax")
            Otherwise:
                If string_equals(type_name, "Integer") is equal to 1:
                    # Variable is Integer type - treat as raw pointer
                    # Load the pointer value
                    file_write(output_file, "    movq -")
                    file_write(output_file, integer_to_string(offset))
                    file_write_line(output_file, "(%rbp), %rax")

                    # For raw pointer access, use default field offset
                    Let field_offset be 0
                    If string_equals(field_name, "type") is equal to 1:
                        Let field_offset be 0
                    Otherwise If string_equals(field_name, "value") is equal to 1:
                        Let field_offset be 8
                    Otherwise If string_equals(field_name, "line") is equal to 1:
                        Let field_offset be 16
                    Otherwise If string_equals(field_name, "column") is equal to 1:
                        Let field_offset be 24
                    End If

                    # Load the field value
                    file_write(output_file, "    movq ")
                    file_write(output_file, integer_to_string(field_offset))
                    file_write_line(output_file, "(%rax), %rax")
                Otherwise:
                # Variable has a type - use type information
                # Load the address of the struct
                file_write(output_file, "    leaq -")
                file_write(output_file, integer_to_string(offset))
                file_write_line(output_file, "(%rbp), %rax")

                Let current_program be memory_get_integer(codegen, 40)  # codegen->current_program
                Let type_count be memory_get_integer(current_program, 32)  # program->type_count
                Let types be memory_get_integer(current_program, 24)       # program->types
                Let type be 0

                Let i be 0
                While i is less than type_count:
                    Let type_ptr be memory_get_integer(types plus i multiplied by 8, 0)
                    Let type_name_ptr be memory_get_integer(type_ptr, 0)  # type->name
                    If string_equals(type_name_ptr, type_name) is equal to 1:
                        Let type be type_ptr
                        Let i be type_count  # break loop
                    End If
                    Let i be i plus 1
                End While

                If type is equal to 0:
                    print_string("[CODEGEN ERROR] Unknown type '")
                    print_string(type_name)
                    print_string("'")
                    print_newline()
                    exit_with_code(1)
                End If

                Let field_offset be 0 minus 1  # -1 for not found
                Let kind be memory_get_integer(type, 8)  # type->kind
                If kind is equal to 1:  # TYPE_KIND_STRUCT
                    Let struct_type_ptr be type plus 16  # &type->data.struct_type
                    Let field_count be memory_get_integer(struct_type_ptr, 0)  # struct_type.field_count
                    Let fields be memory_get_integer(struct_type_ptr, 8)       # struct_type.fields

                    Let i be 0
                    While i is less than field_count:
                        Let field_ptr be fields plus i multiplied by 24  # sizeof(FieldDefinition)
                        Let field_name_ptr be memory_get_integer(field_ptr, 0)  # field.name
                        If string_equals(field_name_ptr, field_name) is equal to 1:
                            Let field_offset be memory_get_integer(field_ptr, 16)  # field.offset
                            Let i be field_count  # break loop
                        End If
                        Let i be i plus 1
                    End While
                End If

                If field_offset is equal to 0 minus 1:  # -1 for not found
                    print_string("[CODEGEN ERROR] Type '")
                    print_string(type_name)
                    print_string("' has no field '")
                    print_string(field_name)
                    print_string("'")
                    print_newline()
                    exit_with_code(1)
                End If

                # Load the field value
                file_write(output_file, "    movq ")
                file_write(output_file, integer_to_string(field_offset))
                file_write_line(output_file, "(%rax), %rax")
                End If
            End If
        Otherwise:
            # Handle complex field access expressions (nested access)
            # For nested access, we need the ADDRESS of the intermediate object,
            # not its value. Use the lvalue addressing logic.
            codegen_generate_lvalue_address(codegen, obj)

            # Now %rbx contains the address of the object, copy to %rax
            file_write_line(output_file, "    movq %rbx, %rax")
            # Get the type of the object expression
            Let object_type be codegen_get_expression_type(codegen, obj)
            If object_type is equal to 0:
                print_string("[CODEGEN ERROR] Cannot determine type of complex field access object")
                print_newline()
                exit_with_code(1)
            End If

            # Find the type definition for the object type
            Let current_program be memory_get_integer(codegen, 40)  # codegen->current_program
            Let type_count be memory_get_integer(current_program, 32)  # program->type_count
            Let types be memory_get_integer(current_program, 24)       # program->types
            Let type be 0

            Let i be 0
            While i is less than type_count:
                Let type_ptr be memory_get_integer(types plus i multiplied by 8, 0)
                Let type_name_ptr be memory_get_integer(type_ptr, 0)  # type->name
                If string_equals(type_name_ptr, object_type) is equal to 1:
                    Let type be type_ptr
                    Let i be type_count  # break loop
                End If
                Let i be i plus 1
            End While

            If type is equal to 0:
                print_string("[CODEGEN ERROR] Unknown type '")
                print_string(object_type)
                print_string("' in complex field access")
                print_newline()
                exit_with_code(1)
            End If

            # Find the field offset
            Let field_offset be 0 minus 1  # -1 for not found
            Let kind be memory_get_integer(type, 8)  # type->kind
            If kind is equal to 1:  # TYPE_KIND_STRUCT
                Let struct_type_ptr be type plus 16  # &type->data.struct_type
                Let field_count be memory_get_integer(struct_type_ptr, 0)  # struct_type.field_count
                Let fields be memory_get_integer(struct_type_ptr, 8)       # struct_type.fields

                Let i be 0
                While i is less than field_count:
                    Let field_ptr be fields plus i multiplied by 24  # sizeof(FieldDefinition)
                    Let field_name_ptr be memory_get_integer(field_ptr, 0)  # field.name
                    If string_equals(field_name_ptr, field_name) is equal to 1:
                        Let field_offset be memory_get_integer(field_ptr, 16)  # field.offset
                        Let i be field_count  # break loop
                    End If
                    Let i be i plus 1
                End While
            End If

            If field_offset is equal to 0 minus 1:  # -1 for not found
                print_string("[CODEGEN ERROR] Type '")
                print_string(object_type)
                print_string("' has no field '")
                print_string(field_name)
                print_string("'")
                print_newline()
                exit_with_code(1)
            End If

            # Add the field offset to the address in %rax
            If field_offset is greater than 0:
                file_write(output_file, "    addq $")
                file_write(output_file, integer_to_string(field_offset))
                file_write_line(output_file, ", %rax")
            End If

            # Load the field value
            file_write_line(output_file, "    movq (%rax), %rax")
        End If
        Return 0
    End If

    # Other expression types (TYPE_NAME should cause error, VARIANT_CONSTRUCTOR, FUNCTION_POINTER, ARRAY_INDEX)
    If expr_type is equal to 6:  # EXPR_TYPE_NAME
        # Type names don't generate code directly - they're handled in LET statements
        # This shouldn't be reached in normal execution
        print_string("[CODEGEN ERROR] Type names should only appear in LET statements")
        print_newline()
        exit_with_code(1)
        Return 0
    End If

    If expr_type is equal to 11:  # EXPR_BUILTIN_CALL
        Let builtin_call_ptr be expr plus 8  # &expr->data.builtin_call
        Let builtin_type be memory_get_integer(builtin_call_ptr, 0)  # builtin_call.builtin_type
        Let arg_count be memory_get_integer(builtin_call_ptr, 8)     # builtin_call.argument_count
        Let arguments be memory_get_integer(builtin_call_ptr, 16)    # builtin_call.arguments

        # Map builtin types to function names - complete mapping from C code
        Let func_name be ""
        If builtin_type is equal to 100:  # TOKEN_READ_FILE
            Let func_name be "runtime_read_file"
        Otherwise If builtin_type is equal to 101:  # TOKEN_WRITE_FILE
            Let func_name be "runtime_write_file"
        Otherwise If builtin_type is equal to 102:  # TOKEN_STRING_LENGTH
            Let func_name be "string_length"
        Otherwise If builtin_type is equal to 103:  # TOKEN_STRING_CHAR_AT
            Let func_name be "string_char_at"
        Otherwise If builtin_type is equal to 104:  # TOKEN_STRING_SUBSTRING
            Let func_name be "string_substring"
        Otherwise If builtin_type is equal to 105:  # TOKEN_STRING_EQUALS
            Let func_name be "string_equals"
        Otherwise If builtin_type is equal to 106:  # TOKEN_ASCII_VALUE_OF
            Let func_name be "ascii_value_of"
        Otherwise If builtin_type is equal to 107:  # TOKEN_IS_DIGIT
            Let func_name be "is_digit"
        Otherwise If builtin_type is equal to 108:  # TOKEN_IS_ALPHA
            Let func_name be "is_alpha"
        Otherwise If builtin_type is equal to 109:  # TOKEN_IS_WHITESPACE
            Let func_name be "is_whitespace"
        Otherwise If builtin_type is equal to 110:  # TOKEN_LIST_CREATE
            Let func_name be "list_create"
        Otherwise If builtin_type is equal to 111:  # TOKEN_LIST_APPEND
            Let func_name be "list_append"
        Otherwise If builtin_type is equal to 112:  # TOKEN_LIST_GET
            Let func_name be "list_get"
        Otherwise If builtin_type is equal to 113:  # TOKEN_LIST_GET_INTEGER
            Let func_name be "list_get_integer"
        Otherwise If builtin_type is equal to 114:  # TOKEN_LIST_LENGTH
            Let func_name be "list_length"
        Otherwise If builtin_type is equal to 115:  # TOKEN_LIST_DESTROY
            Let func_name be "list_destroy"
        Otherwise If builtin_type is equal to 116:  # TOKEN_LIST_SET
            Let func_name be "list_set"
        Otherwise If builtin_type is equal to 117:  # TOKEN_LIST_INSERT
            Let func_name be "list_insert"
        Otherwise If builtin_type is equal to 118:  # TOKEN_LIST_REMOVE
            Let func_name be "list_remove"
        Otherwise If builtin_type is equal to 119:  # TOKEN_LIST_CLEAR
            Let func_name be "list_clear"
        Otherwise If builtin_type is equal to 120:  # TOKEN_LIST_FIND
            Let func_name be "list_find"
        Otherwise If builtin_type is equal to 121:  # TOKEN_LIST_SORT
            Let func_name be "list_sort"
        Otherwise If builtin_type is equal to 122:  # TOKEN_LIST_REVERSE
            Let func_name be "list_reverse"
        Otherwise If builtin_type is equal to 123:  # TOKEN_LIST_COPY
            Let func_name be "list_copy"
        Otherwise If builtin_type is equal to 124:  # TOKEN_LIST_MERGE
            Let func_name be "list_merge"
        Otherwise If builtin_type is equal to 125:  # TOKEN_STRING_CONCAT
            Let func_name be "string_concat"
        Otherwise If builtin_type is equal to 126:  # TOKEN_STRING_COMPARE
            Let func_name be "string_compare"
        Otherwise If builtin_type is equal to 127:  # TOKEN_STRING_TO_INTEGER
            Let func_name be "string_to_integer"
        Otherwise If builtin_type is equal to 128:  # TOKEN_INTEGER_TO_STRING
            Let func_name be "integer_to_string"
        Otherwise If builtin_type is equal to 129:  # TOKEN_STRING_FIND
            Let func_name be "string_find"
        Otherwise If builtin_type is equal to 130:  # TOKEN_STRING_REPLACE
            Let func_name be "string_replace"
        Otherwise If builtin_type is equal to 131:  # TOKEN_STRING_TRIM
            Let func_name be "string_trim"
        Otherwise If builtin_type is equal to 132:  # TOKEN_STRING_SPLIT
            Let func_name be "string_split"
        Otherwise If builtin_type is equal to 133:  # TOKEN_FILE_OPEN
            Let func_name be "runtime_file_open"
        Otherwise If builtin_type is equal to 134:  # TOKEN_FILE_CLOSE
            Let func_name be "runtime_file_close"
        Otherwise If builtin_type is equal to 135:  # TOKEN_FILE_READ_LINE
            Let func_name be "runtime_file_read_line"
        Otherwise If builtin_type is equal to 136:  # TOKEN_FILE_WRITE_LINE
            Let func_name be "runtime_file_write_line"
        Otherwise If builtin_type is equal to 137:  # TOKEN_FILE_EXISTS
            Let func_name be "runtime_file_exists"
        Otherwise If builtin_type is equal to 138:  # TOKEN_FILE_DELETE
            Let func_name be "runtime_file_delete"
        Otherwise If builtin_type is equal to 139:  # TOKEN_FILE_SIZE
            Let func_name be "runtime_file_size"
        Otherwise If builtin_type is equal to 140:  # TOKEN_FILE_SEEK
            Let func_name be "runtime_file_seek"
        Otherwise If builtin_type is equal to 141:  # TOKEN_FILE_TELL
            Let func_name be "runtime_file_tell"
        Otherwise If builtin_type is equal to 142:  # TOKEN_FILE_EOF
            Let func_name be "runtime_file_eof"
        Otherwise If builtin_type is equal to 143:  # TOKEN_SIN
            Let func_name be "runtime_sin"
        Otherwise If builtin_type is equal to 144:  # TOKEN_COS
            Let func_name be "runtime_cos"
        Otherwise If builtin_type is equal to 145:  # TOKEN_TAN
            Let func_name be "runtime_tan"
        Otherwise If builtin_type is equal to 146:  # TOKEN_SQRT
            Let func_name be "runtime_sqrt"
        Otherwise If builtin_type is equal to 147:  # TOKEN_POW
            Let func_name be "runtime_pow"
        Otherwise If builtin_type is equal to 148:  # TOKEN_ABS
            Let func_name be "runtime_abs"
        Otherwise If builtin_type is equal to 149:  # TOKEN_FLOOR
            Let func_name be "runtime_floor"
        Otherwise If builtin_type is equal to 150:  # TOKEN_CEIL
            Let func_name be "runtime_ceil"
        Otherwise If builtin_type is equal to 151:  # TOKEN_MIN
            Let func_name be "runtime_min"
        Otherwise If builtin_type is equal to 152:  # TOKEN_MAX
            Let func_name be "runtime_max"
        Otherwise If builtin_type is equal to 153:  # TOKEN_RANDOM
            Let func_name be "runtime_random"
        Otherwise If builtin_type is equal to 154:  # TOKEN_LOG
            Let func_name be "runtime_log"
        Otherwise If builtin_type is equal to 155:  # TOKEN_EXP
            Let func_name be "runtime_exp"
        Otherwise If builtin_type is equal to 156:  # TOKEN_GET_COMMAND_LINE_ARGS
            Let func_name be "get_command_line_args_count"
        Otherwise If builtin_type is equal to 157:  # TOKEN_EXIT_WITH_CODE
            Let func_name be "exit_with_code"
        Otherwise If builtin_type is equal to 158:  # TOKEN_PANIC
            Let func_name be "panic"
        Otherwise If builtin_type is equal to 159:  # TOKEN_ASSERT
            Let func_name be "assert"
        Otherwise If builtin_type is equal to 160:  # TOKEN_ALLOCATE
            Let func_name be "allocate"
        Otherwise If builtin_type is equal to 161:  # TOKEN_DEALLOCATE
            Let func_name be "deallocate"
        Otherwise:
            If 1 is equal to 1:  # Always true - workaround for parser bug
                print_string("[CODEGEN ERROR] Unknown built-in function type")
                print_newline()
                exit_with_code(1)
            End If
        End If

        # Validate argument count for each builtin type - complete validation from C code
        # (Extensive argument validation logic preserved from original...)
        Let expected_args be 0 minus 1  # -1 means variable args
        If builtin_type is equal to 100:  # TOKEN_READ_FILE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 101:  # TOKEN_WRITE_FILE
            Let expected_args be 2
        Otherwise If builtin_type is equal to 102:  # TOKEN_STRING_LENGTH
            Let expected_args be 1
        Otherwise If builtin_type is equal to 103:  # TOKEN_STRING_CHAR_AT
            Let expected_args be 2
        Otherwise If builtin_type is equal to 104:  # TOKEN_STRING_SUBSTRING
            Let expected_args be 3
        Otherwise If builtin_type is equal to 105:  # TOKEN_STRING_EQUALS
            Let expected_args be 2
        Otherwise If builtin_type is equal to 106:  # TOKEN_ASCII_VALUE_OF
            Let expected_args be 1
        Otherwise If builtin_type is equal to 107:  # TOKEN_IS_DIGIT
            Let expected_args be 1
        Otherwise If builtin_type is equal to 108:  # TOKEN_IS_ALPHA
            Let expected_args be 1
        Otherwise If builtin_type is equal to 109:  # TOKEN_IS_WHITESPACE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 110:  # TOKEN_LIST_CREATE
            Let expected_args be 0
        Otherwise If builtin_type is equal to 111:  # TOKEN_LIST_APPEND
            Let expected_args be 2
        Otherwise If builtin_type is equal to 112:  # TOKEN_LIST_GET
            Let expected_args be 2
        Otherwise If builtin_type is equal to 113:  # TOKEN_LIST_GET_INTEGER
            Let expected_args be 2
        Otherwise If builtin_type is equal to 114:  # TOKEN_LIST_LENGTH
            Let expected_args be 1
        Otherwise If builtin_type is equal to 115:  # TOKEN_LIST_DESTROY
            Let expected_args be 1
        Otherwise If builtin_type is equal to 133:  # TOKEN_FILE_OPEN
            Let expected_args be 2
        Otherwise If builtin_type is equal to 134:  # TOKEN_FILE_CLOSE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 135:  # TOKEN_FILE_READ_LINE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 136:  # TOKEN_FILE_WRITE_LINE
            Let expected_args be 2
        Otherwise If builtin_type is equal to 137:  # TOKEN_FILE_EXISTS
            Let expected_args be 1
        Otherwise If builtin_type is equal to 138:  # TOKEN_FILE_DELETE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 139:  # TOKEN_FILE_SIZE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 140:  # TOKEN_FILE_SEEK
            Let expected_args be 3
        Otherwise If builtin_type is equal to 141:  # TOKEN_FILE_TELL
            Let expected_args be 1
        Otherwise If builtin_type is equal to 142:  # TOKEN_FILE_EOF
            Let expected_args be 1
        Otherwise If builtin_type is equal to 143:  # TOKEN_SIN
            Let expected_args be 1
        Otherwise If builtin_type is equal to 144:  # TOKEN_COS
            Let expected_args be 1
        Otherwise If builtin_type is equal to 145:  # TOKEN_TAN
            Let expected_args be 1
        Otherwise If builtin_type is equal to 146:  # TOKEN_SQRT
            Let expected_args be 1
        Otherwise If builtin_type is equal to 147:  # TOKEN_POW
            Let expected_args be 2
        Otherwise If builtin_type is equal to 148:  # TOKEN_ABS
            Let expected_args be 1
        Otherwise If builtin_type is equal to 149:  # TOKEN_FLOOR
            Let expected_args be 1
        Otherwise If builtin_type is equal to 150:  # TOKEN_CEIL
            Let expected_args be 1
        Otherwise If builtin_type is equal to 151:  # TOKEN_MIN
            Let expected_args be 2
        Otherwise If builtin_type is equal to 152:  # TOKEN_MAX
            Let expected_args be 2
        Otherwise If builtin_type is equal to 153:  # TOKEN_RANDOM
            Let expected_args be 0
        Otherwise If builtin_type is equal to 154:  # TOKEN_LOG
            Let expected_args be 1
        Otherwise If builtin_type is equal to 155:  # TOKEN_EXP
            Let expected_args be 1
        Otherwise If builtin_type is equal to 156:  # TOKEN_GET_COMMAND_LINE_ARGS
            Let expected_args be 0
        Otherwise If builtin_type is equal to 157:  # TOKEN_EXIT_WITH_CODE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 158:  # TOKEN_PANIC
            Let expected_args be 1
        Otherwise If builtin_type is equal to 159:  # TOKEN_ASSERT
            Let expected_args be 2
        Otherwise If builtin_type is equal to 160:  # TOKEN_ALLOCATE
            Let expected_args be 1
        Otherwise If builtin_type is equal to 161:  # TOKEN_DEALLOCATE
            Let expected_args be 1
        End If

        If expected_args is not equal to 0 minus 1:  # not variable args
            If arg_count is not equal to expected_args:
                print_string("[CODEGEN ERROR] ")
                print_string(func_name)
                print_string(" expects ")
                print_string(integer_to_string(expected_args))
                print_string(" arguments, got ")
                print_string(integer_to_string(arg_count))
                print_newline()
                exit_with_code(1)
            End If
        End If

        # Evaluate arguments in reverse order and push them to stack
        Let i be arg_count minus 1
        While i is greater than or equal to 0:
            Let arg_ptr be memory_get_integer(arguments plus i multiplied by 8, 0)
            codegen_generate_expression(codegen, arg_ptr)
            file_write_line(output_file, "    pushq %rax")
            Let i be i minus 1
        End While

        # Pop arguments into correct registers
        Let i be 0
        While i is less than arg_count:
            If i is equal to 0:
                file_write_line(output_file, "    popq %rdi")
            Otherwise If i is equal to 1:
                file_write_line(output_file, "    popq %rsi")
            Otherwise If i is equal to 2:
                file_write_line(output_file, "    popq %rdx")
            Otherwise If i is equal to 3:
                file_write_line(output_file, "    popq %rcx")
            Otherwise If i is equal to 4:
                file_write_line(output_file, "    popq %r8")
            Otherwise If i is equal to 5:
                file_write_line(output_file, "    popq %r9")
            End If
            Let i be i plus 1
        End While

        # Call the runtime function
        file_write(output_file, "    call ")
        file_write(output_file, func_name)
        file_write_line(output_file, "@PLT")
        # Result is in %rax
        Return 0
    End If

    If expr_type is equal to 12:  # EXPR_VARIANT_CONSTRUCTOR
        Let variant_constructor_ptr be expr plus 8  # &expr->data.variant_constructor
        Let type_name be memory_get_integer(variant_constructor_ptr, 0)     # variant_constructor.type_name
        Let variant_name be memory_get_integer(variant_constructor_ptr, 8)  # variant_constructor.variant_name
        Let field_count be memory_get_integer(variant_constructor_ptr, 16)  # variant_constructor.field_count
        Let field_values be memory_get_integer(variant_constructor_ptr, 24) # variant_constructor.field_values

        # Find the type definition
        Let current_program be memory_get_integer(codegen, 40)  # codegen->current_program
        Let type_count be memory_get_integer(current_program, 32)  # program->type_count
        Let types be memory_get_integer(current_program, 24)       # program->types
        Let type be 0

        Let i be 0
        While i is less than type_count:
            Let type_ptr be memory_get_integer(types plus i multiplied by 8, 0)
            Let type_name_ptr be memory_get_integer(type_ptr, 0)  # type->name
            If string_equals(type_name_ptr, type_name) is equal to 1:
                Let type be type_ptr
                Let i be type_count  # break loop
            End If
            Let i be i plus 1
        End While

        If type is equal to 0:
            print_string("[CODEGEN ERROR] Unknown variant type '")
            print_string(type_name)
            print_string("'")
            print_newline()
            exit_with_code(1)
        End If

        Let kind be memory_get_integer(type, 8)  # type->kind
        If kind is not equal to 3:  # TYPE_KIND_VARIANT
            print_string("[CODEGEN ERROR] Type '")
            print_string(type_name)
            print_string("' is not a variant type")
            print_newline()
            exit_with_code(1)
        End If

        # Find the variant
        Let variant_type_ptr be type plus 16  # &type->data.variant_type
        Let variant_count be memory_get_integer(variant_type_ptr, 0)  # variant_type.variant_count
        Let variants be memory_get_integer(variant_type_ptr, 8)       # variant_type.variants
        Let variant be 0

        Let i be 0
        While i is less than variant_count:
            Let variant_ptr be variants plus i multiplied by 32  # sizeof(Variant)
            Let variant_name_ptr be memory_get_integer(variant_ptr, 0)  # variant.name
            If string_equals(variant_name_ptr, variant_name) is equal to 1:
                Let variant be variant_ptr
                Let i be variant_count  # break loop
            End If
            Let i be i plus 1
        End While

        If variant is equal to 0:
            print_string("[CODEGEN ERROR] Unknown variant '")
            print_string(variant_name)
            print_string("' in type '")
            print_string(type_name)
            print_string("'")
            print_newline()
            exit_with_code(1)
        End If

        # Allocate memory for the variant
        Let type_size be memory_get_integer(type, 16)  # type->size
        file_write(output_file, "    # Construct variant ")
        file_write(output_file, type_name)
        file_write(output_file, "::")
        file_write_line(output_file, variant_name)
        file_write(output_file, "    movq $")
        file_write(output_file, integer_to_string(type_size))
        file_write_line(output_file, ", %rdi")
        file_write_line(output_file, "    call malloc")
        file_write_line(output_file, "    pushq %rax  # Save variant pointer")

        # Store the tag (variant index)
        Let tag be memory_get_integer(variant, 8)  # variant.tag
        file_write(output_file, "    movq $")
        file_write(output_file, integer_to_string(tag))
        file_write_line(output_file, ", (%rax)  # Store variant tag")

        # Store field values
        Let variant_fields be memory_get_integer(variant, 16)  # variant.fields
        Let i be 0
        While i is less than field_count:
            # Evaluate field value
            Let field_value_ptr be memory_get_integer(field_values plus i multiplied by 8, 0)
            codegen_generate_expression(codegen, field_value_ptr)

            # Store in the variant at the right offset
            file_write_line(output_file, "    popq %rdi  # Restore variant pointer")
            file_write_line(output_file, "    pushq %rdi  # Keep it on stack")

            Let field_ptr be variant_fields plus i multiplied by 24  # sizeof(FieldDefinition)
            Let field_offset be memory_get_integer(field_ptr, 16)  # field.offset
            file_write(output_file, "    movq %rax, ")
            file_write(output_file, integer_to_string(field_offset))
            file_write(output_file, "(%rdi)  # Store field at offset ")
            file_write_line(output_file, integer_to_string(field_offset))
            Let i be i plus 1
        End While

        # Leave the variant pointer in %rax
        file_write_line(output_file, "    popq %rax  # Final variant pointer")
        Return 0
    End If

    If expr_type is equal to 13:  # EXPR_FUNCTION_POINTER
        Let function_pointer_ptr be expr plus 8  # &expr->data.function_pointer
        Let func_name be memory_get_integer(function_pointer_ptr, 0)  # function_pointer.function_name

        # Load the address of the named function
        file_write(output_file, "    leaq ")
        file_write(output_file, func_name)
        file_write_line(output_file, "(%rip), %rax  # Load function address for pointer")
        Return 0
    End If

    If expr_type is equal to 16:  # EXPR_ARRAY_INDEX
        Let array_index_ptr be expr plus 8  # &expr->data.array_index
        Let arr be memory_get_integer(array_index_ptr, 0)  # array_index.array
        Let index be memory_get_integer(array_index_ptr, 8)  # array_index.index

        # Generate code for array indexing with bounds checking
        # Evaluate index expression
        codegen_generate_expression(codegen, index)
        file_write_line(output_file, "    pushq %rax  # Save index")

        # Get array base address
        Let array_type be memory_get_integer(arr, 0)  # array->type
        If array_type is equal to 1:  # EXPR_VARIABLE
            Let array_variable_name be memory_get_integer(arr, 8)  # array->data.variable_name
            Let var_index be codegen_find_variable(codegen, array_variable_name)
            If var_index is equal to 0 minus 1:  # -1 for not found
                print_string("[CODEGEN ERROR] Undefined array '")
                print_string(array_variable_name)
                print_string("'")
                print_newline()
                exit_with_code(1)
            End If

            Let variables be memory_get_integer(codegen, 8)  # codegen->variables
            Let var_ptr be variables plus var_index multiplied by 32
            Let offset be memory_get_integer(var_ptr, 8)          # variable.stack_offset
            Let is_parameter be memory_get_integer(var_ptr, 24)   # variable.is_parameter

            # Check if this is an array parameter or local array
            If is_parameter is equal to 1:
                # For array parameters, load the pointer value
                file_write(output_file, "    movq -")
                file_write(output_file, integer_to_string(offset))
                file_write_line(output_file, "(%rbp), %rdi  # Load array parameter pointer")
            Otherwise:
                # For local arrays, get the address
                file_write(output_file, "    leaq -")
                file_write(output_file, integer_to_string(offset))
                file_write_line(output_file, "(%rbp), %rdi  # Array base address")
            End If
        Otherwise:
            # Handle complex array expressions (e.g., function return)
            codegen_generate_expression(codegen, arr)
            file_write_line(output_file, "    movq %rax, %rdi  # Array base from expression")
        End If

        # Calculate element offset (index * element_size)
        file_write_line(output_file, "    popq %rax  # Restore index")

        # For arrays, all elements are currently 8 bytes (Integer size)
        file_write_line(output_file, "    imulq $8, %rax  # index * element_size")

        # Add offset to base address
        file_write_line(output_file, "    addq %rdi, %rax  # base + offset")

        # Load value from array
        file_write_line(output_file, "    movq (%rax), %rax  # Load array element")
        Return 0
    End If

    # Unknown expression type
    print_string("[CODEGEN ERROR] Unknown expression type")
    print_newline()
    exit_with_code(1)
    Return 0
End Process

# Generate code for statement - equivalent to codegen_generate_statement
Process called "codegen_generate_statement" takes codegen as Integer, stmt as Integer returns Integer:
    Let stmt_type be memory_get_integer(stmt, 0)  # stmt->type
    Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file

    If stmt_type is equal to 0:  # STMT_LET
        # Check if this is a type allocation
        Let let_expr be memory_get_integer(stmt, 8)  # stmt->data.let_stmt.expression
        If let_expr is not equal to 0:
            Let expr_type be memory_get_integer(let_expr, 0)  # expr->type
            If expr_type is equal to 7:  # EXPR_TYPE_NAME
                # This is a struct allocation - find the type
                Let type_name be memory_get_integer(let_expr, 8)  # expr->data.type_name
                Let current_program be memory_get_integer(codegen, 40)  # codegen->current_program
                Let type_count be memory_get_integer(current_program, 32)  # program->type_count
                Let types be memory_get_integer(current_program, 40)  # program->types

                Let type_found be 0
                Let type_def be 0
                Let i be 0
                While i is less than type_count:
                    Let current_type be memory_get_integer(types, i multiplied by 8)
                    Let current_type_name be memory_get_integer(current_type, 0)  # type->name
                    If string_equals(current_type_name, type_name) is equal to 1:
                        Let type_found be 1
                        Let type_def be current_type
                        Let i be type_count  # Break
                    End If
                    Let i be i plus 1
                End While

                If type_found is equal to 0:
                    file_write(2, "[CODEGEN ERROR] Unknown type '")  # stderr
                    file_write(2, type_name)
                    file_write_line(2, "'")
                    exit_with_code(1)
                    Return 1
                End If

                # Add variable with type information
                Let variable_name be memory_get_integer(stmt, 16)  # stmt->data.let_stmt.variable_name
                codegen_add_variable_with_type(codegen, variable_name, type_name)

                # Get variable info
                Let var_index be codegen_find_variable(codegen, variable_name)
                Let variables be memory_get_integer(codegen, 8)  # codegen->variables
                Let offset be memory_get_integer(variables, var_index multiplied by 24 plus 8)  # variables[var_index].stack_offset

                # Handle different type kinds
                Let type_kind be memory_get_integer(type_def, 8)  # type->kind
                Let type_size be memory_get_integer(type_def, 16)  # type->size

                If type_kind is equal to 2:  # TYPE_KIND_ARRAY
                    # For arrays, allocate space for all elements and zero out memory
                    Let i be 0
                    While i is less than type_size:
                        file_write(output_file, "    movq $0, -")
                        file_write(output_file, integer_to_string(offset minus i))
                        file_write_line(output_file, "(%rbp)  # Zero array element")
                        Let i be i plus 8
                    End While

                    # Update stack offset to account for full array size
                    Let current_stack_offset be memory_get_integer(codegen, 16)  # codegen->stack_offset
                    memory_set_integer(codegen, 16, current_stack_offset plus type_size)
                Otherwise:
                    # For structs, zero out the struct memory
                    Let i be 0
                    While i is less than type_size:
                        file_write(output_file, "    movq $0, -")
                        file_write(output_file, integer_to_string(offset minus i))
                        file_write_line(output_file, "(%rbp)")
                        Let i be i plus 8
                    End While
                End If
            Otherwise:
                # Regular expression - add variable to symbol table
                # Check if the expression returns a string or list
                If expr_type is equal to 8:  # EXPR_BUILTIN_CALL
                    Let builtin_type be memory_get_integer(let_expr, 8)  # expr->data.builtin_call.builtin_type

                    # Check for string-returning builtins (read_file, string_substring, string_concat, integer_to_string, string_replace, string_trim)
                    Let is_string_builtin be 0
                    If builtin_type is equal to 37:
                        Let is_string_builtin be 1
                    End If
                    If builtin_type is equal to 42:
                        Let is_string_builtin be 1
                    End If
                    If builtin_type is equal to 48:
                        Let is_string_builtin be 1
                    End If
                    If builtin_type is equal to 49:
                        Let is_string_builtin be 1
                    End If
                    If builtin_type is equal to 52:
                        Let is_string_builtin be 1
                    End If
                    If builtin_type is equal to 54:
                        Let is_string_builtin be 1
                    End If
                    If is_string_builtin is equal to 1:
                        Let variable_name be memory_get_integer(stmt, 16)  # stmt->data.let_stmt.variable_name
                        codegen_add_variable_with_type(codegen, variable_name, "String")
                    Otherwise:
                        # Check for list-returning builtins (list_create, list_copy, list_merge)
                        Let is_list_builtin be 0
                        If builtin_type is equal to 19:
                            Let is_list_builtin be 1
                        End If
                        If builtin_type is equal to 31:
                            Let is_list_builtin be 1
                        End If
                        If builtin_type is equal to 32:
                            Let is_list_builtin be 1
                        End If
                        If is_list_builtin is equal to 1:
                            Let variable_name be memory_get_integer(stmt, 16)  # stmt->data.let_stmt.variable_name
                            codegen_add_variable_with_type(codegen, variable_name, "List")
                        Otherwise:
                            # Regular integer/other expression
                            Let variable_name be memory_get_integer(stmt, 16)  # stmt->data.let_stmt.variable_name
                            codegen_add_variable(codegen, variable_name)
                        End If
                    End If
                Otherwise:
                    # Regular integer/other expression
                    Let variable_name be memory_get_integer(stmt, 16)  # stmt->data.let_stmt.variable_name
                    codegen_add_variable(codegen, variable_name)
                End If

                # Generate expression (result in %rax)
                codegen_generate_expression(codegen, let_expr)

                # Store value in variable's stack slot
                Let variable_name be memory_get_integer(stmt, 16)  # stmt->data.let_stmt.variable_name
                Let var_index be codegen_find_variable(codegen, variable_name)
                Let variables be memory_get_integer(codegen, 8)  # codegen->variables
                Let offset be memory_get_integer(variables, var_index multiplied by 24 plus 8)  # variables[var_index].stack_offset
                file_write(output_file, "    movq %rax, -")
                file_write(output_file, integer_to_string(offset))
                file_write_line(output_file, "(%rbp)")
            End If
        End If
        Return 0
    End If

    If stmt_type is equal to 1:  # STMT_SET
        # Generate value expression (result in %rax)
        Let set_expr be memory_get_integer(stmt, 8)  # stmt->data.set_stmt.expression
        codegen_generate_expression(codegen, set_expr)

        # Save the value on the stack
        file_write_line(output_file, "    pushq %rax")

        # Generate the address of the target (result in %rbx)
        Let set_target be memory_get_integer(stmt, 16)  # stmt->data.set_stmt.target
        codegen_generate_lvalue_address(codegen, set_target)

        # Restore value and store to target address
        file_write_line(output_file, "    popq %rax")
        file_write_line(output_file, "    movq %rax, (%rbx)")
        Return 0
    End If

    If stmt_type is equal to 2:  # STMT_RETURN
        # Generate expression (result in %rax)
        Let return_expr be memory_get_integer(stmt, 8)  # stmt->data.return_stmt.expression
        codegen_generate_expression(codegen, return_expr)

        # Function epilogue
        file_write_line(output_file, "    movq %rbp, %rsp")
        file_write_line(output_file, "    popq %rbp")
        file_write_line(output_file, "    ret")
        Return 0
    End If

    If stmt_type is equal to 3:  # STMT_IF
        Let label_counter be memory_get_integer(codegen, 20)  # codegen->label_counter
        Let label_num be label_counter
        memory_set_integer(codegen, 20, label_counter plus 1)

        Let else_label be label_num multiplied by 10 plus 1
        Let end_label be label_num multiplied by 10 plus 2

        # Generate condition (result in %rax)
        Let condition_expr be memory_get_integer(stmt, 8)  # stmt->data.if_stmt.condition
        codegen_generate_expression(codegen, condition_expr)

        # Test if condition is false (0)
        file_write_line(output_file, "    testq %rax, %rax")
        file_write(output_file, "    jz .L")
        file_write(output_file, integer_to_string(else_label))
        file_write_line(output_file, "")

        # Generate if body
        Let if_body_count be memory_get_integer(stmt, 16)  # stmt->data.if_stmt.if_body_count
        Let if_body be memory_get_integer(stmt, 24)  # stmt->data.if_stmt.if_body
        Let i be 0
        While i is less than if_body_count:
            Let current_stmt be memory_get_integer(if_body, i multiplied by 8)
            codegen_generate_statement(codegen, current_stmt)
            Let i be i plus 1
        End While

        file_write(output_file, "    jmp .L")
        file_write(output_file, integer_to_string(end_label))
        file_write_line(output_file, "")

        # Generate else body
        file_write(output_file, ".L")
        file_write(output_file, integer_to_string(else_label))
        file_write_line(output_file, ":")

        Let else_body_count be memory_get_integer(stmt, 32)  # stmt->data.if_stmt.else_body_count
        Let else_body be memory_get_integer(stmt, 40)  # stmt->data.if_stmt.else_body
        Let i be 0
        While i is less than else_body_count:
            Let current_stmt be memory_get_integer(else_body, i multiplied by 8)
            codegen_generate_statement(codegen, current_stmt)
            Let i be i plus 1
        End While

        file_write(output_file, ".L")
        file_write(output_file, integer_to_string(end_label))
        file_write_line(output_file, ":")
        Return 0
    End If

    If stmt_type is equal to 4:  # STMT_WHILE
        Let label_counter be memory_get_integer(codegen, 20)  # codegen->label_counter
        Let label_num be label_counter
        memory_set_integer(codegen, 20, label_counter plus 1)

        Let loop_start be label_num multiplied by 10 plus 1
        Let loop_end be label_num multiplied by 10 plus 2

        # Push loop context for break/continue statements
        codegen_push_loop_context(codegen, loop_start, loop_end)

        # Loop start label
        file_write(output_file, ".L")
        file_write(output_file, integer_to_string(loop_start))
        file_write_line(output_file, ":")

        # Generate condition (result in %rax)
        Let condition_expr be memory_get_integer(stmt, 8)  # stmt->data.while_stmt.condition
        codegen_generate_expression(codegen, condition_expr)

        # Test if condition is false (0)
        file_write_line(output_file, "    testq %rax, %rax")
        file_write(output_file, "    jz .L")
        file_write(output_file, integer_to_string(loop_end))
        file_write_line(output_file, "")

        # Generate loop body
        Let body_count be memory_get_integer(stmt, 16)  # stmt->data.while_stmt.body_count
        Let body be memory_get_integer(stmt, 24)  # stmt->data.while_stmt.body
        Let i be 0
        While i is less than body_count:
            Let current_stmt be memory_get_integer(body, i multiplied by 8)
            codegen_generate_statement(codegen, current_stmt)
            Let i be i plus 1
        End While

        # Jump back to loop start
        file_write(output_file, "    jmp .L")
        file_write(output_file, integer_to_string(loop_start))
        file_write_line(output_file, "")

        # Loop end label
        file_write(output_file, ".L")
        file_write(output_file, integer_to_string(loop_end))
        file_write_line(output_file, ":")

        # Pop loop context
        codegen_pop_loop_context(codegen)
        Return 0
    End If

    If stmt_type is equal to 5:  # STMT_BREAK
        Let loop_ctx be codegen_current_loop_context(codegen)
        If loop_ctx is not equal to 0:
            Let break_label be memory_get_integer(loop_ctx, 8)  # loop_ctx->break_label
            file_write(output_file, "    jmp .L")
            file_write(output_file, integer_to_string(break_label))
            file_write_line(output_file, "")
        Otherwise:
            file_write_line(2, "[CODEGEN ERROR] Break statement outside of loop")  # stderr
            exit_with_code(1)
        End If
        Return 0
    End If

    If stmt_type is equal to 6:  # STMT_CONTINUE
        Let loop_ctx be codegen_current_loop_context(codegen)
        If loop_ctx is not equal to 0:
            Let continue_label be memory_get_integer(loop_ctx, 0)  # loop_ctx->continue_label
            file_write(output_file, "    jmp .L")
            file_write(output_file, integer_to_string(continue_label))
            file_write_line(output_file, "")
        Otherwise:
            file_write_line(2, "[CODEGEN ERROR] Continue statement outside of loop")  # stderr
            exit_with_code(1)
        End If
        Return 0
    End If

    If stmt_type is equal to 7:  # STMT_INLINE_ASSEMBLY
        # Generate raw assembly instructions
        Let assembly_line_count be memory_get_integer(stmt, 8)  # stmt->data.inline_assembly_stmt.assembly_line_count
        Let assembly_lines be memory_get_integer(stmt, 16)  # stmt->data.inline_assembly_stmt.assembly_lines

        Let i be 0
        While i is less than assembly_line_count:
            Let instruction be memory_get_integer(assembly_lines, i multiplied by 8)

            # Process escape sequences (especially \n)
            Let instruction_len be string_length(instruction)
            Let processed be allocate(instruction_len plus 1)
            Let src be 0
            Let dst be 0
            While src is less than instruction_len:
                Let current_char be string_char_at(instruction, src)
                If current_char is equal to 92:  # '\' character
                    If src plus 1 is less than instruction_len:
                        Let next_char be string_char_at(instruction, src plus 1)
                        If next_char is equal to 110:  # 'n' character
                            # Skip the \n escape sequence - we don't need newlines in assembly instructions
                            Let src be src plus 2
                        Otherwise:
                            If next_char is equal to 116:  # 't' character
                                memory_set_byte(processed, dst, 9)  # Tab character
                                Let dst be dst plus 1
                                Let src be src plus 2
                            Otherwise:
                                If next_char is equal to 92:  # '\' character
                                    memory_set_byte(processed, dst, 92)  # '\' character
                                    Let dst be dst plus 1
                                    Let src be src plus 2
                                Otherwise:
                                    memory_set_byte(processed, dst, current_char)
                                    Let dst be dst plus 1
                                    Let src be src plus 1
                                End If
                            End If
                        End If
                    Otherwise:
                        memory_set_byte(processed, dst, current_char)
                        Let dst be dst plus 1
                        Let src be src plus 1
                    End If
                Otherwise:
                    memory_set_byte(processed, dst, current_char)
                    Let dst be dst plus 1
                    Let src be src plus 1
                End If
            End While
            memory_set_byte(processed, dst, 0)  # Null terminator

            file_write(output_file, "    ")
            file_write(output_file, processed)
            file_write_line(output_file, "")

            deallocate(processed)
            Let i be i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 8:  # STMT_PRINT
        # Generate expression (result in %rax)
        Let print_expr be memory_get_integer(stmt, 8)  # stmt->data.print_stmt.expression
        codegen_generate_expression(codegen, print_expr)

        # Call appropriate print function based on expression type
        Let expr_type be memory_get_integer(print_expr, 0)  # expr->type
        If expr_type is equal to 5:  # EXPR_STRING_LITERAL
            # String literal - call print_string
            file_write_line(output_file, "    movq %rax, %rdi")
            file_write_line(output_file, "    call print_string")
        Otherwise:
            If expr_type is equal to 8:  # EXPR_BUILTIN_CALL
                Let builtin_type be memory_get_integer(print_expr, 8)  # expr->data.builtin_call.builtin_type
                # Check for string-returning builtins (read_file, string_substring, string_concat, integer_to_string, string_replace, string_trim)
                Let is_string_builtin be 0
                If builtin_type is equal to 37:
                    Let is_string_builtin be 1
                End If
                If builtin_type is equal to 42:
                    Let is_string_builtin be 1
                End If
                If builtin_type is equal to 48:
                    Let is_string_builtin be 1
                End If
                If builtin_type is equal to 49:
                    Let is_string_builtin be 1
                End If
                If builtin_type is equal to 52:
                    Let is_string_builtin be 1
                End If
                If builtin_type is equal to 54:
                    Let is_string_builtin be 1
                End If
                If is_string_builtin is equal to 1:
                    # These functions return strings - call print_string
                    file_write_line(output_file, "    movq %rax, %rdi")
                    file_write_line(output_file, "    call print_string")
                Otherwise:
                    # Integer expression - call print_integer
                    file_write_line(output_file, "    movq %rax, %rdi")
                    file_write_line(output_file, "    call print_integer")
                End If
            Otherwise:
                If expr_type is equal to 1:  # EXPR_VARIABLE
                    # Check variable type to determine appropriate print function
                    Let variable_name be memory_get_integer(print_expr, 8)  # expr->data.variable_name
                    Let var_index be codegen_find_variable(codegen, variable_name)
                    If var_index is not equal to 0 minus 1:
                        Let variables be memory_get_integer(codegen, 8)  # codegen->variables
                        Let type_name be memory_get_integer(variables, var_index multiplied by 24 plus 16)  # variables[var_index].type_name
                        If type_name is not equal to 0:
                            If string_equals(type_name, "String") is equal to 1:
                                # This variable contains a string - call print_string
                                file_write_line(output_file, "    movq %rax, %rdi")
                                file_write_line(output_file, "    call print_string")
                            Otherwise:
                                If string_equals(type_name, "List") is equal to 1:
                                    # This variable contains a list pointer - print as integer address
                                    file_write_line(output_file, "    movq %rax, %rdi")
                                    file_write_line(output_file, "    call print_integer")
                                Otherwise:
                                    # Assume integer for other variables
                                    file_write_line(output_file, "    movq %rax, %rdi")
                                    file_write_line(output_file, "    call print_integer")
                                End If
                            End If
                        Otherwise:
                            # Assume integer for untyped variables
                            file_write_line(output_file, "    movq %rax, %rdi")
                            file_write_line(output_file, "    call print_integer")
                        End If
                    Otherwise:
                        # Variable not found, assume integer
                        file_write_line(output_file, "    movq %rax, %rdi")
                        file_write_line(output_file, "    call print_integer")
                    End If
                Otherwise:
                    # Integer expression (literal, arithmetic) - call print_integer
                    file_write_line(output_file, "    movq %rax, %rdi")
                    file_write_line(output_file, "    call print_integer")
                End If
            End If
        End If
        Return 0
    End If

    If stmt_type is equal to 9:  # STMT_EXPRESSION
        # Generate the expression and ignore its result
        Let expr_stmt_expr be memory_get_integer(stmt, 8)  # stmt->data.expr_stmt.expression
        codegen_generate_expression(codegen, expr_stmt_expr)
        Return 0
    End If

    If stmt_type is equal to 10:  # STMT_IMPORT
        # Imports are handled at program level, no code generation needed
        Return 0
    End If

    If stmt_type is equal to 11:  # STMT_MATCH
        # Evaluate the expression to match on
        Let match_expr be memory_get_integer(stmt, 8)  # stmt->data.match_stmt.expression
        codegen_generate_expression(codegen, match_expr)
        file_write_line(output_file, "    pushq %rax  # Save match expression value")

        # Generate unique labels for each case and the end
        Let label_counter be memory_get_integer(codegen, 20)  # codegen->label_counter
        Let match_id be label_counter
        memory_set_integer(codegen, 20, label_counter plus 1)

        Let end_label be string_concat(".match_end_", integer_to_string(match_id))

        # Generate code for each case
        Let case_count be memory_get_integer(stmt, 16)  # stmt->data.match_stmt.case_count
        Let cases be memory_get_integer(stmt, 24)  # stmt->data.match_stmt.cases

        Let i be 0
        While i is less than case_count:
            Let match_case be cases plus i multiplied by 64  # sizeof(MatchCase) estimate
            Let variant_name be memory_get_integer(match_case, 0)  # match_case->variant_name
            Let field_count be memory_get_integer(match_case, 8)  # match_case->field_count
            Let field_names be memory_get_integer(match_case, 16)  # match_case->field_names
            Let body_count be memory_get_integer(match_case, 24)  # match_case->body_count
            Let body be memory_get_integer(match_case, 32)  # match_case->body

            Let case_label be string_concat(".match_case_", string_concat(integer_to_string(match_id), string_concat("_", integer_to_string(i))))
            Let next_case_id be i plus 1
            Let next_label be string_concat(".match_case_", string_concat(integer_to_string(match_id), string_concat("_", integer_to_string(next_case_id))))

            # Check if this case matches
            file_write(output_file, case_label)
            file_write_line(output_file, ":")
            file_write_line(output_file, "    popq %rax  # Get match expression")
            file_write_line(output_file, "    pushq %rax  # Keep on stack")

            # Load the tag from the variant
            file_write_line(output_file, "    movq (%rax), %rdx  # Load variant tag")

            # Find the tag value for this variant name - ADT variant tags are sequential starting from 0
            file_write(output_file, "    cmpq $")
            file_write(output_file, integer_to_string(i))
            file_write(output_file, ", %rdx  # Check tag for ")
            file_write(output_file, variant_name)
            file_write_line(output_file, "")

            If i is less than case_count minus 1:
                file_write(output_file, "    jne ")
                file_write(output_file, next_label)
                file_write_line(output_file, "  # Jump to next case")
            Otherwise:
                file_write(output_file, "    jne ")
                file_write(output_file, end_label)
                file_write_line(output_file, "  # No match, exit")
            End If

            # If we matched, extract fields and bind to local variables
            If field_count is greater than 0:
                # Pop the variant pointer
                file_write_line(output_file, "    popq %rax  # Get variant pointer")
                file_write_line(output_file, "    pushq %rax  # Keep on stack")

                # ADT fields start at offset 8 (after tag) with 8 bytes per field
                Let j be 0
                While j is less than field_count:
                    Let field_offset be 8 plus j multiplied by 8
                    file_write(output_file, "    movq ")
                    file_write(output_file, integer_to_string(field_offset))
                    file_write(output_file, "(%rax), %rdx  # Load field ")
                    file_write(output_file, integer_to_string(j))
                    file_write_line(output_file, "")

                    # Create a local variable for the binding - allocate stack space properly
                    Let current_stack_offset be memory_get_integer(codegen, 16)  # codegen->stack_offset
                    Let new_stack_offset be current_stack_offset plus 8
                    memory_set_integer(codegen, 16, new_stack_offset)

                    file_write(output_file, "    movq %rdx, -")
                    file_write(output_file, integer_to_string(new_stack_offset))
                    Let field_name be memory_get_integer(field_names, j multiplied by 8)
                    file_write(output_file, "(%rbp)  # Store ")
                    file_write(output_file, field_name)
                    file_write_line(output_file, " at stack offset")

                    # Add the binding to the variable table with correct offset
                    Let variable_count be memory_get_integer(codegen, 12)  # codegen->variable_count
                    Let variable_capacity be memory_get_integer(codegen, 32)  # codegen->variable_capacity
                    If variable_count is greater than or equal to variable_capacity:
                        Let new_capacity be variable_capacity multiplied by 2
                        memory_set_integer(codegen, 32, new_capacity)
                        Let variables be memory_get_integer(codegen, 8)  # codegen->variables
                        Let new_variables be reallocate(variables, new_capacity multiplied by 24)  # sizeof(Variable) = 24
                        memory_set_integer(codegen, 8, new_variables)
                    End If

                    Let variables be memory_get_integer(codegen, 8)  # codegen->variables
                    Let var_idx_offset be variable_count multiplied by 24
                    memory_set_integer(variables, var_idx_offset, string_duplicate(field_name))  # name
                    memory_set_integer(variables, var_idx_offset plus 8, new_stack_offset)  # stack_offset
                    memory_set_integer(variables, var_idx_offset plus 16, string_duplicate("Integer"))  # type_name
                    memory_set_integer(codegen, 12, variable_count plus 1)  # Increment variable_count

                    Let j be j plus 1
                End While
            End If

            # Generate the case body
            Let k be 0
            While k is less than body_count:
                Let current_stmt be memory_get_integer(body, k multiplied by 8)
                codegen_generate_statement(codegen, current_stmt)
                Let k be k plus 1
            End While

            # Clean up bindings from variable table but keep stack offset
            If field_count is greater than 0:
                # Free the variable names we allocated
                Let j be 0
                While j is less than field_count:
                    Let variable_count be memory_get_integer(codegen, 12)  # codegen->variable_count
                    Let var_idx be variable_count minus field_count plus j
                    Let variables be memory_get_integer(codegen, 8)  # codegen->variables
                    Let var_name be memory_get_integer(variables, var_idx multiplied by 24)
                    Let var_type_name be memory_get_integer(variables, var_idx multiplied by 24 plus 16)
                    deallocate(var_name)
                    deallocate(var_type_name)
                    Let j be j plus 1
                End While
                # Remove from variable table
                Let variable_count be memory_get_integer(codegen, 12)  # codegen->variable_count
                memory_set_integer(codegen, 12, variable_count minus field_count)
            End If

            # Jump to end
            file_write(output_file, "    jmp ")
            file_write(output_file, end_label)
            file_write_line(output_file, "")

            Let i be i plus 1
        End While

        file_write(output_file, end_label)
        file_write_line(output_file, ":")
        file_write_line(output_file, "    popq %rax  # Clean up match expression")
        Return 0
    End If

    Return 0
End Process

# Create a new code generator - equivalent to codegen_create
Process called "codegen_create" takes output_filename as Integer returns Integer:
    Let codegen be allocate(64)  # sizeof(CodeGenerator) estimate

    Let output_file be file_open(output_filename, "w")
    memory_set_integer(codegen, 0, output_file)  # codegen->output_file

    memory_set_integer(codegen, 12, 0)  # codegen->variable_count
    memory_set_integer(codegen, 32, 16)  # codegen->variable_capacity - Start with space for 16 variables
    Let variables be allocate(16 multiplied by 24)  # 16 * sizeof(Variable)
    memory_set_integer(codegen, 8, variables)  # codegen->variables

    memory_set_integer(codegen, 16, 0)  # codegen->stack_offset
    memory_set_integer(codegen, 20, 0)  # codegen->label_counter
    memory_set_integer(codegen, 24, 0)  # codegen->string_count
    memory_set_integer(codegen, 28, 32)  # codegen->string_capacity - Start with space for 32 strings
    Let strings be allocate(32 multiplied by 16)  # 32 * sizeof(StringLiteral)
    memory_set_integer(codegen, 56, strings)  # codegen->strings

    memory_set_integer(codegen, 40, 0)  # codegen->current_program
    memory_set_integer(codegen, 44, 0)  # codegen->loop_depth
    memory_set_integer(codegen, 48, 8)  # codegen->loop_capacity - Start with space for 8 nested loops
    Let loop_stack be allocate(8 multiplied by 16)  # 8 * sizeof(LoopContext)
    memory_set_integer(codegen, 52, loop_stack)  # codegen->loop_stack

    If output_file is equal to 0:
        file_write(2, "[CODEGEN ERROR] Could not open output file '")  # stderr
        file_write(2, output_filename)
        file_write_line(2, "'")
        deallocate(variables)
        deallocate(strings)
        deallocate(loop_stack)
        deallocate(codegen)
        Return 0
    End If

    Return codegen
End Process

# Destroy a code generator - equivalent to codegen_destroy
Process called "codegen_destroy" takes codegen as Integer returns Integer:
    If codegen is not equal to 0:
        Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file
        If output_file is not equal to 0:
            file_close(output_file)
        End If

        # Free variable names and type names
        Let variable_count be memory_get_integer(codegen, 12)  # codegen->variable_count
        Let variables be memory_get_integer(codegen, 8)  # codegen->variables
        Let i be 0
        While i is less than variable_count:
            Let var_name be memory_get_integer(variables, i multiplied by 24)
            Let var_type_name be memory_get_integer(variables, i multiplied by 24 plus 16)
            deallocate(var_name)
            deallocate(var_type_name)
            Let i be i plus 1
        End While

        # Free string literal values and labels
        Let string_count be memory_get_integer(codegen, 24)  # codegen->string_count
        Let strings be memory_get_integer(codegen, 56)  # codegen->strings
        Let i be 0
        While i is less than string_count:
            Let str_value be memory_get_integer(strings, i multiplied by 16)
            Let str_label be memory_get_integer(strings, i multiplied by 16 plus 8)
            deallocate(str_value)
            deallocate(str_label)
            Let i be i plus 1
        End While

        deallocate(variables)
        deallocate(strings)
        Let loop_stack be memory_get_integer(codegen, 52)  # codegen->loop_stack
        deallocate(loop_stack)
        deallocate(codegen)
    End If
    Return 0
End Process

# Push a new loop context for break/continue handling - equivalent to codegen_push_loop_context
Process called "codegen_push_loop_context" takes codegen as Integer, continue_label as Integer, break_label as Integer returns Integer:
    Let loop_depth be memory_get_integer(codegen, 44)  # codegen->loop_depth
    Let loop_capacity be memory_get_integer(codegen, 48)  # codegen->loop_capacity

    # Expand loop stack if necessary
    If loop_depth is greater than or equal to loop_capacity:
        Let new_capacity be loop_capacity multiplied by 2
        memory_set_integer(codegen, 48, new_capacity)
        Let loop_stack be memory_get_integer(codegen, 52)  # codegen->loop_stack
        Let new_loop_stack be reallocate(loop_stack, 16 multiplied by new_capacity)  # sizeof(LoopContext) * new_capacity
        memory_set_integer(codegen, 52, new_loop_stack)
    End If

    Let loop_stack be memory_get_integer(codegen, 52)  # codegen->loop_stack
    Let context_offset be loop_depth multiplied by 16  # sizeof(LoopContext)
    memory_set_integer(loop_stack, context_offset, continue_label)  # continue_label
    memory_set_integer(loop_stack, context_offset plus 8, break_label)  # break_label
    memory_set_integer(codegen, 44, loop_depth plus 1)  # Increment loop_depth
    Return 0
End Process

# Pop the current loop context - equivalent to codegen_pop_loop_context
Process called "codegen_pop_loop_context" takes codegen as Integer returns Integer:
    Let loop_depth be memory_get_integer(codegen, 44)  # codegen->loop_depth
    If loop_depth is greater than 0:
        memory_set_integer(codegen, 44, loop_depth minus 1)
    End If
    Return 0
End Process

# Get the current loop context - equivalent to codegen_current_loop_context
Process called "codegen_current_loop_context" takes codegen as Integer returns Integer:
    Let loop_depth be memory_get_integer(codegen, 44)  # codegen->loop_depth
    If loop_depth is greater than 0:
        Let loop_stack be memory_get_integer(codegen, 52)  # codegen->loop_stack
        Let context_offset be loop_depth minus 1 multiplied by 16  # sizeof(LoopContext)
        Return loop_stack plus context_offset
    End If
    Return 0  # NULL
End Process

# Generate code for a function - equivalent to codegen_generate_function
Process called "codegen_generate_function" takes codegen as Integer, func as Integer returns Integer:
    # Reset variable state for each function
    memory_set_integer(codegen, 12, 0)  # codegen->variable_count = 0
    memory_set_integer(codegen, 16, 0)  # codegen->stack_offset = 0
    memory_set_integer(codegen, 44, 0)  # codegen->loop_depth = 0

    Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file
    Let func_name be memory_get_integer(func, 0)  # func->name

    # Export function as global symbol for cross-module linking
    file_write(output_file, ".globl ")
    file_write(output_file, func_name)
    file_write_line(output_file, "")

    # Function label
    file_write(output_file, func_name)
    file_write_line(output_file, ":")

    # Function prologue
    file_write_line(output_file, "    pushq %rbp")
    file_write_line(output_file, "    movq %rsp, %rbp")

    # Handle parameters (System V ABI: %rdi, %rsi, %rdx, %rcx, %r8, %r9)
    Let param_registers be allocate(6 multiplied by 8)  # Array of 6 string pointers
    memory_set_integer(param_registers, 0, "%rdi")
    memory_set_integer(param_registers, 8, "%rsi")
    memory_set_integer(param_registers, 16, "%rdx")
    memory_set_integer(param_registers, 24, "%rcx")
    memory_set_integer(param_registers, 32, "%r8")
    memory_set_integer(param_registers, 40, "%r9")
    Let max_register_params be 6

    Let parameter_count be memory_get_integer(func, 16)  # func->parameter_count

    # If this is main function with argc/argv parameters, initialize command line args
    If string_equals(func_name, "main") is equal to 1:
        If parameter_count is greater than or equal to 2:
            # Store original argc and argv before processing them as Runa parameters
            file_write_line(output_file, "    # Initialize command line arguments")
            file_write_line(output_file, "    pushq %rdi  # Save argc")
            file_write_line(output_file, "    pushq %rsi  # Save argv")
            file_write_line(output_file, "    call runtime_set_command_line_args@PLT")
            file_write_line(output_file, "    popq %rsi   # Restore argv")
            file_write_line(output_file, "    popq %rdi   # Restore argc")
            file_write_line(output_file, "")
        End If
    End If

    # CRITICAL FIX: Allocate stack space BEFORE any stack access to prevent Valgrind violations
    # Pre-allocate generous stack space for all function variables and temporaries
    file_write_line(output_file, "    subq $512, %rsp  # Pre-allocate generous stack space")
    file_write_line(output_file, "          ")

    Let parameters be memory_get_integer(func, 24)  # func->parameters
    Let i be 0
    Let should_continue be 1
    While should_continue is equal to 1:
        If i is greater than or equal to parameter_count:
            Let should_continue be 0
        End If
        If i is greater than or equal to max_register_params:
            Let should_continue be 0
        End If
        If should_continue is equal to 1:
        # Add parameter as a variable and store from appropriate register
        # Use the parameter type from the function definition
        Let param_offset be i multiplied by 16  # sizeof(Parameter)
        Let param_name be memory_get_integer(parameters, param_offset)  # parameters[i].name
        Let param_type be memory_get_integer(parameters, param_offset plus 8)  # parameters[i].type
        If param_type is equal to 0:
            Let param_type be "Integer"  # Default type
        End If

        Let param_index be codegen_add_variable_with_type_and_param_flag(codegen, param_name, param_type, 1)  # Mark as parameter
        Let variables be memory_get_integer(codegen, 8)  # codegen->variables
        Let param_stack_offset be memory_get_integer(variables, param_index multiplied by 24 plus 8)  # variables[param_index].stack_offset
        Let register_name be memory_get_integer(param_registers, i multiplied by 8)
        file_write(output_file, "    movq ")
        file_write(output_file, register_name)
        file_write(output_file, ", -")
        file_write(output_file, integer_to_string(param_stack_offset))
        file_write_line(output_file, "(%rbp)")

        Let i be i plus 1
        End If  # End of should_continue check
    End While

    # Handle parameters beyond 6 (passed on stack in System V ABI)
    Let i be max_register_params
    While i is less than parameter_count:
        Let param_offset be i multiplied by 16  # sizeof(Parameter)
        Let param_name be memory_get_integer(parameters, param_offset)  # parameters[i].name
        Let param_type be memory_get_integer(parameters, param_offset plus 8)  # parameters[i].type
        Let param_index be codegen_add_variable_with_type_and_param_flag(codegen, param_name, param_type, 1)  # Mark as parameter
        Let variables be memory_get_integer(codegen, 8)  # codegen->variables
        Let param_stack_offset be memory_get_integer(variables, param_index multiplied by 24 plus 8)  # variables[param_index].stack_offset

        # Stack parameters are at positive offsets from rbp: 16(%rbp), 24(%rbp), etc.
        Let stack_param_offset be 16 plus i minus max_register_params multiplied by 8
        file_write(output_file, "    movq ")
        file_write(output_file, integer_to_string(stack_param_offset))
        file_write_line(output_file, "(%rbp), %rax")
        file_write(output_file, "    movq %rax, -")
        file_write(output_file, integer_to_string(param_stack_offset))
        file_write_line(output_file, "(%rbp)")

        Let i be i plus 1
    End While

    # Generate function body statements
    Let statement_count be memory_get_integer(func, 32)  # func->statement_count
    Let statements be memory_get_integer(func, 40)  # func->statements
    Let i be 0
    While i is less than statement_count:
        Let current_stmt be memory_get_integer(statements, i multiplied by 8)
        codegen_generate_statement(codegen, current_stmt)
        Let i be i plus 1
    End While

    deallocate(param_registers)
    Return 0
End Process

# Main code generation entry point - equivalent to codegen_generate
Process called "codegen_generate" takes codegen as Integer, program as Integer returns Integer:
    # Store program reference for type lookups
    memory_set_integer(codegen, 40, program)  # codegen->current_program = program

    Let output_file be memory_get_integer(codegen, 0)  # codegen->output_file
    Let import_count be memory_get_integer(program, 8)  # program->import_count

    # Generate import comments (for documentation)
    If import_count is greater than 0:
        file_write_line(output_file, "# Imports:")
        Let imports be memory_get_integer(program, 16)  # program->imports
        Let i be 0
        While i is less than import_count:
            Let import be memory_get_integer(imports, i multiplied by 8)
            Let import_filename be memory_get_integer(import, 0)  # import->filename
            Let module_name be memory_get_integer(import, 8)  # import->module_name
            file_write(output_file, "#   Import ")
            file_write(output_file, import_filename)
            file_write(output_file, " as ")
            file_write(output_file, module_name)
            file_write_line(output_file, "")
            Let i be i plus 1
        End While
        file_write_line(output_file, "")
    End If

    # First pass: collect all string literals by analyzing the AST
    Let function_count be memory_get_integer(program, 48)  # program->function_count
    Let functions be memory_get_integer(program, 56)  # program->functions
    Let i be 0
    While i is less than function_count:
        Let func be memory_get_integer(functions, i multiplied by 8)
        Let statement_count be memory_get_integer(func, 32)  # func->statement_count
        Let statements be memory_get_integer(func, 40)  # func->statements
        Let j be 0
        While j is less than statement_count:
            Let stmt be memory_get_integer(statements, j multiplied by 8)
            codegen_collect_strings_from_statement(codegen, stmt)
            Let j be j plus 1
        End While
        Let i be i plus 1
    End While

    # Generate .rodata section with string literals
    Let string_count be memory_get_integer(codegen, 24)  # codegen->string_count
    If string_count is greater than 0:
        file_write_line(output_file, ".section .rodata")
        Let strings be memory_get_integer(codegen, 56)  # codegen->strings
        Let i be 0
        While i is less than string_count:
            Let str_label be memory_get_integer(strings, i multiplied by 16 plus 8)  # strings[i].label
            Let str_value be memory_get_integer(strings, i multiplied by 16)  # strings[i].value
            file_write(output_file, str_label)
            file_write_line(output_file, ":")
            file_write(output_file, "    .string ")
            file_write(output_file, character_to_string(34))  # ASCII 34 is double quote
            file_write(output_file, str_value)
            file_write_line(output_file, character_to_string(34))  # ASCII 34 is double quote
            Let i be i plus 1
        End While
        file_write_line(output_file, "")
    End If

    # Generate .data section for initialized global variables
    Let global_count be memory_get_integer(program, 24)  # program->global_count
    Let globals be memory_get_integer(program, 32)  # program->globals
    Let has_initialized_globals be 0
    Let i be 0
    While i is less than global_count:
        Let global be memory_get_integer(globals, i multiplied by 8)
        Let initial_value be memory_get_integer(global, 16)  # global->initial_value
        If initial_value is not equal to 0:
            Let has_initialized_globals be 1
            Let i be global_count  # Break
        End If
        Let i be i plus 1
    End While

    If has_initialized_globals is equal to 1:
        file_write_line(output_file, ".section .data")
        Let i be 0
        While i is less than global_count:
            Let global be memory_get_integer(globals, i multiplied by 8)
            Let global_name be memory_get_integer(global, 0)  # global->name
            Let initial_value be memory_get_integer(global, 16)  # global->initial_value
            If initial_value is not equal to 0:
                file_write(output_file, ".globl ")
                file_write(output_file, global_name)
                file_write_line(output_file, "")
                file_write(output_file, global_name)
                file_write_line(output_file, ":")

                # Handle global variable initialization values
                Let expr_type be memory_get_integer(initial_value, 0)  # initial_value->type
                If expr_type is equal to 0:  # EXPR_INTEGER
                    Let integer_value be memory_get_integer(initial_value, 8)  # initial_value->data.integer_value
                    file_write(output_file, "    .quad ")
                    file_write(output_file, integer_to_string(integer_value))
                    file_write_line(output_file, "")
                Otherwise:
                    # Non-constant expressions default to zero initialization
                    file_write_line(output_file, "    .quad 0  # Non-constant initializer defaults to 0")
                End If
            End If
            Let i be i plus 1
        End While
        file_write_line(output_file, "")
    End If

    # Generate .bss section for uninitialized global variables
    Let has_uninitialized_globals be 0
    Let i be 0
    While i is less than global_count:
        Let global be memory_get_integer(globals, i multiplied by 8)
        Let initial_value be memory_get_integer(global, 16)  # global->initial_value
        If initial_value is equal to 0:
            Let has_uninitialized_globals be 1
            Let i be global_count  # Break
        End If
        Let i be i plus 1
    End While

    If has_uninitialized_globals is equal to 1:
        file_write_line(output_file, ".section .bss")
        Let i be 0
        While i is less than global_count:
            Let global be memory_get_integer(globals, i multiplied by 8)
            Let global_name be memory_get_integer(global, 0)  # global->name
            Let initial_value be memory_get_integer(global, 16)  # global->initial_value
            If initial_value is equal to 0:
                file_write(output_file, ".globl ")
                file_write(output_file, global_name)
                file_write_line(output_file, "")
                file_write(output_file, global_name)
                file_write_line(output_file, ":")
                file_write_line(output_file, "    .zero 8  # 8 bytes for Integer")
            End If
            Let i be i plus 1
        End While
        file_write_line(output_file, "")
    End If

    # Generate .text section
    file_write_line(output_file, ".text")

    # Add print_string runtime function
    file_write_line(output_file, "print_string:")
    file_write_line(output_file, "    pushq %rbp")
    file_write_line(output_file, "    movq %rsp, %rbp")
    file_write_line(output_file, "    ")
    file_write_line(output_file, "    # Calculate string length")
    file_write_line(output_file, "    movq %rdi, %rsi  # Save string pointer")
    file_write_line(output_file, "    movq %rdi, %rcx  # Counter for strlen")
    file_write_line(output_file, "    xorq %rax, %rax  # Length accumulator")
    file_write_line(output_file, ".strlen_loop:")
    file_write_line(output_file, "    cmpb $0, (%rcx)")
    file_write_line(output_file, "    je .strlen_done")
    file_write_line(output_file, "    incq %rcx")
    file_write_line(output_file, "    incq %rax")
    file_write_line(output_file, "    jmp .strlen_loop")
    file_write_line(output_file, ".strlen_done:")
    file_write_line(output_file, "    ")
    file_write_line(output_file, "    # Call write syscall (sys_write = 1)")
    file_write_line(output_file, "    movq $1, %rdi     # fd = stdout")
    file_write_line(output_file, "    movq %rsi, %rsi   # buf = string pointer (already in rsi)")
    file_write_line(output_file, "    movq %rax, %rdx   # count = string length")
    file_write_line(output_file, "    movq $1, %rax     # syscall number for write")
    file_write_line(output_file, "    syscall")
    file_write_line(output_file, "    ")
    file_write_line(output_file, "    # Print newline")
    file_write_line(output_file, "    movq $1, %rdi     # fd = stdout")
    file_write_line(output_file, "    leaq .newline(%rip), %rsi  # newline string")
    file_write_line(output_file, "    movq $1, %rdx     # count = 1")
    file_write_line(output_file, "    movq $1, %rax     # syscall number for write")
    file_write_line(output_file, "    syscall")
    file_write_line(output_file, "    ")
    file_write_line(output_file, "    popq %rbp")
    file_write_line(output_file, "    ret")
    file_write_line(output_file, "")

    # Add print_integer runtime function
    file_write_line(output_file, "print_integer:")
    file_write_line(output_file, "    pushq %rbp")
    file_write_line(output_file, "    movq %rsp, %rbp")
    file_write_line(output_file, "    subq $32, %rsp  # Space for string buffer (20 digits + null)")
    file_write_line(output_file, "    ")
    file_write_line(output_file, "    # Convert integer to string")
    file_write_line(output_file, "    movq %rdi, %rax  # integer value")
    file_write_line(output_file, "    leaq -32(%rbp), %rsi  # buffer pointer")
    file_write_line(output_file, "    addq $19, %rsi  # point to end of buffer (for reverse building)")
    file_write_line(output_file, "    movb $0, (%rsi)  # null terminator")
    file_write_line(output_file, "    decq %rsi")
    file_write_line(output_file, "    ")
    file_write_line(output_file, "    # Handle zero case")
    file_write_line(output_file, "    testq %rax, %rax")
    file_write_line(output_file, "    jnz .convert_loop")
    file_write_line(output_file, "    movb $48, (%rsi)  # '0' character")
    file_write_line(output_file, "    jmp .convert_done")
    file_write_line(output_file, "    ")
    file_write_line(output_file, ".convert_loop:")
    file_write_line(output_file, "    testq %rax, %rax")
    file_write_line(output_file, "    jz .convert_done")
    file_write_line(output_file, "    movq %rax, %rcx")
    file_write_line(output_file, "    movq $10, %rbx")
    file_write_line(output_file, "    xorq %rdx, %rdx")
    file_write_line(output_file, "    divq %rbx  # %rax = quotient, %rdx = remainder")
    file_write_line(output_file, "    addq $48, %rdx  # convert remainder to ASCII")
    file_write_line(output_file, "    movb %dl, (%rsi)  # store digit")
    file_write_line(output_file, "    decq %rsi")
    file_write_line(output_file, "    jmp .convert_loop")
    file_write_line(output_file, "    ")
    file_write_line(output_file, ".convert_done:")
    file_write_line(output_file, "    incq %rsi  # point to first character")
    file_write_line(output_file, "    ")
    file_write_line(output_file, "    # Calculate string length")
    file_write_line(output_file, "    movq %rsi, %rcx  # Counter for strlen")
    file_write_line(output_file, "    xorq %rax, %rax  # Length accumulator")
    file_write_line(output_file, ".int_strlen_loop:")
    file_write_line(output_file, "    cmpb $0, (%rcx)")
    file_write_line(output_file, "    je .int_strlen_done")
    file_write_line(output_file, "    incq %rcx")
    file_write_line(output_file, "    incq %rax")
    file_write_line(output_file, "    jmp .int_strlen_loop")
    file_write_line(output_file, ".int_strlen_done:")
    file_write_line(output_file, "    ")
    file_write_line(output_file, "    # Call write syscall (sys_write = 1)")
    file_write_line(output_file, "    movq $1, %rdi     # fd = stdout")
    file_write_line(output_file, "    # %rsi already points to string")
    file_write_line(output_file, "    movq %rax, %rdx   # count = string length")
    file_write_line(output_file, "    movq $1, %rax     # syscall number for write")
    file_write_line(output_file, "    syscall")
    file_write_line(output_file, "    ")
    file_write_line(output_file, "    # Print newline")
    file_write_line(output_file, "    movq $1, %rdi     # fd = stdout")
    file_write_line(output_file, "    leaq .newline(%rip), %rsi  # newline string")
    file_write_line(output_file, "    movq $1, %rdx     # count = 1")
    file_write_line(output_file, "    movq $1, %rax     # syscall number for write")
    file_write_line(output_file, "    syscall")
    file_write_line(output_file, "    ")
    file_write_line(output_file, "    movq %rbp, %rsp")
    file_write_line(output_file, "    popq %rbp")
    file_write_line(output_file, "    ret")
    file_write_line(output_file, "")
    file_write_line(output_file, ".section .rodata")
    file_write_line(output_file, ".newline:")
    file_write(output_file, "    .string ")
    file_write(output_file, character_to_string(34))  # double quote
    file_write(output_file, "\\n")  # newline escape
    file_write_line(output_file, character_to_string(34))  # double quote
    file_write_line(output_file, "")
    file_write_line(output_file, ".text")

    # Generate all functions
    Let i be 0
    While i is less than function_count:
        Let func be memory_get_integer(functions, i multiplied by 8)
        Let func_name be memory_get_integer(func, 0)  # func->name

        # Make main function global
        If string_equals(func_name, "main") is equal to 1:
            file_write_line(output_file, ".globl main")
        End If

        file_write_line(output_file, "")
        codegen_generate_function(codegen, func)
        Let i be i plus 1
    End While

    # Add a main function wrapper if no main function exists
    Let has_main be 0
    Let i be 0
    While i is less than function_count:
        Let func be memory_get_integer(functions, i multiplied by 8)
        Let func_name be memory_get_integer(func, 0)  # func->name
        If string_equals(func_name, "main") is equal to 1:
            Let has_main be 1
            Let i be function_count  # Break
        End If
        Let i be i plus 1
    End While

    # If no main function exists, generate one that calls the first Process
    If has_main is equal to 0:
        If function_count is greater than 0:
        file_write_line(output_file, "")
        file_write_line(output_file, ".globl main")
        file_write_line(output_file, "main:")
        file_write_line(output_file, "    # Call the first Process function")
        Let first_func be memory_get_integer(functions, 0)
        Let first_func_name be memory_get_integer(first_func, 0)  # functions[0]->name
        file_write(output_file, "    call ")
        file_write(output_file, first_func_name)
        file_write_line(output_file, "")
        file_write_line(output_file, "    # Exit with the return value")
        file_write_line(output_file, "    movq %rax, %rdi")
        file_write_line(output_file, "    movq $60, %rax")
        file_write_line(output_file, "    syscall")
        End If  # End function_count > 0
    End If  # End has_main == 0

    # Add GNU stack note to prevent executable stack warning
    file_write_line(output_file, "")
    file_write(output_file, ".section .note.GNU-stack,")
    file_write(output_file, character_to_string(34))  # double quote
    file_write(output_file, character_to_string(34))  # double quote
    file_write_line(output_file, ",@progbits")
    Return 0
End Process