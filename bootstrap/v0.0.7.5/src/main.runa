# Copyright 2025 Sybertnetics Artificial Intelligence Solutions
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Main Compiler for Runa v0.0.7.5
# Line-by-line transliteration from v0.0.7.3 main.c (64 LOC)

# Process to read entire file contents into memory
# Equivalent to C static char* read_file(const char *filename)
Process called "read_file_internal" takes filename as Integer returns Integer:
    # Read entire file using runtime function (handles file open failure internally)
    Let content be runtime_read_file(filename)

    # Check if reading failed (equivalent to fopen() returning NULL)
    If content is equal to 0:
        # print_string(error message (equivalent to fprintf(stderr, "[MAIN ERROR] Could not open input file '%s'\n", filename))
        Let error_msg_temp be string_concat("[MAIN ERROR] Could not open input file '", filename)
        Let error_msg be string_concat(error_msg_temp, "'")
        deallocate(error_msg_temp)
        print_string(error_msg)
        deallocate(error_msg)
        Return 0
    End If

    Return content
End Process

# CRITICAL FIX #1: Process imports by loading and merging imported files
# This makes imports actually work instead of being ignored
Process called "process_imports" takes program as Integer returns Integer:
    # Get imports from program structure
    # Program layout: functions(0), function_count(8), function_capacity(12),
    #                 types(16), type_count(24), type_capacity(28),
    #                 imports(32), import_count(40), import_capacity(44)
    Let imports_ptr be memory_get_pointer(program, 32)
    Let import_count be memory_get_int32(program, 40)

    If import_count is equal to 0:
        Return 0  # No imports to process
    End If

    # Process each import
    Let i be 0
    While i is less than import_count:
        # Get import structure: filename(0), module_name(8)
        Let ptr_size be 8
        Let offset be i multiplied by ptr_size
        Let import_ptr_addr be imports_ptr plus offset
        Let import_stmt be memory_get_pointer(import_ptr_addr, 0)

        Let filename be memory_get_pointer(import_stmt, 0)
        Let module_name be memory_get_pointer(import_stmt, 8)

        # Load and parse the imported file
        Let import_source be read_file_internal(filename)
        If import_source is equal to 0:
            Let error_msg be string_concat("[IMPORT ERROR] Failed to load import file: ", filename)
            print_string(error_msg)
            deallocate(error_msg)
            Return 1  # Error
        End If

        # Create lexer and parser for imported file
        Let import_lexer be lexer_create(import_source)
        Let import_parser be parser_create(import_lexer)
        Let import_program be parser_parse_program(import_parser)

        If import_program is equal to 0:
            Let error_msg be string_concat("[IMPORT ERROR] Failed to parse import file: ", filename)
            print_string(error_msg)
            deallocate(error_msg)
            Return 1  # Error
        End If

        # Merge imported functions into main program
        Let imported_func_count be memory_get_int32(import_program, 8)
        Let imported_functions be memory_get_pointer(import_program, 0)

        Let j be 0
        While j is less than imported_func_count:
            Let func_offset be j multiplied by ptr_size
            Let func_ptr_addr be imported_functions plus func_offset
            Let func be memory_get_pointer(func_ptr_addr, 0)

            # Add function to main program (program_add_function handles capacity)
            program_add_function(program, func)

            Set j to j plus 1
        End While

        # Merge imported types into main program
        Let imported_type_count be memory_get_int32(import_program, 24)
        Let imported_types be memory_get_pointer(import_program, 16)

        Set j to 0
        While j is less than imported_type_count:
            Let type_offset be j multiplied by ptr_size
            Let type_ptr_addr be imported_types plus type_offset
            Let type_def be memory_get_pointer(type_ptr_addr, 0)

            # Add type to main program
            program_add_type(program, type_def)

            Set j to j plus 1
        End While

        # Clean up (but don't destroy the functions/types we merged)
        parser_destroy(import_parser)
        lexer_destroy(import_lexer)
        deallocate(import_source)

        Set i to i plus 1
    End While

    Return 0  # Success
End Process

# Main compiler entry point
# Equivalent to C int main(int argc, char **argv)
Process called "main" takes argc as Integer, argv as Integer returns Integer:
    # Check command line arguments (argc != 3)
    If argc is not equal to 3:
        # print_string(usage message (equivalent to fprintf(stderr, "Usage: %s <input.runa> <output.s>\n", argv[0]))
        Let prog_name be get_command_line_arg(0)
        Let usage_msg_temp be string_concat("Usage: ", prog_name)
        Let usage_msg be string_concat(usage_msg_temp, " <input.runa> <output.s>")
        deallocate(usage_msg_temp)
        print_string(usage_msg)
        deallocate(usage_msg)
        deallocate(prog_name)
        Return 1
    End If

    # Get command line arguments (equivalent to input_filename = argv[1])
    Let input_filename be get_command_line_arg(1)
    Let output_filename be get_command_line_arg(2)

    # Read source file (equivalent to char *source = read_file(input_filename))
    Let source be read_file_internal(input_filename)

    # Check if reading failed (equivalent to !source)
    If source is equal to 0:
        print_string("[ERROR] Failed to read source file")
        Return 1
    End If

    # Create lexer (equivalent to Lexer *lexer = lexer_create(source))
    Let lexer be lexer_create(source)

    # Create parser (equivalent to Parser *parser = parser_create(lexer))
    Let parser be parser_create(lexer)

    # Parse program (equivalent to Program *program = parser_parse_program(parser))
    Let program be parser_parse_program(parser)

    # Check if parsing failed (equivalent to !program)
    If program is equal to 0:
        print_string("[ERROR] main: Parsing failed - program is NULL")
        # Cleanup parser and lexer before returning
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source)
        Return 1
    Otherwise:
        Let func_count be memory_get_int32(program, 8)
        If func_count is equal to 0:
        Otherwise:
        End If
        Let functions_ptr be memory_get_pointer(program, 0)
        If functions_ptr is equal to 0:
        Otherwise:
        End If
    End If

    # CRITICAL FIX #1: Process imports - load and merge imported files
    Let import_result be process_imports(program)
    If import_result is not equal to 0:
        print_string("[ERROR] Failed to process imports")
        program_destroy(program)
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source)
        Return 1
    End If

    # Create code generator (equivalent to CodeGenerator *codegen = codegen_create(output_filename))
    Let codegen be codegen_create(output_filename)

    # Check if codegen creation failed (equivalent to !codegen)
    If codegen is equal to 0:
        # Cleanup resources before returning
        program_destroy(program)
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source)
        Return 1
    End If

    # Generate code (equivalent to codegen_generate(codegen, program))
    codegen_generate(codegen, program)

    # Close output file to ensure content is written (flushes buffer)
    Let output_file be memory_get_integer(codegen, 0)
    file_close_buffered(output_file)

    # Print success message (equivalent to printf("Successfully compiled '%s' to '%s'\n", input_filename, output_filename))
    Let success_msg_temp be string_concat("Successfully compiled '", input_filename)
    Let success_msg_temp2 be string_concat(success_msg_temp, "' to '")
    deallocate(success_msg_temp)
    Let success_msg be string_concat(success_msg_temp2, output_filename)
    deallocate(success_msg_temp2)
    Let success_msg_final be string_concat(success_msg, "'")
    deallocate(success_msg)
    print_string(success_msg_final)
    deallocate(success_msg_final)

    # Cleanup resources (equivalent to C cleanup code)
    # TEMPORARY: Comment out codegen_destroy to avoid crash during testing
    # codegen_destroy(codegen)
    program_destroy(program)
    parser_destroy(parser)
    lexer_destroy(lexer)
    deallocate(source)

    Return 0
End Process