# Main Compiler for Runa v0.0.7.5
# Line-by-line transliteration from v0.0.7.3 main.c (64 LOC)

# Process to read entire file contents into memory
# Equivalent to C static char* read_file(const char *filename)
Process called "read_file_internal" takes filename as Integer returns Integer:
    # Read entire file using runtime function (handles file open failure internally)
    Let content be runtime_read_file(filename)

    # Check if reading failed (equivalent to fopen() returning NULL)
    If content is equal to 0:
        # print_string(error message (equivalent to fprintf(stderr, "[MAIN ERROR] Could not open input file '%s'\n", filename))
        Let error_msg_temp be string_concat("[MAIN ERROR] Could not open input file '", filename)
        Let error_msg be string_concat(error_msg_temp, "'")
        deallocate(error_msg_temp)
        print_string(error_msg)
        deallocate(error_msg)
        Return 0
    End If

    Return content
End Process

# Main compiler entry point
# Equivalent to C int main(int argc, char **argv)
Process called "main" takes argc as Integer, argv as Integer returns Integer:
    # Check command line arguments (argc != 3)
    If argc is not equal to 3:
        # print_string(usage message (equivalent to fprintf(stderr, "Usage: %s <input.runa> <output.s>\n", argv[0]))
        Let prog_name be get_command_line_arg(0)
        Let usage_msg_temp be string_concat("Usage: ", prog_name)
        Let usage_msg be string_concat(usage_msg_temp, " <input.runa> <output.s>")
        deallocate(usage_msg_temp)
        print_string(usage_msg)
        deallocate(usage_msg)
        deallocate(prog_name)
        Return 1
    End If

    # Get input and output filenames from command line (const char *input_filename = argv[1])
    Let input_filename be get_command_line_arg(1)
    Let output_filename be get_command_line_arg(2)

    # Read the source code from input file (char *source_code = read_file(input_filename))
    Let source_code be read_file_internal(input_filename)
    If source_code is equal to 0:
        Return 1
    End If

    # Create lexer and tokenize the source code (Lexer *lexer = lexer_create(source_code))
    Let lexer be lexer_create(source_code)

    # Create parser and parse into AST (Parser *parser = parser_create(lexer))
    Let parser be parser_create(lexer)
    Let program be parser_parse_program(parser)
    If program is equal to 0:
        # Cleanup on parsing failure
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source_code)
        Return 1
    End If

    # Create code generator for output file (CodeGenerator *codegen = codegen_create(output_filename))
    Let codegen be codegen_create(output_filename)
    If codegen is equal to 0:
        # Cleanup on codegen creation failure
        program_destroy(program)
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source_code)
        Return 1
    End If

    # Generate assembly code from AST (codegen_generate(codegen, program))
    codegen_generate(codegen, program)

    # print_string(success message (printf("Successfully compiled '%s' to '%s'\n", input_filename, output_filename))
    Let success_msg_temp1 be string_concat("Successfully compiled '", input_filename)
    Let success_msg_temp2 be string_concat(success_msg_temp1, "' to '")
    deallocate(success_msg_temp1)
    Let success_msg_temp3 be string_concat(success_msg_temp2, output_filename)
    deallocate(success_msg_temp2)
    Let success_msg be string_concat(success_msg_temp3, "'")
    deallocate(success_msg_temp3)
    print_string(success_msg)
    deallocate(success_msg)

    # Cleanup all resources in exact same order as C version
    codegen_destroy(codegen)
    program_destroy(program)
    parser_destroy(parser)
    lexer_destroy(lexer)
    deallocate(source_code)

    Return 0
End Process
