# Main Compiler for Runa v0.0.7.5
# Line-by-line transliteration from v0.0.7.3 main.c (64 LOC)

# Process to read entire file contents into memory
# Equivalent to C static char* read_file(const char *filename)
Process called "read_file_internal" takes filename as Integer returns Integer:
    # Read entire file using runtime function (handles file open failure internally)
    Let content be read_file(filename)

    # Check if reading failed (equivalent to fopen() returning NULL)
    If content is equal to 0:
        # Print error message (equivalent to fprintf(stderr, "[MAIN ERROR] Could not open input file '%s'\n", filename))
        Let error_msg be string_concat("[MAIN ERROR] Could not open input file '", filename)
        Set error_msg to string_concat(error_msg, "'")
        Print error_msg
        Return 0
    End If

    Return content
End Process

# Main compiler entry point
# Equivalent to C int main(int argc, char **argv)
Process called "main" takes argc as Integer, argv as Integer returns Integer:
    # Check command line arguments (argc != 3)
    If argc is not equal to 3:
        # Print usage message (equivalent to fprintf(stderr, "Usage: %s <input.runa> <output.s>\n", argv[0]))
        Let prog_name be get_command_line_arg(0)
        Let usage_msg be string_concat("Usage: ", prog_name)
        Set usage_msg to string_concat(usage_msg, " <input.runa> <output.s>")
        Print usage_msg
        Return 1
    End If

    # Get input and output filenames from command line (const char *input_filename = argv[1])
    Let input_filename be get_command_line_arg(1)
    Let output_filename be get_command_line_arg(2)

    # Read the source code from input file (char *source_code = read_file(input_filename))
    Let source_code be read_file_internal(input_filename)
    If source_code is equal to 0:
        Return 1
    End If

    # Create lexer and tokenize the source code (Lexer *lexer = lexer_create(source_code))
    Let lexer be lexer_create(source_code)

    # Create parser and parse into AST (Parser *parser = parser_create(lexer))
    Let parser be parser_create(lexer)
    Let program be parser_parse_program(parser)
    If program is equal to 0:
        # Cleanup on parsing failure
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source_code)
        Return 1
    End If

    # Create code generator for output file (CodeGenerator *codegen = codegen_create(output_filename))
    Let codegen be codegen_create(output_filename)
    If codegen is equal to 0:
        # Cleanup on codegen creation failure
        program_destroy(program)
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source_code)
        Return 1
    End If

    # Generate assembly code from AST (codegen_generate(codegen, program))
    codegen_generate(codegen, program)

    # Print success message (printf("Successfully compiled '%s' to '%s'\n", input_filename, output_filename))
    Let success_msg be string_concat("Successfully compiled '", input_filename)
    Set success_msg to string_concat(success_msg, "' to '")
    Set success_msg to string_concat(success_msg, output_filename)
    Set success_msg to string_concat(success_msg, "'")
    Print success_msg

    # Cleanup all resources in exact same order as C version
    codegen_destroy(codegen)
    program_destroy(program)
    parser_destroy(parser)
    lexer_destroy(lexer)
    deallocate(source_code)

    Return 0
End Process