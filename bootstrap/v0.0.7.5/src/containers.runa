# Container implementations
# Transliterated from containers.c - line-by-line preservation

# ==== Vector Implementation ====

# Vector structure:
# offset 0: items (pointer to array of pointers)
# offset 8: capacity
# offset 16: size
# offset 24: free_item function pointer

Process called "vector_create" takes dummy as Integer returns Integer:
    Let initial_cap be 16
    Let result be vector_create_with_capacity(initial_cap)
    Return result
End Process

Process called "vector_create_with_capacity" takes initial_capacity as Integer returns Integer:
    Let vec be memory_allocate(32)  # sizeof(Vector) = 32
    If vec is equal to 0:
        Return 0
    End If

    Let items_size be initial_capacity multiplied by 8  # sizeof(void*) = 8
    Let items be memory_allocate(items_size)
    If items is equal to 0:
        memory_free(vec)
        Return 0
    End If

    memory_set_integer(vec, 0, items)           # vec->items = items
    memory_set_integer(vec, 8, initial_capacity) # vec->capacity = initial_capacity
    memory_set_integer(vec, 16, 0)              # vec->size = 0
    memory_set_integer(vec, 24, 0)              # vec->free_item = NULL
    Return vec
End Process

Process called "vector_create_with_destructor" takes free_item as Integer returns Integer:
    Let vec be vector_create()
    If vec is not equal to 0:
        memory_set_integer(vec, 24, free_item)  # vec->free_item = free_item
    End If
    Return vec
End Process

Process called "vector_destroy" takes vec as Integer returns Integer:
    If vec is equal to 0:
        Return 0
    End If

    Let free_item be memory_get_integer(vec, 24)
    If free_item is not equal to 0:
        Let size be memory_get_integer(vec, 16)
        Let items be memory_get_integer(vec, 0)
        Let i be 0
        While i is less than size:
            Let item_offset be i multiplied by 8
            Let item be memory_get_integer(items, item_offset)
            If item is not equal to 0:
                call_function_pointer(free_item, item)
            End If
            Set i to i plus 1
        End While
    End If

    Let items be memory_get_integer(vec, 0)
    memory_free(items)
    memory_free(vec)
    Return 0
End Process

Process called "vector_push" takes vec as Integer, item as Integer returns Integer:
    If vec is equal to 0:
        Return 0  # false
    End If

    Let size be memory_get_integer(vec, 16)
    Let capacity be memory_get_integer(vec, 8)

    If size is greater than or equal to capacity:
        Let new_capacity be capacity multiplied by 2
        Let new_size be new_capacity multiplied by 8
        Let items be memory_get_integer(vec, 0)
        Let new_items be memory_reallocate(items, new_size)
        If new_items is equal to 0:
            Return 0  # false
        End If

        memory_set_integer(vec, 0, new_items)       # vec->items = new_items
        memory_set_integer(vec, 8, new_capacity)    # vec->capacity = new_capacity
    End If

    Let items be memory_get_integer(vec, 0)
    Let item_offset be size multiplied by 8
    memory_set_integer(items, item_offset, item)    # vec->items[size] = item

    Set size to size plus 1
    memory_set_integer(vec, 16, size)               # vec->size++
    Return 1  # true
End Process

Process called "vector_pop" takes vec as Integer returns Integer:
    If vec is equal to 0:
        Return 0
    End If

    Let size be memory_get_integer(vec, 16)
    If size is equal to 0:
        Return 0
    End If

    Set size to size minus 1
    memory_set_integer(vec, 16, size)    # --vec->size

    Let items be memory_get_integer(vec, 0)
    Let item_offset be size multiplied by 8
    Let item be memory_get_integer(items, item_offset)
    Return item
End Process

Process called "vector_get" takes vec as Integer, index as Integer returns Integer:
    If vec is equal to 0:
        Return 0
    End If

    Let size be memory_get_integer(vec, 16)
    If index is greater than or equal to size:
        Return 0
    End If

    Let items be memory_get_integer(vec, 0)
    Let item_offset be index multiplied by 8
    Let item be memory_get_integer(items, item_offset)
    Return item
End Process

Process called "vector_set" takes vec as Integer, index as Integer, item as Integer returns Integer:
    If vec is equal to 0:
        Return 0  # false
    End If

    Let size be memory_get_integer(vec, 16)
    If index is greater than or equal to size:
        Return 0  # false
    End If

    Let free_item be memory_get_integer(vec, 24)
    Let items be memory_get_integer(vec, 0)
    Let item_offset be index multiplied by 8

    If free_item is not equal to 0:
        Let old_item be memory_get_integer(items, item_offset)
        If old_item is not equal to 0:
            call_function_pointer(free_item, old_item)
        End If
    End If

    memory_set_integer(items, item_offset, item)
    Return 1  # true
End Process

Process called "vector_insert" takes vec as Integer, index as Integer, item as Integer returns Integer:
    If vec is equal to 0:
        Return 0  # false
    End If

    Let size be memory_get_integer(vec, 16)
    If index is greater than size:
        Return 0  # false
    End If

    Let capacity be memory_get_integer(vec, 8)
    If size is greater than or equal to capacity:
        Let new_capacity be capacity multiplied by 2
        Let new_size be new_capacity multiplied by 8
        Let items be memory_get_integer(vec, 0)
        Let new_items be memory_reallocate(items, new_size)
        If new_items is equal to 0:
            Return 0  # false
        End If

        memory_set_integer(vec, 0, new_items)
        memory_set_integer(vec, 8, new_capacity)
    End If

    # Shift elements to the right
    Let items be memory_get_integer(vec, 0)
    Let i be size
    While i is greater than index:
        Let i_minus_1 be i minus 1
        Let src_offset be i_minus_1 multiplied by 8
        Let dst_offset be i multiplied by 8
        Let value be memory_get_integer(items, src_offset)
        memory_set_integer(items, dst_offset, value)
        Set i to i minus 1
    End While

    Let item_offset be index multiplied by 8
    memory_set_integer(items, item_offset, item)

    Set size to size plus 1
    memory_set_integer(vec, 16, size)
    Return 1  # true
End Process

Process called "vector_remove" takes vec as Integer, index as Integer returns Integer:
    If vec is equal to 0:
        Return 0  # false
    End If

    Let size be memory_get_integer(vec, 16)
    If index is greater than or equal to size:
        Return 0  # false
    End If

    Let free_item be memory_get_integer(vec, 24)
    Let items be memory_get_integer(vec, 0)

    If free_item is not equal to 0:
        Let item_offset be index multiplied by 8
        Let old_item be memory_get_integer(items, item_offset)
        If old_item is not equal to 0:
            call_function_pointer(free_item, old_item)
        End If
    End If

    # Shift elements to the left
    Let size_minus_1 be size minus 1
    Let i be index
    While i is less than size_minus_1:
        Let i_plus_1 be i plus 1
        Let src_offset be i_plus_1 multiplied by 8
        Let dst_offset be i multiplied by 8
        Let value be memory_get_integer(items, src_offset)
        memory_set_integer(items, dst_offset, value)
        Set i to i plus 1
    End While

    Set size to size_minus_1
    memory_set_integer(vec, 16, size)
    Return 1  # true
End Process

Process called "vector_clear" takes vec as Integer returns Integer:
    If vec is equal to 0:
        Return 0
    End If

    Let free_item be memory_get_integer(vec, 24)
    If free_item is not equal to 0:
        Let size be memory_get_integer(vec, 16)
        Let items be memory_get_integer(vec, 0)
        Let i be 0
        While i is less than size:
            Let item_offset be i multiplied by 8
            Let item be memory_get_integer(items, item_offset)
            If item is not equal to 0:
                call_function_pointer(free_item, item)
            End If
            Set i to i plus 1
        End While
    End If

    memory_set_integer(vec, 16, 0)  # vec->size = 0
    Return 0
End Process

Process called "vector_size" takes vec as Integer returns Integer:
    If vec is not equal to 0:
        Return memory_get_integer(vec, 16)
    Otherwise:
        Return 0
    End If
End Process

Process called "vector_capacity" takes vec as Integer returns Integer:
    If vec is not equal to 0:
        Return memory_get_integer(vec, 8)
    Otherwise:
        Return 0
    End If
End Process

Process called "vector_is_empty" takes vec as Integer returns Integer:
    If vec is equal to 0:
        Return 1  # true
    End If

    Let size be memory_get_integer(vec, 16)
    If size is equal to 0:
        Return 1  # true
    Otherwise:
        Return 0  # false
    End If
End Process

Process called "vector_reserve" takes vec as Integer, new_capacity as Integer returns Integer:
    If vec is equal to 0:
        Return 0  # false
    End If

    Let capacity be memory_get_integer(vec, 8)
    If new_capacity is less than or equal to capacity:
        Return 0  # false
    End If

    Let new_size be new_capacity multiplied by 8
    Let items be memory_get_integer(vec, 0)
    Let new_items be memory_reallocate(items, new_size)
    If new_items is equal to 0:
        Return 0  # false
    End If

    memory_set_integer(vec, 0, new_items)
    memory_set_integer(vec, 8, new_capacity)
    Return 1  # true
End Process

Process called "vector_shrink_to_fit" takes vec as Integer returns Integer:
    If vec is equal to 0:
        Return 1  # true
    End If

    Let size be memory_get_integer(vec, 16)
    Let capacity be memory_get_integer(vec, 8)
    If size is equal to capacity:
        Return 1  # true
    End If

    Let new_size be size multiplied by 8
    Let items be memory_get_integer(vec, 0)
    Let new_items be memory_reallocate(items, new_size)

    # Check if realloc failed and size > 0
    Let failed be 0
    If new_items is equal to 0:
        If size is greater than 0:
            Set failed to 1
        End If
    End If

    If failed is equal to 1:
        Return 0  # false
    End If

    memory_set_integer(vec, 0, new_items)
    memory_set_integer(vec, 8, size)
    Return 1  # true
End Process

Process called "vector_begin" takes vec as Integer returns Integer:
    If vec is not equal to 0:
        Return memory_get_integer(vec, 0)
    Otherwise:
        Return 0
    End If
End Process

Process called "vector_end" takes vec as Integer returns Integer:
    If vec is not equal to 0:
        Let items be memory_get_integer(vec, 0)
        Let size be memory_get_integer(vec, 16)
        Let offset be size multiplied by 8
        Return items plus offset
    Otherwise:
        Return 0
    End If
End Process

Process called "vector_foreach" takes vec as Integer, callback as Integer returns Integer:
    If vec is equal to 0:
        Return 0
    End If
    If callback is equal to 0:
        Return 0
    End If

    Let size be memory_get_integer(vec, 16)
    Let items be memory_get_integer(vec, 0)
    Let i be 0
    While i is less than size:
        Let item_offset be i multiplied by 8
        Let item be memory_get_integer(items, item_offset)
        call_function_pointer(callback, item)
        Set i to i plus 1
    End While
    Return 0
End Process

# ==== Stack Implementation ====

# Stack structure:
# offset 0: vec (pointer to Vector)

Process called "stack_create" takes dummy as Integer returns Integer:
    Let stack be memory_allocate(8)  # sizeof(Stack) = 8
    If stack is equal to 0:
        Return 0
    End If

    Let vec be vector_create()
    If vec is equal to 0:
        memory_free(stack)
        Return 0
    End If

    memory_set_integer(stack, 0, vec)
    Return stack
End Process

Process called "stack_create_with_destructor" takes free_item as Integer returns Integer:
    Let stack be memory_allocate(8)
    If stack is equal to 0:
        Return 0
    End If

    Let vec be vector_create_with_destructor(free_item)
    If vec is equal to 0:
        memory_free(stack)
        Return 0
    End If

    memory_set_integer(stack, 0, vec)
    Return stack
End Process

Process called "stack_destroy" takes stack as Integer returns Integer:
    If stack is equal to 0:
        Return 0
    End If

    Let vec be memory_get_integer(stack, 0)
    vector_destroy(vec)
    memory_free(stack)
    Return 0
End Process

Process called "stack_push" takes stack as Integer, item as Integer returns Integer:
    If stack is not equal to 0:
        Let vec be memory_get_integer(stack, 0)
        Let result be vector_push(vec, item)
        Return result
    Otherwise:
        Return 0  # false
    End If
End Process

Process called "stack_pop" takes stack as Integer returns Integer:
    If stack is not equal to 0:
        Let vec be memory_get_integer(stack, 0)
        Let result be vector_pop(vec)
        Return result
    Otherwise:
        Return 0
    End If
End Process

Process called "stack_peek" takes stack as Integer returns Integer:
    If stack is equal to 0:
        Return 0
    End If

    Let vec be memory_get_integer(stack, 0)
    Let is_empty be vector_is_empty(vec)
    If is_empty is equal to 1:
        Return 0
    End If

    Let size be memory_get_integer(vec, 16)
    Let index be size minus 1
    Let result be vector_get(vec, index)
    Return result
End Process

Process called "stack_size" takes stack as Integer returns Integer:
    If stack is not equal to 0:
        Let vec be memory_get_integer(stack, 0)
        Let result be vector_size(vec)
        Return result
    Otherwise:
        Return 0
    End If
End Process

Process called "stack_is_empty" takes stack as Integer returns Integer:
    If stack is equal to 0:
        Return 1  # true
    End If

    Let vec be memory_get_integer(stack, 0)
    Let result be vector_is_empty(vec)
    Return result
End Process

Process called "stack_clear" takes stack as Integer returns Integer:
    If stack is not equal to 0:
        Let vec be memory_get_integer(stack, 0)
        vector_clear(vec)
    End If
    Return 0
End Process

# ==== Queue Implementation ====

# Queue structure:
# offset 0: items (pointer to array)
# offset 8: capacity
# offset 16: front
# offset 24: rear
# offset 32: size
# offset 40: free_item function pointer

Process called "queue_create" takes dummy as Integer returns Integer:
    Let initial_cap be 16
    Let result be queue_create_with_capacity(initial_cap)
    Return result
End Process

Process called "queue_create_with_capacity" takes initial_capacity as Integer returns Integer:
    Let queue be memory_allocate(48)  # sizeof(Queue) = 48
    If queue is equal to 0:
        Return 0
    End If

    Let items_size be initial_capacity multiplied by 8
    Let items be memory_allocate(items_size)
    If items is equal to 0:
        memory_free(queue)
        Return 0
    End If

    memory_set_integer(queue, 0, items)            # queue->items = items
    memory_set_integer(queue, 8, initial_capacity) # queue->capacity = initial_capacity
    memory_set_integer(queue, 16, 0)               # queue->front = 0
    memory_set_integer(queue, 24, 0)               # queue->rear = 0
    memory_set_integer(queue, 32, 0)               # queue->size = 0
    memory_set_integer(queue, 40, 0)               # queue->free_item = NULL
    Return queue
End Process

Process called "queue_create_with_destructor" takes free_item as Integer returns Integer:
    Let queue be queue_create()
    If queue is not equal to 0:
        memory_set_integer(queue, 40, free_item)
    End If
    Return queue
End Process

Process called "queue_destroy" takes queue as Integer returns Integer:
    If queue is equal to 0:
        Return 0
    End If

    queue_clear(queue)
    Let items be memory_get_integer(queue, 0)
    memory_free(items)
    memory_free(queue)
    Return 0
End Process

Process called "queue_enqueue" takes queue as Integer, item as Integer returns Integer:
    If queue is equal to 0:
        Return 0  # false
    End If

    Let size be memory_get_integer(queue, 32)
    Let capacity be memory_get_integer(queue, 8)
    If size is greater than or equal to capacity:
        Return 0  # false
    End If

    Let items be memory_get_integer(queue, 0)
    Let rear be memory_get_integer(queue, 24)
    Let item_offset be rear multiplied by 8
    memory_set_integer(items, item_offset, item)

    # queue->rear = (queue->rear + 1) % queue->capacity
    Let rear_plus_1 be rear plus 1
    Let new_rear be rear_plus_1 modulo by capacity
    memory_set_integer(queue, 24, new_rear)

    Set size to size plus 1
    memory_set_integer(queue, 32, size)
    Return 1  # true
End Process

Process called "queue_dequeue" takes queue as Integer returns Integer:
    If queue is equal to 0:
        Return 0
    End If

    Let size be memory_get_integer(queue, 32)
    If size is equal to 0:
        Return 0
    End If

    Let items be memory_get_integer(queue, 0)
    Let front be memory_get_integer(queue, 16)
    Let item_offset be front multiplied by 8
    Let item be memory_get_integer(items, item_offset)

    # queue->front = (queue->front + 1) % queue->capacity
    Let front_plus_1 be front plus 1
    Let capacity be memory_get_integer(queue, 8)
    Let new_front be front_plus_1 modulo by capacity
    memory_set_integer(queue, 16, new_front)

    Set size to size minus 1
    memory_set_integer(queue, 32, size)
    Return item
End Process

Process called "queue_peek" takes queue as Integer returns Integer:
    If queue is equal to 0:
        Return 0
    End If

    Let size be memory_get_integer(queue, 32)
    If size is equal to 0:
        Return 0
    End If

    Let items be memory_get_integer(queue, 0)
    Let front be memory_get_integer(queue, 16)
    Let item_offset be front multiplied by 8
    Return memory_get_integer(items, item_offset)
End Process

Process called "queue_size" takes queue as Integer returns Integer:
    If queue is not equal to 0:
        Return memory_get_integer(queue, 32)
    Otherwise:
        Return 0
    End If
End Process

Process called "queue_is_empty" takes queue as Integer returns Integer:
    If queue is equal to 0:
        Return 1  # true
    End If

    Let size be memory_get_integer(queue, 32)
    If size is equal to 0:
        Return 1  # true
    Otherwise:
        Return 0  # false
    End If
End Process

Process called "queue_is_full" takes queue as Integer returns Integer:
    If queue is equal to 0:
        Return 0  # false
    End If

    Let size be memory_get_integer(queue, 32)
    Let capacity be memory_get_integer(queue, 8)
    If size is greater than or equal to capacity:
        Return 1  # true
    Otherwise:
        Return 0  # false
    End If
End Process

Process called "queue_clear" takes queue as Integer returns Integer:
    If queue is equal to 0:
        Return 0
    End If

    Let free_item be memory_get_integer(queue, 40)
    If free_item is not equal to 0:
        Let continue_loop be 1
        While continue_loop is equal to 1:
            Let size be memory_get_integer(queue, 32)
            If size is greater than 0:
                Let item be queue_dequeue(queue)
                If item is not equal to 0:
                    call_function_pointer(free_item, item)
                End If
            Otherwise:
                Set continue_loop to 0
            End If
        End While
    Otherwise:
        memory_set_integer(queue, 32, 0)  # queue->size = 0
        memory_set_integer(queue, 16, 0)  # queue->front = 0
        memory_set_integer(queue, 24, 0)  # queue->rear = 0
    End If
    Return 0
End Process

# ==== Linked List Implementation ====

# ListNode structure:
# offset 0: data
# offset 8: prev
# offset 16: next

# LinkedList structure:
# offset 0: head
# offset 8: tail
# offset 16: size
# offset 24: free_item

Process called "container_list_create" takes dummy as Integer returns Integer:
    Let list be memory_allocate(32)  # sizeof(LinkedList) = 32
    If list is equal to 0:
        Return 0
    End If

    memory_set_integer(list, 0, 0)   # list->head = NULL
    memory_set_integer(list, 8, 0)   # list->tail = NULL
    memory_set_integer(list, 16, 0)  # list->size = 0
    memory_set_integer(list, 24, 0)  # list->free_item = NULL
    Return list
End Process

Process called "list_create_with_destructor" takes free_item as Integer returns Integer:
    Let list be container_list_create()
    If list is not equal to 0:
        memory_set_integer(list, 24, free_item)
    End If
    Return list
End Process

Process called "container_list_destroy" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If

    container_list_clear(list)
    memory_free(list)
    Return 0
End Process

Process called "list_push_front" takes list as Integer, item as Integer returns Integer:
    If list is equal to 0:
        Return 0  # false
    End If

    Let new_node be memory_allocate(24)  # sizeof(ListNode) = 24
    If new_node is equal to 0:
        Return 0  # false
    End If

    memory_set_integer(new_node, 0, item)  # new_node->data = item
    memory_set_integer(new_node, 8, 0)     # new_node->prev = NULL

    Let head be memory_get_integer(list, 0)
    memory_set_integer(new_node, 16, head)  # new_node->next = list->head

    If head is not equal to 0:
        memory_set_integer(head, 8, new_node)  # list->head->prev = new_node
    Otherwise:
        memory_set_integer(list, 8, new_node)  # list->tail = new_node
    End If

    memory_set_integer(list, 0, new_node)  # list->head = new_node

    Let size be memory_get_integer(list, 16)
    Set size to size plus 1
    memory_set_integer(list, 16, size)
    Return 1  # true
End Process

Process called "list_push_back" takes list as Integer, item as Integer returns Integer:
    If list is equal to 0:
        Return 0  # false
    End If

    Let new_node be memory_allocate(24)
    If new_node is equal to 0:
        Return 0  # false
    End If

    memory_set_integer(new_node, 0, item)   # new_node->data = item
    memory_set_integer(new_node, 16, 0)     # new_node->next = NULL

    Let tail be memory_get_integer(list, 8)
    memory_set_integer(new_node, 8, tail)   # new_node->prev = list->tail

    If tail is not equal to 0:
        memory_set_integer(tail, 16, new_node)  # list->tail->next = new_node
    Otherwise:
        memory_set_integer(list, 0, new_node)   # list->head = new_node
    End If

    memory_set_integer(list, 8, new_node)  # list->tail = new_node

    Let size be memory_get_integer(list, 16)
    Set size to size plus 1
    memory_set_integer(list, 16, size)
    Return 1  # true
End Process

Process called "list_pop_front" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If

    Let head be memory_get_integer(list, 0)
    If head is equal to 0:
        Return 0
    End If

    Let data be memory_get_integer(head, 0)
    Let next be memory_get_integer(head, 16)

    memory_set_integer(list, 0, next)  # list->head = node->next
    If next is not equal to 0:
        memory_set_integer(next, 8, 0)  # list->head->prev = NULL
    Otherwise:
        memory_set_integer(list, 8, 0)  # list->tail = NULL
    End If

    memory_free(head)

    Let size be memory_get_integer(list, 16)
    Set size to size minus 1
    memory_set_integer(list, 16, size)
    Return data
End Process

Process called "list_pop_back" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If

    Let tail be memory_get_integer(list, 8)
    If tail is equal to 0:
        Return 0
    End If

    Let data be memory_get_integer(tail, 0)
    Let prev be memory_get_integer(tail, 8)

    memory_set_integer(list, 8, prev)  # list->tail = node->prev
    If prev is not equal to 0:
        memory_set_integer(prev, 16, 0)  # list->tail->next = NULL
    Otherwise:
        memory_set_integer(list, 0, 0)   # list->head = NULL
    End If

    memory_free(tail)

    Let size be memory_get_integer(list, 16)
    Set size to size minus 1
    memory_set_integer(list, 16, size)
    Return data
End Process

Process called "list_front" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If

    Let head be memory_get_integer(list, 0)
    If head is not equal to 0:
        Return memory_get_integer(head, 0)
    Otherwise:
        Return 0
    End If
End Process

Process called "list_back" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If

    Let tail be memory_get_integer(list, 8)
    If tail is not equal to 0:
        Return memory_get_integer(tail, 0)
    Otherwise:
        Return 0
    End If
End Process

Process called "list_insert_after" takes list as Integer, node as Integer, item as Integer returns Integer:
    If list is equal to 0:
        Return 0  # false
    End If
    If node is equal to 0:
        Return 0  # false
    End If

    Let new_node be memory_allocate(24)
    If new_node is equal to 0:
        Return 0  # false
    End If

    memory_set_integer(new_node, 0, item)    # new_node->data = item
    memory_set_integer(new_node, 8, node)    # new_node->prev = node

    Let node_next be memory_get_integer(node, 16)
    memory_set_integer(new_node, 16, node_next)  # new_node->next = node->next

    If node_next is not equal to 0:
        memory_set_integer(node_next, 8, new_node)  # node->next->prev = new_node
    Otherwise:
        memory_set_integer(list, 8, new_node)       # list->tail = new_node
    End If

    memory_set_integer(node, 16, new_node)  # node->next = new_node

    Let size be memory_get_integer(list, 16)
    Set size to size plus 1
    memory_set_integer(list, 16, size)
    Return 1  # true
End Process

Process called "list_insert_before" takes list as Integer, node as Integer, item as Integer returns Integer:
    If list is equal to 0:
        Return 0  # false
    End If
    If node is equal to 0:
        Return 0  # false
    End If

    Let new_node be memory_allocate(24)
    If new_node is equal to 0:
        Return 0  # false
    End If

    memory_set_integer(new_node, 0, item)     # new_node->data = item
    memory_set_integer(new_node, 16, node)    # new_node->next = node

    Let node_prev be memory_get_integer(node, 8)
    memory_set_integer(new_node, 8, node_prev)  # new_node->prev = node->prev

    If node_prev is not equal to 0:
        memory_set_integer(node_prev, 16, new_node)  # node->prev->next = new_node
    Otherwise:
        memory_set_integer(list, 0, new_node)        # list->head = new_node
    End If

    memory_set_integer(node, 8, new_node)  # node->prev = new_node

    Let size be memory_get_integer(list, 16)
    Set size to size plus 1
    memory_set_integer(list, 16, size)
    Return 1  # true
End Process

Process called "list_remove_node" takes list as Integer, node as Integer returns Integer:
    If list is equal to 0:
        Return 0  # false
    End If
    If node is equal to 0:
        Return 0  # false
    End If

    Let prev be memory_get_integer(node, 8)
    Let next be memory_get_integer(node, 16)

    If prev is not equal to 0:
        memory_set_integer(prev, 16, next)  # node->prev->next = node->next
    Otherwise:
        memory_set_integer(list, 0, next)   # list->head = node->next
    End If

    If next is not equal to 0:
        memory_set_integer(next, 8, prev)   # node->next->prev = node->prev
    Otherwise:
        memory_set_integer(list, 8, prev)   # list->tail = node->prev
    End If

    Let free_item be memory_get_integer(list, 24)
    If free_item is not equal to 0:
        Let data be memory_get_integer(node, 0)
        If data is not equal to 0:
            call_function_pointer(free_item, data)
        End If
    End If

    memory_free(node)

    Let size be memory_get_integer(list, 16)
    Set size to size minus 1
    memory_set_integer(list, 16, size)
    Return 1  # true
End Process

Process called "container_list_find" takes list as Integer, item as Integer, compare as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If
    If compare is equal to 0:
        Return 0
    End If

    Let current be memory_get_integer(list, 0)
    While current is not equal to 0:
        Let data be memory_get_integer(current, 0)
        Let result be call_function_pointer_2args(compare, data, item)
        If result is not equal to 0:
            Return current
        End If
        Set current to memory_get_integer(current, 16)
    End While

    Return 0
End Process

Process called "list_size" takes list as Integer returns Integer:
    If list is not equal to 0:
        Return memory_get_integer(list, 16)
    Otherwise:
        Return 0
    End If
End Process

Process called "list_is_empty" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 1  # true
    End If

    Let size be memory_get_integer(list, 16)
    If size is equal to 0:
        Return 1  # true
    Otherwise:
        Return 0  # false
    End If
End Process

Process called "container_list_clear" takes list as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If

    Let free_item be memory_get_integer(list, 24)
    Let current be memory_get_integer(list, 0)

    While current is not equal to 0:
        Let next be memory_get_integer(current, 16)

        If free_item is not equal to 0:
            Let data be memory_get_integer(current, 0)
            If data is not equal to 0:
                call_function_pointer(free_item, data)
            End If
        End If

        memory_free(current)
        Set current to next
    End While

    memory_set_integer(list, 0, 0)   # list->head = NULL
    memory_set_integer(list, 8, 0)   # list->tail = NULL
    memory_set_integer(list, 16, 0)  # list->size = 0
    Return 0
End Process

Process called "list_begin" takes list as Integer returns Integer:
    If list is not equal to 0:
        Return memory_get_integer(list, 0)
    Otherwise:
        Return 0
    End If
End Process

Process called "list_end" takes list as Integer returns Integer:
    # End is represented as NULL
    Return 0
End Process

Process called "list_next" takes node as Integer returns Integer:
    If node is not equal to 0:
        Return memory_get_integer(node, 16)
    Otherwise:
        Return 0
    End If
End Process

Process called "list_prev" takes node as Integer returns Integer:
    If node is not equal to 0:
        Return memory_get_integer(node, 8)
    Otherwise:
        Return 0
    End If
End Process

Process called "list_foreach" takes list as Integer, callback as Integer returns Integer:
    If list is equal to 0:
        Return 0
    End If
    If callback is equal to 0:
        Return 0
    End If

    Let current be memory_get_integer(list, 0)
    While current is not equal to 0:
        Let data be memory_get_integer(current, 0)
        call_function_pointer(callback, data)
        Set current to memory_get_integer(current, 16)
    End While
    Return 0
End Process

# ==== Set Implementation ====
# Note: Set is implemented using hashtable
# Set structure:
# offset 0: table (hashtable pointer)
# offset 8: free_item

Process called "set_create" takes hash_func as Integer, compare_func as Integer returns Integer:
    Let set be memory_allocate(16)  # sizeof(Set) = 16
    If set is equal to 0:
        Return 0
    End If

    Let initial_buckets be 256
    Let table be hashtable_create(initial_buckets, hash_func, compare_func)
    If table is equal to 0:
        memory_free(set)
        Return 0
    End If

    memory_set_integer(set, 0, table)
    memory_set_integer(set, 8, 0)     # set->free_item = NULL
    Return set
End Process

Process called "set_create_with_destructor" takes hash_func as Integer, compare_func as Integer, free_item as Integer returns Integer:
    Let set be set_create(hash_func, compare_func)
    If set is not equal to 0:
        memory_set_integer(set, 8, free_item)
        # Update hash table to use destructor
        Let table be memory_get_integer(set, 0)
        memory_set_integer(table, 40, free_item)  # table->free_key = free_item
    End If
    Return set
End Process

Process called "set_destroy" takes set as Integer returns Integer:
    If set is equal to 0:
        Return 0
    End If

    Let table be memory_get_integer(set, 0)
    hashtable_destroy(table)
    memory_free(set)
    Return 0
End Process

Process called "set_add" takes set as Integer, item as Integer returns Integer:
    If set is equal to 0:
        Return 0  # false
    End If

    Let table be memory_get_integer(set, 0)
    # In a set, key and value are the same
    Let result be hashtable_put(table, item, item)
    Return result
End Process

Process called "set_remove" takes set as Integer, item as Integer returns Integer:
    If set is not equal to 0:
        Let table be memory_get_integer(set, 0)
        Let result be hashtable_remove(table, item)
        Return result
    Otherwise:
        Return 0  # false
    End If
End Process

Process called "set_contains" takes set as Integer, item as Integer returns Integer:
    If set is not equal to 0:
        Let table be memory_get_integer(set, 0)
        Let result be hashtable_contains(table, item)
        Return result
    Otherwise:
        Return 0  # false
    End If
End Process

Process called "set_size" takes set as Integer returns Integer:
    If set is not equal to 0:
        Let table be memory_get_integer(set, 0)
        Let result be hashtable_size(table)
        Return result
    Otherwise:
        Return 0
    End If
End Process

Process called "set_is_empty" takes set as Integer returns Integer:
    If set is equal to 0:
        Return 1  # true
    End If

    Let table be memory_get_integer(set, 0)
    Let size be hashtable_size(table)
    If size is equal to 0:
        Return 1  # true
    Otherwise:
        Return 0  # false
    End If
End Process

Process called "set_clear" takes set as Integer returns Integer:
    If set is not equal to 0:
        Let table be memory_get_integer(set, 0)
        hashtable_clear(table)
    End If
    Return 0
End Process

# Note: Set union/intersection/difference operations would require hashtable_iterator
# which isn't available in v0.0.7.3. These would need to be added later.

# ==== Utility Functions ====

Process called "free_string_item" takes item as Integer returns Integer:
    memory_free(item)
    Return 0
End Process

Process called "free_integer_item" takes item as Integer returns Integer:
    memory_free(item)
    Return 0
End Process