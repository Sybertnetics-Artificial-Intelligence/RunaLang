Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Hash Table Implementation - Line-for-line transliteration from hashtable.c
Note: Preserves exact hash function (djb2), collision handling, and resize logic

Note: ==== Type Definitions ====
Note: WORKAROUND: Types commented out due to v0.0.7.3 bug with Type+Let combo
Note: Once v0.0.7.5 is self-hosted, uncomment these

Note: Type called "HashEntry":
Note:     key as Integer,       Note: Pointer to key
Note:     value as Integer,     Note: Pointer to value
Note:     next as Integer       Note: Pointer to next entry (for chaining)
Note: End Type

Note: Type called "HashTable":
Note:     buckets as Integer,       Note: Pointer to array of HashEntry pointers
Note:     bucket_count as Integer,  Note: Number of buckets
Note:     entry_count as Integer,   Note: Number of entries
Note:     hash_func as Integer,     Note: Function pointer for hash function
Note:     compare_func as Integer,  Note: Function pointer for comparison
Note:     free_key as Integer,      Note: Function pointer for key destructor
Note:     free_value as Integer     Note: Function pointer for value destructor
Note: End Type

Note: Type called "HashIterator":
Note:     table as Integer,         Note: Pointer to HashTable
Note:     bucket_index as Integer,  Note: Current bucket index
Note:     current_entry as Integer  Note: Pointer to current HashEntry
Note: End Type

Note: Type called "HashTableStats":
Note:     bucket_count as Integer,
Note:     entry_count as Integer,
Note:     empty_buckets as Integer,
Note:     max_chain_length as Integer,
Note:     average_chain_length as Integer,  Note: Using Integer for simplicity (multiplied by 100)
Note:     load_factor as Integer            Note: Using Integer for simplicity (multiplied by 100)
Note: End Type

Note: ==== Hash Table Creation and Destruction ====

Process called "hashtable_create" takes initial_buckets as Integer, hash_func as Integer, compare_func as Integer returns Integer:
    Return hashtable_create_with_destructors(initial_buckets, hash_func, compare_func, 0, 0)
End Process

Process called "hashtable_create_with_destructors" takes initial_buckets as Integer, hash_func as Integer, compare_func as Integer, free_key as Integer, free_value as Integer returns Integer:
    If initial_buckets is equal to 0:
        Return 0
    End If
    If hash_func is equal to 0:
        Return 0
    End If
    If compare_func is equal to 0:
        Return 0
    End If

    Let table be allocate(56)  Note: sizeof(HashTable)
    If table is equal to 0:
        Return 0
    End If

    Let buckets_size be initial_buckets multiplied by 8
    Let buckets be allocate(buckets_size)
    If buckets is equal to 0:
        deallocate(table)
        Return 0
    End If

    Note: Initialize buckets to NULL
    Let i be 0
    While i is less than initial_buckets:
        memory_set_pointer_at_index(buckets, i, 0)
        Set i to i plus 1
    End While

    memory_set_pointer(table, 0, buckets)  Note: buckets
    memory_set_int32(table, 8, initial_buckets)  Note: bucket_count
    memory_set_int32(table, 16, 0)  Note: entry_count
    memory_set_pointer(table, 24, hash_func)  Note: hash_func
    memory_set_pointer(table, 32, compare_func)  Note: compare_func
    memory_set_pointer(table, 40, free_key)  Note: free_key
    memory_set_pointer(table, 48, free_value)  Note: free_value

    Return table
End Process

Process called "hashtable_destroy" takes table as Integer returns Integer:
    If table is equal to 0:
        Return 0
    End If

    Note: Clear all entries
    hashtable_clear(table)

    Note: Free the buckets array
    Let buckets be memory_get_pointer(table, 0)
    deallocate(buckets)

    Note: Free the table itself
    deallocate(table)

    Return 0
End Process

Note: ==== Hash Table Operations ====

Process called "hashtable_put" takes table as Integer, key as Integer, value as Integer returns Integer:
    If table is equal to 0:
        Return 0
    End If
    If key is equal to 0:
        Return 0
    End If

    Let hash_func be memory_get_pointer(table, 24)
    Let hash be call_function_1(hash_func, key)
    Let bucket_count be memory_get_int32(table, 8)
    Note: hash modulo bucket_count = hash - (hash / bucket_count) * bucket_count
    Let hash_div_count be hash divided by bucket_count
    Let hash_mult_count be hash_div_count multiplied by bucket_count
    Let bucket_index be hash minus hash_mult_count

    Let buckets be memory_get_pointer(table, 0)
    Let current be memory_get_pointer_at_index(buckets, bucket_index)
    Let prev be 0

    Note: Search for existing key
    Let continue_search be 1
    While continue_search is equal to 1:
        If current is equal to 0:
            Set continue_search to 0
        Otherwise:
            Let current_key be memory_get_pointer(current, 0)
            Let compare_func be memory_get_pointer(table, 32)
            Let is_match be call_function_2(compare_func, current_key, key)
            If is_match is equal to 1:
                Note: Key exists, update value
                Let free_value be memory_get_pointer(table, 48)
                Let current_value be memory_get_pointer(current, 8)
                If free_value is not equal to 0:
                    If current_value is not equal to 0:
                        call_function_1(free_value, current_value)
                    End If
                End If
                memory_set_pointer(current, 8, value)
                Return 1
            End If
            Set prev to current
            Set current to memory_get_pointer(current, 16)  Note: next
        End If
    End While

    Note: Key doesn't exist, create new entry
    Let new_entry be allocate(24)  Note: sizeof(HashEntry)
    If new_entry is equal to 0:
        Return 0
    End If

    memory_set_pointer(new_entry, 0, key)
    memory_set_pointer(new_entry, 8, value)
    memory_set_pointer(new_entry, 16, 0)  Note: next = NULL

    If prev is not equal to 0:
        memory_set_pointer(prev, 16, new_entry)
    Otherwise:
        memory_set_pointer_at_index(buckets, bucket_index, new_entry)
    End If

    Let entry_count be memory_get_integer(table, 16)
    memory_set_integer(table, 16, entry_count plus 1)

    Return 1
End Process

Process called "hashtable_get" takes table as Integer, key as Integer returns Integer:
    If table is equal to 0:
        Return 0
    End If
    If key is equal to 0:
        Return 0
    End If

    Let hash_func be memory_get_pointer(table, 24)
    Let hash be call_function_1(hash_func, key)
    Let bucket_count be memory_get_int32(table, 8)
    Note: hash modulo bucket_count = hash - (hash / bucket_count) * bucket_count
    Let hash_div_count be hash divided by bucket_count
    Let hash_mult_count be hash_div_count multiplied by bucket_count
    Let bucket_index be hash minus hash_mult_count

    Let buckets be memory_get_pointer(table, 0)
    Let current be memory_get_pointer_at_index(buckets, bucket_index)

    While current is not equal to 0:
        Let current_key be memory_get_pointer(current, 0)
        Let compare_func be memory_get_pointer(table, 32)
        Let is_match be call_function_2(compare_func, current_key, key)
        If is_match is equal to 1:
            Return memory_get_pointer(current, 8)  Note: return value
        End If
        Set current to memory_get_pointer(current, 16)  Note: next
    End While

    Return 0
End Process

Process called "hashtable_remove" takes table as Integer, key as Integer returns Integer:
    If table is equal to 0:
        Return 0
    End If
    If key is equal to 0:
        Return 0
    End If

    Let hash_func be memory_get_pointer(table, 24)
    Let hash be call_function_1(hash_func, key)
    Let bucket_count be memory_get_int32(table, 8)
    Note: hash modulo bucket_count = hash - (hash / bucket_count) * bucket_count
    Let hash_div_count be hash divided by bucket_count
    Let hash_mult_count be hash_div_count multiplied by bucket_count
    Let bucket_index be hash minus hash_mult_count

    Let buckets be memory_get_pointer(table, 0)
    Let current be memory_get_pointer_at_index(buckets, bucket_index)
    Let prev be 0

    While current is not equal to 0:
        Let current_key be memory_get_pointer(current, 0)
        Let compare_func be memory_get_pointer(table, 32)
        Let is_match be call_function_2(compare_func, current_key, key)
        If is_match is equal to 1:
            Note: Found the entry to remove
            Let next be memory_get_pointer(current, 16)
            If prev is not equal to 0:
                memory_set_pointer(prev, 16, next)
            Otherwise:
                memory_set_pointer_at_index(buckets, bucket_index, next)
            End If

            Note: Free key and value if destructors are provided
            Let free_key be memory_get_pointer(table, 40)
            If free_key is not equal to 0:
                If current_key is not equal to 0:
                    call_function_1(free_key, current_key)
                End If
            End If

            Let free_value be memory_get_pointer(table, 48)
            Let current_value be memory_get_pointer(current, 8)
            If free_value is not equal to 0:
                If current_value is not equal to 0:
                    call_function_1(free_value, current_value)
                End If
            End If

            deallocate(current)

            Let entry_count be memory_get_integer(table, 16)
            memory_set_integer(table, 16, entry_count minus 1)

            Return 1
        End If
        Set prev to current
        Set current to memory_get_pointer(current, 16)  Note: next
    End While

    Return 0
End Process

Process called "hashtable_contains" takes table as Integer, key as Integer returns Integer:
    Let value be hashtable_get(table, key)
    If value is not equal to 0:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Process called "hashtable_size" takes table as Integer returns Integer:
    If table is not equal to 0:
        Return memory_get_int32(table, 16)  Note: entry_count
    Otherwise:
        Return 0
    End If
End Process

Process called "hashtable_clear" takes table as Integer returns Integer:
    If table is equal to 0:
        Return 0
    End If

    Let bucket_count be memory_get_integer(table, 8)
    Let buckets be memory_get_pointer(table, 0)
    Let free_key be memory_get_pointer(table, 40)
    Let free_value be memory_get_pointer(table, 48)

    Let i be 0
    While i is less than bucket_count:
        Let current be memory_get_pointer_at_index(buckets, i)
        While current is not equal to 0:
            Let next be memory_get_pointer(current, 16)

            Note: Free key and value if destructors are provided
            If free_key is not equal to 0:
                Let current_key be memory_get_pointer(current, 0)
                If current_key is not equal to 0:
                    call_function_1(free_key, current_key)
                End If
            End If

            If free_value is not equal to 0:
                Let current_value be memory_get_pointer(current, 8)
                If current_value is not equal to 0:
                    call_function_1(free_value, current_value)
                End If
            End If

            deallocate(current)
            Set current to next
        End While
        memory_set_pointer_at_index(buckets, i, 0)
        Set i to i plus 1
    End While

    memory_set_int32(table, 16, 0)  Note: entry_count = 0

    Return 0
End Process

Note: ==== Iterator Implementation ====

Process called "hashtable_iterator_create" takes table as Integer returns Integer:
    If table is equal to 0:
        Return 0
    End If

    Let iter be allocate(24)  Note: sizeof(HashIterator)
    If iter is equal to 0:
        Return 0
    End If

    memory_set_pointer(iter, 0, table)
    memory_set_integer(iter, 8, 0)  Note: bucket_index
    memory_set_pointer(iter, 16, 0)  Note: current_entry

    Note: Find the first non-empty bucket
    Let bucket_count be memory_get_integer(table, 8)
    Let buckets be memory_get_pointer(table, 0)

    Let i be 0
    While i is less than bucket_count:
        Let entry be memory_get_pointer_at_index(buckets, i)
        If entry is not equal to 0:
            memory_set_integer(iter, 8, i)
            memory_set_pointer(iter, 16, entry)
            Return iter
        End If
        Set i to i plus 1
    End While

    Return iter
End Process

Process called "hashtable_iterator_has_next" takes iter as Integer returns Integer:
    If iter is equal to 0:
        Return 0
    End If
    Let current_entry be memory_get_pointer(iter, 16)
    If current_entry is not equal to 0:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Process called "hashtable_iterator_next" takes iter as Integer, key_ptr as Integer, value_ptr as Integer returns Integer:
    If iter is equal to 0:
        If key_ptr is not equal to 0:
            memory_set_pointer(key_ptr, 0, 0)
        End If
        If value_ptr is not equal to 0:
            memory_set_pointer(value_ptr, 0, 0)
        End If
        Return 0
    End If

    Let current_entry be memory_get_pointer(iter, 16)
    If current_entry is equal to 0:
        If key_ptr is not equal to 0:
            memory_set_pointer(key_ptr, 0, 0)
        End If
        If value_ptr is not equal to 0:
            memory_set_pointer(value_ptr, 0, 0)
        End If
        Return 0
    End If

    Note: Return current entry's key and value
    If key_ptr is not equal to 0:
        Let key be memory_get_pointer(current_entry, 0)
        memory_set_pointer(key_ptr, 0, key)
    End If
    If value_ptr is not equal to 0:
        Let value be memory_get_pointer(current_entry, 8)
        memory_set_pointer(value_ptr, 0, value)
    End If

    Note: Move to next entry
    Let next_entry be memory_get_pointer(current_entry, 16)
    memory_set_pointer(iter, 16, next_entry)

    Note: If no more entries in current bucket, find next non-empty bucket
    If next_entry is equal to 0:
        Let table be memory_get_pointer(iter, 0)
        Let bucket_count be memory_get_integer(table, 8)
        Let buckets be memory_get_pointer(table, 0)
        Let bucket_index be memory_get_integer(iter, 8)

        Let i be bucket_index plus 1
        While i is less than bucket_count:
            Let entry be memory_get_pointer_at_index(buckets, i)
            If entry is not equal to 0:
                memory_set_integer(iter, 8, i)
                memory_set_pointer(iter, 16, entry)
                Return 1
            End If
            Set i to i plus 1
        End While
    End If

    Return 1
End Process

Process called "hashtable_iterator_destroy" takes iter as Integer returns Integer:
    deallocate(iter)
    Return 0
End Process

Note: ==== Hash Functions ====

Note: Hash function for string keys (djb2 algorithm) - EXACT PRESERVATION
Process called "hash_string" takes key as Integer returns Integer:
    Let str_ptr be key
    Let hash be 5381

    Let c be memory_get_byte(str_ptr, 0)
    Let offset be 0
    While c is not equal to 0:
        Note: hash = ((hash << 5) + hash) + c  which is hash * 33 + c
        Note: Using hash * 32 for now - bit_shift_left not available in v0.0.7.5
        Let hash_shifted be hash multiplied by 32
        Set hash to hash_shifted plus hash
        Set hash to hash plus c
        Set offset to offset plus 1
        Set c to memory_get_byte(str_ptr, offset)
    End While

    Return hash
End Process

Note: Compare function for string keys
Process called "compare_strings" takes key1 as Integer, key2 as Integer returns Integer:
    Let result be string_compare(key1, key2)
    If result is equal to 0:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Note: Hash function for integer keys - EXACT PRESERVATION of mixing algorithm
Process called "hash_integer" takes key as Integer returns Integer:
    Note: Treat the pointer as pointing to an integer
    Let value be memory_get_integer(key, 0)

    Note: Simple arithmetic hash mixing without bitwise operations
    Note: Use multiplication and modulo for distribution
    Let magic1 be 13787848793156543929  Note: 0xbf58476d1ce4e5b9
    Set value to value multiplied by magic1

    Note: Add some mixing with division and modulo
    Let temp be value divided by 1073741824  Note: 2^30
    Set value to value plus temp

    Let magic2 be 10723151780598845931  Note: 0x94d049bb133111eb
    Set value to value multiplied by magic2

    Note: Final mixing
    Let temp2 be value divided by 134217728  Note: 2^27
    Set value to value plus temp2

    Note: Ensure positive value
    If value is less than 0:
        Set value to 0 minus value
    End If

    Return value
End Process

Note: Compare function for integer keys
Process called "compare_integers" takes key1 as Integer, key2 as Integer returns Integer:
    Let val1 be memory_get_integer(key1, 0)
    Let val2 be memory_get_integer(key2, 0)
    If val1 is equal to val2:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Note: Hash function for pointer keys
Process called "hash_pointer" takes key as Integer returns Integer:
    Note: Hash the pointer value itself
    Let ptr_value be key

    Note: Mix using arithmetic operations instead of bitwise
    Note: Divide by 2^32 and add to original for mixing
    Let temp be ptr_value divided by 4294967296  Note: 2^32
    Set ptr_value to ptr_value plus temp

    Note: ptr_value = ptr_value * 0x9e3779b97f4a7c15ULL
    Let magic be 11400714819323198485  Note: 0x9e3779b97f4a7c15
    Set ptr_value to ptr_value multiplied by magic

    Note: Final mixing with division
    Let temp2 be ptr_value divided by 4294967296  Note: 2^32
    Set ptr_value to ptr_value plus temp2

    Note: Ensure positive value
    If ptr_value is less than 0:
        Set ptr_value to 0 minus ptr_value
    End If

    Return ptr_value
End Process

Note: Compare function for pointer keys
Process called "compare_pointers" takes key1 as Integer, key2 as Integer returns Integer:
    If key1 is equal to key2:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Note: ==== Statistics ====

Process called "hashtable_get_stats" takes table as Integer, stats as Integer returns Integer:
    If table is equal to 0:
        Note: Initialize stats to zero
        memory_set_int32(stats, 0, 0)  Note: bucket_count
        memory_set_int32(stats, 8, 0)  Note: entry_count
        memory_set_integer(stats, 16, 0)  Note: empty_buckets
        memory_set_integer(stats, 24, 0)  Note: max_chain_length
        memory_set_integer(stats, 32, 0)  Note: average_chain_length
        memory_set_integer(stats, 40, 0)  Note: load_factor
        Return 0
    End If

    Let bucket_count be memory_get_integer(table, 8)
    Let entry_count be memory_get_integer(table, 16)
    Let buckets be memory_get_pointer(table, 0)

    memory_set_integer(stats, 0, bucket_count)
    memory_set_integer(stats, 8, entry_count)

    Let total_chain_length be 0
    Let max_chain_length be 0
    Let empty_buckets be 0

    Let i be 0
    While i is less than bucket_count:
        Let current be memory_get_pointer_at_index(buckets, i)
        If current is equal to 0:
            Set empty_buckets to empty_buckets plus 1
        Otherwise:
            Let chain_length be 0
            While current is not equal to 0:
                Set chain_length to chain_length plus 1
                Set current to memory_get_pointer(current, 16)  Note: next
            End While
            Set total_chain_length to total_chain_length plus chain_length
            If chain_length is greater than max_chain_length:
                Set max_chain_length to chain_length
            End If
        End If
        Set i to i plus 1
    End While

    memory_set_integer(stats, 16, empty_buckets)
    memory_set_integer(stats, 24, max_chain_length)

    Note: Calculate average chain length (multiplied by 100 for integer representation)
    Let non_empty_buckets be bucket_count minus empty_buckets
    Let average_chain_length be 0
    If non_empty_buckets is greater than 0:
        Set average_chain_length to total_chain_length multiplied by 100
        Set average_chain_length to average_chain_length divided by non_empty_buckets
    End If
    memory_set_integer(stats, 32, average_chain_length)

    Note: Calculate load factor (multiplied by 100 for integer representation)
    Let load_factor be entry_count multiplied by 100
    Set load_factor to load_factor divided by bucket_count
    memory_set_integer(stats, 40, load_factor)

    Return 1
End Process

Process called "hashtable_print_stats" takes table as Integer returns Integer:
    Let stats be allocate(48)  Note: sizeof(HashTableStats)
    hashtable_get_stats(table, stats)

    print_string("Hash Table Statistics:")
    print_string("  Bucket count: ")
    print_integer(memory_get_integer(stats, 0))
    print_string("  Entry count: ")
    print_integer(memory_get_integer(stats, 8))
    print_string("  Empty buckets: ")
    print_integer(memory_get_integer(stats, 16))
    print_string("  Max chain length: ")
    print_integer(memory_get_integer(stats, 24))
    print_string("  Average chain length: ")
    print_integer(memory_get_integer(stats, 32))  Note: Already multiplied by 100
    print_string("  Load factor: ")
    print_integer(memory_get_integer(stats, 40))  Note: Already multiplied by 100

    deallocate(stats)
    Return 0
End Process

Note: ==== Memory Helper Functions ====

Process called "call_function_1" takes func as Integer, arg1 as Integer returns Integer:
    Note: This will be implemented by runtime to call function pointer with 1 arg
    Return 0
End Process

Process called "call_function_2" takes func as Integer, arg1 as Integer, arg2 as Integer returns Integer:
    Note: This will be implemented by runtime to call function pointer with 2 args
    Return 0
End Process

Note: Runtime memory functions - provided by C runtime library
Note: memory_get_byte, memory_set_pointer, memory_get_pointer are external

Note: memory_set_integer and memory_get_integer are external runtime functions
Note: They will be linked from the C runtime (runtime_system.c)
Note: No Runa implementation needed - the compiler will generate PLT calls

Note: More runtime functions - provided by C runtime library
Note: memory_set_pointer_at_index, memory_get_pointer_at_index
Note: allocate, deallocate, string_compare are all external