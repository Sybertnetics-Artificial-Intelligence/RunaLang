Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: String Utilities for Runa v0.0.7.5 Bootstrap Compiler
Note: Refactored to work within v0.0.7.3 compiler limitations
Note: - No Character type (use Integer for ASCII values)
Note: - No complex boolean expressions in While loops
Note: - No function calls in conditions

Note: ==== Basic String Functions ====

Process called "string_length" takes str as Integer returns Integer:
    If str is equal to 0:
        Return 0
    End If
    Let f1_len be 0
    Let f1_sl_loop be 1
    While f1_sl_loop is equal to 1:
        Let f1_sl_ch be memory_get_byte(str, f1_len)
        If f1_sl_ch is equal to 0:
            Let f1_sl_loop be 0
        Otherwise:
            Let f1_len be f1_len plus 1
        End If
    End While
    Return f1_len
End Process

Process called "string_char_at" takes str as Integer, index as Integer returns Integer:
    If str is equal to 0:
        Return 0
    End If
    Let f2_sc_char be memory_get_byte(str, index)
    Return f2_sc_char
End Process

Process called "string_equals" takes str1 as Integer, str2 as Integer returns Integer:
    If str1 is equal to 0:
        If str2 is equal to 0:
            Return 1
        End If
        Return 0
    End If
    If str2 is equal to 0:
        Return 0
    End If

    Let f3_se_i be 0
    Let f3_se_loop be 1
    While f3_se_loop is equal to 1:
        Let f3_se_c1 be memory_get_byte(str1, f3_se_i)
        Let f3_se_c2 be memory_get_byte(str2, f3_se_i)
        If f3_se_c1 is not equal to f3_se_c2:
            Return 0
        End If
        If f3_se_c1 is equal to 0:
            Let f3_se_loop be 0
        Otherwise:
            Let f3_se_i be f3_se_i plus 1
        End If
    End While
    Return 1
End Process

Process called "is_digit" takes char as Integer returns Integer:
    Let f4_zero be 48  Note: ASCII '0'
    Let f4_nine be 57  Note: ASCII '9'
    If char is greater than or equal to f4_zero:
        If char is less than or equal to f4_nine:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "is_alpha" takes char as Integer returns Integer:
    Let f5_upper_a be 65  Note: ASCII 'A'
    Let f5_upper_z be 90  Note: ASCII 'Z'
    Let f5_lower_a be 97  Note: ASCII 'a'
    Let f5_lower_z be 122 Note: ASCII 'z'

    If char is greater than or equal to f5_upper_a:
        If char is less than or equal to f5_upper_z:
            Return 1
        End If
    End If

    If char is greater than or equal to f5_lower_a:
        If char is less than or equal to f5_lower_z:
            Return 1
        End If
    End If

    Return 0
End Process

Process called "is_whitespace" takes char as Integer returns Integer:
    Let f6_space be 32     Note: ASCII f6_space
    Let f6_tab be 9        Note: ASCII f6_tab
    Let f6_newline be 10   Note: ASCII f6_newline
    Let f6_cr be 13        Note: ASCII carriage return

    If char is equal to f6_space:
        Return 1
    End If
    If char is equal to f6_tab:
        Return 1
    End If
    If char is equal to f6_newline:
        Return 1
    End If
    If char is equal to f6_cr:
        Return 1
    End If
    Return 0
End Process

Process called "integer_to_string" takes value as Integer returns Integer:
    Note: Handle special case of 0
    If value is equal to 0:
        Let f7_str be memory_allocate(2)
        memory_set_byte(f7_str, 0, 48)  Note: ASCII '0'
        memory_set_byte(f7_str, 1, 0)   Note: null terminator
        Return f7_str
    End If

    Note: Handle negative numbers
    Let f7_is_negative be 0
    Let f7_num be value
    If value is less than 0:
        Let f7_is_negative be 1
        Let f7_num be -value
    End If

    Note: Count digits
    Let f7_digit_count be 0
    Let f7_temp be f7_num
    While f7_temp is greater than 0:
        Let f7_digit_count be f7_digit_count plus 1
        Let f7_temp be f7_temp divided by 10
    End While

    Note: Allocate string (digits + sign + null)
    Let f7_size be f7_digit_count plus 1
    If f7_is_negative is equal to 1:
        Let f7_size be f7_size plus 1
    End If
    Let f7_str be memory_allocate(f7_size)

    Note: Fill from the end
    Let f7_pos be f7_digit_count
    If f7_is_negative is equal to 1:
        Let f7_pos be f7_pos plus 1
    End If
    memory_set_byte(f7_str, f7_pos, 0)  Note: null terminator

    Note: Add digits from right to left
    Let f7_temp be f7_num
    Let f7_pos be f7_digit_count minus 1
    If f7_is_negative is equal to 1:
        Let f7_pos be f7_pos plus 1
    End If

    While f7_temp is greater than 0:
        Note: f7_temp modulo 10 = f7_temp - (f7_temp / 10) * 10
        Let f7_temp_div_10 be f7_temp divided by 10
        Let f7_temp_mult_10 be f7_temp_div_10 multiplied by 10
        Let f7_digit be f7_temp minus f7_temp_mult_10
        Let f7_ascii_digit be f7_digit plus 48  Note: Convert to ASCII
        memory_set_byte(f7_str, f7_pos, f7_ascii_digit)
        Let f7_pos be f7_pos minus 1
        Let f7_temp be f7_temp divided by 10
    End While

    Note: Add minus sign if negative
    If f7_is_negative is equal to 1:
        memory_set_byte(f7_str, 0, 45)  Note: ASCII '-'
    End If

    Return f7_str
End Process

Note: memory_get_byte and memory_set_byte are provided as externs from runtime

Process called "bit_not" takes value as Integer returns Integer:
    Note: Bitwise NOT operation replaced with arithmetic
    Note: For 64-bit signed integers, ~x = -(x + 1)
    Let f8_temp be value plus 1
    Let f8_result be -f8_temp
    Return f8_result
End Process

Note: memory_set_pointer and memory_get_pointer are provided by runtime

Process called "system_write" takes fd as Integer, buffer as Integer, count as Integer returns Integer:
    Note: System call for write (syscall number 1)
    Let f9_syscall_write be 1
    Let f9_result be system_call(f9_syscall_write, fd, buffer, count)
    Return f9_result
End Process

Process called "string_to_integer" takes str as Integer returns Integer:
    Note: Convert string to integer
    If str is equal to 0:
        Return 0
    End If

    Let f10_result be 0
    Let f10_i be 0
    Let f10_is_negative be 0

    Note: Check for negative sign
    Let f10_first_char be memory_get_byte(str, 0)
    Let f10_minus_char be 45  Note: ASCII '-'
    If f10_first_char is equal to f10_minus_char:
        Let f10_is_negative be 1
        Let f10_i be 1
    End If

    Note: Parse digits
    Let f10_continue_loop be 1
    While f10_continue_loop is equal to 1:
        Let f10_char be memory_get_byte(str, f10_i)
        If f10_char is equal to 0:
            Let f10_continue_loop be 0
        Otherwise:
            Let f10_is_dig be is_digit(f10_char)
            If f10_is_dig is equal to 1:
                Let f10_result be f10_result multiplied by 10
                Let f10_zero_char be 48  Note: ASCII '0'
                Let f10_digit be f10_char minus f10_zero_char
                Let f10_result be f10_result plus f10_digit
                Let f10_i be f10_i plus 1
            Otherwise:
                Let f10_continue_loop be 0
            End If
        End If
    End While

    If f10_is_negative is equal to 1:
        Let f10_result be -f10_result
    End If

    Return f10_result
End Process

Process called "memory_reallocate" takes ptr as Integer, new_size as Integer returns Integer:
    Note: The runtime's reallocate takes 3 parameters (ptr, old_size, new_size)
    Note: but we only have ptr and new_size, so we'll use a simpler approach:
    Note: IMPORTANT: Do NOT use reallocate(ptr, 0, new_size) as it zeros the buffer!
    If ptr is equal to 0:
        Return allocate(new_size)
    End If
    Note: Use a direct realloc that preserves existing data
    Note: This external function is provided by the runtime
    Return memory_realloc(ptr, new_size)
End Process

Note: ==== Type Definitions ====
Note: WORKAROUND: Types commented out due to v0.0.7.3 bug with Type+Let combo
Note: Once v0.0.7.5 is self-hosted, uncomment these

Note: Type called "StringBuilder":
Note:     buffer as Integer,      Note: Pointer to char buffer
Note:     capacity as Integer,
Note:     length as Integer
Note: End Type

Note: Type called "StringTokenizer":
Note:     string as Integer,      Note: Pointer to string
Note:     current as Integer,     Note: Current position pointer
Note:     delimiters as Integer,  Note: Pointer to delimiters string
Note:     own_string as Integer   Note: Boolean flag
Note: End Type

Note: Type called "StringArray":
Note:     strings as Integer,     Note: Pointer to string arr
Note:     count as Integer,
Note:     capacity as Integer
Note: End Type

Note: ==== String Builder Implementation ====

Process called "string_builder_create_with_capacity" takes initial_capacity as Integer returns Integer:
    Let f12_sb be allocate(24)  Note: sizeof(StringBuilder) = 3 * 8 bytes
    If f12_sb is equal to 0:
        Return 0
    End If

    Let f12_buffer be allocate(initial_capacity)
    If f12_buffer is equal to 0:
        deallocate(f12_sb)
        Return 0
    End If

    Note: Initialize f12_buffer with null terminator
    memory_set_byte(f12_buffer, 0, 0)

    Note: Set StringBuilder fields
    memory_set_pointer(f12_sb, 0, f12_buffer)           Note: f12_sb->f12_buffer = f12_buffer
    memory_set_int32(f12_sb, 8, initial_capacity)  Note: f12_sb->capacity = initial_capacity
    memory_set_integer(f12_sb, 16, 0)               Note: f12_sb->length = 0

    Return f12_sb
End Process

Process called "string_builder_create" returns Integer:
    Return string_builder_create_with_capacity(256)
End Process

Process called "string_builder_destroy" takes sb as Integer returns Integer:
    If sb is not equal to 0:
        Let f14_buffer be memory_get_pointer(sb, 0)
        deallocate(f14_buffer)
        deallocate(sb)
    End If
    Return 0
End Process

Process called "string_builder_ensure_capacity" takes sb as Integer, needed as Integer returns Integer:
    Let f15_current_length be memory_get_integer(sb, 16)
    Let f15_current_capacity be memory_get_integer(sb, 8)
    Let f15_total_needed be f15_current_length plus needed

    If f15_total_needed is greater than or equal to f15_current_capacity:
        Let f15_new_capacity be f15_current_capacity multiplied by 2

        Note: Keep doubling capacity until it's large enough
        Let f15_capacity_ok be 0
        While f15_capacity_ok is equal to 0:
            If f15_new_capacity is greater than f15_total_needed:
                Let f15_capacity_ok be 1
            Otherwise:
                Let f15_new_capacity be f15_new_capacity multiplied by 2
            End If
        End While

        Let f15_old_buffer be memory_get_pointer(sb, 0)
        Let f15_new_buffer be reallocate(f15_old_buffer, f15_new_capacity)
        If f15_new_buffer is equal to 0:
            Return 0  Note: false
        End If

        memory_set_pointer(sb, 0, f15_new_buffer)
        memory_set_integer(sb, 8, f15_new_capacity)
    End If
    Return 1  Note: true
End Process

Process called "string_builder_append" takes sb as Integer, str as String returns Integer:
    If sb is equal to 0:
        Return 0  Note: false
    End If

    Let f16_len be string_length(str)
    If f16_len is equal to 0:
        Return 1  Note: true - empty string append succeeds
    End If

    Let f16_ensure_result be string_builder_ensure_capacity(sb, f16_len)
    If f16_ensure_result is equal to 0:
        Return 0  Note: false
    End If

    Let f16_buffer be memory_get_pointer(sb, 0)
    Let f16_current_length be memory_get_integer(sb, 16)

    Note: Copy string to f16_buffer at current position
    memory_copy_string(f16_buffer, f16_current_length, str)

    Note: Update length
    memory_set_integer(sb, 16, f16_current_length plus f16_len)

    Return 1  Note: true
End Process

Process called "string_builder_append_char" takes sb as Integer, c as Integer returns Integer:
    Note: c is ASCII value instead of Character
    If sb is equal to 0:
        Return 0  Note: false
    End If

    Let f17_ensure_result be string_builder_ensure_capacity(sb, 1)
    If f17_ensure_result is equal to 0:
        Return 0  Note: false
    End If

    Let f17_buffer be memory_get_pointer(sb, 0)
    Let f17_current_length be memory_get_integer(sb, 16)

    Note: Set character at current position
    memory_set_byte(f17_buffer, f17_current_length, c)
    Let f17_current_length be f17_current_length plus 1

    Note: Add null terminator
    memory_set_byte(f17_buffer, f17_current_length, 0)

    Note: Update length
    memory_set_integer(sb, 16, f17_current_length)

    Return 1  Note: true
End Process

Process called "string_builder_append_int" takes sb as Integer, value as Integer returns Integer:
    Let f18_buffer_str be integer_to_string(value)
    Return string_builder_append(sb, f18_buffer_str)
End Process

Process called "string_builder_to_string" takes sb as Integer returns String:
    If sb is equal to 0:
        Return ""
    End If

    Let f19_result_buffer be memory_get_pointer(sb, 0)
    Let f19_result_str be memory_pointer_to_string(f19_result_buffer)

    Note: Reset StringBuilder to empty state
    Let f19_new_buffer be allocate(1)
    memory_set_byte(f19_new_buffer, 0, 0)
    memory_set_pointer(sb, 0, f19_new_buffer)
    memory_set_integer(sb, 8, 1)
    memory_set_integer(sb, 16, 0)

    Return f19_result_str
End Process

Process called "string_builder_get_string" takes sb as Integer returns String:
    If sb is equal to 0:
        Return ""
    End If
    Let f20_buffer be memory_get_pointer(sb, 0)
    Return memory_pointer_to_string(f20_buffer)
End Process

Process called "string_builder_length" takes sb as Integer returns Integer:
    If sb is equal to 0:
        Return 0
    End If
    Return memory_get_integer(sb, 16)
End Process

Process called "string_builder_clear" takes sb as Integer returns Integer:
    If sb is not equal to 0:
        Let f22_buffer be memory_get_pointer(sb, 0)
        memory_set_byte(f22_buffer, 0, 0)
        memory_set_integer(sb, 16, 0)
    End If
    Return 0
End Process

Note: ==== String Tokenizer Implementation ====

Process called "string_tokenizer_create" takes str as String, delimiters as String returns Integer:
    If string_length(str) is equal to 0:
        Return 0
    End If
    If string_length(delimiters) is equal to 0:
        Return 0
    End If

    Let f23_tokenizer be allocate(32)  Note: sizeof(StringTokenizer)
    If f23_tokenizer is equal to 0:
        Return 0
    End If

    Let f23_str_copy be string_duplicate(str)
    If f23_str_copy is equal to 0:
        deallocate(f23_tokenizer)
        Return 0
    End If

    memory_set_pointer(f23_tokenizer, 0, f23_str_copy)
    memory_set_pointer(f23_tokenizer, 8, f23_str_copy)

    Note: Store delimiters as a duplicated string pointer
    Let f23_delim_copy be string_duplicate(delimiters)
    memory_set_pointer(f23_tokenizer, 16, f23_delim_copy)
    memory_set_integer(f23_tokenizer, 24, 1)

    Return f23_tokenizer
End Process

Process called "string_tokenizer_next" takes tokenizer as Integer returns String:
    If tokenizer is equal to 0:
        Return ""
    End If

    Let f24_current_ptr be memory_get_pointer(tokenizer, 8)
    If f24_current_ptr is equal to 0:
        Return ""
    End If

    Let f24_delimiters_ptr be memory_get_pointer(tokenizer, 16)
    Let f24_delimiters be memory_pointer_to_string(f24_delimiters_ptr)

    Note: Skip leading f24_delimiters
    Let f24_offset be 0
    Let f24_continue_skip be 1
    While f24_continue_skip is equal to 1:
        Let f24_current_char be memory_get_byte(f24_current_ptr, f24_offset)
        If f24_current_char is equal to 0:
            Let f24_continue_skip be 0
        Otherwise:
            Let f24_is_delim be string_contains_char_value(f24_delimiters, f24_current_char)
            If f24_is_delim is equal to 0:
                Let f24_continue_skip be 0
            Otherwise:
                Let f24_offset be f24_offset plus 1
            End If
        End If
    End While

    Note: Check if we reached end of string
    Let f24_current_char be memory_get_byte(f24_current_ptr, f24_offset)
    If f24_current_char is equal to 0:
        memory_set_pointer(tokenizer, 8, 0)
        Return ""
    End If

    Let f24_token_start_offset be f24_offset

    Note: Find next delimiter
    Let f24_continue_scan be 1
    While f24_continue_scan is equal to 1:
        Let f24_current_char be memory_get_byte(f24_current_ptr, f24_offset)
        If f24_current_char is equal to 0:
            Let f24_continue_scan be 0
        Otherwise:
            Let f24_is_delim be string_contains_char_value(f24_delimiters, f24_current_char)
            If f24_is_delim is equal to 1:
                Let f24_continue_scan be 0
            Otherwise:
                Let f24_offset be f24_offset plus 1
            End If
        End If
    End While

    Note: Extract token
    Let f24_token_length be f24_offset minus f24_token_start_offset
    Let f24_token be memory_get_substring(f24_current_ptr, f24_token_start_offset, f24_token_length)

    Note: Update current position
    Let f24_current_char be memory_get_byte(f24_current_ptr, f24_offset)
    If f24_current_char is not equal to 0:
        memory_set_byte(f24_current_ptr, f24_offset, 0)
        Let f24_new_current be memory_pointer_offset(f24_current_ptr, f24_offset plus 1)
        memory_set_pointer(tokenizer, 8, f24_new_current)
    Otherwise:
        memory_set_pointer(tokenizer, 8, 0)
    End If

    Return f24_token
End Process

Process called "string_tokenizer_has_next" takes tokenizer as Integer returns Integer:
    If tokenizer is equal to 0:
        Return 0
    End If

    Let f25_current_ptr be memory_get_pointer(tokenizer, 8)
    If f25_current_ptr is equal to 0:
        Return 0
    End If

    Let f25_delimiters_ptr be memory_get_pointer(tokenizer, 16)
    Let f25_delimiters be memory_pointer_to_string(f25_delimiters_ptr)

    Note: Skip f25_delimiters to check if there's a token
    Let f25_offset be 0
    Let f25_continue_check be 1
    While f25_continue_check is equal to 1:
        Let f25_temp_char be memory_get_byte(f25_current_ptr, f25_offset)
        If f25_temp_char is equal to 0:
            Let f25_continue_check be 0
        Otherwise:
            Let f25_is_delim be string_contains_char_value(f25_delimiters, f25_temp_char)
            If f25_is_delim is equal to 0:
                Let f25_continue_check be 0
            Otherwise:
                Let f25_offset be f25_offset plus 1
            End If
        End If
    End While

    Let f25_temp_char be memory_get_byte(f25_current_ptr, f25_offset)
    If f25_temp_char is equal to 0:
        Return 0
    Otherwise:
        Return 1
    End If
End Process

Process called "string_tokenizer_destroy" takes tokenizer as Integer returns Integer:
    If tokenizer is not equal to 0:
        Let f26_own_string be memory_get_byte(tokenizer, 24)
        If f26_own_string is equal to 1:
            Let f26_string_ptr be memory_get_pointer(tokenizer, 0)
            deallocate(f26_string_ptr)
            Let f26_delimiters_ptr be memory_get_pointer(tokenizer, 16)
            deallocate(f26_delimiters_ptr)
        End If
        deallocate(tokenizer)
    End If
    Return 0
End Process

Note: ==== String Array Implementation ====

Process called "string_array_create" returns Integer:
    Let f27_arr be allocate(24)  Note: sizeof(StringArray)
    If f27_arr is equal to 0:
        Return 0
    End If

    Let f27_initial_capacity be 8
    Let f27_strings_ptr be allocate(f27_initial_capacity multiplied by 8)
    If f27_strings_ptr is equal to 0:
        deallocate(f27_arr)
        Return 0
    End If

    memory_set_pointer(f27_arr, 0, f27_strings_ptr)
    memory_set_integer(f27_arr, 8, 0)
    memory_set_integer(f27_arr, 16, f27_initial_capacity)

    Return f27_arr
End Process

Process called "string_array_add" takes arr as Integer, str as String returns Integer:
    If arr is equal to 0:
        Return 0
    End If

    Let f28_count be memory_get_integer(arr, 8)
    Let f28_capacity be memory_get_int32(arr, 16)

    Note: Resize if needed
    If f28_count is greater than or equal to f28_capacity:
        Let f28_new_capacity be f28_capacity multiplied by 2
        Let f28_old_strings be memory_get_pointer(arr, 0)
        Let f28_new_strings be reallocate(f28_old_strings, f28_new_capacity multiplied by 8)
        If f28_new_strings is equal to 0:
            Return 0
        End If
        memory_set_pointer(arr, 0, f28_new_strings)
        memory_set_integer(arr, 16, f28_new_capacity)
    End If

    Note: Add string
    Let f28_strings_ptr be memory_get_pointer(arr, 0)
    Let f28_str_copy be string_duplicate(str)
    Let f28_offset be f28_count multiplied by 8
    memory_set_pointer(f28_strings_ptr, f28_offset, f28_str_copy)

    Note: Update f28_count
    memory_set_integer(arr, 8, f28_count plus 1)

    Return 1
End Process

Process called "string_array_destroy" takes arr as Integer returns Integer:
    If arr is not equal to 0:
        Let f29_count be memory_get_integer(arr, 8)
        Let f29_strings_ptr be memory_get_pointer(arr, 0)

        Note: Free all strings
        Let f29_i be 0
        While f29_i is less than f29_count:
            Let f29_offset be f29_i multiplied by 8
            Let f29_str_ptr be memory_get_pointer(f29_strings_ptr, f29_offset)
            deallocate(f29_str_ptr)
            Let f29_i be f29_i plus 1
        End While

        deallocate(f29_strings_ptr)
        deallocate(arr)
    End If
    Return 0
End Process

Note: ==== Basic String Utilities ====

Process called "string_duplicate" takes str as String returns Integer:
    Let f30_len be string_length(str)
    Let f30_result be allocate(f30_len plus 1)
    If f30_result is equal to 0:
        Return 0
    End If

    memory_copy_string_to_buffer(f30_result, str)
    Return f30_result
End Process

Process called "string_starts_with" takes str as String, prefix as String returns Integer:
    Let f31_str_len be string_length(str)
    Let f31_prefix_len be string_length(prefix)

    If f31_prefix_len is greater than f31_str_len:
        Return 0
    End If

    Let f31_str_prefix be string_substring(str, 0, f31_prefix_len)
    If string_equals(f31_str_prefix, prefix):
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Process called "string_ends_with" takes str as String, suffix as String returns Integer:
    Let f32_str_len be string_length(str)
    Let f32_suffix_len be string_length(suffix)

    If f32_suffix_len is greater than f32_str_len:
        Return 0
    End If

    Let f32_start_pos be f32_str_len minus f32_suffix_len
    Let f32_str_suffix be string_substring(str, f32_start_pos, f32_suffix_len)
    If string_equals(f32_str_suffix, suffix):
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Process called "string_contains" takes str as String, substring as String returns Integer:
    Let f33_pos be string_find(str, substring)
    If f33_pos is less than 0:
        Return 0
    Otherwise:
        Return 1
    End If
End Process

Process called "string_is_empty" takes str as String returns Integer:
    If string_length(str) is equal to 0:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Process called "string_is_whitespace" takes str as String returns Integer:
    Let f35_len be string_length(str)
    If f35_len is equal to 0:
        Return 1
    End If

    Let f35_i be 0
    While f35_i is less than f35_len:
        Let f35_ch be string_char_at(str, f35_i)
        Let f35_ch_value be ascii_value_of(f35_ch)
        Note: Check for space (32), tab (9), newline (10), carriage return (13)
        Let f35_is_ws be 0
        If f35_ch_value is equal to 32:
            Let f35_is_ws be 1
        End If
        If f35_ch_value is equal to 9:
            Let f35_is_ws be 1
        End If
        If f35_ch_value is equal to 10:
            Let f35_is_ws be 1
        End If
        If f35_ch_value is equal to 13:
            Let f35_is_ws be 1
        End If

        If f35_is_ws is equal to 0:
            Return 0  Note: Found non-whitespace
        End If
        Let f35_i be f35_i plus 1
    End While

    Return 1  Note: All whitespace
End Process

Process called "string_is_numeric" takes str as String returns Integer:
    Let f36_len be string_length(str)
    If f36_len is equal to 0:
        Return 0
    End If

    Let f36_i be 0
    Note: Check for optional leading minus
    Let f36_ch be string_char_at(str, 0)
    Let f36_ch_value be ascii_value_of(f36_ch)
    If f36_ch_value is equal to 45:  Note: '-'
        Let f36_i be 1
        If f36_len is equal to 1:
            Return 0  Note: Just "-" is not numeric
        End If
    End If

    While f36_i is less than f36_len:
        Let f36_ch be string_char_at(str, f36_i)
        Let f36_is_d be is_digit(f36_ch)
        If f36_is_d is equal to 0:
            Return 0
        End If
        Let f36_i be f36_i plus 1
    End While

    Return 1
End Process

Note: ==== Helper Functions ====

Process called "string_contains_char_value" takes str as String, char_value as Integer returns Integer:
    Let f37_len be string_length(str)
    Let f37_i be 0
    While f37_i is less than f37_len:
        Let f37_ch be string_char_at(str, f37_i)
        Let f37_ch_val be ascii_value_of(f37_ch)
        If f37_ch_val is equal to char_value:
            Return 1
        End If
        Let f37_i be f37_i plus 1
    End While
    Return 0
End Process

Process called "string_util_split" takes str as String, delimiter as String returns Integer:
    Let f38_arr be string_array_create()
    If f38_arr is equal to 0:
        Return 0
    End If

    Let f38_tokenizer be string_tokenizer_create(str, delimiter)
    If f38_tokenizer is equal to 0:
        string_array_destroy(f38_arr)
        Return 0
    End If

    Let f38_has_more be string_tokenizer_has_next(f38_tokenizer)
    While f38_has_more is equal to 1:
        Let f38_token be string_tokenizer_next(f38_tokenizer)
        string_array_add(f38_arr, f38_token)
        Let f38_has_more be string_tokenizer_has_next(f38_tokenizer)
    End While

    string_tokenizer_destroy(f38_tokenizer)
    Return f38_arr
End Process

Note: ==== Memory Helper Functions ====
Note: Memory functions are implemented above (lines 177-201) or provided by runtime

Process called "memory_copy_string" takes ptr as Integer, offset as Integer, str as String returns Integer:
    Note: Copy string to ptr + offset
    Let f39_dest be ptr plus offset
    Let f39_src be str  Note: String is already a pointer
    Let f39_i be 0
    Let f39_continue_loop be 1

    While f39_continue_loop is equal to 1:
        Let f39_char be memory_get_byte(f39_src, f39_i)
        memory_set_byte(f39_dest, f39_i, f39_char)
        If f39_char is equal to 0:
            Let f39_continue_loop be 0
        Otherwise:
            Let f39_i be f39_i plus 1
        End If
    End While

    Return f39_i  Note: Return number of bytes copied (excluding null)
End Process

Process called "memory_copy_string_to_buffer" takes ptr as Integer, str as String returns Integer:
    Note: Copy string to buffer at ptr, return bytes copied
    Let f40_src be str  Note: String is already a pointer
    Let f40_i be 0
    Let f40_continue_loop be 1

    While f40_continue_loop is equal to 1:
        Let f40_char be memory_get_byte(f40_src, f40_i)
        memory_set_byte(ptr, f40_i, f40_char)
        If f40_char is equal to 0:
            Let f40_continue_loop be 0
        Otherwise:
            Let f40_i be f40_i plus 1
        End If
    End While

    Return f40_i  Note: Return number of bytes copied (excluding null)
End Process

Process called "memory_pointer_offset" takes ptr as Integer, offset as Integer returns Integer:
    Note: Runtime function to calculate ptr + offset
    Return ptr plus offset
End Process

Note: Additional helper functions needed by string_utils

Process called "memory_allocate" takes size as Integer returns Integer:
    Note: Wrapper for runtime allocate function
    Return allocate(size)
End Process

Note: system_call, memory_pointer_to_string, memory_get_substring are provided by runtime

Note: memory_set_pointer_at_index and memory_get_pointer_at_index removed - not needed

Note: reallocate is provided by the runtime (runtime_system.c)
Note: It properly copies old data to the new location