Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note: Main Compiler for Runa v0.0.8.4.5.3


Note: Process to read entire file contents into memory
Note: Equivalent to C static char* read_file(const char *filename)
Process called "read_file_internal" takes filename as Integer returns Integer:
    Note: Read entire file using runtime function (handles file open failure internally)
    Let content be runtime_read_file(filename)

    Note: Check if reading failed (equivalent to fopen() returning NULL)
    If content is equal to 0:
        Note: print_string(error message (equivalent to fprintf(stderr, "[MAIN ERROR] Could not open input file '%s'\n", filename))
        Let error_msg_temp be string_concat("[MAIN ERROR] Could not open input file '", filename)
        Let error_msg be string_concat(error_msg_temp, "'")
        deallocate(error_msg_temp)
        print_string(error_msg)
        deallocate(error_msg)
        Return 0
    End If

    Return content
End Process

Process called "main" takes argc as Integer, argv as Integer returns Integer:
    Note: Check command line arguments (argc != 3)
    If argc is not equal to 3:
        Note: print_string(usage message (equivalent to fprintf(stderr, "Usage: %s <input.runa> <output.s>\n", argv[0]))
        Let prog_name be get_command_line_arg(0)
        Let usage_msg_temp be string_concat("Usage: ", prog_name)
        Let usage_msg be string_concat(usage_msg_temp, " <input.runa> <output.s>")
        deallocate(usage_msg_temp)
        print_string(usage_msg)
        deallocate(usage_msg)
        deallocate(prog_name)
        Return 1
    End If

    Note: Get command line arguments (equivalent to input_filename = argv[1])
    Let input_filename be get_command_line_arg(1)
    Let output_filename be get_command_line_arg(2)

    Note: Read source file (equivalent to char *source = read_file(input_filename))
    Let source be read_file_internal(input_filename)

    Note: Check if reading failed (equivalent to !source)
    If source is equal to 0:
        print_string("[ERROR] Failed to read source file")
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Create arena for temporary allocations (Instance/Arena Hybrid Architecture)
    Let initial_arena_size be 65536  Note: 64KB initial size
    Let arena be arena_create(initial_arena_size)
    If arena is equal to 0:
        print_string("[ERROR] Failed to create arena allocator")
        deallocate(source)
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Create lexer (equivalent to Lexer *lexer = lexer_create(source))
    Let lexer be lexer_create(source, arena)

    Note: Create parser (equivalent to Parser *parser = parser_create(lexer))
    Let parser be parser_create(lexer, arena)

    Note: Parse program (equivalent to Program *program = parser_parse_program(parser))
    Let program be parser_parse_program(parser)

    Note: Check if parsing failed (equivalent to !program)
    If program is equal to 0:
        print_string("[ERROR] main: Parsing failed - program is NULL")
        Note: Cleanup parser and lexer before returning
        parser_destroy(parser)
        lexer_destroy(lexer)
        arena_destroy(arena)
        deallocate(source)
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Process imports with import system
    Let import_result be process_imports_recursive(program, arena)
    If import_result is not equal to 0:
        Note: Import processing failed
        program_destroy(program)
        parser_destroy(parser)
        lexer_destroy(lexer)
        arena_destroy(arena)
        deallocate(source)
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Create code generator (equivalent to CodeGenerator *codegen = codegen_create(output_filename))
    Let codegen be codegen_create(output_filename, arena)

    Note: Check if codegen creation failed (equivalent to !codegen)
    If codegen is equal to 0:
        Note: Cleanup resources before returning
        arena_destroy(arena)
        program_destroy(program)
        parser_destroy(parser)
        lexer_destroy(lexer)
        deallocate(source)
        deallocate(input_filename)
        deallocate(output_filename)
        Return 1
    End If

    Note: Generate code (equivalent to codegen_generate(codegen, program))
    codegen_generate(codegen, program)

    Note: Close output file to ensure content is written (flushes buffer)
    Let output_file be memory_get_integer(codegen, 0)
    file_close_buffered(output_file)

    Note: Print success message (equivalent to printf("Successfully compiled '%s' to '%s'\n", input_filename, output_filename))
    Let success_msg_temp be string_concat("Successfully compiled '", input_filename)
    Let success_msg_temp2 be string_concat(success_msg_temp, "' to '")
    deallocate(success_msg_temp)
    Let success_msg be string_concat(success_msg_temp2, output_filename)
    deallocate(success_msg_temp2)
    Let success_msg_final be string_concat(success_msg, "'")
    deallocate(success_msg)
    print_string(success_msg_final)
    deallocate(success_msg_final)

    Note: Cleanup resources (equivalent to C cleanup code)
    Note: CRITICAL: Destroy individual objects BEFORE destroying arena
    codegen_destroy(codegen)
    program_destroy(program)
    parser_destroy(parser)
    lexer_destroy(lexer)
    arena_destroy(arena)  Note: Destroy arena LAST - after all objects using it
    deallocate(source)
    deallocate(input_filename)
    deallocate(output_filename)

    Return 0
End Process
