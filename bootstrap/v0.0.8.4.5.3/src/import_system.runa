Note:
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
===============================================================================
IMPORT SYSTEM v0.0.8.4.5.3
===============================================================================

This module implements a simple, working import system for Runa v0.0.8.4.5.3.
It provides basic file import functionality with circular dependency detection.

FEATURES:
✓ Basic file import resolution
✓ Circular dependency detection
✓ Simple error handling
✓ File reading and parsing
✓ Function and type merging

This system focuses on simplicity and reliability over advanced features.
:End Note

Note: ============================================================================
Note: Simple Import Context Structure
Note: ============================================================================

Note: ImportContext structure (arena-allocated, 40 bytes):
Note:   offset 0: visited_files (array of string pointers, 8 bytes)
Note:   offset 8: visited_count (integer, 8 bytes)
Note:   offset 16: visited_capacity (integer, 8 bytes)
Note:   offset 24: import_stack (array of string pointers, 8 bytes)
Note:   offset 32: stack_depth (integer, 8 bytes)

Process called "import_context_create" takes arena as Integer returns Integer:
    Note: Create simple import context for tracking visited files

    Let context be arena_allocate(arena, 40)
    If context is equal to 0:
        Return 0
    End If

    Note: Allocate initial arrays
    Let initial_capacity be 64  Note: Start with 64 files
    Let visited_array be arena_allocate(arena, initial_capacity multiplied by 8)
    Let stack_array be arena_allocate(arena, initial_capacity multiplied by 8)

    If visited_array is equal to 0:
        Return 0
    End If

    If stack_array is equal to 0:
        Return 0
    End If

    Note: Initialize context
    memory_set_pointer(context, 0, visited_array)
    memory_set_integer(context, 8, 0)  Note: visited_count = 0
    memory_set_integer(context, 16, initial_capacity)
    memory_set_pointer(context, 24, stack_array)
    memory_set_integer(context, 32, 0)  Note: stack_depth = 0

    Return context
End Process

Process called "import_context_is_visited" takes context as Integer, filename as Integer returns Integer:
    Note: Check if file has already been visited

    Let visited_files be memory_get_pointer(context, 0)
    Let visited_count be memory_get_integer(context, 8)

    Let i be 0
    While i is less than visited_count:
        Let offset be i multiplied by 8
        Let visited_file be memory_get_pointer(visited_files plus offset, 0)

        If string_equals(visited_file, filename) is equal to 1:
            Return 1  Note: Already visited
        End If

        Set i to i plus 1
    End While

    Return 0  Note: Not visited yet
End Process

Process called "import_context_mark_visited" takes context as Integer, filename as Integer, arena as Integer returns Integer:
    Note: Mark file as visited

    Let visited_files be memory_get_pointer(context, 0)
    Let visited_count be memory_get_integer(context, 8)
    Let visited_capacity be memory_get_integer(context, 16)

    Note: Check if we exceeded capacity
    If visited_count is greater than or equal to visited_capacity:
        print_string("[IMPORT ERROR] Too many imported files (capacity exceeded)")
        Return 0
    End If

    Note: Duplicate filename into arena
    Let filename_copy be arena_string_duplicate(arena, filename)
    If filename_copy is equal to 0:
        Return 0
    End If

    Note: Add to visited array
    Let offset be visited_count multiplied by 8
    memory_set_pointer(visited_files plus offset, 0, filename_copy)
    memory_set_integer(context, 8, visited_count plus 1)

    Return 1
End Process

Process called "import_context_push_stack" takes context as Integer, filename as Integer, arena as Integer returns Integer:
    Note: Push filename onto import stack for cycle detection

    Let import_stack be memory_get_pointer(context, 24)
    Let stack_depth be memory_get_integer(context, 32)
    Let visited_capacity be memory_get_integer(context, 16)

    Note: Check capacity
    If stack_depth is greater than or equal to visited_capacity:
        Return 0  Note: Stack overflow
    End If

    Note: Duplicate filename
    Let filename_copy be arena_string_duplicate(arena, filename)
    If filename_copy is equal to 0:
        Return 0
    End If

    Note: Push to stack
    Let offset be stack_depth multiplied by 8
    memory_set_pointer(import_stack plus offset, 0, filename_copy)
    memory_set_integer(context, 32, stack_depth plus 1)

    Return 1
End Process

Process called "import_context_pop_stack" takes context as Integer returns Integer:
    Note: Pop filename from import stack

    Let stack_depth be memory_get_integer(context, 32)

    If stack_depth is equal to 0:
        Return 0  Note: Stack empty
    End If

    memory_set_integer(context, 32, stack_depth minus 1)
    Return 1
End Process

Process called "import_context_is_in_stack" takes context as Integer, filename as Integer returns Integer:
    Note: Check if filename is in import stack (cycle detection)

    Let import_stack be memory_get_pointer(context, 24)
    Let stack_depth be memory_get_integer(context, 32)

    Let i be 0
    While i is less than stack_depth:
        Let offset be i multiplied by 8
        Let stack_file be memory_get_pointer(import_stack plus offset, 0)

        If string_equals(stack_file, filename) is equal to 1:
            Return 1  Note: Cycle detected!
        End If

        Set i to i plus 1
    End While

    Return 0
End Process

Process called "import_context_print_stack" takes context as Integer returns Integer:
    Note: Print import stack for error messages

    Let import_stack be memory_get_pointer(context, 24)
    Let stack_depth be memory_get_integer(context, 32)

    print_string("  Import chain:")

    Let i be 0
    While i is less than stack_depth:
        Let offset be i multiplied by 8
        Let stack_file be memory_get_pointer(import_stack plus offset, 0)

        print_string("    -> ")
        print_string(stack_file)

        Set i to i plus 1
    End While

    Return 1
End Process

Note: ============================================================================
Note: Simple File Resolution
Note: ============================================================================

Process called "resolve_import_path" takes import_path as Integer, arena as Integer returns Integer:
    Note: Simple file path resolution
    Note: Returns resolved path, or 0 on failure

    Note: Try different extensions
    Let ext1 be ""
    Let ext2 be ".runa"
    Let ext3 be ".r"
    Let ext4 be ".ru"

    Let full_path be string_concat(import_path, ext1)
    If file_exists(full_path) is equal to 1:
        Return full_path
    End If

    Set full_path to string_concat(import_path, ext2)
    If file_exists(full_path) is equal to 1:
        Return full_path
    End If

    Set full_path to string_concat(import_path, ext3)
    If file_exists(full_path) is equal to 1:
        Return full_path
    End If

    Set full_path to string_concat(import_path, ext4)
    If file_exists(full_path) is equal to 1:
        Return full_path
    End If

    Return 0
End Process

Process called "file_exists" takes filename as Integer returns Integer:
    Note: Check if file exists
    Note: Returns 1 if exists, 0 if not

    Let file_handle be open_file(filename, "r")
    If file_handle is equal to 0:
        Return 0
    End If

    close_file(file_handle)
    Return 1
End Process

Process called "read_file_internal" takes filename as Integer returns Integer:
    Note: Read file contents
    Note: Returns pointer to file contents, or 0 on failure

    Let file_handle be open_file(filename, "r")
    If file_handle is equal to 0:
        Return 0
    End If

    Let file_size be get_file_size(filename)
    If file_size is equal to 0:
        close_file(file_handle)
        Return 0
    End If

    Let contents be allocate(file_size plus 1)
    If contents is equal to 0:
        close_file(file_handle)
        Return 0
    End If

    Let bytes_read be read_file_data(file_handle, contents, file_size)
    close_file(file_handle)

    If bytes_read is not equal to file_size:
        deallocate(contents)
        Return 0
    End If

    memory_set_byte(contents plus file_size, 0, 0)
    Return contents
End Process

Process called "get_file_size" takes filename as Integer returns Integer:
    Note: Get file size
    Note: Returns file size in bytes, or 0 on error

    Let file_handle be open_file(filename, "r")
    If file_handle is equal to 0:
        Return 0
    End If

    Let size be get_file_size_internal(file_handle)
    close_file(file_handle)

    Return size
End Process

Note: ============================================================================
Note: Main Import Processing Engine
Note: ============================================================================

Process called "process_imports_recursive" takes program as Integer, arena as Integer returns Integer:
    Note: Main entry point for import processing
    Note: Returns 0 on success, 1 on error

    Note: Create import context
    Let context be import_context_create(arena)
    If context is equal to 0:
        print_string("[IMPORT ERROR] Failed to create import context")
        Return 1
    End If

    Note: Get import count and imports array
    Let import_count be memory_get_int32(program, 40)
    If import_count is equal to 0:
        Return 0  Note: No imports to process
    End If

    Let imports be memory_get_pointer(program, 32)
    If imports is equal to 0:
        print_string("[IMPORT ERROR] No imports array found")
        Return 1
    End If

    Note: Process each import
    Let i be 0
    While i is less than import_count:
        Note: Get import statement pointer
        Let ptr_size be 8
        Let import_offset be i multiplied by ptr_size
        Let import_ptr be imports plus import_offset
        Let import_stmt be memory_get_pointer(import_ptr, 0)

        If import_stmt is equal to 0:
            print_string("[IMPORT ERROR] Null import statement at index ")
            print_integer(i)
            Return 1
        End If

        Note: Get filename from import statement
        Let import_filename be memory_get_pointer(import_stmt, 0)
        If import_filename is equal to 0:
            print_string("[IMPORT ERROR] Null filename in import statement")
            Return 1
        End If

        Note: CYCLE DETECTION
        If import_context_is_in_stack(context, import_filename) is equal to 1:
            print_string("[IMPORT ERROR] Circular import detected!")
            print_string("  Attempting to import: ")
            print_string(import_filename)
            import_context_print_stack(context)
            print_string("  This would create a circular dependency.")
            Return 1
        End If

        Note: DEDUPLICATION
        If import_context_is_visited(context, import_filename) is equal to 1:
            Set i to i plus 1
            Continue
        End If

        Note: MARK AS VISITED
        If import_context_mark_visited(context, import_filename, arena) is equal to 0:
            print_string("[IMPORT ERROR] Failed to mark file as visited")
            Return 1
        End If

        Note: PUSH TO STACK
        If import_context_push_stack(context, import_filename, arena) is equal to 0:
            print_string("[IMPORT ERROR] Import stack overflow")
            Return 1
        End If

        Note: Resolve import path
        Let resolved_path be resolve_import_path(import_filename, arena)
        If resolved_path is equal to 0:
            print_string("[IMPORT ERROR] Failed to resolve import: ")
            print_string(import_filename)
            import_context_pop_stack(context)
            Return 1
        End If

        Note: Read the imported file
        Let import_source be read_file_internal(resolved_path)
        If import_source is equal to 0:
            print_string("[IMPORT ERROR] Failed to read import file: ")
            print_string(resolved_path)
            import_context_pop_stack(context)
            Return 1
        End If

        Note: Create lexer for imported file
        Let import_lexer be lexer_create(import_source, arena)
        If import_lexer is equal to 0:
            print_string("[IMPORT ERROR] Failed to create lexer for: ")
            print_string(resolved_path)
            deallocate(import_source)
            import_context_pop_stack(context)
            Return 1
        End If

        Note: Create parser for imported file
        Let import_parser be parser_create(import_lexer, arena)
        If import_parser is equal to 0:
            print_string("[IMPORT ERROR] Failed to create parser for: ")
            print_string(resolved_path)
            lexer_destroy(import_lexer)
            deallocate(import_source)
            import_context_pop_stack(context)
            Return 1
        End If

        Note: Parse the imported file
        Let import_program be parser_parse_program(import_parser)
        If import_program is equal to 0:
            print_string("[IMPORT ERROR] Failed to parse import file: ")
            print_string(resolved_path)
            parser_destroy(import_parser)
            lexer_destroy(import_lexer)
            deallocate(import_source)
            import_context_pop_stack(context)
            Return 1
        End If

        Note: RECURSIVE PROCESSING
        Let recursive_result be process_imports_recursive(import_program, arena)
        If recursive_result is not equal to 0:
            parser_destroy(import_parser)
            lexer_destroy(import_lexer)
            deallocate(import_source)
            import_context_pop_stack(context)
            Return 1
        End If

        Note: Merge functions from imported program into main program
        Let merge_result be merge_imported_functions(program, import_program, arena)
        If merge_result is not equal to 0:
            print_string("[IMPORT ERROR] Failed to merge functions from: ")
            print_string(resolved_path)
            parser_destroy(import_parser)
            lexer_destroy(import_lexer)
            deallocate(import_source)
            import_context_pop_stack(context)
            Return 1
        End If

        Note: Merge types from imported program into main program
        Let type_merge_result be merge_imported_types(program, import_program, arena)
        If type_merge_result is not equal to 0:
            print_string("[IMPORT ERROR] Failed to merge types from: ")
            print_string(resolved_path)
            parser_destroy(import_parser)
            lexer_destroy(import_lexer)
            deallocate(import_source)
            import_context_pop_stack(context)
            Return 1
        End If

        Note: Cleanup import parsing resources
        parser_destroy(import_parser)
        lexer_destroy(import_lexer)
        deallocate(import_source)
        import_context_pop_stack(context)

        Set i to i plus 1
    End While

    print_string("[IMPORT SUCCESS] Processed ")
    print_integer(import_count)
    print_string(" imports successfully")

    Return 0
End Process

Process called "merge_imported_functions" takes main_program as Integer, import_program as Integer, arena as Integer returns Integer:
    Note: Merge functions from imported program into main program
    Note: Returns 0 on success, 1 on error
    
    Let import_func_count be memory_get_int32(import_program, 8)
    If import_func_count is equal to 0:
        Return 0  Note: No functions to merge
    End If
    
    Let import_functions be memory_get_pointer(import_program, 0)
    If import_functions is equal to 0:
        Return 1
    End If
    
    Let main_func_count be memory_get_int32(main_program, 8)
    Let main_functions be memory_get_pointer(main_program, 0)
    
    Note: Resize main functions array to accommodate new functions
    Let new_func_count be main_func_count plus import_func_count
    Let new_functions be arena_allocate(arena, new_func_count multiplied by 8)
    If new_functions is equal to 0:
        Return 1
    End If

    Note: Copy existing functions
    Let i be 0
    While i is less than main_func_count:
        Let func_ptr be memory_get_pointer(main_functions, i multiplied by 8)
        memory_set_pointer(new_functions, i multiplied by 8, func_ptr)
        Set i to i plus 1
    End While

    Note: Copy imported functions
    Let j be 0
    While j is less than import_func_count:
        Set func_ptr to memory_get_pointer(import_functions, j multiplied by 8)
        Let index be main_func_count plus j  Note: Force correct evaluation: (main_func_count + j)
        Let offset be index multiplied by 8  Note: Then multiply the sum by 8
        memory_set_pointer(new_functions, offset, func_ptr)
        Set j to j plus 1
    End While

    Note: Update main program
    memory_set_pointer(main_program, 0, new_functions)
    memory_set_int32(main_program, 8, new_func_count)
    memory_set_int32(main_program, 12, new_func_count)  Note: function_capacity = function_count

    Return 0
End Process

Process called "merge_imported_types" takes main_program as Integer, import_program as Integer, arena as Integer returns Integer:
    Note: Merge types from imported program into main program
    Note: Returns 0 on success, 1 on error

    Let import_type_count be memory_get_int32(import_program, 24)
    If import_type_count is equal to 0:
        Return 0  Note: No types to merge
    End If

    Let import_types be memory_get_pointer(import_program, 16)
    If import_types is equal to 0:
        Return 1
    End If

    Let main_type_count be memory_get_int32(main_program, 24)
    Let main_types be memory_get_pointer(main_program, 16)
    
    Note: Resize main types array to accommodate new types
    Let new_type_count be main_type_count plus import_type_count
    Let new_types be arena_allocate(arena, new_type_count multiplied by 8)
    If new_types is equal to 0:
        Return 1
    End If
    
    Note: Copy existing types
    Let i be 0
    While i is less than main_type_count:
        Let type_ptr be memory_get_pointer(main_types, i multiplied by 8)
        memory_set_pointer(new_types, i multiplied by 8, type_ptr)
        Set i to i plus 1
    End While

    Note: Copy imported types
    Let j be 0
    While j is less than import_type_count:
        Set type_ptr to memory_get_pointer(import_types, j multiplied by 8)
        Let index be main_type_count plus j  Note: Force correct evaluation: (main_type_count + j)
        Let offset be index multiplied by 8  Note: Then multiply the sum by 8
        memory_set_pointer(new_types, offset, type_ptr)
        Set j to j plus 1
    End While
    
    Note: Update main program
    memory_set_pointer(main_program, 16, new_types)
    memory_set_int32(main_program, 24, new_type_count)
    memory_set_int32(main_program, 28, new_type_count)  Note: type_capacity = type_count

    Return 0
End Process
