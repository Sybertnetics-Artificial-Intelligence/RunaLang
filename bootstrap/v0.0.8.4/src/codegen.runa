Note: 
Copyright 2025 Sybertnetics Artificial Intelligence Solutions

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:End Note

Note:
Code Generator for x86-64 Assembly
Transliterated from codegen_x86.c (v0.0.7.3)
Generates x86-64 assembly from parsed AST
:End Note

Note: Program structure offsets (defined in parser.runa)
Note: Using numeric values to avoid duplicate symbol errors
Note: PROGRAM_FUNCTIONS = 0
Note: PROGRAM_FUNCTION_COUNT = 8
Note: PROGRAM_TYPES = 16
Note: PROGRAM_TYPE_COUNT = 24
Note: PROGRAM_IMPORTS = 32
Note: PROGRAM_IMPORT_COUNT = 40
Note: PROGRAM_GLOBAL_VARS = 48
Note: PROGRAM_GLOBAL_COUNT = 56

Note: Forward declarations for loop context management
Note: These will be implemented later in the file

Note: string_duplicate is provided by string_utils module

Note: Helper to emit a line with newline
Process called "emit_line" takes output_file as Integer, line as Integer returns Integer:
    file_write_buffered(output_file, line, 0)
    file_write_buffered(output_file, "\n", 0)
    Return 0
End Process

Note: DJB2 hash function for strings
Process called "codegen_hash_string" takes key as Integer returns Integer:
    Let str_ptr be key
    Let hash be 5381
    Let c be memory_get_byte(str_ptr, 0)
    Let offset be 0
    While c is not equal to 0:
        Let hash_shifted be hash multiplied by 32
        Set hash to hash_shifted plus hash
        Set hash to hash plus c
        Set offset to offset plus 1
        Set c to memory_get_byte(str_ptr, offset)
    End While
    Return hash
End Process

Note: String comparison for hash table
Process called "codegen_compare_strings" takes key1 as Integer, key2 as Integer returns Integer:
    Let result be string_compare(key1, key2)
    If result is equal to 0:
        Return 1
    Otherwise:
        Return 0
    End If
End Process

Note: Find variable in current scope - OPTIMIZED with first-char check
Process called "codegen_find_variable" takes codegen as Integer, name as Integer returns Integer:
    Let variable_count be memory_get_int32(codegen, 16)  Note: codegen->variable_count (int)
    Let variables be memory_get_pointer(codegen, 8)        Note: codegen->variables

    Note: Optimization: get first character of search name
    Let name_first_char be memory_get_byte(name, 0)

    Let i be 0
    While i is less than variable_count:
        Let var_offset be i multiplied by 32
        Let var_ptr be variables plus var_offset  Note: sizeof(Variable) = 32
        Let var_name be memory_get_pointer(var_ptr, 0)

        Note: Fast path: check first character before expensive string_equals
        Let var_first_char be memory_get_byte(var_name, 0)
        If var_first_char is equal to name_first_char:
            If string_equals(var_name, name) is equal to 1:
                Return i
            End If
        End If

        Let i be i plus 1
    End While
    Return -1  Note: -1 for not found
End Process

Note: Calculate size of a type in bytes - equivalent to codegen_calculate_type_size
Process called "codegen_calculate_type_size" takes type_name as Integer, program as Integer returns Integer:
    Note: Built-in types
    If string_equals(type_name, "Integer") is equal to 1:
        Return 8  Note: 64-bit integer
    Otherwise If string_equals(type_name, "Byte") is equal to 1:
        Return 1  Note: 8-bit byte
    Otherwise If string_equals(type_name, "Short") is equal to 1:
        Return 2  Note: 16-bit short
    Otherwise If string_equals(type_name, "Long") is equal to 1:
        Return 8  Note: 64-bit long
    End If

    Note: Custom types - look up in the program
    If program is not equal to 0:
        Let type_count be memory_get_int32(program, 24)  Note: PROGRAM_TYPE_COUNT - use int32
        Let types be memory_get_pointer(program, 16)       Note: PROGRAM_TYPES - use pointer
        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)  Note: type->name
            If string_equals(type_name_ptr, type_name) is equal to 1:
                Let type_size be memory_get_int32(type_ptr, 40)  Note: TYPEDEFINITION_SIZE_OFFSET
                Return type_size
            End If
            Let i be i plus 1
        End While
    End If

    Note: Unknown type - default to 8 bytes
    Return 8
End Process

Note: Add variable with type and parameter flag - equivalent to codegen_add_variable_with_type_and_param_flag
Process called "codegen_add_variable_with_type_and_param_flag" takes codegen as Integer, name as Integer, type_name as Integer, is_parameter as Integer returns Integer:
    Note: Get current counts and capacity

    Let variable_count be memory_get_int32(codegen, 16)      Note: codegen->variable_count (int)
    Let variable_capacity be memory_get_int32(codegen, 20)   Note: codegen->variable_capacity (int)
    Let variables be memory_get_pointer(codegen, 8)            Note: codegen->variables

    Note: DEBUG: Show what we read
    Note: print_integer(variable_count)
    Note: print_integer(variable_capacity)

    Note: Grow array if needed
    If variable_count is greater than or equal to variable_capacity:
        Let new_capacity be variable_capacity multiplied by 2
        Let new_size be new_capacity multiplied by 32  Note: sizeof(Variable)
        Let new_variables be allocate(new_size)

        Note: Copy existing variables
        Let i be 0
        While i is less than variable_count:
            Let var_offset be i multiplied by 32
            Let old_var be variables plus var_offset
            Let var_offset be i multiplied by 32
            Let new_var be new_variables plus var_offset
            Note: Copy Variable struct (32 bytes)
            memory_copy(new_var, old_var, 32)
            Let i be i plus 1
        End While

        Note: Free old array and update
        deallocate(variables)
        memory_set_pointer(codegen, 8, new_variables)      Note: codegen->variables
        memory_set_int32(codegen, 20, new_capacity)      Note: codegen->variable_capacity (int)
        Let variables be new_variables
    End If

    Note: Calculate size based on type
    Let current_program be memory_get_pointer(codegen, 48)  Note: codegen->current_program (pointer with padding)
    Let size be codegen_calculate_type_size(type_name, current_program)
    If type_name is equal to 0:
        Let size be codegen_calculate_type_size("Integer", current_program)
    End If

    Note: Update stack offset
    Let stack_offset be memory_get_int32(codegen, 24)  Note: codegen->stack_offset (int)
    Let new_stack_offset be stack_offset plus size
    memory_set_int32(codegen, 24, new_stack_offset)  Note: codegen->stack_offset (int)

    Note: Get variable index
    Let var_index be variable_count
    Let var_offset be var_index multiplied by 32  Note: Calculate offset separately
    Let var_ptr be variables plus var_offset      Note: Then add to base pointer


    Note: Set variable fields
    memory_set_pointer(var_ptr, 0, string_duplicate(name))       Note: name
    memory_set_int32(var_ptr, 8, new_stack_offset)            Note: stack_offset (int)
    If type_name is equal to 0:
        memory_set_pointer(var_ptr, 16, string_duplicate("Integer")) Note: type_name - use literal directly
    Otherwise:
        memory_set_pointer(var_ptr, 16, string_duplicate(type_name)) Note: type_name
    End If
    memory_set_int32(var_ptr, 24, is_parameter)               Note: is_parameter (int)

    Note: Increment count
    memory_set_int32(codegen, 16, variable_count plus 1)  Note: codegen->variable_count (int)

    Return var_index
End Process

Note: Add variable with type - equivalent to codegen_add_variable_with_type
Process called "codegen_add_variable_with_type" takes codegen as Integer, name as Integer, type_name as Integer returns Integer:
    Return codegen_add_variable_with_type_and_param_flag(codegen, name, type_name, 0)
End Process

Note: Add variable with default Integer type - equivalent to codegen_add_variable
Process called "codegen_add_variable" takes codegen as Integer, name as Integer returns Integer:
    Return codegen_add_variable_with_type(codegen, name, "Integer")
End Process

Note: Add string literal - equivalent to codegen_add_string_literal
Process called "codegen_add_string_literal" takes codegen as Integer, value as Integer returns Integer:
    Note: Get current counts and capacity
    Let string_count be memory_get_int32(codegen, 40)      Note: codegen->string_count (int)
    Let string_capacity be memory_get_int32(codegen, 44)   Note: codegen->string_capacity (int)
    Let strings be memory_get_pointer(codegen, 32)           Note: codegen->strings (pointer with padding)


    Note: Grow array if needed
    If string_count is greater than or equal to string_capacity:
        Let new_capacity be string_capacity multiplied by 2
        Let new_size be new_capacity multiplied by 16  Note: sizeof(StringLiteral)
        Let new_strings be allocate(new_size)

        Note: Copy existing strings
        Let i be 0
        While i is less than string_count:
            Let str_offset be i multiplied by 16
            Let old_str be strings plus str_offset
            Let str_offset be i multiplied by 16
            Let new_str be new_strings plus str_offset
            Note: Copy StringLiteral struct (16 bytes)
            memory_copy(new_str, old_str, 16)
            Let i be i plus 1
        End While

        Note: Free old array and update
        deallocate(strings)
        memory_set_pointer(codegen, 32, new_strings)      Note: codegen->strings (pointer)
        memory_set_int32(codegen, 44, new_capacity)     Note: codegen->string_capacity (int)
        Let strings be new_strings
    End If

    Let str_index be string_count
    Let str_offset be str_index multiplied by 16
    Let str_ptr be strings plus str_offset

    Note: Set string value
    memory_set_pointer(str_ptr, 0, string_duplicate(value))  Note: value

    Note: Generate unique label for this string
    Let label be string_concat(".STR", integer_to_string(str_index))
    memory_set_pointer(str_ptr, 8, label)  Note: label

    Note: Increment count
    memory_set_int32(codegen, 40, string_count plus 1)  Note: codegen->string_count (int)


    Return str_index
End Process

Note: Collect strings from expression - equivalent to codegen_collect_strings_from_expression
Process called "codegen_collect_strings_from_expression" takes codegen as Integer, expr as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If
    Note: Safety check for invalid pointers
    If expr is equal to 0:
        Return 0
    End If

    Let expr_type be memory_get_int32(expr, 0)  Note: expr->type (32-bit)


    If expr_type is equal to 5:  Note: EXPR_STRING_LITERAL
        Note: Check if string already exists
        Let string_count be memory_get_int32(codegen, 40)  Note: codegen->string_count (int)
        Let strings be memory_get_pointer(codegen, 32)  Note: codegen->strings (pointer)
        Let string_literal be memory_get_pointer(expr, 8)  Note: expr->data.string_literal (union at offset 4)

        Note: Safety check for string_literal
        If string_literal is equal to 0:
            Return 0
        End If
        If string_literal is equal to 0:
            Return 0
        End If

        Note: Safety check - string_count should be reasonable
        If string_count is less than 0:
            Return 0
        End If
        Note: Don't limit string count - allow as many as needed
        Note: If string_count is greater than 1000:
        Note:     Return 0
        Note: End If

        Let i be 0
        While i is less than string_count:
            Let str_offset be i multiplied by 16
            Let str_ptr be strings plus str_offset
            Let existing_value be memory_get_pointer(str_ptr, 0)  Note: Should be pointer, not integer!
            Note: Safety check for existing_value before comparison
            If existing_value is not equal to 0:
                If existing_value is greater than 65536:
                    If string_equals(existing_value, string_literal) is equal to 1:
                        Return 0  Note: Already added
                    End If
                End If
            End If
            Let i be i plus 1
        End While

        codegen_add_string_literal(codegen, string_literal)
        Return 0
    End If

    If expr_type is equal to 2:  Note: EXPR_BINARY_OP
        Let left be memory_get_pointer(expr, 8)   Note: binary_op.left
        Let right be memory_get_pointer(expr, 16) Note: binary_op.right
        codegen_collect_strings_from_expression(codegen, left)
        codegen_collect_strings_from_expression(codegen, right)
        Return 0
    End If

    If expr_type is equal to 3:  Note: EXPR_COMPARISON
        Let left be memory_get_pointer(expr, 8)   Note: comparison.left
        Let right be memory_get_pointer(expr, 16) Note: comparison.right
        codegen_collect_strings_from_expression(codegen, left)
        codegen_collect_strings_from_expression(codegen, right)
        Return 0
    End If

    If expr_type is equal to 4:  Note: EXPR_FUNCTION_CALL
        Let func_call_ptr be expr plus 8  Note: &expr->data.function_call
        Note: function_call structure: function_name (char*) at 0, arguments (Expression**) at 8, argument_count (int) at 16
        Let function_name be memory_get_pointer(func_call_ptr, 0)  Note: function_call.function_name
        Let arguments be memory_get_pointer(func_call_ptr, 8)      Note: function_call.arguments - this is a pointer!
        Let argument_count be memory_get_int32(func_call_ptr, 16) Note: function_call.argument_count


        Let i be 0
        While i is less than argument_count:
            Let arg_offset be i multiplied by 8
            Let arg_ptr be memory_get_pointer(arguments, arg_offset)


            codegen_collect_strings_from_expression(codegen, arg_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 6:  Note: EXPR_FIELD_ACCESS
        Let object be memory_get_pointer(expr, 8)  Note: field_access.object
        codegen_collect_strings_from_expression(codegen, object)
        Return 0
    End If

    If expr_type is equal to 8:  Note: EXPR_BUILTIN_CALL
        Let builtin_call_ptr be expr plus 8  Note: &expr->data.builtin_call
        Note: builtin_call structure: builtin_type (int) at 0, arguments (Expression**) at 8, argument_count (int) at 16
        Let builtin_type be memory_get_int32(builtin_call_ptr, 0)  Note: builtin_call.builtin_type
        Let arguments be memory_get_pointer(builtin_call_ptr, 8)      Note: builtin_call.arguments - this is a pointer!
        Let argument_count be memory_get_int32(builtin_call_ptr, 16) Note: builtin_call.argument_count

        Let i be 0
        While i is less than argument_count:
            Let arg_offset be i multiplied by 8
            Let arg_ptr be memory_get_pointer(arguments, arg_offset)
            codegen_collect_strings_from_expression(codegen, arg_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 9:  Note: EXPR_VARIANT_CONSTRUCTOR
        Let variant_constructor_ptr be expr plus 8  Note: &expr->data.variant_constructor
        Note: variant_constructor structure: type_name (char*) at 0, variant_name (char*) at 8, field_values (Expression**) at 16, field_count (int) at 24
        Let type_name be memory_get_pointer(variant_constructor_ptr, 0)     Note: variant_constructor.type_name
        Let variant_name be memory_get_pointer(variant_constructor_ptr, 8)  Note: variant_constructor.variant_name
        Let field_values be memory_get_pointer(variant_constructor_ptr, 16) Note: variant_constructor.field_values - this is a pointer!
        Let field_count be memory_get_int32(variant_constructor_ptr, 24)  Note: variant_constructor.field_count

        Let i be 0
        While i is less than field_count:
            Let field_offset be i multiplied by 8
            Let field_value_ptr be memory_get_pointer(field_values, field_offset)  Note: This is also a pointer!
            codegen_collect_strings_from_expression(codegen, field_value_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If expr_type is equal to 16:  Note: EXPR_ARRAY_INDEX
        Let array_index_ptr be expr plus 8  Note: &expr->data.array_index
        Let arr be memory_get_integer(array_index_ptr, 0)  Note: array_index.array
        Let index be memory_get_integer(array_index_ptr, 8)  Note: array_index.index
        codegen_collect_strings_from_expression(codegen, arr)
        codegen_collect_strings_from_expression(codegen, index)
        Return 0
    End If

    If expr_type is equal to 20:  Note: EXPR_STRUCT_CONSTRUCTION
        Let field_values be memory_get_pointer(expr, 24)
        Let field_count be memory_get_int32(expr, 32)
        Let field_i be 0
        While field_i is less than field_count:
            Let field_ptr_offset be field_i multiplied by 8
            Let field_value_expr be memory_get_pointer(field_values, field_ptr_offset)
            codegen_collect_strings_from_expression(codegen, field_value_expr)
            Let field_i be field_i plus 1
        End While
        Return 0
    End If

    Note: Other expression types (INTEGER, VARIABLE, TYPE_NAME, FUNCTION_POINTER) have no strings to collect
    Return 0
End Process

Note: Collect strings from statement - equivalent to codegen_collect_strings_from_statement
Process called "codegen_collect_strings_from_statement" takes codegen as Integer, stmt as Integer returns Integer:
    If stmt is equal to 0:
        Return 0
    End If

    Note: Safety check - if stmt is NULL, skip it
    If stmt is equal to 0:
        Return 0
    End If

    Let stmt_type be memory_get_int32(stmt, 0)  Note: stmt->type


    Note: Safety check - statement types should be reasonable (0-17 for now, including STMT_COMPOUND_ASSIGN = 17)
    If stmt_type is less than 0:
        Return 0
    End If
    If stmt_type is greater than 17:
        Return 1
    End If

    If stmt_type is equal to 1:  Note: STMT_LET
        Note: Statement structure: type at 0, data union at 8
        Note: let_stmt in union: var_name at 0, expression at 8
        Let var_name be memory_get_pointer(stmt, 8)   Note: stmt+8 = let_stmt.var_name
        Let expression be memory_get_pointer(stmt, 16) Note: stmt+16 = let_stmt.expression


        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 2:  Note: STMT_SET
        Note: Statement structure: type at 0, data union at 8
        Note: set_stmt in union: target at 0, expression at 8
        Let target be memory_get_pointer(stmt, 8)      Note: stmt+8 = set_stmt.target
        Let expression be memory_get_pointer(stmt, 16) Note: stmt+16 = set_stmt.expression
        codegen_collect_strings_from_expression(codegen, target)
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 3:  Note: STMT_RETURN
        Let return_stmt_ptr be stmt plus 8  Note: &stmt->data.return_stmt
        Let expression be memory_get_pointer(return_stmt_ptr, 0)  Note: return_stmt.expression
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 4:  Note: STMT_PRINT
        Let print_stmt_ptr be stmt plus 8  Note: &stmt->data.print_stmt
        Let expression be memory_get_pointer(print_stmt_ptr, 0)  Note: print_stmt.expression
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 5:  Note: STMT_IF

        Let if_stmt_ptr be stmt plus 8  Note: &stmt->data.if_stmt
        Let condition be memory_get_pointer(if_stmt_ptr, 0)        Note: if_stmt.condition (offset 8)
        Let if_body be memory_get_pointer(if_stmt_ptr, 8)          Note: if_stmt.if_body (offset 16)
        Let if_body_count be memory_get_int32(if_stmt_ptr, 16)   Note: if_stmt.if_body_count (offset 24)
        Let else_body be memory_get_pointer(if_stmt_ptr, 24)       Note: if_stmt.else_body (offset 32)
        Let else_body_count be memory_get_int32(if_stmt_ptr, 32) Note: if_stmt.else_body_count (offset 40)


        codegen_collect_strings_from_expression(codegen, condition)

        Note: Process if body - add safety check
        If if_body is not equal to 0:  Note: NULL pointer check
            Let i be 0
            While i is less than if_body_count:
                Let stmt_offset be i multiplied by 8


                Let stmt_ptr be memory_get_pointer(if_body, stmt_offset)


                codegen_collect_strings_from_statement(codegen, stmt_ptr)
                Let i be i plus 1
            End While
        End If

        Note: Process else body - add safety check
        If else_body is not equal to 0:  Note: NULL pointer check
            Let i be 0
            While i is less than else_body_count:
                Let stmt_offset be i multiplied by 8
                Let stmt_ptr be memory_get_pointer(else_body, stmt_offset)
                codegen_collect_strings_from_statement(codegen, stmt_ptr)
                Let i be i plus 1
            End While
        End If
        Return 0
    End If

    If stmt_type is equal to 6:  Note: STMT_WHILE
        Let while_stmt_ptr be stmt plus 8  Note: &stmt->data.while_stmt
        Let condition be memory_get_pointer(while_stmt_ptr, 0)   Note: while_stmt.condition (offset 8)
        Let body be memory_get_pointer(while_stmt_ptr, 8)        Note: while_stmt.body (offset 16)
        Let body_count be memory_get_int32(while_stmt_ptr, 16) Note: while_stmt.body_count (offset 24)

        codegen_collect_strings_from_expression(codegen, condition)

        Note: Process body
        Let i be 0
        While i is less than body_count:
            Let stmt_offset be i multiplied by 8
            Let stmt_ptr be memory_get_pointer(body, stmt_offset)
            codegen_collect_strings_from_statement(codegen, stmt_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 6:  Note: STMT_WHILE
        Note: This is the duplicate WHILE check, should be removed but keeping for now
        Let while_stmt_ptr be stmt plus 8  Note: &stmt->data.while_stmt
        Let condition be memory_get_pointer(while_stmt_ptr, 0)   Note: while_stmt.condition (offset 8)
        Let body be memory_get_pointer(while_stmt_ptr, 8)        Note: while_stmt.body (offset 16)
        Let body_count be memory_get_int32(while_stmt_ptr, 16) Note: while_stmt.body_count (offset 24)

        codegen_collect_strings_from_expression(codegen, condition)

        Let i be 0
        While i is less than body_count:
            Let stmt_offset be i multiplied by 8
            Let stmt_ptr be memory_get_pointer(body, stmt_offset)
            codegen_collect_strings_from_statement(codegen, stmt_ptr)
            Let i be i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 7:  Note: STMT_EXPRESSION
        Let expr_stmt_ptr be stmt plus 8  Note: &stmt->data.expr_stmt
        Let expression be memory_get_pointer(expr_stmt_ptr, 0)  Note: expr_stmt.expression - this is a pointer!
        codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    If stmt_type is equal to 8:  Note: STMT_MATCH
        Note: Collect strings from match expression and when clause bodies
        Let match_expr be memory_get_pointer(stmt, 8)  Note: STMT_MATCH_EXPR
        codegen_collect_strings_from_expression(codegen, match_expr)

        Let when_clauses be memory_get_pointer(stmt, 16)  Note: STMT_MATCH_WHEN_CLAUSES
        Let when_count be memory_get_int32(stmt, 24)  Note: STMT_MATCH_WHEN_COUNT

        Note: Process each when clause (48 bytes each)
        Let i be 0
        While i is less than when_count:
            Let clause_offset be i multiplied by 48
            Let clause_ptr be when_clauses plus clause_offset
            Let pattern_type be memory_get_int32(clause_ptr, 0)
            Let pattern_value be memory_get_pointer(clause_ptr, 8)
            Let body_stmts be memory_get_pointer(clause_ptr, 32)
            Let body_count be memory_get_integer(clause_ptr, 40)

            Note: Collect strings from pattern value (expression for literals)
            If pattern_type is equal to 0:  Note: PATTERN_LITERAL
                codegen_collect_strings_from_expression(codegen, pattern_value)
            End If

            Note: Collect strings from body statements
            Let j be 0
            While j is less than body_count:
                Let stmt_offset be j multiplied by 8
                Let stmt_ptr be memory_get_pointer(body_stmts, stmt_offset)
                codegen_collect_strings_from_statement(codegen, stmt_ptr)
                Set j to j plus 1
            End While

            Set i to i plus 1
        End While
        Return 0
    End If

    Note: STMT_COMPOUND_ASSIGN: target at offset 8, expression at offset 24
    If stmt_type is equal to 17:
        Let target be memory_get_pointer(stmt, 8)
        Let expression be memory_get_pointer(stmt, 24)
        Let result1 be codegen_collect_strings_from_expression(codegen, target)
        Let result2 be codegen_collect_strings_from_expression(codegen, expression)
        Return 0
    End If

    Note: STMT_FOR: start at offset 16, end at offset 24, step at offset 32, body at offset 40
    If stmt_type is equal to 11:
        Let start_expr be memory_get_pointer(stmt, 16)
        Let end_expr be memory_get_pointer(stmt, 24)
        Let step_expr be memory_get_pointer(stmt, 32)
        Let body be memory_get_pointer(stmt, 40)
        Let body_count be memory_get_integer(stmt, 48)

        Let result1 be codegen_collect_strings_from_expression(codegen, start_expr)
        Let result2 be codegen_collect_strings_from_expression(codegen, end_expr)
        If step_expr is not equal to 0:
            Let result3 be codegen_collect_strings_from_expression(codegen, step_expr)
        End If

        Let i be 0
        While i is less than body_count:
            Let body_stmt be memory_get_pointer(body, i multiplied by 8)
            Let result_body be codegen_collect_strings_from_statement(codegen, body_stmt)
            Set i to i plus 1
        End While
        Return 0
    End If

    If stmt_type is equal to 12:  Note: STMT_FOR_EACH
        Let collection_expr be memory_get_pointer(stmt, 16)
        Let body be memory_get_pointer(stmt, 24)
        Let body_count be memory_get_integer(stmt, 32)

        Let result1 be codegen_collect_strings_from_expression(codegen, collection_expr)

        Let i be 0
        While i is less than body_count:
            Let body_stmt be memory_get_pointer(body, i multiplied by 8)
            Let result_body be codegen_collect_strings_from_statement(codegen, body_stmt)
            Set i to i plus 1
        End While
        Return 0
    End If

    Note: Other statement types (IMPORT, BREAK, CONTINUE, INLINE_ASSEMBLY) don't have strings to collect
    Return 0
End Process

Note: Helper function to determine the type name of an expression
Process called "codegen_get_expression_type" takes codegen as Integer, expr as Integer returns Integer:
    If expr is equal to 0:
        Return 0
    End If

    Let expr_type be memory_get_int32(expr, 0)  Note: expr->type

    If expr_type is equal to 1:  Note: EXPR_VARIABLE
        Let variable_name be memory_get_pointer(expr, 8)  Note: expr->data.variable_name
        Let var_index be codegen_find_variable(codegen, variable_name)

        If var_index is less than 0:  Note: -1 for not found
            Note: Check if this is a global variable
            Let current_program be memory_get_pointer(codegen, 48)  Note: codegen->current_program (pointer with padding)
            If current_program is not equal to 0:
                Let global_count be memory_get_int32(current_program, 56)  Note: program->global_count (PROGRAM_GLOBAL_COUNT)
                Let globals be memory_get_pointer(current_program, 48)       Note: program->globals (PROGRAM_GLOBAL_VARS)

                Let j be 0
                While j is less than global_count:
                    Let global_offset be j multiplied by 8
                    Let global_ptr be memory_get_pointer(globals, global_offset)
                    Let global_name be memory_get_pointer(global_ptr, 0)  Note: global->name
                    If string_equals(global_name, variable_name) is equal to 1:
                        Let global_type be memory_get_integer(global_ptr, 8)  Note: global->type
                        Return global_type
                    End If
                    Let j be j plus 1
                End While
            End If
            Return 0
        End If

        Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
        Let var_offset be var_index multiplied by 32
        Let var_ptr be variables plus var_offset
        Let type_name be memory_get_pointer(var_ptr, 16)  Note: variable.type_name
        Return type_name
    End If

    If expr_type is equal to 6:  Note: EXPR_FIELD_ACCESS
        Let field_access_ptr be expr plus 8  Note: &expr->data.field_access
        Let object be memory_get_pointer(field_access_ptr, 0)       Note: field_access.object
        Let field_name be memory_get_pointer(field_access_ptr, 8)   Note: field_access.field_name

        Note: Get the type of the object
        Let object_type be codegen_get_expression_type(codegen, object)
        If object_type is equal to 0:
            Return 0
        End If

        Note: Find the type definition
        Let current_program be memory_get_pointer(codegen, 48)  Note: codegen->current_program (pointer with padding)
        Let type_count be memory_get_int32(current_program, 24)  Note: PROGRAM_TYPE_COUNT
        Let types be memory_get_pointer(current_program, 16)       Note: PROGRAM_TYPES
        Let type be 0

        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)  Note: type->name
            If string_equals(type_name_ptr, object_type) is equal to 1:
                Let type be type_ptr
                Let i be type_count  Note: break loop
            End If
            Let i be i plus 1
        End While

        If type is equal to 0:
            Return 0
        End If

        Note: Find the field and return its type
        Let kind be memory_get_int32(type, 8)  Note: type->kind
        If kind is equal to 0:  Note: TYPE_KIND_STRUCT
            Note: TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET is 24
            Note: TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET is 16
            Let field_count be memory_get_int32(type, 24)
            Let fields be memory_get_pointer(type, 16)

            Let i be 0
            While i is less than field_count:
                Let field_offset be i multiplied by 24
                Let field_ptr be fields plus field_offset  Note: sizeof(FieldDefinition)
                Let field_name_ptr be memory_get_pointer(field_ptr, 0)  Note: field.name
                If string_equals(field_name_ptr, field_name) is equal to 1:
                    Let field_type be memory_get_pointer(field_ptr, 8)  Note: field.type
                    Return field_type
                End If
                Let i be i plus 1
            End While
        End If

        Return 0
    End If

    If expr_type is equal to 20:  Note: EXPR_STRUCT_CONSTRUCTION
        Let struct_type_name be memory_get_pointer(expr, 8)
        Return struct_type_name
    End If

    Note: Other expression types don't have determinable types in this context
    Return 0
End Process

Note: Generate the address of an lvalue expression (result in %rbx)
Process called "codegen_generate_lvalue_address" takes codegen as Integer, expr as Integer returns Integer:
    Let expr_type be memory_get_int32(expr, 0)  Note: expr->type
    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file

    If expr_type is equal to 1:  Note: EXPR_VARIABLE
        Note: Find variable and generate its address
        Let variable_name be memory_get_pointer(expr, 8)  Note: expr->data.variable_name
        Let var_index be codegen_find_variable(codegen, variable_name)

        If var_index is less than 0:  Note: -1 for not found
            Note: Check if this is a global variable
            Let is_global be 0
            Let current_program be memory_get_pointer(codegen, 48)  Note: codegen->current_program (pointer with padding)

            If current_program is not equal to 0:
                Let global_count be memory_get_int32(current_program, 56)  Note: program->global_count (PROGRAM_GLOBAL_COUNT)
                Let globals be memory_get_pointer(current_program, 48)       Note: program->globals (PROGRAM_GLOBAL_VARS)

                Let j be 0
                While j is less than global_count:
                    Let global_offset be j multiplied by 8
                    Let global_ptr be memory_get_pointer(globals, global_offset)
                    Let global_name be memory_get_pointer(global_ptr, 0)  Note: global->name
                    If string_equals(global_name, variable_name) is equal to 1:
                        Let is_global be 1
                        Let j be global_count  Note: break loop
                    End If
                    Let j be j plus 1
                End While
            End If

            If is_global is equal to 1:
                Note: Generate address of global variable
                file_write_buffered(output_file, "    leaq ", 0)
                file_write_buffered(output_file, variable_name, 0)
                file_write_buffered(output_file, "(%rip), %rbx  # Address of global variable", 0)
            Otherwise:
                print_string("[CODEGEN ERROR] Unknown variable '")
                print_string(variable_name)
                print_string("'")
                exit_with_code(1)
            End If
        Otherwise:
            Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
            Let var_offset be var_index multiplied by 32
            Let var_ptr be variables plus var_offset
            Let offset be memory_get_int32(var_ptr, 8)  Note: variable.stack_offset

            Note: Generate address of variable on stack
            file_write_buffered(output_file, "    leaq -", 0)
            file_write_buffered(output_file, integer_to_string(offset), 0)
            file_write_buffered(output_file, "(%rbp), %rbx\n", 0)
        End If
        Return 0
    End If

    If expr_type is equal to 6:  Note: EXPR_FIELD_ACCESS
        Let field_access_ptr be expr plus 8  Note: &expr->data.field_access
        Let object be memory_get_pointer(field_access_ptr, 0)     Note: field_access.object
        Let field_name be memory_get_pointer(field_access_ptr, 8) Note: field_access.field_name

        Note: For field access, we need the POINTER VALUE, not the address of the pointer variable
        Note: If object is a variable, we need to load its value (the pointer)
        Let obj_type be memory_get_int32(object, 0)
        If obj_type is equal to 1:  Note: EXPR_VARIABLE - load the pointer value
            Let variable_name be memory_get_pointer(object, 8)
            Let var_index be codegen_find_variable(codegen, variable_name)
            If var_index is less than 0:
                print_string("[CODEGEN ERROR] Unknown variable in field access")
                exit_with_code(1)
            End If
            Let variables be memory_get_pointer(codegen, 8)
            Let var_offset be var_index multiplied by 32
            Let var_ptr be variables plus var_offset
            Let stack_offset be memory_get_int32(var_ptr, 8)
            file_write_buffered(output_file, "    movq -", 0)
            file_write_buffered(output_file, integer_to_string(stack_offset), 0)
            file_write_buffered(output_file, "(%rbp), %rbx  # Load struct pointer\n", 0)
        Otherwise:
            Note: For other expressions, generate their value and use that as the pointer
            codegen_generate_expression(codegen, object)
            file_write_buffered(output_file, "    movq %rax, %rbx  # Use expression result as pointer\n", 0)
        End If

        Note: Now %rbx contains the struct pointer value
        Note: We need to add the field offset to get the field address

        Note: Get the type of the object using our helper function
        Let object_type be codegen_get_expression_type(codegen, object)
        If object_type is equal to 0:
            print_string("[CODEGEN ERROR] Cannot determine type of object in field access")
            exit_with_code(1)
        End If

        Note: Find the type definition
        Let current_program be memory_get_pointer(codegen, 48)  Note: codegen->current_program (pointer with padding)
        Let type_count be memory_get_int32(current_program, 24)  Note: PROGRAM_TYPE_COUNT
        Let types be memory_get_pointer(current_program, 16)       Note: PROGRAM_TYPES
        Let type be 0

        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)  Note: type->name
            If string_equals(type_name_ptr, object_type) is equal to 1:
                Let type be type_ptr
                Let i be type_count  Note: break loop
            End If
            Let i be i plus 1
        End While

        If type is equal to 0:
            print_string("[CODEGEN ERROR] Unknown type '")
            print_string(object_type)
            print_string("'")
            exit_with_code(1)
        End If

        Note: Find field offset
        Let field_offset be -1  Note: -1 for not found
        Let kind be memory_get_int32(type, 8)  Note: type->kind

        If kind is equal to 0:  Note: TYPE_KIND_STRUCT
            Note: TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET is 24
            Note: TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET is 16
            Let field_count be memory_get_int32(type, 24)
            Let fields be memory_get_pointer(type, 16)

            Let i be 0
            While i is less than field_count:
                Let field_idx_offset be i multiplied by 24
                Let field_ptr be fields plus field_idx_offset  Note: sizeof(FieldDefinition)
                Let field_name_ptr be memory_get_pointer(field_ptr, 0)  Note: field.name
                If string_equals(field_name_ptr, field_name) is equal to 1:
                    Let field_offset be memory_get_int32(field_ptr, 16)  Note: field.offset
                    Let i be field_count  Note: break loop
                End If
                Let i be i plus 1
            End While
        End If

        If field_offset is less than 0:  Note: -1 for not found
            print_string("[CODEGEN ERROR] Type '")
            print_string(object_type)
            print_string("' has no field '")
            print_string(field_name)
            print_string("'")
            exit_with_code(1)
        End If

        Note: Add field offset to object address
        file_write_buffered(output_file, "    addq $", 0)
        file_write_buffered(output_file, integer_to_string(field_offset), 0)
        file_write_buffered(output_file, ", %rbx\n", 0)
        Return 0
    End If

    If expr_type is equal to 16:  Note: EXPR_ARRAY_INDEX
        Let array_index_ptr be expr plus 8  Note: &expr->data.array_index
        Let arr be memory_get_integer(array_index_ptr, 0)  Note: array_index.array
        Let index be memory_get_integer(array_index_ptr, 8)  Note: array_index.index

        Note: Check if the array is a parameter or local variable
        Let array_type be memory_get_int32(arr, 0)  Note: array->type
        If array_type is equal to 1:  Note: EXPR_VARIABLE
            Let array_variable_name be memory_get_pointer(arr, 8)  Note: array->data.variable_name
            Let var_index be codegen_find_variable(codegen, array_variable_name)

            If var_index is greater than or equal to 0:  Note: found variable
                Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
                Let var_offset be var_index multiplied by 32
                Let var_ptr be variables plus var_offset
                Let is_parameter be memory_get_int32(var_ptr, 24)  Note: variable.is_parameter

                If is_parameter is equal to 1:
                    Note: For array parameters, load the pointer value, not the address
                    Let offset be memory_get_int32(var_ptr, 8)  Note: variable.stack_offset
                    file_write_buffered(output_file, "    movq -", 0)
                    file_write_buffered(output_file, integer_to_string(offset), 0)
                    file_write_buffered(output_file, "(%rbp), %rbx  # Load array parameter pointer", 0)
                Otherwise:
                    Note: For local arrays, generate the address
                    codegen_generate_lvalue_address(codegen, arr)
                End If
            Otherwise:
                Note: For complex expressions, generate the address
                codegen_generate_lvalue_address(codegen, arr)
            End If
        Otherwise:
            Note: For complex expressions, generate the address
            codegen_generate_lvalue_address(codegen, arr)
        End If

        Note: Save base address
        emit_line(output_file, "    pushq %rbx")

        Note: Generate index expression
        codegen_generate_expression(codegen, index)

        Note: Pop base address
        emit_line(output_file, "    popq %rbx")

        Note: Calculate element address: base + (index * element_size)
        Note: For arrays, all elements are currently 8 bytes (Integer size)
        emit_line(output_file, "    imulq $8, %rax")
        emit_line(output_file, "    addq %rax, %rbx")
        Return 0
    End If

    Note: Invalid lvalue expression type
    print_string("[CODEGEN ERROR] Invalid lvalue expression type")
    exit_with_code(1)
    Return 0
End Process

Note: Helper function to generate integer literal expression
Process called "codegen_generate_integer_expr" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file
    Let integer_value be memory_get_pointer(expr, 8)  Note: expr->data.integer_value
    file_write_buffered(output_file, "    movq $", 0)
    file_write_buffered(output_file, integer_to_string(integer_value), 0)
    file_write_buffered(output_file, ", %rax\n", 0)
    Return 0
End Process

Note: Helper function to generate variable expression
Process called "codegen_generate_variable_expr" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let variable_name be memory_get_pointer(expr, 8)  Note: expr->data.variable_name
    Let var_index be codegen_find_variable(codegen, variable_name)

    If var_index is less than 0:  Note: -1 for not found
        Note: Check if this is a global variable
        Let is_global be 0
        Let current_program be memory_get_pointer(codegen, 48)

        If current_program is not equal to 0:
            Let global_count be memory_get_int32(current_program, 56)  Note: PROGRAM_GLOBAL_COUNT
            Let globals be memory_get_pointer(current_program, 48)  Note: PROGRAM_GLOBAL_VARS

            Let j be 0
            Let found_global_ptr be 0
            While j is less than global_count:
                Let global_offset be j multiplied by 8
                Let global_ptr be memory_get_pointer(globals, global_offset)
                Let global_name be memory_get_pointer(global_ptr, 0)
                If string_equals(global_name, variable_name) is equal to 1:
                    Let is_global be 1
                    Let found_global_ptr be global_ptr
                    Let j be global_count
                End If
                Let j be j plus 1
            End While
        End If

        If is_global is equal to 1:
            Note: Check if this global has an integer initial_value (compile-time constant)
            Let initial_value be memory_get_pointer(found_global_ptr, 16)  Note: global->initial_value
            If initial_value is not equal to 0:
                Let expr_type be memory_get_int32(initial_value, 0)  Note: initial_value->type
                If expr_type is equal to 0:  Note: EXPR_INTEGER (compile-time constant)
                    Let integer_value be memory_get_pointer(initial_value, 8)  Note: initial_value->data.integer_value
                    file_write_buffered(output_file, "    movq $", 0)
                    file_write_buffered(output_file, integer_to_string(integer_value), 0)
                    file_write_buffered(output_file, ", %rax  # Load compile-time constant ", 0)
                    file_write_buffered(output_file, variable_name, 0)
                    file_write_buffered(output_file, "\n", 0)
                    Return 0
                End If
            End If
            Note: Not a compile-time constant, generate runtime access
            file_write_buffered(output_file, "    movq ", 0)
            file_write_buffered(output_file, variable_name, 0)
            file_write_buffered(output_file, "(%rip), %rax  # Load global variable\n", 0)
            Return 0
        End If

        Note: Check if function name
        Let is_function be 0
        If current_program is not equal to 0:
            Let function_count be memory_get_int32(current_program, 8)  Note: PROGRAM_FUNCTION_COUNT
            Let functions be memory_get_pointer(current_program, 0)  Note: PROGRAM_FUNCTIONS

            Note: Optimization: get first character for fast filtering
            Let name_first_char be memory_get_byte(variable_name, 0)

            Let j be 0
            While j is less than function_count:
                Let func_offset be j multiplied by 8
                Let function_ptr be memory_get_pointer(functions, func_offset)
                Let function_name be memory_get_pointer(function_ptr, 0)

                Note: Fast path: check first character before expensive string_equals
                Let func_first_char be memory_get_byte(function_name, 0)
                If func_first_char is equal to name_first_char:
                    If string_equals(function_name, variable_name) is equal to 1:
                        Let is_function be 1
                        Let j be function_count
                    End If
                End If

                Let j be j plus 1
            End While
        End If

        If is_function is equal to 0:
            print_string("[CODEGEN ERROR] Undefined variable: ")
            print_string(variable_name)
            exit_with_code(1)
        End If

        file_write_buffered(output_file, "    leaq ", 0)
        file_write_buffered(output_file, variable_name, 0)
        file_write_buffered(output_file, "(%rip), %rax  # Load function address\n", 0)
        Return 0
    End If

    Note: Variable found in local scope
    Let variables be memory_get_pointer(codegen, 8)
    Let var_offset be var_index multiplied by 32
    Let var_ptr be variables plus var_offset
    Let offset be memory_get_integer(var_ptr, 8)
    Let var_type be memory_get_pointer(var_ptr, 16)

    Note: Check if array type
    Let is_array be 0
    Let current_program be memory_get_pointer(codegen, 48)

    If current_program is not equal to 0:
        Let type_count be memory_get_int32(current_program, 24)  Note: PROGRAM_TYPE_COUNT
        Let types be memory_get_pointer(current_program, 16)  Note: PROGRAM_TYPES

        Let i be 0
        While i is less than type_count:
            Let type_offset be i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name_ptr be memory_get_pointer(type_ptr, 0)
            If string_equals(type_name_ptr, var_type) is equal to 1:
                Let kind be memory_get_integer(type_ptr, 8)
                If kind is equal to 2:
                    Let is_array be 1
                End If
                Let i be type_count
            End If
            Let i be i plus 1
        End While
    End If

    If is_array is equal to 1:
        file_write_buffered(output_file, "    leaq -", 0)
        file_write_buffered(output_file, integer_to_string(offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax  # Load array address\n", 0)
    Otherwise:
        file_write_buffered(output_file, "    movq -", 0)
        file_write_buffered(output_file, integer_to_string(offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax\n", 0)
    End If

    Return 0
End Process

Note: Generate code for integer literal expressions
Process called "codegen_generate_integer_literal" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let integer_value be memory_get_pointer(expr, 8)  Note: expr->data.integer_value
    file_write_buffered(output_file, "    movq $", 0)
    file_write_buffered(output_file, integer_to_string(integer_value), 0)
    file_write_buffered(output_file, ", %rax\n", 0)
    Return 0
End Process

Note: Generate code for variable expressions
Process called "codegen_generate_variable_handler" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    codegen_generate_variable_expr(codegen, expr)  Note: Already extracted earlier
    Return 0
End Process

Note: Generate code for string literal expressions
Process called "codegen_generate_string_literal" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)

    Note: Safety check
    If expr is equal to 0:  Note: NULL pointer check
        print_string("[CODEGEN ERROR] Invalid string literal expression")
        exit_with_code(1)
    End If

    Let string_value be memory_get_pointer(expr, 8)  Note: expr->data.string_value

    Note: Find or add the string to the string table
    Let string_count be memory_get_int32(codegen, 40)  Note: codegen->string_count (after padding)
    Let string_literals be memory_get_pointer(codegen, 32)  Note: codegen->strings (pointer with padding)
    Let string_index be -1  Note: -1 for not found

    Let i be 0
    While i is less than string_count:
        Let str_offset be i multiplied by 16  Note: StringLiteral is 16 bytes
        Let stored_string be memory_get_pointer(string_literals, str_offset)
        If string_equals(stored_string, string_value) is equal to 1:
            Let string_index be i
            Let i be string_count  Note: break loop
        End If
        Let i be i plus 1
    End While

    If string_index is less than 0:
        Note: Add new string - this should call codegen_add_string_literal instead
        Let string_index be codegen_add_string_literal(codegen, string_value)
    End If

    Note: Generate reference to string
    file_write_buffered(output_file, "    leaq .STR", 0)
    file_write_buffered(output_file, integer_to_string(string_index), 0)
    file_write_buffered(output_file, "(%rip), %rax\n", 0)
    Return 0
End Process

Note: Generate code for binary operation expressions
Process called "codegen_generate_binary_op" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let left be memory_get_pointer(expr, 8)         Note: binary_op.left
    Let right be memory_get_pointer(expr, 16)       Note: binary_op.right
    Let operator be memory_get_integer(expr, 24)    Note: binary_op.operator

    Note: OPTIMIZATION: For simple right operands (variables/integers), use direct register operations
    Let right_type be memory_get_int32(right, 0)
    Let use_direct_op be 0

    Note: Check if right is a simple variable (EXPR_VARIABLE = 1)
    If right_type is equal to 1:
        Let use_direct_op be 1
    End If

    Note: Check if right is an integer literal (EXPR_INTEGER = 0)
    If right_type is equal to 0:
        Let use_direct_op be 1
    End If

    If use_direct_op is equal to 1:
        Note: OPTIMIZED PATH: Direct register operations (3 instructions instead of 6)
        Note: Generate left operand (result in %rax)
        codegen_generate_expression(codegen, left)

        Note: For simple operations, operate directly on right without stack
        If operator is equal to 16:  Note: TOKEN_PLUS
            If right_type is equal to 0:  Note: Integer literal
                Let int_val be memory_get_pointer(right, 8)
                file_write_buffered(output_file, "    addq $", 0)
                file_write_buffered(output_file, integer_to_string(int_val), 0)
                file_write_buffered(output_file, ", %rax\n", 0)
            Otherwise:  Note: Variable
                Let var_name be memory_get_pointer(right, 8)
                Let var_index be codegen_find_variable(codegen, var_name)
                If var_index is greater than or equal to 0:
                    Let variables be memory_get_pointer(codegen, 8)
                    Let var_offset be var_index multiplied by 32
                    Let var_ptr be variables plus var_offset
                    Let stack_offset be memory_get_integer(var_ptr, 8)
                    file_write_buffered(output_file, "    addq -", 0)
                    file_write_buffered(output_file, integer_to_string(stack_offset), 0)
                    file_write_buffered(output_file, "(%rbp), %rax\n", 0)
                Otherwise:
                    Note: Fallback to stack-based for complex cases
                    emit_line(output_file, "    pushq %rax")
                    codegen_generate_expression(codegen, right)
                    emit_line(output_file, "    popq %rbx")
                    emit_line(output_file, "    addq %rbx, %rax")
                End If
            End If
        Otherwise If operator is equal to 17:  Note: TOKEN_MINUS
            If right_type is equal to 0:  Note: Integer literal
                Let int_val be memory_get_pointer(right, 8)
                file_write_buffered(output_file, "    subq $", 0)
                file_write_buffered(output_file, integer_to_string(int_val), 0)
                file_write_buffered(output_file, ", %rax\n", 0)
            Otherwise:  Note: Variable
                Let var_name be memory_get_pointer(right, 8)
                Let var_index be codegen_find_variable(codegen, var_name)
                If var_index is greater than or equal to 0:
                    Let variables be memory_get_pointer(codegen, 8)
                    Let var_offset be var_index multiplied by 32
                    Let var_ptr be variables plus var_offset
                    Let stack_offset be memory_get_integer(var_ptr, 8)
                    file_write_buffered(output_file, "    subq -", 0)
                    file_write_buffered(output_file, integer_to_string(stack_offset), 0)
                    file_write_buffered(output_file, "(%rbp), %rax\n", 0)
                Otherwise:
                    Note: Fallback to stack-based for complex cases
                    emit_line(output_file, "    pushq %rax")
                    codegen_generate_expression(codegen, right)
                    emit_line(output_file, "    popq %rbx")
                    emit_line(output_file, "    subq %rax, %rbx")
                    emit_line(output_file, "    movq %rbx, %rax")
                End If
            End If
        Otherwise If operator is equal to 35:  Note: TOKEN_MULTIPLIED
            Note: Multiply requires both operands in registers, use stack-based
            emit_line(output_file, "    pushq %rax")
            codegen_generate_expression(codegen, right)
            emit_line(output_file, "    popq %rbx")
            emit_line(output_file, "    imulq %rbx, %rax")
        Note: For operations that require %rbx (div, mod, bitwise, shifts), use stack-based
        Otherwise If operator is equal to 36:  Note: TOKEN_DIVIDED
            emit_line(output_file, "    pushq %rax")
            codegen_generate_expression(codegen, right)
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    popq %rax")
            emit_line(output_file, "    testq %rcx, %rcx")
            Let label_counter be memory_get_int32(codegen, 28)
            file_write_buffered(output_file, "    jz .Ldiv_by_zero_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, "\n", 0)
            emit_line(output_file, "    cqto")
            emit_line(output_file, "    idivq %rcx")
            file_write_buffered(output_file, "    jmp .Ldiv_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, "\n", 0)
            file_write_buffered(output_file, ".Ldiv_by_zero_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            emit_line(output_file, "    movq $0, %rax")
            file_write_buffered(output_file, ".Ldiv_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            memory_set_int32(codegen, 28, label_counter plus 1)
        Otherwise If operator is equal to 37:  Note: TOKEN_MODULO
            emit_line(output_file, "    pushq %rax")
            codegen_generate_expression(codegen, right)
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    popq %rax")
            emit_line(output_file, "    testq %rcx, %rcx")
            Let label_counter be memory_get_int32(codegen, 28)
            file_write_buffered(output_file, "    jz .Lmod_by_zero_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, "\n", 0)
            emit_line(output_file, "    cqto")
            emit_line(output_file, "    idivq %rcx")
            emit_line(output_file, "    movq %rdx, %rax")
            file_write_buffered(output_file, "    jmp .Lmod_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, "\n", 0)
            file_write_buffered(output_file, ".Lmod_by_zero_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            emit_line(output_file, "    movq $0, %rax")
            file_write_buffered(output_file, ".Lmod_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            memory_set_int32(codegen, 28, label_counter plus 1)
        Otherwise If operator is equal to 39:  Note: TOKEN_BIT_AND
            If right_type is equal to 0:  Note: Integer literal
                Let int_val be memory_get_pointer(right, 8)
                file_write_buffered(output_file, "    andq $", 0)
                file_write_buffered(output_file, integer_to_string(int_val), 0)
                file_write_buffered(output_file, ", %rax\n", 0)
            Otherwise:  Note: Variable or complex
                emit_line(output_file, "    pushq %rax")
                codegen_generate_expression(codegen, right)
                emit_line(output_file, "    popq %rbx")
                emit_line(output_file, "    andq %rbx, %rax")
            End If
        Otherwise If operator is equal to 40:  Note: TOKEN_BIT_OR
            If right_type is equal to 0:  Note: Integer literal
                Let int_val be memory_get_pointer(right, 8)
                file_write_buffered(output_file, "    orq $", 0)
                file_write_buffered(output_file, integer_to_string(int_val), 0)
                file_write_buffered(output_file, ", %rax\n", 0)
            Otherwise:  Note: Variable or complex
                emit_line(output_file, "    pushq %rax")
                codegen_generate_expression(codegen, right)
                emit_line(output_file, "    popq %rbx")
                emit_line(output_file, "    orq %rbx, %rax")
            End If
        Otherwise If operator is equal to 41:  Note: TOKEN_BIT_XOR
            If right_type is equal to 0:  Note: Integer literal
                Let int_val be memory_get_pointer(right, 8)
                file_write_buffered(output_file, "    xorq $", 0)
                file_write_buffered(output_file, integer_to_string(int_val), 0)
                file_write_buffered(output_file, ", %rax\n", 0)
            Otherwise:  Note: Variable or complex
                emit_line(output_file, "    pushq %rax")
                codegen_generate_expression(codegen, right)
                emit_line(output_file, "    popq %rbx")
                emit_line(output_file, "    xorq %rbx, %rax")
            End If
        Otherwise If operator is equal to 42:  Note: TOKEN_BIT_SHIFT_LEFT
            emit_line(output_file, "    pushq %rax")
            codegen_generate_expression(codegen, right)
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    popq %rax")
            emit_line(output_file, "    salq %cl, %rax")
        Otherwise If operator is equal to 43:  Note: TOKEN_BIT_SHIFT_RIGHT
            emit_line(output_file, "    pushq %rax")
            codegen_generate_expression(codegen, right)
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    popq %rax")
            emit_line(output_file, "    sarq %cl, %rax")
        End If
    Otherwise:
        Note: FALLBACK PATH: Complex expressions use stack-based evaluation
        Note: Generate left operand (result in %rax)
        codegen_generate_expression(codegen, left)
        emit_line(output_file, "    pushq %rax")
        Note: Generate right operand (result in %rax)
        codegen_generate_expression(codegen, right)
        emit_line(output_file, "    popq %rbx")

        Note: Perform the operation based on operator
        If operator is equal to 16:  Note: TOKEN_PLUS
            emit_line(output_file, "    addq %rbx, %rax")
        Otherwise If operator is equal to 17:  Note: TOKEN_MINUS
            emit_line(output_file, "    subq %rax, %rbx")
            emit_line(output_file, "    movq %rbx, %rax")
        Otherwise If operator is equal to 35:  Note: TOKEN_MULTIPLIED
            emit_line(output_file, "    imulq %rbx, %rax")
        Otherwise If operator is equal to 36:  Note: TOKEN_DIVIDED
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    movq %rbx, %rax")
            emit_line(output_file, "    testq %rcx, %rcx")
            Let label_counter be memory_get_int32(codegen, 28)
            Let jz_label be string_concat("    jz .Ldiv_by_zero_", integer_to_string(label_counter))
            emit_line(output_file, jz_label)
            emit_line(output_file, "    cqto")
            emit_line(output_file, "    idivq %rcx")
            Note: Use file_write_buffered instead of string_concat to avoid allocations
            file_write_buffered(output_file, "    jmp .Ldiv_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, "\n", 0)
            file_write_buffered(output_file, ".Ldiv_by_zero_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            emit_line(output_file, "    movq $0, %rax")
            file_write_buffered(output_file, ".Ldiv_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            memory_set_int32(codegen, 28, label_counter plus 1)
        Otherwise If operator is equal to 37:  Note: TOKEN_MODULO
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    movq %rbx, %rax")
            emit_line(output_file, "    testq %rcx, %rcx")
            Let label_counter be memory_get_int32(codegen, 28)
            Let jz_label be string_concat("    jz .Lmod_by_zero_", integer_to_string(label_counter))
            emit_line(output_file, jz_label)
            emit_line(output_file, "    cqto")
            emit_line(output_file, "    idivq %rcx")
            emit_line(output_file, "    movq %rdx, %rax")
            Note: Use file_write_buffered instead of string_concat to avoid allocations
            file_write_buffered(output_file, "    jmp .Lmod_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, "\n", 0)
            file_write_buffered(output_file, ".Lmod_by_zero_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            emit_line(output_file, "    movq $0, %rax")
            file_write_buffered(output_file, ".Lmod_done_", 0)
            file_write_buffered(output_file, integer_to_string(label_counter), 0)
            file_write_buffered(output_file, ":\n", 0)
            memory_set_int32(codegen, 28, label_counter plus 1)
        Otherwise If operator is equal to 39:  Note: TOKEN_BIT_AND
            emit_line(output_file, "    andq %rbx, %rax")
        Otherwise If operator is equal to 40:  Note: TOKEN_BIT_OR
            emit_line(output_file, "    orq %rbx, %rax")
        Otherwise If operator is equal to 41:  Note: TOKEN_BIT_XOR
            emit_line(output_file, "    xorq %rbx, %rax")
        Otherwise If operator is equal to 42:  Note: TOKEN_BIT_SHIFT_LEFT
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    movq %rbx, %rax")
            emit_line(output_file, "    salq %cl, %rax")
        Otherwise If operator is equal to 43:  Note: TOKEN_BIT_SHIFT_RIGHT
            emit_line(output_file, "    movq %rax, %rcx")
            emit_line(output_file, "    movq %rbx, %rax")
            emit_line(output_file, "    sarq %cl, %rax")
        Otherwise If operator is equal to 30:  Note: TOKEN_AND
            emit_line(output_file, "    andq %rbx, %rax")
        Otherwise If operator is equal to 31:  Note: TOKEN_OR
            emit_line(output_file, "    orq %rbx, %rax")
        End If
    End If
    Return 0
End Process

Note: Generate code for unary operators (NOT)
Process called "codegen_generate_unary_op" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let operator be memory_get_integer(expr, 8)
    Let operand be memory_get_pointer(expr, 16)

    codegen_generate_expression(codegen, operand)

    If operator is equal to 29:  Note: TOKEN_NOT
        emit_line(output_file, "    testq %rax, %rax")
        emit_line(output_file, "    setz %al")
        emit_line(output_file, "    movzbq %al, %rax")
    End If

    Return 0
End Process

Note: Generate code for comparison expressions
Process called "codegen_generate_comparison" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let left be memory_get_pointer(expr, 8)           Note: comparison.left
    Let right be memory_get_pointer(expr, 16)         Note: comparison.right
    Let comparison_op be memory_get_integer(expr, 24) Note: comparison.comparison_op

    Note: Generate left operand (result in %rax)
    codegen_generate_expression(codegen, left)
    emit_line(output_file, "    pushq %rax")
    Note: Generate right operand (result in %rax)
    codegen_generate_expression(codegen, right)
    emit_line(output_file, "    popq %rbx")

    Note: Compare and set result
    emit_line(output_file, "    cmpq %rax, %rbx")
    If comparison_op is equal to 22:  Note: TOKEN_EQUAL
        emit_line(output_file, "    sete %al")
    Otherwise If comparison_op is equal to 23:  Note: TOKEN_NOT_EQUAL
        emit_line(output_file, "    setne %al")
    Otherwise If comparison_op is equal to 24:  Note: TOKEN_LESS
        emit_line(output_file, "    setl %al")
    Otherwise If comparison_op is equal to 25:  Note: TOKEN_GREATER
        emit_line(output_file, "    setg %al")
    Otherwise If comparison_op is equal to 27:  Note: TOKEN_LESS_EQUAL
        emit_line(output_file, "    setle %al")
    Otherwise If comparison_op is equal to 26:  Note: TOKEN_GREATER_EQUAL
        emit_line(output_file, "    setge %al")
    End If
    emit_line(output_file, "    movzbq %al, %rax")
    Return 0
End Process

Note: Generate code for function call expressions
Process called "codegen_generate_function_call" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let function_call_ptr be expr plus 8  Note: &expr->data.function_call
    Let function_name be memory_get_pointer(function_call_ptr, 0)  Note: function_call.function_name
    Let arguments be memory_get_pointer(function_call_ptr, 8)      Note: function_call.arguments
    Let arg_count be memory_get_int32(function_call_ptr, 16)     Note: function_call.argument_count

    Note: Safety check for function_name
    If function_name is equal to 0:  Note: NULL pointer check
        exit_with_code(1)
    End If

    Note: Generate argument values in reverse order (right-to-left evaluation)
    Let i be arg_count minus 1
    While i is greater than or equal to 0:
        Let arg_offset be i multiplied by 8
        Let arg_expr be memory_get_pointer(arguments, arg_offset)

        Note: Debug check
        If arg_expr is equal to 0:
            print_string("[CODEGEN ERROR] NULL argument expression pointer: ")
            print_integer(arg_expr)
            exit_with_code(1)
        End If

        codegen_generate_expression(codegen, arg_expr)
        file_write_buffered(output_file, "    pushq %rax\n", 0)
        Let i be i minus 1
    End While

    Note: Pop arguments into registers
    If arg_count is greater than or equal to 1:
        file_write_buffered(output_file, "    popq %rdi\n", 0)
    End If
    If arg_count is greater than or equal to 2:
        file_write_buffered(output_file, "    popq %rsi\n", 0)
    End If
    If arg_count is greater than or equal to 3:
        file_write_buffered(output_file, "    popq %rdx\n", 0)
    End If
    If arg_count is greater than or equal to 4:
        file_write_buffered(output_file, "    popq %rcx\n", 0)
    End If
    If arg_count is greater than or equal to 5:
        file_write_buffered(output_file, "    popq %r8\n", 0)
    End If
    If arg_count is greater than or equal to 6:
        file_write_buffered(output_file, "    popq %r9\n", 0)
    End If

    Note: Call the function - add @PLT for external runtime functions
    file_write_buffered(output_file, "    call ", 0)
    file_write_buffered(output_file, function_name, 0)

    Note: Check if this is a runtime function that needs @PLT
    Let needs_plt be 0
    If string_equals(function_name, "allocate") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "deallocate") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_allocate") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_reallocate") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "string_length") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "string_char_at") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "string_equals") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "string_compare") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "string_find") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "string_substring") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "string_duplicate") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "string_concat") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "integer_to_string") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "ascii_value_of") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "is_digit") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "is_whitespace") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "file_open_buffered") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "file_write_buffered") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "file_close_buffered") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_get_byte") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_set_byte") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_get_int32") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_set_int32") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_get_integer") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_set_integer") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_get_pointer") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_set_pointer") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "memory_set_pointer_at_index") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "exit_with_code") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "read_file_internal") is equal to 1: Let needs_plt be 1
    Otherwise If string_equals(function_name, "get_command_line_arg") is equal to 1: Let needs_plt be 1
    End If
    Note: Note: print_string, print_integer, string_copy_n, string_set_char are Runa functions - no @PLT

    If needs_plt is equal to 1:
        file_write_buffered(output_file, "@PLT", 0)
    End If
    file_write_buffered(output_file, "\n", 0)

    Note: Result is now in %rax (x86_64 calling convention)
    Note: The function result is left in %rax for the calling code to use
    Return 0
End Process

Note: Generate code for indirect function call expressions (function pointers)
Process called "codegen_generate_indirect_call" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let function_call_ptr be expr plus 8  Note: &expr->data.function_call (same structure)
    Let function_expr be memory_get_pointer(function_call_ptr, 0)  Note: Expression that evaluates to function pointer
    Let arguments be memory_get_pointer(function_call_ptr, 8)      Note: function_call.arguments
    Let arg_count be memory_get_int32(function_call_ptr, 16)     Note: function_call.argument_count

    Note: Generate argument values in reverse order (right-to-left evaluation)
    Let i be arg_count minus 1
    While i is greater than or equal to 0:
        Let arg_offset be i multiplied by 8
        Let arg_expr be memory_get_pointer(arguments, arg_offset)
        codegen_generate_expression(codegen, arg_expr)
        file_write_buffered(output_file, "    pushq %rax\n", 0)
        Let i be i minus 1
    End While

    Note: Pop arguments into registers
    If arg_count is greater than or equal to 1:
        file_write_buffered(output_file, "    popq %rdi\n", 0)
    End If
    If arg_count is greater than or equal to 2:
        file_write_buffered(output_file, "    popq %rsi\n", 0)
    End If
    If arg_count is greater than or equal to 3:
        file_write_buffered(output_file, "    popq %rdx\n", 0)
    End If
    If arg_count is greater than or equal to 4:
        file_write_buffered(output_file, "    popq %rcx\n", 0)
    End If
    If arg_count is greater than or equal to 5:
        file_write_buffered(output_file, "    popq %r8\n", 0)
    End If
    If arg_count is greater than or equal to 6:
        file_write_buffered(output_file, "    popq %r9\n", 0)
    End If

    Note: Save function pointer expression - evaluate it into a temporary register
    Note: We need to be careful not to clobber argument registers
    file_write_buffered(output_file, "    pushq %rdi\n", 0)  Note: Save args if present
    If arg_count is greater than or equal to 2:
        file_write_buffered(output_file, "    pushq %rsi\n", 0)
    End If
    If arg_count is greater than or equal to 3:
        file_write_buffered(output_file, "    pushq %rdx\n", 0)
    End If
    If arg_count is greater than or equal to 4:
        file_write_buffered(output_file, "    pushq %rcx\n", 0)
    End If
    If arg_count is greater than or equal to 5:
        file_write_buffered(output_file, "    pushq %r8\n", 0)
    End If
    If arg_count is greater than or equal to 6:
        file_write_buffered(output_file, "    pushq %r9\n", 0)
    End If

    Note: Evaluate function pointer expression into %rax
    codegen_generate_expression(codegen, function_expr)
    file_write_buffered(output_file, "    movq %rax, %r10  # Save function pointer\n", 0)

    Note: Restore argument registers
    If arg_count is greater than or equal to 6:
        file_write_buffered(output_file, "    popq %r9\n", 0)
    End If
    If arg_count is greater than or equal to 5:
        file_write_buffered(output_file, "    popq %r8\n", 0)
    End If
    If arg_count is greater than or equal to 4:
        file_write_buffered(output_file, "    popq %rcx\n", 0)
    End If
    If arg_count is greater than or equal to 3:
        file_write_buffered(output_file, "    popq %rdx\n", 0)
    End If
    If arg_count is greater than or equal to 2:
        file_write_buffered(output_file, "    popq %rsi\n", 0)
    End If
    file_write_buffered(output_file, "    popq %rdi\n", 0)

    Note: Make indirect call through function pointer in %r10
    file_write_buffered(output_file, "    call *%r10  # Indirect call through function pointer\n", 0)

    Note: Result is now in %rax
    Return 0
End Process

Note: Generate code for field access expressions
Process called "codegen_generate_field_access" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)
    Let field_access_ptr be expr plus 8  Note: Union at offset 8
    Let obj be memory_get_pointer(field_access_ptr, 0)
    Let field_name be memory_get_pointer(field_access_ptr, 8)

    Note: Get the type of the object
    Let object_type be codegen_get_expression_type(codegen, obj)
    If object_type is equal to 0:
        print_string("[CODEGEN ERROR] Cannot determine type of object in field access")
        exit_with_code(1)
    End If

    Note: Find the type definition
    Let current_program be memory_get_pointer(codegen, 48)  Note: codegen->current_program
    Let type_count be memory_get_int32(current_program, 24)  Note: PROGRAM_TYPE_COUNT
    Let types be memory_get_pointer(current_program, 16)     Note: PROGRAM_TYPES
    Let type be 0

    Let i be 0
    While i is less than type_count:
        Let type_offset be i multiplied by 8
        Let type_ptr be memory_get_pointer(types, type_offset)
        Let type_name_ptr be memory_get_pointer(type_ptr, 0)  Note: type->name
        If string_equals(type_name_ptr, object_type) is equal to 1:
            Let type be type_ptr
            Let i be type_count  Note: break loop
        End If
        Let i be i plus 1
    End While

    If type is equal to 0:
        print_string("[CODEGEN ERROR] Unknown type '")
        print_string(object_type)
        print_string("'")
        exit_with_code(1)
    End If


    Note: Find field offset
    Let field_offset be -1  Note: -1 for not found
    Let kind be memory_get_int32(type, 8)  Note: type->kind

    If kind is equal to 0:  Note: TYPE_KIND_STRUCT
        Note: TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET is 24
        Note: TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET is 16
        Let field_count be memory_get_int32(type, 24)
        Let fields be memory_get_pointer(type, 16)

        Let j be 0
        While j is less than field_count:
            Let field_idx_offset be j multiplied by 24
            Let field_ptr be fields plus field_idx_offset  Note: sizeof(FieldDefinition)
            Let field_name_ptr be memory_get_pointer(field_ptr, 0)  Note: field.name
            If string_equals(field_name_ptr, field_name) is equal to 1:
                Let field_offset be memory_get_int32(field_ptr, 16)  Note: field.offset
                Let j be field_count  Note: break loop
            End If
            Let j be j plus 1
        End While
    End If

    If field_offset is less than 0:  Note: -1 for not found
        print_string("[CODEGEN ERROR] Type '")
        print_string(object_type)
        print_string("' has no field '")
        print_string(field_name)
        print_string("'")
        exit_with_code(1)
    End If

    Note: Generate code to load object address and access field
    Let obj_type be memory_get_int32(obj, 0)

    If obj_type is equal to 1:  Note: EXPR_VARIABLE
        Let obj_variable_name be memory_get_pointer(obj, 8)
        Let var_index be codegen_find_variable(codegen, obj_variable_name)
        If var_index is less than 0:
            print_string("[CODEGEN ERROR] Unknown variable")
            exit_with_code(1)
        End If

        Let variables be memory_get_pointer(codegen, 8)
        Let var_offset be var_index multiplied by 32
        Let var_ptr be variables plus var_offset
        Let stack_offset be memory_get_int32(var_ptr, 8)

        file_write_buffered(output_file, "    movq -", 0)
        file_write_buffered(output_file, integer_to_string(stack_offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax\n", 0)

        Note: Add field offset and dereference
        file_write_buffered(output_file, "    movq ", 0)
        file_write_buffered(output_file, integer_to_string(field_offset), 0)
        file_write_buffered(output_file, "(%rax), %rax\n", 0)
    Otherwise:
        Note: For complex expressions, generate the expression first
        codegen_generate_expression(codegen, obj)
        file_write_buffered(output_file, "    movq ", 0)
        file_write_buffered(output_file, integer_to_string(field_offset), 0)
        file_write_buffered(output_file, "(%rax), %rax\n", 0)
    End If

    Return 0
End Process

Note: Handle builtin call expressions
Process called "codegen_generate_builtin_call" takes codegen as Integer, expr as Integer returns Integer:
    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file
    Let builtin_call_ptr be expr plus 8  Note: &expr->data.builtin_call
    Let builtin_type be memory_get_int32(builtin_call_ptr, 0)  Note: builtin_call.builtin_type
    Let arguments be memory_get_pointer(builtin_call_ptr, 8)     Note: builtin_call.arguments
    Let arg_count be memory_get_int32(builtin_call_ptr, 16)    Note: builtin_call.argument_count

    Note: Map builtin types to function names - split into ranges to avoid deep nesting limits
    Let func_name be ""

    Note: First generate all argument values onto stack
    Let i be arg_count minus 1
    While i is greater than or equal to 0:
        Let arg_offset be i multiplied by 8
        Let arg_expr be memory_get_pointer(arguments, arg_offset)
        codegen_generate_expression(codegen, arg_expr)
        file_write_buffered(output_file, "    pushq %rax\n", 0)
        Let i be i minus 1
    End While

    Note: Pop arguments into the correct registers based on calling convention
    If arg_count is greater than or equal to 1:
        file_write_buffered(output_file, "    popq %rdi\n", 0)
    End If
    If arg_count is greater than or equal to 2:
        file_write_buffered(output_file, "    popq %rsi\n", 0)
    End If
    If arg_count is greater than or equal to 3:
        file_write_buffered(output_file, "    popq %rdx\n", 0)
    End If
    If arg_count is greater than or equal to 4:
        file_write_buffered(output_file, "    popq %rcx\n", 0)
    End If
    If arg_count is greater than or equal to 5:
        file_write_buffered(output_file, "    popq %r8\n", 0)
    End If
    If arg_count is greater than or equal to 6:
        file_write_buffered(output_file, "    popq %r9\n", 0)
    End If

    Note: Map builtin_type to function name
    Note: Since we don't have all builtins implemented, generate a generic name
    Note: This allows compilation to proceed but these calls won't work at runtime
    file_write_buffered(output_file, "    # Unimplemented builtin type ", 0)
    file_write_buffered(output_file, integer_to_string(builtin_type), 0)
    file_write_buffered(output_file, "\n", 0)
    file_write_buffered(output_file, "    movq $0, %rax  # Placeholder return value\n", 0)

    Return 0
End Process

Note: Generate code for expression - equivalent to codegen_generate_expression
Note: Simplified codegen_generate_expression that replaces the massive 1155-line function
Note: This will be inserted into codegen.runa to replace lines 1276-2431

Process called "codegen_generate_expression" takes codegen as Integer, expr as Integer returns Integer:
    Note: Safety check
    If expr is equal to 0:  Note: NULL pointer check
        print_string("[CODEGEN ERROR] NULL expression pointer")
        exit_with_code(1)
    End If

    Let expr_type be memory_get_int32(expr, 0)  Note: expr->type
    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file

    Note: Simple dispatcher without deep nesting
    If expr_type is equal to 0:  Note: EXPR_INTEGER_LITERAL
        Let integer_value be memory_get_integer(expr, 8)
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(integer_value), 0)
        file_write_buffered(output_file, ", %rax\n", 0)
        Return 0
    Otherwise If expr_type is equal to 1:  Note: EXPR_VARIABLE
        codegen_generate_variable_expr(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 2:  Note: EXPR_BINARY_OP
        codegen_generate_binary_op(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 3:  Note: EXPR_COMPARISON
        codegen_generate_comparison(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 4:  Note: EXPR_FUNCTION_CALL
        codegen_generate_function_call(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 11:  Note: EXPR_INDIRECT_CALL
        codegen_generate_indirect_call(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 12:  Note: EXPR_UNARY (NOT operator)
        codegen_generate_unary_op(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 5:  Note: EXPR_STRING_LITERAL
        codegen_generate_string_literal(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 6:  Note: EXPR_FIELD_ACCESS
        codegen_generate_field_access(codegen, expr)
        Return 0
    Otherwise If expr_type is equal to 7:  Note: EXPR_TYPE_CAST
        Let cast_expr be memory_get_pointer(expr, 16)
        codegen_generate_expression(codegen, cast_expr)
        Return 0
    Otherwise If expr_type is equal to 8:  Note: EXPR_BUILTIN_CALL
        Note: Simplified builtin call for Stage 1
        Let builtin_call_ptr be expr plus 8  Note: Union at offset 4
        Let arguments be memory_get_pointer(builtin_call_ptr, 8)
        Let arg_count be memory_get_integer(builtin_call_ptr, 16)

        Note: Generate arguments in reverse
        Let i be arg_count minus 1
        While i is greater than or equal to 0:
            Let arg_offset be i multiplied by 8
            Let arg_expr be memory_get_pointer(arguments, arg_offset)
            codegen_generate_expression(codegen, arg_expr)
            file_write_buffered(output_file, "    pushq %rax\n", 0)
            Let i be i minus 1
        End While

        Note: Pop into registers
        If arg_count is greater than 0:
            file_write_buffered(output_file, "    popq %rdi\n", 0)
        End If
        If arg_count is greater than 1:
            file_write_buffered(output_file, "    popq %rsi\n", 0)
        End If
        If arg_count is greater than 2:
            file_write_buffered(output_file, "    popq %rdx\n", 0)
        End If

        Note: Get builtin type token and map to function name
        Let builtin_type be memory_get_int32(builtin_call_ptr, 0)
        Let func_name be 0  Note: Will be set based on token

        Note: Map TOKEN to runtime function name
        If builtin_type is equal to 57: Let func_name be "string_length"  Note: TOKEN_STRING_LENGTH
        Otherwise If builtin_type is equal to 58: Let func_name be "string_char_at"  Note: TOKEN_STRING_CHAR_AT
        Otherwise If builtin_type is equal to 59: Let func_name be "string_substring"  Note: TOKEN_STRING_SUBSTRING
        Otherwise If builtin_type is equal to 60: Let func_name be "string_equals"  Note: TOKEN_STRING_EQUALS
        Otherwise If builtin_type is equal to 61: Let func_name be "ascii_value_of"  Note: TOKEN_ASCII_VALUE_OF
        Otherwise If builtin_type is equal to 62: Let func_name be "is_digit"  Note: TOKEN_IS_DIGIT
        Otherwise If builtin_type is equal to 64: Let func_name be "is_whitespace"  Note: TOKEN_IS_WHITESPACE
        Otherwise If builtin_type is equal to 72: Let func_name be "string_find"  Note: TOKEN_STRING_FIND
        Otherwise If builtin_type is equal to 73: Let func_name be "string_compare"  Note: TOKEN_STRING_COMPARE
        Otherwise If builtin_type is equal to 74: Let func_name be "string_concat"  Note: TOKEN_STRING_CONCAT
        Otherwise If builtin_type is equal to 75: Let func_name be "string_duplicate"  Note: TOKEN_STRING_DUPLICATE
        Otherwise If builtin_type is equal to 76: Let func_name be "integer_to_string"  Note: TOKEN_INTEGER_TO_STRING
        Otherwise If builtin_type is equal to 119: Let func_name be "allocate"  Note: TOKEN_ALLOCATE
        Otherwise If builtin_type is equal to 120: Let func_name be "deallocate"  Note: TOKEN_DEALLOCATE
        Otherwise If builtin_type is equal to 130: Let func_name be "memory_get_byte"  Note: TOKEN_MEMORY_GET_BYTE
        Otherwise If builtin_type is equal to 131: Let func_name be "memory_set_byte"  Note: TOKEN_MEMORY_SET_BYTE
        End If

        Note: Generate the call
        file_write_buffered(output_file, "    call ", 0)
        If func_name is equal to 0:
            file_write_buffered(output_file, "unknown_builtin_", 0)
            file_write_buffered(output_file, integer_to_string(builtin_type), 0)
        Otherwise:
            file_write_buffered(output_file, func_name, 0)
            file_write_buffered(output_file, "@PLT", 0)
        End If
        file_write_buffered(output_file, "\n", 0)
        Return 0
    Otherwise If expr_type is equal to 9:  Note: EXPR_VARIANT_CONSTRUCTOR
        Note: Get variant details
        Let type_name be memory_get_pointer(expr, 8)
        Let variant_name be memory_get_pointer(expr, 16)
        Let field_count be memory_get_int32(expr, 32)

        Note: Find the variant definition to get the tag
        Let current_program be memory_get_pointer(codegen, 48)
        Let type_count be memory_get_int32(current_program, 24)
        Let types be memory_get_pointer(current_program, 16)

        Let variant_tag be 0
        Let i be 0
        While i is less than type_count:
            Let type_ptr be memory_get_pointer_at_index(types, i)
            Let type_def_name be memory_get_pointer(type_ptr, 0)
            If string_equals(type_def_name, type_name) is equal to 1:
                Note: Found the type, now find the variant
                Let variant_count be memory_get_int32(type_ptr, 24)
                Let variants be memory_get_pointer(type_ptr, 16)

                Note: Loop through all variants to find match
                Let vi be 0
                Let found_match be 0
                While vi is less than variant_count:
                    Let variant_offset be vi multiplied by 32
                    Let variant_ptr be variants plus variant_offset
                    Let vname be memory_get_pointer(variant_ptr, 0)

                    If string_equals(vname, variant_name) is equal to 1:
                        Set variant_tag to memory_get_int32(variant_ptr, 20)
                        Set found_match to 1
                        Set vi to variant_count  Note: Break
                    Otherwise:
                        Set vi to vi plus 1
                    End If
                End While

                Note: If no match found, default to first variant (temporary workaround)
                If found_match is equal to 0:
                    If variant_count is greater than 0:
                        Let first_variant_ptr be variants
                        Set variant_tag to memory_get_int32(first_variant_ptr, 20)
                    End If
                End If
                Set i to type_count  Note: Break
            End If
            Set i to i plus 1
        End While

        Note: Allocate variant (8 bytes for tag + field storage)
        Let alloc_size be 8  Note: Just tag for fieldless variants
        If field_count is greater than 0:
            Let field_storage be field_count multiplied by 8
            Set alloc_size to alloc_size plus field_storage
        End If

        emit_line(output_file, "    # Allocate variant")
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(alloc_size), 0)
        file_write_buffered(output_file, ", %rdi\n", 0)
        emit_line(output_file, "    call allocate")

        Note: Store discriminator tag at offset 0
        file_write_buffered(output_file, "    movl $", 0)
        file_write_buffered(output_file, integer_to_string(variant_tag), 0)
        file_write_buffered(output_file, ", (%rax)  # Store variant tag\n", 0)

        Note: Store field values if field_count > 0
        If field_count is greater than 0:
            file_write_buffered(output_file, "    pushq %rax  # Save variant pointer\n", 0)

            Let field_values be memory_get_pointer(expr, 24)
            Let k be 0
            While k is less than field_count:
                Note: Generate field value expression
                Let field_value_expr be memory_get_pointer(field_values, k multiplied by 8)
                codegen_generate_expression(codegen, field_value_expr)

                Note: Store field value at offset 8 + (k * 8)
                Let field_offset be 8 plus k multiplied by 8
                file_write_buffered(output_file, "    movq (%rsp), %rbx  # Load variant pointer\n", 0)
                file_write_buffered(output_file, "    movq %rax, ", 0)
                file_write_buffered(output_file, integer_to_string(field_offset), 0)
                file_write_buffered(output_file, "(%rbx)  # Store field ", 0)
                file_write_buffered(output_file, integer_to_string(k), 0)
                file_write_buffered(output_file, "\n", 0)

                Set k to k plus 1
            End While

            file_write_buffered(output_file, "    popq %rax  # Restore variant pointer\n", 0)
        End If

        Return 0
    Otherwise If expr_type is equal to 10:  Note: EXPR_FUNCTION_POINTER
        Let function_pointer_ptr be expr plus 8  Note: Union at offset 4
        Let func_name be memory_get_pointer(function_pointer_ptr, 0)
        file_write_buffered(output_file, "    leaq ", 0)
        file_write_buffered(output_file, func_name, 0)
        file_write_buffered(output_file, "(%rip), %rax\n", 0)
        Return 0
    Otherwise If expr_type is equal to 16:  Note: EXPR_ARRAY_INDEX
        Note: Array indexing: array[index]
        Let array_expr be memory_get_pointer(expr, 8)
        Let index_expr be memory_get_pointer(expr, 16)

        Note: Generate code for index (result in %rax)
        codegen_generate_expression(codegen, index_expr)
        file_write_buffered(output_file, "    pushq %rax  # Save index\n", 0)

        Note: Generate code for array (result in %rax)
        codegen_generate_expression(codegen, array_expr)

        Note: Pop index into %rbx, array pointer is in %rax
        file_write_buffered(output_file, "    popq %rbx  # Load index\n", 0)

        Note: Calculate offset: index * 8 (pointer size)
        file_write_buffered(output_file, "    imulq $8, %rbx  # Multiply index by 8\n", 0)

        Note: Add offset to array pointer
        file_write_buffered(output_file, "    addq %rbx, %rax  # Add offset to array pointer\n", 0)

        Note: Load value from array[index]
        file_write_buffered(output_file, "    movq (%rax), %rax  # Load value from array\n", 0)

        Return 0
    End If

    If expr_type is equal to 17:  Note: EXPR_LIST_LITERAL
        Note: Get list elements and count
        Let elements be memory_get_pointer(expr, 8)
        Let element_count be memory_get_integer(expr, 16)

        Note: Create list using list_create()
        emit_line(output_file, "    call list_create")
        emit_line(output_file, "    pushq %rax  # Save list pointer")

        Note: Append each element using list_append()
        Let i be 0
        While i is less than element_count:
            Let elem_offset be i multiplied by 8
            Let elem_expr be memory_get_pointer(elements, elem_offset)

            Note: Generate element value
            codegen_generate_expression(codegen, elem_expr)
            emit_line(output_file, "    pushq %rax  # Save element value")

            Note: Call list_append(list, value)
            emit_line(output_file, "    movq 8(%rsp), %rdi  # Load list pointer")
            emit_line(output_file, "    movq (%rsp), %rsi   # Load element value")
            emit_line(output_file, "    call list_append")
            emit_line(output_file, "    popq %rax  # Clean up element value")

            Set i to i plus 1
        End While

        Note: Pop list pointer into %rax as result
        emit_line(output_file, "    popq %rax  # List pointer as result")
        Return 0
    End If

    If expr_type is equal to 18:  Note: EXPR_ARRAY_LITERAL
        Note: Get array elements, size, and type
        Let elements be memory_get_pointer(expr, 8)
        Let array_size be memory_get_integer(expr, 16)

        Note: Calculate size: array_size * 8 (assuming pointer-sized elements for now)
        Let total_size be array_size multiplied by 8

        Note: Allocate memory for array
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(total_size), 0)
        file_write_buffered(output_file, ", %rdi\n", 0)
        file_write_buffered(output_file, "    call memory_allocate\n", 0)
        file_write_buffered(output_file, "    pushq %rax  # Save array pointer\n", 0)

        Note: Generate code for each element and store
        Let i be 0
        While i is less than array_size:
            Let elem_offset be i multiplied by 8
            Let elem_expr be memory_get_pointer(elements, elem_offset)

            Note: Generate element value
            codegen_generate_expression(codegen, elem_expr)

            Note: Store in array
            file_write_buffered(output_file, "    movq (%rsp), %rbx  # Load array pointer\n", 0)
            file_write_buffered(output_file, "    movq %rax, ", 0)
            file_write_buffered(output_file, integer_to_string(elem_offset), 0)
            file_write_buffered(output_file, "(%rbx)\n", 0)

            Set i to i plus 1
        End While

        Note: Pop array pointer into %rax as result
        file_write_buffered(output_file, "    popq %rax  # Array pointer as result\n", 0)
        Return 0
    End If

    If expr_type is equal to 19:  Note: EXPR_ARRAY_TYPE (uninitialized)
        Note: Get array size
        Let array_size be memory_get_integer(expr, 8)

        Note: Calculate size: array_size * 8
        Let total_size be array_size multiplied by 8

        Note: Allocate zeroed memory
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(total_size), 0)
        file_write_buffered(output_file, ", %rdi\n", 0)
        file_write_buffered(output_file, "    call memory_allocate\n", 0)
        Return 0
    End If

    If expr_type is equal to 20:  Note: EXPR_STRUCT_CONSTRUCTION
        Note: Get struct construction data
        Let struct_type_name be memory_get_pointer(expr, 8)
        Let field_names be memory_get_pointer(expr, 16)
        Let field_values be memory_get_pointer(expr, 24)
        Let field_count be memory_get_int32(expr, 32)

        Note: Find the struct type definition to get size and field offsets
        Let current_program be memory_get_pointer(codegen, 48)
        Let type_count be memory_get_int32(current_program, 24)  Note: PROGRAM_TYPE_COUNT
        Let types be memory_get_pointer(current_program, 16)      Note: PROGRAM_TYPES
        Let type be 0

        Let type_i be 0
        While type_i is less than type_count:
            Let type_offset be type_i multiplied by 8
            Let type_ptr be memory_get_pointer(types, type_offset)
            Let type_name be memory_get_pointer(type_ptr, 0)
            If string_equals(type_name, struct_type_name) is equal to 1:
                Let type be type_ptr
                Let type_i be type_count  Note: break
            End If
            Let type_i be type_i plus 1
        End While

        If type is equal to 0:
            print_string("[CODEGEN ERROR] Unknown struct type '")
            print_string(struct_type_name)
            print_string("'")
            exit_with_code(1)
        End If

        Note: Calculate struct size from type definition
        Note: TYPEDEFINITION_SIZE_OFFSET is 40
        Let struct_size be memory_get_int32(type, 40)  Note: TYPEDEFINITION_SIZE_OFFSET

        Note: Allocate memory for struct
        file_write_buffered(output_file, "    movq $", 0)
        file_write_buffered(output_file, integer_to_string(struct_size), 0)
        file_write_buffered(output_file, ", %rdi\n", 0)
        file_write_buffered(output_file, "    call allocate@PLT\n", 0)
        file_write_buffered(output_file, "    pushq %rax  # Save struct pointer\n", 0)

        Note: Set each field value
        Let field_i be 0
        While field_i is less than field_count:
            Let field_ptr_offset be field_i multiplied by 8
            Let field_name be memory_get_pointer(field_names, field_ptr_offset)
            Let field_value_expr be memory_get_pointer(field_values, field_ptr_offset)

            Note: Find field offset in type definition
            Note: TYPEDEFINITION_DATA_STRUCT_FIELD_COUNT_OFFSET is 24
            Note: TYPEDEFINITION_DATA_STRUCT_FIELDS_OFFSET is 16
            Let struct_field_count be memory_get_int32(type, 24)
            Let fields be memory_get_pointer(type, 16)
            Let field_offset be -1

            Let field_j be 0
            While field_j is less than struct_field_count:
                Let field_def_offset be field_j multiplied by 24
                Let field_def_ptr be fields plus field_def_offset
                Let field_def_name be memory_get_pointer(field_def_ptr, 0)
                If string_equals(field_def_name, field_name) is equal to 1:
                    Let field_offset be memory_get_int32(field_def_ptr, 16)
                    Let field_j be struct_field_count  Note: break
                End If
                Let field_j be field_j plus 1
            End While

            If field_offset is less than 0:
                print_string("[CODEGEN ERROR] Unknown field '")
                print_string(field_name)
                print_string("' in struct '")
                print_string(struct_type_name)
                print_string("'")
                exit_with_code(1)
            End If

            Note: Generate field value expression
            codegen_generate_expression(codegen, field_value_expr)

            Note: Store value in struct field
            file_write_buffered(output_file, "    movq (%rsp), %rbx  # Load struct pointer\n", 0)
            file_write_buffered(output_file, "    movq %rax, ", 0)
            file_write_buffered(output_file, integer_to_string(field_offset), 0)
            file_write_buffered(output_file, "(%rbx)  # Store field value\n", 0)

            Let field_i be field_i plus 1
        End While

        Note: Pop struct pointer into %rax as result
        file_write_buffered(output_file, "    popq %rax  # Struct pointer as result\n", 0)
        Return 0
    End If

    If expr_type is equal to 21:  Note: EXPR_SET_LITERAL
        Note: Get set elements and count
        Let elements be memory_get_pointer(expr, 8)
        Let element_count be memory_get_integer(expr, 16)

        Note: Create set using set_create()
        emit_line(output_file, "    call set_create")
        emit_line(output_file, "    pushq %rax  # Save set pointer")

        Note: Add each element using set_add()
        Let i be 0
        While i is less than element_count:
            Let elem_offset be i multiplied by 8
            Let elem_expr be memory_get_pointer(elements, elem_offset)

            Note: Generate element value
            codegen_generate_expression(codegen, elem_expr)
            emit_line(output_file, "    pushq %rax  # Save element value")

            Note: Call set_add(set, value)
            emit_line(output_file, "    movq 8(%rsp), %rdi  # Load set pointer")
            emit_line(output_file, "    movq (%rsp), %rsi   # Load element value")
            emit_line(output_file, "    call set_add")
            emit_line(output_file, "    popq %rax  # Clean up element value")

            Set i to i plus 1
        End While

        Note: Pop set pointer into %rax as result
        emit_line(output_file, "    popq %rax  # Set pointer as result")
        Return 0
    End If

    If expr_type is equal to 22:  Note: EXPR_DICT_LITERAL
        Note: Get dictionary keys, values, and pair count
        Let keys be memory_get_pointer(expr, 8)
        Let values be memory_get_pointer(expr, 16)
        Let pair_count be memory_get_integer(expr, 24)

        Note: Create dictionary using dict_create()
        emit_line(output_file, "    call dict_create")
        emit_line(output_file, "    pushq %rax  # Save dict pointer")

        Note: Add each key-value pair using dict_set()
        Let i be 0
        While i is less than pair_count:
            Let pair_offset be i multiplied by 8
            Let key_expr be memory_get_pointer(keys, pair_offset)
            Let value_expr be memory_get_pointer(values, pair_offset)

            Note: Generate key expression
            codegen_generate_expression(codegen, key_expr)
            emit_line(output_file, "    pushq %rax  # Save key")

            Note: Generate value expression
            codegen_generate_expression(codegen, value_expr)
            emit_line(output_file, "    pushq %rax  # Save value")

            Note: Call dict_set(dict, key, value)
            emit_line(output_file, "    movq 16(%rsp), %rdi  # Load dict pointer")
            emit_line(output_file, "    movq 8(%rsp), %rsi   # Load key")
            emit_line(output_file, "    movq (%rsp), %rdx    # Load value")
            emit_line(output_file, "    call dict_set")
            emit_line(output_file, "    addq $16, %rsp  # Clean up key and value")

            Set i to i plus 1
        End While

        Note: Pop dict pointer into %rax as result
        emit_line(output_file, "    popq %rax  # Dict pointer as result")
        Return 0
    End If

    If expr_type is equal to 23:  Note: EXPR_LAMBDA
        Note: Generate lambda closure (no free variables yet)

        Note: Get lambda parameter name and body
        Let param_name be memory_get_pointer(expr, 8)
        Let body_expr be memory_get_pointer(expr, 16)

        Note: Generate unique lambda function name
        Let lambda_counter be memory_get_int32(codegen, 28)  Note: label_counter
        memory_set_int32(codegen, 28, lambda_counter plus 1)

        Note: Build lambda function name: __lambda_N
        Let lambda_name be "__lambda_"
        Let counter_str be integer_to_string(lambda_counter)
        Let full_lambda_name be string_concat(lambda_name, counter_str)

        Note: Save current function context
        Let saved_variables be memory_get_pointer(codegen, 8)
        Let saved_var_count be memory_get_int32(codegen, 16)
        Let saved_var_capacity be memory_get_int32(codegen, 20)
        Let saved_stack_offset be memory_get_int32(codegen, 24)

        Note: Create new variable context for lambda
        Let lambda_variables be allocate(16 multiplied by 32)
        memory_set_pointer(codegen, 8, lambda_variables)
        memory_set_int32(codegen, 16, 0)
        memory_set_int32(codegen, 20, 16)
        memory_set_int32(codegen, 24, 0)

        Note: Add parameter as local variable
        codegen_add_variable(codegen, param_name)

        Note: Generate lambda function in assembly
        Note: First, emit a jump to skip over the lambda function code
        Let skip_label be "__skip_lambda_"
        Let skip_label_full be string_concat(skip_label, counter_str)
        file_write_buffered(output_file, "    jmp ", 0)
        emit_line(output_file, skip_label_full)

        emit_line(output_file, "")
        emit_line(output_file, "# Lambda function")
        file_write_buffered(output_file, full_lambda_name, 0)
        emit_line(output_file, ":")
        emit_line(output_file, "    pushq %rbp")
        emit_line(output_file, "    movq %rsp, %rbp")

        Note: Parameter is in %rdi (first argument)
        Note: Store parameter on stack
        emit_line(output_file, "    subq $16, %rsp  # Allocate space for parameter")
        emit_line(output_file, "    movq %rdi, -8(%rbp)  # Store parameter")

        Note: Generate body expression
        codegen_generate_expression(codegen, body_expr)

        Note: Result is in %rax, clean up and return
        emit_line(output_file, "    leave")
        emit_line(output_file, "    ret")
        emit_line(output_file, "")

        Note: Emit skip label
        file_write_buffered(output_file, skip_label_full, 0)
        emit_line(output_file, ":")

        Note: Restore original function context
        deallocate(lambda_variables)
        memory_set_pointer(codegen, 8, saved_variables)
        memory_set_int32(codegen, 16, saved_var_count)
        memory_set_int32(codegen, 20, saved_var_capacity)
        memory_set_int32(codegen, 24, saved_stack_offset)

        Note: Now allocate closure struct (16 bytes: function_ptr + environment)
        emit_line(output_file, "    # Allocate closure struct")
        emit_line(output_file, "    movq $16, %rdi")
        emit_line(output_file, "    call allocate")
        emit_line(output_file, "    pushq %rax  # Save closure pointer")

        Note: Store function pointer in closure at offset 0
        file_write_buffered(output_file, "    leaq ", 0)
        file_write_buffered(output_file, full_lambda_name, 0)
        emit_line(output_file, "(%rip), %rbx  # Load function address")
        emit_line(output_file, "    popq %rax  # Restore closure pointer")
        emit_line(output_file, "    movq %rbx, 0(%rax)  # Store function_ptr")

        Note: Store NULL environment at offset 8
        emit_line(output_file, "    movq $0, 8(%rax)  # NULL environment")

        Note: Closure pointer is now in %rax as result
        Return 0
    End If

    If expr_type is equal to 24:  Note: EXPR_LAMBDA_CALL
        Note: Phase 3: Invoke lambda with arguments
        Note: Structure: lambda_expr at offset 8, arguments at offset 16, arg_count at offset 24

        Note: Get lambda expression (should evaluate to closure pointer)
        Let lambda_expr be memory_get_pointer(expr, 8)
        Let arguments be memory_get_pointer(expr, 16)
        Let arg_count be memory_get_int32(expr, 24)

        Note: Generate code to evaluate lambda expression to get closure pointer
        codegen_generate_expression(codegen, lambda_expr)
        Note: Result is closure pointer in %rax

        Note: Save closure pointer
        emit_line(output_file, "    pushq %rax  # Save closure pointer")

        Note: For Phase 3, we only support single argument
        If arg_count is equal to 1:
            Note: Evaluate the argument
            Let arg_expr be memory_get_pointer(arguments, 0)
            codegen_generate_expression(codegen, arg_expr)
            Note: Argument value is now in %rax

            Note: Move argument to %rdi (first parameter register)
            emit_line(output_file, "    movq %rax, %rdi  # Move argument to parameter register")

            Note: Restore closure pointer
            emit_line(output_file, "    popq %rax  # Restore closure pointer")

            Note: Load function pointer from closure (offset 0)
            emit_line(output_file, "    movq 0(%rax), %rbx  # Load function pointer from closure")

            Note: Call the lambda function
            emit_line(output_file, "    call *%rbx  # Invoke lambda")

            Note: Result is in %rax
            Return 0
        Otherwise:
            print_string("[CODEGEN ERROR] Lambda calls only support 1 argument in Phase 3")
            print_newline()
            exit_with_code(1)
        End If
    End If

    Note: Default case
    print_string("[CODEGEN ERROR] Unsupported expression type: ")
    print_integer(expr_type)
    print_newline()
    exit_with_code(1)
    Return 0
End Process
Process called "codegen_generate_statement" takes codegen as Integer, stmt as Integer returns Integer:
    Let stmt_type be memory_get_int32(stmt, 0)  Note: stmt->type - use int32 not integer
    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file

    If stmt_type is equal to 1:  Note: STMT_LET
        Note: Get the variable name first - it's always needed
        Let variable_name be memory_get_pointer(stmt, 8)  Note: stmt->data.let_stmt.variable_name at offset 8

        Note: Check if this is a type allocation
        Let let_expr be memory_get_pointer(stmt, 16)  Note: stmt->data.let_stmt.expression at offset 16
        If let_expr is not equal to 0:
            Let expr_type be memory_get_int32(let_expr, 0)  Note: expr->type
            If expr_type is equal to 7:  Note: EXPR_TYPE_NAME
                Note: This is a struct allocation - find the type
                Let type_name be memory_get_pointer(let_expr, 8)  Note: expr->data.type_name
                Let current_program be memory_get_pointer(codegen, 48)  Note: codegen->current_program (pointer with padding)
                Let type_count be memory_get_int32(current_program, 24)  Note: PROGRAM_TYPE_COUNT
                Let types be memory_get_pointer(current_program, 16)  Note: PROGRAM_TYPES

                Let type_found be 0
                Let type_def be 0
                Let i be 0
                While i is less than type_count:
                    Let current_type be memory_get_pointer(types, i multiplied by 8)
                    Let current_type_name be memory_get_pointer(current_type, 0)  Note: type->name
                    If string_equals(current_type_name, type_name) is equal to 1:
                        Let type_found be 1
                        Let type_def be current_type
                        Let i be type_count  Note: Break
                    End If
                    Let i be i plus 1
                End While

                If type_found is equal to 0:
                    exit_with_code(1)
                    Return 1
                End If

                Note: Add variable with type information
                codegen_add_variable_with_type(codegen, variable_name, type_name)

                Note: Get variable info
                Let var_index be codegen_find_variable(codegen, variable_name)
                Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
                Let offset be memory_get_int32(variables, var_index multiplied by 32 plus 8)  Note: variables[var_index].stack_offset

                Note: Handle different type kinds
                Let type_kind be memory_get_int32(type_def, 8)  Note: type->kind
                Let type_size be memory_get_int32(type_def, 16)  Note: type->size

                If type_kind is equal to 3:  Note: TYPE_KIND_ARRAY
                    Note: For arrays, allocate space for all elements and zero out memory
                    Let i be 0
                    While i is less than type_size:
                        file_write_buffered(output_file, "    movq $0, -", 0)
                        file_write_buffered(output_file, integer_to_string(offset minus i), 0)
                        file_write_buffered(output_file, "(%rbp)  # Zero array element", 0)
                        Let i be i plus 8
                    End While

                    Note: Update stack offset to account for full array size
                    Let current_stack_offset be memory_get_int32(codegen, 24)  Note: codegen->stack_offset
                    memory_set_integer(codegen, 16, current_stack_offset plus type_size)
                Otherwise:
                    Note: For structs, zero out the struct memory
                    Let i be 0
                    While i is less than type_size:
                        file_write_buffered(output_file, "    movq $0, -", 0)
                        file_write_buffered(output_file, integer_to_string(offset minus i), 0)
                        file_write_buffered(output_file, "(%rbp)\n", 0)
                        Let i be i plus 8
                    End While
                End If
            Otherwise:
                Note: Regular expression - check if the expression returns a string or list
                If expr_type is equal to 8:  Note: EXPR_BUILTIN_CALL
                    Let builtin_call_ptr be let_expr plus 8  Note: &expr->data.builtin_call
                    Let builtin_type be memory_get_int32(builtin_call_ptr, 0)  Note: builtin_call.builtin_type

                    Note: Check for string-returning builtins (read_file, string_substring, string_concat, integer_to_string, string_replace, string_trim)
                    Let is_string_builtin be 0
                    If builtin_type is equal to 37:
                        Let is_string_builtin be 1
                    Otherwise If builtin_type is equal to 42:
                        Let is_string_builtin be 1
                    Otherwise If builtin_type is equal to 48:
                        Let is_string_builtin be 1
                    Otherwise If builtin_type is equal to 49:
                        Let is_string_builtin be 1
                    Otherwise If builtin_type is equal to 52:
                        Let is_string_builtin be 1
                    Otherwise If builtin_type is equal to 54:
                        Let is_string_builtin be 1
                    End If
                    If is_string_builtin is equal to 1:
                        codegen_add_variable_with_type(codegen, variable_name, "String")
                    Otherwise:
                        Note: Check for list-returning builtins (list_create, list_copy, list_merge)
                        Let is_list_builtin be 0
                        If builtin_type is equal to 19:
                            Let is_list_builtin be 1
                        Otherwise If builtin_type is equal to 31:
                            Let is_list_builtin be 1
                        Otherwise If builtin_type is equal to 32:
                            Let is_list_builtin be 1
                        End If
                        If is_list_builtin is equal to 1:
                            codegen_add_variable_with_type(codegen, variable_name, "List")
                        Otherwise:
                            Note: Regular integer/other builtin expression
                            Note: Try to infer type from expression
                            Let inferred_type be codegen_get_expression_type(codegen, let_expr)
                            If inferred_type is equal to 0:
                                codegen_add_variable(codegen, variable_name)
                            Otherwise:
                                codegen_add_variable_with_type(codegen, variable_name, inferred_type)
                            End If
                        End If
                    End If
                Otherwise:
                    Note: Regular integer/other expression (non-builtin) - infer type
                    Let inferred_type be codegen_get_expression_type(codegen, let_expr)
                    If inferred_type is equal to 0:
                        codegen_add_variable(codegen, variable_name)
                    Otherwise:
                        codegen_add_variable_with_type(codegen, variable_name, inferred_type)
                    End If
                End If

                Note: Generate expression (result in %rax)
                codegen_generate_expression(codegen, let_expr)

                Note: Store value in variable's stack slot
                Let var_index be codegen_find_variable(codegen, variable_name)
                Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
                Let offset be memory_get_int32(variables, var_index multiplied by 32 plus 8)  Note: variables[var_index].stack_offset
                file_write_buffered(output_file, "    movq %rax, -", 0)
                file_write_buffered(output_file, integer_to_string(offset), 0)
                file_write_buffered(output_file, "(%rbp)\n", 0)
            End If
        End If
        Return 0
    End If

    If stmt_type is equal to 2:  Note: STMT_SET
        Note: Generate value expression (result in %rax)
        Let set_expr be memory_get_pointer(stmt, 16)  Note: stmt->data.set_stmt.expression
        codegen_generate_expression(codegen, set_expr)

        Note: Save the value on the stack
        emit_line(output_file, "    pushq %rax")

        Note: Generate the address of the target (result in %rbx)
        Let set_target be memory_get_pointer(stmt, 8)  Note: stmt->data.set_stmt.target
        codegen_generate_lvalue_address(codegen, set_target)

        Note: Restore value and store to target address
        emit_line(output_file, "    popq %rax")
        emit_line(output_file, "    movq %rax, (%rbx)")
        Return 0
    End If

    If stmt_type is equal to 17:  Note: STMT_COMPOUND_ASSIGN
        Note: Generate RHS expression (result in %rax)
        Let compound_expr be memory_get_pointer(stmt, 24)  Note: expression at offset 24
        codegen_generate_expression(codegen, compound_expr)

        Note: Save RHS value on stack
        emit_line(output_file, "    pushq %rax")

        Note: Generate the address of the target (result in %rbx)
        Let compound_target be memory_get_pointer(stmt, 8)  Note: target at offset 8
        codegen_generate_lvalue_address(codegen, compound_target)

        Note: Load current value from target into %rcx
        emit_line(output_file, "    movq (%rbx), %rcx")

        Note: Pop RHS value into %rax
        emit_line(output_file, "    popq %rax")

        Note: Get operation type: 0=add, 1=sub, 2=mul, 3=div
        Let operation be memory_get_int32(stmt, 16)  Note: operation at offset 16

        Note: Perform operation: %rcx = %rcx op %rax
        If operation is equal to 0:
            emit_line(output_file, "    addq %rax, %rcx")
        End If
        If operation is equal to 1:
            emit_line(output_file, "    subq %rax, %rcx")
        End If
        If operation is equal to 2:
            emit_line(output_file, "    imulq %rax, %rcx")
        End If
        If operation is equal to 3:
            Note: Division: %rcx / %rax
            Note: Move dividend to %rax, save divisor
            emit_line(output_file, "    pushq %rax")
            emit_line(output_file, "    movq %rcx, %rax")
            emit_line(output_file, "    cqto")
            emit_line(output_file, "    popq %rcx")
            emit_line(output_file, "    idivq %rcx")
            emit_line(output_file, "    movq %rax, %rcx")
        End If

        Note: Store result back to target
        emit_line(output_file, "    movq %rcx, (%rbx)")
        Return 0
    End If

    If stmt_type is equal to 11:  Note: STMT_FOR
        Let label_counter be memory_get_int32(codegen, 28)
        Let label_num be label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)

        Let loop_start_label be label_num multiplied by 10 plus 1
        Let loop_end_label be label_num multiplied by 10 plus 2

        Note: Get loop components
        Let var_name be memory_get_pointer(stmt, 8)
        Let start_expr be memory_get_pointer(stmt, 16)
        Let end_expr be memory_get_pointer(stmt, 24)
        Let step_expr be memory_get_pointer(stmt, 32)
        Let body be memory_get_pointer(stmt, 40)
        Let body_count be memory_get_integer(stmt, 48)

        Note: Allocate loop variable on stack
        codegen_add_variable(codegen, var_name)
        Let var_index be codegen_find_variable(codegen, var_name)
        Let variables be memory_get_pointer(codegen, 8)
        Let var_offset be memory_get_int32(variables, var_index multiplied by 32 plus 8)

        Note: Generate start expression and store in loop variable
        codegen_generate_expression(codegen, start_expr)
        file_write_buffered(output_file, "    movq %rax, -", 0)
        file_write_buffered(output_file, integer_to_string(var_offset), 0)
        file_write_buffered(output_file, "(%rbp)\n", 0)

        Note: Generate end expression and save on stack
        codegen_generate_expression(codegen, end_expr)
        emit_line(output_file, "    pushq %rax")

        Note: Loop start label
        Let loop_start_str be string_concat(".L", integer_to_string(loop_start_label))
        Let loop_start_label_line be string_concat(loop_start_str, ":")
        emit_line(output_file, loop_start_label_line)

        Note: Load loop variable and end value, compare
        file_write_buffered(output_file, "    movq -", 0)
        file_write_buffered(output_file, integer_to_string(var_offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax\n", 0)
        emit_line(output_file, "    movq (%rsp), %rcx")
        emit_line(output_file, "    cmpq %rcx, %rax")
        Let jg_instruction be string_concat("    jg .L", integer_to_string(loop_end_label))
        emit_line(output_file, jg_instruction)

        Note: Generate loop body
        Let i be 0
        While i is less than body_count:
            Let body_stmt be memory_get_pointer(body, i multiplied by 8)
            codegen_generate_statement(codegen, body_stmt)
            Set i to i plus 1
        End While

        Note: Increment loop variable by step
        If step_expr is not equal to 0:
            codegen_generate_expression(codegen, step_expr)
            emit_line(output_file, "    pushq %rax")
        End If
        If step_expr is equal to 0:
            emit_line(output_file, "    movq $1, %rax")
            emit_line(output_file, "    pushq %rax")
        End If
        file_write_buffered(output_file, "    movq -", 0)
        file_write_buffered(output_file, integer_to_string(var_offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax\n", 0)
        emit_line(output_file, "    popq %rcx")
        emit_line(output_file, "    addq %rcx, %rax")
        file_write_buffered(output_file, "    movq %rax, -", 0)
        file_write_buffered(output_file, integer_to_string(var_offset), 0)
        file_write_buffered(output_file, "(%rbp)\n", 0)

        Note: Jump back to loop start
        Let jmp_instruction be string_concat("    jmp .L", integer_to_string(loop_start_label))
        emit_line(output_file, jmp_instruction)

        Note: Loop end label
        Let loop_end_str be string_concat(".L", integer_to_string(loop_end_label))
        Let loop_end_label_line be string_concat(loop_end_str, ":")
        emit_line(output_file, loop_end_label_line)

        Note: Pop end value from stack
        emit_line(output_file, "    popq %rax")

        Return 0
    End If

    If stmt_type is equal to 12:  Note: STMT_FOR_EACH
        Let label_counter be memory_get_int32(codegen, 28)
        Let label_num be label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)

        Let loop_start_label be label_num multiplied by 10 plus 1
        Let loop_end_label be label_num multiplied by 10 plus 2

        Note: Get loop components
        Let var_name be memory_get_pointer(stmt, 8)
        Let collection_expr be memory_get_pointer(stmt, 16)
        Let body be memory_get_pointer(stmt, 24)
        Let body_count be memory_get_integer(stmt, 32)

        Note: Evaluate collection expression (result in %rax)
        codegen_generate_expression(codegen, collection_expr)
        emit_line(output_file, "    pushq %rax")  Note: Save collection pointer on stack

        Note: Get collection length by calling list_length
        emit_line(output_file, "    movq %rax, %rdi")
        emit_line(output_file, "    call list_length")
        emit_line(output_file, "    pushq %rax")  Note: Save length on stack

        Note: Initialize loop counter to 0
        emit_line(output_file, "    movq $0, %rax")
        emit_line(output_file, "    pushq %rax")  Note: Save counter on stack

        Note: Allocate loop variable on stack for the item value
        codegen_add_variable(codegen, var_name)
        Let var_index be codegen_find_variable(codegen, var_name)
        Let variables be memory_get_pointer(codegen, 8)
        Let var_offset be memory_get_int32(variables, var_index multiplied by 32 plus 8)

        Note: Loop start label
        Let loop_start_str be string_concat(".L", integer_to_string(loop_start_label))
        Let loop_start_label_line be string_concat(loop_start_str, ":")
        emit_line(output_file, loop_start_label_line)

        Note: Compare counter with length
        emit_line(output_file, "    movq (%rsp), %rax")       Note: Load counter
        emit_line(output_file, "    movq 8(%rsp), %rcx")      Note: Load length
        emit_line(output_file, "    cmpq %rcx, %rax")
        Let jge_instruction be string_concat("    jge .L", integer_to_string(loop_end_label))
        emit_line(output_file, jge_instruction)

        Note: Get item at current index: list_get(collection, counter)
        emit_line(output_file, "    movq 16(%rsp), %rdi")     Note: Load collection pointer
        emit_line(output_file, "    movq (%rsp), %rsi")       Note: Load counter as index
        emit_line(output_file, "    call list_get")

        Note: Store item in loop variable
        file_write_buffered(output_file, "    movq %rax, -", 0)
        file_write_buffered(output_file, integer_to_string(var_offset), 0)
        file_write_buffered(output_file, "(%rbp)\n", 0)

        Note: Generate loop body
        Let i be 0
        While i is less than body_count:
            Let body_stmt be memory_get_pointer(body, i multiplied by 8)
            codegen_generate_statement(codegen, body_stmt)
            Set i to i plus 1
        End While

        Note: Increment counter
        emit_line(output_file, "    movq (%rsp), %rax")
        emit_line(output_file, "    addq $1, %rax")
        emit_line(output_file, "    movq %rax, (%rsp)")

        Note: Jump back to loop start
        Let jmp_instruction be string_concat("    jmp .L", integer_to_string(loop_start_label))
        emit_line(output_file, jmp_instruction)

        Note: Loop end label
        Let loop_end_str be string_concat(".L", integer_to_string(loop_end_label))
        Let loop_end_label_line be string_concat(loop_end_str, ":")
        emit_line(output_file, loop_end_label_line)

        Note: Clean up stack (counter, length, collection)
        emit_line(output_file, "    addq $24, %rsp")

        Return 0
    End If

    If stmt_type is equal to 3:  Note: STMT_RETURN
        Note: Generate expression (result in %rax)
        Let return_expr be memory_get_pointer(stmt, 8)  Note: stmt->data.return_stmt.expression - use pointer
        codegen_generate_expression(codegen, return_expr)

        Note: Function epilogue
        file_write_buffered(output_file, "    movq %rbp, %rsp\n", 0)
        file_write_buffered(output_file, "    popq %rbp\n", 0)
        file_write_buffered(output_file, "    ret\n", 0)
        Return 0
    End If

    If stmt_type is equal to 5:  Note: STMT_IF
        Let label_counter be memory_get_int32(codegen, 28)  Note: codegen->label_counter (int)
        Let label_num be label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)  Note: codegen->label_counter++ (int)

        Let else_label be label_num multiplied by 10 plus 1
        Let end_label be label_num multiplied by 10 plus 2

        Note: Generate condition (result in %rax)
        Let condition_expr be memory_get_pointer(stmt, 8)  Note: stmt->data.if_stmt.condition - use pointer
        codegen_generate_expression(codegen, condition_expr)

        Note: Test if condition is false (0)
        emit_line(output_file, "    testq %rax, %rax")
        Let jz_instruction be string_concat("    jz .L", integer_to_string(else_label))
        emit_line(output_file, jz_instruction)

        Note: Generate if body
        Let if_body be memory_get_pointer(stmt, 16)  Note: stmt->data.if_stmt.if_body
        Let if_body_count be memory_get_int32(stmt, 24)  Note: stmt->data.if_stmt.if_body_count
        Let ifbody_i be 0
        While ifbody_i is less than if_body_count:
            Let ifbody_stmt be memory_get_pointer(if_body, ifbody_i multiplied by 8)
            codegen_generate_statement(codegen, ifbody_stmt)
            Let ifbody_i be ifbody_i plus 1
        End While

        file_write_buffered(output_file, "    jmp .L", 0)
        file_write_buffered(output_file, integer_to_string(end_label), 0)
        file_write_buffered(output_file, "\n", 0)

        Note: Generate else body
        Let else_label_str be string_concat(".L", integer_to_string(else_label))
        Let else_label_line be string_concat(else_label_str, ":")
        emit_line(output_file, else_label_line)
        deallocate(else_label_str)
        deallocate(else_label_line)

        Let else_body be memory_get_pointer(stmt, 32)  Note: stmt->data.if_stmt.else_body
        Let else_body_count be memory_get_int32(stmt, 40)  Note: stmt->data.if_stmt.else_body_count
        Let elsebody_i be 0
        While elsebody_i is less than else_body_count:
            Let elsebody_stmt be memory_get_pointer(else_body, elsebody_i multiplied by 8)
            codegen_generate_statement(codegen, elsebody_stmt)
            Let elsebody_i be elsebody_i plus 1
        End While

        Let end_label_str be string_concat(".L", integer_to_string(end_label))
        Let end_label_line be string_concat(end_label_str, ":")
        emit_line(output_file, end_label_line)
        deallocate(end_label_str)
        deallocate(end_label_line)
        Return 0
    End If

    If stmt_type is equal to 6:  Note: STMT_WHILE
        Let label_counter be memory_get_int32(codegen, 28)  Note: codegen->label_counter (int)
        Note: Try to use it without printing to see if it works
        If label_counter is greater than 1000000:
        End If
        Let label_num be label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)  Note: codegen->label_counter++ (int)

        Let loop_start be label_num multiplied by 10 plus 1
        Let loop_end be label_num multiplied by 10 plus 2

        Note: Push loop context for break/continue statements
        codegen_push_loop_context(codegen, loop_start, loop_end)

        Note: Loop start label
        file_write_buffered(output_file, ".L", 0)
        Let loop_start_str be integer_to_string(loop_start)
        file_write_buffered(output_file, loop_start_str, 0)
        file_write_buffered(output_file, ":", 0)

        Note: Generate condition (result in %rax)
        Let condition_expr be memory_get_pointer(stmt, 8)  Note: stmt->data.while_stmt.condition
        codegen_generate_expression(codegen, condition_expr)

        Note: Test if condition is false (0)
        emit_line(output_file, "    testq %rax, %rax")
        Let jz_instruction be string_concat("    jz .L", integer_to_string(loop_end))
        emit_line(output_file, jz_instruction)

        Note: Generate loop body
        Let whilebody be memory_get_pointer(stmt, 16)  Note: stmt->data.while_stmt.body
        Let whilebody_count be memory_get_int32(stmt, 24)  Note: stmt->data.while_stmt.body_count
        Let whilebody_i be 0
        While whilebody_i is less than whilebody_count:
            Let whilebody_stmt be memory_get_pointer(whilebody, whilebody_i multiplied by 8)
            codegen_generate_statement(codegen, whilebody_stmt)
            Let whilebody_i be whilebody_i plus 1
        End While

        Note: Jump back to loop start
        file_write_buffered(output_file, "    jmp .L", 0)
        file_write_buffered(output_file, integer_to_string(loop_start), 0)
        file_write_buffered(output_file, "\n", 0)

        Note: Loop end label
        Let loop_end_str be string_concat(".L", integer_to_string(loop_end))
        Let loop_end_line be string_concat(loop_end_str, ":")
        emit_line(output_file, loop_end_line)
        deallocate(loop_end_str)
        deallocate(loop_end_line)

        Note: Pop loop context
        codegen_pop_loop_context(codegen)
        Return 0
    End If

    If stmt_type is equal to 9:  Note: STMT_BREAK
        Let loop_ctx be codegen_current_loop_context(codegen)
        If loop_ctx is not equal to 0:
            Let break_label be memory_get_int32(loop_ctx, 8)  Note: loop_ctx->break_label
            file_write_buffered(output_file, "    jmp .L", 0)
            file_write_buffered(output_file, integer_to_string(break_label), 0)
            file_write_buffered(output_file, "\n", 0)
        Otherwise:
            exit_with_code(1)
        End If
        Return 0
    End If

    If stmt_type is equal to 10:  Note: STMT_CONTINUE
        Let loop_ctx be codegen_current_loop_context(codegen)
        If loop_ctx is not equal to 0:
            Let continue_label be memory_get_int32(loop_ctx, 0)  Note: loop_ctx->continue_label
            file_write_buffered(output_file, "    jmp .L", 0)
            file_write_buffered(output_file, integer_to_string(continue_label), 0)
            file_write_buffered(output_file, "\n", 0)
        Otherwise:
            exit_with_code(1)
        End If
        Return 0
    End If

    Note: Inline assembly: emit raw assembly text
    If stmt_type is equal to 16:  Note: STMT_INLINE_ASSEMBLY
        Note: Get raw assembly text (single string, not array)
        Let raw_text be memory_get_pointer(stmt, 8)
        Let text_length be memory_get_int32(stmt, 16)

        Note: Write raw text directly to output, character by character
        Note: Add 4-space indentation to each line for proper assembly formatting
        Let char_idx be 0
        Let at_line_start be 1  Note: Track if we're at the start of a line

        While char_idx is less than text_length:
            Let current_char be string_char_at(raw_text, char_idx)
            Let newline be 10  Note: ASCII for '\n'

            Note: Add indentation at start of each line
            If at_line_start is equal to 1:
                Note: Check if line is not empty (not just newline)
                If current_char is not equal to newline:
                    file_write_buffered(output_file, "    ", 0)
                End If
                Set at_line_start to 0
            End If

            Note: Write character
            Let char_str_len be 2
            Let char_str be memory_allocate(char_str_len)
            memory_set_byte(char_str, 0, current_char)
            memory_set_byte(char_str, 1, 0)  Note: null terminator
            file_write_buffered(output_file, char_str, 0)
            deallocate(char_str)

            Note: Track newlines for indentation
            If current_char is equal to newline:
                Set at_line_start to 1
            End If

            Set char_idx to char_idx plus 1
        End While

        Note: Ensure we end with a newline
        If at_line_start is equal to 0:
            file_write_buffered(output_file, "\n", 0)
        End If

        Return 0
    End If

    If stmt_type is equal to 4:  Note: STMT_PRINT
        Note: Generate expression (result in %rax)
        Let print_expr be memory_get_pointer(stmt, 8)  Note: stmt->data.print_stmt.expression
        codegen_generate_expression(codegen, print_expr)

        Note: Call appropriate print function based on expression type
        Let expr_type be memory_get_int32(print_expr, 0)  Note: expr->type
        If expr_type is equal to 5:  Note: EXPR_STRING_LITERAL
            Note: String literal - call print_string
            file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
            file_write_buffered(output_file, "    call print_string\n", 0)
        Otherwise:
            If expr_type is equal to 8:  Note: EXPR_BUILTIN_CALL
                Let builtin_call_ptr be print_expr plus 8  Note: &expr->data.builtin_call
                Let builtin_type be memory_get_int32(builtin_call_ptr, 0)  Note: builtin_call.builtin_type
                Note: Check for string-returning builtins (read_file, string_substring, string_concat, integer_to_string, string_replace, string_trim)
                Let is_string_builtin be 0
                If builtin_type is equal to 37:
                    Let is_string_builtin be 1
                Otherwise If builtin_type is equal to 42:
                    Let is_string_builtin be 1
                Otherwise If builtin_type is equal to 48:
                    Let is_string_builtin be 1
                Otherwise If builtin_type is equal to 49:
                    Let is_string_builtin be 1
                Otherwise If builtin_type is equal to 52:
                    Let is_string_builtin be 1
                Otherwise If builtin_type is equal to 54:
                    Let is_string_builtin be 1
                End If
                If is_string_builtin is equal to 1:
                    Note: These functions return strings - call print_string
                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                    file_write_buffered(output_file, "    call print_string\n", 0)
                Otherwise:
                    Note: Integer expression - call print_integer
                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                    file_write_buffered(output_file, "    call print_integer\n", 0)
                End If
            Otherwise:
                If expr_type is equal to 1:  Note: EXPR_VARIABLE
                    Note: Check variable type to determine appropriate print function
                    Let variable_name be memory_get_pointer(print_expr, 8)  Note: expr->data.variable_name
                    Let var_index be codegen_find_variable(codegen, variable_name)
                    If var_index is greater than or equal to 0:
                        Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
                        Let type_name be memory_get_pointer(variables, var_index multiplied by 32 plus 16)  Note: variables[var_index].type_name
                        If type_name is not equal to 0:
                            If string_equals(type_name, "String") is equal to 1:
                                Note: This variable contains a string - call print_string
                                file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                                file_write_buffered(output_file, "    call print_string\n", 0)
                            Otherwise:
                                If string_equals(type_name, "List") is equal to 1:
                                    Note: This variable contains a list pointer - print as integer address
                                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                                    file_write_buffered(output_file, "    call print_integer\n", 0)
                                Otherwise:
                                    Note: Assume integer for other variables
                                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                                    file_write_buffered(output_file, "    call print_integer\n", 0)
                                End If
                            End If
                        Otherwise:
                            Note: Assume integer for untyped variables
                            file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                            file_write_buffered(output_file, "    call print_integer\n", 0)
                        End If
                    Otherwise:
                        Note: Variable not found, assume integer
                        file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                        file_write_buffered(output_file, "    call print_integer\n", 0)
                    End If
                Otherwise:
                    Note: Integer expression (literal, arithmetic) - call print_integer
                    file_write_buffered(output_file, "    movq %rax, %rdi\n", 0)
                    file_write_buffered(output_file, "    call print_integer\n", 0)
                End If
            End If
        End If
        Return 0
    End If

    If stmt_type is equal to 7:  Note: STMT_EXPRESSION
        Note: Generate the expression and ignore its result
        Let expr_stmt_expr be memory_get_pointer(stmt, 8)  Note: stmt->data.expr_stmt.expression
        codegen_generate_expression(codegen, expr_stmt_expr)
        Return 0
    End If

    If stmt_type is equal to 13:  Note: STMT_IMPORT
        Note: Imports are handled at program level, no code generation needed
        Return 0
    End If

    If stmt_type is equal to 8:  Note: STMT_MATCH
        Note: Generate code for Match statement with literal patterns
        Note: Evaluate match expression once and store in temp
        Let match_expr be memory_get_pointer(stmt, 8)  Note: STMT_MATCH_EXPR
        codegen_generate_expression(codegen, match_expr)
        file_write_buffered(output_file, "    pushq %rax  # Save match value\n", 0)

        Note: Get unique label for end of match
        Let label_counter be memory_get_int32(codegen, 28)
        Let match_id be label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)

        Note: Get when clauses
        Let when_clauses be memory_get_pointer(stmt, 16)  Note: STMT_MATCH_WHEN_CLAUSES
        Let when_count be memory_get_int32(stmt, 24)  Note: STMT_MATCH_WHEN_COUNT

        Note: Generate if-else chain for each When clause
        Let i be 0
        While i is less than when_count:
            Note: Get when clause data (48 bytes per clause)
            Let clause_offset be i multiplied by 48
            Let clause_ptr be when_clauses plus clause_offset
            Let pattern_type be memory_get_int32(clause_ptr, 0)
            Let pattern_value be memory_get_pointer(clause_ptr, 8)
            Let field_bindings be memory_get_pointer(clause_ptr, 16)
            Let field_count be memory_get_int32(clause_ptr, 24)
            Let body_stmts be memory_get_pointer(clause_ptr, 32)
            Let body_count be memory_get_integer(clause_ptr, 40)

            Note: Generate label for this case
            file_write_buffered(output_file, ".match_", 0)
            file_write_buffered(output_file, integer_to_string(match_id), 0)
            file_write_buffered(output_file, "_case_", 0)
            file_write_buffered(output_file, integer_to_string(i), 0)
            file_write_buffered(output_file, ":\n", 0)

            Note: Handle pattern based on type
            If pattern_type is equal to 2:  Note: PATTERN_WILDCARD
                Note: Wildcard always matches - no comparison needed
                Note: Just fall through to execute the body
            Otherwise If pattern_type is equal to 3:  Note: PATTERN_TYPE
                Note: Type pattern - check if value matches the specified type
                Note: pattern_value contains the type name string
                Let type_name_to_check be pattern_value

                Note: Pop match value for type checking
                file_write_buffered(output_file, "    popq %rax  # Get match value\n", 0)
                file_write_buffered(output_file, "    pushq %rax  # Keep for next comparison\n", 0)

                Note: Check if type is a primitive (Integer, Byte, etc.)
                If string_equals(type_name_to_check, "Integer") is equal to 1:
                    Note: For Integer type: check if value is small (not a pointer)
                    Note: Assume pointers are > 0x1000, integers are small values
                    file_write_buffered(output_file, "    movq $4096, %rbx  # Pointer threshold\n", 0)
                    file_write_buffered(output_file, "    cmpq %rbx, %rax  # Compare value with threshold\n", 0)
                    Note: If value >= threshold, it's a pointer (not Integer) - jump to next case
                    Let next_case be i plus 1
                    If next_case is less than when_count:
                        file_write_buffered(output_file, "    jge .match_", 0)
                        file_write_buffered(output_file, integer_to_string(match_id), 0)
                        file_write_buffered(output_file, "_case_", 0)
                        file_write_buffered(output_file, integer_to_string(next_case), 0)
                        file_write_buffered(output_file, "  # Not Integer, try next case\n", 0)
                    Otherwise:
                        file_write_buffered(output_file, "    jge .match_", 0)
                        file_write_buffered(output_file, integer_to_string(match_id), 0)
                        file_write_buffered(output_file, "_end  # Not Integer, no match\n", 0)
                    End If
                Otherwise:
                    Note: For named types (variants/structs): check if it's a valid pointer
                    Note: This is a simplified check - just verify it's a pointer-like value
                    file_write_buffered(output_file, "    movq $4096, %rbx  # Pointer threshold\n", 0)
                    file_write_buffered(output_file, "    cmpq %rbx, %rax  # Check if pointer-like\n", 0)
                    Note: If value < threshold, it's not a pointer (not this type) - jump to next case
                    Let next_case be i plus 1
                    If next_case is less than when_count:
                        file_write_buffered(output_file, "    jl .match_", 0)
                        file_write_buffered(output_file, integer_to_string(match_id), 0)
                        file_write_buffered(output_file, "_case_", 0)
                        file_write_buffered(output_file, integer_to_string(next_case), 0)
                        file_write_buffered(output_file, "  # Not pointer type, try next case\n", 0)
                    Otherwise:
                        file_write_buffered(output_file, "    jl .match_", 0)
                        file_write_buffered(output_file, integer_to_string(match_id), 0)
                        file_write_buffered(output_file, "_end  # Not pointer type, no match\n", 0)
                    End If
                End If
            Otherwise If pattern_type is equal to 0:  Note: PATTERN_LITERAL
                Note: Pop match value and compare with pattern
                file_write_buffered(output_file, "    popq %rax  # Get match value\n", 0)
                file_write_buffered(output_file, "    pushq %rax  # Keep for next comparison\n", 0)

                Note: Generate pattern expression
                codegen_generate_expression(codegen, pattern_value)

                Note: Compare: match value in stack, pattern value in %rax
                file_write_buffered(output_file, "    movq %rax, %rbx  # Pattern value to %rbx\n", 0)
                file_write_buffered(output_file, "    movq (%rsp), %rax  # Match value to %rax\n", 0)
                file_write_buffered(output_file, "    cmpq %rbx, %rax  # Compare\n", 0)
            Otherwise:  Note: PATTERN_VARIANT
                Note: Variant pattern matching
                Note: pattern_value is the variant name string
                Note: field_bindings is array of binding variable names
                Note: field_count is number of fields to extract

                Note: Get variant tag for this pattern
                Let variant_name be pattern_value
                Let variant_tag_to_match be 0
                Let variant_field_count be 0

                Note: Look up variant in program's type definitions
                Let current_program be memory_get_pointer(codegen, 48)
                Let type_count be memory_get_int32(current_program, 24)
                Let types be memory_get_pointer(current_program, 16)

                Let found_variant be 0
                Let vi be 0
                While vi is less than type_count:
                    Let type_ptr be memory_get_pointer_at_index(types, vi)
                    Let type_kind be memory_get_int32(type_ptr, 8)

                    Note: Check if this is a variant type (TYPE_KIND_VARIANT = 1)
                    If type_kind is equal to 1:
                        Let variant_count be memory_get_int32(type_ptr, 24)
                        Let variants be memory_get_pointer(type_ptr, 16)

                        Note: Loop through all variants to find match
                        Let vj be 0
                        While vj is less than variant_count:
                            Let variant_offset be vj multiplied by 32
                            Let variant_ptr be variants plus variant_offset
                            Let vname be memory_get_pointer(variant_ptr, 0)

                            If string_equals(vname, variant_name) is equal to 1:
                                Set variant_tag_to_match to memory_get_int32(variant_ptr, 20)
                                Set variant_field_count to memory_get_int32(variant_ptr, 16)
                                Set found_variant to 1
                                Set vi to type_count  Note: Break outer loop
                                Set vj to variant_count  Note: Break inner loop
                            Otherwise:
                                Set vj to vj plus 1
                            End If
                        End While
                    End If
                    Set vi to vi plus 1
                End While

                Note: Generate tag comparison
                file_write_buffered(output_file, "    movq (%rsp), %rax  # Get match value pointer\n", 0)
                file_write_buffered(output_file, "    movl (%rax), %ebx  # Load variant tag\n", 0)
                file_write_buffered(output_file, "    cmpl $", 0)
                file_write_buffered(output_file, integer_to_string(variant_tag_to_match), 0)
                file_write_buffered(output_file, ", %ebx  # Compare with expected tag\n", 0)
            End If

            Note: Jump to next case if not equal (unless wildcard or type pattern)
            If pattern_type is not equal to 2:  Note: Not wildcard
                If pattern_type is not equal to 3:  Note: Not type pattern - generate conditional jump
                    Let next_case be i plus 1
                    If next_case is less than when_count:
                        file_write_buffered(output_file, "    jne .match_", 0)
                        file_write_buffered(output_file, integer_to_string(match_id), 0)
                        file_write_buffered(output_file, "_case_", 0)
                        file_write_buffered(output_file, integer_to_string(next_case), 0)
                        file_write_buffered(output_file, "  # Try next case\n", 0)
                    Otherwise:
                        file_write_buffered(output_file, "    jne .match_", 0)
                        file_write_buffered(output_file, integer_to_string(match_id), 0)
                        file_write_buffered(output_file, "_end  # No match\n", 0)
                    End If
                End If
            End If

            Note: Generate body if matched
            Note: Handle field extraction for variant patterns
            If pattern_type is equal to 0:  Note: PATTERN_LITERAL
                file_write_buffered(output_file, "    popq %rax  # Matched, clean up stack\n", 0)
            Otherwise If pattern_type is equal to 2:  Note: PATTERN_WILDCARD
                file_write_buffered(output_file, "    popq %rax  # Matched, clean up stack\n", 0)
            Otherwise If pattern_type is equal to 3:  Note: PATTERN_TYPE
                file_write_buffered(output_file, "    popq %rax  # Matched, clean up stack\n", 0)
            Otherwise:  Note: PATTERN_VARIANT
                Note: Extract fields and bind to variables
                file_write_buffered(output_file, "    popq %rax  # Get match value pointer\n", 0)

                Note: Extract each field
                Let fk be 0
                While fk is less than field_count:
                    Note: Get field binding name
                    Let binding_name be memory_get_pointer(field_bindings, fk multiplied by 8)

                    Note: Add variable for this binding
                    codegen_add_variable(codegen, binding_name)

                    Note: Find the variable to get its stack offset
                    Let var_index be codegen_find_variable(codegen, binding_name)
                    Let variables be memory_get_pointer(codegen, 8)
                    Let var_offset be memory_get_int32(variables, var_index multiplied by 32 plus 8)

                    Note: Load field from variant at offset 8 + (fk * 8)
                    Let field_offset be 8 plus fk multiplied by 8
                    file_write_buffered(output_file, "    movq ", 0)
                    file_write_buffered(output_file, integer_to_string(field_offset), 0)
                    file_write_buffered(output_file, "(%rax), %rbx  # Load field ", 0)
                    file_write_buffered(output_file, integer_to_string(fk), 0)
                    file_write_buffered(output_file, "\n", 0)

                    Note: Store field in local variable
                    file_write_buffered(output_file, "    movq %rbx, -", 0)
                    file_write_buffered(output_file, integer_to_string(var_offset), 0)
                    file_write_buffered(output_file, "(%rbp)  # Store in binding ", 0)
                    file_write_buffered(output_file, binding_name, 0)
                    file_write_buffered(output_file, "\n", 0)

                    Set fk to fk plus 1
                End While
            End If

            Note: Generate body statements
            Let j be 0
            While j is less than body_count:
                Let stmt_offset be j multiplied by 8
                Let body_stmt be memory_get_pointer(body_stmts, stmt_offset)
                codegen_generate_statement(codegen, body_stmt)
                Set j to j plus 1
            End While

            Note: Jump to end after body
            file_write_buffered(output_file, "    jmp .match_", 0)
            file_write_buffered(output_file, integer_to_string(match_id), 0)
            file_write_buffered(output_file, "_end\n", 0)

            Set i to i plus 1
        End While

        Note: End label
        file_write_buffered(output_file, ".match_", 0)
        file_write_buffered(output_file, integer_to_string(match_id), 0)
        file_write_buffered(output_file, "_end:\n", 0)
        file_write_buffered(output_file, "    addq $8, %rsp  # Clean up match value if still on stack\n", 0)

        Return 0
    End If

    If stmt_type is equal to 7:  Note: OLD_STMT_MATCH (unused)
        Note: Evaluate the expression to match on
        Let match_expr be memory_get_pointer(stmt, 8)  Note: stmt->data.match_stmt.expression
        codegen_generate_expression(codegen, match_expr)
        file_write_buffered(output_file, "    pushq %rax  # Save match expression value", 0)

        Note: Generate unique labels for each case and the end
        Let label_counter be memory_get_int32(codegen, 28)  Note: codegen->label_counter (int)
        Let match_id be label_counter
        memory_set_int32(codegen, 28, label_counter plus 1)  Note: codegen->label_counter++ (int)

        Let end_label be string_concat(".match_end_", integer_to_string(match_id))

        Note: Generate code for each case
        Let case_count be memory_get_int32(stmt, 16)  Note: stmt->data.match_stmt.case_count
        Let cases be memory_get_pointer(stmt, 24)  Note: stmt->data.match_stmt.cases

        Let i be 0
        While i is less than case_count:
            Let case_offset be i multiplied by 64
            Let match_case be cases plus case_offset  Note: sizeof(MatchCase) estimate
            Let variant_name be memory_get_pointer(match_case, 0)  Note: match_case->variant_name
            Let field_count be memory_get_int32(match_case, 8)  Note: match_case->field_count
            Let field_names be memory_get_pointer(match_case, 16)  Note: match_case->field_names
            Let body_count be memory_get_int32(match_case, 24)  Note: match_case->body_count
            Let body be memory_get_pointer(match_case, 32)  Note: match_case->body

            Let next_case_id be i plus 1

            Note: Check if this case matches - write label directly without string_concat
            file_write_buffered(output_file, ".match_case_", 0)
            file_write_buffered(output_file, integer_to_string(match_id), 0)
            file_write_buffered(output_file, "_", 0)
            file_write_buffered(output_file, integer_to_string(i), 0)
            file_write_buffered(output_file, ":", 0)
            file_write_buffered(output_file, "    popq %rax  # Get match expression\n", 0)
            file_write_buffered(output_file, "    pushq %rax  # Keep on stack", 0)

            Note: Load the tag from the variant
            file_write_buffered(output_file, "    movq (%rax), %rdx  # Load variant tag", 0)

            Note: Find the tag value for this variant name - ADT variant tags are sequential starting from 0
            file_write_buffered(output_file, "    cmpq $", 0)
            file_write_buffered(output_file, integer_to_string(i), 0)
            file_write_buffered(output_file, ", %rdx  # Check tag for ", 0)
            file_write_buffered(output_file, variant_name, 0)
            file_write_buffered(output_file, "\n", 0)

            If i is less than case_count minus 1:
                file_write_buffered(output_file, "    jne .match_case_", 0)
                file_write_buffered(output_file, integer_to_string(match_id), 0)
                file_write_buffered(output_file, "_", 0)
                file_write_buffered(output_file, integer_to_string(next_case_id), 0)
                file_write_buffered(output_file, "  # Jump to next case", 0)
            Otherwise:
                file_write_buffered(output_file, "    jne ", 0)
                file_write_buffered(output_file, end_label, 0)
                file_write_buffered(output_file, "  # No match, exit", 0)
            End If

            Note: If we matched, extract fields and bind to local variables
            If field_count is greater than 0:
                Note: Pop the variant pointer
                file_write_buffered(output_file, "    popq %rax  # Get variant pointer\n", 0)
                file_write_buffered(output_file, "    pushq %rax  # Keep on stack", 0)

                Note: ADT fields start at offset 8 (after tag) with 8 bytes per field
                Let j be 0
                While j is less than field_count:
                    Let field_offset_value be j multiplied by 8
                    Let field_offset be 8 plus field_offset_value
                    file_write_buffered(output_file, "    movq ", 0)
                    file_write_buffered(output_file, integer_to_string(field_offset), 0)
                    file_write_buffered(output_file, "(%rax), %rdx  # Load field ", 0)
                    file_write_buffered(output_file, integer_to_string(j), 0)
                    file_write_buffered(output_file, "\n", 0)

                    Note: Create a local variable for the binding - allocate stack space properly
                    Let current_stack_offset be memory_get_int32(codegen, 24)  Note: codegen->stack_offset
                    Let new_stack_offset be current_stack_offset plus 8
                    memory_set_integer(codegen, 16, new_stack_offset)

                    file_write_buffered(output_file, "    movq %rdx, -", 0)
                    file_write_buffered(output_file, integer_to_string(new_stack_offset), 0)
                    Let field_name be memory_get_pointer(field_names, j multiplied by 8)
                    file_write_buffered(output_file, "(%rbp, 0)  # Store ", 0)
                    file_write_buffered(output_file, field_name, 0)
                    file_write_buffered(output_file, " at stack offset", 0)

                    Note: Add the binding to the variable table with correct offset
                    Let variable_count be memory_get_int32(codegen, 16)  Note: codegen->variable_count (int)
                    Let variable_capacity be memory_get_int32(codegen, 24)  Note: codegen->variable_capacity
                    If variable_count is greater than or equal to variable_capacity:
                        Let new_capacity be variable_capacity multiplied by 2
                        memory_set_integer(codegen, 24, new_capacity)
                        Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
                        Let new_variables be reallocate(variables, new_capacity multiplied by 32)  Note: sizeof(Variable) = 32
                        memory_set_pointer(codegen, 8, new_variables)
                    End If

                    Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
                    Let var_idx_offset be variable_count multiplied by 32  Note: sizeof(Variable) = 32
                    memory_set_pointer(variables, var_idx_offset, string_duplicate(field_name))  Note: name
                    memory_set_integer(variables, var_idx_offset plus 8, new_stack_offset)  Note: stack_offset
                    memory_set_pointer(variables, var_idx_offset plus 16, string_duplicate("Integer"))  Note: type_name
                    memory_set_int32(codegen, 12, variable_count plus 1)  Note: Increment variable_count

                    Let j be j plus 1
                End While
            End If

            Note: Generate the case body
            Let k be 0
            While k is less than body_count:
                Let current_stmt be memory_get_pointer(body, k multiplied by 8)
                codegen_generate_statement(codegen, current_stmt)
                Let k be k plus 1
            End While

            Note: Clean up bindings from variable table but keep stack offset
            If field_count is greater than 0:
                Note: Free the variable names we allocated
                Let j be 0
                While j is less than field_count:
                    Let variable_count be memory_get_int32(codegen, 16)  Note: codegen->variable_count (int)
                    Let var_idx be variable_count minus field_count plus j
                    Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
                    Let var_name be memory_get_integer(variables, var_idx multiplied by 24)
                    Let var_type_name be memory_get_integer(variables, var_idx multiplied by 24 plus 16)
                    deallocate(var_name)
                    deallocate(var_type_name)
                    Let j be j plus 1
                End While
                Note: Remove from variable table
                Let variable_count be memory_get_int32(codegen, 16)  Note: codegen->variable_count (int)
                memory_set_integer(codegen, 12, variable_count minus field_count)
            End If

            Note: Jump to end
            file_write_buffered(output_file, "    jmp ", 0)
            file_write_buffered(output_file, end_label, 0)
            file_write_buffered(output_file, "\n", 0)

            Let i be i plus 1
        End While

        file_write_buffered(output_file, end_label, 0)
        file_write_buffered(output_file, ":", 0)
        file_write_buffered(output_file, "    popq %rax  # Clean up match expression\n", 0)
        Return 0
    End If

    Return 0
End Process

Note: Create a new code generator - equivalent to codegen_create
Process called "codegen_create" takes output_filename as Integer returns Integer:
    Let codegen be allocate(80)  Note: sizeof(CodeGenerator) - includes var_hashtable at offset 72

    Note: Note: allocate() uses calloc() which already zeros the memory,
    Note: so no explicit initialization loop is needed

    Let output_file be file_open_buffered(output_filename, 1)  Note: 1 = write mode (O_WRONLY | O_CREAT | O_TRUNC)
    If output_file is less than 0:  Note: Negative indicates error
        Note: Failed to open output file
        deallocate(codegen)
        Return 0
    End If
    memory_set_integer(codegen, 0, output_file)  Note: codegen->output_file

    Let variables be allocate(16 multiplied by 32)  Note: 16 * sizeof(Variable) - Variable is 32 bytes
    memory_set_pointer(codegen, 8, variables)  Note: codegen->variables
    memory_set_int32(codegen, 16, 0)  Note: codegen->variable_count (int)
    memory_set_int32(codegen, 20, 16)  Note: codegen->variable_capacity (int) - Start with space for 16 variables


    memory_set_int32(codegen, 24, 0)  Note: codegen->stack_offset (int)
    memory_set_int32(codegen, 28, 0)  Note: codegen->label_counter (int)
    memory_set_int32(codegen, 40, 0)  Note: codegen->string_count (int)
    memory_set_int32(codegen, 44, 512)  Note: codegen->string_capacity (int) - Start with space for 512 strings

    Let strings be allocate(512 multiplied by 16)  Note: 512 * sizeof(StringLiteral)
    memory_set_pointer(codegen, 32, strings)  Note: codegen->strings (pointer with padding)
    memory_set_pointer(codegen, 48, 0)  Note: codegen->current_program (pointer with padding)
    memory_set_int32(codegen, 64, 0)  Note: codegen->loop_depth (int)
    memory_set_int32(codegen, 68, 8)  Note: codegen->loop_capacity (int) - Start with space for 8 nested loops

    Let loop_stack be allocate(8 multiplied by 16)  Note: 8 * sizeof(LoopContext)
    memory_set_pointer(codegen, 56, loop_stack)  Note: codegen->loop_stack (pointer)

    Note: Hash table will be created on first use (function pointers not available yet)
    memory_set_pointer(codegen, 72, 0)  Note: codegen->var_hashtable (initially NULL)

    If output_file is equal to 0:
        deallocate(variables)
        deallocate(strings)
        deallocate(loop_stack)
        deallocate(codegen)
        Return 0
    End If

    Return codegen
End Process

Note: Destroy a code generator - equivalent to codegen_destroy
Process called "codegen_destroy" takes codegen as Integer returns Integer:
    If codegen is not equal to 0:
        Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file
        If output_file is not equal to 0:
            file_close_fd(output_file)
        End If

        Note: Free variable names and type names
        Note: Read 32-bit variable_count correctly
        Let byte0 be memory_get_byte(codegen, 16)
        Let byte1 be memory_get_byte(codegen, 17)
        Let byte2 be memory_get_byte(codegen, 18)
        Let byte3 be memory_get_byte(codegen, 19)
        Let temp1 be byte1 multiplied by 256
        Let temp2 be byte2 multiplied by 65536
        Let temp3 be byte3 multiplied by 16777216
        Let variable_count be byte0 plus temp1 plus temp2 plus temp3

        Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
        If variables is not equal to 0:
            Let i be 0
            While i is less than variable_count:
                Let var_offset be i multiplied by 32  Note: sizeof(Variable) = 32
                Let var_ptr be variables plus var_offset
                Let var_name be memory_get_pointer(var_ptr, 0)  Note: Variable.name at offset 0
                Let var_type_name be memory_get_pointer(var_ptr, 16)  Note: Variable.type_name at offset 16
                If var_name is not equal to 0:
                    deallocate(var_name)
                End If
                If var_type_name is not equal to 0:
                    deallocate(var_type_name)
                End If
                Let i be i plus 1
            End While
        End If

        Note: Free string literal values and labels
        Note: Read 32-bit string_count correctly
        Let byte0 be memory_get_byte(codegen, 40)
        Let byte1 be memory_get_byte(codegen, 41)
        Let byte2 be memory_get_byte(codegen, 42)
        Let byte3 be memory_get_byte(codegen, 43)
        Let temp1 be byte1 multiplied by 256
        Let temp2 be byte2 multiplied by 65536
        Let temp3 be byte3 multiplied by 16777216
        Let string_count be byte0 plus temp1 plus temp2 plus temp3

        Let strings be memory_get_pointer(codegen, 32)  Note: codegen->strings (pointer with padding)
        If strings is not equal to 0:
            Let i be 0
            While i is less than string_count:
                Let str_offset be i multiplied by 16  Note: sizeof(StringLiteral) = 16
                Let str_ptr be strings plus str_offset
                Let str_value be memory_get_pointer(str_ptr, 0)  Note: StringLiteral.value at offset 0
                Let str_label be memory_get_pointer(str_ptr, 8)  Note: StringLiteral.label at offset 8
                If str_value is not equal to 0:
                    deallocate(str_value)
                End If
                If str_label is not equal to 0:
                    deallocate(str_label)
                End If
                Let i be i plus 1
            End While
        End If

        If variables is not equal to 0:
            deallocate(variables)
        End If
        If strings is not equal to 0:
            deallocate(strings)
        End If
        Let loop_stack be memory_get_pointer(codegen, 56)  Note: codegen->loop_stack (pointer)
        If loop_stack is not equal to 0:
            deallocate(loop_stack)
        End If
        Note: Destroy hash table
        Let var_hashtable be memory_get_pointer(codegen, 72)
        If var_hashtable is not equal to 0:
            hashtable_destroy(var_hashtable)
        End If
        deallocate(codegen)
    End If
    Return 0
End Process

Note: Push a new loop context for break/continue handling - equivalent to codegen_push_loop_context
Process called "codegen_push_loop_context" takes codegen as Integer, continue_label as Integer, break_label as Integer returns Integer:
    Let loop_depth be memory_get_int32(codegen, 64)  Note: codegen->loop_depth (int)
    Let loop_capacity be memory_get_int32(codegen, 68)  Note: codegen->loop_capacity (int)

    Note: Expand loop stack if necessary
    If loop_depth is greater than or equal to loop_capacity:
        Let new_capacity be loop_capacity multiplied by 2
        memory_set_int32(codegen, 68, new_capacity)  Note: codegen->loop_capacity (int)
        Let loop_stack be memory_get_pointer(codegen, 56)  Note: codegen->loop_stack (pointer)
        Let new_loop_stack be memory_reallocate(loop_stack, 16 multiplied by new_capacity)  Note: sizeof(LoopContext) * new_capacity
        memory_set_pointer(codegen, 56, new_loop_stack)  Note: codegen->loop_stack (pointer)
    End If

    Let loop_stack be memory_get_pointer(codegen, 56)  Note: codegen->loop_stack
    Let context_offset be loop_depth multiplied by 16  Note: sizeof(LoopContext)
    memory_set_integer(loop_stack, context_offset, continue_label)  Note: continue_label
    memory_set_integer(loop_stack, context_offset plus 8, break_label)  Note: break_label
    memory_set_int32(codegen, 64, loop_depth plus 1)  Note: Increment loop_depth (int)
    Return 0
End Process

Note: Pop the current loop context - equivalent to codegen_pop_loop_context
Process called "codegen_pop_loop_context" takes codegen as Integer returns Integer:
    Let loop_depth be memory_get_int32(codegen, 64)  Note: codegen->loop_depth (int)
    If loop_depth is greater than 0:
        memory_set_int32(codegen, 64, loop_depth minus 1)  Note: codegen->loop_depth (int)
    End If
    Return 0
End Process

Note: Get the current loop context - equivalent to codegen_current_loop_context
Process called "codegen_current_loop_context" takes codegen as Integer returns Integer:
    Let loop_depth be memory_get_int32(codegen, 64)  Note: codegen->loop_depth (int)
    If loop_depth is greater than 0:
        Let loop_stack be memory_get_pointer(codegen, 56)  Note: codegen->loop_stack (pointer)
        Let loop_index be loop_depth minus 1
        Let context_offset be loop_index multiplied by 16  Note: sizeof(LoopContext)
        Return loop_stack plus context_offset
    End If
    Return 0  Note: NULL
End Process

Note: Generate code for a function - equivalent to codegen_generate_function
Process called "codegen_generate_function" takes codegen as Integer, func as Integer returns Integer:
    Note: Reset variable state for each function
    memory_set_int32(codegen, 16, 0)  Note: codegen->variable_count = 0
    memory_set_int32(codegen, 24, 0)  Note: codegen->stack_offset = 0
    memory_set_int32(codegen, 64, 0)  Note: codegen->loop_depth = 0 (int)

    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file
    Let func_name be memory_get_pointer(func, 0)  Note: func->name

    Note: Export function as global symbol for cross-module linking
    file_write_buffered(output_file, ".globl ", 0)
    file_write_buffered(output_file, func_name, 0)
    file_write_buffered(output_file, "\n", 0)

    Note: Function label
    file_write_buffered(output_file, func_name, 0)
    file_write_buffered(output_file, ":\n", 0)

    Note: Function prologue
    emit_line(output_file, "    pushq %rbp")
    emit_line(output_file, "    movq %rsp, %rbp")

    Note: Handle parameters (System V ABI: %rdi, %rsi, %rdx, %rcx, %r8, %r9)
    Let param_registers be allocate(6 multiplied by 8)  Note: Array of 6 string pointers
    memory_set_pointer(param_registers, 0, "%rdi")
    memory_set_pointer(param_registers, 8, "%rsi")
    memory_set_pointer(param_registers, 16, "%rdx")
    memory_set_pointer(param_registers, 24, "%rcx")
    memory_set_pointer(param_registers, 32, "%r8")
    memory_set_pointer(param_registers, 40, "%r9")
    Let max_register_params be 6

    Let parameter_count be memory_get_int32(func, 16)  Note: func->parameter_count

    Note: If this is main function with argc/argv parameters, initialize command line args
    If string_equals(func_name, "main") is equal to 1:
        If parameter_count is greater than or equal to 2:
            Note: Store original argc and argv before processing them as Runa parameters
            emit_line(output_file, "    # Initialize command line arguments")
            emit_line(output_file, "    pushq %rdi  # Save argc")
            emit_line(output_file, "    pushq %rsi  # Save argv")
            emit_line(output_file, "    call runtime_set_command_line_args@PLT")
            emit_line(output_file, "    popq %rsi   # Restore argv")
            emit_line(output_file, "    popq %rdi   # Restore argc")
        End If
    End If

    Note: CRITICAL FIX: Allocate stack space BEFORE any stack access to prevent Valgrind violations
    Note: Pre-allocate generous stack space for all function variables and temporaries
    Note: Increased from 512 to 2048 to handle parser functions with many locals
    emit_line(output_file, "    subq $2048, %rsp  # Pre-allocate generous stack space")

    Let parameters be memory_get_pointer(func, 8)  Note: func->parameters (Parameter*)
    Let i be 0
    Let should_continue be 1
    While should_continue is equal to 1:
        If i is greater than or equal to parameter_count:
            Let should_continue be 0
        End If
        If i is greater than or equal to max_register_params:
            Let should_continue be 0
        End If
        If should_continue is equal to 1:
        Note: Add parameter as a variable and store from appropriate register
        Note: Use the parameter type from the function definition
        Let param_offset be i multiplied by 16  Note: sizeof(Parameter)
        Let param_name be memory_get_pointer(parameters, param_offset)  Note: parameters[i].name
        Let param_type be memory_get_pointer(parameters, param_offset plus 8)  Note: parameters[i].type
        If param_type is equal to 0:
            Let param_type be "Integer"  Note: Default type
        End If

        Let param_index be codegen_add_variable_with_type_and_param_flag(codegen, param_name, param_type, 1)  Note: Mark as parameter
        Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
        Let var_offset be param_index multiplied by 32  Note: sizeof(Variable) = 32, not 24!
        Let var_ptr be variables plus var_offset
        Let param_stack_offset be memory_get_int32(var_ptr, 8)  Note: variables[param_index].stack_offset
        Let register_name be memory_get_pointer(param_registers, i multiplied by 8)
        file_write_buffered(output_file, "    movq ", 0)
        file_write_buffered(output_file, register_name, 0)
        file_write_buffered(output_file, ", -", 0)
        file_write_buffered(output_file, integer_to_string(param_stack_offset), 0)
        file_write_buffered(output_file, "(%rbp)\n", 0)

        Let i be i plus 1
        End If  Note: End of should_continue check
    End While

    Note: Handle parameters beyond 6 (passed on stack in System V ABI)
    Let i be max_register_params
    While i is less than parameter_count:
        Let param_offset be i multiplied by 16  Note: sizeof(Parameter)
        Let param_name be memory_get_pointer(parameters, param_offset)  Note: parameters[i].name
        Let param_type be memory_get_pointer(parameters, param_offset plus 8)  Note: parameters[i].type
        Let param_index be codegen_add_variable_with_type_and_param_flag(codegen, param_name, param_type, 1)  Note: Mark as parameter
        Let variables be memory_get_pointer(codegen, 8)  Note: codegen->variables
        Let var_offset be param_index multiplied by 32  Note: sizeof(Variable) = 32, not 24!
        Let var_ptr be variables plus var_offset
        Let param_stack_offset be memory_get_int32(var_ptr, 8)  Note: variables[param_index].stack_offset

        Note: Stack parameters are at positive offsets from rbp: 16(%rbp), 24(%rbp), etc.
        Let stack_param_index be i minus max_register_params
        Let stack_param_offset_value be stack_param_index multiplied by 8
        Let stack_param_offset be 16 plus stack_param_offset_value
        file_write_buffered(output_file, "    movq ", 0)
        file_write_buffered(output_file, integer_to_string(stack_param_offset), 0)
        file_write_buffered(output_file, "(%rbp), %rax\n", 0)
        file_write_buffered(output_file, "    movq %rax, -", 0)
        file_write_buffered(output_file, integer_to_string(param_stack_offset), 0)
        file_write_buffered(output_file, "(%rbp)", 0)

        Let i be i plus 1
    End While

    Note: Generate function body statements
    Note: Function structure has:
    Note: offset 24: return_type (string)
    Note: offset 32: statements (Statement** array)
    Note: offset 40: statement_count (int)
    Let statement_count be memory_get_int32(func, 40)  Note: func->statement_count
    Let statements be memory_get_pointer(func, 32)     Note: func->statements

    If statements is not equal to 0:
        Let stmt_idx be 0
        While stmt_idx is less than statement_count:
            Let stmt_offset be stmt_idx multiplied by 8
            Let stmt be memory_get_pointer(statements, stmt_offset)  Note: statements[stmt_idx]
            If stmt is not equal to 0:
                codegen_generate_statement(codegen, stmt)
            End If
            Let stmt_idx be stmt_idx plus 1
        End While
    End If

    Note: Add function epilogue ONLY if function doesn't end with explicit return
    Let needs_epilogue be 1
    If statement_count is greater than 0:
        Let last_stmt_offset be statement_count minus 1
        Set last_stmt_offset to last_stmt_offset multiplied by 8
        Let last_stmt be memory_get_pointer(statements, last_stmt_offset)
        If last_stmt is not equal to 0:
            Let last_stmt_type be memory_get_int32(last_stmt, 0)
            If last_stmt_type is equal to 3:  Note: STMT_RETURN
                Set needs_epilogue to 0
            End If
        End If
    End If

    If needs_epilogue is equal to 1:
        emit_line(output_file, "    movq %rbp, %rsp")
        emit_line(output_file, "    popq %rbp")
        emit_line(output_file, "    ret")
    End If

    deallocate(param_registers)
    Return 0
End Process

Note: Main code generation entry point - equivalent to codegen_generate
Process called "codegen_generate" takes codegen as Integer, program as Integer returns Integer:

    Note: Store program reference for type lookups
    memory_set_pointer(codegen, 48, program)  Note: codegen->current_program = program (pointer with padding)

    Let output_file be memory_get_integer(codegen, 0)  Note: codegen->output_file

    Note: Check if program is initialized properly
    Let import_count be memory_get_int32(program, 40)  Note: PROGRAM_IMPORT_COUNT - use int32 not integer
    Note: Instead check if it's a reasonable value first
    If import_count is equal to 0:
    Otherwise:
    End If

    Note: Safety check to prevent accessing invalid memory
    If import_count is less than 0:
        Let import_count be 0
    End If
    If import_count is greater than 1000:
        Let import_count be 0
    End If

    Note: Generate import comments (for documentation)
    If import_count is greater than 0:
        file_write_buffered(output_file, "# Imports:", 0)
        Let imports be memory_get_pointer(program, 32)  Note: PROGRAM_IMPORTS - should be pointer not integer
        Let i be 0
        While i is less than import_count:
            Let import be memory_get_pointer(imports, i multiplied by 8)
            Let import_filename be memory_get_integer(import, 0)  Note: import->filename
            Let module_name be memory_get_integer(import, 8)  Note: import->module_name
            file_write_buffered(output_file, "#   Import ", 0)
            file_write_buffered(output_file, import_filename, 0)
            file_write_buffered(output_file, " as ", 0)
            file_write_buffered(output_file, module_name, 0)
            file_write_buffered(output_file, "\n", 0)
            Let i be i plus 1
        End While
        file_write_buffered(output_file, "\n", 0)
    End If

    Note: First pass: collect all string literals by analyzing the AST
    Let function_count be memory_get_int32(program, 8)   Note: PROGRAM_FUNCTION_COUNT - use int32

    Note: Safety check: if function_count is negative or too large, assume no functions
    If function_count is less than 0:
        Let function_count be 0
    End If
    If function_count is greater than 10000:  Note: Sanity check
        Let function_count be 0
    End If

    Let functions be memory_get_pointer(program, 0)        Note: PROGRAM_FUNCTIONS - use pointer

    Note: Safety check - if functions is NULL, return error
    If functions is equal to 0:
        print_string("[ERROR] codegen_generate: functions pointer is NULL")
        Return 0
    End If

    Let i be 0
    While i is less than function_count:
        Let func be memory_get_pointer(functions, i multiplied by 8)



        Note: Safety check for function pointer - skip NULL pointers
        If func is not equal to 0:
                Note: Function structure in parser.runa has:
                Note: FUNCTION_STATEMENTS at 32 (Statement** - array of statements)
                Note: FUNCTION_STATEMENT_COUNT at 40

                Let func_name be memory_get_pointer(func, 0)  Note: func->name
                Let statements_array be memory_get_pointer(func, 32)  Note: func->statements (Statement**)

                Let statement_count be memory_get_int32(func, 40)  Note: func->statement_count

                Note: Process each statement in the function

                If statements_array is not equal to 0:
                    If statement_count is greater than 0:
                        Note: Process ALL statements in the function body

                        Let stmt_idx be 0
                        While stmt_idx is less than statement_count:

                            Note: Get the statement at index stmt_idx
                            Let stmt_offset be stmt_idx multiplied by 8  Note: pointer size
                            Let body_statement be memory_get_pointer(statements_array, stmt_offset)


                            Note: Process the statement
                            Let result be 0
                            If body_statement is not equal to 0:
                                Let result be codegen_collect_strings_from_statement(codegen, body_statement)

                                Note: Check if function reported critical error
                                If result is not equal to 0:
                                    Return 0
                                End If
                            End If

                            Note: Move to next statement
                            Let stmt_idx be stmt_idx plus 1
                        End While
                End If
            End If
        End If
        Let i be i plus 1
    End While

    Note: WORKAROUND removed - string collection is now working!

    Note: OLD orphaned code for rodata generation - REMOVED (now done in codegen main function)

    Note: Generate .data section for initialized global variables
    Let global_count be memory_get_int32(program, 56)  Note: PROGRAM_GLOBAL_COUNT - use int32
    Let globals be memory_get_pointer(program, 48)       Note: PROGRAM_GLOBAL_VARS - use pointer
    Let has_initialized_globals be 0
    Let i be 0
    While i is less than global_count:
        Let global be memory_get_pointer(globals, i multiplied by 8)
        Let initial_value be memory_get_pointer(global, 16)  Note: global->initial_value
        If initial_value is not equal to 0:
            Let has_initialized_globals be 1
            Let i be global_count  Note: Break
        End If
        Let i be i plus 1
    End While

    If has_initialized_globals is equal to 1:
        emit_line(output_file, ".section .data")
        Let i be 0
        While i is less than global_count:
            Let global be memory_get_pointer(globals, i multiplied by 8)
            Let global_name be memory_get_pointer(global, 0)  Note: global->name
            Let initial_value be memory_get_pointer(global, 16)  Note: global->initial_value
            If initial_value is not equal to 0:
                file_write_buffered(output_file, ".globl ", 0)
                file_write_buffered(output_file, global_name, 0)
                file_write_buffered(output_file, "\n", 0)
                file_write_buffered(output_file, global_name, 0)
                file_write_buffered(output_file, ":", 0)

                Note: Handle global variable initialization values
                Let expr_type be memory_get_int32(initial_value, 0)  Note: initial_value->type
                If expr_type is equal to 0:  Note: EXPR_INTEGER
                    Let integer_value be memory_get_pointer(initial_value, 8)  Note: initial_value->data.integer_value
                    file_write_buffered(output_file, "    .quad ", 0)
                    file_write_buffered(output_file, integer_to_string(integer_value), 0)
                    file_write_buffered(output_file, "\n", 0)
                Otherwise:
                    Note: Non-constant expressions default to zero initialization
                    file_write_buffered(output_file, "    .quad 0  # Non-constant initializer defaults to 0", 0)
                End If
            End If
            Let i be i plus 1
        End While
        file_write_buffered(output_file, "\n", 0)
    End If

    Note: Generate .bss section for uninitialized global variables
    Let has_uninitialized_globals be 0
    Let i be 0
    While i is less than global_count:
        Let global be memory_get_pointer(globals, i multiplied by 8)
        Let initial_value be memory_get_pointer(global, 16)  Note: global->initial_value
        If initial_value is equal to 0:
            Let has_uninitialized_globals be 1
            Let i be global_count  Note: Break
        End If
        Let i be i plus 1
    End While

    If has_uninitialized_globals is equal to 1:
        emit_line(output_file, ".section .bss")
        Let i be 0
        While i is less than global_count:
            Let global be memory_get_pointer(globals, i multiplied by 8)
            Let global_name be memory_get_pointer(global, 0)  Note: global->name
            Let initial_value be memory_get_pointer(global, 16)  Note: global->initial_value
            If initial_value is equal to 0:
                file_write_buffered(output_file, ".globl ", 0)
                file_write_buffered(output_file, global_name, 0)
                file_write_buffered(output_file, "\n", 0)
                file_write_buffered(output_file, global_name, 0)
                file_write_buffered(output_file, ":", 0)
                file_write_buffered(output_file, "    .zero 8  # 8 bytes for Integer", 0)
            End If
            Let i be i plus 1
        End While
        file_write_buffered(output_file, "\n", 0)
    End If

    Note: Generate .text section
    emit_line(output_file, ".text")

    Note: Add print_string runtime function
    emit_line(output_file, "print_string:")
    emit_line(output_file, "    pushq %rbp")
    emit_line(output_file, "    movq %rsp, %rbp")
    emit_line(output_file, "")
    emit_line(output_file, "    # Calculate string length")
    emit_line(output_file, "    movq %rdi, %rsi  # Save string pointer")
    emit_line(output_file, "    movq %rdi, %rcx  # Counter for strlen")
    emit_line(output_file, "    xorq %rax, %rax  # Length accumulator")
    emit_line(output_file, ".strlen_loop:")
    emit_line(output_file, "    cmpb $0, (%rcx)")
    emit_line(output_file, "    je .strlen_done")
    emit_line(output_file, "    incq %rcx")
    emit_line(output_file, "    incq %rax")
    emit_line(output_file, "    jmp .strlen_loop")
    emit_line(output_file, ".strlen_done:")
    emit_line(output_file, "")
    emit_line(output_file, "    # Call write syscall (sys_write = 1)")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    movq %rsi, %rsi   # buf = string pointer (already in rsi)")
    emit_line(output_file, "    movq %rax, %rdx   # count = string length")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    # Print newline")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    leaq .newline(%rip), %rsi  # newline string")
    emit_line(output_file, "    movq $1, %rdx     # count = 1")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    popq %rbp")
    emit_line(output_file, "    ret")
    emit_line(output_file, "\n")

    Note: Add print_integer runtime function
    emit_line(output_file, "print_integer:")
    emit_line(output_file, "    pushq %rbp")
    emit_line(output_file, "    movq %rsp, %rbp")
    emit_line(output_file, "    subq $32, %rsp  # Space for string buffer (20 digits + null)")
    emit_line(output_file, "")
    emit_line(output_file, "    # Convert integer to string")
    emit_line(output_file, "    movq %rdi, %rax  # integer value")
    emit_line(output_file, "    leaq -32(%rbp), %rsi  # buffer pointer")
    emit_line(output_file, "    addq $19, %rsi  # point to end of buffer (for reverse building)")
    emit_line(output_file, "    movb $0, (%rsi)  # null terminator")
    emit_line(output_file, "    decq %rsi")
    emit_line(output_file, "")
    emit_line(output_file, "    # Handle zero case")
    emit_line(output_file, "    testq %rax, %rax")
    emit_line(output_file, "    jnz .convert_loop")
    emit_line(output_file, "    movb $48, (%rsi)  # '0' character")
    emit_line(output_file, "    jmp .convert_done")
    emit_line(output_file, "")
    emit_line(output_file, ".convert_loop:")
    emit_line(output_file, "    testq %rax, %rax")
    emit_line(output_file, "    jz .convert_done")
    emit_line(output_file, "    movq %rax, %rcx")
    emit_line(output_file, "    movq $10, %rbx")
    emit_line(output_file, "    xorq %rdx, %rdx")
    emit_line(output_file, "    divq %rbx  # %rax = quotient, %rdx = remainder")
    emit_line(output_file, "    addq $48, %rdx  # convert remainder to ASCII")
    emit_line(output_file, "    movb %dl, (%rsi)  # store digit")
    emit_line(output_file, "    decq %rsi")
    emit_line(output_file, "    jmp .convert_loop")
    emit_line(output_file, "")
    emit_line(output_file, ".convert_done:")
    emit_line(output_file, "    incq %rsi  # point to first character")
    emit_line(output_file, "")
    emit_line(output_file, "    # Calculate string length")
    emit_line(output_file, "    movq %rsi, %rcx  # Counter for strlen")
    emit_line(output_file, "    xorq %rax, %rax  # Length accumulator")
    emit_line(output_file, ".int_strlen_loop:")
    emit_line(output_file, "    cmpb $0, (%rcx)")
    emit_line(output_file, "    je .int_strlen_done")
    emit_line(output_file, "    incq %rcx")
    emit_line(output_file, "    incq %rax")
    emit_line(output_file, "    jmp .int_strlen_loop")
    emit_line(output_file, ".int_strlen_done:")
    emit_line(output_file, "")
    emit_line(output_file, "    # Call write syscall (sys_write = 1)")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    # %rsi already points to string")
    emit_line(output_file, "    movq %rax, %rdx   # count = string length")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    # Print newline")
    emit_line(output_file, "    movq $1, %rdi     # fd = stdout")
    emit_line(output_file, "    leaq .newline(%rip), %rsi  # newline string")
    emit_line(output_file, "    movq $1, %rdx     # count = 1")
    emit_line(output_file, "    movq $1, %rax     # syscall number for write")
    emit_line(output_file, "    syscall")
    emit_line(output_file, "")
    emit_line(output_file, "    movq %rbp, %rsp")
    emit_line(output_file, "    popq %rbp")
    emit_line(output_file, "    ret")
    emit_line(output_file, "\n")
    emit_line(output_file, ".section .rodata")
    emit_line(output_file, ".newline:")
    Note: Output newline string literal using ASCII byte value
    emit_line(output_file, "    .byte 10  # newline character")

    Note: Output string literals from string table
    Let byte0 be memory_get_byte(codegen, 40)
    Let byte1 be memory_get_byte(codegen, 41)
    Let byte2 be memory_get_byte(codegen, 42)
    Let byte3 be memory_get_byte(codegen, 43)
    Let temp1 be byte1 multiplied by 256
    Let temp2 be byte2 multiplied by 65536
    Let temp3 be byte3 multiplied by 16777216
    Let string_count be byte0 plus temp1 plus temp2 plus temp3

    print_integer(string_count)

    If string_count is greater than 0:
        Let strings be memory_get_pointer(codegen, 32)
        Let i be 0
        While i is less than string_count:
            Let str_label be memory_get_pointer(strings, i multiplied by 16 plus 8)
            Let str_value be memory_get_pointer(strings, i multiplied by 16)
            file_write_buffered(output_file, str_label, 0)
            file_write_buffered(output_file, ":", 0)
            file_write_buffered(output_file, "    .string ", 0)
            Let quote_bytes be memory_allocate(2)
            memory_set_byte(quote_bytes, 0, 34)
            memory_set_byte(quote_bytes, 1, 0)
            file_write_buffered(output_file, quote_bytes, 0)
            file_write_buffered(output_file, str_value, 0)
            file_write_buffered(output_file, quote_bytes, 0)
            file_write_buffered(output_file, "\n", 0)
            deallocate(quote_bytes)
            Let i be i plus 1
        End While
    End If

    emit_line(output_file, ".text")

    Note: Generate all functions
    Let i be 0
    While i is less than function_count:
        Let func be memory_get_pointer(functions, i multiplied by 8)

        Note: Safety check for function pointer - skip NULL pointers
        If func is not equal to 0:
            Let func_name be memory_get_pointer(func, 0)  Note: func->name

            Note: Make main function global
            If string_equals(func_name, "main") is equal to 1:
                emit_line(output_file, ".globl main")
            End If

            emit_line(output_file, "\n")
            codegen_generate_function(codegen, func)
        End If
        Let i be i plus 1
    End While

    Note: Add a main function wrapper if no main function exists
    Let has_main be 0
    Let i be 0
    While i is less than function_count:
        Let func be memory_get_pointer(functions, i multiplied by 8)

        Note: Safety check for function pointer - skip NULL pointers
        If func is not equal to 0:
            Let func_name be memory_get_pointer(func, 0)  Note: func->name
            If string_equals(func_name, "main") is equal to 1:
                Let has_main be 1
                Let i be function_count  Note: Break
            End If
        End If
        Let i be i plus 1
    End While

    Note: Disable automatic main wrapper generation to allow modular compilation
    Note: Each module should define its own main() if needed
    Note: This prevents multiple main() definitions when linking modules
    Note: If has_main is equal to 0:
    Note:     Note: Wrapper generation disabled for library modules
    Note: End If

    Note: Add GNU stack note to prevent executable stack warning
    file_write_buffered(output_file, "\n", 0)
    Note: Output the GNU stack section
    emit_line(output_file, ".section .note.GNU-stack")

    Return 0
End Process
