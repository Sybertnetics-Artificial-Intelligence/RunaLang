Note: v0.2 x86-64 Assembly Code Generator
Note: Per specification Section 2.5

Import "parser" as Parser

Type called "CodeGenerator":
    output as String
    label_counter as Integer
    stack_offset as Integer
    variables as Dictionary[String, Integer] Note: Variable name to stack offset
    current_function as String
End Type

Process called "generate" that takes ast as Parser.ASTNode returns String:
    Let gen be a value of type CodeGenerator with
        output as "",
        label_counter as 0,
        stack_offset as 0,
        variables as a dictionary containing nothing,
        current_function as ""

    emit(gen, ".text")
    emit(gen, ".globl main")
    emit(gen, "")

    generate_node(gen, ast)

    Return gen.output
End Process

Process called "generate_node" that takes gen as CodeGenerator, node as Parser.ASTNode returns Nothing:
    If node.node_type is equal to Parser.Program:
        For Each child in node.children:
            generate_node(gen, child)
        End For

    Otherwise If node.node_type is equal to Parser.Function:
        generate_function(gen, node)

    Otherwise:
        Note: Skip other node types for now
    End If
End Process

Process called "generate_function" that takes gen as CodeGenerator, node as Parser.ASTNode returns Nothing:
    Let name be node.value
    Set gen.current_function to name
    emit(gen, name plus ":")

    Note: Function prologue
    emit(gen, "    push %rbp")
    emit(gen, "    mov %rsp, %rbp")

    Note: Allocate stack space for locals (simplified - fixed 256 bytes)
    emit(gen, "    sub $256, %rsp")

    Note: Generate function body
    For Each stmt in node.children:
        If is_list(stmt):
            For Each actual_stmt in stmt:
                generate_statement(gen, actual_stmt)
            End For
        Otherwise:
            generate_statement(gen, stmt)
        End If
    End For

    Note: Function epilogue
    emit(gen, ".L_return_" plus name plus ":")
    emit(gen, "    mov %rbp, %rsp")
    emit(gen, "    pop %rbp")
    emit(gen, "    ret")
    emit(gen, "")
End Process

Process called "generate_statement" that takes gen as CodeGenerator, stmt as Parser.ASTNode returns Nothing:
    If stmt.node_type is equal to Parser.Let:
        generate_let_statement(gen, stmt)

    Otherwise If stmt.node_type is equal to Parser.Set:
        generate_set_statement(gen, stmt)

    Otherwise If stmt.node_type is equal to Parser.Return:
        generate_return_statement(gen, stmt)

    Otherwise If stmt.node_type is equal to Parser.If:
        generate_if_statement(gen, stmt)

    Otherwise If stmt.node_type is equal to Parser.While:
        generate_while_statement(gen, stmt)

    Otherwise If stmt.node_type is equal to Parser.ForEach:
        generate_foreach_statement(gen, stmt)

    Otherwise If stmt.node_type is equal to Parser.Match:
        generate_match_statement(gen, stmt)

    Otherwise:
        generate_expression(gen, stmt)
    End If
End Process

Process called "generate_let_statement" that takes gen as CodeGenerator, stmt as Parser.ASTNode returns Nothing:
    Let var_name be stmt.value
    Let init_expr be stmt.children at index 0

    generate_expression(gen, init_expr)

    Note: Store result in variable
    Set gen.stack_offset to gen.stack_offset plus 8
    Set gen.variables at key var_name to gen.stack_offset
    emit(gen, "    mov %rax, -" plus int_to_string(gen.stack_offset) plus "(%rbp)")
End Process

Process called "generate_set_statement" that takes gen as CodeGenerator, stmt as Parser.ASTNode returns Nothing:
    Let var_name be stmt.value
    Let expr be stmt.children at index 0

    generate_expression(gen, expr)

    Note: Store in existing variable
    Let offset be gen.variables at key var_name
    emit(gen, "    mov %rax, -" plus int_to_string(offset) plus "(%rbp)")
End Process

Process called "generate_return_statement" that takes gen as CodeGenerator, stmt as Parser.ASTNode returns Nothing:
    Let expr be stmt.children at index 0
    generate_expression(gen, expr)
    emit(gen, "    jmp .L_return_" plus gen.current_function)
End Process

Process called "generate_if_statement" that takes gen as CodeGenerator, stmt as Parser.ASTNode returns Nothing:
    Let condition be stmt.children at index 0
    Let then_block be stmt.children at index 1

    Let else_label be gen_label(gen, "else")
    Let end_label be gen_label(gen, "endif")

    generate_expression(gen, condition)
    emit(gen, "    test %rax, %rax")
    emit(gen, "    jz " plus else_label)

    If is_list(then_block):
        For Each s in then_block:
            generate_statement(gen, s)
        End For
    Otherwise:
        generate_statement(gen, then_block)
    End If

    emit(gen, "    jmp " plus end_label)
    emit(gen, else_label plus ":")
    emit(gen, end_label plus ":")
End Process

Process called "generate_while_statement" that takes gen as CodeGenerator, stmt as Parser.ASTNode returns Nothing:
    Let condition be stmt.children at index 0
    Let body be stmt.children at index 1

    Let start_label be gen_label(gen, "while_start")
    Let end_label be gen_label(gen, "while_end")

    emit(gen, start_label plus ":")
    generate_expression(gen, condition)
    emit(gen, "    test %rax, %rax")
    emit(gen, "    jz " plus end_label)

    If is_list(body):
        For Each s in body:
            generate_statement(gen, s)
        End For
    Otherwise:
        generate_statement(gen, body)
    End If

    emit(gen, "    jmp " plus start_label)
    emit(gen, end_label plus ":")
End Process

Process called "generate_foreach_statement" that takes gen as CodeGenerator, stmt as Parser.ASTNode returns Nothing:
    Let var_name be stmt.value
    Let collection be stmt.children at index 0
    Let body be stmt.children at index 1

    Let start_label be gen_label(gen, "foreach_start")
    Let end_label be gen_label(gen, "foreach_end")
    Let iter_var be var_name plus "_iter"

    Note: Initialize iterator variable to 0
    Set gen.stack_offset to gen.stack_offset plus 8
    Set gen.variables at key iter_var to gen.stack_offset
    emit(gen, "    mov $0, %rax")
    emit(gen, "    mov %rax, -" plus int_to_string(gen.stack_offset) plus "(%rbp)")

    Note: Get collection length and store it
    generate_expression(gen, collection)
    emit(gen, "    mov %rax, %rdi")
    emit(gen, "    call list_length")
    emit(gen, "    push %rax")

    emit(gen, start_label plus ":")

    Note: Compare iterator with collection length
    Let iter_offset be gen.variables at key iter_var
    emit(gen, "    mov -" plus int_to_string(iter_offset) plus "(%rbp), %rax")
    emit(gen, "    pop %rbx")
    emit(gen, "    push %rbx")
    emit(gen, "    cmp %rbx, %rax")
    emit(gen, "    jge " plus end_label)

    Note: Get current element
    generate_expression(gen, collection)
    emit(gen, "    mov %rax, %rdi")
    emit(gen, "    mov -" plus int_to_string(iter_offset) plus "(%rbp), %rsi")
    emit(gen, "    call list_get")

    Note: Store current element in loop variable
    Set gen.stack_offset to gen.stack_offset plus 8
    Set gen.variables at key var_name to gen.stack_offset
    emit(gen, "    mov %rax, -" plus int_to_string(gen.stack_offset) plus "(%rbp)")

    Note: Execute loop body
    If is_list(body):
        For Each s in body:
            generate_statement(gen, s)
        End For
    Otherwise:
        generate_statement(gen, body)
    End If

    Note: Increment iterator
    emit(gen, "    mov -" plus int_to_string(iter_offset) plus "(%rbp), %rax")
    emit(gen, "    inc %rax")
    emit(gen, "    mov %rax, -" plus int_to_string(iter_offset) plus "(%rbp)")
    emit(gen, "    jmp " plus start_label)

    emit(gen, end_label plus ":")
    Note: Clean up stack
    emit(gen, "    pop %rax")
End Process

Process called "generate_match_statement" that takes gen as CodeGenerator, stmt as Parser.ASTNode returns Nothing:
    Let expr be stmt.children at index 0
    Let cases be stmt.children at index 1

    generate_expression(gen, expr)
    emit(gen, "    push %rax")

    Let end_label be gen_label(gen, "match_end")
    Let case_labels be a list containing nothing

    Note: Generate labels for each case
    For Each i from 0 to length of cases minus 1:
        Let case_label be gen_label(gen, "match_case")
        Add case_label to end of case_labels
    End For

    Note: Generate comparisons for each case
    For Each i from 0 to length of cases minus 1:
        Let case_node be cases at index i
        Let pattern_value be case_node.value
        Let case_label be case_labels at index i

        emit(gen, "    pop %rax")
        emit(gen, "    push %rax")

        Note: Compare with pattern
        If is_digit(string_char_at(pattern_value, 0)):
            emit(gen, "    mov $" plus pattern_value plus ", %rbx")
        Otherwise:
            Note: String literal comparison - simplified for now
            emit(gen, "    mov $0, %rbx")
        End If

        emit(gen, "    cmp %rbx, %rax")
        emit(gen, "    je " plus case_label)
    End For

    Note: If no case matches, jump to end
    emit(gen, "    jmp " plus end_label)

    Note: Generate case bodies
    For Each i from 0 to length of cases minus 1:
        Let case_node be cases at index i
        Let case_body be case_node.children
        Let case_label be case_labels at index i

        emit(gen, case_label plus ":")

        If is_list(case_body):
            For Each s in case_body:
                generate_statement(gen, s)
            End For
        Otherwise:
            generate_statement(gen, case_body)
        End If

        emit(gen, "    jmp " plus end_label)
    End For

    emit(gen, end_label plus ":")
    Note: Clean up expression from stack
    emit(gen, "    pop %rax")
End Process

Process called "generate_expression" that takes gen as CodeGenerator, expr as Parser.ASTNode returns Nothing:
    If expr.node_type is equal to Parser.Literal:
        If expr.data_type is equal to "Integer":
            emit(gen, "    mov $" plus expr.value plus ", %rax")
        Otherwise If expr.data_type is equal to "String":
            Let label be gen_string_literal(gen, expr.value)
            emit(gen, "    lea " plus label plus "(%rip), %rax")
        End If

    Otherwise If expr.node_type is equal to Parser.Identifier:
        Let offset be gen.variables at key expr.value
        emit(gen, "    mov -" plus int_to_string(offset) plus "(%rbp), %rax")

    Otherwise If expr.node_type is equal to Parser.BinaryOp:
        generate_binary_expression(gen, expr)

    Otherwise If expr.node_type is equal to Parser.FunctionCall:
        generate_function_call(gen, expr)

    Otherwise:
        Note: Default case - load zero
        emit(gen, "    mov $0, %rax")
    End If
End Process

Process called "generate_binary_expression" that takes gen as CodeGenerator, expr as Parser.ASTNode returns Nothing:
    Let left be expr.children at index 0
    Let right be expr.children at index 1

    generate_expression(gen, left)
    emit(gen, "    push %rax")

    generate_expression(gen, right)
    emit(gen, "    mov %rax, %rbx")
    emit(gen, "    pop %rax")

    If expr.value is equal to "plus":
        emit(gen, "    add %rbx, %rax")
    Otherwise If expr.value is equal to "minus":
        emit(gen, "    sub %rbx, %rax")
    Otherwise If expr.value is equal to "multiplied by":
        emit(gen, "    imul %rbx, %rax")
    Otherwise If expr.value is equal to "divided by":
        emit(gen, "    xor %rdx, %rdx")
        emit(gen, "    idiv %rbx")
    Otherwise If expr.value is equal to "is equal to":
        emit(gen, "    cmp %rbx, %rax")
        emit(gen, "    sete %al")
        emit(gen, "    movzx %al, %rax")
    Otherwise If expr.value is equal to "is greater than":
        emit(gen, "    cmp %rbx, %rax")
        emit(gen, "    setg %al")
        emit(gen, "    movzx %al, %rax")
    Otherwise If expr.value is equal to "is less than":
        emit(gen, "    cmp %rbx, %rax")
        emit(gen, "    setl %al")
        emit(gen, "    movzx %al, %rax")
    Otherwise If expr.value is equal to "and":
        emit(gen, "    and %rbx, %rax")
    Otherwise If expr.value is equal to "or":
        emit(gen, "    or %rbx, %rax")
    End If
End Process

Process called "generate_function_call" that takes gen as CodeGenerator, expr as Parser.ASTNode returns Nothing:
    Let func_name be expr.value
    Let args be expr.children

    Note: For simplicity in v0.2, handle built-in functions
    If func_name is equal to "string_concat":
        Note: Call built-in string concatenation
        Let arg1 be args at index 0
        Let arg2 be args at index 1
        generate_expression(gen, arg1)
        emit(gen, "    push %rax")
        generate_expression(gen, arg2)
        emit(gen, "    mov %rax, %rsi")
        emit(gen, "    pop %rdi")
        emit(gen, "    call string_concat_builtin")

    Otherwise If func_name is equal to "string_length":
        Let arg be args at index 0
        generate_expression(gen, arg)
        emit(gen, "    mov %rax, %rdi")
        emit(gen, "    call string_length_builtin")

    Otherwise:
        Note: Regular function call
        For Each i from 0 to length of args minus 1:
            generate_expression(gen, args at index i)
            If i is equal to 0: emit(gen, "    mov %rax, %rdi")
            Otherwise If i is equal to 1: emit(gen, "    mov %rax, %rsi")
            Otherwise If i is equal to 2: emit(gen, "    mov %rax, %rdx")
            Otherwise If i is equal to 3: emit(gen, "    mov %rax, %rcx")
            Otherwise If i is equal to 4: emit(gen, "    mov %rax, %r8")
            Otherwise If i is equal to 5: emit(gen, "    mov %rax, %r9")
            Otherwise:
                emit(gen, "    push %rax")
            End If
        End For

        emit(gen, "    call " plus func_name)
    End If
End Process

Process called "emit" that takes gen as CodeGenerator, line as String returns Nothing:
    Set gen.output to string_concat(gen.output, line)
    Set gen.output to string_concat(gen.output, char_to_string(10))  Note: Newline
End Process

Process called "gen_label" that takes gen as CodeGenerator, prefix as String returns String:
    Set gen.label_counter to gen.label_counter plus 1
    Return ".L" plus prefix plus "_" plus int_to_string(gen.label_counter)
End Process

Process called "gen_string_literal" that takes gen as CodeGenerator, value as String returns String:
    Set gen.label_counter to gen.label_counter plus 1
    Let label be ".LC" plus int_to_string(gen.label_counter)

    Note: Add to data section (simplified)
    Set gen.output to string_concat(gen.output, ".section .rodata")
    Set gen.output to string_concat(gen.output, char_to_string(10))
    Set gen.output to string_concat(gen.output, label plus ":")
    Set gen.output to string_concat(gen.output, char_to_string(10))
    Set gen.output to string_concat(gen.output, "    .string \"" plus value plus "\"")
    Set gen.output to string_concat(gen.output, char_to_string(10))
    Set gen.output to string_concat(gen.output, ".text")
    Set gen.output to string_concat(gen.output, char_to_string(10))

    Return label
End Process

Process called "is_list" that takes obj as Parser.ASTNode returns Boolean:
    Note: Check if object represents a list of statements
    Return length of obj.children is greater than 0
End Process

Process called "int_to_string" that takes num as Integer returns String:
    Note: Convert integer to string representation
    If num is equal to 0:
        Return "0"
    End If

    Let result be ""
    Let n be num
    Let is_negative be false

    If n is less than 0:
        Set is_negative to true
        Set n to 0 minus n
    End If

    While n is greater than 0:
        Let digit be n mod 10
        Let digit_char be ""
        If digit is equal to 0: Set digit_char to "0"
        Otherwise If digit is equal to 1: Set digit_char to "1"
        Otherwise If digit is equal to 2: Set digit_char to "2"
        Otherwise If digit is equal to 3: Set digit_char to "3"
        Otherwise If digit is equal to 4: Set digit_char to "4"
        Otherwise If digit is equal to 5: Set digit_char to "5"
        Otherwise If digit is equal to 6: Set digit_char to "6"
        Otherwise If digit is equal to 7: Set digit_char to "7"
        Otherwise If digit is equal to 8: Set digit_char to "8"
        Otherwise If digit is equal to 9: Set digit_char to "9"
        End If
        Set result to string_concat(digit_char, result)
        Set n to n divided by 10
    End While

    If is_negative:
        Set result to string_concat("-", result)
    End If

    Return result
End Process

Process called "char_to_string" that takes ch as Integer returns String:
    Note: Convert ASCII character code to single character string
    If ch is equal to 10: Return "\n"
    Otherwise If ch is equal to 9: Return "\t"
    Otherwise If ch is equal to 13: Return "\r"
    Otherwise If ch is equal to 32: Return " "
    Otherwise If ch is equal to 33: Return "!"
    Otherwise If ch is equal to 34: Return "\""
    Otherwise If ch is equal to 35: Return "#"
    Otherwise If ch is equal to 36: Return "$"
    Otherwise If ch is equal to 37: Return "%"
    Otherwise If ch is equal to 38: Return "&"
    Otherwise If ch is equal to 39: Return "'"
    Otherwise If ch is equal to 40: Return "("
    Otherwise If ch is equal to 41: Return ")"
    Otherwise If ch is equal to 42: Return "*"
    Otherwise If ch is equal to 43: Return "+"
    Otherwise If ch is equal to 44: Return ","
    Otherwise If ch is equal to 45: Return "-"
    Otherwise If ch is equal to 46: Return "."
    Otherwise If ch is equal to 47: Return "/"
    Otherwise If ch is equal to 48: Return "0"
    Otherwise If ch is equal to 49: Return "1"
    Otherwise If ch is equal to 50: Return "2"
    Otherwise If ch is equal to 51: Return "3"
    Otherwise If ch is equal to 52: Return "4"
    Otherwise If ch is equal to 53: Return "5"
    Otherwise If ch is equal to 54: Return "6"
    Otherwise If ch is equal to 55: Return "7"
    Otherwise If ch is equal to 56: Return "8"
    Otherwise If ch is equal to 57: Return "9"
    Otherwise If ch is equal to 58: Return ":"
    Otherwise If ch is equal to 59: Return ";"
    Otherwise If ch is equal to 60: Return "<"
    Otherwise If ch is equal to 61: Return "="
    Otherwise If ch is equal to 62: Return ">"
    Otherwise If ch is equal to 63: Return "?"
    Otherwise If ch is equal to 64: Return "@"
    Otherwise If ch is equal to 65: Return "A"
    Otherwise If ch is equal to 66: Return "B"
    Otherwise If ch is equal to 67: Return "C"
    Otherwise If ch is equal to 68: Return "D"
    Otherwise If ch is equal to 69: Return "E"
    Otherwise If ch is equal to 70: Return "F"
    Otherwise If ch is equal to 71: Return "G"
    Otherwise If ch is equal to 72: Return "H"
    Otherwise If ch is equal to 73: Return "I"
    Otherwise If ch is equal to 74: Return "J"
    Otherwise If ch is equal to 75: Return "K"
    Otherwise If ch is equal to 76: Return "L"
    Otherwise If ch is equal to 77: Return "M"
    Otherwise If ch is equal to 78: Return "N"
    Otherwise If ch is equal to 79: Return "O"
    Otherwise If ch is equal to 80: Return "P"
    Otherwise If ch is equal to 81: Return "Q"
    Otherwise If ch is equal to 82: Return "R"
    Otherwise If ch is equal to 83: Return "S"
    Otherwise If ch is equal to 84: Return "T"
    Otherwise If ch is equal to 85: Return "U"
    Otherwise If ch is equal to 86: Return "V"
    Otherwise If ch is equal to 87: Return "W"
    Otherwise If ch is equal to 88: Return "X"
    Otherwise If ch is equal to 89: Return "Y"
    Otherwise If ch is equal to 90: Return "Z"
    Otherwise If ch is equal to 91: Return "["
    Otherwise If ch is equal to 92: Return "\\"
    Otherwise If ch is equal to 93: Return "]"
    Otherwise If ch is equal to 94: Return "^"
    Otherwise If ch is equal to 95: Return "_"
    Otherwise If ch is equal to 96: Return "`"
    Otherwise If ch is equal to 97: Return "a"
    Otherwise If ch is equal to 98: Return "b"
    Otherwise If ch is equal to 99: Return "c"
    Otherwise If ch is equal to 100: Return "d"
    Otherwise If ch is equal to 101: Return "e"
    Otherwise If ch is equal to 102: Return "f"
    Otherwise If ch is equal to 103: Return "g"
    Otherwise If ch is equal to 104: Return "h"
    Otherwise If ch is equal to 105: Return "i"
    Otherwise If ch is equal to 106: Return "j"
    Otherwise If ch is equal to 107: Return "k"
    Otherwise If ch is equal to 108: Return "l"
    Otherwise If ch is equal to 109: Return "m"
    Otherwise If ch is equal to 110: Return "n"
    Otherwise If ch is equal to 111: Return "o"
    Otherwise If ch is equal to 112: Return "p"
    Otherwise If ch is equal to 113: Return "q"
    Otherwise If ch is equal to 114: Return "r"
    Otherwise If ch is equal to 115: Return "s"
    Otherwise If ch is equal to 116: Return "t"
    Otherwise If ch is equal to 117: Return "u"
    Otherwise If ch is equal to 118: Return "v"
    Otherwise If ch is equal to 119: Return "w"
    Otherwise If ch is equal to 120: Return "x"
    Otherwise If ch is equal to 121: Return "y"
    Otherwise If ch is equal to 122: Return "z"
    Otherwise If ch is equal to 123: Return "{"
    Otherwise If ch is equal to 124: Return "|"
    Otherwise If ch is equal to 125: Return "}"
    Otherwise If ch is equal to 126: Return "~"
    Otherwise: Return "?"
    End If
End Process

Process called "is_digit" that takes ch as Integer returns Boolean:
    Return ch is greater than or equal to 48 and ch is less than or equal to 57
End Process

Note: Wrapper function for v0.1 compatibility
Process called "CodeGen_generate" that takes ast as Parser.ASTNode returns String:
    Return generate(ast)
End Process