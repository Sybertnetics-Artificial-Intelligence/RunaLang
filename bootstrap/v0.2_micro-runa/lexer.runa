Note: v0.2 Lexer Implementation
Note: Per specification Section 2.2

Type called "Token":
    token_type as TokenType
    value as String
    line as Integer
    column as Integer
End Type

Type TokenType is:
    | Keyword      Note: Process, Let, If, Return, etc.
    | Identifier   Note: Variable and function names
    | Integer      Note: Numeric literals
    | String       Note: String literals
    | Symbol       Note: (, ), :, etc.
    | Operator     Note: plus, minus, etc.
End Type

Process called "tokenize" that takes source as String returns List[Token]:
    Let tokens be a list containing nothing
    Let position be 0
    Let line be 1
    Let column be 1

    While position is less than string_length(source):
        Let ch be string_char_at(source, position)

        If is_whitespace(ch):
            If ch is equal to 10: Note: Newline
                Set line to line plus 1
                Set column to 1
            Otherwise:
                Set column to column plus 1
            End If
            Set position to position plus 1

        Otherwise If is_letter(ch):
            Let ident_result be read_identifier(source, position)
            Let identifier be get_first(ident_result)
            Let new_pos be get_second(ident_result)

            Note: Handle multi-word operators
            Let final_token be handle_multi_word_operator(source, position, identifier)
            If final_token.value is not equal to "":
                Add final_token to end of tokens
                Set position to final_token.column
                Set column to final_token.column
            Otherwise:
                Let token_type be Keyword
                If is_keyword(identifier) is equal to false:
                    Set token_type to Identifier
                End If

                Let token be a value of type Token with
                    token_type as token_type,
                    value as identifier,
                    line as line,
                    column as column

                Add token to end of tokens
                Set column to column plus (new_pos minus position)
                Set position to new_pos
            End If

        Otherwise If is_digit(ch):
            Let num_result be read_number(source, position)
            Let number be get_first(num_result)
            Let new_pos be get_second(num_result)

            Let token be a value of type Token with
                token_type as Integer,
                value as number,
                line as line,
                column as column

            Add token to end of tokens
            Set column to column plus (new_pos minus position)
            Set position to new_pos

        Otherwise If ch is equal to 34: Note: Quote character
            Let str_result be read_string(source, position)
            Let string_val be get_first(str_result)
            Let new_pos be get_second(str_result)

            Let token be a value of type Token with
                token_type as String,
                value as string_val,
                line as line,
                column as column

            Add token to end of tokens
            Set column to column plus (new_pos minus position)
            Set position to new_pos

        Otherwise:
            Let symbol be char_to_string(ch)
            Let token be a value of type Token with
                token_type as Symbol,
                value as symbol,
                line as line,
                column as column

            Add token to end of tokens
            Set column to column plus 1
            Set position to position plus 1
        End If
    End While

    Return tokens
End Process

Process called "read_identifier" that takes source as String, start as Integer returns List[String]:
    Let position be start
    Let identifier be ""

    While position is less than string_length(source):
        Let ch be string_char_at(source, position)
        If is_letter(ch) or is_digit(ch) or ch is equal to 95: Note: Underscore
            Set identifier to string_concat(identifier, char_to_string(ch))
            Set position to position plus 1
        Otherwise:
            Break from loop
        End If
    End While

    Let result be a list containing identifier, int_to_string(position)
    Return result
End Process

Process called "read_number" that takes source as String, start as Integer returns List[String]:
    Let position be start
    Let number be ""

    While position is less than string_length(source):
        Let ch be string_char_at(source, position)
        If is_digit(ch):
            Set number to string_concat(number, char_to_string(ch))
            Set position to position plus 1
        Otherwise:
            Break from loop
        End If
    End While

    Let result be a list containing number, int_to_string(position)
    Return result
End Process

Process called "read_string" that takes source as String, start as Integer returns List[String]:
    Let position be start plus 1  Note: Skip opening quote
    Let string_val be ""

    While position is less than string_length(source):
        Let ch be string_char_at(source, position)
        If ch is equal to 34: Note: Closing quote
            Set position to position plus 1
            Break from loop
        Otherwise If ch is equal to 92: Note: Backslash escape
            Set position to position plus 1
            If position is less than string_length(source):
                Let escaped_ch be string_char_at(source, position)
                If escaped_ch is equal to 110: Note: n
                    Set string_val to string_concat(string_val, char_to_string(10))
                Otherwise If escaped_ch is equal to 116: Note: t
                    Set string_val to string_concat(string_val, char_to_string(9))
                Otherwise If escaped_ch is equal to 114: Note: r
                    Set string_val to string_concat(string_val, char_to_string(13))
                Otherwise If escaped_ch is equal to 92: Note: backslash
                    Set string_val to string_concat(string_val, char_to_string(92))
                Otherwise If escaped_ch is equal to 34: Note: quote
                    Set string_val to string_concat(string_val, char_to_string(34))
                Otherwise:
                    Set string_val to string_concat(string_val, char_to_string(escaped_ch))
                End If
                Set position to position plus 1
            End If
        Otherwise:
            Set string_val to string_concat(string_val, char_to_string(ch))
            Set position to position plus 1
        End If
    End While

    Let result be a list containing string_val, int_to_string(position)
    Return result
End Process

Process called "is_keyword" that takes word as String returns Boolean:
    If word is equal to "Process": Return true
    Otherwise If word is equal to "called": Return true
    Otherwise If word is equal to "that": Return true
    Otherwise If word is equal to "takes": Return true
    Otherwise If word is equal to "returns": Return true
    Otherwise If word is equal to "as": Return true
    Otherwise If word is equal to "Let": Return true
    Otherwise If word is equal to "Set": Return true
    Otherwise If word is equal to "be": Return true
    Otherwise If word is equal to "to": Return true
    Otherwise If word is equal to "If": Return true
    Otherwise If word is equal to "Otherwise": Return true
    Otherwise If word is equal to "End": Return true
    Otherwise If word is equal to "While": Return true
    Otherwise If word is equal to "For": Return true
    Otherwise If word is equal to "Each": Return true
    Otherwise If word is equal to "in": Return true
    Otherwise If word is equal to "Return": Return true
    Otherwise If word is equal to "Match": Return true
    Otherwise If word is equal to "When": Return true
    Otherwise If word is equal to "Type": Return true
    Otherwise If word is equal to "Import": Return true
    Otherwise If word is equal to "Export": Return true
    Otherwise If word is equal to "Note": Return true
    Otherwise If word is equal to "plus": Return true
    Otherwise If word is equal to "minus": Return true
    Otherwise If word is equal to "multiplied": Return true
    Otherwise If word is equal to "by": Return true
    Otherwise If word is equal to "divided": Return true
    Otherwise If word is equal to "is": Return true
    Otherwise If word is equal to "greater": Return true
    Otherwise If word is equal to "less": Return true
    Otherwise If word is equal to "than": Return true
    Otherwise If word is equal to "equal": Return true
    Otherwise If word is equal to "not": Return true
    Otherwise If word is equal to "and": Return true
    Otherwise If word is equal to "or": Return true
    Otherwise: Return false
End Process

Process called "is_whitespace" that takes ch as Integer returns Boolean:
    If ch is equal to 32: Return true   Note: Space
    Otherwise If ch is equal to 9: Return true    Note: Tab
    Otherwise If ch is equal to 13: Return true   Note: Carriage return
    Otherwise: Return false
End Process

Process called "char_to_string" that takes ch as Integer returns String:
    Note: This is a built-in character operation from v0.1
    Note: Converts ASCII code to single character string
    Return char_to_string(ch)
End Process

Process called "int_to_string" that takes num as Integer returns String:
    Note: This is a built-in conversion from v0.1
    Return int_to_string(num)
End Process

Process called "get_first" that takes list as List[String] returns String:
    Return list at index 0
End Process

Process called "get_second" that takes list as List[String] returns String:
    Return list at index 1
End Process

Process called "handle_multi_word_operator" that takes source as String, start as Integer, first_word as String returns Token:
    Let empty_token be a value of type Token with
        token_type as Operator,
        value as "",
        line as 0,
        column as 0

    If first_word is equal to "is":
        Let pos be start plus 2  Note: Skip "is"
        Let next_word be read_next_word(source, pos)

        If next_word is equal to "greater":
            Let third_pos be pos plus 7  Note: Skip "greater"
            Let third_word be read_next_word(source, third_pos)
            If third_word is equal to "than":
                Return a value of type Token with
                    token_type as Operator,
                    value as "is greater than",
                    line as 0,
                    column as third_pos plus 4
            End If
        Otherwise If next_word is equal to "less":
            Let third_pos be pos plus 4  Note: Skip "less"
            Let third_word be read_next_word(source, third_pos)
            If third_word is equal to "than":
                Return a value of type Token with
                    token_type as Operator,
                    value as "is less than",
                    line as 0,
                    column as third_pos plus 4
            End If
        Otherwise If next_word is equal to "equal":
            Let third_pos be pos plus 5  Note: Skip "equal"
            Let third_word be read_next_word(source, third_pos)
            If third_word is equal to "to":
                Return a value of type Token with
                    token_type as Operator,
                    value as "is equal to",
                    line as 0,
                    column as third_pos plus 2
            End If
        End If

    Otherwise If first_word is equal to "multiplied":
        Let pos be start plus 10  Note: Skip "multiplied"
        Let next_word be read_next_word(source, pos)
        If next_word is equal to "by":
            Return a value of type Token with
                token_type as Operator,
                value as "multiplied by",
                line as 0,
                column as pos plus 2
        End If

    Otherwise If first_word is equal to "divided":
        Let pos be start plus 7  Note: Skip "divided"
        Let next_word be read_next_word(source, pos)
        If next_word is equal to "by":
            Return a value of type Token with
                token_type as Operator,
                value as "divided by",
                line as 0,
                column as pos plus 2
        End If
    End If

    Return empty_token
End Process

Process called "read_next_word" that takes source as String, start as Integer returns String:
    Let pos be start

    Note: Skip whitespace
    While pos is less than string_length(source):
        Let ch be string_char_at(source, pos)
        If is_whitespace(ch):
            Set pos to pos plus 1
        Otherwise:
            Break from loop
        End If
    End While

    Note: Read word
    Let word be ""
    While pos is less than string_length(source):
        Let ch be string_char_at(source, pos)
        If is_letter(ch):
            Set word to string_concat(word, char_to_string(ch))
            Set pos to pos plus 1
        Otherwise:
            Break from loop
        End If
    End While

    Return word
End Process

Note: Wrapper function for v0.1 compatibility
Process called "Lexer_tokenize" that takes source as String returns List[Token]:
    Return tokenize(source)
End Process