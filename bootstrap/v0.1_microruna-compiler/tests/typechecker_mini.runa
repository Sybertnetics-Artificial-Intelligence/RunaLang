Note: MicroRunaTypeChecker

Note: Global type tracking storage using pipe separated strings
Note: Format variables varname type scope varname2 type2 scope2
Note: Format functions funcname param1 param2 returntype func2 param ret
Note: Format types typename field1 type1 field2 type2 type2 fields
Let global_variables be ""
Let global_functions be ""
Let global_types be ""
Let current_scope be "global"
Let current_function_return be "Void"

Process called "extract_ast_part" that takes ast_data as String, part_index as Integer returns String:
    Note: ExtractASTComponent
    Let current_part be 0
    Let start_pos be 0
    Let i be 0
    Let ast_length be length_of(ast_data)

    While i is less than ast_length:
        Let char_code be char_at(ast_data, i)
        If char_code is equal to 124:
            If current_part is equal to part_index:
                Return substring(ast_data, start_pos, i)
            End If
            Set current_part to current_part plus 1
            Set start_pos to i plus 1
        End If
        Set i to i plus 1
    End While

    If current_part is equal to part_index:
        Return substring(ast_data, start_pos, ast_length)
    End If
    Return ""
End Process

Process called "get_expression_type" that takes expr_ast as String returns String:
    Note: DetermineExpressionType Enhanced with real type inference
    Let ast_type be extract_ast_part(expr_ast, 0)

    If ast_type is equal to "integer_literal":
        Return "Integer"
    End If
    If ast_type is equal to "string_literal":
        Return "String"
    End If
    If ast_type is equal to "identifier":
        Let var_name be extract_ast_part(expr_ast, 1)
        Return lookup_variable_type(var_name)
