Note: MicroRuna v0.1 Compiler Integration Tests
Note: Tests end-to-end compilation pipeline
Note: Validates complete source-to-executable workflow

Note: Integration test framework
Type called "IntegrationTestResult":
    test_name as String
    passed as Integer
    error_message as String
    execution_time as Integer
End Type

Type called "IntegrationTestRunner":
    total_tests as Integer
    passed_tests as Integer
    failed_tests as Integer
    total_time as Integer
End Type

Note: Main integration test entry point
Process called "run_integration_tests" that takes no parameters returns Integer:
    Let runner be a value of type IntegrationTestRunner with
        total_tests as 0,
        passed_tests as 0,
        failed_tests as 0,
        total_time as 0

    Display "üîó Running MicroRuna v0.1 Integration Tests"
    Display "============================================"

    Note: Test 1: Simple program compilation
    call test_simple_program_compilation(runner)

    Note: Test 2: Function definition and call
    call test_function_compilation(runner)

    Note: Test 3: Control flow structures
    call test_control_flow_compilation(runner)

    Note: Test 4: Built-in function usage
    call test_builtin_functions_compilation(runner)

    Note: Test 5: Complete MicroRuna program
    call test_complete_program_compilation(runner)

    Note: The ultimate test: Self-compilation
    call test_self_compilation(runner)

    Note: Print results
    Display runner

    If runner.failed_tests is equal to 0:
        Return 0
    Otherwise:
        Return 1
    End If
End Process

Note: Test 1: Simple program compilation
Process called "test_simple_program_compilation" that takes runner as IntegrationTestRunner returns Void:
    Display "üß™ Test 1: Simple Program Compilation"

    Note: Create simple test program
    Let test_program be "Let x be 42 Display to_string(x)"

    Let result be call compile_and_validate_program(test_program, "simple_test")
    call record_integration_result(runner, result)
End Process

Note: Test 2: Function definition and call
Process called "test_function_compilation" that takes runner as IntegrationTestRunner returns Void:
    Display "üß™ Test 2: Function Definition and Call"

    Note: Create test program with function
    Let test_program be "Process called \"add\" that takes a as Integer and b as Integer returns Integer: Return a plus b End Process Let result be call add(10, 20) Display to_string(result)"

    Let result be call compile_and_validate_program(test_program, "function_test")
    call record_integration_result(runner, result)
End Process

Note: Test 3: Control flow structures
Process called "test_control_flow_compilation" that takes runner as IntegrationTestRunner returns Void:
    Display "üß™ Test 3: Control Flow Structures"

    Note: Create test program with if/while
    Let test_program be "Let x be 5 If x is greater than 3: Display \"x is large\" Otherwise: Display \"x is small\" End If Let i be 0 While i is less than 3: Display to_string(i) Set i to i plus 1 End While"

    Let result be call compile_and_validate_program(test_program, "control_flow_test")
    call record_integration_result(runner, result)
End Process

Note: Test 4: Built-in function usage
Process called "test_builtin_functions_compilation" that takes runner as IntegrationTestRunner returns Void:
    Display "üß™ Test 4: Built-in Functions"

    Note: Create test program using built-in functions
    Let test_program be "Let message be \"Hello, World!\" Let len be call length_of(message) Display message Display to_string(len) Let sub be call substring(message, 0, 5) Display sub"

    Let result be call compile_and_validate_program(test_program, "builtin_test")
    call record_integration_result(runner, result)
End Process

Note: Test 5: Complete MicroRuna program
Process called "test_complete_program_compilation" that takes runner as IntegrationTestRunner returns Void:
    Display "üß™ Test 5: Complete MicroRuna Program"

    Note: Create comprehensive test program
    Let test_program be "Type called \"Person\": name as String age as Integer End Type Process called \"greet\" that takes person as Person returns Void: Let greeting be call concat(\"Hello, \", person.name) Display greeting End Process Let alice be a value of type Person with name as \"Alice\", age as 30 call greet(alice)"

    Let result be call compile_and_validate_program(test_program, "complete_test")
    call record_integration_result(runner, result)
End Process

Note: Test 6: Self-compilation test
Process called "test_self_compilation" that takes runner as IntegrationTestRunner returns Void:
    Display "üß™ Test 6: Self-Compilation (Bootstrap Validation)"
    Display "üöÄ THE ULTIMATE TEST!"

    Note: Attempt to compile the v0.1 compiler using itself
    Let start_time be call get_current_time()

    Note: Read v0.1 source files
    Let main_source be call read_file("src/main.runa")
    Let lexer_source be call read_file("src/lexer.runa")
    Let parser_source be call read_file("src/parser.runa")
    Let typechecker_source be call read_file("src/typechecker.runa")
    Let codegen_source be call read_file("src/codegen.runa")
    Let runtime_source be call read_file("src/runtime.runa")

    Note: Check if all source files were read successfully
    If main_source is equal to "ERROR" or lexer_source is equal to "ERROR" or parser_source is equal to "ERROR" or typechecker_source is equal to "ERROR" or codegen_source is equal to "ERROR" or runtime_source is equal to "ERROR":
        Let fail_result be a value of type IntegrationTestResult with
            test_name as "Self-Compilation",
            passed as 0,
            error_message as "Could not read v0.1 source files",
            execution_time as 0

        call record_integration_result(runner, fail_result)
        Return
    End If

    Note: Combine all sources into one big program for testing
    Let combined_source be main_source
    Set combined_source to concat(combined_source, " ")
    Set combined_source to concat(combined_source, lexer_source)
    Set combined_source to concat(combined_source, " ")
    Set combined_source to concat(combined_source, parser_source)
    Set combined_source to concat(combined_source, " ")
    Set combined_source to concat(combined_source, typechecker_source)
    Set combined_source to concat(combined_source, " ")
    Set combined_source to concat(combined_source, codegen_source)
    Set combined_source to concat(combined_source, " ")
    Set combined_source to concat(combined_source, runtime_source)

    Note: Attempt compilation using v0.1 compiler
    Let compilation_result be call compile_with_v01_compiler(combined_source, "runac-v0.1-gen2")

    Let end_time be call get_current_time()
    Let execution_time be end_time minus start_time

    If compilation_result is equal to "SUCCESS":
        Let success_result be a value of type IntegrationTestResult with
            test_name as "Self-Compilation",
            passed as 1,
            error_message as "",
            execution_time as execution_time

        call record_integration_result(runner, success_result)
        Display "üéâ BOOTSTRAP SUCCESS! v0.1 compiler can compile itself!"
    Otherwise:
        Let fail_result be a value of type IntegrationTestResult with
            test_name as "Self-Compilation",
            passed as 0,
            error_message as compilation_result,
            execution_time as execution_time

        call record_integration_result(runner, fail_result)
        Display "‚ùå Self-compilation failed - more work needed"
    End If
End Process

Note: Core compilation test function
Process called "compile_and_validate_program" that takes program_source as String and test_name as String returns IntegrationTestResult:
    Let start_time be call get_current_time()

    Note: Step 1: Tokenization
    Let tokens be call lexer_tokenize(program_source)
    If tokens is equal to "ERROR":
        Let end_time be call get_current_time()
        Return a value of type IntegrationTestResult with
            test_name as test_name,
            passed as 0,
            error_message as "Lexer tokenization failed",
            execution_time as end_time minus start_time
    End If

    Note: Step 2: Parsing
    Let ast be call parser_parse(tokens)
    If ast is equal to "ERROR":
        Let end_time be call get_current_time()
        Return a value of type IntegrationTestResult with
            test_name as test_name,
            passed as 0,
            error_message as "Parser failed to generate AST",
            execution_time as end_time minus start_time
    End If

    Note: Step 3: Type checking
    Let type_result be call typechecker_check(ast)
    If type_result is not equal to "OK":
        Let end_time be call get_current_time()
        Return a value of type IntegrationTestResult with
            test_name as test_name,
            passed as 0,
            error_message as concat("Type checking failed: ", type_result),
            execution_time as end_time minus start_time
    End If

    Note: Step 4: Code generation
    Let assembly be call codegen_generate(ast)
    If assembly is equal to "ERROR":
        Let end_time be call get_current_time()
        Return a value of type IntegrationTestResult with
            test_name as test_name,
            passed as 0,
            error_message as "Code generation failed",
            execution_time as end_time minus start_time
    End If

    Note: Step 5: Assembly and linking (simulated)
    Let assembly_result be call simulate_assembly_and_linking(assembly, test_name)
    Let end_time be call get_current_time()

    If assembly_result is equal to "SUCCESS":
        Return a value of type IntegrationTestResult with
            test_name as test_name,
            passed as 1,
            error_message as "",
            execution_time as end_time minus start_time
    Otherwise:
        Return a value of type IntegrationTestResult with
            test_name as test_name,
            passed as 0,
            error_message as concat("Assembly/linking failed: ", assembly_result),
            execution_time as end_time minus start_time
    End If
End Process

Note: Simulate assembly and linking process
Process called "simulate_assembly_and_linking" that takes assembly_code as String and output_name as String returns String:
    Note: In a real implementation, this would:
    Note: 1. Write assembly to file
    Note: 2. Call gcc to assemble and link
    Note: 3. Verify executable was created

    Note: For now, check if assembly contains expected sections
    If call contains(assembly_code, ".text") and call contains(assembly_code, "main:"):
        Return "SUCCESS"
    Otherwise:
        Return "Assembly code missing required sections"
    End If
End Process

Note: Compile using v0.1 compiler (self-compilation)
Process called "compile_with_v01_compiler" that takes source as String and output_name as String returns String:
    Note: This would use the v0.1 compiler to compile the source
    Note: For now, run through the compilation pipeline

    Let tokens be call lexer_tokenize(source)
    If tokens is equal to "ERROR":
        Return "Self-compilation: Lexer failed"
    End If

    Let ast be call parser_parse(tokens)
    If ast is equal to "ERROR":
        Return "Self-compilation: Parser failed"
    End If

    Let type_result be call typechecker_check(ast)
    If type_result is not equal to "OK":
        Return concat("Self-compilation: Type checker failed: ", type_result)
    End If

    Let assembly be call codegen_generate(ast)
    If assembly is equal to "ERROR":
        Return "Self-compilation: Code generator failed"
    End If

    Note: If we get here, self-compilation succeeded
    Return "SUCCESS"
End Process

Note: Utility functions
Process called "get_current_time" that takes no parameters returns Integer:
    Note: Return current timestamp in milliseconds
    Note: For MicroRuna bootstrap, return a dummy value
    Return 1000
End Process

Process called "record_integration_result" that takes runner as IntegrationTestRunner and result as IntegrationTestResult returns Void:
    Set runner.total_tests to runner.total_tests plus 1
    Set runner.total_time to runner.total_time plus result.execution_time

    If result.passed is equal to 1:
        Set runner.passed_tests to runner.passed_tests plus 1
        Let pass_msg be concat("‚úÖ ", result.test_name)
        Set pass_msg to concat(pass_msg, " (")
        Set pass_msg to concat(pass_msg, to_string(result.execution_time))
        Set pass_msg to concat(pass_msg, "ms)")
        Display pass_msg
    Otherwise:
        Set runner.failed_tests to runner.failed_tests plus 1
        Let fail_msg be concat("‚ùå ", result.test_name)
        Set fail_msg to concat(fail_msg, ": ")
        Set fail_msg to concat(fail_msg, result.error_message)
        Set fail_msg to concat(fail_msg, " (")
        Set fail_msg to concat(fail_msg, to_string(result.execution_time))
        Set fail_msg to concat(fail_msg, "ms)")
        Display fail_msg
    End If
End Process

Process called "print_integration_summary" that takes runner as IntegrationTestRunner returns Void:
    Display ""
    Display "üìä Integration Test Summary"
    Display "==========================="

    Let total_msg be concat("Total tests: ", to_string(runner.total_tests))
    Display total_msg

    Let passed_msg be concat("Passed: ", to_string(runner.passed_tests))
    Display passed_msg

    Let failed_msg be concat("Failed: ", to_string(runner.failed_tests))
    Display failed_msg

    Let time_msg be concat("Total execution time: ", to_string(runner.total_time))
    Set time_msg to concat(time_msg, "ms")
    Display time_msg

    If runner.failed_tests is equal to 0:
        Display ""
        Display "üéâ ALL INTEGRATION TESTS PASSED!"
        Display "üöÄ MicroRuna v0.1 Compiler is ready for production!"

        Note: Check if self-compilation passed
        If runner.passed_tests is greater than 5:
            Display ""
            Display "üèÜ BOOTSTRAP ACHIEVEMENT UNLOCKED!"
            Display "The first self-hosted MicroRuna compiler has been born!"
            Display "Language independence achieved! üéØ"
        End If
    Otherwise:
        Display ""
        Display "‚ùå Some integration tests failed"
        Display "‚ö†Ô∏è More development work is needed before v0.1 is complete"
    End If
End Process

Note: Test runner for external execution
Process called "main" that takes no parameters returns Integer:
    Note: Entry point for running integration tests standalone
    Return call run_integration_tests()
End Process