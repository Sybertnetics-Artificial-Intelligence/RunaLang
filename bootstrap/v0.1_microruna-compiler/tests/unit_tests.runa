Note: MicroRuna v0.1 Compiler Unit Tests
Note: Tests individual components of the compiler
Note: Validates lexer, parser, typechecker, and codegen separately

Note: Test framework structure
Type called "TestResult":
    test_name as String
    passed as Integer
    error_message as String
End Type

Note: Test runner state
Type called "TestRunner":
    total_tests as Integer
    passed_tests as Integer
    failed_tests as Integer
End Type

Note: Main test entry point
Process called "run_unit_tests" that takes no parameters returns Integer:
    Let runner be a value of type TestRunner with
        total_tests as 0,
        passed_tests as 0,
        failed_tests as 0

    Display "üß™ Running MicroRuna v0.1 Compiler Unit Tests"
    Display "=============================================="

    Note: Run lexer tests
    call run_lexer_tests(runner)

    Note: Run parser tests
    call run_parser_tests(runner)

    Note: Run typechecker tests
    call run_typechecker_tests(runner)

    Note: Run codegen tests
    call run_codegen_tests(runner)

    Note: Print results
    Display runner

    If runner.failed_tests is equal to 0:
        Return 0
    Otherwise:
        Return 1
    End If
End Process

Note: Lexer unit tests
Process called "run_lexer_tests" that takes runner as TestRunner returns Void:
    Display "üìù Testing Lexer Component"
    Display "---------------------------"

    Note: Test 1: Basic keyword tokenization
    Let test1 be call test_lexer_keywords(runner)
    call record_test_result(runner, test1)

    Note: Test 2: Integer literal tokenization
    Let test2 be call test_lexer_integers(runner)
    call record_test_result(runner, test2)

    Note: Test 3: String literal tokenization
    Let test3 be call test_lexer_strings(runner)
    call record_test_result(runner, test3)

    Note: Test 4: Identifier tokenization
    Let test4 be call test_lexer_identifiers(runner)
    call record_test_result(runner, test4)

    Note: Test 5: Punctuation tokenization
    Let test5 be call test_lexer_punctuation(runner)
    call record_test_result(runner, test5)
End Process

Process called "test_lexer_keywords" that takes runner as TestRunner returns TestResult:
    Let test_input be "Let x be 42"
    Let tokens be call lexer_tokenize(test_input)

    Note: Check if tokenization succeeded
    If tokens is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "Lexer Keywords",
            passed as 0,
            error_message as "Tokenization failed"
    End If

    Note: For now, assume success if no error
    Note: Full implementation would parse tokens and verify types
    Return a value of type TestResult with
        test_name as "Lexer Keywords",
        passed as 1,
        error_message as ""
End Process

Process called "test_lexer_integers" that takes runner as TestRunner returns TestResult:
    Let test_input be "123 456 789"
    Let tokens be call lexer_tokenize(test_input)

    If tokens is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "Lexer Integers",
            passed as 0,
            error_message as "Integer tokenization failed"
    End If

    Return a value of type TestResult with
        test_name as "Lexer Integers",
        passed as 1,
        error_message as ""
End Process

Process called "test_lexer_strings" that takes runner as TestRunner returns TestResult:
    Let test_input be "\"hello\" \"world\""
    Let tokens be call lexer_tokenize(test_input)

    If tokens is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "Lexer Strings",
            passed as 0,
            error_message as "String tokenization failed"
    End If

    Return a value of type TestResult with
        test_name as "Lexer Strings",
        passed as 1,
        error_message as ""
End Process

Process called "test_lexer_identifiers" that takes runner as TestRunner returns TestResult:
    Let test_input be "variable_name function_call"
    Let tokens be call lexer_tokenize(test_input)

    If tokens is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "Lexer Identifiers",
            passed as 0,
            error_message as "Identifier tokenization failed"
    End If

    Return a value of type TestResult with
        test_name as "Lexer Identifiers",
        passed as 1,
        error_message as ""
End Process

Process called "test_lexer_punctuation" that takes runner as TestRunner returns TestResult:
    Let test_input be "()[],.:"
    Let tokens be call lexer_tokenize(test_input)

    If tokens is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "Lexer Punctuation",
            passed as 0,
            error_message as "Punctuation tokenization failed"
    End If

    Return a value of type TestResult with
        test_name as "Lexer Punctuation",
        passed as 1,
        error_message as ""
End Process

Note: Parser unit tests
Process called "run_parser_tests" that takes runner as TestRunner returns Void:
    Display "üå≥ Testing Parser Component"
    Display "---------------------------"

    Note: Test 1: Let statement parsing
    Let test1 be call test_parser_let_statement(runner)
    call record_test_result(runner, test1)

    Note: Test 2: Function call parsing
    Let test2 be call test_parser_function_call(runner)
    call record_test_result(runner, test2)

    Note: Test 3: Binary expression parsing
    Let test3 be call test_parser_binary_expression(runner)
    call record_test_result(runner, test3)

    Note: Test 4: Process definition parsing
    Let test4 be call test_parser_process_definition(runner)
    call record_test_result(runner, test4)
End Process

Process called "test_parser_let_statement" that takes runner as TestRunner returns TestResult:
    Let test_input be "Let x be 42"
    Let tokens be call lexer_tokenize(test_input)

    If tokens is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "Parser Let Statement",
            passed as 0,
            error_message as "Tokenization failed"
    End If

    Let ast be call parser_parse(tokens)
    If ast is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "Parser Let Statement",
            passed as 0,
            error_message as "Parsing failed"
    End If

    Return a value of type TestResult with
        test_name as "Parser Let Statement",
        passed as 1,
        error_message as ""
End Process

Process called "test_parser_function_call" that takes runner as TestRunner returns TestResult:
    Let test_input be "Display \"hello\""
    Let tokens be call lexer_tokenize(test_input)

    If tokens is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "Parser Function Call",
            passed as 0,
            error_message as "Tokenization failed"
    End If

    Let ast be call parser_parse(tokens)
    If ast is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "Parser Function Call",
            passed as 0,
            error_message as "Parsing failed"
    End If

    Return a value of type TestResult with
        test_name as "Parser Function Call",
        passed as 1,
        error_message as ""
End Process

Process called "test_parser_binary_expression" that takes runner as TestRunner returns TestResult:
    Let test_input be "x plus y"
    Let tokens be call lexer_tokenize(test_input)

    If tokens is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "Parser Binary Expression",
            passed as 0,
            error_message as "Tokenization failed"
    End If

    Let ast be call parser_parse(tokens)
    If ast is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "Parser Binary Expression",
            passed as 0,
            error_message as "Parsing failed"
    End If

    Return a value of type TestResult with
        test_name as "Parser Binary Expression",
        passed as 1,
        error_message as ""
End Process

Process called "test_parser_process_definition" that takes runner as TestRunner returns TestResult:
    Let test_input be "Process called \"test\" that takes x as Integer returns Integer: Return x End Process"
    Let tokens be call lexer_tokenize(test_input)

    If tokens is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "Parser Process Definition",
            passed as 0,
            error_message as "Tokenization failed"
    End If

    Let ast be call parser_parse(tokens)
    If ast is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "Parser Process Definition",
            passed as 0,
            error_message as "Parsing failed"
    End If

    Return a value of type TestResult with
        test_name as "Parser Process Definition",
        passed as 1,
        error_message as ""
End Process

Note: Type checker unit tests
Process called "run_typechecker_tests" that takes runner as TestRunner returns Void:
    Display "üîç Testing TypeChecker Component"
    Display "----------------------------------"

    Note: Test 1: Variable type inference
    Let test1 be call test_typechecker_variables(runner)
    call record_test_result(runner, test1)

    Note: Test 2: Function call validation
    Let test2 be call test_typechecker_function_calls(runner)
    call record_test_result(runner, test2)

    Note: Test 3: Type compatibility
    Let test3 be call test_typechecker_compatibility(runner)
    call record_test_result(runner, test3)
End Process

Process called "test_typechecker_variables" that takes runner as TestRunner returns TestResult:
    Let test_input be "Let x be 42 Set x to 24"
    Let tokens be call lexer_tokenize(test_input)
    Let ast be call parser_parse(tokens)

    If ast is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "TypeChecker Variables",
            passed as 0,
            error_message as "Parsing failed"
    End If

    Let type_result be call typechecker_check(ast)
    If type_result is not equal to "OK":
        Return a value of type TestResult with
            test_name as "TypeChecker Variables",
            passed as 0,
            error_message as type_result
    End If

    Return a value of type TestResult with
        test_name as "TypeChecker Variables",
        passed as 1,
        error_message as ""
End Process

Process called "test_typechecker_function_calls" that takes runner as TestRunner returns TestResult:
    Let test_input be "call length_of(\"hello\")"
    Let tokens be call lexer_tokenize(test_input)
    Let ast be call parser_parse(tokens)

    If ast is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "TypeChecker Function Calls",
            passed as 0,
            error_message as "Parsing failed"
    End If

    Let type_result be call typechecker_check(ast)
    If type_result is not equal to "OK":
        Return a value of type TestResult with
            test_name as "TypeChecker Function Calls",
            passed as 0,
            error_message as type_result
    End If

    Return a value of type TestResult with
        test_name as "TypeChecker Function Calls",
        passed as 1,
        error_message as ""
End Process

Process called "test_typechecker_compatibility" that takes runner as TestRunner returns TestResult:
    Let test_input be "Let x be 42 Set x to \"hello\""
    Let tokens be call lexer_tokenize(test_input)
    Let ast be call parser_parse(tokens)

    If ast is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "TypeChecker Compatibility",
            passed as 0,
            error_message as "Parsing failed"
    End If

    Let type_result be call typechecker_check(ast)
    If type_result is equal to "OK":
        Note: This should fail - type mismatch
        Return a value of type TestResult with
            test_name as "TypeChecker Compatibility",
            passed as 0,
            error_message as "Type checker should have caught type mismatch"
    End If

    Return a value of type TestResult with
        test_name as "TypeChecker Compatibility",
        passed as 1,
        error_message as ""
End Process

Note: Code generator unit tests
Process called "run_codegen_tests" that takes runner as TestRunner returns Void:
    Display "‚öôÔ∏è Testing CodeGen Component"
    Display "-----------------------------"

    Note: Test 1: Integer literal generation
    Let test1 be call test_codegen_integer_literal(runner)
    call record_test_result(runner, test1)

    Note: Test 2: Variable assignment generation
    Let test2 be call test_codegen_variable_assignment(runner)
    call record_test_result(runner, test2)

    Note: Test 3: Function call generation
    Let test3 be call test_codegen_function_call(runner)
    call record_test_result(runner, test3)
End Process

Process called "test_codegen_integer_literal" that takes runner as TestRunner returns TestResult:
    Let test_input be "Let x be 42"
    Let tokens be call lexer_tokenize(test_input)
    Let ast be call parser_parse(tokens)

    If ast is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "CodeGen Integer Literal",
            passed as 0,
            error_message as "Parsing failed"
    End If

    Let assembly be call codegen_generate(ast)
    If assembly is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "CodeGen Integer Literal",
            passed as 0,
            error_message as "Code generation failed"
    End If

    Note: Check if assembly contains expected instructions
    If call contains(assembly, "movq $42"):
        Return a value of type TestResult with
            test_name as "CodeGen Integer Literal",
            passed as 1,
            error_message as ""
    Otherwise:
        Return a value of type TestResult with
            test_name as "CodeGen Integer Literal",
            passed as 0,
            error_message as "Generated assembly doesn't contain expected instructions"
    End If
End Process

Process called "test_codegen_variable_assignment" that takes runner as TestRunner returns TestResult:
    Let test_input be "Let x be 42 Set x to 24"
    Let tokens be call lexer_tokenize(test_input)
    Let ast be call parser_parse(tokens)

    If ast is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "CodeGen Variable Assignment",
            passed as 0,
            error_message as "Parsing failed"
    End If

    Let assembly be call codegen_generate(ast)
    If assembly is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "CodeGen Variable Assignment",
            passed as 0,
            error_message as "Code generation failed"
    End If

    Return a value of type TestResult with
        test_name as "CodeGen Variable Assignment",
        passed as 1,
        error_message as ""
End Process

Process called "test_codegen_function_call" that takes runner as TestRunner returns TestResult:
    Let test_input be "Display \"hello\""
    Let tokens be call lexer_tokenize(test_input)
    Let ast be call parser_parse(tokens)

    If ast is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "CodeGen Function Call",
            passed as 0,
            error_message as "Parsing failed"
    End If

    Let assembly be call codegen_generate(ast)
    If assembly is equal to "ERROR":
        Return a value of type TestResult with
            test_name as "CodeGen Function Call",
            passed as 0,
            error_message as "Code generation failed"
    End If

    Note: Check if assembly contains printf call
    If call contains(assembly, "call printf"):
        Return a value of type TestResult with
            test_name as "CodeGen Function Call",
            passed as 1,
            error_message as ""
    Otherwise:
        Return a value of type TestResult with
            test_name as "CodeGen Function Call",
            passed as 0,
            error_message as "Generated assembly doesn't contain expected function call"
    End If
End Process

Note: Test framework utilities
Process called "record_test_result" that takes runner as TestRunner and result as TestResult returns Void:
    Set runner.total_tests to runner.total_tests plus 1

    If result.passed is equal to 1:
        Set runner.passed_tests to runner.passed_tests plus 1
        Let pass_msg be concat("‚úÖ ", result.test_name)
        Display pass_msg
    Otherwise:
        Set runner.failed_tests to runner.failed_tests plus 1
        Let fail_msg be concat("‚ùå ", result.test_name)
        Set fail_msg to concat(fail_msg, ": ")
        Set fail_msg to concat(fail_msg, result.error_message)
        Display fail_msg
    End If
End Process

Process called "print_test_summary" that takes runner as TestRunner returns Void:
    Display ""
    Display "üìä Unit Test Summary"
    Display "===================="

    Let total_msg be concat("Total tests: ", to_string(runner.total_tests))
    Display total_msg

    Let passed_msg be concat("Passed: ", to_string(runner.passed_tests))
    Display passed_msg

    Let failed_msg be concat("Failed: ", to_string(runner.failed_tests))
    Display failed_msg

    If runner.failed_tests is equal to 0:
        Display "üéâ All unit tests passed!"
    Otherwise:
        Display "‚ùå Some tests failed - check implementation"
    End If
End Process