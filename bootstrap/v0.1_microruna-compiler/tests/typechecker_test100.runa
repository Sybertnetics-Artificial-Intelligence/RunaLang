Note: MicroRunaTypeChecker

Note: Global type tracking storage using pipe separated strings
Note: Format variables varname type scope varname2 type2 scope2
Note: Format functions funcname param1 param2 returntype func2 param ret
Note: Format types typename field1 type1 field2 type2 type2 fields
Let global_variables be ""
Let global_functions be ""
Let global_types be ""
Let current_scope be "global"
Let current_function_return be "Void"

Process called "extract_ast_part" that takes ast_data as String, part_index as Integer returns String:
    Note: ExtractASTComponent
    Let current_part be 0
    Let start_pos be 0
    Let i be 0
    Let ast_length be length_of(ast_data)

    While i is less than ast_length:
        Let char_code be char_at(ast_data, i)
        If char_code is equal to 124:
            If current_part is equal to part_index:
                Return substring(ast_data, start_pos, i)
            End If
            Set current_part to current_part plus 1
            Set start_pos to i plus 1
        End If
        Set i to i plus 1
    End While

    If current_part is equal to part_index:
        Return substring(ast_data, start_pos, ast_length)
    End If
    Return ""
End Process

Process called "get_expression_type" that takes expr_ast as String returns String:
    Note: DetermineExpressionType Enhanced with real type inference
    Let ast_type be extract_ast_part(expr_ast, 0)

    If ast_type is equal to "integer_literal":
        Return "Integer"
    End If
    If ast_type is equal to "string_literal":
        Return "String"
    End If
    If ast_type is equal to "identifier":
        Let var_name be extract_ast_part(expr_ast, 1)
        Return lookup_variable_type(var_name)
    End If
    If ast_type is equal to "function_call":
        Return infer_function_return_type(expr_ast)
    End If
    If ast_type is equal to "binary_expression":
        Return check_binary_expression_type(expr_ast)
    End If
    If ast_type is equal to "list_literal":
        Return "List"
    End If
    If ast_type is equal to "struct_creation":
        Let type_name be extract_ast_part(expr_ast, 1)
        Return type_name
    End If
    If ast_type is equal to "field_access":
        Return infer_field_type(expr_ast)
    End If
    If ast_type is equal to "index_access":
        Return infer_index_type(expr_ast)
    End If

    Return "Unknown"
End Process

Process called "check_let_statement" that takes ast as String returns String:
    Note: CheckLetStatement Now tracks variable types
    Let var_name be extract_ast_part(ast, 1)
    Let expr_ast be extract_ast_part(ast, 2)
    Let expr_type be get_expression_type(expr_ast)

    Note: Track the variable type
    call track_variable_type(var_name, expr_type)

    Let result be "let_checked|"
    Set result to concat(result, var_name)
    Set result to concat(result, "|")
    Set result to concat(result, expr_type)
    Return result
End Process

Process called "check_set_statement" that takes ast as String returns String:
    Note: CheckSetStatement Now validates type compatibility
    Let var_name be extract_ast_part(ast, 1)
    Let expr_ast be extract_ast_part(ast, 2)
    Let expr_type be get_expression_type(expr_ast)

    Note: Check if variable exists and types match
    Let existing_type be lookup_variable_type(var_name)
    If existing_type is equal to "Unknown":
        Return report_type_error(concat("Undefined variable ", var_name))
