Note: IntegratedMicroRunaCompiler

Process called "is_letter" that takes char_code as Integer returns Integer:
    Note: CheckIfCharacterIsLetter
    If char_code is greater than 64:
        If char_code is less than 91:
            Return 1
        End If
    End If
    If char_code is greater than 96:
        If char_code is less than 123:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "is_digit" that takes char_code as Integer returns Integer:
    Note: CheckIfCharacterIsDigit
    If char_code is greater than 47:
        If char_code is less than 58:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "is_whitespace" that takes char_code as Integer returns Integer:
    Note: CheckIfCharacterIsWhitespace
    If char_code is equal to 32:
        Return 1
    End If
    If char_code is equal to 9:
        Return 1
    End If
    If char_code is equal to 10:
        Return 1
    End If
    If char_code is equal to 13:
        Return 1
    End If
    Return 0
End Process

Process called "create_token" that takes token_type as String, value as String, line as Integer, column as Integer returns String:
    Note: CreateTokenInPipeFormat
    Let result be token_type
    Set result to concat(result, "|")
    Set result to concat(result, value)
    Set result to concat(result, "|")
    Set result to concat(result, to_string(line))
    Set result to concat(result, "|")
    Set result to concat(result, to_string(column))
    Return result
End Process

Process called "parse_integer" that takes text as String returns Integer:
    Note: ParseStringToInteger
    Let result be 0
    Let i be 0
    Let text_length be length_of(text)

    While i is less than text_length:
        Let current_char be char_at(text, i)
        If is_digit(current_char) is equal to 1:
            Let digit_value be current_char minus 48
            Let multiply_count be 0
            Let temp_result be result
            While multiply_count is less than 9:
                Set result to result plus temp_result
                Set multiply_count to multiply_count plus 1
            End While
            Set result to result plus digit_value
        End If
        Set i to i plus 1
    End While

    Return result
End Process

Process called "extract_word_value" that takes word_result as String returns String:
    Note: ExtractWordFromResult
    Let pipe_pos be 0
    Let result_length be length_of(word_result)

    While pipe_pos is less than result_length:
        Let current_char be char_at(word_result, pipe_pos)
        If current_char is equal to 124:
            Return substring(word_result, 0, pipe_pos)
        End If
        Set pipe_pos to pipe_pos plus 1
    End While

    Return word_result
End Process

Process called "extract_word_position" that takes word_result as String returns Integer:
    Note: ExtractPositionFromResult
    Let pipe_pos be 0
    Let result_length be length_of(word_result)

    While pipe_pos is less than result_length:
        Let current_char be char_at(word_result, pipe_pos)
        If current_char is equal to 124:
            Let position_str be substring(word_result, pipe_pos plus 1, result_length)
            Return parse_integer(position_str)
        End If
        Set pipe_pos to pipe_pos plus 1
    End While

    Return 0
End Process

Process called "read_word" that takes source as String, start_pos as Integer returns String:
    Note: ReadWordFromSource
    Let end_pos be start_pos
    Let source_length be length_of(source)

    While end_pos is less than source_length:
        Let current_char be char_at(source, end_pos)
        If is_letter(current_char) is equal to 1:
            Set end_pos to end_pos plus 1
        End If
        If is_letter(current_char) is equal to 0:
            If is_digit(current_char) is equal to 1:
                Set end_pos to end_pos plus 1
            End If
            If is_digit(current_char) is equal to 0:
                Set end_pos to source_length
            End If
        End If
    End While

    Let word be substring(source, start_pos, end_pos)
    Let result be concat(word, "|")
    Set result to concat(result, to_string(end_pos))
    Return result
End Process

Process called "classify_word" that takes word as String returns String:
    Note: ClassifyWordAsKeyword
    If word is equal to "Process":
        Return "Process"
    End If
    If word is equal to "called":
        Return "Called"
    End If
    If word is equal to "that":
        Return "That"
    End If
    If word is equal to "takes":
        Return "Takes"
    End If
    If word is equal to "as":
        Return "As"
    End If
    If word is equal to "returns":
        Return "Returns"
    End If
    If word is equal to "End":
        Return "End"
    End If
    If word is equal to "Let":
        Return "Let"
    End If
    If word is equal to "be":
        Return "Be"
    End If
    If word is equal to "Set":
        Return "Set"
    End If
    If word is equal to "to":
        Return "To"
    End If
    If word is equal to "If":
        Return "If"
    End If
    If word is equal to "While":
        Return "While"
    End If
    If word is equal to "For":
        Return "For"
    End If
    If word is equal to "Each":
        Return "Each"
    End If
    If word is equal to "in":
        Return "In"
    End If
    If word is equal to "Display":
        Return "Display"
    End If
    If word is equal to "Return":
        Return "Return"
    End If
    If word is equal to "Note":
        Return "Note"
    End If
    If word is equal to "is":
        Return "Is"
    End If
    If word is equal to "equal":
        Return "Equal"
    End If
    If word is equal to "less":
        Return "Less"
    End If
    If word is equal to "than":
        Return "Than"
    End If
    If word is equal to "greater":
        Return "Greater"
    End If
    If word is equal to "plus":
        Return "Plus"
    End If
    If word is equal to "minus":
        Return "Minus"
    End If
    If word is equal to "not":
        Return "Not"
    End If
    Return "Identifier"
End Process

Process called "read_number" that takes source as String, start_pos as Integer returns String:
    Note: ReadNumberFromSource
    Let end_pos be start_pos
    Let source_length be length_of(source)

    While end_pos is less than source_length:
        Let current_char be char_at(source, end_pos)
        If is_digit(current_char) is equal to 1:
            Set end_pos to end_pos plus 1
        End If
        If is_digit(current_char) is equal to 0:
            Set end_pos to source_length
        End If
    End While

    Let number be substring(source, start_pos, end_pos)
    Let result be concat(number, "|")
    Set result to concat(result, to_string(end_pos))
    Return result
End Process

Process called "read_string" that takes source as String, start_pos as Integer returns String:
    Note: ReadStringFromSource
    Let end_pos be start_pos plus 1
    Let source_length be length_of(source)

    While end_pos is less than source_length:
        Let current_char be char_at(source, end_pos)
        If current_char is equal to 34:
            Let string_content be substring(source, start_pos plus 1, end_pos)
            Let result be concat(string_content, "|")
            Set result to concat(result, to_string(end_pos plus 1))
            Return result
        End If
        Set end_pos to end_pos plus 1
    End While

    Let result be "|"
    Set result to concat(result, to_string(source_length))
    Return result
End Process

Process called "append_token" that takes tokens as String, new_token as String returns String:
    Note: AppendTokenToList
    If length_of(tokens) is equal to 0:
        Return new_token
    End If
    Let result be concat(tokens, "\n")
    Set result to concat(result, new_token)
    Return result
End Process

Process called "tokenize_input" that takes source as String returns String:
    Note: TokenizeSourceCode
    Let tokens be ""
    Let position be 0
    Let line be 1
    Let column be 1
    Let source_length be length_of(source)

    While position is less than source_length:
        Let current_char be char_at(source, position)

        If is_whitespace(current_char) is equal to 1:
            If current_char is equal to 10:
                Set line to line plus 1
                Set column to 1
            End If
            If current_char is not equal to 10:
                Set column to column plus 1
            End If
            Set position to position plus 1
        End If

        If is_whitespace(current_char) is equal to 0:
            If is_letter(current_char) is equal to 1:
                Let word_result be read_word(source, position)
                Let word be extract_word_value(word_result)
                Let new_position be extract_word_position(word_result)
                Let token_type be classify_word(word)
                Let token be create_token(token_type, word, line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus length_of(word)
                Set position to new_position
            End If

            If is_digit(current_char) is equal to 1:
                Let number_result be read_number(source, position)
                Let number be extract_word_value(number_result)
                Let new_position be extract_word_position(number_result)
                Let token be create_token("Integer", number, line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus length_of(number)
                Set position to new_position
            End If

            If current_char is equal to 34:
                Let string_result be read_string(source, position)
                Let string_value be extract_word_value(string_result)
                Let new_position be extract_word_position(string_result)
                Let token be create_token("StringLiteral", string_value, line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus length_of(string_value) plus 2
                Set position to new_position
            End If

            If current_char is equal to 58:
                Let token be create_token("Colon", ":", line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus 1
                Set position to position plus 1
            End If

            If current_char is equal to 44:
                Let token be create_token("Comma", ",", line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus 1
                Set position to position plus 1
            End If

            If current_char is equal to 40:
                Let token be create_token("LeftParen", "(", line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus 1
                Set position to position plus 1
            End If

            If current_char is equal to 41:
                Let token be create_token("RightParen", ")", line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus 1
                Set position to position plus 1
            End If

            If is_letter(current_char) is equal to 0:
                If is_digit(current_char) is equal to 0:
                    If current_char is not equal to 34:
                        If current_char is not equal to 58:
                            If current_char is not equal to 44:
                                If current_char is not equal to 40:
                                    If current_char is not equal to 41:
                                        Set position to position plus 1
                                        Set column to column plus 1
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            End If
        End If
    End While

    Return tokens
End Process

Process called "compile_simple_program" that takes source_code as String returns String:
    Note: CompileSimpleProgram
    Let tokens be tokenize_input(source_code)
    Let assembly_header be ".text\n.global _start\n_start:\n"
    Let assembly_footer be "    mov $60, %rax\n    mov $0, %rdi\n    syscall\n"
    Let result be concat(assembly_header, "    # Compiled from MicroRuna\n")
    Set result to concat(result, assembly_footer)
    Return result
End Process