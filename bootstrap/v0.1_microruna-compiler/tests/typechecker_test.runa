Note: MicroRunaTypeChecker

Note: Global type tracking storage using pipe separated strings
Note: Format variables varname type scope varname2 type2 scope2
Note: Format functions funcname param1 param2 returntype func2 param ret
Note: Format types typename field1 type1 field2 type2 type2 fields
Let global_variables be ""
Let global_functions be ""
Let global_types be ""
Let current_scope be "global"
Let current_function_return be "Void"

Process called "extract_ast_part" that takes ast_data as String, part_index as Integer returns String:
    Note: ExtractASTComponent
    Let current_part be 0
    Let start_pos be 0
    Let i be 0
    Let ast_length be length_of(ast_data)

    While i is less than ast_length:
        Let char_code be char_at(ast_data, i)
        If char_code is equal to 124:
            If current_part is equal to part_index:
                Return substring(ast_data, start_pos, i)
            End If
            Set current_part to current_part plus 1
            Set start_pos to i plus 1
        End If
        Set i to i plus 1
    End While

    If current_part is equal to part_index:
        Return substring(ast_data, start_pos, ast_length)
    End If
    Return ""
End Process

Process called "get_expression_type" that takes expr_ast as String returns String:
    Note: DetermineExpressionType Enhanced with real type inference
    Let ast_type be extract_ast_part(expr_ast, 0)

    If ast_type is equal to "integer_literal":
        Return "Integer"
    End If
    If ast_type is equal to "string_literal":
        Return "String"
    End If
    If ast_type is equal to "identifier":
        Let var_name be extract_ast_part(expr_ast, 1)
        Return lookup_variable_type(var_name)
    End If
    If ast_type is equal to "function_call":
        Return infer_function_return_type(expr_ast)
    End If
    If ast_type is equal to "binary_expression":
        Return check_binary_expression_type(expr_ast)
    End If
    If ast_type is equal to "list_literal":
        Return "List"
    End If
    If ast_type is equal to "struct_creation":
        Let type_name be extract_ast_part(expr_ast, 1)
        Return type_name
    End If
    If ast_type is equal to "field_access":
        Return infer_field_type(expr_ast)
    End If
    If ast_type is equal to "index_access":
        Return infer_index_type(expr_ast)
    End If

    Return "Unknown"
End Process

Process called "check_let_statement" that takes ast as String returns String:
    Note: CheckLetStatement Now tracks variable types
    Let var_name be extract_ast_part(ast, 1)
    Let expr_ast be extract_ast_part(ast, 2)
    Let expr_type be get_expression_type(expr_ast)

    Note: Track the variable type
    call track_variable_type(var_name, expr_type)

    Let result be "let_checked|"
    Set result to concat(result, var_name)
    Set result to concat(result, "|")
    Set result to concat(result, expr_type)
    Return result
End Process

Process called "check_set_statement" that takes ast as String returns String:
    Note: CheckSetStatement Now validates type compatibility
    Let var_name be extract_ast_part(ast, 1)
    Let expr_ast be extract_ast_part(ast, 2)
    Let expr_type be get_expression_type(expr_ast)

    Note: Check if variable exists and types match
    Let existing_type be lookup_variable_type(var_name)
    If existing_type is equal to "Unknown":
        Return report_type_error(concat("Undefined variable: ", var_name))
    End If

    If existing_type is not equal to expr_type:
        Return report_type_error(concat("Type mismatch for ", concat(var_name, concat(": expected ", concat(existing_type, concat(" got ", expr_type))))))
    End If

    Let result be "set_checked|"
    Set result to concat(result, var_name)
    Set result to concat(result, "|")
    Set result to concat(result, expr_type)
    Return result
End Process

Process called "check_display_statement" that takes ast as String returns String:
    Note: CheckDisplayStatement
    Let expr_ast be extract_ast_part(ast, 1)
    Let expr_type be get_expression_type(expr_ast)
    Let result be "display_checked|"
    Set result to concat(result, expr_type)
    Return result
End Process

Process called "check_return_statement" that takes ast as String returns String:
    Note: CheckReturnStatement
    Let expr_ast be extract_ast_part(ast, 1)
    Let expr_type be get_expression_type(expr_ast)
    Let result be "return_checked|"
    Set result to concat(result, expr_type)
    Return result
End Process

Process called "check_statement" that takes ast as String returns String:
    Note: CheckSingleStatement Enhanced with full statement support
    Let stmt_type be extract_ast_part(ast, 0)

    If stmt_type is equal to "let_statement":
        Return check_let_statement(ast)
    End If
    If stmt_type is equal to "set_statement":
        Return check_set_statement(ast)
    End If
    If stmt_type is equal to "display_statement":
        Return check_display_statement(ast)
    End If
    If stmt_type is equal to "return_statement":
        Return check_return_statement(ast)
    End If
    If stmt_type is equal to "note_statement":
        Return "note_checked|comment"
    End If
    If stmt_type is equal to "if_statement":
        Return check_if_statement(ast)
    End If
    If stmt_type is equal to "while_statement":
        Return check_while_statement(ast)
    End If
    If stmt_type is equal to "process_definition":
        Return check_process_definition(ast)
    End If
    If stmt_type is equal to "type_definition":
        Return check_type_definition(ast)
    End If
    If stmt_type is equal to "function_call":
        Return validate_function_call(ast)
    End If

    Return "unknown_statement_checked"
End Process

Process called "check_types" that takes ast as String returns String:
    Note: MainTypeCheckingEntry Enhanced with initialization
    Note: Initialize builtin functions on first run
    If length_of(global_functions) is equal to 0:
        call initialize_builtins()
    End If

    Let ast_type be extract_ast_part(ast, 0)

    If ast_type is equal to "program":
        Let statements be extract_ast_part(ast, 1)
        Return "program_checked|validated"
    End If

    Return check_statement(ast)
End Process

Process called "validate_expression_type" that takes expr_type as String, expected_type as String returns Integer:
    Note: ValidateExpressionType
    If expr_type is equal to expected_type:
        Return 1
    End If
    If expr_type is equal to "Integer":
        If expected_type is equal to "String":
            Return 0
        End If
    End If
    Return 0
End Process

Process called "initialize_builtins" that takes nothing:
