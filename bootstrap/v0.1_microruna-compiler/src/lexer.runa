Note: MicroRuna Lexer built incrementally for v0.0 compatibility

Process called "is_letter" that takes char_code as Integer returns Integer:
    Note: Check if character is a letter
    If char_code is greater than 64:
        If char_code is less than 91:
            Return 1
        End If
    End If
    If char_code is greater than 96:
        If char_code is less than 123:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "is_digit" that takes char_code as Integer returns Integer:
    Note: Check if character is a digit 0 through 9
    If char_code is greater than 47:
        If char_code is less than 58:
            Return 1
        End If
    End If
    Return 0
End Process

Process called "is_whitespace" that takes char_code as Integer returns Integer:
    Note: Check if character is whitespace space tab newline
    If char_code is equal to 32:
        Return 1
    End If
    If char_code is equal to 9:
        Return 1
    End If
    If char_code is equal to 10:
        Return 1
    End If
    If char_code is equal to 13:
        Return 1
    End If
    Return 0
End Process

Process called "create_token" that takes token_type as String, value as String, line as Integer, column as Integer returns String:
    Note: Create token string in pipe separated format
    Let result be token_type
    Set result to concat(result, "|")
    Set result to concat(result, value)
    Set result to concat(result, "|")
    Set result to concat(result, to_string(line))
    Set result to concat(result, "|")
    Set result to concat(result, to_string(column))
    Return result
End Process

Process called "parse_integer" that takes text as String returns Integer:
    Note: Manually parse string digits to integer value using repeated addition
    Let result be 0
    Let i be 0
    Let text_length be length_of(text)

    While i is less than text_length:
        Let current_char be char_at(text, i)
        If is_digit(current_char) is equal to 1:
            Let digit_value be current_char minus 48
            Let multiply_count be 0
            Let temp_result be result
            While multiply_count is less than 9:
                Set result to result plus temp_result
                Set multiply_count to multiply_count plus 1
            End While
            Set result to result plus digit_value
        End If
        Set i to i plus 1
    End While

    Return result
End Process

Process called "extract_word_value" that takes word_result as String returns String:
    Note: Extract word value from pipe separated result
    Let pipe_pos be 0
    Let result_length be length_of(word_result)

    While pipe_pos is less than result_length:
        Let current_char be char_at(word_result, pipe_pos)
        If current_char is equal to 124:
            Return substring(word_result, 0, pipe_pos)
        End If
        Set pipe_pos to pipe_pos plus 1
    End While

    Return word_result
End Process

Process called "extract_word_position" that takes word_result as String returns Integer:
    Note: Extract new position from pipe separated result
    Let pipe_pos be 0
    Let result_length be length_of(word_result)

    While pipe_pos is less than result_length:
        Let current_char be char_at(word_result, pipe_pos)
        If current_char is equal to 124:
            Let position_str be substring(word_result, pipe_pos plus 1, result_length)
            Return parse_integer(position_str)
        End If
        Set pipe_pos to pipe_pos plus 1
    End While

    Return 0
End Process

Process called "read_word" that takes source as String, start_pos as Integer returns String:
    Note: Read word from source starting at position and return word with new position
    Let end_pos be start_pos
    Let source_length be length_of(source)

    While end_pos is less than source_length:
        Let current_char be char_at(source, end_pos)
        If is_letter(current_char) is equal to 1:
            Set end_pos to end_pos plus 1
        End If
        If is_letter(current_char) is equal to 0:
            If is_digit(current_char) is equal to 1:
                Set end_pos to end_pos plus 1
            End If
            If is_digit(current_char) is equal to 0:
                Set end_pos to source_length
            End If
        End If
    End While

    Let word be substring(source, start_pos, end_pos)
    Let result be concat(word, "|")
    Set result to concat(result, to_string(end_pos))
    Return result
End Process

Process called "peek_next_word" that takes source as String, position as Integer returns String:
    Note: Peek at the next word without advancing position
    Let start_pos be position
    Let source_length be length_of(source)

    Note: Skip whitespace
    While start_pos is less than source_length:
        Let current_char be char_at(source, start_pos)
        If is_whitespace(current_char) is equal to 0:
            Set start_pos to source_length
        End If
        If is_whitespace(current_char) is equal to 1:
            Set start_pos to start_pos plus 1
        End If
    End While

    If start_pos is equal to source_length:
        Return ""
    End If

    Note: Read the word
    Let end_pos be start_pos
    While end_pos is less than source_length:
        Let current_char be char_at(source, end_pos)
        If is_letter(current_char) is equal to 1:
            Set end_pos to end_pos plus 1
        End If
        If is_letter(current_char) is equal to 0:
            Set end_pos to source_length
        End If
    End While

    Return substring(source, start_pos, end_pos)
End Process

Process called "classify_word_with_context" that takes word as String, source as String, position as Integer returns String:
    Note: Classify word as keyword or identifier with lookahead for compound tokens
    If word is equal to "is":
        Let next_word be peek_next_word(source, position)
        If next_word is equal to "equal":
            Let pos_after_equal be position plus length_of(next_word) plus 1
            Let word_after_equal be peek_next_word(source, pos_after_equal)
            If word_after_equal is equal to "to":
                Return "IsEqualTo|3"
            End If
        End If
        If next_word is equal to "not":
            Let pos_after_not be position plus length_of(next_word) plus 1
            Let word_after_not be peek_next_word(source, pos_after_not)
            If word_after_not is equal to "equal":
                Let pos_after_equal be pos_after_not plus length_of(word_after_not) plus 1
                Let word_after_equal be peek_next_word(source, pos_after_equal)
                If word_after_equal is equal to "to":
                    Return "IsNotEqualTo|4"
                End If
            End If
        End If
        If next_word is equal to "less":
            Let pos_after_less be position plus length_of(next_word) plus 1
            Let word_after_less be peek_next_word(source, pos_after_less)
            If word_after_less is equal to "than":
                Return "IsLessThan|3"
            End If
        End If
        If next_word is equal to "greater":
            Let pos_after_greater be position plus length_of(next_word) plus 1
            Let word_after_greater be peek_next_word(source, pos_after_greater)
            If word_after_greater is equal to "than":
                Return "IsGreaterThan|3"
            End If
        End If
        Return "Is"
    End If
    Return classify_word(word)
End Process

Process called "classify_word" that takes word as String returns String:
    Note: Classify word as keyword or identifier
    If word is equal to "Process":
        Return "Process"
    End If
    If word is equal to "called":
        Return "Called"
    End If
    If word is equal to "that":
        Return "That"
    End If
    If word is equal to "takes":
        Return "Takes"
    End If
    If word is equal to "as":
        Return "As"
    End If
    If word is equal to "returns":
        Return "Returns"
    End If
    If word is equal to "End":
        Return "End"
    End If
    If word is equal to "Let":
        Return "Let"
    End If
    If word is equal to "be":
        Return "Be"
    End If
    If word is equal to "Set":
        Return "Set"
    End If
    If word is equal to "to":
        Return "To"
    End If
    If word is equal to "If":
        Return "If"
    End If
    If word is equal to "While":
        Return "While"
    End If
    If word is equal to "Otherwise":
        Return "Otherwise"
    End If
    If word is equal to "For":
        Return "For"
    End If
    If word is equal to "Each":
        Return "Each"
    End If
    If word is equal to "in":
        Return "In"
    End If
    If word is equal to "Display":
        Return "Display"
    End If
    If word is equal to "Return":
        Return "Return"
    End If
    If word is equal to "Note":
        Return "Note"
    End If
    If word is equal to "Type":
        Return "Type"
    End If
    If word is equal to "list":
        Return "List"
    End If
    If word is equal to "containing":
        Return "Containing"
    End If
    If word is equal to "and":
        Return "And"
    End If
    If word is equal to "at":
        Return "At"
    End If
    If word is equal to "index":
        Return "Index"
    End If
    If word is equal to "key":
        Return "Key"
    End If
    If word is equal to "is":
        Return "Is"
    End If
    If word is equal to "equal":
        Return "Equal"
    End If
    If word is equal to "less":
        Return "Less"
    End If
    If word is equal to "than":
        Return "Than"
    End If
    If word is equal to "greater":
        Return "Greater"
    End If
    If word is equal to "plus":
        Return "Plus"
    End If
    If word is equal to "minus":
        Return "Minus"
    End If
    If word is equal to "not":
        Return "Not"
    End If
    If word is equal to "of":
        Return "Of"
    End If
    If word is equal to "a":
        Return "A"
    End If
    If word is equal to "value":
        Return "Value"
    End If
    If word is equal to "type":
        Return "TypeKeyword"
    End If
    If word is equal to "with":
        Return "With"
    End If
    If word is equal to "call":
        Return "Call"
    End If
    Return "Identifier"
End Process

Process called "read_number" that takes source as String, start_pos as Integer returns String:
    Note: Read number from source starting at position
    Let end_pos be start_pos
    Let source_length be length_of(source)

    While end_pos is less than source_length:
        Let current_char be char_at(source, end_pos)
        If is_digit(current_char) is equal to 1:
            Set end_pos to end_pos plus 1
        End If
        If is_digit(current_char) is equal to 0:
            Set end_pos to source_length
        End If
    End While

    Let number be substring(source, start_pos, end_pos)
    Let result be concat(number, "|")
    Set result to concat(result, to_string(end_pos))
    Return result
End Process

Process called "read_string" that takes source as String, start_pos as Integer returns String:
    Note: Read string literal from source starting at quote with escape sequence handling
    Let end_pos be start_pos plus 1
    Let source_length be length_of(source)
    Let processed_string be ""

    While end_pos is less than source_length:
        Let current_char be char_at(source, end_pos)

        Note: Check for escape sequence
        If current_char is equal to 92:
            Note: Backslash found, check next character
            If end_pos plus 1 is less than source_length:
                Let next_char be char_at(source, end_pos plus 1)

                Note: Process escape sequences
                If next_char is equal to 110:
                    Note: \n - newline
                    Let newline_char be 10
                    Set processed_string to concat(processed_string, substring(source, end_pos plus 1, end_pos plus 2))
                    Set processed_string to substring(processed_string, 0, length_of(processed_string) minus 1)
                    Note: Append actual newline character (ASCII 10)
                    Set end_pos to end_pos plus 2
                End If

                If next_char is equal to 116:
                    Note: \t - tab
                    Let tab_char be 9
                    Set processed_string to concat(processed_string, substring(source, end_pos plus 1, end_pos plus 2))
                    Set processed_string to substring(processed_string, 0, length_of(processed_string) minus 1)
                    Note: Append actual tab character (ASCII 9)
                    Set end_pos to end_pos plus 2
                End If

                If next_char is equal to 114:
                    Note: \r - carriage return
                    Let cr_char be 13
                    Set processed_string to concat(processed_string, substring(source, end_pos plus 1, end_pos plus 2))
                    Set processed_string to substring(processed_string, 0, length_of(processed_string) minus 1)
                    Note: Append actual CR character (ASCII 13)
                    Set end_pos to end_pos plus 2
                End If

                If next_char is equal to 92:
                    Note: \\ - backslash
                    Set processed_string to concat(processed_string, substring(source, end_pos plus 1, end_pos plus 2))
                    Set end_pos to end_pos plus 2
                End If

                If next_char is equal to 34:
                    Note: \" - quote
                    Set processed_string to concat(processed_string, substring(source, end_pos plus 1, end_pos plus 2))
                    Set end_pos to end_pos plus 2
                End If

                Note: If no recognized escape sequence, include backslash as-is
                If next_char is not equal to 110:
                    If next_char is not equal to 116:
                        If next_char is not equal to 114:
                            If next_char is not equal to 92:
                                If next_char is not equal to 34:
                                    Set processed_string to concat(processed_string, substring(source, end_pos, end_pos plus 1))
                                    Set end_pos to end_pos plus 1
                                End If
                            End If
                        End If
                    End If
                End If
            End If

            If end_pos plus 1 is equal to source_length:
                Set processed_string to concat(processed_string, substring(source, end_pos, end_pos plus 1))
                Set end_pos to end_pos plus 1
            End If
        End If

        Note: Check for closing quote
        If current_char is equal to 34:
            If current_char is not equal to 92:
                Let result be concat(processed_string, "|")
                Set result to concat(result, to_string(end_pos plus 1))
                Return result
            End If
        End If

        Note: Regular character
        If current_char is not equal to 92:
            If current_char is not equal to 34:
                Set processed_string to concat(processed_string, substring(source, end_pos, end_pos plus 1))
                Set end_pos to end_pos plus 1
            End If
        End If
    End While

    Note: Unterminated string
    Let result be concat(processed_string, "|")
    Set result to concat(result, to_string(source_length))
    Return result
End Process

Process called "append_token" that takes tokens as String, new_token as String returns String:
    Note: Append new token to token list with newline separator
    If length_of(tokens) is equal to 0:
        Return new_token
    End If
    Let result be concat(tokens, "\n")
    Set result to concat(result, new_token)
    Return result
End Process

Process called "tokenize_input" that takes source as String returns String:
    Note: Full tokenization implementation that scans source and generates tokens
    Let tokens be ""
    Let position be 0
    Let line be 1
    Let column be 1
    Let source_length be length_of(source)

    While position is less than source_length:
        Let current_char be char_at(source, position)

        If is_whitespace(current_char) is equal to 1:
            If current_char is equal to 10:
                Set line to line plus 1
                Set column to 1
            End If
            If current_char is not equal to 10:
                Set column to column plus 1
            End If
            Set position to position plus 1
        End If

        If is_whitespace(current_char) is equal to 0:
            If is_letter(current_char) is equal to 1:
                Let word_result be read_word(source, position)
                Let word be extract_word_value(word_result)
                Let new_position be extract_word_position(word_result)
                Let classification_result be classify_word_with_context(word, source, new_position)

                Note: Check if it's a compound token
                Let pipe_pos be 0
                Let has_pipe be 0
                Let result_length be length_of(classification_result)
                While pipe_pos is less than result_length:
                    If char_at(classification_result, pipe_pos) is equal to 124:
                        Set has_pipe to 1
                        Set pipe_pos to result_length
                    End If
                    Set pipe_pos to pipe_pos plus 1
                End While

                If has_pipe is equal to 1:
                    Note: It's a compound token, extract token type and word count
                    Let token_type be extract_word_value(classification_result)
                    Let word_count_str be extract_word_position(classification_result)
                    Let word_count be parse_integer(word_count_str)

                    Note: Build the compound value
                    Let compound_value be word
                    Let words_consumed be 1
                    Let temp_pos be new_position
                    While words_consumed is less than word_count:
                        Let next_word be peek_next_word(source, temp_pos)
                        Set compound_value to concat(compound_value, " ")
                        Set compound_value to concat(compound_value, next_word)

                        Note: Advance temp_pos past the next word
                        Let advance_amount be length_of(next_word) plus 1
                        Set temp_pos to temp_pos plus advance_amount
                        Set words_consumed to words_consumed plus 1
                    End While

                    Let token be create_token(token_type, compound_value, line, column)
                    Set tokens to append_token(tokens, token)
                    Set column to column plus length_of(compound_value)
                    Set position to temp_pos
                End If

                If has_pipe is equal to 0:
                    Let token_type be classification_result
                    Let token be create_token(token_type, word, line, column)
                    Set tokens to append_token(tokens, token)
                    Set column to column plus length_of(word)
                    Set position to new_position
                End If
            End If

            If is_digit(current_char) is equal to 1:
                Let number_result be read_number(source, position)
                Let number be extract_word_value(number_result)
                Let new_position be extract_word_position(number_result)
                Let token be create_token("Integer", number, line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus length_of(number)
                Set position to new_position
            End If

            If current_char is equal to 34:
                Let string_result be read_string(source, position)
                Let string_value be extract_word_value(string_result)
                Let new_position be extract_word_position(string_result)
                Let token be create_token("StringLiteral", string_value, line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus length_of(string_value) plus 2
                Set position to new_position
            End If

            If current_char is equal to 58:
                Let token be create_token("Colon", ":", line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus 1
                Set position to position plus 1
            End If

            If current_char is equal to 44:
                Let token be create_token("Comma", ",", line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus 1
                Set position to position plus 1
            End If

            If current_char is equal to 40:
                Let token be create_token("LeftParen", "(", line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus 1
                Set position to position plus 1
            End If

            If current_char is equal to 41:
                Let token be create_token("RightParen", ")", line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus 1
                Set position to position plus 1
            End If

            If current_char is equal to 46:
                Let token be create_token("Dot", ".", line, column)
                Set tokens to append_token(tokens, token)
                Set column to column plus 1
                Set position to position plus 1
            End If

            If is_letter(current_char) is equal to 0:
                If is_digit(current_char) is equal to 0:
                    If current_char is not equal to 34:
                        If current_char is not equal to 58:
                            If current_char is not equal to 44:
                                If current_char is not equal to 40:
                                    If current_char is not equal to 41:
                                        If current_char is not equal to 46:
                                            Set position to position plus 1
                                            Set column to column plus 1
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            End If
        End If
    End While

    Note: Add EOF token
    Let eof_token be create_token("EOF", "", line, column)
    Set tokens to append_token(tokens, eof_token)

    Return tokens
End Process