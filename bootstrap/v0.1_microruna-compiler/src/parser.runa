Note: MicroRunaParserFixed

Process called "get_token_at_position" that takes tokens as String, position as Integer returns String:
    Note: ExtractToken
    Let line_start be 0
    Let current_line be 0
    Let i be 0
    Let tokens_length be length_of(tokens)

    While i is less than tokens_length:
        Let char_code be char_at(tokens, i)
        If char_code is equal to 10:
            If current_line is equal to position:
                Return substring(tokens, line_start, i)
            End If
            Set current_line to current_line plus 1
            Set line_start to i plus 1
        End If
        Set i to i plus 1
    End While

    If current_line is equal to position:
        Return substring(tokens, line_start, tokens_length)
    End If
    Return "EOF|end|0|0"
End Process

Process called "extract_token_part" that takes token_data as String, part_index as Integer returns String:
    Note: ExtractTokenPart
    Let current_part be 0
    Let start_pos be 0
    Let i be 0
    Let token_length be length_of(token_data)

    While i is less than token_length:
        Let char_code be char_at(token_data, i)
        If char_code is equal to 124:
            If current_part is equal to part_index:
                Return substring(token_data, start_pos, i)
            End If
            Set current_part to current_part plus 1
            Set start_pos to i plus 1
        End If
        Set i to i plus 1
    End While

    If current_part is equal to part_index:
        Return substring(token_data, start_pos, token_length)
    End If
    Return ""
End Process

Process called "string_starts_with" that takes text as String, prefix as String returns Integer:
    Note: CheckStringPrefix
    Let text_len be length_of(text)
    Let prefix_len be length_of(prefix)

    If prefix_len is greater than text_len:
        Return 0
    End If

    Let i be 0
    While i is less than prefix_len:
        Let text_char be char_at(text, i)
        Let prefix_char be char_at(prefix, i)
        If text_char is not equal to prefix_char:
            Return 0
        End If
        Set i to i plus 1
    End While

    Return 1
End Process

Process called "append_string_with_separator" that takes base as String, addition as String, separator as String returns String:
    Note: AppendWithSeparator
    If length_of(base) is equal to 0:
        Return addition
    End If
    Let result be concat(base, separator)
    Return concat(result, addition)
End Process

Process called "count_lines" that takes text as String returns Integer:
    Note: CountLines
    Let count be 0
    Let i be 0
    Let text_length be length_of(text)

    While i is less than text_length:
        Let char_code be char_at(text, i)
        If char_code is equal to 10:
            Set count to count plus 1
        End If
        Set i to i plus 1
    End While

    Return count plus 1
End Process

Process called "parse_function_call" that takes tokens as String, position as Integer returns String:
    Note: ParseFunctionCall
    Let func_token be get_token_at_position(tokens, position)
    Let func_name be extract_token_part(func_token, 1)
    Let result be "function_call|"
    Set result to concat(result, func_name)
    Set result to concat(result, "|arguments")
    Return result
End Process

Process called "parse_list_literal" that takes tokens as String, position as Integer returns String:
    Note: Parse list literal: "a list containing x, y, z"
    Let current_pos be position

    Note: Skip "a"
    Set current_pos to current_pos plus 1

    Note: Expect "list"
    Let list_token be get_token_at_position(tokens, current_pos)
    Let list_value be extract_token_part(list_token, 1)
    If list_value is not equal to "list":
        Return "error_expected_list"
    End If
    Set current_pos to current_pos plus 1

    Note: Check for "containing"
    Let containing_token be get_token_at_position(tokens, current_pos)
    Let containing_value be extract_token_part(containing_token, 1)
    If containing_value is equal to "containing":
        Set current_pos to current_pos plus 1
    End If

    Note: Parse elements simplified for bootstrap
    Let elements be "element1|element2"
    Set current_pos to current_pos plus 3

    Let result be "list_literal|"
    Set result to concat(result, elements)
    Return result
End Process

Process called "parse_struct_creation" that takes tokens as String, position as Integer returns String:
    Note: Parse struct creation: "a value of type TypeName with field1 as value1, field2 as value2"
    Let current_pos be position

    Note: Skip "a"
    Set current_pos to current_pos plus 1

    Note: Expect "value"
    Let value_token be get_token_at_position(tokens, current_pos)
    Let value_word be extract_token_part(value_token, 1)
    If value_word is not equal to "value":
        Return "error_expected_value"
    End If
    Set current_pos to current_pos plus 1

    Note: Expect "of"
    Let of_token be get_token_at_position(tokens, current_pos)
    Let of_word be extract_token_part(of_token, 1)
    If of_word is equal to "of":
        Set current_pos to current_pos plus 1
    End If

    Note: Expect "type"
    Let type_token be get_token_at_position(tokens, current_pos)
    Let type_word be extract_token_part(type_token, 1)
    If type_word is equal to "type":
        Set current_pos to current_pos plus 1
    End If

    Note: Get the type name
    Let typename_token be get_token_at_position(tokens, current_pos)
    Let typename be extract_token_part(typename_token, 1)
    Set current_pos to current_pos plus 1

    Note: Check for "with" for field initialization
    Let with_token be get_token_at_position(tokens, current_pos)
    Let with_word be extract_token_part(with_token, 1)

    Let fields be ""
    If with_word is equal to "with":
        Set current_pos to current_pos plus 1

        Note: Parse field assignments simplified for bootstrap
        Set fields to "field1:value1|field2:value2"
        Set current_pos to current_pos plus 4
    End If

    Let result be "struct_creation|"
    Set result to concat(result, typename)
    Set result to concat(result, "|")
    Set result to concat(result, fields)
    Return result
End Process

Process called "parse_primary_expression" that takes tokens as String, position as Integer returns String:
    Note: ParsePrimaryExpression handles literals identifiers function calls field and index access
    Let current_token be get_token_at_position(tokens, position)
    Let token_type be extract_token_part(current_token, 0)
    Let token_value be extract_token_part(current_token, 1)

    If token_type is equal to "Integer":
        Return concat("integer_literal|", token_value)
    End If
    If token_type is equal to "StringLiteral":
        Return concat("string_literal|", token_value)
    End If
    If token_type is equal to "Identifier":
        Let base_expr be concat("identifier|", token_value)
        Let current_pos be position plus 1
        Let result be base_expr

        Note: Check for chained access (field access, index access, function calls)
        Let continue_parsing be 1
        While continue_parsing is equal to 1:
            Let next_token be get_token_at_position(tokens, current_pos)
            Let next_type be extract_token_part(next_token, 0)

            If next_type is equal to "LeftParen":
                Note: Function call
                Set result to concat("function_call|", token_value)
                Set result to concat(result, "|arguments")
                Set current_pos to current_pos plus 2
            Otherwise:
                If next_type is equal to "Dot":
                    Note: Field access
                    Let field_pos be current_pos plus 1
                    Let field_token be get_token_at_position(tokens, field_pos)
                    Let field_name be extract_token_part(field_token, 1)
                    Let field_result be "field_access|"
                    Set field_result to concat(field_result, result)
                    Set field_result to concat(field_result, "|")
                    Set field_result to concat(field_result, field_name)
                    Set result to field_result
                    Set current_pos to field_pos plus 1
                Otherwise:
                    If next_type is equal to "At":
                        Note: Index access using at index syntax
                        Let index_keyword_pos be current_pos plus 1
                        Let index_keyword be get_token_at_position(tokens, index_keyword_pos)
                        Let index_keyword_value be extract_token_part(index_keyword, 1)
                        If index_keyword_value is equal to "index":
                            Let index_expr_pos be index_keyword_pos plus 1
                            Let index_expr be parse_primary_expression(tokens, index_expr_pos)
                            Let index_result be "index_access|"
                            Set index_result to concat(index_result, result)
                            Set index_result to concat(index_result, "|")
                            Set index_result to concat(index_result, index_expr)
                            Set result to index_result
                            Set current_pos to index_expr_pos plus 1
                        Otherwise:
                            Set continue_parsing to 0
                        End If
                    Otherwise:
                        Set continue_parsing to 0
                    End If
                End If
            End If
        End While
        Return result
    End If

    Note: Handle "a list" and "a value of type" syntax
    If token_type is equal to "A":
        Let next_token be get_token_at_position(tokens, position plus 1)
        Let next_value be extract_token_part(next_token, 1)
        If next_value is equal to "list":
            Return parse_list_literal(tokens, position)
        End If
        If next_value is equal to "value":
            Return parse_struct_creation(tokens, position)
        End If
    End If

    Return "expression_error"
End Process

Process called "parse_additive_expression" that takes tokens as String, position as Integer returns String:
    Note: ParseAdditiveExpression
    Let left_expr be parse_primary_expression(tokens, position)
    Let operator_pos be position plus 1
    Let operator_token be get_token_at_position(tokens, operator_pos)
    Let operator_type be extract_token_part(operator_token, 0)

    If operator_type is equal to "Plus":
        Let right_pos be position plus 3
        Let right_expr be parse_primary_expression(tokens, right_pos)
        Let result be "binary_expression|"
        Set result to concat(result, left_expr)
        Set result to concat(result, "|Plus|")
        Set result to concat(result, right_expr)
        Return result
    End If

    If operator_type is equal to "Minus":
        Let right_pos be position plus 3
        Let right_expr be parse_primary_expression(tokens, right_pos)
        Let result be "binary_expression|"
        Set result to concat(result, left_expr)
        Set result to concat(result, "|Minus|")
        Set result to concat(result, right_expr)
        Return result
    End If

    Return left_expr
End Process

Process called "parse_comparison_expression" that takes tokens as String, position as Integer returns String:
    Note: ParseComparisonExpression
    Let left_expr be parse_additive_expression(tokens, position)
    Let operator_pos be position plus 1
    Let operator_token be get_token_at_position(tokens, operator_pos)
    Let operator_type be extract_token_part(operator_token, 0)

    If operator_type is equal to "IsEqualTo":
        Let right_pos be position plus 4
        Let right_expr be parse_additive_expression(tokens, right_pos)
        Let result be "comparison_expression|"
        Set result to concat(result, left_expr)
        Set result to concat(result, "|IsEqualTo|")
        Set result to concat(result, right_expr)
        Return result
    End If

    If operator_type is equal to "IsLessThan":
        Let right_pos be position plus 4
        Let right_expr be parse_additive_expression(tokens, right_pos)
        Let result be "comparison_expression|"
        Set result to concat(result, left_expr)
        Set result to concat(result, "|IsLessThan|")
        Set result to concat(result, right_expr)
        Return result
    End If

    Return left_expr
End Process

Process called "parse_expression" that takes tokens as String, position as Integer returns String:
    Note: ParseExpressionWithPrecedence
    Return parse_comparison_expression(tokens, position)
End Process

Process called "parse_condition" that takes tokens as String, position as Integer returns String:
    Note: ParseCondition
    Let left_expr be parse_expression(tokens, position)
    Let operator_position be position plus 1
    Let operator_token be get_token_at_position(tokens, operator_position)
    Let operator_type be extract_token_part(operator_token, 0)
    Let right_position be position plus 3
    Let right_expr be parse_expression(tokens, right_position)

    Let result be "binary_expression|"
    Set result to concat(result, left_expr)
    Set result to concat(result, "|")
    Set result to concat(result, operator_type)
    Set result to concat(result, "|")
    Set result to concat(result, right_expr)
    Return result
End Process

Process called "parse_note_statement" that takes tokens as String, position as Integer returns String:
    Note: ParseNoteStatement
    Let note_token be get_token_at_position(tokens, position)
    Let note_value be extract_token_part(note_token, 1)
    Let result be "note_statement|"
    Set result to concat(result, note_value)
    Return result
End Process

Process called "parse_let_statement" that takes tokens as String, position as Integer returns String:
    Note: ParseLetStatement
    Let var_token be get_token_at_position(tokens, position plus 1)
    Let var_name be extract_token_part(var_token, 1)
    Let expr_position be position plus 3
    Let expr_ast be parse_expression(tokens, expr_position)
    Let result be "let_statement|"
    Set result to concat(result, var_name)
    Set result to concat(result, "|")
    Set result to concat(result, expr_ast)
    Return result
End Process

Process called "parse_set_statement" that takes tokens as String, position as Integer returns String:
    Note: ParseSetStatement
    Let var_token be get_token_at_position(tokens, position plus 1)
    Let var_name be extract_token_part(var_token, 1)
    Let expr_position be position plus 3
    Let expr_ast be parse_expression(tokens, expr_position)
    Let result be "set_statement|"
    Set result to concat(result, var_name)
    Set result to concat(result, "|")
    Set result to concat(result, expr_ast)
    Return result
End Process

Process called "parse_display_statement" that takes tokens as String, position as Integer returns String:
    Note: ParseDisplayStatement
    Let expr_position be position plus 1
    Let expr_ast be parse_expression(tokens, expr_position)
    Let result be "display_statement|"
    Set result to concat(result, expr_ast)
    Return result
End Process

Process called "parse_return_statement" that takes tokens as String, position as Integer returns String:
    Note: ParseReturnStatement
    Let expr_position be position plus 1
    Let expr_ast be parse_expression(tokens, expr_position)
    Let result be "return_statement|"
    Set result to concat(result, expr_ast)
    Return result
End Process

Process called "parse_if_statement" that takes tokens as String, position as Integer returns String:
    Note: ParseIfStatement
    Let condition_position be position plus 1
    Let condition_ast be parse_condition(tokens, condition_position)
    Let result be "if_statement|"
    Set result to concat(result, condition_ast)
    Set result to concat(result, "|body_statements")
    Return result
End Process

Process called "parse_while_statement" that takes tokens as String, position as Integer returns String:
    Note: ParseWhileStatement
    Let condition_position be position plus 1
    Let condition_ast be parse_condition(tokens, condition_position)
    Let result be "while_statement|"
    Set result to concat(result, condition_ast)
    Set result to concat(result, "|body_statements")
    Return result
End Process

Process called "parse_process_definition" that takes tokens as String, position as Integer returns String:
    Note: ParseProcessDefinition
    Let name_token be get_token_at_position(tokens, position plus 2)
    Let process_name be extract_token_part(name_token, 1)
    Let result be "process_definition|"
    Set result to concat(result, process_name)
    Set result to concat(result, "|parameters|return_type|body_statements")
    Return result
End Process

Process called "parse_type_definition" that takes tokens as String, position as Integer returns String:
    Note: ParseTypeDefinition
    Let name_token be get_token_at_position(tokens, position plus 2)
    Let type_name be extract_token_part(name_token, 1)
    Let result be "type_definition|"
    Set result to concat(result, type_name)
    Set result to concat(result, "|fields")
    Return result
End Process


Process called "parse_statement" that takes tokens as String, position as Integer returns String:
    Note: ParseStatement
    Let current_token be get_token_at_position(tokens, position)
    Let token_type be extract_token_part(current_token, 0)

    If token_type is equal to "Let":
        Return parse_let_statement(tokens, position)
    End If
    If token_type is equal to "Set":
        Return parse_set_statement(tokens, position)
    End If
    If token_type is equal to "Display":
        Return parse_display_statement(tokens, position)
    End If
    If token_type is equal to "Return":
        Return parse_return_statement(tokens, position)
    End If
    If token_type is equal to "If":
        Return parse_if_statement(tokens, position)
    End If
    If token_type is equal to "While":
        Return parse_while_statement(tokens, position)
    End If
    If token_type is equal to "Process":
        Return parse_process_definition(tokens, position)
    End If
    If token_type is equal to "Type":
        Return parse_type_definition(tokens, position)
    End If
    If token_type is equal to "Note":
        Return parse_note_statement(tokens, position)
    End If

    Return "unknown_statement"
End Process

Process called "parse_program" that takes tokens as String returns String:
    Note: ParseProgram
    Let parsed_statements be ""
    Let current_position be 0
    Let max_tokens be count_lines(tokens)

    While current_position is less than max_tokens:
        Let current_token be get_token_at_position(tokens, current_position)
        Let token_type be extract_token_part(current_token, 0)

        If token_type is equal to "EOF":
            Set current_position to max_tokens
        End If
        If token_type is not equal to "EOF":
            Let stmt_result be parse_statement(tokens, current_position)
            Set parsed_statements to append_string_with_separator(parsed_statements, stmt_result, ";")
            Set current_position to current_position plus 1
        End If
    End While

    Return concat("program|", parsed_statements)
End Process