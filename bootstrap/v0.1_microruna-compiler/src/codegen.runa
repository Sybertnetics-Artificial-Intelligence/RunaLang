Note: MicroRunaCodeGenerator

Process called "extract_ast_part" that takes ast_data as String, part_index as Integer returns String:
    Note: ExtractASTComponent
    Let current_part be 0
    Let start_pos be 0
    Let i be 0
    Let ast_length be length_of(ast_data)

    While i is less than ast_length:
        Let char_code be char_at(ast_data, i)
        If char_code is equal to 124:
            If current_part is equal to part_index:
                Return substring(ast_data, start_pos, i)
            End If
            Set current_part to current_part plus 1
            Set start_pos to i plus 1
        End If
        Set i to i plus 1
    End While

    If current_part is equal to part_index:
        Return substring(ast_data, start_pos, ast_length)
    End If
    Return ""
End Process

Process called "generate_assembly_header" that returns String:
    Note: GenerateAssemblyHeader
    Let header be ".text\n"
    Set header to concat(header, ".global _start\n")
    Set header to concat(header, "_start:\n")
    Return header
End Process

Process called "generate_assembly_footer" that returns String:
    Note: GenerateAssemblyFooter
    Let footer be "    mov $60, %rax\n"
    Set footer to concat(footer, "    mov $0, %rdi\n")
    Set footer to concat(footer, "    syscall\n")
    Return footer
End Process

Process called "generate_function_call" that takes ast as String returns String:
    Note: GenerateFunctionCall
    Let func_name be extract_ast_part(ast, 1)
    Let args_ast be extract_ast_part(ast, 2)

    Let code be "    # Function call: "
    Set code to concat(code, func_name)
    Set code to concat(code, "\n")
    Set code to concat(code, "    # Push arguments\n")
    Set code to concat(code, "    call ")
    Set code to concat(code, func_name)
    Set code to concat(code, "\n")
    Set code to concat(code, "    # Result in %rax\n")
    Return code
End Process

Process called "generate_expression_code" that takes expr_ast as String returns String:
    Note: GenerateExpressionCode
    Let expr_type be extract_ast_part(expr_ast, 0)

    If expr_type is equal to "integer_literal":
        Let value be extract_ast_part(expr_ast, 1)
        Let code be "    mov $"
        Set code to concat(code, value)
        Set code to concat(code, ", %rax\n")
        Return code
    End If

    If expr_type is equal to "string_literal":
        Let value be extract_ast_part(expr_ast, 1)
        Let code be "    # String literal: "
        Set code to concat(code, value)
        Set code to concat(code, "\n")
        Return code
    End If

    If expr_type is equal to "identifier":
        Let var_name be extract_ast_part(expr_ast, 1)
        Let code be "    # Load variable: "
        Set code to concat(code, var_name)
        Set code to concat(code, "\n")
        Set code to concat(code, "    mov ")
        Set code to concat(code, var_name)
        Set code to concat(code, "(%rip), %rax\n")
        Return code
    End If

    If expr_type is equal to "binary_expression":
        Let left_expr be extract_ast_part(expr_ast, 1)
        Let operator be extract_ast_part(expr_ast, 2)
        Let right_expr be extract_ast_part(expr_ast, 3)

        Let code be generate_expression_code(left_expr)
        Set code to concat(code, "    push %rax\n")
        Let right_code be generate_expression_code(right_expr)
        Set code to concat(code, right_code)
        Set code to concat(code, "    mov %rax, %rbx\n")
        Set code to concat(code, "    pop %rax\n")

        If operator is equal to "Plus":
            Set code to concat(code, "    add %rbx, %rax\n")
        End If
        If operator is equal to "Minus":
            Set code to concat(code, "    sub %rbx, %rax\n")
        End If

        Return code
    End If

    If expr_type is equal to "comparison_expression":
        Let left_expr be extract_ast_part(expr_ast, 1)
        Let operator be extract_ast_part(expr_ast, 2)
        Let right_expr be extract_ast_part(expr_ast, 3)

        Let code be generate_expression_code(left_expr)
        Set code to concat(code, "    push %rax\n")
        Let right_code be generate_expression_code(right_expr)
        Set code to concat(code, right_code)
        Set code to concat(code, "    mov %rax, %rbx\n")
        Set code to concat(code, "    pop %rax\n")
        Set code to concat(code, "    cmp %rbx, %rax\n")

        If operator is equal to "IsEqualTo":
            Set code to concat(code, "    sete %al\n")
            Set code to concat(code, "    movzx %al, %rax\n")
        End If
        If operator is equal to "IsLessThan":
            Set code to concat(code, "    setl %al\n")
            Set code to concat(code, "    movzx %al, %rax\n")
        End If

        Return code
    End If

    If expr_type is equal to "function_call":
        Return generate_function_call(expr_ast)
    End If

    If expr_type is equal to "field_access":
        Let object_ast be extract_ast_part(expr_ast, 1)
        Let field_name be extract_ast_part(expr_ast, 2)
        Let code be "    # Field access: "
        Set code to concat(code, field_name)
        Set code to concat(code, "\n")
        Let object_code be generate_expression_code(object_ast)
        Set code to concat(code, object_code)
        Set code to concat(code, "    # Load field ")
        Set code to concat(code, field_name)
        Set code to concat(code, "\n")
        Return code
    End If

    If expr_type is equal to "index_access":
        Let array_ast be extract_ast_part(expr_ast, 1)
        Let index_ast be extract_ast_part(expr_ast, 2)
        Let code be "    # Index access\n"
        Let array_code be generate_expression_code(array_ast)
        Set code to concat(code, array_code)
        Set code to concat(code, "    push %rax\n")
        Let index_code be generate_expression_code(index_ast)
        Set code to concat(code, index_code)
        Set code to concat(code, "    mov %rax, %rbx\n")
        Set code to concat(code, "    pop %rax\n")
        Set code to concat(code, "    # Load element at index\n")
        Return code
    End If

    If expr_type is equal to "list_literal":
        Let elements be extract_ast_part(expr_ast, 1)
        Let code be "    # List literal\n"
        Set code to concat(code, "    # Elements: ")
        Set code to concat(code, elements)
        Set code to concat(code, "\n")
        Set code to concat(code, "    # Allocate and initialize list\n")
        Return code
    End If

    If expr_type is equal to "struct_creation":
        Let type_name be extract_ast_part(expr_ast, 1)
        Let fields be extract_ast_part(expr_ast, 2)
        Let code be "    # Struct creation: "
        Set code to concat(code, type_name)
        Set code to concat(code, "\n")
        Set code to concat(code, "    # Fields: ")
        Set code to concat(code, fields)
        Set code to concat(code, "\n")
        Set code to concat(code, "    # Allocate and initialize struct\n")
        Return code
    End If

    Return "    # Unknown expression\n"
End Process

Process called "generate_let_statement" that takes ast as String returns String:
    Note: GenerateLetStatement
    Let var_name be extract_ast_part(ast, 1)
    Let expr_ast be extract_ast_part(ast, 2)
    Let expr_code be generate_expression_code(expr_ast)
    Let code be "    # Let "
    Set code to concat(code, var_name)
    Set code to concat(code, " be expression\n")
    Set code to concat(code, expr_code)
    Set code to concat(code, "    # Store in variable\n")
    Return code
End Process

Process called "generate_set_statement" that takes ast as String returns String:
    Note: GenerateSetStatement
    Let var_name be extract_ast_part(ast, 1)
    Let expr_ast be extract_ast_part(ast, 2)
    Let expr_code be generate_expression_code(expr_ast)
    Let code be "    # Set "
    Set code to concat(code, var_name)
    Set code to concat(code, " to expression\n")
    Set code to concat(code, expr_code)
    Set code to concat(code, "    # Store in variable\n")
    Return code
End Process

Process called "generate_display_statement" that takes ast as String returns String:
    Note: GenerateDisplayStatement
    Let expr_ast be extract_ast_part(ast, 1)
    Let expr_code be generate_expression_code(expr_ast)
    Let code be "    # Display expression\n"
    Set code to concat(code, expr_code)
    Set code to concat(code, "    # Print value in %rax\n")
    Return code
End Process

Process called "generate_return_statement" that takes ast as String returns String:
    Note: GenerateReturnStatement
    Let expr_ast be extract_ast_part(ast, 1)
    Let expr_code be generate_expression_code(expr_ast)
    Let code be "    # Return expression\n"
    Set code to concat(code, expr_code)
    Set code to concat(code, "    # Return value in %rax\n")
    Set code to concat(code, "    ret\n")
    Return code
End Process

Process called "generate_if_statement" that takes ast as String returns String:
    Note: GenerateIfStatement
    Let condition_ast be extract_ast_part(ast, 1)
    Let body_ast be extract_ast_part(ast, 2)

    Let code be "    # If statement\n"
    Set code to concat(code, "    # Evaluate condition\n")
    Let condition_code be generate_expression_code(condition_ast)
    Set code to concat(code, condition_code)
    Set code to concat(code, "    test %rax, %rax\n")
    Set code to concat(code, "    jz .Lif_end\n")
    Set code to concat(code, "    # Then block\n")
    Set code to concat(code, "    # Process body statements\n")
    Set code to concat(code, ".Lif_end:\n")
    Return code
End Process

Process called "generate_while_statement" that takes ast as String returns String:
    Note: GenerateWhileStatement
    Let condition_ast be extract_ast_part(ast, 1)
    Let body_ast be extract_ast_part(ast, 2)

    Let code be "    # While statement\n"
    Set code to concat(code, ".Lwhile_start:\n")
    Set code to concat(code, "    # Evaluate condition\n")
    Let condition_code be generate_expression_code(condition_ast)
    Set code to concat(code, condition_code)
    Set code to concat(code, "    test %rax, %rax\n")
    Set code to concat(code, "    jz .Lwhile_end\n")
    Set code to concat(code, "    # Loop body\n")
    Set code to concat(code, "    # Process body statements\n")
    Set code to concat(code, "    jmp .Lwhile_start\n")
    Set code to concat(code, ".Lwhile_end:\n")
    Return code
End Process

Process called "generate_process_definition" that takes ast as String returns String:
    Note: GenerateProcessDefinition
    Let proc_name be extract_ast_part(ast, 1)
    Let params_ast be extract_ast_part(ast, 2)
    Let return_type be extract_ast_part(ast, 3)
    Let body_ast be extract_ast_part(ast, 4)

    Let code be proc_name
    Set code to concat(code, ":\n")
    Set code to concat(code, "    push %rbp\n")
    Set code to concat(code, "    mov %rsp, %rbp\n")
    Set code to concat(code, "    # Function body\n")
    Set code to concat(code, "    # Process parameters\n")
    Set code to concat(code, "    # Process body statements\n")
    Set code to concat(code, "    pop %rbp\n")
    Set code to concat(code, "    ret\n")
    Return code
End Process

Process called "generate_statement_code" that takes ast as String returns String:
    Note: GenerateStatementCode
    Let stmt_type be extract_ast_part(ast, 0)

    If stmt_type is equal to "let_statement":
        Return generate_let_statement(ast)
    End If
    If stmt_type is equal to "set_statement":
        Return generate_set_statement(ast)
    End If
    If stmt_type is equal to "display_statement":
        Return generate_display_statement(ast)
    End If
    If stmt_type is equal to "return_statement":
        Return generate_return_statement(ast)
    End If
    If stmt_type is equal to "if_statement":
        Return generate_if_statement(ast)
    End If
    If stmt_type is equal to "while_statement":
        Return generate_while_statement(ast)
    End If
    If stmt_type is equal to "process_definition":
        Return generate_process_definition(ast)
    End If
    If stmt_type is equal to "function_call":
        Return generate_function_call(ast)
    End If
    If stmt_type is equal to "note_statement":
        Return "    # Note comment\n"
    End If

    Return "    # Unknown statement\n"
End Process

Process called "generate_main_body" that takes ast as String returns String:
    Note: GenerateMainBody
    Let code be ".text\n"
    Set code to concat(code, ".global main\n")
    Set code to concat(code, "main:\n")
    Set code to concat(code, "    push %rbp\n")
    Set code to concat(code, "    mov %rsp, %rbp\n")
    Set code to concat(code, "    # Main function body\n")
    Let body_code be generate_statement_code(ast)
    Set code to concat(code, body_code)
    Set code to concat(code, "    mov $0, %rax\n")
    Set code to concat(code, "    pop %rbp\n")
    Set code to concat(code, "    ret\n")
    Return code
End Process

Process called "generate_code" that takes ast as String returns String:
    Note: MainCodeGenerationEntry
    Let ast_type be extract_ast_part(ast, 0)
    Let header be generate_assembly_header()
    Let footer be generate_assembly_footer()

    If ast_type is equal to "program":
        Let statements be extract_ast_part(ast, 1)
        Let code be concat(header, "    # Program statements\n")
        Set code to concat(code, footer)
        Return code
    End If

    Let stmt_code be generate_statement_code(ast)
    Let result be concat(header, stmt_code)
    Set result to concat(result, footer)
    Return result
End Process