Note: MicroRunaTypeChecker

Note: Global type tracking storage using pipe separated strings
Note: Format variables varname type scope varname2 type2 scope2
Note: Format functions funcname param1 param2 returntype func2 param ret
Note: Format types typename field1 type1 field2 type2 type2 fields
Let global_variables be ""
Let global_functions be ""
Let global_types be ""
Let current_scope be "global"
Let current_function_return be "Void"

Process called "extract_ast_part" that takes ast_data as String, part_index as Integer returns String:
    Note: ExtractASTComponent
    Let current_part be 0
    Let start_pos be 0
    Let i be 0
    Let ast_length be length_of(ast_data)

    While i is less than ast_length:
        Let char_code be char_at(ast_data, i)
        If char_code is equal to 124:
            If current_part is equal to part_index:
                Return substring(ast_data, start_pos, i)
            End If
            Set current_part to current_part plus 1
            Set start_pos to i plus 1
        End If
        Set i to i plus 1
    End While

    If current_part is equal to part_index:
        Return substring(ast_data, start_pos, ast_length)
    End If
    Return ""
End Process

Process called "get_expression_type" that takes expr_ast as String returns String:
    Note: DetermineExpressionType Enhanced with real type inference
    Let ast_type be extract_ast_part(expr_ast, 0)

    If ast_type is equal to "integer_literal":
        Return "Integer"
    End If
    If ast_type is equal to "string_literal":
        Return "String"
    End If
    If ast_type is equal to "identifier":
        Let var_name be extract_ast_part(expr_ast, 1)
        Return lookup_variable_type(var_name)
    End If
    If ast_type is equal to "function_call":
        Return infer_function_return_type(expr_ast)
    End If
    If ast_type is equal to "binary_expression":
        Return check_binary_expression_type(expr_ast)
    End If
    If ast_type is equal to "list_literal":
        Return "List"
    End If
    If ast_type is equal to "struct_creation":
        Let type_name be extract_ast_part(expr_ast, 1)
        Return type_name
    End If
    If ast_type is equal to "field_access":
        Return infer_field_type(expr_ast)
    End If
    If ast_type is equal to "index_access":
        Return infer_index_type(expr_ast)
    End If

    Return "Unknown"
End Process

Process called "check_let_statement" that takes ast as String returns String:
    Note: CheckLetStatement Now tracks variable types
    Let var_name be extract_ast_part(ast, 1)
    Let expr_ast be extract_ast_part(ast, 2)
    Let expr_type be get_expression_type(expr_ast)

    Note: Track the variable type
    call track_variable_type(var_name, expr_type)

    Let result be "let_checked|"
    Set result to concat(result, var_name)
    Set result to concat(result, "|")
    Set result to concat(result, expr_type)
    Return result
End Process

Process called "check_set_statement" that takes ast as String returns String:
    Note: CheckSetStatement Now validates type compatibility
    Let var_name be extract_ast_part(ast, 1)
    Let expr_ast be extract_ast_part(ast, 2)
    Let expr_type be get_expression_type(expr_ast)

    Note: Check if variable exists and types match
    Let existing_type be lookup_variable_type(var_name)
    If existing_type is equal to "Unknown":
        Return report_type_error(concat("Undefined variable ", var_name))
    End If

    If existing_type is not equal to expr_type:
        Return report_type_error(concat("Type mismatch for ", concat(var_name, concat(" expected ", concat(existing_type, concat(" got ", expr_type))))))
    End If

    Let result be "set_checked|"
    Set result to concat(result, var_name)
    Set result to concat(result, "|")
    Set result to concat(result, expr_type)
    Return result
End Process

Process called "check_display_statement" that takes ast as String returns String:
    Note: CheckDisplayStatement
    Let expr_ast be extract_ast_part(ast, 1)
    Let expr_type be get_expression_type(expr_ast)
    Let result be "display_checked|"
    Set result to concat(result, expr_type)
    Return result
End Process

Process called "check_return_statement" that takes ast as String returns String:
    Note: CheckReturnStatement
    Let expr_ast be extract_ast_part(ast, 1)
    Let expr_type be get_expression_type(expr_ast)
    Let result be "return_checked|"
    Set result to concat(result, expr_type)
    Return result
End Process

Process called "check_statement" that takes ast as String returns String:
    Note: CheckSingleStatement Enhanced with full statement support
    Let stmt_type be extract_ast_part(ast, 0)

    If stmt_type is equal to "let_statement":
        Return check_let_statement(ast)
    End If
    If stmt_type is equal to "set_statement":
        Return check_set_statement(ast)
    End If
    If stmt_type is equal to "display_statement":
        Return check_display_statement(ast)
    End If
    If stmt_type is equal to "return_statement":
        Return check_return_statement(ast)
    End If
    If stmt_type is equal to "note_statement":
        Return "note_checked|comment"
    End If
    If stmt_type is equal to "if_statement":
        Return check_if_statement(ast)
    End If
    If stmt_type is equal to "while_statement":
        Return check_while_statement(ast)
    End If
    If stmt_type is equal to "process_definition":
        Return check_process_definition(ast)
    End If
    If stmt_type is equal to "type_definition":
        Return check_type_definition(ast)
    End If
    If stmt_type is equal to "function_call":
        Return validate_function_call(ast)
    End If

    Return "unknown_statement_checked"
End Process

Process called "check_types" that takes ast as String returns String:
    Note: MainTypeCheckingEntry Enhanced with initialization
    Note: Initialize builtin functions on first run
    If length_of(global_functions) is equal to 0:
        call initialize_builtins()
    End If

    Let ast_type be extract_ast_part(ast, 0)

    If ast_type is equal to "program":
        Let statements be extract_ast_part(ast, 1)
        Return "program_checked|validated"
    End If

    Return check_statement(ast)
End Process

Process called "validate_expression_type" that takes expr_type as String, expected_type as String returns Integer:
    Note: ValidateExpressionType
    If expr_type is equal to expected_type:
        Return 1
    End If
    If expr_type is equal to "Integer":
        If expected_type is equal to "String":
            Return 0
        End If
    End If
    Return 0
End Process

Process called "initialize_builtins":
    Note: Initialize all builtin function signatures
    Set global_functions to "length_of|String|Integer"
    Set global_functions to concat(global_functions, ";char_at|String,Integer|Integer")
    Set global_functions to concat(global_functions, ";substring|String,Integer,Integer|String")
    Set global_functions to concat(global_functions, ";concat|String,String|String")
    Set global_functions to concat(global_functions, ";to_string|Integer|String")
    Set global_functions to concat(global_functions, ";Display|String|Void")
    Set global_functions to concat(global_functions, ";read_file|String|String")
    Set global_functions to concat(global_functions, ";write_file|String,String|Void")
    Set global_functions to concat(global_functions, ";split|String,String|List")
    Set global_functions to concat(global_functions, ";trim|String|String")
    Set global_functions to concat(global_functions, ";starts_with|String,String|Integer")
    Set global_functions to concat(global_functions, ";ends_with|String,String|Integer")
    Set global_functions to concat(global_functions, ";contains|String,String|Integer")
    Set global_functions to concat(global_functions, ";replace|String,String,String|String")
    Set global_functions to concat(global_functions, ";to_upper|String|String")
    Set global_functions to concat(global_functions, ";to_lower|String|String")
End Process

Process called "find_char" that takes text as String, char_code as Integer, start_pos as Integer returns Integer:
    Note: Helper to find character position in string
    Let text_length be length_of(text)
    Let i be start_pos
    While i is less than text_length:
        If char_at(text, i) is equal to char_code:
            Return i
        End If
        Set i to i plus 1
    End While
    Return 0
End Process

Process called "track_variable_type" that takes var_name as String, var_type as String returns Void:
    Note: Add or update a variable type in the current scope
    Let entry be concat(var_name, "|")
    Set entry to concat(entry, var_type)
    Set entry to concat(entry, "|")
    Set entry to concat(entry, current_scope)

    If length_of(global_variables) is equal to 0:
        Set global_variables to entry
    Otherwise:
        Set global_variables to concat(global_variables, ";")
        Set global_variables to concat(global_variables, entry)
    End If
End Process

Process called "lookup_variable_type" that takes var_name as String returns String:
    Note: Find a variable type in the current or parent scopes
    Let vars_length be length_of(global_variables)
    If vars_length is equal to 0:
        Return "Unknown"
    End If

    Let i be 0
    Let start_pos be 0
    Let found_type be "Unknown"

    While i is less than vars_length plus 1:
        Let char_code be 0
        If i is less than vars_length:
            Set char_code to char_at(global_variables, i)
        End If

        Let should_process be 0
        If char_code is equal to 59:
            Set should_process to 1
        End If
        If i is equal to vars_length:
            Set should_process to 1
        End If

        If should_process is equal to 1:
            Let entry be substring(global_variables, start_pos, i)
            Let pipe1_pos be find_char(entry, 124, 0)
            If pipe1_pos is greater than 0:
                Let entry_name be substring(entry, 0, pipe1_pos)
                If entry_name is equal to var_name:
                    Let pipe2_pos be find_char(entry, 124, pipe1_pos plus 1)
                    If pipe2_pos is greater than pipe1_pos:
                        Set found_type to substring(entry, pipe1_pos plus 1, pipe2_pos)
                    End If
                End If
            End If
            Set start_pos to i plus 1
        End If
        Set i to i plus 1
    End While

    Return found_type
End Process

Process called "report_type_error" that takes error_msg as String returns String:
    Note: Report a type error with context
    Let full_msg be "TYPE_ERROR "
    Set full_msg to concat(full_msg, error_msg)
    Set full_msg to concat(full_msg, " in scope ")
    Set full_msg to concat(full_msg, current_scope)
    Display full_msg
    Return full_msg
End Process

Process called "infer_function_return_type" that takes call_ast as String returns String:
    Note: Get return type of function call
    Let func_name be extract_ast_part(call_ast, 1)

    Note: Search in global_functions for this function
    Let funcs_length be length_of(global_functions)
    If funcs_length is equal to 0:
        Return "Unknown"
    End If

    Let i be 0
    Let start_pos be 0

    While i is less than funcs_length plus 1:
        Let char_code be 0
        If i is less than funcs_length:
            Set char_code to char_at(global_functions, i)
        End If

        If char_code is equal to 59 Or i is equal to funcs_length:
            Let entry be substring(global_functions, start_pos, i)
            Note: Try pipe first for builtins then colon for user functions
            Let sep1_pos be find_char(entry, 124, 0)
            If sep1_pos is equal to 0:
                Set sep1_pos to find_char(entry, 58, 0)
            End If
            If sep1_pos is greater than 0:
                Let entry_name be substring(entry, 0, sep1_pos)
                If entry_name is equal to func_name:
                    Note: Find second separator
                    Let sep2_pos be find_char(entry, 124, sep1_pos plus 1)
                    If sep2_pos is equal to 0:
                        Set sep2_pos to find_char(entry, 58, sep1_pos plus 1)
                    End If
                    If sep2_pos is greater than sep1_pos:
                        Return substring(entry, sep2_pos plus 1, length_of(entry))
                    End If
                End If
            End If
            Set start_pos to i plus 1
        End If
        Set i to i plus 1
    End While

    Return "Unknown"
End Process

Process called "check_binary_expression_type" that takes expr_ast as String returns String:
    Note: Type check binary expressions
    Let operator be extract_ast_part(expr_ast, 1)
    Let left_ast be extract_ast_part(expr_ast, 2)
    Let right_ast be extract_ast_part(expr_ast, 3)

    Let left_type be get_expression_type(left_ast)
    Let right_type be get_expression_type(right_ast)

    Note: Comparison operators return Integer (0 or 1 for boolean)
    If operator is equal to "greater_than" Or operator is equal to "less_than":
        Return "Integer"
    End If
    If operator is equal to "equal" Or operator is equal to "not_equal":
        Return "Integer"
    End If
    If operator is equal to "greater_equal" Or operator is equal to "less_equal":
        Return "Integer"
    End If

    Note: Arithmetic operators preserve type if both operands match
    If operator is equal to "plus" Or operator is equal to "minus":
        If left_type is equal to right_type:
            Return left_type
        End If
        Return report_type_error(concat("Type mismatch ", concat(left_type, concat(" and ", right_type))))
    End If
    If operator is equal to "multiply" Or operator is equal to "divide":
        If left_type is equal to "Integer" And right_type is equal to "Integer":
            Return "Integer"
        End If
        Return report_type_error("Arithmetic requires Integer operands")
    End If

    Return "Unknown"
End Process

Process called "infer_field_type" that takes ast as String returns String:
    Note: Infer type of field access with complete struct validation
    Let object_ast be extract_ast_part(ast, 1)
    Let field_name be extract_ast_part(ast, 2)

    Let object_type be get_expression_type(object_ast)

    Note: Validate that object is a custom type (struct)
    If object_type is equal to "Integer" Or object_type is equal to "String" Or object_type is equal to "Void":
        Return report_type_error(concat("Cannot access field on primitive type ", object_type))
    End If

    If object_type is equal to "Unknown":
        Return report_type_error("Cannot access field on unknown type")
    End If

    Note: Look up field type in struct definition
    Let field_type be lookup_field_type(object_type, field_name)
    If field_type is equal to "Unknown":
        Return report_type_error(concat("Field ", concat(field_name, concat(" not found in type ", object_type))))
    End If

    Return field_type
End Process

Process called "infer_index_type" that takes ast as String returns String:
    Note: Infer type of index access with complete validation
    Let object_ast be extract_ast_part(ast, 1)
    Let index_ast be extract_ast_part(ast, 2)

    Let object_type be get_expression_type(object_ast)
    Let index_type be get_expression_type(index_ast)

    Note: Index must be Integer
    If index_type is not equal to "Integer":
        Return report_type_error(concat("Index must be Integer, got ", index_type))
    End If

    Note: Validate indexable types
    If object_type is equal to "String":
        Return "Integer"
    End If
    If object_type is equal to "List":
        Note: For basic List type, return generic element type
        Return "Unknown"
    End If
    If substring(object_type, 0, 4) is equal to "List":
        Note: For typed lists like List[String], extract element type
        Let bracket_pos be find_char(object_type, 91, 0)
        If bracket_pos is greater than 0:
            Let close_bracket_pos be find_char(object_type, 93, bracket_pos)
            If close_bracket_pos is greater than bracket_pos:
                Return substring(object_type, bracket_pos plus 1, close_bracket_pos)
            End If
        End If
        Return "Unknown"
    End If

    Return report_type_error(concat("Cannot index type ", object_type))
End Process

Process called "track_function_signature" that takes func_name as String, params as String, return_type as String returns Void:
    Note: Store function signature in global_functions
    Let entry be concat(func_name, "|")
    Set entry to concat(entry, params)
    Set entry to concat(entry, "|")
    Set entry to concat(entry, return_type)

    If length_of(global_functions) is equal to 0:
        Set global_functions to entry
    Otherwise:
        Set global_functions to concat(global_functions, ";")
        Set global_functions to concat(global_functions, entry)
    End If
End Process

Process called "validate_function_call" that takes call_ast as String returns String:
    Note: Validate function call arguments
    Let func_name be extract_ast_part(call_ast, 1)
    Let args_ast be extract_ast_part(call_ast, 2)

    Note: Look up function signature
    Let signature be lookup_function_signature(func_name)
    If signature is equal to "Unknown":
        Return report_type_error(concat("Unknown function ", func_name))
    End If

    Note: Extract expected parameter types handling both pipes and colons
    Let sep_pos be find_char(signature, 124, 0)
    If sep_pos is equal to 0:
        Set sep_pos to find_char(signature, 58, 0)
    End If
    If sep_pos is equal to 0:
        Return "validated"
    End If

    Let params_str be substring(signature, 0, sep_pos)

    Note: Count and validate arguments
    Let expected_count be count_params(params_str)
    Let actual_count be count_args(args_ast)

    If expected_count is not equal to actual_count:
        Return report_type_error(concat("Argument count mismatch for ", func_name))
    End If

    Return "validated"
End Process

Process called "lookup_function_signature" that takes func_name as String returns String:
    Note: Get full signature for a function
    Let funcs_length be length_of(global_functions)
    If funcs_length is equal to 0:
        Return "Unknown"
    End If

    Let i be 0
    Let start_pos be 0

    While i is less than funcs_length plus 1:
        Let char_code be 0
        If i is less than funcs_length:
            Set char_code to char_at(global_functions, i)
        End If

        If char_code is equal to 59 Or i is equal to funcs_length:
            Let entry be substring(global_functions, start_pos, i)
            Note: Try pipe first for builtins then colon for user functions
            Let sep_pos be find_char(entry, 124, 0)
            If sep_pos is equal to 0:
                Set sep_pos to find_char(entry, 58, 0)
            End If
            If sep_pos is greater than 0:
                Let entry_name be substring(entry, 0, sep_pos)
                If entry_name is equal to func_name:
                    Return substring(entry, sep_pos plus 1, length_of(entry))
                End If
            End If
            Set start_pos to i plus 1
        End If
        Set i to i plus 1
    End While

    Return "Unknown"
End Process

Process called "count_params" that takes params_str as String returns Integer:
    Note: Count comma separated parameters
    If length_of(params_str) is equal to 0:
        Return 0
    End If

    Let count be 1
    Let i be 0
    Let str_len be length_of(params_str)

    While i is less than str_len:
        If char_at(params_str, i) is equal to 44:
            Set count to count plus 1
        End If
        Set i to i plus 1
    End While

    Return count
End Process

Process called "count_args" that takes args_ast as String returns Integer:
    Note: Count pipe separated arguments in AST
    If length_of(args_ast) is equal to 0:
        Return 0
    End If

    Let count be 1
    Let i be 0
    Let str_len be length_of(args_ast)

    While i is less than str_len:
        If char_at(args_ast, i) is equal to 124:
            Set count to count plus 1
        End If
        Set i to i plus 1
    End While

    Return count
End Process

Process called "enter_scope" that takes scope_name as String returns Void:
    Note: Enter a new scope
    Set current_scope to scope_name
End Process

Process called "exit_scope":
    Note: Exit current scope back to global
    Set current_scope to "global"
End Process

Process called "check_if_statement" that takes ast as String returns String:
    Note: Validate If statement with complete condition and block checking
    Let condition_ast be extract_ast_part(ast, 1)
    Let then_block_ast be extract_ast_part(ast, 2)
    Let else_block_ast be extract_ast_part(ast, 3)

    Note: Type check condition should be evaluable expression
    Let condition_type be get_expression_type(condition_ast)
    If condition_type is equal to "Unknown":
        Return report_type_error("If condition has unknown type")
    End If

    Note: Save current scope for block checking
    Let old_scope be current_scope
    call enter_scope(concat(current_scope, "_if"))

    Note: Check then block statements
    Let then_result be check_block_statements(then_block_ast)
    If substring(then_result, 0, 10) is equal to "TYPE_ERROR":
        call exit_scope()
        Return then_result
    End If

    Note: Check else block if present
    If length_of(else_block_ast) is greater than 0:
        Let else_result be check_block_statements(else_block_ast)
        If substring(else_result, 0, 10) is equal to "TYPE_ERROR":
            call exit_scope()
            Return else_result
        End If
    End If

    call exit_scope()
    Return "if_statement_checked|validated"
End Process

Process called "check_while_statement" that takes ast as String returns String:
    Note: Validate While loop with condition and body checking
    Let condition_ast be extract_ast_part(ast, 1)
    Let body_ast be extract_ast_part(ast, 2)

    Note: Type check condition
    Let condition_type be get_expression_type(condition_ast)
    If condition_type is equal to "Unknown":
        Return report_type_error("While condition has unknown type")
    End If

    Note: Save current scope for loop body checking
    Let old_scope be current_scope
    call enter_scope(concat(current_scope, "_while"))

    Note: Check loop body statements
    Let body_result be check_block_statements(body_ast)
    If substring(body_result, 0, 10) is equal to "TYPE_ERROR":
        call exit_scope()
        Return body_result
    End If

    call exit_scope()
    Return "while_statement_checked|validated"
End Process

Process called "check_block_statements" that takes block_ast as String returns String:
    Note: Check multiple statements in a block
    If length_of(block_ast) is equal to 0:
        Return "empty_block_checked"
    End If

    Note: Parse statements separated by semicolons or pipes
    Let i be 0
    Let start_pos be 0
    Let block_length be length_of(block_ast)

    While i is less than block_length plus 1:
        Let char_code be 0
        If i is less than block_length:
            Set char_code to char_at(block_ast, i)
        End If

        If char_code is equal to 59 Or char_code is equal to 124 Or i is equal to block_length:
            Let stmt_ast be substring(block_ast, start_pos, i)
            If length_of(stmt_ast) is greater than 0:
                Let stmt_result be check_statement(stmt_ast)
                If substring(stmt_result, 0, 10) is equal to "TYPE_ERROR":
                    Return stmt_result
                End If
            End If
            Set start_pos to i plus 1
        End If
        Set i to i plus 1
    End While

    Return "block_statements_checked"
End Process

Process called "check_process_definition" that takes ast as String returns String:
    Note: Complete process definition checking with scope and parameter management
    Let func_name be extract_ast_part(ast, 1)
    Let params_ast be extract_ast_part(ast, 2)
    Let return_type_ast be extract_ast_part(ast, 3)
    Let body_ast be extract_ast_part(ast, 4)

    Note: Build parameter type string for signature
    Let params_string be build_param_type_string(params_ast)

    Note: Default return type if not specified
    Let return_type be "Void"
    If length_of(return_type_ast) is greater than 0:
        Set return_type to return_type_ast
    End If

    Note: Track function signature in global storage
    call track_function_signature(func_name, params_string, return_type)

    Note: Save current context
    Let old_scope be current_scope
    Let old_return_type be current_function_return

    Note: Enter function scope
    call enter_scope(func_name)
    Set current_function_return to return_type

    Note: Add parameters to variable scope
    call add_parameters_to_scope(params_ast)

    Note: Check function body
    Let body_result be check_block_statements(body_ast)
    If substring(body_result, 0, 10) is equal to "TYPE_ERROR":
        Set current_scope to old_scope
        Set current_function_return to old_return_type
        Return body_result
    End If

    Note: Restore previous context
    Set current_scope to old_scope
    Set current_function_return to old_return_type

    Return "process_definition_checked|validated"
End Process

Process called "build_param_type_string" that takes params_ast as String returns String:
    Note: Build comma separated parameter type string from AST
    If length_of(params_ast) is equal to 0:
        Return ""
    End If

    Let result be ""
    Let i be 0
    Let start_pos be 0
    Let params_length be length_of(params_ast)

    While i is less than params_length plus 1:
        Let char_code be 0
        If i is less than params_length:
            Set char_code to char_at(params_ast, i)
        End If

        If char_code is equal to 124 Or i is equal to params_length:
            Let param_entry be substring(params_ast, start_pos, i)
            If length_of(param_entry) is greater than 0:
                Note: Extract type from name type format
                Let colon_pos be find_char(param_entry, 58, 0)
                If colon_pos is greater than 0:
                    Let param_type be substring(param_entry, colon_pos plus 1, length_of(param_entry))
                    If length_of(result) is greater than 0:
                        Set result to concat(result, ",")
                    End If
                    Set result to concat(result, param_type)
                End If
            End If
            Set start_pos to i plus 1
        End If
        Set i to i plus 1
    End While

    Return result
End Process

Process called "add_parameters_to_scope" that takes params_ast as String returns Void:
    Note: Add function parameters to current variable scope
    If length_of(params_ast) is equal to 0:
        Return
    End If

    Let i be 0
    Let start_pos be 0
    Let params_length be length_of(params_ast)

    While i is less than params_length plus 1:
        Let char_code be 0
        If i is less than params_length:
            Set char_code to char_at(params_ast, i)
        End If

        If char_code is equal to 124 Or i is equal to params_length:
            Let param_entry be substring(params_ast, start_pos, i)
            If length_of(param_entry) is greater than 0:
                Note: Parse name type format
                Let colon_pos be find_char(param_entry, 58, 0)
                If colon_pos is greater than 0:
                    Let param_name be substring(param_entry, 0, colon_pos)
                    Let param_type be substring(param_entry, colon_pos plus 1, length_of(param_entry))
                    call track_variable_type(param_name, param_type)
                End If
            End If
            Set start_pos to i plus 1
        End If
        Set i to i plus 1
    End While
End Process

Process called "check_type_definition" that takes ast as String returns String:
    Note: Complete struct and type definition checking and storage
    Let type_name be extract_ast_part(ast, 1)
    Let fields_ast be extract_ast_part(ast, 2)

    Note: Build field type mapping string
    Let fields_string be build_field_type_string(fields_ast)

    Note: Store type definition in global storage
    Let entry be concat(type_name, "|")
    Set entry to concat(entry, fields_string)

    If length_of(global_types) is equal to 0:
        Set global_types to entry
    Otherwise:
        Set global_types to concat(global_types, ";")
        Set global_types to concat(global_types, entry)
    End If

    Return "type_definition_checked|validated"
End Process

Process called "build_field_type_string" that takes fields_ast as String returns String:
    Note: Build field type mapping string from AST
    If length_of(fields_ast) is equal to 0:
        Return ""
    End If

    Let result be ""
    Let i be 0
    Let start_pos be 0
    Let fields_length be length_of(fields_ast)

    While i is less than fields_length plus 1:
        Let char_code be 0
        If i is less than fields_length:
            Set char_code to char_at(fields_ast, i)
        End If

        If char_code is equal to 124 Or i is equal to fields_length:
            Let field_entry be substring(fields_ast, start_pos, i)
            If length_of(field_entry) is greater than 0:
                Note: Convert name type to name type format
                Let colon_pos be find_char(field_entry, 58, 0)
                If colon_pos is greater than 0:
                    Let field_name be substring(field_entry, 0, colon_pos)
                    Let field_type be substring(field_entry, colon_pos plus 1, length_of(field_entry))
                    If length_of(result) is greater than 0:
                        Set result to concat(result, ",")
                    End If
                    Set result to concat(result, field_name)
                    Set result to concat(result, "=")
                    Set result to concat(result, field_type)
                End If
            End If
            Set start_pos to i plus 1
        End If
        Set i to i plus 1
    End While

    Return result
End Process

Process called "lookup_field_type" that takes struct_type as String, field_name as String returns String:
    Note: Look up field type in struct definition
    Let types_length be length_of(global_types)
    If types_length is equal to 0:
        Return "Unknown"
    End If

    Let i be 0
    Let start_pos be 0

    While i is less than types_length plus 1:
        Let char_code be 0
        If i is less than types_length:
            Set char_code to char_at(global_types, i)
        End If

        If char_code is equal to 59 Or i is equal to types_length:
            Let entry be substring(global_types, start_pos, i)
            Let colon_pos be find_char(entry, 58, 0)
            If colon_pos is greater than 0:
                Let entry_name be substring(entry, 0, colon_pos)
                If entry_name is equal to struct_type:
                    Let fields_str be substring(entry, colon_pos plus 1, length_of(entry))
                    Return find_field_type_in_string(fields_str, field_name)
                End If
            End If
            Set start_pos to i plus 1
        End If
        Set i to i plus 1
    End While

    Return "Unknown"
End Process

Process called "find_field_type_in_string" that takes fields_str as String, field_name as String returns String:
    Note: Find field type in comma separated field type string
    Let i be 0
    Let start_pos be 0
    Let fields_length be length_of(fields_str)

    While i is less than fields_length plus 1:
        Let char_code be 0
        If i is less than fields_length:
            Set char_code to char_at(fields_str, i)
        End If

        If char_code is equal to 44 Or i is equal to fields_length:
            Let field_entry be substring(fields_str, start_pos, i)
            Let equals_pos be find_char(field_entry, 61, 0)
            If equals_pos is greater than 0:
                Let entry_name be substring(field_entry, 0, equals_pos)
                If entry_name is equal to field_name:
                    Return substring(field_entry, equals_pos plus 1, length_of(field_entry))
                End If
            End If
            Set start_pos to i plus 1
        End If
        Set i to i plus 1
    End While

    Return "Unknown"
End Process