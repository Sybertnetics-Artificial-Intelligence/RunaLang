# v0.2 Micro-Runa Compiler Implementation Plan

## Executive Summary

This document provides a comprehensive implementation plan for v0.2 Micro-Runa, the first self-hosted Runa compiler. It is based on the actual capabilities of v0.1 (confirmed working as of 2025-09-14) and uses the **canonical Runa syntax** as specified in the language documentation.

## Primary Goal

**Create a minimal Runa compiler written in Runa that can compile simple Runa programs without any external library dependencies.**

---

## Part 1: Core Language Features Required (Based on v0.1 Capabilities)

### ✅ FEATURES v0.1 SUPPORTS (Canonical Syntax Only)

#### 1. **Basic Program Structure**
```runa
Process called "main" that takes argc as Integer, argv as Integer returns Integer:
    Let result be 42
    Return result
End Process
```

#### 2. **Variable Operations**
```runa
Let variable be value
Set variable to new_value
```

#### 3. **Arithmetic Operations** (Canonical Mode)
- Addition: `value1 plus value2`
- Subtraction: `value1 minus value2`
- Multiplication: `value1 multiplied by value2`
- Division: `value1 divided by value2`

#### 4. **Comparison Operations** (Canonical Mode)
- Equal: `value1 is equal to value2`
- Not equal: `value1 is not equal to value2`
- Greater than: `value1 is greater than value2`
- Less than: `value1 is less than value2`
- Greater or equal: `value1 is greater than or equal to value2`
- Less or equal: `value1 is less than or equal to value2`

#### 5. **Logical Operations** (Canonical Mode)
- AND: `condition1 And condition2`
- OR: `condition1 Or condition2`
- NOT: `Not condition` (⚠️ Not implemented in v0.1)

#### 6. **Control Flow**
```runa
If condition:
    statement
Otherwise:
    alternative_statement
End If

While condition:
    statement
End While

For Each item in collection:
    statement
End For
```

#### 7. **I/O Operations**
```runa
WriteFile "content" to "filename"
Let content be ReadFile from "filename"
```

#### 8. **Type Definitions**
```runa
Type called "TypeName":
    field_name as DataType
    another_field as String
End Type
```

#### 9. **Object Construction**
```runa
Let obj be a value of type TypeName with
    field_name as value,
    another_field as "text"
```

#### 10. **Field Access**
```runa
Let value be obj.field_name
Set obj.field_name to new_value
```

---

## Part 2: v0.2 Required Functionality

### Phase 1: Minimal Tokenizer
**Goal**: Convert Runa source text into tokens

**Required Token Types**:
1. **Keywords**: Process, called, that, takes, as, returns, Let, be, Set, to, If, Otherwise, End, Return, Type, with, a, value, of, type, For, Each, in, While
2. **Identifiers**: Variable and function names
3. **Literals**:
   - Integer: `42`, `0`, `-17`
   - String: `"hello world"`
   - Boolean: `true`, `false`
4. **Operators** (Canonical):
   - Arithmetic: plus, minus, multiplied, by, divided
   - Comparison: is, equal, not, greater, less, than, or, to
   - Logical: And, Or, Not
5. **Delimiters**:
   - Colon `:`
   - Comma `,`
   - Dot `.`
6. **Special**: EOF marker

**Implementation in Canonical Runa**:
```runa
Process called "tokenize" that takes source as String returns String:
    Let tokens be ""
    Let i be 0
    Let length be string_length(source)

    While i is less than length:
        Let char be character_at(source, i)

        If char is equal to " ":
            Set i to i plus 1
        Otherwise If is_letter(char):
            Let word be read_word(source, i)
            Set tokens to tokens joined with classify_word(word)
            Set tokens to tokens joined with ","
        Otherwise If is_digit(char):
            Let number be read_number(source, i)
            Set tokens to tokens joined with "NUMBER:"
            Set tokens to tokens joined with number
            Set tokens to tokens joined with ","
        End If
    End While

    Return tokens
End Process
```

### Phase 2: Minimal Parser
**Goal**: Build Abstract Syntax Tree from tokens

**Required AST Node Types**:
1. Program (root)
2. Process definition
3. Let statement
4. Set statement
5. If statement
6. Return statement
7. Binary operations
8. Variable reference
9. Literal values
10. WriteFile statement

**AST Representation as String**:
Since v0.1 doesn't support complex data structures well, use string encoding:
```
NODE_TYPE:VALUE:CHILDREN
```

Example:
```
PROGRAM::PROCESS:main:LET:x:10,RETURN:x
```

### Phase 3: Assembly Code Generation
**Goal**: Generate x86-64 assembly directly (no LLVM)

**Required Assembly Sections**:
```asm
.text
.global _start

_start:
    call main
    mov %rax, %rdi    # Exit code
    mov $60, %rax     # sys_exit
    syscall

main:
    push %rbp
    mov %rsp, %rbp

    # Function body here

    mov %rbp, %rsp
    pop %rbp
    ret

.data
    # String literals here
```

**Implementation Strategy**:
```runa
Process called "generate_assembly" that takes ast as String returns String:
    Let asm_code be ".text" joined with newline
    Set asm_code to asm_code joined with ".global _start" joined with newline
    Set asm_code to asm_code joined with generate_start_function()
    Set asm_code to asm_code joined with generate_main_from_ast(ast)
    Return asm_code
End Process
```

### Phase 4: Main Driver
**Goal**: Orchestrate compilation pipeline

```runa
Process called "main" returns Integer:
    Let source_code be ReadFile from "input.runa"
    Let tokens be tokenize(source_code)
    Let ast be parse(tokens)
    Let assembly be generate_assembly(ast)
    WriteFile assembly to "output.s"
    Return 0
End Process
```

---

## Part 3: Implementation Constraints

### MUST USE (Canonical Syntax):
1. **Natural language operators**: `plus`, `minus`, `multiplied by`, `divided by`
2. **Comparison syntax**: `is equal to`, `is greater than`, etc.
3. **Variable declarations**: `Let x be value`
4. **Assignments**: `Set x to value`
5. **Collections** (if needed): `a list containing 1, 2, 3`

### MUST AVOID:
1. **Developer mode syntax**: No `+`, `-`, `*`, `/`, `==`, etc.
2. **While Loops**: Use recursion due to v0.1 bug
3. **Complex nested expressions**: Keep expressions simple
4. **User-defined functions**: Inline everything in main
5. **Module imports**: v0.1 doesn't support them

### WORKAROUNDS FOR v0.1 BUGS:
1. **While loop infinite loop bug**: Use unrolled loops or file I/O for iteration
2. **Return values from recursion**: Use WriteFile/ReadFile for state passing
3. **Complex data structures**: Use string encoding with delimiters

---

## Part 4: Testing Strategy

### Stage 1: Basic Compilation
```runa
Process called "main" returns Integer:
    Return 42
End Process
```
Expected: Assembly that returns exit code 42

### Stage 2: Variables and Arithmetic (Canonical)
```runa
Process called "main" returns Integer:
    Let a be 10
    Let b be 20
    Let sum be a plus b
    Return sum
End Process
```
Expected: Returns exit code 30

### Stage 3: Conditionals (Canonical)
```runa
Process called "main" returns Integer:
    Let x be 5
    If x is greater than 3:
        Return 1
    Otherwise:
        Return 0
    End If
End Process
```
Expected: Returns exit code 1

### Stage 4: Self-Hosting Test
v0.2 should compile a simple version of itself

---

## Part 5: String Helper Functions Needed

Since v0.1 has limited string support, we need these helpers:

```runa
Process called "string_length" that takes str as String returns Integer:
    Let count be 0
    # Implementation using inline assembly or syscalls
    Return count
End Process

Process called "string_concat" that takes str1 as String, str2 as String returns String:
    # Concatenate strings
    Return result
End Process

Process called "character_at" that takes str as String, index as Integer returns String:
    # Return single character
    Return char
End Process

Process called "substring" that takes str as String, start as Integer, length as Integer returns String:
    # Extract substring
    Return result
End Process

Process called "string_equals" that takes str1 as String, str2 as String returns Integer:
    # Compare strings
    Return 1  # or 0
End Process
```

---

## Part 6: Success Criteria

### Compilation Chain:
- [x] v0.1 compiles v0.2 compiler
- [x] v0.2 runs and produces output
- [ ] v0.2 tokenizes Runa source correctly
- [ ] v0.2 parses tokens into AST
- [ ] v0.2 generates valid x86-64 assembly
- [ ] Generated assembly can be assembled with `as`
- [ ] Linked executable runs correctly

### Feature Coverage:
- [ ] Process definitions
- [ ] Variable declarations (Let)
- [ ] Variable assignments (Set)
- [ ] Arithmetic operations (canonical)
- [ ] Comparison operations (canonical)
- [ ] If/Otherwise statements
- [ ] Return statements
- [ ] WriteFile operations

---

## Part 7: Development Strategy

### Incremental Implementation:
1. **Start with hardcoded output**: Make v0.2 generate fixed assembly
2. **Add tokenization**: Parse simple keywords
3. **Add minimal parsing**: Handle `Return 42` only
4. **Add variables**: Support Let statements
5. **Add arithmetic**: Support canonical operators
6. **Add conditionals**: Support If/Otherwise
7. **Full pipeline**: Complete compiler

### Testing Each Step:
After each incremental addition:
1. Compile v0.2 with v0.1
2. Run v0.2 on test input
3. Verify output assembly
4. Assemble and link
5. Run and check exit code

---

## Timeline Estimate

### Phase 1: String Helpers & Setup (3-4 hours)
- Implement string manipulation functions
- Set up basic file I/O

### Phase 2: Tokenizer (4-5 hours)
- Character classification
- Token extraction
- Keyword recognition

### Phase 3: Parser (5-6 hours)
- AST string encoding
- Statement parsing
- Expression parsing

### Phase 4: Code Generation (6-8 hours)
- Assembly templates
- Variable tracking
- Control flow generation

### Phase 5: Integration & Testing (3-4 hours)
- Pipeline integration
- Test suite
- Self-hosting verification

**Total Estimated Time: 21-27 hours**

---

## Conclusion

v0.2 Micro-Runa must be implemented using **canonical Runa syntax only**, as this is what v0.1 parses. The compiler will generate pure x86-64 assembly, eliminating all external library dependencies. By working within v0.1's capabilities and using proper canonical syntax, we achieve true self-hosting with zero external dependencies.

**Key to success: Use canonical syntax, keep it simple, test incrementally.**