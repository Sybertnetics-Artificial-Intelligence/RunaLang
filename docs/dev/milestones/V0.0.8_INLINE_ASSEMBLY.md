# Runa v0.0.8 Milestone: Inline Assembly Support

**Status:** ðŸ”„ Next Milestone
**Priority:** High

---

## ðŸŽ¯ Goal

Enable developers to embed raw assembly code within Runa programs, eliminating the need for external assembly files and preparing the compiler for native object file generation.

---

## ðŸ”‘ Key Objectives

1. âœ… Add inline assembly syntax to the language
2. âœ… Implement parser support for assembly blocks
3. âœ… Integrate assembly blocks into codegen
4. âœ… Test inline assembly with system calls and performance-critical code
5. âœ… Document inline assembly usage

---

## ðŸ“‹ Detailed Tasks

### Phase 1: Language Design (Week 1, Days 1-2)

#### 1.1 Syntax Specification
**Task:** Define the inline assembly syntax

**Proposed Syntax:**
```runa
Process called "example" returns Integer:
    Let result be 42

    Inline Assembly:
        # Raw x86-64 assembly goes here
        movq $60, %rax       # syscall: exit
        movq -8(%rbp), %rdi  # load result from stack
        syscall              # invoke system call
    End Assembly

    Return result  # Unreachable, but satisfies type system
End Process
```

**Design Decisions:**
- Keywords: `Inline Assembly:` ... `End Assembly`
- Indentation: Preserved as-is
- Comments: Support `#` for assembly comments
- Scope: Can access Runa variables via stack offsets

**Deliverable:** Syntax specification document

---

#### 1.2 AST Representation
**Task:** Design AST node for inline assembly

**Structure:**
```c
typedef struct Statement {
    StatementType type;  // STMT_INLINE_ASSEMBLY
    union {
        // ...
        struct {
            char **assembly_lines;     // Array of assembly strings
            int assembly_line_count;   // Number of lines
        } inline_assembly_stmt;
    } data;
} Statement;
```

**Deliverable:** Updated AST types in `parser.runa`

---

### Phase 2: Lexer Changes (Week 1, Days 3-4)

#### 2.1 New Keywords
**Task:** Add `Inline`, `Assembly` keywords to lexer

**File:** `src/lexer.runa`

**Changes:**
```runa
# Add new token types:
Let TOKEN_INLINE be 90
Let TOKEN_ASSEMBLY be 91

# Add keyword recognition:
Process called "identify_keyword" takes word as String returns Integer:
    # ... existing keywords ...

    Let inline_str be "Inline"
    If string_equals(word, inline_str) is equal to 1:
        Return TOKEN_INLINE
    End If

    Let assembly_str be "Assembly"
    If string_equals(word, assembly_str) is equal to 1:
        Return TOKEN_ASSEMBLY
    End If

    # ...
End Process
```

**Deliverable:** Updated lexer with new tokens

---

#### 2.2 Assembly Line Tokenization
**Task:** Special handling for assembly content

**Challenge:** Assembly syntax conflicts with Runa syntax
- Assembly uses `%`, `$`, `,` which aren't Runa tokens
- Need to capture raw text between `Inline Assembly:` and `End Assembly`

**Solution:**
```runa
Process called "lex_assembly_block" takes lexer as Integer returns Integer:
    # Switch to raw mode: capture lines verbatim
    # Stop at "End Assembly"
    # Return array of strings
End Process
```

**Deliverable:** Raw text capture mode in lexer

---

### Phase 3: Parser Changes (Week 1, Days 5-7)

#### 3.1 Parse Inline Assembly Statement
**Task:** Implement parsing for assembly blocks

**File:** `src/parser.runa`

**Pseudocode:**
```runa
Process called "parser_parse_inline_assembly" takes parser as Integer returns Integer:
    # Expect: "Inline Assembly:"
    parser_expect(parser, TOKEN_INLINE)
    parser_expect(parser, TOKEN_ASSEMBLY)
    parser_expect(parser, TOKEN_COLON)
    parser_expect(parser, TOKEN_NEWLINE)

    # Collect assembly lines until "End Assembly"
    Let lines be list_create()
    While current_token is not TOKEN_END or next_token is not TOKEN_ASSEMBLY:
        Let line be lexer_get_assembly_line(parser.lexer)
        list_append(lines, line)
    End While

    parser_expect(parser, TOKEN_END)
    parser_expect(parser, TOKEN_ASSEMBLY)

    # Create statement
    Let stmt be statement_create_inline_assembly(lines)
    Return stmt
End Process
```

**Deliverable:** Parser function for inline assembly

---

#### 3.2 Integration with Statement Parsing
**Task:** Add assembly statement to parser's statement switch

**File:** `src/parser.runa`

**Change:**
```runa
Process called "parser_parse_statement" takes parser as Integer returns Integer:
    # ... existing statement types ...

    If token_type is equal to TOKEN_INLINE:
        Return parser_parse_inline_assembly(parser)
    End If

    # ...
End Process
```

**Deliverable:** Integrated assembly parsing

---

### Phase 4: Codegen Changes (Week 2, Days 1-3)

#### 4.1 Emit Assembly Directly
**Task:** Add codegen support for inline assembly

**File:** `src/codegen.runa`

**Implementation:**
```runa
Process called "codegen_generate_statement" takes codegen as Integer, stmt as Integer returns Integer:
    # ... existing statement types ...

    If stmt_type is equal to 16:  # STMT_INLINE_ASSEMBLY
        # Get assembly lines
        Let assembly_line_count be memory_get_int32(stmt, 8)
        Let assembly_lines be memory_get_pointer(stmt, 16)

        # Emit each line directly to output file
        Let output_file be memory_get_pointer(codegen, 0)
        Let i be 0
        While i is less than assembly_line_count:
            Let line be memory_get_pointer(assembly_lines, i multiplied by 8)
            file_write_buffered(output_file, line, 0)
            file_write_buffered(output_file, "\n", 0)
            Set i to i plus 1
        End While

        Return 0
    End If

    # ...
End Process
```

**Deliverable:** Assembly emission in codegen

---

#### 4.2 Variable Access from Assembly
**Task:** Document stack frame layout for accessing Runa variables

**Documentation:**
```
Stack Frame Layout (x86-64 System V ABI):

%rbp points to saved RBP
%rbp - 8  â†’ Local variable 1
%rbp - 16 â†’ Local variable 2
%rbp - 24 â†’ Local variable 3
...

Example: Access variable 'result' (first local variable):
    movq -8(%rbp), %rax  # Load result into %rax
```

**Deliverable:** Stack layout documentation

---

### Phase 5: Testing (Week 2, Days 4-5)

#### 5.1 Basic Assembly Test
**File:** `tests/test_inline_asm_exit.runa`

```runa
Process called "main" returns Integer:
    Inline Assembly:
        mov $60, %rax    # exit syscall
        mov $42, %rdi    # exit code 42
        syscall
    End Assembly
    Return 0  # Unreachable
End Process
```

**Expected:** Program exits with code 42

---

#### 5.2 Variable Access Test
**File:** `tests/test_inline_asm_variable.runa`

```runa
Process called "main" returns Integer:
    Let exit_code be 7

    Inline Assembly:
        mov $60, %rax        # exit syscall
        movq -8(%rbp), %rdi  # load exit_code from stack
        syscall
    End Assembly

    Return 0  # Unreachable
End Process
```

**Expected:** Program exits with code 7

---

#### 5.3 System Call Test (write)
**File:** `tests/test_inline_asm_write.runa`

```runa
Process called "main" returns Integer:
    Inline Assembly:
        # Write "Hello\n" to stdout
        mov $1, %rax         # write syscall
        mov $1, %rdi         # fd = stdout
        lea message(%rip), %rsi  # buffer
        mov $6, %rdx         # length
        syscall

        # Exit
        mov $60, %rax
        xor %rdi, %rdi
        syscall

    .section .rodata
    message:
        .ascii "Hello\n"
    End Assembly

    Return 0
End Process
```

**Expected:** Prints "Hello" and exits

---

#### 5.4 Performance Test
**File:** `benchmarks/inline_asm_performance.runa`

**Goal:** Compare inline assembly vs Runa-generated code

```runa
# Standard Runa
Process called "add_runa" takes a as Integer, b as Integer returns Integer:
    Return a plus b
End Process

# Inline assembly version
Process called "add_asm" takes a as Integer, b as Integer returns Integer:
    Inline Assembly:
        movq -8(%rbp), %rax   # load a
        addq -16(%rbp), %rax  # add b
        # result already in %rax
    End Assembly
    Return 0  # Dummy return
End Process
```

**Measure:** Execution time of 1 million calls

---

### Phase 6: Documentation (Week 3, Days 1-3)

#### 6.1 User Guide
**File:** `runa/docs/user/inline-assembly.md`

**Contents:**
- What is inline assembly?
- When to use it (performance-critical code, system calls)
- When NOT to use it (portability concerns, complexity)
- Syntax reference
- Examples (exit, write, arithmetic)
- Stack frame layout
- Common pitfalls
- Safety warnings

**Deliverable:** Complete inline assembly guide

---

#### 6.2 x86-64 Reference
**File:** `runa/docs/user/x86-64-reference.md`

**Contents:**
- Register usage conventions
- System call table (Linux)
- Instruction reference (commonly used)
- ABI calling convention
- Stack alignment requirements

**Deliverable:** x86-64 quick reference

---

#### 6.3 Examples Collection
**Directory:** `examples/inline_assembly/`

**Examples:**
1. `hello_world.runa` - Print using write syscall
2. `exit_code.runa` - Exit with custom code
3. `fast_math.runa` - Optimized arithmetic
4. `simd_example.runa` - SIMD instructions
5. `syscall_wrapper.runa` - Wrapper for syscalls

**Deliverable:** Example programs

---

### Phase 7: Bootstrap Validation (Week 3, Days 4-5)

#### 7.1 Self-Compilation Test
**Task:** Ensure compiler still compiles itself

**Steps:**
1. Compile v0.0.7.5 with v0.0.8
2. Compile v0.0.8 with itself
3. Compare binaries (should be identical)

**Command:**
```bash
# Stage 1: v0.0.7.5 compiles v0.0.8
./v0.0.7.5/build/runac v0.0.8/src/*.runa -o v0.0.8/stage1/

# Stage 2: v0.0.8 compiles itself
./v0.0.8/stage1/runac v0.0.8/src/*.runa -o v0.0.8/stage2/

# Compare
diff v0.0.8/stage1/runac v0.0.8/stage2/runac
```

**Deliverable:** Bootstrap test passes

---

#### 7.2 Regression Testing
**Task:** Run all v0.0.7.5 tests with v0.0.8

**Command:**
```bash
cd runa/bootstrap/v0.0.8
./run_tests.sh
```

**Expected:** All tests pass

---

## ðŸ“¦ Deliverables

1. âœ… Updated lexer with `Inline`, `Assembly` tokens
2. âœ… Parser support for inline assembly blocks
3. âœ… Codegen emits assembly directly
4. âœ… 5+ test programs using inline assembly
5. âœ… User documentation (guide + reference)
6. âœ… Example programs
7. âœ… Bootstrap test passes
8. âœ… All regression tests pass

---

## ðŸŽ¯ Success Criteria

### Must Have:
- [ ] Inline assembly compiles correctly
- [ ] Can perform system calls (exit, write)
- [ ] Self-hosting compiler still works
- [ ] Documentation is complete
- [ ] No performance regression

### Nice to Have:
- [ ] SIMD instruction support
- [ ] Multiple assembly blocks in one function
- [ ] Syntax highlighting for assembly in IDE

### Stretch Goals:
- [ ] Assembly block validation (check for invalid instructions)
- [ ] Register allocation hints
- [ ] Inline assembly in expressions (not just statements)

---

## ðŸš§ Known Limitations (v0.0.8)

1. **No validation:** Compiler trusts assembly is correct
2. **x86-64 only:** ARM, RISC-V not supported yet
3. **Linux only:** Windows/macOS syscalls different
4. **Manual stack offsets:** Must calculate variable positions manually
5. **No register allocation:** User manages registers
6. **Limited interaction:** Can't easily return values from assembly to Runa

These will be addressed in future versions.

---

## ðŸ”— Related Documents

- [Development Roadmap](../DEVELOPMENT_ROADMAP.md)
- [Version Comparison](../VERSION_COMPARISON.md)
- [v0.0.9 Milestone](./V0.0.9_NATIVE_OBJECT_LINKER.md)

---

## ðŸ“… Timeline

| Week | Days | Tasks |
|------|------|-------|
| **Week 1** | Day 1-2 | Language design, AST structure |
| **Week 1** | Day 3-4 | Lexer changes |
| **Week 1** | Day 5-7 | Parser implementation |
| **Week 2** | Day 1-3 | Codegen implementation |
| **Week 2** | Day 4-5 | Testing (5 test programs) |
| **Week 3** | Day 1-3 | Documentation |
| **Week 3** | Day 4-5 | Bootstrap validation, regression tests |

**Total:** 19 days (~3 weeks)

---

## ðŸ‘¥ Team Notes

**Primary Developer:** TBD
**Reviewer:** TBD
**Documentation:** TBD

---

**Status:** Ready to Start
